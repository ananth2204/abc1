{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012445000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 4056234, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE609.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 4056234, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 4056234, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE609.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00?\\x05'", "DS1TRBAL": "b'\\x94\\x16'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04p\\x00\\x0e\\x04u\\x00\\x02\\x00@'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00\\x00\\x01\\x10\\x11?\\x01\\x10\\x11?\\x19\\x01\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-23T00:00:00", "modifydate": "2010-04-23T19:01:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  609\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE609\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 38,384 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/23/10    19:01:00    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ACTIVE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00%\\x01\\x026_\\x01\\x026_\\x12\\x16\\x00'\\x00'\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:16:25", "lines": 39, "newlines": 39, "modlines": 0, "user": "JMILLER"}, "text": "REXXSAMP - Sample Rexx function in assembler\n\nWhat it does:\n-----------------------------------------------\nThis assembler program (named ACTIVE) is invoked from the Rexx\ninterpretive environment, and is invoked the same way as a\nbuilt-in Rexx function.  This particular program is passed a 1-8\ncharacter string containing the name of an MVS job, and returns a\nboolean value of true if the job is running, or false if the job\nis not running.  (\"Job\" can be an STC, JOB or TSU.)\n\nHow to transfer file to the MVS host.\n-----------------------------------------------\n\n- Create a PDS on the MVS system, called userid.TEMP, or some\n  such name.  CYL(1,1,15) is big enough.\n  RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable DCB parameters.\n\n- Download the REXXSAMP.EXE self-extracting file to a PC.  Place\n  REXXSAMP.EXE in a directory by itself, and run it.  This will\n  result in all required members being extracted. (These won't be\n  readable on a PC  See note below)\n\n- FTP all the extracted files from the PC to the MVS PDS\n  allocated in the first step.  Use the FTP subcommand: \"BINARY\"\n  or equivalent to specify a binary transfer.  This is a must.\n  (These FTP'd files become members of the target PDS.)\n\n- Read the $$$$$DOC member in the PDS for further instructions.\n\n\nNOTE: The files that are in this self-extracting zip file are in\nEBCDIC format, so they will look like garbage on the PC, even\nafter being extracted.  They will however be normal, readable\nEBCDIC PDS members after they are extracted and transferred to an\nMVS host using Binary mode.\n\n\nJohn C. Miller\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x01\\x026_\\x01\\x03\\x00\\x8f#8\\x00\\x1e\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2003-01-08T23:38:54", "lines": 30, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT456.FILE609',\n//             OPRE=SBGOLOB,\n//             QUAL=FILE609,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=DATA04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=CBT.CBT455.FILE035.PDS\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=ACTIVE\n//S002 EXEC PDSLOAD,MEMB=RESCUE\n//S003 EXEC PDSLOAD,MEMB=RESCUE20\n//S004 EXEC PDSLOAD,MEMB=RFLD\n//S005 EXEC PDSLOAD,MEMB=RESCUNEW\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RESCUE": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x026_\\x01\\x026_\\x12\\x17\\x00\\xb5\\x00\\xb5\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:17:16", "lines": 181, "newlines": 181, "modlines": 0, "user": "JMILLER"}, "text": "1 -----------------------------------------------------------------\n             OS/390 Rescue System Generation Macros\n             Version 1.1\n             09/25/97\n  -----------------------------------------------------------------\n\n\n  John Miller\n  California State University, Office of the Chancellor\n  jcmiller@calstate.edu\n\n  PLEASE: Send me email on the inevitable bugs that you may find.\n\n\n\n\n1 -----------------------------------------------------------------\n                     I N T R O D U C T I O N\n  -----------------------------------------------------------------\n  This set of assembler macros is used to generate the JCL needed to\n  create a one volume self contained IPL'able OS/390 system.  Such a\n  system is invaluable for recovering from situations where the\n  production system cannot IPL.\n\n  Please note:  This documentation assumes that you have a decent\n  knowlege of MVS or OS/390; not a real hot-shot, but that you\n  basically know your way around.  This facility is NOT a \"Push\n  the button and out comes an IPL'able pack,\" but require that you check\n  and customize some things, and maybe take a few tries getting the\n  final product to IPL correctly.  It does however eliminate the vast\n  majority out of the guess-work and trial and error of building a one\n  pack system from scratch.\n\n  Documentation:\n\n  This member contains much of what you need to know about creating\n  a one pack OS/390 system.  Be sure to read the macro source for more\n  information on use of the various macros.\n\n  Here's how to use this facility:\n\n  1 - Check and/or Modify the XX prefixed members within the RESCUE PDS.\n      These are PARMLIB members that will be copied over to the rescue\n      system's SYS1.PARMLIB, VTAM parameters, and other stuff.\n      (See summary of members below)\n\n  2 - Build and submit the stage 1 JCL.  See sample member \"STAGE1.\"\n    - @JOBCARD macro coded;\n    - @DATASET macros coded as required;\n    - @COPY macros coded as required;\n    - @TSTVOL macro coded last.\n      (See @TSTVOL member for documentation on parms).\n\n  3 - Submit the JCL created by step 1.  Release each job in order,\n      and when the jobs have all finished with all steps return code 0,\n      you should have an IPL'able system.  (Or close to it).\n\n  4 - IPL and test the rescue system.  Vary all disk volumes offline\n      except for RESCUE just to be extra sure that you aren't\n      inadvertently pointing to some production piece of the OS on some\n      other volume.\n\n\n1 -----------------------------------------------------------------\n           S U M M A R Y    O F   M E M B E R S\n  -----------------------------------------------------------------\n  COMMAND  - Assembler source to the COMMAND command, which is\n  optionally used for issuing VARY commands, etc.  Uses RACF RACHECK\n  validation to prevent unauthorized issuance of MVS commands.\n  -----------------------------------------------------------------\n  STAGE1   - Sample stage 1 JCL and macros.   good starting point.\n  -----------------------------------------------------------------\n  STAGE2   - Example stage 2 output.  DON'T run this sample member;\n  you will want to generate your own, with your own modified Stage 1.\n  -----------------------------------------------------------------\n  WAIT     - Assembler source to the WAIT program, which is used\n  (optionally) in the stage 2 JCL to time some of the activities.\n  -----------------------------------------------------------------\n  XATCCON  - VTAM Major nodes to be started automatically;\n  -----------------------------------------------------------------\n  XATCSTR  - VTAM startup parameters;\n  -----------------------------------------------------------------\n  XCOMMND  - Commands issued at IPL;\n  -----------------------------------------------------------------\n  XXIEASYS - Main parmlib member - shouldn't need much if any chg.\n  -----------------------------------------------------------------\n  XXIEFSSN - Subsystems.\n  -----------------------------------------------------------------\n  XXIKJTSO - TSO Auth commands.\n  -----------------------------------------------------------------\n  XXJESPRM - JES2 parms.  You'll probably be best off replacing\n  this with a copy of your own JES2 parms, and changing the\n  CKPTDEF and SPOOLDEF statements to point to the RESCUE volume.\n  BE SURE YOU DO THIS!  Otherwise, when you IPL your rescue sys.,\n  and cold start JES2, you will wipe out your production JES spool.\n  This would be bad.  JES2 does tell you what volume is going to be\n  cold started, and gives you a chance to back out, so pay attention\n  when you do a cold start, and be sure JES2 is telling you that\n  RESCUE is the volume being cold started.\n  -----------------------------------------------------------------\n  XXLOAD   - Specifies the master catalog name, IODF file suffix,\n  nucleus suffix, and some other stuff.  See \"OS/390 Initialization\n  and Tuning\" for more information.\n                 +--------SYS1.IODFxx suffix.\n                 V\n        IODF     02 SYS1              01\n\n        NUCLEUS  1  <-----Nucleus suffix\n        SYSCAT   RESCUE113CCATALOG.RESCUE  <----Master catlg name\n\n  Be sure that you have a @DATASET macro specified for the IODF\n  file that you are using: SYS1.IODF02 would be the file for the\n  above LOADxx member.\n  -----------------------------------------------------------------\n  XXSMFPRM - SMF parms.  Should be OK, use your own if you wish.\n  -----------------------------------------------------------------\n  XXVATLST - Specified RESCUE as STRG, which will allow temp.\n  datasets such as ISPF temp files, etc. to be allocated.\n  -----------------------------------------------------------------\n\n1 -----------------------------------------------------------------\n           S U M M A R Y    O F   M A C R O S\n  -----------------------------------------------------------------\n  The following macros are used in building a rescue system:\n\n  - @JOBCARD - This macro reads in JCL job card statements that will be\n    used as a model in generating each of the system generation jobs.\n    The example JCL member \"STAGE1\" illustrates how to use this macro.\n\n  - @DATASET - This macro is used to define user or other data sets that\n    need to be recreated on the rescue system volume.  This macro is\n    called within the stage 1 input (typically for locally defined\n    datasets), and also called as an inner macro from within the @TSTVOL\n    macro (for \"vanilla\" system datasets).\n\n    The @DATASET macro accepts the following parameters:\n    - Units (CYL, TRK or block value)\n    - Primary allocation units.\n    - Secondary allocation units.\n    - Directory blocks (Must be 0 for non-pds)\n    - Method to use in copying the dataset:\n         C - IEBCOPY\n         G - IEBGENER\n         D - DFDSS\n         N - Don't copy, allocate only.\n    - Data set name\n    - Optional space subparameters such as CONTIG, RLSE, etc.\n    - Optional input volume for DFDSS INDYNAM parameter.\n    - Optional usage parameters.  This parameter is used to specify\n      additional processing for the dataset as follows:\n         LNK     - Add to LNKLST00 parmlib member.\n         LPA     - Add to LPALST00 parmlib member.\n         APF     - Add to IEAAPF00 parmlib member.\n         JES2    - JES2 PROCLIB to be added to JES2 startup PROC.\n         VTAMLST - Add to VTAM startup PROC VTAMLST concatenation.\n         VTAMLIB - Add to VTAM startup PROC VTAMLIB concatenation.\n         ISPPLIB - Add to ISPPLIB concatenation in TSO PROC.\n         ISPMLIB - Add to ISPMLIB concatenation in TSO PROC.\n         ISPSLIB - Add to ISPSLIB concatenation in TSO PROC.\n         ISPTLIB - Add to ISPTLIB concatenation in TSO PROC.\n         SYSPROC - Add to SYSPROC concatenation in TSO PROC.\n\n    The following macros would result in JCL being generated to perform\n    an IEBCOPY of dataset 'SYS5.LINKLIB', and have the library placed\n    in the APF list and Link list, and the RLSE parm coded in JCL:\n\n         @DATASET CYL,0095,0035,150,C,SYS5.LINKLIB,RLSE,,(LNK,APF)\n                        or\n         @DATASET 23400,0190,0070,150,C,SYS5.LINKLIB,RLSE,,(APF,LNK)\n\n  - @COPY - This macro specifies individual pds members that are to be\n    copied in order to set up the ipl'able system.  See the verbiage\n    within the macro itself in member @COPY for more detailed usage\n    information.\n\n  - @TSTVOL  - The main deal.  This macro performs the actual JCL\n    generation process.  See the documentation within the macro for a\n    description of the parameters that can be specified.  NOTE: The\n    @JOBCARD macro as well as all @COPY and @DATASET macros must come\n    BEFORE the @TSTVOL macro.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RESCU20": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x026_\\x01\\x026_\\x12\\x17\\x00\\xfe\\x00\\xfe\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:17:53", "lines": 254, "newlines": 254, "modlines": 0, "user": "JMILLER"}, "text": "---------------------------------------------------------------------\nRescue System Execs - V2.0\n---------------------------------------------------------------------\n03/28/2001\nJohn C. Miller\nhttp://www.jmit.com/\njohn@jmit.com\n---------------------------------------------------------------------\nNOTE: See the $$$QUIK member to get started with minimum verbiage.\n\nThe Long Version:\nThis set of Rexx execs is used to build a single-volume (3390-3), self\ncontained OS/390 rescue system.  These exec are a replacement for the\nolder rescue assembler macros for building a rescue system based on\nOS/390 version 1.3.  These exec are much better in my opinion. The\nexecs are smarter, and dynamically build lots of parmlib members,\nPROCs, etc.  This version was developed based on OS/390 version 2.10,\nand supports OMVS.  I've included TCP/IP libraries in this build.\n\nRead the $$$ members - They contain useful information, especially if\nyou are having problems.  See the $$$MAINT member for maintenance issues\nrelated to HFS and PDS-E support.  See the $$$RACF member for info on\nRACF authority that you'll need to run the jobs that build the RESCUE\nsystem.\n\nYou don't have to be an OS/390 guru to successfully use this set of\ntools to build an OS/390 rescue system.  You do however need to have a\nfairly solid grounding in OS/390 (MVS) in order to know what the various\njobs and piece parts do, and how to get past inevitable glitches.\nLiberal use of the IBM manuals will be of help.  (See the web site below\nfor some handy IBM web manuals)\n\nDISCLAIMER: You alone are responsible for any success that you have with\nthis software tool, as well as any damage done to your system, losses\nincurred, etc.\n\nI would greatly appreciate any bug reports, and will answer questions\nvia email, time permitting.\n\nGood Luck, and remember to RTFM (Read The Fine Manuals)\n\n---------------------------------------------------------------------\n            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:\n      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:\n---------------------------------------------------------------------\n* Look at the generated jobs *before* running them, especially JOBA,\n  the first job.  It is *incredibly* easy to wipe out an existing\n  PRODUCTION disk volume with JOBA if you are not careful.  JOBA\n  automatically varies a volume offline, and runs ICKDSF to\n  initialize it.  You will need to reply to an MVS console prompt\n  when JOBA runs. BEFORE replying to this message to continue, DOUBLE\n  CHECK the unit address in the message, and be sure it's the disk\n  pack that you want to wipe clean and use to build your rescue\n  system.  Most of the remaining jobs are not as dangerous, but you\n  should still review the JCL, and understand what each job is doing.\n  (This is good for the soul anyway!)\n\n* I'm making the significant assumption that you know what you're doing.\n\n  IN SHORT: If you don't know what a job is going to do, you have\n  absolutely no business running it !!!\n\n---------------------------------------------------------------------\n                       IMPORTANT NOTES:\n            READ THESE NOW TO AVOID FRUSTRATION LATER\n---------------------------------------------------------------------\n* The good news, now that I've scared you into being careful, is that\n  these execs can take some of the drudgery, tedium, and trial and error\n  out of the process of building an OS/390 system from scratch.\n\n* OS/390 is not a turnkey system, and these rescue execs are NOT, repeat\n  NOT completely automatic.  They are simply a tool that can be used to\n  greatly assist in building a single volume rescue system.  However:\n  the parameters as delivered are what I used to build a fully\n  functioning OS/390 rescue system, and so they may be pretty close to\n  what you need, or at least a good start!\n\n* So take some time to carefully review the @PARMS and @DATASET members.\n  Don't rush through this part.  Expect to do some tweaking, and expect\n  to have to do several system builds before you get a system that IPLs\n  and works as expected.\n\n  Once you get the @PARMS and @DATASET members set up the way you\n  like, it's very easy to generate a fresh set of jobs, and then run\n  the jobs to build a new system.  You'll may even learn something\n  about OS/390 by studying the generated jobs.\n\n* RACF Authorities:  See the $$$RACF member of this PDS for RACF\n  privileges that are required.\n\n* COMMAND and WAIT programs:  These programs enable the disk unit to be\n  varied online and offline by a batch job. If you want this capability\n  but don't have these programs on your system already, you can use the\n  source in the RESCUE PDS to assemble them.  Assemble these modules to\n  a linklisted APF authorized library.\n\n  The COMMAND program is one that I pulled of a CBT tape.  I added code\n  to do a RACHECK against the COMMAND profile in the APPL class looking\n  for at least READ access.  This prevents undesirable miscreants and\n  other unauthorized individuals from issuing MVS commands using this\n  program.\n\n  If you don't want to use the COMMAND and WAIT programs, code a null\n  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take\n  these parms out altogether.  The JCL generated will no longer use\n  these programs.\n\n---------------------------------------------------------------------\n                  Modifying the RESCUE execs:\n---------------------------------------------------------------------\nIf you want to tweak, hack, or otherwise modify these execs, by all\nmeans be my guest - but you're on your own.  I've tried to comment\nthe code sufficiently to give a saavy rexx coder the basic idea of\nwhat's going on. I try to avoid truly ugly, oblique, obscure, or\noverly terse ways of doing things in rexx when there's a simpler\nway, but I don't shy away from \"off the wall\" techniques when they\nwork best (or when I can't figure out a simpler way of doing a\ntask!)\n\nI've made the execs essentially modular, in that the main exec\nRESCUE calls external subroutines that are named starting with '#'.\nEach subroutine generally builds one job, or does one task.  To add\nsome new functionality of your own design, make a copy of one of the\nsubroutines like #initvol, for example, and make it do what you\nwant.\n\n---------------------------------------------------------------------\nHere's how to use these execs to build a one-pack rescue system:\n---------------------------------------------------------------------\n1)  Edit the ##PDS member, and change the 'pds=' parameter to the\n    name of the RESCUE PDS which contains this $$$DOC member as well\n    as the other RESCUE system parts.  I named the PDS\n    'SYS2.RESCUE.EXEC', but name it whatever works for you.  Just\n    remember to put that name in the ##PDS member.\n\n2)  Edit the @DATASET member to include all the datasets needed to\n    build a single volume OS/390 system.  The @DATASET members is\n    delivered with the list of datasets that I used to create a\n    OS/390 2.10 rescue system.  Your mileage may vary, and you\n    will need to be sure that all needed datasets are included.\n\n3)  Edit the @PARMS member with the values that you want.  The @PARMS\n    member is delivered with an example set of parms that were\n    actually used to successfully build a rescue system. You will want\n    to change some of the parameters.\n\n4a) Use the $BUILD job to run the rescue build execs under batch TSO.\n    Fix the jobcard and PDS name (SYSPROC DD stmt) first.\n\n4b) If desired you can place the PDS containing the rescue execs in your\n    SYSPROC concatenation, and from TSO READY enter: %RESCUE. You may\n    have to log off to let some of the jobs run, however, so this method\n    may be a pain at times.\n\n    Regardless of which option you choose, the necessary jobs and\n    members will now be built, and named sequentially JOBA..JOBn, where\n    n is howver many jobs end up getting generated.\n\n  *******************************************************************\n  *******************************************************************\n  *** NOTE: Up until this point, nothing has been been changed on ***\n  **  either the driving system or the new rescue system.  The     **\n  **  steps below this box will start tweaking and building.       **\n  **  If all goes as expected, the only changes made to the        **\n  **  driving system are:                                          **\n  **  a. The driving system mastercat will have an alias defined   **\n  **     pointing to the rescue system mastercat.                  **\n  **  b. RACF Profile TSORESC in TSOPROC class will be defined.    **\n  **  c. RACF ID $RESCUE and group $STC will be defined.           **\n  **                                                               **\n  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **\n  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **\n  **     (Did I mention that you should review each job            **\n  ***    before it is run?  Well, please do.)                     ***\n  *******************************************************************\n  *******************************************************************\n\n5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and\n    understanding the jobs *before* you run them would be, as they\n    say, \"a good thing.\"\n\n    Investigate any job steps that complete with return code 8 or\n    greater.\n\n  *******************************************************************\n  *******************************************************************\n  ***  If everything was defined right, you should now have an    ***\n  **   IPL'able OS/390 rescue system.  The steps below are some    **\n  **   areas to check before trying to IPL.  You don't have to     **\n  **   do these things now, but you'll probably save yourself      **\n  ***  some IPLs if you do check them first.                      ***\n  *******************************************************************\n  *******************************************************************\n\n6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and\n    also be sure that the necessary VTAMLST members are available on\n    your rescue system.  Use COPY statements in the @DATASET member to\n    specify members to copy.  You may want to code a special set of\n    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST\n    and VTAMLIB using COPY statements.\n\n7)  Review PARMLIB.  SYS1.RESCUE.PARMLIB is first in the PARMLIB concat,\n    followed by whatever other PARMLIBS are coded in @DATASET with the\n    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you\n    and copied to SYS1.RESCUE.PARMLIB as follows:\n\n    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)\n    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)\n    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with\n               the \"JES2\" attribute.\n    JES2PARM - JES2 parms. Member ZJES2PARM is combined with dynamically\n               built SPOOLDEF and CKPTDEF statements, and then copied to\n               the JES2PARM member in SYS1.RESCUE.PARMLIB.  Review\n               ZJES2PRM for any changes you want to make *before*\n               building the rescue jobs.  The SPOOLDEF and CKPTDEF are\n               already coded for you, but you may want to change some of\n               the other parameters, or replace the entire ZJES2PRM\n               member with your own JES2 parms.  If you do this, be sure\n               to remove the SPOOLDEF and CKPTDEF statements from the\n               source that you place in ZJES2PARM, since these two\n               statements are coded for you automatically.\n    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements\n               built dynamically.\n\n    NOTE: You'll need to be sure that one of the PARMLIB's that you're\n    copying to the RESCUE system has the remainder of the members needed\n    as coded in SYS1.RESCUE.PARMLIB(IEASYS00)'. Your production PARMLIB\n    dataset will probably work fine.\n\n8)  Review PROCLIB.  SYS1.RESCUE.PROCLIB is first in the PROCLIB\n    concat, followed by whatever other PROCLIBs are coded in\n    @DATASET with the \"JES2\" attribute: ,,(JES2).  Started procedures\n    (PROCS) are built for you and copied to SYS1.RESCUE.PROCLIB as\n    follows:\n    TSO      - TSO started PROC.\n    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and\n               VTAMLIB concatenation that you coded in @DATASET with the\n               'VTAMLST' and 'VTAMLIB' attribute respectively.\n    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00\n               concatenation that you coded in @DATASET with the 'JES2'\n               attribute.\n    TSORESC  - TSO LOGON PROC.  Includes libraries defined in @DATASET\n               with attributes:  ISPPLIB, ISPMLIB, ISPSLIB, ISPTLIB,\n               ISPLLIB, SYSPROC, SYSUADS.\n\n9)  Review IPLPARM.  SYS1.IPLPARM on the RESCUE volume has member LOAD00\n    built from the parameters you specified.  PARMLIB statements are\n    included for libraries in the @DATASET member coded with the\n    'PARMLIB' attribute.\n\n10) IPL the new rescue volume, and see what happens.  Hopefully\n    you'll be close to having a working system.  If it works the\n    first time--you rock!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE609": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00A\\x01\\x10\\x11?\\x01\\x10\\x11?\\x19\\x00\\x00%\\x00%\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-23T00:00:00", "modifydate": "2010-04-23T19:00:41", "lines": 37, "newlines": 37, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 609 is a set of packages from John Miller.  Two of them   *   FILE 609\n//*           allow you to set up a RESCUE system (i.e. a miniature *   FILE 609\n//*           IPLable system which allows you to fix another MVS    *   FILE 609\n//*           system).  One is older, and is in member RESCUE.  The *   FILE 609\n//*           other is for OS/390 2.10, and is in member RESCUE20.  *   FILE 609\n//*                                                                 *   FILE 609\n//*           A new, fixed version of RESCUE20 has been supplied    *   FILE 609\n//*           by Chris Buckley.  This version has various           *   FILE 609\n//*           improvements, as described in member $$DOC of the     *   FILE 609\n//*           (PDSLOAD-) unloaded pds which is member RESCUNEW in   *   FILE 609\n//*    >>>>>  this file.  RESCUNEW is to be regarded as the most    *   FILE 609\n//*    >>>>>  up-to-date version here, as per John Miller's         *   FILE 609\n//*           endorsement.  I have included all the versions,       *   FILE 609\n//*           because someone may need one, rather than another.    *   FILE 609\n//*                                                                 *   FILE 609\n//*           Chris Buckley's email:  chris_buckley@mandg.co.uk     *   FILE 609\n//*                                                                 *   FILE 609\n//*           Member ZCLONE30 was added for later systems (circa    *   FILE 609\n//*           z/OS 1.11 or thereabouts).  This member is a pds      *   FILE 609\n//*           in IEBUPDTE SYSIN format or PDSLOAD format.           *   FILE 609\n//*                                                                 *   FILE 609\n//*           These members are unloaded PDSes, in PDSLOAD format,  *   FILE 609\n//*           which preserves the ISPF statistics.  A job is        *   FILE 609\n//*           provided, called $PDSLOAD, to create the individual   *   FILE 609\n//*           unloaded PDSes.                                       *   FILE 609\n//*                                                                 *   FILE 609\n//*           A third package called RFLD, has now been moved to    *   FILE 609\n//*           CBT Tape File 827.  This is to help maintain the      *   FILE 609\n//*           RACF dataset.                                         *   FILE 609\n//*                                                                 *   FILE 609\n//*           A fourth package is called ACTIVE, and it is a REXX   *   FILE 609\n//*           function to return whether a certain JOB is running   *   FILE 609\n//*           currently on your MVS system.                         *   FILE 609\n//*                                                                 *   FILE 609\n//*           email:  john@jmit.com                                 *   FILE 609\n//*           phone:  714-563-1513                                  *   FILE 609\n//*                                                                 *   FILE 609\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACTIVE": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x026_\\x01\\x026_\\x12\\x15\\x01\\x16\\x01\\x16\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:15:00", "lines": 278, "newlines": 278, "modlines": 0, "user": "JMILLER"}, "text": "./ ADD NAME=$REXSAMP 0100-02365-02365-1212-00039-00039-00000-JMILLER\nREXXSAMP - Sample Rexx function in assembler\n\nWhat it does:\n-----------------------------------------------\nThis assembler program (named ACTIVE) is invoked from the Rexx\ninterpretive environment, and is invoked the same way as a\nbuilt-in Rexx function.  This particular program is passed a 1-8\ncharacter string containing the name of an MVS job, and returns a\nboolean value of true if the job is running, or false if the job\nis not running.  (\"Job\" can be an STC, JOB or TSU.)\n\nHow to transfer file to the MVS host.\n-----------------------------------------------\n\n- Create a PDS on the MVS system, called userid.TEMP, or some\n  such name.  CYL(1,1,15) is big enough.\n  RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable DCB parameters.\n\n- Download the REXXSAMP.EXE self-extracting file to a PC.  Place\n  REXXSAMP.EXE in a directory by itself, and run it.  This will\n  result in all required members being extracted. (These won't be\n  readable on a PC  See note below)\n\n- FTP all the extracted files from the PC to the MVS PDS\n  allocated in the first step.  Use the FTP subcommand: \"BINARY\"\n  or equivalent to specify a binary transfer.  This is a must.\n  (These FTP'd files become members of the target PDS.)\n\n- Read the $$$$$DOC member in the PDS for further instructions.\n\n\nNOTE: The files that are in this self-extracting zip file are in\nEBCDIC format, so they will look like garbage on the PC, even\nafter being extracted.  They will however be normal, readable\nEBCDIC PDS members after they are extracted and transferred to an\nMVS host using Binary mode.\n\n\nJohn C. Miller\n./ ADD NAME=ACTIVE   0100-02365-02365-1212-00237-00237-00000-JMILLER\n//EGTLJCMA JOB (0),JCMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M\n//ASSEMBLE  EXEC ASMHCL,\n//    REGION=2M,PARM.C='OBJECT,NODECK,RENT,REUS',\n//    PARM.L='RENT,REUS'\n//C.SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//            DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN       DD *\n         TITLE 'ACTIVE - Look for an active STC, JOB or TSU'\n*---------------------------------------------------------------------*\n* ACTIVE                                                              *\n*---------------------------------------------------------------------*\n* Note: This module is an example of how to code a rexx function      *\n* in assembler language.  Assemble and linkedit this source to a load *\n* library that is in LNKLST, LPALST, or other location that makes the *\n* module available to the TSO environment. (STEPLIB, etc.)            *\n* Then, invoke the program as you would a built-in rexx function. The *\n* 'active' program in this example would be invoked as follows:       *\n* /* rexx */                                                          *\n* IF active('SMTP') THEN SAY 'SMTP IS ACTIVE'                         *\n*                                                                     *\n* Your own rexx function can do anything that needs to be done from a *\n* non-APF authorized environment, and needs only to set the necessary *\n* EVDATA          - The actual data you want to return to your exec.  *\n* EVALBLOCK_EVLEN - Length of the data returned.                      *\n* R15 = 0 ===>    - Function processed normally.                      *\n* R15 = 8 ===>    - Function had an error--rexx exec will terminate.  *\n*---------------------------------------------------------------------*\n* Author:       John C. Miller                                        *\n* System:       General Rexx utility function.                        *\n* Purpose:      Rexx function to see if a specified JOB, STC or TSU   *\n*               is active on the system.                              *\n* Notes:        This module is called from the Rexx interpretive      *\n*               environment.                                          *\n* Registers:    Entry:                                                *\n*                  R0  - Points to Environment Control Block.         *\n*                  R1  - Points to Evaluation Block.                  *\n*               Exit:                                                 *\n*                  R0  - Points to Environment Control Block.         *\n*                  R1  - Points to External Routine Parameter List.   *\n*                  R15 - 0 means function processed normally.         *\n*                        8 means function had errors.  Rexx will give *\n*                        an error message and flush the rest of the   *\n*                        rexx exec.                                   *\n* Return Value: C'1' means JOB/STC/TSU was found.                     *\n*               C'0' means JOB/STC/TSU was not found.                 *\n* Invocation:                                                         *\n*     /* REXX */                                                      *\n*     IF active('SMTP') THEN SAY 'SMTP IS ACTIVE'                     *\n*---------------------------------------------------------------------*\n* 11/26/93 John Miller                                                *\n*----------------------------------------------------------------------\n         LCLC  &RETN               Set symbolic for subr. return reg.\n&RETN    SETC  'R14'\n*\nACTIVE   CSECT\n         SAVE  (14,12),,REXX-&SYSTIME-&SYSDATE-JCM\n         LR    R10,R15             Load base register.\n         USING ACTIVE,R10          Get addressability.\n         LR    R2,R1               Save ERPL pointer.\n         GETMAIN R,LV=WLENG        Get storage, and chain save areas.\n         ST    R13,4(R1)             \"\n         ST    R1,8(R13)             \"\n         LR    R13,R1                \"\n         USING WORKAREA,R13        Addressability to work area.\n         MVC   ARGPTR,16(R2)       Set up -> agrlist.\n         XC    RCODE,RCODE         Start with RC=0.\n*---------------------------------------------------------------------*\n*   SET UP EVAL BLOCK                                                 *\n*---------------------------------------------------------------------*\nEBSETUP  DS    0H\n         L     R9,20(R2)           Point to EVALB pointer.\n         L     R9,0(R9)            Point to EVALB.\n         USING EVALBLOCK,R9        Addressability to EVAL block.\n*---------------------------------------------------------------------*\n*   Main section.                                                     *\n*   Get jobname from function call: CL8                               *\n*---------------------------------------------------------------------*\nMAIN     DS    0H\n         MVC   JNAME,=CL8' '       Blank out parm storage.\n         LA    R12,JNAME           Point to where parm will go.\n         MVI   ARGLEN,8            Set max length of parm.\n         BAL   &RETN,GETPARM       Parse parameter from function call.\n         NC    RCODE,RCODE         If non-zero return code then -\n         BNZ   BADRC                 return.\n*---------------------------------------------------------------------*\n*   Now chain through ASCBs to see if ours is there.                  *\n*---------------------------------------------------------------------*\n         L     R1,16               -> CVT.\n         USING CVT,R1              Get addressability to CVT.\n         L     R1,CVTASVT          -> ASVT\n         USING ASVT,R1             Get addressability to ASVT.\n         L     R2,ASVTMAXU         Max. number of ASCB's.\n         LA    R3,ASVTENTY         -> First ASCB.\nASCBTOP  DS    0H\n         L     R1,0(R3)            Get ptr to this ASCB.\n         LTR   R1,R1               Live ASCB?\n         BM    NEXTASCB            No, Try next.\n         USING ASCB,R1             Addressability.\n         LM    R4,R5,ASCBJBNI      Get job names.\n         CLC   0(8,R4),JNAME       Jobname match initated jobname?\n         BE    TRUE                Yes, set TRUE result.\n         CLC   0(8,R5),JNAME       Johname match STC/Mount jobname?\n         BE    TRUE                Yes, set TRUE result.\nNEXTASCB DS    0H\n         LA    R3,4(R3)            -> next ASCB pointer.\n         BCT   R2,ASCBTOP          Look at next ASCB in chain.\n*---------------------------------------------------------------------*\n*   False - ASCB not found.                                           *\n*---------------------------------------------------------------------*\nFALSE    DS    0H\n         MVI   EVDATA,C'0'                Move data to return area.\n         MVC   EVALBLOCK_EVLEN,=F'1'      Set return value length.\n         B     EXIT                       Go clean up and exit.\n*---------------------------------------------------------------------*\n*   Specified job was found - Return 1 (TRUE)                         *\n*---------------------------------------------------------------------*\nTRUE     DS    0H\n         MVI   EVDATA,C'1'                Move data to return area.\n         MVC   EVALBLOCK_EVLEN,=F'1'      Set return value length.\n***********************************************************************\n*   RETURN SECTION                                                    *\n***********************************************************************\nEXIT     DS    0H\n         MVI   RCODE,0                    Set good return code.\nEXIT0    DS    0H\n         SR    R4,R4                      Clear register.\n         IC    R4,RCODE                   Save return code in reg.\n         LR    R1,R13                     Get work area address.\n         L     R13,4(R13)                 Restore caller's R13.\n         FREEMAIN R,A=(1),LV=WLENG        Free work area.\n         LR    R15,R4                     Load saved return code.\n         RETURN (14,12),RC=(15)           Return to caller with RC.\n*---------------------------------------------------------------------*\n*   Bad function call.                                                *\n*---------------------------------------------------------------------*\nBADRC    DS    0H\n         MVC   EVALBLOCK_EVLEN,=F'0'      Set zero length.\n         MVI   RCODE,8                    Set failure return code.\n         B     EXIT0                      Go clean up and exit.\n*---------------------------------------------------------------------*\n*   GETPARM                                                           *\n*---------------------------------------------------------------------*\n*   - Subroutine to copy data from the parsed argument list to a      *\n*     work variable.                                                  *\n*---------------------------------------------------------------------*\n*   R11 - Current ARGLIST pointer.                                    *\n*   R12 - Variable in which to store data.                            *\n*   ARGPTR - Current ARG pointer.                                     *\n*   ARGLEN - Maximum length of parm.                                  *\n*   ARGEVLEN - Actual length of parm.                                 *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         STM   R1,R14,REGS1        Save registers.\n         L     R11,ARGPTR          Point to current argument.\n         CLC   0(4,R11),=X'FFFFFFFF'  End of list?\n         BNE   ATOP                No, extract the argument.\n*--------RC 4 MEANS \"EOF\" ON PARMS------------------------------------*\nARGDONE  DS    0H\n         MVI   RCODE,4             Set return code.\n         B     ARGRETN             RETURN TO MAINLINE\n*--------RC 8 MEANS PARM EXCEEDED LENGTH SPECIFIED IN ARGLEN----------*\nARGBAD   DS    0H\n         MVI   RCODE,8             SET RETURN CODE\n         B     ARGRETN             RETURN TO MAINLINE\n*--------RC 0 MEANS PARM RETRIEVED AS REQUESTED-----------------------*\nATOP     DS    0H\n         MVI   RCODE,0             ZERO RETURN CODE\n         L     R6,0(R11)           LOAD PTR TO ARGUMENT DATA\n         L     R7,4(R11)           LOAD LENGTH\n         ST    R7,ARGEVLEN         SAVE PARAMETER LENGTH\n         XR    R8,R8               CLEAR REG\n         IC    R8,ARGLEN           GET MAX LENG\n         CR    R7,R8               IS LENGTH TO BIG?\n         BH    ARGBAD              YES, BETTER EXIT\n         BCTR  R7,0                -1 FOR EX\n         EX    R7,PMOVE            MOVE PARM TO OUTPUT\n         LA    R11,8(R11)          POINT TO NEXT PARAMTER ENTRY\n         ST    R11,ARGPTR          SAVE FOR NEXT TIME\nARGRETN  DS    0H\n         LM    R1,R14,REGS1        RESTORE REGS\n         BR    &RETN               GET NEXT PARAMETER\nPMOVE    MVC   0(0,R12),0(R6)      FOR EX\n***********************************************************************\n*   CONSTANTS                                                         *\n***********************************************************************\n         LTORG\n*---------------------------------------------------------------------*\n* Register equates                                                    *\n*---------------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n***********************************************************************\n*   WORKING STORAGE                                                   *\n***********************************************************************\nWORKAREA DSECT                     BEGINNING OF WORKAREA\nSAVEAREA DS    18F                 REGISTER SAVE AREA\nREGS1    DS    18F                 Subroutine reg save area.\n*-------------------VARIABLES USED BY GETVAR ROUTINE------------------*\nARGPTR   DS    F                   CURRENT ARGUMENT LIST POINTER\nARGEVLEN DS    F                   LENGTH RETURNED BY ARGUMENT PARSE\nARGLEN   DS    X                   CURRENT ARGUMENT MAXIMUM LENGTH\n*---------------------WORK VARIABLES----------------------------------*\nRCODE    DS    X                   RETURN CODE\n*---------------------WORK VARIABLES----------------------------------*\nJNAME    DS    CL8                 Julian Date\n*---------------------END OF DYNAMIC AREA-----------------------------*\n         DS    0D                  FILL OUT DSECT TO DOUBLEWORD\nWLENG    EQU   *-WORKAREA          END OF WORKAREA\n*---------------------------------------------------------------------*\n*   Mapping Macros.                                                   *\n*---------------------------------------------------------------------*\n         IRXEVALB\n         ORG   EVALBLOCK_EVDATA    REPOSITION TO REMAP EVDATA\nEVDATA   DS    CL8                 LOCAL EVDATA\nEBL      EQU   *-EVALBLOCK\n         CVT   DSECT=YES,LIST=YES\n         IHAASVT\n         IHAASCB\n***********************************************************************\n*   End of Module.                                                    *\n***********************************************************************\n         END\n//L.SYSLMOD DD  DISP=SHR,DSN=SYSOSG.CSULOAD(ACTIVE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESCUE": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x026_\\x01\\x026_\\x12\\x15\\x16G\\x16G\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:15:00", "lines": 5703, "newlines": 5703, "modlines": 0, "user": "JMILLER"}, "text": "./ ADD NAME=$$$$$DOC 0100-02365-02365-0941-00181-00181-00000-JMILLER\n1 -----------------------------------------------------------------\n             OS/390 Rescue System Generation Macros\n             Version 1.1\n             09/25/97\n  -----------------------------------------------------------------\n\n\n  John Miller\n  California State University, Office of the Chancellor\n  jcmiller@calstate.edu\n\n  PLEASE: Send me email on the inevitable bugs that you may find.\n\n\n\n\n1 -----------------------------------------------------------------\n                     I N T R O D U C T I O N\n  -----------------------------------------------------------------\n  This set of assembler macros is used to generate the JCL needed to\n  create a one volume self contained IPL'able OS/390 system.  Such a\n  system is invaluable for recovering from situations where the\n  production system cannot IPL.\n\n  Please note:  This documentation assumes that you have a decent\n  knowlege of MVS or OS/390; not a real hot-shot, but that you\n  basically know your way around.  This facility is NOT a \"Push\n  the button and out comes an IPL'able pack,\" but require that you check\n  and customize some things, and maybe take a few tries getting the\n  final product to IPL correctly.  It does however eliminate the vast\n  majority out of the guess-work and trial and error of building a one\n  pack system from scratch.\n\n  Documentation:\n\n  This member contains much of what you need to know about creating\n  a one pack OS/390 system.  Be sure to read the macro source for more\n  information on use of the various macros.\n\n  Here's how to use this facility:\n\n  1 - Check and/or Modify the XX prefixed members within the RESCUE PDS.\n      These are PARMLIB members that will be copied over to the rescue\n      system's SYS1.PARMLIB, VTAM parameters, and other stuff.\n      (See summary of members below)\n\n  2 - Build and submit the stage 1 JCL.  See sample member \"STAGE1.\"\n    - @JOBCARD macro coded;\n    - @DATASET macros coded as required;\n    - @COPY macros coded as required;\n    - @TSTVOL macro coded last.\n      (See @TSTVOL member for documentation on parms).\n\n  3 - Submit the JCL created by step 1.  Release each job in order,\n      and when the jobs have all finished with all steps return code 0,\n      you should have an IPL'able system.  (Or close to it).\n\n  4 - IPL and test the rescue system.  Vary all disk volumes offline\n      except for RESCUE just to be extra sure that you aren't\n      inadvertently pointing to some production piece of the OS on some\n      other volume.\n\n\n1 -----------------------------------------------------------------\n           S U M M A R Y    O F   M E M B E R S\n  -----------------------------------------------------------------\n  COMMAND  - Assembler source to the COMMAND command, which is\n  optionally used for issuing VARY commands, etc.  Uses RACF RACHECK\n  validation to prevent unauthorized issuance of MVS commands.\n  -----------------------------------------------------------------\n  STAGE1   - Sample stage 1 JCL and macros.   good starting point.\n  -----------------------------------------------------------------\n  STAGE2   - Example stage 2 output.  DON'T run this sample member;\n  you will want to generate your own, with your own modified Stage 1.\n  -----------------------------------------------------------------\n  WAIT     - Assembler source to the WAIT program, which is used\n  (optionally) in the stage 2 JCL to time some of the activities.\n  -----------------------------------------------------------------\n  XATCCON  - VTAM Major nodes to be started automatically;\n  -----------------------------------------------------------------\n  XATCSTR  - VTAM startup parameters;\n  -----------------------------------------------------------------\n  XCOMMND  - Commands issued at IPL;\n  -----------------------------------------------------------------\n  XXIEASYS - Main parmlib member - shouldn't need much if any chg.\n  -----------------------------------------------------------------\n  XXIEFSSN - Subsystems.\n  -----------------------------------------------------------------\n  XXIKJTSO - TSO Auth commands.\n  -----------------------------------------------------------------\n  XXJESPRM - JES2 parms.  You'll probably be best off replacing\n  this with a copy of your own JES2 parms, and changing the\n  CKPTDEF and SPOOLDEF statements to point to the RESCUE volume.\n  BE SURE YOU DO THIS!  Otherwise, when you IPL your rescue sys.,\n  and cold start JES2, you will wipe out your production JES spool.\n  This would be bad.  JES2 does tell you what volume is going to be\n  cold started, and gives you a chance to back out, so pay attention\n  when you do a cold start, and be sure JES2 is telling you that\n  RESCUE is the volume being cold started.\n  -----------------------------------------------------------------\n  XXLOAD   - Specifies the master catalog name, IODF file suffix,\n  nucleus suffix, and some other stuff.  See \"OS/390 Initialization\n  and Tuning\" for more information.\n                 +--------SYS1.IODFxx suffix.\n                 V\n        IODF     02 SYS1              01\n\n        NUCLEUS  1  <-----Nucleus suffix\n        SYSCAT   RESCUE113CCATALOG.RESCUE  <----Master catlg name\n\n  Be sure that you have a @DATASET macro specified for the IODF\n  file that you are using: SYS1.IODF02 would be the file for the\n  above LOADxx member.\n  -----------------------------------------------------------------\n  XXSMFPRM - SMF parms.  Should be OK, use your own if you wish.\n  -----------------------------------------------------------------\n  XXVATLST - Specified RESCUE as STRG, which will allow temp.\n  datasets such as ISPF temp files, etc. to be allocated.\n  -----------------------------------------------------------------\n\n1 -----------------------------------------------------------------\n           S U M M A R Y    O F   M A C R O S\n  -----------------------------------------------------------------\n  The following macros are used in building a rescue system:\n\n  - @JOBCARD - This macro reads in JCL job card statements that will be\n    used as a model in generating each of the system generation jobs.\n    The example JCL member \"STAGE1\" illustrates how to use this macro.\n\n  - @DATASET - This macro is used to define user or other data sets that\n    need to be recreated on the rescue system volume.  This macro is\n    called within the stage 1 input (typically for locally defined\n    datasets), and also called as an inner macro from within the @TSTVOL\n    macro (for \"vanilla\" system datasets).\n\n    The @DATASET macro accepts the following parameters:\n    - Units (CYL, TRK or block value)\n    - Primary allocation units.\n    - Secondary allocation units.\n    - Directory blocks (Must be 0 for non-pds)\n    - Method to use in copying the dataset:\n         C - IEBCOPY\n         G - IEBGENER\n         D - DFDSS\n         N - Don't copy, allocate only.\n    - Data set name\n    - Optional space subparameters such as CONTIG, RLSE, etc.\n    - Optional input volume for DFDSS INDYNAM parameter.\n    - Optional usage parameters.  This parameter is used to specify\n      additional processing for the dataset as follows:\n         LNK     - Add to LNKLST00 parmlib member.\n         LPA     - Add to LPALST00 parmlib member.\n         APF     - Add to IEAAPF00 parmlib member.\n         JES2    - JES2 PROCLIB to be added to JES2 startup PROC.\n         VTAMLST - Add to VTAM startup PROC VTAMLST concatenation.\n         VTAMLIB - Add to VTAM startup PROC VTAMLIB concatenation.\n         ISPPLIB - Add to ISPPLIB concatenation in TSO PROC.\n         ISPMLIB - Add to ISPMLIB concatenation in TSO PROC.\n         ISPSLIB - Add to ISPSLIB concatenation in TSO PROC.\n         ISPTLIB - Add to ISPTLIB concatenation in TSO PROC.\n         SYSPROC - Add to SYSPROC concatenation in TSO PROC.\n\n    The following macros would result in JCL being generated to perform\n    an IEBCOPY of dataset 'SYS5.LINKLIB', and have the library placed\n    in the APF list and Link list, and the RLSE parm coded in JCL:\n\n         @DATASET CYL,0095,0035,150,C,SYS5.LINKLIB,RLSE,,(LNK,APF)\n                        or\n         @DATASET 23400,0190,0070,150,C,SYS5.LINKLIB,RLSE,,(APF,LNK)\n\n  - @COPY - This macro specifies individual pds members that are to be\n    copied in order to set up the ipl'able system.  See the verbiage\n    within the macro itself in member @COPY for more detailed usage\n    information.\n\n  - @TSTVOL  - The main deal.  This macro performs the actual JCL\n    generation process.  See the documentation within the macro for a\n    description of the parameters that can be specified.  NOTE: The\n    @JOBCARD macro as well as all @COPY and @DATASET macros must come\n    BEFORE the @TSTVOL macro.\n\n./ ADD NAME=$$$$BUGS 0100-02365-02365-0941-00006-00006-00000-JMILLER\nKnown bugs/irritants/shortcomings/desirable features:\n\n1 - SMS subsystem is not set up on target volume;\n\n2 - Open MVS is not supported.  I just haven't gotten around to\n    it yet.  I plan to have both OMVS and SMS support soon.\n./ ADD NAME=$$README 0100-02365-02365-0941-00028-00028-00000-JMILLER\nOS/390 Rescue System - How to transfer to MVS host:\n---------------------------------------------------\n\n- Create a PDS on the MVS system.  CYL(1,1,15) should be big enough.\n  RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable DCB parameters.\n\n- Download the RESCUE.EXE self-extracting file to a PC.  Place\n  RESCUE.EXE in a directory by itself, and run it.  This will\n  result in all required members being extracted. (These won't be\n  readable on a PC  See note below)\n\n- FTP all the extracted files from the PC to the MVS PDS\n  allocated in the first step.  Use the FTP subcommand: \"BINARY\"\n  or equivalent to specify a binary transfer.  This is a must.\n  (These FTP'd files become members of the target PDS.)\n\n- Read the $$$$$DOC member in the PDS for further instructions.\n\n\nNOTE: The files that are in this self-extracting zip file are in\nEBCDIC format, so they will look like garbage on the PC, even\nafter being extracted.  They will however be normal, readable\nEBCDIC PDS members after they are extracted and transferred to an\nMVS host using Binary mode.\n\n\nJohn C. Miller\njmit@mindspring.com\n./ ADD NAME=@@@@FND  0100-02365-02365-0941-00032-00032-00000-JMILLER\n          MACRO\n          @@@@FND\n.*====================================================================*\n.*    @@USE Inner Macro.                                              *\n.*--------------------------------------------------------------------*\n.*    09/07/97 John Miller                                            *\n.*--------------------------------------------------------------------*\n.*    Find a string in another string.                                *\n.*--------------------------------------------------------------------*\n.*    Change Log:                                                     *\n.*       09/07/97 JCM Initial version.                                *\n.*--------------------------------------------------------------------*\n         GBLB &TMPFND\n         LCLC &NEEDLE,&HAYSTAC\n         LCLA &X,&NLEN,&HLEN\n&NEEDLE  SETC '&SYSLIST(1)'\n&HAYSTAC SETC '&SYSLIST(2)'\n&HLEN    SETA K'&HAYSTAC\n&NLEN    SETA K'&NEEDLE\n&X       SETA 0\n.*\n.FINDTOP ANOP\n&X       SETA (&X+1)\n         AIF  ((&X+&NLEN-1) GT &HLEN).NOTFOUN\n         AIF  ('&HAYSTAC'(&X,&NLEN) EQ '&NEEDLE').FOUND\n         AGO  .FINDTOP\n.FOUND   ANOP\n&TMPFND  SETB 1\n         MEXIT\n.NOTFOUN ANOP\n&TMPFND  SETB 0\n         MEND\n./ ADD NAME=@@FINDDS 0100-02365-02365-0941-00033-00033-00000-JMILLER\n          MACRO\n          @@FINDDS\n.*====================================================================*\n.*    @@FINDDS Inner Macro.                                           *\n.*--------------------------------------------------------------------*\n.*    09/07/97 John Miller                                            *\n.*--------------------------------------------------------------------*\n.*    Build the TMPDS(x) array with datasets that have a USE value    *\n.*    that includes the string specified by TYPE (parm one of this    *\n.*    macro).                                                         *\n.*--------------------------------------------------------------------*\n.*    Change Log:                                                     *\n.*       09/07/97 JCM Initial version.                                *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n         LCLA &X1,&X2\n         LCLC &TYPE\n&TYPE    SETC '&SYSLIST(1)'\n&TMPCTR  SETA 0\n&X1      SETA 0\n&X2      SETA 0\n.*\n.TOP     ANOP\n&X1      SETA    (&X1+1)\n         AIF     (&X1 GT &CTR).DONE\n         @@@@FND &TYPE,&USE(&X1)\n         AIF     (NOT &TMPFND).TOP\n&TMPCTR  SETA    (&TMPCTR+1)\n&TMPDS(&TMPCTR)  SETC '&DSN(&X1)'\n MNOTE 'DSN: &DSN(&X1) &TMPDS(&TMPCTR)'\n         AGO     .TOP\n.DONE    ANOP\n         MEND\n./ ADD NAME=@@GLOBAL 0100-02365-02365-0941-00034-00034-00000-JMILLER\n.*-----------------------------------------------------------------*\n.*    GLOBAL VARIABLES                                             *\n.*-----------------------------------------------------------------*\n         GBLA   &CTR,&CTRB\n         GBLC   &DS2(750)\n         GBLC   &JCRD(11)\n         GBLC   &SRCL(200),&TGTL(200)\n         GBLC   &MEMB(200),&NMEM(200)\n         GBLC   &BLANK\n&BLANK   SETC   '                                                    '\n.*\n.* Data stored by @DATASET macro invocations\n.*\n         GBLC   &SPA(750)\n         GBLC   &PRI(750)\n         GBLC   &SEC(750)\n         GBLC   &DIR(750)\n         GBLC   &CPY(750)\n         GBLC   &DSN(750)\n         GBLC   &SPR(750)\n         GBLC   &VOL(750)\n         GBLC   &USE(750)\n.*\n         GBLA   &TMPCTR\n         GBLB   &TMPFND\n         GBLC   &TMPDS(750)\n.*\n         GBLB   &LNK(750)\n         GBLB   &LPA(750)\n         GBLB   &APF(750)\n         GBLB   &JES2(750)\n         GBLB   &VLIB(750)\n         GBLB   &VLST(750)\n         GBLB   &BLNK,&BLPA,&BAPF,&BJES2,&BVLIB,&BVLST\n./ ADD NAME=@@PARMLB 0100-02365-02365-0941-00160-00160-00000-JMILLER\n          MACRO\n          @@PARMLB &JOBCHAR=,&DEVT=,&VOLUME=\n.*====================================================================*\n.*    @@PARMLB Inner macro.                                           *\n.*--------------------------------------------------------------------*\n.*    09/07/97 John Miller                                            *\n.*--------------------------------------------------------------------*\n.*    Build JCL to create PARMLIB members:                            *\n.*    - LNKLST                                                        *\n.*    - LPALST                                                        *\n.*    - IEAAPF                                                        *\n.*--------------------------------------------------------------------*\n.*    Change Log:                                                     *\n.*       09/07/97 JCM Initial version.                                *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n         LCLB &DOJF\n&DOJF    SETB (&BLNK OR &BLPA OR &BAPF OR &BJES2 OR &BVLIB OR &BVLST)\n         AIF (NOT &DOJF).NOJOB\n         @JOBCARD SUFFIX=&JOBCHAR\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - &JOBCHAR   &SYSTIME &SYSDATE        '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n  MNOTE 'BLNK IS: &BLNK'\n       AIF (NOT &BLNK).FNOLNK1\n PUNCH '//* LNKLST   \u00a6  Dynamically build LNKLSTxx PARMLIB member.   '\n.FNOLNK1 ANOP\n       AIF (NOT &BLPA).FNOLPA1\n PUNCH '//* LPALST   \u00a6  Dynamically build LPALSTxx PARMLIB member.   '\n.FNOLPA1 ANOP\n       AIF (NOT &BAPF).FNOAPF1\n PUNCH '//* IEAAPF   \u00a6  Dynamically build IEAAPFxx PARMLIB member.   '\n.FNOAPF1 ANOP\n PUNCH '//*---------------------------------------------------------*'\n.*--------------------------------------------------------------------*\n.*    Punch JCL steps.                                                *\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*    LNKLSTxx                                                        *\n.*--------------------------------------------------------------------*\n         LCLA &X1,&X2\n         LCLC &TMPDSN(750),&TMP1\n         AIF (NOT &BLNK).FNOLNK2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build LNKLSTxx member.                                  *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LNKLST  EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                         '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(LNKLST00),         '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD *                                            '\n.*---\n&X1      SETA 0\n&X2      SETA 0\n.LNKTOP1 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &CTR).LNKDON1\n         AIF  (NOT &LNK(&X1)).LNKTOP1\n&X2      SETA (&X2+1)\n&TMPDSN(&X2) SETC '&DSN(&X1)'                                        '\n         AGO .LNKTOP1\n.LNKDON1 ANOP\n.*---\n&X1      SETA 0\n.LNKTOP2 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 EQ &X2).LNKDON2\n PUNCH '&TMPDSN(&X1),'\n         AGO .LNKTOP2\n.LNKDON2 ANOP\n&TMP1    SETC '&TMPDSN(&X1)&BLANK'(1,45)\n PUNCH '&TMP1  '\n PUNCH '//*         '\n.*-*-*-*-*-*-*\n.*-*-*-*-*-*-*\n.FNOLNK2 ANOP\n       AIF (NOT &BLPA).FNOLPA2\n.*--------------------------------------------------------------------*\n.*    LPALSTxx                                                        *\n.*--------------------------------------------------------------------*\n         AIF (NOT &BLPA).FNOLPA2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build LPALSTxx member.                                  *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LPALST  EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                         '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(LPALST00),         '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD *                                            '\n.*---\n&X1      SETA 0\n&X2      SETA 0\n.LPATOP1 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &CTR).LPADON1\n         AIF  (NOT &LPA(&X1)).LPATOP1\n&X2      SETA (&X2+1)\n&TMPDSN(&X2) SETC '&DSN(&X1)'                                        '\n         AGO .LPATOP1\n.LPADON1 ANOP\n.*---\n&X1      SETA 0\n.LPATOP2 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 EQ &X2).LPADON2\n&TMP1    SETC '&TMPDSN(&X1),&BLANK'(1,45)\n PUNCH '&TMP1  '\n         AGO .LPATOP2\n.LPADON2 ANOP\n PUNCH '&TMPDSN(&X1)  '\n PUNCH '//*         '\n.*-*-*-*-*-*-*\n.*-*-*-*-*-*-*\n.FNOLPA2 ANOP\n       AIF (NOT &BAPF).FNOAPF2\n.*--------------------------------------------------------------------*\n.*    IEAAPFxx                                                        *\n.*--------------------------------------------------------------------*\n         AIF (NOT &BLPA).FNOLPA2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build IEAAPFxx member.                                  *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LPALST  EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                         '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(IEAAPF00),         '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD *                                            '\n.*---\n&X1      SETA 0\n&X2      SETA 0\n.APFTOP1 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &CTR).APFDON1\n         AIF  (NOT &APF(&X1)).APFTOP1\n&X2      SETA (&X2+1)\n&TMPDSN(&X2) SETC '&DSN(&X1)&BLANK'\n         AGO .APFTOP1\n.APFDON1 ANOP\n.*---\n&X1      SETA 0\n.APFTOP2 ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 EQ &X2).APFDON2\n&TMP1    SETC '&TMPDSN(&X1)&BLANK'(1,35).'&VOLUME,'\n PUNCH '&TMP1  '\n         AGO .APFTOP2\n.APFDON2 ANOP\n&TMP1    SETC '&TMPDSN(&X1)&BLANK'(1,35).'&VOLUME'\n PUNCH '&TMP1  '\n PUNCH '//*    '\n.*-*-*-*-*-*-*\n.*-*-*-*-*-*-*\n.FNOAPF2 ANOP\n.NOJOB   ANOP\n         MEND\n./ ADD NAME=@@PROCLB 0100-02365-02365-0941-00196-00196-00000-JMILLER\n          MACRO\n          @@PROCLB &DEVT=,&VOLUME=,&TSOPROC=\n.*====================================================================*\n.*    @@PARMLB Inner macro.                                           *\n.*--------------------------------------------------------------------*\n.*    09/07/97 John Miller                                            *\n.*--------------------------------------------------------------------*\n.*    Build JCL to create PROCLIB members:                            *\n.*    - JES2                                                          *\n.*    - VTAM                                                          *\n.*    - TSO PROC                                                      *\n.*    - Other PROCs.                                                  *\n.*--------------------------------------------------------------------*\n.*    Change Log:                                                     *\n.*       09/07/97 JCM Initial version.                                *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n         AIF (NOT &BJES2).NOJES2\n         LCLC &TMPDSN(750)\n.*--------------------------------------------------------------------*\n.*    Build JES2 startup PROC.                                        *\n.*--------------------------------------------------------------------*\n         AIF (NOT &BJES2).FNOJES2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build JES2 startup PROC.                                *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//JESPROC EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                         '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(JES2),             '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD DATA,DLM=''@#''                              '\n PUNCH '//JES2      PROC M=00                                       '\n PUNCH '//*======================================================*  '\n PUNCH '//* JES2 STARTUP PROC - RESCUE SYSTEM                    *  '\n PUNCH '//*======================================================*  '\n PUNCH '//IEFPROC  EXEC PGM=HASJES20,DPRTY=(15,15),TIME=1440        '\n PUNCH '//HASPPARM DD  DSN=SYS1.PARMLIB(JESPRM&&M),DISP=SHR         '\n PUNCH '//HASPLIST DD  DDNAME=IEFRDER                               '\n.*---\n&X1      SETA 1\n         @@FINDDS JES2\n         MNOTE 'JES2 TMPCTR: &TMPCTR '\n         AIF  (&TMPCTR LT 1).JSDONE1\n PUNCH '//PROC00   DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.JSTOP1  ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).JSDONE1\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .JSTOP1\n.JSDONE1 ANOP\n PUNCH '@#                                                          '\n.FNOJES2 ANOP\n.*-*-*-*-*-*-*\n.*-*-*-*-*-*-*\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*    VTAM PROC                                                       *\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build VTAM startup PROC.                                *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LPALST  EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                        '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(VTAM),             '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD DATA,DLM=''@#''                              '\n PUNCH '//VTAM     PROC                                             '\n PUNCH '//*======================================================*  '\n PUNCH '//* VTAM STARTUP PROC - RESCUE SYSTEM                    *  '\n PUNCH '//*======================================================*  '\n PUNCH '//VTAM     EXEC PGM=ISTINM01,REGION=6500K,                  '\n PUNCH '//         DPRTY=(15,15),TIME=1440,PERFORM=8                '\n PUNCH '//SISTCLIB DD DISP=SHR,DSN=SYS1.SISTCLIB                    '\n PUNCH '//SYSABEND DD SYSOUT=*,HOLD=YES                             '\n.*---\n.*---\n&X1      SETA 1\n         @@FINDDS VTAMLST\n         AIF  (&TMPCTR LT 1).VLDONE1\n PUNCH '//VTAMLST  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.VLTOP1  ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).VLDONE1\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .VLTOP1\n.VLDONE1 ANOP\n&X1      SETA 1\n         @@FINDDS VTAMLIB\n         AIF  (&TMPCTR LT 1).VIDONE1\n PUNCH '//VTAMLIB  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.VITOP1  ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).VIDONE1\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .VITOP1\n.VIDONE1 ANOP\n PUNCH '@#                                                        '\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*    Build TSO LOGON PROC                                            *\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* Build a TSO LOGON PROC.                                 *'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//TSOPROC EXEC PGM=IEBGENER,REGION=2M                        '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                      '\n PUNCH '//SYSIN     DD DUMMY                                         '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(&TSOPROC),         '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME                      '\n PUNCH '//SYSUT1    DD DATA,DLM=''@#''                              '\n PUNCH '//&TSOPROC  PROC                                            '\n PUNCH '//*======================================================*  '\n PUNCH '//* TSO LOGON PROC - Rescue System.                      *  '\n PUNCH '//* &SYSTIME &SYSDATE                                    *  '\n PUNCH '//*======================================================*  '\n PUNCH '//&TSOPROC EXEC PGM=IKJEFT01,DYNAMNBR=256,PARM=ISPALLOC     '\n PUNCH '//SYSPRINT DD TERM=TS,SYSOUT=*                              '\n PUNCH '//SYSTERM  DD TERM=TS,SYSOUT=*                              '\n PUNCH '//SYSIN    DD TERM=TS                                       '\n PUNCH '//SYSPROC  DD DISP=SHR,DSN=SYS3.CLIST                       '\n PUNCH '//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP                        '\n PUNCH '//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST                    '\n PUNCH '//* Dynamically build statements below                      '\n.*\n.****SYSPROC DATASETS*****\n.*\n&X1      SETA 1\n         @@FINDDS SYSPROC\n         AIF  (&TMPCTR LT 1).T0DONE\n PUNCH '//SYSPROC  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.T0TOP   ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).T0DONE\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .T0TOP\n.T0DONE  ANOP\n.*\n.*\n.****ISPPLIB DATASETS*****\n.*\n&X1      SETA 1\n         @@FINDDS ISPPLIB\n         AIF  (&TMPCTR LT 1).T1DONE\n PUNCH '//ISPPLIB  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.T1TOP   ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).T1DONE\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .T1TOP\n.T1DONE  ANOP\n.*\n.****ISPMLIB DATASETS*****\n.*\n&X1      SETA 1\n         @@FINDDS ISPMLIB\n         AIF  (&TMPCTR LT 1).T2DONE\n PUNCH '//ISPMLIB  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.T2TOP   ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).T2DONE\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .T2TOP\n.T2DONE  ANOP\n.*\n.****ISPSLIB DATASETS*****\n.*\n&X1      SETA 1\n         @@FINDDS ISPSLIB\n         AIF  (&TMPCTR LT 1).T3DONE\n PUNCH '//ISPSLIB  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.T3TOP   ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).T3DONE\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .T3TOP\n.T3DONE  ANOP\n.*\n.****ISPTLIB DATASETS*****\n.*\n&X1      SETA 1\n         @@FINDDS ISPTLIB\n         AIF  (&TMPCTR LT 1).T4DONE\n PUNCH '//ISPTLIB  DD  DISP=SHR,DSN=&TMPDS(1)                    '\n.T4TOP   ANOP\n&X1      SETA (&X1+1)\n         AIF  (&X1 GT &TMPCTR).T4DONE\n PUNCH '//         DD  DISP=SHR,DSN=&TMPDS(&X1)                  '\n         AGO  .T4TOP\n.T4DONE  ANOP\n.****\n PUNCH '@#                                                          '\n         MEND\n./ ADD NAME=@COPY    0100-02365-02365-0941-00076-00076-00000-JMILLER\n         MACRO\n         @COPY &SRCLIB=,                                               X\n               &TGTLIB=,                                               X\n               &MEMBER=,                                               X\n               &NEWMEM=\n.*--------------------------------------------------------------------*\n.*    @COPY    MACRO                                                  *\n.*--------------------------------------------------------------------*\n.*    THIS MACRO SPECIFIES INDIVIDUAL PDS MEMBERS THAT ARE TO BE      *\n.*    COPIED IN ORDER TO SET UP THE IPL'ABLE SYSTEM.                  *\n.*--------------------------------------------------------------------*\n.*    PARAMETERS:                                                     *\n.*    - SRCLIB=  < THE PDS THAT CONTAINS THE MEMBER(S) TO BE COPIED   *\n.*    - TGTLIB=  < THE PDS ON THE TEST SYSTEM THAT WILL CONTAIN THE   *\n.*               < MEMBER.                                            *\n.*    - MEMBER=  < THE NAME OF THE MEMBER TO BE COPIED.               *\n.*    - NEWMEM=  < THE NEW NAME THAT THE MEMBER WILL HAVE WHEN COPIED.*\n.*--------------------------------------------------------------------*\n.*    NOTES:                                                          *\n.*    - THE FIRST INVOCATION OF THIS MACRO MUST SPECIFY THE SRCLIB=   *\n.*      AND TGTLIB= PARAMETERS.  THIS IS SO ANY MACRO PROCESSING THE  *\n.*      ARRAY OF COPY MEMBERS WILL KNOW AT A SINGLE PASS WHAT THE     *\n.*      SOURCE AND TARGET LIBRARIES ARE.                              *\n.*    - ONCE SRCLIB= OR TGTLIB= IS SPECIFIED, THE VALUE REMAINS UNITL *\n.*      IT IS CHANGED BY A SUBSEQUENT SRCLIB= OR TGTLIB=              *\n.*--------------------------------------------------------------------*\n.*      09/07/97 JOHN MILLER                                          *\n.*--------------------------------------------------------------------*\n         GBLA &CTRB\n         GBLC &SRCL(200),&TGTL(200),&MEMB(200),&NMEM(200)\n         GBLC &DEFSRC,&DEFTGT\n         LCLA &X,&Y\n         LCLC &MEMPRM\n         AIF (&CTRB GT 0).NOTFRST         FIRST TIME THROUGH, BOTH\n         AIF ('&SRCLIB' EQ '').ERR001     TGTLIB AND SRCLIB MUST BE\n         AIF ('&TGTLIB' EQ '').ERR001     CODED.\n.NOTFRST ANOP                             *************************\n&CTRB    SETA (&CTRB+1)\n         AIF (&CTRB GT 200).ERR002\n.***\n.* COPY PASSED PARAMETERS\n.***\n         AIF ('&SRCLIB' EQ '').NOSRC\n&DEFSRC  SETC '&SRCLIB'\n&SRCL(&CTRB) SETC '&SRCLIB'\n.NOSRC   ANOP\n.*\n         AIF ('&TGTLIB' EQ '').NOTGT\n&DEFTGT  SETC '&TGTLIB'\n&TGTL(&CTRB) SETC '&TGTLIB'\n.NOTGT   ANOP\n.*\n.***\n.* IF NO MEMBER SPECIFIED, DON'T CREATE A MEMBER ENTRY IN THE ARRAY\n.***\n         AIF ('&MEMBER' EQ '').NOMEM\n&MEMB(&CTRB) SETC '&MEMBER'\n         AIF ('&NEWMEM' EQ '').DONE\n&NMEM(&CTRB) SETC '&NEWMEM'\n.DONE    ANOP\n&MEMPRM  SETC '&MEMB(&CTRB)'\n         AIF ('&NMEM(&CTRB)' EQ '').NONEW\n&MEMPRM  SETC '&MEMPRM,&NMEM(&CTRB)'\n.NONEW   ANOP\n.* MNOTE 0,'  SELECT MEMBER=((&MEMPRM,R)) '\n.NOMEM   ANOP\n           MEXIT\n.*--------------------------------------------------------------------*\n.*    ERRORS                                                          *\n.*--------------------------------------------------------------------*\n.ERR001  MNOTE 8,'FIRST INVOCATION OF @COPY MUST SPECIFY BOTH SRCLIB'\n         MNOTE 8,'AND TGTLIB.'\n         MEXIT\n.ERR002  MNOTE 8,'MAXIMUM COPY DEFINITIONS EXCEEDED.'\n         MEXIT\n         MEND\n./ ADD NAME=@DATASET 0100-02365-02365-0941-00160-00160-00000-JMILLER\n         MACRO\n         @DATASET\n.*--------------------------------------------------------------------*\n.*    @DATASET MACRO                                                  *\n.*--------------------------------------------------------------------*\n.* 09/02/97 John Miller                                               *\n.* Rescue volume generation facility.                                 *\n.*--------------------------------------------------------------------*\n.* The @DATASET macro specifies a data set that is to be copied or    *\n.* allocated in some manner to the target rescue system volume.       *\n.*--------------------------------------------------------------------*\n.*   Parameters for the @dataset macro are as follows:                *\n.*   1 - CYL, TRK or BLOCK value to be used for allocation            *\n.*   2 - Primary allocation quantity                                  *\n.*   3 - Secondary allocation quantity                                *\n.*   4 - Directory blocks (for PDS, specify 0 for sequential)         *\n.*   5 - Copy Mode:                                                   *\n.*       C - IEBCOPY                                                  *\n.*       G - IEBGENER/ICEGENER                                        *\n.*       D - DFDSS - Note: DFDSS performs the DS allocation           *\n.*       N - Don't copy (Allocate only)                               *\n.*   6 - Dataset name                                                 *\n.*   7 - Options for space subparameter (Optional) (RLSE, CONTIG)     *\n.*   8 - Input volume for DFDSS INDYNAM(volser) parameter.            *\n.*   9 - Additional processing options for dataset:                   *\n.*       LNK     - Add to LNKLSTxx.                                   *\n.*       LPA     - Add to LPALSTxx.                                   *\n.*       APF     - Add to IEAAPFxx.                                   *\n.*       JES2    - JES2 PROCLIB to be added to JES2 startup PROC.     *\n.*       VTAMLST - Add to VTAM startup PROC VTAMLST concatenation.    *\n.*       VTAMLIB - Add to VTAM startup PROC VTAMLIB concatenation.    *\n.*       ISPPLIB - Add ISPPLIB concatenation of TSO PROC.             *\n.*       ISPMLIB - Add ISPMLIB concatenation of TSO PROC.             *\n.*       ISPSLIB - Add ISPSLIB concatenation of TSO PROC.             *\n.*       ISPTLIB - Add ISPTLIB concatenation of TSO PROC.             *\n.*       SYSPROC - Add SYSPROC concatenation of TSO PROC.             *\n.*--------------------------------------------------------------------*\n.* CHANGE LOG:                                                        *\n.*--------------------------------------------------------------------*\n.* 01/24/91 John Miller - Initial version (MVS 3.1.3)                 *\n.* 09/15/97 John Miller - OS/390 version.                             *\n.*--------------------------------------------------------------------*\n.*\n.*--------------------------------------------------------------------*\n.*    Copy Global variable definitions.                               *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n.*\n         LCLA &X,&Y\n         LCLC &COPY\n&CTR     SETA (&CTR+1)\n         AIF (&CTR GT 750).ERR008\n         AIF ('&SYSLIST(1)' EQ '').ERR001\n         AIF ('&SYSLIST(2)' EQ '').ERR002\n         AIF ('&SYSLIST(3)' EQ '').ERR003\n         AIF ('&SYSLIST(4)' EQ '').ERR004\n         AIF ('&SYSLIST(5)' EQ '').ERR005\n         AIF ('&SYSLIST(6)' EQ '').ERR006\n.*\n.*   @DATASET CYL,0002,0001,050,C,SYS2.LINKLIB,RLSE\n.*\n&SPA(&CTR) SETC '&SYSLIST(1)'\n&PRI(&CTR) SETC '&SYSLIST(2)'\n&SEC(&CTR) SETC '&SYSLIST(3)'\n&DIR(&CTR) SETC '&SYSLIST(4)'\n&CPY(&CTR) SETC '&SYSLIST(5)'\n&DSN(&CTR) SETC '&SYSLIST(6)'\n&SPR(&CTR) SETC '&SYSLIST(7)'\n&VOL(&CTR) SETC '&SYSLIST(8)'\n&USE(&CTR) SETC '&SYSLIST(9)'\n.****----\n.* Parse parameter #9\n.****----\n           LCLA &USEX,&USEY\n&USEX      SETA 0\n&USEY      SETA N'&SYSLIST(9)\n.USETOP1   ANOP\n&USEX      SETA (&USEX+1)\n           AIF  (&USEX GT &USEY).USEDONE\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'LNK').USENX1\n&LNK(&CTR) SETB 1\n&BLNK      SETB 1\n.USENX1    ANOP\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'LPA').USENX2\n&LPA(&CTR) SETB 1\n&BLPA      SETB 1\n.USENX2    ANOP\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'APF').USENX3\n&APF(&CTR) SETB 1\n&BAPF      SETB 1\n.USENX3    ANOP\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'JES2').USENX4\n&JES2(&CTR) SETB 1\n&BJES2     SETB 1\n.USENX4    ANOP\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'VTAMLIB').USENX5\n&VLIB(&CTR) SETB 1\n&BVLIB     SETB 1\n.USENX5    ANOP\n.*\n           AIF  ('&SYSLIST(9,&USEX)' NE 'VTAMLST').USENX6\n&VLST(&CTR) SETB 1\n&BVLST     SETB 1\n.USENX6    ANOP\n           AGO .USETOP1\n.*\n.USEDONE   ANOP\n.****----\n           AIF  ('&SPR(&CTR)' EQ '').NOSPR\n&SPR(&CTR) SETC ',&SPR(&CTR)'\n.NOSPR     ANOP\n&X         SETA  K'&DSN(&CTR)\n&Y         SETA  &X\n.MTOP      ANOP\n&X         SETA  &X-1\n           AIF (&X LT 1).ERR007\n           AIF ('&DSN(&CTR)  '(&X,1) EQ '.').SETDS2\n           AGO .MTOP\n.SETDS2    ANOP\n&DS2(&CTR) SETC '&DSN(&CTR)'(&X+1,&Y-&X)\n           MEXIT\n.*--------------------------------------------------------------------*\n.*    ERRORS                                                          *\n.*--------------------------------------------------------------------*\n.ERR001  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'NONE WERE SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR002  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'1 WAS SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR003  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'2 WERE SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR004  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'3 WERE SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR005  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'4 WERE SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR006  MNOTE 8,'INVALID MACRO REQUEST.  6 PARAMETERS ARE REQUIRED,'\n         MNOTE 8,'5 WERE SUPPLIED.  REQUIRED IS:'\n         MNOTE 8,'UNITS,PRIMARY,SECONDARY,DIR,Y/N,DSNAME'\n         MEXIT\n.ERR007  MNOTE 8,'SINGLE LEVEL DATA SETS ARE NOT SUPPORTED.'\n         MNOTE 8,'SPECIFIED DATASET &DSN(&CTR) HAS ONLY 1 QUALIFIER.'\n         MEXIT\n.ERR008  MNOTE 8,'MAXIMUM DATASET DEFINITIONS EXCEEDED -'\n         MNOTE 8,'INCREASE VALUE OF GLOBAL PARAMETER INDEXES.'\n         MEXIT\n         MEND\n./ ADD NAME=@JOBCARD 0100-02365-02365-0941-00081-00081-00000-JMILLER\n         MACRO\n         @JOBCARD &SUFFIX=\n.*--------------------------------------------------------------------*\n.*    @JOBCARD MACRO                                                  *\n.*    THIS MACRO IDS DUAL PURPOSE:                                    *\n.*    1 - THIS MACRO READS THE JCL STATEMENTS FOLLOWING IT IN SOURCE  *\n.*        AND STORES THEM IN CASM VARIABLES FOR USE BY @TSTVOL MACRO. *\n.*    2 - PUNCHES A JOBCARD.  THIS OPTION IS SELECTED BY SPECIFYING   *\n.*        A SINGLE CHARACTER FOR THE \"SUFFIX=\" KEYWORD.               *\n.*--------------------------------------------------------------------*\n.*    04/17/91 JOHN MILLER                                            *\n.*--------------------------------------------------------------------*\n.*\n.*--------------------------------------------------------------------*\n.*    Copy Global variable definitions.                               *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n.*\n         LCLA &X,&Y,&Z\n         LCLC &CARD,&B\n         LCLC &JC1A,&JC1B\n         AIF ('&SUFFIX' NE '').PUNCH\n&B       SETC '&B                                        '\n&B       SETC '&B                                        '\n&CARD    AREAD\n         AIF ('&CARD'(1,2) NE '//').ERR002\n.TFIND   ANOP\n&Y       SETA &Y+1\n         AIF (&Y GT 10).ERR003\n         AIF ('&CARD'(&Y,1) NE ' ').TFIND\n&JC1A    SETC '&CARD'(1,&Y-1)\n&JC1B    SETC '&CARD&B'(&Y,72-&Y-1)\n         AIF (K'&JC1A LT 10).J1OK\n&JC1A    SETC '&JC1A'(1,9)\n.J1OK    ANOP\n&JCRD(1) SETC '&JC1A'\n&JCRD(2) SETC '&JC1B'\n.*       MNOTE 0,'&JCRD(1).&JCRD(2)'\n&X       SETA 2\n.JOBTOP  ANOP\n&X       SETA &X+1\n         AIF (&X GT 11).ERR001\n&CARD    AREAD\n         AIF ('&CARD'(1,2) NE '//').DONE\n         AIF ('&CARD'(1,2) EQ '/*').DONE\n.*       MNOTE 0,'&CARD'\n&JCRD(&X) SETC '&CARD'\n         AGO .JOBTOP\n.DONE    ANOP\n         MEXIT\n.*--------------------------------------------------------------------*\n.*    THIS SECTION PUNCHES OUT THE SAVED JOBCARD WITH THE SUPPLIED    *\n.*    JOB NAME SUFFIX                                                 *\n.*--------------------------------------------------------------------*\n.PUNCH   ANOP\n         LCLC &SUF\n&SUF     SETC '&SUFFIX'(1,1)\n&X       SETA 2\n PUNCH '&JCRD(1).&SUF.&JCRD(2)'\n.PTOP    ANOP\n&X       SETA &X+1\n         AIF (&X GT 11).PUNDONE\n         AIF ('&JCRD(&X)' EQ '').PUNDONE\n PUNCH '&JCRD(&X)'\n         AGO  .PTOP\n.PUNDONE ANOP\n         MEXIT\n.*--------------------------------------------------------------------*\n.*    ERRORS                                                          *\n.*--------------------------------------------------------------------*\n.ERR001  MNOTE 8,'MORE THAN 10 JOB STATEMENTS WERE SPECIFIED - '\n         MNOTE 8,'RE-RUN THE ASSEMBLY WITH 10 OR FEWER JOB STATEMENTS.'\n         MEXIT\n.ERR002  MNOTE 8,'FIRST JOB STATEMENT DID NOT BEGIN WITH //'\n         MNOTE 8,'RE-RUN THE ASSEMBLY WITH A VALID JOBCARD FOLLOWING '\n         MNOTE 8,'THIS MACRO.'\n         MEXIT\n.ERR003  MNOTE 8,'INVALID JOBNAME - FIRST JOB STATEMENT MUST CONTAIN'\n         MNOTE 8,'// IMMEDIATELY FOLLOWED BY A 1 TO 8 CHAR JOBNAME'\n         MEXIT\n         MEND\n./ ADD NAME=@TSTVOL  0100-02365-02365-0941-01224-01224-00000-JMILLER\n          MACRO\n          @TSTVOL &CATALOG=CATALOG.RESCUE,                             X\n               &CATFIND=Y,                                             X\n               &CATPTR=N,                                              X\n               &COMMAND=Y,                                             X\n               &DCBREF=Y,                                              X\n               &DEALLOC=DEALLOC,                                       X\n               &DEVT=3380,                                             X\n               &DUMP=Y,                                                X\n               &JOBS=ABCDEFG,                                          X\n               &LIST=Y,                                                X\n               &MASTRCAT=,                                             X\n               &MCATVOL=CSUCAT,                                        X\n               &OWNER=SYS900,                                          X\n               &PGCOMM=150,                                            X\n               &PGLCL1=150,                                            X\n               &PGPLPA=150,                                            X\n               &RACF=Y,                                                X\n               &RACFDS=SYS1.RACFP1,                                    X\n               &RFCOPY=Y,                                              X\n               &STEPCAT=,                                              X\n               &SYSRES=SYSRS1,                                         X\n               &SYSX=SYSX,                                             X\n               &SYS1=SYS1,                                             X\n               &TAPEUNT=CART,                                          X\n               &TMSPRM=EXPDT=98000,                                    X\n               &TSOPASS=XXXXXXXX,                                      X\n               &TSOPROC=MINIMUM,                                       X\n               &SECS=5,                                                X\n               &UADS=Y,                                                X\n               &UNITADR=000,                                           X\n               &USR1=IBMUSER,                                          X\n               &USR2=,                                                 X\n               &USR3=,                                                 X\n               &USR4=,                                                 X\n               &USR5=,                                                 X\n               &USYNC=Y,                                               X\n               &VFY=,                                                  X\n               &VOLUME=RESCUE,                                         X\n               &WRKPFX=SYS9.RESCUE,                                    X\n               &WRKUNIT=SYSALLDA,                                      X\n               &WRKVOL=,                                               X\n               &WAIT=Y\n.*====================================================================*\n.*    @TSTVOL MACRO for OS/390 Version 1.1                            *\n.*--------------------------------------------------------------------*\n.*    09/25/97 John Miller                                            *\n.*--------------------------------------------------------------------*\n.*    This macro is the heart of a facility that generates the JCL    *\n.*    to create a one-pack IPL'able OS/390 system for emergency and   *\n.*    maintenance purposes.  Each installation will most likely want  *\n.*    to customize the default values, dataset specifications and     *\n.*    dataset names to be compatible with their installation.         *\n.*--------------------------------------------------------------------*\n.*    This facility is very similar to the SYSGEN or IPOGEN processes *\n.*    for those of you who have been in MVS long enough to remember   *\n.*    them! It is a 2 stage process:                                  *\n.*                                                                    *\n.*    Stage 1:                                                        *\n.*    A set of assembler macros are coded in the STAGE1 source. These *\n.*    macros describe the datasets and other information needed to    *\n.*    fully describe the new system being built.  The output of this  *\n.*    assembler \"stage 1\" job is a large set of JCL called Stage 2.   *\n.*                                                                    *\n.*    Stage 2:                                                        *\n.*    This is a large deck of JCL produced by Stage 1.  The JCL       *\n.*    consists of several jobs which are run in sequence, and which   *\n.*    build the IPLable system \"from scratch,\" starting with an empty *\n.*    disk volume, and ending with a fully self-contained, one volume *\n.*    OS/390 system.                                                  *\n.*--------------------------------------------------------------------*\n.*    This macro (@TSTVOL) must be invoked last.  The @JOBCARD and    *\n.*    and any required @DATASET and @COPY macros must be coded before *\n.*    this one.                                                       *\n.*                                                                    *\n.*    See the @JOBCARD, @DATASET and @COPY macros for more info. on   *\n.*    their use.                                                      *\n.*--------------------------------------------------------------------*\n.*    Change Log:                                                     *\n.*    09/25/97 John Miller                                            *\n.*    Reworked from 1992 MVS 3.1.3. version.                          *\n.*--------------------------------------------------------------------*\n.*    Inner macros:                                                   *\n.*                  @JOBCARD                                          *\n.*                  @DATASET                                          *\n.*                  @COPY                                             *\n.*                  @@FINDDS                                          *\n.*                  @@@@FND                                           *\n.*--------------------------------------------------------------------*\n.*    Parameters:                                                     *\n.*--------------------------------------------------------------------*\n.*    CATALOG=      < Name of the target Master Cat. to be built.     *\n.*    CATFIND=      < Y/N Find dsns via catalog vs. from SYSRES vol.  *\n.*    CATPTR=       < Y/N IEBDG run to create catalog pointer.        *\n.*                  < Specify \"N\" if using LOADxx parmlib member.     *\n.*    COMMAND=      < Y/N Command program (SVC34) is available.       *\n.*    DCBREF=       < Y/N To code DCB=(DSN) on output DD statements.  *\n.*    DEALLOC=      < Name of dummy STC to deallocate DASD UCBs.      *\n.*    DEVT=         < Device type of the target volume.               *\n.*    DUMP=         < DUMP THE PACK WHEN DONE       (Y/N)             *\n.*    JOBS=         < Which jobs to generate (Default to all jobs)    *\n.*                  < JOBS=ABCDEFG results in all jobs being run.     *\n.*    LIST=Y        < Y/N Set assembler PRINT option on.              *\n.*    MASTRCAT=     < Driver system master catalog name.              *\n.*    MCATVOL=      < Volume containing driver system master cat.     *\n.*    OWNER=        < Goes in OWNER field of catalog entries.         *\n.*    PGCOMM=       < # Cyls for COMMON page dataset.                 *\n.*    PGLCL1=       < # Cyls for LOCAL page dataset.                  *\n.*    PGPLPA=       < # Cyls for PLPA page dataset.                   *\n.*    RACF=         < Y/N Do RACF ds initialization, etc.             *\n.*    RACFDS=       < Fully qualified name for target RACF dataset.   *\n.*                  < NOTE: If RFCOPY=Y, then RACFDS= must specify    *\n.*                  < the name of the production RACF dataset to be   *\n.*                  < copied.                                         *\n.*    RFCOPY=       < Y/N Copy productn RACF dataset. See above note. *\n.*    SECS=         < Seconds to wait (Parm to the WAIT program).     *\n.*    STEPCAT=      < Catalog used to find dsns to be copied (opt.)   *\n.*    SYSRES=       < Driver system SYSRES volume.                    *\n.*    SYSX=         < Temporary high level qualifier.                 *\n.*    SYS1=         < Alternate \"SYS1\" high level qualifier.          *\n.*    TAPEUNT=      < Tape unit generic or esoteric                   *\n.*    TMSPRM=       < Tms parm to be added to tape DD for vol. backup *\n.*    TSOPASS=      < TSO UADS password                               *\n.*    TSOPROC=      < TSO PROC to be built and defined to UADS        *\n.*    UADS=         < Perform UADS processing (Y/N)                   *\n.*    UNITADR=000,  < Unit address of the rescue target volume        *\n.*    USR1=         < TSO users to be supported.  An ISPF profile     *\n.*    USR2=         < data set is created for each user specified.    *\n.*    USR3=         < In addition, if \"UADS=Y\" is coded, each         *\n.*    USR4=         < user is defined in UADS with the PROC and       *\n.*    USR5=         < password specified in TSOPROC= and TSOPASS=     *\n.*                  < respectively.  This is generally required if    *\n.*                  < RACF=NO is coded, as TSO LOGON is then UADS     *\n.*                  < only.                                           *\n.*    USYNC=        < Perform UADS to BRODCAST SYNC                   *\n.*    VFY=          < Old VOLSER to be verified before clipping       *\n.*    VOLUME=       < Volid to be given to the target rescue system.  *\n.*    WAIT=         < Y/N Wait program is available.                  *\n.*====================================================================*\n         PUSH   PRINT\n         PRINT  ON\n         AIF    ('&LIST'     EQ  'Y').LISTYES\n         PRINT  OFF\n.LISTYES ANOP\n.*--------------------------------------------------------------------*\n.*    Copy Global variable definitions.                               *\n.*--------------------------------------------------------------------*\n         COPY @@GLOBAL\n.*\n.*--------------------------------------------------------------------*\n.*    LOCAL VARIABLES                                                 *\n.*--------------------------------------------------------------------*\n         LCLA &W,&X,&Y,&Z\n         LCLC &DDNAME,&DDN,&XCTR\n.*--------------------------------------------------------------------*\n.*    CHECK TO BE SURE THE @JOBCARD MACRO HAS BEEN INVOKED            *\n.*--------------------------------------------------------------------*\n         AIF ('&JCRD(1)' EQ '').ERR001\n.*--------------------------------------------------------------------*\n.*    Parse the JOBS= parameter and set flags for which jobs to build.*\n.*--------------------------------------------------------------------*\n         LCLA &Q1,&Q2\n         LCLC &C1\n         LCLB &DOJOBA,&DOJOBB,&DOJOBC,&DOJOBD,&DOJOBE,&DOJOBF,&DOJOBG\n&DOJOBA  SETB 0\n&DOJOBB  SETB 0\n&DOJOBC  SETB 0\n&DOJOBD  SETB 0\n&DOJOBE  SETB 0\n&DOJOBF  SETB 0\n&DOJOBG  SETB 0\n&Q1      SETA 0\n.TOPJOB1 ANOP\n&Q1      SETA (&Q1+1)\n         AIF (&Q1 GT K'&JOBS).DONJOB1\n         AIF ('&JOBS'(&Q1,1) NE 'A').NOJA1\n&DOJOBA  SETB 1\n.NOJA1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'B').NOJB1\n&DOJOBB  SETB 1\n.NOJB1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'C').NOJC1\n&DOJOBC  SETB 1\n.NOJC1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'D').NOJD1\n&DOJOBD  SETB 1\n.NOJD1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'E').NOJE1\n&DOJOBE  SETB 1\n.NOJE1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'F').NOJF1\n&DOJOBF  SETB 1\n.NOJF1   ANOP\n         AIF ('&JOBS'(&Q1,1) NE 'G').NOJG1\n&DOJOBG  SETB 1\n.NOJG1   ANOP\n         AGO .TOPJOB1\n.DONJOB1 ANOP\n         AIF ('&JCRD(1)' EQ '').ERR001\n.*====================================================================*\n.*--------------------------------------------------------------------*\n.*    DEFINE NONVSAM SYSTEM DATASETS TO BE COPIED                     *\n.*--------------------------------------------------------------------*\n.* - SUPPORT FOR ADDITIONAL DATASETS CAN BE ACCOMPLISHED BE SIMPLY    *\n.*   ADDING ADDITIONAL @DATASET MACRO ENTRIES AS NEEDED.              *\n.* - TO REMOVE SUPPORT FOR A LIBRARY DELETE OR COMMENT OUT THE ENTRY. *\n.*--------------------------------------------------------------------*\n.* << THE VALUES SHOWN ARE IN 3380 CYLINDERS >>                       *\n.*--------------------------------------------------------------------*\n.*====================================================================*\n.*\n.*\n.*--------------------------------------------------------------------*\n.*       MVS DATASETS                                                 *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0005,000,150,C,&SYS1..CMDLIB,,,(LNK)\n     @DATASET CYL,0001,000,000,G,&SYS1..DAE\n     @DATASET CYL,0008,001,150,C,&SYS1..HELP\n     @DATASET CYL,0002,000,150,C,&SYS1..IMAGELIB\n     @DATASET CYL,0005,001,150,C,&SYS1..CSSLIB,RLSE,,(LNK)\n     @DATASET CYL,0200,000,650,C,&SYS1..LINKLIB,RLSE,,(APF,LNK)\n     @DATASET CYL,0010,001,025,C,&SYS1..V1R3M0.SHASLINK,,,(LNK,APF)\n     @DATASET CYL,0090,000,550,C,&SYS1..LPALIB,RLSE\n     @DATASET CYL,0140,005,350,C,&SYS1..MACLIB,RLSE\n     @DATASET CYL,0020,001,250,C,&SYS1..MIGLIB,RLSE\n     @DATASET CYL,0040,000,250,C,&SYS1..NUCLEUS\n     @DATASET CYL,0002,000,050,C,&SYS1..PARMLIB\n     @DATASET CYL,0002,001,150,C,&SYS1..PROCLIB,,,(JES2)\n     @DATASET CYL,0050,001,250,C,&SYS1..SAMPLIB\n     @DATASET CYL,0002,001,150,C,&SYS1..SVCLIB\n     @DATASET CYL,0002,001,150,C,&SYS1..UADS\n     @DATASET CYL,0003,000,000,N,&SYS1..BRODCAST\n     @DATASET CYL,0003,000,000,N,&SYS1..HASPCKPT\n     @DATASET CYL,0060,000,000,N,&SYS1..HASPACE\n     @DATASET CYL,0010,000,000,N,&SYS1..CPAC.LOGREC\n     @DATASET CYL,0060,000,000,N,&SYS1..DUMP00\n     @DATASET CYL,0060,000,000,N,&SYS1..DUMP01\n.*--------------------------------------------------------------------*\n.*       RACF DATASET AND ISPF LIBRARIES                              *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0010,000,000,N,&RACFDS\n     @DATASET CYL,0002,001,150,C,&SYS1..HRFCLST\n     @DATASET CYL,0002,001,150,C,&SYS1..HRFMSG\n     @DATASET CYL,0002,001,150,C,&SYS1..HRFPANL\n     @DATASET CYL,0002,001,150,C,&SYS1..HRFSKEL\n.*--------------------------------------------------------------------*\n.*       ISMF ISPF libraries                                          *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0001,001,095,C,&SYS1..DGTCLIB\n     @DATASET CYL,0010,001,095,C,&SYS1..DGTLLIB\n     @DATASET CYL,0002,001,095,C,&SYS1..DGTMLIB\n     @DATASET CYL,0033,001,350,C,&SYS1..DGTPLIB\n     @DATASET CYL,0002,001,095,C,&SYS1..DGTSLIB\n     @DATASET CYL,0001,001,095,C,&SYS1..DGTTLIB\n.*--------------------------------------------------------------------*\n.*       OS DITTO Datasets                                            *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0002,001,095,C,&SYS1..DUTLOAD\n     @DATASET CYL,0003,001,095,C,&SYS1..DUTPLIB\n.*--------------------------------------------------------------------*\n.*       SDSF Datasets                                                *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0001,000,000,N,ISF.HASPINDX\n     @DATASET CYL,0001,001,150,C,ISF.SISFLINK,,,(LNK)\n     @DATASET CYL,0005,001,050,C,ISF.SISFLOAD,,,(LNK)\n     @DATASET CYL,0001,001,025,C,ISF.SISFLPA,,,(LPA)\n     @DATASET CYL,0001,001,150,C,ISF.SISFMLIB,,,(ISPMLIB)\n     @DATASET CYL,0002,001,150,C,ISF.SISFPLIB,,,(ISPPLIB)\n     @DATASET CYL,0001,001,150,C,ISF.SISFTLIB,,,(ISPTLIB)\n     @DATASET CYL,0001,001,150,C,ISF.SISFSLIB,,,(ISPSLIB)\n     @DATASET CYL,0015,001,150,C,ISF.SISFSRC\n.*--------------------------------------------------------------------*\n.*       COPY ISPF DATASETS                                           *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0035,0001,075,C,ISP.SISPLPA,,,(LPA)\n     @DATASET CYL,0008,0001,075,C,ISP.SISPLOAD,,,(LNK)\n     @DATASET CYL,0003,0001,150,C,ISP.SISPMENU,,,(ISPMLIB)\n     @DATASET CYL,0025,0001,200,C,ISP.SISPPENU,,,(ISPPLIB)\n     @DATASET CYL,0006,0001,125,C,ISP.SISPSENU,,,(ISPSLIB)\n     @DATASET CYL,0002,0001,125,C,ISP.SISPSLIB,,,(ISPSLIB)\n     @DATASET CYL,0001,0001,125,C,ISP.SISPTENU,,,(ISPTLIB)\n.*--------------------------------------------------------------------*\n.*       COPY PDF DATASETS (OBSOLETE FOR ISPF V4.)                    *\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*       VTAM / NCP DATASETS                                          *\n.*--------------------------------------------------------------------*\n     @DATASET CYL,0001,0001,125,C,CNM.VTAMLST,,,(VTAMLST)\n     @DATASET CYL,0001,0001,125,C,CNM.VTAMLIB,,,(VTAMLIB,APF)\n     @DATASET CYL,0005,0001,125,C,&SYS1..VTAMLST,,,(VTAMLST)\n     @DATASET CYL,0005,0001,125,C,&SYS1..VTAMLIB,,,(VTAMLIB,APF)\n     @DATASET CYL,0050,0001,125,C,&SYS1..SISTCLIB,,,(APF)\n     @DATASET CYL,0007,0001,125,C,NCP5.LOADLIB,,,(APF)\n.**  @DATASET CYL,0005,0000,125,N,NCP5.NCPDUMP\n.*--------------------------------------------------------------------*\n.*       ISPF PROFILE DATASETS                                        *\n.*--------------------------------------------------------------------*\n         AIF ('&USR1' EQ '').NOISPF1\n     @DATASET CYL,0001,0000,050,N,&USR1..ISPF.ISPPROF\n.NOISPF1 ANOP\n         AIF ('&USR2' EQ '').NOISPF2\n     @DATASET CYL,0001,0000,050,N,&USR2..ISPF.ISPPROF\n.NOISPF2 ANOP\n         AIF ('&USR3' EQ '').NOISPF3\n     @DATASET CYL,0001,0000,050,N,&USR3..ISPF.ISPPROF\n.NOISPF3 ANOP\n         AIF ('&USR4' EQ '').NOISPF4\n     @DATASET CYL,0001,0000,050,N,&USR4..ISPF.ISPPROF\n.NOISPF4 ANOP\n         AIF ('&USR5' EQ '').NOISPF5\n     @DATASET CYL,0001,0000,050,N,&USR5..ISPF.ISPPROF\n.NOISPF5 ANOP\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*--------------- END OF NONVSAM DATASET DEFINITIONS -----------------*\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*\n.*\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"A\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBA).NOJOBA\n         @JOBCARD SUFFIX=A\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - A   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* EXPORTD  \u00a6  DISCONNECTS TEST SYSTEM MASTER CATALOG       '\n         AIF ('&COMMAND' NE 'Y').NOCMD1\n PUNCH '//* OFFLINE  \u00a6  VARIES DEVICE &UNITADR OFFLINE               '\n.NOCMD1  ANOP\n PUNCH '//* DSFINIT  \u00a6  INITIALIZES DASD VOLUME USING ICKDSF         '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*    N O T E : : :                                         '\n PUNCH '//*    BE SURE THAT DEVICE &UNITADR IS OFFLINE BEFORE THIS   '\n PUNCH '//*    JOB IS RELEASED.                                      '\n PUNCH '//*----------------------------------------------------------'\n PUNCH '//EXPORTD  EXEC  PGM=IDCAMS,REGION=1M                        '\n PUNCH '//SYSPRINT DD SYSOUT=*                                       '\n PUNCH '//SYSIN    DD *                                              '\n PUNCH '   EXPORT &CATALOG -                                         '\n PUNCH '          DISCONNECT                                         '\n PUNCH '   SET MAXCC=0                                               '\n PUNCH '/*                                                           '\n         AIF ('&COMMAND' NE 'Y').NOCMD2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* OFFLINE  \u00a6  VARY DEVICE &UNITADR OFFLINE                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//OFFLINE  EXEC PGM=COMMAND                                  '\n PUNCH '//SYSIN    DD *                                              '\n PUNCH 'V &UNITADR,OFFLINE                                           '\n PUNCH '/*                                                           '\n         AIF ('&WAIT' NE 'Y').NOWAIT1\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* WAIT     \u00a6  WAIT 5 SECONDS FOR VARY TO COMPLETE          '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//WAIT     EXEC PGM=WAIT,PARM=&SECS                          '\n PUNCH '/*                                                           '\n.NOWAIT1 ANOP\n         AIF ('&COMMAND' NE 'Y').NOCMD5\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* &DEALLOC \u00a6  START DUMMY &DEALLOC TASK                    '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//&DEALLOC EXEC PGM=COMMAND                                  '\n PUNCH '//SYSIN    DD *                                              '\n PUNCH 'S &DEALLOC                                                   '\n.*--------------------------------------------------------------------*\n.* IF THE WAIT PROGRAM IS NOT AVAILABLE, PUNCH AN EXTRA START         *\n.* COMMAND, SO MAYBE WE CAN SLOW THE THING DOWN ENOUGH                *\n.*--------------------------------------------------------------------*\n         AIF ('&WAIT' EQ 'Y').NOWAIT3\n PUNCH 'S &DEALLOC                                                   '\n.NOWAIT3 ANOP\n PUNCH '/*                                                           '\n         AIF ('&WAIT' NE 'Y').NOWAIT2\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* WAIT     \u00a6  WAIT 5 SECONDS FOR DEALLOC TO COMPLETE       '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//WAIT     EXEC PGM=WAIT,PARM=&SECS                          '\n PUNCH '/*                                                           '\n.NOWAIT2 ANOP\n.NOCMD5  ANOP\n.NOCMD2  ANOP\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* DSFINIT  \u00a6  INITIALIZES DASD VOLUME USING ICKDSF         '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//DSFINIT  EXEC PGM=ICKDSF                                   '\n PUNCH '//IPLTEXT  DD DISP=SHR,VOL=SER=&SYSRES,UNIT=SYSDA,           '\n PUNCH '//            DSN=SYS1.SAMPLIB(IPLRECS)                      '\n PUNCH '//         DD DISP=SHR,VOL=SER=&SYSRES,UNIT=SYSDA,           '\n PUNCH '//            DSN=SYS1.SAMPLIB(IEAIPL00)                     '\n PUNCH '//SYSPRINT DD   SYSOUT=*                                     '\n PUNCH '//SYSIN    DD   *                                            '\n PUNCH ' INIT   UNIT(&UNITADR) -                           '\n PUNCH '        VOLID(&VOLUME) -                           '\n PUNCH '        OWNERID(&OWNER) -                          '\n PUNCH '        VTOC(0,1,14) -                             '\n PUNCH '        PURGE -                                    '\n PUNCH '        MAP -                                      '\n         AIF ('&VFY' EQ '').NOVFY\n PUNCH '        VERIFY(&VFY) -                             '\n         AGO  .VFY\n.NOVFY   ANOP\n PUNCH '        NOVERIFY -                                 '\n.VFY     ANOP\n PUNCH '        NOVALIDATE -                               '\n PUNCH '        NOCHECK -                                  '\n PUNCH '        IPLDD(IPLTEXT) -                           '\n PUNCH '        NOBOOTSTRAP                                '\n PUNCH '/*                                                 '\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB A  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.NOJOBA  ANOP\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"B\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBB).NOJOBB\n         @JOBCARD SUFFIX=B\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - B   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n         AIF ('&COMMAND' NE 'Y').NOCMD3\n PUNCH '//* ONLINE   \u00a6  VARY DEVICE &UNITADR ONLINE AND MOUNT &VOLUME'\n.NOCMD3  ANOP\n PUNCH '//* DEFMCAT  \u00a6  DELETE AND RECREATE VVDS                     '\n PUNCH '//*          \u00a6  DEFINE TEST SYSTEM MASTER CATALOG            '\n PUNCH '//* DEFVSAM  \u00a6  DEFINE ALL VSAM DS NEEDED FOR IPL            '\n PUNCH '//* DEFNVSAM \u00a6  DEFINE ALL NON VSAM CATALOG ENTRIES          '\n         AIF ('&COMMAND' NE 'Y').NOCMD4\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* ONLINE   \u00a6  VARY DEVICE &UNITADR ONLINE AND MOUNT &VOLUME'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//OFFLINE  EXEC PGM=COMMAND                                  '\n PUNCH '//SYSIN    DD *                                              '\n PUNCH 'V &UNITADR,ONLINE                                            '\n PUNCH 'M &UNITADR,VOL=(SL,&VOLUME),USE=PRIVATE                      '\n PUNCH '/*                                                           '\n.NOCMD4  ANOP\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* DEFMCAT  \u00a6  DELETE AND RECREATE VVDS, DEFINE NEW MCAT    '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//DEFMCAT  EXEC PGM=IDCAMS,REGION=2M                         '\n PUNCH '//SYSPRINT DD   SYSOUT=*                                     '\n PUNCH '//TARGET   DD   DISP=SHR,UNIT=&DEVT,VOL=SER=&VOLUME          '\n PUNCH '//SYSIN    DD   *                                            '\n PUNCH ' DELETE -                                          '\n PUNCH '         &SYS1..VVDS.V&VOLUME -                    '\n PUNCH '           FILE(TARGET)  -                         '\n PUNCH '           CLUSTER -                               '\n PUNCH '           PURGE -                                 '\n PUNCH '       CATALOG(&MASTRCAT) '                        '\n PUNCH ' SET MAXCC=0                                       '\n PUNCH '                                                   '\n PUNCH ' DEFINE CLUSTER ( -                                '\n PUNCH '           NAME(&SYS1..VVDS.V&VOLUME) -            '\n PUNCH '           CYL(1,1) -                              '\n PUNCH '           VOL(&VOLUME) -                          '\n PUNCH '           FILE(TARGET) -                          '\n PUNCH '           NONINDEXED -                            '\n PUNCH '           OWNER(&OWNER) -                         '\n PUNCH '         ) -                                       '\n PUNCH '       CATALOG(&MASTRCAT)                          '\n PUNCH '                                                   '\n PUNCH ' DEFINE USERCATALOG   ( -                          '\n PUNCH '           NAME(&CATALOG) -                        '\n PUNCH '           CYL(5 2) -                              '\n PUNCH '           VOL(&VOLUME) -                          '\n PUNCH '           BUFFERSPACE(8192) -                     '\n PUNCH '           BUFND(10) -                             '\n PUNCH '           BUFNI(10) -                             '\n PUNCH '           FILE(TARGET) -                         '\n PUNCH '           ICFCATALOG -                            '\n PUNCH '           OWNER(&OWNER) -                         '\n PUNCH '           STRNO(9) -                              '\n PUNCH '                      ) -                          '\n PUNCH '       CATALOG(&MASTRCAT)                          '\n PUNCH '/*                                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* DEFVSAM  \u00a6  DEFINE VSAM DATASETS                         '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//DEFVSAM  EXEC PGM=IDCAMS,REGION=2M,COND=(0,LT)   '\n PUNCH '//STEPCAT  DD  DSN=&CATALOG,DISP=SHR               '\n PUNCH '//SYSPRINT DD  SYSOUT=*                            '\n PUNCH '//TARGET   DD  DISP=SHR,UNIT=&DEVT,VOL=SER=&VOLUME '\n PUNCH '//SYSIN    DD   *                                  '\n PUNCH '  DEFINE CLUSTER ( -                                '\n PUNCH '            NAME( &SYS1..STGINDEX ) -         '\n PUNCH '            CYL(5) -                          '\n PUNCH '            VOL(&VOLUME) -                    '\n PUNCH '            BUFFERSPACE(20480) -              '\n PUNCH '            FILE(TARGET) -                    '\n PUNCH '            KEYS(12 8) -                      '\n PUNCH '            OWNER(&OWNER) -                   '\n PUNCH '            RECORDSIZE(2041,2041) -           '\n PUNCH '            REUSE ) -                         '\n PUNCH '         DATA ( -                             '\n PUNCH '            NAME( &SYS1..STGINDEX.DATA ) -    '\n PUNCH '            CISZ(2048) ) -                    '\n PUNCH '         INDEX ( -                            '\n PUNCH '            NAME( &SYS1..STGINDEX.INDEX ) -   '\n PUNCH '            CISZ(1024) ) -                    '\n PUNCH '         CATALOG(&CATALOG)                    '\n PUNCH '                                              '\n PUNCH ' DEFINE PAGESPACE ( -                         '\n PUNCH '            NAME( PAGE.&VOLUME..PLPA) -     '\n PUNCH '               CYL(&PGPLPA) -                 '\n PUNCH '               VOL(&VOLUME) -                 '\n PUNCH '               FILE(TARGET) -                 '\n PUNCH '               OWNER(&OWNER) -                '\n PUNCH '               NOSWAP -                       '\n PUNCH '               UNIQUE ) -                     '\n PUNCH '            CATALOG(&CATALOG)                 '\n PUNCH '                                              '\n PUNCH ' DEFINE PAGESPACE ( -                         '\n PUNCH '            NAME( PAGE.&VOLUME..COMMON) -   '\n PUNCH '               CYL(&PGCOMM) -                 '\n PUNCH '               VOL(&VOLUME) -                 '\n PUNCH '               FILE(TARGET) -                 '\n PUNCH '               OWNER(&OWNER) -                '\n PUNCH '               NOSWAP -                       '\n PUNCH '               UNIQUE ) -                     '\n PUNCH '            CATALOG(&CATALOG)                 '\n PUNCH '                                              '\n PUNCH ' DEFINE PAGESPACE ( -                         '\n PUNCH '            NAME( PAGE.&VOLUME..LOCAL1) -   '\n PUNCH '               CYL(&PGLCL1) -                 '\n PUNCH '               VOL(&VOLUME) -                 '\n PUNCH '               FILE(TARGET) -                 '\n PUNCH '               OWNER(&OWNER) -                '\n PUNCH '               NOSWAP -                       '\n PUNCH '               UNIQUE ) -                     '\n PUNCH '            CATALOG(&CATALOG)                 '\n PUNCH '                                              '\n PUNCH ' DEFINE CLUSTER ( -                           '\n PUNCH '            NAME( &SYS1..MAN1 ) -             '\n PUNCH '               CYL(10) -                   '\n PUNCH '               VOL(&VOLUME) -              '\n PUNCH '               CISZ(4096) -                '\n PUNCH '               FILE(TARGET) -              '\n PUNCH '               NONINDEXED -                '\n PUNCH '               OWNER(&OWNER) -             '\n PUNCH '               RECORDSIZE(4086 32767) -    '\n PUNCH '               REUSE   SHR(2 3) -          '\n PUNCH '               SPANNED  SPEED ) -          '\n PUNCH '         DATA ( -                                  '\n PUNCH '                 NAME( &SYS1..MAN1.VDATA) ) -      '\n PUNCH '         CATALOG(&CATALOG)                         '\n PUNCH '                                              '\n PUNCH ' DEFINE CLUSTER ( -                           '\n PUNCH '            NAME( &SYS1..MAN2 ) -             '\n PUNCH '               CYL(10) -                   '\n PUNCH '               VOL(&VOLUME) -              '\n PUNCH '               CISZ(4096) -                '\n PUNCH '               FILE(TARGET) -              '\n PUNCH '               NONINDEXED -                '\n PUNCH '               OWNER(&OWNER) -             '\n PUNCH '               RECORDSIZE(4086 32767) -    '\n PUNCH '               REUSE   SHR(2 3) -          '\n PUNCH '               SPANNED  SPEED ) -          '\n PUNCH '         DATA ( -                                  '\n PUNCH '                 NAME( &SYS1..MAN2.VDATA) ) -      '\n PUNCH '         CATALOG(&CATALOG)                         '\n PUNCH '                                                   '\n PUNCH ' IMPORT CONNECT -                                  '\n PUNCH '        OBJECTS( -                                 '\n PUNCH '        (&MASTRCAT  -                              '\n PUNCH '        VOLUME(&MCATVOL) -                         '\n PUNCH '        DEVT(&DEVT) )) -                           '\n PUNCH '        CATALOG(&CATALOG)                          '\n PUNCH '                                                   '\n PUNCH '/*                                                            '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* DEFNVSAM \u00a6  DEFINE NON VSAM CATALOG ENTRIES              '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//DEFNVSAM EXEC PGM=IDCAMS,REGION=3M,COND=(0,LT)              '\n PUNCH '//STEPCAT   DD  DSN=&CATALOG,DISP=SHR '\n PUNCH '//SYSPRINT  DD  SYSOUT=*                                      '\n PUNCH '//SYSIN     DD  *                                             '\n&X       SETA 0\n.JBTOP1  ANOP\n&X       SETA &X+1\n         AIF (&X GT &CTR).JBDONE1\n PUNCH ' DEFINE NONVSAM ( -                                           '\n PUNCH '    NAME(&SYSX..&DSN(&X)) -'\n PUNCH '    OWNER(&OWNER) DEVT(&DEVT) VOL(&VOLUME)) -'\n PUNCH '    CATALOG(&CATALOG)'\n         AGO  .JBTOP1\n.JBDONE1 ANOP\n PUNCH '//*                                                           '\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB B  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.NOJOBB  ANOP\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"C\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBC).NOJOBC\n         @JOBCARD SUFFIX=C\n         LCLC &QVOL,&DSSVOL,&DCBRF\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - C   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  ALLOC   \u00a6  ALLOCATES NONVSAM DATASETS                   '\n PUNCH '//*  LOADNNN \u00a6  COPIES NONVSAM PDS DSNS                      '\n PUNCH '//*  COPYNNN \u00a6  COPIES MEMBERS FROM SOURCE TO TARGET SYSTEM  '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  ALLOC -                                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//ALLOC   EXEC PGM=IEFBR14,REGION=4M                         '\n         AIF ('&STEPCAT' EQ '').NOSCATA\n PUNCH '//STEPCAT   DD DISP=SHR,DSN=&STEPCAT      '\n.NOSCATA  ANOP\n&X       SETA 0\n.J1TOP1  ANOP\n&X       SETA &X+1\n         AIF (&X GT &CTR).J1DONE1\n.*******************************************************\n.*** IF DFDSS COPY, LET DFDSS PERFORM THE ALLOCATION ***\n.*** INSTEAD OF IEFBR14.                              **\n.*******************************************************\n         AIF ('&CPY(&X)' EQ 'D').J1TOP1  USE REPLACE OPTION INSTEAD\n&DCBRF   SETC ''\n         AIF ('&DCBREF' NE 'Y').NODCBRF\n&DCBRF   SETC ',DCB=(&DSN(&X))'\n.NODCBRF ANOP\n&DDNAME  SETC '&DS2(&X)        '(1,8)\n PUNCH '//&DDNAME DD DISP=(,KEEP),DSN=&SYSX..&DSN(&X),    '\n PUNCH '//    UNIT=&DEVT,VOL=SER=&VOLUME&DCBRF,    '\n PUNCH '//    SPACE=(&SPA(&X),(&PRI(&X),&SEC(&X),&DIR(&X))&SPR(&X))'\n         AGO  .J1TOP1\n.J1DONE1 ANOP\n&X       SETA 0\n.JCTOP2  ANOP\n&X       SETA &X+1\n&XCTR    SETC '&X'\n.XCTC2   ANOP\n         AIF (K'&XCTR GT 2).NOXCC2\n&XCTR    SETC '0&XCTR'\n         AGO   .XCTC2\n.NOXCC2  ANOP\n         AIF (&X GT &CTR).JCDONE2\n&DDN     SETC '&DS2(&X)        '(1,7)\n&XDDN    SETC '&DS2(&X)'\n         AIF (K'&XDDN LT 8).NODTRIM\n&XDDN    SETC '&XDDN'(1,7)\n.NODTRIM ANOP\n.* SEE IF THIS IS A CATFIND = Y RUN.  IF SO, DON'T ADD THE VOL=SER=\n.* SYSRES UNLESS SPECIFICALLY REQUESTED ON @DATASET MACRO.\n.* IF CATFIND = N, THEN PUT VOL=SER=SYSRES ON ALL, EXCEPT PUT\n.* SPECIFIED VOLUME ON VOL=SER= IF SPECIFIED ON @DATASET MACRO.\n&QVOL    SETC ''\n&DSSVOL  SETC ''\n.*\n         AIF ('&VOL(&X)' EQ '').NOVOL   IF NO VOL, BRANCH AROUND\n&QVOL    SETC '&VOL(&X)'                ELSE SET VOL\n&DSSVOL  SETC 'INDYNAM(&VOL(&X))'       ELSE SET VOL\n         AGO .PUNCPY                    AND GO PUNCH COPY JCL\n.*\n.NOVOL   ANOP\n         AIF ('&CATFIND' EQ 'Y').PUNCPY IF CATFIND=Y, LEAVE VOL BLNK\n&QVOL    SETC '&SYSRES'\n.PUNCPY  ANOP\n         AIF ('&CPY(&X)' EQ 'C').DOCOPY\n         AIF ('&CPY(&X)' EQ 'G').DOGENER\n         AIF ('&CPY(&X)' EQ 'D').DODSS\n         AGO .JCTOP2\n.DOCOPY  ANOP\n.*\n.* PROCESS THIS DATASET WITH IEBCOPY (COPY OPTION \"C\")\n.*\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  LOAD&XCTR - IEBCOPY &DSN(&X)         '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LOAD&XCTR EXEC PGM=IEBCOPY,REGION=2M    '\n         AIF ('&STEPCAT' EQ '').NOSCAT1\n PUNCH '//STEPCAT   DD DISP=SHR,DSN=&STEPCAT      '\n.NOSCAT1  ANOP\n PUNCH '//SYSPRINT  DD SYSOUT=*                   '\n PUNCH '//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))  '\n PUNCH '//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))  '\n PUNCH '//I&DDN  DD DISP=SHR,DSN=&DSN(&X),            '\n PUNCH '//          UNIT=SYSALLDA,VOL=SER=&QVOL       '\n PUNCH '//O&DDN  DD DISP=SHR,DSN=&SYSX..&DSN(&X),     '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME        '\n PUNCH '//SYSIN    DD *                               '\n PUNCH '   COPY I=I&XDDN,O=O&XDDN,LIST=NO       '\n PUNCH '//*                                             '\n         AGO  .JCTOP2\n.DOGENER ANOP\n.*\n.* PROCESS THIS DATASET WITH ICEGENER (COPY OPTION \"G\")\n.*\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  LOAD&XCTR - ICEGENER &DSN(&X)       '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LOAD&XCTR EXEC PGM=ICEGENER,REGION=2M         '\n         AIF ('&STEPCAT' EQ '').NOSCAT2\n PUNCH '//STEPCAT   DD DISP=SHR,DSN=&STEPCAT      '\n.NOSCAT2  ANOP\n PUNCH '//SYSPRINT  DD SYSOUT=*                         '\n PUNCH '//SYSUT1    DD DISP=SHR,DSN=&DSN(&X),           '\n PUNCH '//          UNIT=SYSALLDA,VOL=SER=&QVOL       '\n PUNCH '//SYSUT2    DD DISP=SHR,DSN=&SYSX..&DSN(&X),    '\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME          '\n PUNCH '//SYSIN     DD DUMMY                            '\n PUNCH '//*                                             '\n         AGO  .JCTOP2\n.DODSS   ANOP\n.*\n.* PROCESS THIS DATASET WITH DFDSS (COPY OPTION \"D\")\n.*\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  LOAD&XCTR - DFDSS &DSN(&X)       '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LOAD&XCTR EXEC PGM=ADRDSSU,REGION=4M          '\n         AIF ('&STEPCAT' EQ '').NOSCAT3\n PUNCH '//STEPCAT   DD DISP=SHR,DSN=&STEPCAT      '\n.NOSCAT3  ANOP\n PUNCH '//SYSPRINT  DD SYSOUT=*                         '\n PUNCH '//SYSIN     DD *                                '\n PUNCH '  COPY -                                        '\n PUNCH '  DATASET( -                                    '\n PUNCH '     INCLUDE( -                                 '\n PUNCH '        &DSN(&X) -                              '\n PUNCH '            ) ) -                               '\n PUNCH '  REPLACE    -                                  '\n PUNCH '  ALLDATA(*) -                                  '\n PUNCH '  TOL(ENQF) -                                   '\n PUNCH '  PROCESS(SYS1)  -                              '\n PUNCH '  RECATALOG(&CATALOG) -                         '\n PUNCH '  OUTDYNAM(&VOLUME) &DSSVOL -                   '\n PUNCH '  SHARE                                         '\n PUNCH '//*                                             '\n         AGO  .JCTOP2\n.*\n.JCDONE2 ANOP\n.*-----------------------------------------------------\n.*-----------------------------------------------------\n.*-----------------------------------------------------\n.* PROCESS MEMBER COPIES SPECIFIED THROUGH @COPY MACRO\n.*-----------------------------------------------------\n.*-----------------------------------------------------\n.*-----------------------------------------------------\n         LCLA &YCTR,&ZCTR\n         LCLC &SOURCE,&TARGET\n         LCLC &MEMPRM\n         AIF (&CTRB LT 1).NOMEMCPY\n         AIF ('&SRCL(1)' EQ '').ERRMC01\n         AIF ('&TGTL(1)' EQ '').ERRMC01\n&SOURCE  SETC '&SRCL(1)'\n&TARGET  SETC '&TGTL(1)'\n&YCTR    SETA 1\n         AGO .NEWCJOB                    GO PUNCH FIRST JOB CARDS\n.*-----------------------------------------------------\n.*--- IF TARGET OR SOURCE LIB CHANGES, PUNCH NEW STEP -\n.*-----------------------------------------------------\n.MEMTOP  ANOP\n&YCTR    SETA &YCTR+1\n.* MNOTE 1,'SRCL(&YCTR) IS: &SRCL(&YCTR)'\n.* MNOTE 1,'TGTL(&YCTR) IS: &TGTL(&YCTR)'\n.* MNOTE 1,'MEMB(&YCTR) IS: &MEMB(&YCTR)'\n.* MNOTE 1,'NMEM(&YCTR) IS: &NMEM(&YCTR)'\n         AIF (&YCTR GT &CTRB).MEMDONE\n         AIF ('&SRCL(&YCTR)' NE '').NEWCJOB\n         AIF ('&TGTL(&YCTR)' NE '').NEWCJOB\n.*-----------------------------------------------------\n.*---- PUNCH THE NEXT MEMBER COPY STATEMENT -----------\n.*-----------------------------------------------------\n.NEXTMEM ANOP\n&MEMPRM  SETC ''\n&MEMPRM  SETC '&MEMB(&YCTR)'\n         AIF ('&NMEM(&YCTR)' EQ '').NONEW\n&MEMPRM  SETC '&MEMPRM,&NMEM(&YCTR),R'\n.NONEW   ANOP\n.* MNOTE 0,'  SELECT MEMBER=((&MEMPRM)) '\n PUNCH '  SELECT MEMBER=((&MEMPRM)) '\n         AGO .MEMTOP\n.*-----------------------------------------------------\n.*---- PUNCH THE JCL FOR THE NEXT JOB STEP  -----------\n.*-----------------------------------------------------\n.NEWCJOB ANOP                          ************************\n&ZCTR    SETA &ZCTR+1\n&XCTR    SETC '&ZCTR'                  PAD THE COUNTER WITH 0'S\n.PADCTR  ANOP                          MAKE IT LOOK NICE\n         AIF (K'&XCTR GT 2).NOMCPAD    ************************\n&XCTR    SETC '0&XCTR'\n         AGO .PADCTR\n.NOMCPAD ANOP\n         AIF ('&SRCL(&YCTR)' EQ '').NSRCSET\n&SOURCE  SETC '&SRCL(&YCTR)'\n.NSRCSET ANOP\n         AIF ('&TGTL(&YCTR)' EQ '').NTGTSET\n&TARGET  SETC '&TGTL(&YCTR)'\n.NTGTSET ANOP\n PUNCH '//*'\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  COPY&XCTR - COPY MEMBERS             '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//COPY&XCTR EXEC PGM=IEBCOPY,REGION=2M    '\n PUNCH '//SYSPRINT  DD SYSOUT=*                   '\n PUNCH '//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))  '\n PUNCH '//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))  '\n PUNCH '//INDD      DD DISP=SHR,DSN=&SOURCE'\n PUNCH '//OUTDD     DD DISP=SHR,DSN=&SYSX..&TARGET,'\n PUNCH '//          UNIT=&DEVT,VOL=SER=&VOLUME        '\n PUNCH '//SYSIN    DD *                               '\n PUNCH '   COPY I=INDD,O=OUTDD,LIST=NO          '\n         AGO .MEMTOP\n.*-----------------------------------------------------\n.*---- ERROR ------------------------------------------\n.*-----------------------------------------------------\n.ERRMC01 MNOTE 8,'SOURCE AND TARGET LIB MUST BE SPECIFIED ON FIRST'\n         MNOTE 8,'@COPY INVOCATION.'\n         MEXIT\n.*-----------------------------------------------------\n.*---- END OF MEMBER COPY JCL GENERATION --------------\n.*-----------------------------------------------------\n.MEMDONE  ANOP\n.NOMEMCPY ANOP\n.*\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB C  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*\n.NOJOBC  ANOP\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"D\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBD).NOJOBD\n         @JOBCARD SUFFIX=D\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - D   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* LOGREC   \u00a6  INITIALIZES SYS1.CPAC.LOGREC                 '\n         AIF ('&UADS' NE 'Y').NOUADSX\n PUNCH '//* USYNC    \u00a6  SYNC UADS/BRODCAST DATASETS.                 '\n.NOUADSX ANOP\n         AIF ('&UADS' NE 'Y').NOUADSA\n PUNCH '//* UADSXXXX \u00a6  COPY, AND MANIPULATE TSO UADS MEMBERS        '\n.NOUADSA ANOP\n PUNCH '//* DMPINT0  \u00a6  INITIALIZES DUMP DATASETS                    '\n PUNCH '//* DMPINT1  \u00a6  INITIALIZES DUMP DATASETS                    '\n         AIF ('&RACF' NE 'Y').NORACF2\n         AIF ('&RFCOPY' EQ 'Y').RFCOPY2\n PUNCH '//* ICHINIT  \u00a6  INITIALIZES NEW RACF DATASET                 '\n         AGO .NORACF2\n.RFCOPY2 ANOP\n PUNCH '//* ICHCOPY  \u00a6  COPIES RACF DATASET USING IRRUT200           '\n.NORACF2 ANOP\n PUNCH '//* FMTSMF   \u00a6  FORMAT SMF DATASETS                          '\n         AIF ('&CATPTR' EQ 'N').NOCATP1\n PUNCH '//* CATPTR   \u00a6  SET MASTER CATALOG POINTER                   '\n.NOCATP1 ANOP\n PUNCH '//* CATPRT   \u00a6  PRINT MASTER CATALOG POINTER                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*                                                '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* LOGREC   \u00a6  INITIALIZES SYS1.CPAC.LOGREC                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LOGREC   EXEC PGM=IFCDIP00                              '\n PUNCH '//SERERDS  DD DISP=SHR,DSN=&SYSX..SYS1.CPAC.LOGREC,       '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME                     '\n PUNCH '//*                                                       '\n         AIF ('&USYNC' NE 'Y').NOUSYNC\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* SYNC UADS / BRODCAST DATASETS                       '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//USYNC    EXEC PGM=IKJEFT01,                           '\n PUNCH '//         DYNAMNBR=15,                                 '\n PUNCH '//         REGION=2M                                    '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//SYSIN    DD DUMMY                                '\n PUNCH '//SYSUADS  DD DISP=SHR,DSN=&SYSX..&SYS1..UADS,     '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME              '\n PUNCH '//SYSLBC   DD DISP=SHR,DSN=&SYSX..&SYS1..BRODCAST, '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME              '\n PUNCH '//SYSTSPRT DD SYSOUT=*                             '\n PUNCH '//SYSTSIN  DD *                                    '\n PUNCH '  ACCOUNT                                          '\n PUNCH '  SYNC                                             '\n PUNCH '  END                                              '\n PUNCH '//*                                                '\n.NOUSYNC ANOP\n         AIF ('&UADS' NE 'Y').NOUADSB\n         AIF ('&USR1&USR2&USR3&USR4&USR5' EQ '').NOUADSB\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* COPY UADS ENTRIES FOR SELECTED TSO USERS            '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//UADSCPY  EXEC PGM=IEBCOPY                               '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//SYSUT2   DD UNIT=SYSDA,SPACE=(20,10)             '\n PUNCH '//SYSUT3   DD UNIT=SYSDA,SPACE=(20,10)             '\n PUNCH '//IUADS    DD DSN=SYS1.UADS,DISP=SHR               '\n PUNCH '//OUADS    DD DSN=&SYSX..&SYS1..UADS,DISP=SHR,     '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME              '\n PUNCH '//SYSIN    DD *                                    '\n PUNCH ' COPY I=((IUADS,R)),O=OUADS                        '\n         AIF ('&USR1' EQ '').UNO1\n PUNCH ' SELECT MEMBER=((&USR1.0,$&USR1.0,R))                     '\n.UNO1    ANOP\n         AIF ('&USR2' EQ '').UNO2\n PUNCH ' SELECT MEMBER=((&USR2.0,$&USR2.0,R))                     '\n.UNO2    ANOP\n         AIF ('&USR3' EQ '').UNO3\n PUNCH ' SELECT MEMBER=((&USR3.0,$&USR3.0,R))                     '\n.UNO3    ANOP\n         AIF ('&USR4' EQ '').UNO4\n PUNCH ' SELECT MEMBER=((&USR4.0,$&USR4.0,R))                     '\n.UNO4    ANOP\n         AIF ('&USR5' EQ '').UNO5\n PUNCH ' SELECT MEMBER=((&USR5.0,$&USR5.0,R))                     '\n.UNO5    ANOP\n PUNCH '//*                                                '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* PERFORM ACCOUNT PROCESSING ON TSO USERIDS           '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//UADSACT  EXEC PGM=IKJEFT01,                           '\n PUNCH '//        DYNAMNBR=15,                                  '\n PUNCH '//        REGION=2M                                     '\n PUNCH '//SYSUADS  DD DSN=&SYSX..&SYS1..UADS,DISP=SHR,          '\n PUNCH '//            VOL=SER=&VOLUME,UNIT=&DEVT           '\n PUNCH '//SYSLBC   DD DSN=&SYSX..&SYS1..BRODCAST,DISP=SHR, '\n PUNCH '//            VOL=SER=&VOLUME,UNIT=&DEVT           '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//SYSIN    DD DUMMY                                '\n PUNCH '//SYSTERM  DD SYSOUT=*                             '\n PUNCH '//SYSTSPRT DD SYSOUT=*                             '\n PUNCH '//SYSTSIN  DD *                                    '\n PUNCH ' ACCOUNT                                           '\n         AIF ('&USR1' EQ '').UNOB1\n PUNCH ' ADD    ($&USR1 * *) DATA(&TSOPROC)                '\n PUNCH ' CHANGE ($&USR1 *)   DATA(&TSOPASS)                '\n.UNOB1   ANOP\n         AIF ('&USR2' EQ '').UNOB2\n PUNCH ' ADD    ($&USR2 * *) DATA(&TSOPROC)                '\n PUNCH ' CHANGE ($&USR2 *)   DATA(&TSOPASS)                '\n.UNOB2   ANOP\n         AIF ('&USR3' EQ '').UNOB3\n PUNCH ' ADD    ($&USR3 * *) DATA(&TSOPROC)                '\n PUNCH ' CHANGE ($&USR3 *)   DATA(&TSOPASS)                '\n.UNOB3   ANOP\n         AIF ('&USR4' EQ '').UNOB4\n PUNCH ' ADD    ($&USR4 * *) DATA(&TSOPROC)                '\n PUNCH ' CHANGE ($&USR4 *)   DATA(&TSOPASS)                '\n.UNOB4   ANOP\n         AIF ('&USR5' EQ '').UNOB5\n PUNCH ' ADD    ($&USR5 * *) DATA(&TSOPROC)                '\n PUNCH ' CHANGE ($&USR5 *)   DATA(&TSOPASS)                '\n.UNOB5   ANOP\n PUNCH ' END                                               '\n PUNCH '/*                                                 '\n PUNCH '//*                                                '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* RENAME USERS BACK TO ORIGINAL NAME                  '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//RNUSRS   EXEC PGM=IDCAMS,REGION=2M               '\n PUNCH '//SYSPRINT DD  SYSOUT=*                            '\n PUNCH '//UADS     DD DSN=&SYSX..UADS,                     '\n PUNCH '//            DISP=SHR,UNIT=&DEVT,VOL=SER=&VOLUME  '\n PUNCH '//SYSIN   DD   *                                   '\n         AIF ('&USR1' EQ '').UNOC1\n PUNCH ' ALTER &SYSX..UADS($&USR1.0) -                     '\n PUNCH '       FILE(UADS) -                                '\n PUNCH '       NEWNAME(&SYSX..UADS(&USR1.0))               '\n.UNOC1   ANOP\n         AIF ('&USR2' EQ '').UNOC2\n PUNCH ' ALTER &SYSX..UADS($&USR2.0) -                     '\n PUNCH '       FILE(UADS) -                                '\n PUNCH '       NEWNAME(&SYSX..UADS(&USR2.0))               '\n.UNOC2   ANOP\n         AIF ('&USR3' EQ '').UNOC3\n PUNCH ' ALTER &SYSX..UADS($&USR3.0) -                     '\n PUNCH '       FILE(UADS) -                                '\n PUNCH '       NEWNAME(&SYSX..UADS(&USR3.0))               '\n.UNOC3   ANOP\n         AIF ('&USR4' EQ '').UNOC4\n PUNCH ' ALTER &SYSX..UADS($&USR4.0) -                     '\n PUNCH '       FILE(UADS) -                                '\n PUNCH '       NEWNAME(&SYSX..UADS(&USR4.0))               '\n.UNOC4   ANOP\n         AIF ('&USR5' EQ '').UNOC5\n PUNCH ' ALTER &SYSX..UADS($&USR5.0) -                     '\n PUNCH '       FILE(UADS) -                                '\n PUNCH '       NEWNAME(&SYSX..UADS(&USR5.0))               '\n.UNOC5   ANOP\n PUNCH '//*                                                '\n.NOUADSB ANOP\n PUNCH '//*                                                '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* INITIALIZE DUMP DATASETS                            '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//DMPINT0 EXEC PGM=IEBGENER                             '\n PUNCH '//SYSPRINT DD SYSOUT=*                                  '\n PUNCH '//SYSIN    DD DUMMY                                     '\n PUNCH '//SYSUT1   DD DUMMY,DCB=&SYS1..DUMP00                   '\n PUNCH '//SYSUT2   DD DSN=&SYSX..&SYS1..DUMP00,DISP=SHR,        '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME                   '\n PUNCH '//*                                                '\n PUNCH '//DMPINT1 EXEC PGM=IEBGENER                             '\n PUNCH '//SYSPRINT DD SYSOUT=*                                  '\n PUNCH '//SYSIN    DD DUMMY                                     '\n PUNCH '//SYSUT1   DD DUMMY,DCB=&SYS1..DUMP01                   '\n PUNCH '//SYSUT2   DD DSN=&SYSX..&SYS1..DUMP01,DISP=SHR,        '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME                   '\n PUNCH '//*                                                '\n         AIF ('&RACF' NE 'Y').NORACF\n         AIF ('&RFCOPY' EQ 'Y').RFCOPY\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* INITIALIZE THE NEW RACF DATASET USING IRRMIN00      '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//ICHINIT  EXEC PGM=IRRMIN00,PARM=NEW                   '\n PUNCH '//SYSPRINT DD SYSOUT=*                                  '\n PUNCH '//SYSTEMP  DD DSN=&SYSX..MACLIB(ICHTEMP0),DISP=SHR'\n PUNCH '//SYSRACF  DD DSN=&SYSX..&RACFDS,DISP=OLD, '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME             '\n        AGO .NORACF\n.RFCOPY ANOP\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* COPY THE RACF DATASET USING IRRUT200                '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//ICHCOPY  EXEC PGM=IRRUT200                              '\n PUNCH '//SYSPRINT DD SYSOUT=*                                    '\n PUNCH '//SYSUT2   DD SYSOUT=*                                    '\n PUNCH '//SYSRACF  DD DSN=&RACFDS,DISP=SHR                 '\n PUNCH '//SYSUT1   DD DSN=&SYSX..&RACFDS,DISP=OLD,         '\n PUNCH '// UNIT=&DEVT,VOL=SER=&VOLUME                             '\n PUNCH '//SYSIN    DD *                                           '\n PUNCH '  INDEX                                                   '\n PUNCH '  MAP                                                     '\n PUNCH '  END                                                     '\n PUNCH '//*                                                       '\n.NORACF    ANOP\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* FORMAT THE SMF DATASETS                             '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//FMTSMF EXEC PGM=IFASMFDP,REGION=2M               '\n PUNCH '//STEPCAT  DD DSN=&CATALOG,DISP=SHR                '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//FMAN1    DD DSN=&SYS1..MAN1,DISP=SHR,            '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME              '\n PUNCH '//FMAN2    DD DSN=&SYS1..MAN2,DISP=SHR,            '\n PUNCH '//         UNIT=&DEVT,VOL=SER=&VOLUME              '\n PUNCH '//SYSIN    DD *                                    '\n PUNCH ' INDD(FMAN1,OPTIONS(CLEAR))                        '\n PUNCH ' INDD(FMAN2,OPTIONS(CLEAR))                        '\n         AIF ('&CATPTR' EQ 'N').NOCATP2\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* CONFIGURE SYSCATLG MASTER CATALOG POINTER           '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//CATPTR   EXEC PGM=IEBDG,REGION=512K                        '\n PUNCH '//*-----------------------------------------------------------'\n PUNCH '//* NOTES: ACCEPTABLE CATALOG TYPE VALUES FOR \"FILL=\" ON THE  '\n PUNCH '//*        \"CATTYPE\" FD STATEMENT ARE:                        '\n PUNCH '//*          X''00'' AND X''40''  -  VSAM MASTER CATALOG      '\n PUNCH '//*          X''F1''            -  ICF MASTER CATALOG         '\n PUNCH '//*                                                           '\n PUNCH '//*-----------------------------------------------------------'\n        LCLC &QLEVEL\n&QLEVEL SETC 'F1'\n PUNCH '//SYSPRINT DD  SYSOUT=*                                       '\n PUNCH '//NUCLEUS  DD  DSN=&SYSX..&SYS1..NUCLEUS(SYSCATLG),           '\n PUNCH '//             UNIT=&DEVT,VOL=SER=&VOLUME,                    '\n PUNCH '//             DISP=OLD                                       '\n PUNCH '//SYSIN    DD  *                                              '\n PUNCH '  DSD OUTPUT=(NUCLEUS)                                     '\n PUNCH '  FD NAME=VOL,                                             '\n PUNCH '     LENGTH=06,                                            '\n PUNCH '     STARTLOC=01,                                          '\n PUNCH '     FILL=X''40'',                                         '\n PUNCH '     PICTURE=6,''&VOLUME''  <-VERIFY CATALOG VOLUME        '\n PUNCH '  FD NAME=CATTYPE,                                         '\n PUNCH '     LENGTH=01,                                            '\n PUNCH '     STARTLOC=07,                                          '\n PUNCH '     FILL=X''F1''           <-VERIFY CATALOG TYPE          '\n PUNCH '  FD NAME=QLV,                                             '\n PUNCH '     LENGTH=01,                                            '\n PUNCH '     STARTLOC=08,                                          '\n PUNCH '     FILL=X''&QLEVEL''      <-QUALIFICATION LEVEL          '\n PUNCH '  FD NAME=CAT,                                             '\n PUNCH '     LENGTH=44,                                            '\n PUNCH '     STARTLOC=11,                                          '\n PUNCH '     FILL=X''40'',                                         '\n PUNCH '     PICTURE=44,''&CATALOG                              '''\n PUNCH '  FD NAME=FIL,                                             '\n PUNCH '     LENGTH=26,                                            '\n PUNCH '     STARTLOC=55,                                          '\n PUNCH '     FILL=X''40''                                          '\n PUNCH ' CREATE QUANTITY=1,FILL=X''00'',NAME=(VOL,CATTYPE,QLV,CAT,FIL)'\n PUNCH '//*                                                  '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//* PRINT THE CATALOG POINTER JUST CREATED              '\n PUNCH '//*-----------------------------------------------------'\n PUNCH '//CATPRT    EXEC PGM=IDCAMS                             '\n PUNCH '//SYSPRINT  DD SYSOUT=*                                 '\n PUNCH '//CATPTR    DD DSN=&SYSX..&SYS1..NUCLEUS(SYSCATLG),DISP=SHR,'\n PUNCH '//            UNIT=&DEVT,VOL=SER=&VOLUME             '\n PUNCH '//SYSIN    DD *                                      '\n PUNCH '  PRINT INFILE(CATPTR) DUMP                          '\n PUNCH '//*                                                  '\n.NOCATP2 ANOP\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB D  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.NOJOBD  ANOP\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"E\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBE).NOJOBE\n         @JOBCARD SUFFIX=E\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - E   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* RENAME   \u00a6  RENAME NONVSAM DATASET TO FINAL NAME         '\n PUNCH '//* VTOCLIST \u00a6  VTOC LISTING                                 '\n PUNCH '//* LISTCAT  \u00a6  FINAL LISTCAT                                '\n PUNCH '//*=========================================================*'\n PUNCH '//* RENAME   \u00a6  RENAME NONVSAM DATASET TO FINAL NAME         '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//RENAME  EXEC PGM=IDCAMS,REGION=2M      '\n PUNCH '//STEPCAT  DD  DISP=SHR,DSN=&CATALOG     '\n PUNCH '//SYSPRINT DD  SYSOUT=*                  '\n PUNCH '//SYSIN   DD   *                         '\n&X       SETA 0\n.JETOP1  ANOP\n&X       SETA &X+1\n         AIF (&X GT &CTR).JEDONE1\n         AIF ('&CPY(&X)' EQ 'D').JETOP1\n PUNCH ' ALTER &SYSX..&DSN(&X) -                 '\n PUNCH '       NEWNAME(&DSN(&X)) -               '\n PUNCH '       CATALOG(&CATALOG)                 '\n         AGO  .JETOP1\n.JEDONE1 ANOP\n PUNCH '//*                                                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* VTOCLIST \u00a6  LIST VTOC                                    '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//VTOCLIST EXEC PGM=IEHLIST,REGION=2M              '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//VOL1     DD UNIT=&DEVT,VOL=SER=&VOLUME,DISP=OLD  '\n PUNCH '//SYSIN    DD *                                    '\n PUNCH '  LISTVTOC VOL=&DEVT=&VOLUME                       '\n PUNCH '  LISTVTOC VOL=&DEVT=&VOLUME,FORMAT                '\n PUNCH '//*                                                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* LISTCAT  \u00a6  FINAL CATALOG LISTING                        '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//LISTCAT EXEC PGM=IDCAMS,REGION=2M      '\n PUNCH '//STEPCAT  DD  DISP=SHR,DSN=&CATALOG     '\n PUNCH '//SYSPRINT DD  SYSOUT=*                  '\n PUNCH '//SYSIN   DD   *                         '\n PUNCH '  LISTCAT ALL CATALOG(&CATALOG)          '\n PUNCH '//*                                      '\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB E  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.NOJOBE  ANOP\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"F\"                                          *\n.*--------------------------------------------------------------------*\n         AIF (NOT &DOJOBF).NOJOBF\n         @@PARMLB DEVT=&DEVT,VOLUME=&VOLUME,JOBCHAR=F\n         @@PROCLB DEVT=&DEVT,VOLUME=&VOLUME,TSOPROC=&TSOPROC\n.NOJOBF  ANOP\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB F  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*--------------------------------------------------------------------*\n.*    BEGIN  JCL FOR JOB \"G\"                                          *\n.*--------------------------------------------------------------------*\n         LCLC &TMSDSN\n&TMSDSN  SETC '&WRKPFX..BACKUP'\n         AIF    ('&TMSPRM' EQ '').SKTMSF\n&TMSDSN  SETC '&TMSDSN,&TMSPRM'\n.SKTMSF  ANOP\n         AIF ('&DUMP' NE 'Y').NODUMP\n         AIF (NOT &DOJOBG).NOJOBG\n         @JOBCARD SUFFIX=G\n PUNCH '//*=========================================================*'\n PUNCH '//* JOB - G   &SYSTIME &SYSDATE                           '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//*  STEP    \u00a6       PURPOSE                                 '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//* DSSDUMP  \u00a6  BACK UP THE VOLUME TO TAPE USING DFDSS       '\n PUNCH '//*---------------------------------------------------------*'\n PUNCH '//DSSDUMP  EXEC PGM=ADRDSSU,REGION=2M              '\n PUNCH '//SYSPRINT DD SYSOUT=*                             '\n PUNCH '//TAPE     DD DSN=&TMSDSN,'\n PUNCH '//            UNIT=&TAPEUNT,DISP=(NEW,CATLG,KEEP)  '\n PUNCH '//SYSIN    DD *                                    '\n PUNCH '  DUMP INDY(&VOLUME,&DEVT) -                       '\n PUNCH '  OPT(4) -                                         '\n PUNCH '  OUTDD(TAPE) -                                    '\n PUNCH '  ALLDATA(*) -                                     '\n PUNCH '  ALLEXCP                                          '\n PUNCH '/*                                                 '\n.NODUMP   ANOP\n PUNCH '//*                                                '\n.NOJOBG  ANOP\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-* End of JOB G  *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**\n         MEXIT\n.*--------------------------------------------------------------------*\n.*    ERRORS                                                          *\n.*--------------------------------------------------------------------*\n.ERR001  MNOTE 8,'THE @JOBCARD MACRO MUST BE CODED BEFORE INVOKING'\n         MNOTE 8,'THIS MACRO.'\n         MEXIT\n.*--------------------------------------------------------------------*\n.*    END OF MACRO                                                    *\n.*--------------------------------------------------------------------*\n         POP    PRINT\n         MEND\n./ ADD NAME=COMMAND  0100-02365-02365-0941-00400-00400-00000-JMILLER\n//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M\n//ASMHCL   EXEC  ASMHCL,PARM.L='MAP,LET,LIST,NCAL,AC=1'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//             DD  DSN=SYS1.AMODGEN,DISP=SHR\n//C.SYSIN    DD  *\nCOMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'\n***********************************************************************\n*                                                                     *\n*                           C O M M A N D                             *\n*                                                                     *\n*                   ISSUE SYSTEM OPERATOR COMMANDS                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: This version has RACHECK code added to be sure that the       *\n* caller has at least READ access to the COMMAND profile of the       *\n* APPL RACF class.  To permit use of the COMMAND command:             *\n*                                                                     *\n*    RDEFINE APPL COMMAND UACC(NONE)                                  *\n*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *\n*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *\n*     AUTHORIZED.                                                     *\n*                                                                     *\n*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *\n*                                                                     *\n*     1) BATCH OR CALLED PROGRAM                                      *\n*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *\n*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *\n*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *\n*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *\n*                                                                     *\n*           - OR -                                                    *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND                               *\n*           //SYSIN    DD *                                           *\n*           VARY 017,ONLINE                                           *\n*           /*                                                        *\n*                                                                     *\n*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *\n*        WILL BE ADDED BETWEEN COMMANDS.                              *\n*                                                                     *\n*     2) TSO COMMAND PROCESSOR                                        *\n*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *\n*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *\n*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *\n*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *\n*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *\n*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *\n*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *\n*        FOR EXAMPLE:                                                 *\n*                                                                     *\n*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *\n*                                                                     *\n*     3) CALLABLE SUBROUTINE                                          *\n*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *\n*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *\n*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *\n*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *\n*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *\n*        CONSOLE.) FOR EXAMPLE:                                       *\n*                                                                     *\n*           LA       R1,CMDADDR                                       *\n*           LA       R15,=V(COMMAND)                                  *\n*           BALR     R14,R15                                          *\n*                                                                     *\n*           CMDADDR  DC    A(OPERCMD)                                 *\n*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *\n*           OPERCMD  DC    H(3),CL3'D T'                              *\n*           CONSOLE  DC    F'5'                                       *\n*                                                                     *\n*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *\n*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *\n*                                                                     *\n*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *\n*                                                                     *\n*     AUTHOR:                                                         *\n*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *\n*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *\n*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *\n*                                                                     *\n*          STEVE LANGLEY                                              *\n*          SOUTHERN CALIFORNIA EDISON                                 *\n*          P.O. BOX 800                                               *\n*          ROSEMEAD, CALIF. 91770                                     *\n*          1-213-572-3435                                             *\n*                                                                     *\n*     IMPLEMENTOR:                                          *HMD 07/81*\n*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*\n*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*\n*                                                           *HMD 07/81*\n*          HOWARD M. DEAN                                   *HMD 07/81*\n*          GTE DATA SERVICES                                *HMD 07/81*\n*          4750 LINCOLN BLVD.                               *HMD 07/81*\n*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*\n*          PHONE - (213) - 821-0511                         *HMD 07/81*\n*                                                           *HMD 07/81*\n*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*\n*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*\n*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*\n***********************************************************************\n         EJECT\nCOMMAND  CSECT\n         SPACE 3\nR0       EQU   0                  REGISTER 0\nR1       EQU   1                  REGISTER 1\nR2       EQU   2                  WORK REGISTER\nR3       EQU   3                  WORK REGISTER\nR4       EQU   4                  WORK REGISTER\nR5       EQU   5                  WORK REGISTER\nR6       EQU   6                  WORK REGISTER             *HMD 07/81*\nR7       EQU   7                  WORK REGISTER             *HMD 07/81*\nR8       EQU   8                  WORK REGISTER             *HMD 07/81*\nR9       EQU   9                  WORK REGISTER             *HMD 07/81*\nR10      EQU   10                 PARAMETER LIST ADDRESS REGISTER\nR11      EQU   11                 SUBROUTINE LINKAGE REGISTER\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13                 SAVE AREA ADDRESS REGISTER\nR14      EQU   14                 REGISTER 14\nR15      EQU   15                 REGISTER 15\n         EJECT\n         SAVE  (14,12)            SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH\n         USING COMMAND,R12        ADDRESSABILITY\n         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS\n         ST    R13,SAVEAREA+4     ESTABLISH BACK\n         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS\n         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS\n         LR    R10,R1             SAVE PARAMETER REGISTER\n         SPACE 2\n*********************************************************** *CKO 07/92*\n* Determine whether user is authorized to the application   *CKO 07/92*\n*********************************************************** *CKO 07/92*\nRACHK    EQU  *                                             *CKO 07/92*\n         RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*\n         LTR  R15,R15             Authorized to this prog?  *CKO 07/92*\n         BNZ  NOTAUTH             Nope.                     *CKO 07/92*\n         SPACE 2                                            *CKO 07/92*\n         L     R2,CVTPTR          R2 = ADDR OF CVT\n         USING CVT,R2\n         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD\n         L     R4,12(R3)          R4 = ADDR OF OUR ASCB\n         USING ASCB,R4\n         MVC   ASID,ASCBASID      SAVE OUR ASID\n         DROP  R4\n         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*\n         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*\n         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*\n         LR    R2,R4              R2 = R4                   *HMD 07/81*\n         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*\n         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*\n         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*\n         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*\n         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*\n         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*\n         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*\nUCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*\n         C     R5,UCMMCENT        IS THIS THE MASTER CON    *HMD 07/81*\n         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*\n         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*\n         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*\nUCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*\n         CR    R5,R7              END OF UCM'S?             *HMD 07/81*\n         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*\n         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*\n         SPACE 3\nINITDONE DS    0H                 CHECK OUT INPUT PARM\n         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*\n         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*\n         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?\n         BO    ONEPARM            YES; ONLY PARM\n         TM    4(R10),X'80'       IS SECOND THE LAST PARM?\n         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)\n***********************************************************************\n*                                                                     *\n*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *\n*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *\n*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *\n*                                                                     *\n***********************************************************************\n         XR    R2,R2              CLEAR R2\n         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER\n         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID\n         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK\n         L     R3,0(R10)          R3 = ADDR OF INPUT LINE\n         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT\n         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND\n         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING\n         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*\n         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*\n         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*\n         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*\n         BNH   LENOK              LENGTH IS OK              *HMD 07/81*\n         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*\nLENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC\n         EX    R2,MOVE1           MOVE CMD INTO CARD\n*************************************************************HMD 07/82*\n** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*\n** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*\n** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*\n**                                                          *HMD 07/82*\n** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*\n** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*\n** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*\n** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*\n** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*\n** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*\n** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*\n** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*\n** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*\n** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*\n** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*\n** DUMP.                                                    *HMD 07/82*\n**                                                          *HMD 07/82*\n** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*\n** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*\n** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*\n** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*\n*************************************************************HMD 07/82*\n         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*\n         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*\n         CLC   =C'start ',CARD    L         C               *HMD 07/82*\n         BE    STARTM               O          A            *HMD 07/82*\n         CLC   =C's ',CARD            W            S        *HMD 07/82*\n         BE    STARTM                   E             E     *HMD 07/82*\n         CLC   =C'mount ',CARD            R                 *HMD 07/82*\n         BE    STARTM                                       *HMD 07/82*\n         CLC   =C'm ',CARD                                  *HMD 07/82*\n         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*\nSTARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*\nDOCMD    B     DOSVC34            GO DO THE COMMAND\n***********************************************************************\n*                                                                     *\n*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *\n*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *\n*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *\n*     FROM', SO USE THAT FOR THE R0 MASK.                             *\n*                                                                     *\n***********************************************************************\nTWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34\n         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34\n***********************************************************************\n*                                                                     *\n*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *\n*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *\n*                                                                     *\n***********************************************************************\nONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS\n         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*\n         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH\n         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN\n         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*\n         BNH   CMDOK              NO, IS OK                 *HMD 07/81*\n         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*\nCMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE\n         EX    R3,MOVE            EXECUTE MVC\nDOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *\n*                                                                     *\n***********************************************************************\nUSESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*\nGETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST\n         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80\n         CLI   CARD,C'*'          IS THIS A COMMENT?\n         BE    GETSYSIN           YES;GO GET ANOTHER CARD\n         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\nEODSYSIN CLOSE (SYSIN)            CLOSE SYSIN\n         SPACE 3\nEOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA\n         RETURN (14,12),RC=0      RETURN TO CALLER\n         SPACE 3                                            *CKO 07/92*\nBADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*\n         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*\n         EJECT\n***********************************************************************\n*                                                                     *\n*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *\n*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *\n*                                                                     *\n***********************************************************************\nSVC34    DS    0H\n         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*\n         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*\nFINDTEXT DS    0H                 FIND LAST TEXT CHARACTER\n         CR    R3,R4              ALL BLANK?\n         BNH   SVC34END           YES - IGNORE IT\n         CLI   0(R3),C' '         BLANK CHARACTER?\n         BNE   GOTTEXT            NO - FOUND END OF TEXT\n         BCT   R3,FINDTEXT        KEEP ON LOOKING\n         SPACE\nGOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS\n         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*\n         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*\n         LA    R3,5(R3)           TEXT AND LIST PREFIX\n         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH\n         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*\n         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*\n         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*\n         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE\n* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW\n* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.\n* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.\n         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*\n         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*\nMODEOK   DS    0H                                           *HMD 07/82*\n*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n*        WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*\n         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n         WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MODESET KEY=ZERO         INDICATE KEY=ZERO\n         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*\n         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*\n         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n*                                 ARE WE USING SYSIN?       *HMD 07/81*\n         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*\n         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*\nNOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*\n         MODESET KEY=NZERO        GO BACK TO USER KEY\n         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*\n         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE\n* DONE ISSUING COMMANDS.\n         SPACE\nSVC34END DS    0H                 END OF COMMAND ROUTINE\n         BR    R11                RETURN TO MAINLINE\n         SPACE 2                                            *CKO 07/92*\nNOTAUTH  EQU  *                                             *CKO 07/92*\n         TPUT  =CL60'Authorization failed for executing COMMAND',60\n         B     BADEOJ                     Exit              *CKO 07/92*\n         EJECT\nSAVEAREA DC    18F'0'             OUR SAVEAREA\nHOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*\nR0MASK   DC    A(0)               R0 MASK FOR SVC34\nAUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*\nAUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*\nMOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*\nASID     DC    H'00'              OUR ASID\n* Parms for RACHECK                                         *CKO 07/92*\nCMDENT   DC    CL8'COMMAND'                                 *CKO 07/92*\nCMDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*\n         SPACE\n         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD\nCMDLIST  DC    AL2(*-*,0)         SVC 34 LIST\nCARD     DC    CL101' '           COMMAND TEXT\n         SPACE 3\nMOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST\nMOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST\n         EJECT\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *\n               EODAD=EODSYSIN\nMSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX\n               ND:',MF=L\nMSG2     WTO '                                                         X\n                                                          ',MF=L\nWTOCMD   EQU MSG2+4\n         EJECT\n         LTORG                    BEGIN LITERAL POOL\n         EJECT\n***********************************************************************\n*                                                                     *\n*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *\n*                                                                     *\n*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *\n*                                                                     *\n***********************************************************************\n         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE\n         EJECT\n         IHAASCB                  ADDRESS SPACE CONTROL BLOCK\n         EJECT\n         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*\n         EJECT                                              *HMD 07/81*\n         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*\n         END\n//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(COMMAND),DISP=SHR,UNIT=\n./ ADD NAME=STAGE1   0100-02365-02365-0941-00081-00081-00000-JMILLER\n//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM\n//*-------------------------------------------------------------------*\n//* ASSEMBLE STAGE 1 MACRO FOR RESCUE SYSTEM (OS/390)                 *\n//*-------------------------------------------------------------------*\n//ASM      EXEC  PGM=IEV90,PARM='DECK,NOOBJECT'\n//SYSLIB   DD  DSN=OS390.RESCUE,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(10,10))\n//SYSPUNCH DD  DSN=OS390.RESCUE(STAGE2),DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DATA,DLM=@@\n*---------------------------------------------------------------------*\n* S T A G E   1    S O U R C E    F O L L O W S:                      *\n*---------------------------------------------------------------------*\n* JOBCARD TO BE USED ON GENERATED JOBS                                *\n*---------------------------------------------------------------------*\n         @JOBCARD\n//EGTLJCM  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n*---------------------------------------------------------------------*\n* USER DEFINED DATASETS TO BE GENERATED ON NEW VOLUME                 *\n*---------------------------------------------------------------------*\n* LINK LIBRARIES\n*---------------------------------------------------------------------*\n  @DATASET CYL,0002,0001,050,C,SYS2.LINKLIB,RLSE,,(LNK,APF)\n  @DATASET CYL,0002,0000,050,C,SYSOSG.CSULOAD,RLSE,,(LNK,APF)\n*---------------------------------------------------------------------*\n* LPALST LIBRARIES\n*---------------------------------------------------------------------*\n  @DATASET CYL,0016,0001,150,C,TCPIP.SEZALPA,RLSE,,(LPA,APF)\n*---------------------------------------------------------------------*\n* IODEF LIBRARY (HCD)\n*---------------------------------------------------------------------*\n  @DATASET CYL,0000,0000,000,D,SYS1.IODF02.CLUSTER\n*---------------------------------------------------------------------*\n* OTHER LIBRARIES\n*---------------------------------------------------------------------*\n  @DATASET CYL,0001,0001,050,C,SYS3.CLIST,,,(SYSPROC)\n  @DATASET CYL,0002,0001,050,C,SYS2.PROCLIB,,,(JES2)\n  @DATASET CYL,0005,0001,075,C,SYS2.CSL.LOADLIB,,,(APF)\n  @DATASET CYL,0002,0001,050,C,SYSOSG.PROCLIB,,,(JES2)\n*---------------------------------------------------------------------*\n* MEMBERS TO BE COPIED                                                *\n*---------------------------------------------------------------------*\n*  PARMLIB  -\n  @COPY SRCLIB=OS390.RESCUE,TGTLIB=SYS1.PARMLIB\n  @COPY MEMBER=XXCOMMND,NEWMEM=COMMND00\n  @COPY MEMBER=XXIEASYS,NEWMEM=IEASYS00\n  @COPY MEMBER=XXIEFSSN,NEWMEM=IEFSSN00\n  @COPY MEMBER=XXIKJTSO,NEWMEM=IKJTSO00\n  @COPY MEMBER=XXJESPRM,NEWMEM=JESPRM00\n  @COPY MEMBER=XXLOAD00,NEWMEM=LOAD00\n  @COPY MEMBER=XXSMFPRM,NEWMEM=SMFPRM00\n  @COPY MEMBER=XXVATLST,NEWMEM=VATLST00\n*  VTAMLST\n  @COPY TGTLIB=CNM.VTAMLST\n  @COPY MEMBER=XXATCSTR,NEWMEM=ATCSTR00\n  @COPY MEMBER=XXATCCON,NEWMEM=ATCCON00\n*--------------------------------------------------------------------*\n* GENERATE JCL FOR TEST IPL SYSTEM                                   *\n*--------------------------------------------------------------------*\nGOFORIT @TSTVOL UADS=N,                                                X\n               RACF=Y,                                                 X\n               JOBS=ABCDEFG,                                           X\n               USR1=IBMUSER,                                           X\n               USR2=EGTLJCM,                                           X\n               USR3=EGTLKFT,                                           X\n               RACFDS=SYS1.RACFP1,                                     X\n               TAPEUNT=CART,                                           X\n               UNITADR=E4B,                                            X\n               DEVT=3380,                                              X\n               CATALOG=CATALOG.RESCUE,                                 X\n               VOLUME=RESCUE,                                          X\n               DUMP=N,                                                 X\n               WAIT=Y,                                                 X\n               MASTRCAT=CATALOG.CSU.MASTER,                            X\n               MCATVOL=CSUCAT,                                         X\n               STEPCAT=,                                               X\n               OWNER=RESCUE,                                           X\n               SYSRES=SYSRS3\n          END\n@@\n./ ADD NAME=STAGE2   0100-02365-02365-0941-02014-02014-00000-JMILLER\n//EGTLJCMA  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - A   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//* EXPORTD  \u00a6  DISCONNECTS TEST SYSTEM MASTER CATALOG\n//* OFFLINE  \u00a6  VARIES DEVICE E4B OFFLINE\n//* DSFINIT  \u00a6  INITIALIZES DASD VOLUME USING ICKDSF\n//*---------------------------------------------------------*\n//*    N O T E : : :\n//*    BE SURE THAT DEVICE E4B IS OFFLINE BEFORE THIS\n//*    JOB IS RELEASED.\n//*----------------------------------------------------------\n//EXPORTD  EXEC  PGM=IDCAMS,REGION=1M\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n   EXPORT CATALOG.RESCUE -\n          DISCONNECT\n   SET MAXCC=0\n/*\n//*---------------------------------------------------------*\n//* OFFLINE  \u00a6  VARY DEVICE E4B OFFLINE\n//*---------------------------------------------------------*\n//OFFLINE  EXEC PGM=COMMAND\n//SYSIN    DD *\nV E4B,OFFLINE\n/*\n//*---------------------------------------------------------*\n//* WAIT     \u00a6  WAIT 5 SECONDS FOR VARY TO COMPLETE\n//*---------------------------------------------------------*\n//WAIT     EXEC PGM=WAIT,PARM=5\n/*\n//*---------------------------------------------------------*\n//* DEALLOC \u00a6  START DUMMY DEALLOC TASK\n//*---------------------------------------------------------*\n//DEALLOC EXEC PGM=COMMAND\n//SYSIN    DD *\nS DEALLOC\n/*\n//*---------------------------------------------------------*\n//* WAIT     \u00a6  WAIT 5 SECONDS FOR DEALLOC TO COMPLETE\n//*---------------------------------------------------------*\n//WAIT     EXEC PGM=WAIT,PARM=5\n/*\n//*---------------------------------------------------------*\n//* DSFINIT  \u00a6  INITIALIZES DASD VOLUME USING ICKDSF\n//*---------------------------------------------------------*\n//DSFINIT  EXEC PGM=ICKDSF\n//IPLTEXT  DD DISP=SHR,VOL=SER=SYSRS3,UNIT=SYSDA,\n//            DSN=SYS1.SAMPLIB(IPLRECS)\n//         DD DISP=SHR,VOL=SER=SYSRS3,UNIT=SYSDA,\n//            DSN=SYS1.SAMPLIB(IEAIPL00)\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n INIT   UNIT(E4B) -\n        VOLID(RESCUE) -\n        OWNERID(RESCUE) -\n        VTOC(0,1,14) -\n        PURGE -\n        MAP -\n        NOVERIFY -\n        NOVALIDATE -\n        NOCHECK -\n        IPLDD(IPLTEXT) -\n        NOBOOTSTRAP\n/*\n//EGTLJCMB  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - B   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//* ONLINE   \u00a6  VARY DEVICE E4B ONLINE AND MOUNT RESCUE\n//* DEFMCAT  \u00a6  DELETE AND RECREATE VVDS\n//*          \u00a6  DEFINE TEST SYSTEM MASTER CATALOG\n//* DEFVSAM  \u00a6  DEFINE ALL VSAM DS NEEDED FOR IPL\n//* DEFNVSAM \u00a6  DEFINE ALL NON VSAM CATALOG ENTRIES\n//*---------------------------------------------------------*\n//* ONLINE   \u00a6  VARY DEVICE E4B ONLINE AND MOUNT RESCUE\n//*---------------------------------------------------------*\n//OFFLINE  EXEC PGM=COMMAND\n//SYSIN    DD *\nV E4B,ONLINE\nM E4B,VOL=(SL,RESCUE),USE=PRIVATE\n/*\n//*---------------------------------------------------------*\n//* DEFMCAT  \u00a6  DELETE AND RECREATE VVDS, DEFINE NEW MCAT\n//*---------------------------------------------------------*\n//DEFMCAT  EXEC PGM=IDCAMS,REGION=2M\n//SYSPRINT DD   SYSOUT=*\n//TARGET   DD   DISP=SHR,UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD   *\n DELETE -\n         SYS1.VVDS.VRESCUE -\n           FILE(TARGET)  -\n           CLUSTER -\n           PURGE -\n       CATALOG(CATALOG.CSU.MASTER)\n SET MAXCC=0\n\n DEFINE CLUSTER ( -\n           NAME(SYS1.VVDS.VRESCUE) -\n           CYL(1,1) -\n           VOL(RESCUE) -\n           FILE(TARGET) -\n           NONINDEXED -\n           OWNER(RESCUE) -\n         ) -\n       CATALOG(CATALOG.CSU.MASTER)\n\n DEFINE USERCATALOG   ( -\n           NAME(CATALOG.RESCUE) -\n           CYL(5 2) -\n           VOL(RESCUE) -\n           BUFFERSPACE(8192) -\n           BUFND(10) -\n           BUFNI(10) -\n           FILE(TARGET) -\n           ICFCATALOG -\n           OWNER(RESCUE) -\n           STRNO(9) -\n                      ) -\n       CATALOG(CATALOG.CSU.MASTER)\n/*\n//*---------------------------------------------------------*\n//* DEFVSAM  \u00a6  DEFINE VSAM DATASETS\n//*---------------------------------------------------------*\n//DEFVSAM  EXEC PGM=IDCAMS,REGION=2M,COND=(0,LT)\n//STEPCAT  DD  DSN=CATALOG.RESCUE,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//TARGET   DD  DISP=SHR,UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD   *\n  DEFINE CLUSTER ( -\n            NAME( SYS1.STGINDEX ) -\n            CYL(5) -\n            VOL(RESCUE) -\n            BUFFERSPACE(20480) -\n            FILE(TARGET) -\n            KEYS(12 8) -\n            OWNER(RESCUE) -\n            RECORDSIZE(2041,2041) -\n            REUSE ) -\n         DATA ( -\n            NAME( SYS1.STGINDEX.DATA ) -\n            CISZ(2048) ) -\n         INDEX ( -\n            NAME( SYS1.STGINDEX.INDEX ) -\n            CISZ(1024) ) -\n         CATALOG(CATALOG.RESCUE)\n\n DEFINE PAGESPACE ( -\n            NAME( PAGE.RESCUE.PLPA) -\n               CYL(150) -\n               VOL(RESCUE) -\n               FILE(TARGET) -\n               OWNER(RESCUE) -\n               NOSWAP -\n               UNIQUE ) -\n            CATALOG(CATALOG.RESCUE)\n\n DEFINE PAGESPACE ( -\n            NAME( PAGE.RESCUE.COMMON) -\n               CYL(150) -\n               VOL(RESCUE) -\n               FILE(TARGET) -\n               OWNER(RESCUE) -\n               NOSWAP -\n               UNIQUE ) -\n            CATALOG(CATALOG.RESCUE)\n\n DEFINE PAGESPACE ( -\n            NAME( PAGE.RESCUE.LOCAL1) -\n               CYL(150) -\n               VOL(RESCUE) -\n               FILE(TARGET) -\n               OWNER(RESCUE) -\n               NOSWAP -\n               UNIQUE ) -\n            CATALOG(CATALOG.RESCUE)\n\n DEFINE CLUSTER ( -\n            NAME( SYS1.MAN1 ) -\n               CYL(10) -\n               VOL(RESCUE) -\n               CISZ(4096) -\n               FILE(TARGET) -\n               NONINDEXED -\n               OWNER(RESCUE) -\n               RECORDSIZE(4086 32767) -\n               REUSE   SHR(2 3) -\n               SPANNED  SPEED ) -\n         DATA ( -\n                 NAME( SYS1.MAN1.VDATA) ) -\n         CATALOG(CATALOG.RESCUE)\n\n DEFINE CLUSTER ( -\n            NAME( SYS1.MAN2 ) -\n               CYL(10) -\n               VOL(RESCUE) -\n               CISZ(4096) -\n               FILE(TARGET) -\n               NONINDEXED -\n               OWNER(RESCUE) -\n               RECORDSIZE(4086 32767) -\n               REUSE   SHR(2 3) -\n               SPANNED  SPEED ) -\n         DATA ( -\n                 NAME( SYS1.MAN2.VDATA) ) -\n         CATALOG(CATALOG.RESCUE)\n\n IMPORT CONNECT -\n        OBJECTS( -\n        (CATALOG.CSU.MASTER  -\n        VOLUME(CSUCAT) -\n        DEVT(3380) )) -\n        CATALOG(CATALOG.RESCUE)\n\n/*\n//*---------------------------------------------------------*\n//* DEFNVSAM \u00a6  DEFINE NON VSAM CATALOG ENTRIES\n//*---------------------------------------------------------*\n//DEFNVSAM EXEC PGM=IDCAMS,REGION=3M,COND=(0,LT)\n//STEPCAT   DD  DSN=CATALOG.RESCUE,DISP=SHR\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS2.LINKLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYSOSG.CSULOAD) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.TCPIP.SEZALPA) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.IODF02.CLUSTER) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS3.CLIST) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS2.PROCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS2.CSL.LOADLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYSOSG.PROCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.CMDLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DAE) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HELP) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.IMAGELIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.CSSLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.LINKLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.V1R3M0.SHASLINK) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.LPALIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.MACLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.MIGLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.NUCLEUS) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.PARMLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.PROCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.SAMPLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.SVCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.UADS) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.BRODCAST) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HASPCKPT) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HASPACE) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.CPAC.LOGREC) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DUMP00) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DUMP01) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.RACFP1) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HRFCLST) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HRFMSG) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HRFPANL) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.HRFSKEL) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTLLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTMLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTPLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTSLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DGTTLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DUTLOAD) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.DUTPLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.HASPINDX) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFLINK) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFLOAD) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFLPA) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFMLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFPLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFTLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFSLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISF.SISFSRC) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPLPA) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPLOAD) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPMENU) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPPENU) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPSENU) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPSLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.ISP.SISPTENU) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.CNM.VTAMLST) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.CNM.VTAMLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.VTAMLST) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.VTAMLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.SYS1.SISTCLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.NCP5.LOADLIB) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.IBMUSER.ISPF.ISPPROF) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.EGTLJCM.ISPF.ISPPROF) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n DEFINE NONVSAM ( -\n    NAME(SYSX.EGTLKFT.ISPF.ISPPROF) -\n    OWNER(RESCUE) DEVT(3380) VOL(RESCUE)) -\n    CATALOG(CATALOG.RESCUE)\n//*\n//EGTLJCMC  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - C   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//*  ALLOC   \u00a6  ALLOCATES NONVSAM DATASETS\n//*  LOADNNN \u00a6  COPIES NONVSAM PDS DSNS\n//*  COPYNNN \u00a6  COPIES MEMBERS FROM SOURCE TO TARGET SYSTEM\n//*---------------------------------------------------------*\n//*  ALLOC -\n//*---------------------------------------------------------*\n//ALLOC   EXEC PGM=IEFBR14,REGION=4M\n//LINKLIB  DD DISP=(,KEEP),DSN=SYSX.SYS2.LINKLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS2.LINKLIB),\n//    SPACE=(CYL,(0002,0001,050),RLSE)\n//CSULOAD  DD DISP=(,KEEP),DSN=SYSX.SYSOSG.CSULOAD,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYSOSG.CSULOAD),\n//    SPACE=(CYL,(0002,0000,050),RLSE)\n//SEZALPA  DD DISP=(,KEEP),DSN=SYSX.TCPIP.SEZALPA,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(TCPIP.SEZALPA),\n//    SPACE=(CYL,(0016,0001,150),RLSE)\n//CLIST    DD DISP=(,KEEP),DSN=SYSX.SYS3.CLIST,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS3.CLIST),\n//    SPACE=(CYL,(0001,0001,050))\n//PROCLIB  DD DISP=(,KEEP),DSN=SYSX.SYS2.PROCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS2.PROCLIB),\n//    SPACE=(CYL,(0002,0001,050))\n//LOADLIB  DD DISP=(,KEEP),DSN=SYSX.SYS2.CSL.LOADLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS2.CSL.LOADLIB),\n//    SPACE=(CYL,(0005,0001,075))\n//PROCLIB  DD DISP=(,KEEP),DSN=SYSX.SYSOSG.PROCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYSOSG.PROCLIB),\n//    SPACE=(CYL,(0002,0001,050))\n//CMDLIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.CMDLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.CMDLIB),\n//    SPACE=(CYL,(0005,000,150))\n//DAE      DD DISP=(,KEEP),DSN=SYSX.SYS1.DAE,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DAE),\n//    SPACE=(CYL,(0001,000,000))\n//HELP     DD DISP=(,KEEP),DSN=SYSX.SYS1.HELP,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HELP),\n//    SPACE=(CYL,(0008,001,150))\n//IMAGELIB DD DISP=(,KEEP),DSN=SYSX.SYS1.IMAGELIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.IMAGELIB),\n//    SPACE=(CYL,(0002,000,150))\n//CSSLIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.CSSLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.CSSLIB),\n//    SPACE=(CYL,(0005,001,150),RLSE)\n//LINKLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.LINKLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.LINKLIB),\n//    SPACE=(CYL,(0200,000,650),RLSE)\n//SHASLINK DD DISP=(,KEEP),DSN=SYSX.SYS1.V1R3M0.SHASLINK,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.V1R3M0.SHASLINK),\n//    SPACE=(CYL,(0010,001,025))\n//LPALIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.LPALIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.LPALIB),\n//    SPACE=(CYL,(0090,000,550),RLSE)\n//MACLIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.MACLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.MACLIB),\n//    SPACE=(CYL,(0140,005,350),RLSE)\n//MIGLIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.MIGLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.MIGLIB),\n//    SPACE=(CYL,(0020,001,250),RLSE)\n//NUCLEUS  DD DISP=(,KEEP),DSN=SYSX.SYS1.NUCLEUS,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.NUCLEUS),\n//    SPACE=(CYL,(0040,000,250))\n//PARMLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.PARMLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.PARMLIB),\n//    SPACE=(CYL,(0002,000,050))\n//PROCLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.PROCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.PROCLIB),\n//    SPACE=(CYL,(0002,001,150))\n//SAMPLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.SAMPLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.SAMPLIB),\n//    SPACE=(CYL,(0050,001,250))\n//SVCLIB   DD DISP=(,KEEP),DSN=SYSX.SYS1.SVCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.SVCLIB),\n//    SPACE=(CYL,(0002,001,150))\n//UADS     DD DISP=(,KEEP),DSN=SYSX.SYS1.UADS,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.UADS),\n//    SPACE=(CYL,(0002,001,150))\n//BRODCAST DD DISP=(,KEEP),DSN=SYSX.SYS1.BRODCAST,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.BRODCAST),\n//    SPACE=(CYL,(0003,000,000))\n//HASPCKPT DD DISP=(,KEEP),DSN=SYSX.SYS1.HASPCKPT,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HASPCKPT),\n//    SPACE=(CYL,(0003,000,000))\n//HASPACE  DD DISP=(,KEEP),DSN=SYSX.SYS1.HASPACE,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HASPACE),\n//    SPACE=(CYL,(0060,000,000))\n//LOGREC   DD DISP=(,KEEP),DSN=SYSX.SYS1.CPAC.LOGREC,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.CPAC.LOGREC),\n//    SPACE=(CYL,(0010,000,000))\n//DUMP00   DD DISP=(,KEEP),DSN=SYSX.SYS1.DUMP00,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DUMP00),\n//    SPACE=(CYL,(0060,000,000))\n//DUMP01   DD DISP=(,KEEP),DSN=SYSX.SYS1.DUMP01,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DUMP01),\n//    SPACE=(CYL,(0060,000,000))\n//RACFP1   DD DISP=(,KEEP),DSN=SYSX.SYS1.RACFP1,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.RACFP1),\n//    SPACE=(CYL,(0010,000,000))\n//HRFCLST  DD DISP=(,KEEP),DSN=SYSX.SYS1.HRFCLST,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HRFCLST),\n//    SPACE=(CYL,(0002,001,150))\n//HRFMSG   DD DISP=(,KEEP),DSN=SYSX.SYS1.HRFMSG,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HRFMSG),\n//    SPACE=(CYL,(0002,001,150))\n//HRFPANL  DD DISP=(,KEEP),DSN=SYSX.SYS1.HRFPANL,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HRFPANL),\n//    SPACE=(CYL,(0002,001,150))\n//HRFSKEL  DD DISP=(,KEEP),DSN=SYSX.SYS1.HRFSKEL,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.HRFSKEL),\n//    SPACE=(CYL,(0002,001,150))\n//DGTCLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTCLIB),\n//    SPACE=(CYL,(0001,001,095))\n//DGTLLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTLLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTLLIB),\n//    SPACE=(CYL,(0010,001,095))\n//DGTMLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTMLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTMLIB),\n//    SPACE=(CYL,(0002,001,095))\n//DGTPLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTPLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTPLIB),\n//    SPACE=(CYL,(0033,001,350))\n//DGTSLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTSLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTSLIB),\n//    SPACE=(CYL,(0002,001,095))\n//DGTTLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DGTTLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DGTTLIB),\n//    SPACE=(CYL,(0001,001,095))\n//DUTLOAD  DD DISP=(,KEEP),DSN=SYSX.SYS1.DUTLOAD,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DUTLOAD),\n//    SPACE=(CYL,(0002,001,095))\n//DUTPLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.DUTPLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.DUTPLIB),\n//    SPACE=(CYL,(0003,001,095))\n//HASPINDX DD DISP=(,KEEP),DSN=SYSX.ISF.HASPINDX,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.HASPINDX),\n//    SPACE=(CYL,(0001,000,000))\n//SISFLINK DD DISP=(,KEEP),DSN=SYSX.ISF.SISFLINK,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFLINK),\n//    SPACE=(CYL,(0001,001,150))\n//SISFLOAD DD DISP=(,KEEP),DSN=SYSX.ISF.SISFLOAD,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFLOAD),\n//    SPACE=(CYL,(0005,001,050))\n//SISFLPA  DD DISP=(,KEEP),DSN=SYSX.ISF.SISFLPA,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFLPA),\n//    SPACE=(CYL,(0001,001,025))\n//SISFMLIB DD DISP=(,KEEP),DSN=SYSX.ISF.SISFMLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFMLIB),\n//    SPACE=(CYL,(0001,001,150))\n//SISFPLIB DD DISP=(,KEEP),DSN=SYSX.ISF.SISFPLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFPLIB),\n//    SPACE=(CYL,(0002,001,150))\n//SISFTLIB DD DISP=(,KEEP),DSN=SYSX.ISF.SISFTLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFTLIB),\n//    SPACE=(CYL,(0001,001,150))\n//SISFSLIB DD DISP=(,KEEP),DSN=SYSX.ISF.SISFSLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFSLIB),\n//    SPACE=(CYL,(0001,001,150))\n//SISFSRC  DD DISP=(,KEEP),DSN=SYSX.ISF.SISFSRC,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISF.SISFSRC),\n//    SPACE=(CYL,(0015,001,150))\n//SISPLPA  DD DISP=(,KEEP),DSN=SYSX.ISP.SISPLPA,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPLPA),\n//    SPACE=(CYL,(0035,0001,075))\n//SISPLOAD DD DISP=(,KEEP),DSN=SYSX.ISP.SISPLOAD,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPLOAD),\n//    SPACE=(CYL,(0008,0001,075))\n//SISPMENU DD DISP=(,KEEP),DSN=SYSX.ISP.SISPMENU,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPMENU),\n//    SPACE=(CYL,(0003,0001,150))\n//SISPPENU DD DISP=(,KEEP),DSN=SYSX.ISP.SISPPENU,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPPENU),\n//    SPACE=(CYL,(0025,0001,200))\n//SISPSENU DD DISP=(,KEEP),DSN=SYSX.ISP.SISPSENU,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPSENU),\n//    SPACE=(CYL,(0006,0001,125))\n//SISPSLIB DD DISP=(,KEEP),DSN=SYSX.ISP.SISPSLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPSLIB),\n//    SPACE=(CYL,(0002,0001,125))\n//SISPTENU DD DISP=(,KEEP),DSN=SYSX.ISP.SISPTENU,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(ISP.SISPTENU),\n//    SPACE=(CYL,(0001,0001,125))\n//VTAMLST  DD DISP=(,KEEP),DSN=SYSX.CNM.VTAMLST,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(CNM.VTAMLST),\n//    SPACE=(CYL,(0001,0001,125))\n//VTAMLIB  DD DISP=(,KEEP),DSN=SYSX.CNM.VTAMLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(CNM.VTAMLIB),\n//    SPACE=(CYL,(0001,0001,125))\n//VTAMLST  DD DISP=(,KEEP),DSN=SYSX.SYS1.VTAMLST,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.VTAMLST),\n//    SPACE=(CYL,(0005,0001,125))\n//VTAMLIB  DD DISP=(,KEEP),DSN=SYSX.SYS1.VTAMLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.VTAMLIB),\n//    SPACE=(CYL,(0005,0001,125))\n//SISTCLIB DD DISP=(,KEEP),DSN=SYSX.SYS1.SISTCLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(SYS1.SISTCLIB),\n//    SPACE=(CYL,(0050,0001,125))\n//LOADLIB  DD DISP=(,KEEP),DSN=SYSX.NCP5.LOADLIB,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(NCP5.LOADLIB),\n//    SPACE=(CYL,(0007,0001,125))\n//ISPPROF  DD DISP=(,KEEP),DSN=SYSX.IBMUSER.ISPF.ISPPROF,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(IBMUSER.ISPF.ISPPROF),\n//    SPACE=(CYL,(0001,0000,050))\n//ISPPROF  DD DISP=(,KEEP),DSN=SYSX.EGTLJCM.ISPF.ISPPROF,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(EGTLJCM.ISPF.ISPPROF),\n//    SPACE=(CYL,(0001,0000,050))\n//ISPPROF  DD DISP=(,KEEP),DSN=SYSX.EGTLKFT.ISPF.ISPPROF,\n//    UNIT=3380,VOL=SER=RESCUE,DCB=(EGTLKFT.ISPF.ISPPROF),\n//    SPACE=(CYL,(0001,0000,050))\n//*---------------------------------------------------------*\n//*  LOAD001 - IEBCOPY SYS2.LINKLIB\n//*---------------------------------------------------------*\n//LOAD001 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ILINKLIB  DD DISP=SHR,DSN=SYS2.LINKLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OLINKLIB  DD DISP=SHR,DSN=SYSX.SYS2.LINKLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ILINKLIB,O=OLINKLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD002 - IEBCOPY SYSOSG.CSULOAD\n//*---------------------------------------------------------*\n//LOAD002 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ICSULOAD  DD DISP=SHR,DSN=SYSOSG.CSULOAD,\n//          UNIT=SYSALLDA,VOL=SER=\n//OCSULOAD  DD DISP=SHR,DSN=SYSX.SYSOSG.CSULOAD,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ICSULOAD,O=OCSULOAD,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD003 - IEBCOPY TCPIP.SEZALPA\n//*---------------------------------------------------------*\n//LOAD003 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISEZALPA  DD DISP=SHR,DSN=TCPIP.SEZALPA,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSEZALPA  DD DISP=SHR,DSN=SYSX.TCPIP.SEZALPA,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISEZALPA,O=OSEZALPA,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD004 - DFDSS SYS1.IODF02.CLUSTER\n//*---------------------------------------------------------*\n//LOAD004 EXEC PGM=ADRDSSU,REGION=4M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n  COPY -\n  DATASET( -\n     INCLUDE( -\n        SYS1.IODF02.CLUSTER -\n            ) ) -\n  REPLACE    -\n  ALLDATA(*) -\n  TOL(ENQF) -\n  PROCESS(SYS1)  -\n  RECATALOG(CATALOG.RESCUE) -\n  OUTDYNAM(RESCUE)  -\n  SHARE\n//*\n//*---------------------------------------------------------*\n//*  LOAD005 - IEBCOPY SYS3.CLIST\n//*---------------------------------------------------------*\n//LOAD005 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ICLIST    DD DISP=SHR,DSN=SYS3.CLIST,\n//          UNIT=SYSALLDA,VOL=SER=\n//OCLIST    DD DISP=SHR,DSN=SYSX.SYS3.CLIST,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ICLIST,O=OCLIST,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD006 - IEBCOPY SYS2.PROCLIB\n//*---------------------------------------------------------*\n//LOAD006 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IPROCLIB  DD DISP=SHR,DSN=SYS2.PROCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OPROCLIB  DD DISP=SHR,DSN=SYSX.SYS2.PROCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IPROCLIB,O=OPROCLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD007 - IEBCOPY SYS2.CSL.LOADLIB\n//*---------------------------------------------------------*\n//LOAD007 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ILOADLIB  DD DISP=SHR,DSN=SYS2.CSL.LOADLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OLOADLIB  DD DISP=SHR,DSN=SYSX.SYS2.CSL.LOADLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ILOADLIB,O=OLOADLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD008 - IEBCOPY SYSOSG.PROCLIB\n//*---------------------------------------------------------*\n//LOAD008 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IPROCLIB  DD DISP=SHR,DSN=SYSOSG.PROCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OPROCLIB  DD DISP=SHR,DSN=SYSX.SYSOSG.PROCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IPROCLIB,O=OPROCLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD009 - IEBCOPY SYS1.CMDLIB\n//*---------------------------------------------------------*\n//LOAD009 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ICMDLIB   DD DISP=SHR,DSN=SYS1.CMDLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OCMDLIB   DD DISP=SHR,DSN=SYSX.SYS1.CMDLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ICMDLIB,O=OCMDLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD010 - ICEGENER SYS1.DAE\n//*---------------------------------------------------------*\n//LOAD010 EXEC PGM=ICEGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DISP=SHR,DSN=SYS1.DAE,\n//          UNIT=SYSALLDA,VOL=SER=\n//SYSUT2    DD DISP=SHR,DSN=SYSX.SYS1.DAE,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN     DD DUMMY\n//*\n//*---------------------------------------------------------*\n//*  LOAD011 - IEBCOPY SYS1.HELP\n//*---------------------------------------------------------*\n//LOAD011 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IHELP     DD DISP=SHR,DSN=SYS1.HELP,\n//          UNIT=SYSALLDA,VOL=SER=\n//OHELP     DD DISP=SHR,DSN=SYSX.SYS1.HELP,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IHELP,O=OHELP,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD012 - IEBCOPY SYS1.IMAGELIB\n//*---------------------------------------------------------*\n//LOAD012 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IIMAGELI  DD DISP=SHR,DSN=SYS1.IMAGELIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OIMAGELI  DD DISP=SHR,DSN=SYSX.SYS1.IMAGELIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IIMAGELI,O=OIMAGELI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD013 - IEBCOPY SYS1.CSSLIB\n//*---------------------------------------------------------*\n//LOAD013 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ICSSLIB   DD DISP=SHR,DSN=SYS1.CSSLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OCSSLIB   DD DISP=SHR,DSN=SYSX.SYS1.CSSLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ICSSLIB,O=OCSSLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD014 - IEBCOPY SYS1.LINKLIB\n//*---------------------------------------------------------*\n//LOAD014 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ILINKLIB  DD DISP=SHR,DSN=SYS1.LINKLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OLINKLIB  DD DISP=SHR,DSN=SYSX.SYS1.LINKLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ILINKLIB,O=OLINKLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD015 - IEBCOPY SYS1.V1R3M0.SHASLINK\n//*---------------------------------------------------------*\n//LOAD015 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISHASLIN  DD DISP=SHR,DSN=SYS1.V1R3M0.SHASLINK,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSHASLIN  DD DISP=SHR,DSN=SYSX.SYS1.V1R3M0.SHASLINK,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISHASLIN,O=OSHASLIN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD016 - IEBCOPY SYS1.LPALIB\n//*---------------------------------------------------------*\n//LOAD016 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ILPALIB   DD DISP=SHR,DSN=SYS1.LPALIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OLPALIB   DD DISP=SHR,DSN=SYSX.SYS1.LPALIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ILPALIB,O=OLPALIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD017 - IEBCOPY SYS1.MACLIB\n//*---------------------------------------------------------*\n//LOAD017 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IMACLIB   DD DISP=SHR,DSN=SYS1.MACLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OMACLIB   DD DISP=SHR,DSN=SYSX.SYS1.MACLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IMACLIB,O=OMACLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD018 - IEBCOPY SYS1.MIGLIB\n//*---------------------------------------------------------*\n//LOAD018 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IMIGLIB   DD DISP=SHR,DSN=SYS1.MIGLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OMIGLIB   DD DISP=SHR,DSN=SYSX.SYS1.MIGLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IMIGLIB,O=OMIGLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD019 - IEBCOPY SYS1.NUCLEUS\n//*---------------------------------------------------------*\n//LOAD019 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//INUCLEUS  DD DISP=SHR,DSN=SYS1.NUCLEUS,\n//          UNIT=SYSALLDA,VOL=SER=\n//ONUCLEUS  DD DISP=SHR,DSN=SYSX.SYS1.NUCLEUS,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=INUCLEUS,O=ONUCLEUS,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD020 - IEBCOPY SYS1.PARMLIB\n//*---------------------------------------------------------*\n//LOAD020 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IPARMLIB  DD DISP=SHR,DSN=SYS1.PARMLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OPARMLIB  DD DISP=SHR,DSN=SYSX.SYS1.PARMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IPARMLIB,O=OPARMLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD021 - IEBCOPY SYS1.PROCLIB\n//*---------------------------------------------------------*\n//LOAD021 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IPROCLIB  DD DISP=SHR,DSN=SYS1.PROCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OPROCLIB  DD DISP=SHR,DSN=SYSX.SYS1.PROCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IPROCLIB,O=OPROCLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD022 - IEBCOPY SYS1.SAMPLIB\n//*---------------------------------------------------------*\n//LOAD022 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISAMPLIB  DD DISP=SHR,DSN=SYS1.SAMPLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSAMPLIB  DD DISP=SHR,DSN=SYSX.SYS1.SAMPLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISAMPLIB,O=OSAMPLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD023 - IEBCOPY SYS1.SVCLIB\n//*---------------------------------------------------------*\n//LOAD023 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISVCLIB   DD DISP=SHR,DSN=SYS1.SVCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSVCLIB   DD DISP=SHR,DSN=SYSX.SYS1.SVCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISVCLIB,O=OSVCLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD024 - IEBCOPY SYS1.UADS\n//*---------------------------------------------------------*\n//LOAD024 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IUADS     DD DISP=SHR,DSN=SYS1.UADS,\n//          UNIT=SYSALLDA,VOL=SER=\n//OUADS     DD DISP=SHR,DSN=SYSX.SYS1.UADS,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IUADS,O=OUADS,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD032 - IEBCOPY SYS1.HRFCLST\n//*---------------------------------------------------------*\n//LOAD032 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IHRFCLST  DD DISP=SHR,DSN=SYS1.HRFCLST,\n//          UNIT=SYSALLDA,VOL=SER=\n//OHRFCLST  DD DISP=SHR,DSN=SYSX.SYS1.HRFCLST,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IHRFCLST,O=OHRFCLST,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD033 - IEBCOPY SYS1.HRFMSG\n//*---------------------------------------------------------*\n//LOAD033 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IHRFMSG   DD DISP=SHR,DSN=SYS1.HRFMSG,\n//          UNIT=SYSALLDA,VOL=SER=\n//OHRFMSG   DD DISP=SHR,DSN=SYSX.SYS1.HRFMSG,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IHRFMSG,O=OHRFMSG,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD034 - IEBCOPY SYS1.HRFPANL\n//*---------------------------------------------------------*\n//LOAD034 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IHRFPANL  DD DISP=SHR,DSN=SYS1.HRFPANL,\n//          UNIT=SYSALLDA,VOL=SER=\n//OHRFPANL  DD DISP=SHR,DSN=SYSX.SYS1.HRFPANL,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IHRFPANL,O=OHRFPANL,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD035 - IEBCOPY SYS1.HRFSKEL\n//*---------------------------------------------------------*\n//LOAD035 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IHRFSKEL  DD DISP=SHR,DSN=SYS1.HRFSKEL,\n//          UNIT=SYSALLDA,VOL=SER=\n//OHRFSKEL  DD DISP=SHR,DSN=SYSX.SYS1.HRFSKEL,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IHRFSKEL,O=OHRFSKEL,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD036 - IEBCOPY SYS1.DGTCLIB\n//*---------------------------------------------------------*\n//LOAD036 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTCLIB  DD DISP=SHR,DSN=SYS1.DGTCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTCLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTCLIB,O=ODGTCLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD037 - IEBCOPY SYS1.DGTLLIB\n//*---------------------------------------------------------*\n//LOAD037 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTLLIB  DD DISP=SHR,DSN=SYS1.DGTLLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTLLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTLLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTLLIB,O=ODGTLLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD038 - IEBCOPY SYS1.DGTMLIB\n//*---------------------------------------------------------*\n//LOAD038 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTMLIB  DD DISP=SHR,DSN=SYS1.DGTMLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTMLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTMLIB,O=ODGTMLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD039 - IEBCOPY SYS1.DGTPLIB\n//*---------------------------------------------------------*\n//LOAD039 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTPLIB  DD DISP=SHR,DSN=SYS1.DGTPLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTPLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTPLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTPLIB,O=ODGTPLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD040 - IEBCOPY SYS1.DGTSLIB\n//*---------------------------------------------------------*\n//LOAD040 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTSLIB  DD DISP=SHR,DSN=SYS1.DGTSLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTSLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTSLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTSLIB,O=ODGTSLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD041 - IEBCOPY SYS1.DGTTLIB\n//*---------------------------------------------------------*\n//LOAD041 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDGTTLIB  DD DISP=SHR,DSN=SYS1.DGTTLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODGTTLIB  DD DISP=SHR,DSN=SYSX.SYS1.DGTTLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDGTTLIB,O=ODGTTLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD042 - IEBCOPY SYS1.DUTLOAD\n//*---------------------------------------------------------*\n//LOAD042 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDUTLOAD  DD DISP=SHR,DSN=SYS1.DUTLOAD,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODUTLOAD  DD DISP=SHR,DSN=SYSX.SYS1.DUTLOAD,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDUTLOAD,O=ODUTLOAD,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD043 - IEBCOPY SYS1.DUTPLIB\n//*---------------------------------------------------------*\n//LOAD043 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IDUTPLIB  DD DISP=SHR,DSN=SYS1.DUTPLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//ODUTPLIB  DD DISP=SHR,DSN=SYSX.SYS1.DUTPLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IDUTPLIB,O=ODUTPLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD045 - IEBCOPY ISF.SISFLINK\n//*---------------------------------------------------------*\n//LOAD045 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFLIN  DD DISP=SHR,DSN=ISF.SISFLINK,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFLIN  DD DISP=SHR,DSN=SYSX.ISF.SISFLINK,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFLIN,O=OSISFLIN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD046 - IEBCOPY ISF.SISFLOAD\n//*---------------------------------------------------------*\n//LOAD046 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFLOA  DD DISP=SHR,DSN=ISF.SISFLOAD,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFLOA  DD DISP=SHR,DSN=SYSX.ISF.SISFLOAD,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFLOA,O=OSISFLOA,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD047 - IEBCOPY ISF.SISFLPA\n//*---------------------------------------------------------*\n//LOAD047 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFLPA  DD DISP=SHR,DSN=ISF.SISFLPA,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFLPA  DD DISP=SHR,DSN=SYSX.ISF.SISFLPA,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFLPA,O=OSISFLPA,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD048 - IEBCOPY ISF.SISFMLIB\n//*---------------------------------------------------------*\n//LOAD048 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFMLI  DD DISP=SHR,DSN=ISF.SISFMLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFMLI  DD DISP=SHR,DSN=SYSX.ISF.SISFMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFMLI,O=OSISFMLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD049 - IEBCOPY ISF.SISFPLIB\n//*---------------------------------------------------------*\n//LOAD049 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFPLI  DD DISP=SHR,DSN=ISF.SISFPLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFPLI  DD DISP=SHR,DSN=SYSX.ISF.SISFPLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFPLI,O=OSISFPLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD050 - IEBCOPY ISF.SISFTLIB\n//*---------------------------------------------------------*\n//LOAD050 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFTLI  DD DISP=SHR,DSN=ISF.SISFTLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFTLI  DD DISP=SHR,DSN=SYSX.ISF.SISFTLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFTLI,O=OSISFTLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD051 - IEBCOPY ISF.SISFSLIB\n//*---------------------------------------------------------*\n//LOAD051 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFSLI  DD DISP=SHR,DSN=ISF.SISFSLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFSLI  DD DISP=SHR,DSN=SYSX.ISF.SISFSLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFSLI,O=OSISFSLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD052 - IEBCOPY ISF.SISFSRC\n//*---------------------------------------------------------*\n//LOAD052 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISFSRC  DD DISP=SHR,DSN=ISF.SISFSRC,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISFSRC  DD DISP=SHR,DSN=SYSX.ISF.SISFSRC,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISFSRC,O=OSISFSRC,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD053 - IEBCOPY ISP.SISPLPA\n//*---------------------------------------------------------*\n//LOAD053 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPLPA  DD DISP=SHR,DSN=ISP.SISPLPA,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPLPA  DD DISP=SHR,DSN=SYSX.ISP.SISPLPA,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPLPA,O=OSISPLPA,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD054 - IEBCOPY ISP.SISPLOAD\n//*---------------------------------------------------------*\n//LOAD054 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPLOA  DD DISP=SHR,DSN=ISP.SISPLOAD,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPLOA  DD DISP=SHR,DSN=SYSX.ISP.SISPLOAD,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPLOA,O=OSISPLOA,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD055 - IEBCOPY ISP.SISPMENU\n//*---------------------------------------------------------*\n//LOAD055 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPMEN  DD DISP=SHR,DSN=ISP.SISPMENU,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPMEN  DD DISP=SHR,DSN=SYSX.ISP.SISPMENU,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPMEN,O=OSISPMEN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD056 - IEBCOPY ISP.SISPPENU\n//*---------------------------------------------------------*\n//LOAD056 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPPEN  DD DISP=SHR,DSN=ISP.SISPPENU,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPPEN  DD DISP=SHR,DSN=SYSX.ISP.SISPPENU,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPPEN,O=OSISPPEN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD057 - IEBCOPY ISP.SISPSENU\n//*---------------------------------------------------------*\n//LOAD057 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPSEN  DD DISP=SHR,DSN=ISP.SISPSENU,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPSEN  DD DISP=SHR,DSN=SYSX.ISP.SISPSENU,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPSEN,O=OSISPSEN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD058 - IEBCOPY ISP.SISPSLIB\n//*---------------------------------------------------------*\n//LOAD058 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPSLI  DD DISP=SHR,DSN=ISP.SISPSLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPSLI  DD DISP=SHR,DSN=SYSX.ISP.SISPSLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPSLI,O=OSISPSLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD059 - IEBCOPY ISP.SISPTENU\n//*---------------------------------------------------------*\n//LOAD059 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISPTEN  DD DISP=SHR,DSN=ISP.SISPTENU,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISPTEN  DD DISP=SHR,DSN=SYSX.ISP.SISPTENU,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISPTEN,O=OSISPTEN,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD060 - IEBCOPY CNM.VTAMLST\n//*---------------------------------------------------------*\n//LOAD060 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IVTAMLST  DD DISP=SHR,DSN=CNM.VTAMLST,\n//          UNIT=SYSALLDA,VOL=SER=\n//OVTAMLST  DD DISP=SHR,DSN=SYSX.CNM.VTAMLST,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IVTAMLST,O=OVTAMLST,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD061 - IEBCOPY CNM.VTAMLIB\n//*---------------------------------------------------------*\n//LOAD061 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IVTAMLIB  DD DISP=SHR,DSN=CNM.VTAMLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OVTAMLIB  DD DISP=SHR,DSN=SYSX.CNM.VTAMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IVTAMLIB,O=OVTAMLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD062 - IEBCOPY SYS1.VTAMLST\n//*---------------------------------------------------------*\n//LOAD062 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IVTAMLST  DD DISP=SHR,DSN=SYS1.VTAMLST,\n//          UNIT=SYSALLDA,VOL=SER=\n//OVTAMLST  DD DISP=SHR,DSN=SYSX.SYS1.VTAMLST,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IVTAMLST,O=OVTAMLST,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD063 - IEBCOPY SYS1.VTAMLIB\n//*---------------------------------------------------------*\n//LOAD063 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//IVTAMLIB  DD DISP=SHR,DSN=SYS1.VTAMLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OVTAMLIB  DD DISP=SHR,DSN=SYSX.SYS1.VTAMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=IVTAMLIB,O=OVTAMLIB,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD064 - IEBCOPY SYS1.SISTCLIB\n//*---------------------------------------------------------*\n//LOAD064 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ISISTCLI  DD DISP=SHR,DSN=SYS1.SISTCLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OSISTCLI  DD DISP=SHR,DSN=SYSX.SYS1.SISTCLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ISISTCLI,O=OSISTCLI,LIST=NO\n//*\n//*---------------------------------------------------------*\n//*  LOAD065 - IEBCOPY NCP5.LOADLIB\n//*---------------------------------------------------------*\n//LOAD065 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//ILOADLIB  DD DISP=SHR,DSN=NCP5.LOADLIB,\n//          UNIT=SYSALLDA,VOL=SER=\n//OLOADLIB  DD DISP=SHR,DSN=SYSX.NCP5.LOADLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=ILOADLIB,O=OLOADLIB,LIST=NO\n//*\n//*\n//*---------------------------------------------------------*\n//*  COPY001 - COPY MEMBERS\n//*---------------------------------------------------------*\n//COPY001 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//INDD      DD DISP=SHR,DSN=OS390.RESCUE\n//OUTDD     DD DISP=SHR,DSN=SYSX.SYS1.PARMLIB,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=INDD,O=OUTDD,LIST=NO\n  SELECT MEMBER=((XXCOMMND,COMMND00,R))\n  SELECT MEMBER=((XXIEASYS,IEASYS00,R))\n  SELECT MEMBER=((XXIEFSSN,IEFSSN00,R))\n  SELECT MEMBER=((XXIKJTSO,IKJTSO00,R))\n  SELECT MEMBER=((XXJESPRM,JESPRM00,R))\n  SELECT MEMBER=((XXLOAD00,LOAD00,R))\n  SELECT MEMBER=((XXSMFPRM,SMFPRM00,R))\n  SELECT MEMBER=((XXVATLST,VATLST00,R))\n//*\n//*---------------------------------------------------------*\n//*  COPY002 - COPY MEMBERS\n//*---------------------------------------------------------*\n//COPY002 EXEC PGM=IEBCOPY,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//SYSUT4    DD UNIT=SYSDA,SPACE=(CYL,(75,2))\n//INDD      DD DISP=SHR,DSN=OS390.RESCUE\n//OUTDD     DD DISP=SHR,DSN=SYSX.CNM.VTAMLST,\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n   COPY I=INDD,O=OUTDD,LIST=NO\n  SELECT MEMBER=((XXATCSTR,ATCSTR00,R))\n  SELECT MEMBER=((XXATCCON,ATCCON00,R))\n//EGTLJCMD  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - D   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//* LOGREC   \u00a6  INITIALIZES SYS1.CPAC.LOGREC\n//* DMPINT0  \u00a6  INITIALIZES DUMP DATASETS\n//* DMPINT1  \u00a6  INITIALIZES DUMP DATASETS\n//* ICHCOPY  \u00a6  COPIES RACF DATASET USING IRRUT200\n//* FMTSMF   \u00a6  FORMAT SMF DATASETS\n//* CATPRT   \u00a6  PRINT MASTER CATALOG POINTER\n//*---------------------------------------------------------*\n//*\n//*---------------------------------------------------------*\n//* LOGREC   \u00a6  INITIALIZES SYS1.CPAC.LOGREC\n//*---------------------------------------------------------*\n//LOGREC   EXEC PGM=IFCDIP00\n//SERERDS  DD DISP=SHR,DSN=SYSX.SYS1.CPAC.LOGREC,\n//         UNIT=3380,VOL=SER=RESCUE\n//*\n//*-----------------------------------------------------\n//* SYNC UADS / BRODCAST DATASETS\n//*-----------------------------------------------------\n//USYNC    EXEC PGM=IKJEFT01,\n//         DYNAMNBR=15,\n//         REGION=2M\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUADS  DD DISP=SHR,DSN=SYSX.SYS1.UADS,\n//         UNIT=3380,VOL=SER=RESCUE\n//SYSLBC   DD DISP=SHR,DSN=SYSX.SYS1.BRODCAST,\n//         UNIT=3380,VOL=SER=RESCUE\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n  ACCOUNT\n  SYNC\n  END\n//*\n//*\n//*-----------------------------------------------------\n//* INITIALIZE DUMP DATASETS\n//*-----------------------------------------------------\n//DMPINT0 EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DUMMY,DCB=SYS1.DUMP00\n//SYSUT2   DD DSN=SYSX.SYS1.DUMP00,DISP=SHR,\n//         UNIT=3380,VOL=SER=RESCUE\n//*\n//DMPINT1 EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DUMMY,DCB=SYS1.DUMP01\n//SYSUT2   DD DSN=SYSX.SYS1.DUMP01,DISP=SHR,\n//         UNIT=3380,VOL=SER=RESCUE\n//*\n//*-----------------------------------------------------\n//* COPY THE RACF DATASET USING IRRUT200\n//*-----------------------------------------------------\n//ICHCOPY  EXEC PGM=IRRUT200\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD SYSOUT=*\n//SYSRACF  DD DSN=SYS1.RACFP1,DISP=SHR\n//SYSUT1   DD DSN=SYSX.SYS1.RACFP1,DISP=OLD,\n// UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n  INDEX\n  MAP\n  END\n//*\n//*-----------------------------------------------------\n//* FORMAT THE SMF DATASETS\n//*-----------------------------------------------------\n//FMTSMF EXEC PGM=IFASMFDP,REGION=2M\n//STEPCAT  DD DSN=CATALOG.RESCUE,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//FMAN1    DD DSN=SYS1.MAN1,DISP=SHR,\n//         UNIT=3380,VOL=SER=RESCUE\n//FMAN2    DD DSN=SYS1.MAN2,DISP=SHR,\n//         UNIT=3380,VOL=SER=RESCUE\n//SYSIN    DD *\n INDD(FMAN1,OPTIONS(CLEAR))\n INDD(FMAN2,OPTIONS(CLEAR))\n//EGTLJCME  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - E   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//* RENAME   \u00a6  RENAME NONVSAM DATASET TO FINAL NAME\n//* VTOCLIST \u00a6  VTOC LISTING\n//* LISTCAT  \u00a6  FINAL LISTCAT\n//*=========================================================*\n//* RENAME   \u00a6  RENAME NONVSAM DATASET TO FINAL NAME\n//*---------------------------------------------------------*\n//RENAME  EXEC PGM=IDCAMS,REGION=2M\n//STEPCAT  DD  DISP=SHR,DSN=CATALOG.RESCUE\n//SYSPRINT DD  SYSOUT=*\n//SYSIN   DD   *\n ALTER SYSX.SYS2.LINKLIB -\n       NEWNAME(SYS2.LINKLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYSOSG.CSULOAD -\n       NEWNAME(SYSOSG.CSULOAD) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.TCPIP.SEZALPA -\n       NEWNAME(TCPIP.SEZALPA) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS3.CLIST -\n       NEWNAME(SYS3.CLIST) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS2.PROCLIB -\n       NEWNAME(SYS2.PROCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS2.CSL.LOADLIB -\n       NEWNAME(SYS2.CSL.LOADLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYSOSG.PROCLIB -\n       NEWNAME(SYSOSG.PROCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.CMDLIB -\n       NEWNAME(SYS1.CMDLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DAE -\n       NEWNAME(SYS1.DAE) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HELP -\n       NEWNAME(SYS1.HELP) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.IMAGELIB -\n       NEWNAME(SYS1.IMAGELIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.CSSLIB -\n       NEWNAME(SYS1.CSSLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.LINKLIB -\n       NEWNAME(SYS1.LINKLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.V1R3M0.SHASLINK -\n       NEWNAME(SYS1.V1R3M0.SHASLINK) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.LPALIB -\n       NEWNAME(SYS1.LPALIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.MACLIB -\n       NEWNAME(SYS1.MACLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.MIGLIB -\n       NEWNAME(SYS1.MIGLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.NUCLEUS -\n       NEWNAME(SYS1.NUCLEUS) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.PARMLIB -\n       NEWNAME(SYS1.PARMLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.PROCLIB -\n       NEWNAME(SYS1.PROCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.SAMPLIB -\n       NEWNAME(SYS1.SAMPLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.SVCLIB -\n       NEWNAME(SYS1.SVCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.UADS -\n       NEWNAME(SYS1.UADS) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.BRODCAST -\n       NEWNAME(SYS1.BRODCAST) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HASPCKPT -\n       NEWNAME(SYS1.HASPCKPT) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HASPACE -\n       NEWNAME(SYS1.HASPACE) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.CPAC.LOGREC -\n       NEWNAME(SYS1.CPAC.LOGREC) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DUMP00 -\n       NEWNAME(SYS1.DUMP00) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DUMP01 -\n       NEWNAME(SYS1.DUMP01) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.RACFP1 -\n       NEWNAME(SYS1.RACFP1) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HRFCLST -\n       NEWNAME(SYS1.HRFCLST) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HRFMSG -\n       NEWNAME(SYS1.HRFMSG) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HRFPANL -\n       NEWNAME(SYS1.HRFPANL) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.HRFSKEL -\n       NEWNAME(SYS1.HRFSKEL) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTCLIB -\n       NEWNAME(SYS1.DGTCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTLLIB -\n       NEWNAME(SYS1.DGTLLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTMLIB -\n       NEWNAME(SYS1.DGTMLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTPLIB -\n       NEWNAME(SYS1.DGTPLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTSLIB -\n       NEWNAME(SYS1.DGTSLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DGTTLIB -\n       NEWNAME(SYS1.DGTTLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DUTLOAD -\n       NEWNAME(SYS1.DUTLOAD) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.DUTPLIB -\n       NEWNAME(SYS1.DUTPLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.HASPINDX -\n       NEWNAME(ISF.HASPINDX) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFLINK -\n       NEWNAME(ISF.SISFLINK) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFLOAD -\n       NEWNAME(ISF.SISFLOAD) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFLPA -\n       NEWNAME(ISF.SISFLPA) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFMLIB -\n       NEWNAME(ISF.SISFMLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFPLIB -\n       NEWNAME(ISF.SISFPLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFTLIB -\n       NEWNAME(ISF.SISFTLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFSLIB -\n       NEWNAME(ISF.SISFSLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISF.SISFSRC -\n       NEWNAME(ISF.SISFSRC) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPLPA -\n       NEWNAME(ISP.SISPLPA) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPLOAD -\n       NEWNAME(ISP.SISPLOAD) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPMENU -\n       NEWNAME(ISP.SISPMENU) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPPENU -\n       NEWNAME(ISP.SISPPENU) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPSENU -\n       NEWNAME(ISP.SISPSENU) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPSLIB -\n       NEWNAME(ISP.SISPSLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.ISP.SISPTENU -\n       NEWNAME(ISP.SISPTENU) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.CNM.VTAMLST -\n       NEWNAME(CNM.VTAMLST) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.CNM.VTAMLIB -\n       NEWNAME(CNM.VTAMLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.VTAMLST -\n       NEWNAME(SYS1.VTAMLST) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.VTAMLIB -\n       NEWNAME(SYS1.VTAMLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.SYS1.SISTCLIB -\n       NEWNAME(SYS1.SISTCLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.NCP5.LOADLIB -\n       NEWNAME(NCP5.LOADLIB) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.IBMUSER.ISPF.ISPPROF -\n       NEWNAME(IBMUSER.ISPF.ISPPROF) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.EGTLJCM.ISPF.ISPPROF -\n       NEWNAME(EGTLJCM.ISPF.ISPPROF) -\n       CATALOG(CATALOG.RESCUE)\n ALTER SYSX.EGTLKFT.ISPF.ISPPROF -\n       NEWNAME(EGTLKFT.ISPF.ISPPROF) -\n       CATALOG(CATALOG.RESCUE)\n//*\n//*---------------------------------------------------------*\n//* VTOCLIST \u00a6  LIST VTOC\n//*---------------------------------------------------------*\n//VTOCLIST EXEC PGM=IEHLIST,REGION=2M\n//SYSPRINT DD SYSOUT=*\n//VOL1     DD UNIT=3380,VOL=SER=RESCUE,DISP=OLD\n//SYSIN    DD *\n  LISTVTOC VOL=3380=RESCUE\n  LISTVTOC VOL=3380=RESCUE,FORMAT\n//*\n//*---------------------------------------------------------*\n//* LISTCAT  \u00a6  FINAL CATALOG LISTING\n//*---------------------------------------------------------*\n//LISTCAT EXEC PGM=IDCAMS,REGION=2M\n//STEPCAT  DD  DISP=SHR,DSN=CATALOG.RESCUE\n//SYSPRINT DD  SYSOUT=*\n//SYSIN   DD   *\n  LISTCAT ALL CATALOG(CATALOG.RESCUE)\n//*\n//EGTLJCMF  JOB (0),JMILLER,MSGCLASS=X,CLASS=A,\n// NOTIFY=EGTLJCM,REGION=6M,TYPRUN=HOLD\n//*=========================================================*\n//* JOB - F   11.03 09/25/97\n//*---------------------------------------------------------*\n//*  STEP    \u00a6       PURPOSE\n//*---------------------------------------------------------*\n//* LNKLST   \u00a6  Dynamically build LNKLSTxx PARMLIB member.\n//* LPALST   \u00a6  Dynamically build LPALSTxx PARMLIB member.\n//* IEAAPF   \u00a6  Dynamically build IEAAPFxx PARMLIB member.\n//*---------------------------------------------------------*\n//*---------------------------------------------------------*\n//* Build LNKLSTxx member.                                  *\n//*---------------------------------------------------------*\n//LNKLST  EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(LNKLST00),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD *\nSYS2.LINKLIB,\nSYSOSG.CSULOAD,\nSYS1.CMDLIB,\nSYS1.CSSLIB,\nSYS1.LINKLIB,\nSYS1.V1R3M0.SHASLINK,\nISF.SISFLINK,\nISF.SISFLOAD,\nISP.SISPLOAD\n//*\n//*---------------------------------------------------------*\n//* Build LPALSTxx member.                                  *\n//*---------------------------------------------------------*\n//LPALST  EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(LPALST00),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD *\nTCPIP.SEZALPA,\nISF.SISFLPA,\nISP.SISPLPA\n//*\n//*---------------------------------------------------------*\n//* Build IEAAPFxx member.                                  *\n//*---------------------------------------------------------*\n//LPALST  EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PARMLIB(IEAAPF00),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD *\nSYS2.LINKLIB                       RESCUE,\nSYSOSG.CSULOAD                     RESCUE,\nTCPIP.SEZALPA                      RESCUE,\nSYS2.CSL.LOADLIB                   RESCUE,\nSYS1.LINKLIB                       RESCUE,\nSYS1.V1R3M0.SHASLINK               RESCUE,\nCNM.VTAMLIB                        RESCUE,\nSYS1.VTAMLIB                       RESCUE,\nSYS1.SISTCLIB                      RESCUE,\nNCP5.LOADLIB                       RESCUE\n//*\n//*---------------------------------------------------------*\n//* Build JES2 startup PROC.                                *\n//*---------------------------------------------------------*\n//JESPROC EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(JES2),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD DATA,DLM='@#'\n//JES2      PROC M=00\n//*======================================================*\n//* JES2 STARTUP PROC - RESCUE SYSTEM                    *\n//*======================================================*\n//IEFPROC  EXEC PGM=HASJES20,DPRTY=(15,15),TIME=1440\n//HASPPARM DD  DSN=SYS1.PARMLIB(JESPRM&M),DISP=SHR\n//HASPLIST DD  DDNAME=IEFRDER\n//PROC00   DD  DISP=SHR,DSN=SYS2.PROCLIB\n//         DD  DISP=SHR,DSN=SYSOSG.PROCLIB\n//         DD  DISP=SHR,DSN=SYS1.PROCLIB\n@#\n//*---------------------------------------------------------*\n//* Build VTAM startup PROC.                                *\n//*---------------------------------------------------------*\n//LPALST  EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(VTAM),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD DATA,DLM='@#'\n//VTAM     PROC\n//*======================================================*\n//* VTAM STARTUP PROC - RESCUE SYSTEM                    *\n//*======================================================*\n//VTAM     EXEC PGM=ISTINM01,REGION=6500K,\n//         DPRTY=(15,15),TIME=1440,PERFORM=8\n//SISTCLIB DD DISP=SHR,DSN=SYS1.SISTCLIB\n//SYSABEND DD SYSOUT=*,HOLD=YES\n//VTAMLST  DD  DISP=SHR,DSN=CNM.VTAMLST\n//         DD  DISP=SHR,DSN=SYS1.VTAMLST\n//VTAMLIB  DD  DISP=SHR,DSN=CNM.VTAMLIB\n//         DD  DISP=SHR,DSN=SYS1.VTAMLIB\n@#\n//*---------------------------------------------------------*\n//* Build a TSO LOGON PROC.                                 *\n//*---------------------------------------------------------*\n//TSOPROC EXEC PGM=IEBGENER,REGION=2M\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DISP=SHR,DSN=SYS1.PROCLIB(MINIMUM),\n//          UNIT=3380,VOL=SER=RESCUE\n//SYSUT1    DD DATA,DLM='@#'\n//MINIMUM  PROC\n//*======================================================*\n//* TSO LOGON PROC - Rescue System.                      *\n//* 11.03 09/25/97                                    *\n//*======================================================*\n//MINIMUM EXEC PGM=IKJEFT01,DYNAMNBR=256,PARM=ISPALLOC\n//SYSPRINT DD TERM=TS,SYSOUT=*\n//SYSTERM  DD TERM=TS,SYSOUT=*\n//SYSIN    DD TERM=TS\n//SYSPROC  DD DISP=SHR,DSN=SYS3.CLIST\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST\n//* Dynamically build statements below\n//SYSPROC  DD  DISP=SHR,DSN=SYS3.CLIST\n//ISPPLIB  DD  DISP=SHR,DSN=ISF.SISFPLIB\n//         DD  DISP=SHR,DSN=ISP.SISPPENU\n//ISPMLIB  DD  DISP=SHR,DSN=ISF.SISFMLIB\n//         DD  DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD  DISP=SHR,DSN=ISF.SISFSLIB\n//         DD  DISP=SHR,DSN=ISP.SISPSENU\n//         DD  DISP=SHR,DSN=ISP.SISPSLIB\n//ISPTLIB  DD  DISP=SHR,DSN=ISF.SISFTLIB\n//         DD  DISP=SHR,DSN=ISP.SISPTENU\n@#\n//*\n./ ADD NAME=WAIT     0100-02365-02365-0941-00157-00157-00000-JMILLER\n//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M\n//ASMHCL   EXEC  ASMHCL,PARM.L='MAP,LET,LIST,NCAL'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD  *\nPRC      TITLE 'WAIT - WAIT A LITTLE BIT.'\n********************************************************************\n*                                                                  *\n* NAME - WAIT.                                                     *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *\n*     WAIT. DEFAULT IS 10 SECONDS.                                 *\n*                                                                  *\n* RETURN CODES -                                                   *\n*                                                                  *\n*   R15 = 20, BAD PARM FIELD.                                      *\n*                                                                  *\n* LOG -                                                            *\n*   05/30/86 L01 PTW IMPLEMENTED                                   *L01\n*   09/27/88 L02 PTW IMPLEMENTED                                   *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'WAIT'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12\n         GETMAIN RU,LV=DYNLEN\n         LR    R2,R13\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LR    R0,R1\n         LA    R14,DYNLEN\n         LA    R1,R1\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVC   SECONDS,=F'10'     DEFAULT.\n         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).\n         L     R2,24(,R2)         A(A(PARM)).\n         LTR   R2,R2              CHECK FOR NULL PARM.\n         BZ    DOTIME\n         L     R2,0(,R2)          A(PARM).\n         LH    R3,0(,R2)          L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    DOTIME               THEN EXIT.\n         CH    R3,=H'4'           IF LENGTH NGT '4' +\n         BH    BADTIME            FORGET NEXT.\n         LA    R4,2(,R2)\nVERNUM   DS    0H\n         CLI   0(R4),C'0'         SCAN\n         BL    BADTIME             FORWARD\n         CLI   0(R4),C'9'         SCAN\n         BH    BADTIME             FORWARD\n         LA    R4,1(,R4)            TO FIRST\n         BCT   R3,VERNUM\n         LH    R3,0(,R2)\n         BCTR  R3,0               MACHINE LENGTH.\n         EX    R3,PACKSEC         PACK SECONDS.\n         CVB   R3,DOUBLE          CONVERT TO BINARY.\n         CH    R3,=H'1'           TEST SECONDS\n         BL    BADTIME             FOR LIMITS.\n         CH    R3,=H'9999'\n         BH    BADTIME\n         ST    R3,SECONDS          AND STORE.\nPACKSEC  PACK  DOUBLE,2(*-*,R2)\n********************************************************************\n*                                                                  *\n*        W A I T                                                   *\n*                                                                  *\n********************************************************************\nDOTIME   DS    0H\n         L     R2,SECONDS\n         MH    R2,=H'100'\n         ST    R2,SECONDS\n         STIMER WAIT,BINTVL=SECONDS\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADTIME  DS    0H\n         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         MVC   RC,=F'20'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nDOUBLE   DS    D\nRC       DS    F\nSECONDS  DS    F\nDYNLEN   EQU   *-DYNAMIC\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(WAIT),DISP=SHR,UNIT=\n./ ADD NAME=XXATCCON 0100-02365-02365-0941-00015-00015-00000-JMILLER\n***********************************************************************\n***********************************************************************\n**                                                                  **\n**       ACTIVATE ALL VTAM MAJOR NODES                              **\n**                                                                  **\n***********************************************************************\n***********************************************************************\n         E02PATH,              ** PATH TABLES                       ** X\n         E02ADJ,               ** ADJACENT SSCP ROUTING             ** X\n         E02APPLS,             ** NETVIEW APPLICATIONS              ** X\n         E02TSO,               ** TSO APPLIDS                       ** X\n         E02CDRM,              ** CROSS DOMAIN RESOURCE MGR'S       ** X\n         E02CDRSC,             ** CROSS DOMAIN RESOURCES            ** X\n         E01NCP,               ** CSUC'S NCP                        ** X\n         E02TCPIP,             ** TCP/IP LOGICAL TERMINALS          ** X\n./ ADD NAME=XXATCSTR 0100-02365-02365-0941-00015-00015-00000-JMILLER\n***********************************************************************\n**       VTAM STARTUP OPTIONS                                       **\n**       08/22/97 JOHN MILLER                                       **\n**                                                                  **\n**       S CNMNET,,,(LIST=03)                                       **\n**********************************************************************\n         MAXSUBA=255,           ** MAXIMUM SUBAREA                  ** X\n         CONFIG=00,             ** START MAJOR NODES IN ATCCON00    ** X\n         HOSTPU=E02MPU,         ** SNI - PUS - UNIQUE NETWORK NAME  ** X\n         HOSTSA=192,            ** SUBAREA - UNIQUE NETWORK VALUE   ** X\n         NETID=CSUNET,          ** SNI - UNIQUE NETWORK IDENTIFIER  ** X\n         SSCPID=0192,           ** NETWORK UNIQUE                   ** X\n         PPOLOG=YES,                                                   X\n         IOBUF=(100,256,19,,1,20),                                     X\n         SSCPNAME=E02M          ** SNI - GATEWAY VTAM (SSCP) NAME   **\n./ ADD NAME=XXCOMMND 0100-02365-02365-0941-00009-00009-00000-JMILLER\nCOM='T MPF=00'\nCOM='TRACE'\nCOM='CD SET,SDUMP=(ALLPSA,NUC,SQA,LSQA,RGN,LPA,TRT,SWA,CSA,SUM),Q=YES'\nCOM='S DLF,SUB=MSTR'\nCOM='S VLF,SUB=MSTR'\nCOM='S EPWFFST.FFST,SUB=MSTR'\nCOM='S VTAM,,,(LIST=00)'\nCOM='S IRRDPTAB'\nCOM='S TSO'\n./ ADD NAME=XXIEASYS 0100-02365-02365-0941-00075-00075-00000-JMILLER\nAPF=00,                      AUTHORIZATION LIST\nCLOCK=00,                    SELECT CLOCK00                     DEFAULT\nCLPA,                        ALWAYS COLD START\nCMB=(UNITR,COMM,GRAPH,CHRDR), ADDITIONAL CMB ENTRIES\nCMD=00,                      TOD PROMPT, SDUMP, TRACE ON AND RMF /*J3*/\nCON=00,                      SELECT CONSOL00                    DEFAULT\nCSA=(3000,15000),            MVS/ESA CSA RANGE\nDUMP=DASD,                   PLACE SVC DUMPS ON DASD DEVICES  DEFAULT\nFIX=00,                      FIX MODULES SPECIFIED               /*J3*/\nGRS=NONE,                    NO COORDINATION OF GRS REQUESTS\nICS=00,                      SELECT IEAICS00 INSTALL CNTL SPECS FOR SRM\nIOS=00,                      SET MIH FOR BTI BOX                    RJG\nIPS=00,                      SELECT IEAIPS00 INSTALL PERF SPECS FOR SRM\nLNK=00,                      SPECIFY LNKLST00                    /*J3*/\nLNKAUTH=LNKLST,              AUTHORIZE LNKLST00-DEFAULT, APFTAB IS ALT\nLOGCLS=A,                    WILL NOT BE PRINTED BY DEFAULT\nLOGLMT=999999,               MUST BE 6 DIGITS, MAX WTL MESSAGES QUEUED\nLOGREC=SYS1.&SYSNAME..LOGREC,  ERROR RECORDING\nLPA=(00,L),                  SELECT LPALST00\nMAXUSER=250,                 (SYS TASKS + INITS + TSOUSERS)\nMLPA=00,                     MLPA PARAMETERS\nMSTRJCL=00,                  MASTER JCL - MSTJCL00              DEFAULT\nOPI=YES,                     ALLOW OPERATOR OVERRIDE TO IEASYS00\nOPT=00,                      SPECIFY IEAOPT00 (SRM TUNING PARMETERS)\nPAGE=(PAGE.RESCUE.PLPA,\n      PAGE.RESCUE.COMMON,\n      PAGE.RESCUE.LOCAL1,L),\nPAGTOTL=(7,4),               ALLOW ADDITION 3 PAGE D/S AND 2 SWAP D/S\nPAK=00,                      IEAPAK00\nPROD=00,                     SELECT IFAPRDEX - SECURE SERVER DISABLED\nREAL=128,                    ALLOWS 2 64K JOBS OR 1 128K JOB TO RUN V=R\nRSU=0,                       NO RECONFIG STORAGE UNITS          DEFAULT\nRSVSTRT=5,                   RESERVED ASVT ENTRIES              DEFAULT\nRSVNONR=5,                   RESERVED ASVT ENTRIES              DEFAULT\nSCH=00,                      SELECT SCHED00                     DEFAULT\nSMF=00,                      SELECT SMFPRM00, SMF PARAMETERS    DEFAULT\nSMS=01,                      SELECT IGDSMS01, SMS PARAMETERS\nSQA=(6,0),                   MVS/ESA SQA APPROX 640K\nSYSNAME=CPAC,                SYSTEM NAME\nSSN=00,                      SUBSYSTEM INITIALIZATION NAMES\nSVC=00,                      SELECT IEASVC00                    DEFAULT\nVAL=00,                      SELECT VATLST00                    DEFAULT\nVIODSN=SYS1.STGINDEX,        VIO DS\nVRREGN=64                    DEFAULT REAL-STORAGE REGION SIZE   DEFAULT\n/* THIS COMPLETES THE SYSP LIST                                      */\n/*                                                                   */\n/* NOTE 1: NOTE THAT SCAN OF THE SYSP PARAMETERS ENDS AT THE FIRST   */\n/*         PARAMETER WITHOUT A COMMA.  WHEN MODIFYING ANY PARAMETER  */\n/*         EXCEPT THE LAST SPECIFIED, INCLUDE THE COMMA.             */\n/*                                                                   */\n/* NOTE 2: PAGE PARAMETER SPECIFIED AT IPL TIME MERGES WITH IEASYSXX */\n/*         SEE INIT AND TUNING GUIDE GC28-1149.                      */\n/*                                                                   */\n/* NOTE 3: THE FOLLOWING PARAMETERS HAVE BEEN OMITTED BY CHOICE      */\nALT=                         CAN ONLY BE SPECIFIED BY THE OPERATOR\n                             NOT A VALID PARMETER FOR IEASYSXX\nBLDL=                        NOT VALID FOR MVS/ESA\nCVIO                         DO NOT DELETE VIO D/S - CLPA IMPLIES CVIO\nDUPLEX=                      NO DUPLEX D/S - OPTIONAL WITH SU 7\nHARDCPY=                     HARD COPY PARMS - CONTROLLED BY CONSOLXX\nIOS=                         NOW SETS AN ALT TIME INTERVAL FOR MIH\nPURGE                        DO NOT DEMOUNT MSS VOLUMES\nSWAP=                        NO SWAP DATASET SPECIFIED\nSYSP=00                      SPECIFIED BY OPERATOR AT IPL FOR THIS SYSP\n                             NOT A VALID PARMETER FOR IEASYSXX\nWTOBFRS=500                  NO. OF WTO BUFFERS- CONTROLLED BY CONSOLXX\nWTORPLY=50                   NO. OF WTOR BUFFERS-CONTROLLED BY CONSOLXX\n IEALODXX IS NO LONGER VALID WITH MVS/ESA\n LPALSTXX IS A OPTION WHICH ALLOWS YOU TO\n          CONCATENATE TO SYS1.LPALIB.\n/*                           THIS IS THE END OF IEASYS00             */\n /* LIB: SYS1.PARMLIB(IEASYS00)                                      */\n /* GDE: CBIPO MVS CUSTOMIZATION                                     */\n /* DOC: THIS IS THE MVS CBIPO SYSTEM PARAMETER LIST.                */\n /*                                                                  */\n./ ADD NAME=XXIEFSSN 0100-02365-02365-0941-00001-00001-00000-JMILLER\nJES2,,,PRIMARY                   PRIMARY SUBSYSTEM\n./ ADD NAME=XXIKJTSO 0100-02365-02365-0941-00071-00071-00000-JMILLER\nALLOCATE DEFAULT(SHR)\nAUTHCMD NAMES(          /* AUTHORIZED COMMANDS      */      +\n   DEL      DELETE      /*                          */      +\n   RFLIST               /* RACF LIST CMD JCM 8/90   */      +\n   RFLISTD              /* RACF LIST CMD JCM 8/90   */      +\n   RFLISTG              /* RACF LIST CMD JCM 8/90   */      +\n   RFLISTT              /* RACF LIST CMD JCM 8/90   */      +\n   VLFNOTE              /* FOR VLF                  */      +\n   RECEIVE              /* TSO COMMANDS             */      +\n   TRANSMIT XMIT        /*                          */      +\n   LISTB    LISTBC      /*                          */      +\n   SE       SEND        /*                          */      +\n   RACONVRT             /*                          */      +\n   SYNC                 /*                          */      +\n   AD       ADDSD       /* RACF COMMANDS            */      +\n   AG       ADDGROUP    /*                          */      +\n   AU       ADDUSER     /*                          */      +\n   ALG      ALTGROUP    /*                          */      +\n   ALD      ALTDSD      /*                          */      +\n   ALU      ALTUSER     /*                          */      +\n   BLKUPD               /*                          */      +\n   CO       CONNECT     /*                          */      +\n   DD       DELDSD      /*                          */      +\n   DG       DELGROUP    /*                          */      +\n   DU       DELUSER     /*                          */      +\n   LD       LISTDSD     /*                          */      +\n   LG       LISTGRP     /*                          */      +\n   LU       LISTUSER    /*                          */      +\n   RALT     RALTER      /*                          */      +\n   RDEF     RDEFINE     /*                          */      +\n   RDEL     RDELETE     /*                          */      +\n   RE       REMOVE      /*                          */      +\n   RL       RLIST       /*                          */      +\n   RVARY                /*                          */      +\n   PASSWORD PW          /*                          */      +\n   PE       PERMIT      /*                          */      +\n   SETR     SETROPTS    /*                          */      +\n   SR       SEARCH      /*                          */      +\n             )          /*                          */\n                        /*                          */\nAUTHPGM NAMES(          /* AUTHORIZED PROGRAMS      */      +\n   IEBCOPY              /*                          */      +\n   ICHDSM00             /* RACF PROGRAMS            */      +\n   ICHUT100             /*                          */      +\n   ICHUT200             /*                          */      +\n   ICHUT400             /*                          */      +\n           )            /*                          */\n                        /*                          */\nNOTBKGND NAMES(         /* COMMANDS WHICH MAY NOT BE */  +\n                        /* ISSUED IN THE BACKGROUND  */  +\n   OPER     OPERATOR    /*                           */  +\n   TERM     TERMINAL)   /*                           */\n                        /*                           */\nAUTHTSF NAMES(          /* PROGRAMS TO BE AUTHORIZED */  +\n                        /* WHEN CALLED THROUGH THE   */  +\n                        /* TSO SERVICE FACILITY.     */  +\n   RFLIST               /* USER RACF COMMANDS        */  +\n   RFLISTD              /* JCM 01/04/91              */  +\n   RFLISTG              /* ...                       */  +\n   RFLISTT              /* ...                       */  +\n   CITEST               /* ...                       */  +\n   IEBCOPY              /*                           */  +\n   IKJEFF76)            /*                           */\n                        /*                           */\nSEND                    /* SEND COMMAND DEFAULTS     */  +\n   OPERSEND(ON)         /*                           */  +\n   USERSEND(ON)         /*                           */  +\n   SAVE(ON)             /*                           */  +\n   CHKBROD(OFF)         /*                           */  +\n   USEBROD(ON)          /*                           */  +\n   LOGNAME(SYS1.BRODCAST)  /*                        */\n./ ADD NAME=XXJESPRM 0100-02365-02365-0941-00595-00595-00000-JMILLER\n/*********************************************************************/\n/* JES2 parms for SYS911 emergency system.                           */\n/* 08/22/97 John Miller                                              */\n/*********************************************************************/\nLOGON(1) APPLID=CHICOVM\n/*                                                                   */\nAPPL(CHICOVM) NODE=192\nAPPL(EJES2) NODE=191\nAPPL(AJES201)  NODE=101\n/*                                                                   */\nBUFDEF   BELOWBUF=(LIMIT=114,WARN=80),\n         EXTBUF=(LIMIT=114,WARN=80)\n/*                                                                   */\nCKPTDEF  CKPT1=(DSNAME=SYS1.HASPCKPT,   /* NAME FOR CKPT &DSNPRFX  CS*/\n         VOLSER=RESCUE,\n         INUSE=YES),\n         MODE=DUPLEX,        /* DUPLEXING                &CHKPT2   WS*/\n         DUPLEX=ON,          /* DUPLEXING                &CHKPT2   WS*/\n         LOGSIZE=2,\n         APPLCOPY=COMMON\nCONDEF   AUTOCMD=50,         /* Number of Auto Cmds             dhwnc*/\n         BUFNUM=950,         /* Number of CMBs                  dhwnc*/\n         BUFWARN=80,         /* Warning Threshold %            dohwnc*/\n         CONCHAR=$,          /* Console Cmd Character            dwnc*/\n         DISPLEN=65,         /* $SCAN Cmd/init Display Length  dohwnc*/\n         DISPMAX=100,        /* $SCAN Cmd/init Max Lines       dohwnc*/\n         MASMSG=200,         /* Number of Queued Msgs          dohwnc*/\n         RDRCHAR=$           /* Reader Cmd Character           dohwnc*/\n/*                                                                   */\nDEBUG    =NO                 /* Don't Use Unless Nec.          dohwnc*/\n/*                                                                   */\nESTBYTE  NUM=99999,          /* 99999000 Bytes for 1st Msg     dohwnc*/\n         INT=99999,          /*  then 99999000 Byte Intervals  dohwnc*/\n         OPT=0               /* Allow Jobs to Continue         dohwnc*/\n/*                                                                   */\nESTIME   NUM=2,              /* 2 minutes for 1st Message      dohwnc*/\n         INT=1,              /*  then at 1 minute Intervals    dohwnc*/\n         OPT=NO              /* No HASP308 message             dohwnc*/\n/*                                                                   */\nESTLNCT  NUM=2,              /* 2000 Lines for 1st Message     dohwnc*/\n         INT=2000,           /*  then at 2000 Line Intervals   dohwnc*/\n         OPT=0               /* Allow Jobs to Continue         dohwnc*/\n/*                                                                   */\nESTPAGE  NUM=40,             /* 40 Pages for 1st Message       dohwnc*/\n         INT=10,             /*  then at 10 Page Intervals     dohwnc*/\n         OPT=0               /* Allow Jobs to Continue         dohwnc*/\n/*                                                                   */\nESTPUN   NUM=100,            /* 100 Cards for 1st Message      dohwnc*/\n         INT=2000,           /*  then at 2000 Card Intervals   dohwnc*/\n         OPT=0               /* Allow Jobs to Continue         dohwnc*/\n                           /*                                    */\n                           /*                                    */\nI(1)    NAME=1,           /* Initiator Name                   dwnc*/\n         CLASS=A,           /* Initial Job Classes             downc*/\n         START=YES          /* Start Automatically             downc*/\n/*                                                                  */\nI(2)    NAME=2,           /* Initiator Name                   dwnc*/\n         CLASS=A,           /* Initial Job Classes             downc*/\n         START=YES          /* Start Automatically             downc*/\n/*                                                                  */\nI(3)    NAME=3,           /* Initiator Name                   dwnc*/\n         CLASS=BA,         /* Initial Job Classes             downc*/\n         START=YES         /* Start Automatically             downc*/\n/*                                                                   */\nI(4)    NAME=4,           /* Initiator Name                   dwnc*/\n         CLASS=BA,         /* Initial Job Classes             downc*/\n         START=YES        /* Start automatically             downc*/\n/*                                                                  */\nI(5)    NAME=5,           /* Initiator Name                   dwnc*/\n         CLASS=HBA,        /* Initial Job Classes             downc*/\n         START=YES         /* Start automatically             downc*/\n/*                                                                  */\nI(6)    NAME=6,           /* Initiator Name                   dwnc*/\n         CLASS=HBA,        /* Initial Job Classes             downc*/\n         START=YES         /* Start Automatically             downc*/\n/*                                                                   */\nI(7)    NAME=7,           /* Initiator Name                   dwnc*/\n         CLASS=HBA,        /* Initial Job Classes             downc*/\n         START=YES        /* Start automatically             downc*/\n/*                                                                  */\nI(8)    NAME=8,           /* Initiator Name                   dwnc*/\n         CLASS=HBA,        /* Initial Job Classes             downc*/\n         START=YES         /* Start automatically             downc*/\n/*                                                                   */\nI(9)    NAME=9,           /* Initiator Name                   dwnc*/\n         CLASS=F,          /* Initial Job Classes             downc*/\n         START=NO         /* DRAIN                           downc*/\n/*                                                                 */\nI(10)   NAME=10,          /* Initiator Name                   dwnc*/\n         CLASS=G,          /* Initial Job Classes             downc*/\n         START=NO         /* DRAIN                           downc*/\n/*                                                                  */\nI(11)   NAME=11,          /* Initiator Name                   dwnc*/\n         CLASS=H,          /* Initial Job Classes             downc*/\n         START=NO          /* DRAIN                           downc*/\n/*                                                                 */\nI(12)   NAME=12,          /* Initiator Name                   dwnc*/\n         CLASS=I,          /* Initial Job Classes             downc*/\n         START=NO         /* DRAIN                           downc*/\n/*                                                                  */\nINITDEF  PARTNUM=12         /* Number of Initiators              wnc*/\n/*                                                                  */\nINTRDR   AUTH=(JOB=YES,DEVICE=YES,SYSTEM=YES),\n         /* Allow System,Device - Job Cmds  downc*/\n         CLASS=A,            /* Default Job Class               downc*/\n         HOLD=NO,            /* Not TYPRUN=HOLD                 dhwnc*/\n         PRTYINC=0,          /* Don't Prty Age Jobs               wnc*/\n         PRTYLIM=15,         /* Limit Job Prty to 15              wnc*/\n         RDINUM=20           /* Number of Internal RDRS          dwnc*/\n/*                                                                   */\nJOBCLASS(A) ACCT=NO,         /* Acct# not req   b................... */\n         PGMRNAME=NO,        /* Pgmrnm not rq   b................... */\n         TIME=(0030,00),     /* Job Step Time   ...mmmmss........... */\n         REGION=512K,        /* Region Size     .........ccc........ */\n         COMMAND=VERIFY,     /* Verify Cmds     ............r....... */\n         BLP=YES,            /* Allows BLP      .............l...... */\n         AUTH=ALL,           /* Allow all Cmd   ..............aaaa.. */\n         MSGLEVEL=(1,1),     /* Job, All Msgs   ..................ef */\n         COPY=NO,            /* Not TYPRUN=COPY                 dhwnc*/\n         HOLD=NO,            /* Not TYPRUN=HOLD                 dhwnc*/\n         IEFUJP=YES,         /* Take SMF Job Purge Exit         dhwnc*/\n         IEFUSO=YES,         /* Take SYSOUT Excess Exit         dhwnc*/\n         JOURNAL=NO,         /* Journal this Job Class          dhwnc*/\n         LOG=YES,            /* Print JES2 JOB LOG              dhwnc*/\n         OUTPUT=YES,         /* Produce Output for Job          dhwnc*/\n         PERFORM=000,        /* SRM Performance Group 0         dhwnc*/\n         PROCLIB=00,         /* Use //PROC00 DD                 dhwnc*/\n         RESTART=NO,         /* No Requeue (XEQ) on IPL         dhwnc*/\n         SCAN=NO,            /* Not TYPRUN=SCAN                 dhwnc*/\n         SWA=BELOW,          /* SWA cbs below 16m line          dhwnc*/\n         TYPE6=YES,          /* Produce SMF 6 Records           dhwnc*/\n         TYPE26=YES          /* Produce SMF 26 Records          dhwnc*/\n/*                                                                   */\nJOBCLASS(H) ACCT=NO,         /* Acct# not req   b................... */\n         PGMRNAME=NO,        /* Pgmrnm not rq   b................... */\n         TIME=(0030,00),     /* Job Step Time   ...mmmmss........... */\n         REGION=512K,        /* Region Size     .........ccc........ */\n         COMMAND=VERIFY,     /* Verify Cmds     ............r....... */\n         BLP=YES,            /* Allows BLP      .............l...... */\n         AUTH=ALL,           /* Allow all Cmd   ..............aaaa.. */\n         MSGLEVEL=(1,1),     /* Job, All Msgs   ..................ef */\n         COPY=NO,            /* Not TYPRUN=COPY                 dhwnc*/\n         HOLD=YES,           /* TYPRUN=HOLD                     dhwnc*/\n         IEFUJP=YES,         /* Take SMF Job Purge Exit         dhwnc*/\n         IEFUSO=YES,         /* Take SYSOUT Excess Exit         dhwnc*/\n         JOURNAL=NO,         /* Journal this Job Class          dhwnc*/\n         LOG=YES,            /* Print JES2 JOB LOG              dhwnc*/\n         OUTPUT=YES,         /* Produce Output for Job          dhwnc*/\n         PERFORM=000,        /* SRM Performance Group 0         dhwnc*/\n         PROCLIB=00,         /* Use //PROC00 DD                 dhwnc*/\n         RESTART=NO,         /* No Requeue (XEQ) on IPL         dhwnc*/\n         SCAN=NO,            /* Not TYPRUN=SCAN                 dhwnc*/\n         SWA=BELOW,          /* SWA cbs below 16m line          dhwnc*/\n         TYPE6=YES,          /* Produce SMF 6 Records           dhwnc*/\n         TYPE26=YES          /* Produce SMF 26 Records          dhwnc*/\n/*                                                                   */\nJOBDEF   ACCTFLD=OPTIONAL,   /* Accounting field optional      dohwnc*/\n         JCLERR=NO,          /* No Term. Job w/JCL Error       dohwnc*/\n         JOBNUM=1500,        /* Job Queue Size                     dc*/\n         JOBWARN=80,         /* Warning Threshold % For JQEs   dohwnc*/\n         NUMWARN=80,         /* Warn Threshold % for Job Numb. dohwnc*/\n         PRTYHIGH=10,        /* Upper Limit for Aging          dohwnc*/\n         PRTYJECL=YES,       /*PRIORITY JECL Supported         dohwnc*/\n         PRTYJOB=NO,         /* PRTY= on JOB Not Sup'd         dohwnc*/\n         PRTYLOW=5,          /* Lower Limit for Aging          dohwnc*/\n         PRTYRATE=96,        /* Prty Aging Rate X/Day          dohwnc*/\n         RANGE=(1-9999)      /* Local Job Number Range          downc*/\n/*                                                                   */\nJOBPRTY(1) PRIORITY=9,       /* Job Prty=9 if                  dohwnc*/\n          TIME=2             /*  < 2 min. exec. time           dohwnc*/\n                             /*                                      */\nJOBPRTY(2) PRIORITY=8,       /* Job Prty=8 if                        */\n          TIME=5             /*  < 5 min. exec. time                 */\n/*                                                                   */\nLINE(1)   UNIT=SNA           /* Remote 3287 in Kendall Hall          */\nLINE(2)   UNIT=SNA           /* Remote Laser in Kendall Hall         */\nLINE(3)   UNIT=SNA           /* Remote line printer in Kendall       */\nLINE(4)   UNIT=SNA           /* Remote laser printer in AD&R         */\nLINE(5)   UNIT=SNA           /* Remote line printer in Purchasing    */\nLINE(101) UNIT=SNA           /* NJE Connection to IRT                */\nLINE(191) UNIT=SNA           /* NJE Connection to Chico MVS          */\n/*                            *--------------------------------------*\n                              |    Identify JES2 APPLIDs to VTAM     |\n                              *--------------------------------------*\n                                                                     */\nMASDEF   DORMANCY=(100,      /* Minimum Dormancy Time          dohwnc*/\n                       500), /* Maximum Dormancy Time          dohwnc*/\n         HOLD=99999999,      /* Minimum Hold Time              dohwnc*/\n         LOCKOUT=1000,       /* Lock-out Warning Time          dohwnc*/\n         OWNMEMB=E01M,       /* SMF ID of this System                */\n         SHARED=NOCHECK,     /* Check for Shared DASD             doc*/\n         SYNCTOL=120         /* Synch.Tolerance (Sec.)         dohwnc*/\n/*                                                                   */\nMEMBER(1) NAME=E01M          /* IDS of all MAS Members               */\n/*                                                                   */\nNJEDEF   DELAY=120,         /* Max. Msg Delay Time            dohwnc*/\n         JRNUM=4,           /* Num. of job receivers           dhwnc*/\n         JTNUM=4,           /* Num. of job xmitters            dhwnc*/\n         LINENUM=4,         /* Num. of lines for NJE           dhwnc*/\n         NODENUM=2000,      /* Max. Number of NJE nodes          dnc*/\n         OWNNODE=192,       /* This Node's Number                 dc*/\n         PATH=1,            /* Num. of Paths/Alt'nate          dhwnc*/\n         RESTMAX=8000000,   /* Max. resistance tolerance       dhwnc*/\n         RESTNODE=100,      /* This node's resistance          dhwnc*/\n         RESTTOL=0,         /* Alt. resistance tolerance       dhwnc*/\n         SRNUM=4,           /* Num. of sysout receivers        dhwnc*/\n         STNUM=4            /* Num. of sysout transmitters     dhwnc*/\n/*                          NJE NODES                            FRM*/\nNODE(191)  NAME=CHIMVS,     /* NJE  NAME FOR CHICO MVS              */\n         AUTH=(NET=NO,DEVICE=NO,JOB=NO,SYSTEM=NO), /* NO REMOTE AUTH*/\n         COMPACT=0,         /* NO COMPACTION                        */\n         HOLD=NONE,         /* RECEIVED JOBS WILL NOT BE HELD       */\n         RECEIVE=BOTH,      /* ACCEPT JOBS AND SYSOUT               */\n         REST=0,            /* PATH RESISTANCE                      */\n         PATHMGR=NO,        /*                                      */\n         TRANSMIT=BOTH      /* TRANSMIT JOBS AND SYSOUT             */\n/*                                                                  */\nNODE(192)  NAME=CHICOVM,    /* NJE  NAME FOR CHICO OS/390           */\n         AUTH=(NET=YES,DEVICE=YES,JOB=YES,SYSTEM=YES),\n         COMPACT=0,         /* NO COMPACTION                        */\n         HOLD=NONE,         /* RECEIVED JOBS WILL NOT BE HELD       */\n         RECEIVE=BOTH,      /* ACCEPT JOBS AND SYSOUT               */\n         REST=0,            /* PATH RESISTANCE                      */\n         TRANSMIT=BOTH      /* TRANSMIT JOBS AND SYSOUT             */\n/*                                                                  */\nNODE(101)  NAME=CSUCO,      /* NJE  NAME FOR IRT                    */\n         AUTH=(NET=NO,DEVICE=NO,JOB=NO,SYSTEM=NO), /* NO REMOTE AUTH*/\n         COMPACT=0,         /* NO COMPACTION                        */\n         HOLD=NONE,         /* RECEIVED JOBS WILL NOT BE HELD       */\n         RECEIVE=BOTH,      /* ACCEPT JOBS AND SYSOUT               */\n         REST=0,            /* PATH RESISTANCE                      */\n         TRANSMIT=BOTH      /* TRANSMIT JOBS AND SYSOUT             */\n/*                                                                  */\nCONNECT NODEA=192,NODEB=191\n/*                                                                  */\nOFF(1).JR CLass=,           /* Reload All Classes             dohwnc*/\n         HOLD=,             /* Reload Held - Non-Held         dohwnc*/\n         JOBNAME=,          /* Reload Any Job Name            dohwnc*/\n                            /* Modify Jobs on Reload                */\n         MOD=(CLASS=,       /* - Don't Change Class           dohwnc*/\n              HOLD=,        /* - Don't Change Hold            dohwnc*/\n              ROUTECDE=,    /* - Don't Change Dest'n          dohwnc*/\n              SYSAFF=),     /* - Don't Change SysAff.         dohwnc*/\n         NOTIFY=NO,         /* Don't Notify on Reload         dohwnc*/\n         RANGE=J1-32767,    /* Reload All Job Numbers         dohwnc*/\n         ROUTECDE=(),       /* Reload Jobs w/Any Dest         dohwnc*/\n         START=YES,         /* Started with $S OFFLOAD         dhwnc*/\n         SYSAFF=(),         /* Reload Jobs with Any Aff       dohwnc*/\n         WS=(CLASS/)        /* Job Selection Criteria         dohwnc*/\n/*                                                                  */\nOFF(1).JT CLass=,           /* Select No Classes              dohwnc*/\n         DISP=DELETE,       /* Purge after Offload            dohwnc*/\n         HOLD=,             /* Select Held - Non-Held         dohwnc*/\n         JOBNAME=,          /* Select Any Job Name            dohwnc*/\n         NOTIFY=NO,         /* Don't Notify on Offld.         dohwnc*/\n         RANGE=J1-32767,    /* Select All Job Numbers         dohwnc*/\n         ROUTECDE=(),       /* Select Jobs w/Any Dest         dohwnc*/\n         START=YES,         /* Started with $S OFFLOAD         dhwnc*/\n         SYSAFF=(),         /* Select Jobs with Any Aff       dohwnc*/\n         VOLUME=(),         /* Select Any Spool Volume        dohwnc*/\n         WS=(CLASS/)        /* Job Selection Criteria         dohwnc*/\n/*                                                                  */\nOFF(1).SR BURST=,         /* Select Any Burst Setting       dohwnc*/\n         OUTDISP=(K,H,W,L), /* Select Held - Non-Hld DS      dohwnc*/\n         FCB=,              /* Select Any FCB                 dohwnc*/\n         FLASH=,            /* Select Any/No Flash            dohwnc*/\n         HOLD=,             /* Selct Held/Non-Hld Jobs        dohwnc*/\n         JOBNAME=,          /* Select Any Job Name            dohwnc*/\n                            /* Modify Following on Reload     dohwnc*/\n         MOD=(BURST=,       /* - Don't Change Burst           dohwnc*/\n              OUTDISP=,     /* - Don't Change OUTDISP         dohwnc*/\n              FCB=,         /* - Don't Change FCB             dohwnc*/\n              FLASH=,       /* - Don't Change Flash           dohwnc*/\n              HOLD=,        /* - Don't Change Hold            dohwnc*/\n              PRMODE=,      /* - Don't Change PRMODE          dohwnc*/\n              QUEUE=,       /* - Don't Change Class           dohwnc*/\n              ROUTECDE=,    /* - Don't Change Destn           dohwnc*/\n              UCS=,         /* - Don't Change UCS             dohwnc*/\n              WRITER=),     /* - Don't Change writer          dohwnc*/\n         NOTIFY=NO,         /* Don't Notify on reload         dohwnc*/\n         PRMODE=(),         /* Select Any PRMODE              dohwnc*/\n         QUEUE=,            /* Select Any Sysout Class        dohwnc*/\n         RANGE=J1-32767,    /* Select All Job Numbers         dohwnc*/\n         ROUTECDE=(),       /* Select Jobs w/Any Dest         dohwnc*/\n         START=YES,         /* Started with $S OFFLOAD         dhwnc*/\n         UCS=,              /* Select any UCS                 dohwnc*/\n         WRITER=,           /* Select any Writer              dohwnc*/\n         WS=(Q/)            /* Job Selection Criteria         dohwnc*/\n                            /* - Class Only                   dohwnc*/\n/*                                                                  */\nOFF(1).ST BURST=,           /* Select Any Burst Set'g         dohwnc*/\n         DISP=DELETE,       /* Purge after Offload            dohwnc*/\n         OUTDISP=(W,K),     /* Select Held - Non-Hld DS       dohwnc*/\n         FCB=,              /* Select Any FCB                 dohwnc*/\n         FLASH=,            /* Select Any/No Flash            dohwnc*/\n         HOLD=,             /* Selct Held-Non-Hld Jobs        dohwnc*/\n         JOBNAME=,          /* Select Any Job Name            dohwnc*/\n         LIMIT=(0-*),       /* Select Any # Lines             dohwnc*/\n         NOTIFY=NO,         /* Don't Notify on Offld.         dohwnc*/\n         PLIM=(0-*),        /* Select Any # Pages             dohwnc*/\n         PRMODE=(),         /* Select Any PRMODE              dohwnc*/\n         QUEUE=,            /* Select Any Sysout Class        dohwnc*/\n         RANGE=J1-32767,    /* Select All Job Numbers         dohwnc*/\n         ROUTECDE=(),       /* Select Jobs w/Any Dest         dohwnc*/\n         START=YES,         /* Started with $S OFFLOAD         dhwnc*/\n         UCS=,              /* Select any UCS                 dohwnc*/\n         VOLUME=(),         /* Select Any Spool Volume        dohwnc*/\n         WRITER=,           /* Select any Writer              dohwnc*/\n         WS=(Q/)            /* Job Selection Criteria         dohwnc*/\n                            /* - Class Only                   dohwnc*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    JES2 Options Definition           |\n                              |    added in SP311                    |\n                              *--------------------------------------*\n                                                                     */\n/* OPTSDEF  CKPTOPT=HIGHEST,   */\n/*       CONSOLE=YES,         */\n/*       HASPPARM=HASPPARM, */\n/*       LIST=NO, */\n/*       LISTOPT=NO, */\n/*       LOG=YES, */\n/*       LOGOPT=YES, */\n/*       RECONFIG=NO, */\n/*       REQMSG=YES, */\n/*       STARTOPT=WARM, */\n/*       STARTYPE=WARM */\n/*                                                                  */\n/*                                                                  */\nOUTCLASS(A) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=(WRITE,WRITE), /* Not a Held Class               wc*/\n         OUTPUT=PRINT,      /* Print Class                        wc*/\n         TRKCELL=YES        /* Track-Cell this Class              wc*/\n/*                                                                  */\nOUTCLASS(B) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=(WRITE,WRITE), /* Not a Held Class               wc*/\n         OUTPUT=PUNCH,      /* Print Class                        wc*/\n         TRKCELL=NO         /* No Track-Cell                      wc*/\n/*                                                                  */\nOUTCLASS(D) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=HOLD,      /* A Held Class                       wc*/\n         OUTPUT=PRINT,      /* Print Class                        wc*/\n         TRKCELL=NO         /* No Track-Cell                      wc*/\n/*                                                                  */\nOUTCLASS(J) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=(WRITE,WRITE), /* Not a Held Class               wc*/\n         OUTPUT=PRINT,      /* Special Print Class                wc*/\n         TRKCELL=NO        /* No Track-Cell                      wc*/\n/*                                                                 */\nOUTCLASS(K) BLNKTRNC=YES,  /* Truncate trailing blanks           wc*/\n         OUTDISP=(WRITE,WRITE), /* Not a Held Class               wc*/\n         OUTPUT=PUNCH,      /* Special Punch Class                wc*/\n         TRKCELL=NO         /* No Track-Cell                      wc*/\n/*                                                                 */\nOUTCLASS(L) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=HOLD,      /* A Held Class                       wc*/\n         OUTPUT=PRINT,      /* Print Class for LWTR               wc*/\n         TRKCELL=NO         /* No Track-Cell                      wc*/\n/*                                                                  */\nOUTCLASS(X) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=HOLD,      /* A Held Class                       wc*/\n         OUTPUT=PRINT,      /* Print Class                        wc*/\n         TRKCELL=YES        /* Track-Cell this class              wc*/\n/*                                                                  */\nOUTCLASS(Z) BLNKTRNC=YES,   /* Truncate trailing blanks           wc*/\n         OUTDISP=(WRITE,WRITE), /* Not a Held Class               wc*/\n         OUTPUT=DUMMY,      /* DUMMY PRINT Class                  wc*/\n         TRKCELL=YES        /* Track-Cell this class              wc*/\n/*                                                                  */\nOUTDEF   BRODCAST=NO,       /* Whether shared broadcasting     downc*/\n         COPIES=255,        /* Max. # of Copies Allowed       dohwnc*/\n         DMNDSET=NO,        /* No Demand Setup                  dwnc*/\n         JOENUM=2000,       /* Max. # of JOEs                     dc*/\n/*       JOEFREE  */        /* Number of free JOEs                 d*/\n         JOEWARN=80,        /* Warning Threshold %            dohwnc*/\n         PRTYHIGH=255,      /* Ceiling for PRTY Aging         dohwnc*/\n         PRTYLOW=0,         /* Floor for PRTY Aging           dohwnc*/\n         PRTYOUT=NO,        /* No PRTY= on // OUTPUT          dohwnc*/\n         STDFORM=STD,       /* Default Forms ID                 dwnc*/\n         USERSET=NO         /* No User Demand-Setup             dwnc*/\n/*                                                                  */\nOUTPRTY(1) PRIORITY=144,    /* Output PRTY is 144 if          dohwnc*/\n         RECORD=2000,       /*  < 2000 records (LINE)         dohwnc*/\n         PAGE=50            /*  or < 50 pages (PAGE)          dohwnc*/\n/*                                                                  */\nOUTPRTY(2) PRIORITY=128,    /* Output PRTY is 128 if          dohwnc*/\n         RECORD=5000,       /*  < 5000 records (LINE)         dohwnc*/\n         PAGE=100           /*  or < 100 pages (PAGE)         dohwnc*/\n/*                                                                  */\nPCEDEF   CNVTNUM=2,         /* Number of Converter PCEs        dhwnc*/\n         OUTNUM=2,          /* Number of Output PCEs           dhwnc*/\n         PSONUM=2,          /* Number of PSO PCEs              dhwnc*/\n         PURGENUM=2         /* Number of Purge PCEs            dhwnc*/\n/*                                                                   */\nPRINTDEF CCWNUM=200,        /* # CCWs / Print Buffer            dwnc*/\n         DBLBUFR=YES,       /* Double Buffer Lcl Prts           dwnc*/\n         FCB=6,             /* Initial FCB Loaded               dwnc*/\n         LINECT=61,         /* 61 Lines/Page                  dohwnc*/\n/*       NIFCB=8X8,    */   /* No 3800 FCB Loaded               dwnc*/\n/*       NIFLASH=****, */    /* No 3800 Flash Loaded             dwnc*/\n                             /* NOTE: the values for NIFCB= and      */\n                             /*       NIFLASH=  CANNOT be null or    */\n                             /*       asterisks (as shown here).     */\n                             /*       If the statements are not      */\n                             /*       coded at all, then the default */\n                             /*       will be asterisks. The         */\n                             /*       statements are shown this way  */\n                             /*       only to include the default    */\n                             /*       values here.                   */\n         NIUCS=0,            /* Was GT15                         dwnc*/\n         RDBLBUFR=NO,        /* Single Buffer Rmt Prts           dwnc*/\n         SEPPAGE=(LOCAL=FULL,REMOTE=HALF),\n         TRANS=NO,           /* PN-Xlate for 1403/Rm.Pr          dwnc*/\n         UCS=0               /* Bypass UCS-Loading               dwnc*/\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    Local Printers                    |\n                              *--------------------------------------*\n                                                                     */\n                             /* Alternate name for PRTn:             */\n                             /*   PRINTERn                           */\nPRT(1)  CLASS=AJ,       /* Job class that can be chosen   dohwnc*/\n        CKPTLINE=0,      /*  Max lines in a logical page    dohwnc*/\n/*      UNIT=00E,           set prt1 to printer 00e  */\n        CKPTPAGE=100,    /*  Max pages before a CKPT        dohwnc*/\n        START=NO,        /*  PRT1 comes up drained          dohwnc*/\n       WS=(W,R,Q,PRM,LIM/F,UCS,FCB,P),\n         TRKCELL=NO      /*  Records despooled 1 at a time    hwnc*/\n/*                                                                  */\nPRT(2)  CLASS=AJ,       /* Job class that can be chosen   dohwnc*/\n        CKPTLINE=0,      /*  Max lines in a logical page    dohwnc*/\n/*      UNIT=00F,            set prt2 to printer 00F  */\n        CKPTPAGE=100,    /*  Max pages before a CKPT        dohwnc*/\n        START=YES,       /*  PRT2 comes up started          dohwnc*/\n       WS=(W,R,Q,PRM,LIM/F,UCS,FCB,P),\n         TRKCELL=NO      /*  Records despooled 1 at a time    hwnc*/\n/*                                                                   */\nPUNCHDEF CCWNUM=200,         /* # CCWs / Punch Buffer            dwnc*/\n         DBLBUFR=YES,        /* Single Buffer Lcl Puns           dwnc*/\n         RDBLBUFR=NO         /* Single Buffer Rmt Puns           dwnc*/\n/*                                                                   */\nPUN(1)  CKPTLINE=100,    /* No. of cards to punch per page dohwnc*/\n        CLASS=BK,    /*  Output class processed by PUN  dohwnc*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* Work selection criterion    dohwnc*/\n/*                                                                   */\nPUN(2)  CKPTLINE=100,    /* No. of cards to punch per page dohwnc*/\n        CLass=BK,    /*  Output class processed by PUN  dohwnc*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* Work selection criterion    dohwnc*/\n/*                                                                   */\nRDR(1)  START=YES,       /* RDRnn comes up started (DRAIN) dohwnc*/\n        CLASS=A,        /* Default job class              dohwnc*/\n        HOLD=NO,        /* Jobs not held after conv.(HOLD)dohwnc*/\n        MSGCLASS=A     /* Default message class          dohwnc*/\n/*                                                                  */\n/* RECVOPTS (ALL)  */       /* JES2 Main Task                 dohwnc*/\n/*       COUNT=2,  */        /* Number of occurrences to count dohwnc*/\n/*       INTERVAL=24  */     /* Interval (in hours) in which   dohwnc*/\n                             /* errors are counted                   */\n                             /*                                      */\n/*                                                                   */\nRMT(1)    DEVTYPE=LUTYPE1,BUFSIZE=256,LINE=1,NUMRDR=0,\n          NUMPRT=1,NUMPUN=0,COMPACT=NO,COMPRESS=NO,CONS=NO\nR(1).PR(1)   CLASS=A,PRWIDTH=132,CKPTPAGE=1,CKPTLINE=66\nDESTID(KENDALL)  DEST=R1\n/*                                                                   */\nRMT(2)    DEVTYPE=LUTYPE1,BUFSIZE=256,LINE=2,NUMRDR=0,\n          NUMPRT=1,NUMPUN=0,COMPACT=NO,COMPRESS=NO,CONS=NO\nR(2).PR(1)   CLASS=A,PRWIDTH=132,CKPTPAGE=1,CKPTLINE=66\nDESTID(LASER1)  DEST=R2\n/*                                                                   */\nRMT(3)    DEVTYPE=LUTYPE1,BUFSIZE=256,LINE=3,NUMRDR=0,\n          NUMPRT=1,NUMPUN=0,COMPACT=NO,COMPRESS=NO,CONS=NO,\n          SETUP=PDIR\nR(3).PR(1)   CLASS=A,PRWIDTH=132,CKPTPAGE=1,CKPTLINE=66\nDESTID(FABO)    DEST=R3\n/*                                                                   */\nRMT(4)    DEVTYPE=LUTYPE1,BUFSIZE=256,LINE=4,NUMRDR=0,\n          NUMPRT=1,NUMPUN=0,COMPACT=NO,COMPRESS=NO,CONS=NO\nR(4).PR(1)   CLASS=A,PRWIDTH=132,CKPTPAGE=1,CKPTLINE=66\nDESTID(ARLASER) DEST=R4\n/*                                                                   */\nRMT(5)    DEVTYPE=LUTYPE1,BUFSIZE=256,LINE=5,NUMRDR=0,\n          NUMPRT=1,NUMPUN=0,COMPACT=NO,COMPRESS=NO,CONS=NO,\n          SETUP=PDIR\nR(5).PR(1)   CLASS=A,PRWIDTH=132,CKPTPAGE=1,CKPTLINE=66\nDESTID(PRCH)    DEST=R5\n/*                                                                   */\n                             /* BSC remote terminal                  */\n                             /* Work selection criteria        dohwnc*/\nSMFDEF   BUFNUM=20,          /* Number of SMF Buffers            dwnc*/\n         BUFWARN=80          /* Warning Threshold %            dohwnc*/\n/*                                                                   */\nSPOOLDEF BUFSIZE=3992,       /* Maximum Buffer Size                dc*/\n         DSNAME=SYS1.HASPACE,/* Spool Data Sets' Name              dc*/\n         FENCE=NO,           /* Don't Force to Minimum volume   downc*/\n         SPOOLNUM=32,        /* Max. Number of spool volumes      dwc*/\n         TGBPERVL=5,         /* track groups per volume in blob  dowc*/\n         TGSPACE=(MAX=16288, /* Fits TGMs into 4K Page               */\n                  WARN=80),  /* Warning Threshold %                  */\n         TGSIZE=30,          /* 30 Buffers/Track Group           dwnc*/\n         TRKCELL=3,          /* 3 Buffers/Track-cell               dc*/\n         VOLUME=RESCU        /* SPOOL VOLUME SERIAL #S               */\n/*       VOLUME=CSUSP           SPOOL VOLUME SERIAL #S             CS*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    SSI Definitions                   |\n                              |    added in SP311                    |\n                              *--------------------------------------*\n                                                                     */\nSSI(1)  TRACE=NO            /* Specify which subsystem funct  dohwnc*/\n                            /* Whether or not tracing is      dohwnc*/\n                            /*  active for this SSI function        */\n/*                                                                   */\nSTCCLASS TIME=(1440,00),     /* Job Step Time   ...mmmmss........... */\n         REGION=000K,        /* Region Size     .........ccc........ */\n         COMMAND=EXECUTE,    /* Execute Commands............r....... */\n         BLP=NO,             /* Ignore BLP parm .............l...... */\n         AUTH=ALL,           /* Allow all Cmds  ..............aaaa.. */\n         MSGLEVEL=(0,0),     /* Job, All Msgs   ..................ef */\n         IEFUJP=YES,         /* Take SMF Job Purge Exit         dhwnc*/\n         IEFUSO=YES,         /* Take SYSOUT Excess Exit         dhwnc*/\n         LOG=YES,            /* Print JES2 JOB LOG              dhwnc*/\n         MSGCLASS=A,         /* Default Message Class           dhwnc*/\n         OUTPUT=YES,         /* Produce Output for Job          dhwnc*/\n         PERFORM=000,        /* SRM Performance Group 0         dhwnc*/\n         PROCLIB=00,         /* Use //PROC00 DD                 dhwnc*/\n         SWA=BELOW,          /* SWA cbs below 16m line          dhwnc*/\n                             /*     (added by APAR OY02574)          */\n                             /*     (superseded by APAR OY03444)     */\n         TYPE6=YES,          /* Produce SMF 6 Records           dhwnc*/\n         TYPE26=YES          /* Produce SMF 26 Records          dhwnc*/\n/*                                                                   */\n/*                             TP (NJE/RJE) Characteristics          */\nTPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),\n         EXTBUF=(LIMIT=200,SIZE=1152,WARN=80),\n         MBUFSIZE=400,       /* Multi-leaving buffer size            */\n         RMTMSG=100,         /* Max. # Msgs Queued to remote         */\n         SESSION=20,         /* MAX. # SNA Sessions                  */\n         AUTOINTV=120        /* AUTO LOGIN TIMER INTERVAL       dhwnc*/\n/*                                                                   */\n/*********************************************************************/\nTRACE(1)  START=NO          /* Specify which trace id          downc*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    $TRACE Facility                   |\n                              *--------------------------------------*\n                                                                     */\nTRACEDEF TABLES=3,           /* Number of trace tables          downc*/\n         PAGES=2,            /* Number of 4K pages per table     dwnc*/\n         TABWARN=80,         /* Warning Threshold %             downc*/\n         ACTIVE=NO,          /* Whether or not to start the      dwnc*/\n                             /*  trace facility                      */\n         LOG=(START=NO,      /* Whether or not to format and    downc*/\n                             /*  add data to trace log dataset       */\n              SIZE=500,      /* Max size of trace log dataset   downc*/\n              CLASS=A)       /* Trace log dataset output class  downc*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    TSU Defaults                      |\n                              *--------------------------------------*\n                                                                     */\nTSUCLASS TIME=(1440,00),     /* Job Step Time   ...mmmmss..........  */\n         REGION=000K,        /* Region Size     .........ccc.......  */\n         COMMAND=EXECUTE,    /* Execute Commands............r......  */\n         BLP=NO,             /* Ignore BLP parm .............l.....  */\n         AUTH=ALL,           /* Allow all Cmds  ..............aaaa.  */\n         MSGLEVEL=(0,0),     /* Job, All Msgs   ..................ef */\n         IEFUJP=YES,         /* Take SMF Job Purge Exit         dhwnc*/\n         IEFUSO=YES,         /* Take SYSOUT Excess Exit         dhwnc*/\n         LOG=YES,            /* Print JES2 JOB LOG              dhwnc*/\n         MSGCLASS=Z,         /* Default Message Class           dhwnc*/\n         OUTPUT=YES,         /* Produce Output for Job          dhwnc*/\n         PERFORM=000,        /* SRM Performance Group 0         dhwnc*/\n         PROCLIB=00,         /* Use //PROC00 DD                 dhwnc*/\n         SWA=BELOW,          /* SWA cbs below 16m line          dhwnc*/\n                             /*     (added by APAR OY02574)          */\n                             /*     (superseded by APAR OY03444)     */\n         TYPE6=YES,          /* Produce SMF 6 Records           dhwnc*/\n         TYPE26=YES          /* Produce SMF 26 Records          dhwnc*/\n                             /*                                      */\n/*********************************************************************/\n$SLOGON1\n$SLINE1\n$SLINE2\n$SLINE3\n$SLINE4\n$SLINE5\n$SLINE101\n$SLINE191\n./ ADD NAME=XXLOAD00 0100-02365-02365-0941-00003-00003-00000-JMILLER\nIODF     02 SYS1              01\nNUCLEUS  1\nSYSCAT   RESCUE113CCATALOG.RESCUE\n./ ADD NAME=XXSMFPRM 0100-02365-02365-0941-00028-00028-00000-JMILLER\n     ACTIVE                       /*ACTIVE SMF RECORDING*/\n     DSNAME(SYS1.MAN1,SYS1.MAN2,SYS1.MAN3)  /* THREE DATA SETS */\n     NOPROMPT                    /*DO NOT PROMPT OPERATOR FOR OPTIONS*/\n     REC(PERM)                    /*TYPE 17 PERM RECORDS ONLY*/\n     MAXDORM(3000)               /* WRITE AN IDLE BUFFER AFTER 30 MIN*/\n     STATUS(010000)              /* WRITE SMF STATS AFTER 1 HOUR*/\n     JWT(0030)                   /* 522 AFTER 30 MINUTES*/\n     SID(CPAC)                   /* SYSTEM ID IS IPO1  .NU..RU. */\n     LISTDSN                     /* LIST DATA SET STATUS AT IPL*/\n     SYS(NOTYPE(16:19,62:69),EXITS(IEFU83,IEFU84,IEFACTRT,IEFUJV,\n                    IEFUSI,IEFUJI,IEFUTL,IEFU29),NOINTERVAL,NODETAIL)\n\n     /* COLLECT ALL RECORDS. TAKE ALL KNOWN\n        EXITS, NOTE: JES EXITS CONTROLED BY JES , THERE IS NO\n        DEFAULT INTERVAL RECORDS WRITTEN AND ONLY SUMMARY T32\n        RECORDS AS A DEFAULT FOR TSO */\n\n     SUBSYS(STC,EXITS(IEFU29,IEFU83,IEFU84,IEFUJP,IEFUSO))\n\n     /* WRITE RECORDS ACCORDING TO SYS VALUE, TAKE ONLY FIVE\n        EXITS, NOTE: IEFU29 EXECUTES IN THE MASTER ASID WHICH IS A\n        STC ADDRESS SPACE SO IEFU29 MUST BE ON FOR STC. USE ALL OTHER\n        SYS PARMETERS AS A DEFAULT  */\n /* LIB: SYS1.PARMLIB(SMFPRM00)                                   */\n /* GDE: CBIPO MVS CUSTOMIZATION\n /* DOC: THIS MEMBER OF 'SYS1.PARMLIB' CONTAINS PARAMETERS THAT\n /*      DEFINE HOW THE SMF FACILITY WILL BE USED.\n /*\n./ ADD NAME=XXVATLST 0100-02365-02365-0941-00002-00002-00000-JMILLER\nVATDEF  IPLUSE(PRIVATE) SYSUSE(PRIVATE)\nRESCUE,0,0,3390     N - STORAGE VOLUME\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESCUE20": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x026_\\x01\\x026_\\x12\\x15 w w\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2002-12-31T12:15:00", "lines": 8311, "newlines": 8311, "modlines": 0, "user": "JMILLER"}, "text": "./ ADD NAME=$$$DOC   0100-02365-02365-1141-00254-00254-00000-JMILLER\n---------------------------------------------------------------------\nRescue System Execs - V2.0\n---------------------------------------------------------------------\n03/28/2001\nJohn C. Miller\nhttp://www.jmit.com/\njohn@jmit.com\n---------------------------------------------------------------------\nNOTE: See the $$$QUIK member to get started with minimum verbiage.\n\nThe Long Version:\nThis set of Rexx execs is used to build a single-volume (3390-3), self\ncontained OS/390 rescue system.  These exec are a replacement for the\nolder rescue assembler macros for building a rescue system based on\nOS/390 version 1.3.  These exec are much better in my opinion. The\nexecs are smarter, and dynamically build lots of parmlib members,\nPROCs, etc.  This version was developed based on OS/390 version 2.10,\nand supports OMVS.  I've included TCP/IP libraries in this build.\n\nRead the $$$ members - They contain useful information, especially if\nyou are having problems.  See the $$$MAINT member for maintenance issues\nrelated to HFS and PDS-E support.  See the $$$RACF member for info on\nRACF authority that you'll need to run the jobs that build the RESCUE\nsystem.\n\nYou don't have to be an OS/390 guru to successfully use this set of\ntools to build an OS/390 rescue system.  You do however need to have a\nfairly solid grounding in OS/390 (MVS) in order to know what the various\njobs and piece parts do, and how to get past inevitable glitches.\nLiberal use of the IBM manuals will be of help.  (See the web site below\nfor some handy IBM web manuals)\n\nDISCLAIMER: You alone are responsible for any success that you have with\nthis software tool, as well as any damage done to your system, losses\nincurred, etc.\n\nI would greatly appreciate any bug reports, and will answer questions\nvia email, time permitting.\n\nGood Luck, and remember to RTFM (Read The Fine Manuals)\n\n---------------------------------------------------------------------\n            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:\n      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:\n---------------------------------------------------------------------\n* Look at the generated jobs *before* running them, especially JOBA,\n  the first job.  It is *incredibly* easy to wipe out an existing\n  PRODUCTION disk volume with JOBA if you are not careful.  JOBA\n  automatically varies a volume offline, and runs ICKDSF to\n  initialize it.  You will need to reply to an MVS console prompt\n  when JOBA runs. BEFORE replying to this message to continue, DOUBLE\n  CHECK the unit address in the message, and be sure it's the disk\n  pack that you want to wipe clean and use to build your rescue\n  system.  Most of the remaining jobs are not as dangerous, but you\n  should still review the JCL, and understand what each job is doing.\n  (This is good for the soul anyway!)\n\n* I'm making the significant assumption that you know what you're doing.\n\n  IN SHORT: If you don't know what a job is going to do, you have\n  absolutely no business running it !!!\n\n---------------------------------------------------------------------\n                       IMPORTANT NOTES:\n            READ THESE NOW TO AVOID FRUSTRATION LATER\n---------------------------------------------------------------------\n* The good news, now that I've scared you into being careful, is that\n  these execs can take some of the drudgery, tedium, and trial and error\n  out of the process of building an OS/390 system from scratch.\n\n* OS/390 is not a turnkey system, and these rescue execs are NOT, repeat\n  NOT completely automatic.  They are simply a tool that can be used to\n  greatly assist in building a single volume rescue system.  However:\n  the parameters as delivered are what I used to build a fully\n  functioning OS/390 rescue system, and so they may be pretty close to\n  what you need, or at least a good start!\n\n* So take some time to carefully review the @PARMS and @DATASET members.\n  Don't rush through this part.  Expect to do some tweaking, and expect\n  to have to do several system builds before you get a system that IPLs\n  and works as expected.\n\n  Once you get the @PARMS and @DATASET members set up the way you\n  like, it's very easy to generate a fresh set of jobs, and then run\n  the jobs to build a new system.  You'll may even learn something\n  about OS/390 by studying the generated jobs.\n\n* RACF Authorities:  See the $$$RACF member of this PDS for RACF\n  privileges that are required.\n\n* COMMAND and WAIT programs:  These programs enable the disk unit to be\n  varied online and offline by a batch job. If you want this capability\n  but don't have these programs on your system already, you can use the\n  source in the RESCUE PDS to assemble them.  Assemble these modules to\n  a linklisted APF authorized library.\n\n  The COMMAND program is one that I pulled of a CBT tape.  I added code\n  to do a RACHECK against the COMMAND profile in the APPL class looking\n  for at least READ access.  This prevents undesirable miscreants and\n  other unauthorized individuals from issuing MVS commands using this\n  program.\n\n  If you don't want to use the COMMAND and WAIT programs, code a null\n  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take\n  these parms out altogether.  The JCL generated will no longer use\n  these programs.\n\n---------------------------------------------------------------------\n                  Modifying the RESCUE execs:\n---------------------------------------------------------------------\nIf you want to tweak, hack, or otherwise modify these execs, by all\nmeans be my guest - but you're on your own.  I've tried to comment\nthe code sufficiently to give a saavy rexx coder the basic idea of\nwhat's going on. I try to avoid truly ugly, oblique, obscure, or\noverly terse ways of doing things in rexx when there's a simpler\nway, but I don't shy away from \"off the wall\" techniques when they\nwork best (or when I can't figure out a simpler way of doing a\ntask!)\n\nI've made the execs essentially modular, in that the main exec\nRESCUE calls external subroutines that are named starting with '#'.\nEach subroutine generally builds one job, or does one task.  To add\nsome new functionality of your own design, make a copy of one of the\nsubroutines like #initvol, for example, and make it do what you\nwant.\n\n---------------------------------------------------------------------\nHere's how to use these execs to build a one-pack rescue system:\n---------------------------------------------------------------------\n1)  Edit the ##PDS member, and change the 'pds=' parameter to the\n    name of the RESCUE PDS which contains this $$$DOC member as well\n    as the other RESCUE system parts.  I named the PDS\n    'SYS2.RESCUE.EXEC', but name it whatever works for you.  Just\n    remember to put that name in the ##PDS member.\n\n2)  Edit the @DATASET member to include all the datasets needed to\n    build a single volume OS/390 system.  The @DATASET members is\n    delivered with the list of datasets that I used to create a\n    OS/390 2.10 rescue system.  Your mileage may vary, and you\n    will need to be sure that all needed datasets are included.\n\n3)  Edit the @PARMS member with the values that you want.  The @PARMS\n    member is delivered with an example set of parms that were\n    actually used to successfully build a rescue system. You will want\n    to change some of the parameters.\n\n4a) Use the $BUILD job to run the rescue build execs under batch TSO.\n    Fix the jobcard and PDS name (SYSPROC DD stmt) first.\n\n4b) If desired you can place the PDS containing the rescue execs in your\n    SYSPROC concatenation, and from TSO READY enter: %RESCUE. You may\n    have to log off to let some of the jobs run, however, so this method\n    may be a pain at times.\n\n    Regardless of which option you choose, the necessary jobs and\n    members will now be built, and named sequentially JOBA..JOBn, where\n    n is howver many jobs end up getting generated.\n\n  *******************************************************************\n  *******************************************************************\n  *** NOTE: Up until this point, nothing has been been changed on ***\n  **  either the driving system or the new rescue system.  The     **\n  **  steps below this box will start tweaking and building.       **\n  **  If all goes as expected, the only changes made to the        **\n  **  driving system are:                                          **\n  **  a. The driving system mastercat will have an alias defined   **\n  **     pointing to the rescue system mastercat.                  **\n  **  b. RACF Profile TSORESC in TSOPROC class will be defined.    **\n  **  c. RACF ID $RESCUE and group $STC will be defined.           **\n  **                                                               **\n  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **\n  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **\n  **     (Did I mention that you should review each job            **\n  ***    before it is run?  Well, please do.)                     ***\n  *******************************************************************\n  *******************************************************************\n\n5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and\n    understanding the jobs *before* you run them would be, as they\n    say, \"a good thing.\"\n\n    Investigate any job steps that complete with return code 8 or\n    greater.\n\n  *******************************************************************\n  *******************************************************************\n  ***  If everything was defined right, you should now have an    ***\n  **   IPL'able OS/390 rescue system.  The steps below are some    **\n  **   areas to check before trying to IPL.  You don't have to     **\n  **   do these things now, but you'll probably save yourself      **\n  ***  some IPLs if you do check them first.                      ***\n  *******************************************************************\n  *******************************************************************\n\n6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and\n    also be sure that the necessary VTAMLST members are available on\n    your rescue system.  Use COPY statements in the @DATASET member to\n    specify members to copy.  You may want to code a special set of\n    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST\n    and VTAMLIB using COPY statements.\n\n7)  Review PARMLIB.  SYS1.RESCUE.PARMLIB is first in the PARMLIB concat,\n    followed by whatever other PARMLIBS are coded in @DATASET with the\n    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you\n    and copied to SYS1.RESCUE.PARMLIB as follows:\n\n    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)\n    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)\n    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with\n               the \"JES2\" attribute.\n    JES2PARM - JES2 parms. Member ZJES2PARM is combined with dynamically\n               built SPOOLDEF and CKPTDEF statements, and then copied to\n               the JES2PARM member in SYS1.RESCUE.PARMLIB.  Review\n               ZJES2PRM for any changes you want to make *before*\n               building the rescue jobs.  The SPOOLDEF and CKPTDEF are\n               already coded for you, but you may want to change some of\n               the other parameters, or replace the entire ZJES2PRM\n               member with your own JES2 parms.  If you do this, be sure\n               to remove the SPOOLDEF and CKPTDEF statements from the\n               source that you place in ZJES2PARM, since these two\n               statements are coded for you automatically.\n    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements\n               built dynamically.\n\n    NOTE: You'll need to be sure that one of the PARMLIB's that you're\n    copying to the RESCUE system has the remainder of the members needed\n    as coded in SYS1.RESCUE.PARMLIB(IEASYS00)'. Your production PARMLIB\n    dataset will probably work fine.\n\n8)  Review PROCLIB.  SYS1.RESCUE.PROCLIB is first in the PROCLIB\n    concat, followed by whatever other PROCLIBs are coded in\n    @DATASET with the \"JES2\" attribute: ,,(JES2).  Started procedures\n    (PROCS) are built for you and copied to SYS1.RESCUE.PROCLIB as\n    follows:\n    TSO      - TSO started PROC.\n    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and\n               VTAMLIB concatenation that you coded in @DATASET with the\n               'VTAMLST' and 'VTAMLIB' attribute respectively.\n    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00\n               concatenation that you coded in @DATASET with the 'JES2'\n               attribute.\n    TSORESC  - TSO LOGON PROC.  Includes libraries defined in @DATASET\n               with attributes:  ISPPLIB, ISPMLIB, ISPSLIB, ISPTLIB,\n               ISPLLIB, SYSPROC, SYSUADS.\n\n9)  Review IPLPARM.  SYS1.IPLPARM on the RESCUE volume has member LOAD00\n    built from the parameters you specified.  PARMLIB statements are\n    included for libraries in the @DATASET member coded with the\n    'PARMLIB' attribute.\n\n10) IPL the new rescue volume, and see what happens.  Hopefully\n    you'll be close to having a working system.  If it works the\n    first time--you rock!\n\n./ ADD NAME=$$$IDX   0100-02365-02365-1141-00053-00053-00000-JMILLER\nIndex of members:\n\nMembers starting with \"#\" are rexx subroutines.\nMembers starting with \"Z\" are input of some kind for the rescue execs.\n\"Z\" members may need some modification based on local requirements.\nMembers starting with \"@\" are input parms that you need to code.\n\n$$$DOC   - The documentation for the RESCUE execs, such as it is.\n$$$IDX   - This member.\n$$$MAINT - Info regarding OS/390 maintenance and non-SMS managed HFS.\n$$$MISC  - Miscellaneous explanations, etc.\n$$$QUIK  - Quickstart for the impatient - Better know what you're doin.\n$$$RACF  - Info on RACF authority that you'll need to run the jobs.\n$$$SARES - Info on building standalone restore tapes.  Important!\n$BUILD   - Batch job to run RESCUE system build.\n$SAREST  - Job to build a standalone RESCUE system restore tape.\n##JOBCHR - Sub-subroutine - Gives the next sequential job char.\n##PDS    - Sub-subroutine - Gives the name of the RESCUE PDS (This ds.)\n#ALCNVSM - Build JCL to allocate nonVSAM datasets.\n#ALTNVSM - Build JCL to remove System Secific Alias (SSA) (i.e. SYSX.)\n#COPYDS  - Build JCL to copy datasets.\n#COPYMEM - Build JCL to copy members specified in @DATASET member.\n#DEFMCAT - Build JCL to define the master catalog.\n#DEFNVSM - Build JCL to define nonVSAM catalog entries.\n#DEFVSAM - Build JCL to define VSAM files: STGINDEX, PAGE, SMF, etc.\n#INITVOL - Build JCL to ICKDSF init the RESCUE volume.\n#MEMBERS - Build assorted members, and store them in this PDS.\n#RFCOPY  - Build JCL to copy the RACF dataset.\n@DATASET - Place where all the RESCUE system datasets are defined.\n@PARMS   - Main setup member that defines how system will be built.\nCOMMAND  - \"COMMAND\" src - Issues MVS console commands, RACF secured.\nRESCUE   - The main exec that is run to build all the JCL and members.\nZBPXPRM  - OMVS PARMLIB member.  MOUNT statments are added to this mem.\nZIEALPA  - IEALPA00 PARMLIB member source.  Updated by execs.\nZIEASYS  - IEASYS00 PARMLIB member.\nZJES2PRM - Partial JES2PARM member.  Modifiy if desired.\nZJOBNUM  - Work member - Last job number used.  Leave this alone.\n\nMembers that get built when the RESCUE exec is run:\n\nBPXPRM00 - OMVS parms.\nIGDSMS00 - SMS parms.\nJES2     - JES2 started procedure.\nJES2PARM - JES2 parameter deck.\nJOBx     - Jobs that do the actual build of the RESCUE system.\nLOAD00   - IPLPARM LOAD00 member.\nMSTJCL01 - Master JCL PARMLIB member.\nPROGA0   - PROG PARMLIB member with APF statements.\nPROGL0   - PROG PARMLIB member with LNKLST statements.\nTSORESC  - TSO LOGON procedure.\nVTAM     - VTAM started procedure.\nZBPXPRM  - Entries are added to this member for OMVS datasets.\nZIEALPA  - Entries are added to this member for ICHRIN03 and ICHRDSNT\n./ ADD NAME=$$$MAINT 0100-02365-02365-1141-00020-00020-00000-JMILLER\nNote:\n\nThe RESCUE execs were coded on an OS/390 2.10 system with the required\nPTFs applied for the support of non-SMS managed HFS and PDS-E files.\nThe jobs generated by these exec assume such support, and may have\nproblems if your driving system does not contain the necessary PTFs from\nHFS/PDSE support on non-SMS volumes.  If this occurs, you will need to\napply the PTFs needed for your release, or settle for a two volume\nrescue system:  One volume for the main OS/390 system, and a second, SMS\nmanaged volume for the OMVS HFS files needed to bring up OMVS and\nTCP/IP.\n\nBefore I could get DFDSS to copy HFS and PDS-E datasets to non-SMS\nvolumes, I had to apply the following PTFs to OS/390 2.10.  You may\nneed these and/or others, so check IBMLink for the particulars.\n\nUW75133 UW73273 UW74319 UW75737 UW72235 UW75748 UW71231\nUW71404 UW75737 UW76206 UW74319 UW75133 UW75690 UW75748\n\n03/10/2001 John C. Miller\n./ ADD NAME=$$$MISC  0100-02365-02365-1141-00070-00070-00000-JMILLER\n---------------------------------------------------------------------\nRescue System Execs - Notes, explanations, etc.\n---------------------------------------------------------------------\n\n---------------------------------------------------------------------\nSSA\n---------------------------------------------------------------------\nExplanation:\nSystem Specific Aliases is a technique that has been used for many\nmoons by the IBM MVS software delivery groups.  An alias is defined in\nthe driving system master catalog that points to the new system\nmastercat.  Any dataset names that might conflict with live datasets\nare defined with an extra prefix (the \"SSA\") not found on the driving\nsystem.  This accomplishes 2 desirable outcomes:\n\n1) All catalog entries for RESCUE system datasets are created in the\nRESCUE system master catalog, where we want them. This avoids junk in\nthe driving system master catalog or user catalogs.\n\n2) RESCUE system datasets remain cataloged to the driving system until\nthe jobs are done manipulating them. This approach avoids the use of\nSTEPCAT DD statements, which according to IBM developers, will be\ndropped completely at some point.\n\n---------------------------------------------------------------------\nRACF Started Task Table\n---------------------------------------------------------------------\nExplanation:  I use a RACF started task module ICHRIN03 instead of\nusing profiles in the RACF STARTED class, which would probably be much\nmore cool.  I take this approach to minimize changes to the driving\n\n1) The RACF DS on the rescue system is a copy of the one on the driving\n   system.  Therefore, before copying the RACFDS from the driving\n   system, any needed RACF tweaking has to be done to the driving\n   system's RACF environment. I prefer to minimize any changes to the\n   driving systems RACF environment.  I basically add a RACF ID and a\n   RACF group, and don't activate any classes, etc.  You just need to\n   pick a USERID and GROUP name that don't already exist.  If you pick\n   a USERID or GROUP that do already exist on the driving system, the\n   generated jobs will contain whining messages to this effect.\n\n2) Messing with the STARTED class on the driving system (Which you may\n   or may not even be using) can have some dire consequences, and may\n   result in the driving system becoming non-IPLable.  I prefer to not\n   go there.\n\n---------------------------------------------------------------------\nTCP/IP\n---------------------------------------------------------------------\nTCP/IP will probably need some work by you before you can telnet in\nand log on to your new rescue system.\n\nThe RESCUE execs handle some of the required TCP/IP setup like the\nstarted task table entry for TCPIP, a RACF ID defined with a UID0 OMVS\nsegment, OMVS datasets being defined in the BPXPRM00 parmlib member,\nand maybe some other stuff that I've programmed in but forgotten.\n\nYou'll need to be sure that the necessary PROCS and parameteter\nmembers are set up right for your shop.  This is a non-trivial task,\nand I have not yet risen to the task of automating this part.  It\nshould be a fairly simple task to copy over these elements as-is from\nyour production system, and make a few changes for things like the IP\naddress and domain name, and the hardware interface.\n\n---------------------------------------------------------------------\nMSTJCL01\n---------------------------------------------------------------------\nI name the master JCL member with the \"01\" suffix to prevent the master\nscheduler from starting using any JCL found in SYS1.LINKLIB(MSTJCL00)\nThis way I can be absolutely sure that my master JCL member is used.\n./ ADD NAME=$$$QUIK  0100-02365-02365-1141-00042-00042-00000-JMILLER\n---------------------------------------------------------------------\nRescue System Execs - Quick Start\n---------------------------------------------------------------------\nOk, so you're like me -- impatient, and don't want to read through all\nthe dumb comments, disclaimers, etc.  Here's the $.50 version of how to\nuse the RESCUE execs:\n\n1)  Edit the ##PDS member, and change the 'pds=' parameter to the\n    name of the RESCUE PDS which contains this $$$DOC member as well\n    as the other RESCUE system parts.\n\n2)  Edit the @DATASET member to include all the datasets needed to\n    build a single volume OS/390 system.  The @DATASET members is\n    delivered with the list of datasets that I used to create a\n    OS/390 2.10 rescue system.  Your mileage may vary, and you\n    will need to be sure that all needed datasets are included.\n\n3)  Edit the @PARMS member with the values that you want.  The @PARMS\n    member is delivered with an example set of parms that were actually\n    used to successfully build a rescue system. You will probably want\n    to change most if not all of them.\n\n4)  Use the $BUILD job to run the rescue build execs under batch TSO.\n    Fix the jobcard and PDS name (SYSPROC DD stmt) first.\n\n5)  Run all the jobs (JOBA - JOBx).  Again, reviewing and understanding\n    the jobs before you run them would be, as they say, \"good.\"\n    Investigate any steps that are return code 8 or greater.\n\n    If you're really hot, you now have an IPL'able rescue system.\n\n    If on the other hand you're like me, you'll have a few dozen little\n    gotchas to fix, pieces that fell through the cracks.  Things like:\n\n    a. VTAMLST members that reflect your local config.  Tweak the\n    @DATASET member to auto copy members like these over.\n\n    b. Assorted PARMLIB members missing.\n    c. Some off the wall linklib that was missed somehow.\n    d. You name it.\n\n    Have Fun!\n./ ADD NAME=$$$RACF  0100-02365-02365-1141-00037-00037-00000-JMILLER\n---------------------------------------------------------------------\nRACF authority needed:\n---------------------------------------------------------------------\nBelow are some requirements for RACF authority that you'll need\nto run the jobs generated by the RESCUE exec.  You don't need\nthese permissions to runs the execs which generate the JCL and\nother members for the RESCUE system, but you will need them to actually\nrun some of the jobs.\n\nI've probably missed some--if so, please drop me a note so I can add\nthem to the list for others who use this thing.  My email is in the\n$$$DOC member - Thanks.\n\n---------------------------------------------------------------------\nRACF privileges needed:\n---------------------------------------------------------------------\nRACF SPECIAL is needed to run the IRRUT400 job, which locks the\nproduction RACF dataset, and creates a copy.  If your ID does not have\nthe RACF SPECIAL attribute, extra warning notes will be included in the\njobs that are generated, indicating that RACF SPECIAL is needed to run\nthose jobs.\n\n---------------------------------------------------------------------\nRACF Facility profiles to which you will need at least ALTER access:\n---------------------------------------------------------------------\nSTGADMIN.ADR.COPY.BYPASSACS\nSTGADMIN.ADR.COPY.PROCESS.SYS\nSTGADMIN.ADR.DUMP.TOLERATE.ENQF\nSTGADMIN.ADR.RESTORE.BYPASSACS\nSTGADMIN.ADR.RESTORE.TOLERATE.ENQF\n\nI suggest defining a generic FACILITY profile such as would be defined\nby the commands below, and getting ALTER access to it.\n\n   RDEFINE FACILITY STGADMIN.ADR.** UACC(NONE)\n   PERMIT  STGADMIN.ADR.** CLASS(FACILITY) ID(yourid) ACCESS(ALTER)\n   SETROPTS RACLIST(FACILITY) REFRESH\n./ ADD NAME=$$$SARES 0100-02365-02365-1141-00055-00055-00000-JMILLER\n------------------------------------------------------------------*\nStandalone Rescue Tapes ($SAREST)\n------------------------------------------------------------------*\nRun this job after you have a working RESCUE system built, and to\nwhich you can log on to TSO and do useful tasks.  It will create a\nset of tapes that you can use if you ever get completely hosed--i.e.\nyour system is flat on its back, and you have no system that you can\nbring up to make repairs. I have been in this very situation, and I\ncan tell you that it is *immensely* satisfying to be able to resort\nto the procedure described herein, and pull a rabbit out of a hat,\nso to speak.\n\nI suggest that you call the tapes created by this job RESCU1 -\nRESCUn, and put a stick on label on each tape with the volser\nwritten on it.  Since these tapes are non-labelled, the system\nwill not keep them straight for you!\n\nAnother very important suggestion: Before creating these tapes,\nchange the RACF password for the TSO ID you will be using to some\nnew value, and PHYSICALLY WRITE THIS DOWN on the first of the\ntapes.  The RACF password that you were using when you created\nthe RESCUE system dump tapes will likely be long forgotten by the\ntime you get around to using them.  If you can't log on to TSO,\nyour RESCUE system will be worthless.  Some sysprogs will copy\nthe production RACF dataset to their RESCUE packs as part of a\nweekly maintenance job.  DON'T DO THIS!  If your RACF dataset\nhappens to get damaged, then your RESCUE system gets damaged too.\nGet the RESCUE system up and working, and then leave it alone.\nIt should not be touched unless you really need to, such as if\nthe IO configuration changes, and you need to update the IODF\nfile to reflect the new devices.\n\n------------------------------------------------------------------*\nExample of using the stand alone RESCUE restore tape. You would\nonly use this in the event that you could not IPL a workable\nOS390 system, and had to restore the rescue system. If you have\na working OS/390 system, you can log on and do a normal DFDSS batch\nRESTORE job using these tapes.\n(In this example, the disk drive is unit 120, the tape is 380)\n------------------------------------------------------------------*\n 1) Mount the first tape written on the tape drive (380)\n 2) At the HMC set the IPL address to 380.  If you don't have an\n    HMC, then set the IPL address according to your particular CPU.\n 3) Perform an IPL (LOAD CLEAR)\n 4) From any attached local terminal hit the Enter key. You should be\n    prompted to hit CLEAR when the program is ready to go. Do so.\n 5) Specify CONSOLE for the input device.\n 6) Specify CONSOLE for the output device.\n 7) Enter the restore command:\n       RESTORE FROMDEV(3400) FROMADDR(380) TOADDR(120) NOVFY\n 8) Reply Y when prompted to restore the volume.  Make sure it's the\n    right disk unit, or you may destroy some live data.\n 9) Keep mounting tapes until they have all been read.\n10) Change the IPL address to 120, and IPL again. You're (hopefully) up.\n11) Log on to TSO, and save the day.\n./ ADD NAME=$$README 0100-02365-02365-1141-00068-00068-00000-JMILLER\n---------------------------------------------------\nOS/390 Rescue System - Version 2.0\n---------------------------------------------------\n03/28/2001\n\nBased on OS/390 version 2.10\n\nAn OS/390 system typically is spread out over several disk packs.\nThis set of Rexx execs builds the necessary jobs to generate a\ncompletely self-contained IPL'able OS/390 version 2.10 system on\na single 3390-3 disk pack.  Earlier versions of OS/390 can also\nbe used, but the techniques used for copying OMVS datasets may\nnot work depending on the release and maintenance level of the\nsystem being \"cloned.\"\n\nThe system datasets on your existing OS/390 system are copied (or\nin some cases re-created) on the one pack system, so the rescue\nsystem will be at the same maintenance level as your production\nsystem.  You can easily rebuild the rescue system after\nmaintenance is applied to the production system if so desired.\n\nI recommend that you build a rescue system on one of your \"spare\"\ndisk volumes, and then make a tape backup of this volume that you\nkeep in a safe place. This way you will have your RESCUE system\non a disk pack and ready to IPL when you need it, but you can\nalso restore over this pack if you need it for any reason, and\nrestore the RESCUE system to some other volume from your backup\ntape.  Job $SAREST will create a tape with stand alone DFDSS on\nfile 1 of the tape, and the RESCUE volume DFDSS restore image in\nfile 2.  This enables you to bring up a IPLable OS/390 system\nfrom a totally inoperable environment.  (Great for disaster\nrecovery.)\n\nThe uses for such a system are many.  For those times when you\ncannot IPL your main production system, this one pack rescue\nsystem can be IPL'd to perform the necessary repair to the\nproduction system.\n\n\nHow to transfer to MVS host:\n---------------------------------------------------\n- Download the RESCUE20.EXE self-extracting file to a PC.  Place\n  RESCUE20.EXE in a directory by itself, and run it.  This will\n  result in all required members being extracted. (These won't be\n  readable on a PC  See note below)\n\n- Create a PDS on the MVS system that will hold the RESCUE system\n  execs and parameters.  CYL(1,1,15) should be big enough.\n  RECFM=FB,LRECL=80,BLKSIZE=6160 are suitable DCB parameters.\n\n- FTP all the extracted files from the PC to the MVS PDS\n  allocated in the first step.  Use the FTP subcommand: \"BINARY\"\n  or equivalent to specify a binary transfer.  This is a must.\n  (These FTP'd files become members of the target PDS.)\n\n- Read the $$$DOC member in the PDS for further instructions.\n\nNOTE: The files that are in this self-extracting zip file are in\nEBCDIC format, so they will look like garbage on the PC, even\nafter being extracted.  They will however be normal, readable\nEBCDIC PDS members after they are extracted and transferred to an\nMVS host using Binary mode.\n\n---------------------------------------------------\n\nJohn C. Miller\njohn@jmit.com\n03/28/2001\n./ ADD NAME=$BUILD   0100-02365-02365-1141-00018-00018-00000-JMILLER\n//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M\n/*JOBPARM LINES=900000\n//*---------------------------------------------------------------*\n//* Execute TSO in batch to run RESCUE execs.                     *\n//*---------------------------------------------------------------*\n//* Before running this job, The name of the PDS containing the   *\n//* RESCUE execs and members MUST be coded in these 2 places:     *\n//* 1. The SYSPROC DD statement below, and                        *\n//* 2. In the ##PDS member.                                       *\n//*---------------------------------------------------------------*\n//* 03/11/2001 John C. Miller.                                    *\n//*---------------------------------------------------------------*\n//TSO      EXEC PGM=IKJEFT01,REGION=4M,PARM='RESCUE'\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=SYS2.RESCUE.EXEC\n//SYSTSIN  DD DUMMY\n./ ADD NAME=$SAREST  0100-02365-02365-1141-00036-00036-00000-JMILLER\n//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M\n//*------------------------------------------------------------------*\n//* $SAREST - Build an IPL'able, stand alone restore tape for the\n//* RESCUE system.\n//*------------------------------------------------------------------*\n//* IMPORTANT: See member $$$SARES notes and discussion.\n//*------------------------------------------------------------------*\n//* 03/28/2001 John C. Miller\n//*------------------------------------------------------------------*\n//*************************************************\n//* Write standalone DFDSS image in file 1        *\n//*************************************************\n//SADSS   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'\n//SAMODS    DD DSN=SYS1.SADRYLIB,DISP=SHR\n//TAPE      DD UNIT=CART,DISP=(NEW,PASS),\n//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),\n//          LABEL=(1,NL,EXPDT=98000),\n//          VOL=(,RETAIN,SER=RESCU1)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n   BUILDSA -\n       INDD(SAMODS) -\n       OUTDD(TAPE)  -\n       ADMINISTRATOR -\n       IPL(CARD) -\n       OPERCNSL(001F)\n//*************************************************\n//* Write volume dump image in file 2             *\n//*************************************************\n//DUMP     EXEC PGM=ADRDSSU,REGION=4M\n//SYSPRINT  DD SYSOUT=*\n//TAPE      DD UNIT=CART,DISP=(NEW,PASS),\n//          LABEL=(2,NL,EXPDT=98000),\n//          VOL=REF=*.SADSS.TAPE\n//SYSIN     DD *\n  DUMP INDYNAM(RESCUE) OUTDD(TAPE)\n./ ADD NAME=##JOBCHR 0100-02365-02365-1141-00059-00059-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* ##JOBCHR - Issue the next sequential job number.        */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG options .\n##JOBCHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\"\n\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\n/*---------------------------------------------------------*/\n/* Allocate jobnum file.                                   */\n/*---------------------------------------------------------*/\n##jobmemok = 1\nIF SYSDSN(\"'\"pds\"(ZJOBNUM)'\") /= OK THEN ##jobmemok = 0\n##xx = msg('OFF')\n\"FREE  FI(INOUT) \"\n##xx = msg(##xx)\n\"ALLOC FI(INOUT) DA('\"pds\"(ZJOBNUM)') SHR REUS\"\n\n/*---------------------------------------------------------*/\n/* Reset ZJOBNUM file back to 0.                           */\n/*---------------------------------------------------------*/\nIF options = 'RESET' THEN DO\n   JOBNUM.0 = 1\n   JOBNUM.1 = 0\n   \"EXECIO * DISKW INOUT (FINIS STEM JOBNUM.\"\n   exit\nEND\n\n/*---------------------------------------------------------*/\n/* Get next sequential integer for job num.                */\n/*---------------------------------------------------------*/\n/* Read the ZJOBNUM member if it's there    */\nIF SYSDSN(\"'\"pds\"(ZJOBNUM)'\") = OK THEN DO\n   \"EXECIO * DISKR INOUT (FINIS STEM JOBNUM.\"\nEND\n\n/* Reset the job num to 1 if we couldn't get a valid num.  */\nIF DATATYPE(JOBNUM.0) /= 'NUM' THEN ##jobmemok = 0\nIF \\##jobmemok THEN DO\n   JOBNUM.0 = 1\n   JOBNUM.1 = 1\nEND\n\njnum = JOBNUM.1\njnum = jnum + 1\nif jnum > length(##JOBCHARS) THEN jnum = 1\nJOBNUM.1 = jnum\nJOBNUM.0 = 1\n\"EXECIO * DISKW INOUT (FINIS STEM JOBNUM.\"\nRETURN substr(##jobchars,jnum,1)\n\n./ ADD NAME=##PDS    0100-02365-02365-1141-00017-00017-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* ##PDS    - Return main rescue PDS name.  I haven't      */\n/* figured out a reliable way of dynamically determing the */\n/* source PDS of a rexx exec.  PARSE SOURCE doesn't cut    */\n/* it. I though about using Library Management facilities, */\n/* but that complicates the process for running the RESCUE */\n/* exec under batch.  If anyone actually reads this        */\n/* comment and has a better way of doing this--do tell!    */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/* Code the name of your RESCUE PDS (This dataset) below:  */\n/*---------------------------------------------------------*/\nRETURN 'SYS2.RESCUE.EXEC'\n./ ADD NAME=#ALCNVSM 0100-02365-02365-1141-00301-00301-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #ALCNVSM - Initialize RESCUE volume.                    */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Allocate nonVSAM datasets.                         */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Allocate NONVSAM datasets.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"ALLOCNVS - Allocate nonVSAM datasets.                \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFNVSAM EXEC  PGM=IEFBR14\"\n\ndsctr = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   zzunit = strip(zzunit,\"B\");zzpri = strip(zzpri,\"B\")\n   zzsec  = strip(zzsec,\"B\"); zzdir = strip(zzdir,\"B\")\n   IF zzdsn1 = \"\" THEN ITERATE\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   dsctr = dsctr + 1\n   IF pos(zzmode,\"CDGNHX\") = 0 THEN DO\n      say \"Dataset not processed, mode must be C, D, G, N or H:\"\n      say DSNS.##xxx\n   END\n   IF zzmode = \"D\" THEN ITERATE\n   IF zzmode = \"H\" THEN ITERATE\n   IF zzmode = \"C\" THEN call allocn\n   IF zzmode = \"G\" THEN call allocn\n   IF zzmode = \"N\" THEN call allocn\nend\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/* subr */\nallocn:\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\nddname = LEFT(llq(tgtdsn),8)\ncall jcl \"//\"ddname\" DD DISP=(NEW,KEEP),UNIT=\"devtype\",\"\ncall jcl \"//         VOL=SER=\"volser\",DSN=\"ssa\"\"tgtdsn\",\"\ncall jcl \"//         SPACE=(\"zzunit\",(\"zzpri\",\"zzsec\",\"zzdir\")),\"\ncall jcl \"//         DCB=(\"zzdsn1\")\"\ncall jcl \"//*\"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n./ ADD NAME=#ALTNVSM 0100-02365-02365-1141-00304-00304-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #ALTNVSM - Alter nonVSAM entries back to final name.    */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Alter NONVSAM entries back to final names.         */\n/* (Remove the SYSX.)                                      */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Alter NONVSAM entries to final names.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"ALTERNVS - Alter NONVSAM names to final names, removing\"\ncall jcc \"           the \"ssa\" prefix. Since we aliased the SSA from\"\ncall jcc \"           the driving system's mastercat, we don't need to\"\ncall jcc \"           specify the RESCUE system catalog name in the \"\ncall jcc \"           ALTER statements. \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//ALTERNVS EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD    SYSOUT=*\"\ncall jcl \"//SYSIN    DD    *\"\n\ndsctr = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   dsctr = dsctr + 1\n   IF pos(zzmode,\"CDGNHX\") = 0 THEN DO\n      say \"Dataset not processed, mode must be C, D, G, N or H:\"\n      say DSNS.##xxx\n   END\n   IF zzmode = \"D\" THEN ITERATE\n   IF zzmode = \"C\" THEN call altern\n   IF zzmode = \"G\" THEN call altern\n   IF zzmode = \"N\" THEN call altern\nend\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/* subr */\naltern:\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\ncall jcl \"  ALTER \"ssa\"\"tgtdsn\" -\"\ncall jcl \"        NEWNAME(\"tgtdsn\") -\"\ncall jcl \"        CATALOG(\"newmcat\")\"\ncall jcl \" \"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#COPYDS  0100-02365-02365-1141-00419-00419-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #COPYDS  - Copy datasets.                               */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Copy datasets.                                     */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Copy datasets.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"COPY - Copy the datasets defined in the DATASETS member.\"\ncall jcd\ncall jcc mydate()\" \"comment\n\ndsctr = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   dsctr = dsctr + 1\n   IF pos(zzmode,\"CDGNHX\") = 0 THEN DO\n      say \"Dataset not processed, mode must be C, D, G, N or H:\"\n      say DSNS.##xxx\n   END\n   IF zzmode = \"D\" THEN call copydss\n   IF zzmode = \"C\" THEN call copyieb\n   IF zzmode = \"G\" THEN call copygen\n   IF zzmode = \"N\" THEN call copynon\n   IF zzmode = \"H\" THEN call copyhfs\nend\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/* subr */\ncopydss:\nstepname = \"DSSC\"RIGHT(\"00000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn1\" with DFDSS.\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=ADRDSSU\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"      COPY DATASET( - \"\ncall jcl \"         INCLUDE(\"zzdsn1\")) -\"\ncall jcl \"         REPLACE    -\"\nIF attrib('RLSE',zzparms) THEN,  /* If not RLSE, do ALLDATA. */\ncall jcl \"         ALLDATA(*) -\"\ncall jcl \"         TOL(ENQF) - \"\ncall jcl \"         BYPASSACS(**) -\"\ncall jcl \"         NULLSTORCLAS  -\"\ncall jcl \"         PROCESS(SYS1)  -\"\nIF zzdsn2 /= \"\" THEN,\ncall jcl \"         RENAMEU(\"zzdsn1\",\"zzdsn2\") -\"\ncall jcl \"         RECATALOG(\"newmcat\") -\"\ncall jcl \"         OUTDYNAM(\"volser\") -\"\ncall jcl \"         SHARE\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopyieb:\nstepname = \"IEBC\"RIGHT(\"0000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn1\" with IEBCOPY\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEBCOPY\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSUT1   DD DSN=\"zzdsn1\",DISP=SHR,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\ncall jcl \"//SYSUT2   DD DSN=\"ssa\"\"tgtdsn\",DISP=SHR,\"\nIF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */\ncall jcl \"//         SPACE=(CYL,(1,1,1),RLSE),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//SYSIN    DD * \"\ncall jcl \"  COPY I=SYSUT1,O=SYSUT2,LIST=NO \"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopygen:\nstepname = \"GENR\"RIGHT(\"0000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn1\" with IEBGENER\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEBGENER\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSUT1   DD DSN=\"zzdsn1\",DISP=SHR,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\ncall jcl \"//SYSUT2   DD DSN=\"ssa\"\"tgtdsn\",DISP=SHR,\"\nIF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */\ncall jcl \"//         SPACE=(CYL,(1,1,1),RLSE),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//SYSIN    DD DUMMY\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopynon:\nstepname = \"NOOP\"RIGHT(\"0000\"dsctr,4)\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\ncall jcd\ncall jcc stepname\ncall jcc \"None: \"tgtdsn\" will not be copied.\"\ncall jcc \"This dataset was specified as No-Copy (Allocate only.)\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEFBR14\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopyhfs:\nstepname = \"HFSD\"RIGHT(\"00000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn1\" HFS with DFDSS DUMP and RESTORE.\"\nIF zzdsn2 /= \"\" THEN,\ncall jcc \"Target dsn is \"zzdsn2\".\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=ADRDSSU\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//TAPE      DD DISP=(,PASS),DSN=&&TAPE,UNIT=SYSALLDA,\"\ncall jcl \"//          VOL=SER=\"workvol\",SPACE=(CYL,(350,200),RLSE)\"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"  DUMP    DATASET(  -\"\ncall jcl \"          INCLUDE(\"zzdsn1\")) -\"\ncall jcl \"          TOL(ENQF) -\"\ncall jcl \"          OUTDD(TAPE)\"\ncall jcl \"//*\"\nstepnam2 = \"HFSR\"RIGHT(\"00000\"dsctr,4)\ncall jcl \"//\"stepnam2\" EXEC PGM=ADRDSSU,COND=(4,LT,\"stepname\")\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//TAPE      DD DISP=(OLD,DELETE),DSN=&&TAPE\"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"  RESTORE DATASET( -\"\ncall jcl \"          INCLUDE(**)) -\"\ncall jcl \"          RECATALOG(\"newmcat\") -\"\ncall jcl \"          BYPASSACS(**) -\"\ncall jcl \"          NULLSTORCLAS -\"\nIF zzdsn2 /= \"\" THEN,\ncall jcl \"          RENAMEU(\"zzdsn1\",\"zzdsn2\") -\"\ncall jcl \"          OUTDYNAM(\"volser\") -\"\ncall jcl \"          REPLACE TOL(ENQF) INDD(TAPE) \"\ncall jcl \"//*\"\nRETURN\n\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##attrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##parms, ##attrib\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#COPYMEM 0100-02365-02365-1141-00469-00469-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #DEFNVSM - Define non-VSAM catalog entries              */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit            /* Read @parms and @dataset.       */\nif \\verpds() THEN exit  /* Make sure RESCUE.PARMLIB and    */\n                        /* RESCUE.PROCLIB are there.       */\n\n/*=========================================================*/\n/* JOB: Copy members from RESCUE PDS to various places.    */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Copy generated members.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"COPYMEM - Copy customized members for various PROCs,   \"\ncall jcc \"          PARMLIB members, etc.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//COPYMEM  EXEC  PGM=IEBCOPY\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\n\n/*--------------------------------------------------------------------*/\n/* Look for COPY commands in @DATASET member, and build DD statements.*/\n/* The nxtdd() function returns a unique DDNAME to associate with the */\n/* DSN passed to it.  It also saves the DSN/DD pair in the stem var   */\n/* DD.x.  DD.x.$dsn = the dsn for entry x, DD.x.$dd is the correspond.*/\n/* ddname for that entry. This enables us to look up the DDNAME for   */\n/* our second pass through the COPY statements, which is when we build*/\n/* the \"  COPY I=INDD,O=OUTDD\" statements.                            */\n/*--------------------------------------------------------------------*/\nDO xx = 1 TO DSNS.0\n   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE\n   IF POS('IN=',DSNS.xx) > 0 THEN DO\n      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','\n      /* Parse ending with space, then with ',' -- Pick shortest one. */\n      IF length(inds1) < length(inds2) THEN indsn = inds1\n      ELSE indsn = inds2\n      /* Do crude variable substitution.  */\n      indsn = varsub(indsn)\n      /* Parse ending with space, then with ',' -- Pick shortest one. */\n      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','\n      IF length(outds1) < length(outds2) THEN outdsn = outds1\n      ELSE outdsn = outds2\n      /* See if we need to code a DD statement for this DSN:          */\n      zdd = nxtdd(indsn)\n      if zdd /= \"\" THEN DO\n         call jcl \"//\"left(zdd,8)\" DD DISP=SHR,DSN=\"indsn\n      END\n      wdd = nxtdd(outdsn)\n      if wdd /= \"\" THEN DO\n         call jcl \"//\"left(wdd,8)\" DD DISP=SHR,DSN=\"outdsn\",\"\n         call jcl \"//         UNIT=SYSALLDA,VOL=SER=\"volser\n      END\n   END\nEND\n\n/* Look for COPY commands in @DATASET member, and build SYSIN stmts.  */\ncall jcl \"//SYSIN    DD *\"\nDO xx = 1 TO DSNS.0\n   IF WORD(DSNS.xx,1) /= 'COPY' THEN ITERATE\n   /* Set current IN= and OUT= libraries. */\n   IF POS('IN=',DSNS.xx) > 0 THEN DO\n      /* Parse ending with space, then with ',' -- Pick shortest one. */\n      PARSE VAR DSNS.xx 'IN=' inds1 . 1 'IN=' inds2 ','\n      IF length(inds1) < length(inds2) THEN indsn = inds1\n      ELSE indsn = inds2\n      /* Do crude variable substitution.  */\n      indsn = varsub(indsn)\n      PARSE VAR DSNS.xx 'OUT=' outds1 . 1 'OUT=' outds2 ','\n      /* Parse ending with space, then with ',' -- Pick shortest one. */\n      IF length(outds1) < length(outds2) THEN outdsn = outds1\n      ELSE outdsn = outds2\n      /* Look up the dsns in the ddname table (DD.x)  */\n      call jcl \"  COPY I=\"getdd(indsn)\",O=\"getdd(outdsn)\n   END\n   /* Handle the member statements. */\n   IF POS('M=',DSNS.xx) > 0 THEN DO\n   /* Parse membername, check for with and without parens. */\n      PARSE VAR DSNS.xx 'M=(' mem1 ')' . 1 'M=' mem2 .\n      IF mem1 /= \"\" THEN mem = mem1\n      ELSE mem = mem2\n      PARSE VAR mem m1 ',' m2 .\n      /* Do crude variable substitution.  */\n      m1 = varsub(m1); m2 = varsub(m2)\n      /* Build S M=((x,y,R)) statements. */\n      call jcl \"   S M=((\"m1\",\"m2\",R))\"\n   END\nEND\n\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\ngetdd:\n/* Get DDNAME saved for this dsn. */\nARG ##dsn\nIF VALUE(\"DD.0\") = \"DD.0\" THEN DD.0 = 0\nDO ##x10 = 1 TO DD.0\n   IF DD.##x10.$dsn = ##dsn THEN RETURN DD.##x10.$dd\nEND\nRETURN \"\"\n\nnxtdd:\n/* See if a DDNAME has been coded yet for this DSN: */\nARG ##dsn\nIF VALUE(\"DD.0\") = \"DD.0\" THEN DD.0 = 0\nDO ##x10 = 1 TO DD.0\n   IF DD.##x10.$dsn = ##dsn THEN RETURN \"\"\nEND\n\n/* It hasn't yet, so find a unique DDNAME, and code it. */\n##y10 = DD.0 + 1; DD.0 = ##y10\nDD.##y10.$dsn = ##dsn\nIF uniqdd(llq(##dsn)) THEN DO\n   DD.##y10.$dd = llq(##dsn)\n   RETURN DD.##y10.$dd\nEND\n\n/* DDname was already taken and associated with a different dsn, */\n/* so need to find a unique DDNAME (Like PROCLIB2 vs. PROCLIB)   */\n/* ##a10 is the left 6 chars of the llq.                         */\n##a10 = strip(left(llq(##dsn),6),'B')\nDO ##z10 = 1 TO 99\n  ##b10 = ##a10\"\"right(\"00\"##z10,2)    /* PARMLI01 for examle.   */\n  if uniqdd(##b10) THEN DO\n     DD.##y10.$dd = ##b10\n     RETURN DD.##y10.$dd\n  END\nEND\nRETURN \"\"  /* Greater than 99 ddnames based on the bas ddn - Error. */\n\nuniqdd:\nARG ##dd\nIF VALUE(\"DD.0\") = \"DD.0\" THEN DD.0 = 0\nDO ##x11 = 1 TO DD.0\n   IF DD.##x11.$dd = ##dd THEN RETURN 0\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n###dslst = \"\"\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .\n   zzdsn = strip(zzdsn,'B')\n   IF zzdsn = \"\" THEN ITERATE\n   IF attrib(##prm,zzparm) THEN DO\n      IF zzdsn2 /= \"\" THEN,\n      ###dslst = ###dslst\" \"zzdsn2\n      ELSE,\n      ###dslst = ###dslst\" \"zzdsn1\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdsthere:\nARG ##prm .\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n\ndo ##xxx = 1 TO DSNS.0\n   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*---------------------------------------------------------*/\n/* Check for presence of all datasets.  If copy mode is    */\n/* \"N\" meaning the DS is not copied bu just created, then  */\n/* assume it is ok.                                        */\n/*---------------------------------------------------------*/\nverpds:\n##ok1 = 0; ##ok2 = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   IF zzdsn2 = 'SYS1.RESCUE.PARMLIB' THEN ##ok1 = 1\n   IF zzdsn2 = 'SYS1.RESCUE.PROCLIB' THEN ##ok2 = 1\nEND\n\nIF \\##ok1 THEN DO\n   SAY \"SYS1.RESCUE.PARMLIB not defined in @DATASET member;\"\nEND\nIF \\##ok2 THEN DO\n   SAY \"SYS1.RESCUE.PROCLIB not defined in @DATASET member;\"\nEND\nIF \\##ok1 | \\##ok2 THEN DO\n   SAY \"Unable to continue.\"\nEND\n\nRETURN ##ok1 & ##ok2\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##attrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#DEFMCAT 0100-02365-02365-1141-00276-00276-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #DEFMCAT - Define master catalog.                       */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Define master catalog.                             */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Define master catalog.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"DEFMCAT - Define new master catalog.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFMCAT  EXEC PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" \"\ncall jcl \"      DEFINE USERCATALOG     ( -\"\ncall jcl \"             NAME(\"newmcat\") -\"\ncall jcl \"             CYL(5 2) - \"\ncall jcl \"             VOL(\"volser\") -\"\ncall jcl \"             BUFFERSPACE(8192) -\"\ncall jcl \"             BUFND(10) -\"\ncall jcl \"             BUFNI(10) -\"\ncall jcl \"             ICFCATALOG -\"\ncall jcl \"             STRNO(9) ) -\"\ncall jcl \"             CATALOG(\"oldmcat\")\"\ncall jcl \" \"\nIF VALUE(\"ssa\") /= \"SSA\" & ssa /= \"\" THEN DO\n   zzssa = STRIP(ssa,\"B\",\".\")   /* Get rid of trailing \".\" */\n   call jcl \"      IF MAXCC = 0 THEN DO \"\n   call jcl \"         DELETE \"zzssa\" ALIAS\"\n   call jcl \"         SET MAXCC=0\"\n   call jcl \" \"\n   call jcl \"         DEFINE ALIAS(NAME(\"zzssa\") -\"\n   call jcl \"         RELATE(\"newmcat\")) -\"\n   call jcl \"         CATALOG(\"oldmcat\")\"\n   call jcl \"      END\"\n   call jcl \" \"\nEND\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#DEFNVSM 0100-02365-02365-1141-00307-00307-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #DEFNVSM - Define non-VSAM catalog entries              */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Define NONVSAM catalog entries.                    */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Define NONVSAM catalog entries.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"NONVSAM - Define non-VSAM catalog entries for datasets      \"\ncall jcc \"          not copied by DFDSS.  We only define datasets that\"\ncall jcc \"          are not processed by DFDSS, because DFDSS catalogs\"\ncall jcc \"          as part of the COPY operation.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFNVSAM EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" LISTCAT ENT(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" IF LASTCC = 0 THEN DO\"\n\n\ndsctr = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   dsctr = dsctr + 1\n   IF pos(zzmode,\"CDGNHX\") = 0 THEN DO\n      say \"Dataset not processed, mode must be C, D, G, N or H:\"\n      say DSNS.##xxx\n   END\n   IF zzmode = \"D\" THEN ITERATE\n   IF zzmode = \"C\" THEN call defnvs\n   IF zzmode = \"G\" THEN call defnvs\n   IF zzmode = \"N\" THEN call defnvs\nend\ncall jcl \" END\"\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/* subr */\ndefnvs:\nIF zzdsn2 /= \"\" THEN tgtdsn = zzdsn2\nELSE tgtdsn = zzdsn1\ncall jcl \"    DEFINE NONVSAM ( -\"\ncall jcl \"       NAME(\"ssa\"\"tgtdsn\") -\"\ncall jcl \"       DEVT(\"devtype\") VOL(\"volser\")) \"\ncall jcl \" \"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#DEFVSAM 0100-02365-02365-1141-00469-00469-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #DEFVSAM - Define VSAM files.                           */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Define VSAM files.                                 */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Define VSAM files.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"DEFVSAM - Define MANx, PAGE, STGINDEX datasets.\"\ncall jcd\ncall jcc \"Define the datasets with the SSA prefix: \"ssa\", so that the\"\ncall jcc \"catalog entries are defined in our new rescue master catalog,\"\ncall jcc newmcat\". After the define, perform an IDCAMS ALTER to remove \"\ncall jcc \"the SSA prefix, and restore the file back to it's final name.\"\ncall jcc \"These gyrations avoid the use of the STEPCAT DD statement  \"\ncall jcc \"which may become unsupported in the future.\"\ncall jcd\ncall jcc \"We check for the SSA being defined before doing any defines.\"\ncall jcc \"This prevents us from inadvertently storing junk in the \"\ncall jcc \"mster catalog of the driving system.                       \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFVSAM  EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" LISTCAT ALL ENTRY(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" IF LASTCC = 0 THEN DO\"\ncall jcl \" \"\ncall jcl \"      DEFINE CLUSTER ( -\"\ncall jcl \"                NAME( \"ssa\"SYS1.STGINDEX ) -\"\ncall jcl \"                CYL(5) - \"\ncall jcl \"                VOL(\"volser\") -\"\ncall jcl \"                BUFFERSPACE(20480) - \"\ncall jcl \"                FILE(TARGET) -\"\ncall jcl \"                KEYS(12 8) - \"\ncall jcl \"                RECORDSIZE(2041,2041) -\"\ncall jcl \"                REUSE ) - \"\ncall jcl \"             DATA ( -\"\ncall jcl \"                NAME( \"ssa\"SYS1.STGINDEX.DATA ) -\"\ncall jcl \"                CISZ(2048) ) - \"\ncall jcl \"             INDEX ( - \"\ncall jcl \"                NAME( \"ssa\"SYS1.STGINDEX.INDEX ) -\"\ncall jcl \"                CISZ(1024) )\"\ncall jcl \" \"\ncall jcl \"       IF LASTCC = 0 THEN DO \"\ncall jcl \"          ALTER \"ssa\"SYS1.STGINDEX -\"\ncall jcl \"             NEWNAME( SYS1.STGINDEX ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"          ALTER \"ssa\"SYS1.STGINDEX.DATA -\"\ncall jcl \"             NEWNAME( SYS1.STGINDEX.DATA ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"          ALTER \"ssa\"SYS1.STGINDEX.INDEX -\"\ncall jcl \"             NEWNAME( SYS1.STGINDEX.INDEX ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"       END \"\ncall jcl \" \"\ncall jcl \" \"\ncall jcl \"     DEFINE PAGESPACE ( -\"\ncall jcl \"                NAME( \"ssa\"PAGE.RESCUE.PLPA) -\"\ncall jcl \"                   CYL(150) - \"\ncall jcl \"                   VOL(\"volser\") -\"\ncall jcl \"                   FILE(TARGET) - \"\ncall jcl \"                   NOSWAP - \"\ncall jcl \"                   UNIQUE )  \"\ncall jcl \" \"\ncall jcl \"       IF LASTCC = 0 THEN DO \"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.PLPA -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.PLPA ) - \"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.PLPA.DATA -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.PLPA.DATA ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"       END \"\ncall jcl \" \"\ncall jcl \" \"\ncall jcl \"     DEFINE PAGESPACE ( - \"\ncall jcl \"                NAME( \"ssa\"PAGE.RESCUE.COMMON) -\"\ncall jcl \"                   CYL(150) - \"\ncall jcl \"                   VOL(\"volser\") -\"\ncall jcl \"                   FILE(TARGET) - \"\ncall jcl \"                   NOSWAP - \"\ncall jcl \"                   UNIQUE ) - \"\ncall jcl \" \"\ncall jcl \"       IF LASTCC = 0 THEN DO \"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.COMMON -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.COMMON ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.COMMON.DATA -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.COMMON.DATA ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"       END \"\ncall jcl \" \"\ncall jcl \" \"\ncall jcl \"     DEFINE PAGESPACE ( -\"\ncall jcl \"                NAME( \"ssa\"PAGE.RESCUE.LOCAL1) -\"\ncall jcl \"                   CYL(150) - \"\ncall jcl \"                   VOL(\"volser\") -\"\ncall jcl \"                   FILE(TARGET) -\"\ncall jcl \"                   NOSWAP - \"\ncall jcl \"                   UNIQUE )  \"\ncall jcl \" \"\ncall jcl \"       IF LASTCC = 0 THEN DO \"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.LOCAL1 -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.LOCAL1 ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"          ALTER \"ssa\"PAGE.RESCUE.LOCAL1.DATA -\"\ncall jcl \"             NEWNAME( PAGE.RESCUE.LOCAL1.DATA ) -\"\ncall jcl \"             CATALOG(\"newmcat\")\"\ncall jcl \"       END \"\ncall jcl \" \"\ncall jcl \" \"\n\n/*---------------------------------------------------------*/\n/* Build defines for each SMF ds as defined in @DATASET,   */\n/* i.e. dsns that have the SMF parm coded.                 */\n/*---------------------------------------------------------*/\ncall smflist   /* Make list of SMF datasets. */\n\nDO xx = 1 TO SMF.0\n   smfds  = SMF.xx.$ds\n   smfpri = SMF.xx.$pri\n   smfpri = strip(smfpri,'L','0')\n   call jcl \"     DEFINE CLUSTER ( - \"\n   call jcl \"                NAME( \"ssa\"\"smfds\" ) -\"\n   call jcl \"                   CYL( \"smfpri\" ) -\"\n   call jcl \"                   VOL(\"volser\") -\"\n   call jcl \"                   CISZ(4096) - \"\n   call jcl \"                   FILE(TARGET) - \"\n   call jcl \"                   NONINDEXED - \"\n   call jcl \"                   RECORDSIZE(4086 32767) - \"\n   call jcl \"                   REUSE   SHR(2 3) - \"\n   call jcl \"                   SPANNED  SPEED ) - \"\n   call jcl \"             DATA ( -  \"\n   call jcl \"                     NAME( \"ssa\"\"smfds\".DATA) ) \"\n   call jcl \" \"\nEND\n\n/* Closing END from highest level IF LASTCC (from alias).  */\ncall jcl \" END \"\ncall jcl \"//*\"\n\n/*---------------------------------------------------------*/\n/* Format SMF datasets.  They still have the SSA on front. */\n/*---------------------------------------------------------*/\ncall jcd\ncall jcc \"FMTSMF   - Format SMF datasets.\"\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//FMTSMF EXEC PGM=IFASMFDP\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\nDO xx = 1 TO SMF.0\n   smfds = SMF.xx.$ds\n   smfds = ssa\"\"smfds\n   call jcl \"//\"substr(llq(smfds),1,8)\" DD DSN=\"smfds\",DISP=SHR,\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\nEND\ncall jcl \"//SYSIN    DD *\"\nDO xx = 1 TO SMF.0\n   smfds = SMF.xx.$ds\n   call jcl \"   INDD(\"llq(smfds)\",OPTIONS(CLEAR))\"\nEND\ncall jcl \"//*\"\n\n/*---------------------------------------------------------*/\n/* Rename SMF datasets to final name (remove SSA).         */\n/*---------------------------------------------------------*/\ncall jcd\ncall jcc \"RENSMF   - Rename SMF datasets.\"\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//RENSMF EXEC PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//SYSIN    DD *\"\ncall jcl \" LISTCAT ALL ENTRY(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" IF LASTCC = 0 THEN DO\"\ncall jcl \" \"\nDO xx = 1 TO SMF.0\n   smfds = SMF.xx.$ds\n   call jcl \"       ALTER \"ssa\"\"smfds\" -\"\n   call jcl \"          NEWNAME( \"smfds\" ) -\"\n   call jcl \"          CATALOG(\"newmcat\")\"\n   call jcl \"       ALTER \"ssa\"\"smfds\".DATA -\"\n   call jcl \"          NEWNAME( \"smfds\".DATA ) -\"\n   call jcl \"          CATALOG(\"newmcat\")\"\n   call jcl \" \"\nEND\ncall jcl \" END\"\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Make a list of SMF datasets, plus the PRI and SEC aloc. */\n/*---------------------------------------------------------*/\nsmflist:\nSMF.0 = 0\n##x91 = 0\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   zzparms = translate(zzparms,'    ','(),.')\n   IF WORDPOS('SMF',zzparms) > 0 THEN DO\n      ##x91 = ##x91 + 1\n      SMF.##x91.$ds = zzdsn1\n      SMF.##x91.$pri = zzpri\n   END\nend\nSMF.0 = ##x91\n\nRETURN\n\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#DELSSA  0100-02365-02365-1141-00255-00255-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #DELSSA  - Delete SSA.                                  */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Delete the SSA (System Specific Alias)             */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Delete SSA: \"ssa\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"DELSSA  - Delete the System Specifc Alias: \"ssa\".\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DELSSA   EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" DELETE \"strip(ssa,\"B\",\".\")\" ALIAS\"\ncall jcl \" \"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#INITVOL 0100-02365-02365-1141-00356-00356-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #INITVOL - Initialize RESCUE volume.                    */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Initialize RESCUE volume, define VVDS, VTOC, etc.  */\n/*=========================================================*/\njobnum = ##jobchr()\n\n/*---------------------------------------------------------*/\n/* See if COMMANDPGM and WAITPGM are coded in parms.  If   */\n/* not, then don't code the ONLINE and OFFLINE steps.      */\n/*---------------------------------------------------------*/\nIF VALUE(\"COMMANDPGM\") = \"COMMANDPGM\" | commandpgm = \"\" THEN cmdpgm = 0\nELSE cmdpgm = 1\n\nSay \"Building Job \"jobnum\": Init disk pack.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"EXPORTD - Export the new mcat for good measure.\"\nIF cmdpgm THEN,\ncall jcc \"OFFLINE - Vary the target VOLSER offline.\"\ncall jcc \"DSFINIT - Initialize the volume with ICKDSF.\"\nIF cmdpgm THEN,\ncall jcc \"ONLINE  - Vary the target VOLSER online.\"\ncall jcc \"DEFVVDS - Define VVDS on volume.\"\ncall jcd\ncall jcc \"NOTE: You will need to reply to the ICKDSF message ICK003D\"\ncall jcc \"on the MVS console after submitting this job.BE SURE that\"\ncall jcc \"the address specified in this message is the correct disk\"\ncall jcc \"unit.  If the wrong address is specified, and this wrong\"\ncall jcc \"address is an offline disk unit, it will be completely wiped\"\ncall jcc \"out, and will have to be recovered from a backup.\"\n\n/*---------------------------------------------------------*/\n/* Can't automatically do V ONLINE etc., so place notes    */\n/* in JCL to that effect.                                  */\n/*---------------------------------------------------------*/\nIF \\cmdpgm THEN DO\n   call jcd\n   call jcc \"NOTE: The 'COMMAND' and/or 'WAIT' programs were not coded \"\n   call jcc \"in the @PARMS member.  You will need to manually vary the \"\n   call jcc \"disk unit for the rescue system offline, and online.      \"\n   call jcc \" \"\n   call jcc \"Before running this job, vary the disk unit offline from  \"\n   call jcc \"the MVS console using the command: \"\n   call jcc \"   V \"addr\",OFFLINE\"\n   call jcc \"After replying to the the ICKDSF message to confirm the\"\n   call jcc \"initialization of the disk pack, you will need to reply\"\n   call jcc \"to the MVS allocation message with the address of the  \"\n   call jcc \"new rescue volume, \"addr\".\"\nEND\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//EXPORTD    EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN      DD * \"\ncall jcl \"     EXPORT \"newmcat \"-\"\ncall jcl \"            DISCONNECT    \"\ncall jcl \"     SET MAXCC=0  \"\n/*---------------------------------------------------------*/\n/* If COMMAND cmd is available, us it to do the VARY.      */\n/*---------------------------------------------------------*/\nIF cmdpgm THEN DO\n   call jcd\n   call jcc   \" OFFLINE\"\n   call jcd\n   call jcl \"//OFFLINE    EXEC PGM=COMMAND,PARM='V \"addr\",OFFLINE'\"\n   call jcl \"//WAIT       EXEC PGM=WAIT,PARM=2\"\nEND\ncall jcd\ncall jcc   \"DSFINIT - DSF Initialize\"\ncall jcd\ncall jcl \"//DSFINIT  EXEC PGM=ICKDSF\"\ncall jcl \"//IPLTEXT  DD DISP=SHR,VOL=SER=\"sysres\",UNIT=SYSALLDA,\"\ncall jcl \"//         DSN=SYS1.SAMPLIB(IPLRECS)\"\ncall jcl \"//         DD DISP=SHR,VOL=SER=\"sysres\",UNIT=SYSALLDA,\"\ncall jcl \"//         DSN=SYS1.SAMPLIB(IEAIPL00)\"\ncall jcl \"//SYSPRINT DD     SYSOUT=* \"\ncall jcl \"//SYSIN      DD   *        \"\ncall jcl \" INIT     UNIT(\"addr\") -   \"\ncall jcl \"          VOLID(\"volser\") -\"\ncall jcl \"          VTOC(0,1,14) -  \"\ncall jcl \"          PURGE -  \"\ncall jcl \"          MAP -  \"\ncall jcl \"          NOVERIFY -  \"\ncall jcl \"          NOVALIDATE -  \"\ncall jcl \"          NOCHECK -  \"\ncall jcl \"          IPLDD(IPLTEXT) - \"\ncall jcl \"          NOBOOTSTRAP\"\ncall jcl \"//*\"\n/*---------------------------------------------------------*/\n/* If COMMAND cmd is available, us it to do the VARY.      */\n/*---------------------------------------------------------*/\nIF cmdpgm THEN DO\n   call jcd\n   call jcc   \" ONLINE - Vary the disk unit back online.\"\n   call jcd\n   call jcl \"//ONLINE   EXEC PGM=COMMAND,PARM='V \"addr\",ONLINE'\"\n   call jcl \"//WAIT     EXEC PGM=WAIT,PARM=2\"\nEND\ncall jcd\ncall jcc   \"DEFVVDS - Define VVDS.\"\ncall jcd\ncall jcl \"//DEFVVDS  EXEC PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//TARGET   DD DISP=SHR,UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//SYSIN    DD *\"\ncall jcl \" DELETE    SYS1.VVDS.V\"volser\" -\"\ncall jcl \"           FILE(TARGET) CLUSTER PURGE -\"\ncall jcl \"           CATALOG(\"oldmcat\") \"\ncall jcl \" SET MAXCC=0\"\ncall jcl \" \"\ncall jcl \" DEFINE CLUSTER ( -\"\ncall jcl \"             NAME(SYS1.VVDS.V\"volser\") -\"\ncall jcl \"             CYL(1,1) -\"\ncall jcl \"             VOL(\"volser\") -\"\ncall jcl \"             FILE(TARGET) - \"\ncall jcl \"             NONINDEXED - \"\ncall jcl \"             OWNER(RESCUE) ) -\"\ncall jcl \"          CATALOG(\"oldmcat\")\"\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#MEMBERS 0100-02365-02365-1141-00823-00823-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* MEMBERS - Build various RESCUE system members.          */\n/*---------------------------------------------------------*/\n/* 03/08/2001 John C. Miller                               */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit           /* Read parms, initialize vars.     */\n\n/*---------------------------------------------------------*/\n/* Call routines to build various members.                 */\n/*---------------------------------------------------------*/\ncall iodf              /* LOAD00 for IODF.                 */\ncall apf               /* PROGA0 for APF.                  */\ncall lnklst            /* PROGL0 for LNKLST.               */\ncall lpa               /* LPALST00.                        */\ncall jes2              /* PROC for JES2.                   */\ncall jes2parm          /* Create JES2PARM.                 */\ncall tsoproc           /* TSO LOGON PROC.                  */\ncall vtamproc          /* VTAM startup proc.               */\ncall mstrjcl           /* MSTRJCL00.                       */\ncall bpxprm            /* LOAD00 for IODF.                 */\ncall igdsms            /* IGDSMS00 member.                 */\n\nexit\n\n/*=====================================*/\n/*  Build the LOAD00 member            */\n/*=====================================*/\niodf:\nSAY \"Building LOAD00 IPLPARM member.\"\n##iodf = \"00\"\n##iodfsys = \"SYS1\"\n/* See if nonstandard SYSx prefix. */\nIF substr(iodf,1,3) = 'SYS' THEN DO\n   PARSE VAR iodf ##iodfsys \".\" .\nEND\n\n/* See if nonstandard IODFxx prefix. */\n##y9 = POS('.IODF',iodf)\nIF ##y9 > 0 THEN ##iodf = substr(iodf,##y9+5,2)\ncall setout pds,'LOAD00'  /* Set output member name.  */\ncall jcl \"IODF     \"##iodf\" \"substr(##iodfsys,1,8)\"\",\n         substr(ioconfigid,1,9)\"00\"\ncall jcl \"NUCLEUS  1\"\ncall jcl \"SYSCAT   \"substr(volser,1,6)\"113C\"newmcat\n\n/* Add PARMLIBs */\nlibs = xdslist('PARMLIB')\nDO x = 1 TO WORDS(libs)\n   call jcl \"PARMLIB  \"substr(WORD(libs,x),1,45)volser\nEND\n\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/*=====================================*/\n/*  Build the PROGA0 member (APF libs) */\n/*=====================================*/\napf:\nSAY \"Building PROGA0 PARMLIB member.\"\ncall setout pds,'PROGA0'  /* Set output member name.  */\n\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"/* APF entries dynamically built by RESCUE exec.    */\"\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"APF FORMAT(DYNAMIC)\"\n\n/* Add APF LIBs */\nlibs = xdslist('APF')\nDO x = 1 TO WORDS(libs)\n   ##z10 = \"APF ADD \"substr(\"DSNAME(\"WORD(libs,x)\")\",1,46)\n   ##z10 = ##z10\"VOLUME(\"volser\")\"\n   call jcl ##z10\nEND\n\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/*=====================================*/\n/*  Build the PROGL0 member (LNKlist)  */\n/*=====================================*/\nlnklst:\nSAY \"Building PROGL0 PARMLIB member.\"\ncall setout pds,'PROGL0'  /* Set output member name.  */\n\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"/* LNKLST entries dynamically built by RESCUE exec. */\"\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"LNKLST DEFINE NAME(LNKLST00)\"\n\n/* Add LNKLST LIBs */\nlibs = xdslist('LNK')\nDO x = 1 TO WORDS(libs)\n   ##z10 = \"LNKLST ADD NAME(LNKLST00)\"\n   call jcl ##z10\n   ##z10 = \"     DSNAME(\"substr(WORD(libs,x)\")\",1,40)\"VOLUME(\"volser\")\"\n   call jcl ##z10\nEND\n\ncall jcl \"LNKLST ACTIVATE NAME(LNKLST00)\"\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=====================================*/\n/*  Build the LPALST member.           */\n/*=====================================*/\nlpa:\nSAY \"Building LPALST00 PARMLIB member.\"\ncall setout pds,'LPALST00'  /* Set output member name.  */\n\n/* Add LPALST LIBs */\nlibs = xdslist('LPA')\nDO x = 1 TO WORDS(libs)\n   IF x < WORDS(libs) THEN,\n   call jcl WORD(libs,x)\",\"\n   ELSE,\n   call jcl WORD(libs,x)\nEND\n\ncall clsout pds\nRETURN\n\n\n/*=====================================*/\n/*  Build the JES2 PROC.               */\n/*=====================================*/\njes2:\nSAY \"Building JES2 PROC.\"\ncall setout pds,'JES2'  /* Set output member name.  */\n\ncall jcd\ncall jcc \"JES2 Startup PROC.\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\ncall jcl \"//JES2     PROC JESPARM=JES2PARM\"\ncall jcl \"//IEFPROC  EXEC PGM=HASJES20,\"\ncall jcl \"//            DPRTY=(15,15),TIME=1440,PERFORM=9\"\ncall jcl \"//HASPPARM DD DISP=SHR,DSN=SYS1.RESCUE.PARMLIB(&JESPARM)\"\n\n/* Add PROCLIBs */\nlibs = xdslist('JES2')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//PROC00   DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\ncall jcl \"//*\"\ncall jcl \"//IEFRDER  DD SYSOUT=*\"\ncall jcl \"//*\"\ncall jcl \"//HASPLIST DD DDNAME=IEFRDER\"\ncall jcl \"//*\"\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=====================================*/\n/*  Build the JES2PARM member.         */\n/*=====================================*/\njes2parm:\nSAY \"Building JES2 PARMS.\"\ncall setout pds,'JES2PARM'    /* Set output member name.  */\ncall setinp pds,'ZJES2PRM','JES2PRM.' /* Input member name.  */\n\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"/* JES2 Parameter deck.                                  */\"\ncall jcl \"/* Built dynamically by RESCUE exec, \"mydate()\"          */\"\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"CKPTDEF  CKPT1=(DSNAME=SYS1.HASPCKPT,\"\ncall jcl \"         INUSE=YES,VOLSER=\"volser\")\"\ncall jcl \"SPOOLDEF BUFSIZE=3856,\"\ncall jcl \"         DSNAME=\"chkpoint\",\"\ncall jcl \"         FENCE=NO,\"\ncall jcl \"         SPOOLNUM=32,\"\ncall jcl \"         TGBPERVL=5,\"\ncall jcl \"         TGSPACE=(MAX=16288,WARN=80),\"\ncall jcl \"         TGSIZE=33,\"\ncall jcl \"         TRKCELL=5,\"\ncall jcl \"         VOLUME=\"spoolvol\n/*-------------------------------------*/\n/*  Copy rest of parms from JES2PRM.   */\n/*-------------------------------------*/\nDO x = 1 TO JES2PRM.0\n   call jcl JES2PRM.x\nEND\n\ncall clsout pds,'JES2PARM'\nDROP JES2PRM.\n\nRETURN\n\n\n/*=====================================*/\n/*  Build the BPXPRM00 member.         */\n/*=====================================*/\nbpxprm:\nSAY \"Building OMVS PARMLIB member BPXPRM00.\"\ncall setout pds,'BPXPRM00'    /* Set output member name.  */\ncall setinp pds,'ZBPXPRM','BPXPRM.' /* Input member name. */\n\n/*--------------------------------------------------------*/\n/*  Create haeader and copy main part of BPXPRM.          */\n/*--------------------------------------------------------*/\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"/* OMVS parameters.                                      */\"\ncall jcl \"/* Built dynamically by RESCUE exec, \"mydate()\"          */\"\ncall jcl \"/*-------------------------------------------------------*/\"\nDO x = 1 TO BPXPRM.0\n   call jcl BPXPRM.x\nEND\ncall jcl \" \"\n\n/*--------------------------------------------------------*/\n/*  Build MOUNT statments for OMVS libs.                  */\n/*--------------------------------------------------------*/\nDO x = 1 TO DSNS.0\n   /*--------------------------------------------------------*/\n   /* Parse out dsn1, dsn2 and the parms for each dataset in */\n   /* the @DATASET member.  Any that have OMVSxxx will have  */\n   /* a mount entry defined in BPXPRM00.                     */\n   /*--------------------------------------------------------*/\n   PARSE VAR DSNS.x . ',' . ',' . ',' . ',' . ',',\n                    zzdsn1 ',' zzdsn2 ',' '(' zzparms ')' .\n   /* Symbolic substitution in case &WHATVER was specified. */\n   zzdsn1 = varsub(zzdsn1); zzdsn2 = varsub(zzdsn2)\n   IF POS('OMVS',zzparms) = 0 THEN ITERATE\n   PARSE VAR zzparms 'OMVS' omvsprm .    /* Is this an OMVS* entry? */\n   IF zzdsn2 /= \"\" THEN zzdsn = zzdsn2   /* Use dsn2 if its there.  */\n   ELSE zzdsn = zzdsn1\n   /* Yes, it's an OMVS parm, so make a MOUNT command for it.*/\n   IF omvsprm /= \"\" THEN call omvsmnt omvsprm, zzdsn\nEND\n\ncall clsout pds\nDROP BPXPRM.\nRETURN\n\n/* subr. */\nomvsmnt:\nPARSE ARG ##omvsprm, ##omvsds\nIF ##omvsprm = '/'    THEN DO\n   call jcl \"ROOT     FILESYSTEM('\"##omvsds\"')\"\n   call jcl \"         TYPE(HFS)\"\n   call jcl \"         MODE(RDWR)\"\n   call jcl \" \"\nEND\nELSE DO\n   call jcl \"MOUNT    FILESYSTEM('\"##omvsds\"')\"\n   call jcl \"         MOUNTPOINT('\"##omvsprm\"')\"\n   call jcl \"         TYPE(HFS)\"\n   call jcl \"         MODE(RDWR)\"\n   call jcl \" \"\nEND\nRETURN\n\n/*=====================================*/\n/*  Build the TSO LOGON PROC.          */\n/*=====================================*/\ntsoproc:\nIF SYMBOL(\"TSOPROC\") = 'LIT' THEN DO\n   Say \"TSOPROC name not defined in @PARMS member, no TSO PROC created.\"\n   RETURN\nEND\n\nSAY \"Building TSO LOGON PROC\" tsoproc\".\"\n\ncall setout pds,tsoproc    /* Set output member name.  */\n\ncall jcd\ncall jcc \"TSO LOGON PROC\"tsoproc\".\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\np = substr(tsoproc,1,8)\ncall jcl \"//\"p\" PROC\"\ncall jcl \"//IKJACCNT EXEC PGM=IKJEFT01,DYNAMNBR=200,PARM='%ISPALLOC'\"\n\n/* Add ISPPLIBs */\nlibs = xdslist('ISPPLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//ISPPLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPMLIBs */\nlibs = xdslist('ISPMLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//ISPMLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPSLIBs */\nlibs = xdslist('ISPSLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//ISPSLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPLLIBs */\nlibs = xdslist('ISPLLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//ISPLLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPTLIBs */\nlibs = xdslist('ISPTLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//ISPTLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSPROCs */\nlibs = xdslist('SYSPROC')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//SYSPROC  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSHELPs */\nlibs = xdslist('SYSHELP')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//SYSHELP  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSLBC */\nlibs = xdslist('SYSLBC')\nIF words(libs) > 0 THEN DO\n   call jcl \"//SYSLBC   DD DISP=SHR,DSN=\"WORD(libs,1)\nEND\n\n/* Add MISC LOGON statements. */\n\ncall jcl \"//SYSPRINT DD TERM=TS,SYSOUT=Z\"\ncall jcl \"//SYSTERM  DD TERM=TS,SYSOUT=Z\"\ncall jcl \"//SYSIN    DD TERM=TS \"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=====================================*/\n/*  Build the VTAM startup PROC.       */\n/*=====================================*/\nvtamproc:\nSAY \"Building VTAM PROC.\"\ncall setout pds,'VTAM' /* Set output member name.  */\n\ncall jcd\ncall jcc \"VTAM Started procedure.\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\ncall jcl \"//VTAM     EXEC PGM=ISTINM01,REGION=0M,\"\ncall jcl \"//         DPRTY=(15,15),TIME=1440,PERFORM=8\"\n\n/* Add VTAMLSTs */\nlibs = xdslist('VTAMLST')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//VTAMLST  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add VTAMLIBs */\nlibs = xdslist('VTAMLIB')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//VTAMLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\nsistclib = 'SYS1.SISTCLIB'\nIF xdsthere(sistclib) THEN,\ncall jcl \"//SISTCLIB DD DISP=SHR,DSN=\"sistclib\n\ncall jcl \"//SYSABEND DD SYSOUT=*,HOLD=YES\"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=====================================*/\n/*  Build Master JCL deck (MSTJCL01)   */\n/*=====================================*/\nmstrjcl:\nSAY \"Building Master JCL member.\"\ncall setout pds,'MSTJCL01' /* Set output member name.  */\n\ncall jcl \"//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440\"\ncall jcd\ncall jcc \"Master JCL.\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\ncall jcl \"//         EXEC PGM=IEEMB860,DPRTY=(15,15)\"\ncall jcl \"//STCINRDR DD SYSOUT=(A,INTRDR)\"\ncall jcl \"//TSOINRDR DD SYSOUT=(A,INTRDR)\"\n\n/* Add PROCLIBs */\nlibs = xdslist('JES2')\nDO x = 1 TO WORDS(libs)\n   IF x = 1 THEN,\n   call jcl \"//IEFPDSI  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSUADSs */\nlibs = xdslist('SYSUADS')\nIF WORDS(libs) > 0 THEN,\n   call jcl \"//SYSUADS  DD DISP=SHR,DSN=\"WORD(libs,1)\n\n/* Add SYSLBCs */\nlibs = xdslist('SYSLBC')\nIF WORDS(libs) > 0 THEN,\n   call jcl \"//SYSLBC   DD DISP=SHR,DSN=\"WORD(libs,1)\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=========================================================*/\n/* Create IGDSMS member from ZIGDSMS contents plus entries */\n/* for the ACDS and COMMDS files.                          */\n/*=========================================================*/\nigdsms:\n\nSAY \"Building IGDSMS00 SMS parmlib member.\"\n/*---------------------------------------------------------*/\n/* If no member found, set stem count to 0 for later, and  */\n/* plan to write output to ZIEALPA.                        */\n/*---------------------------------------------------------*/\nstat = setinp(pds,'ZIGDSMS')  /* Open member ZIEALPA for input. */\nIF stat = 'MEMBER NOT FOUND' THEN DO\n   SAY \"IGDSMS00 not created, model ZIGDSMS not found.\"\n   RETURN\nEND\nlibs1 = xdslist('ACDS')\nlibs2 = xdslist('COMMDS')\nIF WORDS(libs1) = 0 THEN DO\n   SAY \"IGDSMS00 not built -- ACDS must be defined in @DATASET.\"\n   RETURN\nEND\nIF WORDS(libs1) = 0 THEN DO\n   SAY \"IGDSMS00 not built -- COMMDS must be defined in @DATASET.\"\n   RETURN\nEND\n\nsmsacds = WORD(libs1,1)  /* Pick first (hopefully only) ACDS ent. */\nsmscommds = WORD(libs2,1)  /* Pick first (hopefully only) COMM ent. */\n\n/*---------------------------------------------------------*/\n/* Build IGDSMS00 member.                                  */\n/*---------------------------------------------------------*/\ncall setout pds,'IGDSMS00'           /* Write to IGDSMS00  */\n/* Code ACDS and COMMDS to start member.                   */\ncall jcl \"SMS ACDS(\"smsacds\")\"\ncall jcl \"    COMMDS(\"smscommds\")\"\n\n/* Finish member with ZIGDSMS contents.                    */\nDO xx = 1 TO INPUT.0\n   call jcl INPUT.xx\nEND\n\ncall clsout pds\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .\n   zzdsn = strip(zzdsn,'B')\n   IF zzdsn = \"\" THEN ITERATE\n   IF attrib(##prm,zzparm) THEN DO\n      IF zzdsn2 /= \"\" THEN,\n      ###dslst = ###dslst\" \"zzdsn2\n      ELSE,\n      ###dslst = ###dslst\" \"zzdsn1\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdsthere:\nARG ##prm .\ndo ##xxx = 1 TO DSNS.0\n   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   INTERPRET q '= \"'r'\"'\nEND\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS mem.   */\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(pds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(pds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*-------------------------------------------*/\n/* Variable substitution - Very crude.       */\n/* Handle some special variables, but        */\n/* otherwise just return the var value.      */\n/* This enables the user to specify &TSOPROC */\n/* and the like in the @DATASET member.      */\n/*-------------------------------------------*/\nvarsub:\nARG ####str\nIF substr(####str,1,1) /= '&' THEN RETURN ####str\n####str = substr(####str,2)  /* Strip off the \"&\" */\nIF ####str = 'RESCUE' THEN RETURN ##pds()\nIF SYMBOL(####str) = 'VAR' THEN RETURN VALUE(####str)\nELSE RETURN ####str\n\n./ ADD NAME=#MISC    0100-02365-02365-1141-00379-00379-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #MISC    - Do various other tasks.                      */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Misc.                                              */\n/*=========================================================*/\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Misc. tasks.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\n\ncall logrec           /* Initialize logrec dataset.        */\ncall syncuads         /* SYNC UADS ds.                     */\ncall dumpfmt          /* Format DUMP datasets.             */\n\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/*---------------------------------------------------------*/\n/* Format LOGREC dataset.                                  */\n/*---------------------------------------------------------*/\nlogrec:\nlibs = xdslist('LOGREC')\nIF WORDS(libs) > 0 THEN logrec = WORD(libs,1)\nELSE logrec = \"\"\n\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"LOGREC  - Format LOGREC dataset.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\n/* Format LOGREC dataset if any entry in @dataset was found with */\n/* the LOGREC parm coded.    */\nIF logrec /= \"\" THEN DO\n   call jcc \"LOGREC  - Format the LOGREC dataset.\"\n   call jcd\n   call jcl \"//LOGREC   EXEC PGM=IFCDIP00\"\n   call jcl \"//SERERDS  DD DISP=SHR,DSN=\"logrec\",\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\n   call jcl \"//*\"\nEND\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* SYNC UADS if SYSUADS and SYSLBC datasets were found in  */\n/* @DATASET.                                               */\n/*---------------------------------------------------------*/\nsyncuads:\nlibs = xdslist('SYSUADS')\nIF WORDS(libs) > 0 THEN sysuads = WORD(libs,1)\nELSE sysuads = \"\"\nlibs = xdslist('SYSLBC')\nIF WORDS(libs) > 0 THEN syslbc = WORD(libs,1)\nELSE syslbc = \"\"\nIF sysuads = \"\" | syslbc = \"\" THEN DO\n   Say \"SYSUADS and SYSLBC datasets not defined in @DATASET-Exiting.\"\n   RETURN\nEND\n\n/* Found the SYSUADS and SYSLBC, so build the SYNC JCL. */\n\ncall jcd\ncall jcc \"SYNCUADS - Sync UADS / Brodcast dataset.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//SYNCUADS EXEC PGM=IKJEFT01,DYNAMNBR=15 \"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD DUMMY \"\ncall jcl \"//SYSUADS  DD DISP=SHR,DSN=\"sysuads\",\"\ncall jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\ncall jcl \"//SYSLBC   DD DISP=SHR,DSN=\"syslbc\",\"\ncall jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\ncall jcl \"//SYSTSPRT DD SYSOUT=* \"\ncall jcl \"//SYSTSIN  DD * \"\ncall jcl \"  ACCOUNT       \"\ncall jcl \"  SYNC          \"\ncall jcl \"  END           \"\ncall jcl \"//*\"\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* JCL to format any DUMP datasets found in @DATASET.      */\n/*---------------------------------------------------------*/\ndumpfmt:\nlibs = xdslist('DUMP')\nIF WORDS(libs) = 0 THEN DO\n   Say \"No DUMP datasets defined in @DATASET - Exiting.\"\n   RETURN\nEND\n\n/* Found the some dump datasets, so format them.        */\ncall jcd\ncall jcc \"FMTDUMP  - Format DUMP datasets.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\n\nDO xx = 1 TO WORDS(libs)\n   dmpds = WORD(libs,xx)\n   call jcl \"//DMPINT0 EXEC PGM=IEBGENER\"\n   call jcl \"//SYSPRINT DD SYSOUT=*\"\n   call jcl \"//SYSIN    DD DUMMY\"\n   call jcl \"//SYSUT1   DD DUMMY,\"\n   call jcl \"//         LRECL=4160,BLKSIZE=4160,RECFM=FB,DSORG=PS\"\n   call jcl \"//SYSUT2   DD DSN=\"dmpds\",DISP=SHR,\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\n   call jcl \"//*\"\nEND\n\nRETURN\n\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zzparm ')' .\n   zzdsn = strip(zzdsn,'B')\n   IF zzdsn = \"\" THEN ITERATE\n   IF attrib(##prm,zzparm) THEN DO\n      IF zzdsn2 /= \"\" THEN,\n      ###dslst = ###dslst\" \"zzdsn2\n      ELSE,\n      ###dslst = ###dslst\" \"zzdsn1\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#RFCOPY  0100-02365-02365-1141-00298-00298-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #RACFDS - Copy RACF dataset.                            */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\n/*=========================================================*/\n/* JOB: Copy the RACF dataset.                             */\n/*=========================================================*/\njobnum = ##jobchr()\n\n##runjob = 1\n\nIF VALUE(\"racfds\") = \"RACFDS\" | racfds = \"\" THEN DO\n   Say 'RACFDS parameter not specified - RACF dataset not copied.'\n   RETURN\nEND\n\n/*---------------------------------------------------------*/\n/* Get DS info.                                            */\n/*---------------------------------------------------------*/\nx = listdsi(\"'\"racfds\"'\")\nunits = 'CYL'\nIF sysunits = 'TRACK' THEN units = 'TRK'\n\n/* If RACFVOL specified, specify it in the JCL.            */\nIF VALUE(\"racfvol\") = \"RACFVOL\" | racfvol = \"\" THEN rfvol = \"\"\nELSE rfvol = racfvol\n\n/* Build SPACE= parm.                                      */\nspaceprm = \"SPACE=(\"units\",(\"sysprimary\",\"sysseconds\"))\"\n\n/*---------------------------------------------------------*/\n/* Build JCL.                                              */\n/*---------------------------------------------------------*/\nSay \"Building Job \"jobnum\": Copy RACF Dataset.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFCOPY   - Copy the RACF dataset.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//COPY     EXEC PGM=IRRUT400,PARM='LOCKINPUT,FREESPACE(20)'\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//INDD1    DD DSN=\"racfds\",DISP=OLD,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"rfvol\ncall jcl \"//OUTDD1   DD DSN=\"ssa\"\"racfds\",DISP=(,CATLG),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"volser\",\"\ncall jcl \"//         DCB=(\"racfds\"),\"spaceprm\ncall jcl \"//UNLOCK   EXEC PGM=IRRUT400,PARM='UNLOCKINPUT'\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//INDD1    DD DSN=\"racfds\",DISP=OLD,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"rfvol\n/*-------------------------------------------*/\n/* Alter RF DS name to final name (dump SSA) */\n/*-------------------------------------------*/\ncall jcd\ncall jcc \"ALTERRF  - Change the RACF Dataset name to its final\"\ncall jcc \"           name without the \"ssa\" prefix.\"\ncall jcd\ncall jcl \"//ALTERRF  EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD    SYSOUT=*\"\ncall jcl \"//SYSIN    DD    *\"\ncall jcl \"  ALTER \"ssa\"\"racfds\" -\"\ncall jcl \"        NEWNAME(\"racfds\") -\"\ncall jcl \"        CATALOG(\"newmcat\")\"\ncall jcl \" \"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#RFDSNT  0100-02365-02365-1141-00327-00327-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #RFDSNT - RACF Dataset Name Table (ICHRDSNT)            */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\nIF rfdsnt /= 'YES' THEN DO\n   Say \"RFDSNT parameter not specified - ICHRDSNT assembly not created.\"\n   RETURN\nEND\n\ncall makedsnt         /* Build the DSN table.              */\ncall iealpa           /* Build MLPA member to use ICHRDSNT.*/\n\nexit\n\n/*=========================================================*/\n/* JOB: RACF Dataset Name Table (ICHRDSNT)                 */\n/*=========================================================*/\nmakedsnt:\njobnum = ##jobchr()\n\nSay \"Building Job \"jobnum\": Assemble ICHRDSNT table.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFDSNT   - Assemble RACF dataset name table (ICHRDSNT)\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',\"\ncall jcl \"// PARM.L='SIZE=(320K,250K)' \"\ncall jcl \"//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR \"\ncall jcl \"//         DD  DSN=SYS1.MODGEN,DISP=SHR \"\ncall jcl \"//SYSIN    DD  * \"\ncall jcl \"ICHRDSNT CSECT \"\ncall jcl \"         DC    AL1(1)             NUMBER OF RACF DATA\"\ncall jcl \"         DC    CL44'\"racfds\"'     RACF PRIMARY DATASET\"\ncall jcl \"         DC    CL44' '            RACF BACKUP DATASET\"\ncall jcl \"         DC    AL1(255)           RESIDENT INDEX BLKS\"\ncall jcl \"         DC    XL1'81'            DUPLICATE ALL EXCEPT\"\ncall jcl \"         END\"\ncall jcl \"//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,\"\ncall jcl \"//  UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//L.SYSIN       DD *\"\ncall jcl \"  NAME ICHRDSNT(R) \"\n\ncall clsout pds,'JOB'jobnum\nRETURN\n\n/*=========================================================*/\n/* Create IEALPA member from ZIEALPA contents plus an      */\n/* entry we'll build for ICHRDSNT.                         */\n/*=========================================================*/\niealpa:\n\n/*---------------------------------------------------------*/\n/* If no member found, set stem count to 0 for later, and  */\n/* plan to write output to ZIEALPA.                        */\n/*---------------------------------------------------------*/\nstat = setinp(pds,'ZIEALPA')  /* Open member ZIEALPA for input. */\nIF stat = 'MEMBER NOT FOUND' THEN DO\n   SAY \"Model MLPA member ZIEALPA not found, and will be created.\"\n   INPUT.0 = 0\n   outmem = 'ZIEALPA'\nEND\nELSE IF stat /= 'OK' THEN DO\n   Say \"Error opening ZIEALPA, exiting.\"\n   RETURN\nEND\n\n/*---------------------------------------------------------*/\n/* If there's already an entry for this module, do nothing.*/\n/*---------------------------------------------------------*/\nDO xx = 1 TO INPUT.0\n/* Parse out comments first. */\n   PARSE VAR INPUT.xx p '/*'\n   IF POS(\"ICHRDSNT\",p) > 0 THEN DO\n      SAY \"ICHRDSNT entry already in MLPA model - No entry added.\"\n      call clsinp pds,'ZIEALPA'  /* Close input file. */\n      RETURN\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* No entry found, so rebuild ZIEALPA with out mod added.  */\n/*---------------------------------------------------------*/\ncall setout pds,'ZIEALPA'\nDO xx = 1 TO INPUT.0\n   call jcl INPUT.xx\nEND\nstcent = \"INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRDSNT )\"\ncall jcl stcent\ncall clsout pds,'ZIEALPA'\nSay \"Entry ICHRDSNT added to ZIEALPA MLPA model.\"\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n##stat = SYSDSN(\"'\"##ds2\"(\"##mem2\")'\")\nIF ##stat /= 'OK' THEN DO\n   RETURN ##stat\nEND\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\ncc = rc\nIF cc = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 'OK'\nEND\nELSE DO\n   RETURN 'ALLOC ERROR' cc\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n./ ADD NAME=#RFSTC   0100-02365-02365-1141-00639-00639-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* #RFSTC  - RACF Started Task Table (ICHRIN03)            */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\n\nIF rfstc /= 'YES' THEN DO\n   Say \"RFSTC parameter not specified - ICHRIN03 assembly not created.\"\n   RETURN\nEND\n\ncall makestc          /* Build the STC table.              */\ncall iealpa           /* Build MLPA member to use ICHRIN03.*/\ncall defids           /* Create RACF groups/IDs as needed. */\n\nexit\n\n/*=========================================================*/\n/* JOB: RACF Started Task Table (ICHRDSNT)                 */\n/*=========================================================*/\nmakestc:\njobnum = ##jobchr()\n\nSay \"Building Job \"jobnum\": Assemble ICHRIN03 table.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFDSNT   - Assemble RACF Started Task Table (ICHRIN03)\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',\"\ncall jcl \"// PARM.L='SIZE=(320K,250K)' \"\ncall jcl \"//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR \"\ncall jcl \"//         DD  DSN=SYS1.MODGEN,DISP=SHR \"\ncall jcl \"//SYSIN    DD  * \"\ncall jcl \"ICHRIN03 CSECT                                               \"\ncall jcl \"TABSTART DC    AL2(NUMENTR)              NUMBER OF ENTRIES   \"\n\nprivflag = \"X'8000000000000000'\"\nstdflag  = \"X'0000000000000000'\"\n\n/*------------------------------------------------------------------*/\n/* Use STC's from @PARMS.  RFSTCx = VTAM, $RESCUE, $STC             */\n/* p1 = Task name, p2 = RACF ID, p3 = RACF Grp.                     */\n/*------------------------------------------------------------------*/\nstc.0 = 0\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   PARSE VAR ent zztask ',' zzid ',' zzgrp .\n   zztask = strip(zztask,\"B\")\n   zzid = strip(zzid,\"B\")\n   zzgrp  = strip(zzgrp,\"B\")\n   stc.xx = substr(zztask,1,8)\"\"substr(zzid,1,8)\"\"substr(zzgrp,1,8)\nEND\nstc.0 = xx-1\n/*------------------------------------------------------------------*/\n/* Loop through the entries we've built, and put them in DC stmts.  */\n/* Assume trusted and proviledged for all defined tasks.            */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO stc.0\n   call jcl \"         DC    C'\"stc.xx\"',\"privflag\nEND\n/*------------------------------------------------------------------*/\n/* Finish up the source for the table, and the rest of the JCL.     */\n/*------------------------------------------------------------------*/\ncall jcl \"         DC    C'*       =       STC     ',\"stdflag\ncall jcl \"NUMENTR  EQU   (*-TABSTART-2)/32+X'8000'\"\ncall jcl \"         DC    C'&SYSDATE' \"\ncall jcl \"         DC    C'&SYSTIME' \"\ncall jcl \"         END \"\ncall jcl \"//L.SYSLMOD     DD DSN=SYS1.RESCUE.LINKLIB,DISP=SHR,\"\ncall jcl \"//  UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//L.SYSIN       DD *\"\ncall jcl \"  NAME ICHRIN03(R) \"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*=========================================================*/\n/* Create IEALPA member from ZIEALPA contents plus an      */\n/* entry we'll build for ICHRIN03.                         */\n/*=========================================================*/\niealpa:\n\n/*---------------------------------------------------------*/\n/* If no member found, set stem count to 0 for later, and  */\n/* plan to write output to ZIEALPA.                        */\n/*---------------------------------------------------------*/\nstat = setinp(pds,'ZIEALPA')  /* Open member ZIEALPA for input. */\nIF stat = 'MEMBER NOT FOUND' THEN DO\n   SAY \"Model MLPA member ZIEALPA not found, and will be created.\"\n   INPUT.0 = 0\n   outmem = 'ZIEALPA'\nEND\nELSE IF stat /= 'OK' THEN DO\n   Say \"Error opening ZIEALPA, exiting.\"\n   RETURN\nEND\n\n/*---------------------------------------------------------*/\n/* If no member read, set stem count to 0 for later.       */\n/*---------------------------------------------------------*/\nIF INPUT.0 = \"INPUT.0\" THEN DO\n   SAY \"Model MLPA member ZIEALPA not found.\"\n   INPUT.0 = 0\nEND\n\n/*---------------------------------------------------------*/\n/* If there's already an entry for this module, do nothing.*/\n/*---------------------------------------------------------*/\nDO xx = 1 TO INPUT.0\n/* Parse out comments first. */\n   PARSE VAR INPUT.xx p '/*'\n   IF POS(\"ICHRIN03\",p) > 0 THEN DO\n      SAY \"ICHRIN03 entry already in MLPA model - No entry added.\"\n      call clsinp pds,'ZIEALPA'  /* Close input file. */\n      RETURN\n   END\nEND\n/*---------------------------------------------------------*/\n/* No entry found, so rebuild ZIEALPA with out mod added.  */\n/*---------------------------------------------------------*/\ncall setout pds,'ZIEALPA'\nDO xx = 1 TO INPUT.0\n   call jcl INPUT.xx\nEND\nstcent = \"INCLUDE LIBRARY(SYS1.RESCUE.LINKLIB) MODULES( ICHRIN03 )\"\ncall jcl stcent\ncall clsout pds,'ZIEALPA'\nSay \"Entry ICHRIN03 added to ZIEALPA MLPA model.\"\n\nRETURN\n\n/*=========================================================*/\n/* JOB: Define RACF IDs needed for RESCUE system.          */\n/* JOB: ID submitting job mist have RACF SPECIAL.          */\n/*=========================================================*/\ndefids:\n\njobnum = ##jobchr()\nSay \"Building Job \"jobnum\": Define RACF IDs and Groups for STCs.\"\ncall setout pds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFSTCDEF - Create RACF IDs and groups for started tasks.\"\ncall jcd\n/*---------------------------------------------------------*/\n/* Be sure we have RACF special.                           */\n/*---------------------------------------------------------*/\nIF \\racfspec() THEN DO\n   call jcc \"*** NOTE: ***\"\n   call jcc \"Userid \"USERID()\" was used to build this job, but does \"\n   call jcc \"not have the RACF SPECIAL attribute.  If \"USERID()\" is \"\n   call jcc \"used to run this job, it should first be granted the   \"\n   call jcc \"SPECIAL attribute or the equivalent specific privileges \"\n   call jcc \"needed be to run successfully. RACF violations will  \"\n   call jcc \"result if this is not done.\"\n   call jcd\nEND\nELSE DO\n   call jcc \"NOTE: Be sure that the ID used to run this job has the\"\n   call jcc \"RACF SPECIAL attribute, or the equivalent specific    \"\n   call jcc \"privileges required.\"\n   call jcd\nEND\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//TSO      EXEC PGM=IKJEFT01,REGION=4M\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//SYSIN    DD DUMMY   \"\ncall jcl \"//SYSTSPRT DD SYSOUT=*\"\ncall jcl \"//SYSTSIN  DD *\"\n\n/*------------------------------------------------------------------*/\n/* Delete RACF IDs and Groups.                                      */\n/*------------------------------------------------------------------*/\n/* Use RFSTCx parms from @PARMS to get userids to be defined.       */\n/* Delete each GROUP and ID first, but only if they are not already */\n/* defined to the driving system.                                   */\n/* jobs to be re-run if desired.                                    */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Delete ID if needed. */\n   IF ckstcid(zzid) THEN DO\n      c1 = \" DELUSER  \"zzid\n      IF \\idthere(zzid) THEN DO\n         call jcl \" \"\n         call jcl c1\n      END\n      ELSE DO\n      /* Comment out the commands, because the ID was already there. */\n         SAY zzid\" is already defined to RACF, and was not deleted.\"\n         call jcl \" \"\n         e1  = \" \"zzid\" is already defined to RACF, and was\"\n         e2  = \" not deleted.  Select an ID that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n      END\n   END\nEND\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Delete group if needed. */\n   IF ckstcgrp(zzgrp) THEN DO\n      c1 = \" DELGROUP \"zzgrp\n      IF \\grpthere(zzgrp) THEN DO\n         call jcl \" \"\n         call jcl c1\n      END\n      ELSE DO\n         SAY zzgrp\" is already defined to RACF, and was not deleted.\"\n         call jcl \" \"\n         e1  = \" \"zzgrp\" is already defined to RACF, and was\"\n         e2  = \" not deleted.  Select a Group that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n      END\n   END\nEND\nDROP STCID.\nDROP STCGRP.\n\n/*------------------------------------------------------------------*/\n/* Define RACF IDs and Groups.                                      */\n/*------------------------------------------------------------------*/\n/* Use RFSTCx parms from @PARMS to get userids to be defined.       */\n/* Define each group and user as needed, but only if they are not   */\n/* defined yet. Code a DELGROUP and DELUSER statement to allow the  */\n/* jobs to be re-run if desired.                                    */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Define group if needed. */\n   IF ckstcgrp(zzgrp) THEN DO\n      c1 = \" ADDGROUP \"zzgrp\" OWNER(SYS1) SUP(SYS1) +\"\n      c2 = \" OMVS(gid(0))\"\n      IF \\grpthere(zzgrp) THEN DO\n         call jcl \" \"\n         call jcl c1\n         call jcl c2\n      END\n      ELSE DO\n         SAY zzgrp\" is already defined to RACF, and was not created.\"\n         call jcl \" \"\n         e1  = \" \"zzgrp\" is already defined to RACF, and was\"\n         e2  = \" not created.  Select a Group that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c2,1,60)\" */\"\n      END\n   END\nEND\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Define ID if needed. */\n   IF ckstcid(zzid) THEN DO\n      c1 = \" ADDUSER  \"zzid\" OWNER(SYS1) DFLTGRP(\"zzgrp\") +\"\n      c2 = \" OPERATIONS NOPASSWORD NAME('Rescue System') + \"\n      c3 = \" OMVS(uid(0) home('/') program('/bin/sh') )\"\n      IF \\idthere(zzid) THEN DO\n         call jcl \" \"\n         call jcl c1\n         call jcl c2\n         call jcl c3\n      END\n      ELSE DO\n      /* Comment out the commands, because the ID was already there. */\n         SAY zzid\" is already defined to RACF, and was not created.\"\n         call jcl \" \"\n         e1  = \" \"zzid\" is already defined to RACF, and was\"\n         e2  = \" not created.  Select an ID that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c2,1,60)\" */\"\n         call jcl \" /*\"substr(c3,1,60)\" */\"\n      END\n   END\nEND\n\n/*-------------------------------------------*/\n/*- Define the TSO PROC to RACF             -*/\n/*-------------------------------------------*/\ncall jcl \" \"\ncall jcl \" RDEFINE TSOPROC \"tsoproc\" UACC(READ)\"\ncall jcl \" RALTER  TSOPROC \"tsoproc\" UACC(READ)\"\ncall jcl \" SETROPTS RACLIST(TSOPROC) REFRESH\"\ncall jcl \" \"\n\ncall clsout pds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*-ckstcid - Check if we need to process     */\n/*-this stc id.  If not, return 0.  If so,   */\n/*-return 1.                                 */\n/*-------------------------------------------*/\nckstcid:\nARG ##id\nIF STCID.0 = \"STCID.0\" THEN stcid.0 = 0\nDO ##x = 1 TO stcid.0\n   IF ##id = stcid.##x THEN RETURN 0\nEND\n##x34 = stcid.0\n##x34 = ##x34 + 1\nstcid.0 = ##x34\nstcid.##x34 = ##id\nRETURN 1\n\nckstcgrp:\nARG ##grp\nIF STCGRP.0 = \"STCGRP.0\" THEN stcgrp.0 = 0\nDO ##x = 1 TO stcgrp.0\n   IF ##grp = stcgrp.##x THEN RETURN 0\nEND\n##x34 = stcgrp.0\n##x34 = ##x34 + 1\nstcgrp.0 = ##x34\nstcgrp.##x34 = ##grp\nRETURN 1\n\n/*---------------------------------------------------------*/\n/* idisthere  - Says if a RACF ID is defined.              */\n/* grpisthere - Says if a RACF ID is defined.              */\n/*---------------------------------------------------------*/\nidthere:\nARG ##id\nx = outtrap('list.',1)\n\"LU \"##id\n cc = rc\nx = outtrap('OFF')\nRETURN (cc = 0)\n\ngrpthere:\nARG ##grp\nx = outtrap('list.',1)\n\"LG \"##grp\n cc = rc\nx = outtrap('OFF')\nRETURN (cc = 0)\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),RESCUE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n   IF r = \"\" THEN ITERATE\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n##stat = SYSDSN(\"'\"##ds2\"(\"##mem2\")'\")\nIF ##stat /= 'OK' THEN DO\n   RETURN ##stat\nEND\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\ncc = rc\nIF cc = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 'OK'\nEND\nELSE DO\n   RETURN 'ALLOC ERROR' cc\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n./ ADD NAME=@DATASET 0100-02365-02365-1141-00234-00234-00000-JMILLER\n*--------------------------------------------------------------------*\n*  Dataset Definitions:                                              *\n*--------------------------------------------------------------------*\n*  Parms for dataset entries are as follows:                         *\n*  uuu,pppp,sss,ddd,m,dsn1,dsn2,(parms)                              *\n*  ------------------------------                                    *\n*  uuu   - Allocation unit, such as CYL,TRK, etc. (copy mode C,G,N)  *\n*  pppp  - Primary allocation (copy mode C,G,N)                      *\n*  sss   - Secondary allocation (copy mode C,G,N)                    *\n*  dir   - Directory blocks (copy mode C,G,N)                        *\n*  m     - Method of copy:                                           *\n*          C - IEBCOPY                                               *\n*          D - DFDSS                                                 *\n*          G - IEBGENER                                              *\n*          H - HFS file copy via DFDSS DUMP & RESTORE (See notes in  *\n*              $$$MAINT member about maintenance needed for this.)   *\n*          N - No copy, allocate only                                *\n*          X - Do nothing, used as a flag for internal processing.   *\n*  dsn1  - Name of dataset to be copied or defined.  If copy mode    *\n*          \"N\" is specified, this dataset is not copied, but used    *\n*          only as a model for allocating the dataset.               *\n*  dsn2  - Name of dataset on the target system, if it is to be      *\n*          different from dsn1.  If this parameter is omitted, the   *\n*          the dataset will be named to the value specified in dsn1. *\n*  parms - Flags to indicate special handling:                       *\n*          OMVSxxxx  - BPXPRMxx member will mount this file at mount *\n*                    - point xxxx. e.g. OMVS/etc.  OMVS/ will define *\n*                    - the ROOT filesystem, and generate a ROOT stmt.*\n*          APF       - Added to PROGA0 for APF authorization.        *\n*          LNK       - Added to PROGL0 for linklst.                  *\n*          LPA       - Added to LPALST00 PARMLIB member.             *\n*          RLSE      - Excess space released after copy.  This helps *\n*                      fit the system into minimum space.            *\n*          ISPxLIB   - Lib added to ISPxLIB DD in TSO PROC.          *\n*          SYSPROC   - Lib added to SYSPROC DD in TSO PROC.          *\n*          SYSHELP   - Lib added to SYSHELP DD in TSO PROC.          *\n*          SYSLBC    - Lib added to SYSLBC DD in TSO PROC.           *\n*          JES2      - Lib added to PROC00 DD in JES2 PROC.          *\n*          VTAMLST   - Lib added to VTAMLST DD in VTAM PROC.         *\n*          VTAMLIB   - Lib added to VTAMLIB DD in VTAM PROC.         *\n*          IPLPARM   - Lib where LOAD00 member will be created.      *\n*          PARMLIB   - PARMLIB to be added to SYS1.IPLAPRM(LOAD00).  *\n*--------------------------------------------------------------------*\n*  Parms for member COPY operations are as follows:                  *\n*  The source and target PDS libraries must be specified before any  *\n*  member copy statements are coded.  First code a COPY with IN=     *\n*                                                                    *\n*  First code a COPY with IN= and OUT= parms:                        *\n*  and OUT= parms:                                                   *\n*     COPY IN=<source PDS>,OUT=<Target PDS>                          *\n*  Then code one or more COPY member statments, as below:            *\n*     COPY M=memname                                                 *\n*     COPY M=(memname)                                               *\n*     COPY M=(memname,newmemname)                                    *\n*                                                                    *\n*  Each COPY member statement uses the IN= and OUT= libraries set in *\n*  the preceeding COPY IN=,OUT= statement.                           *\n*                                                                    *\n*  An IEBCOPY job will be created that copies the members defined in *\n*  all the COPY statements.                                          *\n*--------------------------------------------------------------------*\n*--------------------------------------------------------------------*\n*  REQUIRED - DON'T ALTER THE NEXT SET OF ENTRIES FROM HERE UNTIL    *\n*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *\n*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *\n*     V       THESE STATEMENTS ARE ALTERED.                          *\n*--------------------------------------------------------------------*\n CYL,0001,000,015,N,SYS1.IPLPARM,,(IPLPARM)\n CYL,0001,000,015,N,SYS1.PARMLIB,SYS1.RESCUE.CLIST,(SYSPROC)\n CYL,0002,000,015,N,SYS1.PARMLIB,SYS1.RESCUE.PARMLIB,(PARMLIB)\n CYL,0002,000,025,N,SYS1.LINKLIB,SYS1.RESCUE.LINKLIB,(APF,LNK)\n CYL,0002,000,015,N,SYS1.PROCLIB,SYS1.RESCUE.PROCLIB,(JES2)\n COPY IN=&RESCUE,OUT=SYS1.RESCUE.CLIST\n    COPY M=(ZISPALOC,ISPALLOC)\n COPY IN=&RESCUE,OUT=SYS1.RESCUE.PARMLIB\n    COPY M=(BPXPRM00)\n    COPY M=(JES2PARM)\n    COPY M=(MSTJCL01)\n    COPY M=(LPALST00)\n    COPY M=(PROGA0)\n    COPY M=(PROGL0)\n    COPY M=(ZCOMMND,COMMND00)\n    COPY M=(ZIEALPA,IEALPA00)\n    COPY M=(ZIEASYS,IEASYS00)\n    COPY M=(ZIEFSSN,IEFSSN00)\n    COPY M=(IGDSMS00)\n    COPY M=(ZTSOKEY,TSOKEY00)\n    COPY M=(ZVATLST,VATLST00)\n COPY IN=&RESCUE,OUT=SYS1.RESCUE.PROCLIB\n    COPY M=(ZTSO,TSO)\n    COPY M=(VTAM)\n    COPY M=(JES2)\n    COPY M=(&TSOPROC)\n COPY IN=&RESCUE,OUT=SYS1.IPLPARM\n    COPY M=LOAD00\n*--------------------------------------------------------------------*\n*  END OF REQUIRED STATEMENTS.                                       *\n*--------------------------------------------------------------------*\n*--------------------------------------------------------------------*\n*  OMVS Datasets:                                                    *\n*--------------------------------------------------------------------*\n OMVS,,,,H,OMVS.ROOT.MAINT,OMVS.ROOT,(OMVS/)\n OMVS,,,,H,OMVS.ETC,,(OMVS/etc)\n*--------------------------------------------------------------------*\n*  MVS Datasets:                                                     *\n*--------------------------------------------------------------------*\n CYL,0000,000,000,D,SYS1.IODF00.CLUSTER\n CYL,0000,000,000,D,SMS.ACDS,,(ACDS)\n CYL,0000,000,000,D,SMS.SCDS\n CYL,0000,000,000,D,SMS.COMMDS,,(COMMDS)\n CYL,0000,000,000,D,SMS.ACS\n CYL,0000,000,000,D,SYS1.LINKLIB,,(RLSE,APF,LNK)\n CYL,0010,001,025,D,SYS1.V2R10M0.SHASLINK,,(RLSE,LNK,APF)\n CYL,0010,001,025,D,SYS1.V2R10M0.SHASMIG,,(RLSE,LNK,APF)\n CYL,0090,000,550,D,SYS1.LPALIB,,(RLSE)\n CYL,0140,005,350,D,SYS1.MACLIB,,(RLSE)\n CYL,0020,001,250,D,SYS1.MIGLIB,,(RLSE,APF)\n CYL,0055,000,250,D,SYS1.NUCLEUS\n CYL,0002,000,050,D,SYS1.PARMLIB,,(PARMLIB)\n CYL,0002,000,050,D,SYS1.IBM.PARMLIB,,(PARMLIB)\n CYL,0002,001,150,D,SYS1.PROCLIB,,(JES2)\n CYL,0002,001,150,D,CPAC.PROCLIB,,(JES2)\n CYL,0002,001,150,D,SYS1.IBM.PROCLIB,,(JES2)\n CYL,0050,001,250,D,SYS1.SAMPLIB,,(RLSE)\n CYL,0002,001,150,D,SYS1.SVCLIB,,(RLSE)\n CYL,0002,001,150,D,SYS1.UADS,,(SYSUADS)\n CYL,0003,000,000,D,SYS1.BRODCAST,,(SYSLBC)\n CYL,0024,000,000,N,SYS1.HASPCKPT\n CYL,0060,000,000,N,SYS1.HASPACE\n CYL,0010,000,000,N,SYS1.LOGREC,,(LOGREC)\n CYL,0020,000,000,X,SYS1.MAN1,,(SMF)\n CYL,0010,000,000,X,SYS1.MAN2,,(SMF)\n CYL,0010,000,000,X,SYS1.MAN3,,(SMF)\n CYL,0060,000,000,N,SYS1.DUMP00,,(DUMP)\n CYL,0060,000,000,N,SYS1.DUMP01,,(DUMP)\n CYL,0005,001,150,D,SYS1.CSSLIB,,(RLSE,LNK)\n CYL,0000,000,000,D,EOY.SEOYLOAD,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,EOX.SEPHLOD1,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,GIM.SGIMLMD0,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,CEE.SCEERUN,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,CEE.SCEERUN2,,(LNK,APF)\n CYL,0000,000,000,D,IMO.SIMOMOD1,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,ISP.SISPSASC,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,FFST.V120ESA.SEPWMOD2,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,FFST.V120ESA.SEPWMOD4,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,SYS1.SICELINK,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,SYS1.SORTLIB,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,IOE.SIOELMOD,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,SYS1.SIOALMOD,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,CBC.SCLBDLL,,(RLSE,LNK,APF)\n CYL,0030,000,050,D,SYS1.SERBLINK,,(RLSE,LNK,APF)\n CYL,0010,000,010,D,CEE.SCEELPA,,(RLSE,LNK,APF,LPA)\n CYL,0001,000,005,D,SYS1.SERBLPA,,(RLSE,LPA)\n CYL,0005,000,150,D,SYS1.CMDLIB,,(RLSE,LNK)\n CYL,0001,000,000,D,SYS1.DAE\n CYL,0008,001,150,D,SYS1.HELP,,(RLSE,SYSHELP)\n CYL,0002,000,150,D,SYS1.IMAGELIB,,(RLSE)\n*--------------------------------------------------------------------*\n* HCD ISPF libraries                                                 *\n*--------------------------------------------------------------------*\n CYL,0000,000,000,D,SYS1.SCBDHENU,,(RLSE,LNK,APF)\n CYL,0000,000,000,D,SYS1.SCBDCLST,,(RLSE,SYSPROC)\n CYL,0000,000,000,D,SYS1.SCBDMENU,,(RLSE,ISPMLIB)\n CYL,0000,000,000,D,SYS1.SCBDPENU,,(RLSE,ISPPLIB)\n CYL,0000,000,000,D,SYS1.SCBDTENU,,(RLSE,ISPTLIB)\n*--------------------------------------------------------------------*\n* ISPF Libraries                                                     *\n*--------------------------------------------------------------------*\n CYL,0001,0001,125,D,ISP.SISPTENU,,(RLSE,ISPTLIB)\n CYL,0002,0001,125,D,ISP.SISPSLIB,,(RLSE,ISPSLIB)\n CYL,0003,0001,150,D,ISP.SISPMENU,,(RLSE,ISPMLIB)\n CYL,0006,0001,125,D,ISP.SISPSENU,,(RLSE,ISPSLIB)\n CYL,0008,0001,075,D,ISP.SISPLOAD,,(RLSE,LNK,ISPLLIB)\n CYL,0025,0001,200,D,ISP.SISPPENU,,(RLSE,ISPPLIB)\n CYL,0025,0001,200,D,ISP.SISPCLIB,,(RLSE,SYSPROC)\n CYL,0035,0001,075,D,ISP.SISPLPA,,(RLSE,LPA)\n*--------------------------------------------------------------------*\n* TCPIP datasets                                                     *\n*--------------------------------------------------------------------*\n CYL,0030,000,010,D,TCPIP.SEZALPA,,(RLSE,APF,LPA)\n CYL,0060,005,010,D,TCPIP.SEZALINK,,(RLSE,APF,LNK)\n CYL,0060,005,010,D,SYS1.TCPPARMS\n CYL,0060,005,010,D,TCPIP.SEZATCP,,(RLSE)\n CYL,0060,005,010,D,TCPIP.SEZAINST,,(LNK)\n CYL,0060,005,010,D,TCPIP.SMTPNJE.HOSTINFO\n CYL,0060,005,010,D,TCPIP.SECTABLE\n*--------------------------------------------------------------------*\n* RACF DATASET AND ISPF LIBRARIES                                    *\n*--------------------------------------------------------------------*\n*  The RACF dataset is copied automatically.  Don't specify it here. *\n CYL,0002,001,150,D,SYS1.HRFCLST,,(RLSE,SYSPROC)\n CYL,0002,001,150,D,SYS1.HRFMSG,,(RLSE,ISPMLIB)\n CYL,0002,001,150,D,SYS1.HRFPANL,,(RLSE,ISPPLIB)\n CYL,0002,001,150,D,SYS1.HRFSKEL,,(RLSE,ISPSLIB)\n*--------------------------------------------------------------------*\n* ISMF ISPF libraries                                                *\n*--------------------------------------------------------------------*\n CYL,0001,001,095,D,SYS1.DGTCLIB,,(RLSE,SYSPROC)\n CYL,0010,001,095,D,SYS1.DGTLLIB,,(RLSE,ISPLLIB)\n CYL,0002,001,095,D,SYS1.DGTMLIB,,(RLSE,ISPMLIB)\n CYL,0033,001,350,D,SYS1.DGTPLIB,,(RLSE,ISPPLIB)\n CYL,0002,001,095,D,SYS1.DGTSLIB,,(RLSE,ISPSLIB)\n CYL,0001,001,095,D,SYS1.DGTTLIB,,(RLSE,ISPTLIB)\n*--------------------------------------------------------------------*\n* SDSF Datasets                                                      *\n*--------------------------------------------------------------------*\n CYL,0001,000,000,N,ISF.HASPINDX\n CYL,0001,001,150,D,ISF.SISFLINK,,(RLSE,LNK)\n CYL,0005,001,050,D,ISF.SISFLOAD,,(RLSE,LNK)\n CYL,0001,001,025,D,ISF.SISFLPA,,(RLSE,LPA)\n CYL,0001,001,150,D,ISF.SISFMLIB,,(RLSE,ISPMLIB)\n CYL,0002,001,150,D,ISF.SISFPLIB,,(RLSE,ISPPLIB)\n CYL,0001,001,150,D,ISF.SISFTLIB,,(RLSE,ISPTLIB)\n CYL,0001,001,150,D,ISF.SISFSLIB,,(RLSE,ISPSLIB)\n CYL,0015,001,150,D,ISF.SISFSRC,,(RLSE)\n*--------------------------------------------------------------------*\n* VTAM / NCP DATASETS                                                *\n*--------------------------------------------------------------------*\n CYL,0005,0001,125,D,SYS1.VTAMLST,,(VTAMLST)\n CYL,0005,0001,125,D,SYS1.VTAMLIB,,(RLSE,VTAMLIB,APF)\n CYL,0050,0001,125,D,SYS1.SISTCLIB,,(RLSE,APF)\n*--------------------------------------------------------------------*\n* Local datasets - Assorted PDS's that you want on your rescue sys.  *\n*--------------------------------------------------------------------*\n*CYL,0000,0000,000,D,SYS5.HELP,,(SYSHELP)\n*CYL,0000,0000,000,D,SYS5.TSSO.LOAD,,(APF,LNK)\n*CYL,0000,0000,000,D,SYS5.TSSO.CLIST\n*CYL,0000,0000,000,D,SYS5.TSSO.AOFTABS\n*CYL,0000,0000,000,D,SYS2.LINKLIB,,(APF,LNK)\n*CYL,0000,0000,000,D,SYS2.CSL86.LINKLIB,,(APF,LNK)\n*CYL,0000,0000,000,D,AOSGJCM.CNTL\n*CYL,0000,0000,000,D,AOSGJCM.VM.CNTL\n*CYL,0000,0000,000,D,AOSGJCM.EXEC\n*CYL,0000,0000,000,D,AOSGJCM.CLIST\n./ ADD NAME=@PARMS   0100-02365-02365-1141-00095-00095-00000-JMILLER\n/*-------------------------------------------------------------------*\n/*  Rescue system parameters.                                        *\n/*  To assign parms, use statements like: PARM1  = Some Value        *\n/*-------------------------------------------------------------------*\n/*  03/10/2001 John C. Miller.                                       *\n/*-------------------------------------------------------------------*\n/*-------------------------------------------------------------------*\n/* Jobcard info.  \"COMMENT\" is placed in each job.                   *\n/* Jobname must be 7 chars or less to allow job char to be added.    *\n/*-------------------------------------------------------------------*\n JOBCARD1   = //AOSGJCM  JOB (0),RESCUE,MSGCLASS=X,CLASS=A,\n JOBCARD2   = //  NOTIFY=&SYSUID,REGION=6M TYPRUN=HOLD\n JOBCARD3   = /*JOBPARM L=9999\n COMMENT    = John C. Miller\n\n/*-------------------------------------------------------------------*\n/* TSO PROC and Userids to be created on the new system.             *\n/* TSOPROC should NOT exist on the driving system.                   *\n/*-------------------------------------------------------------------*\n TSOPROC    = TSORES                  /* TSOPROC to be built.\n TSOID1     = AOSGJCM                 /* TSO IDs to be defined on the\n TSOID2     = XJMILLR                 /* rescue system.\n TSOID3     = XKFT\n\n/*-------------------------------------------------------------------*\n/* Assorted other parms.                                             *\n/*-------------------------------------------------------------------*\n ADDR       = F66                     /* Unit addr of RESCUE volume.\n DEVTYPE    = 3390                    /* Unit of RESCUE volume.\n VOLSER     = RESCUE                  /* VOLSER of RESCUE volume.\n\n SSA        = SYSX.                   /* Temp. dsn prefix used to\n                                      /* avoid ENQ problems.\n/*-------------------------------------------------------------------*\n/* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *\n/*-------------------------------------------------------------------*\n WORKVOL    = RESCU2                  /* Volser for large work files.\n\n/*-------------------------------------------------------------------*\n/* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *\n/* IOCONFIG ID in the IODF dataset that you specify.                 *\n/*-------------------------------------------------------------------*\n IODF       = SYS1.IODF00.CLUSTER     /* IODF dataset name.\n IOCONFIGID = CSUT                    /* 8 char IO config ID for LOADxx\n\n SMFID      = CSUT                    /* 4 char SMF id for new system.\n NEWMCAT    = CATALOG.RESCUE          /* Rescue sys. mastercat name.\n OLDMCAT    = CATALOG.OS390J.MASTER   /* Driving sys master cat.\n SYSRES     = JRS001                  /* Driving sys sysres volume.\n COMMANDPGM = COMMAND                 /* \"COMMAND\" pgm is available.\n WAITPGM    = WAIT                    /* \"WAIT\" pgm is available.\n\n/*-------------------------------------------------------------------*\n/* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *\n/* ZJES2PRM member to create a final JES2PARM member.                *\n/*-------------------------------------------------------------------*\n SPOOLVOL   = RESC                    /* SPOOLDEF prefix.\n CHKPOINT   = SYS1.HASPCKPT           /* JES2 Ckpt dataset name.\n SPOOL      = SYS1.HASPACE            /* JES2 spool ds name.\n\n/*-------------------------------------------------------------------*\n/* RACF Parms.                                                       *\n/* Note: Some of the RACF actions require RACF SPECIAL to perform.   *\n/* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *\n/* the resulting jobs will need RACF SPECIAL, or specific privileges *\n/* for various RACF operations (CLAUTH, etc.)                        *\n/*-------------------------------------------------------------------*\n/*-------------------------------------------------------------------*\n/* RFSTCx: Defines STCs for ICHRIN03 started task table.             *\n/* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *\n/* Each task defined will have privileged bit set on, so these tasks *\n/* should be able to bypass most RACF Access checking.  Commands     *\n/* for creating the specified IDs and Groups will be generated only  *\n/* if the IDs/groups DO NOT already exist.                           *\n/*-------------------------------------------------------------------*\n RACFDS     = SYS1.RACFP1             /* Driving system RF ds and vol.\n RACFVOL    =                         /* \"\n RFDSNT     = YES                     /* Create RACF ICHRDSNT\n RFSTC      = YES                     /* Create RACF ICHRIN03\n RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class\n/*-------------------------------------------------------------------*\n/* Started task support:                                             *\n/* If entries are defined below, then an ICHRIN03 module will be     *\n/* built with these entries.  An MLPA entry fir this ICHRIN03        *\n/* will be placed in IEALPA00.  Format of RFSTCx is:                 *\n/* RFSTCx = stcname, racfid, racfgrp                                 *\n/* All three parameters are required.                                *\n/*-------------------------------------------------------------------*\n RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC3     = JES2BACK,$RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC4     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC5     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC6     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03\n RFSTC7     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n./ ADD NAME=COMMAND  0100-02365-02365-1141-00401-00401-00000-JMILLER\n//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M\n//ASMHCL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL,AC=1'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.AMODGEN,DISP=SHR\n//C.SYSIN    DD  *\nCOMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'\n***********************************************************************\n*                                                                     *\n*                           C O M M A N D                             *\n*                                                                     *\n*                   ISSUE SYSTEM OPERATOR COMMANDS                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: This version has RACHECK code added to be sure that the       *\n* caller has at least READ access to the COMMAND profile of the       *\n* APPL RACF class.  To permit use of the COMMAND command:             *\n*                                                                     *\n*    RDEFINE APPL COMMAND UACC(NONE)                                  *\n*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *\n*                                                                     *\n* 03/21/2001 John C. Miller                                           *\n***********************************************************************\n*                                                                     *\n*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *\n*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *\n*     AUTHORIZED.                                                     *\n*                                                                     *\n*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *\n*                                                                     *\n*     1) BATCH OR CALLED PROGRAM                                      *\n*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *\n*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *\n*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *\n*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *\n*                                                                     *\n*           - OR -                                                    *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND                               *\n*           //SYSIN    DD *                                           *\n*           VARY 017,ONLINE                                           *\n*           /*                                                        *\n*                                                                     *\n*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *\n*        WILL BE ADDED BETWEEN COMMANDS.                              *\n*                                                                     *\n*     2) TSO COMMAND PROCESSOR                                        *\n*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *\n*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *\n*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *\n*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *\n*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *\n*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *\n*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *\n*        FOR EXAMPLE:                                                 *\n*                                                                     *\n*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *\n*                                                                     *\n*     3) CALLABLE SUBROUTINE                                          *\n*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *\n*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *\n*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *\n*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *\n*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *\n*        CONSOLE.) FOR EXAMPLE:                                       *\n*                                                                     *\n*           LA       R1,CMDADDR                                       *\n*           LA       R15,=V(COMMAND)                                  *\n*           BALR     R14,R15                                          *\n*                                                                     *\n*           CMDADDR  DC    A(OPERCMD)                                 *\n*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *\n*           OPERCMD  DC    H(3),CL3'D T'                              *\n*           CONSOLE  DC    F'5'                                       *\n*                                                                     *\n*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *\n*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *\n*                                                                     *\n*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *\n*                                                                     *\n*     AUTHOR:                                                         *\n*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *\n*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *\n*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *\n*                                                                     *\n*          STEVE LANGLEY                                              *\n*          SOUTHERN CALIFORNIA EDISON                                 *\n*          P.O. BOX 800                                               *\n*          ROSEMEAD, CALIF. 91770                                     *\n*          1-213-572-3435                                             *\n*                                                                     *\n*     IMPLEMENTOR:                                          *HMD 07/81*\n*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*\n*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*\n*                                                           *HMD 07/81*\n*          HOWARD M. DEAN                                   *HMD 07/81*\n*          GTE DATA SERVICES                                *HMD 07/81*\n*          4750 LINCOLN BLVD.                               *HMD 07/81*\n*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*\n*          PHONE - (213) - 821-0511                         *HMD 07/81*\n*                                                           *HMD 07/81*\n*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*\n*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*\n*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*\n***********************************************************************\n         EJECT\nCOMMAND  CSECT\n         SPACE 3\nR0       EQU   0                  REGISTER 0\nR1       EQU   1                  REGISTER 1\nR2       EQU   2                  WORK REGISTER\nR3       EQU   3                  WORK REGISTER\nR4       EQU   4                  WORK REGISTER\nR5       EQU   5                  WORK REGISTER\nR6       EQU   6                  WORK REGISTER             *HMD 07/81*\nR7       EQU   7                  WORK REGISTER             *HMD 07/81*\nR8       EQU   8                  WORK REGISTER             *HMD 07/81*\nR9       EQU   9                  WORK REGISTER             *HMD 07/81*\nR10      EQU   10                 PARAMETER LIST ADDRESS REGISTER\nR11      EQU   11                 SUBROUTINE LINKAGE REGISTER\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13                 SAVE AREA ADDRESS REGISTER\nR14      EQU   14                 REGISTER 14\nR15      EQU   15                 REGISTER 15\n         EJECT\n         SAVE  (14,12)            SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH\n         USING COMMAND,R12        ADDRESSABILITY\n         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS\n         ST    R13,SAVEAREA+4     ESTABLISH BACK\n         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS\n         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS\n         LR    R10,R1             SAVE PARAMETER REGISTER\n         SPACE 2\n*********************************************************** *CKO 07/92*\n* Determine whether user is authorized to the application   *CKO 07/92*\n*********************************************************** *CKO 07/92*\nRACHK    EQU  *                                             *CKO 07/92*\n         RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*\n         LTR  R15,R15             Authorized to this prog?  *CKO 07/92*\n         BNZ  NOTAUTH             Nope.                     *CKO 07/92*\n         SPACE 2                                            *CKO 07/92*\n         L     R2,CVTPTR          R2 = ADDR OF CVT\n         USING CVT,R2\n         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD\n         L     R4,12(R3)          R4 = ADDR OF OUR ASCB\n         USING ASCB,R4\n         MVC   ASID,ASCBASID      SAVE OUR ASID\n         DROP  R4\n         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*\n         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*\n         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*\n         LR    R2,R4              R2 = R4                   *HMD 07/81*\n         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*\n         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*\n         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*\n         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*\n         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*\n         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*\n         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*\nUCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*\n         C     R5,UCMMCENT        IS THIS THE MASTER CON    *HMD 07/81*\n         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*\n         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*\n         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*\nUCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*\n         CR    R5,R7              END OF UCM'S?             *HMD 07/81*\n         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*\n         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*\n         SPACE 3\nINITDONE DS    0H                 CHECK OUT INPUT PARM\n         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*\n         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*\n         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?\n         BO    ONEPARM            YES; ONLY PARM\n         TM    4(R10),X'80'       IS SECOND THE LAST PARM?\n         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)\n***********************************************************************\n*                                                                     *\n*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *\n*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *\n*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *\n*                                                                     *\n***********************************************************************\n         XR    R2,R2              CLEAR R2\n         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER\n         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID\n         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK\n         L     R3,0(R10)          R3 = ADDR OF INPUT LINE\n         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT\n         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND\n         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING\n         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*\n         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*\n         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*\n         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*\n         BNH   LENOK              LENGTH IS OK              *HMD 07/81*\n         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*\nLENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC\n         EX    R2,MOVE1           MOVE CMD INTO CARD\n*************************************************************HMD 07/82*\n** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*\n** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*\n** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*\n**                                                          *HMD 07/82*\n** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*\n** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*\n** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*\n** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*\n** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*\n** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*\n** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*\n** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*\n** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*\n** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*\n** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*\n** DUMP.                                                    *HMD 07/82*\n**                                                          *HMD 07/82*\n** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*\n** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*\n** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*\n** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*\n*************************************************************HMD 07/82*\n         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*\n         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*\n         CLC   =C'start ',CARD    L         C               *HMD 07/82*\n         BE    STARTM               O          A            *HMD 07/82*\n         CLC   =C's ',CARD            W            S        *HMD 07/82*\n         BE    STARTM                   E             E     *HMD 07/82*\n         CLC   =C'mount ',CARD            R                 *HMD 07/82*\n         BE    STARTM                                       *HMD 07/82*\n         CLC   =C'm ',CARD                                  *HMD 07/82*\n         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*\nSTARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*\nDOCMD    B     DOSVC34            GO DO THE COMMAND\n***********************************************************************\n*                                                                     *\n*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *\n*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *\n*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *\n*     FROM', SO USE THAT FOR THE R0 MASK.                             *\n*                                                                     *\n***********************************************************************\nTWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34\n         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34\n***********************************************************************\n*                                                                     *\n*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *\n*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *\n*                                                                     *\n***********************************************************************\nONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS\n         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*\n         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH\n         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN\n         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*\n         BNH   CMDOK              NO, IS OK                 *HMD 07/81*\n         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*\nCMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE\n         EX    R3,MOVE            EXECUTE MVC\nDOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *\n*                                                                     *\n***********************************************************************\nUSESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*\nGETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST\n         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80\n         CLI   CARD,C'*'          IS THIS A COMMENT?\n         BE    GETSYSIN           YES;GO GET ANOTHER CARD\n         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\nEODSYSIN CLOSE (SYSIN)            CLOSE SYSIN\n         SPACE 3\nEOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA\n         RETURN (14,12),RC=0      RETURN TO CALLER\n         SPACE 3                                            *CKO 07/92*\nBADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*\n         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*\n         EJECT\n***********************************************************************\n*                                                                     *\n*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *\n*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *\n*                                                                     *\n***********************************************************************\nSVC34    DS    0H\n         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*\n         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*\nFINDTEXT DS    0H                 FIND LAST TEXT CHARACTER\n         CR    R3,R4              ALL BLANK?\n         BNH   SVC34END           YES - IGNORE IT\n         CLI   0(R3),C' '         BLANK CHARACTER?\n         BNE   GOTTEXT            NO - FOUND END OF TEXT\n         BCT   R3,FINDTEXT        KEEP ON LOOKING\n         SPACE\nGOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS\n         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*\n         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*\n         LA    R3,5(R3)           TEXT AND LIST PREFIX\n         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH\n         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*\n         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*\n         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*\n         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE\n* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW\n* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.\n* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.\n         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*\n         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*\nMODEOK   DS    0H                                           *HMD 07/82*\n*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n*        WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*\n         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n         WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MODESET KEY=ZERO         INDICATE KEY=ZERO\n         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*\n         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*\n         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n*                                 ARE WE USING SYSIN?       *HMD 07/81*\n         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*\n         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*\nNOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*\n         MODESET KEY=NZERO        GO BACK TO USER KEY\n         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*\n         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE\n* DONE ISSUING COMMANDS.\n         SPACE\nSVC34END DS    0H                 END OF COMMAND ROUTINE\n         BR    R11                RETURN TO MAINLINE\n         SPACE 2                                            *CKO 07/92*\nNOTAUTH  EQU  *                                             *CKO 07/92*\n         TPUT  =CL60'Authorization failed for executing COMMAND',60\n         B     BADEOJ                     Exit              *CKO 07/92*\n         EJECT\nSAVEAREA DC    18F'0'             OUR SAVEAREA\nHOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*\nR0MASK   DC    A(0)               R0 MASK FOR SVC34\nAUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*\nAUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*\nMOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*\nASID     DC    H'00'              OUR ASID\n* Parms for RACHECK                                         *CKO 07/92*\nCMDENT   DC    CL8'COMMAND'                                 *CKO 07/92*\nCMDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*\n         SPACE\n         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD\nCMDLIST  DC    AL2(*-*,0)         SVC 34 LIST\nCARD     DC    CL101' '           COMMAND TEXT\n         SPACE 3\nMOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST\nMOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST\n         EJECT\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *\n               EODAD=EODSYSIN\nMSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX\n               ND:',MF=L\nMSG2     WTO '                                                         X\n                                                          ',MF=L\nWTOCMD   EQU MSG2+4\n         EJECT\n         LTORG                    BEGIN LITERAL POOL\n         EJECT\n***********************************************************************\n*                                                                     *\n*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *\n*                                                                     *\n*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *\n*                                                                     *\n***********************************************************************\n         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE\n         EJECT\n         IHAASCB                  ADDRESS SPACE CONTROL BLOCK\n         EJECT\n         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*\n         EJECT                                              *HMD 07/81*\n         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*\n         END\n//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(COMMAND),DISP=SHR,UNIT=\n./ ADD NAME=RESCUE   0100-02365-02365-1141-00363-00363-00000-JMILLER\n/*---------------------------------------------------Rexx--*/\n/*         M A I N    R E S C U E    E X E C               */\n/*---------------------------------------------------------*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* Read the $$$DOC member for more information on using    */\n/* the RESCUE execs.                                       */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\n\ncall varinit          /* Read @parms and @dataset.         */\ncall ##jobchr reset   /* Reset job char file.              */\n\n/*---------------------------------------------------------*/\n/* Be sure all datasets are present; if not, exit.         */\n/*---------------------------------------------------------*/\nif  \\dscheck() THEN DO\n   SAY 'One or more datasets missing.  Processing terminated.'\n   exit\nend\n\n/*---------------------------------------------------------*/\n/* Call routines to build various JCL members.             */\n/*---------------------------------------------------------*/\ncall #initvol         /* Init volume.                      */\ncall #defmcat         /* Define mastercat.                 */\ncall #defvsam         /* Define PAGE, MANx, etc.           */\ncall #defnvsm         /* Define NONVSAM catalog entries.   */\ncall #alcnvsm         /* Allocate non-VSAM datasets.       */\ncall #copyds          /* Copy datasets.                    */\ncall #altnvsm         /* Alter NONVSAM entries.            */\ncall #rfdsnt          /* Create RACF dataset name table.   */\ncall #rfstc           /* Create RACF started task table.   */\ncall #rfcopy          /* Create copy of RF dataset.        */\ncall #members         /* Build various members. (External) */\ncall #copymem         /* Copy members.                     */\ncall #delssa          /* Delete the System Specific Alias. */\ncall #misc            /* Last minute assorted stuff.       */\n\nexit\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n###dslst = \"\"\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   IF pos(##prm,zzparm) > 0 THEN DO\n      ###dslst = ###dslst\" \"zzdsn1\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdsthere:\nARG ##prm .\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n\ndo ##xxx = 1 TO DSNS.0\n   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   say VALUE(\"JOBCARD\"##x8)\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/*' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   INTERPRET q '= \"'r'\"'\nEND\n\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(pds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(pds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*---------------------------------------------------------*/\n/* Check for presence of all datasets.  If copy mode is    */\n/* \"N\" meaning the DS is not copied bu just created, then  */\n/* assume it is ok.                                        */\n/*---------------------------------------------------------*/\ndscheck:\nSay \"Checking datasets in @DATASET member.\"\n##ok = 1\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /*--------------------------------------------------*/\n   /* If a model is specified, then check only for the */\n   /* existence of the model ds.                       */\n   /*--------------------------------------------------*/\n   stat = SYSDSN(\"'\"zzdsn1\"'\")\n   IF stat /= 'OK' THEN DO\n      SAY 'Dataset not found: 'zzdsn1\n      ##ok = 0\n   END\nEND\nRETURN ##ok\n\nIF zzmode = \"N\" THEN ITERATE /* No copy-> assume ok. */\n./ ADD NAME=WAIT     0100-02365-02365-1141-00157-00157-00000-JMILLER\n//EGTLJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=EGTLJCM,REGION=6M\n//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD  *\nPRC      TITLE 'WAIT - WAIT A LITTLE BIT.'\n********************************************************************\n*                                                                  *\n* NAME - WAIT.                                                     *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *\n*     WAIT. DEFAULT IS 10 SECONDS.                                 *\n*                                                                  *\n* RETURN CODES -                                                   *\n*                                                                  *\n*   R15 = 20, BAD PARM FIELD.                                      *\n*                                                                  *\n* LOG -                                                            *\n*   05/30/86 L01 PTW IMPLEMENTED                                   *L01\n*   09/27/88 L02 PTW IMPLEMENTED                                   *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'WAIT'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12\n         GETMAIN RU,LV=DYNLEN\n         LR    R2,R13\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LR    R0,R1\n         LA    R14,DYNLEN\n         LA    R1,R1\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVC   SECONDS,=F'10'     DEFAULT.\n         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).\n         L     R2,24(,R2)         A(A(PARM)).\n         LTR   R2,R2              CHECK FOR NULL PARM.\n         BZ    DOTIME\n         L     R2,0(,R2)          A(PARM).\n         LH    R3,0(,R2)          L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    DOTIME               THEN EXIT.\n         CH    R3,=H'4'           IF LENGTH NGT '4' +\n         BH    BADTIME            FORGET NEXT.\n         LA    R4,2(,R2)\nVERNUM   DS    0H\n         CLI   0(R4),C'0'         SCAN\n         BL    BADTIME             FORWARD\n         CLI   0(R4),C'9'         SCAN\n         BH    BADTIME             FORWARD\n         LA    R4,1(,R4)            TO FIRST\n         BCT   R3,VERNUM\n         LH    R3,0(,R2)\n         BCTR  R3,0               MACHINE LENGTH.\n         EX    R3,PACKSEC         PACK SECONDS.\n         CVB   R3,DOUBLE          CONVERT TO BINARY.\n         CH    R3,=H'1'           TEST SECONDS\n         BL    BADTIME             FOR LIMITS.\n         CH    R3,=H'9999'\n         BH    BADTIME\n         ST    R3,SECONDS          AND STORE.\nPACKSEC  PACK  DOUBLE,2(*-*,R2)\n********************************************************************\n*                                                                  *\n*        W A I T                                                   *\n*                                                                  *\n********************************************************************\nDOTIME   DS    0H\n         L     R2,SECONDS\n         MH    R2,=H'100'\n         ST    R2,SECONDS\n         STIMER WAIT,BINTVL=SECONDS\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADTIME  DS    0H\n         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         MVC   RC,=F'20'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nDOUBLE   DS    D\nRC       DS    F\nSECONDS  DS    F\nDYNLEN   EQU   *-DYNAMIC\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n//L.SYSLMOD DD  DSN=SYSOSG.CSULOAD(WAIT),DISP=SHR,UNIT=\n./ ADD NAME=ZBPXPRM  0100-02365-02365-1141-00049-00049-00000-JMILLER\nFILESYSTYPE TYPE(HFS)\n            ENTRYPOINT(GFUAINIT)\n            PARM(' ')\n\nFILESYSTYPE TYPE(TFS)\n            ENTRYPOINT(BPXTFS)\n\n   MAXPROCSYS(900)\n   MAXPROCUSER(100)\n   MAXUIDS(200)\n   MAXFILEPROC(2000)\n   MAXPTYS(800)\n   CTRACE(CTIBPX00)\n   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)\n   NETWORK DOMAINNAME(AF_UNIX)\n           DOMAINNUMBER(1)\n           MAXSOCKETS(2000)\n           TYPE(UDS)\n   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)\n   NETWORK DOMAINNAME(AF_INET)\n           DOMAINNUMBER(2)\n           MAXSOCKETS(64000)\n           TYPE(INET)\n   MAXTHREADTASKS(1000)\n   MAXTHREADS(500)\n   IPCMSGNIDS    (500)\n   IPCMSGQBYTES  (2147483647)\n   IPCMSGQMNUM   (10000)\n   IPCSHMNIDS    (500)\n   IPCSHMSPAGES  (262144)\n   IPCSHMMPAGES  (25600)\n   IPCSHMNSEGS   (500)\n   IPCSEMNIDS    (500)\n   IPCSEMNSEMS   (1000)\n   IPCSEMNOPS    (25)\n   MAXMMAPAREA(40960)\n   MAXCORESIZE(4194304)\n   MAXASSIZE(209715200)\n   MAXCPUTIME(1000)\n   MAXSHAREPAGES(131072)\n   FORKCOPY(COW)\n   SUPERUSER(BPXROOT)\n   TTYGROUP(TTY)\n   STARTUP_PROC(OMVS)\n   SYSCALL_COUNTS(NO)\n   MAXQUEUEDSIGS(1000)\n   SYSPLEX(NO)\n   SHRLIBRGNSIZE(67108864)\n   SHRLIBMAXPAGES(4096)\n./ ADD NAME=ZCOMMND  0100-02365-02365-1141-00008-00008-00000-JMILLER\nCOM='CD SET,SDUMP,NODUMP'\nCOM='S VLF,SUB=MSTR'\nCOM='S DLF,SUB=MSTR'\nCOM='S TSSO,SUB=MSTR'\nCOM='S EZAZSSI,P=NORMVS'\nCOM='S IRRDPTAB'\nCOM='S SDSF'\nCOM='S VTAM,,,(LIST=00)'\n./ ADD NAME=ZIEALPA  0100-02365-02365-1141-00006-00006-00000-JMILLER\n/*-------------------------------------------------------------*/\n/* MLPA modules.  Do not specify RACF DSNT and STC tables      */\n/* (ICHRIN03 and ICHRDSNT) is they are being auto-built.       */\n/* MLPA entries for these modules will be build automatically  */\n/* if they are omitted here.                                   */\n/*-------------------------------------------------------------*/\n./ ADD NAME=ZIEASYS  0100-02365-02365-1141-00042-00042-00000-JMILLER\nAPG=07,                       AUTOMATIC PRIORITY GROUP IS 7\nCLOCK=00,                     SELECT CLOCK00\nCLPA,                         ALWAYS DO CLPA\nCMB=(UNITR,COMM,GRAPH,CHRDR), ADDITIONAL CMB ENTRIES\nCMD=(00,01),\nCON=00,                       SELECT CONSOL00\nCSA=(3000,30000),             CSA RANGE\nDUMP=DASD,                    PLACE SVC DUMPS ON DASD DEVICES\nGRS=NONE,                     NO COORDINATION OF GRS REQUESTS\nICS=00,                       SELECT IEAICS00, CNTL SPECS FOR SRM\nIPS=00,                       SELECT IEAIPS00, PERF SPECS FOR SRM\nLNKAUTH=LNKLST,               AUTHORIZE LNKLST00, APFTAB IS ALTERNATE\nLOGCLS=L,                     WILL NOT BE PRINTED BY DEFAULT\nLOGLMT=999999,                MAX WTL MESSAGES QUEUED, MUST BE 6 DIGITS\nLOGREC=SYS1.LOGREC,           ERROR RECORDING\nLPA=00,                       SELECT LPALST00\nMAXUSER=250,                  SYS TASKS PLUS INITS PLUS TSOUSERS\nMLPA=00,                      SELECT IEALPA00, MLPA PARAMETERS\nMSTRJCL=01,                   SELECT MSTJCL01, MASTER JCL\nOMVS=(00),                    SELECT BPXPRM00\nOPI=YES,                      ALLOW OPERATOR OVERRIDE TO IEASYS00\nOPT=00,                       SELECT IEAOPT00, SRM TUNING PARAMETERS\nPAGE=(PAGE.RESCUE.PLPA,\n      PAGE.RESCUE.COMMON,\n      PAGE.RESCUE.LOCAL1,L),\nPAK=00,                       SELECT IEAPAK00\nPROG=(L0,A0),                 SELECT PROGL0 AND A0 (LINKLST AND APF)\nREAL=128,                     ALLOWS 2 64K OR 1 128K JOB TO RUN V=R\nRSU=0,                        NO RECONFIG STORAGE UNITS\nRSVNONR=5,                    RESERVED ASVT ENTRIES\nRSVSTRT=5,                    RESERVED ASVT ENTRIES\nSCH=00,                       SELECT SCHED00\nSMF=00,                       SELECT SMFPRM00, SMF PARAMETERS\nSMS=00,                       SMS PARAMETERS\nSQA=(15,64),                  SQA SIZE APPROX 640K\nSSN=00,                       SELECT IEFSSN00, SUBSYSTEM NAMES\nSYSNAME=RESCUE,               SYSTEM NAME\nPROD=00,                      SELECT IFAPRD01\nSVC=00,                       SELECT IEASVC00, USER SVCS\nVAL=00,                       SELECT VATLST00\nVIODSN=SYS1.STGINDEX,         VIO DS\nVRREGN=64                     DEFAULT REAL-STORAGE REGION SIZE\n./ ADD NAME=ZIEFSSN  0100-02365-02365-1141-00012-00012-00000-JMILLER\nSUBSYS SUBNAME(SMS)\n   INITRTN(IGDSSIIN)\n   INITPARM('ID=02,PROMPT=DISPLAY')\nSUBSYS SUBNAME(JES2) PRIMARY(YES) START(YES)\nSUBSYS SUBNAME(IRLM)\nSUBSYS SUBNAME(JRLM)\nSUBSYS SUBNAME(FFST)\nSUBSYS SUBNAME(SOM)  INITRTN(GOSAMSSI)\nSUBSYS SUBNAME(TNF)\nSUBSYS SUBNAME(VMCF)\nSUBSYS SUBNAME(CICS) INITRTN(DFHSSIN)\nSUBSYS SUBNAME(TSSO) INITRTN(TSSOINIT)\n./ ADD NAME=ZIGDSMS  0100-02365-02365-1141-00010-00010-00000-JMILLER\n    INTERVAL(15)\n    DINTERVAL(150)\n    REVERIFY(NO)\n    ACSDEFAULTS(NO)\n    TRACE(ON)\n    SIZE(128K)\n    TYPE(ALL)\n    JOBNAME(*)\n    ASID(*)\n    SELECT(ALL)\n./ ADD NAME=ZISPALOC 0100-02365-02365-1141-00045-00045-00000-JMILLER\n/*-------------------------------------------------------rexx--------*/\n/* TSO Allocation EXEC.                                              */\n/* Rescue System.                                                    */\n/*                                                                   */\n/* 03/17/2001 John C. Miller                                         */\n/*-------------------------------------------------------------------*/\ncall setup\n\n/*-------------------------------------------------------------------*/\n/* Allocate ISPPROF dataset                                          */\n/*-------------------------------------------------------------------*/\nispprof = USERID()\".ISPF.ISPPROF\"\nif \\alc('ISPPROF', \"'\"ispprof\"'\") THEN DO\n   \"alloc da('\"ispprof\"') f(ISPPROF) new\",\n   \"space(1 1) cyl lrecl(80) blksize(6160) recfm(f b) dir(15)\"\n   cc = RC\n   IF cc /= 0 THEN DO\n      SAY \"Unable to allocate ISPF profile dataset \"ispprof\";\"\n      SAY \"Please contact systems support for assistance.\"\n      SAY \"Return code: \"cc\n   END\nEND\n\n/*-------------------------------------------------------------------*/\n/* Execute user CLIST/Exec if present (Pre-allocation)               */\n/*-------------------------------------------------------------------*/\nIF SYSDSN(\"'\"ispprof\"(PRE)'\") = \"OK\" THEN DO\n   \"EXEC '\"ispprof\"(PRE)'\"\n   cc = RC\n   IF cc /= 0 THEN exit\nEND\n\n\"PDF\"\nexit\n\n/*--------- Allocate the concatenation ------------*/\nalc:\nPARSE UPPER ARG ddname, dsname\nmg = MSG('OFF')                          /* Turn msg off             */\n\"FREE  FI(\"ddname\")\"                     /* Free the DDNAME          */\nmg = MSG(mg)                             /* Restore msg level        */\n\"ALLOC FI(\"ddname\") DA(\"dsname\") SHR\"    /* Allocate the files       */\ncc = RC                                  /* Save return code         */\nRETURN cc <= 4                           /* Return 1 if OK           */\n\n./ ADD NAME=ZJES2PRM 0100-02365-02365-1141-00480-00480-00000-JMILLER\n/*-------------------------------------------------------*/\n/* The parms below were copied from ZJES2PRM in          */\n/* the REACUE build PDS. It is recommended that you not  */\n/* modify these parameters directly, but rather make any */\n/* changes to the ZJES2PRM source, and rebuild the       */\n/* RESCUE members.  03/10/2001 John C. Miller.           */\n/*-------------------------------------------------------*/\nOPTSDEF LOG=YES\n/*                                                                   */\nLOGON(1) APPLID=JES2\n/*                                                                   */\nBUFDEF   BELOWBUF=(LIMIT=114,WARN=80)\n/*                                                                   */\nCONDEF   AUTOCMD=50,\n         BUFNUM=950,\n         BUFWARN=80,\n         CONCHAR=$,\n         DISPLEN=65,\n         DISPMAX=100,\n         MASMSG=200,\n         RDRCHAR=$\nDEBUG    =NO\nCOMPACT  NAME=JESDATA,\n         NUMBER=10,\n         CHARS=(16,\n           F1,F2,F3,F4,F5,F6,\n           F7,F8,F9,A,E,I,D6,\n           E4,40,X)\nESTBYTE  NUM=99999,\n         INT=99999,\n         OPT=0\nESTIME   NUM=2,\n         INT=1,\n         OPT=NO\nESTLNCT  NUM=5,\n         INT=6000,\n         OPT=0\nESTPAGE  NUM=100,\n         INT=10,\n         OPT=0\nESTPUN   NUM=100,\n         INT=2000,\n         OPT=0\nFSSDEF(PRINTOFF)\nINIT(1) NAME=1,CLASS=A,START=YES\nINIT(2) NAME=1,CLASS=A,START=YES\nINIT(3) NAME=1,CLASS=A,START=YES\nINIT(4) NAME=1,CLASS=A,START=YES\nINIT(5) NAME=1,CLASS=A,START=YES\nINIT(6) NAME=1,CLASS=A,START=YES\nINIT(7) NAME=1,CLASS=A,START=YES\nINIT(8) NAME=1,CLASS=A,START=YES\nINITDEF  PARTNUM=8\n/*                                                                  */\nINTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,\n         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=20\n/*                                                                   */\nJOBCLASS(A) ACCT=NO,         /* ACCT# NOT REQ   B................... */\n         PGMRNAME=NO,        /* PGMRNM NOT RQ   B................... */\n         TIME=(0030,00),     /* JOB STEP TIME   ...MMMMSS........... */\n         REGION=4096K,       /* REGION SIZE     .........CCC........ */\n         COMMAND=VERIFY,     /* VERIFY CMDS     ............R....... */\n         BLP=YES,            /* IGNORE BLP      .............L...... */\n         AUTH=ALL,           /* ALLOW ALL CMD   ..............AAAA.. */\n         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */\n         COPY=NO,            /* NOT TYPRUN=COPY                 DHWNC*/\n         HOLD=NO,            /* NOT TYPRUN=HOLD                 DHWNC*/\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         JOURNAL=NO,         /* JOURNAL THIS JOB CLASS          DHWNC*/\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         RESTART=NO,         /* NO REQUEUE (XEQ) ON IPL         DHWNC*/\n         SCAN=NO,            /* NOT TYPRUN=SCAN                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n/*                                                                   */\n/*                                                                   */\nJOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL      DOHWNC*/\n         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR       DOHWNC*/\n     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                     DC*/\n         JOBNUM=9999,        /* JOB QUEUE SIZE                  MAM2*/\n         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES   DOHWNC*/\n         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB. DOHWNC*/\n         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING          DOHWNC*/\n         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED         DOHWNC*/\n         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D         DOHWNC*/\n         PRTYLOW=5,          /* LOWER LIMIT FOR AGING          DOHWNC*/\n         PRTYRATE=96,        /* PRTY AGING RATE X/DAY          DOHWNC*/\n         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE          DOWNC*/\n/*                                                                   */\nJOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                  DOHWNC*/\n          TIME=2             /*  < 2 MIN. EXEC. TIME           DOHWNC*/\n                             /*                                      */\nJOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */\n          TIME=5             /*  < 5 MIN. EXEC. TIME                 */\n                             /*                                      */\nJOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/\n                             /* ETC.                                 */\n                             /*                                      */\nJOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/\n         TIME=1440           /* ETC.                                 */\n                             /*                                      */\n/*                            *--------------------------------------*\n                              |    IDENTIFY JES2 APPLIDS TO VTAM     |\n                              *--------------------------------------*\n                                                                    */\nMASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */\n         HOLD=100,           /* MINIMUM HOLD TIME                    */\n         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */\n         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */\n                             /*                                      */\n/*                                                                  */\nNJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME            DOHWNC*/\n         JRNUM=4,           /* NUM. OF JOB RECEIVERS           DHWNC*/\n         JTNUM=4,           /* NUM. OF JOB XMITTERS            DHWNC*/\n         LINENUM=1,         /* NUM. OF LINES FOR NJE           DHWNC*/\n         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES         MAM2*/\n         OWNNODE=1,         /* THIS NODE'S NUMBER              MAM  */\n         PATH=1,            /* NUM. OF PATHS/ALT'NATE          DHWNC*/\n         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE       DHWNC*/\n         RESTNODE=100,      /* THIS NODE'S RESISTANCE          DHWNC*/\n         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE       DHWNC*/\n         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS        DHWNC*/\n         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS     DHWNC*/\n/*                                                                  */\n/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */\n/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */\n                             /*                                      */\nOFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART\nOFF(1).JR CLASS=,           /* RELOAD ALL CLASSES             DOHWNC*/\n         HOLD=,             /* RELOAD HELD - NON-HELD         DOHWNC*/\n         JOBNAME=,          /* RELOAD ANY JOB NAME            DOHWNC*/\n                            /* MODIFY JOBS ON RELOAD                */\n         MOD=(CLASS=,       /* - DON'T CHANGE CLASS           DOHWNC*/\n              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/\n              ROUTECDE=,    /* - DON'T CHANGE DEST'N          DOHWNC*/\n              SYSAFF=),     /* - DON'T CHANGE SYSAFF.         DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/\n         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* ABORTED WITH $S OFFLOAD         DHWNC*/\n         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF       DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n/*                                                                  */\nOFF(1).JT CLASS=,           /* SELECT NO CLASSES              DOHWNC*/\n         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/\n         HOLD=,             /* SELECT HELD - NON-HELD         DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD     DHWNC*/\n         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF       DOHWNC*/\n         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n/*                                                                  */\nOFF(1).SR BURST=,         /* SELECT ANY BURST SETTING       DOHWNC*/\n         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),\n         FCB=,              /* SELECT ANY FCB                 DOHWNC*/\n         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/\n         HOLD=,             /* SELCT HELD/NON-HLD JOBS        DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n                            /* MODIFY FOLLOWING ON RELOAD     DOHWNC*/\n         MOD=(BURST=,       /* - DON'T CHANGE BURST           DOHWNC*/\n              OUTDISP=,     /* - DON'T CHANGE DSHOLD          DOHWNC*/\n              FCB=,         /* - DON'T CHANGE FCB             DOHWNC*/\n              FLASH=,       /* - DON'T CHANGE FLASH           DOHWNC*/\n              FORMS=,       /* - DON'T CHANGE FORMS           DOHWNC*/\n              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/\n              PRMODE=,      /* - DON'T CHANGE PRMODE          DOHWNC*/\n              QUEUE=,       /* - DON'T CHANGE CLASS           DOHWNC*/\n              ROUTECDE=,    /* - DON'T CHANGE DESTN           DOHWNC*/\n              UCS=,         /* - DON'T CHANGE UCS             DOHWNC*/\n              WRITER=),     /* - DON'T CHANGE WRITER          DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/\n         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/\n         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/\n         UCS=,              /* SELECT ANY UCS                 DOHWNC*/\n         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DOHWNC*/\n                            /* - CLASS ONLY                   DOHWNC*/\n/*                                                                  */\nOFF(1).ST BURST=,           /* SELECT ANY BURST SET'G         DOHWNC*/\n         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/\n         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),\n         FCB=,              /* SELECT ANY FCB                 DOHWNC*/\n         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/\n         HOLD=,             /* SELCT HELD-NON-HLD JOBS        DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n         LIMIT=(0-*),       /* SELECT ANY # LINES             DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/\n         PLIM=(0-*),        /* SELECT ANY # PAGES             DOHWNC*/\n         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/\n         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/\n         UCS=,              /* SELECT ANY UCS                 DOHWNC*/\n         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/\n         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n                            /* - CLASS ONLY                   DOHWNC*/\n/*                                                                   */\n/*********************************************************************/\nOUTCLASS(A) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(B) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* NO TRACK-CELL                      WC*/\n/*                                                                  */\nOUTCLASS(C) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(D) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(H) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\n/*                                                                  */\nOUTCLASS(J) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* SPECIAL PRINT CLASS                WC*/\n         TRKCELL=NO        /* NO TRACK-CELL                      WC*/\n/*                                                                 */\nOUTCLASS(K) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */\n         OUTDISP=(HOLD,HOLD),                 /*               MAM */\n         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */\n/*                                                                 */\nOUTCLASS(L) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(KEEP,KEEP),\n         OUTPUT=PRINT,      /* PRINT CLASS FOR LWTR               WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(M) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                 */\nOUTCLASS(O) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */\n         OUTDISP=(HOLD,HOLD),                 /*               MAM */\n         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */\n/*                                                                 */\nOUTCLASS(P) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Q) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(T) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\n/*                                                                  */\nOUTCLASS(X) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Y) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Z) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(5) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(PURGE,PURGE),\n         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING     DOWNC*/\n         COPIES=255,        /* MAX. # OF COPIES ALLOWED       DOHWNC*/\n         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/\n         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/\n         JOEWARN=80,        /* WARNING THRESHOLD %            DOHWNC*/\n         PRTYHIGH=255,      /* CEILING FOR PRTY AGING         DOHWNC*/\n         PRTYLOW=0,         /* FLOOR FOR PRTY AGING           DOHWNC*/\n         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT          DOHWNC*/\n         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/\n         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/\n/*                                                                  */\nOUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF          DOHWNC*/\n         RECORD=2000,       /*  < 2000 RECORDS (LINE)         DOHWNC*/\n         PAGE=50            /*  OR < 50 PAGES (PAGE)          DOHWNC*/\n/*                                                                  */\nOUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF          DOHWNC*/\n         RECORD=5000,       /*  < 5000 RECORDS (LINE)         DOHWNC*/\n         PAGE=100           /*  OR < 100 PAGES (PAGE)         DOHWNC*/\n/*                                                                  */\nOUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/\n           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/\n           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/\n                             /* ETC.                               OC*/\nOUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/\n           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/\n           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/\n                             /* ETC.                               OC*/\n/*                                                                  */\nPCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES        DHWNC*/\n         OUTNUM=2,          /* NUMBER OF OUTPUT PCES           DHWNC*/\n         PSONUM=2,          /* NUMBER OF PSO PCES              DHWNC*/\n         PURGENUM=2         /* NUMBER OF PURGE PCES            DHWNC*/\n/*                                                                   */\nPRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/\n         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/\n         FCB=6,             /* INITIAL FCB LOADED               DWNC*/\n         LINECT=61,         /* 61 LINES/PAGE                  DOHWNC*/\n/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/\n/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/\n                             /* NOTE: THE VALUES FOR NIFCB= AND      */\n                             /*       NIFLASH=  CANNOT BE NULL OR    */\n                             /*       ASTERISKS (AS SHOWN HERE).     */\n                             /*       IF THE STATEMENTS ARE NOT      */\n                             /*       CODED AT ALL, THEN THE DEFAULT */\n                             /*       WILL BE ASTERISKS. THE         */\n                             /*       STATEMENTS ARE SHOWN THIS WAY  */\n                             /*       ONLY TO INCLUDE THE DEFAULT    */\n                             /*       VALUES HERE.                   */\n         NIUCS=0,            /* WAS GT15                         DWNC*/\n         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/\n         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),\n         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/\n         UCS=0               /* BYPASS UCS-LOADING               DWNC*/\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    LOCAL PRINTERS                    |\n                              *--------------------------------------*\n                                                                     */\n                             /* ALTERNATE NAME FOR PRTN:             */\n                             /*   PRINTERN                           */\nPRT(1)  CLASS=AJ,        /* JOB CLASS THAT CAN BE CHOSEN   DOHWNC*/\n        UNIT=00E,\n        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE    DOHWNC*/\n        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT        DOHWNC*/\n        START=YES,       /*  PRT1 COMES UP STARTED          DOHWNC*/\n        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),\n        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/\n/*                                                                  */\nPRT(2)  CLASS=AJ,        /* JOB CLASS THAT CAN BE CHOSEN   DOHWNC*/\n        UNIT=60F,\n        CKPTLINE=60,     /*  MAX LINES IN A LOGICAL PAGE    DOHWNC*/\n        CKPTPAGE=100,    /*  MAX PAGES BEFORE A CKPT        DOHWNC*/\n        START=YES,       /*  PRT2 COMES UP STARTED          DOHWNC*/\n        WS=(W,R,Q,PRM,LIM,F,FCB/UCS,P),\n        TRKCELL=NO       /*  RECORDS DESPOOLED 1 AT A TIME    HWNC*/\n/*                                                                   */\n/*                                                                   */\nPUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/\n         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/\n         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/\n/*                                                                   */\nPUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/\n        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/\n/*                                                                   */\nPUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/\n        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/\n/*                                                                   */\nRDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN) DOHWNC*/\n        CLASS=A,        /* DEFAULT JOB CLASS              DOHWNC*/\n        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)DOHWNC*/\n        MSGCLASS=A     /* DEFAULT MESSAGE CLASS          DOHWNC*/\n                             /* ERRORS ARE COUNTED                   */\n                             /*                                      */\n/*                                                                   */\nSMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/\n         BUFWARN=80          /* WARNING THRESHOLD %            DOHWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    SSI DEFINITIONS                   |\n                              |    ADDED IN SP311                    |\n                              *--------------------------------------*\n                                                                     */\nSSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT  DOHWNC*/\n                            /* WHETHER OR NOT TRACING IS      DOHWNC*/\n                            /*  ACTIVE FOR THIS SSI FUNCTION        */\n/*                                                                   */\nSTCCLASS TIME=(0010,00),     /* JOB STEP TIME   ...MMMMSS........... */\n         REGION=0K,          /* REGION SIZE     .........CCC........ */\n         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */\n         BLP=YES,            /* IGNORE BLP PARM .............L...... */\n         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */\n         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS           DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n                             /*     (ADDED BY APAR OY02574)          */\n                             /*     (SUPERSEDED BY APAR OY03444)     */\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n/*                                                                   */\n/*                             TP (NJE/RJE) CHARACTERISTICS          */\n/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */\nTPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),\n         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE       DHWNC*/\n         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE   DOHWNC*/\n         SESSION=20,         /* MAX. # SNA SESSIONS             DHWNC*/\n         AUTOINTV=120\n/*                                                                   */\n/*********************************************************************/\nTRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID          DOWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    $TRACE FACILITY                   |\n                              *--------------------------------------*\n                                                                     */\nTRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES          DOWNC*/\n         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/\n         TABWARN=80,         /* WARNING THRESHOLD %             DOWNC*/\n         ACTIVE=NO,          /* WHETHER OR NOT TO START HE      DOWNC*/\n                             /*  TRACE FACILITY                      */\n         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND    DOWNC*/\n                             /*  ADD DATA TO TRACE LOG DATASET       */\n              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET   DOWNC*/\n              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS  DOWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    TSU DEFAULTS                      |\n                              *--------------------------------------*\n                                                                     */\nTSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */\n         REGION=0K,          /* REGION SIZE     .........CCC.......  */\n         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */\n         BLP=NO,             /* IGNORE BLP PARM .............L.....  */\n         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */\n         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         MSGCLASS=Z,         /* DEFAULT MESSAGE CLASS           DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n                             /*     (ADDED BY APAR OY02574)          */\n                             /*     (SUPERSEDED BY APAR OY03444)     */\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n                             /*                                      */\n./ ADD NAME=ZJOBNUM  0100-02365-02365-1141-00001-00001-00000-JMILLER\n15\n./ ADD NAME=ZTSO     0100-02365-02365-1141-00005-00005-00000-JMILLER\n//TSO     PROC MBR=TSOKEY00\n//STEP1   EXEC PGM=IKTCAS00,TIME=1440\n//PARMLIB  DD  DSN=SYS1.RESCUE.PARMLIB(&MBR),DISP=SHR,FREE=CLOSE\n//PRINTOUT DD  SYSOUT=*,FREE=CLOSE\n//*\n./ ADD NAME=ZTSOKEY  0100-02365-02365-1141-00007-00007-00000-JMILLER\nUSERMAX=10,                                                            +\nRECONLIM=3,                                                            +\nBUFRSIZE=132,                                                          +\nHIBFREXT=6600,                                                         +\nLOBFREXT=3300,                                                         +\nCHNLEN=4,                                                              +\nSCRSIZE=1920\n./ ADD NAME=ZVATLST  0100-02365-02365-1141-00002-00002-00000-JMILLER\nVATDEF IPLUSE(PRIVATE),SYSUSE(PRIVATE)\nRESCUE,1,0,3390    ,Y\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESCUNEW": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x03\\x00\\x8f\\x01\\x03\\x00\\x8f#\\x10\\x18\\xac\\x18\\xac\\x00\\x00\\xc2\\xe4\\xc3\\xd2\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-01-08T00:00:00", "modifydate": "2003-01-08T23:10:00", "lines": 6316, "newlines": 6316, "modlines": 0, "user": "BUCKLEY"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ZCLONE30": {"ttr": 9217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x11?\\x01\\x10\\x11?\\x18\\tCGCG\\x00\\x00\\xd1\\xd4\\xc9\\xd3\\xd3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-23T00:00:00", "modifydate": "2010-04-23T18:09:00", "lines": 17223, "newlines": 17223, "modlines": 0, "user": "JMILLER"}, "text": "./ ADD NAME=$$$$DOC  0101-10057-10057-1938-00763-00760-00000-COMPJM\n---------------------------------------------------------------------\nzCLONE System Execs - V3.0\n---------------------------------------------------------------------\n07/18/2009\nJohn C. Miller\njohn@jmit.com\n---------------------------------------------------------------------\nNOTE: See the $$$QUIK member to get started with minimum verbiage.\nRead this member for the more verbose instructions.\n\nPlease email me with errors that you find or suggestions for improvement\nso that I can make this tool more useable.\n\n------------------------------------------------------------------------\n                              CONTENTS\n------------------------------------------------------------------------\n\nIntroduction--what is zClone?....................................1.0\n  Modifying the ZCLONE execs.....................................1.1\n\nUsing the execs to build a system................................2.0\n  Notes on building a system.....................................2.1\n  Steps to build a system with these execs.......................2.2\n\nParameters coded in the @PARMS member............................3.0\n\nParameters coded in the @DATASET member..........................4.0\n  DATASET ALLOC statement........................................4.1\n  MEMCOPY statement..............................................4.2\n\n\n---------------------------------------------------------------------\n1.0 - Introduction\n---------------------------------------------------------------------\n\nzCLONE started out originally as a set of assembler macros designed to\ncreate a single volume MVS XA rescue system.  The macros were patterned\nafter the old 2-stage MVS sysgen model.\n\nAs MVS/XA evolved into MVS/ESA and then OS/390 and z/OS, it became\nincreasingly difficult and then impossible to build a single volume\n(3390-3) one-pack rescue system with OMVS and all the trimmings.\n\nI subsequently rewrote the code in rexx for greater maintainability, and\nexpanded the execs to enable cloning systems occupying any number of\nvolumes.\n\nThese execs are designed as a generalized system cloning facility, and\nenable one to create an IPLable z/OS system that resides on as many\nvolumes as desired. This makes zCLONE useful for general z/OS cloning\noperations, in addition to building rescue systems.\n\nThe exec build a set of batch jobs that when run build a z/OS system\nfrom scratch.  Some PROCs and PARMLIB members are automatically\ngenerated based on the\n\n---------------------------------------------------------------------\n1.1 - Modifying the ZCLONE execs\n---------------------------------------------------------------------\n\nIf you want to tweak, hack, or otherwise modify these execs, by all\nmeans be my guest - but you're on your own.  I've tried to comment\nthe code sufficiently to give a saavy rexx coder the basic idea of\nwhat's going on. I try to avoid truly ugly, oblique, obscure, or\noverly terse ways of doing things in rexx when there's a simpler\nway, but I don't shy away from \"off the wall\" techniques when they\nwork best (or when I can't figure out a simpler way of doing a\ntask!)\n\nI've made the execs essentially modular, in that the main exec\nZCLONE calls external subroutines that are named starting with '#'.\nEach subroutine generally builds one job, or does one task.  To add\nsome new functionality of your own design, make a copy of one of the\nsubroutines like #initvol, for example, and make it do what you\nwant.  Then add a call to your new module from the ZCLONE member.\n\n---------------------------------------------------------------------\n2.0 - Using the execs to build a system\n---------------------------------------------------------------------\n\nThe process for building a system is to:\n1. Customize the @PARMS and @DATASET members;\n2. Run the $BUILD job to generate the JCL;\n3. Submit the generated batch jobs one at a time to create the new\n   system.\n\nYou can re-do the above steps over and over until you are happy with\nthe resulting system.  The execs and the generated batch jobs clean up\nafter themselves, so you can just start from step 1 as often as needed\nwithout doing anything special.  The only thing you might need to do is\ncustomize and enter the MVS commands in member $CATCLSE to unallocate\nand close your catalogs, so that your new catalog volume will come\noffline.\n\nYou don't have to be an MVS guru to successfully use this set of tools\nto build an z/OS system.  Much of the knowlege needed to build an\nIPL'able system from the ground up are embedded in the execs.\n\nYou do however need to have a fairly solid grounding in z/OS (MVS) in\norder to know what the various jobs and piece parts do, and how to get\npast inevitable glitches.  Liberal use of the IBM manuals will be of\nhelp.  Study the generated batch jobs to see all the steps involved\nin building a z/OS system from the scratch.\n\nDISCLAIMER: You alone are responsible for any success that you have with\nthis software tool, as well as any damage done to your system, losses\nincurred, etc.\n\nI would greatly appreciate any bug reports, and will answer questions\nvia email, time permitting.\n\nGood Luck, and remember to RTFM (Read The Fine Manuals)\n\n---------------------------------------------------------------------\n2.1 - Important Notes:\n---------------------------------------------------------------------\n\n            VERY, VERY, EXTRAORDINARILY IMPORTANT NOTES:\n      READ THESE NOW, OR BE TRULY AND PROFOUNDLY SORRY LATER:\n\n* Look at the generated jobs *before* running them, especially JOBA,\n  the first job.  It is *incredibly* easy to wipe out an existing\n  PRODUCTION disk volume with JOBA if you are not careful.  JOBA\n  automatically varies a volume offline, and runs ICKDSF to\n  initialize it.  You will need to reply to an MVS console prompt\n  when JOBA runs. BEFORE replying to this message to continue, DOUBLE\n  CHECK the unit address in the message, and be sure it's the disk\n  pack that you want to wipe clean and use to build your new z/OS\n  system.  Most of the remaining jobs are not as dangerous, but you\n  should still review the JCL, and understand what each job is doing.\n  (This is good for the soul anyway!)\n\n* I'm making the significant assumption that you basically know what\n  you're doing on MVS.\n\n  IN SHORT: If you don't know what a job is going to do, you have\n  absolutely no business running it.  First figure out what it's doing.\n\n\n                       IMPORTANT NOTES:\n            READ THESE NOW TO AVOID FRUSTRATION LATER\n\n* The good news, now that I've scared you into being careful, is that\n  these execs can take some of the drudgery, tedium, and trial and error\n  out of the process of building an zOS system from scratch.\n\n* zOS is not a turnkey system, and these clone execs are NOT, repeat\n  NOT completely automatic.  They are simply a tool that can be used to\n  greatly assist in building a cloned system.  However:  the parametersq\n  as delivered are what I used to build a fully functioning zOS system,\n  and so they may be pretty close to what you need, or at least a good\n  start!\n\n* Do take some time to carefully review the @PARMS and @DATASET members.\n  Don't rush through this part.  Expect to do some tweaking, and expect\n  to have to do several system builds before you get a system that IPLs\n  and works as expected.\n\n  Once you get the @PARMS and @DATASET members set up the way you\n  like, it's very easy to generate a fresh set of jobs, and then run\n  the jobs to build a new system.  You'll may even learn something\n  about zOS by studying the generated jobs.\n\n* RACF Authority:  See the $$$RACF member of this PDS for RACF\n  privileges that are required.\n\n* COMMAND and WAIT programs:  These programs enable the disk unit to be\n  varied online and offline by a batch job. If you want this capability\n  but don't have these programs on your system already, you can use the\n  source in the ZCLONE PDS to assemble them.  Assemble these modules to\n  a linklisted APF authorized library.\n\n  The COMMAND program is one that I pulled from the CBT tape.  I added\n  code to do a RACHECK against the COMMAND profile in the RACF APPL\n  class looking for at least READ access.  This prevents undesirable\n  miscreants and other unauthorized individuals from issuing MVS\n  commands using this program.\n\n  If you don't want to use the COMMAND and WAIT programs, code a null\n  value for COMMANDPGM and WAITPGM in the @PARMS member, or just take\n  these parms out altogether.  The JCL generated will then no longer use\n  these programs.\n\n---------------------------------------------------------------------\n2.2 - Steps to build a z/OS system with these execs\n---------------------------------------------------------------------\n\n1)  Edit the @DATASET member to include all the datasets needed to build\n    your new zOS system. A sample @DATASET member is provided as an\n    example of how to use the zClone execs.  This @DATASET member is the\n    one I used to create a zOS 1.8 two pack system.  Your mileage may\n    vary, and you will need to be sure that all needed datasets are\n    included.  The @DATASET member contains documentation on how to code\n    the various values.\n\n2)  Edit the @PARMS member with the values that you want.  The @PARMS\n    member is delivered with an example set of parms that were actually\n    used to successfully build a two pack rescue system. You will want\n    to change some of the parameters.  The @PARMS member contains\n    comments describing the various values.\n\n3)  Customize the $BUILD job:\n    - Make sure the jobcard is valid.\n    - Change the SYSPROC DD statement to point to the ZCLONE\n      distribution PDS.\n    - Change the INPDS parameter near the bottom of the JCL to likewise\n      reflect the ZCLONE distribution pds (i.e. the pds containing the\n      zClone execs).\n    - Change the OUTPDS parameter near the bottom of the JCL to reflect\n      the name of an empty PDS that you have allocated to contain the\n      JCL and other members generated by the zClone execs.\n\n4)  Now submit the job in $BUILD, and the necessary jobs and members\n    will now be built and stored into the output PDS that you specified\n    in the OUTPDS parameter in the $BUILD job. The jobs will be named\n    sequentially JOBA..JOBn, where n is however many jobs end up getting\n    generated.\n\n   *****************************************************************\n  *******************************************************************\n  *** NOTE: Up until this point, nothing has been been changed on ***\n  **  either the driving system or the new cloned system.  The     **\n  **  steps below this box will start tweaking and building.       **\n  **  If all goes as expected, the only changes made to the        **\n  **  driving system are:                                          **\n  **  a. The driving system mastercat will have an alias defined   **\n  **     pointing to the cloned system mastercat.                  **\n  **  b. The driving system mastercat will have the clone system   **\n  **     master catalog connected as a usercat.                    **\n  **  c. RACF Profile TSOZCLO in TSOPROC class will be defined.    **\n  **  d. RACF ID $ZCLONE and group $STC will be defined.           **\n  **                                                               **\n  **     THAT SHOULD BE IT.  ANYTHING ELSE WAS NOT INTENDED,       **\n  **     AND SHOULD BE DONE AT YOUR OWN RISK!!!                    **\n  **     (Did I mention that you should review each job            **\n  ***    before it is run?  Well, please do.)                     ***\n  *******************************************************************\n   *****************************************************************\n\n5)  Run all the jobs (JOBA - JOBx).  Again -- reviewing and\n    understanding the jobs *before* you run them would be, as they\n    say, \"a good thing.\"   It's possible that you could have coded\n    values in @PARMS and @DATASET such that the generated jobs could\n    damage your system -- so make sure each job does what you are\n    expecting.\n\n    Investigate any job steps that complete with return code 8 or\n    greater.  Return code 4 and 0 are fine.\n\n6)  You will need to fix the ATCCON and ATCSTR members of VTAMLST, and\n    also be sure that the necessary VTAMLST members are available on\n    your cloned system.  Use COPY statements in the @DATASET member to\n    specify members to copy.  You may want to code a special set of\n    trimmed down VTAM parms in a private PDS, and copy them into VTAMLST\n    and VTAMLIB using COPY statements.\n\n7)  Review PARMLIB.  SYS1.ZCLONE.PARMLIB is first in the PARMLIB concat,\n    followed by whatever other PARMLIBS are coded in @DATASET with the\n    'PARMLIB' attribute: ,,(PARMLIB).  Parmlib members are built for you\n    and copied to SYS1.ZCLONE.PARMLIB as follows:\n\n    BPXPRM00 - OMVS parmlib member that contains generated MOUNT stmts\n               for all OMVS libraries specified in the @DATASET member.\n    COUPLE00 - COUPLExx member generated to reflect couple datasets\n               defined in @DATASET.\n    IEASYS00 - Main parmlib member is copied from the zClone library\n               member ZIEASYS, and then updated with PAGE=, LOGREC=,\n               and SYSNAME= parameters.\n    IGDSMS00 - SMS parms built from ZIGDSMS and ACDS/COMMDS statements\n               built dynamically.\n    JES2PARM - JES2 parms. Member ZJES2PARM in the ZCLONE distribution\n               PDS is combined with dynamically built SPOOLDEF and\n               CKPTDEF statements, and then copied to the JES2PARM\n               member in SYS1.ZCLONE.PARMLIB.  Review ZJES2PRM for any\n               changes you want to make *before* building the ZCLONE\n               jobs.  The SPOOLDEF and CKPTDEF are already coded for\n               you, but you may want to change some of the other\n               parameters, or replace the entire ZJES2PRM member with\n               your own JES2 parms.  If you do this, be sure to remove\n               the SPOOLDEF and CKPTDEF statements from the source that\n               you place in ZJES2PARM, since these two statements are\n               coded for you automatically.\n\n    MSTJCL01 - Master JCL.  Includes all PROCLIBS coded in @DATASET with\n               the \"JES2\" attribute.\n    PROGA0   - APF authorized libraries (Coded in @DATASET with APF)\n    PROGL0   - Linklist libraries (Coded in @DATASET with LNK)\n    VATLST00 - A basic VATLST PARMLIB member is generated.\n\n    NOTE: You'll need to be sure that one of the PARMLIB's that you're\n    copying to the cloned system has the remainder of the members needed\n    as coded in SYS1.ZCLONE.PARMLIB(IEASYS00)'. Your production PARMLIB\n    dataset will probably work fine.\n\n8)  Review PROCLIB.  SYS1.ZCLONE.PROCLIB is first in the PROCLIB\n    concat, followed by whatever other PROCLIBs are coded in\n    @DATASET with the \"JES2\" attribute: ,,(JES2).  Started procedures\n    (PROCS) are built for you and copied to SYS1.cloned.PROCLIB as\n    follows:\n    TSO      - TSO started PROC.\n    VTAM     - VTAM started PROC.  Includes libraries in the VTAMLST and\n               VTAMLIB concatenation that you coded in @DATASET with the\n               'VTAMLST' and 'VTAMLIB' attribute respectively.\n    JES2     - JES2 Startup PROC.  Includes libraries in the PROC00\n               concatenation that you coded in @DATASET with the 'JES2'\n               attribute.\n    TSORES   - TSO LOGON PROC. The name of this LOGON PROC is set in the\n               @PARMS member with the \"TSOPROC = \" parameter.  This\n               dynamically generated PROC includes libraries defined in\n               @DATASET with attributes:  ISPPLIB, ISPMLIB, ISPSLIB,\n               ISPTLIB, ISPLLIB, SYSPROC, SYSUADS.\n\n9)  Review IPLPARM.  SYS1.IPLPARM on the cloned volume has member LOAD00\n    built from the parameters you specified.  PARMLIB statements are\n    included for libraries in the @DATASET member coded with the\n    'PARMLIB' attribute.\n\n   *****************************************************************\n  *******************************************************************\n  ***  If everything was defined right, you should now have an    ***\n  **   IPL'able z/OS system.  The steps below are some areas that  **\n  **   should be checked before trying to IPL.  You don't have to  **\n  **   do these things now, but you'll probably save yourself      **\n  ***  some IPLs if you do check them first.                      ***\n  *******************************************************************\n   *****************************************************************\n\n10) IPL the new system, and see what happens.  Hopefully you'll be close\n    to having a working system.  If it works the first time--you rock!\n\n\n---------------------------------------------------------------------\n3.0 - Parameters coded in the @PARMS member.\n---------------------------------------------------------------------\n\nThe @PARMS member of the ZCLONE distribution PDS is the heart of the\ndefinitions used to build the cloned system.  You can name this member\nwhatever you want, just be sure specify this member name in the PARMS()\nparameter in the $BUILD job.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nUser variables:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   You may find it useful to define your own variables.  Any variables\n   that you define in the @PARMS member can be subsequently used in the\n   @PARMS member, and in the @DATASET member.  Items like VOLSERs, and\n   dataset names or qualifiers can be defined and later referred to.\n\n   For example, you may want to add a qualifier to one or more datasets\n   to identify the system that you are building.  Let's say you are\n   planning to build several system images, each with a unique name.  To\n   simplify the process, you could define a variable called \"SYSTM\" and\n   give it a value.  e.g. in the @PARMS member, you would code:\n\n   SYSTM = CLONE01\n\n   and then in the @DATASET member you could then code such entries as:\n\n   DATASET ALLOC DSN(PAGE.&SYSTM.PLPA) -\n           VOLUME(&PAGVL1) SPACE(CYL,(200)) PARM(PGPLPA)\n\n   DATASET ALLOC DSN(PAGE.&SYSTM.LOCAL1) -\n           VOLUME(&PAGVL1) SPACE(CYL,(200)) PARM(PGPLPA)\n\n   Any variables that you define should:\n   - Start with an alpha character  (no special characters)\n   - NOT start with \"z\"\n   - Contain only characters and numbers.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nJobcard info:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   JOBCARD1 through JOBCARDn are used as the model Jobcard for all\n   generated jobs.  Each jobname is created by appending one character\n   onto the jobname that you code.  e.g.  using the jobcard example\n   below, the actual generated jobnames would be TSOJCMA, TSOJCMB, etc.\n\n   Whatever you code in the COMMENT parm will be added to the comments\n   in each job.  Comments are currently limited to what you can fit on\n   one line.\n\n   e.g.:\n\n   JOBCARD1   = //TSOJCM  JOB (990030,135,60,100),JMILLER,CLASS=A,\n   JOBCARD2   = //   NOTIFY=TSOJCM,MSGCLASS=X,REGION=6M\n   JOBCARD3   = /*JOBPARM LINES=999999\n   COMMENT    = John C. Miller\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n@DATASET:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n   @DATASET specifies the member name of the ZCLONE distribition PDS\n   that contains your dataset copy and allocation definitions.  If\n   omitted, this parm defaults to @DATASET.\n\n   e.g.:\n\n   @DATASET   = @DATATS1\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nUSESYM:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n   USESYM = YES means that indirect volume addressing will be used for\n   NONVSAM datasets. &SYSR2-&SYSRn will be defined, since &SYSR1 is\n   reserved, and already defined by z/OS.\n\n   Note:  Some datasets can be defined with indirect volsers, but should\n   not be defined this way because doing do will cause the IPL to fail,\n   e.g.  PARMLIBs, and PROCLIBS in Master JCL.  To prevent a specific\n   dataset from being cataloged with an indirect volser, code\n   PARM(NOSYM) on the DATASET COPY or ALLOC statement in the @DATASET\n   member.  This will cause that dataset to be cataloged with the actual\n   volser rather than a symbolic.\n\n   e.g.:\n\n   USESYM     = YES                    /* Use indirect volsers.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nVALIDPARMS:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  Set VALIDPARMS to NO if you want to bypass validation checking\n  for the @PARMS and @DATASET members.  This may be useful if you\n  are using the execs just to generate JCL for certain parts of the\n  system build process, and don't care about having an IPL'able\n  system.  If set to YES, the execs do some validity checking of\n  @PARMS and @DATASET values, check to see if source datasets\n  exist, and check to see that certain key system datasets have\n  been defined.\n\n  e.g.:\n\n  VALIDPARMS = YES                    /* Validate parms and datasets.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTSOPROC:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   This is optional.  If coded, the ZCLONE execs will construct a TSO\n   PROC by this name.  If coded, this TSO PROC should not exist on the\n   driving system.  The TSO PROC is built using datasets that you\n   defined in @DATASET as ISPF, SYSPROC, or SYSEXEC libraries.\n\n   If you already have a TSOPROC that you know will work,\n   then you can leave the TSOPROC value blank.\n\n   e.g.:\n\n   TSOPROC    = TSO911                  /* TSOPROC to be built.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTSOPROC:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Define TSO userids that you want on the new system.  As many TSO ids\n   as desired can be specified here.  If the system you are cloning\n   already has all the TSO USERIDS that you need, then you can leave\n   TSOIDx blank.\n\n   e.g.:\n   TSOID1     = TSO001\n   TSOID2     = TSO002\n   TSOID3     = TSOTST\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDEVTYPE:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Defines the device type of the DASD that will contain the new\n   system.  This applies to all target volumes.\n\n   e.g.:\n\n   DEVTYPE    = 3390                  /* Device type of target volumes.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nVOLSERx  and ADDRx:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Define the VOLSERs of that will contain the new system.  You must\n   specify at least VOLSER1 and ADDR1.  You can specify up to 99\n   VOLSERx/ADDRx pairs for up to 99 target volumes.  Each VOLSERx coded\n   must have a correspoding ADDRx parm coded, and vice-versa.\n\n   e.g.:\n   VOLSER1    = Z8RES1\n   VOLSER2    = Z8RES2\n   ADDR1      = 5001\n   ADDR2      = 5002\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOptional volume aliases:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Optional volume aliases.  This is an example of using user\n   defined variables.  This allows us to use logical volume names\n   as the target for datasets, rather than the actual volser.  For\n   example, below we are defining CATVOL, JUNKVOL, and USERVOL as\n   logical names all pointing to one actual volser.  In the\n   @DATASET member, we can then specify VOL(&CATVOL) for example,\n   to refer this volser, instead of hard-coding the volser.  This\n   allows us to logically group datasets without tying them\n   directly to volsers.  At some point we might want to change\n   which volume the datasets go to that are defined with\n   VOL(&CATVOL).  We can do this my changing one parm here,\n   instead of potentially many parms in the @DATASET member.  Of\n   course, you can avoid all this, and just code VOL(&VOLSERn) in\n   the @DATASET member if you want to keep it simple.\n\n   e.g.:\n\n   SYSR1      = &VOLSER1                /* Volume alias.\n   SYSR2      = &VOLSER2                /* Volume alias.\n   HFSVOL     = &VOLSER2                /* Volume alias.\n   CATVOL     = &VOLSER3                /* Volume alias.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nWORKVOL:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Work space for building the new system.  Not needed if you have\n   plenty of PUBLIC mounted disk.  No data is permanently left on this\n   volume.\n\n   e.g.:\n\n   WORKVOL    = Z18T01                  /* Volser for large work files.\n\n*-------------------------------------------------------------------*\n* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *\n* IOCONFIG ID in the IODF dataset that you specify.  This value is  *\n* inserted in the SYS1.IPLPARM(LOADxx) member.                      *\n* SMFID is the new SMF id to be assigned to the new system.         *\n*-------------------------------------------------------------------*\n IOCONFIGID = UCRPROD                 /* 8 char IO config ID for LOADxx\n SMFID      = UCRP                    /* 4 char SMF id for new system.\n\n*-------------------------------------------------------------------*\n* OLDMCAT - Old master catalog name (mastercat of driving system)   *\n*-------------------------------------------------------------------*\n OLDMCAT    = CATALOG.Z18T.MASTER     /* Driving sys master cat.\n\n*-------------------------------------------------------------------*\n* New catalogs: New mastercat and optionally a new usercatalog.     *\n* Both the master catalog and the user catalog can have an SSA      *\n* specified for them.  The SSA is a prefix that is pre-pended to    *\n* each dataset name.  This does two things:  1) It provides an easy *\n* way to force dataset entries to be cataloged in the desired cat,  *\n* and 2) it prevents ENQ issues with allocated datasets on the      *\n* driving system.  Datasets are renamed back to the desired names   *\n* (Without the SSA on front) as part of the system build process.   *\n*-------------------------------------------------------------------*\n NEWMCAT    = CATALOG.MST18P          /* New sys. mastercat name.\n NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.\n SSA        = SYSZC.                  /* Temp. dsn prefix.\n\n NEWUCAT    = CATALOG.SYS18P          /* New sys. usercat name.\n NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.\n SSAU       = SYSUC.                  /* Temp DSN prefix.\n UCATALIAS1 = SMS\n\n SYSRES     = Z18RS1                  /* Driving sys sysres volume.\n COMMANDPGM = COMMAND                 /* \"COMMAND\" pgm is available.\n WAITPGM    = WAIT                    /* \"WAIT\" pgm is available.\n\n*-------------------------------------------------------------------*\n* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *\n* ZJES2PRM member to create a final JES2PARM member.  You must      *\n* define a SPOOL and at least one CKPT dataset in the @DATASET      *\n* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *\n* and the spool dataset should have the parm HASPACE.               *\n* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *\n* set to 4, for example, and the volser where the spool dataset is  *\n* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *\n*-------------------------------------------------------------------*\n SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.\n\n*-------------------------------------------------------------------*\n* RACF Parms.                                                       *\n* Note: Some of the RACF actions require RACF SPECIAL to perform.   *\n* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *\n* the resulting jobs will need RACF SPECIAL, or specific privileges *\n* for various RACF operations (CLAUTH, etc.)                        *\n*-------------------------------------------------------------------*\n*-------------------------------------------------------------------*\n* RFSTCx: Defines STCs for ICHRIN03 started task table.             *\n* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *\n* Each task defined will have privileged bit set on, so these tasks *\n* should be able to bypass most RACF Access checking.  Commands     *\n* for creating the specified IDs and Groups will be generated only  *\n* if the IDs/groups DO NOT already exist.                           *\n*-------------------------------------------------------------------*\n RFDSNT     = NO                      /* Create RACF ICHRDSNT\n RFSTC      = NO                      /* Create RACF ICHRIN03\n RFTSOPROC  = NO                      /* Define TSOPROC to TSOPROC class\n\nStarted task support:\n  If entries are defined below, then an ICHRIN03 module will be built\n  with these entries.  An MLPA entry for this ICHRIN03 will be placed\n  in IEALPA00.  Format of RFSTCx is:  RFSTCx = stcname, racfid,\n  racfgrp All three parms are required.  This option may be most\n  useful when building a single pack rescue system.  You may want to\n  comment out or delete these statements if the profiles in your RACF\n  STARTED class or in your existing ICHRIN03 module are sufficient for\n  your needs.\n\n*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n\nSYSPLEX     = UCRP     /* Name of this sysplex\n\n---------------------------------------------------------------------\n4.0 - Parameters coded in the @@DATASET member.\n---------------------------------------------------------------------\n\nThe @DATASET member refers to the member containing the dataset\ndefinitions for the system being clones.  The actual member name\nis determined by the \"@DATASET = \" parm in the @PARMS member, or\nwhatever parms member you are using.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n4.1 - DATASET:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nThe DATASET verb defines a dataset to be copied to the new system,\nor a dataset to be allocated only for the new system.\n\nDATASET COPY  parameters - Copy a dataset using parameters.\n\nDATASET ALLOC parameters - Allocate a new dataset using parameters.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n4.1.1 - Value for PARM() on DATASET Statements:\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n   HASPACE  - The dataset is a JES2 spool dataset, and is defined in\n              JES2PARMS in the SPOOLDEF statement.\n\n   HASPCKPT - The dataset is a JES2 checkpoint dataset, and is specified\n              in JES2PARMS.\n\n   SYSUADS  - The dataset is the UADS dataset, and a SYNC operation is\n              done on this dataset.\n\n   SYSLBC   - The dataset is the BRODCAST dataset and is initialized.\n\n   ISPPLIB  - ISPF panel lib to be added to ISPPLIB concat in the\n              TSOPROC created (if any) for the new system.\n\n   ISPMLIB  - ISPF panel lib to be added to ISPMLIB concat in the\n              TSOPROC created (if any) for the new system.\n\n   ISPSLIB  - ISPF panel lib to be added to ISPSLIB concat in the\n              TSOPROC created (if any) for the new system.\n\n   ISPTLIB  - ISPF panel lib to be added to ISPTLIB concat in the\n              TSOPROC created (if any) for the new system.\n\n   SYSPROC  - ISPF panel lib to be added to SYSPROC concat in the\n              TSOPROC created (if any) for the new system.\n\n   VTAMLST  - Lib to be included in VTAMLST concatention in the VTAM\n              started procedure.\n\n   VTAMLIB  - Lib to be included in VTAMLIB concatention in the VTAM\n              started procedure.\n\n   APF      - Load lib to be APF authorized.\n\n   LNK      - Load lib to be added to LNKLSTxx.\n\n   LPA      - Load lib to be added to LPALSTxx.\n\n   ACDS     - Dataset is the SMS ACDS.\n\n   COMMDS   - Dataset is the SMS COMMDS.\n\n- RLSE      Space should be released after copy.\n- SMF       MANx VSAM file tb formatted as SMF dataset.\n\nThe following should be coded once and only once, and are used\nby the ZCLONE execs to build various system components.\n- ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.\n- ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.\n- ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.\n- ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n4.1.1 - DATASET ALLOC Statement\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n   Example:\n\n   DATASET ALLOC DSN(SYS1.PRD99.MACLIB) MODEL(SYS1.MACLIB) -\n      SPACE(CYL,(100,,75))\n\n   Parameters:\n   -----------\n\n   DSN(datatsetname)\n\n      Name of dataset being cloned.  For DATASET ALLOC operations,\n      DSN defines the name of the dataset on the new system.\n\n   MODEL(modeldsn)\n\n      Creates the new dataset with the same DCB parameters as the\n      specified model dataset.\n\n   VOL(volser)\n\n      A literal value can be specified for volser, but it is recommended\n      that you use variables for volser.  You can either specify VOLSERn\n      or some other user variable that resolves to a valid volser.\n\n   SPACE(spaceparms)\n\n      Only used for DATASET ALLOC operations.  Code the spaceparms value\n      the same way you would code SPACE=() on a JCL card.\n\n      e.g.:\n\n      SPACE(CYL,(150))\n\n   PARM(usageparms)\n\n      Usage parameters for this dataset.  The values specified in\n      PARM() determine what additional processing is done for the\n      dataset.  See the section below on DATASET PARMS\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n4.2 - MEMCOPY Statement\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThe MEMCOPY verb allows you to specify a member that you want copied\nfrom one PDS to another, optionally with a new name.  The parameters\naccepted on the MEMCOPY statement are:\n\n- IN:   The input PDS, where the desired member resides.  This can be\n        any of the following:\n        - A static member that you create in your own PDS;\n        - The ZCLONE main exec PDS--for this code: IN(&IPDS)\n        - The ZCLONE output PDS where certain dynamic members are built,\n          in which case you would code: IN(&OPDS)\n\n        The actual dataset name can be partly or wholly made up of\n        symbolic variables, as the zClone execs do a basic level of\n        symbolic substitution for you.  For example, let's say you have\n        a PARMLIB member from a running system that you want to copy\n        to the new system you are building.  if you code the following\n        statement in the @PARMS member:\n\n        SYSNAM = RESC01\n\n        Then you might use the &SYSNAM variable in defining dataset\n        names in the IN and OUT parms of MEMCOPY, like this:\n\n        MEMCOPY IN(SYS1.&SYSNAM.PARMLIB) OUT(SYS1.PARMLIB) M(LNKLST00)        00\n\n        You can use any symbolic variables defined in the @PARMS\n        member.\n\n- OUT:  The output PDS where the member will be copied.  The same\n        principles for the IN parm apply to the OUT parm.\n\n./ ADD NAME=$$$BUGS\n- The syntax checking of the @DATASET member is not very robust.  So if\n  for example you leave an extra continuation character on the end of a\n  DATASET statement, you'll get a generic IKJ error message on the PARSE\n  statement, which is not very helpful.  If this happens you will need\n  to scan the @DATASET member manually, and look for stuff like that.\n  This is the main typo sort of error that I've found to be a problem.\n  Improved syntax checking is on the drawing board but don't hold your\n  breath.\n\n./ ADD NAME=$$$IDX   0100-10057-10057-1930-00053-00053-00000-COMPJM\nIndex of members:\n\nMembers starting with \"#\" are rexx subroutines.\nMembers starting with \"Z\" model members used by the ZCLONE execs.\n\"Z\" members may need some modification based on local requirements.\nMembers starting with \"@\" are input parms that you need to code.\n\n$$$DOC   - The documentation for the ZCLONE execs, such as it is.\n$$$IDX   - This member.\n$$$MISC  - Miscellaneous explanations, etc.\n$$$QUIK  - Quickstart for the impatient - Better know what you're doin.\n$$$RACF  - Info on RACF authority that you'll need to run the jobs.\n$$$SARES - Info on building standalone restore tapes.  Helpful.\n$BUILD   - Batch job to run ZCLONE system build.\n$CATCLSE - Commands to unallocate and close ICF catalogs.\n$SAREST  - Job to build a standalone RESCUE system restore tape.\n#ALCNVSM - Build JCL to allocate nonVSAM datasets.\n#ALTNVSM - Build JCL to remove System Secific Alias (SSA) (i.e. SYSX.)\n#COPYDS  - Build JCL to copy datasets.\n#COPYMEM - Build JCL to copy members specified in @DATASET member.\n#DEFMCAT - Build JCL to define the master catalog.\n#DEFNVSM - Build JCL to define nonVSAM catalog entries.\n#DEFVSAM - Build JCL to define VSAM files: STGINDEX, PAGE, SMF, etc.\n#INITVOL - Build JCL to ICKDSF init the cloned sysres volume.\n#MEMBERS - Build assorted members, and store them in this PDS.\n#RFCOPY  - Build JCL to copy the RACF dataset.\n@DATASET - Place where all the target system datasets are defined.\n@PARMS   - Main setup member that defines how system will be built.\nCOMMAND  - \"COMMAND\" src - Issues MVS console commands, RACF secured.\nZCLONE   - The main exec that is run to build all the JCL and members.\nWAIT     - \"WAIT\" assembler source.  Optional but may be helpful.\nZBPXPRM  - OMVS PARMLIB member.  MOUNT statments are added to this mem.\nZCOUPLE  - XCF parmlib member.  Set to sysplex local, change if desired.\nZIEALPA  - IEALPA00 PARMLIB member source.  Updated by execs.\nZIEASYS  - IEASYS00 PARMLIB member.\nZJES2PRM - Partial JES2PARM member.  Modify if desired.\nZJOBNUM  - Work member - Last job number used.  Leave this alone.\n\nMembers that get built and stored in the output PDS (OUTPDS in $BUILD)\nwhen the ZCLONE exec is run:\n\nBPXPRM00 - OMVS parms.\nCOUPLE00 - XCF parms.\nIGDSMS00 - SMS parms.\nJES2     - JES2 started procedure.\nJES2PARM - JES2 parameter deck.\nJOBn     - Jobs that do the actual build of the cloned system.\nLOAD00   - IPLPARM LOAD00 member.\nMSTJCL01 - Master JCL PARMLIB member.\nPROGA0   - PROG PARMLIB member with APF statements.\nPROGL0   - PROG PARMLIB member with LNKLST statements.\nTSORESC  - TSO LOGON procedure.\nVTAM     - VTAM started procedure.\n./ ADD NAME=$$$MISC  0100-10057-10057-1916-00078-00078-00000-COMPJM\n---------------------------------------------------------------------\nZCLONE System Execs - Notes, explanations, etc.\n---------------------------------------------------------------------\n\n---------------------------------------------------------------------\nSSA\n---------------------------------------------------------------------\nExplanation:\nSystem Specific Aliases is a technique that has been used for many\nmoons by the IBM MVS software delivery groups.  An alias is defined in\nthe driving system master catalog that points to the new system\nmastercat.  Any dataset names that might conflict with live datasets\nare defined with an extra prefix (the \"SSA\") not found on the driving\nsystem.  This accomplishes 2 desirable outcomes:\n\n1) All catalog entries for cloned system datasets are created in the\ncloned system master catalog, where we want them. This avoids junk in\nthe driving system master catalog or user catalogs.\n\n2) Cloned system datasets remain cataloged to the driving system until\nthe jobs are done manipulating them. This approach avoids the use of\nSTEPCAT DD statements, which as of z/OS 1.7 no longer work.\n\n---------------------------------------------------------------------\nXCF\n---------------------------------------------------------------------\nFor the sake of simplicity and stand-alone-ness, the cloned system\ngets built configured for sysplex-local. If I get ambitious I may\nadd support at some point for building parallel sysplex images.\n\n---------------------------------------------------------------------\nRACF Started Task Table\n---------------------------------------------------------------------\nExplanation:  I use a RACF started task module ICHRIN03 instead of\nusing profiles in the RACF STARTED class, which would be much\nmore cool.  I take this approach to minimize changes to the driving\nsystem.\n\n1) The RACF DS on the cloned system is a copy of the one on the driving\n   system.  Therefore, before copying the RACFDS from the driving\n   system, any needed RACF tweaking has to be done to the driving\n   system's RACF environment. I prefer to minimize any changes to the\n   driving systems RACF environment.  I basically add a RACF ID and a\n   RACF group, and don't activate any classes, etc.  You just need to\n   pick a USERID and GROUP name that don't already exist.  If you pick\n   a USERID or GROUP that do already exist on the driving system, the\n   generated jobs will contain whining messages to this effect.\n\n2) Messing with the STARTED class on the driving system (Which you may\n   or may not even be using) can have some unexpected and unpleasant\n   consequences, and may result in the driving system becoming\n   non-IPLable.  I prefer to not go there.\n\n---------------------------------------------------------------------\nTCP/IP\n---------------------------------------------------------------------\nTCP/IP will probably need some work by you before you can telnet in\nand log on to your new cloned system.\n\nThe ZCLONE execs handle some of the required TCP/IP setup like the\nstarted task table entry for TCPIP, a RACF ID defined with a UID0 OMVS\nsegment, OMVS datasets being defined in the BPXPRM00 parmlib member,\nand maybe some other stuff that I've programmed in but forgotten.\n\nYou'll need to be sure that the necessary PROCS and parameteter\nmembers are set up right for your shop.  This is a non-trivial task,\nand I have not yet risen to the task of completely automating this part.\nIt should be a fairly simple task to copy over these elements as-is from\nyour production system, and make a few changes for things like the IP\naddress and domain name, and the hardware interface.\n\n---------------------------------------------------------------------\nMSTJCL01\n---------------------------------------------------------------------\nI name the master JCL member with the \"01\" suffix to prevent the master\nscheduler from starting using any master JCL that might be laying about\nin SYS1.LINKLIB(MSTJCL00) This way I can be reasonably sure that my\nmaster JCL member is the one used.\n./ ADD NAME=$$$QUIK\n---------------------------------------------------------------------\nZCLONE System Execs - Quick Start\n---------------------------------------------------------------------\nOk, so you're like me -- impatient, and don't want to read through all\nthe dumb comments, disclaimers, etc.  Here's the $.50 version of how to\nuse the ZCLONE execs to build a one-pack RESCUE system.\n\n1)  You should have the zClone execs in one PDS.  Create a second empty\n    PDS (LRECL=80, BLKSIZE=whatever) to contain the generated JCL.  The\n    PDS containing the zClone execs needs to be coded in the $BUILD\n    member on the INPDS paramter, and the empty output PDS that you\n    created should be specified in $BUILD in the OUTPDS parameter.\n\n2)  Edit the @DATASET member to include all the datasets needed to build\n    your system.  The @DATASET member is delivered with the exact\n    configuration of datasets that I used to create a z/OS 1.8 one pack\n    rescue system.  Your mileage may vary, and you will need to be sure\n    that all needed datasets are included.\n\n3)  Edit the @PARMS member with the values that you want.  The @PARMS\n    member is delivered with an example set of parms that were actually\n    used to successfully build a one pack z/OS 1.8 system. You will\n    need to change a lot of these values, especially the ones that\n    describe your driving system.\n\n4)  Use the $BUILD job to run the ZCLONE build execs under batch TSO.\n    Fix the jobcard and PDS name (SYSPROC DD stmt) first.\n\n5)  Run all the jobs (JOBA - JOBx).  Again, reviewing and understanding\n    the jobs before you run them would be, as they say, \"good.\"\n    Investigate any steps that are return code 8 or greater.\n\n    If you're really hot, you'll have an IPL'able system on the first\n    try.  If you're like me, then you'll need a few iterations to get\n    it right, to fix such things as:\n\n    a. VTAMLST members that reflect your local config.  Tweak the\n    @DATASET member to auto copy members like these over.\n\n    b. Assorted PARMLIB members missing.\n    c. Some off the wall LINKLIB that was missed somehow.\n    d. You name it.\n\n    Have Fun!\n./ ADD NAME=$$$RACF\n---------------------------------------------------------------------\nACF2\n---------------------------------------------------------------------\nIf your system uses ACF2, then you will need to make some adaptations,\nmainly to the jobs for replicating the ACF2 database, and the security\ncommands used to set up the TSO userids.\n\n---------------------------------------------------------------------\nRACF Started Task Table versus STARTED class.\n---------------------------------------------------------------------\nThe ZCLONE execs as shipped create a basic ICHRIN03 started task table\nmodule that will be sufficient to IPL the new system.  This approach is\ntaken because it requires fewer changes to the RACF dataset on the\ndriving system.  Once the new system is up, you can adjust the profiles\nin the STARTED class, and get rid of the ICHRIN03 module.\n\nIf you prefer, you can copy your own custom ICHRIN03 module from an\nexisting linklib to the new system's SYS1.LINKLIB by changing the\nMEMCOPY statement in the @DATASET member that copies ICHRIN03.\n\n---------------------------------------------------------------------\nRACF authority needed:\n---------------------------------------------------------------------\nBelow are some requirements for RACF authority that you'll need\nto run the jobs generated by the ZCLONE execs.  You don't need\nthese permissions to runs the execs which generate the JCL and\nother members for the cloned system, but you will need them to actually\nrun some of the jobs.\n\n---------------------------------------------------------------------\nRACF privileges needed:\n---------------------------------------------------------------------\nRACF SPECIAL is needed to run the IRRUT400 job, which locks the\nproduction RACF dataset, and creates a copy.  If your ID does not have\nthe RACF SPECIAL attribute, extra warning notes will be included in the\njobs that are generated, indicating that RACF SPECIAL is needed to run\nthose jobs.\n\n---------------------------------------------------------------------\nRACF Facility profiles to which you will need at least ALTER access:\n---------------------------------------------------------------------\nSTGADMIN.ADR.COPY.BYPASSACS\nSTGADMIN.ADR.COPY.PROCESS.SYS\nSTGADMIN.ADR.DUMP.TOLERATE.ENQF\nSTGADMIN.ADR.RESTORE.BYPASSACS\nSTGADMIN.ADR.RESTORE.TOLERATE.ENQF\n\nYou may want to define a generic FACILITY profile such as would be\ndefined by the commands below, and getting ALTER access to it.\n\n   RDEFINE FACILITY STGADMIN.ADR.** UACC(NONE)\n   PERMIT  STGADMIN.ADR.** CLASS(FACILITY) ID(yourid) ACCESS(ALTER)\n   SETROPTS RACLIST(FACILITY) REFRESH\n./ ADD NAME=$$$SARES\n------------------------------------------------------------------*\nStandalone Rescue Tapes ($SAREST)\n------------------------------------------------------------------*\nA rescue z/OS system can be a lifesaver.  The $SAREST job creates\nan IPL tape that allows you to restore a z/OS rescue system for\ndisaster recovery purposes.\n\nRun this job after you have a working RESCUE system built, and to\nwhich you can log on to TSO and do useful tasks.  It will create a\nset of tapes that you can use if you ever get completely hosed--i.e.\nyour system is flat on its back, and you have no system that you can\nbring up to make repairs. I have been in this very situation, and I\ncan tell you that it is *immensely* satisfying to be able to resort\nto the procedure described herein, and pull a rabbit out of a hat,\nso to speak.\n\nI suggest that you call the tapes created by this job RESCU1 -\nRESCUn, and put a stick on label on each tape with the volser\nwritten on it.  Since these tapes are non-labelled, the system\nwill not keep them straight for you!\n\nAnother very important suggestion: Before creating these tapes,\nchange the RACF password for the TSO ID you will be using to some\nnew value, and PHYSICALLY WRITE THIS DOWN on the first of the\ntapes.  The RACF password that you were using when you created\nthe RESCUE system dump tapes will likely be long forgotten by the\ntime you get around to using them.  If you can't log on to TSO,\nyour RESCUE system will be worthless.  Some sysprogs will copy\nthe production RACF dataset to their RESCUE packs as part of a\nweekly maintenance job.  DON'T DO THIS!  If your RACF dataset\nhappens to get damaged, then your RESCUE system gets damaged too.\nGet the RESCUE system up and working, and then leave it alone.\nIt should not be touched unless you really need to, such as if\nthe IO configuration changes, and you need to update the IODF\nfile to reflect the new devices.\n\n------------------------------------------------------------------*\nExample of using the stand alone RESCUE restore tape:\n------------------------------------------------------------------*\nYou would only use this in the event that you could not IPL a\nworkable z/OS system, and had to restore the rescue system. If you\nhave a working z/OS system, you can log on and do a normal DFDSS\nbatch RESTORE job using these tapes.  (In this example, the disk\ndrive is unit 120, the tape is 380)\n------------------------------------------------------------------*\n 1) Mount the first tape written on the tape drive 380.\n 2) At the HMC set the IPL address to 380.  If you don't have an\n    HMC, then set the IPL address according to your particular CPU.\n 3) Perform an IPL (LOAD CLEAR)\n    If IPLing from a VM Virtual Machine, use the CP command: IPL 380\n 4) From any attached local terminal hit the Enter key. You should be\n    prompted to hit CLEAR when the program is ready to go. Do so.\n 5) Specify CONSOLE for the input device.\n 6) Specify CONSOLE for the output device.\n 7) Enter the restore command:\n       RESTORE FROMDEV(3400) FROMADDR(380) TOADDR(120) NOVFY\n 8) Reply Y when prompted to restore the volume.  Make sure it's the\n    right disk unit, or you may destroy some live data.\n 9) Keep mounting tapes until they have all been read.\n10) Change the IPL address to 120, and IPL again. You're (hopefully) up.\n11) Log on to TSO, and save the day.\n\nNote: If the RESCUE pack was built on a different system from the one\non which it is being restored, then you may need to make certain changes\nto the restored system before it is IPLable:\n- IODF devices definitions and NIPCONS definitions\n- SYS1.PARMLIB(CONSOLxx)\n- SYS1.VTAMLST local VTAM terminal definitions.\n- SYS1.IPLPARM(LOADxx) system name must match and IODF system name.\nIdeally these items should be addressed before the RESCUE system is\ndumped to tape.  Otherwise the system will be unusable until the above\nitems are fixed.\n\nOR - If you are really in a bind, (and you are running a zSeries box\nwith ICC) and you know the IODF on the RESCUE system doesn't match the\nIOCDS of the processor, and the VTAMLST and CONSOLxx members won't work,\nyou are in for a bit of hassle, but you can still use a RESCUE system:\n\n- From the Service Element create a bare bones IOCDS that includes the\n  addresses for all the connected DASD that you care about, and also\n  the addresses for any MVS consoles and VTAM terminals you plan to use\n  on the RESCUE system.  POR with this IOCDS.\n- Modify some of the ICC definitions to match your CONSOLxx and VTAMLST\n  local terminal addresses.\n- Now IPL your RESCUE system and save the day.\n\n./ ADD NAME=$BUILD   0100-10057-10057-1925-00027-00027-00000-COMPJM\n//COMPJMX JOB (990030,135,60,100),JMILLER,CLASS=A,\n//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M\n/*JOBPARM LINES=90000\n//*---------------------------------------------------------------*\n//* Execute TSO in batch to run ZCLONE execs.                     *\n//* Make sure you are not editing the ZCLONE input pds, and that  *\n//* you don't have it allocated in any other way.                 *\n//*---------------------------------------------------------------*\n//* The SYSPROC DD statment should be changed to the name of the  *\n//* PDS containing the ZCLONE execs and members.  The INPDS       *\n//* parameter should also be set to the same ZCLONE PDS.          *\n//*---------------------------------------------------------------*\n//* OUTPDS should be est to indicate an empty PDS where generated *\n//* JCL and parameter members can be stored.                      *\n//*---------------------------------------------------------------*\n//* 10/11/2009 John C. Miller.                                    *\n//*---------------------------------------------------------------*\n//TSO      EXEC PGM=IKJEFT01,REGION=4M\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS\n//SYSTSIN  DD *\n %ZCLONE  INPDS(COMPJM.ZCLONE) +     <-- Change to ZCLONE PDS name\n          OUTPDS(COMPJM.CJOBS) +     <-- Change to name of empty PDS\n          PARMS(@PARMS)              <-- Change to you parm member\n/*\n./ ADD NAME=$BUILD2  0100-10057-10057-1926-00026-00026-00000-COMPJM\n//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=64M\n/*JOBPARM LINES=90000\n//*---------------------------------------------------------------*\n//* Execute TSO in batch to run ZCLONE execs.                     *\n//* Make sure you are not editing the ZCLONE input pds, and that  *\n//* you don't have it allocated in any other way.                 *\n//*---------------------------------------------------------------*\n//* The SYSPROC DD statment should be changed to the name of the  *\n//* PDS containing the ZCLONE execs and members.  The INPDS       *\n//* parameter should also be set to the same ZCLONE PDS.          *\n//*---------------------------------------------------------------*\n//* OUTPDS should be est to indicate an empty PDS where generated *\n//* JCL and parameter members can be stored.                      *\n//*---------------------------------------------------------------*\n//* 10/11/2009 John C. Miller.                                    *\n//*---------------------------------------------------------------*\n//TSO      EXEC PGM=IKJEFT01,REGION=4M\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS\n//SYSTSIN  DD *\n %ZCLONE  INPDS(COMPJM.ZCLONE)  +    <-- Change to ZCLONE PDS name\n          OUTPDS(COMPJM.CJOBS2) +    <-- Change to name of empty PDS\n          PARMS(@PARMS2)             <-- Change to you parm member\n/*\n./ ADD NAME=$BUILD3  0101-10016-10057-1927-00026-00021-00000-COMPJM\n//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=64M\n/*JOBPARM LINES=90000\n//*---------------------------------------------------------------*\n//* Execute TSO in batch to run ZCLONE execs.                     *\n//* Make sure you are not editing the ZCLONE input pds, and that  *\n//* you don't have it allocated in any other way.                 *\n//*---------------------------------------------------------------*\n//* The SYSPROC DD statment should be changed to the name of the  *\n//* PDS containing the ZCLONE execs and members.  The INPDS       *\n//* parameter should also be set to the same ZCLONE PDS.          *\n//*---------------------------------------------------------------*\n//* OUTPDS should be est to indicate an empty PDS where generated *\n//* JCL and parameter members can be stored.                      *\n//*---------------------------------------------------------------*\n//* 10/11/2009 John C. Miller.                                    *\n//*---------------------------------------------------------------*\n//TSO      EXEC PGM=IKJEFT01,REGION=4M\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=COMPJM.ZCLONE  <-- Change to ZCLONE PDS\n//SYSTSIN  DD *\n %ZCLONE  INPDS(COMPJM.ZCLONE)  +    <-- Change to ZCLONE PDS name\n          OUTPDS(COMPJM.CJOBS3) +    <-- Change to name of empty PDS\n          PARMS(@PARMS3)             <-- Change to you parm member\n/*\n./ ADD NAME=$CATCLSE 0100-10057-10057-1935-00012-00012-00000-COMPJM\n/*$VS,'F CATALOG,CLOSE(CATALOG.MASTER)'\n/*$VS,'F CATALOG,UNALLOCATE(CATALOG.MAST18)'\n/*$VS,'F CATALOG,CLOSE(CATALOG.SYST18)'\n/*$VS,'F CATALOG,UNALLOCATE(CATALOG.SYST18)'\n//COMPJMA JOB (0),JMILLER,CLASS=A,NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M\n//*---------------------------------------------------------------\n//* Use these commands to unallocate and close the master and user\n//* catalogs of the newly generated system.  You may need to do this\n//* if you need to start the system build process over, to enable the\n//* volumes containing your catalogs to come offline.\n//*---------------------------------------------------------------\n// EXEC PGM=IEFBR14\n./ ADD NAME=$SAREST\n//AOSGJCMA JOB (0),JMILLER,MSGCLASS=X,CLASS=A,NOTIFY=&SYSUID,REGION=6M\n//*------------------------------------------------------------------*\n//* $SAREST - Build an IPL'able, stand alone restore tape for the\n//* RESCUE system.  This job assumes that your rescue IPL volume\n//* is labelled \"RECUE\".  If your RESCUE system includes more than\n//* a single volume, then repeat this jobstream substituting the\n//* volser for any other volumes that you want to standalone restore.\n//*------------------------------------------------------------------*\n//* IMPORTANT: See member $$$SARES notes and discussion.\n//*------------------------------------------------------------------*\n//* 03/28/1997 John C. Miller\n//*------------------------------------------------------------------*\n//*************************************************\n//* Write standalone DFDSS image in file 1        *\n//*************************************************\n//SADSS   EXEC PGM=ADRDSSU,PARM='UTILMSG=YES'\n//SAMODS    DD DSN=SYS1.SADRYLIB,DISP=SHR\n//TAPE      DD UNIT=CART,DISP=(NEW,PASS),\n//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),\n//          LABEL=(1,NL,EXPDT=98000),\n//          VOL=(,RETAIN,SER=RESCU1)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n   BUILDSA -\n       INDD(SAMODS) -\n       OUTDD(TAPE)  -\n       ADMINISTRATOR -\n       IPL(CARD) -\n       OPERCNSL(001F)\n//*************************************************\n//* Write volume dump image in file 2             *\n//*************************************************\n//DUMP     EXEC PGM=ADRDSSU,REGION=4M\n//SYSPRINT  DD SYSOUT=*\n//TAPE      DD UNIT=CART,DISP=(NEW,PASS),\n//          LABEL=(2,NL,EXPDT=98000),\n//          VOL=REF=*.SADSS.TAPE\n//SYSIN     DD *\n  DUMP INDYNAM(RESCUE) OUTDD(TAPE)\n./ ADD NAME=#ALCNVSM\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #ALCNVSM - Allocate NONVSAM files.                      */\n/*                                                         */\n/* Processes entries in @DATASET member, ignoring those    */\n/* datasets with operation types of \"D\" and \"H\", which are */\n/* datasets that will be copied using DFDSS, and hence do  */\n/* not need to be pre-allocated.                           */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Allocate nonVSAM datasets.                         */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Allocate NONVSAM datasets.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"ALLOCNVS - Allocate nonVSAM datasets.                \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFNVSAM EXEC  PGM=IEFBR14\"\n\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\n/* Loop through DS. stem var and punch alloc dd statements.*/\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\nDO ###yy = 1 TO DS.0\n   zzEXCEPTIONS = \"SMF STGINDEX PGPLPA PGCOMMON PGLOCAL XCF LOGR WLM\"\n   zbEXC = hasParms(zzEXCEPTIONS,DS.###yy.PARM)\n   IF zbEXC THEN ITERATE\n   /*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\n   /* If ALLOC option then punch alloc DD statements.      */\n   /*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\n   IF DS.###yy.verb = \"DATASET\" & DS.###yy.option = \"ALLOC\" THEN DO\n      IF POS(\"SMF\",DS.###yy.PARM) > 0 THEN ITERATE\n      call allocdn\n   END\nEND\ncall clsout opds,'JOB'jobnum\nRETURN\n\nallocdn:\nIF SYMBOL(\"DS.\"###yy\".NEWNAME\") = \"VAR\" THEN tgtdsn = DS.###yy.NEWNAME\nELSE                                         tgtdsn = DS.###yy.DSN\nvolser = DS.###yy.VOL\nddname = LEFT(llq(tgtdsn),8)\nspa = DS.###yy.SPACE\nIF SYMBOL(\"DS.\"###yy\".MODEL\") = \"VAR\" THEN DO\n   mod = DS.###yy.MODEL\n   space_cont = \",\"\n   model_present = 1\nEND\nELSE DO\n   model_present = 0\n   space_cont = \"\"\nEND\nmod = DS.###yy.MODEL\nzssa = getssa(tgtdsn) /* Look up appropriate SSA */\n\ncall jcl \"//\"ddname\" DD DISP=(NEW,KEEP),UNIT=\"devtype\",\"\ncall jcl \"//         VOL=SER=\"volser\",DSN=\"zssa\"\"tgtdsn\",\"\ncall jcl \"//         SPACE=(\"spa\")\"space_cont\nIF model_present THEN,\ncall jcl \"//         DCB=(\"mod\")\"\ncall jcl \"//*\"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#ALTER\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #ALTER   - Alter catalog entries to remove the SSA.     */\n/*---------------------------------------------------------*/\n/* V3.1 - 10/10/2007 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG ssa catalog .\n\n/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/\n/* Do a listcat on the cloned system mastercat, and loop   */\n/* through the entries, building ALTER stmts as needed.    */\n/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/\nzzlevel = STRIP(ssa,'B','.')\n##x = OUTTRAP('lc.',99999)\n   \"LISTCAT LEVEL(\"zzlevel\") CATALOG('\"catalog\"')\"\n##x = OUTTRAP('OFF')\n\ncc = 0\n\nDO ##x = 1 TO lc.0\n   IF POS(\"IN-CAT ---\",lc.##x) > 0 THEN ITERATE  /* Discard junk. */\n   PARSE VAR lc.##x zztype zzdummy zzdsn .\n   IF SUBSTR(zzdsn,1,length(ssa)) /= ssa THEN ITERATE /* Not ssa.* */\n   PARSE VAR zzdsn (ssa) zzdsn2\n   say ,\n   \"ALTER '\"zzdsn\"' NEWNAME('\"zzdsn2\"') CATALOG('\"catalog\"')\"\n   \"ALTER '\"zzdsn\"' NEWNAME('\"zzdsn2\"') CATALOG('\"catalog\"')\"\n    IF rc > cc THEN cc = rc\nEND\n\nIF cc = 0 THEN DO\n   SAY ,\n   \"DELETE '\"zzlevel\"' ALIAS\"\nEND\nELSE DO\n   SAY \"System specific alias (SSA) \"zzlevel\" not deleted.\"\nEND\n\nRETURN\n./ ADD NAME=#ALTERJC\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #ALTERJC - Alter catalog entries back to final name.    */\n/*---------------------------------------------------------*/\n/* V3.1 - 03/08/2007 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Alter catalog entries back to final names.         */\n/* (Remove the SYSX.)                                      */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Alter catalog entries to final names.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"ALTER - Alter dataset names to final names, removing\"\ncall jcc \"        the \"ssa\" prefix.                           \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//ALTER    EXEC PGM=IKJEFT01,REGION=4M\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//SYSIN    DD DUMMY\"\ncall jcl \"//SYSTSPRT DD SYSOUT=*\"\ncall jcl \"//SYSPROC  DD DISP=SHR,DSN=\"ipds\ncall jcl \"//SYSTSIN  DD *\"\ncall jcl \" #ALTER \"ssa\"  \"newmcat\ncall jcl \" #ALTER \"ssau\" \"newucat\ncall jcl \"//*\"\ncall clsout opds,'JOB'jobnum\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#COPYDS\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #COPYDS  - Copy datasets.                               */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2007 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\nmaxdsns = 99\nmaxdsnctr = maxdsns + 1\n\n/*=========================================================*/\n/* JOB: Copy datasets.                                     */\n/*=========================================================*/\ndsctr = 0; jobctr = 0\n\nDO ##xxx = 1 TO DS.0\n   maxdsnctr = maxdsnctr +1\n   IF maxdsnctr > maxdsns THEN DO\n      jobctr = jobctr + 1\n      zjnum1 = \"JOB\"jobnum\"\"RIGHT(\"000\"jobctr,2)\n      zjnum2 = jobnum\"\"RIGHT(\"000\"jobctr,2)\n      call clsout opds\n      call setout opds,zjnum1\n      maxdsnctr = 0\n      Say \"Building Job \"zjnum2\": Copy datasets.\"\n      call jobcard jobnum\n      call jcd\n      call jcc \"Job \"zjnum2\n      call jcd\n      call jcc \"COPY - Copy the datasets in the @DATASETS member.\"\n      call jcd\n      call jcc mydate()\" \"comment\n   END\n   IF DS.##xxx.verb /= \"DATASET\" | DS.##xxx.option /= \"COPY\" THEN,\n   ITERATE\n   /* DATASET COPY  record.  */\n   dsctr = dsctr + 1\n   zzdsn = DS.##xxx.DSN\n   zzvol = DS.##xxx.VOL\n   IF SYMBOL(\"DS.\"##xxx\".NEWNAME\") /= \"VAR\" THEN zznewname = \"\"\n   ELSE zznewname = DS.##xxx.NEWNAME\n\n   IF DS.##xxx.MODE = \"DFDSS\"      THEN call copydss\n   IF DS.##xxx.MODE = \"IEBCOPY\"    THEN call copyieb\n   IF DS.##xxx.MODE = \"IEBGENER\"   THEN call copygen\n   IF DS.##xxx.MODE = \"HFS\"        THEN call copyhfs\n   IF DS.##xxx.MODE = \"RACF\"       THEN call copyracf\n   IF POS(\"SMF\",DS.##xxx.PARM) > 0 THEN call copynon\nEND\n\ncall jcl \"//*\"\ncall clsout opds,'JOB'jobnum\nRETURN\n\n/* subr */\ncopydss:\nstepname = \"DSSC\"RIGHT(\"00000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn\" with DFDSS.\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=ADRDSSU\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"      COPY DATASET( - \"\ncall jcl \"         INCLUDE(\"zzdsn\")) -\"\ncall jcl \"         REPLACE    -\"\nIF attrib('RLSE',zzparms) THEN,  /* If not RLSE, do ALLDATA. */\ncall jcl \"         ALLDATA(*) -\"\ncall jcl \"         TOL(ENQF) - \"\ncall jcl \"         BYPASSACS(**) -\"\ncall jcl \"         NULLSTORCLAS  -\"\ncall jcl \"         PROCESS(SYS1)  -\"\nIF zznewname /= \"\" THEN zssa = getssa(zznewname)\nELSE                    zssa = getssa(zzdsn)\n\nIF zznewname /= \"\" THEN zzrnu = zssa\"\"zznewname\nELSE                    zzrnu = zssa\"\"zzdsn\n\ncall jcl \"         RENAMEU( -\"\ncall jcl \"            \"zzdsn\", -\"\ncall jcl \"            \"zzrnu\" -\"\ncall jcl \"                ) -\"\nIF dstype(zzdsn) = \"VSAM\" THEN,\ncall jcl \"         RECATALOG(\"newmcat\") -\"\ncall jcl \"         OUTDYNAM(\"zzvol\") -\"\ncall jcl \"         SHARE\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopyieb:\nstepname = \"IEBC\"RIGHT(\"0000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn\" with IEBCOPY\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEBCOPY\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSUT1   DD DSN=\"zzdsn\",DISP=SHR,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"\nIF zznewname /= \"\" THEN tgtdsn = zznewname\nELSE tgtdsn = zzdsn\nzssa = getssa(tgtdsn) /* Look up appropriate SSA */\n\ncall jcl \"//SYSUT2   DD DSN=\"zssa\"\"tgtdsn\",DISP=SHR,\"\nIF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */\ncall jcl \"//         SPACE=(CYL,(1,1,1),RLSE),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"zzvol\ncall jcl \"//SYSIN    DD * \"\ncall jcl \"  COPY I=SYSUT1,O=SYSUT2,LIST=NO \"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopygen:\nstepname = \"GENR\"RIGHT(\"0000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn\" with IEBGENER\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEBGENER\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSUT1   DD DSN=\"zzdsn\",DISP=SHR,\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"\nIF zznewname /= \"\" THEN tgtdsn = zznewname\nELSE tgtdsn = zzdsn\nzssa = getssa(tgtdsn) /* Look up appropriate SSA */\ncall jcl \"//SYSUT2   DD DSN=\"zssa\"\"tgtdsn\",DISP=SHR,\"\nIF attrib('RLSE',zzparms) THEN, /* If RLSE, specify RLSE.     */\ncall jcl \"//         SPACE=(CYL,(1,1,1),RLSE),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"zzvol\ncall jcl \"//SYSIN    DD DUMMY\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopynon:\nstepname = \"NOOP\"RIGHT(\"0000\"dsctr,4)\nIF zznewname /= \"\" THEN tgtdsn = zznewname\nELSE tgtdsn = zzdsn\ncall jcd\ncall jcc stepname\ncall jcc \"None: \"tgtdsn\" will not be copied.\"\ncall jcc \"This dataset was specified as No-Copy (Allocate only.)\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=IEFBR14\"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopyhfs:\nstepname = \"HFSD\"RIGHT(\"00000\"dsctr,4)\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn\" HFS with DFDSS DUMP and RESTORE.\"\nIF zznewname /= \"\" THEN,\ncall jcc \"Target dsn is \"zznewname\".\"\ncall jcd\ncall jcl \"//\"stepname\" EXEC PGM=ADRDSSU\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//TAPE      DD DISP=(,PASS),DSN=&&TAPE,UNIT=SYSALLDA,\"\ncall jcl \"//          VOL=SER=\"workvol\",SPACE=(CYL,(350,200),RLSE)\"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"  DUMP    DATASET(  -\"\ncall jcl \"          INCLUDE(\"zzdsn\")) -\"\ncall jcl \"          TOL(ENQF) -\"\ncall jcl \"          OUTDD(TAPE)\"\ncall jcl \"//*\"\nstepnam2 = \"HFSR\"RIGHT(\"00000\"dsctr,4)\ncall jcl \"//\"stepnam2\" EXEC PGM=ADRDSSU,COND=(4,LT,\"stepname\")\"\ncall jcl \"//SYSPRINT  DD SYSOUT=* \"\ncall jcl \"//TAPE      DD DISP=(OLD,DELETE),DSN=&&TAPE\"\ncall jcl \"//SYSIN     DD * \"\ncall jcl \"  RESTORE DATASET( -\"\ncall jcl \"          INCLUDE(**)) -\"\ncall jcl \"          RECATALOG(\"newmcat\") -\"\ncall jcl \"          BYPASSACS(**) -\"\ncall jcl \"          NULLSTORCLAS -\"\nIF zznewname /= \"\" THEN zssa = getssa(zznewname)\nELSE                    zssa = getssa(zzdsn)\n\nIF zznewname /= \"\" THEN zzrnu = zzdsn\",\"zssa\"\"zznewname\nELSE                    zzrnu = zzdsn\",\"zssa\"\"zzdsn\ncall jcl \"          RENAMEU(\"zzrnu\") -\"\ncall jcl \"          OUTDYNAM(\"zzvol\") -\"\ncall jcl \"          REPLACE TOL(ENQF) INDD(TAPE) \"\ncall jcl \"//*\"\nRETURN\n\n/* subr */\ncopyracf:\nstepname = \"RACF\"RIGHT(\"00000\"dsctr,4)\nIF isblank(\"DS.\"##xxx\".SPACE\") THEN zzspa = \"\"\nELSE zzspa = \",SPACE=(\"DS.##xxx.SPACE\")\"\ncall jcd\ncall jcc stepname\ncall jcc \"Copy \"zzdsn\" with IRRUT400\"\ncall jcd\ncall jcl \"//RFCOPY   EXEC PGM=IRRUT400,PARM='LOCKINPUT,FREESPACE(20)'\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\nIF zznewname /= \"\" THEN tgtdsn = zznewname\nELSE                   tgtdsn = zzdsn\nzssa = getssa(tgtdsn) /* Look up appropriate SSA */\ncall jcl \"//INDD1    DD DSN=\"zzdsn\",DISP=OLD\"\ncall jcl \"//OUTDD1   DD DSN=\"zssa\"\"tgtdsn\",DISP=(,KEEP),\"\ncall jcl \"//         UNIT=SYSALLDA,VOL=SER=\"zzvol\",\"\ncall jcl \"//         DCB=(\"zzdsn\")\"zzspa\ncall jcl \"//UNLOCK   EXEC PGM=IRRUT400,PARM='UNLOCKINPUT'\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//INDD1    DD DSN=\"zzdsn\",DISP=OLD\"\n\nRETURN\n\n/* subr */\nalter_rename:\nARG ##old,##new\n\ncall jcd\ncall jcl \"//ALTER    EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD    SYSOUT=*\"\ncall jcl \"//SYSIN    DD    *\"\ncall jcl \"  ALTER \"##old\" -\"\ncall jcl \"        NEWNAME(\"##new\") -\"\ncall jcl \"        CATALOG(\"newmcat\")\"\ncall jcl \"//*\"\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#COPYMEM\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #COPYMEM - Copy generated members to their final homes. */\n/*---------------------------------------------------------*/\n/* V3.0 - 07/15/2007 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Copy members from ZCLONE PDS to various places.    */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Copy generated members.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"COPYMEM - Copy customized members for various PROCs,   \"\ncall jcc \"          PARMLIB members, etc.\"\ncall jcd\ncall jcc mydate()\" \"comment\n\n/*--------------------------------------------------------------------*/\n/* Look for MEMCOPY commands in @DATASET member, and build DD stmts.  */\n/* If the first 5 chars are blank, we assume a continuation, and keep */\n/* stringing records togther until no more continuation records are   */\n/* found.  Then we parse the combined string for all the values.      */\n/*--------------------------------------------------------------------*/\nindsn=\"\";outdsn=\"\";stepctr=0\nDO ##xxx = 1 TO DS.0\n   IF DS.##xxx.verb /= \"MEMCOPY\" THEN ITERATE\n   zzindsn  = DS.##xxx.IN\n   zzoutdsn = DS.##xxx.OUT\n   IF indsn /= zzindsn | outdsn /= zzoutdsn THEN DO\n      indsn = zzindsn; outdsn = zzoutdsn\n      zzinvol  = getvol(DS.##xxx.IN)\n      /* No support for coding the volser on an input dataset. */\n      zzinvol  = \"\"\n      zzoutvol = getvol(DS.##xxx.OUT)\n      call copystep\n   END\n   zzmems = DS.##xxx.M\n   zzmems = TRANSLATE(zzmems,\"   \",\"(),\")\n   PARSE VAR zzmems zzmem1 zzmem2\n   zzmems = zzmem1\",\"zzmem2\n   call jcl \"    S M=((\"zzmems\",R))\"\nEND\n\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\ncopystep:\n\n   stepctr = stepctr + 1\n   zzstp = \"COPY\"RIGHT(\"0000\"stepctr,3)\n   call jcd\n   call jcc zzstp\n   call jcd\n   call jcl \"//\"zzstp\"  EXEC  PGM=IEBCOPY\"\n   call jcl \"//SYSPRINT DD SYSOUT=*\"\n   IF zzinvol /= \"\" THEN DO\n      call jcl \"//IN       DD DISP=SHR,DSN=\"zzindsn\",\"\n      call jcl \"//         UNIT=\"devtype\",VOL=SER=\"zzinvol\n   END\n   ELSE DO\n      call jcl \"//IN       DD DISP=SHR,DSN=\"zzindsn\n   END\n   IF zzoutvol /= \"\" THEN DO\n      call jcl \"//OUT      DD DISP=SHR,DSN=\"zzoutdsn\",\"\n      call jcl \"//         UNIT=\"devtype\",VOL=SER=\"zzoutvol\n   END\n   ELSE DO\n      call jcl \"//OUT      DD DISP=SHR,DSN=\"zzoutdsn\n   END\n   call jcl \"//SYSIN    DD *\"\n   call jcl \"  COPY I=IN,O=OUT\"\n   RETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#DEFCAT\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #DEFMCAT - Define master catalog.                       */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Define master catalog.                             */\n/*=========================================================*/\nIF \\isblank('NEWMCAT') | \\isblank('NEWUCAT') THEN DO\n   Say \"Building Job \"jobnum\": Define master catalog.\"\n   call setout opds,'JOB'jobnum\n   call jobcard jobnum\n   call jcd\n   call jcc \"Job \"jobnum\n   call jcd\n   call jcc \"DEFMCAT - Define catalogs and aliases.\"\n   call jcd\n   call jcc mydate()\" \"comment\n   call jcl \"//DEFCAT   EXEC PGM=IDCAMS\"\n   call jcl \"//SYSPRINT DD SYSOUT=* \"\n   call jcl \"//SYSIN    DD * \"\nEND\n\n/*---------------------------------------------------------*/\n/* Mastercat.                                              */\n/*---------------------------------------------------------*/\nIF \\isblank('NEWMCAT') THEN DO\n   call jcl \" \"\n   call jcl \"      DEFINE USERCATALOG     ( -\"\n   call jcl \"         NAME(\"newmcat\") -\"\n   call jcl \"         CYL(5 2) - \"\n   call jcl \"         VOL(\"newmcatvol\") -\"\n   call jcl \"         BUFFERSPACE(8192) -\"\n   call jcl \"         BUFND(10) -\"\n   call jcl \"         BUFNI(10) -\"\n   call jcl \"         ICFCATALOG -\"\n   call jcl \"         STRNO(9) ) -\"\n   call jcl \"         CATALOG(\"oldmcat\")\"\n   call jcl \" \"\n   IF \\isblank(\"SSA\") THEN DO\n      zzssa = STRIP(ssa,\"B\",\".\")   /* Get rid of trailing \".\" */\n      call jcl \"      IF MAXCC = 0 THEN DO \"\n      call jcl \"         DELETE \"zzssa\" ALIAS\"\n      call jcl \"         SET MAXCC=0\"\n      call jcl \" \"\n      call jcl \"         DEFINE ALIAS(NAME(\"zzssa\") -\"\n      call jcl \"         RELATE(\"newmcat\")) -\"\n      call jcl \"         CATALOG(\"oldmcat\")\"\n      call jcl \"      END\"\n      call jcl \" \"\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Usercat.                                                */\n/*---------------------------------------------------------*/\nIF \\isblank('NEWMCAT') & \\isblank('NEWMCAT') THEN DO\n   call jcl \" \"\n   call jcl \"      IF MAXCC = 0 THEN DO \"\n   call jcl \"         DEFINE USERCATALOG     ( -\"\n   call jcl \"            NAME(\"newucat\") -\"\n   call jcl \"            CYL(5 2) - \"\n   call jcl \"            VOL(\"newucatvol\") -\"\n   call jcl \"            BUFFERSPACE(8192) -\"\n   call jcl \"            BUFND(10) -\"\n   call jcl \"            BUFNI(10) -\"\n   call jcl \"            ICFCATALOG -\"\n   call jcl \"            STRNO(9) ) -\"\n   call jcl \"            CATALOG(\"oldmcat\")\"\n   call jcl \"      END\"\n   call jcl \"      IF MAXCC = 0 THEN DO \"\n   call jcl \"         IMPORT OBJECTS -\"\n   call jcl \"            ((\"newucat \" -\"\n   call jcl \"            VOLUME(\"newucatvol\") -\"\n   call jcl \"            DEVICETYPE(\"devtype\"))) -\"\n   call jcl \"            CONNECT CATALOG(\"newmcat\")\"\n   call jcl \"      END\"\n   call jcl \" \"\n   IF \\isblank(\"SSAU\") THEN DO\n      zzssau = STRIP(ssau,\"B\",\".\")   /* Get rid of trailing \".\" */\n      call jcl \"      IF MAXCC = 0 THEN DO \"\n      call jcl \"         DELETE \"zzssau\" ALIAS\"\n      call jcl \"         SET MAXCC=0\"\n      call jcl \" \"\n      call jcl \"         DEFINE ALIAS(NAME(\"zzssau\") -\"\n      call jcl \"         RELATE(\"newucat\")) -\"\n      call jcl \"         CATALOG(\"oldmcat\")\"\n      call jcl \"      END\"\n      call jcl \" \"\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Usercat aliases (if specified in @PARMS)                */\n/*---------------------------------------------------------*/\nIF \\isblank(\"UCATALIAS1\") & \\isblank(\"NEWUCAT\") THEN DO\n   call jcl \"      IF MAXCC = 0 THEN DO \"\nEND\nDO zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"zz) & \\isblank(\"NEWUCAT\") THEN DO\n      zalias = VALUE(\"UCATALIAS\"zz);\n      call jcl \"         DEFINE ALIAS(NAME(\"zalias\") -\"\n      call jcl \"         RELATE(\"newucat\")) -\"\n      call jcl \"         CATALOG(\"newmcat\")\"\n      call jcl \" \"\n   END\nEND\nIF \\isblank(\"UCATALIAS1\") THEN DO\n   call jcl \"      END\"\nEND\n\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#DEFNVSM\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------Rexx--*/\n/* #DEFNVSM - Define non-VSAM catalog entries              */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\nzuse_syms = \\isblank(\"USESYM\") & USESYM = \"YES\"\n\n/*=========================================================*/\n/* JOB: Define NONVSAM catalog entries.                    */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Define NONVSAM catalog entries.\"\ncall setout opds,'JOB'jobnum\n\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"NONVSAM - Define non-VSAM catalog entries for all NONVSAM   \"\ncall jcc \"          datasets, including those copied by DFDSS.\"\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFNVSAM EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" LISTCAT ENT(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" IF LASTCC = 0 THEN DO\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Define catlg entries for NONVSAM.         */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nDO ##xxx = 1 TO DS.0\n   IF DS.##xxx.verb /= \"DATASET\" THEN ITERATE\n   IF dstype(DS.##XXX.DSN) = \"VSAM\" THEN ITERATE\n   zzEXCEPTIONS = \"SMF STGINDEX PGPLPA PGCOMMON PGLOCAL XCF WLM LOGR \"\n   zbEXC = hasParms(zzEXCEPTIONS,DS.##xxx.PARM)\n   IF zbEXC THEN ITERATE\n   IF SYMBOL(\"DS.\"##xxx\".NEWNAME\")=\"VAR\" THEN zzdsn = DS.##xxx.NEWNAME\n   ELSE zzdsn = DS.##xxx.DSN\ntrace off\n   zzcat = getcat(zzdsn)\n   zzvol = DS.##xxx.VOL\n   zssa = getssa(zzdsn) /* Look up appropriate SSA */\n   call jcl \"    DEFINE NONVSAM ( -\"\n   call jcl \"       NAME(\"zssa\"\"zzdsn\") -\"\n   call jcl \"       DEVT(\"devtype\") VOL(\"zzvol\")) CATALOG(\"zzcat\")\"\n   call jcl \" \"\n   IF zuse_syms THEN DO\n      call jcl \"    ALTER \"zssa\"\"zzdsn\" -\"\n      call jcl \"       NEWNAME(\"zzdsn\") -\"\n      call jcl \"       CATALOG(\"zzcat\")\"\n      call jcl \" \"\n      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n      /* If PARM(NOSYM) coded for this DS, don't recatlg with       */\n      /* symbolid volser.                                           */\n      /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n      IF \\hasParms(\"NOSYM\",DS.##xxx.PARM) THEN DO\n         call jcl \"    DELETE \"zzdsn\" NOSCRATCH -\"\n         call jcl \"       CATALOG(\"zzcat\")\"\n         call jcl \" \"\n         call jcl \"    DEFINE NONVSAM ( -\"\n         call jcl \"       NAME(\"zzdsn\") -\"\n         zzvl2 = volsym(zzvol)\n         call jcl \"       DEVT(0000) VOL(\"zzvl2\")) CATALOG(\"zzcat\")\"\n         call jcl \" \"\n      END\n   END\ntrace off\nEND\ncall jcl \" END\"\ncall jcl \"//*\"\ncall clsout opds,'JOB'jobnum\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/* - - - 07/29/2009 JCM - - - - - - - - - - -*/\n/* If \"ASTERISKS\" is defined in parms for    */\n/* this ds, then catalog with \"******\"       */\n/* instead of &SYSR1. \"******\",\"ASTER\",\"*\"   */\n/* are also synonyms.                        */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nIF hasParms(\"ASTERISKS\",DS.##xxx.PARM) THEN RETURN \"******\"\nIF hasParms(\"******\",DS.##xxx.PARM) THEN RETURN \"******\"\nIF hasParms(\"ASTER\",DS.##xxx.PARM) THEN RETURN \"******\"\nIF hasParms(\"*\",DS.##xxx.PARM) THEN RETURN \"******\"\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#DEFVSAM\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------Rexx--*/\n/* #DEFVSAM - Define VSAM files.                           */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Define VSAM files.                                 */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Define VSAM files.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"DEFVSAM - Define MANx, PAGE, STGINDEX datasets.\"\ncall jcd\ncall jcc \"Define the datasets with the SSA prefix: \"ssa\", so that the\"\ncall jcc \"catalog entries are defined in our new rescue master catalog,\"\ncall jcc newmcat\".\"\ncall jcd\ncall jcc \"We check for the SSA being defined before doing any defines.\"\ncall jcc \"This prevents us from inadvertently storing junk in the \"\ncall jcc \"master catalog of the driving system.  \"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DEFVSAM  EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" LISTCAT ALL ENTRY(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" IF LASTCC = 0 THEN DO\"\ncall jcl \" \"\nDO ##xxx = 1 TO DS.0\n   IF hasParms(\"STGINDEX\",DS.##xxx.PARM) THEN DO\n      zzdsn = DS.##xxx.DSN\n      zzvol = DS.##xxx.VOL\n      zzspa = TRANSLATE(DS.##xxx.SPACE,\"   \",\",()\")\n      PARSE VAR zzspa zzunit zzpri .\n      call jcl \"      DEFINE CLUSTER ( -\"\n      call jcl \"                NAME( \"ssa\"\"zzdsn\" ) -\"\n      call jcl \"                \"zzunit\"( \"zzpri\" ) -\"\n      call jcl \"                VOL(\"zzvol\") -\"\n      call jcl \"                BUFFERSPACE(20480) - \"\n      call jcl \"                KEYS(12 8) - \"\n      call jcl \"                RECORDSIZE(2041,2041) -\"\n      call jcl \"                REUSE ) - \"\n      call jcl \"             DATA ( -\"\n      call jcl \"                NAME( \"ssa\"\"zzdsn\".DATA ) -\"\n      call jcl \"                CISZ(2048) ) - \"\n      call jcl \"             INDEX ( - \"\n      call jcl \"                NAME( \"ssa\"\"zzdsn\".INDEX ) -\"\n      call jcl \"                CISZ(1024) )\"\n      call jcl \" \"\n      call jcl \" \"\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Create PAGE datasets.                                   */\n/*---------------------------------------------------------*/\nDO ##xxx = 1 TO DS.0\n   IF hasParms(\"PGPLPA PGCOMMON PGLOCAL\",DS.##xxx.PARM) THEN DO\n      zzdsn = DS.##xxx.DSN\n      zzvol = DS.##xxx.VOL\n      zzspa = TRANSLATE(DS.##xxx.SPACE,\"   \",\",()\")\n      PARSE VAR zzspa zzunit zzpri .\n      call jcl \"     DEFINE PAGESPACE ( -\"\n      call jcl \"                NAME( \"ssa\"\"zzdsn\") -\"\n      call jcl \"                   \"zzunit\"(\" zzpri \") -\"\n      call jcl \"                   VOL(\"zzvol\") -\"\n      call jcl \"                   NOSWAP - \"\n      call jcl \"                   UNIQUE )  \"\n      call jcl \" \"\n      call jcl \" \"\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Build defines for each SMF ds as defined in @DATASET,   */\n/* i.e. dsns that have the SMF parm coded.                 */\n/*---------------------------------------------------------*/\ncall smflist\n\nDO xx = 1 TO SMF.0\n   smfds   = SMF.xx.dsn\n   smfvl   = SMF.xx.vol\n   smfunit = SMF.xx.unit\n   smfpri  = SMF.xx.pri\n   smfsec  = SMF.xx.sec\n   call jcl \"  DEFINE CLUSTER ( - \"\n   call jcl \"             NAME( \"ssa\"\"smfds\" ) -\"\n   call jcl \"                \"smfunit\"( \"zpri zsec\" ) -\"\n   call jcl \"                VOLUME(\"smfvl\") -\"\n   call jcl \"                CISZ(4096) - \"\n   call jcl \"                NONINDEXED - \"\n   call jcl \"                RECORDSIZE(4086 32767) - \"\n   call jcl \"                REUSE   SHR(2 3) - \"\n   call jcl \"                SPANNED  SPEED ) - \"\n   call jcl \"          DATA ( -  \"\n   call jcl \"                  NAME( \"ssa\"\"smfds\".DATA) ) \"\n   call jcl \" \"\nEND\n\n/* Closing END from highest level IF LASTCC (from alias).  */\ncall jcl \" END \"\ncall jcl \"//*\"\n\n/*---------------------------------------------------------*/\n/* Format SMF datasets.  They still have the SSA on front. */\n/*---------------------------------------------------------*/\ncall jcd\ncall jcc \"FMTSMF   - Format SMF datasets.\"\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//FMTSMF EXEC PGM=IFASMFDP\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\nDO xx = 1 TO SMF.0\n   smfds   = SMF.xx.dsn\n   smfds   = ssa\"\"smfds\n   smfvl   = SMF.xx.vol\n   call jcl \"//\"substr(llq(smfds),1,8)\" DD DSN=\"smfds\",DISP=SHR,\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"smfvl\nEND\ncall jcl \"//SYSIN    DD *\"\nDO xx = 1 TO SMF.0\n   smfds   = SMF.xx.dsn\n   call jcl \"   INDD(\"llq(smfds)\",OPTIONS(CLEAR))\"\nEND\ncall jcl \"//*\"\n\n/*---------------------------------------------------------*/\n/* Rename SMF datasets to final name (remove SSA).         */\n/*---------------------------------------------------------*/\ncall jcd\ncall jcc \"RENSMF   - Rename SMF datasets.\"\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//RENSMF EXEC PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//SYSIN    DD *\"\ncall jcl \" LISTCAT ALL ENTRY(\"strip(ssa,\"B\",\".\")\") ALIAS\"\ncall jcl \" \"\ncall jcl \"//*\"\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* Make a list of SMF datasets, plus the PRI and SEC aloc. */\n/*---------------------------------------------------------*/\nsmflist:\nSMF.0 = 0\n##x91 = 0\n/* Read @dataset member into DSNS. stem variable.           */\n\nDO ##xxx = 1 TO DS.0\n   IF POS(\"SMF\",DS.##xxx.PARM) = 0 THEN ITERATE\n   ##x91 = ##x91 + 1\n   SMF.##x91.dsn = DS.##xxx.DSN\n   SMF.##x91.vol = DS.##xxx.VOL\n   PARSE VAR DS.##xxx.SPACE zunit \",\" zspa\n   zspa = TRANSLATE(zspa,'   ','(),')\n   PARSE VAR zspa zpri zsec\n   SMF.##x91.unit = zunit\n   SMF.##x91.pri  = zpri\n   SMF.##x91.pri  = zsec\nEND\nSMF.0 = ##x91\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#DELSSA\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #DELSSA  - Delete SSA.                                  */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Delete the SSA (System Specific Alias)             */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Delete SSA: \"ssa\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"DELSSA  - Delete the System Specifc Aliases\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//DELSSA   EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD * \"\ncall jcl \" DELETE \"strip(ssa,\"B\",\".\")\" ALIAS\"\ncall jcl \" \"\nIF \\isblank('NEWUCAT') & \\isblank('SSAU') THEN,\ncall jcl \" DELETE \"strip(ssau,\"B\",\".\")\" ALIAS\"\ncall jcl \" \"\n\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#INITVOL\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #INITVOL - Initialize RESCUE volume.                    */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*---------------------------------------------------------*/\n/* See if COMMANDPGM and WAITPGM are coded in parms.  If   */\n/* not, then don't code the ONLINE and OFFLINE steps.      */\n/*---------------------------------------------------------*/\ncmdpgm  = \\isblank(\"COMMANDPGM\")\nwaitpg  = \\isblank(\"WAITPGM\")\n\nSay \"Building Job \"jobnum\": Init disk pack.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"EXPORTD - Export the new mcat to clean up from previous runs.\"\nIF cmdpgm THEN,\ncall jcc \"OFFLINE - Vary the target VOLSER offline.\"\ncall jcc \"DSFINIT - Initialize volumes with ICKDSF.\"\nIF cmdpgm THEN,\ncall jcc \"ONLINE  - Vary the target VOLSERS online.\"\ncall jcc \"DEFVVDS - Define VVDSs on volumes.\"\ncall jcd\ncall jcc \"NOTE: You will need to reply to the ICKDSF message ICK003D\"\ncall jcc \"on the MVS console after submitting this job.BE SURE that\"\ncall jcc \"the address specified in this message is the correct disk\"\ncall jcc \"unit.  If the wrong address is specified, and this wrong\"\ncall jcc \"address is an offline disk unit, it will be completely wiped\"\ncall jcc \"out, and will have to be recovered from a backup.\"\n\n/*---------------------------------------------------------*/\n/* Can't automatically do V ONLINE etc., so place notes    */\n/* in JCL to that effect.                                  */\n/*---------------------------------------------------------*/\nIF \\cmdpgm THEN DO\n   call jcd\n   call jcc \"NOTE: The 'COMMAND' and/or 'WAIT' programs were not coded \"\n   call jcc \"in the @PARMS member.  You will need to manually vary the \"\n   call jcc \"disk units for the cloned system offline, and online.     \"\n   call jcc \" \"\n   call jcc \"Before running this job, vary the disk unit offline from  \"\n   call jcc \"the MVS console using the command: \"\n   call jcc \"   V \"addr\",OFFLINE\"\n   call jcc \"After replying to the the ICKDSF message to confirm the\"\n   call jcc \"initialization of the disk pack, you will need to reply\"\n   call jcc \"to the MVS allocation message with the address of the  \"\n   call jcc \"new rescue volume, \"addr\".\"\nEND\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//EXPORTD    EXEC  PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN      DD * \"\ncall jcl \"     EXPORT \"newmcat \"-\"\ncall jcl \"            DISCONNECT    \"\nIF \\isblank('NEWUCAT') THEN DO\n   call jcl \"     EXPORT \"newucat \"-\"\n   call jcl \"            DISCONNECT    \"\nEND\ncall jcl \"     SET MAXCC=0  \"\n/*---------------------------------------------------------*/\n/* If COMMAND cmd is available, us it to do the VARY.      */\n/*---------------------------------------------------------*/\nIF cmdpgm THEN DO\n   zpg1=COMMANDPGM\n   call jcd\n   call jcc   \" OFFLINE\"\n   call jcd\n   DO zz = 1 TO 99\n      IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n         zaddr = VALUE(\"ADDR\"zz); zvolser = VALUE(\"VOLSER\"zz)\n         j =  \"//OFFLINE    EXEC PGM=\"zpg1\",PARM='V \"zaddr\",OFFLINE'\"\n         call jcl j\n         IF waitpg THEN DO\n            zpg2=WAITPGM\n            call jcl \"//WAIT       EXEC PGM=\"zpg2\",PARM=2\"\n         END\n      END\n   END\nEND\n/*---------------------------------------------------------*/\n/* Write the JCL to initialize the volumes.  Include ipl   */\n/* text and bootstrap records for the ADDR1/VOLSER1.       */\n/*---------------------------------------------------------*/\nDO zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n      zaddr = VALUE(\"ADDR\"zz); zvolser = VALUE(\"VOLSER\"zz)\n      call volinit \"VOLSER\"zz, \"ADDR\"zz\n   END\nEND\n/*---------------------------------------------------------*/\n/* If COMMAND cmd is available, us it to do the VARY.      */\n/*---------------------------------------------------------*/\nIF cmdpgm THEN DO\n   zpgm=COMMANDPGM\n   call jcd\n   call jcc   \" ONLINE\"\n   call jcd\n   DO zz = 1 TO 99\n      IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n         zaddr = VALUE(\"ADDR\"zz); zvolser = VALUE(\"VOLSER\"zz)\n         j =  \"//ONLINE     EXEC PGM=\"zpgm\",PARM='V \"zaddr\",ONLINE'\"\n         call jcl j\n         IF waitpg THEN DO\n            zpg2=WAITPGM\n            call jcl \"//WAIT       EXEC PGM=\"zpg2\",PARM=2\"\n         END\n      END\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Define VVDS on each volume.                             */\n/*---------------------------------------------------------*/\ncall jcd\ncall jcc   \"DEFVVDS - Define VVDS.\"\ncall jcd\ncall jcl \"//DEFVVDS  EXEC PGM=IDCAMS\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\nDO zz = 1 TO 99\n   filenm = \"TRGT\"RIGHT(\"00\"zz,3)\n   volser = VALUE(\"VOLSER\"zz)\n   IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n      call jcl \"//\"filenm\"  DD DISP=SHR,UNIT=SYSALLDA,VOL=SER=\"volser\n   END\nEND\ncall jcl \"//SYSIN    DD *\"\nDO zz = 1 TO 99\n   filenm = \"TRGT\"RIGHT(\"00\"zz,3)\n   volser = VALUE(\"VOLSER\"zz)\n   IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n      call jcl \" DELETE    SYS1.VVDS.V\"volser\" -\"\n      call jcl \"           FILE(\"filenm\") CLUSTER PURGE -\"\n      call jcl \"           CATALOG(\"oldmcat\") \"\n      call jcl \" SET MAXCC=0\"\n      call jcl \" \"\n      call jcl \" DEFINE CLUSTER ( -\"\n      call jcl \"           NAME(SYS1.VVDS.V\"volser\") -\"\n      call jcl \"           CYL(1,1) -\"\n      call jcl \"           VOL(\"volser\") -\"\n      call jcl \"           FILE(\"filenm\") - \"\n      call jcl \"           NONINDEXED - \"\n      call jcl \"           OWNER(RESCUE) ) -\"\n      call jcl \"           CATALOG(\"oldmcat\")\"\n      call jcl \"                            \"\n   END\nEND\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* volinit - Subroutine to initialize a volume.            */\n/*---------------------------------------------------------*/\nvolinit:\nARG ##volser, ##addr\nIF \\isblank(##volser) & \\isblank(##addr) THEN DO\n   zvolser = VALUE(##volser); zaddr = VALUE(##addr)\n   call jcd\n   call jcc   \"DSFINIT - DSF Initialize\"\n   call jcd\n   call jcl \"//DSFINIT  EXEC PGM=ICKDSF\"\n   IF ##volser = 'VOLSER1' THEN DO\n      call jcl \"//IPLTEXT  DD DISP=SHR,VOL=SER=\"sysres\",UNIT=SYSALLDA,\"\n      call jcl \"//         DSN=SYS1.SAMPLIB(IPLRECS)\"\n      call jcl \"//         DD DISP=SHR,VOL=SER=\"sysres\",UNIT=SYSALLDA,\"\n      call jcl \"//         DSN=SYS1.SAMPLIB(IEAIPL00)\"\n   END\n   call jcl \"//SYSPRINT DD     SYSOUT=* \"\n   call jcl \"//SYSIN      DD   *        \"\n   call jcl \" INIT     UNIT(\"zaddr\") -   \"\n   call jcl \"          VOLID(\"zvolser\") -\"\n   call jcl \"          VTOC(0,1,14) -  \"\n   call jcl \"          PURGE -  \"\n   call jcl \"          MAP -  \"\n   IF ##volser = 'VOLSER1' THEN DO\n      call jcl \"          IPLDD(IPLTEXT) - \"\n      call jcl \"          NOBOOTSTRAP -\"\n   END\n   call jcl \"          NOVERIFY -  \"\n   call jcl \"          NOVALIDATE -  \"\n   call jcl \"          NOCHECK    \"\n   call jcl \"//*\"\nEND\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#MEMBERS\n/*---------------------------------------------------Rexx--*/\n/* MEMBERS - Build various RESCUE system members.          */\n/*---------------------------------------------------------*/\n/* No jobs are generated by this member.                   */\n/*---------------------------------------------------------*/\n/* 03/08/2007 John C. Miller                               */\n/*---------------------------------------------------------*/\nARG ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*---------------------------------------------------------*/\n/* Call routines to build various members.                 */\n/*---------------------------------------------------------*/\ncall iodf              /* LOAD00 for IODF.                 */\ncall ieasym            /* IEASYM00 system symbols.         */\ncall apf               /* PROGA0 for APF.                  */\ncall lnklst            /* PROGL0 for LNKLST.               */\ncall lpa               /* LPALST00.                        */\ncall jes2              /* PROC for JES2.                   */\ncall jes2parm          /* Create JES2PARM.                 */\ncall tsoproc           /* TSO LOGON PROC.                  */\ncall tso               /* TSO STARTED PROC.                */\ncall vtamproc          /* VTAM startup proc.               */\ncall mstrjcl           /* MSTRJCL00.                       */\ncall bpxprm            /* BPXPRM00 OMVS parms.             */\ncall igdsms            /* IGDSMS00 member.                 */\ncall couple            /* COUPLE00 member.                 */\ncall vatlst            /* VATLST00 member.                 */\ncall ieasys            /* IEASYS00 member.                 */\n\nexit\n\n/*---------------------------------------------------------*/\n/* COUPLEnn member:  For now, we only support operation    */\n/* in sysplex-local mode using   COUPLE SYSPLEX(LOCAL)     */\n/*---------------------------------------------------------*/\n/* @PARM statements used to create COUPLE00 member.        */\n/* Not currently used.                                     */\n/*---------------------------------------------------------*/\n/* Couple datasets.                                        */\n/*            DSN               Volume # to put ds on.     */\n/*---------------------------------------------------------*/\n/*  XCF1        = SYS1.XCF.CDS01    1                      */\n/*  XCF2        = SYS1.XCF.CDS02    2                      */\n/*  WLM1        = SYS1.WLM.CDS01    1                      */\n/*  WLM2        = SYS1.WLM.CDS02    2                      */\n/*  LOGR1       = SYS1.LOGR.CDS01   1                      */\n/*  LOGR2       = SYS1.LOGR.CDS02   2                      */\n/*                                                         */\n/*  SYSPLEX     = LOCAL                                    */\n/*---------------------------------------------------------*/\nRETURN                                                     */\n\n/*---------------------------------------------------------*/\n/* LOAD00 member: SYS1.IPLPARM                             */\n/*---------------------------------------------------------*/\niodf:\nSAY \"Building LOAD00 IPLPARM member.\"\n##iodf = \"00\"\n##iodfsys = \"SYS1\"\n/* See if nonstandard SYSx prefix. */\nIF substr(iodf,1,3) = 'SYS' THEN DO\n   PARSE VAR iodf ##iodfsys \".\" .\nEND\n\n/* See if nonstandard IODFxx prefix. */\n##y9 = POS('.IODF',iodf)\nIF ##y9 > 0 THEN ##iodf = substr(iodf,##y9+5,2)\ncall setout opds,'LOAD00' /* Set output member name.  */\ncall jcl \"IODF     \"##iodf\" \"substr(##iodfsys,1,8)\"\",\n         substr(ioconfigid,1,9)\"00\"\ncall jcl \"NUCLEUS  1\"\ncall jcl \"SYSCAT   \"substr(newmcatvol,1,6)\"113C\"newmcat\ncall jcl \"IEASYM   00\"\n\n/* Add PARMLIBs */\nlibs = xdslist('PARMLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   volser = WORD(libs,x+1)\n   call jcl \"PARMLIB  \"substr(WORD(libs,x),1,45)volser\nEND\n\ncall clsout opds,'LOAD00'\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of LOAD00 Member.                                   */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* IEASYM member: SYS1.PARMLIB                             */\n/*---------------------------------------------------------*/\nieasym:\nSAY \"Building IEASYM PARMLIB member.\"\ncall setout opds,'IEASYM00' /* Set output member name.  */\n\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\n/* Create a SYSDEF and a throwaway SYMDEF entry.        */\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\ncall jcl \"SYSDEF\"\ncall jcl \"   SYMDEF(&SSALIAS='\"SSA\"')\"\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\n/* Iterate through VOLSER2-VOLSERn and create a SYSRn   */\n/* system variable in IEASYM00                          */\n/*-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  */\nDO zz = 2 TO 99\n   IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n      zvolser = VALUE(\"VOLSER\"zz)\n      call jcl \"   SYMDEF(&SYSR\"zz\"='\"zvolser\"')\"\n   END\nEND\n\ncall clsout opds,'IEASYM00'\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of IEASYM Member.                                   */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* PROGA0 Parmlib member: APF entries.                     */\n/*---------------------------------------------------------*/\n/* Creates entries for all datasets in @DATASET that have  */\n/* PARM(APF)                                               */\n/*---------------------------------------------------------*/\napf:\nSAY \"Building PROGA0 PARMLIB member.\"\ncall setout opds,'PROGA0' /* Set output member name.  */\n\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"/* APF entries dynamically built by RESCUE exec.    */\"\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"APF FORMAT(DYNAMIC)\"\n\n/* Add APF LIBs */\nlibs = xdslist('APF')\nDO x = 1 TO WORDS(libs) BY 2\n   ##z10 = \"APF ADD \"substr(\"DSNAME(\"WORD(libs,x)\")\",1,46)\n   ##z10 = ##z10\"VOLUME(\"WORD(libs,x+1)\")\"\n   call jcl ##z10\nEND\n\ncall clsout opds,'PROGA0'\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of PROGA0 Member.                                   */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* PROGL0 Parmlib member: LNKLST entries                   */\n/*---------------------------------------------------------*/\n/* Creates entries for all datasets in @DATASET that have  */\n/* PARM(LNKLST)                                            */\n/*---------------------------------------------------------*/\nlnklst:\nSAY \"Building PROGL0 PARMLIB member.\"\ncall setout opds,'PROGL0' /* Set output member name.  */\n\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"/* LNKLST entries dynamically built by RESCUE exec. */\"\ncall jcl \"/*--------------------------------------------------*/\"\ncall jcl \"LNKLST DEFINE NAME(LNKLST00)\"\n\n/* Add LNKLST LIBs */\nlibs = xdslist('LNK')\nDO x = 1 TO WORDS(libs) BY 2\n   ds = WORD(libs,x); volser = WORD(libs,x+1)\n   ##z10 = \"LNKLST ADD NAME(LNKLST00)\"\n   call jcl ##z10\n   ##z10 = \"     \"substr(\"DSNAME(\"ds\")\",1,40)\"VOLUME(\"volser\")\"\n   call jcl ##z10\nEND\n\ncall jcl \"LNKLST ACTIVATE NAME(LNKLST00)\"\ncall clsout opds,'PROGL0'\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of PROGL0 Member.                                   */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* LPALST00 Parmlib member - LPA libraries.                */\n/*---------------------------------------------------------*/\n/* Creates entries for all datasets in @DATASET that have  */\n/* PARM(LPA)                                               */\n/*---------------------------------------------------------*/\nlpa:\nSAY \"Building LPALST00 PARMLIB member.\"\ncall setout opds,'LPALST00' /* Set output member name.  */\n\n/* Add LPALST LIBs */\nlibs = xdslist('LPA')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x < WORDS(libs)-1 THEN,\n   call jcl WORD(libs,x)\",\"\n   ELSE,\n   call jcl WORD(libs,x)\nEND\n\ncall clsout opds\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of LPALST00 Member.                                 */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n\n/*---------------------------------------------------------*/\n/* JES2 - Startup PROC.                                    */\n/*---------------------------------------------------------*/\n/* Adds a DD statement under the //PROC00 DDNAME for all   */\n/* datasets in @DATASET that have PARM(PROCLIB)            */\n/*---------------------------------------------------------*/\njes2:\nSAY \"Building JES2 PROC.\"\ncall setout opds,'JES2' /* Set output member name.  */\nlibs = xdslist('ZPARMLIB')\nzzparmlib = WORD(libs,1)\n\ncall jcd\ncall jcc \"JES2 Startup PROC.\"\ncall jcc \"Built dynamically by ZCLONE exec, \"mydate()\ncall jcd\ncall jcl \"//JES2     PROC JESPARM=JES2PARM\"\ncall jcl \"//IEFPROC  EXEC PGM=HASJES20,\"\ncall jcl \"//            DPRTY=(15,15),TIME=1440,PERFORM=9\"\ncall jcl \"//HASPPARM DD DISP=SHR,DSN=\"zzparmlib\"(&JESPARM)\"\n\n/* Add PROCLIBs */\nlibs = xdslist('PROCLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//PROC00   DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\ncall jcl \"//*\"\ncall jcl \"//IEFRDER  DD SYSOUT=*\"\ncall jcl \"//*\"\ncall jcl \"//HASPLIST DD DDNAME=IEFRDER\"\ncall jcl \"//*\"\ncall clsout opds,'JES2'\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of JES2 PROC Member.                                */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* JES2PARM - JES2 parameter member.                       */\n/*---------------------------------------------------------*/\n/* Uses the ZJES2PRM member as a model, and adds SPOOLDEF  */\n/* and CKPTDEF statements.  The checkpoint datasets coded  */\n/* are the first one or two datasets that have             */\n/* PARM(HASPCKPT) coded.  The VOLUME= parm of the SPOOLDEF */\n/* statement is derived as follows:  1) Find the first ds  */\n/* in @DATASET that has PARM(HASPACE).  2) The volume that */\n/* this dataset resides on is used as the base for the     */\n/* VOLUME= parm.  The SPOOLPRF parameter coded in @PARMS   */\n/* determines the length of the VOLUEM= parm.  E.g., if    */\n/* SYS1.HASPACE PARM(HASPACE) VOLUME(RESC1A) is coded in   */\n/* @DATASET, AND SPOOLPRF=5 IN @PARMS, THEN VOLUME=RESC1   */\n/* will be the result.                                     */\n/*---------------------------------------------------------*/\njes2parm:\nSAY \"Building JES2 PARMS.\"\ncall setout opds,'JES2PARM'   /* Set output member name.  */\ncall setinp ipds,'ZJES2PRM','JES2PRM.' /* Input member name. */\n\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"/* JES2 Parameter deck.                                  */\"\ncall jcl \"/* Built dynamically by RESCUE exec, \"mydate()\"          */\"\ncall jcl \"/*-------------------------------------------------------*/\"\nckpts = xdslist('HASPCKPT')\nIF WORDS(ckpts)>2 THEN ckptcomma = \",\"\nELSE ckptcomma = \"\"\nckptds = WORD(ckpts,1); ckptvol = WORD(ckpts,2)\ncall jcl \"CKPTDEF  CKPT1=(DSNAME=\"ckptds\",\"\ncall jcl \"         INUSE=YES,VOL=\"ckptvol\")\"ckptcomma\nIF WORDS(ckpts)>2 THEN DO\n   ckptds = WORD(ckpts,3); ckptvol = WORD(ckpts,4)\n   call jcl \"         CKPT2=(DSNAME=\"ckptds\",\"\n   call jcl \"         INUSE=YES,VOL=\"ckptvol\")\"\nEND\n/*-------------------------------------*/\n/* Build SPOOLDEF statement.           */\n/* spoolprf is from @PARMS and is the  */\n/* length of the VOLUME= parm.         */\n/*-------------------------------------*/\nspool = xdslist('HASPACE')\nspoolds = WORD(spool,1); spoolvol = WORD(spool,2)\nIF SYMBOL(\"spoolprf\") /= \"VAR\" THEN spoolprf = 4\nIF DATATYPE(spoolprf) /= \"N\"   THEN spoolprf = 4\nIF spoolprf < 4                THEN spoolprf = 4\nIF spoolprf > 6                THEN spoolprf = 4\nspoolvol = substr(spoolvol,1,spoolprf)\ncall jcl \"SPOOLDEF BUFSIZE=3856,\"\ncall jcl \"         DSNAME=\"spoolds\",\"\ncall jcl \"         FENCE=NO,\"\ncall jcl \"         SPOOLNUM=32,\"\ncall jcl \"         TGBPERVL=5,\"\ncall jcl \"         TGSPACE=(MAX=16288,WARN=80),\"\ncall jcl \"         TGSIZE=33,\"\ncall jcl \"         TRKCELL=5,\"\ncall jcl \"         VOLUME=\"spoolvol\n/*-------------------------------------*/\n/*  Copy rest of parms from JES2PRM.   */\n/*-------------------------------------*/\nDO x = 1 TO JES2PRM.0\n   call jcl JES2PRM.x\nEND\n\ncall clsout opds,'JES2PARM'\nDROP JES2PRM.\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of JES2PARM Member.                                 */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* BPXPRM00 - OMVS Parmlib member.                         */\n/*---------------------------------------------------------*/\n/* Copy model member ZBPXPRM to output member BPXPRM00.    */\n/* Also add to BPXPRM00 mount statements for any OMVS      */\n/* files.                                                  */\n/*---------------------------------------------------------*/\n\n/*=====================================*/\n/*  Build the BPXPRM00 member.         */\n/*=====================================*/\nbpxprm:\nSAY \"Building OMVS PARMLIB member BPXPRM00.\"\ncall setout opds,'BPXPRM00'    /* Set output member name.  */\ncall setinp ipds,'ZBPXPRM','BPXPRM.' /* Input member name. */\n\n/*----------------------------------------*/\n/* Create header and copy model BPXPRM.   */\n/*----------------------------------------*/\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"/* OMVS parameters.                                      */\"\ncall jcl \"/* Built dynamically by RESCUE exec, \"mydate()\"          */\"\ncall jcl \"/*-------------------------------------------------------*/\"\nDO x = 1 TO BPXPRM.0\n   call jcl BPXPRM.x\nEND\ncall jcl \" \"\n\n/*----------------------------------------*/\n/*  Build MOUNT statments for OMVS libs.  */\n/*----------------------------------------*/\nDO y = 1 TO DS.0\n   /*--------------------------------------------------------*/\n   /* Loop through the DS. stem var for any dataset with     */\n   /* a MOUNT() parameter, and create a mount statement.     */\n   /*--------------------------------------------------------*/\n   IF SYMBOL(\"DS.\"y\".MOUNT\") /= \"VAR\" THEN ITERATE\n   IF SYMBOL(\"DS.\"y\".TYPE\")  /= \"VAR\" THEN DS.x.TYPE=\"HFS\"\n   IF SYMBOL(\"DS.\"y\".MODE\")  /= \"VAR\" THEN DS.x.MODE=\"RDWR\"\n   call omvsmnt DS.y.MOUNT,DS.y.DSN\nEND\n\ncall clsout opds,'BPXPRM00'\nDROP BPXPRM.\nRETURN\n\n/* subr. */\nomvsmnt:\nPARSE ARG ##mountpt, ##omvsds\n##mountpt = STRIP(##mountpt,\"B\",\"'\")\nIF ##mountpt = '/'    THEN DO\n   call jcl \"ROOT     FILESYSTEM('\"##omvsds\"')\"\n   call jcl \"         TYPE(HFS)\"\n   call jcl \"         MODE(RDWR)\"\n   call jcl \" \"\nEND\nELSE DO\n   call jcl \"MOUNT    FILESYSTEM('\"##omvsds\"')\"\n   call jcl \"         MOUNTPOINT('\"##mountpt\"')\"\n   call jcl \"         TYPE(HFS)\"\n   call jcl \"         MODE(RDWR)\"\n   call jcl \" \"\nEND\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of BPXPRM00 Parmlib member.                         */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build the TSO STARTUP PROC.        */\n/*=====================================*/\ntso:\n\nSAY \"Building TSO STARTUP PROC\" tsoproc\".\"\ncall setout opds,'TSO'      /* Set output member name.  */\nlibs = xdslist('ZPARMLIB')  /* Get name of our parmlib. */\nzzparmlib = WORD(libs,1)\n\ncall jcd\ncall jcc \"TSO STARTUP PROC\"\ncall jcc \"Built dynamically by ZCLONE exec, \"mydate()\ncall jcd\ncall jcl \"//TSO     PROC MBR=TSOKEY00\"\ncall jcl \"//STEP1   EXEC PGM=IKTCAS00,TIME=1440\"\ncall jcl \"//PARMLIB   DD  DSN=\"zzparmlib\"(&MBR),DISP=SHR,FREE=CLOSE\"\ncall jcl \"//PRINTOUT  DD  SYSOUT=*,FREE=CLOSE\"\ncall jcl \"//*\"\ncall clsout opds,'TSO'\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of TSO STARTUP PROC.                                */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build the TSO LOGON PROC.          */\n/*=====================================*/\ntsoproc:\nIF SYMBOL(\"TSOPROC\") = 'LIT' THEN DO\n   Say \"TSOPROC name not defined in @PARMS member, no TSO PROC created.\"\n   RETURN\nEND\n\nSAY \"Building TSO LOGON PROC\" tsoproc\".\"\n\ncall setout opds,tsoproc    /* Set output member name.  */\n\ncall jcd\ncall jcc \"TSO LOGON PROC: \"tsoproc\".\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\np = substr(tsoproc,1,8)\ncall jcl \"//\"p\" PROC\"\ncall jcl \"//IKJACCNT EXEC PGM=IKJEFT01,DYNAMNBR=200,PARM='%ISPALLOC'\"\n\n/* Add ISPPLIBs */\nlibs = xdslist('ISPPLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//ISPPLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPMLIBs */\nlibs = xdslist('ISPMLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//ISPMLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPSLIBs */\nlibs = xdslist('ISPSLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//ISPSLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPLLIBs */\nlibs = xdslist('ISPLLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//ISPLLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add ISPTLIBs */\nlibs = xdslist('ISPTLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//ISPTLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSPROCs */\nlibs = xdslist('SYSPROC')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//SYSPROC  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSHELPs */\nlibs = xdslist('SYSHELP')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//SYSHELP  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSLBC */\nlibs = xdslist('SYSLBC')\nIF words(libs) > 0 THEN DO\n   call jcl \"//SYSLBC   DD DISP=SHR,DSN=\"WORD(libs,1)\nEND\n\n/* Add MISC LOGON statements. */\n\ncall jcl \"//SYSPRINT DD TERM=TS,SYSOUT=Z\"\ncall jcl \"//SYSTERM  DD TERM=TS,SYSOUT=Z\"\ncall jcl \"//SYSIN    DD TERM=TS \"\n\ncall clsout opds,tsoproc\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of TSOPROC member.                                  */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build the VTAM startup PROC.       */\n/*=====================================*/\nvtamproc:\nSAY \"Building VTAM PROC.\"\ncall setout opds,'VTAM' /* Set output member name.  */\n\ncall jcd\ncall jcc \"VTAM Started procedure.\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\ncall jcl \"//VTAM     EXEC PGM=ISTINM01,REGION=0M,\"\ncall jcl \"//         DPRTY=(15,15),TIME=1440,PERFORM=8\"\n\n/* Add VTAMLSTs */\nlibs = xdslist('VTAMLST')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//VTAMLST  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add VTAMLIBs */\nlibs = xdslist('VTAMLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//VTAMLIB  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\nlibs = xdslist('SISTCLIB')\nIF WORDS(libs) > 0 THEN,\ncall jcl \"//SISTCLIB DD DISP=SHR,DSN=\"WORD(libs,1)\ncall jcl \"//SYSABEND DD SYSOUT=*,HOLD=YES\"\n\ncall clsout opds,'VTAM'\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of VTAM PROC.                                       */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build Master JCL deck (MSTJCL01)   */\n/*=====================================*/\nmstrjcl:\nSAY \"Building MSTJCL01 PARMLIB member.\"\ncall setout opds,'MSTJCL01' /* Set output member name.  */\n\ncall jcl \"//MSTJCL01 JOB MSGLEVEL=(1,1),TIME=1440\"\ncall jcd\ncall jcc \"Master JCL.\"\ncall jcc \"Built dynamically by RESCUE exec, \"mydate()\ncall jcd\ncall jcl \"//         EXEC PGM=IEEMB860,DPRTY=(15,15)\"\ncall jcl \"//STCINRDR DD SYSOUT=(A,INTRDR)\"\ncall jcl \"//TSOINRDR DD SYSOUT=(A,INTRDR)\"\n\n/* Add PROCLIBs */\nlibs = xdslist('PROCLIB')\nDO x = 1 TO WORDS(libs) BY 2\n   IF x = 1 THEN,\n   call jcl \"//IEFPDSI  DD DISP=SHR,DSN=\"WORD(libs,x)\n   ELSE,\n   call jcl \"//         DD DISP=SHR,DSN=\"WORD(libs,x)\nEND\n\n/* Add SYSUADSs */\nlibs = xdslist('SYSUADS')\nIF WORDS(libs) > 0 THEN,\n   call jcl \"//SYSUADS  DD DISP=SHR,DSN=\"WORD(libs,1)\n\n/* Add SYSLBCs */\nlibs = xdslist('SYSLBC')\nIF WORDS(libs) > 0 THEN,\n   call jcl \"//SYSLBC   DD DISP=SHR,DSN=\"WORD(libs,1)\n\ncall clsout opds,'MSTJCL01'\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of MSTRJCL01.                                       */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=========================================================*/\n/* Create IGDSMS member from ZIGDSMS contents plus entries */\n/* for the ACDS and COMMDS files.                          */\n/*=========================================================*/\nigdsms:\n\nSAY \"Building IGDSMS00 SMS PARMLIB member.\"\n/*---------------------------------------------------------*/\n/* If no member found, set stem count to 0 for later, and  */\n/* plan to write output to ZIGDSMS.                        */\n/*---------------------------------------------------------*/\nstat = setinp(ipds,'ZIGDSMS')  /* Open member ZIGDSMS for input. */\nIF stat = 'MEMBER NOT FOUND' THEN DO\n   SAY \"IGDSMS00 not created, model ZIGDSMS not found.\"\n   RETURN\nEND\nlibs1 = xdslist('ACDS')\nlibs2 = xdslist('COMMDS')\nIF WORDS(libs1) = 0 THEN DO\n   SAY \"IGDSMS00 not built -- ACDS must be defined in @DATASET.\"\n   RETURN\nEND\nIF WORDS(libs1) = 0 THEN DO\n   SAY \"IGDSMS00 not built -- COMMDS must be defined in @DATASET.\"\n   RETURN\nEND\n\nsmsacds = WORD(libs1,1)  /* Pick first (hopefully only) ACDS ent. */\nsmscommds = WORD(libs2,1)  /* Pick first (hopefully only) COMM ent. */\n\n/*---------------------------------------------------------*/\n/* Build IGDSMS00 member.                                  */\n/*---------------------------------------------------------*/\ncall setout opds,'IGDSMS00'           /* Write to IGDSMS00  */\n/* Code ACDS and COMMDS to start member.                   */\ncall jcl \"SMS ACDS(\"smsacds\")\"\ncall jcl \"    COMMDS(\"smscommds\")\"\n\n/* Finish member with ZIGDSMS contents.                    */\nDO xx = 1 TO INPUT.0\n   call jcl INPUT.xx\nEND\n\ncall clsout opds\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of IGDSMS00.                                        */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=========================================================*/\n/* Build COUPLE00 member.                                  */\n/*=========================================================*/\ncouple:\n\nSAY \"Building COUPLE00 PARMLIB member.\"\n/*---------------------------------------------------------*/\n/* Build COUPLE00 member.                                  */\n/*---------------------------------------------------------*/\ncall setout opds,'COUPLE00'          /* Write to COUPLE00  */\ncall jcl \"/*-------------------------------------------------------*/\"\ncall jcl \"/* COUPLExx                                              */\"\ncall jcl \"/* Built dynamically by ZCLONE exec, \"mydate()\"          */\"\ncall jcl \"/*-------------------------------------------------------*/\"\nxcflibs  = xdslist('XCF')\nwlmlibs  = xdslist('WLM')\nlogrlibs = xdslist('LOGR')\n\nIF WORDS(xcflibs\" \"wlmlibs\" \"logrlibs) > 0 THEN makecouple = 1\nELSE makecouple = 0\n\n/* If we have no couple datasets, write a SYSPLEX LOCAL stmt.        */\nIF \\makecouple THEN DO\n   call jcl \"COUPLE SYSPLEX(LOCAL)\"\n   RETURN\nEND\n\n/* Otherwise create a couple member with couple datasets.            */\nIF WORDS(xcflibs) > 0 THEN DO\n   call jcl \"    COUPLE SYSPLEX(\"sysplex\")\"\n   DO ##xx = 1 TO WORDS(xcflibs) BY 4\n      zsDSN = WORD(xcflibs,##xx)\n      call jcl \"             PCOUPLE(\"zsDSN\")\"\n      zsDSN = WORD(xcflibs,##xx+2)\n      call jcl \"             ACOUPLE(\"zsDSN\")\"\n   END\nEND\n\nIF WORDS(wlmlibs) > 0 THEN DO\n   call jcl \"        DATA TYPE(WLM)\"\n   DO ##xx = 1 TO WORDS(wlmlibs) BY 4\n      zsDSN = WORD(wlmlibs,##xx)\n      call jcl \"             PCOUPLE(\"zsDSN\")\"\n      zsDSN = WORD(wlmlibs,##xx+2)\n      call jcl \"             ACOUPLE(\"zsDSN\")\"\n   END\nEND\n\nIF WORDS(logrlibs) > 0 THEN DO\n   call jcl \"        DATA TYPE(LOGR)\"\n   DO ##xx = 1 TO WORDS(logrlibs) BY 4\n      zsDSN = WORD(logrlibs,##xx)\n      call jcl \"             PCOUPLE(\"zsDSN\")\"\n      zsDSN = WORD(logrlibs,##xx+2)\n      call jcl \"             ACOUPLE(\"zsDSN\")\"\n   END\nEND\n\ncall clsout opds\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of COUPLE00.                                        */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build the VATLST00 PARMLIB member. */\n/*=====================================*/\nvatlst:\n\nSAY \"Building VATLST00 PARMLIB member\"\ncall setout opds,'VATLST00' /* Set output member name.  */\n\ncall jcl \"VATDEF IPLUSE(PRIVATE),SYSUSE(STORAGE)\"\nDO zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"zz) & \\isblank(\"ADDR\"zz) THEN DO\n      zvolser = VALUE(\"VOLSER\"zz)\n      call jcl zvolser\",1,0,\"DEVTYPE\"    ,Y\"\n   END\nEND\n\ncall clsout opds\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of VATLST00.                                        */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*=====================================*/\n/*  Build the IEASYS00 PARMLIB member. */\n/*=====================================*/\nieasys:\n\nSAY \"Building IEASYS00 PARMLIB member\"\ncall setinp ipds, 'ZIEASYS'\ncall setout opds,'IEASYS00'\nDO xx = 1 TO INPUT.0\n   call jcl INPUT.xx\nEND\n\n/*- - - - - - - - - - - - - - - - - - -*/\n/* PAGE= parameter                     */\n/*- - - - - - - - - - - - - - - - - - -*/\nlibs = xdslist('PGPLPA')   /* Get name of PLPA PAGE ds.   */\nzsDS = WORD(libs,1)\nstmt = \"PAGE=(\"zsDS\",\"\ncall jcl stmt              /* Write it to IEASYS00        */\n\nlibs = xdslist('PGCOMMON') /* Get name of COMMON PAGE ds. */\nzsDS = WORD(libs,1)\nstmt = \"      \"zsDS\",\"\ncall jcl stmt              /* Write it to IEASYS00        */\n\nlibs = xdslist('PGLOCAL')  /* Get name of LOCAL PAGE dsns */\nDO x = 1 TO WORDS(libs) BY 2\n   zsDS = WORD(libs,x)\n   stmt = \"      \"zsDS\",\"\n   IF (x+1) >= WORDS(libs) THEN stmt = stmt\"L,),\"\n   call jcl stmt\nEND\n\n/*- - - - - - - - - - - - - - - - - - -*/\n/* LOGREC= parameter                   */\n/*- - - - - - - - - - - - - - - - - - -*/\nlibs = xdslist('LOGREC')   /* Get name of LOGREC ds.      */\nIF WORDS(libs) > 1 THEN DO\n   zsDS = WORD(libs,1)\n   call jcl \"LOGREC=\"zsDS\",\"\nEND\n\n/*- - - - - - - - - - - - - - - - - - -*/\n/* SYSNAME=parameter                   */\n/*- - - - - - - - - - - - - - - - - - -*/\ncall jcl \"SYSNAME=\"smfid\n\ncall clsinp ipds, 'ZIEASYS'\ncall clsout opds, 'IEASYS00'\n\nRETURN\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of IEASYS00.                                        */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#MISC\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #MISC    - Do various other tasks.                      */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\n/*=========================================================*/\n/* JOB: Misc.                                              */\n/*=========================================================*/\nSay \"Building Job \"jobnum\": Misc. tasks.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\n\ncall logrec           /* Initialize logrec dataset.        */\ncall syncuads         /* SYNC UADS ds.                     */\ncall dumpfmt          /* Format DUMP datasets.             */\ncall couple           /* Couple datasets.                  */\n\n/*---------------------------------------------------------*/\n/* COUPLEnn member:  For now, we only support operation    */\n/* in sysplex-local mode using   COUPLE SYSPLEX(LOCAL)     */\n/*---------------------------------------------------------*/\n/* call couple    */       /* Create couple datasets.           */\n\ncall clsout opds,'JOB'jobnum\nRETURN\n\n/*---------------------------------------------------------*/\n/* Format LOGREC dataset.                                  */\n/*---------------------------------------------------------*/\nlogrec:\nlibs = xdslist('LOGREC')\nIF WORDS(libs) > 0 THEN DO\n   logrec = WORD(libs,1)\n   volser = WORD(libs,2)\nEND\nELSE logrec = \"\"\n\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"LOGREC  - Format LOGREC dataset.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\n/* Format LOGREC dataset if any entry in @dataset was found with */\n/* the LOGREC parm coded.    */\nzzssa = getssa(logrec)\nIF logrec /= \"\" THEN DO\n   call jcc \"LOGREC  - Format the LOGREC dataset.\"\n   call jcd\n   call jcl \"//LOGREC   EXEC PGM=IFCDIP00\"\n   call jcl \"//SERERDS  DD DISP=SHR,DSN=\"zzssa\"\"logrec\",\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\n   call jcl \"//*\"\nEND\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* SYNC UADS if SYSUADS and SYSLBC datasets were found in  */\n/* @DATASET.                                               */\n/*---------------------------------------------------------*/\nsyncuads:\nlibs = xdslist('SYSUADS')\nIF WORDS(libs) > 0 THEN sysuads = WORD(libs,1)\nELSE sysuads = \"\"\nlibs = xdslist('SYSLBC')\nIF WORDS(libs) > 0 THEN syslbc = WORD(libs,1)\nELSE syslbc = \"\"\nIF sysuads = \"\" | syslbc = \"\" THEN DO\n   Say \"SYSUADS and SYSLBC datasets not defined in @DATASET-Exiting.\"\n   RETURN\nEND\n\n/* Found the SYSUADS and SYSLBC, so build the SYNC JCL. */\nlibs = xdslist('SYSUADS')\nuadsvolser = WORD(libs,2)\nlibs = xdslist('SYSLBC')\nlbcvolser = WORD(libs,2)\nzzssa = getssa(sysuads)\ncall jcd\ncall jcc \"SYNCUADS - Sync UADS / Brodcast dataset.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//SYNCUADS EXEC PGM=IKJEFT01,DYNAMNBR=15 \"\ncall jcl \"//SYSPRINT DD SYSOUT=* \"\ncall jcl \"//SYSIN    DD DUMMY \"\ncall jcl \"//SYSUADS  DD DISP=SHR,DSN=\"zzssa\"\"sysuads\",\"\ncall jcl \"//         UNIT=\"devtype\",VOL=SER=\"uadsvolser\nzzssa = getssa(syslbc)\ncall jcl \"//SYSLBC   DD DISP=SHR,DSN=\"zzssa\"\"syslbc\",\"\ncall jcl \"//         UNIT=\"devtype\",VOL=SER=\"lbcvolser\ncall jcl \"//SYSTSPRT DD SYSOUT=* \"\ncall jcl \"//SYSTSIN  DD * \"\ncall jcl \"  ACCOUNT       \"\ncall jcl \"  SYNC          \"\ncall jcl \"  END           \"\ncall jcl \"//*\"\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* JCL to format any DUMP datasets found in @DATASET.      */\n/*---------------------------------------------------------*/\ndumpfmt:\nlibs = xdslist('DUMP')\nIF WORDS(libs) = 0 THEN DO\n   Say \"No DUMP datasets found in @DATASET - None will be formatted.\"\n   RETURN\nEND\n\n/* Found some dump datasets, so format them.        */\ncall jcd\ncall jcc \"FMTDUMP  - Format DUMP datasets.\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\n\nDO xx = 1 TO WORDS(libs) BY 2\n   dmpds = WORD(libs,xx)\n   volser = WORD(libs,xx+1)\n   zzssa = getssa(dmpds)\n   call jcl \"//DMPINT0 EXEC PGM=IEBGENER\"\n   call jcl \"//SYSPRINT DD SYSOUT=*\"\n   call jcl \"//SYSIN    DD DUMMY\"\n   call jcl \"//SYSUT1   DD DUMMY,\"\n   call jcl \"//         LRECL=4160,BLKSIZE=4160,RECFM=FB,DSORG=PS\"\n   call jcl \"//SYSUT2   DD DSN=\"zzssa\"\"dmpds\",DISP=SHR,\"\n   call jcl \"//         UNIT=\"devtype\",VOL=SER=\"volser\n   call jcl \"//*\"\nEND\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* JCL  to create XCF, WLM and LOGR couple datasets.       */\n/*---------------------------------------------------------*/\ncouple:\nxcflibs  = xdslist('XCF')\nwlmlibs  = xdslist('WLM')\nlogrlibs = xdslist('LOGR')\n\nIF WORDS(xcflibs\" \"wlmlibs\" \"logrlibs) > 0 THEN makecouple = 1\nELSE makecouple = 0\n\n/* If we have couple datasets to make, write JCL.   */\nIF makecouple THEN DO\n   call jcd\n   call jcc \"COUPLE - Create XCF, WLM and LOGR datasets.\"\n   call jcd\n   call jcc mydate()\" \"comment\n   call jcd\n   call jcl \"//ALCCDS   EXEC PGM=IXCL1DSU\"\n   call jcl \"//STEPLIB   DD DSN=SYS1.MIGLIB,DISP=SHR\"\n   call jcl \"//SYSPRINT DD SYSOUT=*\"\n   call jcl \"//SYSIN     DD *\"\nEND\n\nDO ##xx = 1 TO WORDS(xcflibs) BY 2\n   dsn = WORD(xcflibs,##xx); volser = WORD(xcflibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \"    DATA TYPE(SYSPLEX)\"\n   call jcl \"       ITEM NAME(GROUP)    NUMBER(50)\"\n   call jcl \"       ITEM NAME(MEMBER)   NUMBER(100)\"\n   call jcl \"       ITEM NAME(GRS)      NUMBER(1)\"\nEND\n\nDO ##xx = 1 TO WORDS(wlmlibs) BY 2\n   dsn = WORD(wlmlibs,##xx); volser = WORD(wlmlibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \" DATA TYPE(WLM)\"\n   call jcl \"      ITEM NAME(APPLENV) NUMBER(100)\"\n   call jcl \"      ITEM NAME(POLICY) NUMBER(10)  \"\n   call jcl \"      ITEM NAME(SCHENV) NUMBER(100) \"\n   call jcl \"      ITEM NAME(SRVCLASS) NUMBER(30)\"\n   call jcl \"      ITEM NAME(SVAEAEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVDCREXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVDEFEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVSEAEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(WORKLOAD) NUMBER(35)\"\nEND\n\n\nDO ##xx = 1 TO WORDS(logrlibs) BY 2\n   dsn = WORD(logrlibs,##xx); volser = WORD(logrlibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \"    DATA TYPE(LOGR)\"\n   call jcl \"         ITEM NAME(LSR) NUMBER(10)\"\n   call jcl \"         ITEM NAME(LSTRR) NUMBER(10)\"\n   call jcl \"         ITEM NAME(DSEXTENT) NUMBER(10)\"\nEND\n\n\nRETURN\n\n/*---------------------------------------------------------*/\n/* JCL  to create TSO ALIASES.                             */\n/*---------------------------------------------------------*/\ntsoalias:\nIF isblank('tsoid1') THEN DO\n   call qu 1,'Warning: TSOID1 not defined.'\n   RETURN\nEND\n\nxcflibs  = xdslist('XCF')\nwlmlibs  = xdslist('WLM')\nlogrlibs = xdslist('LOGR')\n\nIF WORDS(xcflibs\" \"wlmlibs\" \"logrlibs) > 0 THEN makecouple = 1\nELSE makecouple = 0\n\n/* If we have couple datasets to make, write JCL.   */\nIF makecouple THEN DO\n   call jcd\n   call jcc \"COUPLE - Create XCF, WLM and LOGR datasets.\"\n   call jcd\n   call jcc mydate()\" \"comment\n   call jcd\n   call jcl \"//ALCCDS   EXEC PGM=IXCL1DSU\"\n   call jcl \"//STEPLIB   DD DSN=SYS1.MIGLIB,DISP=SHR\"\n   call jcl \"//SYSPRINT DD SYSOUT=*\"\n   call jcl \"//SYSIN     DD *\"\nEND\n\nDO ##xx = 1 TO WORDS(xcflibs) BY 2\n   dsn = WORD(xcflibs,##xx); volser = WORD(xcflibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \"    DATA TYPE(SYSPLEX)\"\n   call jcl \"       ITEM NAME(GROUP)    NUMBER(50)\"\n   call jcl \"       ITEM NAME(MEMBER)   NUMBER(100)\"\n   call jcl \"       ITEM NAME(GRS)      NUMBER(1)\"\nEND\n\nDO ##xx = 1 TO WORDS(wlmlibs) BY 2\n   dsn = WORD(wlmlibs,##xx); volser = WORD(wlmlibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \" DATA TYPE(WLM)\"\n   call jcl \"      ITEM NAME(APPLENV) NUMBER(100)\"\n   call jcl \"      ITEM NAME(POLICY) NUMBER(10)  \"\n   call jcl \"      ITEM NAME(SCHENV) NUMBER(100) \"\n   call jcl \"      ITEM NAME(SRVCLASS) NUMBER(30)\"\n   call jcl \"      ITEM NAME(SVAEAEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVDCREXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVDEFEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(SVSEAEXT) NUMBER(5) \"\n   call jcl \"      ITEM NAME(WORKLOAD) NUMBER(35)\"\nEND\n\n\nDO ##xx = 1 TO WORDS(logrlibs) BY 2\n   dsn = WORD(logrlibs,##xx); volser = WORD(logrlibs,##xx+1)\n   call jcl \" \"\n   call jcl \"  DEFINEDS SYSPLEX(\"sysplex\")\"\n   call jcl \"       DSN(\"ssa\"\"dsn\")\"\n   call jcl \"       VOLSER(\"volser\")\"\n   call jcl \"       MAXSYSTEM(8)\"\n   call jcl \"       CATALOG\"\n   call jcl \"    DATA TYPE(LOGR)\"\n   call jcl \"         ITEM NAME(LSR) NUMBER(10)\"\n   call jcl \"         ITEM NAME(LSTRR) NUMBER(10)\"\n   call jcl \"         ITEM NAME(DSEXTENT) NUMBER(10)\"\nEND\n\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#RFDSNT\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #RFDSNT - RACF Dataset Name Table (ICHRDSNT)            */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\nIF rfdsnt /= 'YES' THEN DO\n   Say \"RFDSNT parameter not specified - ICHRDSNT assembly not created.\"\n   RETURN\nEND\n\ncall makedsnt         /* Build the DSN table.              */\ncall iealpa           /* Build MLPA member to use ICHRDSNT.*/\n\nexit\n\n/*=========================================================*/\n/* JOB: RACF Dataset Name Table (ICHRDSNT)                 */\n/*=========================================================*/\nmakedsnt:\n\nSay \"Building Job \"jobnum\": Assemble ICHRDSNT table.\"\nlibs = xdslist('ZLINKLIB') /* Get ds info for RESCUE.LINKLIB. */\nds = WORD(libs,1); volume = WORD(libs,2)\nlibs = xdslist('RACFDS')  /* Get ds info for RACF DS.        */\nracfds = WORD(libs,1)\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFDSNT   - Assemble RACF dataset name table (ICHRDSNT)\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',\"\ncall jcl \"// PARM.L='SIZE=(320K,250K)' \"\ncall jcl \"//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR \"\ncall jcl \"//         DD  DSN=SYS1.MODGEN,DISP=SHR \"\ncall jcl \"//SYSIN    DD  * \"\ncall jcl \"ICHRDSNT CSECT \"\ncall jcl \"         DC    AL1(1)             NUMBER OF RACF DATA\"\ncall jcl \"         DC    CL44'\"racfds\"'     RACF PRIMARY DATASET\"\ncall jcl \"         DC    CL44' '            RACF BACKUP DATASET\"\ncall jcl \"         DC    AL1(255)           RESIDENT INDEX BLKS\"\ncall jcl \"         DC    XL1'81'            DUPLICATE ALL EXCEPT\"\ncall jcl \"         END\"\ncall jcl \"//L.SYSLMOD     DD DSN=\"ssa\"\"ds\",DISP=SHR,\"\ncall jcl \"//  UNIT=\"devtype\",VOL=SER=\"volume\ncall jcl \"//L.SYSIN       DD *\"\ncall jcl \"  NAME ICHRDSNT(R) \"\n\ncall clsout opds,'JOB'jobnum\nRETURN\n\n/*=========================================================*/\n/* Create IEALPA member from ZIEALPA contents plus an      */\n/* entry we'll build for ICHRDSNT.                         */\n/*=========================================================*/\niealpa:\nlibs = xdslist('ZLINKLIB')   /* Get ds info for ZCLONE LINKLIB. */\nds = WORD(libs,1); volume = WORD(libs,2)\nsrch = \"ICHRDSNT\"\ntxt = \"INCLUDE LIBRARY(\"ds\") MODULES( ICHRDSNT )\"\ncall InsertIntoMember ipds,'ZIEALPA',opds,'IEALPA00',txt,srch,1\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#RFSTC\n/*---------------------------------------------------Rexx--*/\n/* ZCLONE  - Build JCL and other elements for cloning a    */\n/*           z/OS system.                                  */\n/*---------------------------------------------------------*/\n/* #RFSTC  - RACF Started Task Table (ICHRIN03)            */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\nARG jobnum ipds opds zzprms .\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\ncall parse_dataset\n\nIF rfstc /= 'YES' THEN DO\n   Say \"RFSTC parameter not specified - ICHRIN03 assembly not created.\"\n   RETURN\nEND\n\ncall makestc          /* Build the STC table.              */\ncall iealpa           /* Build MLPA member to use ICHRIN03.*/\ncall defids           /* Create RACF groups/IDs as needed. */\n\nexit\n\n/*=========================================================*/\n/* JOB: RACF Started Task Table (ICHRDSNT)                 */\n/*=========================================================*/\nmakestc:\n\nSay \"Building Job \"jobnum\": Assemble ICHRIN03 table.\"\nlibs = xdslist('RLINK')   /* Get ds info for RESCUE.LINKLIB. */\nds = WORD(libs,1); volser = WORD(libs,2)\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFDSNT   - Assemble RACF Started Task Table (ICHRIN03)\"\ncall jcd\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//STEP1    EXEC ASMACL,PARM.C='OBJECT,NODECK',\"\ncall jcl \"// PARM.L='SIZE=(320K,250K)' \"\ncall jcl \"//C.SYSLIB DD  DSN=SYS1.MACLIB,DISP=SHR \"\ncall jcl \"//         DD  DSN=SYS1.MODGEN,DISP=SHR \"\ncall jcl \"//SYSIN    DD  * \"\ncall jcl \"ICHRIN03 CSECT                                               \"\ncall jcl \"TABSTART DC    AL2(NUMENTR)              NUMBER OF ENTRIES   \"\n\nprivflag = \"X'8000000000000000'\"\nstdflag  = \"X'0000000000000000'\"\n\n/*------------------------------------------------------------------*/\n/* Use STC's from @PARMS.  RFSTCx = VTAM, $RESCUE, $STC             */\n/* p1 = Task name, p2 = RACF ID, p3 = RACF Grp.                     */\n/*------------------------------------------------------------------*/\nstc.0 = 0\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   PARSE VAR ent zztask ',' zzid ',' zzgrp .\n   zztask = strip(zztask,\"B\")\n   zzid = strip(zzid,\"B\")\n   zzgrp  = strip(zzgrp,\"B\")\n   stc.xx = substr(zztask,1,8)\"\"substr(zzid,1,8)\"\"substr(zzgrp,1,8)\nEND\nstc.0 = xx-1\n/*------------------------------------------------------------------*/\n/* Loop through the entries we've built, and put them in DC stmts.  */\n/* Assume trusted and priviledged for all defined tasks.            */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO stc.0\n   call jcl \"         DC    C'\"stc.xx\"',\"privflag\nEND\n/*------------------------------------------------------------------*/\n/* Finish up the source for the table, and the rest of the JCL.     */\n/*------------------------------------------------------------------*/\ncall jcl \"         DC    C'*       =       STC     ',\"stdflag\ncall jcl \"NUMENTR  EQU   (*-TABSTART-2)/32+X'8000'\"\ncall jcl \"         DC    C'&SYSDATE' \"\ncall jcl \"         DC    C'&SYSTIME' \"\ncall jcl \"         END \"\ncall jcl \"//L.SYSLMOD     DD DSN=\"ssa\"\"ds\",DISP=SHR,\"\ncall jcl \"//  UNIT=SYSALLDA,VOL=SER=\"volser\ncall jcl \"//L.SYSIN       DD *\"\ncall jcl \"  NAME ICHRIN03(R) \"\n\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*=========================================================*/\n/* Create IEALPA member from ZIEALPA contents plus an      */\n/* entry we'll build for ICHRIN03.                         */\n/*=========================================================*/\niealpa:\nlibs = xdslist('ZLINKLIB')   /* Get ds info for RESCUE.LINKLIB. */\nds = WORD(libs,1); volume = WORD(libs,2)\nsrch = \"ICHRIN03\"\ntxt = \"INCLUDE LIBRARY(\"ds\") MODULES( ICHRIN03 )\"\ncall InsertIntoMember ipds,'ZIEALPA',opds,'IEALPA00',txt,srch,1\n\nRETURN\n\n/*=========================================================*/\n/* JOB: Define RACF IDs needed for RESCUE system.          */\n/* JOB: ID submitting job mist have RACF SPECIAL.          */\n/*=========================================================*/\ndefids:\n\nSay \"Building Job \"jobnum\": Define RACF IDs and Groups for STCs.\"\ncall setout opds,'JOB'jobnum\ncall jobcard jobnum\ncall jcd\ncall jcc \"Job \"jobnum\ncall jcd\ncall jcc \"RFSTCDEF - Create RACF IDs and groups for started tasks.\"\ncall jcd\n/*---------------------------------------------------------*/\n/* Be sure we have RACF special.                           */\n/*---------------------------------------------------------*/\nIF \\racfspec() THEN DO\n   call jcc \"*** NOTE: ***\"\n   call jcc \"Userid \"USERID()\" was used to build this job, but does \"\n   call jcc \"not have the RACF SPECIAL attribute.  If \"USERID()\" is \"\n   call jcc \"used to run this job, it should first be granted the   \"\n   call jcc \"SPECIAL attribute or the equivalent specific privileges \"\n   call jcc \"needed be to run successfully. RACF violations will  \"\n   call jcc \"result if this is not done.\"\n   call jcd\nEND\nELSE DO\n   call jcc \"NOTE: Be sure that the ID used to run this job has the\"\n   call jcc \"RACF SPECIAL attribute, or the equivalent specific    \"\n   call jcc \"privileges required.\"\n   call jcd\nEND\ncall jcc mydate()\" \"comment\ncall jcd\ncall jcl \"//TSO      EXEC PGM=IKJEFT01,REGION=4M\"\ncall jcl \"//SYSPRINT DD SYSOUT=*\"\ncall jcl \"//SYSIN    DD DUMMY   \"\ncall jcl \"//SYSTSPRT DD SYSOUT=*\"\ncall jcl \"//SYSTSIN  DD *\"\n\n/*------------------------------------------------------------------*/\n/* Delete RACF IDs and Groups.                                      */\n/*------------------------------------------------------------------*/\n/* Use RFSTCx parms from @PARMS to get userids to be defined.       */\n/* Delete each GROUP and ID first, but only if they are not already */\n/* defined to the driving system.                                   */\n/* jobs to be re-run if desired.                                    */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Delete ID if needed. */\n   IF ckstcid(zzid) THEN DO\n      c1 = \" DELUSER  \"zzid\n      IF \\idthere(zzid) THEN DO\n         call jcl \" \"\n         call jcl c1\n      END\n      ELSE DO\n      /* Comment out the commands, because the ID was already there. */\n         SAY zzid\" is already defined to RACF, and was not deleted.\"\n         call jcl \" \"\n         e1  = \" \"zzid\" is already defined to RACF, and was\"\n         e2  = \" not deleted.  Select an ID that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n      END\n   END\nEND\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Delete group if needed. */\n   IF ckstcgrp(zzgrp) THEN DO\n      c1 = \" DELGROUP \"zzgrp\n      IF \\grpthere(zzgrp) THEN DO\n         call jcl \" \"\n         call jcl c1\n      END\n      ELSE DO\n         SAY zzgrp\" is already defined to RACF, and was not deleted.\"\n         call jcl \" \"\n         e1  = \" \"zzgrp\" is already defined to RACF, and was\"\n         e2  = \" not deleted.  Select a Group that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n      END\n   END\nEND\nDROP STCID.\nDROP STCGRP.\n\n/*------------------------------------------------------------------*/\n/* Define RACF IDs and Groups.                                      */\n/*------------------------------------------------------------------*/\n/* Use RFSTCx parms from @PARMS to get userids to be defined.       */\n/* Define each group and user as needed, but only if they are not   */\n/* defined yet. Code a DELGROUP and DELUSER statement to allow the  */\n/* jobs to be re-run if desired.                                    */\n/*------------------------------------------------------------------*/\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Define group if needed. */\n   IF ckstcgrp(zzgrp) THEN DO\n      c1 = \" ADDGROUP \"zzgrp\" OWNER(SYS1) SUP(SYS1) +\"\n      c2 = \" OMVS(gid(0))\"\n      IF \\grpthere(zzgrp) THEN DO\n         call jcl \" \"\n         call jcl c1\n         call jcl c2\n      END\n      ELSE DO\n         SAY zzgrp\" is already defined to RACF, and was not created.\"\n         call jcl \" \"\n         e1  = \" \"zzgrp\" is already defined to RACF, and was\"\n         e2  = \" not created.  Select a Group that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c2,1,60)\" */\"\n      END\n   END\nEND\nDO xx = 1 TO 99\n   IF VALUE(\"RFSTC\"xx) = \"RFSTC\"xx THEN LEAVE\n   ent = VALUE(\"RFSTC\"xx)\n   ent = translate(ent,' ',',')\n   PARSE VAR ent zztask zzid zzgrp .\n   zztask = strip(zztask,\"B\"); zzid = strip(zzid,\"B\");\n   zzgrp  = strip(zzgrp,\"B\")\n   /* Define ID if needed. */\n   IF ckstcid(zzid) THEN DO\n      c1 = \" ADDUSER  \"zzid\" OWNER(SYS1) DFLTGRP(\"zzgrp\") +\"\n      c2 = \" OPERATIONS NOPASSWORD NAME('Rescue System') + \"\n      c3 = \" OMVS(uid(0) home('/') program('/bin/sh') )\"\n      IF \\idthere(zzid) THEN DO\n         call jcl \" \"\n         call jcl c1\n         call jcl c2\n         call jcl c3\n      END\n      ELSE DO\n      /* Comment out the commands, because the ID was already there. */\n         SAY zzid\" is already defined to RACF, and was not created.\"\n         call jcl \" \"\n         e1  = \" \"zzid\" is already defined to RACF, and was\"\n         e2  = \" not created.  Select an ID that does not\"\n         e3  = \" already exist, and change the RFSTC statements\"\n         e4  = \" in the @PARMS member and rerun the rescue execs.\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(e1,1,60)\" */\"\n         call jcl \" /*\"substr(e2,1,60)\" */\"\n         call jcl \" /*\"substr(e3,1,60)\" */\"\n         call jcl \" /*\"substr(e4,1,60)\" */\"\n         call jcl \" /*\"substr(\"\",1,61,'-')\"*/\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c1,1,60)\" */\"\n         call jcl \" /*\"substr(c2,1,60)\" */\"\n         call jcl \" /*\"substr(c3,1,60)\" */\"\n      END\n   END\nEND\n\n/*-------------------------------------------*/\n/*- Define the TSO PROC to RACF             -*/\n/*-------------------------------------------*/\ncall jcl \" \"\ncall jcl \" RDEFINE TSOPROC \"tsoproc\" UACC(READ)\"\ncall jcl \" RALTER  TSOPROC \"tsoproc\" UACC(READ)\"\ncall jcl \" SETROPTS RACLIST(TSOPROC) REFRESH\"\ncall jcl \" \"\n\ncall clsout opds,'JOB'jobnum\n\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- Program specific functions ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/*-ckstcid - Check if we need to process     */\n/*-this stc id.  If not, return 0.  If so,   */\n/*-return 1.                                 */\n/*-------------------------------------------*/\nckstcid:\nARG ##id\nIF STCID.0 = \"STCID.0\" THEN stcid.0 = 0\nDO ##x = 1 TO stcid.0\n   IF ##id = stcid.##x THEN RETURN 0\nEND\n##x34 = stcid.0\n##x34 = ##x34 + 1\nstcid.0 = ##x34\nstcid.##x34 = ##id\nRETURN 1\n\nckstcgrp:\nARG ##grp\nIF STCGRP.0 = \"STCGRP.0\" THEN stcgrp.0 = 0\nDO ##x = 1 TO stcgrp.0\n   IF ##grp = stcgrp.##x THEN RETURN 0\nEND\n##x34 = stcgrp.0\n##x34 = ##x34 + 1\nstcgrp.0 = ##x34\nstcgrp.##x34 = ##grp\nRETURN 1\n\n/*---------------------------------------------------------*/\n/* idisthere  - Says if a RACF ID is defined.              */\n/* grpisthere - Says if a RACF ID is defined.              */\n/*---------------------------------------------------------*/\nidthere:\nARG ##id\nx = outtrap('list.',1)\n\"LU \"##id\n cc = rc\nx = outtrap('OFF')\nRETURN (cc = 0)\n\ngrpthere:\nARG ##grp\nx = outtrap('list.',1)\n\"LG \"##grp\n cc = rc\nx = outtrap('OFF')\nRETURN (cc = 0)\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=#VALIDAT\n/*---------------------------------------------------Rexx--*/\n/* VALIDAT - Validate the @PARMS and @DATASET members.     */\n/*---------------------------------------------------------*/\n/* This member attempts to find problems with the PARMS    */\n/* and DATASET members that would cause problems with the  */\n/* build.                                                  */\n/*---------------------------------------------------------*/\n/* 07/16/2007 John C. Miller                               */\n/*---------------------------------------------------------*/\nARG ipds opds zzprms .\n\nIF \\varinit() THEN RETURN 1 /* Read parms, initialize vars. */\n\nhas_errors = 0\n\nIF VALIDPARMS = 'NO' THEN DO\n   call qu 1,,\n   '--------------------- Validity Checking Bypassed -----------------'\n   call qu 1,\"\"\n   return has_errors\nEND\n\ncall parse_dataset     /* Parse dataset list.              */\n\n/*---------------------------------------------------------*/\n/* PARMS                                                   */\n/*---------------------------------------------------------*/\nheading='PARMS'\ncall qu 1,,\n'---------------------- Starting validation -----------------------'\n/*-----------*/\n/* JOBCARDx  */\n/*-----------*/\nIF isblank('jobcard1') THEN DO\n   has_errors = 1\n   call qu 1,'Error: JOBCARD'\n   call qu 1,,\n   'JOBCARD1 must be a valid JOB statement.  JOBCARD2-10 are optional'\n   call qu 1,' '\nEND\n\n/*-----------*/\n/* TSOPROC   */\n/*-----------*/\nIF isblank('tsoproc') THEN DO\n   has_errors = 1\n   call qu 1,'Error: TSOPROC'\n   call qu 1,,\n   'TSOPROC must be a valid TSO PROC name.'\n   call qu 1,' '\nEND\n\n/*-----------*/\n/* TSOIDS    */\n/*-----------*/\nIF isblank('tsoid1') THEN DO\n   has_errors = 1\n   call qu 1,'Error: TSOID'\n   call qu 1,,\n   'You must specify at least one TSO Userid in the TSOID1 parm field.'\n   call qu 1,' '\nEND\n\n/*-----------*/\n/* DEVTYPE   */\n/*-----------*/\nIF isblank('devtype') THEN DO\n   has_errors = 1\n   call qu 1,'Error: DEVTYPE'\n   call qu 1,,\n   'You must specify a valid generic (e.g. 3390, 3390, etc.) in the'\n   call qu 1,,\n   'DEVTYPE field.  You can also specify a valid esoteric (e.g. SYSDA)'\n   call qu 1,,\n   'if defined on your system.'\n   call qu 1,' '\nEND\n\n/*-----------*/\n/* VOLSERnn  */\n/* ADDRnn    */\n/*-----------*/\nIF SYMBOL(\"VOLSER1\") /= \"VAR\" | VALUE(\"VOLSER1\") = \"\" THEN DO\n   has_errors = 1\n   call qu 1,'Error: VOLSER'\n   call qu 1,,\n   'At least one VOLSER/ADDR pair (VOLSER1/ADDR1) is required.'\nEND\nIF SYMBOL(\"ADDR1\") /= \"VAR\" | VALUE(\"ADDR1\") = \"\" THEN DO\n   has_errors = 1\n   call qu 1,'Error: VOLSER'\n   call qu 1,,\n   'At least one VOLSER/ADDR pair (VOLSER1/ADDR1) is required.'\nEND\nDO y = 1 TO 99\n   IF \\isblank(\"VOLSER\"y) THEN DO\n      zzvol = VALUE(\"VOLSER\"y)\n      IF LENGTH(zzvol) > 6 THEN DO\n         has_errors = 1\n         call qu 1,'Error: VOLSER'\n         call qu 1,,\n         '   VOLSER'y' value 'zzvol' must be less than 6 chars.'\n         call qu 1,\" \"\n      END\n      IF isblank(\"ADDR\"y) THEN DO\n         has_errors = 1\n         call qu 1,'Error: ADDR'\n         call qu 1,,\n         '   VOLSER'y' was specified, but ADDR'y' was also needed. '\n         call qu 1,\" \"\n      END\n   END\nEND\nDO y = 1 TO 99\n   IF \\isblank(\"ADDR\"y) THEN DO\n      zzadr = VALUE(\"ADDR\"y)\n      IF LENGTH(zzadr) > 4 THEN DO\n         has_errors = 1\n         call qu 1,'Error: ADDR'\n         call qu 1,,\n         'ADDR'y' value 'zzadr' invalid.  Must be less than 5 chars.'\n         call qu 1,\" \"\n      END\n      IF isblank(\"VOLSER\"y) THEN DO\n         has_errors = 1\n         call qu 1,'Error: VOLSER'\n         call qu 1,,\n         '   ADDR'y' was specified, but VOLSER'y' was also needed. '\n         call qu 1,\" \"\n      END\n   END\nEND\n\n/*-----------*/\n/* Assorted  */\n/*-----------*/\nIF isblank('ioconfigid') THEN DO\n   has_errors = 1\n   call qu 1,'Error: IOCONFIGID'\n   call qu 1,,\n   '   IOCONFIGID must have coded one of the valid system config'\n   call qu 1,,\n   '   values as defined in your IODF.  Use HCD option 1.1 to see   '\n   call qu 1,,\n   '   what system config values are defined in an IODF file.'\n   call qu 1,\" \"\nEND\n\nIF isblank('smfid') THEN DO\n   has_errors = 1\n   call qu 1,'Error: SMFID'\n   call qu 1,,\n   'SMFID must have coded the 4 character SMF ID of your choosing.'\n   call qu 1,\" \"\nEND\n\nIF isblank('newmcat') THEN DO\n   has_errors = 1\n   call qu 1,'Error: NEWMCAT'\n   call qu 1,,\n   'NEWMCAT must have coded the name of the new RESCUE system master'\n   call qu 1,,\n   'catalog.'\n   call qu 1,\" \"\nEND\n\nIF isblank('oldmcat') THEN DO\n   has_errors = 1\n   call qu 1,'Error: OLDMCAT'\n   call qu 1,,\n   'OLDMCAT must have coded the name of the driving system master'\n   call qu 1,,\n   'catalog. '\n   call qu 1,\" \"\nEND\n\nIF isblank('sysres') THEN DO\n   has_errors = 1\n   call qu 1,'Error: SYSRES'\n   call qu 1,,\n   'SYSRES must have coded the volser of your IPL volume.'\n   call qu 1,\" \"\nEND\n\n/*---------------------------------------------------------*/\n/* JES2                                                    */\n/*---------------------------------------------------------*/\n\n/*----------*/\n/* SPOOLPRF */\n/*----------*/\nIF isblank(\"spoolprf\") THEN DO\n   call qu 1,,\n   'Warning: SPOOLPRF:'\n   call qu 1,,\n   '   SPOOLPRF Value not coded in @PARMS, using a value of 4.'\n   call qu 1,\"\"\nEND\nIF spoolprf < 4 | spoolprf > 6 THEN DO\n   call qu 1,,\n   'Warning: SPOOLPRF:'\n   call qu 1,,\n   '   SPOOLPRF value must be 4 through 6. Using a value of 4.'\n   call qu 1,\"\"\nEND\n\n/*----------*/\n/* HASPCKPT */\n/*----------*/\nlibs = xdslist('HASPCKPT')\nIF WORDS(libs) = 0 THEN DO\n   has_errors = 1\n   call qu 1,'Error: HASPCKPT'\n   call qu 1,,\n   '   No HASCKPT dataset has been defined. Make sure you have at least'\n   call qu 1,,\n   '   one JES2 CKPT dataset defined in the @DATASET member, and that'\n   call qu 1,,\n   '   it has PARM(HASPCKPT) on the entry.'\n   call qu 1,' '\nEND\nIF WORDS(libs) > 4 THEN DO\n   call qu 1,'Warning: HASPCKPT'\n   call qu 1,,\n   '   More than two JES2 CKPT datasets were defined.  The first two '\n   call qu 1,,\n   '   datasets will be defined as CKPT1 and CKPT2 respectively, and'\n   call qu 1,,\n   '   others will be defined as specified, but not used as JES2 CKPT '\n   call qu 1,,\n   'datasets.'\n   call qu 1,' '\nEND\n\n/*---------------------------------------------------------*/\n/* Analyze the @DATASET member for:                        */\n/* - Make sure datasets exist when necessary;              */\n/* - Make sure a defined volume for a ds exists.           */\n/*---------------------------------------------------------*/\ndscheck1:\nDO ###xx = 1 TO DS.0\n   /*--------------------------------------------------*/\n   /* If DATASET ALLOC coded, be sure SPACE is coded   */\n   /* and either MODEL or DCB is coded.                */\n   /*--------------------------------------------------*/\n   IF DS.###xx.verb = \"DATASET\" & DS.###xx.option = \"ALLOC\" THEN DO\n      zzDSN  = DS.###xx.DSN\n      zbDCB  = (SYMBOL(\"DS.\"###xx\".DCB\")   = \"VAR\")\n      zbMOD  = (SYMBOL(\"DS.\"###xx\".MODEL\") = \"VAR\")\n      zbSPA  = (SYMBOL(\"DS.\"###xx\".SPACE\") = \"VAR\")\n      zbSMF  = hasParms(\"SMF\",DS.###xx.PARM)\n      zbLOGR = hasparms(\"WLM LOGR XCF\",DS.###xx.PARM)\n      zzEXCEPTIONS = \"STGINDEX PGPLPA PGCOMMON PGLOCAL\"\n      zbPAG = hasParms(zzEXCEPTIONS,DS.###xx.PARM)\n      IF \\(zbSPA | zbLOGR) THEN DO\n         call qu 1,'Error: 'zzdsn\n         call qu 1,,\n         '   SPACE not coded for an ALLOC only dsn.'\n         call qu 1,\" \"\n         has_errors = 1\n      END\n      IF \\(zbMOD | zbDCB | zbSMF | zbPAG | zbLOGR) THEN DO\n         call qu 1,'Error: 'zzdsn\n         call qu 1,,\n         '   Either MODEL or DCB must be coded for ALLOC only dsn.'\n         call qu 1,\" \"\n         has_errors = 1\n      END\n   END\n\n   /*--------------------------------------------------*/\n   /* For certain types of datasets, give an error if  */\n   /* the COPY verb was specified.                     */\n   /*--------------------------------------------------*/\n   zzNoCopyParms = \" SMF HASPACE HASPCKPT\"\n   zzPARM        = DS.###xx.PARM\n   zzThisDSN     = DS.###xx.DSN\n   zzThisOPTION  = DS.###xx.OPTION\n\n   trace off\n   IF zzThisOPTION = \"COPY\" THEN,\n   DO ###xx2 = 1 TO WORDS(zzNoCopyParms)\n      zzThisParm = WORD(zzNoCopyParms,###xx2)\n      IF POS(zzThisParm,zzPARM) > 0 THEN DO\n         call qu 1,'Error: 'zzThisDSN\n         call qu 1,,\n         '   Invalid dataset type for COPY mode:' zzThisParm\n         call qu 1,,\n         '   'zzThisParm' datasets should be coded as ALLOC, and have'\n         call qu 1,,\n         '   SPACE coded, and either MODEL or DCB coded.'\n         call qu 1,\" \"\n         has_errors = 1\n      END\n   END\n\n   /*--------------------------------------------------*/\n   /* If MODEL() is coded, make sure it exists.        */\n   /*--------------------------------------------------*/\n   IF SYMBOL(\"DS.\"###xx\".MODEL\") = \"VAR\" THEN DO\n      xxdsn = DS.###xx.MODEL\n      stat = SYSDSN(\"'\"xxdsn\"'\")\n      IF stat /= 'OK' THEN DO\n         call qu 1,'Error: 'xxdsn\n         call qu 1,,\n         '   Model dataset not found: 'xxdsn\n         call qu 1,\" \"\n         has_errors = 1\n      END\n   END\n\n   /*--------------------------------------------------*/\n   /* If DATASET COPY coded, make sure \"copy from\"     */\n   /* dataset exists.                                  */\n   /*--------------------------------------------------*/\n   IF DS.###xx.verb = \"DATASET\" & DS.###xx.option = \"COPY\" THEN DO\n      xxdsn = DS.###xx.DSN\n      stat = SYSDSN(\"'\"XXdsn\"'\")\n      IF stat /= 'OK' THEN DO\n         call qu 1,'Error: 'xxdsn' - Dataset not found.'\n         call qu 1,\" \"\n         has_errors = 1\n      END\n   END\n\n   /*--------------------------------------------------*/\n   /* If RACF dataset is being copied, make sure SPACE */\n   /* is coded. This is because we use IRRUT400 to do  */\n   /* the COPY, and it can't tell how bit the src      */\n   /* RACF dataset is.                                 */\n   /*--------------------------------------------------*/\n   IF hasParms(\"RACFDS\",DS.###xx.PARM) & isblank(\"DS.\"###xx\".SPACE\") ,\n   THEN DO\n      xxdsn = DS.###xx.DSN\n      call qu 1,'Error: RACFDS'\n      call qu 1,,\n      '   COPY of RACF dataset requires a SPACE parameter.'\n      call qu 1,\" \"\n      has_errors = 1\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Check all MEMCOPY statements to be sure both IN and OUT */\n/* datasets exist.                                         */\n/*---------------------------------------------------------*/\nmemcopycheck:\nDO ###xx = 1 TO DS.0\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   /* If not a MEMCOPY then skip to next record  */\n   /* Otherwise copy some variables out of the   */\n   /* DS. stem var.                              */\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   IF DS.###xx.verb /= \"MEMCOPY\" THEN ITERATE\n   zzIN  = DS.###xx.IN\n   zzOUT = DS.###xx.OUT\n   zzMEM = DS.###xx.M\n   /* SAY zzOUT zzMEM dsdefined(zzOUT)           */\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   /* Check OUT ds - Must be defined by a        */\n   /* DATASET COPY or DATASET ALLOC command.     */\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   IF \\dsdefined(zzOUT) THEN DO\n      has_errors=1\n      call qu 1,\"Error: MEMCOPY-OUT\"\n      call qu 1,\"MEMCOPY OUT dataset \"zzOUT\" is not defined with either\"\n      call qu 1,\"a DATASET COPY or DATASET ALLOC statement.\"\n   END\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   /* Check IN ds - Should either exist now, or  */\n   /* be created with a DATASET ALLOC or COPY.   */\n   /*- - - - - - - - - - - - - - - - - - - - - - */\n   IF SYSDSN(\"'\"zzIN\"'\") /= 'OK' & \\dsdefined(zzIN) THEN DO\n      has_errors=1\n      call qu 1,\"Error: MEMCOPY-IN\"\n      call qu 1,\"MEMCOPY IN dataset \"zzIN \"does not exist, and is also \"\n      call qu 1,\"not defined as a new dataset with a DATASET stmt.\"\n   END\nEND\n\n/*---------------------------------------------------------*/\n/* Check to ensure that there is at least one dataset      */\n/* coded in @DATASET for each of certain parm values.      */\n/* Other datasets must be coded once and only once.        */\n/*---------------------------------------------------------*/\ndscheck2:\nIF \\check_parm_present('SYSUADS')   THEN call error_parm('SYSUADS')\nIF \\check_parm_present('SYSLBC')    THEN call error_parm('SYSLBC')\nIF \\check_parm_present('HASPACE')   THEN call error_parm('HASPACE')\nIF \\check_parm_present1('PGPLPA')   THEN call error_parm1('PGPLPA')\nIF \\check_parm_present1('PGCOMMON') THEN call error_parm1('PGCOMMON')\nIF \\check_parm_present('PGLOCAL')   THEN call error_parm('PGLOCAL')\n\nIF \\check_parm_present1('ZLINKLIB') THEN call error_parm1('ZLINKLIB')\nIF \\check_parm_present1('ZPROCLIB') THEN call error_parm1('ZPROCLIB')\nIF \\check_parm_present1('ZPARMLIB') THEN call error_parm1('ZPARMLIB')\nIF \\check_parm_present1('ZSYSPROC') THEN call error_parm1('ZSYSPROC')\nIF \\check_parm_present1('IPLPARM')     THEN,\n   call error_parm1('IPLPARM'),,\n   \"No IPLPARM file was specified in the @DATASET member.\"\nIF \\check_parm_present1('IODF')     THEN,\n   call error_parm1('IODF'),,\n   \"No IODF file was specified in the @DATASET member.\"\nIF \\check_parm_present1('ACDS')     THEN,\n   call error_parm1('SMS: ACDS'),,\n   \"No ACDS file was specified in the @DATASET member.\"\nIF \\check_parm_present1('COMMDS')     THEN,\n   call error_parm1('SMS: COMMDS'),,\n   \"No COMMDS file was specified in the @DATASET member.\"\n\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of dscheck                                          */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\ncall qu 1,,\n'--------------------- End of validity checking -------------------'\ncall qu 1,\"\"\n\ncall qup 1\n\nreturn has_errors\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- program specific functions ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/* Make sure volume coded in a @DATASET      */\n/* entry has been defined in @PARMS.         */\n/*-------------------------------------------*/\ncheck_volume:\nARG ##vol\nDO y = 1 TO 99\n   IF \\isblank(\"VOLSER\"y) THEN,\n      IF ##prm = VALUE(\"VOLSER\"y) THEN RETURN 1\nEND\nRETURN 0\n\n/*-------------------------------------------*/\n/* Make sure parm \"x\" is defined in at least */\n/* one entry in @DATASET.                    */\n/*-------------------------------------------*/\ncheck_parm_present:\nARG ##prm\n##libs = xdslist(##prm)\nRETURN WORDS(##libs) > 0\n\nwarn_parm:\nARG ##prm,##msg\ncall qu 1,\"Warning: \"##prm\nIF ##msg = \"\" THEN ##msg =,\n   \"   No dataset was defined with this PARM value.\"\ncall qu 1,##msg\ncall qu 1,,\n##prm\": This may cause problems with the target system.\"\nRETURN\n\nerror_parm:\nARG ##prm,##msg\ncall qu 1,\"Error: \"##prm\nIF ##msg = \"\" THEN ##msg =,\n\"   At least one dataset must be defined with this PARM value.\"\ncall qu 1,##msg\nhas_errors = 1\nRETURN\n\ncheck_parm_present1:\nARG ##prm\n##libs = xdslist(##prm)\nRETURN WORDS(##libs) = 2\n\nerror_parm1:\nARG ##prm,##msg\ncall qu 1,\"Error: \"##prm\nIF ##msg = \"\" THEN ##msg =,\n   \"   One and only one dataset must be defined with this PARM value.\"\ncall qu 1,##msg\nhas_errors = 1\nRETURN\n\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem, ##mode\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\nIF ##mode = \"\" THEN ##mode = \"SHR\"\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') \"##mode\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call clsinp ##ds, ##mem\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=@DATASET\n*--------------------------------------------------------------------*\n*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *\n*--------------------------------------------------------------------*\n*  Note:  Several different symbolic variables are used in the VOL() *\n*         parameter below.  For this particular system build, all of *\n*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *\n*         to the same physical volume, as we are building a single   *\n*         volume RESCUE system.  This relationship is set up in the  *\n*         @PARMS member.  Setting it up this way makes it a simpler  *\n*         matter to spread the datasets out over multiple volumes    *\n*         if/when desired.                                           *\n*         If no VOL() is coded, the first volume &VOLSER1 is used.   *\n*--------------------------------------------------------------------*\n*  Dataset Definitions:                                              *\n*--------------------------------------------------------------------*\n*  Supported verbs are:                                              *\n*  DATASET                                                           *\n*  MEMCOPY                                                           *\n*--------------------------------------------------------------------*\n*  DATASET verb:                                                     *\n*     The DATASET verb is used to define datasets that are to be     *\n*     created on the new system.  They are either copied or          *\n*     allocated, as specified by the COPY or ALLOC suboptions resp-  *\n*     ectively.                                                      *\n*  DATASET COPY PARAMETERS:                                          *\n*  -  PARM(parms) One or more comma separated parameters that tell   *\n*     what the dataset is used for, or special attributes that it    *\n*     has.  The PARM field is used by the zClone execs to identify   *\n*     datasets to be coded in PROCs, PARMLIB members, and other      *\n*     special handling needs (like formatting LOGREC e.g.).          *\n*     - HASPACE   The dataset is a JES2 spool dataset.               *\n*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *\n*     - SYSUADS   The dataset is the UADS dataset.                   *\n*     - SYSLBC    The dataset is the BRODCAST dataset.               *\n*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *\n*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *\n*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *\n*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *\n*     - SYSPROC   Lib to be in SYSPROC concatenation.                *\n*     - VTAMLST   Lib to be in VTAMLST concatenation.                *\n*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *\n*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *\n*     - LPA       Lib to be in LPALST.                               *\n*     - ACDS      Dataset is the SMS ACDS.                           *\n*     - COMMDS    Dataset is the SMS COMMDS.                         *\n*     - RLSE      Space should be released after copy.               *\n*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *\n*     The following should be coded once and only once, and are used *\n*     by the ZCLONE execs to build various system components.        *\n*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *\n*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *\n*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *\n*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *\n*--------------------------------------------------------------------*\n*  REQUIRED - DON'T DELETE THE NEXT SET OF ENTRIES FROM HERE UNTIL   *\n*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *\n*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *\n*     V       THESE STATEMENTS ARE ALTERED.                          *\n*--------------------------------------------------------------------*\n\n DATASET ALLOC DSN(SYS1.Z&CLN.CLIST) MODEL(SYS1.PARMLIB) -\n               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.PARMLIB) SPACE(CYL,(1,0,15)) -\n               MODEL(SYS1.PARMLIB) PARM(ZPARMLIB,PARMLIB)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)\n\n DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(IPLPARM)\n\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.CLIST)   M(ZISPALOC,ISPALLOC)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZCOMMND,COMMND00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(COUPLE00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEALPA,IEALPA00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEFSSN,IEFSSN00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZTSOKEY,TSOKEY00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(BPXPRM00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYM00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYS00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IGDSMS00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(JES2PARM)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(LPALST00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(MSTJCL01)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGA0)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGL0)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(VATLST00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(&TSOPROC)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(JES2)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(TSO)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(VTAM)\n MEMCOPY IN(&OPDS) OUT(SYS1.IPLPARM) M(LOAD00)\n\n*--------------------------------------------------------------------*\n*  END OF REQUIRED STATEMENTS.                                       *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n* Local datasets - Assorted PDS's and members that we want.          *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)\n DATASET COPY  DSN(COMPJM.CNTL)  VOL(&CATVOL)\n DATASET COPY  DSN(COMPJM.EXEC)  VOL(&CATVOL)\n DATASET ALLOC DSN(SYS2.ISPPLIB) MODEL(SYS1.PARMLIB) -\n         SPACE(CYL,(2,0,15)) PARM(ISPPLIB)  VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.TCPIP)   VOL(&CATVOL)\n MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.Z&CLN.CLIST)   M(@HCD)\n MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.Z&CLN.CLIST)   M(@ISMF)\n MEMCOPY IN(SYS2.ISPPLIB) OUT(SYS2.ISPPLIB)       M(ISR@PRIM)\n\n*--------------------------------------------------------------------*\n*  OMVS Datasets:                                                    *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')\n DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')\n DATASET COPY  DSN(OMVS.AFOROOT)  VOL(&HFSVOL)  MOUNT('/usr/lib/ssh')\n DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')\n DATASET COPY  DSN(OMVS.SIBMROOT) VOL(&HFSVOL)  MOUNT('/usr/lpp/pli')\n DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -\n               MOUNT('/usr/lpp/cobol')\n\n*--------------------------------------------------------------------*\n*  Page and other system VSAM datasets.                              *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(PAGE.Z&CLN.PLPA)    SPACE(CYL,(150)) PARM(PGPLPA) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.Z&CLN.COMMON) SPACE(CYL,(150)) PARM(PGCOMMON) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.Z&CLN.LOCAL1) SPACE(CYL,(150)) PARM(PGLOCAL) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.Z&CLN.LOCAL2) SPACE(CYL,(150)) PARM(PGLOCAL) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.STGINDEX) SPACE(CYL,(5)) -\n         VOL(&SYSVL1)      PARM(STGINDEX)\n\n*--------------------------------------------------------------------*\n* Couple datasets.                                                   *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)\n DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)\n DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)\n DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)\n DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)\n DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)\n\n*--------------------------------------------------------------------*\n*  MVS Datasets:                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.DFSMS.ACDS)     PARM(ACDS) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.DFSMS.SCDS)     VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.DFSMS.COMMDS)   PARM(COMMDS) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)\n DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)\n DATASET COPY  DSN(SYS1.NUCLEUS)\n DATASET COPY  DSN(SYS1.PARMLIB)         PARM(PARMLIB)\n DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)\n DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)\n DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB)\n DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB)\n DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB)\n DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB)\n DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)\n DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&CATVOL) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)\n\n DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&CATVOL) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)\n\n DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -\n         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.LOGREC)          PARM(LOGREC) VOL(&CATVOL) -\n         MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)\n\n DATASET ALLOC DSN(SYS1.MAN1)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.MAN2)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.MAN3)  PARM(SMF) SPACE(CYL,(10)) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.DUMP00)          PARM(DUMP) SPACE(CYL,(25)) -\n         MODEL(SYS1.DUMP01) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.DUMP01)          PARM(DUMP) SPACE(CYL,(25)) -\n         MODEL(SYS1.DUMP01) VOL(&CATVOL)\n\n DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)\n DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)\n DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(SYS1.DAE)\n DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)\n DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)\n\n*--------------------------------------------------------------------*\n* HCD ISPF libraries                                                 *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* ISPF Libraries                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)\n DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)\n\n*--------------------------------------------------------------------*\n* TCPIP datasets                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)\n DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)\n DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)\n DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)\n\n*--------------------------------------------------------------------*\n* RACF DATASET AND ISPF LIBRARIES                                    *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.RACFP1)  PARM(RACFDS) MODE(RACF) -\n               SPACE(CYL,(25)) VOL(&CATVOL)\n DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)\n\n*--------------------------------------------------------------------*\n* ISMF ISPF libraries                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)\n DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* SDSF Datasets                                                      *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)\n DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)\n DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)\n*--------------------------------------------------------------------*\n* VTAM / NCP DATASETS                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)\n DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)\n*DATASET COPY  DSN( CPAC.VTAMLIB)  PARM(VTAMLIB,APF) VOL(&CATVOL)\n DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)\n DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)\n DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)\n\n*--------------------------------------------------------------------*\n* HLASM DATASETS                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&CATVOL)\n./ ADD NAME=@DATA2\n*--------------------------------------------------------------------*\n*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *\n*--------------------------------------------------------------------*\n*  Note:  Several different symbolic variables are used in the VOL() *\n*         parameter below.  For this particular system build, all of *\n*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *\n*         to the same physical volume, as we are building a single   *\n*         volume RESCUE system.  This relationship is set up in the  *\n*         @PARMS member.  Setting it up this way makes it a simpler  *\n*         matter to spread the datasets out over multiple volumes    *\n*         if/when desired.                                           *\n*         If no VOL() is coded, the first volume &VOLSER1 is used.   *\n*--------------------------------------------------------------------*\n*  Dataset Definitions:                                              *\n*--------------------------------------------------------------------*\n*  Supported verbs are:                                              *\n*  DATASET                                                           *\n*  MEMCOPY                                                           *\n*--------------------------------------------------------------------*\n*  DATASET verb:                                                     *\n*     The DATASET verb is used to define datasets that are to be     *\n*     created on the new system.  They are either copied or          *\n*     allocated, as specified by the COPY or ALLOC suboptions resp-  *\n*     ectively.                                                      *\n*  DATASET COPY PARAMETERS:                                          *\n*  -  PARM(parms) One or more comma separated parameters that tell   *\n*     what the dataset is used for, or special attributes that it    *\n*     has.  The PARM field is used by the zClone execs to identify   *\n*     datasets to be coded in PROCs, PARMLIB members, and other      *\n*     special handling needs (like formatting LOGREC e.g.).          *\n*     - HASPACE   The dataset is a JES2 spool dataset.               *\n*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *\n*     - SYSUADS   The dataset is the UADS dataset.                   *\n*     - SYSLBC    The dataset is the BRODCAST dataset.               *\n*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *\n*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *\n*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *\n*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *\n*     - SYSPROC   Lib to be in SYSPROC concatenation.                *\n*     - VTAMLST   Lib to be in VTAMLST concatenation.                *\n*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *\n*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *\n*     - LPA       Lib to be in LPALST.                               *\n*     - ACDS      Dataset is the SMS ACDS.                           *\n*     - COMMDS    Dataset is the SMS COMMDS.                         *\n*     - RLSE      Space should be released after copy.               *\n*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *\n*     The following should be coded once and only once, and are used *\n*     by the ZCLONE execs to build various system components.        *\n*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *\n*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *\n*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *\n*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *\n*--------------------------------------------------------------------*\n*  REQUIRED - DON'T DELETE THE NEXT SET OF ENTRIES FROM HERE UNTIL   *\n*     |       THE NEXT COMMENT BLOCK. THESE ARE BASIC PARTS OF THE   *\n*     |       RESCUE SYSTEM BUILD PROCESS, AND THE EXEC MAY BREAK IF *\n*     V       THESE STATEMENTS ARE ALTERED.                          *\n*--------------------------------------------------------------------*\n\n DATASET ALLOC DSN(SYS1.&SYSNAME.CLIST) MODEL(SYS1.PARMLIB) -\n               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.PARMLIB) SPACE(CYL,(1,0,15)) -\n               MODEL(SYS1.PARMLIB) PARM(ZPARMLIB,PARMLIB)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)\n\n DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(IPLPARM) VOL(&CATVOL)\n\n MEMCOPY IN(&IPDS) OUT(SYS1.&SYSNAME.CLIST)   M(ZISPALOC,ISPALLOC)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZCOMMND,COMMND00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(COUPLE00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEALPA,IEALPA00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZIEFSSN,IEFSSN00)\n MEMCOPY IN(&IPDS) OUT(SYS1.Z&CLN.PARMLIB) M(ZTSOKEY,TSOKEY00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(BPXPRM00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYM00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IEASYS00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(IGDSMS00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(JES2PARM)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(LPALST00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(MSTJCL01)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGA0)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(PROGL0)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PARMLIB) M(VATLST00)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(&TSOPROC)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(JES2)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(TSO)\n MEMCOPY IN(&OPDS) OUT(SYS1.Z&CLN.PROCLIB) M(VTAM)\n MEMCOPY IN(&OPDS) OUT(SYS1.IPLPARM) M(LOAD00)\n\n*--------------------------------------------------------------------*\n*  END OF REQUIRED STATEMENTS.                                       *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n* Local datasets - Assorted PDS's and members that we want.          *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)\n DATASET COPY  DSN(SYSJCM1.CNTL)  VOL(&CATVOL)\n DATASET COPY  DSN(SYSJCM1.EXEC)  VOL(&CATVOL)\n DATASET ALLOC DSN(SYS2.ISPPLIB) MODEL(SYS1.PARMLIB) -\n         SPACE(CYL,(2,0,15)) PARM(ISPPLIB)  VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.TCPIP)   VOL(&CATVOL)\n MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.&SYSNAME.CLIST)   M(@HCD)\n MEMCOPY IN(CPAC.CMDPROC) OUT(SYS1.&SYSNAME.CLIST)   M(@ISMF)\n MEMCOPY IN(SYS2.ISPPLIB) OUT(SYS2.ISPPLIB)       M(ISR@PRIM)\n\n*--------------------------------------------------------------------*\n*  OMVS Datasets:                                                    *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')\n DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')\n*DATASET COPY  DSN(OMVS.AFOROOT)  VOL(&HFSVOL)  MOUNT('/usr/lib/ssh')\n DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')\n*DATASET COPY  DSN(OMVS.SIBMROOT) VOL(&HFSVOL)  MOUNT('/usr/lpp/pli')\n DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -\n               MOUNT('/usr/lpp/cobol')\n\n*--------------------------------------------------------------------*\n*  Page and other system VSAM datasets.                              *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(PAGE.&SYSNAME.PLPA) SPACE(CYL,(150)) PARM(PGPLPA) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.&SYSNAME.COMMON) SPACE(CYL,(150)) PARM(PGCOMMON) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL1) SPACE(CYL,(150)) PARM(PGLOCAL) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL2) SPACE(CYL,(150)) PARM(PGLOCAL) -\n         VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.&SYSNAME.STGINDEX) SPACE(CYL,(5)) -\n         NEWNAME(SYS1.&SYSNAME.STGINDEX) -\n         VOL(&SYSVL1) PARM(STGINDEX)\n\n*--------------------------------------------------------------------*\n* Couple datasets.                                                   *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)\n DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)\n DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)\n DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)\n DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)\n DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)\n\n*--------------------------------------------------------------------*\n*  MVS Datasets:                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL) -\n         NEWNAME(SYS1.IODF00.CLUSTER)\n DATASET COPY  DSN(SYS1.DFSMS.ACDS)     PARM(ACDS) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.DFSMS.SCDS)     VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.DFSMS.COMMDS)   PARM(COMMDS) VOL(&CATVOL)\n DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)\n DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)\n DATASET COPY  DSN(SYS1.NUCLEUS)\n DATASET COPY  DSN(SYS1.PARMLIB)         PARM(PARMLIB,*)\n DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)\n DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)\n DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB)\n DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB)\n DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB)\n DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB)\n DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)\n DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&SYSVL1)\n\n DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&SYSVL1) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)\n\n DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&SYSVL1) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)\n\n DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -\n         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&SYSVL1)\n\n DATASET ALLOC DSN(SYS1.&SYSNAME.LOGREC)  PARM(LOGREC) VOL(&CATVOL) -\n         MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)\n\n DATASET ALLOC DSN(SYS1.&SYSNAME.MAN1) PARM(SMF) -\n         SPACE(CYL,(10)) VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.&SYSNAME.MAN2) PARM(SMF) -\n         SPACE(CYL,(10)) VOL(&CATVOL)\n DATASET ALLOC DSN(SYS1.&SYSNAME.MAN3) PARM(SMF) -\n         SPACE(CYL,(10)) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.&SYSNAME.DUMP00) PARM(DUMP) SPACE(CYL,(25)) -\n         MODEL(SYS1.DUMP01) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.&SYSNAME.DUMP01) PARM(DUMP) SPACE(CYL,(25)) -\n         MODEL(SYS1.DUMP01) VOL(&CATVOL)\n\n DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)\n DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)\n DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(SYS1.DAE)\n DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)\n DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)\n\n*--------------------------------------------------------------------*\n* HCD ISPF libraries                                                 *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* ISPF Libraries                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)\n DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)\n\n*--------------------------------------------------------------------*\n* TCPIP datasets                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)\n DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)\n DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)\n DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)\n\n*--------------------------------------------------------------------*\n* RACF DATASET AND ISPF LIBRARIES                                    *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.RACF)    PARM(RACFDS) MODE(RACF) -\n               SPACE(CYL,(25)) VOL(&CATVOL)              -\n               NEWNAME(SYS1.&SYSNAME.RACF)\n DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)\n\n*--------------------------------------------------------------------*\n* ISMF ISPF libraries                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)\n DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* SDSF Datasets                                                      *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)\n DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)\n DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)\n*--------------------------------------------------------------------*\n* VTAM / NCP DATASETS                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)\n DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)\n*DATASET COPY  DSN( CPAC.VTAMLIB)  PARM(VTAMLIB,APF) VOL(&CATVOL)\n DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)\n DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)\n DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)\n\n*--------------------------------------------------------------------*\n* HLASM DATASETS                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&CATVOL)\n DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&CATVOL)\n./ ADD NAME=@DATA3   0108-10016-10018-2021-00296-00283-00000-COMPJM\n*--------------------------------------------------------------------*\n*  EXAMPLE: Build a single-volume (3390-9) zOS rescue system.        *\n*--------------------------------------------------------------------*\n*  Note:  Several different symbolic variables are used in the VOL() *\n*         parameter below.  For this particular system build, all of *\n*         the variables (e.g. &CATVOL, &SYSVL1, &SYSVL2, etc.) point *\n*         to the same physical volume, as we are building a single   *\n*         volume RESCUE system.  This relationship is set up in the  *\n*         @PARMS member.  Setting it up this way makes it a simpler  *\n*         matter to spread the datasets out over multiple volumes    *\n*         if/when desired.                                           *\n*         If no VOL() is coded, the first volume &VOLSER1 is used.   *\n*--------------------------------------------------------------------*\n*  Dataset Definitions:                                              *\n*--------------------------------------------------------------------*\n*  Supported verbs are:                                              *\n*  DATASET                                                           *\n*  MEMCOPY                                                           *\n*--------------------------------------------------------------------*\n*  DATASET verb:                                                     *\n*     The DATASET verb is used to define datasets that are to be     *\n*     created on the new system.  They are either copied or          *\n*     allocated, as specified by the COPY or ALLOC suboptions resp-  *\n*     ectively.                                                      *\n*  DATASET COPY PARAMETERS:                                          *\n*  -  PARM(parms) One or more comma separated parameters that tell   *\n*     what the dataset is used for, or special attributes that it    *\n*     has.  The PARM field is used by the zClone execs to identify   *\n*     datasets to be coded in PROCs, PARMLIB members, and other      *\n*     special handling needs (like formatting LOGREC e.g.).          *\n*     - HASPACE   The dataset is a JES2 spool dataset.               *\n*     - HASPCKPT  The dataset is a JES2 checkpoint dataset.          *\n*     - SYSUADS   The dataset is the UADS dataset.                   *\n*     - SYSLBC    The dataset is the BRODCAST dataset.               *\n*     - ISPPLIB   ISPF panel lib to be added to ISPPLIB concat.      *\n*     - ISPMLIB   ISPF msg lib to be added to ISPMLIB concat.        *\n*     - ISPSLIB   ISPF skel lib to be added to ISSPLIB concat.       *\n*     - ISPTLIB   ISPF table lib to be added to ISTPLIB concat.      *\n*     - SYSPROC   Lib to be in SYSPROC concatenation.                *\n*     - VTAMLST   Lib to be in VTAMLST concatenation.                *\n*     - VTAMLIB   Lib to be in VTAMLIB concatenation.                *\n*     - APF,LNK   Lib to be in APF list or LNKLST respectively.      *\n*     - LPA       Lib to be in LPALST.                               *\n*     - ACDS      Dataset is the SMS ACDS.                           *\n*     - COMMDS    Dataset is the SMS COMMDS.                         *\n*     - RLSE      Space should be released after copy.               *\n*     - SMF       MANx VSAM file tb formatted as SMF dataset.        *\n*     - ******    Catalog this dataset on IPL volume.                *\n*     - *         Same as \"******\"                                   *\n*     The following should be coded once and only once, and are used *\n*     by the ZCLONE execs to build various system components.        *\n*     - ZLINKLIB  Dataset is the ZCLONE utility LINKLIB.             *\n*     - ZPROCLIB  Dataset is the ZCLONE utility PROCLIB.             *\n*     - ZPARMLIB  Dataset is the ZCLONE utility PARMLIB.             *\n*     - ZSYSPROC  Dataset is the ZCLONE utility SYSPROC (clist) lib. *\n*--------------------------------------------------------------------*\n\n DATASET ALLOC DSN(SYS1.IPLPARM) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(IPLPARM) VOL(&CATVOL)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.CLIST) MODEL(SYS1.PARMLIB) -\n               SPACE(CYL,(2,0,15)) PARM(ZSYSPROC,SYSPROC)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.LINKLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.LINKLIB) PARM(ZLINKLIB,APF,LNK)\n\n DATASET ALLOC DSN(SYS1.Z&CLN.PROCLIB) SPACE(CYL,(2,0,25)) -\n               MODEL(SYS1.PARMLIB) PARM(ZPROCLIB,PROCLIB)\n\n MEMCOPY IN(&OPDS) OUT(SYS1.PARMLIB) M(PROGA0)\n MEMCOPY IN(&OPDS) OUT(SYS1.PARMLIB) M(PROGL0)\n MEMCOPY IN(&OPDS) OUT(SYS1.PROCLIB) M(VTAM)\n MEMCOPY IN(SYS2.MVSIMAGE) OUT(SYS1.PARMLIB) M(IEASYM00)\n MEMCOPY IN(&IPDS)         OUT(SYS1.PARMLIB) M(ZCOMMND,COMMND00)\n MEMCOPY IN(&OPDS)         OUT(SYS1.PARMLIB) M(IEASYM00)\n MEMCOPY IN(&OPDS)         OUT(SYS1.PROCLIB) M(JES2)\n MEMCOPY IN(&OPDS)         OUT(SYS1.IPLPARM) M(LOAD00)\n MEMCOPY IN(&IPDS)         OUT(SYS2.CMDPROC) M(ZISPALOC,ISPALLOC)\n MEMCOPY IN(&OPDS)         OUT(SYS1.PARMLIB) M(JES2PARM)\n*MEMCOPY IN(SYS2.MVSIMAGE) OUT(SYS1.PARMLIB) M(SMFPRM00)\n\n*--------------------------------------------------------------------*\n*  END OF REQUIRED STATEMENTS.                                       *\n*--------------------------------------------------------------------*\n\n*--------------------------------------------------------------------*\n* Local datasets - Assorted PDS's and members that we want.          *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS2.LINKLIB) PARM(APF,LNK) VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.CMDPROC) PARM(SYSPROC) VOL(&CATVOL)\n DATASET COPY  DSN(SYS2.ISPPLIB) PARM(SYSPROC) VOL(&CATVOL)\n*DATASET COPY  DSN(SYSJCM1.CNTL)  VOL(&CATVOL)\n*DATASET COPY  DSN(SYSJCM1.EXEC)  VOL(&CATVOL)\n*\n*DATASET COPY  DSN(SYS2.PROD1.TCPIP)     VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.PROD2.TCPIP)     VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.SYSTEMS.TCPIP)   VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.TEST.TCPIP)      VOL(&CATVOL)\n*\n*DATASET COPY  DSN(SYS2.PROD1.PROCLIB)   VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.PROD2.PROCLIB)   VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.SYSTEMS.PROCLIB) VOL(&CATVOL)\n*DATASET COPY  DSN(SYS2.TEST.PROCLIB)    VOL(&CATVOL)\n\n*--------------------------------------------------------------------*\n*  OMVS Datasets:                                                    *\n*--------------------------------------------------------------------*\n*DATASET COPY  DSN(OMVS.ROOT)     VOL(&HFSVOL)  MOUNT('/')\n*DATASET COPY  DSN(OMVS.ETC)      VOL(&HFSVOL)  MOUNT('/etc')\n*DATASET COPY  DSN(OMVS.VAR)      VOL(&HFSVOL)  MOUNT('/var')\n*DATASET COPY  DSN(OMVS.SIGYROOT) VOL(&HFSVOL)  -\n               MOUNT('/usr/lpp/cobol')\n\n*--------------------------------------------------------------------*\n*  Page and other system VSAM datasets.                              *\n*--------------------------------------------------------------------*\n*DATASET ALLOC DSN(PAGE.&SYSNAME.PLPA) SPACE(CYL,(150)) PARM(PGPLPA) -\n*        VOL(PAGE01)\n*DATASET ALLOC DSN(PAGE.&SYSNAME.COMMON) SPACE(CYL,(150)) -\n*        PARM(PGCOMMON) VOL(PAGE01)\n*DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL1) SPACE(CYL,(150)) -\n*        PARM(PGLOCAL) VOL(PAGE02)\n*DATASET ALLOC DSN(PAGE.&SYSNAME.LOCAL2) SPACE(CYL,(150)) -\n*        PARM(PGLOCAL) VOL(PAGE02)\n*DATASET ALLOC DSN(SYS1.&SYSNAME.STGINDEX) SPACE(CYL,(5)) -\n*        NEWNAME(SYS1.&SYSNAME.STGINDEX) -\n*        VOL(&CATVOL) PARM(STGINDEX)\n*\n*--------------------------------------------------------------------*\n* Couple datasets.                                                   *\n*--------------------------------------------------------------------*\n*DATASET ALLOC DSN(SYS1.COUPLE.PLEXP) VOL(&CATVOL) PARM(XCF)\n*DATASET ALLOC DSN(SYS1.COUPLE.PLEXB) VOL(&SYSVL1) PARM(XCF)\n*DATASET ALLOC DSN(SYS1.COUPLE.WLMP)  VOL(&CATVOL) PARM(WLM)\n*DATASET ALLOC DSN(SYS1.COUPLE.WLMB)  VOL(&SYSVL1) PARM(WLM)\n*DATASET ALLOC DSN(SYS1.COUPLE.LOGRP) VOL(&CATVOL) PARM(LOGR)\n*DATASET ALLOC DSN(SYS1.COUPLE.LOGRB) VOL(&SYSVL1) PARM(LOGR)\n\n*--------------------------------------------------------------------*\n*  MVS Datasets:                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.CICSTS32.CPSM.SEYULPA)  PARM(LPA)\n DATASET COPY  DSN(SYS1.CICSTS32.CICS.SDFHLPA)  PARM(LPA)\n\n DATASET COPY  DSN(SYS1.IODF00.CLUSTER) PARM(IODF) VOL(&CATVOL) -\n         NEWNAME(SYS1.IODF00.CLUSTER)\n DATASET COPY  DSN(SYS1.DBBLIB)          VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.SDWWDLPA)        PARM(LPA)\n DATASET COPY  DSN(SYS1.SIEALNKE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.SIEAMIGE)        PARM(APF,LNK)\n DATASET COPY  DSN(SYS1.LINKLIB)         PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(SYS1.SHASLNKE)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SHASMIG)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.LPALIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MACLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.MIGLIB)          PARM(RLSE,APF)\n DATASET COPY  DSN(SYS1.NUCLEUS)\n DATASET COPY  DSN(SYS1.PARMLIB)  PARM(PARMLIB,ZPARMLIB)   VOL(&CATVOL)\n DATASET COPY  DSN(CPAC.PARMLIB)         PARM(PARMLIB)\n DATASET COPY  DSN(CPAC.CMDPROC)         PARM(CMPDPROC)\n DATASET COPY  DSN(SYS1.IBM.PARMLIB)     PARM(PARMLIB) VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.PROCLIB)         PARM(PROCLIB) VOL(&CATVOL)\n DATASET COPY  DSN(CPAC.PROCLIB)         PARM(PROCLIB) VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.IBM.PROCLIB)     PARM(PROCLIB) VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.SAMPLIB)         PARM(RLSE)\n DATASET COPY  DSN(SYS1.SVCLIB)          PARM(RLSE)\n DATASET COPY  DSN(SYS1.UADS)            PARM(SYSUADS) VOL(&SYSVL1)\n DATASET COPY  DSN(SYS1.BRODCAST)        PARM(SYSLBC) VOL(&SYSVL1)\n\n DATASET ALLOC DSN(SYS1.HASPCKP1)        PARM(HASPCKPT) VOL(&CATVOL) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,15)\n\n DATASET ALLOC DSN(SYS1.HASPCKP2)        PARM(HASPCKPT) VOL(&CATVOL) -\n         MODEL(SYS1.HASPCKPT) SPACE(CYL,10)\n\n DATASET ALLOC DSN(SYS1.HASPACE)         PARM(HASPACE) -\n         MODEL(SYS1.HASPACE)  SPACE(CYL,500) VOL(&CATVOL)\n\n*DATASET ALLOC DSN(SYS1.&SYSNAME.LOGREC)  PARM(LOGREC) VOL(&CATVOL) -\n*        MODEL(SYS1.CPAC.LOGREC) SPACE(CYL,5)\n*\n*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN1) PARM(SMF) -\n*        SPACE(CYL,(10)) VOL(&CATVOL)\n*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN2) PARM(SMF) -\n*        SPACE(CYL,(10)) VOL(&CATVOL)\n*DATASET ALLOC DSN(SYS1.&SYSNAME.MAN3) PARM(SMF) -\n*        SPACE(CYL,(10)) VOL(&CATVOL)\n*\n DATASET COPY  DSN(SYS1.CSSLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(EOY.SEOYLOAD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(EOX.SEPHLOD1)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(GIM.SGIMLMD0)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEERUN2)         PARM(LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD2) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(FFST.V120ESA.SEPWMOD4) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SICELINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SORTLIB)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(IOE.SIOELMOD)         PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SIOALMOD)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CBC.SCLBDLL)          PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SERBLINK)        PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(CEE.SCEELPA)          PARM(RLSE,LNK,APF,LPA)\n DATASET COPY  DSN(SYS1.SERBLPA)         PARM(RLSE,LPA)\n DATASET COPY  DSN(SYS1.CMDLIB)          PARM(RLSE,LNK)\n DATASET COPY  DSN(SYS1.DAE)\n DATASET COPY  DSN(SYS1.HELP)            PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.IMAGELIB)        PARM(RLSE)\n DATASET COPY  DSN(SYS1.SBDTHELP)        PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(SYS1.HELPENP)         PARM(RLSE,SYSHELP)\n\n*--------------------------------------------------------------------*\n* HCD ISPF libraries                                                 *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.SCBDHENU) PARM(RLSE,LNK,APF)\n DATASET COPY  DSN(SYS1.SCBDCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.SCBDMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.SCBDPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.SCBDTENU) PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* ISPF Libraries                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(ISP.SISPHELP) PARM(RLSE,SYSHELP)\n DATASET COPY  DSN(ISP.SISPTENU) PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISP.SISPSLIB) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPMENU) PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISP.SISPSENU) PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISP.SISPLOAD) PARM(RLSE,LNK,ISPLLIB)\n DATASET COPY  DSN(ISP.SISPPENU) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISP.SISPCLIB) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(ISP.SISPLPA)  PARM(RLSE,LPA)\n\n*--------------------------------------------------------------------*\n* TCPIP datasets                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(TCPIP.SEZALPA) PARM(RLSE,APF,LPA)\n DATASET COPY  DSN(TCPIP.SEZALOAD) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZALNK2) PARM(RLSE,APF,LNK)\n DATASET COPY  DSN(TCPIP.SEZATCP) PARM(RLSE)\n DATASET COPY  DSN(TCPIP.SEZAINST) PARM(LNK)\n DATASET COPY  DSN(TCPIP.HOSTS.LOCAL)\n\n*--------------------------------------------------------------------*\n* RACF DATASET AND ISPF LIBRARIES                                    *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.RACFP1)  PARM(RACFDS) MODE(RACF) -\n               SPACE(CYL,(25)) VOL(&CATVOL)\n DATASET COPY  DSN(  SYS1.HRFCLST) PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(  SYS1.HRFMSG)  PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(  SYS1.HRFPANL) PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(  SYS1.HRFSKEL) PARM(RLSE,ISPSLIB)\n\n*--------------------------------------------------------------------*\n* ISMF ISPF libraries                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN(SYS1.DGTCLIB)   PARM(RLSE,SYSPROC)\n DATASET COPY  DSN(SYS1.DGTLLIB)   PARM(RLSE,ISPLLIB)\n DATASET COPY  DSN(SYS1.DGTMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(SYS1.DGTPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(SYS1.DGTSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(SYS1.DGTTLIB)   PARM(RLSE,ISPTLIB)\n\n*--------------------------------------------------------------------*\n* SDSF Datasets                                                      *\n*--------------------------------------------------------------------*\n DATASET ALLOC DSN(ISF.HASPINDX) SPACE(CYL,5) MODEL(ISF.HASPINDX)\n DATASET COPY  DSN(ISF.SISFHELP)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFMOD1)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLINK)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLOAD)   PARM(RLSE,LNK)\n DATASET COPY  DSN(ISF.SISFLPA)    PARM(RLSE,LPA)\n DATASET COPY  DSN(ISF.SISFMLIB)   PARM(RLSE,ISPMLIB)\n DATASET COPY  DSN(ISF.SISFPLIB)   PARM(RLSE,ISPPLIB)\n DATASET COPY  DSN(ISF.SISFTLIB)   PARM(RLSE,ISPTLIB)\n DATASET COPY  DSN(ISF.SISFSLIB)   PARM(RLSE,ISPSLIB)\n DATASET COPY  DSN(ISF.SISFSRC)    PARM(RLSE)\n*--------------------------------------------------------------------*\n* VTAM / NCP DATASETS                                                *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( CPAC.VTAMLST)  PARM(VTAMLST)     VOL(&CATVOL)\n DATASET ALLOC DSN( CPAC.VTAMLIB)  SPACE(CYL,3) MODEL(SYS1.VTAMLIB)\n DATASET COPY  DSN( SYS1.VTAMLIB)  PARM(VTAMLIB,APF)\n DATASET COPY  DSN( SYS1.SISTCLIB) PARM(SISTCLIB,APF,RLSE)\n DATASET COPY  DSN( SYS1.SISTMAC1) PARM(RLSE)\n\n*--------------------------------------------------------------------*\n* HLASM DATASETS                                                     *\n*--------------------------------------------------------------------*\n DATASET COPY  DSN( ASM.SASMMAC1 ) PARM(RLSE)        VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMMAC2 ) PARM(RLSE)        VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMMOD1 ) PARM(RLSE,LNK)    VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMMOD2 ) PARM(RLSE,LNK)    VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMPUT2 ) PARM(RLSE)        VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMSAM1 ) PARM(RLSE)        VOL(&SYSVL1)\n DATASET COPY  DSN( ASM.SASMSAM2 ) PARM(RLSE)        VOL(&SYSVL1)\n./ ADD NAME=@PARMS\n*-------------------------------------------------------------------*\n*  ZCLONE system parameters.                                        *\n*  To assign parms, use statements like: PARM1  = Some Value        *\n*-------------------------------------------------------------------*\n*  03/10/2007 John C. Miller.                                       *\n*-------------------------------------------------------------------*\n CLN        = 210       /* My locally defined variable (JCM).\n SYSPLEX    = HRCPLEX   /* For couple dataset definition.\n\n*-------------------------------------------------------------------*\n* Jobcard info.  \"COMMENT\" is placed in each job.                   *\n* Jobname must be 7 chars or less to allow job char to be added.    *\n*-------------------------------------------------------------------*\n JOBCARD1   = //COMPJM  JOB (990030,135,60,100),JMILLER,CLASS=A,\n JOBCARD2   = //   NOTIFY=COMPJM,MSGCLASS=X,REGION=6M\n JOBCARD3   = /*JOBPARM LINES=999999\n COMMENT    = John C. Miller\n\n @DATASET   = @DATASET   /* Contains dataset definitions.  If omitted,\n                         /* defaults to @DATASET.\n\n*-------------------------------------------------------------------*\n* USESYM = YES means that indirect volume addressing will be used   *\n* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *\n*-------------------------------------------------------------------*\n USESYM     = NO                     /* Use indirect volsers.\n VALIDPARMS = YES                    /* Don't validate parms.\n\n*-------------------------------------------------------------------*\n* TSO PROC and Userids to be created on the new system.             *\n* TSOPROC should NOT exist on the driving system.  As many TSO ids  *\n* as desired can be specified here.                                 *\n*-------------------------------------------------------------------*\n TSOPROC    = TSOSYS                  /* TSOPROC to be built.\n TSOID1     = COMPJM                  /* TSO IDs to be defined on the\n TSOID2     = COMPJM2                 /* rescue system.\n TSOID3     =\n\n*-------------------------------------------------------------------*\n* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *\n* If you need more space, then specify VOLSER2 & ADDR2 for a second *\n* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *\n* volumes as desired can be specified here, but there must be an    *\n* ADDRn entry for each VOLSERn entry.                               *\n* Note:  System symbols will be defined for each volume beyond      *\n* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *\n* but only if USESYM = YES in this member.                          *\n*-------------------------------------------------------------------*\n DEVTYPE    = 3390                    /* Unit of RESCUE volume.\n ADDR1      = 914A                    /* Unit addr of volume.\n VOLSER1    = ZOS&CLN                 /* VOLSER.\n\n* Optional volume aliases *\n SYSVL1     = &VOLSER1                /* Volume alias.\n SYSVL2     = &VOLSER1                /* Volume alias.\n HFSVOL     = &VOLSER1                /* Volume alias.\n CATVOL     = &VOLSER1                /* Volume alias.\n PAGVL1     = &VOLSER1                /* Volume alias.\n PAGVL2     = &VOLSER1                /* Volume alias.\n\n*-------------------------------------------------------------------*\n* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *\n* No data is permanently left on this volume.                       *\n*-------------------------------------------------------------------*\n WORKVOL    = Z10001                  /* Volser for large work files.\n\n*-------------------------------------------------------------------*\n* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *\n* IOCONFIG ID in the IODF dataset that you specify.  This value is  *\n* inserted in the SYS1.IPLPARM(LOADxx) member.                      *\n*-------------------------------------------------------------------*\n IOCONFIGID = UCRPROD                 /* 8 char IO config ID for LOADxx\n SMFID      = Z&CLN                   /* 4 char SMF id for new system.\n\n*-------------------------------------------------------------------*\n* Catalog related parms.                                            *\n*-------------------------------------------------------------------*\n OLDMCAT    = CATALOG.Z10.MASTER      /* Driving sys master cat.\n NEWMCAT    = CATALOG.Z10.MST&CLN     /* New sys. mastercat name.\n NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.\n NEWUCAT    = CATALOG.Z10.SYS&CLN     /* New sys. usercat name.\n NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.\n UCATALIAS1 = SMS\n UCATALIAS2 = &TSOID1\n UCATALIAS2 = &TSOID2\n UCATALIAS2 = &TSOID3\n SSA        = SYSZC.                  /* Temp. dsn prefix used to\n SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is\n\n SYSRES     = Z10RES                  /* Driving sys sysres volume.\n COMMANDPGM = COMMAND                 /* \"COMMAND\" pgm is available.\n WAITPGM    = WAIT                    /* \"WAIT\" pgm is available.\n\n*-------------------------------------------------------------------*\n* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *\n* ZJES2PRM member to create a final JES2PARM member.  You must      *\n* define a SPOOL and at least one CKPT dataset in the @DATASET      *\n* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *\n* and the spool dataset should have the parm HASPACE.               *\n* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *\n* set to 4, for example, and the volser where the spool dataset is  *\n* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *\n*-------------------------------------------------------------------*\n SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.\n\n*-------------------------------------------------------------------*\n* RACF Parms.                                                       *\n* Note: Some of the RACF actions require RACF SPECIAL to perform.   *\n* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *\n* the resulting jobs will need RACF SPECIAL, or specific privileges *\n* for various RACF operations (CLAUTH, etc.)                        *\n*-------------------------------------------------------------------*\n*-------------------------------------------------------------------*\n* RFSTCx: Defines STCs for ICHRIN03 started task table.             *\n* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *\n* Each task defined will have privileged bit set on, so these tasks *\n* should be able to bypass most RACF Access checking.  Commands     *\n* for creating the specified IDs and Groups will be generated only  *\n* if the IDs/groups DO NOT already exist.                           *\n*-------------------------------------------------------------------*\n RFDSNT     = YES                     /* Create RACF ICHRDSNT\n RFSTC      = NO                      /* Create RACF ICHRIN03\n RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class\n\n*-------------------------------------------------------------------*\n* Started task support:                                             *\n* If entries are defined below, then an ICHRIN03 module will be     *\n* built with these entries.  An MLPA entry for this ICHRIN03        *\n* will be placed in IEALPA00.  Format of RFSTCx is:                 *\n* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *\n* This option may be most useful when building a single pack rescue *\n* system.  If your RACF dataset already has STARTED class profiles  *\n* for the started tasks listed below, then you don't need an STC.   *\n*-------------------------------------------------------------------*\n*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n./ ADD NAME=@PARM2\n*-------------------------------------------------------------------*\n*  ZCLONE system parameters.                                        *\n*  To assign parms, use statements like: PARM1  = Some Value        *\n*-------------------------------------------------------------------*\n*  03/10/2007 John C. Miller.                                       *\n*-------------------------------------------------------------------*\n CLN        = R01       /* My locally defined variable (JCM).\n SYSPLEX    = HRCPLEX   /* For couple dataset definition.\n SYSNAME    = TEST      /* For LPAR specific dsns.\n\n*-------------------------------------------------------------------*\n* Jobcard info.  \"COMMENT\" is placed in each job.                   *\n* Jobname must be 7 chars or less to allow job char to be added.    *\n*-------------------------------------------------------------------*\n JOBCARD1   = //SYSJCM1 JOB (990030,135,60,100),JMILLER,CLASS=A,\n JOBCARD2   = //   NOTIFY=SYSJCM1,MSGCLASS=X,REGION=6M\n JOBCARD3   = /*JOBPARM LINES=999999\n COMMENT    = John C. Miller\n\n @DATASET   = @DATA2     /* Contains dataset definitions.  If omitted,\n                         /* defaults to @DATASET.\n\n*-------------------------------------------------------------------*\n* USESYM = YES means that indirect volume addressing will be used   *\n* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *\n*-------------------------------------------------------------------*\n USESYM     = YES                    /* Use indirect volsers.\n VALIDPARMS = YES                    /* Don't validate parms.\n\n*-------------------------------------------------------------------*\n* TSO PROC and Userids to be created on the new system.             *\n* TSOPROC should NOT exist on the driving system.  As many TSO ids  *\n* as desired can be specified here.                                 *\n*-------------------------------------------------------------------*\n TSOPROC    = TSOSYS                  /* TSOPROC to be built.\n TSOID1     = COMPJM                  /* TSO IDs to be defined on the\n TSOID2     = COMPJM2                 /* rescue system.\n TSOID3     =\n\n*-------------------------------------------------------------------*\n* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *\n* If you need more space, then specify VOLSER2 & ADDR2 for a second *\n* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *\n* volumes as desired can be specified here, but there must be an    *\n* ADDRn entry for each VOLSERn entry.                               *\n* Note:  System symbols will be defined for each volume beyond      *\n* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *\n* but only if USESYM = YES in this member.                          *\n*-------------------------------------------------------------------*\n DEVTYPE    = 3390                    /* Unit of RESCUE volume.\n ADDR1      = 0271                    /* UNIT ADDR OF VOLUME.\n VOLSER1    = ZOSRS1                  /* VOLSER.\n ADDR2      = 0270                    /* UNIT ADDR OF VOLUME.\n VOLSER2    = ZOSCAT                  /* VOLSER.\n\n* Optional volume aliases *\n SYSVL1     = &VOLSER1                /* Volume alias.\n SYSVL2     = &VOLSER1                /* Volume alias.\n HFSVOL     = &VOLSER1                /* Volume alias.\n CATVOL     = ZOSCAT                  /* Volume alias.\n PAGVL1     = &VOLSER1                /* Volume alias.\n PAGVL2     = &VOLSER1                /* Volume alias.\n\n*-------------------------------------------------------------------*\n* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *\n* No data is permanently left on this volume.                       *\n*-------------------------------------------------------------------*\n WORKVOL    = Z10001                  /* Volser for large work files.\n\n*-------------------------------------------------------------------*\n* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *\n* IOCONFIG ID in the IODF dataset that you specify.  This value is  *\n* inserted in the SYS1.IPLPARM(LOADxx) member.                      *\n*-------------------------------------------------------------------*\n IOCONFIGID = PROD1                   /* 8 char IO config ID for LOADxx\n SMFID      = Z&CLN                   /* 4 char SMF id for new system.\n\n*-------------------------------------------------------------------*\n* Catalog related parms.                                            *\n*-------------------------------------------------------------------*\n OLDMCAT    = CATALOG.MSTZ110         /* Driving sys master cat.\n NEWMCAT    = CATALOG.MASTER          /* New sys. mastercat name.\n NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.\n NEWUCAT    = CATALOG.SYSTEM          /* New sys. usercat name.\n NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.\n UCATALIAS1 = SMS\n UCATALIAS2 = &TSOID1\n UCATALIAS2 = &TSOID2\n UCATALIAS2 = &TSOID3\n SSA        = SYSZC.                  /* Temp. dsn prefix used to\n SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is\n\n SYSRES     = Z10RES                  /* Driving sys sysres volume.\n COMMANDPGM = COMMAND                 /* \"COMMAND\" pgm is available.\n WAITPGM    = WAIT                    /* \"WAIT\" pgm is available.\n\n*-------------------------------------------------------------------*\n* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *\n* ZJES2PRM member to create a final JES2PARM member.  You must      *\n* define a SPOOL and at least one CKPT dataset in the @DATASET      *\n* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *\n* and the spool dataset should have the parm HASPACE.               *\n* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *\n* set to 4, for example, and the volser where the spool dataset is  *\n* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *\n*-------------------------------------------------------------------*\n SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.\n\n*-------------------------------------------------------------------*\n* RACF Parms.                                                       *\n* Note: Some of the RACF actions require RACF SPECIAL to perform.   *\n* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *\n* the resulting jobs will need RACF SPECIAL, or specific privileges *\n* for various RACF operations (CLAUTH, etc.)                        *\n*-------------------------------------------------------------------*\n*-------------------------------------------------------------------*\n* RFSTCx: Defines STCs for ICHRIN03 started task table.             *\n* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *\n* Each task defined will have privileged bit set on, so these tasks *\n* should be able to bypass most RACF Access checking.  Commands     *\n* for creating the specified IDs and Groups will be generated only  *\n* if the IDs/groups DO NOT already exist.                           *\n*-------------------------------------------------------------------*\n RFDSNT     = YES                     /* Create RACF ICHRDSNT\n RFSTC      = NO                      /* Create RACF ICHRIN03\n RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class\n\n*-------------------------------------------------------------------*\n* Started task support:                                             *\n* If entries are defined below, then an ICHRIN03 module will be     *\n* built with these entries.  An MLPA entry for this ICHRIN03        *\n* will be placed in IEALPA00.  Format of RFSTCx is:                 *\n* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *\n* This option may be most useful when building a single pack rescue *\n* system.  If your RACF dataset already has STARTED class profiles  *\n* for the started tasks listed below, then you don't need an STC.   *\n*-------------------------------------------------------------------*\n*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n./ ADD NAME=@PARM3   0104-10016-10018-1903-00142-00142-00000-COMPJM\n*-------------------------------------------------------------------*\n*  ZCLONE system parameters.                                        *\n*  To assign parms, use statements like: PARM1  = Some Value        *\n*-------------------------------------------------------------------*\n*  03/10/2007 John C. Miller.                                       *\n*-------------------------------------------------------------------*\n CLN        = R01       /* My locally defined variable (JCM).\n SYSPLEX    = HRCPLEX   /* For couple dataset definition.\n SYSNAME    = TEST      /* For LPAR specific dsns.\n\n*-------------------------------------------------------------------*\n* Jobcard info.  \"COMMENT\" is placed in each job.                   *\n* Jobname must be 7 chars or less to allow job char to be added.    *\n*-------------------------------------------------------------------*\n JOBCARD1   = //COMPJM  JOB (0),JMILLER,CLASS=A,\n JOBCARD2   = //   NOTIFY=COMPJM,MSGCLASS=X,REGION=6M\n JOBCARD3   = /*JOBPARM LINES=999999\n COMMENT    = John C. Miller\n\n @DATASET   = @DATA3     /* Contains dataset definitions.  If omitted,\n                         /* defaults to @DATASET.\n\n*-------------------------------------------------------------------*\n* USESYM = YES means that indirect volume addressing will be used   *\n* for NONVSAM datasets. &SYSR2-&SYSRn will be defined.              *\n*-------------------------------------------------------------------*\n USESYM     = YES                    /* Use indirect volsers.\n VALIDPARMS = NO                     /* Don't validate parms.\n\n*-------------------------------------------------------------------*\n* TSO PROC and Userids to be created on the new system.             *\n* TSOPROC should NOT exist on the driving system.  As many TSO ids  *\n* as desired can be specified here.                                 *\n*-------------------------------------------------------------------*\n TSOPROC    = TSOSYS                  /* TSOPROC to be built.\n TSOID1     = COMPJM                  /* TSO IDs to be defined on the\n TSOID2     = COMPJM2                 /* rescue system.\n TSOID3     =\n\n*-------------------------------------------------------------------*\n* Volume parameters.  You must specify at least VOLSER1 and ADDR1.  *\n* If you need more space, then specify VOLSER2 & ADDR2 for a second *\n* volume, and VOLSER3 & ADDR3 for a third volume, etc.  As many     *\n* volumes as desired can be specified here, but there must be an    *\n* ADDRn entry for each VOLSERn entry.                               *\n* Note:  System symbols will be defined for each volume beyond      *\n* VOLSER1.  &SYSR2 - &SYSRn will be defined for VOLSER2 and higher, *\n* but only if USESYM = YES in this member.                          *\n*-------------------------------------------------------------------*\n DEVTYPE    = 3390                    /* Unit of RESCUE volume.\n ADDR1      = 9150                    /* UNIT ADDR OF VOLUME.\n VOLSER1    = ZOSRS1                  /* VOLSER.\n ADDR2      = 9051                    /* UNIT ADDR OF VOLUME.\n VOLSER2    = ZOSCAT                  /* VOLSER.\n\n* Optional volume aliases *\n SYSVL1     = &VOLSER1                /* Volume alias.\n SYSVL2     = &VOLSER1                /* Volume alias.\n HFSVOL     = &VOLSER1                /* Volume alias.\n CATVOL     = &VOLSER2                /* Volume alias.\n PAGVL1     = &VOLSER1                /* Volume alias.\n PAGVL2     = &VOLSER1                /* Volume alias.\n\n*-------------------------------------------------------------------*\n* WORKVOL - Not needed if you have plenty of PUBLIC mounted disk.   *\n* No data is permanently left on this volume.                       *\n*-------------------------------------------------------------------*\n WORKVOL    = Z10001                  /* Volser for large work files.\n\n*-------------------------------------------------------------------*\n* IOCONFIGID - Use HCD to be sure this value is defined as a valid  *\n* IOCONFIG ID in the IODF dataset that you specify.  This value is  *\n* inserted in the SYS1.IPLPARM(LOADxx) member.                      *\n*-------------------------------------------------------------------*\n IOCONFIGID = PROD1                   /* 8 char IO config ID for LOADxx\n SMFID      = Z&CLN                   /* 4 char SMF id for new system.\n\n*-------------------------------------------------------------------*\n* Catalog related parms.                                            *\n*-------------------------------------------------------------------*\n OLDMCAT    = CATALOG.Z10.MASTER      /* Driving sys master cat.\n NEWMCAT    = CATALOG.MASTER          /* New sys. mastercat name.\n NEWMCATVOL = &CATVOL                 /* New sys. mastercat vol.\n NEWUCAT    = CATALOG.SYSTEM          /* New sys. usercat name.\n NEWUCATVOL = &CATVOL                 /* New sys. usercat vol.\n UCATALIAS1 = &TSOID1\n UCATALIAS2 = &TSOID2\n UCATALIAS3 = &TSOID3\n SSA        = SYSZC.                  /* Temp. dsn prefix used to\n SSAU       = SYSUC.                  /* avoid ENQ problems. SSAU is\n\n SYSRES     = Z10RES                  /* Driving sys sysres volume.\n COMMANDPGM = COMMAND                 /* \"COMMAND\" pgm is available.\n WAITPGM    = WAIT                    /* \"WAIT\" pgm is available.\n\n*-------------------------------------------------------------------*\n* JES2 Parms.  A SPOOLDEF and CKPTDEF entry will be added to the    *\n* ZJES2PRM member to create a final JES2PARM member.  You must      *\n* define a SPOOL and at least one CKPT dataset in the @DATASET      *\n* member.  The CKPT dataset(s) should have the parm of HASPCKPT,    *\n* and the spool dataset should have the parm HASPACE.               *\n* SPOOLPRF is the length of the SPOOLDEF VOLUME= parm.  If it is    *\n* set to 4, for example, and the volser where the spool dataset is  *\n* allocated is RESCUE, then the SPOOLDEF VOLUME=RESC is coded.      *\n*-------------------------------------------------------------------*\n SPOOLPRF   = 5                       /* Length of SPOOLDEF prefix.\n\n*-------------------------------------------------------------------*\n* RACF Parms.                                                       *\n* Note: Some of the RACF actions require RACF SPECIAL to perform.   *\n* Any TSO ID can run the RESCUE execs, but the RACF ID used to run  *\n* the resulting jobs will need RACF SPECIAL, or specific privileges *\n* for various RACF operations (CLAUTH, etc.)                        *\n*-------------------------------------------------------------------*\n*-------------------------------------------------------------------*\n* RFSTCx: Defines STCs for ICHRIN03 started task table.             *\n* p1 = Task name, p2 = RACF ID, p3 = RACF group.                    *\n* Each task defined will have privileged bit set on, so these tasks *\n* should be able to bypass most RACF Access checking.  Commands     *\n* for creating the specified IDs and Groups will be generated only  *\n* if the IDs/groups DO NOT already exist.                           *\n*-------------------------------------------------------------------*\n RFDSNT     = YES                     /* Create RACF ICHRDSNT\n RFSTC      = NO                      /* Create RACF ICHRIN03\n RFTSOPROC  = YES                     /* Define TSOPROC to TSOPROC class\n\n*-------------------------------------------------------------------*\n* Started task support:                                             *\n* If entries are defined below, then an ICHRIN03 module will be     *\n* built with these entries.  An MLPA entry for this ICHRIN03        *\n* will be placed in IEALPA00.  Format of RFSTCx is:                 *\n* RFSTCx = stcname, racfid, racfgrp  All three parms are required.  *\n* This option may be most useful when building a single pack rescue *\n* system.  If your RACF dataset already has STARTED class profiles  *\n* for the started tasks listed below, then you don't need an STC.   *\n*-------------------------------------------------------------------*\n*RFSTC1     = RACF,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC2     = JES2,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n**FSTC3     = VTAM,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC4     = TSO,     $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC5     = TCPIP,   $RESCUE, $STC  /* STCs to go in ICHRIN03\n*RFSTC6     = OMVS,    $RESCUE, $STC  /* STCs to go in ICHRIN03\n./ ADD NAME=@SUBRL\n/*-------------------------------=Rexx----*/\n/* @SUBR - EDIT MACRO                     */\n/*----------------------------------------*/\n/* 08/31/2007 John C. Miller              */\n/*----------------------------------------*/\n/* Purpose: Replace subroutines in a src. */\n/*----------------------------------------*/\nADDRESS ISREDIT\nMACRO\nmember = \"SUBR\"\n\n/* Get last line of member */\n\"(LINELST) = LINENUM .ZL\"\n\n\"F 'low level functions'\"\nIF rc > 0 THEN signal done\n\"(LINESTR) = LINENUM .ZCSR\"\nLINESTR = LINESTR - 2\nIF LINESTR < 0 THEN LINESTR = 1\n\n\"DELETE \"LINESTR LINELST\n\"COPY \"member\" AFTER \"LINESTR-1\n\"CHANGE 'setout pds' 'setout opds' ALL\"\n\"CHANGE 'setinp pds' 'setinp ipds' ALL\"\n\"CHANGE 'clsout pds' 'clsout opds' ALL\"\n\"CHANGE 'ARG jobnum ipds opds .' 'ARG jobnum ipds opds zzprms .' ALL\"\n\"CHANGE 'call varinit' 'IF \\varinit() THEN RETURN' ALL\"\n\"CHANGE 'F \\varinit() THEN RETURN 0' 'F \\varinit() THEN RETURN 1' ALL\"\n\ndone:\n\"END\"\n./ ADD NAME=COMMAND\n//COMPJMA JOB (990030,135,60,100),JMILLER,CLASS=A,\n//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M\n//  JCLLIB ORDER=('CPAC.PROCLIB')\n//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL,AC(1)'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD  *\nCOMMAND  TITLE 'C O M M A N D  --  ISSUE SYSTEM OPERATOR COMMANDS V2.0'\n***********************************************************************\n*                                                                     *\n*                           C O M M A N D                             *\n*                                                                     *\n*                   ISSUE SYSTEM OPERATOR COMMANDS                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: This version has RACHECK code added to be sure that the       *\n* caller has at least READ access to the COMMAND profile of the       *\n* APPL RACF class.  To permit use of the COMMAND command:             *\n*                                                                     *\n*    RDEFINE APPL COMMAND UACC(NONE)                                  *\n*    PERMIT  COMMAND CLASS(APPL) ID(userid)                           *\n*                                                                     *\n* 03/21/2001 John C. Miller                                           *\n***********************************************************************\n*                                                                     *\n*     THIS PROGRAM ACCEPTS SYSTEM OR JES OPERATOR COMMANDS AS         *\n*     INPUT AND EXECUTES THEM USING SVC 34. IT MUST BE APF            *\n*     AUTHORIZED.                                                     *\n*                                                                     *\n*     COMMAND CAN OPERATE IN ONE OF THREE MODES:                      *\n*                                                                     *\n*     1) BATCH OR CALLED PROGRAM                                      *\n*        IN THIS MODE COMMAND ACCEPTS INPUT AS EITHER 80-BYTE         *\n*        CARD IMAGES FROM SYSIN OR A SINGLE COMMAND FROM THE PARM     *\n*        FIELD. THE RESPONSE TO THE OPERATOR COMMAND WILL             *\n*        APPEAR ON ALL OPERATOR CONSOLES. FOR EXAMPLE:                *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND,PARM='VARY 017,ONLINE'        *\n*                                                                     *\n*           - OR -                                                    *\n*                                                                     *\n*           //STEP1    EXEC PGM=COMMAND                               *\n*           //SYSIN    DD *                                           *\n*           VARY 017,ONLINE                                           *\n*           /*                                                        *\n*                                                                     *\n*        IF COMMANDS ARE FETCHED FROM SYSIN, A DELAY OF 2 SECONDS     *\n*        WILL BE ADDED BETWEEN COMMANDS.                              *\n*                                                                     *\n*     2) TSO COMMAND PROCESSOR                                        *\n*        IN THIS MODE COMMAND EXPECTS TO FIND THE OPERATOR COMMAND    *\n*        DIRECTLY FOLLOWING ON THE TSO INPUT LINE. THE RESPONSE TO    *\n*        OS COMMANDS WILL THEN BE DISPLAYED ON THE TSO TERMINAL.      *\n*        RESPONSE TO JES COMMANDS WILL APPEAR ON YOUR TERMINAL        *\n*        PROVIDED A LOCAL MODIFICATION IS MADE TO JES2 TO ALLOW       *\n*        IT TO INTERCEPT THE COMMAND AND SET THE RESPONSE TO TSO.     *\n*        OTHERWISE, JES2 COMMANDS WILL APPEAR ON ALL CONSOLES.        *\n*        FOR EXAMPLE:                                                 *\n*                                                                     *\n*           COMMAND D T         <--- (RESPONSE WILL APPEAR ON CRT)    *\n*                                                                     *\n*     3) CALLABLE SUBROUTINE                                          *\n*        IN THIS MODE COMMAND ACCEPTS INPUT ACCORDING TO STANDARD     *\n*        OS LINKAGE CONVENTIONS. IN ADDITION TO THE COMMAND ITSELF,   *\n*        A SECOND PARAMETER MAY BE PASSED WHICH CONTAINS THE          *\n*        CONSOLE NUMBER WHERE YOU WISH THE RESPONSE TO APPEAR.        *\n*        (THE SVC 34 WILL ALSO ASSUME THE AUTHORITY OF THAT           *\n*        CONSOLE.) FOR EXAMPLE:                                       *\n*                                                                     *\n*           LA       R1,CMDADDR                                       *\n*           LA       R15,=V(COMMAND)                                  *\n*           BALR     R14,R15                                          *\n*                                                                     *\n*           CMDADDR  DC    A(OPERCMD)                                 *\n*           CNSADDR  DC    XL1'80',AL3(CONSOLE)                       *\n*           OPERCMD  DC    H(3),CL3'D T'                              *\n*           CONSOLE  DC    F'5'                                       *\n*                                                                     *\n*        THIS WOULD MAKE IT APPEAR AS IF 'D T' WERE ISSUED FROM       *\n*        CONSOLE 5. (THIS METHOD IS USED BY PROGRAM 'SPY')            *\n*                                                                     *\n*        COMMAND MAY BE USED TO ISSUE REPLIES TO WTORS.               *\n*                                                                     *\n*     AUTHOR:                                                         *\n*       THE ORIGINAL VERSION OF COMMAND WAS WRITTEN BY MARK SORKIN.   *\n*       THE CURRENT VERSION HAS BEEN HEAVILY MODIFIED AT SCE.         *\n*       QUESTIONS AND COMMENTS MAY BE SENT TO                         *\n*                                                                     *\n*          STEVE LANGLEY                                              *\n*          SOUTHERN CALIFORNIA EDISON                                 *\n*          P.O. BOX 800                                               *\n*          ROSEMEAD, CALIF. 91770                                     *\n*          1-213-572-3435                                             *\n*                                                                     *\n*     IMPLEMENTOR:                                          *HMD 07/81*\n*       THIS PROGRAM HAS BEEN REVISED AND IMPLEMENTED AT    *HMD 07/81*\n*       GTE DATA SERVICES, MARINA DEL REY, CA BY:           *HMD 07/81*\n*                                                           *HMD 07/81*\n*          HOWARD M. DEAN                                   *HMD 07/81*\n*          GTE DATA SERVICES                                *HMD 07/81*\n*          4750 LINCOLN BLVD.                               *HMD 07/81*\n*          MARINA DEL REY, CALIF. 90291                     *HMD 07/81*\n*          PHONE - (213) - 821-0511                         *HMD 07/81*\n*                                                           *HMD 07/81*\n*       CHANGES MADE BY THE ABOVE ARE MARKED WITH           *HMD 07/81*\n*       '*HMD XX/XX*' IN COL 61-71. XX/XX IS THE            *HMD 07/81*\n*       CHANGE DATE (MONTH AND YEAR).                       *HMD 07/81*\n***********************************************************************\n         EJECT\nCOMMAND  CSECT\n         SPACE 3\nR0       EQU   0                  REGISTER 0\nR1       EQU   1                  REGISTER 1\nR2       EQU   2                  WORK REGISTER\nR3       EQU   3                  WORK REGISTER\nR4       EQU   4                  WORK REGISTER\nR5       EQU   5                  WORK REGISTER\nR6       EQU   6                  WORK REGISTER             *HMD 07/81*\nR7       EQU   7                  WORK REGISTER             *HMD 07/81*\nR8       EQU   8                  WORK REGISTER             *HMD 07/81*\nR9       EQU   9                  WORK REGISTER             *HMD 07/81*\nR10      EQU   10                 PARAMETER LIST ADDRESS REGISTER\nR11      EQU   11                 SUBROUTINE LINKAGE REGISTER\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13                 SAVE AREA ADDRESS REGISTER\nR14      EQU   14                 REGISTER 14\nR15      EQU   15                 REGISTER 15\n         EJECT\n         SAVE  (14,12)            SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH\n         USING COMMAND,R12        ADDRESSABILITY\n         LA    R3,SAVEAREA        GET OUR SAVEAREA ADDRESS\n         ST    R13,SAVEAREA+4     ESTABLISH BACK\n         ST    R3,8(R13)          AND FORWARD SAVEAREA POINTERS\n         LR    R13,R3             ESTABLISH OUR SAVEAREA ADDRESS\n         LR    R10,R1             SAVE PARAMETER REGISTER\n         SPACE 2\n*********************************************************** *CKO 07/92*\n* Determine whether user is authorized to the application   *CKO 07/92*\n*********************************************************** *CKO 07/92*\nRACHK    EQU  *                                             *CKO 07/92*\n         RACHECK ENTITY=(CMDENT),CLASS=CMDCLS,ATTR=READ     *CKO 07/92*\n         LTR  R15,R15             Authorized to this prog?  *CKO 07/92*\n         BNZ  NOTAUTH             Nope.                     *CKO 07/92*\n         SPACE 2                                            *CKO 07/92*\n         L     R2,CVTPTR          R2 = ADDR OF CVT\n         USING CVT,R2\n         L     R3,CVTTCBP         R3 = ADDR OF MAGIC QUADWORD\n         L     R4,12(R3)          R4 = ADDR OF OUR ASCB\n         USING ASCB,R4\n         MVC   ASID,ASCBASID      SAVE OUR ASID\n         DROP  R4\n         L     R4,CVTCUCB         ADDR OF 'CUCB' (UCM BASE) *HMD 07/81*\n         DROP  R2                 NO NEED FOR CVT BASE NOW  *HMD 07/81*\n         USING UCM,R4             ADDRESS THE UCM           *HMD 07/81*\n         LR    R2,R4              R2 = R4                   *HMD 07/81*\n         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCMP *HMD 07/81*\n         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX   *HMD 07/81*\n         USING UCMPRFX,R2         ADDRESS THE PREFIX        *HMD 07/81*\n         L     R5,UCMVEA          R5 = ADDR OF 1ST UCM ENTRY*HMD 07/81*\n         L     R6,UCMVEZ          R6 = LNGTH OF EACH ENTRY  *HMD 07/81*\n         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENT.*HMD 07/81*\n         SLR   R8,R8              R8 = CONSOLE COUNTER      *HMD 07/81*\nUCMLOOP  LA    R8,1(R8)           R8 = CONSOLE NUMBER       *HMD 07/81*\n         C     R5,UCM_DNR_RSV02   IS THIS THE MASTER CON    *HMD 07/81*\n         BNE   UCMNEXT            NO, CONTINUE LOOKING      *HMD 07/81*\n         ST    R8,R0MASK          SAVE MSTR CONSOLE NUMBER  *HMD 07/81*\n         B     INITDONE           DONE WITH THIS NOW        *HMD 07/81*\nUCMNEXT  AR    R5,R6              BUMP TO NEXT UCM ENTRY    *HMD 07/81*\n         CR    R5,R7              END OF UCM'S?             *HMD 07/81*\n         BL    UCMLOOP            NO, CONTINUE              *HMD 07/81*\n         DROP  R2,R4              GET RID OF BASES          *HMD 07/81*\n         SPACE 3\nINITDONE DS    0H                 CHECK OUT INPUT PARM\n         MVI   CARD,C' '          CLEAR OUT COMMAND AREA    *HMD 07/81*\n         MVC   CARD+1(L'CARD-1),CARD                        *HMD 07/81*\n         TM    0(R10),X'80'       IS FIRST THE ONLY PARM?\n         BO    ONEPARM            YES; ONLY PARM\n         TM    4(R10),X'80'       IS SECOND THE LAST PARM?\n         BO    TWOPARMS           YES; TWO PARMS (CALLED WITH CNXX)\n***********************************************************************\n*                                                                     *\n*     A X'80' WAS NOT FOUND IN THE HIGH ORDER BYTE OF THE FIRST       *\n*     TWO PARMS, SO WE CAN ASSUME COMMAND IS BEING CALLED AS A CP.    *\n*     PLACE OUR ASID IN THE R0 MASK AND CONTINUE.                     *\n*                                                                     *\n***********************************************************************\n         XR    R2,R2              CLEAR R2\n         ICM   R2,B'0011',ASID    R2 = ASID OF CALLER\n         O     R2,=XL4'00008000'  TELL SVC34 ITS AN ASID\n         ST    R2,R0MASK          AND OVERRIDE THE R0 MASK\n         L     R3,0(R10)          R3 = ADDR OF INPUT LINE\n         LA    R4,4(R3)           R4 = ADDR OF FIRST CHAR OF INPUT\n         AH    R4,2(R3)           R4 = ADDR OF FIRST CHAR PAST COMMAND\n         LH    R2,0(R3)           R2 = TOTAL LENGTH OF STRING\n         SH    R2,=H'4'           R2 = LENGTH MINUS HEADER  *HMD 07/81*\n         SH    R2,2(R3)           R2 = LENGTH OF OPER CMD   *HMD 07/81*\n         BNP   EOJ                IS NO COMMAND GOTO EOJ    *HMD 07/81*\n         CH    R2,=H'100'         IS LENGTH TOO LONG?       *HMD 07/81*\n         BNH   LENOK              LENGTH IS OK              *HMD 07/81*\n         LA    R2,100             ONLY 1ST 100 BYTES        *HMD 07/81*\nLENOK    BCTR  R2,0               R2 = R2 - 1 FOR EX MVC\n         EX    R2,MOVE1           MOVE CMD INTO CARD\n*************************************************************HMD 07/82*\n** THE FOLLOWING CODE IS NECESSARY THE ENABLE THIS COMMAND  *HMD 07/82*\n** TO WORK UNDER MVS/SP RELEASE 3. THIS IS DUE TO A CHANGE  *HMD 07/82*\n** IN THE COMMAND SCHEDULER CSCB CREATION MODULE IEE0803D.  *HMD 07/82*\n**                                                          *HMD 07/82*\n** IN MVS/SP 3, IF AN ASID IS PRESENT IN THE XSA, THEN THE  *HMD 07/82*\n** COMMAND SCHEDULER MOVES YOUR TSO USERID INTO THE NEWLY   *HMD 07/82*\n** CREATED CSCB. WHY THIS IS DONE, WHO KNOWS. IT CAUSES,    *HMD 07/82*\n** HOWEVER, THE STC INITIALIZATION ROUTINE IEEPRWI2 TO      *HMD 07/82*\n** THINK THAT A 'SYSTEM' ADDRESS SPACE IS BEING CREATED     *HMD 07/82*\n** DUE TO THE CHKEY FIELD OF THE CSCB CONTAINING YOUR       *HMD 07/82*\n** USERID INSTEAD OF ZERO. BECAUSE THIS ADDRESS SPACE       *HMD 07/82*\n** INITIALIZATION ROUTINE NAME FOR SYSTEM ADDRESS SPACES    *HMD 07/82*\n** IS CONTAINED IN THE CHKEY FIELD, IEEPRWI2 ATTEMPT TO     *HMD 07/82*\n** LINK TO YOUR TSO USERID TO INITIALIZE THE STARTED        *HMD 07/82*\n** ADDRESS SPACE. THUS AN ABEND806-4 AND A RESULTING SVC    *HMD 07/82*\n** DUMP.                                                    *HMD 07/82*\n**                                                          *HMD 07/82*\n** SINCE RESPONSE AT THE TERMINAL IS NOT REQUIRED FOR       *HMD 07/82*\n** START AND MOUNT COMMANDS (AND THAT IS THE ONLY PLACE     *HMD 07/82*\n** THIS CRAZY THING HAPPENS) WE WILL ISSUE THOSE COMMANDS   *HMD 07/82*\n** WITH REGISTER ZERO EQUAL TO ZERO.                        *HMD 07/82*\n*************************************************************HMD 07/82*\n         CLC   =C'LOGON ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'logon ',CARD    LOGON COMMAND?            *HMD 07/82*\n         BE    EOJ                DON'T BE SILLY            *HMD 07/82*\n         CLC   =C'START ',CARD    IS IT A START COMMAND?    *HMD 07/82*\n         BE    STARTM             YES..CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'S ',CARD        START COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'MOUNT ',CARD    MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             YES, CLEAR R0MASK         *HMD 07/82*\n         CLC   =C'M ',CARD        MOUNT COMMAND?            *HMD 07/82*\n         BE    STARTM             NO COMTINUE WITH COMMANDS *HMD 07/82*\n         CLC   =C'start ',CARD    L         C               *HMD 07/82*\n         BE    STARTM               O          A            *HMD 07/82*\n         CLC   =C's ',CARD            W            S        *HMD 07/82*\n         BE    STARTM                   E             E     *HMD 07/82*\n         CLC   =C'mount ',CARD            R                 *HMD 07/82*\n         BE    STARTM                                       *HMD 07/82*\n         CLC   =C'm ',CARD                                  *HMD 07/82*\n         BNE   DOCMD              NO COMTINUE WITH COMMANDS *HMD 07/82*\nSTARTM   XC    R0MASK,R0MASK      CLEAR REGISTER 0 MASK     *HMD 07/82*\nDOCMD    B     DOSVC34            GO DO THE COMMAND\n***********************************************************************\n*                                                                     *\n*     X'80' WAS FOUND IN THE HIGH ORDER BYTE OF THE SECOND PARM,      *\n*     SO WE HAVE BEEN CALLED AS A SUBROUTINE (MODE 3). THE SECOND     *\n*     PARM CONTAINS THE CONSOLE ID WHERE THE COMMAND IS TO 'COME      *\n*     FROM', SO USE THAT FOR THE R0 MASK.                             *\n*                                                                     *\n***********************************************************************\nTWOPARMS L     R3,4(R10)          R3 = ADDR OF R0 MASK FOR SVC34\n         MVC   R0MASK(4),0(R3)    SAVE R0 MASK FOR SVC34\n***********************************************************************\n*                                                                     *\n*     ONLY ONE PARM WAS PASSED, SO WE ARE BEING CALLED IN MODE 1.     *\n*     JUST ISSUE THE COMMAND FROM THE PARM STRING.                    *\n*                                                                     *\n***********************************************************************\nONEPARM  L     R10,0(R10)         GET PARAMETER ADDRESS\n         SLR   R3,R3              CLEAR FOR ICM             *HMD 07/81*\n         ICM   R3,B'0011',0(R10)  GET PARAMETER TEXT LENGTH\n         BZ    USESYSIN           NO - GO GET COMMANDS FROM SYSIN\n         CH    R3,=H'100'         COMMAND TOO LONG?         *HMD 07/81*\n         BNH   CMDOK              NO, IS OK                 *HMD 07/81*\n         LA    R3,100             ONLY DO 1ST 100 BYTES     *HMD 07/81*\nCMDOK    BCTR  R3,R0              DECREMENT R3 FOR USE IN EXECUTE\n         EX    R3,MOVE            EXECUTE MVC\nDOSVC34  LA    R11,EOJ            GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*     NO PARM FIELD FOUND, SO LOOK AT SYSIN FOR INPUT                 *\n*                                                                     *\n***********************************************************************\nUSESYSIN OPEN  (SYSIN,INPUT)      OPEN SYSIN\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n         BZ    EOJ                IF BAD OPEN; END OF PGM   *HMD 07/81*\nGETSYSIN GET   SYSIN,CARD         GET A SYSIN RECORD INTO SVC34 LIST\n         MVC   CARD+72(8),CARD+80 BLANK OUT SEQUENCE FIELD IN 73-80\n         CLI   CARD,C'*'          IS THIS A COMMENT?\n         BE    GETSYSIN           YES;GO GET ANOTHER CARD\n         LA    R11,GETSYSIN       GET ADDRESS FOR RETURN FROM SVC34\n         B     SVC34              GO ISSUE COMMAND\n         SPACE 3\nEODSYSIN CLOSE (SYSIN)            CLOSE SYSIN\n         SPACE 3\nEOJ      L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S SAVEAREA\n         RETURN (14,12),RC=0      RETURN TO CALLER\n         SPACE 3                                            *CKO 07/92*\nBADEOJ   L     R13,SAVEAREA+4     GET ADDRESS OF CALLER'S   *CKO 07/92*\n         RETURN (14,12),RC=8      SAVE AREA & RETURN        *CKO 07/92*\n         EJECT\n***********************************************************************\n*                                                                     *\n*     THIS ROUTINE ACTUALLY ISSUES THE SVC 34. IT EITHER RETURNS      *\n*     TO THE SYSIN-READ LOOP OR EOJ DEPENDING ON THE VALUE OF R11     *\n*                                                                     *\n***********************************************************************\nSVC34    DS    0H\n         LA    R3,CARD+L'CARD-1   POINT TO END OF TEXT      *HMD 07/81*\n         LA    R4,CARD-1          POINT TO START OF TEXT    *HMD 07/81*\nFINDTEXT DS    0H                 FIND LAST TEXT CHARACTER\n         CR    R3,R4              ALL BLANK?\n         BNH   SVC34END           YES - IGNORE IT\n         CLI   0(R3),C' '         BLANK CHARACTER?\n         BNE   GOTTEXT            NO - FOUND END OF TEXT\n         BCT   R3,FINDTEXT        KEEP ON LOOKING\n         SPACE\nGOTTEXT  DS    0H                 BUILD PARAMETER LIST LENGTHS\n         SR    R3,R4              COMPUTE LENGTH OF COMMAND *HMD 07/81*\n         BNP   SVC34END           INVALID COMMAND           *HMD 07/81*\n         LA    R3,5(R3)           TEXT AND LIST PREFIX\n         STH   R3,CMDLIST         SET SVC 34 LIST LENGTH\n         TESTAUTH FCTN=1          SEE IF WE ARE AUTHORIZED  *HMD 07/82*\n         LTR   R15,R15            WELL, ARE WE?             *HMD 07/82*\n         BZ    MODEOK             YES..JUST DO MODESET      *HMD 07/82*\n         MVI   AUTHFLG,AUTHUS     INDICATE WE TURNED ON     *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN ON APF AUTHORIZATION. A SAMPLE\n* OF SUCH AN SVC IS ON THE LA MVS USER GROUP TAPE. THIS WILL ALLOW\n* 'COMMAND' TO BE USED UNDER SPF OPTION 6 OR VIA THE 'CALL' COMMAND.\n* ALSO, YOU WILL AVOID THE MESSY JOB OF UPDATING TABLES IN IKJEFT02.\n         LTR   R15,R15            SYSTEM PROGRAMMER?        *HMD 07/82*\n         BNZ   SVC34END           NOPE..DO NOT WASTE TIME   *HMD 07/82*\nMODEOK   DS    0H                                           *HMD 07/82*\n*        LA    R0,MSG1            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n*        WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MVC   WTOCMD(101),CARD   MOVE IN COMMAND           *BAC 05/90*\n         LA    R0,MSG2            ISSUE MESSAGE FOR COMMAND *BAC 05/90*\n         WTO   MF=(E,(R0))                                  *BAC 05/90*\n         MODESET KEY=ZERO         INDICATE KEY=ZERO\n         SYSEVENT DONTSWAP        DONT GET SWAPPED          *HMD 07/81*\n         L     R0,R0MASK          LOAD R0 FOR SVC34         *HMD 07/81*\n         MGCR  CMDLIST            ISSUE OPERATOR COMMAND    *HMD 07/81*\n         TM    SYSIN+DCBOFLGS-IHADCB,DCBOFOPN               *HMD 07/81*\n*                                 ARE WE USING SYSIN?       *HMD 07/81*\n         BZ    NOSTIMR            NO, DO NOT DELAY          *HMD 07/81*\n         STIMER  WAIT,BINTVL=HOLD WAIT FOR A COMPLETION     *HMD 07/81*\nNOSTIMR  SYSEVENT OKSWAP          OK TO GET SWAPPED NOW     *HMD 07/81*\n         MODESET KEY=NZERO        GO BACK TO USER KEY\n         CLI   AUTHFLG,AUTHUS     DID WE TURN ON AUTH?      *HMD 07/82*\n         BNE   SVC34END           NO..JUST RETURN           *HMD 07/82*\n* INSERT YOUR USER SVC HERE TO TURN OFF APF AUTHORIZATION, AS WE ARE\n* DONE ISSUING COMMANDS.\n         SPACE\nSVC34END DS    0H                 END OF COMMAND ROUTINE\n         BR    R11                RETURN TO MAINLINE\n         SPACE 2                                            *CKO 07/92*\nNOTAUTH  EQU  *                                             *CKO 07/92*\n         TPUT  =CL60'Authorization failed for executing COMMAND',60\n         B     BADEOJ                     Exit              *CKO 07/92*\n         EJECT\nSAVEAREA DC    18F'0'             OUR SAVEAREA\nHOLD     DC    F'200'             WAIT FOR 2 SECONDS        *HMD 07/81*\nR0MASK   DC    A(0)               R0 MASK FOR SVC34\nAUTHFLG  DC    X'00'              AUTHORIZATION FLAG        *HMD 07/82*\nAUTHUS   EQU   X'FF'              WE AUTHORIZED FOR SVC34   *HMD 07/82*\nMOREFLG  DC    X'00'              EXTRA FILLER              *HMD 07/82*\nASID     DC    H'00'              OUR ASID\n* Parms for RACHECK                                         *CKO 07/92*\nCMDENT   DC    CL8'COMMAND'                                 *CKO 07/92*\nCMDCLS   DC    AL1(4),C'APPL'                               *CKO 07/92*\n         SPACE\n         CNOP  4,8                ALIGN TO MIDDLE OF DOUBLE WORD\nCMDLIST  DC    AL2(*-*,0)         SVC 34 LIST\nCARD     DC    CL101' '           COMMAND TEXT\n         SPACE 3\nMOVE     MVC   CARD(*-*),2(R10)   MOVE PARM TEXT INTO SVC 34 LIST\nMOVE1    MVC   CARD(*-*),0(R4)    MOVE PARM TEXT INTO SVC 34 LIST\n         EJECT\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),RECFM=FB,     *\n               EODAD=EODSYSIN\nMSG1     WTO 'SYSTEMS PROGRAMMER BRIAN COURT ISSUES THE FOLLOWING COMMAX\n               ND:',MF=L\nMSG2     WTO '                                                         X\n                                                          ',MF=L\nWTOCMD   EQU MSG2+4\n         EJECT\n         LTORG                    BEGIN LITERAL POOL\n         EJECT\n***********************************************************************\n*                                                                     *\n*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *\n*                                                                     *\n*      ALL THESE MACROS CAN BE FOUND IN THE 'SYS1.AMODGEN' MACLIB     *\n*                                                                     *\n***********************************************************************\n         CVT   DSECT=YES,LIST=YES COMMUNICATIONS VECTOR TABLE\n         EJECT\n         IHAASCB                  ADDRESS SPACE CONTROL BLOCK\n         EJECT\n         IEECUCM  FORMAT=NEW      UNIT CONTROL MODULE       *HMD 07/81*\n         EJECT                                              *HMD 07/81*\n         DCBD  DSORG=PS,DEVD=DA   DCB SYMBOLIC DEFN         *HMD 07/81*\n         END\n//L.SYSLMOD DD  DSN=SYS2.LINKLIB(COMMAND),DISP=SHR\n./ ADD NAME=CONSOL00\nINIT     CMDDELIM(\")\n         MLIM(1500)\n         MONITOR(DSNAME)\n         MMS(NO)\n         PFK(00)\n         RLIM(10)\n         UEXIT(N)\nDEFAULT ROUTCODE(ALL)\n/********************************************************************/\n/*                                                                  */\n/* MASTER AND ALTERNATE CONSOLES                                    */\n/*                                                                  */\n/********************************************************************/\n/* LIB: SYS1.PARMLIB(CONSOL00)                                       */\n/* GDE: CBIPO MVS CUSTOMIZATION                                      */\n/* DOC: THIS MEMBER CONTAINS THE MVS CUSTOM-BUILT IPO                */\n/*      SUPPLIED CONSOLE DEFINITIONS FOR THE MASTER                  */\n/*      CONSOLE AND THE ALTERNATE CONSOLES                           */\n/*                                                                   */\nCONSOLE DEVNUM(SYSCONS) ROUTCODE(ALL)\n        MONITOR(JOBNAMES-T)\n/*                                                                  */\nCONSOLE DEVNUM(0A0) ROUTCODE(ALL)\n        NAME(CON1)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(0A8) ROUTCODE(ALL)\n        NAME(CON2)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(0B0) ROUTCODE(ALL)\n        NAME(CON3)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(0B8) ROUTCODE(ALL)\n        NAME(CON4)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(120) ROUTCODE(ALL)\n        NAME(CON5)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(128) ROUTCODE(ALL)\n        NAME(CON6)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(130) ROUTCODE(ALL)\n        NAME(CON7)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\nCONSOLE DEVNUM(138) ROUTCODE(ALL)\n        NAME(CON8)\n        PFKTAB(PFKTAB1)\n        AUTH(MASTER)\n        UNIT(3270-X)\n        MONITOR(JOBNAMES-T)\n        CON(N) DEL(RD) RTME(1/4) MFORM(J,T) AREA(NONE)\n/*                                                                  */\n/*                                                                  */\n/********************************************************************/\n/*                                                                  */\n/* END OF CONSOLE DEFINITIONS                                       */\n/*                                                                  */\n/********************************************************************/\n./ ADD NAME=LOAD10\n*---------------------------------------------------------------------\n* Load parameters for TEST\n*---------------------------------------------------------------------\nLPARNAME TEST\nIODF     00 SYS1     TEST\nIEASYM   (00,L)\nNUCLEUS  1\nSYSCAT   ZOSCAT113CCATALOG.MASTER\nINITSQA  0000M 0001M\n*UCLST   00 N\nSYSPLEX  LOCAL\nPARMLIB  SYS1.PARMLIB                                 ZOSRS1\nPARMLIB  CPAC.PARMLIB                                 ZOSRS1\nPARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1\n*---------------------------------------------------------------------\n* Load parameters for PROD1\n*---------------------------------------------------------------------\nLPARNAME PROD1\nIODF     00 SYS1     PROD1\nIEASYM   (00,L)\nNUCLEUS  1\nSYSCAT   ZOSCAT113CCATALOG.MASTER\nINITSQA  0000M 0001M\nNUCLST   00 N\nSYSPLEX  LOCAL\nPARMLIB  SYS1.PARMLIB                                 ZOSRS1\nPARMLIB  CPAC.PARMLIB                                 ZOSRS1\nPARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1\n*---------------------------------------------------------------------\n* Load parameters for PROD2\n*---------------------------------------------------------------------\nLPARNAME PROD2\nIODF     00 SYS1     PROD2\nIEASYM   (00,L)\nNUCLEUS  1\nSYSCAT   ZOSCAT113CCATALOG.MASTER\nINITSQA  0000M 0001M\nNUCLST   00 N\nSYSPLEX  LOCAL\nPARMLIB  SYS1.PARMLIB                                 ZOSRS1\nPARMLIB  CPAC.PARMLIB                                 ZOSRS1\nPARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1\n*---------------------------------------------------------------------\n* Load parameters for SYSTEMS\n*---------------------------------------------------------------------\nLPARNAME SYSTEMS\nIODF     00 SYS1     SYSTEMS\nIEASYM   (00,L)\nNUCLEUS  1\nSYSCAT   ZOSCAT113CCATALOG.MASTER\nINITSQA  0000M 0001M\nNUCLST   00 N\nSYSPLEX  LOCAL\nPARMLIB  SYS1.PARMLIB                                 ZOSRS1\nPARMLIB  CPAC.PARMLIB                                 ZOSRS1\nPARMLIB  SYS1.IBM.PARMLIB                             ZOSRS1\n./ ADD NAME=PARSED\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\ncall setinp pds,'@DATASET','D.'\nDO ###xx = 1 TO 5\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN DO\n      zcontin = 1\n      zrest = STRIP(zrest,\"T\")\n      zrest = STRIP(zrest,\"T\",\"-\")\n   END\n   ELSE zcontin = 0\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n./ ADD NAME=RESCUE\n/*---------------------------------------------------Rexx--*/\n/*         M A I N    R E S C U E    E X E C               */\n/*---------------------------------------------------------*/\n/* RESCUE  - Build JCL and other elements for a single     */\n/*           volume rescue system.                         */\n/*---------------------------------------------------------*/\n/* Read the $$$DOC member for more information on using    */\n/* the RESCUE execs.                                       */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2001 John C. Miller                        */\n/*---------------------------------------------------------*/\n/*---------------------------------------------------------*/\n/* BE SURE TO SET PDS NAME IN MEMBER: ##PDS                */\n/*---------------------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Get PDS name, initialize variables, and reset job char. */\n/*---------------------------------------------------------*/\npds  = ##pds()        /* Get PDS name.                     */\ncall varinit          /* Read and validate @parms          */\ncall ##jobchr reset   /* Reset job char file.              */\n\n/*---------------------------------------------------------*/\n/* Be sure all datasets are present; if not, exit.         */\n/*---------------------------------------------------------*/\nif  \\dscheck() THEN DO\n   SAY 'One or more datasets missing.  Processing terminated.'\n   exit\nend\n\n/*---------------------------------------------------------*/\n/* Call routines to build various JCL members.             */\n/*---------------------------------------------------------*/\ncall #initvol         /* Init volume.                      */\ncall #defmcat         /* Define mastercat.                 */\ncall #defvsam         /* Define PAGE, MANx, etc.           */\ncall #defnvsm         /* Define NONVSAM catalog entries.   */\ncall #alcnvsm         /* Allocate non-VSAM datasets.       */\ncall #copyds          /* Copy datasets.                    */\ncall #altnvsm         /* Alter NONVSAM entries.            */\ncall #rfdsnt          /* Create RACF dataset name table.   */\ncall #rfstc           /* Create RACF started task table.   */\ncall #rfcopy          /* Create copy of RF dataset.        */\ncall #members         /* Build various members. (External) */\ncall #copymem         /* Copy members.                     */\ncall #delssa          /* Delete the System Specific Alias. */\ncall #misc            /* Last minute assorted stuff.       */\n\nexit\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n###dslst = \"\"\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   IF pos(##prm,zzparm) > 0 THEN DO\n      ###dslst = ###dslst\" \"zzdsn1\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.            */\n/*---------------------------------------------------------*/\nxdsthere:\nARG ##prm .\nIF VALUE(\"DSNS.0\") = \"DSNS.0\" THEN DO\n   SAY 'Need to call varinit before using this function.'\n   RETURN 0\nEND\n\ndo ##xxx = 1 TO DSNS.0\n   IF POS(##prm,DSNS.##xxx) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   say VALUE(\"JOBCARD\"##x8)\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions -----------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*-------------------------------------------*/\n/* Read and validate @PARMS member, and      */\n/* assign variable values.                   */\n/*-------------------------------------------*/\nvarinit:\nparse source a b exn .\nIF SYSDSN(\"'\"pds\"'\") /= OK THEN DO\n   SAY \" \"\n   SAY \"Error allocating '\"pds\"'.  You may need to change the 'pds='\"\n   SAY \"statement in the ##PDS member of the RESCUE PDS to the name of\"\n   SAY \"the PDS that contains the RESCUE system execs and parameter\"\n   SAY \"members.  If running in batch, be sure the RESCUE PDS is NOT in\"\n   SAY \"use or allocated in any way by any other JOBS or TSO users.\"\n   SAY \" \"\n   SAY \"This exec will exit now.\"\n   EXIT\nEND\n\ncall setinp pds,'@PARMS','PARMS.'\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   PARSE VAR data data '/* ' .      /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   INTERPRET q '= \"'r'\"'\nEND\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Now we have all the @PARMS read in, so we */\n/* will check them now.                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n\nRETURN\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget: procedure\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget: procedure\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\ntrace off\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\ntrace off\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(output) DA('\"ds\"(\"mem\")')\"\nx = MSG(x)\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(pds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(pds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str WITH xx$hlq '.' junk\nRETURN xx$hlq\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*---------------------------------------------------------*/\n/* Check for presence of all datasets.  If copy mode is    */\n/* \"N\" meaning the DS is not copied bu just created, then  */\n/* assume it is ok.                                        */\n/*---------------------------------------------------------*/\ndscheck:\nSay \"Checking datasets in @DATASET member.\"\n/* Read @dataset member into DSNS. stem variable.           */\ncall setinp pds,'@DATASET','DSNS.' /* Read DATASETS member. */\n##ok = 1\ndo ##xxx = 1 TO DSNS.0\n   IF substr(DSNS.##xxx,1,1) = '*' THEN ITERATE\n   PARSE VAR DSNS.##xxx,\n   zzunit ',' zzvolnum ',' zzpri ',' zzsec ',' zzdir ',',\n   zzmode ',' zzdsn1 ',' zzdsn2 ',' '(' zparms ')' .\n   zzdsn1 = strip(zzdsn1,'B')\n   zzdsn2 = strip(zzdsn2,'B')\n   IF zzdsn1 = \"\" THEN ITERATE\n   /*--------------------------------------------------*/\n   /* If a model is specified, then check only for the */\n   /* existence of the model ds.                       */\n   /*--------------------------------------------------*/\n   stat = SYSDSN(\"'\"zzdsn1\"'\")\n   IF stat /= 'OK' THEN DO\n      SAY 'Dataset not found: 'zzdsn1\n      ##ok = 0\n   END\nEND\nRETURN ##ok\n\n./ ADD NAME=WAIT\n//COMPJMA JOB (990030,135,60,100),JMILLER,CLASS=A,\n//        NOTIFY=&SYSUID,MSGCLASS=X,REGION=6M\n//  JCLLIB ORDER=('CPAC.PROCLIB')\n//ASMACL   EXEC  ASMACL,PARM.L='MAP,LET,LIST,NCAL'\n//C.SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//           DD  DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD  *\nPRC      TITLE 'WAIT - WAIT A LITTLE BIT.'\n********************************************************************\n*                                                                  *\n* NAME - WAIT.                                                     *\n*                                                                  *\n* DESCRIPTION -                                                    *\n*                                                                  *\n*   THIS MODULE WILL WAIT THE REQUESTED NUMBER OF SECONDS.         *\n*                                                                  *\n* TO USE -                                                         *\n*                                                                  *\n*   PARM='NNNN', WHERE 0 < NNNN <= 9999, THE NUMBER OF SECONDS TO  *\n*     WAIT. DEFAULT IS 10 SECONDS.                                 *\n*                                                                  *\n* RETURN CODES -                                                   *\n*                                                                  *\n*   R15 = 20, BAD PARM FIELD.                                      *\n*                                                                  *\n* LOG -                                                            *\n*   05/30/86 L01 PTW IMPLEMENTED                                   *L01\n*   09/27/88 L02 PTW IMPLEMENTED                                   *L02\n*                                                                  *\n********************************************************************\n         LCLC  &CSECT\n&CSECT   SETC  'WAIT'\n&CSECT   CSECT\n********************************************************************\n*                                                                  *\n*        I N I T I A L I Z E                                       *\n*                                                                  *\n********************************************************************\n         PRINT NOGEN\n         SAVE  (14,12),,&CSECT-&SYSDATE-&SYSTIME\n         LR    R12,R15            ESTABLISH BASE.\n         USING &CSECT,R12\n         GETMAIN RU,LV=DYNLEN\n         LR    R2,R13\n         LR    R13,R1\n         USING DYNAMIC,R13\n         LR    R0,R1\n         LA    R14,DYNLEN\n         LA    R1,R1\n         SLR   R15,R15\n         MVCL  R0,R14             ZERO STORAGE.\n         ST    R2,4(,R13)         BACK CHAIN.\n         ST    R13,8(,R2)         FORWARD CHAIN.\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        P A R M   P R O C E S S I N G                             *\n*                                                                  *\n********************************************************************\n         MVC   SECONDS,=F'10'     DEFAULT.\n         L     R2,4(,R13)         A(PREVIOUS SAVEAREA).\n         L     R2,24(,R2)         A(A(PARM)).\n         LTR   R2,R2              CHECK FOR NULL PARM.\n         BZ    DOTIME\n         L     R2,0(,R2)          A(PARM).\n         LH    R3,0(,R2)          L'PARM.\n         LTR   R3,R3              IF ZEROS +\n         BZ    DOTIME               THEN EXIT.\n         CH    R3,=H'4'           IF LENGTH NGT '4' +\n         BH    BADTIME            FORGET NEXT.\n         LA    R4,2(,R2)\nVERNUM   DS    0H\n         CLI   0(R4),C'0'         SCAN\n         BL    BADTIME             FORWARD\n         CLI   0(R4),C'9'         SCAN\n         BH    BADTIME             FORWARD\n         LA    R4,1(,R4)            TO FIRST\n         BCT   R3,VERNUM\n         LH    R3,0(,R2)\n         BCTR  R3,0               MACHINE LENGTH.\n         EX    R3,PACKSEC         PACK SECONDS.\n         CVB   R3,DOUBLE          CONVERT TO BINARY.\n         CH    R3,=H'1'           TEST SECONDS\n         BL    BADTIME             FOR LIMITS.\n         CH    R3,=H'9999'\n         BH    BADTIME\n         ST    R3,SECONDS          AND STORE.\nPACKSEC  PACK  DOUBLE,2(*-*,R2)\n********************************************************************\n*                                                                  *\n*        W A I T                                                   *\n*                                                                  *\n********************************************************************\nDOTIME   DS    0H\n         L     R2,SECONDS\n         MH    R2,=H'100'\n         ST    R2,SECONDS\n         STIMER WAIT,BINTVL=SECONDS\n         XC    RC,RC\n********************************************************************\n*                                                                  *\n*        R E T U R N                                               *\n*                                                                  *\n********************************************************************\nRETURN   DS    0H\n         L     R2,RC                  R2 = RC.\n         LR    R1,R13              PREPARE\n         L     R13,4(,R13)         FOR FREEMAIN.\n         FREEMAIN RU,LV=DYNLEN,A=(1)\n         LR    R15,R2              AND RETURN\n         RETURN (14,12),RC=(15)      WITH R15 = RC.\n********************************************************************\n*                                                                  *\n*        E R R O R S                                               *\n*                                                                  *\n********************************************************************\nBADTIME  DS    0H\n         WTO   'WAIT: BAD PARM - SPECIFY NNNN (1-9999 SECONDS).',      X\n               ROUTCDE=11,MCSFLAG=HRDCPY\n         MVC   RC,=F'20'\n         B     RETURN\n********************************************************************\n*                                                                  *\n*        S T A T I C   A R E A                                     *\n*                                                                  *\n********************************************************************\nSRCLEVEL DC    C'                                        '\n         LTORG *\n********************************************************************\n*                                                                  *\n*        D Y N A M I C   A R E A                                   *\n*                                                                  *\n********************************************************************\nDYNAMIC  DSECT\nSAVE     DS    18F .\nDOUBLE   DS    D\nRC       DS    F\nSECONDS  DS    F\nDYNLEN   EQU   *-DYNAMIC\n         PRINT OFF\nR0       EQU   00\nR1       EQU   01\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                 PROGRAM BASE.\nR13      EQU   13                 A(SAVE AREA).\nR14      EQU   14\nR15      EQU   15\n         PRINT ON\n         END   &CSECT\n//L.SYSLMOD DD  DSN=SYS2.LINKLIB(WAIT),DISP=SHR,UNIT=\n./ ADD NAME=ZBPXPRM\nFILESYSTYPE TYPE(HFS)\n            ENTRYPOINT(GFUAINIT)\n            PARM(' ')\n\nFILESYSTYPE TYPE(TFS)\n            ENTRYPOINT(BPXTFS)\n\n   MAXPROCSYS(900)\n   MAXPROCUSER(100)\n   MAXUIDS(200)\n   MAXFILEPROC(2000)\n   MAXPTYS(800)\n   CTRACE(CTIBPX00)\n   FILESYSTYPE TYPE(UDS) ENTRYPOINT(BPXTUINT)\n   NETWORK DOMAINNAME(AF_UNIX)\n           DOMAINNUMBER(1)\n           MAXSOCKETS(2000)\n           TYPE(UDS)\n   FILESYSTYPE TYPE(INET) ENTRYPOINT(EZBPFINI)\n   NETWORK DOMAINNAME(AF_INET)\n           DOMAINNUMBER(2)\n           MAXSOCKETS(64000)\n           TYPE(INET)\n   MAXTHREADTASKS(1000)\n   MAXTHREADS(500)\n   IPCMSGNIDS    (500)\n   IPCMSGQBYTES  (2147483647)\n   IPCMSGQMNUM   (10000)\n   IPCSHMNIDS    (500)\n   IPCSHMSPAGES  (262144)\n   IPCSHMMPAGES  (25600)\n   IPCSHMNSEGS   (500)\n   IPCSEMNIDS    (500)\n   IPCSEMNSEMS   (1000)\n   IPCSEMNOPS    (25)\n   MAXMMAPAREA(40960)\n   MAXCORESIZE(4194304)\n   MAXASSIZE(209715200)\n   MAXCPUTIME(1000)\n   MAXSHAREPAGES(131072)\n   FORKCOPY(COW)\n   SUPERUSER(BPXROOT)\n   TTYGROUP(TTY)\n   STARTUP_PROC(OMVS)\n   SYSCALL_COUNTS(NO)\n   MAXQUEUEDSIGS(1000)\n   SYSPLEX(NO)\n   SHRLIBRGNSIZE(67108864)\n   SHRLIBMAXPAGES(4096)\n./ ADD NAME=ZCLONE\n/*---------------------------------------------------Rexx--*/\n/*         M A I N    Z C L O N E    E X E C               */\n/*---------------------------------------------------------*/\n/* ZCLONE  - Build JCL and other elements to clone a       */\n/*           zOS system.                                   */\n/*---------------------------------------------------------*/\n/* Read the $$$DOC member for more information on using    */\n/* the ZCLONE execs.                                       */\n/*---------------------------------------------------------*/\n/* V2.0 - 03/08/2007 John C. Miller                        */\n/*---------------------------------------------------------*/\nPARSE ARG args\n\n/*---------------------------------------------------------*/\n/* Get PDS name, initialize variables, and reset job char. */\n/*---------------------------------------------------------*/\nipds   = kget('INPDS','COMPJM.ZCLONE')\nopds   = kget('OUTPDS','COMPJM.CJOBS')\nzzprms = kget('PARMS','@PARMS') /* PARMS member of INPDS.    */\n\n/*---------------------------------------------------------*/\n/* Be sure all datasets coded in the @DATASET mem exist.   */\n/*---------------------------------------------------------*/\nsarg = ipds\" \"opds\" \"zzprms\n\nIF #validat(sarg) THEN DO\n   SAY 'Exiting due to errors.'\n   exit\nEND\n\ncall varinit          /* Read and validate @parms          */\n\n/*---------------------------------------------------------*/\n/* Call routines to build various JCL members.             */\n/* Pass each routine some parms that they will need.       */\n/*---------------------------------------------------------*/\ncall #initvol jchr() sarg /* Init volumes.                 */\ncall #defcat  jchr() sarg /* Define catalogs.              */\ncall #alcnvsm jchr() sarg /* Allocate non-VSAM datasets.   */\ncall #defvsam jchr() sarg /* Define PAGE, MANx, etc.       */\ncall #copyds  jchr() sarg /* Copy datasets.                */\ncall #misc    jchr() sarg /* Assorted minutiae             */\ncall #defnvsm jchr() sarg /* Define NONVSAM catalog entr.  */\ncall #rfdsnt  jchr() sarg /* Create RACF dataset name tab. */\ncall #rfstc   jchr() sarg /* Create RACF started task tab. */\ncall #alterjc jchr() sarg /* Alter catalog entries.        */\ncall #copymem jchr() sarg /* Copy members.                 */\ncall #members        sarg /* Build various members.        */\nexit\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*---------------------------------------------------------*/\n/* jchr -   Return the next job character.                 */\n/*---------------------------------------------------------*/\njchr:\nARG options .\n##JOBCHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\"\n\n/* Reset xxjobnum to 0 if this is the first call.          */\nIF SYMBOL('zzjnum') = 'LIT' THEN zzjnum = 0\n\nzzjnum = zzjnum + 1\nif zzjnum > length(##JOBCHARS) THEN zzjnum = 1\nRETURN SUBSTR(##JOBCHARS,zzjnum,1)\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- low level functions - v3.8 ----------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n\n/*---------------------------------------------------------*/\n/* Parse the @DATASET member, and store the data in a      */\n/* stem var.  DS.entrynum.parm.   E.g. DS.23.DSN           */\n/*---------------------------------------------------------*/\nparse_dataset:\nDROP DS.\ndsidx=0\nIF isblank('@DATASET') THEN zzdsmem = '@DATASET'\nELSE zzdsmem = @DATASET\ncall setinp ipds,zzdsmem,'D.'\nDO ###xx = 1 TO D.0\n   IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n   IF D.###xx = \"\"          THEN ITERATE\n   D.###xx = SUBSTR(D.###xx,1,72)\n   PARSE VAR D.###xx zverb zrest\n   IF contin(D.###xx) THEN zcontin = 1\n   ELSE zcontin = 0\n   zrest = STRIP(zrest,\"T\")\n   zrest = STRIP(zrest,\"T\",\"-\")\n   zrest = STRIP(zrest,\"T\",\"+\")\n   /* Valid statement found, parse it. */\n   dsidx = dsidx + 1\n   DS.0 = dsidx\n\n   DS.dsidx.verb = zverb\n\n   /* If DATASET then get option (2nd word in line) */\n   IF zverb = 'DATASET' THEN DO\n      PARSE VAR zrest zoption zrest\n      DS.dsidx.option = zoption /* Save option in stem. */\n   END\n   DO WHILE zrest /= \"\"\n      zrest = STRIP(zrest,\"B\")\" \"\n      PARSE VAR zrest zparm '(' zvalue ') ' zrest\n      zvalue = STRIP(zvalue,\"B\")\n      zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n      IF zparm = 'VOLUME' THEN zparm = 'VOL'\n      IF zparm = 'DATASET' THEN zparm = 'DSN'\n      INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n   END\n   DO WHILE zcontin\n      ###xx = ###xx + 1\n      IF LEFT(D.###xx,1) = \"*\" THEN ITERATE\n      IF D.###xx = \"\"          THEN ITERATE\n      IF ###xx > D.0 THEN SIGNAL dsparmsdone\n      D.###xx = SUBSTR(D.###xx,1,72)\n      zrest = D.###xx\n      IF contin(D.###xx) THEN DO\n         zcontin = 1\n         zrest = STRIP(zrest,\"T\")\n         zrest = STRIP(zrest,\"T\",\"-\")\n      END\n      ELSE zcontin = 0\n      DO WHILE zrest /= \"\"\n         zrest = STRIP(zrest,\"B\")\" \"\n         PARSE VAR zrest zparm '(' zvalue ') ' zrest\n         zvalue = STRIP(zvalue,\"B\")\n         zvalue = varsub(zvalue)  /* Do symbolic substitution. */\n         IF zparm = 'VOLUME' THEN zparm = 'VOL'\n         IF zparm = 'DATASET' THEN zparm = 'DSN'\n         INTERPRET 'DS.dsidx.'zparm' = \"'zvalue'\"'\n      END\n   END\n   /* Assign default values if needed. */\n   IF symbol(\"DS.\"dsidx\".VOL\") /= \"VAR\" THEN DS.dsidx.VOL = VOLSER1\n   IF zverb = \"DATASET\" & zoption = \"COPY\" THEN,\n   IF symbol(\"DS.\"dsidx\".MODE\") /= \"VAR\" THEN DS.dsidx.MODE = \"DFDSS\"\nEND\ndsparmsdone:\nRETURN\n\n/* SUBR */\ncontin: ARG ###d, ###contchar\nIF ###contchar = \"\" THEN ###contchar = '-'\n###d = STRIP(###d,\"T\")\nIF RIGHT(###d,1) = ###contchar THEN RETURN 1\nRETURN 0\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n/* End of parse_dataset                                    */\n/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/\n\n/*---------------------------------------------------------*/\n/* Boolean: Is dataset defined in a DATASET COPY or ALLOC? */\n/*---------------------------------------------------------*/\ndsdefined:\nARG #x##dsn2\nDO #x#x2 = 1 TO DS.0\n   IF DS.#x#x2.verb /= \"DATASET\" THEN ITERATE\n   IF SYMBOL(\"DS.\"#x#x2\".NEWNAME\") = \"VAR\" THEN,\n      #x##dsn = DS.#x#x2.NEWNAME\n   ELSE #x##dsn = DS.#x#x2.DSN\n   IF #x##dsn2 = #x##dsn THEN RETURN 1\nEND\nRETURN 0\n\n\n/*---------------------------------------------------------*/\n/* Extract list of datasets depending on parms.  The list  */\n/* returned is a space delimited list of dsn+volume pairs, */\n/* e.g.: SYS1.LINKLIB SYSVL1 SYS1.PARMLIB SYSVL2 etc etc.  */\n/* The parse_dataset routine must have already be run for  */\n/* this routine to work.                                   */\n/*---------------------------------------------------------*/\nxdslist:\nARG ##prm\n###dslst = \"\"\ndo ###xx = 1 TO DS.0\n   IF DS.###xx.verb /= \"DATASET\" THEN ITERATE\n   IF attrib(##prm,DS.###xx.PARM) THEN DO\n      IF SYMBOL(\"DS.\"###xx\".NEWNAME\") = \"VAR\" THEN,\n      ###dslst = ###dslst\" \"DS.###xx.NEWNAME DS.###xx.VOL\n      ELSE,\n      ###dslst = ###dslst\" \"DS.###xx.DSN DS.###xx.VOL\n   END\nEND\nRETURN ###dslst\n\n/*---------------------------------------------------------*/\n/* dstype - Return dataset type.                           */\n/*---------------------------------------------------------*/\ndstype:\nARG ##ds\n##x = OUTTRAP('##y.',25)\n\"LISTD '\"##ds\"'\"\n##rc = rc\n##x = OUTTRAP('OFF')\nIF ##rc > 0 THEN RETURN \"ERROR\"\nELSE RETURN WORD(##y.3,WORDS(##y.3))\n\n/*---------------------------------------------------------*/\n/* Write a jobcard.                                        */\n/*---------------------------------------------------------*/\njobcard:\nARG ##jobnum\n##jc1 = VALUE(\"JOBCARD1\")\nIF ##jc1 = \"JOBCARD1\" THEN RETURN  /* JOBCARD1 not coded in parms. */\nPARSE VAR ##jc1 ##jc1a ##jc1b\n##jc1 = STRIP(##jc1a,\"B\")\"\"##jobnum\" \"##jc1b\ncall jcl ##jc1\n\nDO ##x8 = 2 TO 10\n   IF VALUE(\"JOBCARD\"##x8) = \"JOBCARD\"##x8 THEN RETURN\n   call jcl VALUE(\"JOBCARD\"##x8)\nEND\nRETURN\n\n##c = \"//\"jobpref\"\"##jobnum\" JOB (0),ZCLONE,MSGCLASS=X,\"\ncall jcl ##c\n##c = \"//  NOTIFY=&SYSUID,REGION=6M,TYPRUN=HOLD\"\ncall jcl ##c\nRETURN\n\n/*-------------------------------------------*/\n/* Write to a stem variable.                 */\n/* Use INTERPRET so we can pass              */\n/* a stem variable name.                     */\n/*-------------------------------------------*/\njcl:\nPARSE ARG ##txt7, ##stem7\nIF ##stem7 = \"\" THEN ##stem7 = 'OUTPUT.'\nIF VALUE(##stem7\"0\") = ##STEM7\"0\" THEN DO\n  INTERPRET ##stem7\"0 = 0\"\nEND\nif ##x7 > 1000 THEN TRACE off\nINTERPRET \"##x7 = \"##stem7\"0\"\nINTERPRET \"##x7 = ##x7 + 1\"\nINTERPRET ##stem7\"0 = ##x7\"\nINTERPRET ##stem7\"\"##x7\" = ##txt7\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment block.                              */\n/*---------------------------------------------------------*/\njcc:\nPARSE ARG ##str,##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//* \"##str,##len)\"*\"\nRETURN\n\n/*---------------------------------------------------------*/\n/* Write a jcl comment line.                               */\n/*---------------------------------------------------------*/\njcd:\nPARSE ARG ##len\nIF DATATYPE(##len) /= 'NUM' THEN ##len = 68\ncall jcl left(\"//*\",##len,\"-\")\"*\"\nRETURN\n\n/*-------------------------------------------*/\n/* Read parm file and assign variables.      */\n/*-------------------------------------------*/\nvarinit:\nIF \\setinp(ipds,zzprms,'PARMS.') THEN DO\n   SAY \"Error: Unable to allocate parms member:\"ipds\"(\"zzprms\").\"\n   RETURN 0\nEND\nDO x = 1 TO PARMS.0\n   data = substr(PARMS.x,1,72)     /* Avoid line numbers   */\n   IF substr(data,1,1) = '*' THEN ITERATE  /* Axe comments */\n   IF SUBSTR(WORD(data,1),1,7) /= 'JOBCARD' THEN,\n   PARSE VAR data data '/* ' .     /* Axe inline comments  */\n   IF pos('=',data) = 0 THEN ITERATE  /* Only assigns      */\n   PARSE VAR data q '=' r          /* Get parms and data   */\n   q = strip(q,'B');r = strip(r,'B')\n   IF q = \"\" THEN ITERATE\n/* IF r = \"\" THEN ITERATE */\n   r = varsub(r)\n   INTERPRET q '= \"'r'\"'\nEND\nRETURN 1\n\n/*-------------------------------------------*/\n/* Get keyword value parameter               */\n/*-------------------------------------------*/\nkget:\nARG var, default\nkargs = args\nPARSE UPPER VAR kargs (var)\"(\" var \")\" junk\nIF var = '' THEN var = default\nRETURN var\n\n/*-------------------------------------------*/\n/* Get keyword intrinsic parameter           */\n/*-------------------------------------------*/\niget:\nARG var\npstr = \" \"var\" \"\nIF POS(\" \"var\" \",\" \"args\" \") = 0 THEN RETURN 0\nELSE RETURN 1\n\n/*-----------------------------------------------------*/\n/* Allocate output member                              */\n/*-----------------------------------------------------*/\nsetout:\nARG ##ds, ##mem, ##stem\nIF ##stem = \"\" THEN ##stem = 'OUTPUT.'\nINTERPRET \"DROP \"##stem\n##x = MSG('OFF')\n\"FREE  FI(output)\"\n##x = MSG(##x)\n\"ALLOC FI(output) DA('\"##ds\"(\"##mem\")') SHR\"\nIF RC = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error allocating '##ds'('##mem')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsout:\nARG ##ds5, ##mem5, ##stem5\n\nIF ##stem5 = \"\" THEN ##stem5 = 'OUTPUT.'\n\"EXECIO * DISKW output (FINIS STEM \"##stem5\nrcde = RC\n##x5 = MSG('OFF')\n\"FREE  FI(output)\"\n##x5 = MSG(##x5)\nIF rcde = 0 THEN RETURN 1\nELSE DO\n   SAY 'Error closing '##ds5'('##mem5')'\n   RETURN 0\nEND\n\n\"FREE  FI(output) DA('\"##ds5\"(\"##mem5\")')\"\n\n/*-----------------------------------------------------*/\n/* Allocate input member                               */\n/*-----------------------------------------------------*/\nsetinp:\nARG ##ds2, ##mem2, ##stem2\nIF ##stem2 = \"\" THEN ##stem2 = 'INPUT.'\nIF SYSDSN(\"'\"##ds2\"(\"##mem2\")'\") /= \"OK\" THEN RETURN 0\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\n\"ALLOC FI(input) DA('\"##ds2\"(\"##mem2\")') SHR\"\nIF RC = 0 THEN DO\n   \"EXECIO * DISKR input (FINIS STEM \"##stem2\n   x = MSG('OFF')\n   \"FREE  FI(input)\"\n   x = MSG(x)\n   RETURN 1\nEND\nELSE DO\n   SAY 'Error allocating '##ds2'('##mem2')'\n   RETURN 0\nEND\n\n/*-----------------------------------------------------*/\n/* Close output member                                 */\n/*-----------------------------------------------------*/\nclsinp:\nARG ds, mem\nx = MSG('OFF')\n\"FREE  FI(input)\"\nx = MSG(x)\nRETURN 1\n\n\"FREE  FI(input) DA('\"ds\"(\"mem\")')\"\n\n/*-------------------------------------------*/\n/* Write an status message.                  */\n/* If a null line is specified as the text   */\n/* then close the output file.               */\n/*-------------------------------------------*/\nmmsg: procedure\nPARSE ARG ##msg\nIF value(##msgq.0) = '##MSGQ.0' THEN ##msgq.0 = 0\n\n/*-------------------------------------------*/\n/* Queue the passed msg to the stem var.     */\n/*-------------------------------------------*/\nIF length(##msg) = 0 THEN signal wmsg\n##msgq.0 = ##msgq.0 + 1\n##x = ##msgq.0\n##msgq.##x = ##msg\nRETURN 1\n\n/*-------------------------------------------*/\n/* Write error messages to the PDS.          */\n/*-------------------------------------------*/\nwmsg:\n##x = setout(opds,mstatus)\n\"EXECIO * DISKW output (STEM ##msgq. FINIS\"\n##x = clsout(opds,mstatus) THEN SIGNAL ext\nRETURN 1\n\n/*-------------------------------------------*/\n/* ASTRIP - Strip spaces and dashes          */\n/*-------------------------------------------*/\n/* This low level function strips both blanks*/\n/* and dashes from the passed string.        */\n/*-------------------------------------------*/\nastrip:; ARG str; RETURN STRIP(STRIP(str,,'-'))\n\n/*-------------------------------------------*/\n/* XXHLQ  - get hlq.                         */\n/*-------------------------------------------*/\nhlq: procedure\nARG ##str\nPARSE UPPER VAR ##str ##str2 '.' .\nRETURN ##str2\n\n/*-------------------------------------------*/\n/* XXLLQ  - get hlq.                         */\n/*-------------------------------------------*/\nllq: procedure\nARG ##str\n##x = lastpos(\".\",##str)\n##llq = substr(##str,##x+1)\nRETURN ##llq\n\n/*-------------------------------------------*/\n/* Get date in format: 01/01/2001            */\n/*-------------------------------------------*/\nmydate: procedure\nreturn substr(date('u'),1,6)\"\"word(date('n'),3)\n\n/*-------------------------------------------*/\n/* Get number of occurences of one string    */\n/* in another.                               */\n/*-------------------------------------------*/\nnumof: procedure\nARG ##str,##tgt\n##ctr = 0\nDO WHILE ##str /= \"\"\n   ##ctr = ##ctr + 1\n   parse var ##str (##tgt) ##str\nEND\nRETURN ##ctr-1\n\n/*-------------------------------------------*/\n/* Get next sequential integer fro job num.  */\n/*-------------------------------------------*/\nnextjob:\nIF value(##jobnum) = '##JOBNUM' THEN ##jobnum = 0\n##JOBCHARS = \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n##jobnum = ##jobnum + 1\nRETURN substr(##jobchars,##jobnum,1)\n\n/*-------------------------------------------*/\n/* Check to see if a parm is found in a parm */\n/* list.  ##parms = (APF,IPLPARM,LNK) etc.   */\n/* ##httrib might be LNK., e.g.              */\n/*-------------------------------------------*/\nattrib:\nARG ##attrib, ##parms\n/* Change parens, dots and commas to blanks */\n##parms = \" \"translate(##parms,\"    \",\"(),.\")\" \"\nIF POS(\" \"##attrib\" \",##parms) > 0 THEN RETURN 1\nELSE RETURN 0\n\n/*-------------------------------------------*/\n/* Translate to lower case.                  */\n/*-------------------------------------------*/\nlower: procedure\nARG string\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nRETURN translate(string,lower,upper)\n\n/*---------------------------------------------------------*/\n/* nonblank - Determine if a variable is blank or undef.   */\n/*---------------------------------------------------------*/\nisblank:\nPARSE ARG #prm\nIF VALUE(#prm) = \"\" THEN RETURN 1\nIF SYMBOL(#prm) = = \"LIT\" THEN RETURN 1\nRETURN 0\n\n/*-------------------------------------------*/\n/* Variable substitution.  Return a string   */\n/* with all variables interpolated.  Vars    */\n/* either be vars coded in the rexx exec     */\n/* itself, or parms coded in the @PARMS file.*/\n/*-------------------------------------------*/\nvarsub:\nPARSE ARG ####str\n####i = POS(\"&\",####str)\nDO WHILE ####i > 0\n   ####str0 = SUBSTR(####str,1,####i-1)\n   ####str2 = SUBSTR(####str,####i)\n   ####str2 = TRANSLATE(####str2,\"               \",\" &./()*&%$#@:<>\")\n   ####str2 = WORD(####str2,1)\n   ####l = LENGTH(####str2)+1\n   ####str3 = SUBSTR(####str,####i+####l)\n   IF ####str2 = ZCLONE THEN ####str2 = ipds\n   ELSE IF SYMBOL(####str2) = 'VAR' THEN ####str2 = VALUE(####str2)\n   ####str = ####str0\"\"####str2\"\"####str3\n   ####i = POS(\"&\",####str)\nEND\nRETURN ####str\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Add a text line to a queue.  (actually a  */\n/* stem variable.)  This allows us to manage */\n/* the output from various processes and     */\n/* give the user a more orderly output.      */\n/* The \"queue\" names must be numbers, due to */\n/* the vagaries of the rexx interpreter.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* To store a line in queue #1:              */\n/*   call qu 1,'Hello World!!'               */\n/* To print all lines from queue #1:         */\n/*   DO x = 1 TO q.1.0                       */\n/*      SAY q.1.x                            */\n/*   END                                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqu:\nPARSE ARG #q,#data\n#ctr = VALUE(q.#q.0)\nIF DATATYPE(#ctr) /= 'NUM' THEN DO\n   q.#q.0 = 0\n   #ctr = 0\nEND\n#ctr=#ctr+1; q.#q.0=#ctr\nq.#q.#ctr = #data\nreturn\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Print out all lines of a queue.           */\n/* #q   = Queue number to print (1..n)       */\n/* #box = 1 -> print line within box chars.  */\n/* #box = 0 -> print line w/no box chars.    */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nqup:\nPARSE ARG #q,#box\nIF #box /= 1 THEN #box = 0\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN\nDO ##x = 1 TO q.#q.0\n   IF #box THEN say box(q.#q.##x)\n   ELSE            say q.#q.##x\nEND\nRETURN\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Queue has lines: 0|1                      */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nquhaslines:\nPARSE ARG #q\nIF DATATYPE(q.#q.0) /= 'NUM' THEN RETURN 0\nELSE RETURN 1\n\n/*-------------------------------------------*/\n/* See if we have RACF SPECIAL.              */\n/*-------------------------------------------*/\nracfspec: procedure\nx = outtrap('list.',15)\n\"LISTUSER\" USERID()\nx = outtrap('OFF')\nDO x = 1 TO list.0\n   PARSE VAR list.x 'ATTRIBUTES=' attr\n   IF POS('SPECIAL',attr) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* Get volume for a given dataset.           */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetvol:\nPARSE ARG ####d\nDO ####x=1 TO DS.0\n   IF \\isblank(DS.####x.NEWNAME) THEN ####d2 = DS.####x.NEWNAME\n   ELSE                               ####d2 = DS.####x.DSN\n   IF ####d = ####d2 THEN RETURN DS.####x.VOL\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* InsertIntoMember:  Insert some text into  */\n/* a member, but only if a search string is  */\n/* found/not found.  If ##negative is set to */\n/* 1, then only insert if the search string  */\n/* is not found.  Otherwise, only insert the */\n/* string if the search string IS found.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ninsertIntoMember:\nPARSE ARG ##ds, ##mem, ##ods, ##omem, ##txt, ##srch, ##negative\n\nIF setinp(##ds, ##mem) THEN DO\n   ##foun=0\n   DO ##xx = 1 TO INPUT.0\n      IF POS(##srch,INPUT.##xx) > 0 THEN ##foun=1\n   END\n   IF ##negative  = 1 &  ##foun THEN RETURN 0\n   IF ##negative /= 1 & \\##foun THEN RETURN 0\n   call setout ##ods, ##omem\n   DO ##xx = 1 TO INPUT.0\n      call jcl INPUT.##xx\n   END\nEND\nELSE DO\n   call setout ##ods, ##omem\nEND\ncall jcl ##txt\ncall clsout ##ds, ##mem\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* hasParms - True if any of the coded parms */\n/* are present for a dataset.                */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nhasParms:\nPARSE ARG ##prms, ##dsprms\n##dsprms = TRANSLATE(##dsprms,' ',',')\nDO ####hp = 1 TO WORDS(##prms)\n   IF WORDPOS(WORD(##prms,####hp),##dsprms) > 0 THEN RETURN 1\nEND\nRETURN 0\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* vsam_part:  Return name of DATA or INDEX  */\n/* component of a VSAM file.                 */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvsam_part:\nARG ##part,##ds\n##x = OUTTRAP('##y.',25)\n\"LISTC ENT('\"ds\"')\"\n##rc = rc\n##x = OUTTRAP('OFF')\nDO ##x = 1 TO ##y.0\n   say ##y.##x\n   PARSE VAR ##y.##x (##part) \"------- \" zzdsn .\n   IF zzdsn /= \"\" THEN RETURN zzdsn\nEND\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* volsym:  If USESYM=YES in @PARMS, then    */\n/* substitute \"&SYSRn\" for the volser passed.*/\n/* Otherwise, just spit back the volser.     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\nvolsym:\nPARSE ARG ##volser\nIF isblank(\"USESYM\") THEN RETURN ##volser\nIF USESYM /= \"YES\" & USERSYM /= \"1\" THEN RETURN ##volser\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"VOLSER\"##zz) & \\isblank(\"ADDR\"##zz) THEN DO\n      ###zvolser = VALUE(\"VOLSER\"##zz)\n      IF ##volser = ###zvolser THEN RETURN \"&SYSR\"##zz\n   END\nEND\n\nRETURN \"\"\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getssa: Return the appropriate SSA for a  */\n/* dataset.  If usercat is defined and an    */\n/* alias to the usercat would be applied to  */\n/* this dataset, then return the SSAU value. */\n/* Else, return the SSA value (for the mcat).*/\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetssa:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN SSA\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) & \\isblank(\"NEWUCAT\") THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN SSAU\n   END\nEND\n\nRETURN SSA\n\n/*- - - - - - - - - - - - - - - - - - - - - -*/\n/* getcat: Return the appropriate catalog in */\n/* which to catalog a dataset--either the    */\n/* mastercat or usercat.                     */\n/*- - - - - - - - - - - - - - - - - - - - - -*/\ngetcat:\nPARSE ARG ##ds\nIF isblank(\"NEWUCAT\") THEN RETURN NEWMCAT\n\nDO ##zz = 1 TO 99\n   IF \\isblank(\"UCATALIAS\"##zz) THEN DO\n      ##zalias = VALUE(\"UCATALIAS\"##zz);\n      IF hlq(##ds) = ##zalias THEN RETURN NEWUCAT\n   END\nEND\n\nRETURN NEWMCAT\n\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n/*----- end low level functions -------------*/\n/*-------------------------------------------*/\n/*-------------------------------------------*/\n./ ADD NAME=ZCOMMND\nCOM='CD SET,SDUMP,NODUMP'\nCOM='S VLF,SUB=MSTR'\nCOM='S DLF,SUB=MSTR'\nCOM='S TSSO,SUB=MSTR'\nCOM='S IRRDPTAB'\nCOM='S SDSF'\nCOM='S VTAM,,,(LIST=00)'\nCOM='S TSO'\nCOM='S TCPIP'\nCOM='S TN3270'\n./ ADD NAME=ZCOUPLE\n/*-------------------------------------------------------*/\n/* COUPLE00                                              */\n/* SYSPLEX-LOCAL MODE.                                   */\n/*-------------------------------------------------------*/\nCOUPLE SYSPLEX(LOCAL)\n./ ADD NAME=ZIEALPA\n./ ADD NAME=ZIEASYM\nSYSDEF SYSPARM(00,L)\n   SYMDEF(&SSALIAS='SYSZC.')\nSYSDEF LPARNAME(PROD1)\n       SYSNAME(PROD1)\n       SYSCLONE(P1)\nSYSDEF LPARNAME(PROD2)\n       SYSNAME(PROD2)\n       SYSCLONE(P2)\nSYSDEF LPARNAME(TEST)\n       SYSNAME(TEST)\n       SYSCLONE(TS)\nSYSDEF LPARNAME(SYSTEMS)\n       SYSNAME(SYST)\n       SYSCLONE(SY)\n./ ADD NAME=ZIEASYS\nAPG=07,                       *---------------------------------------\nCLOCK=00,                     * ZCLONE - IEASYS00 STARTER MEMBER.\nCLPA,                         * ZCLONE EXECS USE THIS AS THE START\nCMB=(UNITR,COMM,GRAPH,CHRDR), * POINT FOR BUILDING IEASYS00.\nCMD=(00,01),                  *---------------------------------------\nCON=00,                       SELECT CONSOL00\nCOUPLE=00,                    SELECT COUPLE00\nCSA=(3M,150M),                CSA RANGE\nDUMP=DASD,                    PLACE SVC DUMPS ON DASD DEVICES\nGRS=NONE,                     NO COORDINATION OF GRS REQUESTS\nICS=00,                       SELECT IEAICS00, CNTL SPECS FOR SRM\nIPS=00,                       SELECT IEAIPS00, PERF SPECS FOR SRM\nLNKAUTH=LNKLST,               AUTHORIZE LNKLST00, APFTAB IS ALTERNATE\nLOGCLS=L,                     WILL NOT BE PRINTED BY DEFAULT\nLOGLMT=999999,                MAX WTL MESSAGES QUEUED, MUST BE 6 DIGITS\nLPA=00,                       SELECT LPALST00\nMAXUSER=250,                  SYS TASKS PLUS INITS PLUS TSOUSERS\nMLPA=00,                      SELECT IEALPA00, MLPA PARAMETERS\nMSTRJCL=01,                   SELECT MSTJCL01, MASTER JCL\nOMVS=(00),                    SELECT BPXPRM00\nOPI=YES,                      ALLOW OPERATOR OVERRIDE TO IEASYS00\nPAK=00,                       SELECT IEAPAK00\nPLEXCFG=MONOPLEX,             MONOPLEX\nPROG=(L0,A0),                 SELECT PROGL0 AND A0 (LINKLST AND APF)\nREAL=128,                     ALLOWS 2 64K OR 1 128K JOB TO RUN V=R\nRSU=0,                        NO RECONFIG STORAGE UNITS\nRSVNONR=5,                    RESERVED ASVT ENTRIES\nRSVSTRT=5,                    RESERVED ASVT ENTRIES\nSCH=00,                       SELECT SCHED00\nSMF=00,                       SELECT SMFPRM00, SMF PARAMETERS\nSMS=00,                       SMS PARAMETERS\nSQA=(15,64),                  SQA SIZE APPROX 640K\nSSN=00,                       SELECT IEFSSN00, SUBSYSTEM NAMES\nPROD=00,                      SELECT IFAPRD01\nSVC=00,                       SELECT IEASVC00, USER SVCS\nVAL=00,                       SELECT VATLST00\nVIODSN=SYS1.STGINDEX,         VIO DS\nVRREGN=64,                    DEFAULT REAL-STORAGE REGION SIZE\n./ ADD NAME=ZIEFSSN\nSUBSYS SUBNAME(SMS)\n   INITRTN(IGDSSIIN)\n   INITPARM('ID=02,PROMPT=DISPLAY')\nSUBSYS SUBNAME(JES2) PRIMARY(YES) START(YES)\nSUBSYS SUBNAME(IRLM)\nSUBSYS SUBNAME(JRLM)\nSUBSYS SUBNAME(FFST)\nSUBSYS SUBNAME(SOM)  INITRTN(GOSAMSSI)\nSUBSYS SUBNAME(TNF)\nSUBSYS SUBNAME(VMCF)\nSUBSYS SUBNAME(CICS) INITRTN(DFHSSIN)\nSUBSYS SUBNAME(TSSO) INITRTN(TSSOINIT)\n./ ADD NAME=ZIGDSMS\n    INTERVAL(15)\n    DINTERVAL(150)\n    REVERIFY(NO)\n    ACSDEFAULTS(NO)\n    TRACE(ON)\n    SIZE(128K)\n    TYPE(ALL)\n    JOBNAME(*)\n    ASID(*)\n    SELECT(ALL)\n./ ADD NAME=ZISPALOC\n/*-------------------------------------------------------rexx--------*/\n/* TSO Allocation EXEC.                                              */\n/* Rescue System.                                                    */\n/*                                                                   */\n/* 03/17/2001 John C. Miller                                         */\n/*-------------------------------------------------------------------*/\n\n/*-------------------------------------------------------------------*/\n/* Allocate ISPPROF dataset                                          */\n/*-------------------------------------------------------------------*/\nispprof = USERID()\".ISPF.ISPPROF\"\nif \\alc('ISPPROF', \"'\"ispprof\"'\") THEN DO\n   \"alloc da('\"ispprof\"') f(ISPPROF) new\",\n   \"space(1 1) cyl lrecl(80) blksize(6160) recfm(f b) dir(15)\"\n   cc = RC\n   IF cc /= 0 THEN DO\n      SAY \"Unable to allocate ISPF profile dataset \"ispprof\";\"\n      SAY \"Please contact systems support for assistance.\"\n      SAY \"Return code: \"cc\n   END\nEND\n\n/*-------------------------------------------------------------------*/\n/* Execute user CLIST/Exec if present (Pre-allocation)               */\n/*-------------------------------------------------------------------*/\nIF SYSDSN(\"'\"ispprof\"(PRE)'\") = \"OK\" THEN DO\n   \"EXEC '\"ispprof\"(PRE)'\"\n   cc = RC\n   IF cc /= 0 THEN exit\nEND\n\n\"PDF\"\nexit\n\n/*--------- Allocate the concatenation ------------*/\nalc:\nPARSE UPPER ARG ddname, dsname\nmg = MSG('OFF')                          /* Turn msg off             */\n\"FREE  FI(\"ddname\")\"                     /* Free the DDNAME          */\nmg = MSG(mg)                             /* Restore msg level        */\n\"ALLOC FI(\"ddname\") DA(\"dsname\") SHR\"    /* Allocate the files       */\ncc = RC                                  /* Save return code         */\nRETURN cc <= 4                           /* Return 1 if OK           */\n\n./ ADD NAME=ZJES2PRM\n/*-------------------------------------------------------*/\n/* The parms below were copied from ZJES2PRM in          */\n/* the RESCUE build PDS. It is recommended that you not  */\n/* modify these parameters directly, but rather make any */\n/* changes to the ZJES2PRM source, and rebuild the       */\n/* RESCUE members.  Note that this JES2 PARM desk is not */\n/* complete, in that it does not have SPOOLDEF or CKPT   */\n/* definitions.  These are built dynamically by the      */\n/* RESCUE build process.                                 */\n/* 07/10/2007 John C. Miller                             */\n/*-------------------------------------------------------*/\nOPTSDEF LOG=YES\n/*                                                                   */\nLOGON(1) APPLID=JES2\n/*                                                                   */\nBUFDEF   BELOWBUF=(LIMIT=114,WARN=80)\n/*                                                                   */\nCONDEF   AUTOCMD=50,\n         BUFNUM=950,\n         BUFWARN=80,\n         CONCHAR=$,\n         DISPLEN=65,\n         DISPMAX=100,\n         MASMSG=200,\n         RDRCHAR=$\nDEBUG    =NO\nCOMPACT  NAME=JESDATA,\n         NUMBER=10,\n         CHARS=(16,\n           F1,F2,F3,F4,F5,F6,\n           F7,F8,F9,A,E,I,D6,\n           E4,40,X)\nESTBYTE  NUM=99999,\n         INT=99999,\n         OPT=0\nESTIME   NUM=2,\n         INT=1,\n         OPT=NO\nESTLNCT  NUM=5,\n         INT=6000,\n         OPT=0\nESTPAGE  NUM=100,\n         INT=10,\n         OPT=0\nESTPUN   NUM=100,\n         INT=2000,\n         OPT=0\nFSSDEF(PRINTOFF)\nINIT(1) NAME=1,CLASS=A,START=YES\nINIT(2) NAME=1,CLASS=A,START=YES\nINIT(3) NAME=1,CLASS=A,START=YES\nINIT(4) NAME=1,CLASS=A,START=YES\nINIT(5) NAME=1,CLASS=A,START=YES\nINIT(6) NAME=1,CLASS=A,START=YES\nINIT(7) NAME=1,CLASS=A,START=YES\nINIT(8) NAME=1,CLASS=A,START=YES\nINITDEF  PARTNUM=8\n/*                                                                  */\nINTRDR   AUTH=(JOB=YES,DEVICE=NO,SYSTEM=YES),BATCH=YES,CLASS=A,\n         HOLD=NO,PRTYINC=0,PRTYLIM=15,RDINUM=20\n/*                                                                   */\nJOBCLASS(A) ACCT=NO,         /* ACCT# NOT REQ   B................... */\n         PGMRNAME=NO,        /* PGMRNM NOT RQ   B................... */\n         TIME=(0030,00),     /* JOB STEP TIME   ...MMMMSS........... */\n         REGION=4096K,       /* REGION SIZE     .........CCC........ */\n         COMMAND=VERIFY,     /* VERIFY CMDS     ............R....... */\n         BLP=YES,            /* IGNORE BLP      .............L...... */\n         AUTH=ALL,           /* ALLOW ALL CMD   ..............AAAA.. */\n         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */\n         COPY=NO,            /* NOT TYPRUN=COPY                 DHWNC*/\n         HOLD=NO,            /* NOT TYPRUN=HOLD                 DHWNC*/\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         JOURNAL=NO,         /* JOURNAL THIS JOB CLASS          DHWNC*/\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         RESTART=NO,         /* NO REQUEUE (XEQ) ON IPL         DHWNC*/\n         SCAN=NO,            /* NOT TYPRUN=SCAN                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n/*                                                                   */\n/*                                                                   */\nJOBDEF   ACCTFLD=OPTIONAL,   /* ACCOUNTING FIELD OPTIONAL      DOHWNC*/\n         JCLERR=NO,          /* NO TERM. JOB W/JCL ERROR       DOHWNC*/\n     /*  JOBNUM=1000,  */    /* JOB QUEUE SIZE                     DC*/\n         JOBNUM=9999,        /* JOB QUEUE SIZE                  MAM2*/\n         JOBWARN=80,         /* WARNING THRESHOLD % FOR JQES   DOHWNC*/\n         NUMWARN=80,         /* WARN THRESHOLD % FOR JOB NUMB. DOHWNC*/\n         PRTYHIGH=10,        /* UPPER LIMIT FOR AGING          DOHWNC*/\n         PRTYJECL=YES,       /*PRIORITY JECL SUPPORTED         DOHWNC*/\n         PRTYJOB=NO,         /* PRTY= ON JOB NOT SUP'D         DOHWNC*/\n         PRTYLOW=5,          /* LOWER LIMIT FOR AGING          DOHWNC*/\n         PRTYRATE=96,        /* PRTY AGING RATE X/DAY          DOHWNC*/\n         RANGE=(1-9999)      /* LOCAL JOB NUMBER RANGE          DOWNC*/\n/*                                                                   */\nJOBPRTY(1) PRIORITY=9,       /* JOB PRTY=9 IF                  DOHWNC*/\n          TIME=2             /*  < 2 MIN. EXEC. TIME           DOHWNC*/\n                             /*                                      */\nJOBPRTY(2) PRIORITY=8,       /* JOB PRTY=8 IF                        */\n          TIME=5             /*  < 5 MIN. EXEC. TIME                 */\n                             /*                                      */\nJOBPRTY(3) PRIORITY=7,TIME=15 /*JOB PRTY=7 IF <15 MIN.  &RPRI2,...OC*/\n                             /* ETC.                                 */\n                             /*                                      */\nJOBPRTY(4) PRIORITY=6,       /* JOB PRTY=6 IF NOLIM     &RPRI2,...OC*/\n         TIME=1440           /* ETC.                                 */\n                             /*                                      */\n/*                            *--------------------------------------*\n                              |    IDENTIFY JES2 APPLIDS TO VTAM     |\n                              *--------------------------------------*\n                                                                    */\nMASDEF   SHARED=NOCHECK,     /* MULTI ACCESS SPOOL NOCHECK           */\n         HOLD=100,           /* MINIMUM HOLD TIME                    */\n         DORMANCY=(100,500), /* MINIMUM / MAXIMUM DORMANCY TIME      */\n         LOCKOUT=1200        /* LOCK-OUT WARNING TIME                */\n                             /*                                      */\n/*                                                                  */\nNJEDEF   DELAY=120,         /* MAX. MSG DELAY TIME            DOHWNC*/\n         JRNUM=4,           /* NUM. OF JOB RECEIVERS           DHWNC*/\n         JTNUM=4,           /* NUM. OF JOB XMITTERS            DHWNC*/\n         LINENUM=1,         /* NUM. OF LINES FOR NJE           DHWNC*/\n         NODENUM=2000,      /* MAX. NUMBER OF NJE NODES         MAM2*/\n         OWNNODE=1,         /* THIS NODE'S NUMBER              MAM  */\n         PATH=1,            /* NUM. OF PATHS/ALT'NATE          DHWNC*/\n         RESTMAX=8000000,   /* MAX. RESISTANCE TOLERANCE       DHWNC*/\n         RESTNODE=100,      /* THIS NODE'S RESISTANCE          DHWNC*/\n         RESTTOL=0,         /* ALT. RESISTANCE TOLERANCE       DHWNC*/\n         SRNUM=4,           /* NUM. OF SYSOUT RECEIVERS        DHWNC*/\n         STNUM=4            /* NUM. OF SYSOUT TRANSMITTERS     DHWNC*/\n/*                                                                  */\n/*OFFLOAD(1) DSN=SYS1.OFFLOAD  /* DATA SET NAME           DSN       */\n/*                           /* NO. OF DEVICES (UNITS)  UNITCT      */\n                             /*                                      */\nOFFLOAD(1) DSN=SYS3.SPOOL.OFFLOAD,LABEL=SL,RETPD=7,UNIT=CART\nOFF(1).JR CLASS=,           /* RELOAD ALL CLASSES             DOHWNC*/\n         HOLD=,             /* RELOAD HELD - NON-HELD         DOHWNC*/\n         JOBNAME=,          /* RELOAD ANY JOB NAME            DOHWNC*/\n                            /* MODIFY JOBS ON RELOAD                */\n         MOD=(CLASS=,       /* - DON'T CHANGE CLASS           DOHWNC*/\n              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/\n              ROUTECDE=,    /* - DON'T CHANGE DEST'N          DOHWNC*/\n              SYSAFF=),     /* - DON'T CHANGE SYSAFF.         DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/\n         RANGE=J1-32767,    /* RELOAD ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* RELOAD JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* ABORTED WITH $S OFFLOAD         DHWNC*/\n         SYSAFF=(),         /* RELOAD JOBS WITH ANY AFF       DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n/*                                                                  */\nOFF(1).JT CLASS=,           /* SELECT NO CLASSES              DOHWNC*/\n         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/\n         HOLD=,             /* SELECT HELD - NON-HELD         DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD     DHWNC*/\n         SYSAFF=(),         /* SELECT JOBS WITH ANY AFF       DOHWNC*/\n         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n/*                                                                  */\nOFF(1).SR BURST=,         /* SELECT ANY BURST SETTING       DOHWNC*/\n         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),\n         FCB=,              /* SELECT ANY FCB                 DOHWNC*/\n         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/\n         HOLD=,             /* SELCT HELD/NON-HLD JOBS        DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n                            /* MODIFY FOLLOWING ON RELOAD     DOHWNC*/\n         MOD=(BURST=,       /* - DON'T CHANGE BURST           DOHWNC*/\n              OUTDISP=,     /* - DON'T CHANGE DSHOLD          DOHWNC*/\n              FCB=,         /* - DON'T CHANGE FCB             DOHWNC*/\n              FLASH=,       /* - DON'T CHANGE FLASH           DOHWNC*/\n              FORMS=,       /* - DON'T CHANGE FORMS           DOHWNC*/\n              HOLD=,        /* - DON'T CHANGE HOLD            DOHWNC*/\n              PRMODE=,      /* - DON'T CHANGE PRMODE          DOHWNC*/\n              QUEUE=,       /* - DON'T CHANGE CLASS           DOHWNC*/\n              ROUTECDE=,    /* - DON'T CHANGE DESTN           DOHWNC*/\n              UCS=,         /* - DON'T CHANGE UCS             DOHWNC*/\n              WRITER=),     /* - DON'T CHANGE WRITER          DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON RELOAD         DOHWNC*/\n         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/\n         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/\n         UCS=,              /* SELECT ANY UCS                 DOHWNC*/\n         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DOHWNC*/\n                            /* - CLASS ONLY                   DOHWNC*/\n/*                                                                  */\nOFF(1).ST BURST=,           /* SELECT ANY BURST SET'G         DOHWNC*/\n         DISP=DELETE,       /* PURGE AFTER OFFLOAD            DOHWNC*/\n         OUTDISP=(HOLD,KEEP,LEAVE,WRITE),\n         FCB=,              /* SELECT ANY FCB                 DOHWNC*/\n         FLASH=,            /* SELECT ANY/NO FLASH            DOHWNC*/\n         HOLD=,             /* SELCT HELD-NON-HLD JOBS        DOHWNC*/\n         JOBNAME=,          /* SELECT ANY JOB NAME            DOHWNC*/\n         LIMIT=(0-*),       /* SELECT ANY # LINES             DOHWNC*/\n         NOTIFY=NO,         /* DON'T NOTIFY ON OFFLD.         DOHWNC*/\n         PLIM=(0-*),        /* SELECT ANY # PAGES             DOHWNC*/\n         PRMODE=(),         /* SELECT ANY PRMODE              DOHWNC*/\n         QUEUE=,            /* SELECT ANY SYSOUT CLASS        DOHWNC*/\n         RANGE=J1-32767,    /* SELECT ALL JOB NUMBERS         DOHWNC*/\n         ROUTECDE=(),       /* SELECT JOBS W/ANY DEST         DOHWNC*/\n         START=YES,         /* STARTED WITH $S OFFLOAD         DHWNC*/\n         UCS=,              /* SELECT ANY UCS                 DOHWNC*/\n         VOLUME=(),         /* SELECT ANY SPOOL VOLUME        DOHWNC*/\n         WRITER=,           /* SELECT ANY WRITER              DOHWNC*/\n         WS=(/)             /* JOB SELECTION CRITERIA         DLT   */\n                            /* - CLASS ONLY                   DOHWNC*/\n/*                                                                   */\n/*********************************************************************/\nOUTCLASS(A) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(B) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* NO TRACK-CELL                      WC*/\n/*                                                                  */\nOUTCLASS(C) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(D) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(H) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\n/*                                                                  */\nOUTCLASS(J) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* SPECIAL PRINT CLASS                WC*/\n         TRKCELL=NO        /* NO TRACK-CELL                      WC*/\n/*                                                                 */\nOUTCLASS(K) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */\n         OUTDISP=(HOLD,HOLD),                 /*               MAM */\n         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */\n/*                                                                 */\nOUTCLASS(L) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(KEEP,KEEP),\n         OUTPUT=PRINT,      /* PRINT CLASS FOR LWTR               WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(M) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                 */\nOUTCLASS(O) BLNKTRNC=YES,  /* TRUNCATE TRAILING BLANKS             */\n         OUTDISP=(HOLD,HOLD),                 /*               MAM */\n         OUTPUT=PRINT,      /* PRINT CLASS                     MAM */\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS               */\n/*                                                                 */\nOUTCLASS(P) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Q) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(T) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\n/*                                                                  */\nOUTCLASS(X) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Y) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(HOLD,HOLD),\n         OUTPUT=PRINT,      /* PRINT CLASS                        WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(Z) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(WRITE,WRITE),\n         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTCLASS(5) BLNKTRNC=YES,   /* TRUNCATE TRAILING BLANKS           WC*/\n         OUTDISP=(PURGE,PURGE),\n         OUTPUT=DUMMY,      /* DUMMY PRINT CLASS                  WC*/\n         TRKCELL=YES        /* TRACK-CELL THIS CLASS              WC*/\n/*                                                                  */\nOUTDEF   BRODCAST=NO,       /* WHETHER SHARED BROADCASTING     DOWNC*/\n         COPIES=255,        /* MAX. # OF COPIES ALLOWED       DOHWNC*/\n         DMNDSET=NO,        /* NO DEMAND SETUP                  DWNC*/\n         JOENUM=3000,       /* MAX. # OF JOES                   MAM2*/\n         JOEWARN=80,        /* WARNING THRESHOLD %            DOHWNC*/\n         PRTYHIGH=255,      /* CEILING FOR PRTY AGING         DOHWNC*/\n         PRTYLOW=0,         /* FLOOR FOR PRTY AGING           DOHWNC*/\n         PRTYOUT=NO,        /* NO PRTY= ON // OUTPUT          DOHWNC*/\n         STDFORM=STD,       /* DEFAULT FORMS ID                 DWNC*/\n         USERSET=NO         /* NO USER DEMAND-SETUP             DWNC*/\n/*                                                                  */\nOUTPRTY(1) PRIORITY=144,    /* OUTPUT PRTY IS 144 IF          DOHWNC*/\n         RECORD=2000,       /*  < 2000 RECORDS (LINE)         DOHWNC*/\n         PAGE=50            /*  OR < 50 PAGES (PAGE)          DOHWNC*/\n/*                                                                  */\nOUTPRTY(2) PRIORITY=128,    /* OUTPUT PRTY IS 128 IF          DOHWNC*/\n         RECORD=5000,       /*  < 5000 RECORDS (LINE)         DOHWNC*/\n         PAGE=100           /*  OR < 100 PAGES (PAGE)         DOHWNC*/\n/*                                                                  */\nOUTPRTY(3) PRIORITY=112,     /* OUTPUT PRTY IS 112 IF   &XPRI1    OC*/\n           RECORD=15000,     /*  <15000 RECORDS (LINE)  &XLIN1    OC*/\n           PAGE=300          /*  OR <300 PAGES (PAGE)   &XPAG1    OC*/\n                             /* ETC.                               OC*/\nOUTPRTY(4) PRIORITY=96,      /* OUTPUT PRTY IS  96 IF   &XPRI1    OC*/\n           RECORD=16677215,  /*  < MAX  RECORDS (LINE)  &XLIN1    OC*/\n           PAGE=16677215     /*  OR <MAX PAGES (PAGE)   &XPAG1    OC*/\n                             /* ETC.                               OC*/\n/*                                                                  */\nPCEDEF   CNVTNUM=2,         /* NUMBER OF CONVERTER PCES        DHWNC*/\n         OUTNUM=2,          /* NUMBER OF OUTPUT PCES           DHWNC*/\n         PSONUM=2,          /* NUMBER OF PSO PCES              DHWNC*/\n         PURGENUM=2         /* NUMBER OF PURGE PCES            DHWNC*/\n/*                                                                   */\nPRINTDEF CCWNUM=200,        /* # CCWS / PRINT BUFFER            DWNC*/\n         DBLBUFR=YES,       /* DOUBLE BUFFER LCL PRTS           DWNC*/\n         FCB=6,             /* INITIAL FCB LOADED               DWNC*/\n         LINECT=61,         /* 61 LINES/PAGE                  DOHWNC*/\n/*       NIFCB=8X8,    */   /* NO 3800 FCB LOADED               DWNC*/\n/*       NIFLASH=****, */    /* NO 3800 FLASH LOADED             DWNC*/\n                             /* NOTE: THE VALUES FOR NIFCB= AND      */\n                             /*       NIFLASH=  CANNOT BE NULL OR    */\n                             /*       ASTERISKS (AS SHOWN HERE).     */\n                             /*       IF THE STATEMENTS ARE NOT      */\n                             /*       CODED AT ALL, THEN THE DEFAULT */\n                             /*       WILL BE ASTERISKS. THE         */\n                             /*       STATEMENTS ARE SHOWN THIS WAY  */\n                             /*       ONLY TO INCLUDE THE DEFAULT    */\n                             /*       VALUES HERE.                   */\n         NIUCS=0,            /* WAS GT15                         DWNC*/\n         RDBLBUFR=NO,        /* SINGLE BUFFER RMT PRTS           DWNC*/\n         SEPPAGE=(REMOTE=HALF,LOCAL=FULL),\n         TRANS=NO,           /* PN-XLATE FOR 1403/RM.PR          DWNC*/\n         UCS=0               /* BYPASS UCS-LOADING               DWNC*/\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    LOCAL PRINTERS                    |\n                              *--------------------------------------*\n                                                                     */\n                             /* ALTERNATE NAME FOR PRTN:             */\n                             /*   PRINTERN                           */\n/*                                                                   */\nPUNCHDEF CCWNUM=200,         /* # CCWS / PUNCH BUFFER            DWNC*/\n         DBLBUFR=YES,        /* SINGLE BUFFER LCL PUNS           DWNC*/\n         RDBLBUFR=NO         /* SINGLE BUFFER RMT PUNS           DWNC*/\n/*                                                                   */\nPUN(1)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/\n        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/\n/*                                                                   */\nPUN(2)  CKPTLINE=100,    /* NO. OF CARDS TO PUNCH PER PAGE DOHWNC*/\n        CLASS=BK,    /*  OUTPUT CLASS PROCESSED BY PUN  DOHWNC*/\n       WS=(W,R,Q,PRM,LIM/F,P)  /* WORK SELECTION CRITERION    DOHWNC*/\n/*                                                                   */\nRDR(1)  AUTO,            /* RDRNN COMES UP STARTED (DRAIN) DOHWNC*/\n        CLASS=A,        /* DEFAULT JOB CLASS              DOHWNC*/\n        NOHOLD,         /* JOBS NOT HELD AFTER CONV.(HOLD)DOHWNC*/\n        MSGCLASS=A     /* DEFAULT MESSAGE CLASS          DOHWNC*/\n                             /* ERRORS ARE COUNTED                   */\n                             /*                                      */\n/*                                                                   */\nSMFDEF   BUFNUM=20,          /* NUMBER OF SMF BUFFERS            DWNC*/\n         BUFWARN=80          /* WARNING THRESHOLD %            DOHWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    SSI DEFINITIONS                   |\n                              |    ADDED IN SP311                    |\n                              *--------------------------------------*\n                                                                     */\nSSI(1)  TRACE=NO            /* SPECIFY WHICH SUBSYSTEM FUNCT  DOHWNC*/\n                            /* WHETHER OR NOT TRACING IS      DOHWNC*/\n                            /*  ACTIVE FOR THIS SSI FUNCTION        */\n/*                                                                   */\nSTCCLASS TIME=(0010,00),     /* JOB STEP TIME   ...MMMMSS........... */\n         REGION=0K,          /* REGION SIZE     .........CCC........ */\n         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R....... */\n         BLP=YES,            /* IGNORE BLP PARM .............L...... */\n         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.. */\n         MSGLEVEL=(1,1),     /* JOB, ALL MSGS   ..................EF */\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         OUTDISP=(HOLD,HOLD),      /* PURGE,HOLD TO HOLD,HOLD        */\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         MSGCLASS=K,         /* DEFAULT MESSAGE CLASS           DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n                             /*     (ADDED BY APAR OY02574)          */\n                             /*     (SUPERSEDED BY APAR OY03444)     */\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n/*                                                                   */\n/*                             TP (NJE/RJE) CHARACTERISTICS          */\n/*    TPDEF    BELOWBUF=(LIMIT=200,SIZE=1152,WARN=80),               */\nTPDEF    BELOWBUF=(LIMIT=200,SIZE=3840,WARN=80),\n         MBUFSIZE=3840,      /* MULTI-LEAVING BUFFER SIZE       DHWNC*/\n         RMTMSG=100,         /* MAX. # MSGS QUEUED TO REMOTE   DOHWNC*/\n         SESSION=20,         /* MAX. # SNA SESSIONS             DHWNC*/\n         AUTOINTV=120\n/*                                                                   */\n/*********************************************************************/\nTRACE(1)  START=NO           /* SPECIFY WHICH TRACE ID          DOWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    $TRACE FACILITY                   |\n                              *--------------------------------------*\n                                                                     */\nTRACEDEF TABLES=3,           /* NUMBER OF TRACE TABLES          DOWNC*/\n         PAGES=2,            /* NUMBER OF 4K PAGES PER TABLE     DWNC*/\n         TABWARN=80,         /* WARNING THRESHOLD %             DOWNC*/\n         ACTIVE=NO,          /* WHETHER OR NOT TO START HE      DOWNC*/\n                             /*  TRACE FACILITY                      */\n         LOG=(START=NO,      /* WHETHER OR NOT TO FORMAT AND    DOWNC*/\n                             /*  ADD DATA TO TRACE LOG DATASET       */\n              SIZE=500,      /* MAX SIZE OF TRACE LOG DATASET   DOWNC*/\n              CLASS=A)       /* TRACE LOG DATASET OUTPUT CLASS  DOWNC*/\n/*                                                                   */\n/*********************************************************************/\n/*                            *--------------------------------------*\n                              |    TSU DEFAULTS                      |\n                              *--------------------------------------*\n                                                                     */\nTSUCLASS TIME=(1440,00),     /* JOB STEP TIME   ...MMMMSS..........  */\n         REGION=0K,          /* REGION SIZE     .........CCC.......  */\n         COMMAND=EXECUTE,    /* EXECUTE COMMANDS............R......  */\n         BLP=NO,             /* IGNORE BLP PARM .............L.....  */\n         AUTH=ALL,           /* ALLOW ALL CMDS  ..............AAAA.  */\n         MSGLEVEL=(0,0),     /* JOB, ALL MSGS   ..................EF */\n         IEFUJP=YES,         /* TAKE SMF JOB PURGE EXIT         DHWNC*/\n         IEFUSO=YES,         /* TAKE SYSOUT EXCESS EXIT         DHWNC*/\n         OUTDISP=(PURGE,HOLD),     /* PURGE,HOLD                     */\n         LOG=YES,            /* PRINT JES2 JOB LOG              DHWNC*/\n         MSGCLASS=Z,         /* DEFAULT MESSAGE CLASS           DHWNC*/\n         OUTPUT=YES,         /* PRODUCE OUTPUT FOR JOB          DHWNC*/\n         PERFORM=000,        /* SRM PERFORMANCE GROUP 0         DHWNC*/\n         PROCLIB=00,         /* USE //PROC00 DD                 DHWNC*/\n         SWA=BELOW,          /* SWA CBS BELOW 16M LINE          DHWNC*/\n                             /*     (ADDED BY APAR OY02574)          */\n                             /*     (SUPERSEDED BY APAR OY03444)     */\n         TYPE6=YES,          /* PRODUCE SMF 6 RECORDS           DHWNC*/\n         TYPE26=YES          /* PRODUCE SMF 26 RECORDS          DHWNC*/\n                             /*                                      */\n./ ADD NAME=ZTSOKEY\nUSERMAX=10,                                                            +\nRECONLIM=3,                                                            +\nBUFRSIZE=132,                                                          +\nHIBFREXT=6600,                                                         +\nLOBFREXT=3300,                                                         +\nCHNLEN=4,                                                              +\nSCRSIZE=1920\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT609/FILE609.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT609", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}