{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012749000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 6113744, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE772.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 6113744, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 6113744, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE772.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00^\\x06'", "DS1TRBAL": "b'o\\xb2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05:\\x00\\r\\x05A\\x00\\x02\\x00_'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x073\\x7f\\x01\\x073\\x7f\\x104\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-12-03T00:00:00", "modifydate": "2007-12-03T10:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-475"}, "text": "REGULAR CBT TAPE - VERSION 475    FILE:  772\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT475.FILE772\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 14 MEMBERS COUNTED; CUMULATIVE SIZE IS 57,871 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/03/07    10:34:25    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PDSLOAD": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00%\\x01\\x026_\\x01\\x073/\\x13\\x07\\x00/\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2007-11-28T13:07:25", "lines": 47, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------- *//\n//*      PDSLOAD JOB TO CREATE INSTALL LIBRARIES        *//\n//*                                                     *//\n//*     (THIS JOB WAS TESTED TO WORK ON MY SYSTEM)      *//\n//* --------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT475.FILE772(PDSLOAD)')\n   DSN ('SBGOLOB.TEMP.PDSLOAD') VOL(WORK04)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT475.FILE772',      <=== CHANGE\n//             OPRE=SBGOLOB,\n//             QUAL=FILE772,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=WORK04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.TEMP.PDSLOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=ASM\n//S002 EXEC PDSLOAD,MEMB=C\n//S003 EXEC PDSLOAD,MEMB=CLIST\n//S004 EXEC PDSLOAD,MEMB=H\n//S005 EXEC PDSLOAD,MEMB=HELP\n//S006 EXEC PDSLOAD,MEMB=INCLUDE\n//S007 EXEC PDSLOAD,MEMB=MACLIB\n//S008 EXEC PDSLOAD,MEMB=MSG\n//S009 EXEC PDSLOAD,MEMB=PANEL\n//S010 EXEC PDSLOAD,MEMB=PDSLOAD\n//S011 EXEC PDSLOAD,MEMB=PLI\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE772": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x073\\x7f\\x01\\x073\\x7f\\x104\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-12-03T00:00:00", "modifydate": "2007-12-03T10:34:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "CBT-475"}, "text": "//***FILE 772 is from Stephen E. Bacher and contains a large part   *   FILE 772\n//*           of his work.  Most members of this pds are pds'es     *   FILE 772\n//*           in themselves, in PDSLOAD (like IEBUPDTE) unload      *   FILE 772\n//*           format, which (unlike IEBUPDTE format) can retain     *   FILE 772\n//*           ISPF stats from each member of the unloaded pds.      *   FILE 772\n//*                                                                 *   FILE 772\n//*       email:  \"Bacher,Stephen E.\" <seb@draper.com>              *   FILE 772\n//*                                                                 *   FILE 772\n//*       Members of this file are the following pds'es:            *   FILE 772\n//*                                                                 *   FILE 772\n//*    ASM     -  Assembler programs                                *   FILE 772\n//*    C       -  C programs                                        *   FILE 772\n//*    CLIST   -  REXXes and CLISTs                                 *   FILE 772\n//*    H       -  For the C programs                                *   FILE 772\n//*    HELP    -  TSO HELP members to guide you thru the stuff      *   FILE 772\n//*    INCLUDE -  For the PL/I programs                             *   FILE 772\n//*    MACLIB  -  For enhancing the TSO TEST command in programs    *   FILE 772\n//*    MSG     -  ISPF MSG Library                                  *   FILE 772\n//*    PANEL   -  ISPF Panel Library                                *   FILE 772\n//*    PLI     -  PL/I programs                                     *   FILE 772\n//*                                                                 *   FILE 772\n//*       Additional members of this file:                          *   FILE 772\n//*                                                                 *   FILE 772\n//*    PDSLOAD  - XMIT of load library containing the PDSLOAD pgm.  *   FILE 772\n//*    $PDSLOAD - Job to create pds'es out of all the members       *   FILE 772\n//*               in PDSLOAD (like IEBUPDTE) unload format.         *   FILE 772\n//*                                                                 *   FILE 772\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASM": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x073/\\x01\\x073/\\x19 \\x87,\\x87,\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T19:20:57", "lines": 34604, "newlines": 34604, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00464-00464-00000-SEB\n------------------------------------------------------------------------\nName:     BLOWJOB\nType:     ASM\nPurpose:  Program to force job to ABEND.  Parm passed = desired code.\nRequires:\nUsed by:\nComments: Same as BLOWUP except that it causes a STEP ABEND.\n------------------------------------------------------------------------\nName:     BLOWUP\nType:     ASM\nPurpose:  Program to force a user ABEND.  Parm passed = desired code.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     DCBADDR\nType:     ASM\nPurpose:  Subroutine to return address of a DCB to a PL/1 program.\nRequires: INCLUDE DCLDCB\nUsed by:\nComments: See comment block in source for usage from PL/1.\n------------------------------------------------------------------------\nName:     DRIVERFS\nType:     ASM\nPurpose:  Driver program for ACF82SCR full-screen logon module\nRequires:\nUsed by:\nComments: ACF2\n------------------------------------------------------------------------\nName:     DRIVERSU\nType:     ASM\nPurpose:  Driver program for IKJEFF10 TSO SUBMIT exit routine\nRequires:\nUsed by:\nComments: Better than IBM's driver.\n------------------------------------------------------------------------\nName:     EJECT\nType:     ASM\nPurpose:  TSO command to perform a page eject in background TMP\nRequires:\nUsed by:\nComments: This stopped working as of TSO/E Version 2 because of the use\n          of key 1 storage for TSO control blocks.  Otherwise, was very\n          useful in conjunction with XTERMOUT.\n------------------------------------------------------------------------\nName:     FSOFF\nType:     ASM\nPurpose:  Program to turn full screen mode off under TSO/VTAM.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     FSON\nType:     ASM\nPurpose:  Program to turn full screen mode on under TSO/VTAM.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     GETDSN\nType:     ASM\nPurpose:  Routine to return a DSNAME given a DDNAME\nRequires:\nUsed by:\nComments: Callable from FORTRAN or PL/1\n          Requires SWA=BELOW\n------------------------------------------------------------------------\nName:     GETJID\nType:     ASM\nPurpose:  Routine to return JES2 JOBID\nRequires:\nUsed by:\nComments: Callable from FORTRAN or PL/1\n          Requires ACF2\n------------------------------------------------------------------------\nName:     GETPGM\nType:     ASM\nPurpose:  Routine to return name of executing program\nRequires:\nUsed by:\nComments: Callable from FORTRAN or PL/1\n          Requires ACF2\n------------------------------------------------------------------------\nName:     H\nType:     ASM\nPurpose:  Subcommand to execute TSO commands or CLISTs under TSO TEST\nRequires:\nUsed by:\nComments: Not as much needed as it once was.  Patterned after the old\n          Program Control Facility \"X\" subcommand.\n------------------------------------------------------------------------\nName:     IKJEFF10\nType:     ASM\nPurpose:  TSO SUBMIT exit routine\nRequires:\nUsed by:\nComments: Assumes ACF2 in use.  Contains hardcoded defaults for JOB card\n          parameters like TIME and REGION.\n------------------------------------------------------------------------\nName:     IUCVUDP\nType:     ASM\nPurpose:  Program to demonstrate TCP/IP UDP via IUCV\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     PBRHLPA\nType:     ASM\nPurpose:  Use BRIF to display TSO command output under ISPF.\nRequires: INCLUDE XTSOVAR\n          ASM     XTSOVAR\n          PLI     PBRHELP\n          PLI     PBRHLPR\nUsed by:  CLIST BRHELP\nComments:\n------------------------------------------------------------------------\nName:     PROMPT\nType:     ASM\nPurpose:  TSO command to test the PUTGET PROMPT function.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     RECSIZE\nType:     ASM\nPurpose:  Subroutine to return record size of a file to a PL/1 program.\nRequires:\nUsed by:\nComments: See comment block in source for usage from PL/1.\n------------------------------------------------------------------------\nName:     TCBMAP\nType:     ASM\nPurpose:  Program to map TCB tree system control blocks.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     TMPOFF\nType:     ASM\nPurpose:  Program to turn Session Manager mode off via STTMPMD.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     TMPON\nType:     ASM\nPurpose:  Program to turn Session Manager mode on via STTMPMD.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     VITWHR\nType:     ASM\nPurpose:  IPCS TCB exit to return WHERE an address is, in ISPF variables\nRequires:\nUsed by:  CLIST IPRB\nComments: IPCS,ISPF\n------------------------------------------------------------------------\nName:     VMCFTCP\nType:     ASM\nPurpose:  Program to demonstrate TCP/IP via VMCF\nRequires:\nUsed by:\nComments: Some source code lifted from IBM PASCAL files\n------------------------------------------------------------------------\nName:     VMCFUDP\nType:     ASM\nPurpose:  Program to demonstrate UDP via VMCF\nRequires:\nUsed by:\nComments: Some source code lifted from IBM PASCAL files\n------------------------------------------------------------------------\nName:     XABDGET\nType:     ASM\nPurpose:  Interface module for IPCS verb exits / TSO command processors\nRequires:\nUsed by:  ASM XIP*\nComments: Requires IPCS, but is designed to enable other ASM routines to\n          function as either IPCS verb exits or TSO command processors.\n          Thus, they can collect and display data either from an IPCS\n          dump or the live session.\n------------------------------------------------------------------------\nName:     XACF2\nType:     ASM\nPurpose:  Program to test ACF2 access\nRequires:\nUsed by:\nComments: ACF2\n------------------------------------------------------------------------\nName:     XALCMOD\nType:     ASM\nPurpose:  TSO command to modify allocations\nRequires:\nUsed by:\nComments: Requires SWA=BELOW\n------------------------------------------------------------------------\nName:     XALCUNIT\nType:     ASM\nPurpose:  TSO command to return allocation info about a unit address\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XALLOCSV\nType:     ASM\nPurpose:  TSO command to save current allocation info in a data set\nRequires:\nUsed by:\nComments: Requires SWA=BELOW\n------------------------------------------------------------------------\nName:     XAMODE\nType:     ASM\nPurpose:  Function that returns current AMODE to FORTRAN or PL/1 program\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XCLIST\nType:     ASM\nPurpose:  Subroutine to run a TSO command or CLIST from a PL/1 program\nRequires: ASM XTSEXEC\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XCONCAT\nType:     ASM\nPurpose:  TSO command to concatenate 2 or more preallocated files\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XDECONC\nType:     ASM\nPurpose:  TSO command to deconcatenate a concatenated file name\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XFINDM\nType:     ASM\nPurpose:  Program to tell where member is in PDS concatenation\nRequires:\nUsed by:  CLIST FINDMEM\nComments: When there are too many libraries in the linklist (for when\n          no DDNAME is given), or too many datasets allocated to a given\n          DDNAME, ABEND S013-E4 results due to too many extents.  Hence\n          the FINDMEM2 CLIST replaced the FINDMEM CLIST and doesn't use\n          the XFINDM routine at all.\n------------------------------------------------------------------------\nName:     XGET\nType:     ASM\nPurpose:  Subroutine to do a TGET from a PL/1 program\nRequires:\nUsed by:  lots of PLI programs\nComments:\n------------------------------------------------------------------------\nName:     XIPMAP\nType:     ASM\nPurpose:  IPCS verb exit to map TCB tree control blocks\nRequires: ASM XABDGET\nUsed by:\nComments: Can be used on TSO or under IPCS (see XABDGET).\n------------------------------------------------------------------------\nName:     XIPSWHR\nType:     ASM\nPurpose:  IPCS verb exit to return \"where\" information about an address\nRequires:\nUsed by:\nComments: Not flexible like XIPWHR, but supports searching IPCS NUCMAP.\n------------------------------------------------------------------------\nName:     XIPWHR\nType:     ASM\nPurpose:  IPCS verb exit to return \"where\" information about an address\nRequires: ASM XABDGET\nUsed by:\nComments: Can be used on TSO or under IPCS (see XABDGET).\n------------------------------------------------------------------------\nName:     XITMAP\nType:     ASM\nPurpose:  IPCS TCB exit to map RB control blocks\nRequires: ASM XABDGET\nUsed by:\nComments: Can be used on TSO or under IPCS (see XABDGET).\n------------------------------------------------------------------------\nName:     XITSAV\nType:     ASM\nPurpose:  IPCS TCB exit to display save area trace\nRequires: ASM XABDGET\nUsed by:\nComments: Can be used on TSO or under IPCS (see XABDGET).\n------------------------------------------------------------------------\nName:     XITWHR\nType:     ASM\nPurpose:  IPCS TCB exit to tell \"where\" an address is\nRequires: ASM XABDGET\nUsed by:\nComments: Can be used on TSO or under IPCS (see XABDGET).\n------------------------------------------------------------------------\nName:     XLBRKS\nType:     ASM\nPurpose:  TSO TEST subcommand to list breakpoints\nRequires: MACRO TCOMTAB\nUsed by:\nComments: See note under MACLIB TCOMTAB.  You may not be legally able\n          to assemble this routine!\n          Should be aliased to LISTBRKS, unless you use a REXX exec by\n          that name to invoke it, which may be necessary to get TSO TEST\n          to treat it as a subcommand.  You could also use the \"H\" hack\n          (see H) to run it.\n------------------------------------------------------------------------\nName:     XLL\nType:     ASM\nPurpose:  Program to scan load modules for character strings\nRequires:\nUsed by:\nComments: Has an ISPF interface (see ...)\n------------------------------------------------------------------------\nName:     XLNKLST\nType:     ASM\nPurpose:  TSO command to allocate the link list\nRequires: HELP XLNKLST\nUsed by:  CLIST ALLOCLNK\nComments: (See HELP XLNKLST)\n------------------------------------------------------------------------\nName:     XLSYMS\nType:     ASM\nPurpose:  TSO TEST subcommand to list equated symbols\nRequires: MACRO TCOMTAB\nUsed by:\nComments: See note under MACLIB TCOMTAB.  You may not be legally able\n          to assemble this routine!\n          Should be aliased to LISTSYMS, unless you use a REXX exec by\n          that name to invoke it, which may be necessary to get TSO TEST\n          to treat it as a subcommand.  You could also use the \"H\" hack\n          (see H) to run it.\n------------------------------------------------------------------------\nName:     XPROC\nType:     ASM\nPurpose:  TSO command to emulate CLIST PROC statement for REXX\nRequires: ...\nUsed by:  lots of CLIST members\nComments: This is also on the CBT tape in File 431.\n------------------------------------------------------------------------\nName:     XPUT\nType:     ASM\nPurpose:  Subroutine to do a TPUT from a PL/1 program\nRequires:\nUsed by:  lots of PLI programs\nComments: There is also an XPUTLINE routine, but it's not mine and I may\n          not have the freedom to distribute it.\n------------------------------------------------------------------------\nName:     XRXDEQ\nType:     ASM\nPurpose:  REXX module to do a DEQ\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XRXENQ\nType:     ASM\nPurpose:  REXX module to do an ENQ\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XTSEXEC\nType:     ASM\nPurpose:  Run time TSO command or CLIST executor\nRequires:\nUsed by:  ASM XCLIST\nComments:\n------------------------------------------------------------------------\nName:     XQSCAN\nType:     ASM\nPurpose:  TSO command to display ENQ information.\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XRXVARS\nType:     ASM\nPurpose:  REXX utility to display values of REXX variables\nRequires:\nUsed by:  CLIST SYSCALL\nComments:\n------------------------------------------------------------------------\nName:     XTSOVAR\nType:     ASM\nPurpose:  Function used by PL/I programs to access CLIST variables\nRequires: INCLUDE XTSOVAR\nUsed by:  PLI PBRHELP\nComments: Also see XTSVAR,XTSVARV\n------------------------------------------------------------------------\nName:     XTSVAR\nType:     ASM\nPurpose:  Function used by FORTRAN programs to access CLIST variables\nRequires:\nUsed by:\nComments: Same as XTSOVAR (q.v.).\n------------------------------------------------------------------------\nName:     XTSVARV\nType:     ASM\nPurpose:  Function used by PL/I programs to access CLIST variables\nRequires: INCLUDE XTSOVAR\nUsed by:\nComments: Also see XTSVAR,XTSOVAR.  Looks substantially same as XTSOVAR\n------------------------------------------------------------------------\nName:     XUSERS\nType:     ASM\nPurpose:  TSO command to display users logged on\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XUSING\nType:     ASM\nPurpose:  TSO command to display who is using a volume or unit\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XVOLUME\nType:     ASM\nPurpose:  Display UCB information about devices\nRequires:\nUsed by:  CLIST DU\nComments:\n------------------------------------------------------------------------\nName:     XVX\nType:     ASM\nPurpose:  ISPF dialog program to display virtual storage\nRequires: PANEL XVX*, TXVX*\n          MSG XVX*\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XWRITENR\nType:     ASM\nPurpose:  REXX function to emulate CLIST XWRITENR statement for REXX\nRequires: ...\nUsed by:  lots of CLIST members\nComments: This is also on the CBT tape in File 431.\n------------------------------------------------------------------------\nName:     YITADDR\nType:     ASM\nPurpose:  IPCS TCB exit to return a hex address as a CLIST variable\nRequires:\nUsed by:\nComments: IPCS\n------------------------------------------------------------------------\nName:     YITSAV\nType:     ASM\nPurpose:  IPCS TCB exit to display save area trace\nRequires:\nUsed by:\nComments: IPCS\n------------------------------------------------------------------------\nName:     YITWHR\nType:     ASM\nPurpose:  IPCS TCB exit to return where an address is as CLIST variable\nRequires:\nUsed by:\nComments: IPCS\n------------------------------------------------------------------------\n./ ADD NAME=BLOWJOB  0100-07332-07332-0900-00095-00095-00000-SEB\n         TITLE 'BLOWJOB - MODULE TO CAUSE JOB TO ABEND'\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nBLOWJOB  CSECT\n         SAVE  (14,12),,BLOWJOB_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING BLOWJOB,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         L     R2,0(,R2)           GET ADDRESS OF PARM STRING\n         LH    R3,0(,R2)           GET LENGTH OF PARM STRING\n         LTR   R3,R3               IF NULL PARM STRING\n         BNZ   GETCODE             THEN\n         XR    R1,R1                USE USER CODE OF ZERO\n         B     ABEND               ELSE\nGETCODE  CH    R3,=H'3'            IF CODE LENGTH IS 3\n         BNE   NOT0CX              AND\n         CLC   2(2,R2),=C'0C'      CODE BEGINS WITH 0C\n         BNE   NOT0CX              THEN\n         MVC   ABCODE,4(R2)         GET PROGRAM CHECK CODE\n         TR    ABCODE,TRTBL         TRANSLATE TO BINARY NUMERIC\n         XR    R1,R1                CLEAR INSERT REG\n         IC    R1,ABCODE            GET NUMERIC ABEND CODE\n         LA    R1,X'0C0'(,R1)       ADD 0C TO GET ABEND CODE\n         SLL   R1,12                MAKE IT OCX000\n         B     ABEND\nNOT0CX   DS    0H\n         BCTR  R3,0                REDUCE PARM LENGTH FOR EXECUTE\n         EX    R3,PACK             PACK PARM INTO CONVERSION DOUBLEWORD\n         CVB   R1,DOUBLE           PICK UP ABEND CODE\nABEND    DS    0H\n         SPACE 1\n         ABEND (1),DUMP,STEP\n         SPACE 1\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTION                                                *\n***********************************************************************\nPACK     PACK  DOUBLE(8),2(0,R2)  PACK PARM INTO DOUBLEWORD\n         SPACE 1\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nTRTBL    DC    256YL1(*-TRTBL)\n         ORG   TRTBL+C'0'\n         DC    YL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   TRTBL+C'A'\n         DC    YL1(10,11,12,13,14,15)\n         ORG\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nABCODE   DS    C\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=BLOWUP   0100-07332-07332-0900-00099-00099-00000-SEB\n         TITLE 'BLOWUP - MODULE TO CAUSE AN ABEND'\n***********************************************************************\n*                                                                     *\n* BLOWUP - MODULE TO CAUSE A USER ABEND                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nBLOWUP   CSECT\n         SAVE  (14,12),,BLOWUP_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING BLOWUP,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         L     R2,0(,R2)           GET ADDRESS OF PARM STRING\n         LH    R3,0(,R2)           GET LENGTH OF PARM STRING\n         LTR   R3,R3               IF NULL PARM STRING\n         BNZ   GETCODE             THEN\n         XR    R1,R1                USE USER CODE OF ZERO\n         B     ABEND               ELSE\nGETCODE  CH    R3,=H'3'            IF CODE LENGTH IS 3\n         BNE   NOT0CX              AND\n         CLC   2(2,R2),=C'0C'      CODE BEGINS WITH 0C\n         BNE   NOT0CX              THEN\n         MVC   ABCODE,4(R2)         GET PROGRAM CHECK CODE\n         TR    ABCODE,TRTBL         TRANSLATE TO BINARY NUMERIC\n         XR    R1,R1                CLEAR INSERT REG\n         IC    R1,ABCODE            GET NUMERIC ABEND CODE\n         LA    R1,X'0C0'(,R1)       ADD 0C TO GET ABEND CODE\n         SLL   R1,12                MAKE IT OCX000\n         B     ABEND\nNOT0CX   DS    0H\n         BCTR  R3,0                REDUCE PARM LENGTH FOR EXECUTE\n         EX    R3,PACK             PACK PARM INTO CONVERSION DOUBLEWORD\n         CVB   R1,DOUBLE           PICK UP ABEND CODE\nABEND    DS    0H\n         SPACE 1\n         ABEND (1),DUMP\n         SPACE 1\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTION                                                *\n***********************************************************************\nPACK     PACK  DOUBLE(8),2(0,R2)  PACK PARM INTO DOUBLEWORD\n         SPACE 1\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nTRTBL    DC    256YL1(*-TRTBL)\n         ORG   TRTBL+C'0'\n         DC    YL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   TRTBL+C'A'\n         DC    YL1(10,11,12,13,14,15)\n         ORG\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nABCODE   DS    C\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=DCBADDR  0100-07332-07332-0900-00045-00045-00000-SEB\n***********************************************************************\n*                                                                     *\n* PROCEDURE NAME:  DCBADDR                                            *\n*                                                                     *\n* FUNCTION:  TO RETURN A POINTER TO THE DCB OF A PL/1 FILE.           *\n*                                                                     *\n* DECLARATION:                                                        *\n*                                                                     *\n*     DCL DCBADDR EXTERNAL ENTRY(FILE) RETURNS(PTR);                  *\n*                                                                     *\n* SAMPLE INVOCATION:                                                  *\n*                                                                     *\n*     %INCLUDE SYSLIB(DCLDCB);  /* DECLARE DCB ATTRIBUTES */          *\n*                                                                     *\n*     DCL    SYSPRINT_DCB CHAR(96) BASED(DCBPTR),                     *\n*            DCBPTR       PTR;                                        *\n*                                                                     *\n*     DCBPTR = DCBADDR(SYSPRINT);                                     *\n*                                                                     *\n*     IF DCBPTR ^= NULL THEN                                          *\n*       BLOCKSIZE = DCBPTR -> DCBBLKSI;                               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nDCBADDR  CSECT\n         USING DCBADDR,15\n         STM   14,4,12(13)\n         LM    2,3,0(1)            R2 -> ADDR(DCLCB), R3 -> RETURN AREA\n         L     2,0(,2)             R2 -> DCLCB\n         L     1,4(,12)            R1 -> PRV\n         AH    1,2(,2)              ADD OFFSET OF FCB PTR IN PRV\n         ICM   4,15,0(1)           R4 -> FCB\n         BZ    NODCB               IF NO FCB, RETURN(NULL)\n         ICM   4,15,20(4)          R4 -> DCB\n         BZ    NODCB               IF NO DCB, RETURN(NULL)\n         LA    0,0(,4)             R0 = ADDR(DCB)\n         B     RETURN\nNODCB    DS    0H                  NO DCB, USE NULL BUILT-IN FUNCTION\n         LA    0,255               R0 = X'000000FF'\n         SLL   0,24                R0 = X'FF000000'\nRETURN   ST    0,0(,3)             STORE RESULT IN RETURN AREA\n         LM    14,4,12(13)\n         BR    14\n         END\n./ ADD NAME=DRIVERFS 0100-07332-07332-0900-00382-00382-00000-SEB\n         TITLE 'DRIVERFS - ACF2 FULL-SCREEN LOGON DRIVER'\n***********************************************************************\n*                                                                     *\n* DRIVERFS - ACF2 FULL-SCREEN LOGON DRIVER                            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    .\nR5       EQU   5    Address of buffer to hold menu\nR6       EQU   6    Length of full screen logon menu\nR7       EQU   7    Length of buffer to hold menu\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   Address of ACF82SCR\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nDRIVERFS CSECT\n         SAVE  (14,12),,DRIVERFS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING DRIVERFS,R12\n*\n* THIS PROGRAM IS NOT REENTRANT.\n* THEREFORE THE SAVE AREA IS INLINE.\n*\n         LA    R14,SAVEAREA\n         ST    R13,4(,R14)\n         ST    R14,8(,R13)\n         LR    R13,R14\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Load the ACF2 full-screen logon module, ACF82SCR.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LOAD  EPLOC==CL8'ACF82SCR'\n         LR    R11,R0              Save its address\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  The layout of ACF82SCR is as follows:                              *\n*                                                                     *\n*  +00   4    C'OSCR'                                                 *\n*  +04   4    Offset to screen definition                             *\n*  +08   4    Length of output screen                                 *\n*  +0C   *    Field definitions.  Each is 12 bytes long as follows:   *\n*                                                                     *\n*    +00  4   Field identifier                                        *\n*    +04  4   Offset into ACF82SCR of field                           *\n*    +08  4   Length of field                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R6,8(,R11)          Get length of output screen\n         LA    R7,16(,R6)          Add some slack bytes\n         GETMAIN R,LV=(R7)\n         LR    R5,R1\n         SPACE 1\n         MVC   0(L'INTRO,R5),INTRO Move in TPUT FULLSCR header\n         SPACE 1\n         L     R14,4(,R11)         Load offset of screen definition\n         AR    R14,R11             Convert to absolute address\n         ST    R14,ENDFLD          Save as end of field definitions\n         LA    R0,L'INTRO(,R5)     Point into getmained buffer\n         LR    R1,R6               Get length to move\n         LR    R15,R6\n         MVCL  R0,R14              Move ACF82SCR menu to getmained menu\n         SPACE 1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process the field definitions.  For each field definition, we find  *\n* the entry in our own table that matches the field identifier, and   *\n* move the corresponding data to the menu in the buffer.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R4,12(,R11)         Point to first field definition\nFLDLOOP  DS    0H\n         C     R4,ENDFLD           until end of field definitions\n         BNL   FLDEND\n         L     R8,0(,R4)           Load character field identifier\n         LA    R9,ENTRIES          Start looking at our entries\nENTLOOP  DS    0H\n         C     R9,=A(ENDENTRS)\n         BNL   NOTFOUND\n         CL    R8,0(,R9)\n         BE    FOUND\n         LA    R9,12(,R9)\n         B     ENTLOOP\nFOUND    DS    0H\n         L     R14,4(,R4)          Get offset of menu field\n         LA    R14,2(R5,R14)       Convert to address in menu buffer\n         L     R2,4(,R9)           Get address of our field data\n         L     R3,8(,R9)           Get length of our field data\n         L     R15,8(,R4)          Get length of their field data\n         TM    4(R9),X'80'         If this is a field to move directly\n         BZ    NOTDIREC            then\n         LTR   R15,R15              if the field length is zero (CURS)\n         BNZ   NOTZERO              then\n         LR    R15,R3                load field length from ours\nNOTZERO  DS    0H\n         MVCL  R14,R2              Move our field data to menu buffer\n         B     FLDCONT\nNOTDIREC DS    0H                  else\n         TM    8(R9),X'80'         If this is a boolean field\n         BZ    NOTBOOL             then\n         LH    R3,10(,R9)           reload length\n         LA    R14,3+2+3(,R14)      reload address\n         MVCL  R14,R2              Move our field data to menu buffer\n         B     FLDCONT\nNOTBOOL  DS    0H\n         LA    R14,3+3+10+4+2+3(,R14) reload address\n         MVCL  R14,R2              Move our field data to menu buffer\n         B     FLDCONT\nNOTFOUND DS    0H                  else\n         LA    R14,3+3+10+4+2+3(,R14) reload address\n         XR    R2,R2\n         XR    R3,R3\n         ICM   R15,B'1000',=CL1'?'\n         MVCL  R14,R2              Move our field data to menu buffer\n         B     FLDCONT\nFLDCONT  DS    0H\n         LA    R4,12(,R4)          Continue with next menu field\n         B     FLDLOOP\nFLDEND   DS    0H\n         SPACE 1\n*                                  Convert all row-and-column specs\n*                                  to true 3270 buffer addresses\n         LA    R15,L'INTRO+1(,R5)  Point to beginning of TPUT data\n         LA    R14,L'INTRO(,R6)    Get length of menu plus intro\n         AR    R14,R15             Point to end of menu\nSBALOOP  DS    0H\n         CR    R15,R14             Loop until hit end of buffer\n         BNL   SBAEND\n         CLI   0(R15),X'11'\n         BE    CONVSBA\n         CLI   0(R15),X'3C'\n         BE    CONVRA\n         CLI   0(R15),X'1D'\n         BE    CONVSF\n         LA    R15,1(,R15)\n         B     SBALOOP\nCONVSBA  DS    0H\n         LA    R1,1(,R15)          Point to buffer address\n         BAL   R2,CONVERT\n         LA    R15,3(,R15)\n         B     SBALOOP\nCONVRA   DS    0H\n         LA    R1,1(,R15)          Point to buffer address\n         BAL   R2,CONVERT\n         LA    R15,4(,R15)\n         B     SBALOOP\nCONVSF   DS    0H                  Just skip over it\n         LA    R15,2(,R15)\n         B     SBALOOP\n         SPACE 1\nSBAEND   DS    0H\n         SPACE 1\n         XC    AREA,AREA           Clear TGET area\n         SPACE 1\nRESHOWF  DS    0H\n         STFSMODE ON,INITIAL=YES\nRESHOW   DS    0H\n         TCLEARQ INPUT\n         LA    R0,L'INTRO(,R6)     Get length of menu plus intro\n         TPUT  (R5),(0),FULLSCR\n         TGET  AREA,L'AREA,ASIS\n         SPACE 1\n         CH    R15,=H'8'           If ATTN was hit\n         BE    RESHOWF             then reset full screen env, reshow.\n         SPACE 1\n         CLI   AREA,X'6E'          If PA2 hit\n         BE    RESHOW              then reshow the panel.\n         CLI   AREA,X'F3'          If PF3 hit\n         BE    EXIT                then exit.\n         CLI   AREA,X'C3'          If PF15 hit\n         BE    EXIT                then exit.\n*        ...                       Else do stuff\n         B     RESHOW              and reshow.\n         SPACE 1\nEXIT     DS    0H\n         SPACE 1\n         STFSMODE OFF\n         SPACE 1\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Cleanup.                                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         FREEMAIN R,LV=(R7),A=(R5)\n         SPACE 1\n         DELETE EPLOC==CL8'ACF82SCR'\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nCONVERT  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine converts a row-and-column to 3270 SBA at R1?.       *\n*                                                                     *\n***********************************************************************\n*\n         CLI   0(R1),X'40'         Only convert \"r-c\" values\n         BNLR  R2\n         XR    R0,R0\n         IC    R0,0(,R1)           Get row number\n         BCTR  R0,0                Convert to absolute\n         MH    R0,=H'80'\n         MVI   0(R1),X'00'\n         AH    R0,0(,R1)           Add column number\n         BCTR  R0,0                Convert to absolute\n         STH   R0,0(,R1)           Use absolute as buffer address\n         BR    R2                  Return to caller\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nINTRO    DC    X'27F5'             Escape plus erase-write-alternate\n         SPACE 1\nENTRIES  DS    0A                  Start of field entry table\n         DC    CL4'    '           Field ID\n         DC    A(*-*)              Address of data area\n         DC    A(0)                Length\n         DC    CL4' LID'             FIELD IDENTIFIER           ACF 400\n         DC    A($LID)               OFFSET INTO CSECT OF FIELD ACF 400\n         DC    A(L'$LID)             LENGTH OF FIELD            ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'SRCE'             FIELD ID                   ACF 400\n         DC    A($SRCE)              OFFSET                     ACF 400\n         DC    A(L'$SRCE)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4' GRP'             FIELD ID                   ACF 400\n         DC    A($GRP)\n         DC    A(L'$GRP)             LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'PROC'             FIELD ID                   ACF 400\n         DC    A($PROC)\n         DC    A(L'$PROC)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'MSGC'             FIELD ID                   ACF 400\n         DC    A($MSGC)\n         DC    A(L'$MSGC)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'UNIT'             FIELD ID                   ACF 400\n         DC    A($UNIT)              OFFSET                     ACF 400\n         DC    A(L'$UNIT)            LENGTH                     TS79674\n         SPACE 1                                                ACF 400\n         DC    CL4'TIME'             FIELD ID                   ACF 400\n         DC    A($TIME)              OFFSET                     ACF 400\n         DC    A(L'$TIME)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'SIZE'             FIELD ID                   ACF 400\n         DC    A($SIZE)              OFFSET                     ACF 400\n         DC    A(L'$SIZE)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'ACCT'             FIELD ID                   ACF 400\n         DC    A($ACCT)              OFFSET                     ACF 400\n         DC    A(L'$ACCT)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'PERF'             FIELD ID                   ACF 400\n         DC    A($PERF)              OFFSET                     ACF 400\n         DC    A(L'$PERF)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'MAIL'             FIELD ID                   ACF 400\n         DC    A($MAIL)              OFFSET                     ACF 400\n         DC    X'8000'\n         DC    Y(L'$MAIL)\n         SPACE 1                                                ACF 400\n         DC    CL4'NOTC'             FIELD ID                   ACF 400\n         DC    A($NOTC)              OFFSET                     ACF 400\n         DC    X'8000'\n         DC    Y(L'$NOTC)\n         SPACE 1                                                ACF 400\n         DC    CL4'RECV'             FIELD ID                   ACF 400\n         DC    A($RECV)              OFFSET                     ACF 400\n         DC    X'8000'\n         DC    Y(L'$RECV)\n         SPACE 1                                                ACF 400\n         DC    CL4'RECN'             FIELD ID                   ACF 400\n         DC    A($RECN)\n         DC    X'8000'\n         DC    Y(L'$RECN)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'USER'             FIELD ID                   ACF 400\n         DC    A($USER)              OFFSET                     ACF 400\n         DC    A(L'$USER)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'CURS'             FIELD ID                   ACF 400\n         DC    A($CURS+X'80000000')  AREA TO PLACE CURSOR ADDRESS\n         DC    A(L'$CURS)            FLD HAS NO CORRESPONDING INPUT FLD\n         SPACE 1                                                ACF 400\n         DC    CL4'RLSE'             FIELD ID                   ACF 400\n         DC    A($RELS+X'80000000')  ADDRESS OF RELEASE AREA    ACF 400\n         DC    A(L'$RELS)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'MSG1'             FIELD ID                   ACF 400\n         DC    A($MSG1+X'80000000')\n         DC    A(L'$MSG1)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'MSG2'             FIELD ID                   ACF 400\n         DC    A($MSG2+X'80000000')\n         DC    A(L'$MSG2)            LENGTH                     ACF 400\n         SPACE 1                                                ACF 400\n         DC    CL4'MSG3'             FIELD ID                   ACF 400\n         DC    A($MSG3+X'80000000')\n         DC    A(L'$MSG3)            LENGTH                     ACF 400\nENDENTRS DS    0A                  End of field entry table\n         SPACE 2\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\n* NON-REENTRANT INLINE SAVE AREA FOLLOWS\n         SPACE 1\nSAVEAREA DS    18F\nENDFLD   DS    A                   Address of end of field definitions\n$LID     DC    C'SEB1525'\n$SRCE    DC    C'LOCFUBAR'\n$GRP     DC    C'THE FUGS'\n$PROC    DC    C'MAIN    '\n$MSGC    DC    C'H'\n$UNIT    DC    C'SYSALLDA'\n$TIME    DC    C'(2,30)'\n$SIZE    DC    C'6144K'\n$ACCT    DC    C'(9050-00,3333)'\n$PERF    DC    C'NONE'\n$MAIL    DC    C'YES'\n$NOTC    DC    C'YES'\n$RECV    DC    C'NO '\n$RECN    DC    C'NO '\n$USER    DC    C'ROOM(UP) /* whatever you want to insert here */'\n$CURS    DC    X'114040'           Cursor position\n$RELS    DC    C'4.1.0'\n$MSG1    DC    C'This is message number 1.'\n$MSG2    DC    C'This is message number 2.'\n$MSG3    DC    C'This is message number 3.'\n         SPACE 1\nAREA     DS    CL256               Area for TGETs\n         SPACE 2\n*\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=DRIVERSU 0100-07332-07332-0900-00845-00845-00000-SEB\n         TITLE 'DRIVERSU - SUBMIT EXIT DRIVER (INSTEAD OF DRIVER10)'\n***********************************************************************\n*                                                                     *\n* DRIVERSU - SUBMIT EXIT DRIVER (INSTEAD OF DRIVER10)                 *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LINKAGE EDITOR ATTRIBUTES: NORENT, NOREUS, NCAL                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS A DRIVER FOR SUBMIT EXIT IKJEFF10.  IT WAS WRITTEN BECAUSE  *\n* THE IPO-SUPPLIED DRIVER (DRIVER10) DOESN'T SEEM TO WORK.  THIS ONE  *\n* IS USED TO TEST OUT CHANGES TO THE SUBMIT EXIT.  IT READS THE INPUT *\n* JCL FROM DDNAME SUBMIT, CALLS THE EXIT WHERE APPROPRIATE, AND       *\n* DISPLAYS THE OUTPUT JCL AT THE TERMINAL AND INDICATES WHETHER THE   *\n* JOB WOULD HAVE BEEN SUBMITTED OR NOT.  THE EXIT MAY BE LINKEDITED   *\n* WITH THIS MODULE OR DYNAMICALLY LOADED.  NOTE THAT ANY INSTRUCTIONS *\n* WHICH ARE DEPENDENT ON SUPERVISOR STATE (E.G. MODESET'S) MUST BE    *\n* BYPASSED WHEN RUNNING UNDER THIS DRIVER.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* EVERY ATTEMPT HAS BEEN MADE TO SIMULATE THE ACTUAL PROCESSING OF    *\n* THE SUBMIT COMMAND, WARTS AND ALL, WITHIN CERTAIN LIMITATIONS.      *\n* NOTE: AT THIS TIME THE DRIVER DOES NOT HANDLE CERTAIN CONDITIONS.   *\n* LOGON COMMANDS (WHICH CAUSE SUBMIT TO GENERATE TMP-IN-BATCH JCL)    *\n* ARE NOT SCANNED FOR.  THE PROBLEM WHEREBY JCL BEGINNING WITH A JES2 *\n* CARD IS NOT PROCESSED CORRECTLY BY SUBMIT IS NOT \"SIMULATED\" HERE.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nDRIVERSU CSECT\n         SAVE  (14,12),,DRIVERSU_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING DRIVERSU,R12\n*\n* THIS PROGRAM IS NOT REENTRANT.\n* THEREFORE THE SAVE AREA IS INLINE.\n*\n         LA    R14,SAVEAREA\n         ST    R13,4(,R14)\n         ST    R14,8(,R13)\n         LR    R13,R14\n         EJECT\n         ICM   R15,15,EFF10ADR     IF IKJEFF10 NOT LINKED WITH US\n         BNZ   GOTIT               THEN\n         LOAD  EP=IKJEFF10          LOAD IT\n         ST    R0,EFF10ADR          AND SAVE ITS ADDRESS\nGOTIT    DS    0H\n         TPUT  ASKVER,L'ASKVER\n         TGET  ANSWER,1\n         TCLEARQ INPUT\n         OI    ANSWER,X'40'\n         CLI   ANSWER,C'Y'\n         BE    YESVER\n         CLI   ANSWER,C'N'\n         BE    NOVER\n         B     GOTIT\nYESVER   DS    0H\n         MVI   NEWVER,1\n         B     LETSGO\nNOVER    DS    0H\n         MVI   NEWVER,0\n         B     LETSGO\nLETSGO   DS    0H\n         L     R15,X'21C'          TCB\n         L     R15,X'B4'(,R15)     JSCB\n         L     R15,X'15C'(,R15)    ACTIVE JSCB\n         L     R7,X'108'(,R15)     PSCB\n         USING PSCB,R7\n         MVC   DEFCLASS,PSCBSUBC   SUBMIT CLASS FOR DEFAULT JOBCARD\n         MVC   USERID,BLANKS\n         XR    R14,R14\n         ICM   R14,1,PSCBUSRL      LENGTH OF USERID\n         BZ    NOUSERID            IF NONZERO,\n         BCTR  R14,0               THEN\n         EX    R14,MOVEUID          MOVE USERID FROM PSCB TO USERID\nNOUSERID DS    0H\n         MVC   JOBCARD1+2(7),USERID SET UP USER'S ID FOR JOB CARDS\n         MVC   JOBCARD2+15(7),USERID\n         MVC   JOBCARD3+22(7),USERID\n         SPACE 1\nREPEAT   DS    0H\n         SPACE 1\n         NI    SWITCH,255-CONTINUE-INSTREAM-SLASHEND  TURN OFF FLAGS\n         OI    SWITCH,STARTJOB     INDICATE BEGINNING OF A JOB\n         OPEN  (SUBMIT)            OPEN INPUT JCL DATASET\n         TM    SUBMIT+48,X'10'     IF OPEN FAILED\n         BO    OPENOK              THEN\n         TPUT  OPENMSG,L'OPENMSG    TELL ABOUT IT\n         B     RETURN               AND RETURN IN FAILURE\nOPENOK   DS    0H                  OTHERWISE INPUT SUBMIT DATASET OPEN\n         MVC   JOBNAME(8),BLANKS   CLEAR JOB NAME\n         XC    IESUBCTD(4),IESUBCTD CLEAR SWITCHES\n         OI    IETAKEEX,IETJOB     BUT ALWAYS START TAKING JOBCARDS\n         XC    IECARDP,IECARDP     CLEAR CARD POINTER\n         XC    IEMSGP,IEMSGP       CLEAR MESSAGE POINTER\n         XC    IEREPLYP,IEREPLYP   CLEAR REPLY POINTER\n         LA    R15,USERID          GET ADDRESS OF USERID\n         ST    R15,IEUSRIDP        STORE IT\n         LA    R15,IESUBCTD        ADDRESS OF CONTROL SWITCHES\n         ST    R15,IESUBCTP        STORE POINTER\n         XC    IEEXITWD,IEEXITWD   CLEAR EXIT WORD\n         LA    R15,ACCTSTUF\n         ST    R15,IEACCTIP        SET ADDRESS OF ACCOUNTING DATA\n         LA    R15,ACCTSTFL\n         ST    R15,IEACCTLP        SET ADDRESS OF ACCOUNTING DATA\n         XC    SAVECONT,SAVECONT\n*\n* WE'LL HAVE TO STICK IN THE ACCOUNT INFO BY CHASING CONTROL BLOCKS.\n* WILL DO LATER\n*\n         SPACE 1\n         TPUT  STAAHT,L'STAAHT\n         SPACE 1\n         TPUT  COLS,L'COLS\n         SPACE 1\nREAD     DS    0H\n         SPACE 1\n         GET   SUBMIT              READ A JCL CARD\n         LR    R3,R1               R3 POINTS TO JCL RECORD\n         XR    R6,R6               CLEAR OPERATION CODE LENGTH\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DETERMINE WHAT KIND OF CARD THIS IS                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    SWITCH,INSTREAM     IF WE ARE IN INSTREAM JCL\n         BO    CKDLM               THEN EXIT DOESN'T GET IT\n         SPACE 1\nREALJCL  DS    0H\n         SPACE 1\n         CLI   0(R3),C'/'          IF NOT A REAL JCL CARD\n         BNE   NOEXIT              THEN EXIT DOESN'T GET IT\n         CLI   1(R3),C'*'          ELSE IF /* CARD\n         BE    JES2CARD            THEN GO SCAN COMMENT OR JES2 CARD\n         CLI   1(R3),C'/'          ELSE IF // CARD\n         BNE   NOEXIT              THEN\n         CLI   2(R3),C'*'           IF //* CARD\n         BE    JES3CARD             THEN SCAN COMMENT OR JES3 CARD\n         NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON\n*                                  ELSE INITIALIZE CONTINUATIONAL BITS\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ELSE SCAN FOR WHAT KIND OF CARD THIS IS                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    SWITCH,CONTINUE     IF CONTINUATION WAS EXPECTED\n         BZ    NOTCCCCC            THEN\n         OC    IESTMTYP,SAVECONT    restore bits of what was\n         OI    IESTMTYP,IESCONTN    INDICATE CONTINUATION\n         XC    IESTMTP2,IESTMTP2    INDICATE NOT COMMENT OR JES\n         LA    R4,2(,R3)            START SCAN FOR OPERAND FIELD\n         B     OPNLOOP              AND PROCESS OPERAND FIELD ONLY\nNOTCCCCC DS    0H                  ELSE (NOT A CONTINUATION)...\n         XC    IESTMTYP(2),IESTMTYP CLEAR STATEMENT TYPE\n         LA    R4,2(,R3)           START SCAN FOR LABEL\n         LA    R0,71-3             SET UP BCT REGISTER\nLBLLOOP  DS    0H\n         CLI   0(R4),C' '          SCAN FOR FIRST NONBLANK\n         BE    ENDLBL\n         LA    R4,1(,R4)\n         BCT   R0,LBLLOOP\nENDLBL   DS    0H                  END OF STATEMENT LABEL FOUND\n         LTR   R0,R0               IF END OF CARD ALSO\n         BNP   NOEXIT              THEN CARD IS INVALID\nOPLOOP   DS    0H                  ELSE SCAN FOR OPERATION FIELD\n         CLI   0(R4),C' '\n         BNE   BEGINOP\n         LA    R4,1(,R4)\n         BCT   R0,OPLOOP\nBEGINOP  DS    0H                  BEGINNING OF OPERATION CODE FOUND\n         LTR   R0,R0               IF NO OPERATION CODE FOUND\n         BNP   NULLCARD            THEN NULL JCL CARD \"//  \"\n         LR    R5,R4               ELSE SAVE ADDRES OF OPERATION CODE\nOP2LOOP  DS    0H                  SCAN FOR END OF OPERATION FIELD\n         CLI   0(R4),C' '\n         BE    ENDOP\n         LA    R4,1(,R4)\n         BCT   R0,OP2LOOP\nENDOP    DS    0H                  END OF OPERATION CODE\n         LTR   R0,R0               IF NO OPERATION CODE FOUND\n         BNP   NOEXIT              THEN INVALID CARD\n         LR    R6,R4               ELSE\n         SR    R6,R5               R6 = LENGTH OF OPERATION\nOPNLOOP  DS    0H                  SCAN FOR OPERANDS\n         CLI   0(R4),C' '\n         BNE   BEGINOPN\n         LA    R4,1(,R4)\n         BCT   R0,OPNLOOP\nBEGINOPN DS    0H                  BEGINNING OF OPERANDS\n         MVI   IEOPRAND,0          INIT OPERAND COLUMN = 0\n         LTR   R0,R0               IF NO OPERATION FOUND\n         BNP   NOPERAND            THEN NO OPERANDS\n         LA    R14,1(,R4)          ELSE\n         SLR   R14,R3               COMPUTE COLUMN OF OPERAND DATA\n         STC   R14,IEOPRAND         SET UP OPERAND COLUMN\nNOPERAND DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* NOW SEE WHAT KIND OF CARD IT IS                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R6,R6               IF NO OPERATION CODE\n         BZ    GOCALL              THEN DON'T CHECK CARD TYPE\n         CH    R6,=H'2'            IF LENGTH IS 2\n         BE    TRYDD               THEN IT MIGHT BE DD STATEMENT\n         CH    R6,=H'3'            IF LENGTH IS 3\n         BE    TRYJOB              THEN IT MIGHT BE JOB STATEMENT\n         CH    R6,=H'4'            IF LENGTH IS 4\n         BE    TRYEXEC             THEN IT MIGHT BE EXEC STATEMENT\n         B     CMDCARD             ELSE CAN'T BE ANYTHING ELSE, COMMAND\nTRYDD    DS    0H                  LENGTH IS 2\n         CLC   0(2,R5),=C'DD'      IF IT'S DD\n         BE    DDCARD              THEN PROCESS DD STATEMENT\n         B     CMDCARD             ELSE MUST BE COMMAND\nTRYJOB   DS    0H                  LENGTH IS 2\n         CLC   0(3,R5),=C'JOB'     IF IT'S JOB\n         BE    JOBCARD             THEN PROCESS JOB STATEMENT\n         B     CMDCARD             ELSE MUST BE COMMAND\nTRYEXEC  DS    0H                  LENGTH IS 2\n         CLC   0(4,R5),=C'EXEC'    IF IT'S EXEC\n         BE    EXECCARD            THEN PROCESS EXEC STATEMENT\n******** B     CMDCARD             ELSE MUST BE COMMAND\nCMDCARD  DS    0H                  ELSE MUST BE COMMAND\n         MVI   IESTMTYP,IESCMD     INDICATE COMMAND RECORD\n         MVI   RECTYPE,IESCMD      INDICATE COMMAND RECORD\n         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES\n         B     TESTJOB\nJOBCARD  DS    0H\n         MVI   IESTMTYP,IESJOB     INDICATE JOB CARD\n         MVI   RECTYPE,IESJOB      INDICATE JOB CARD\n         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES\n         NI    SWITCH,255-STARTJOB INDICATE JOB ALREADY STARTED\n         B     GOCALL\nEXECCARD DS    0H\n         MVI   IESTMTYP,IESEXEC    INDICATE EXEC CARD\n         MVI   RECTYPE,IESEXEC     INDICATE EXEC CARD\n         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES\n         B     TESTJOB\nDDCARD   DS    0H\n         MVI   IESTMTYP,IESDD      INDICATE DD CARD\n         MVI   RECTYPE,IESDD       INDICATE DD CARD\n         B     TESTJOB\nTESTDLM  DS    0H                  TEST FOR INSTREAM REQUEST\n         CLI   0(R4),C'*'          IF // DD *\n         BNE   TRYDATA             THEN\n         OI    SWITCH,SLASHEND      INDICATE // CAN END INSTREAM\n         LA    R4,1(,R4)            POINT TO WHERE NEXT KWD MAY BE\n         B     DDIN                 AND INDICATE INSTREAM DATA\nTRYDATA  DS    0H\n         CLC   0(4,R4),=C'DATA'    ELSE IF // DD DATA\n         BNE   TESTJOB             THEN\n         NI    SWITCH,255-SLASHEND  // CANNOT TERMINATE INSTREAM\n         LA    R4,4(,R4)            POINT TO WHERE NEXT KWD MAY BE\nDDIN     DS    0H                  INSTREAM DATA FOLLOWING DD * OR DATA\n         OI    SWITCH,INSTREAM     SHOW INSTREAM DATA\n         CLC   0(5,R4),=C',DLM='   IF A DELIMITER WAS SPECIFIED\n         BNE   DEFDLM              THEN\n         CLI   5(R4),C''''          IF QUOTED DELIMITER VALUE\n         BE    QUOTEDLM             THEN\n         MVC   DLM,5(R4)             SET NEW DELIMITER\n         B     TESTJOB              ELSE\nQUOTEDLM MVC   DLM,6(R4)             MOVE UNQUOTED DELIMITER VALUE\n         B     TESTJOB             ELSE\nDEFDLM   MVC   DLM,=C'/*'           USE DEFAULT DELIMITER\n         B     TESTJOB             AND CONTINUE\n         SPACE 1\nNULLCARD DS    0H\n         SPACE 1\n         MVI   IESTMTYP,IESNULL    INDICATE NULL CARD\n         MVI   RECTYPE,IESNULL     INDICATE NULL CARD\n         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES\n         MVI   IEOPRAND,0          INDICATE NO OPERAND FIELD\n         B     TESTJOB\n         SPACE 1\nJES2CARD DS    0H                  /* ... CARD\n         SPACE 1\n         CLI   2(R3),C' '          IF /* FOLLOWED BY BLANK\n         BE    COMMENTC            THEN IT IS A COMMENT CARD\n         MVI   IESTMTP2,IESJES     ELSE INDICATE JES2 CARD\n         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS\n******** NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON\n********************************** CLEAR CONTINUATIONAL BITS\n         LA    R1,3(,R3)           START OF SCAN\n         B     JESSCAN             GO TO SCAN IT\n         SPACE 1\nJES3CARD DS    0H                  //* ... CARD\n         SPACE 1\n         CLI   3(R3),C' '          IF //* FOLLOWED BY BLANK\n         BE    COMMENTC            THEN IT IS A COMMENT CARD\n         MVI   IESTMTP2,IESJES3    ELSE INDICATE JES3 CARD\n         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS\n******** NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON\n********************************** CLEAR CONTINUATIONAL BITS\n         LA    R1,4(,R3)           START OF SCAN\n         B     JESSCAN             GO TO SCAN IT\n         SPACE 1\nCOMMENTC DS    0H                  /* COMMENTS...\n         SPACE 1\n         OI    IESTMTP2,IESCOMNT   INDICATE COMMENT CARD\n         CLI   NEWVER,1            If emulating fix for OY37954\n         BNE   NOT37954            then\n         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS\n         NI    IESTMTP2,IESCOMNT   (all except comment bit)\nNOT37954 DS    0H                  else don't wipe out the other bits\n         MVI   IEOPRAND,0          INDICATE NO OPERAND FIELD\n         B     NOCONS\n         SPACE 1\nJESSCAN  DS    0H                  FIND JES OPERAND FIELD\n         SPACE 1\n         LA    R0,71-3             END OF SCAN FOR BCT\nJESLOOP  DS    0H                  FIND BLANK FOLLOWING JES PARM\n         CLI   0(R1),C' '\n         BE    JESEND1\n         LA    R1,1(,R1)\n         BCT   R0,JESLOOP\n         MVI   IEOPRAND,0\n         B     TESTJOB\nJESEND1  DS    0H\n         LA    R1,1(,R1)\nJESLOOP2 DS    0H                  FIND NONBLANK FOR OPERAND STUFF\n         CLI   0(R1),C' '\n         BNE   JESEND2\n         LA    R1,1(,R1)\n         BCT   R0,JESLOOP2\n         MVI   IEOPRAND,0\n         B     TESTJOB\nJESEND2  DS    0H\n         LA    R14,1(,R1)          GET OFFSET = ADDR(END)-ADDR(START)\n         SR    R14,R3\n         STC   R14,IEOPRAND        SET UP OPERAND COLUMN\n         SPACE 1\nTESTJOB  DS    0H\n         SPACE 1\n         TM    SWITCH,STARTJOB     IF START OF JOB BUT NO JOB CARD\n         BZ    GOCALL              THEN\n         NI    SWITCH,255-STARTJOB  RESET START-OF-JOB FLAG\n         MVC   SAVETYPE,RECTYPE     SAVE CARD TYPE\n         MVC   SAVEBITS(3),IESUBCTD+1 SAVE INPUT CARD BIT SETTINGS\n         MVI   RECTYPE,IESJOB       SET CARD TYPE = JOB CARD\n         MVC   IESUBCTD+1(3),BITS1\n         MVC   TEMPCARD,JOBCARD1\n         LA    R1,TEMPCARD\n         BAL   R14,CALLEXIT\n         MVC   IESUBCTD+1(3),BITS2\n         MVC   TEMPCARD,JOBCARD2\n         LA    R1,TEMPCARD\n         BAL   R14,CALLEXIT\n         MVC   IESUBCTD+1(3),BITS3\n         MVC   TEMPCARD,JOBCARD3\n         LA    R1,TEMPCARD\n         BAL   R14,CALLEXIT\n         MVC   IESUBCTD+1(3),BITS4\n         MVC   TEMPCARD,JOBCARD4\n         LA    R1,TEMPCARD\n         BAL   R14,CALLEXIT\n         MVC   RECTYPE,SAVETYPE    RESTORE CARD TYPE\n         MVC   IESUBCTD+1(3),SAVEBITS RESTORE BITS\n         SPACE 1\nGOCALL   DS    0H\n         SPACE 1\n         TM    SWITCH,CONTINUE     If card not following continuer,\n         BO    NOSAVECO            then...\n         MVC   SAVECONT,IESTMTYP    Save what-kind-it's-been bits...\n         NI    SAVECONT,IESJOB+IESEXEC+IESDD+IESCMD+IESNULL only these\nNOSAVECO DS    0H\n         NI    IESTMTYP,255-IESSCON INIT CARD NOT TO BE CONTINUED\n         CLI   71(R3),C' '         IF CONTINUATION COLUMN NONBLANK\n         BE    COL72BLK            THEN\n         OI    IESTMTYP,IESSCON     INDICATE STMT TO BE CONTINUED\n         OI    SWITCH,CONTINUE\nCOL72BLK DS    0H\n         NI    IESTMTYP,255-IESOPCON INIT OPERAND NOT TO BE CONTINUED\n         CLI   IEOPRAND,0          IF THERE ARE OPERANDS\n         BE    AFTCON              THEN\n         LA    R1,71(,R3)           SCAN FOR LAST NONBLANK IN THEM\nCONTLOOP DS    0H\n         CLI   0(R1),C' '\n         BNE   SEEIFCNT\n         BCTR  R1,0\n         B     CONTLOOP\nSEEIFCNT DS    0H\n         CLI   0(R1),C','          IF LAST NONBLANK IS A COMMA\n         BNE   AFTCON              THEN\n         OI    IESTMTYP,IESOPCON    SCAN FOR LAST NONBLANK IN THEM\nAFTCON   DS    0H\n         NI    SWITCH,255-CONTINUE THIS CARD WILL NOT BE CONTINUED\n         TM    IESTMTYP,IESOPCON+IESSCON UNLESS ONE OF THESE BITS IS ON\n         BZ    NOCONS\n         OI    SWITCH,CONTINUE\nNOCONS   DS    0H\n         LR    R1,R3               POINT TO CURRENT CARD\n         BAL   R14,CALLEXIT        INVOKE EXIT FOR THE CARD\n         B     READ                GO TO GET NEXT CARD\n         EJECT\nCKDLM    DS    0H                  INSTREAM DATA:\n         SPACE 1\n         TM    SWITCH,SLASHEND     IF // CAN TERMINATE INSTREAM\n         BZ    NOT6161              AND\n         CLC   0(2,R3),=C'//'        // WAS FOUND\n         BNE   NOT6161                THEN TERMINATE INSTREAM\n         NI    SWITCH,255-INSTREAM-SLASHEND\n         B     REALJCL                 AND PROCESS THIS CARD AS READ.\nNOT6161  DS    0H\n         CLC   0(2,R3),DLM         ELSE IF DELIMITER FOUND\n         BNE   NOEXIT              THEN\nOUTOFIT  NI    SWITCH,255-INSTREAM-SLASHEND NO LONGER IN INSTREAM\nNOEXIT   DS    0H\n         LA    R1,0(,R3)           WRITE OUT THE JCL TO TERMINAL\n         LA    R0,79\n         TPUT  (1),(0),R\n         B     READ                GO GET ANOTHER CARD\n         EJECT\nEOF      DS    0H                  END OF FILE ON DD SUBMIT\n         SPACE 1\n         CLOSE (SUBMIT)\n         SPACE 1\n         CLC   JOBNAME,BLANKS      IF JOB NAME NOT BLANK\n         BE    NOEOFJOB            THEN\n         TPUT  JOBMSG,JOBMSGL       SAY 'JOB XXXXXXXX SUBMITTED'\nNOEOFJOB DS    0H\n         TPUT  ASKRPT,L'ASKRPT\n         TGET  ANSWER,1\n         TCLEARQ INPUT\n         OI    ANSWER,X'40'\n         CLI   ANSWER,C'R'\n         BNE   RETURN\n         B     REPEAT\n         EJECT\nCALLEXIT DS    0H\n         SPACE 1\n         ST    R14,SAVE14\n         ST    R1,IECARDP          STORE ADDRESS OF CARD TO BE USED\n         NI    SWITCH,255-JOBSUBD\n         TM    RECTYPE,IESJOB      IF THIS IS A JOB CARD\n         BZ    CXNOTJOB            THEN\n         TM    IETAKEEX,IETJOB      IF EXIT ACCEPTS JOB CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTJOB DS    0H\n         TM    RECTYPE,IESCMD      IF THIS IS A COMMAND CARD\n         BZ    CXNOTCMD            THEN\n         TM    IETAKEEX,IETCMD      IF EXIT ACCEPTS COMMAND CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTCMD DS    0H\n         TM    RECTYPE,IESEXEC     IF THIS IS A EXEC CARD\n         BZ    CXNOTEX             THEN\n         TM    IETAKEEX,IETEXEC     IF EXIT ACCEPTS EXEC CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTEX  DS    0H\n         TM    RECTYPE,IESDD       IF THIS IS A DD CARD\n         BZ    CXNOTDD             THEN\n         TM    IETAKEEX,IETDD       IF EXIT ACCEPTS DD CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTDD  DS    0H\n         TM    RECTYPE,IESNULL     IF THIS IS A NULL CARD\n         BZ    CXNOTNL             THEN\n         TM    IETAKEEX,IETNULL     IF EXIT ACCEPTS NULL CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTNL  DS    0H\n         TM    IESTMTP2,IESJES     IF THIS IS A JES2 CARD\n         BZ    CXNOTJ2             THEN\n         TM    IETAKEEX,IETJES      IF EXIT ACCEPTS JES2 CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTJ2  DS    0H\n         TM    IESTMTP2,IESJES3    IF THIS IS A JES3 CARD\n         BZ    CXNOTJ3             THEN\n         TM    IETAKEEX,IETJES3     IF EXIT ACCEPTS JES3 CARDS\n         BO    RPEATXIT             THEN GO TO CALL THE EXIT\n         B     BYPASSEX             ELSE BYPASS EXIT\nCXNOTJ3  DS    0H\n         TM    IESTMTP2,IESCOMNT   IF THIS IS A COMMENT CARD\n         BZ    BYPASSEX            THEN BYPASS EXIT\n         TM    IETAKEEX,IETCOMNT   IF EXIT DOESN'T TAKE COMMENTS\n         BZ    BYPASSEX            THEN BYPASS EXIT. ELSE...\nRPEATXIT DS    0H\n         UNPK  DISPHEX(9),IETAKEEX(5)\n         TR    DISPHEX(8),HEXTBL\n         TPUT  DISPMSG,L'DISPMSG\n         L     R15,EFF10ADR        GET ADDRESS OF IKJEFF10\n         LA    R1,PARMADDR         POINT TO PARAMETER LIST\n         BALR  R14,R15             CALL THE EXIT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* PROCESS RESULTS OF EXIT                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R15,R15\n         BZ    EXIT0\n         BM    RCERR\n         CH    R15,=H'4'\n         BE    EXIT4\n         CH    R15,=H'8'\n         BE    EXIT8\n         CH    R15,=H'12'\n         BE    EXIT12\n         CH    R15,=H'16'\n         BE    EXIT16\nRCERR    DS    0H\n         TPUT  BADRC,L'BADRC\n         B     EOF\n         SPACE 1\nEXIT4    DS    0H                  IKJEFF10 RETURN CODE 4\n         SPACE 1\n         ICM   R10,15,IECARDP\n         BZ    NOCARD\n         TM    SWITCH,JOBSUBD      IF JOB SUBMITTED MESSAGE DISPLAYED\n         BO    DISPLAY4            THEN BYPASS. ELSE...\n         TM    RECTYPE,IESJOB      IF THIS IS A JOB CARD\n         BZ    DISPLAY4             AND\n         TM    IESTMTYP,IESCONTN     NOT A CONTINUATION\n         BO    DISPLAY4               THEN\n         CLC   JOBNAME,BLANKS          IF JOB NAME NOT BLANK\n         BE    NOSAYJB4                 THEN\n         TPUT  BLANKS,1                  DISPLAY A BLANK LINE\n         TPUT  JOBMSG,JOBMSGL            SAY 'JOB XXXXXXXX SUBMITTED'\n         TPUT  BLANKS,1                  DISPLAY ANOTHER BLANK LINE\nNOSAYJB4 DS    0H\n         MVC   JOBNAME,2(R10)      MOVE JOB NAME TO JOB NAME\n         OI    SWITCH,JOBSUBD      INDICATE JOB SUBMITTED MSG\nDISPLAY4 DS    0H\n         LA    R1,0(,R10)          DISPLAY PROCESSED JCL CARD\n         LA    R0,79\n         TPUT  (1),(0),R\n         SPACE 1\nNOCARD   DS    0H\n         SPACE 1\n         XC    IECARDP,IECARDP\n         B     RPEATXIT            CALL EXIT AGAIN TO INSERT CARD\n         SPACE 1\nEXIT8    DS    0H\n         SPACE 1\n         MVC   MSGID,=C'IKJ56283I '\n         MVI   MESSAGE,C' '\n         MVC   MESSAGE+1(255),MESSAGE\n         ICM   R14,15,IEMSGP       LOAD MESSAGE POINTER\n         BNZ   MSGPOK              CHECK IF NONZERO\n         TPUT  EXIT8NG,L'EXIT8NG\n         B     EXITRET\nMSGPOK   DS    0H\n         LH    R15,0(,R14)         GET \"LL\" MESSAGE LENGTH\n         BCTR  R15,0               SUBTRACT 2\n         BCTR  R15,0\n         LTR   R15,R15             LENGTH BETTER BE POSITIVE\n         BP    MSGPOK2             OR ELSE\n         CH    R15,=H'246'         LENGTH BETTER BE 246 OR LESS\n         BNH   MSGPOK2             OR ELSE\n         TPUT  EXIT8NG2,L'EXIT8NG2\n         B     EXITRET\nMSGPOK2  DS    0H\n         LR    R2,R15              SAVE MESSAGE LENGTH\n         BCTR  R15,0\n         EX    R15,MOVE8\n         LA    R1,MSGID\n         LA    R0,L'MSGID\n         AR    R0,R2\n         TPUT  (1),(0),R\n         B     EXITRET\n         SPACE 1\nEXIT12   EQU   EXIT8\n         SPACE 1\nEXIT16   DS    0H\n         SPACE 1\n         TPUT  TERM,L'TERM\n         B     EOF\n         SPACE 1\nBYPASSEX DS    0H\n         SPACE 1\nEXIT0    EQU   BYPASSEX\n         SPACE 1\n         ICM   R10,15,IECARDP      IF A JCL CARD IS TO BE PROCESSED\n         BZ    EXITRET             THEN\n         TM    SWITCH,JOBSUBD       IF JOB SUBMITTED MSG DISPLAYED\n         BO    DISPLAY0             THEN BYPASS. ELSE...\n         TM    RECTYPE,IESJOB       IF THIS IS A JOB CARD\n         BZ    DISPLAY0             THEN\n         TM    IESTMTYP,IESCONTN     IF NOT A CONTINUATION\n         BO    DISPLAY0              THEN\n         CLC   JOBNAME,BLANKS         IF JOB NAME NOT BLANK\n         BE    NOSAYJOB               THEN\n         TPUT  BLANKS,1                DISPLAY A BLANK LINE\n         TPUT  JOBMSG,JOBMSGL          SAY 'JOB XXXXXXXX SUBMITTED'\n         TPUT  BLANKS,1                DISPLAY ANOTHER BLANK LINE\n         SPACE 1\nNOSAYJOB DS    0H\n         SPACE 1\n         MVC   JOBNAME,2(R10)      MOVE JOB NAME TO JOB NAME\n         OI    SWITCH,JOBSUBD      INDICATE JOB SUBMITTED MESSAGE\n         SPACE 1\nDISPLAY0 DS    0H\n         SPACE 1\n         LA    R1,0(,R10)          DISPLAY THE JCL CARD\n         LA    R0,79\n         TPUT  (1),(0),R\n******** B     EXITRET             AND RETURN.\n         SPACE 1\nEXITRET  DS    0H\n         SPACE 1\n         L     R14,SAVE14          RETURN TO CALLER\n         BR    R14\n         EJECT\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 1\nMOVEUID  MVC   USERID(0),PSCBUSER\nMOVE8    MVC   MESSAGE(0),2(R14)\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\n         WXTRN IKJEFF10\n*FF10ADR DC    V(IKJEFF10)         ADDRESS OF SUBMIT EXIT\nEFF10ADR DC    A(0)                ADDRESS OF SUBMIT EXIT\n         SPACE 1\nSAVE14   DS    A                   RETURN ADDRESS FOR SUBROUTINE\nSWITCH   DC    X'00'\nINSTREAM EQU   B'10000000'          1 = IN SYSIN DD * OR DATA STREAM\nCONTINUE EQU   B'01000000'          1 = CONTINUATION EXPECTED\nSTARTJOB EQU   B'00100000'          1 = BEGINNING OF A JOB\nSLASHEND EQU   B'00010000'          1 = // CAN END INSTREAM (DD *)\nJOBSUBD  EQU   B'00001000'          1 = JOB SUBMITTED MSG DISPLAYED\n*        EQU   B'00000100'          1 = RESERVED\n*        EQU   B'00000010'          1 = RESERVED\n*        EQU   B'00000001'          1 = RESERVED\nUSERID   DS    CL8                 USERID\nBLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS\nDLM      DC    C'/*'               INSTREAM JCL DELIMITER\nANSWER   DC    C' '                REPLY TO REPEAT REQUEST\nPARMADDR DC    A(IEEXITL)          ADDRESS OF PARAMETER LIST\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FOLLOWING STOLEN FROM 'SYS1.MACLIB(IKJEFFIE)' BECAUSE THOSE     *\n* TURDBRAINS INSIST ON MAKING IT A DSECT!                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nIEDSECTD DS    0F         .REGISTER 1 -> POINTER -> IEEXITL\n         DS    0F\nIEEXITL  EQU   *          .EXITLIST = PARAMETER LIST TO SUBMIT'S\n*                         .   INSTALLATION EXIT, IKJEFF10\nIECARDP  DS    A          .CARDPTR = POINTER TO CURRENT JCL STATEMENT.\n*                         .   IF ZERO, EXIT IS BEING REENTERED TO GET\n*                         .   A NEW STATEMENT.  THE EXIT MAY ZERO THIS\n*                         .   FIELD TO DELETE THE CURRENT STATEMENT\n*                         .   OR IT MAY CHANGE THIS STATEMENT.\nIEMSGP   DS    A          .MESSAGEP = ZERO ON ENTRY TO EXIT.  NOTE --\n*                         .   EXIT MUST PLACE POINTER TO MESSAGE HERE\n*                         .   IF RETURNING CODE = 8 OR 12 TO COMMAND\n*                         .  (MESSAGE FORMAT IS LL-TEXT; WHERE LL IS A\n*                         .   TWO-BYTE LENGTH FIELD WITH LENGTH OF THE\n*                         .   MESSAGE, INCLUDING LENGTH OF LL FIELD).\n*                         .   MAXIMUM MESSAGE TEXT LENGTH IS 246 BYTES.\nIEREPLYP DS    A          .REPLYP = ZERO ON FIRST ENTRY TO THE EXIT\n*                         .   AND = POINTER TO REPLY OBTAINED BY THE\n*                         .   COMMAND IF EXIT HAD SPECIFIED RETURN CODE\n*                         .   12 (NOTE -- REPLY HAS SAME SETUP AS MSG).\n*                         .   SUBMIT WILL FREE THE REPLY BUFFER.\nIEUSRIDP DS    A          .USERIDPT = POINTER TO 8-BYTE USERID FIELD\n*                         .   (PADDED ON THE RIGHT WITH BLANKS)\nIESUBCTP DS    A          .SWITSPT = POINTER TO JCL SWITCH BYTES AND\n*                         .   COLUMN OF OPERAND FIELD ON JCL CARD\nIEEXITWD DS    F          .EXITWORK = WORD FOR EXIT'S USE.  IT IS\n*                         .   INITIALIZED TO ZEROES AND RETAINS\n*                         .   WHATEVER VALUE THE EXIT GIVES IT THRU\n*                         .   THE DURATION OF THE SUBMIT COMMAND.\nIEACCTIP DS    A          .ACCTIPT = POINTER TO USER'S ACCOUNTING\n*                         .   INFORMATION (RECONSTRUCTED FROM ACCOUNT\n*                         .   CONTROL TABLE, ACT, BUILT AT LOGON).\n*                         .   THIS ACCOUNT INFORMATION IS PLACED ON\n*                         .   JOB CARDS GENERATED BY SUBMIT.\nIEACCTLP DS    A          .ACCTLPT = POINTER TO TWO-BYTE LENGTH FIELD\n*                         .   FOR THE ACCOUNTING INFORMATION.\n*                         .  (HAVE  0 < LENGTH < 191 -- MAXIMUM OF 142\n*                         .   CHARACTERS PLUS DELIMITERS.)\n         SPACE 3\n***********************************************************************\n* RETURN CODES FROM IKJEFF10 INSTALLATION EXIT TO THE COMMAND         *\n***********************************************************************\nIECONTIN EQU   0          .CONTINUE - COMPLETE PROCESSING CURRENT\n*                         .   STATEMENT AND READ THE NEXT\nIERETURN EQU   4          .PROCESS CURRENT STATEMENT AND RETURN TO EXIT\n*                         .   FOR ANOTHER STATEMENT\nIEMSG    EQU   8          .ISSUE MESSAGE IKJ56283I FOR EXIT AND REENTER\n*                         .   EXIT.  EXIT MUST OBTAIN MESSAGE TEXT AREA\n*                         .   AND MAY FREE IT WHEN REENTERED.\nIEPROMPT EQU   12         .ISSUE PROMPT MESSAGE IKJ56280A FOR EXIT AND\n*                         .   RETURN THE REPLY TO EXIT.  IKJEFF02\n*                         .   MESSAGE ISSUER ROUTINE OBTAINS THE\n*                         .   REPLY AREA AND IKJEFF09 WILL FREE IT.\n*                         .IF USER IN NOPROMPT MODE, SUBMIT ISSUES\n*                         .   ERROR MESSAGE IKJ56282I AND ABORTS.\nIEABORT  EQU   16         .TERMINATE THE SUBMIT COMMAND.  RETURN CODE 8\n*                         .   SHOULD BE USED FIRST TO ISSUE AN ERROR\n*                         .   MESSAGE TO THE TSO USER.\n         SPACE 3\n***********************************************************************\n* DSECT WITH SUBMIT JCL CONTROL INFORMATION PASSED TO EXIT            *\n***********************************************************************\nIESUBCTD DS    0B         .TO USE THIS DSECT, CODE --\n*                         .   L YOURREG,IESUBCTP\n*                         .   USING IESUBCTD,YOURREG\n         DS    0B         .DATA IS ON BYTE BOUNDARY\nIETAKEEX DS    B          .SWITCHES WHICH CONTROL WHEN EXIT IS ENTERED\n*                         .   <<THESE SWITCHES MAY BE CHANGED BY THE\n*                         .   EXIT - IBM EXIT TURNS ALL SWITCHES OFF>>\nIETJOB   EQU   X'80'      .ON IF TAKE EXIT FOR JOB CARDS (DEFAULT = ON)\nIETEXEC  EQU   X'40'      .ON IF TAKE EXIT FOR EXEC CARDS (DEFAULT=OFF)\nIETDD    EQU   X'20'      .                    DD                  OFF\nIETCMD   EQU   X'10'      .                    COMMAND             OFF\nIETNULL  EQU   X'08'      .                    NULL                OFF\nIETJES   EQU   X'04'      .                    /*NONBLANK (JES2)   OFF\nIETCOMNT EQU   X'02'      .                    //* (COMMENT)       OFF\nIETJES3  EQU   X'01'      .                    //*NONBLANK (JES3) OFF\nIEOPRAND DS    XL1        .COLUMN OF OPERAND FIELD ON CURRENT CARD, IF\n*                         .   ONE EXISTS (ONE-ORIGINED COLUMN NUMBER)\nIESTMTYP DS    B          .SWITCHES WHICH INDICATE TYPE OF CURRENT\n*                         .   JCL STATEMENT.  JCL STATEMENTS IN DATA\n*                         .   STREAM FOLLOWING A DD DATA STATEMENT\n*                         .   (OR /*NONBLANK, FOLLOWING A DD *) ARE\n*                         .   NOT PASSED TO THE EXIT.\nIESJOB   EQU   X'80'      .ON IF STATEMENT IS JOB STATEMENT\nIESEXEC  EQU   X'40'      .                   EXEC (PGM OR PROC)\nIESDD    EQU   X'20'      .                   DD\nIESCMD   EQU   X'10'      .                   COMMAND\nIESNULL  EQU   X'08'      .                   NULL\nIESOPCON EQU   X'04'      .      OPERAND TO BE CONTINUED\nIESSCON  EQU   X'02'      .      STATEMENT TO BE CONTINUED\nIESCONTN EQU   X'01'      .      STATEMENT IS A CONTINUATION\nIESTMTP2 DS    B          .SWITCHES, CONTINUED\nIESJES   EQU   X'80'      .ON IF STATEMENT IS /*NONBLANK STATEMENT\n*                         .   (JOB ENTRY SUBSYSTEM CONTROL CARDS)\nIESCOMNT EQU   X'40'      .ON IF STATEMENT IS COMMENT STATEMENT, //*\n*                         .   (OR MAY BE JES3 CONTROL CARD)\nIESJES3  EQU   X'20'      .ON IF STATEMENT IS //*NONBLANK STATEMENT\n*                         .   (JES3 CONTROL CARD)\n         SPACE 2\nSAVEBITS DS    XL3                 SAVED BIT SETTING FOR FIRST CARD\nRECTYPE  DS    X          WE MAINTAIN CARD TYPE BETTER THAN SUBMIT DOES\nSAVETYPE DS    X                   SAVED CARD TYPE FOR FIRST CARD\nSAVECONT DS    X\nNEWVER   DS    X\nMSGHDR   DS    2Y\nMSGID    DS    CL10\nMESSAGE  DS    CL256\n         EJECT\nSUBMIT   DCB   DDNAME=SUBMIT,DSORG=PS,MACRF=GL,LRECL=80,EODAD=EOF\n         EJECT\nCOLUMNS  DC    C'----+----1----+----2----+----3----+----4----+----5'\n         DC    C'----+----6----+----7----+---'\nCOLS     EQU   COLUMNS,*-COLUMNS,C'C'\nSTAAHT   DC    C'****DRIVERSU - SUBMIT EXIT TEST DRIVER - STARTING'\nASKRPT   DC    C'****ENTER R TO REPEAT OR PRESS ENTER TO TERMINATE'\nOPENMSG  DC    C'****UNABLE TO OPEN DDNAME SUBMIT, REQUIRED FOR DRIVER'\nBADRC    DC    C'****INVALID RETURN CODE FROM EXIT, DRIVER TERMINATING'\nTERM     DC    C'****EXIT REQUESTED TERMINATION, DRIVER TERMINATING'\nEXIT8NG  DC    C'****EXIT RETURNED CODE 8 BUT SET NO MESSAGE POINTER'\nEXIT8NG2 DC    C'****EXIT RETURNED CODE 8 BUT MESSAGE LENGTH INVALID'\n*\nASKVER   DC    C'**** Do you want to emulate the fix for OY37954, whereX\n               in comment cards between JOB cards clear the JOB bit?'\n*\nJOBMSG   DC    C'****JOB '\nJOBNAME  DC    CL8' '\n         DC    C' SUBMITTED'\nJOBMSGL  EQU   *-JOBMSG\n         SPACE 1\nACCTSTUF DC    C'(9050-00,3333)'\nACCTSTFL DC    Y(L'ACCTSTUF)\n         SPACE 1\nJOBCARD1 DC    CL80'//USER-IDX  JOB ,'\nJOBCARD2 DC    CL80'//             USER-ID,'\nJOBTHREE DC    C'//             NOTIFY=USER-ID,CLASS='\nDEFCLASS DC    C' '\n         DC    CL(80-(*-JOBTHREE))','\nJOBCARD3 EQU   JOBTHREE,80,C'C'\nJOBCARD4 DC    CL80'//             MSGLEVEL=(1,1)'\nTEMPCARD DS    CL80\nBITS1    DC    YL1(17,IESJOB+IESOPCON,0)\nBITS2    DC    YL1(16,IESJOB+IESOPCON+IESCONTN,0)\nBITS3    DC    YL1(16,IESJOB+IESOPCON+IESCONTN,0)\nBITS4    DC    YL1(16,IESJOB+IESCONTN,0)\n         SPACE 1\nDISPMSG1 DC    C'Bits: '\nDISPHEX  DC    CL9' '\nDISPMSG  EQU   DISPMSG1,*-DISPMSG1-1,C'C'\n         SPACE 1\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 2\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJPSCB\n         SPACE 1\n         END\n./ ADD NAME=EJECT    0100-07332-07332-0900-00029-00029-00000-SEB\n*\n***********************************************************************\n*                                                                     *\n* This command no longer works as of TSO/E Version 2, because of the  *\n* key-1 storage now used by TSO control blocks.   0C4 results.        *\n*                                                                     *\n***********************************************************************\n*\n         TITLE 'EJECT - COMMAND PROCESSOR FOR USE IN TSO BATCH OUTPUT'\n         SPACE\n***********************************************************************\n* THIS COMMAND CAUSES A PAGE-EJECT CONDITION IN AN OUTPUT FILE OF A   *\n* STACK DATASET ELEMENT BY UPDATING THE INTERNAL LINE COUNT FIELD TO  *\n* FORCE A NEW-PAGE CONDITION.  IF THE BOTTOM ELEMENT OF THE CURRENT   *\n* TSO SESSION IS NOT A DATASET ELEMENT NO ACTION IS PERFORMED.        *\n***********************************************************************\n         SPACE\nEJECT    CSECT\n         L     15,12(,1)           ADDRESS OF ECT\n         L     15,4(,15)           ADDRESS OF INPUT STACK (IOSRL)\n         L     15,4(,15)           BOTTOM STACK ELEMENT\n         TM    0(15),X'10'         DATASET ELEMENT?\n         BNOR  14                  NO, DO NOTHING\n         ICM   15,7,1(15)          DSD\n         BZR   14                  ZERO, DO NOTHING\n         MVI   3(15),254           SET MAXIMUM LINE COUNT\n         XR    15,15               SET RETURN CODE TO ZERO\n         BR    14                  RETURN\n         END\n./ ADD NAME=FSOFF    0100-07332-07332-0900-00012-00012-00000-SEB\nFSOFF    CSECT\n         SPACE\n         STM   14,12,12(13)\n         LR    12,15\n         USING FSOFF,12\n         TPUT  OFFSTRM,L'OFFSTRM,FULLSCR,HOLD\n         L     14,12(,13)\n         LM    0,12,20(13)\n         BR    14\n         SPACE\nOFFSTRM  DC    X'277E40115D7E11404013'\n         END\n./ ADD NAME=FSON     0100-07332-07332-0900-00013-00013-00000-SEB\nFSON     CSECT\n         SPACE\n         STM   14,12,12(13)\n         LR    12,15\n         USING FSON,12\n         TPUT  ONSTRM,L'ONSTRM,FULLSCR,HOLD\n         L     14,12(,13)\n         LM    0,12,20(13)\n         BR    14\n         SPACE\n*ONSTRM  DC    X'277E40115D7F11404013'\nONSTRM   DC    X'27F140115D7F114040'\n         END\n./ ADD NAME=GETDSN   0100-07332-07332-0900-00337-00337-00000-SEB\n         TITLE 'GETDSN   - ROUTINE TO RETURN A DSNAME GIVEN DDNAME'\n***********************************************************************\n*                                                                     *\n* GETDSN   - ROUTINE TO RETURN A DSNAME GIVEN DDNAME                  *\n*                                                                     *\n* THIS SUBROUTINE IS CALLABLE FROM A FORTRAN PROGRAM OR PL/1 PROGRAM  *\n* THAT PASSES IT THREE CHARACTER STRING AREAS AS FOLLOWS:             *\n*                                                                     *\n* (1) CHARACTER(8) - THE DDNAME TO SEARCH FOR.                        *\n* (2) CHARACTER(44) - FILLED IN WITH THE DSNAME.                      *\n* (3) CHARACTER(8) - FILLED IN WITH THE MEMBER NAME IF ANY.           *\n*                                                                     *\n* RETURN CODES:                                                       *\n*                                                                     *\n*   0 - EVERYTHING OK.  DSNAME AND MEMBER SET.                        *\n*   4 - REQUESTED FILENAME IS A CONCATENATION.  ONLY THE FIRST        *\n*       DSNAME AND MEMBER ARE RETURNED.                               *\n*   8 - THE FILENAME IS NOT ALLOCATED OR IS INVALID.                  *\n*                                                                     *\n* FORTRAN INVOCATION:                                                 *\n*                                                                     *\n*       CHARACTER*8 DDNAME                                            *\n*       CHARACTER*8 SAMPDD                                            *\n*       CHARACTER*44 DSNAME                                           *\n*       CHARACTER*8 MEMBER                                            *\n*       INTEGER*4 GETDSN                                              *\n*       INTEGER*4 RC                                                  *\n*       DATA SAMPDD/'FT06F001'                                        *\n*       DDNAME = SAMPDD                                               *\n*       RC=GETDSN(DDNAME,DSNAME,MEMBER)                               *\n*       IF(RC.EQ.0) GOTO 10                                           *\n*       IF(RC.EQ.4) GOTO 14                                           *\n*       IF(RC.EQ.8) GOTO 18                                           *\n*    10 WRITE (6,*) DSNAME,'(',MEMBER,')'                             *\n*       GOTO 9999                                                     *\n*    14 WRITE (6,*) DSNAME,'(',MEMBER,') - BUT CONCATENATED...'       *\n*       GOTO 9999                                                     *\n*    18 WRITE (6,*) 'FILE NAME IS NOT ALLOCATED OR IS INVALID'        *\n*       GOTO 9999                                                     *\n*                                                                     *\n* PL/1 INVOCATION:                                                    *\n*                                                                     *\n*  DCL DDNAME CHAR(8),                                                *\n*      DSNAME CHAR(44),                                               *\n*      MEMBER CHAR(8),                                                *\n*      PLIRETV BUILTIN;                                               *\n*  DCL GETDSN ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *\n*  DDNAME = 'SYSPRINT';                                               *\n*  CALL GETDSN(DDNAME,DSNAME,MEMBER);                                 *\n*  SELECT (PLIRETV());                                                *\n*    WHEN (0) BEGIN;                                                  *\n*               PUT LIST(DSNAME || '(' MEMBER || ')');                *\n*             END;                                                    *\n*    WHEN (4) BEGIN;                                                  *\n*               PUT LIST(DSNAME || '(' MEMBER || ')');                *\n*               PUT LIST('...BUT CONCATENATED');                      *\n*             END;                                                    *\n*    WHEN (8) BEGIN;                                                  *\n*               PUT LIST('FILE NAME NOT ALLOCATED OR INVALID');       *\n*             END;                                                    *\n*  END;                                                               *\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*                                                                     *\n*  12/16/87 - SEB1525 - RMODE=ANY AND AMODE=ANY SUPPORT ADDED.        *\n*                                                                     *\n*  01/14/88 - SEB1525 - (1) Returns 'TERMFILE' instead of 'NULLFILE'  *\n*                           for a file allocated to the terminal.     *\n*                                                                     *\n*                       (2) Returns SYSOUT=c, where c is the SYSOUT   *\n*                           class, for SYSOUT files.                  *\n*                                                                     *\n*  10/03/89 - SEB1525 - Fixed \"NO SIOT found\" with multiple job steps *\n*                                                                     *\n*  11/30/89 - SEB1525 - Added optional 4th parameter to return volser *\n*                                                                     *\n* CHANGES NEVER IMPLEMENTED:                                          *\n*                                                                     *\n*                       (1) Use system macros instead of chasing      *\n*                           control block pointers to find the JFCB.  *\n*                           This will permit SWA-above-the-line to    *\n*                           be implemented by Systems if desired.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TIOT ENTRY POINTER\nR4       EQU   4    USED TO INCREMENT TIOT POINTER\nR5       EQU   5    JFCB POINTER\nR6       EQU   6    ADDRESS OF PARM 1 - DDNAME\nR7       EQU   7    ADDRESS OF PARM 2 - DSNAME\nR8       EQU   8    ADDRESS OF PARM 3 - MEMBER\nR9       EQU   9    SUBSYSTEM FLAG\nR10      EQU   10   SUBSYSTEM FLAG\nR11      EQU   11   UCB POINTER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nGETDSN   CSECT\nGETDSN   RMODE ANY\nGETDSN   AMODE ANY\n         SAVE  (14,12),,GETDSN_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING GETDSN,R12\n*\n* THIS PROGRAM NEEDS NO SAVE AREA.\n*\n         SPACE 1\n         TM    8(R1),X'80'         If 3 parameters passed,\n         BZ    FOURPRMS            then...\n         LM    R6,R8,0(R1)          load pointers to 3 parameters\n         XR    R9,R9                clear 4th parameter address\n         B     AFTPARMS            else...\nFOURPRMS DS    0H                   (4 parameters passed)...\n         LM    R6,R9,0(R1)          load pointers to 4 parameters\n         MVC   0(6,R9),=CL8' '     Clear returned volser to blanks\nAFTPARMS DS    0H\n         XR    R10,R10             Clear subsystem flag\n         CLC   0(8,R6),=CL8' '     IF DDNAME IS BLANK\n         BE    RETURN8             THEN INVALID FILE NAME, RETURN 8\n         L     R3,540              GET ADDRESS OF TCB\n         USING TCB,R3\n         L     R3,TCBTIO           GET ADDRESS OF TIOT\n         DROP  R3\n         USING TIOT1,R3\n         LA    R3,TIOENTRY         POINT TO FIRST TIOT ENTRY\n         XR    R4,R4               CLEAR REG USED TO INSERT LENGTH\nLOOP     DS    0H\n         USING TIOENTRY,R3\n         TM    TIOESTTA,TIOSLTYP   IF ENTRY NOT IN USE\n         BO    SKIP                THEN SKIP IT\n         CLC   TIOEDDNM(8),0(R6)   IF DDNAMES MATCH\n         BE    FOUNDIT             THEN WE GOT IT\nSKIP     DS    0H\n         IC    R4,TIOELNGH         ELSE GET LENGTH OF THIS ENTRY\n         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY\n         CLI   TIOELNGH,0          IF THIS IS THE END OF THE TIOT\n         BE    RETURN8             THEN FILE NOT FOUND, RETURN CODE 8\n         B     LOOP                ELSE CONTINUE SEARCHING\n         SPACE 1\nFOUNDIT  DS    0H                  WE FOUND THE TIOT ENTRY...\n*\n* Before getting the JFCB, check the bits in the TIOT entry to see\n* what kind of file this is, and return appropriate information.\n*\n         TM    TIOELINK,TIOTTERM   If this is a terminal\n         BO    DOTERM              then process terminal data set\n         TM    TIOELINK,TIOESSDS   If this is a subsystem data set\n         BO    DOSUBSYS            then process subsystem data set\n*                                  Else assume it's a normal data set\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n         XR    R5,R5               PREPARE REGISTER FOR 24-BIT ADDRESS\n         ICM   R5,7,TIOEJFCB       GET ADDRESS OF JFCB\n         LA    R5,16(,R5)          Point to actual JFCB (past prefix)\n*----------------------------------------------------------------------\n         USING JFCB,R5\n         MVC   0(44,R7),JFCBDSNM   MOVE DSNAME FROM JFCB TO PARM 2\n         MVC   0(8,R8),JFCBELNM    MOVE MEMBER FROM JFCB TO PARM 3\n         B     AFTJFCB\n         SPACE 1\nDOTERM   DS    0H                  Process terminal data set\n         MVC   0(8,R7),=CL8'TERMFILE'  Set returned DSNAME\n         MVI   8(R7),C' '\n         MVC   9(44-8-1,R7),8(R7)  Clear rest of dsname to blanks\n         MVC   0(8,R8),=CL8' '     Clear returned member to blanks\n         B     AFTJFCB\n         SPACE 1\nDOSUBSYS DS    0H                  Process\n         MVI   0(R7),C' '\n         MVC   1(43,R7),0(R7)      Clear returned dsname to blanks\n         MVC   0(8,R8),=CL8' '     Clear returned member to blanks\n*\n* If this is a subsystem data set, it is either a SYSOUT data set\n* or an instream (DD * or DD DATA) data set.\n*\n* If the former, how do we find the SYSOUT class?\n* If the latter, how do we tell?\n*\n*\n* If this is a SYSOUT data set, we must search the SIOT to find the\n* entry corresponding to this DDNAME to get the SYSOUT class.\n*\n         L     R15,540             Get TCB address\n         USING TCB,R15\n         L     R15,TCBJSCB         Get JSCB address\n         DROP  R15\n         USING IEZJSCB,R15\n         L     R15,JSCBACT         Get active JSCB address 10/03/89\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n         XR    R14,R14                                     10/03/89\n         ICM   R14,7,JSCSCTP       Get SCT pointer         10/03/89\n         LA    R15,16(,R14)        Bump past SWA prefix    10/03/89\n*                                                  Deleted 10/03/89\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n*        XR    R14,R14\n*        ICM   R14,7,JSCBJCTA      Get JCT pointer\n*        LA    R15,16(,R14)        Bump past SWA prefix\n*----------------------------------------------------------------------\n*        DROP  R15\n*        USING JCT,R15\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n*        XR    R14,R14\n*        ICM   R14,7,JCTSDKAD      Get SCT pointer\n*        LA    R15,16(,R14)        Bump past SWA prefix\n*----------------------------------------------------------------------\n*                                              End Deleted 10/03/89\n         DROP  R15\n         USING SCT,R15\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n         XR    R14,R14\n         ICM   R14,7,SCTFSIOT      Get SIOT pointer\n         LA    R10,16(,R14)        Bump past SWA prefix\n*----------------------------------------------------------------------\n         DROP  R15\n         USING SIOT,R10\nLOOPSIOT DS    0H                  Loop through SIOT's\n         CLC   SCTDDNAM(8),0(R6)    until we find one for this DDNAME\n         BE    GOTSIOT              at which point go process it\n*----------------------------------------------------------------------\n* No good if SWA above the line!\n*----------------------------------------------------------------------\n         ICM   R14,15,SIOTNPTR     Get next SIOT pointer in chain\n         BZ    ERRSIOT             If none, disastrous error\n         LA    R10,0(,R14)         There's no SWA prefix this time!\n*----------------------------------------------------------------------\n         B     LOOPSIOT            Continue searching\nERRSIOT  DS    0H                  Error - SIOT not found\n         WTO   ROUTCDE=11,                                             X\n               'GETDSN: No SIOT found for requested SYSIN/SYSOUT DD.'\n         MVC   0(8,R7),=CL8'SYSOUT=?'  Set returned DSNAME\n         B     NOSUBSYS            Go with what we got so far...\nGOTSIOT  DS    0H                  We found the SIOT for this ddname...\n         CLI   SCTOUTPN,C' '       If SYSOUT class is filled in,\n         BNH   NOSYSOUT            then...\n         MVC   0(7,R7),=CL7'SYSOUT=' set returned DSNAME\n         MVC   7(1,R7),SCTOUTPN      move in SYSOUT class\n         B     NOSUBSYS            else...\nNOSYSOUT DS    0H                   this must be SYSIN...\n         MVC   0(8,R7),=CL8'SYSIN=* ' set returned DSNAME\nNOSUBSYS DS    0H\n         SPACE 1\nAFTJFCB  DS    0H                  Got DSN/member, now check to see if\n*                                  we need to return a volume serial\n         LTR   R9,R9               If we didn't get a volser parameter\n         BZ    AFTVSER             then skip this stuff. Else.. .\n         XR    R11,R11             Clear register before loadin g\n         ICM   R11,7,TIOEFSRT      Get UCB address\n         BZ    AFTVSER             If none, skip, let volser be blanks\n         USING UCBCMSEG,R11\n         MVC   0(6,R9),UCBVOLI     Move volume serial to parameter 4\n         SPACE 1\nAFTVSER  DS    0H                  Got everything, now check to see if\n*                                  there's a concatenated DD following\n         IC    R4,TIOELNGH         GET LENGTH OF THIS ENTRY\n         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY\n         CLI   TIOELNGH,0          IF THIS IS THE END OF THE TIOT\n         BE    RETURN0             THEN NOT CONCATENATED, RETURN CODE 0\n         TM    TIOESTTA,TIOSLTYP   IF FOLLOWING ENTRY NOT IN USE\n         BO    RETURN0             THEN NOT CONCATENATED, RETURN CODE 0\n         CLC   TIOEDDNM(8),=CL8' ' IF FOLLOWING DDNAME IS BLANK\n         BE    RETURN4             THEN IT'S A CONCATENATION, RETURN 4\n         B     RETURN0             ELSE IT'S ALONE, RETURN CODE 0\n         SPACE 1\nRETURN8  DS    0H                  FAILURE\n         SPACE 1\n         LA    R15,8               SET RETURN CODE TO 8\n         B     RETURN\n         SPACE 1\nRETURN4  DS    0H                  CONCATENATED\n         SPACE 1\n         LA    R15,4               SET RETURN CODE TO 4\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R0,R15              SET RETURN CODE FOR FORTRAN\n         L     R14,12(,R13)\n         LM    R1,R12,24(R13)\n         BR    R14\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n*                                                                     *\n* MACRO EXPANSIONS                                                    *\n*                                                                     *\n* Note:  DST1.AMODGEN is required for most of these macros.           *\n*                                                                     *\n***********************************************************************\n         EJECT\nJFCB     DSECT\n         IEFJFCBN ,                Map the JFCB\n         EJECT\nTIOT     DSECT\n         IEFTIOT1 ,                Map the TIOT\n         EJECT\nUCB      DSECT\n         IEFUCBOB ,                Map the UCB\n         EJECT\nJCT      DSECT\n         IEFAJCTB                  Map the JCT\n         EJECT\nSCT      DSECT\n         IEFASCTB                  Map the SCT\n         EJECT\nSIOT     DSECT\n         IEFASIOT                  Map the SIOT\n         EJECT\n         PRINT NOGEN\n         SPACE 2\n         IKJTCB                    Map the TCB\n         IEZJSCB                   Map the JSCB\n         END\n./ ADD NAME=GETJID   0100-07332-07332-0900-00106-00106-00000-SEB\n         TITLE 'GETJID   - ROUTINE TO RETURN JES2 JOB ID'\n***********************************************************************\n*                                                                     *\n* GETJID   - Subroutine to return JES2 job id (e.g. \"JOB  123\")       *\n*                                                                     *\n* This subroutine is callable from a FORTRAN program or PL/1 program  *\n* that passes it one character string areas as follows:               *\n*                                                                     *\n* (1) CHARACTER(8) - filled in with the 8-character JES2 job ID.      *\n*                                                                     *\n* FORTRAN INVOCATION:                                                 *\n*                                                                     *\n*       CHARACTER*8 JOBID                                             *\n*       CALL GETJID(JOBID)                                            *\n*       WRITE (6,*) 'JES2 JOB ID IS ',JOBID                           *\n*                                                                     *\n* PL/1 INVOCATION:                                                    *\n*                                                                     *\n*  DCL JOBID CHAR(8);                                                 *\n*  DCL GETJID ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *\n*  CALL GETJID(JOBID);                                                *\n*  PUT LIST('JES2 JOB ID IS ' || JOBID);                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nGETJID   CSECT\nGETJID   AMODE ANY\nGETJID   RMODE ANY\n         SAVE  (14,12),,GETJID_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING GETJID,R12\n*\n* THIS PROGRAM NEEDS NO SAVE AREA.\n*\n         SPACE 1\n         L     R6,0(,R1)           Get pointer to parm 1 (char*8)\n         MVC   0(8,R6),DEFAULT     Move default name if not known\n         L     R2,X'10'            Get CVT address\n         USING CVT,R2\n         L     R2,CVTJESCT         Get CVTJESCT\n         USING JESCT,R2\n         L     R2,JESSSCT          Get addr of subsystem control table\n         USING SSCT,R2\nSSNLOOP  DS    0H\n         LTR   R2,R2               If no more subsystems\n         BZ    NOACF2              then ACF2 not active, give up\n         CLC   8(4,R2),=C'ACF2'    Search for ACF2 subsystem\n         BE    GOTACF2\n         L     R2,SSCTSCTA         If not found, get next subsystem\n         B     SSNLOOP\nGOTACF2  DS    0H                  R2 -> ACF2 subsystem table\n         ICM   R3,15,SSCTSUSE      Get address of ACCVT\n         BZ    NOACF2\n         USING ACCVT,R3\n         ICM   R4,15,ACCASVT       Get address of beginning of ACFASVT\n         BZ    NOACF2\n         USING ACFASVT,R4\n         L     R5,X'224'           Get current ASCB address\n         USING ASCB,R5\n         LH    R1,ASCBASID         Get current ASID\n         SLA   R1,5                Convert to index to ACFASVT\n         AR    R4,R1               Point to ACFASVT for this user\n         MVC   0(8,R6),ASVJID      Move JES2 job ID to parm 1\n         B     RETURN\nNOACF2   DS    0H\n         WTO   'GETJID: ACF2 control blocks not available, cannot get JX\n               ES2 job id for this job.'\nRETURN   DS    0H\n         XR    R15,R15             Set return code to zero\n         LR    R0,R15              Set return code for FORTRAN (?)\n         L     R14,12(,R13)\n         LM    R1,R12,24(R13)\n         BR    R14\n         SPACE 1\nDEFAULT  DC    CL8' '              Default name if can't find it\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n         IKJTCB\n         IHAASCB\n         ACCVT\n         ACFASVT\n         IEFJESCT\n         IEFJSCVT\n         CVT   DSECT=YES\n         SPACE 1\n         END\n./ ADD NAME=GETPGM   0100-07332-07332-0900-00090-00090-00000-SEB\n         TITLE 'GETPGM   - ROUTINE TO RETURN EXECUTING PROGRAM NAME'\n***********************************************************************\n*                                                                     *\n* GETPGM   - Subroutine to return name of executing program           *\n*                                                                     *\n* This subroutine is callable from a FORTRAN program or PL/1 program  *\n* that passes it one character string areas as follows:               *\n*                                                                     *\n* (1) CHARACTER(8) - filled in with the name of the executing program.*\n*                                                                     *\n* FORTRAN INVOCATION:                                                 *\n*                                                                     *\n*       CHARACTER*8 PGMNAM                                            *\n*       CALL GETPGM(PGMNAM)                                           *\n*       WRITE (6,*) 'NAME OF PROGRAM IS ',PGMNAM                      *\n*                                                                     *\n* PL/1 INVOCATION:                                                    *\n*                                                                     *\n*  DCL PGMNAM CHAR(8);                                                *\n*  DCL GETPGM ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *\n*  CALL GETPGM(PGMNAM);\n*  PUT LIST('NAME OF PROGRAM IS ' || PGMNAM);                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nGETPGM   CSECT\nGETPGM   AMODE ANY\nGETPGM   RMODE ANY\n         SAVE  (14,12),,GETPGM_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING GETPGM,R12\n*\n* THIS PROGRAM NEEDS NO SAVE AREA.\n*\n         SPACE 1\n         L     R6,0(,R1)           Get pointer to parm 1 (char*8)\n         MVC   0(8,R6),DEFAULT     Move default name if not known\n         L     R7,X'21C'           Get current TCB address\n         USING TCB,R7              Establish addressability\n         XR    R4,R4\n         ICM   R4,7,1(R7)          Get TCB's RB address\nRBLOOP   DS    0H\n         LTR   R8,R4\n         BZ    RETURN              If no RB available, return\n         TM    X'B'(R8),X'80'      If this RB points to TCB\n         BO    LASTRB              then it's the last one\n         XR    R4,R4               else\n         ICM   R4,7,X'1D'(R8)      get next RB address\n         B     RBLOOP              and continue\nLASTRB   DS    0H                  This is the RB to look at\n         ICM   R9,R15,X'C'(R8)     Get CDE address\n         BZ    RETURN              If none, skip\n         MVC   0(8,R6),8(R9)       Move CDE name to parm 1\nRETURN   DS    0H\n         XR    R15,R15             Set return code to zero\n         LR    R0,R15              Set return code for FORTRAN (?)\n         L     R14,12(,R13)\n         LM    R1,R12,24(R13)\n         BR    R14\n         SPACE 1\nDEFAULT  DC    CL8' '              Default name if can't find it\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         EJECT\n         IKJTCB\n         SPACE 1\n         END\n./ ADD NAME=H        0100-07332-07332-0900-01361-01361-00000-SEB\n     TITLE 'HELPEXIT - FRONT END TO HELP COMMAND FOR COMMAND INTERFACE'\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS LINKEDITED WITH THE TSO HELP COMMAND.  IT ACTS AS A  *\n* FRONT-END INTERCEPT IN SUBCOMMAND MODE TO ENABLE A TSO USER TO      *\n* EXECUTE TSO COMMANDS FROM WITHIN SUBCOMMAND MODE.  A TSO USER MAY   *\n* EXECUTE A COMMAND OR CLIST FROM SUBCOMMAND MODE BY ENTERING:        *\n*                                                                     *\n*    HELP X COMMAND OPERANDS ...                                      *\n* OR                                                                  *\n*    HELP XX COMMAND OPERANDS ...                                     *\n*                                                                     *\n* IF THE COMMAND IS A CLIST, THEN IF \"HELP X ...\" IS SPECIFIED THE    *\n* CLIST WILL BE EXECUTED AS A LIST OF COMMANDS; IF \"HELP XX ...\" IS   *\n* SPECIFIED THE CLIST WILL BE EXECUTED AS A LIST OF SUBCOMMANDS.      *\n* THE HELP SUBCOMMAND ENTERED IN ANY OTHER FORMAT WILL EXECUTE IN THE *\n* NORMAL FASHION.  THIS IS DONE BY TRANSFERRING CONTROL TO TRUE ENTRY *\n* POINT IKJEFH01.                                                     *\n*                                                                     *\n*  LINKAGE EDITOR ATTRIBUTES:  REENTRANT, REUSABLE (SAME AS FOR HELP) *\n*  MACRO LIBRARIES REQUIRED:  DST1.AMODGEN                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n*   R3  -->  CPPL (COMMAND PROCESSOR PARAMETER LIST)                  *\n*   R4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *\n*   R5  -->  CBUF (COMMAND BUFFER)                                    *\n*   R6  -->  LIST SOURCE DESCRIPTOR FOR COMMAND TO BE STACKED         *\n*   R7  -->  (AVAILABLE)                                              *\n*   R8  -->  STATIC BASE REGISTER FOR PUTLINE SUBROUTINE              *\n*   R9  -->  ADDRESS OF TCOMTAB IF UNDER TEST, ELSE ZEROES            *\n*   R10 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 0                      *\n*   R11 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 1                      *\n*   R12 -->  STATIC BASE REGISTER                                     *\n*   R13 -->  SAVE AREA POINTER                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nHELPEXIT CSECT\n         SAVE  (14,12),,HELPEXIT_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING HELPEXIT,R12\n         LR    R3,R1               SAVE PARAMETER LIST ADDRESS\n         USING CPPL,R3\n         XR    R11,R11             CLEAR SUBPOOL 1 STORAGE REGISTER\n         LA    R0,SIZDATD0         GET LENGTH OF SUBPOOL 1 STORAGE\n         GETMAIN R,LV=(0)          GET SUBPOOL 1 STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R10,R1              ADDRESS SUBPOOL 0 STORAGE\n         USING DATD0,R10\n         SPACE\n         L     R4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE\n         USING ECT,R4\n         CLC   ECTPCMD(5),=CL8'HELP '  IF PRIMARY COMMAND IS HELP\n         BE    REALHELP                THEN THIS IS TRUE HELP COMMAND\n         CLC   ECTPCMD(2),=CL2'H '     IF PRIMARY COMMAND IS H\n         BE    REALHELP                THEN THIS IS TRUE HELP COMMAND\n         SPACE 2\n***********************************************************************\n* ALLOCATE SUBPOOL 1 STORAGE FOR SCAN SERVICE ROUTINE                 *\n***********************************************************************\n         SPACE\n         GETMAIN R,LV=SIZDATD1,SP=1    GET SUBPOOL 1 STORAGE\n         LR    R11,R1              ADDRESS SUBPOOL 1 STORAGE\n         USING DATD1,R11\n         EJECT\n***********************************************************************\n* INITIALIZE WORK AREAS                                               *\n***********************************************************************\n         SPACE\n         L     R5,CPPLCBUF\n         ST    R5,D0ORGBUF         SAVE ADDR OF ORIGINAL HELP COMMAND\n         L     R14,CPPLUPT\n         L     R15,CPPLECT\n         LA    R0,D0ECB\n         STM   R14,R0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST\n         LA    R1,D1CSFLG\n         LA    R2,CSOA\n         STM   R14,R2,CSPL         SET UP IKJSCAN PARAMETER LIST\n         L     R1,CPPLPSCB\n         LA    R2,DAPB2C\n         STM   R14,R2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST\n         LA    R0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE\n         SLL   R0,16               SHIFT INTO LEFT HALF FOR DAIR CB\n         STCM  R0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD\n         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS\n         MVC   DA2CDDN+1(7),DA2CDDN\n         MVC   D0PREFIX,0(R5)      SAVE ORIGINAL BUFFER PREFIX\n         MVC   D0CMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND\n         MVC   D0BLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK\n         MVC   D0ATTACH(LATTACHL),LATTACH  SET UP ATTACH LIST FORM\n         MVC   PTPB(12),LPUTLINE           SET UP PUTLINE LIST FORM\n         MVC   PGPB(LPUTGETL),LPUTGET      SET UP PUTGET LIST FORM\n         MVC   STPB(LSTACKL),LSTACK        SET UP STACK LIST FORM\n         MVC   D0ESTAE(LESTAEL),LESTAE     SET UP ESTAE LIST FORM\n         MVC   D0STAX(LSTAXL),LSTAX        SET UP STAX LIST FORM\n         LA    R0,1\n         LA    R1,D0MSGHDR\n         XR    R2,R2\n         STM   R0,R2,D0MSGOLD      INITIALIZE PUTLINE WORK AREA\n         LA    R1,D0PGHDR\n         STM   R0,R1,D0PGOLD       INITIALIZE PUTGET MODE MSG AREA\n         LA    R1,D0PGOLD\n         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    R1,D0MSGOLD\n         ST    R1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    R0,D0CMDECB\n         LA    R1,D0ATNECB\n         STM   R0,R1,D0ECBLST      INITIALIZE ECB LIST\n         OI    D0ECBLST+4,X'80'\n*** NOTE: R2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.\n         ST    R2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE\n         ST    R2,D0RETCD          INITIALIZE RETURN CODE TO ZERO\n         MVI   D1CSFLG,0           PREPARE TO SYNTAX CHECK COMMAND\n         MVI   D0FLAGS,0           INITIALIZE FLAGS\n*** SET ADDRESS OF TCOMTAB IF INVOKED UNDER TEST\n         XR    R9,R9               INITIALIZE TEST COMM TABLE REGISTER\n         CLC   D0CMDS(5),=CL5'TEST '  IF ORIGINAL COMMAND WAS TEST,\n         BNE   NTCOM                  THEN\n         L     R9,X'21C'               GET ADDRESS OF TCB\n         L     R9,X'84'(,R9)           GET TCB OF MOTHER TASK (TEST)\n         L     R9,X'14'(,R9)           TCBTRN FIELD = ADDR OF TCOMTAB\nNTCOM    DS    0H\n         SPACE 2\n***********************************************************************\n* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *\n* NOTE: THE DATD0 DSECT IS PASSED TO BOTH ROUTINES.  SINCE THE        *\n*       ADDRESS OF DATD0 IS IN R10, THAT REGISTER IS USED AS THE      *\n*       PARAMETER ADDRESS IN THE ESTAE AND STAX MACRO INSTRUCTIONS.   *\n***********************************************************************\n         SPACE\n         LA    R0,PUTLINE          ADDRESSS OF PUTLINE SUBROUTINE\n         ST    R0,D0PLADDR         SAVE IT FOR EXIT ROUTINES\n         ESTAE STAEEXIT,PARAM=(R10),MF=(E,D0ESTAE)\n         LTR   R15,R15             IF ESTAE FAILED,\n         BZ    ESTAEOK             THEN\n         LA    R1,=C'ESTAE'         BLOW UP\n         LA    R0,5\n         B     ERROR\nESTAEOK  OI    D0FLAGS,D0ESTON     ELSE INDICATE ESTAE IS ACTIVE\n         STAX  STAXEXIT,USADDR=(R10),REPLACE=NO,MF=(E,D0STAX)\n         CH    R15,=H'4'           IF STAX FAILED,\n         BNH   STAXOK              THEN\n         LA    R1,=C'STAX'          BLOW UP\n         LA    R0,4\n         B     ERROR\nSTAXOK   OI    D0FLAGS,D0STXON     ELSE INDICATE STAX IS ACTIVE\n         SPACE 2\n***********************************************************************\n* SCAN INPUT COMMAND TO SEE IF IT IS \"HELP X ...\" OR \"HELP XX ...\"    *\n***********************************************************************\n         SPACE\n         LR    R1,R5               POINT TO COMMAND BUFFER\n         BAL   R14,SCAN            SCAN THE COMMAND\n         LTR   R15,R15             IF NO VALID OPERAND FOLLOWS,\n         BNZ   REALHELP            THEN PROCESS AS NORMAL HELP\n         CLC   D0COMMND(3),=C'XX ' IF FIRST OPERAND IS \"XX\"\n         BE    PROCX2              THEN PROCESS \"HELP XX\" ROUTINE\n         CLC   D0COMMND(2),=C'X '  ELSE SEE IF FIRST OPERAND IS \"X\"\n         BNE   REALHELP            IF NOT, GO TO TRUE HELP ROUTINE.\n         OI    D0FLAGS,D0X1        ELSE INDICATE \"HELP X\"\n         MVC   D0CPPL(16),CPPL     COPY CPPL INTO WORK AREA\n         L     R14,ECTIOWA         GET ADDRESS OF INPUT STACK\n         LM    R1,R2,0(R14)        GET PTRS TO TOP & BOTTOM ELEMENTS\n         LA    R1,0(,R1)           PURIFY TOP-OF-STACK ADDRESS\n         LA    R2,0(,R2)           PURIFY BOTTOM-OF-STACK ADDRESS\n         SR    R1,R2               TOS - BOS = STACK LEVEL (* 4)\n         STH   R1,D0STKLVL         SAVE ORIGINAL STACK LEVEL (* 4)\n         EJECT\nPROCX2   DS    0H\n         SPACE\n***********************************************************************\n* PROCESSING FOR \"HELP XX ...\" SUBCOMMAND:                            *\n* THE REST OF THE SUBCOMMAND BUFFER IS SCANNED AS A TSO COMMAND, THE  *\n* NEXT OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR      *\n* CLIST, AND IF SO, IT IS THEN INVOKED.  CONTROL THEN RETURNS         *\n* IMMEDIATELY TO SUBCOMMAND MODE.                                     *\n***********************************************************************\n         SPACE\n         MVC   D0OFFSET,2(R5)      SAVE POSSIBLE CLIST NAME OFFSET\n         LR    R1,R5               POINT TO COMMAND BUFFER\n         BAL   R14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER\n         B     GOSCAN(R15)         BRANCH BASED ON RETURN CODE\nGOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME\n         B     SCAN4               RC=4 - NO COMMAND NAME\n         B     SCAN8               RC=8 - INVALID COMMAND NAME\n         LH    R15,D0SCANRC        RC=12 - SCAN ERROR\n         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    R0,4\n         B     ERROR\n         SPACE\nSCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    R1,SYNMSG\n         LA    R0,L'SYNMSG\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         B     RETURN\n         SPACE\nSCAN4    DS    0H                  NO COMMAND NAME WAS FOUND\n*\n* NOTE: THE FOLLOWING CODE MAY BE DELETED IF \"HELP X\" OR \"HELP XX\"\n*       BY ITSELF IS TO BE PERMITTED AS A HELP REQUEST FOR A SUBCOMMAND\n*       NAMED \"X\" OR \"XX\".  OTHERWISE \"HELP X\" OR \"HELP XX\" WILL BE\n*       INTERPRETED AS A READY-MODE HELP COMMAND FOR INFORMATION\n*       CONTAINED IN MEMBER \"X\" OR \"XX\" OF THE SYSTEM HELP DATA SET.\n*\n         OI    D0FLAGS,D0ECTMOD    INDICATE THAT ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,=CL8'HELP'  SPECIFY HELP COMMAND\n         NI    ECTSWS,255-ECTNOPD  INDICATE THAT AN OPERAND IS PRESENT\n*\n* THIS MARKS THE END OF THE CODE WHICH YOU MAY WISH TO DELETE.\n*\n         B     REALHELP            GO TO PROCESS AS TRUE HELP COMMAND\n         SPACE\nSCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK\n         BAL   R14,CKCMD           CHECK EXISTENCE OF COMMAND\n         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         LTR   R15,R15             IF COMMAND IS NOT SUPPORTED\n         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT\n         BAL   R14,ATTACH          ELSE ATTACH THE COMMAND\n         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         TM    D0FLAGS,D0X1        IF \"HELP X ...\" WAS ENTERED,\n         BO    PROCX1              THEN GO PROCESS ADD'L STACKED CMD'S\n         SPACE\n***********************************************************************\n* IF THE \"HELP XX ...\" SUBCOMMAND WAS ENTERED UNDER TEST, AND A CLIST *\n* WAS SPECIFIED, SPECIAL PROCESSING MUST BE DONE TO INSURE THAT THE   *\n* CLIST EXECUTES PROPERLY.  TEST'S COMMUNICATION AREA (TCOMTAB,       *\n* POINTED TO BY REGISTER 9 UNDER TEST) CONTAINS A BIT CALLED TSTA,    *\n* WHICH SPECIFIES WHETHER TEST WAS ENTERED VIA A CLIST OR FROM THE    *\n* TERMINAL.  IF THIS BIT IS ON, SUBCOMMANDS OF TEST THAT CAUSE THE    *\n* PROBLEM PROGRAM TO GET CONTROL (GO, CALL, LOAD, GETMAIN, ETC.) CAN  *\n* CAUSE TEST TO STACK AN ADDITIONAL TERMINAL ELEMENT, STOPPING THE    *\n* CLIST.  TO PREVENT THIS, WE SET OFF THE BITS THAT SPECIFY THAT A    *\n* TERMINAL ELEMENT SHOULD BE ADDED (AND REMOVED AT END TIME).         *\n* NOTE:  IT IS POSSIBLE THAT DIFFICULTIES COULD OCCUR IF A CLIST      *\n* EXECUTED UNDER TEST VIA \"HELP XX\" ISSUES THE END SUBCOMMAND.        *\n***********************************************************************\n* NOTE: THIS MAY NOT APPLY TO TSO/E ... REMAINS TO BE SEEN.           *\n***********************************************************************\n         SPACE\n         LTR   R9,R9               IF ORIGINAL COMMAND WAS \"TEST\",\n         BZ    ENDCMDS             THEN\n         NI    X'9B'(R9),B'00111111' TURN OFF TSTA AND TSTB BITS.\n         B     ENDCMDS             FINISH UP\n         EJECT\nREALHELP DS    0H                  PROCESS TRUE HELP COMMAND\n         TM    D0FLAGS,D0BUFMOD    IF COMMAND BUFFER WAS ALTERED,\n         BZ    *+10                THEN\n         MVC   0(4,R5),D0PREFIX     RESTORE COMMAND BUFFER PREFIX.\n         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,\n         BZ    NOFREE1             THEN\n         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE\n         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED\nNOFREE1  DS    0H\n         LR    R1,R3               RESTORE CPPL ADDRESS\n*---THIS CODE EFFECTS THE FRONT ENDING--------------------------------*\n*        L     R15,=V(IKJEFH01)    GET ADDRESS OF TRUE HELP ENTRY POINT\n*        BALR  R14,R15             CALL IKJEFH01 TO DO HELP\n*---END OF FRONT ENDING CODE------------------------------------------*\n* THIS CODE IS IN USE HERE\n* FOR THE PURPOSES OF MY USAGE AT DRAPER, I HAVE SET UP THIS VERSION  *\n* OF THE \"H\" COMMAND SO THAT IT WORKS IN COMPATIBILITY WITH THE       *\n* THROWN-TOGETHER INTERFACE TO XCMD, I.E. IF HELP AAA (SUCH THAT AAA  *\n* IS NEITHER X NOR XX) IS SPECIFIED, I INVOKE XCMD RATHER THAN HELP.  *\n         NI    ECTSWS,255-ECTNOPD  TURN OFF ERRONEOUS NO-OPERANDS BIT\n         LINK  EP=XCMD             LINK TO XCMD TO DO SIMILAR THINGS\n* END OF CODE IN USE HERE\n         ST    R15,D0RETCD         SAVE RETURN CODE FROM HELP\n         B     AFTFREE1            AND RETURN TO SUBCOMMAND MODE\n         EJECT\nRETURN   DS    0H\n         SPACE\n***********************************************************************\n*           *** RETURN TO SUBCOMMAND MODE - BUT FIRST: ***            *\n* THE FOLLOWING CODE IS EXECUTED AT THIS POINT BECAUSE CERTAIN        *\n* SUBCOMMAND ENVIRONMENTS (SUCH AS TESTCOB) SCAN THE SUBCOMMAND       *\n* BUFFER SEVERAL TIMES TO PROCESS SUBCOMMANDS.  THIS IS BECAUSE THE   *\n* SUBCOMMAND MAY BE A SERIES OF SEPARATE SUBCOMMANDS SEPARATED BY     *\n* SEMICOLONS (GENERALLY CONTAINED IN A SUBCOMMAND LIST TO BE EXECUTED *\n* AT A BREAKPOINT).  IN THE CASE OF TESTCOB, THE COMMAND BUFFER       *\n* OFFSET IS USED TO DETERMINE THE STARTING POINT OF EACH SCAN.  THIS  *\n* OFFSET IS GENERALLY SET TO POINT TO THE END OF THE COMMAND BUFFER   *\n* BY THE PARSE SERVICE ROUTINE.  IN CASES WHERE THE COMMAND BUFFER IS *\n* NOT PARSED, HOWEVER, THE COMMAND BUFFER OFFSET IS NOT UPDATED AND   *\n* THE SUBCOMMAND PROCESSOR ATTEMPTS TO INVOKE THE KEYWORD PORTION OF  *\n* THE COMMAND AS ANOTHER SUBCOMMAND.                                  *\n* TO PREVENT THIS, WE CHECK THE COMMAND BUFFER OFFSET OF THE ORIGINAL *\n* \"HELP X ...\" COMMAND TO SEE IF (1) IT DOES NOT POINT TO THE END OF  *\n* THE COMMAND BUFFER AND (2) IT DOES NOT POINT TO A BYTE IMMEDIATELY  *\n* FOLLOWING A SEMICOLON, WHICH WOULD INDICATE A NEW SUBCOMMAND.  IF   *\n* THESE TWO CONDITIONS ARE TRUE, THE COMMAND BUFFER OFFSET FIELD IS   *\n* UPDATED TO POINT TO THE END OF THE COMMAND BUFFER OR A SEMICOLON,   *\n* IF ONE EXISTS FOLLOWING THE CURRENT COMMAND BUFFER OFFSET LOCATION. *\n* THE COMMAND BUFFER IS SCANNED FROM THE CURRENT OFFSET LOCATION TO   *\n* THE END FOR A SEMICOLON.  FOR CONSISTENCY WITH GENERAL PRACTICE, A  *\n* SEMICOLON IS TREATED AS ONE ONLY IF IT DOES NOT OCCUR WITHIN        *\n* QUOTES, PARENTHESES, OR A COMMENT SEQUENCE.                         *\n***********************************************************************\n         SPACE\n         L     R5,D0ORGBUF         GET ADDRESS OF ORIGINAL HELP COMMAND\n         LH    R15,0(,R5)          R15 = COMMAND BUFFER LENGTH\n         LH    R1,2(,R5)           R1  = COMMAND BUFFER OFFSET\n         LA    R0,0(R15,R5)        R0 -> END OF COMMAND BUFFER\n         BCTR  R0,0                R0 -> LAST BYTE IN COMMAND BUFFER\n         LA    R1,4(R1,R5)         R1 -> BUFFER OFFSET LOCATION\n         CR    R1,R0               IF WE'RE AT END OF BUFFER ALREADY\n         BH    AFTBUFF             THEN CURRENT OFFSET IS OK.  ELSE...\n         BCTR  R1,0                LOOK AT PREVIOUS CHARACTER IN BUFFER\n         CLI   0(R1),C';'          IF IT IS A SEMICOLON\n         BE    AFTBUFF             THE CURRENT OFFSET IS OK.  ELSE...\n         XR    R14,R14             CLEAR PARENTHESIS COUNT\nBUFFINCR LA    R1,1(,R1)           START SCANNING BUFFER FOR SEMICOLON\n         CR    R1,R0               SCAN UNTIL END OF COMMAND BUFFER\n         BH    GOTBUFF             (AT END WILL BE NEW OFFSET)\n         CLI   0(R1),C''''         IF QUOTE FOUND,\n         BNE   NOTQUOTE            THEN (\";\" IGNORED INSIDE QUOTES)...\nQUOTLOOP LA    R1,1(,R1)            SCAN FOR END QUOTE ONLY\n         CR    R1,R0                AT END OF BUFFER,\n         BH    GOTBUFF              WE WILL HAVE OFFSET ANYWAY\n         CLI   0(R1),C''''          ELSE IF ANOTHER QUOTE FOUND\n         BE    BUFFINCR             THEN CONTINUE NORMAL SCAN\n         B     QUOTLOOP             ELSE CONTINUE QUOTED SCAN\nNOTQUOTE DS    0H                  ELSE SEE IF INSIDE COMMENTS\n         CR    R1,R0               IF WE'RE NOT AT THE LAST BYTE YET\n         BNL   NOTCOMNT            THEN\n         CLC   0(2,R1),=C'/*'       IF AT BEGINNING OF COMMENT SEQUENCE\n         BNE   NOTCOMNT             THEN\n         LA    R1,2(,R1)             POINT TO BYTE FOLLOWING /*\nCOMNTLP  CR    R1,R0                 SCAN UNTIL END OF BUFFER\n         BNL   BUFFINCR              IF AT END, TERMINATE SCAN\n         CLC   0(2,R1),=C'*/'        IF NOT END OF COMMENT SEQUENCE\n         BE    ENDCOMNT              THEN\n         LA    R1,1(,R1)              CONTINUE SCAN FOR END COMMENT\n         B     COMNTLP               ELSE\nENDCOMNT LA    R1,1(,R1)              BUMP POINTER PAST */\n         B     BUFFINCR               AND CONTINUE SCAN.\nNOTCOMNT DS    0H                  ELSE SEE IF WITHIN PARENTHESES\n         CLI   0(R1),C'('          IF LEFT PARENTHESIS FOUND,\n         BNE   NOLP                THEN\n         LA    R14,1(,R14)          INCREMENT PARENTHESIS COUNT\n         B     BUFFINCR             AND CONTINUE SCAN.  ELSE...\nNOLP     LTR   R14,R14             IF ALREADY INSIDE PARENTHESES,\n         BZ    NOPARENS            THEN\n         CLI   0(R1),C')'           IF RIGHT PARENTHESIS FOUND\n         BNE   BUFFINCR             THEN\n         BCTR  R14,0                 DECREMENT PARENTHESIS COUNT\n         B     BUFFINCR              AND CONTINUE SCAN.  ELSE...\nNOPARENS CLI   0(R1),C';'          IF A SEMICOLON IS REALLY FOUND,\n         BNE   BUFFINCR            THEN\n         LA    R1,1(,R1)            BUMP TO POSITION FOLLOWING IT\nGOTBUFF  DS    0H                  WE NOW HAVE THE NEW OFFSET LOCATION\n         LA    R0,4(,R5)           GET ADDRESS OF START OF COMMAND\n         SLR   R1,R0               LOC - START = NEW OFFSET VALUE\n         STH   R1,2(,R5)           STORE NEW COMMAND BUFFER OFFSET\nAFTBUFF  DS    0H\n         EJECT\n***********************************************************************\n* NOW FREE STORAGE AND EXIT                                           *\n***********************************************************************\n         SPACE\n         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,\n         BZ    AFTFREE1            THEN\n         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE\n         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED\nAFTFREE1 DS    0H\n         TM    D0FLAGS,D0ECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,\n         BZ    *+10                THEN\n         MVC   ECTPCMD(16),D0CMDS   RESTORE ECTPCMD AND ECTSCMD.\n         TM    D0FLAGS,D0STXON     IF STAX IS ACTIVE\n         BNO   OFFSTAX             THEN\n         STAX  ,                    CANCEL STAX\nOFFSTAX  DS    0H\n         TM    D0FLAGS,D0ESTON     IF ESTAE IS ACTIVE\n         BNO   OFFESTAE            THEN\n         ESTAE 0                    CANCEL ESTAE\nOFFESTAE DS    0H\n         SPACE\nFINALRET DS    0H\n         L     R15,D0RETCD         PICK UP RETURN CODE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        PASS BACK RETURN CODE IN R15\n         FREEMAIN R,LV=SIZDATD0,A=(1)  FREE SUBPOOL 0 STORAGE\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 2\nLPUTLINE PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)\nLPUTGET  PUTGET  MF=L,OUTPUT=(*-*,,MODE)\nLPUTGETL EQU   *-LPUTGET\nFLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM\nFLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM\nLSTACK   STACK MF=L,STORAGE=*-*    STACK NEW COMMAND LIST FORM\nLSTACKL  EQU   *-LSTACK\nLATTACH  ATTACH SF=L,SHSPV=78,SZERO=NO\nLATTACHL EQU   *-LATTACH\nLESTAE   ESTAE MF=L\nLESTAEL  EQU   *-LESTAE\nLSTAX    STAX  MF=L,REPLACE=NO\nLSTAXL   EQU   *-LSTAX\n         SPACE\nMODEDATA DC    Y(MODELEN,0)\nMODEMSG  DC    C' HELP X'          LEADING BLANK REQUIRED - NO MSGID\nMODELEN  EQU   *-MODEDATA\n         SPACE\n***********************************************************************\n* MESSAGES                                                            *\n***********************************************************************\n         SPACE\nSYNMSG   DC    C'XHX001I INVALID COMMAND SYNTAX'\nERRMSG1  DC    C'XHX005I COMMAND INTERFACE FAILED, '\nERRMSG2  DC    C' ERROR CODE '\n         SPACE\n         LTORG\n         TITLE 'HELPEXIT - HELP X PROCESSING'\nPROCX1   DS    0H\n         SPACE\n***********************************************************************\n*                   \"HELP X ...\" PROCESSING                           *\n* FOR \"HELP X ...\", ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *\n* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *\n* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY COMPARING    *\n* THE STACK LEVEL WITH THE ORIGINAL STACK LEVEL.                      *\n* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *\n* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *\n* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *\n* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *\n* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *\n* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *\n* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *\n* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *\n* ORIGINALLY FROM SPF MODULE ISPCAT (OR CAT).)  WHEN THIS SITUATION   *\n* IS DETECTED, THE INPUT STACK LEVEL IS CHECKED; IF THE STACK LEVEL   *\n* IS STILL HIGHER THAN THE ORIGINAL STACK LEVEL (I.E. THE LEVEL WHEN  *\n* THE \"HELP X ...\" COMMAND WAS STARTED), IT IS PROBABLE THAT A TERMIN *\n* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *\n* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *\n* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE          *\n* TERMINATE.                                                          *\n* THERE IS ONE MORE PROBLEM AREA:  WHAT IF THE \"HELP X ...\" COMMAND   *\n* WAS INVOKED FROM A CLIST TO BEGIN WITH?  IN THIS CASE PUTGET WILL   *\n* SUCCESSFULLY RETRIEVE SUBCOMMANDS IN THE SAME CLIST FOLLOWING THE   *\n* \"HELP X ...\" COMMAND, WHICH IS NOT WHAT WE WANT.  TO SOLVE THIS     *\n* PROBLEM, WE CHECK THE STACK LEVEL FOLLOWING EVERY COMMAND THAT WE   *\n* RETRIEVED.  IF WE ARE BACK TO THE ORIGINAL STACK LEVEL OR LOWER, WE *\n* KNOW THAT THE COMMAND WE GOT DOESN'T BELONG TO US, SO WE \"GIVE IT   *\n* BACK\" BY COPYING THE COMMAND INTO STORAGE AND ADDING IT TO THE      *\n* INPUT STACK AS AN IN-STORAGE LIST, AND THEN WE TERMINATE.  THE      *\n* SUBCOMMAND ENVIRONMENT RECEIVES CONTROL AGAIN, AND WHEN IT REQUESTS *\n* ANOTHER SUBCOMMAND IT PICKS UP THAT COMMAND WE HAVE JUST STACKED.   *\n***********************************************************************\n         SPACE\n***********************************************************************\n* WHILE THE CURRENT STACK LEVEL IS HIGHER THAN THE ORIGINAL LEVEL,    *\n* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *\n* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *\n* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *\n* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *\n***********************************************************************\n         SPACE\n         TM    D0FLAGS,D0GOTLN     IF LINE HAS BEEN OBTAINED BY PUTGET,\n         BZ    X1GET               THEN\n         LR    R1,R5                GET ADDRESS OF PUTGET BUFFER\n         LA    R0,1                 GET SUBPOOL NUMBER\n         SLL   R0,24                SHIFT INTO HIGH-ORDER BYTE\n         AH    R0,0(,R5)            ADD IN LENGTH OF PUTGET BUFFER\n         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER\n         NI    D0FLAGS,255-D0GOTLN  INDICATE NO MORE PUTGET BUFFER\n         SPACE\nX1GET    DS    0H\n         SPACE\n***********************************************************************\n* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *\n* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK AND/OR THE STACK     *\n* LEVEL AT THIS POINT IS HIGHER THAN THE ORIGINAL STACK LEVEL.  SUCH  *\n* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *\n* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSSING COMMANDS   *\n* UNTIL THE STACK LEVEL BECOMES LESS THAN OR EQUAL TO THE LEVEL AT    *\n* WHICH THE ORIGINAL \"HELP X ...\" COMMAND WAS ISSUED.  NOTE THAT ANY  *\n* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *\n* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *\n* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *\n* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *\n***********************************************************************\n         SPACE\n         L     R14,ECTIOWA         GET ADDRESS OF THE INPUT STACK\n         LM    R1,R2,0(R14)        GET T.O.S. AND B.O.S POINTERS\n         LA    R1,0(,R1)           PURIFY TOP-OF-STACK POINTER\n         LA    R2,0(,R2)           PURIFY BOTTOM-OF-STACK POINTER\n         SR    R1,R2               GET CURRENT STACK LEVEL (* 4)\n         CH    R1,D0STKLVL         IF WE'RE DOWN TO ORIGINAL OR LOWER,\n         BNH   ENDCMDS             THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *\n***********************************************************************\n         SPACE\n         LA    R3,D0CPPL           POINT TO OUR CPPL NOW\n         XC    D0PGHDR(4),D0PGHDR  SET UP BAD (NULL) MODE MESSAGE\n         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE\n         CH    R15,=H'24'          IF INVALID PARAMETERS ON PUTGET,\n         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..\n         L     R14,ECTIOWA          GET ADDRESS OF THE INPUT STACK\n         LM    R1,R2,0(R14)         GET T.O.S. AND B.O.S POINTERS\n         LA    R1,0(,R1)            PURIFY TOP-OF-STACK POINTER\n         LA    R2,0(,R2)            PURIFY BOTTOM-OF-STACK POINTER\n         SR    R1,R2                GET CURRENT STACK LEVEL (* 4)\n         CH    R1,D0STKLVL          IF WE'RE DOWN TO ORIGINAL OR LOWER,\n         BNH   ENDCMDS              THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *\n***********************************************************************\n         SPACE\n         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE\n         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG                OR\n         CH    R15,=H'24'            INVALID PARAMETERS ON PUTGET,\n         BNE   PUTGETOK               THEN (REALLY BAD PUTGET)...\nBADPG    LA    R1,=C'PUTGET'           BLOW UP\n         LA    R0,6\n         B     ERROR\nPUTGETOK DS    0H\n         CLI   D0STATUS,D0ATTN     IF ATTENTION INTERRUPT OCCURRED,\n         BNE   PGNOATTN            THEN\n         LA    R1,FLUSHTOP          FLUSH THE STACK (EVEN IF\n         BAL   R14,FLUSH             CONTROL NOFLUSH IS ACTIVE)\n         B     PROCX1               AND CONTINUE\nPGNOATTN DS    0H                  ELSE PROCESS INPUT...\n         L     R5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER\n         LTR   R15,R15             IF PUTGET RC=0, LINE CAME FROM THE\n         BZ    PROCLINE             TERMINAL (PROB. TERMIN), SO PROCESS\n         SPACE\n***********************************************************************\n* ELSE PUTGET RETURN CODE = 4 - CHECK WHERE WE ARE ON THE INPUT STACK *\n***********************************************************************\n         SPACE\n         L     R14,ECTIOWA          GET ADDRESS OF THE INPUT STACK\n         LM    R1,R2,0(R14)         GET T.O.S. AND B.O.S POINTERS\n         LA    R1,0(,R1)            PURIFY TOP-OF-STACK POINTER\n         LA    R2,0(,R2)            PURIFY BOTTOM-OF-STACK POINTER\n         SR    R1,R2                GET CURRENT STACK LEVEL (* 4)\n         CH    R1,D0STKLVL          IF WE'RE STILL ABOVE ORIGINAL LEVEL\n         BH    PROCLINE             THEN IT'S OURS, WE CAN PROCESS IT\n         SPACE\n***********************************************************************\n* ELSE THIS COMMAND, EVEN THOUGH FROM A CLIST, WAS FROM A CLIST AT    *\n* OUR ORIGINAL STACK LEVEL OR LOWER.  THEREFORE, WE HAVE TO GIVE THIS *\n* COMMAND BACK TO THE SUBCOMMAND UNDER WHICH WE WERE INVOKED.  WE DO  *\n* THIS BY STACKING THE COMMAND IN STORAGE AND TERMINATING SO THAT THE *\n* SUBCOMMAND PROCESSOR PICKS UP THE COMMAND AS THE NEXT SUBCOMMAND.   *\n***********************************************************************\n         SPACE\n         L     R0,=X'4E000010'     SUBPOOL 78 + 16 (LENGTH OF AN LSD)\n         AH    R0,0(,R5)           ADD LENGTH OF THE PUTGET BUFFER\n         GETMAIN R,LV=(0)          GET A BUFFER FROM SUBPOOL 78\n         LR    R6,R1               SAVE BUFFER ADDRESS\n         LA    R14,16(,R6)         ADDRESS OF COMMAND IN STORAGE\n         LH    R15,0(,R5)          LENGTH OF COMMAND BUFFER\n*\n* LEFT HALF OF R15 IS ZERO FOR VARIABLE RECORD LENGTH\n* RIGHT HALF OF R15 IS LENGTH OF THE IN-STORAGE LIST\n*\n         LR    R0,R14              ADDRESS OF FIRST COMMAND IN THE LIST\n         XR    R1,R1               RESERVED FOR EXEC COMMAND, N/A HERE\n         STM   R14,R1,0(R6)        SET UP LSD (LIST SOURCE DESCRIPTOR)\n         BCTR  R15,0               USING COMMAND BUFFER LENGTH,\n         EX    R15,MVINSTOR        MOVE COMMAND TO IN-STORAGE LIST\n*** ASSUME R1 = 0\n         ST    R1,D0ECB            CLEAR ECB\n         SPACE\n***********************************************************************\n* PUT COMMAND ON STACK TO BE PROCESSED AS NEXT SUBCOMMAND         .   *\n***********************************************************************\n         SPACE\n         STACK PARM=STPB,STORAGE=((R6),SOURCE),MF=(E,IOPL)\n         LTR   R15,R15             IF STACK SUCCESSFUL,\n         BZ    ENDCMDS             THEN TERMINATE OUR PROCESSING.\n         LA    R1,=C'STACK'        ELSE BLOW UP\n         LA    R0,5\n         B     ERROR\n         SPACE\nPROCLINE DS    0H                  GO AHEAD AND PROCESS THIS LINE\n         ST    R5,D0CBUF           SET CPPL COMMAND BUFFER ADDRESS\n         XC    D0OFFSET,D0OFFSET   SET COMMAND BUFFER OFFSET TO ZERO\n         LR    R1,R5               POINT TO THE COMMAND BUFFER\n         BAL   R14,SCAN            SCAN NEXT OPERAND OF THE COMMAND\n         B     GOSCANX(R15)        BRANCH BASED ON RETURN CODE\nGOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME\n         B     PROCX1              RC=4 - NO COMMAND NAME\n         B     SCANX8              RC=8 - INVALID COMMAND NAME\n         LH    R15,D0SCANRC        RC=12 - SCAN ERROR\n         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    R0,4\n         B     ERROR\n         SPACE\nSCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    R1,SYNMSG\n         LA    R0,L'SYNMSG\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         B     PROCX1\n         SPACE\nSCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK\n         BAL   R14,CKCMD           CHECK VALIDITY OF COMMAND\n         LTR   R15,R15             IF COMMAN IS NOT VALID,\n         BNZ   PROCX1              THEN CONTINUE WITH THE NEXT ONE\n         BAL   R14,ATTACH          ELSE INVOKE THE COMMAND\n         TM    D0FLAGS,D0SUBER     IF SUBROUTINE ERROR,\n         BO    ERROR               THE GO TO DISPLAY MESSAGE\n         B     PROCX1              ELSE GO TO GET THE NEXT COMMAND\n         EJECT\nENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS\n         XR    R15,R15\n         ICM   R15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT\n         ST    R15,D0RETCD         SAVE THE RETURN CODE\n         SPACE\n***********************************************************************\n* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *\n* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *\n* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*\n***********************************************************************\n         SPACE\n         B     RETURN              RETURN TO SUBCOMMAND MODE\n         SPACE 2\nMVINSTOR MVC   16(0,R6),0(R5)      MOVE COMMAND TO IN-STORAGE LIST\n         EJECT\nERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END\n         SPACE\n***********************************************************************\n* MISCELLANEOUS ERROR DISPLAY.                                        *\n* R0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *\n* R1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *\n* R15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *\n***********************************************************************\n         SPACE\n         MVC   D0MSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE\n         LTR   R14,R0              GET LENGTH OF FUNCTION TYPE\n         BNP   AFTFUNC             IF NONE, BYPASS\n         BCTR  R14,0               ELSE REDUCE LENGTH FOR EXECUTE\n         EX    R14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE\nAFTFUNC  LA    R1,D0MSG+L'ERRMSG1+1(R14)  POINT TO NEXT PART OF MESSAGE\n         MVC   0(L'ERRMSG2,R1),ERRMSG2    SET UP SECOND PART OF MESSAGE\n         CVD   R15,D0DOUBLE               CONVERT ERROR CODE TO DISPLAY\n         UNPK  L'ERRMSG2(2,R1),D0DOUBLE\n         OI    L'ERRMSG2+1(R1),X'F0'\n         LA    R0,L'ERRMSG1+L'ERRMSG2+3(R14)  GET LENGTH OF MSG IN R0\n         XR    R1,R1               INDICATE MESSAGE ALREADY IN WORKAREA\n         BAL   R14,PUTLINE         DISPLAY THE MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           FLUSH THE INPUT STACK\n         B     RETURN              RETURN TO SUBCOMMAND MODE\n         SPACE\nMOVEFUNC MVC   D0MSG+L'ERRMSG1(0),0(R1)  MOVE FUNCTION TO ERROR MESSAGE\n         TITLE 'HELPEXIT - SCAN SUBROUTINE'\n***********************************************************************\n* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *\n* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE HELP SUBCOMMAND     *\n* BUFFER.  ON ENTRY R1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *\n* BE SCANNED.  ON RETURN THE FIELD D0COMMND CONTAINS THE OPERAND,     *\n* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *\n* SYNTACTICALLY INVALID.  R15 IS SET TO ZERO IF THE OPERAND IS A      *\n* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *\n* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *\n* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *\n* THE FLAG D0EXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *\n* NO FURTHER OPERANDS IN THE HELP SUBCOMMAND BUFFER FOLLOWING THE     *\n* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *\n***********************************************************************\n         SPACE\nSCAN     DS    0H\n         ST    R14,D0SCAN14        SAVE RETURN REGISTER\n         MVI   D0COMMND,C' '       SET COMMAND NAME FIELD TO BLANKS\n         MVC   D0COMMND+1(7),D0COMMND\n         NI    D0FLAGS,255-D0EXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW\n         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF\n         ST    R1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM\n         OI    D0FLAGS,D0BUFMOD    INDICATE COMMAND BUFFER MODIFIED\n         XC    D0ECB,D0ECB         CLEAR ECB\n         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER\n         STH   R15,D0SCANRC        SAVE IKJSCAN RETURN CODE\n         LTR   R15,R15             IF SCAN FAILED,\n         BZ    SCANOK              THEN...\n         LA    R15,12               INDICATE SCAN FAILURE\n         B     SCANRET              AND RETURN. ELSE...\nSCANOK   DS    0H                  CHECK RESULTS OF SCAN\n         TM    CSOAFLG,CSOANOC     IF NO OPERAND WAS FOUND,\n         BNO   NOTNOC              THEN...\n         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS\n         LA    R15,4                RETURN INDICATING NOTHING FOUND\n         B     SCANRET             ELSE...\nNOTNOC   DS    0H                  (AN OPERAND EXISTS)\n         LH    R1,CSOALNM          PICK UP LENGTH OF OPERAND\n         LTR   R1,R1               IF LENGTH IS ZERO,\n         BP    NOTBAD              THEN...\n         LA    R15,8                RETURN INDICATING BAD SYNTAX\n         B     SCANRET             ELSE...\nNOTBAD   DS    0H\n         L     R15,CSOACNM         GET ADDRESS OF OPERAND\n         BCTR  R1,0                REDUCE OPERAND LENGTH FOR EXECUTE\n         EX    R1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA\n         XR    R15,R15             INDICATE VALID COMMAND NAME\n         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,\n         BZ    *+8                 THEN...\n         OI    D0FLAGS,D0EXEC       INDICATE IMPLICIT EXEC\n         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,\n         BNO   *+8                 THEN...\n         OI    ECTSWS,ECTNOPD       SAY SO IN ECT\n         SPACE\nSCANRET  L     R14,D0SCAN14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE 2\nMOVECMD  MVC   D0COMMND(0),0(R15)  MOVE COMMAND NAME TO NAME AREA\n         SPACE\n         LTORG\n         TITLE 'HELPEXIT - CKCMD SUBROUTINE'\nCKCMD    DS    0H\n         SPACE\n         ST    R14,D0CKCM14        SAVE RETURN REGISTER\n         NI    D0FLAGS,255-D0SUBER TURN OFF ERROR INDICATOR\n         TM    D0FLAGS,D0EXEC      IF IMPLICIT %CLIST,\n         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...\n         CLC   D0COMMND(5),=CL5'TEST '     IF COMMAND = TEST\n         BE    NGCMD                       THEN REJECT\n         CLC   D0COMMND(6),=CL6'LOGON '    IF COMMAND = LOGON\n         BE    NGCMD                       THEN REJECT\n         CLC   D0COMMND(7),=CL7'LOGOFF '   IF COMMAND = LOGOFF\n         BE    NGCMD                       THEN REJECT\n         MVC   D0MODULE,D0COMMND   ELSE SET COMMAND NAME = SAME NAME\n         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         CLC   =C'TIME ',D0MODULE  IF COMMAND = TIME\n         BNE   NOTTIME             THEN\n         MVC   D0MODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTTIME  CLC   =C'CALL ',D0MODULE  IF COMMAND = CALL\n         BNE   NOTCALL             THEN\n         MVC   D0MODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTCALL  DS    0H                  ELSE SEARCH FOR COMMAND NAME\n         SPACE\n***********************************************************************\n* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *\n* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *\n* WE WILL EMULATE THE TMP AND SPF COMMAND SEARCH CODE INSTEAD.        *\n***********************************************************************\n         SPACE\n         STM   R3,R9,32(R13)       SAVE REGISTERS USED BY LPA SEARCH\n         LM    R0,R1,D0MODULE      LOAD COMMAND NAME INTO PARM REGS\n         L     R3,16               R3 = CVT ADDRESS\n         L     R15,X'160'(,R3)     R15 -> LPA DIRECTORY SEARCH ROUTINE\n         BALR  R14,R15             CALL LPA DIRECTORY SEARCH\n***********************************************************************\n* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *\n* TO THE NEXT SEQUENTIAL INSTRUCTION AND R14 IS SET TO ZERO.  IF THE  *\n* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *\n* AT +4 PAST HERE AND R14 IS NONZERO.                                 *\n***********************************************************************\n         LA    R14,0               IF SUCCESSFUL, SET R14 = 0\n         LM    R3,R9,32(R13)       RESTORE REGISTERS USED BY LPA SEARCH\n         LTR   R14,R14             IF COMMAND NAME WAS FOUND,\n         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...\n         LA    R0,D0MODULE         SET EPLOC PARAMETER FOR IDENTIFY\n         XR    R1,R1               SET ENTRY ADDRESS PARM FOR IDENTIFY\n         IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND\n         CH    R15,=H'8'           IF RC=8, COMMAND IS IN JPA\n         BE    TSEVENT             SO GO USE IT\n         CH    R15,=H'20'          IF RC=20, COMMAND IS IN JPA\n         BE    TSEVENT             SO GO USE IT\n         BLDL  0,D0BLDL            IF NONE OF THE ABOVE, TRY BLDL\n         LTR   R15,R15             SEE IF BLDL SUCCESSFUL\n         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND\n******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST\n         SPACE\nIMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST\n         MVC   D0MODULE,=CL8'EXEC' SET COMMAND NAME = \"EXEC\"\n         LH    R15,D0OFFSET        PICK UP OFFSET OF CLIST NAME\n         LTR   R15,R15             IF ZERO OFFSET, THEN IGNORE\n         BNP   AFTBLNKX\n         BCTR  R15,0               REDUCE FOR EXECUTE\n         BCTR  R15,0               AND FOR MOVE CHARACTERS\n         MVI   4(R5),C' '          SET BUFFER PRECEDING CLIST NAME\n         EX    R15,MVCBLANK         TO BLANKS\nAFTBLNKX XC    2(2,R5),2(R5)       SET COMMAND BUFFER OFFSET = ZERO\n         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         SPACE\nTSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND\n         SPACE\n***********************************************************************\n* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *\n* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *\n* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *\n* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *\n* AS THIS UTILITY WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *\n***********************************************************************\n         SPACE\n         L     R1,ECTPCMD\n         L     R15,ECTPCMD+4\n         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND\n         XR    R15,R15             INDICATE COMMAND IS OK\n         B     CKCMDRET            AND RETURN\n         SPACE\nNGCMD    DS    0H                  COMMAND NOT VALID (TEST, ETC.)\n         MVC   D0MSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE\n         MVC   D0MSG+L'TESTMSG1(8),D0COMMND  MOVE IN COMMAND NAME\n         LA    R1,D0MSG+L'TESTMSG1 POINT TO BEGINNING OF NAME\n         LA    R14,8               MAX COUNT FOR NAME LENGTH\nNGLOOP   CLI   0(R1),C' '          SCAN FOR FIRST BLANK\n         BE    NGBLANK              FOLLOWING COMMAND NAME\n         LA    R1,1(,R1)             UNTIL\n         BCT   R14,NGLOOP             LENGTH OF NAME EXHAUSTED\nNGBLANK  DS    0H\n         MVC   0(L'TESTMSG2,R1),TESTMSG2  MOVE END OF MESSAGE\n         LA    R0,L'TESTMSG2(,R1)  END OF MESSAGE\n         LA    R14,D0MSG           MINUS BEGINNING OF MESSAGE\n         SLR   R0,R14              GIVES LENGTH OF MESSAGE\n         XR    R1,R1               INDICATE MESSAGE ALREADY BUILT\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         LA    R15,8               INDICATE COMMAND INVALID\nCKCMDRET L     R14,D0CKCM14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nMVCBLANK MVC   5(0,R5),4(R5)       FINISH MOVING BLANKS INTO CMD BUFFER\n         SPACE\nTESTMSG1 DC    C'XHX004I COMMAND INTERFACE DOES NOT SUPPORT THE '\nTESTMSG2 DC    C' COMMAND'\n         SPACE\n         LTORG\n         TITLE 'HELPEXIT - ATTACH SUBROUTINE'\nATTACH   DS    0H\n         SPACE\n         ST    R14,D0ATT14         SAVE RETURN REGISTER\n         LR    R1,R3               POINT TO CPPL\n         XC    D0CMDECB,D0CMDECB   CLEAR ATTACH ECB\n         XC    D0ATNECB,D0ATNECB   CLEAR ATTENTION ECB\n         NI    D0FLAGS,255-D0SUBER CLEAR ERROR FLAG\n         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG\n         ATTACH EPLOC=D0MODULE,SF=(E,D0ATTACH),ECB=D0CMDECB,           X\n               STAI=(STAIEXIT,DATD0)     ATTACH THE COMMAND\n         LTR   R15,R15             IF ATTACH FAILED,\n         BZ    ATTACHOK            THEN\n         LA    R1,=C'ATTACH'        BLOW UP\n         LA    R0,6\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\nATTACHOK DS    0H\n         ST    R1,DA2CTCB          SAVE TCB ADDRESS\n         WAIT  1,ECBLIST=D0ECBLST  WAIT FOR COMPLETION OR ATTENTION\n         L     R1,DA2CTCB          GET TCB ADDRESS\n         MVC   ECTRTCD,17(R1)      MOVE TCB COMPLETION CODE TO ECT\n         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED\n         XC    D0ECB,D0ECB         CLEAR ECB\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE\n         ST    R15,D0DAIRRC        SAVE DAIR RETURN CODE\n         LA    R1,DA2CTCB\n         DETACH (1),STAE=YES       DETACH THE COMMAND\n         CH    R15,=H'4'           IF DETACH FAILED,\n         BNH   DETACHOK\n         LA    R1,=C'DETACH'        BLOW UP\n         LA    R0,6\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\nDETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH\n         ICM   R15,15,D0DAIRRC     IF DAIR RETURN CODE NOT ZERO,\n         BZ    DAIROK              THEN...\n         LA    R1,=C'DAIR'          BLOW UP\n         LA    R0,4\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\nDAIROK   DS    0H\n         SPACE\n         CLI   D0STATUS,D0ATTN     IF COMMAND TERMINATED BY ATTENTION,\n         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK\n         CLI   D0STATUS,D0ABEND    ELSE IF THE COMMAND ABENDED,\n         BNE   ATTRET              THEN\n         OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT\n         LA    R1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH\n         B     FLUSHCMD             AND FLUSH THE INPUT STACK.\nATTFLUSH LA    R1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH\nFLUSHCMD BAL   R14,FLUSH           FLUSH THE INPUT STACK\nATTRET   L     R14,D0ATT14         RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         TITLE 'HELPEXIT - PUTGET SUBROUTINE'\n***********************************************************************\n* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *\n* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *\n* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *\n* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *\n* USER IS IN A CLIST AND THE \"NOPAUSE\" PROFILE OPTION IS ACTIVE), IT  *\n* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *\n* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *\n* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *\n* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS \"TRICK\" WAS   *\n* USED IN SPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.          *\n***********************************************************************\n         SPACE\nPUTGET   DS    0H\n         ST    R14,D0PG14          SAVE RETURN REGISTER\nPGRETRY  DS    0H\n         XC    D0ECB,D0ECB         CLEAR ECB\n         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET\n         CH    R15,=H'24'          IF RETURN CODE GREATER THAN 24,\n         BH    PGERROR              THEN BLOW UP\n         B     PGGO(R15)           ELSE PROCESS EACH POSSIBLE R.C.\nPGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL\n         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST\n         B     PUTGET8         8 = ATTENTION INTERRUPTION\n         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE\n         B     PGERROR        16 = ERROR\n         B     PGERROR        20 = ERROR\n         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT\n         SPACE\nPUTGET8  MVI   D0STATUS,D0ATTN     RC=8: INDICATE ATTENTION INTERRUPT\n         B     PGRETURN              AND RETURN\nPUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,\n         BO    PGERROR                    THEN UNRECOVERABLE ERROR\n         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN\n         B     PGRETRY                AND REISSUE PUTGET\nPGERROR  OI    D0FLAGS,D0SUBER     BAD RETURN CODE, UNRECOVERABLE ERROR\n         B     PGRETURN            SO JUST RETURN.\nPGGOTLN  OI    D0FLAGS,D0GOTLN     INDICATE A PUTGET BUFFER OBTAINED\nPGRETURN L     R14,D0PG14          RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         TITLE 'HELPEXIT - PUTLINE SUBROUTINE'\n***********************************************************************\n* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *\n* PUTLINE SERVICE ROUTINE.  AT ENTRY R1 CONTAINS THE ADDRESS OF THE   *\n* MESSAGE TO BE DISPLAYED, AND R0 CONTAINS THE LENGTH OF THE MESSAGE. *\n* IF R1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *\n* D0MSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *\n* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *\n* STRIPPED OFF BY PUTLINE ANYHOW.                                     *\n* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *\n* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *\n* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *\n***********************************************************************\n         SPACE\nPUTLINE  DS    0H\n         ST    R14,D0PUTL14        SAVE RETURN REGISTER\n         BALR  R8,0                SET UP LOCAL ADDRESSABILITY\n         USING *,R8\n         DROP  R12\n         LTR   R15,R0              LOAD LENGTH VALUE\n         BNP   PUTLRET             IF ZERO, DON'T DO ANYTHING\n         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTE\n         LTR   R1,R1               IF R1 IS ZERO,\n         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...\n         EX    R15,MOVEPUT         MOVE MESSAGE TO WORK AREA\nPUTIT    DS    0H\n         LA    R15,5(,R15)         RESTORE LENGTH + 4 FOR HEADER\n         SLL   R15,16              SHIFT LENGTH INTO LEFT HALF OF HDR\n         STCM  R15,15,D0MSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR\n         XC    D0ECB,D0ECB         CLEAR ECB\n         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE\n         LTR   R15,R15             IF PUTLINE OK\n         BZ    PUTLRET             THEN RETURN\n         CH    R15,=H'8'           ELSE IF ATTENTION INTERRUPT\n         BNE   PUTERROR            THEN\n         MVI   D0STATUS,D0ATTN      INDICATE SO\n         B     PUTLRET             ELSE PUTLINE ERROR\nPUTERROR LA    R1,BADPUT\n         LA    R0,L'BADPUT\n         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT\nPUTLRET  L     R14,D0PUTL14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nMOVEPUT  MVC   D0MSG(0),0(R1)      MOVE MESSAGE TO WORK AREA\nBADPUT   DC    C'*** COMMAND INTERFACE PUTLINE FAILURE ***'\n         SPACE\n         LTORG\n         SPACE\n         USING HELPEXIT,R12\n         DROP  R8\n         TITLE 'HELPEXIT - FLUSH SUBROUTINE'\n***********************************************************************\n* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *\n* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *\n* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *\n* ADDITIONAL SUBCOMMANDS \"STACKED\" WITH FIELD MARKS ARE NOT EXECUTED. *\n* ON ENTRY TO THIS SUBROUTINE R1 POINTS TO THE LIST FORM OF THE STACK *\n* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *\n* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *\n* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *\n* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *\n* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *\n* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *\n***********************************************************************\n         SPACE\nFLUSH    DS    0H\n         ST    R14,D0FLSH14        SAVE RETURN REGISTER\n         MVC   D0STACK(LSTACKL),0(R1)  SET UP STACK LIST FORM\n         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE\n         XC    D0ECB,D0ECB         CLEAR ECB\n         STACK PARM=D0STACK,MF=(E,IOPL)  FLUSH THE STACK\n         LTR   R15,R15             IF STACK FAILED\n         BZ    FLUSHRET            THEN SAY SO\n         LA    R1,BADSTACK\n         LA    R0,L'BADSTACK\n         BAL   R14,PUTLINE\nFLUSHRET MVC   D0RETCD,=F'12'      SET RETURN CODE TO 12 WHEN FLUSHING\n         L     R14,D0FLSH14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nBADSTACK DC    C'XHX007I COMMAND INTERFACE STACK ERROR'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R11,R12\n         TITLE 'HELPEXIT - STAI EXIT FOR ABENDING COMMANDS'\nSTAIEXIT DS    0H\n         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER\n         USING STAIEXIT,R12\n         LA    R3,12               CHECK IF REGISTER 0 = \"12\"\n         CR    R0,R3               IF AN SDWA IS AVAILABLE,\n         BE    NOSDWA              THEN...\n         LM    R10,R11,0(R1)        R10 -> WORKAREA, R11 = ABEND CODE\n         B     AFTSDWA             ELSE...\nNOSDWA   LR    R10,R2               R10 -> WORKAREA\n         LR    R11,R1               R11 = ABEND COMPLETION CODE\nAFTSDWA  DS    0H\n         ST    R14,D0STAI14        SAVE RETURN REGISTER\n         L     R4,IOPLECT          ESTABLISH ADDRESSABILITY TO ECT\n         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED\n         STCM  R11,7,D0ABCODE      STORE ABEND CODE\n         SPACE\n***********************************************************************\n* DISPLAY \"ENDED DUE TO ERROR\" MESSAGE                                *\n***********************************************************************\n         SPACE\n         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE\n         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095\n         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND\n         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO\n         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN\n         MVZ   D0SYSTEM(3),=X'000000'\n         TR    D0SYSTEM(3),=C'0123456789ABCDEF'\n         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE\n         B     ANYABEND                     GO TO DISPLAY IT\nUSRABEND MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND\n         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         XR    R0,R0\n         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE\n         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY\n         UNPK  D0USER(4),D0DOUBLE\n         OI    D0USER+3,X'F0'\n         LA    R0,D0USERL                   GET LENGTH OF MESSAGE\nANYABEND DS    0H\n         XR    R1,R1               INDICATE MESSAGE SET UP\n         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE\n         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE\n         LA    R15,16              LET ABEND CONTINUE WITHOUT ESTAI\n         L     R14,D0STAI14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nABEMSGID DC    C'XHX003I '\nABEMSG1  DC    C' ENDED DUE TO ERROR, '\nABEMSG2  DC    C' ABEND CODE '\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'HELPEXIT - STAE EXIT FOR INTERNAL ABEND'\nSTAEEXIT DS    0H\n         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER\n         USING STAEEXIT,R12\n         LA    R3,12               CHECK IF REGISTER 0 = \"12\"\n         CR    R0,R3               IF AN SDWA IS AVAILABLE,\n         BE    NOSDWAE             THEN...\n         L     R10,0(,R1)           R10 -> WORKAREA\n         B     AFTSDWAE            ELSE...\nNOSDWAE  LR    R10,R2               R10 -> WORKAREA\nAFTSDWAE DS    0H\n         L     R15,IOPLECT         ESTABLISH ADDRESSABILITY TO ECT\n         USING ECT,R15\n         MVC   ECTPCMD(16),D0CMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES\n         XR    R15,R15             CONTINUE WITH ABNORMAL TERMINATION\n         BR    R14                 AND RETURN\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12,R15\n         TITLE 'HELPEXIT - STAX EXIT FOR ATTENTION INTERRUPT'\nSTAXEXIT DS    0H\n         SPACE\n         LR    R12,R15             SAVE ENTRY ADDRESS\n         USING STAXEXIT,R12\n         L     R10,8(,R1)          GET ADDRESS OF USER PARAMETER LIST\n         LR    R7,R14              SAVE RETURN ADDRESS\n         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE\n         MVI   D0STATUS,D0ATTN     INDICATE ATTENTION OCCURRED\n         POST  D0ECB,0             POST SERVICE ROUTINES ECB\n         POST  D0ATNECB,0          POST ECB FOR COMMAND ATTACH\n         BR    R7                  RETURN TO SYSTEM\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         USING HELPEXIT,R12\n         USING DATD1,R11\n         TITLE 'HELPEXIT - DATA AREAS'\nDATD0    DSECT\n         SPACE\nD0SAVE   DS    9D                  OS SAVE AREA\nD0DOUBLE DS    D                   FOR NUMERIC CONVERSIONS\nD0SCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE\nD0CKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE\nD0ATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE\nD0PUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE\nD0PG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE\nD0FLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE\nD0STAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE\nD0ECB    DS    F                   ECB FOR TSO SERVICE ROUTINES\nD0CMDECB DS    F                   ECB FOR ATTACHED COMMANDS\nD0ATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS\nD0ECBLST DS    2A                  ECB LIST\nD0PLADDR DS    A                   ADDRESS OF PUTLINE SUBROUTINE\n         SPACE\nD0CPPL   DS    4A                  CPPL FOR ADDITIONAL COMMANDS\n         ORG   D0CPPL\nD0CBUF   DS    A                   ADDRESS OF COMMAND BUFFER\n         DS    3A                  REST OF CPPL\n         SPACE\nIOPL     DS    0F\n         SPACE\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\n         SPACE\nPTPB     DS    0F\n         SPACE\n***********************************************************************\n*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *\n*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *\n*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL4      INTERNAL PUTLINE USAGE\nPTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE\nPTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=\n*                       ADDR,FORMAT) IS SPECIFIED\n         SPACE\nPGPB     DS    0H\n         SPACE\n***********************************************************************\n*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *\n*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *\n*    RETURNING INFORMATION.                                           *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL12     INTERNAL TO GETLINE/PUTLINE\nPGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE\n         SPACE\nSTPB     DS    0F\n         SPACE\n***********************************************************************\n*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *\n*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *\n*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *\n*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *\n*    SOURCE DESCRIPTOR (LSD), INPUT AND OUTPUT DDNAMES, AS WELL AS    *\n*    FOR CONTROL.                                                     *\n***********************************************************************\n         SPACE\n         DS    CL4      INTERNAL TO STACK\nSTPBALSD DS    A        ADDR OF (STORAGE) LIST SOURCE DESCRIPTOR\nSTPBINDD DS    A        ADDR OF INPUT DDNAME\nSTPBOTDD DS    A        ADDR OF OUTPUT DDNAME\nSTPBMBRN DS    A        ADDR OF MEMBER NAME\n         SPACE\nDAPL     DS    0F\n         SPACE\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\n         SPACE\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         SPACE\nDAPB2C   DS    0F\n         SPACE\n***********************************************************************\n* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *\n* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *\n* WHICH ATTACHES SUB-TASKS                                            *\n***********************************************************************\n         SPACE\nDA2CCD   DS    CL2      DAIR ENTRY CODE\nDA2CFLG  DS    H        FLAG FIELD\nDA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE\nDA2CDDN  DS    CL8        DDNAME\n         SPACE\nD0STACK  STACK MF=L,DELETE=ALL\n         SPACE\nD0ATTACH ATTACH SF=L\n         SPACE\nD0ESTAE  ESTAE MF=L\n         SPACE\nD0STAX   STAX  MF=L\n         SPACE\nD0PREFIX DS    F                   SAVED COMMAND BUFFER PREFIX\nD0ORGBUF DS    F                   ADDRESS OF \"HELP X\" COMMAND BUFFER\nD0RETCD  DS    F                   RETURN CODE FROM COMMAND\nD0DAIRRC DS    F                   RETURN CODE FROM IKJDAIR\nD0SCANRC DS    H                   RETURN CODE FROM IKJSCAN\nD0STKLVL DS    H                   ORIGINAL STACK LEVEL (* 4)\nD0OFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME\nD0CMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND\nD0COMMND DS    CL8                 COMMAND NAME FROM SCAN\n         CNOP  4,8                 FORCE D0MODULE ALIGNMENT\nD0BLDL   DS    Y(1,12)             BLDL LIST FOR COMMAND CHECK\nD0MODULE DS    CL8                 MODULE NAME FOR COMMAND\n         DS    XL4                 FILLER FOR BLDL\nD0ABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT\nD0FLAGS  DS    X                   FLAGS\nD0X1     EQU   B'10000000'          1 = HELP X (NOT XX) WAS ENTERED\nD0EXEC   EQU   B'01000000'          1 = IMPLICIT EXEC COMMAND (%)\nD0BUFMOD EQU   B'00100000'          1 = COMMAND BUFFER WAS ALTERED\nD0ECTMOD EQU   B'00010000'          1 = ECT PCMD/SCMD WAS ALTERED\nD0ESTON  EQU   B'00001000'          1 = ESTAE SUCCESSFUL\nD0STXON  EQU   B'00000100'          1 = STAX SUCCESSFUL\nD0SUBER  EQU   B'00000010'          1 = SEVERE ERROR IN SUBROUTINE\nD0GOTLN  EQU   B'00000001'          1 = PUTGET BUFFER TO BE FREED\nD0STATUS DS    X                   COMMAND STATUS FLAG\nD0NORMAL EQU   0                    COMMAND COMPLETED NORMALLY\nD0ATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED\nD0ABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED\n         SPACE\n***********************************************************************\n* PUTGET MODE MESSAGE AREA                                            *\n***********************************************************************\n         SPACE\nD0PGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nD0PGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nD0PGHDR  DS    2Y                  MESSAGE HEADER\nD0PGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT\n         SPACE\n***********************************************************************\n* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *\n* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *\n***********************************************************************\n         SPACE\nD0MSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nD0MSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nD0MSGHDR DS    2Y                  MESSAGE HEADER\nD0MSG    DS    CL128               MESSAGE TEXT\nD0MSG1   EQU   D0MSG+L'ABEMSGID    OFFSET OF \"ENDED DUE TO ERROR\"\nD0MSG2   EQU   D0MSG1+8+L'ABEMSG1  OFFSET OF \"SYSTEM\" OR \"USER\"\nD0SYSTEM EQU   D0MSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE\nD0USER   EQU   D0MSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE\nD0SYSL   EQU   D0SYSTEM+3-D0MSG    LENGTH OF SYSTEM ABEND MESSAGE\nD0USERL  EQU   D0USER+4-D0MSG      LENGTH OF USER ABEND MESSAGE\n         SPACE 2\nSIZDATD0 EQU   *-DATD0\n         EJECT\nDATD1    DSECT\n         SPACE\n***********************************************************************\n* ALL STORAGE USED BY IKJSCAN IS ALLOCATED IN SUBPOOL 1 BECAUSE       *\n* THAT'S WHAT WE WERE TOLD TO DO BY THE GUIDE TO WRITING A TMP OR A   *\n* COMMAND PROCESSOR.                                                  *\n***********************************************************************\n         SPACE\nCSPL     DS    0D\n         SPACE\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         SPACE\nCSOA     DS    0H\n         SPACE\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN\n         DS    CL1      RESERVED\n         SPACE\nD1CSFLG  DS    F                   COMMAND SCAN FLAG WORD\n         SPACE 2\nSIZDATD1 EQU   *-DATD1\n         EJECT\nHELPEXIT CSECT\n         IKJCPPL\nHELPEXIT CSECT\n         IKJECT\nHELPEXIT CSECT\n         CVT   DSECT=YES\n         END\n./ ADD NAME=IKJEFF10 0100-07332-07332-0900-02393-02393-00000-SEB\n         TITLE 'IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE'\n         MACRO\n&SYM     EMIT  ,\n         LCLC  &LABEL\n&LABEL   SETC  'EMIT&SYSNDX'\n&SYM     ST    R6,JWASAVE6\n         LA    R14,&LABEL\n         ST    R14,JWARET            Save continuation address\n         BAL   R14,INSERTOP          Try to insert the operand\n         ICM   R0,15,JWAUPTR         If it wasn't all moved\n         BNZ   CRETURN               then return to try it on next card\n&LABEL   DS    0H                    Resume processing here once OK\n         MEND\n         EJECT\n         MACRO\n&SYM     NEXT  ,\n&SYM     L     R6,JWAONEXT           Get address of end of prev operand\n         LA    R6,1(,R6)             Bump to next operand\n         BAL   R14,SCANCOMA          Get a JCL operand\n         ST    R15,JWAONEXT          Save address of following operand\n         MEND\n         EJECT\n         MACRO\n&SYM     TELL  &MSG\n&SYM     L     R1,=A(&MSG)\n         LA    R0,L'&MSG\n         TPUT  (1),(0),R\n         MEND\n         TITLE 'IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE'\n***********************************************************************\n*                                                                     *\n* IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Module:  IKJEFF10                                                  *\n*                                                                     *\n*  Version:  5                                                        *\n*  Mod:      0                                                        *\n*                                                                     *\n*  This is a TOTAL REWRITE of the Draper SUBMIT exit.                 *\n*                                                                     *\n*  Previous Status:                                                   *\n*                                                                     *\n*    VERSION 1 MOD 0     21 MARCH 1977     OS/VS2 RELEASE 1           *\n*    VERSION 2 MOD 0        MAY   1979     OS/VS2 RELEASE 1           *\n*     (A MAJOR REWRITE TO SUPPORT ACCT * AND USERIDS OF LESS          *\n*     THAN 7 CHARACTERS.  ORIGINAL ROUTINE WAS HACKED TO              *\n*     PIECES BY THIS REWRITE.)                                        *\n*    VERSION 3 MOD 0        JULY  1980     HSM/EASY READER SUPPORT    *\n*    VERSION 3 MOD 0        JAN 5,1982 INSTALLED INTO SP1.1. IPO      *\n*                           WITHOUT MODIFICATION                      *\n*    VERSION 3 MOD 1        OCTOBER 1982   FIXED THE FOLLOWING BUGS:  *\n*                        GENERATED JOB STATEMENT CHECK CORRECTED TO   *\n*                        LOOK FOR THE CORRECT LITERAL IN COLUMN 31    *\n*    VERSION 4 MOD 0        JULY 1983      ADDED NEW FUNCTION TO      *\n*                        PROMPT FOR PASSWORD AND INSERT IT WHEN A     *\n*                        /*PASSWORD CARD WITH NO PASSWORD IS FOUND    *\n*    VERSION 4 MOD 0        AUG 16,1984 INSTALLED INTO SP2.1.2 (XA)   *\n*                           WITHOUT MODIFICATION                      *\n*                                                                     *\n*    Version 5 Mod 0     January 1987                                 *\n*                                                                     *\n*                        Rewritten to handle any number of            *\n*                        transformations of the operands on the       *\n*                        JOB statement, including but not limited to: *\n*                                                                     *\n*                        Replacing \"*\" with full account information  *\n*                        in the accounting field                      *\n*                                                                     *\n*                        Replacing \"*\" with full programmer name in   *\n*                        the programmer name field                    *\n*                                                                     *\n*                        Replacing \"*\" with the userid in the         *\n*                        NOTIFY field                                 *\n*                                                                     *\n*                        Inserting default TIME and REGION values     *\n*                        if not present on the JOB card               *\n*                                                                     *\n*  Note that the above items contain the feature of being able to     *\n*  generate a valid JOB card when none is provided by the user.       *\n*                                                                     *\n* Authors:                                                            *\n*                                                                     *\n*    DAVID A. LYNDE     C. S. DRAPER LABORATORY     CAMBRIDGE, MASS.  *\n*    GARY VINING (VERSION 2)                                          *\n*    STEVE PATTON (VERSION 3)                                         *\n*    STEVE BACHER (VERSION 3 MOD 1)                                   *\n*    STEVE BACHER (VERSION 4)                                         *\n*    Steve Bacher (Version 5)                                         *\n*                                                                     *\n*  Function:                                                          *\n*                                                                     *\n*  (1) To insure that the jobname conforms to installation convention *\n*      and to fill in defaulted information for programmer ease.      *\n*                                                                     *\n*  (2) To insure the availability of datasets referenced via          *\n*      //PROCLIB DD statements for EasyReader.                        *\n*                                                                     *\n*  (3) To prompt for ACF2 passwords in print-inhibit mode when a      *\n*      /*PASSWORD card is found, insuring integrity of the JCL.       *\n*                                                                     *\n*  Installation Jobname Conventions:                                  *\n*                                                                     *\n*      The first n-1 characters of the jobname must be comprised of   *\n*      the characters of the submitter's userid.                      *\n*                                                                     *\n*      If the accounting information is set to \"*\" or omitted, the    *\n*      logon account number and room ID are inserted in its place.    *\n*                                                                     *\n*      If the programmer name field is set to \"*\" or omitted, the     *\n*      TSO userid is inserted in its place.                           *\n*                                                                     *\n*      If the value in the NOTIFY field is \"*\", the TSO userid is     *\n*      inserted in its place.                                         *\n*                                                                     *\n*      If the TIME operand is missing, a default value is provided.   *\n*                                                                     *\n*      If the REGION operand is missing, a default value is provided. *\n*                                                                     *\n*  EasyReader Support:                                                *\n*                                                                     *\n*      If an EasyReader //PROCLIB DD statement is used in the         *\n*      submitted JCL, the proclib(s) is/are recalled if it is         *\n*      HSM migrated.  The proclib is allocated and opened to          *\n*      set the reference date to today's date.                        *\n*                                                                     *\n*  /*PASSWORD Processing:                                             *\n*                                                                     *\n*      If a /*PASSWORD card is found and it contains no password,     *\n*      and the foreground terminal is available, the user is prompted *\n*      (in print-inhibit mode, naturally) to enter the password,      *\n*      which will be inserted on the card.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  Entry Point:  IKJEFF10                                             *\n*                                                                     *\n*  Linkage:      Loaded (by IKJEFF04) and called (by IKJEFF09)        *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     Register 1 points to a word which points to the following list: *\n*                                                                     *\n*     +00  IECARDP   Pointer to current statement                     *\n*     +04  IEMSGP    Pointer to message                               *\n*     +08  IEREPLYP  Pointer to response                              *\n*     +0C  IEUSRIDP  Pointer to userid                                *\n*     +10  IESUBCTP  Pointer to JCL exit switch bytes                 *\n*     +14  IEEXITWD  Word for exit's use (initially zero,             *\n*                    retains value assigned by the exit)              *\n*     +18  IEACCTIP  Pointer to accounting information                *\n*     +1C  IEACCTLP  Pointer to 2-byte length of accounting info      *\n*                                                                     *\n*  JCL exit switch bytes at +10 (IESUBCTP->IESUBCTD) are as follows:  *\n*                                                                     *\n*     +0  IETAKEEX  Take exit for statement if corresponding bit is 1 *\n*                                                                     *\n*   IETJOB   (B'10000000')  -  JOB          (// JOB      )            *\n*   IETEXEC  (B'01000000')  -  EXEC         (// EXEC     )            *\n*   IETDD    (B'00100000')  -  DD           (// DD       )            *\n*   IETCMD   (B'00010000')  -  Command      (// command  )            *\n*   IETNULL  (B'00001000')  -  Null         (//          )            *\n*   IETJES   (B'00000100')  -  JES2 Command (/*nonblank  )            *\n*   IETCOMNT (B'00000010')  -  Comment      (//*         )            *\n*   IETJES3  (B'00000001')  -  JES3 Command (//*nonblank )            *\n*                                                                     *\n*     +1  IEOPRAND  If nonzero, gives the card image column that the  *\n*                   operand field starts in (one-origined)            *\n*                                                                     *\n*     +2  IESTMTYP  Current statement switches                        *\n*                                                                     *\n*   IESJOB   (B'10000000')  -  JOB          (// JOB      )            *\n*   IESEXEC  (B'01000000')  -  EXEC         (// EXEC     )            *\n*   IESDD    (B'00100000')  -  DD           (// DD       )            *\n*   IESCMD   (B'00010000')  -  Command      (// command  )            *\n*   IESNULL  (B'00001000')  -  Null         (//          )            *\n*   IESOPCON (B'00000100')  -  Operand to be continued                *\n*   IESSCON  (B'00000010')  -  Statement to be continued              *\n*   IESCONTN (B'00000001')  -  Statement is a continuation            *\n*                                                                     *\n*     +3  IESTMTP2  Current statement switches, continued             *\n*                                                                     *\n*   IESJES   (B'10000000')  -  JES2 Command (/*nonblank  )            *\n*   IESCOMNT (B'01000000')  -  Comment      (//*         )            *\n*   IESJES3  (B'00100000')  -  JES3 Command (//*nonblank )            *\n*                                                                     *\n*            (B'00011111') reserved.                                  *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*     A completely new JOB card is constructed from the contents of   *\n*     the existing (or SUBMIT-generated) JOB card.  All of the        *\n*     operands from the JOB card and its continuations are read into  *\n*     a buffer; when the last such card is read, a series of new      *\n*     JOB cards and continuations are constructed with the operands   *\n*     collected, any transformations or additions being handled at    *\n*     this point.  Thus, the new JOB card shares nothing with the     *\n*     old, other than its contents.                                   *\n*                                                                     *\n*     The jobname constructed by this routine consists of N           *\n*     characters with the first N-1 of them equal to the userid       *\n*     and the last character the same as the last character of        *\n*     the original user-supplied jobname.                             *\n*                                                                     *\n*     If an ACF2 \"PASSWORD\" card with no password on it appears in    *\n*     the input stream, this exit will prompt the user to enter the   *\n*     password (in print-inhibit mode, naturally) and the password    *\n*     will be placed on the output card.  Note that ACF2 recognizes   *\n*     only the following forms of the \"PASSWORD\" card:                *\n*                                                                     *\n*        /*PASSWORD     (with no intervening blanks)                  *\n*        //*PASSWORD    (with no intervening blanks)                  *\n*        // PASSWORD    (with one intervening blank)                  *\n*                                                                     *\n*     Since JES2 flags the last as a JCL error, only the first two    *\n*     forms are valid and are the only ones checked by this exit.     *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*     Return to IKJEFF09 with one of the following return codes:      *\n*                                                                     *\n*     RC=0  IECONTIN  Exit processing complete                        *\n*                                                                     *\n*     RC=4  IERETURN  Additional job card created, return for         *\n*                     continuation of JOB statement                   *\n*                                                                     *\n*     RC=8  IEMSG     Exit routine is returning a message to be       *\n*                     issued                                          *\n*                                                                     *\n*     RC=12 IEPROMPT  Issue message IKJ56283I for exit and reenter    *\n*                     exit.  Exit must obtain message text area and   *\n*                     may free it when reentered.                     *\n*                                                                     *\n*     RC=16 IEABORT   Terminate the SUBMIT command.  Return code 8    *\n*                     should be used first to issue an error message. *\n*                                                                     *\n*  External References:                                               *\n*                                                                     *\n*     Routines - none                                                 *\n*     Data Areas - Parameters passed in parameter list                *\n*                                                                     *\n*  Data areas:                                                        *\n*                                                                     *\n*     Work area for communication between calls to this exit          *\n*     Work area for building JOB statement                            *\n*                                                                     *\n*  Macros:                                                            *\n*                                                                     *\n*     The usual gang of idiots                                        *\n*                                                                     *\n*  Attributes:                                                        *\n*                                                                     *\n*     RENT, REUS                                                      *\n*                                                                     *\n*  Notes:                                                             *\n*                                                                     *\n*     This exit may be tested with a driver available from IPO, or    *\n*     alternatively with the DRIVERSU driver.  Inquiries should be    *\n*     directed to SEB1525.                                            *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*  Change Activity                                                    *\n*                                                                     *\n*     05/19/87 - Added check for JOB card continuations that    #EXIT28\n*                are not satisfied, since these produce         #EXIT28\n*                obscure failures if such a job gets submitted. #EXIT28\n*                                                                     *\n*     10/11/88 - Change /*PASSWORD to //*PASSWORD to avoid      #EXIT32\n*                loss of support and/or integrity due to        #EXIT32\n*                JES2 exit 4 peculiarities.                     #EXIT32\n*                                                                     *\n*     10/27/88 - When allocating the data set specified on a    #EXIT33\n*                //PROCLIB DD statement to force HSM recall,    #EXIT33\n*                use DISP of SHR rather than OLD.               #EXIT33\n*                                                                     *\n*     04/20/89 - Fixed 0C4 when many JOB continuations used.    #EXIT34\n*                The userid must be copied into the JWA; it     #EXIT34\n*                is not sufficient to store the pointer.        #EXIT34\n*                                                               #EXIT34\n*                                                                     *\n*     05/17/89 - Changed region supplied from 6M to 9M.         #EXIT35\n*     08/07/89 - Changed region supplied from 9M to 10M.        #EXIT36\n*                                                               #EXIT42\n*     11/19/90 - Small fix to see if the problem introduced by  #EXIT42\n*                IBM PTF UY39507 can be averted.  This has to   #EXIT42\n*                do with comments between parts of job cards.   #EXIT42\n*                                                               #EXIT42\n*     11/26/90 - Extend /*PASSWORD prompting to the PASSWORD=   #EXIT43\n*                operand of the JOB statement.                  #EXIT43\n*                                                               #EXIT43\n*     05/06/92 - React to IBM fix for APAR OY37954.  SUBMIT no  #EXIT48\n*                longer sets the JOB bit on for comment cards   #EXIT48\n*                in the middle of a JOB continuation sequence.  #EXIT48\n*                                                               #EXIT48\n***********************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    JOB card operand pointer\nR4       EQU   4    Miscellaneous uses\nR5       EQU   5    Miscellaneous uses\nR6       EQU   6    Used for scanning JOB card operands\nR7       EQU   7    Base register for SUBMIT JCL control information\nR8       EQU   8    Pointer to TSO userid; pointer to JOB operands\nR9       EQU   9    Current JCL card base register\nR10      EQU   10   Work area base register\nR11      EQU   11   Parameter list base register\nR12      EQU   12   Static program base register\nR13      EQU   13   Dynamic base register and save area pointer\nR14      EQU   14\nR15      EQU   15\n         EJECT\nIKJEFF10 CSECT\n         SAVE  (14,12),,IKJEFF10_&SYSDATE._&SYSTIME             #EXIT32\n         LR    R12,R15             Set program base\n         USING IKJEFF10,R12\n         L     R11,0(,R1)          Get address of parameter list\n         USING IEDSECTD,R11\n         L     R7,IESUBCTP         Get address of JCL control switches\n         USING IESUBCTD,R7\n         SPACE 1\n         USING JWA,R10             Workarea address always in R10\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Determine which path to take.                                       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Test message pointer.  If it is nonzero, we are being called to     *\n* display a message - which means that this exit detected an error    *\n* the last time it was called and had returned code 8 or 12.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   R1,15,IEMSGP        If message pointer is nonzero, then\n         BNZ   MSGRTN              this is reentry to return message\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Otherwise, the message pointer is zero, meaning that either this    *\n* is the first call to the exit or the previous call returned a code  *\n* of 0 or 4.                                                          *\n*                                                                     *\n* We check the card pointer.  If it is zero, we are expected to       *\n* generate a new card and return it (the previous call returned code  *\n* 4).  If it is nonzero, we are expected to inspect the card and      *\n* proceed accordingly (the previous call returned code 0).            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   R9,15,IECARDP       If current statement pointer is zero\n         BZ    CONTCARD            then this is reentry to get new card\n*                                  else this is reentry for an old card\n         USING CARDSECT,R9\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Entry to process an input JCL card.                                 *\n*                                                                     *\n* Test JCL switches to determine what kind of card this is.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nJOBSTMT  DS    0H\n         SPACE 1\n         TM    IESTMTYP,IESJOB     If this is a JOB statement\n         BO    PJOB                then process JOB statement\n*                                  Else not JOB statement...    #EXIT28\n         ICM   R10,15,IEEXITWD     Get address of work area     #EXIT28\n         BZ    TRYCMD              If none, no JOB card yet, OK #EXIT28\n         TM    JWAFLAGS,JWAJCONT   If JOB continuation expected #EXIT28\n         BO    BADCJOB             then error - bad JOB card    #EXIT28\nTRYCMD   DS    0H                  Else valid non-JOB card      #EXIT28\n         TM    IESTMTYP,IESCMD     if this is a command statement\n         BZ    TRYEXEC             then...\n         TM    IESTMTYP,IESCONTN    if it's a continuation of command\n         BO    RETURN0              then just return (we don't care)\n         B     PCMD                 else go to process command card\nTRYEXEC  DS    0H                  else (not command statement)...\n         TM    IESTMTYP,IESEXEC    if this is an EXEC statement\n         BZ    TRYDD               then...\n*                                   turn off all return flags except\n         MVI   IETAKEEX,IETJOB      for the one that requests JOB\n         B     RETURN0              statements, and return\nTRYDD    DS    0H                  else (not EXEC statement)...\n         TM    IESTMTYP,IESDD      if this is a DD statement\n         BZ    TRYJES2             then...\n         CLI   CURRCARD+2,C' '      if this DD card is a concatenation\n*                                       or a continuation of a previous\n         BE    SETRFDT                   PROCLIB DD card, or\n         CLC   CURRCARD+2(7),=C'PROCLIB'  the DDNAME is PROCLIB,\n         BE    SETRFDT              then go to process PROCLIB DD\n         MVI   IETAKEEX,IETJOB      else come back just for JOB cards\n         B     RETURN0              and return to get another card\n         SPACE 1\nTRYJES2  DS    0H                  else (not DD statement)...\n         TM    IESTMTP2,IESJES     if this is a JES2 control statement\n         BZ    TRYJES3             then...\n*                                   see if it's an ACF2 PASSWORD card\n         CLC   CURRCARD+2(9),PASWORDB                           #EXIT32\n         BNE   RETURN0              if not, then return to get another\n         B     CKBLNKPW             else process /*PASSWORD card\nTRYJES3  DS    0H                  else (not JES2 statement)...\n         TM    IESTMTP2,IESJES3+IESCOMNT if not a //* statement\n         BZ    RETURN0                    or it's //* but not\n         CLC   CURRCARD+3(9),PASWORDB        a //*PASSWORD card #EXIT32\n         BNE   RETURN0                  then return to get another\n*                                       else it's a //*PASSWORD card\nCKBLNKPW DS    0H                  Process ACF2 PASSWORD statement\n         SPACE 1\n*                                                               #EXIT32\n*************************************************************** #EXIT32\n*                                                               #EXIT32\n* At this point CURRCARD contains either /*PASSWORD ... or      #EXIT32\n* //*PASSWORD ..., and there may or may not be a password       #EXIT32\n* present on the card.  We do two things:                       #EXIT32\n*                                                               #EXIT32\n*  (1) If there is no password, we prompt for one.              #EXIT32\n*                                                               #EXIT32\n*  (2) If the card is /*PASSWORD, we change it to //*PASSWORD.  #EXIT32\n*                                                               #EXIT32\n*************************************************************** #EXIT32\n*                                                               #EXIT32\n         CLC   CURRPSWD-1(60),BLANKS If there's already a password on\n         BNE   FIXPWDCD              the card, then go fix card #EXIT32\n         LA    R3,CURRPSWD           Else show where to fill in #EXIT43\n         BAL   R14,FILLINPW           the password and do it    #EXIT43\n*                                                               #EXIT32\n         SPACE 1                                                #EXIT32\nFIXPWDCD DS    0H                  Here to fix up PASSWORD card #EXIT32\n         SPACE 1                                                #EXIT32\n         TM    IESTMTP2,IESJES     If this is not a JES2 /* c'd #EXIT32\n         BZ    RETURN0             then return, no need to fix  #EXIT32\n         CLI   CURRCARD+11,C' '    If /*PASSWORD xxx (1 blank)  #EXIT32\n         BE    FIXPN1B             then (assume <= 8 bytes)...  #EXIT32\n         MVC   CURRLST9,CURRCARD+11 move password to temp area  #EXIT32\n         MVC   CURRCARD+12(9),CURRLST9 move back shifted over 1 #EXIT32\n         MVC   CURRLST9,BLANKS     blank out temp area          #EXIT32\nFIXPN1B  DS    0H                                               #EXIT32\n         MVC   CURRCARD(12),CSSSPASS Make it //*PASSWORD        #EXIT32\n         B     RETURN0             Return with good card        #EXIT32\n         EJECT\nPJOB     DS    0H                  Process JOB statement\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* First of all, if this is a comment embedded in a JOB statement,     *\n* throw it away.                                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    IESTMTP2,IESCOMNT   If this is a //* inside JOB stuff\n         BO    THROWCOM            then return asking for more  #EXIT42\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* JOB statement or continuation thereof.  There are four states:      *\n*                                                                     *\n*  (1) First card of a JOB statement (IESCONTN=0)                     *\n*      which is not to be continued  (IESOPCON=0,IESSCON=0)           *\n*                                                                     *\n*      (in other words, a wholly self-contained single JOB card)      *\n*                                                                     *\n*  (2) First card of a JOB statement (IESCONTN=0)                     *\n*      which is to be continued  (IESOPCON=1 or IESSCON=1)            *\n*                                                                     *\n*      (e.g. //ABC1234A JOB blah,blah,blah,                   X)      *\n*                                                                     *\n*  (3) Continuation of a JOB statement (IESCONTN=1)                   *\n*      which is not to be continued  (IESOPCON=0,IESSCON=0)           *\n*                                                                     *\n*      (e.g. //             NOTIFY=ABC1234                     )      *\n*                                                                     *\n*  (4) Continuation of a JOB statement (IESCONTN=1)                   *\n*      which is to be continued  (IESOPCON=1 or IESSCON=1)            *\n*                                                                     *\n*      (e.g. //             MSGCLASS=H,                       X)      *\n*                                                                     *\n*  Logic:                                                             *\n*                                                                     *\n*  (a) If this is the first or only card of a JOB statement, then     *\n*      allocate a new JOB statement workarea and place its address    *\n*      in IEEXITWD.  (If there's already a pointer to a workarea      *\n*      there, this is an internal error, but let it go - just be      *\n*      a nice fellow and freemain it.)                                *\n*                                                                     *\n*      Otherwise, this is a continuation card of a JOB statement,     *\n*      so we should already have seen the first card.  IEEXITWD       *\n*      must have a pointer in it, otherwise we have an internal       *\n*      error - we must blow up.                                       *\n*                                                                     *\n*  (b) Again, if this is the first or only JOB card, start by         *\n*      picking off the jobname (and checking for the presence of      *\n*      the 'JOB' verb just to be sure).  Begin picking off the        *\n*      operands, remembering that the first 2 are positional          *\n*      (the accounting information and the programmer name).          *\n*                                                                     *\n*  (c) Whether this is the first JOB card or a continuation,          *\n*      pick off all the operands, doing necessary processing for      *\n*      them as we go.                                                 *\n*                                                                     *\n*  (d) If this is the last or only JOB card (i.e. it is not being     *\n*      continued), then finish up the collecting of operands,         *\n*      first by adding any that were not provided and should be       *\n*      defaulted, and then by commencing card-insertion mode.         *\n*                                                                     *\n*      Up till now, we have been returning code 0 to ask for the      *\n*      next card, and setting IECARDP to zero to tell SUBMIT not      *\n*      to include these JOB cards in the output.  At this point,      *\n*      we start generating our own JOB cards - as many as it takes    *\n*      to hold all the operands - by building each card and returning *\n*      with code 4 to ask for another chance to insert a card.        *\n*                                                                     *\n*      When we finish, we return with code 0 instead of 4 to show     *\n*      that we have no more to insert.  At this point, free the       *\n*      workarea that we've been using.                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    IESTMTYP,IESCONTN   If first card of JOB statement\n         BO    PJOBCONT            then...\n         SPACE 1\n         ICM   R10,15,IEEXITWD      Get address of work area\n         BNZ   GOTTEN               If we don't have one, then...\n         LA    R2,JWADATA-JWA+JWAINCR Load initial work area size\n         LR    R0,R2                 Get into register for GETMAIN\n         GETMAIN R,LV=(0)            Acquire a work area\n         LR    R10,R1                Get its address\n         ST    R10,IEEXITWD          Store in exit parameter list\n         ST    R2,JWALEN             Store length in workarea\nGOTTEN   DS    0H                   We have a workarea...\n         XR    R0,R0                Make a zero\n         ST    R0,JWAOFF            Initialize operand offset to 0\n         ST    R0,JWACOUNT          Initialize output JCL card count\n         ST    R0,JWALSTOP          Initialize last-operand pointer\n         XC    JWAFLAGS,JWAFLAGS    Clear flags\n         MVC   JWANAME,BLANKS       Clear jobname\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Set flag to take exit for EXEC, DD, /*JES2 and //*JES3 statements   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         OI    IETAKEEX,IETEXEC+IETDD+IETJES+IETCOMNT+IETJES3\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Extract the jobname and make sure this is really a JOB card         *\n*                                                                     *\n* IECARDP  is the address of the card image                           *\n* IEUSRIDP is the address of the TSO userid (good to build JOB card)  *\n* IESUBCTP is how to get to the column of the operand field on card   *\n* IEACCTIP is the address of the user's accounting information        *\n* IEACCTLP is the address of the halfword length of that information  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R8,IEUSRIDP         Get address of TSO userid\n         USING USERSECT,R8\n         LA    R4,USERID+6         Get pointer to end of userid\nUIDLOOP  DS    0H                  Loop back until last nonblank found\n         CLI   0(R4),C' '\n         BNE   UIDEND\n         BCT   R4,UIDLOOP\nUIDEND   DS    0H\n         LA    R1,USERID\n         SR    R4,R1               Compute length of userid minus 1\n         ST    R4,JWAUIDL          Save length of userid minus 1\n         EX    R4,MVCUID           Move userid to JWAUID        #EXIT34\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Initialize card scan pointer and locate last character of input     *\n* jobname (if any)                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nINITSCAN DS    0H\n         SPACE 1\n         LA    R1,CURRCARD+1       Initialize card scan pointer\n         BAL   R14,SCANBLAN        Locate blank which delimits jobname\n         BCTR  R15,0               Decrement card scan ptr to last char\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the jobname found on the card is valid, save it.                 *\n* Otherwise set new jobname from userid plus last character of        *\n* jobname if it is valid, else a default jobname character.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         EX    R4,UIDCOMP1         If jobname matches userid\n         BNE   NEWJOBCH             and\n         TRT   0(1,R15),JCHARTBL     the jobname character is valid\n         BNZ   NEWJOBCH               then\n         IC    R6,0(,R15)               use last char of input jobname\n         B     NEWJOBNM            else...\nNEWJOBCH DS    0H\n         LA    R6,C'$'              replace with default char \"$\"\nNEWJOBNM DS    0H                  Generate new job name\n         EX    R4,UIDMOVE1         Move userid to work area jobname\n         STC   R6,JWANAME+1(R4)    Store our job character in name\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Locate verb field - make sure it says \"JOB\"                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,1(,R15)          Advance card scan pointer to blank\n         BAL   R14,SKIPBLAN        Scan to verb\n         LTR   R15,R15             If no verb,\n         BZ    BADJOB               then invalid job card\n         CLC   0(L'CJOB,R15),CJOB  If a verb, it'd better be \"JOB\"\n         BNE   BADJOB              or else invalid job card\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Insure presence of operand field                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,3(,R15)          Advance card scan pointer past \"JOB\"\n         BAL   R14,SKIPBLAN        Scan to operand field\n         LR    R3,R15              Save operand pointer\n         B     COLLECT             Go to collect operands from card\n         SPACE 1\nPJOBCONT DS    0H                  Here if JOB continuation card...\n         SPACE 1\n         ICM   R10,15,IEEXITWD     Get work area address\n         BZ    DISASTER            If none, lose badly\n         XR    R3,R3               Clear insert register\n         ICM   R3,1,IEOPRAND       Get operand column number\n         BZ    NOJOPS              If zero, no operands\n         BCTR  R3,0                Convert column number to offset\n         A     R3,IECARDP          and then to pointer into card\n******** B     COLLECT             Go to collect operands from card\n         SPACE 1\nCOLLECT  DS    0H                  Collect JOB statement operands\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Move the entire operand field as a whole to our work area.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R1,R3               Initialize pointer to operand field\n         BZ    NOJOPS              If none, skip operand movement\n         BAL   R14,SCANBLAN        Locate blank which delimits operands\n*\n* At this point R15 -> the character position following the end of the\n* operand field.  R3 -> the start of the operand field.\n*\n         LR    R5,R15\n         SR    R5,R3               Get length of operand data\n         LA    R2,JWADATA          Point to operand data area\n         A     R2,JWAOFF           Add offset of last moved operands\n         LA    R14,0(R5,R2)        Add in length of new operand data\n         SR    R14,R10             Compute length we'll need\n         C     R14,JWALEN          If length still available\n         BL    PJROOM              then fine. Else...\n         LA    R2,JWAINCR          Get length increment\n         A     R2,JWALEN           Add to current length\n         LR    R0,R2               Use that length for new getmain\n         GETMAIN R,LV=(0)\n         LR    R4,R1               Save its address\n         LR    R0,R1               Destination address in new area\n         L     R1,JWALEN           Length of data to be moved\n         LR    R14,R10             Source address in old area\n         LR    R15,R1              Length of data to be moved\n         MVCL  R0,R14              Move data from old area to new area\n         LR    R1,R10              Get address of old area to free\n         L     R0,JWALEN           Get length of old area to free\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R10,R4              Save address of new area\n         ST    R10,IEEXITWD        Set in exit parameter list\n         ST    R2,JWALEN           Set new work area length\n         LA    R2,JWADATA          Point to operand data area\n         A     R2,JWAOFF           Add offset of last moved operands\nPJROOM   DS    0H\n         BCTR  R5,0                Reduce length for execute\n         EX    R5,MOVEJWA          Move operand field to JOB work area\n         LA    R5,1(,R5)           Restore correct length\n         A     R5,JWAOFF           Increment operand offset\n         ST    R5,JWAOFF            by length of data just moved\n         SPACE 1\nNOJOPS   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Tell SUBMIT not to process this card by setting pointer to zero     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R0,R0               Make a zero\n         ST    R0,IECARDP          Zero out card pointer\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If this statement is going to be continued, then just return.       *\n* Otherwise this is the last card of the JOB statement, so ask the    *\n* caller to start calling us for the purpose of generating new JOB    *\n* cards.                                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    IESTMTYP,IESOPCON+IESSCON  If more JOB cards coming\n         BZ    LASTJOB              then                        #EXIT28\n         OI    JWAFLAGS,JWAJCONT    show continuation expected  #EXIT28\n         B     RETURN0              and return asking for more  #EXIT28\nLASTJOB  DS    0H                  Else last card of a JOB stmt #EXIT28\n         NI    JWAFLAGS,255-JWAJCONT Show continuation satisf'd #EXIT28\n         LA    R15,JWADATA         Compute address of end of\n         A     R15,JWAOFF           operands by adding offset to\n         ST    R15,JWAEND            address of start of operands\n         XR    R0,R0               Make a zero\n         ST    R0,JWAOFF           Set offset to zero\n         LA    R0,JSTART\n         ST    R0,JWARET           Set initial processing address\n         B     RETURN4             and return asking to insert cards\n         EJECT\nPCMD     DS    0H                  Process // unknown (CMD) statement\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* \"// xxx \" statement found - assumed by the system to be a command.  *\n*                                                                     *\n* Determine whether this statement is actually a JOB statement with   *\n* a blank jobname field.  (This shouldn't be the case, but the code   *\n* must have been in here for a reason, so it's possible that the      *\n* SUBMIT command makes mistakes sometimes.)                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,CURRCARD+2       Initialize card scan pointer\n         BAL   R14,SKIPBLAN        Locate verb\n         LTR   R15,R15             If no verb,\n         BZ    BADJOB               then blow up\n         CLC   0(L'CJOB,R15),CJOB  If verb = 'JOB'\n         BE    PJOB                then process as JOB statement\n         B     RETURN0             else process normally\n         EJECT\n         DROP  R10,R8\n         EJECT\nSETRFDT  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Routine to scan each DD statement before the first EXEC for a       *\n*   PROCLIB DD statement.  If a PROCLIB DD statement is found,        *\n*   the dsname is allocated, opened, closed, and freed to recall      *\n*   the proclib if migrated, and update the refdate in the dscb.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*              R2 = \"SCANLENG\"     Length of scan field\n*              R3 = \"SCANPTR\"      Current byte of scan in opcode field\n*              R4 = \"SCANMAX\"\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Check PROCLIB DD statement for dsname                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Load the offset of the operand in the JCL card                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R3,R3               Clear the index register\n         ICM   R3,1,IEOPRAND       Insert the offset of the operand\n         BZ    RETURN0             Return if no operand field\n         BCTR  R3,0                Decrement offset by 1 for zero base\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Load the address of the start of the JCL card                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R4,IECARDP          Load the address of the current card\n         LA    R4,0(,R4)           Zero the high order bit{s}\n         LTR   R4,R4               Test value of address\n         BNP   RETURN0             Return if address is zero\n         AR    R3,R4               Add offset & card addr for op addr\n         LA    R4,66(,R4)          Only scan up to col 66 for DSN= key\n         BCTR  R3,0                Decrement base by 1 to set up loop\nFINDDSN  DS    0H\n         LA    R3,1(,R3)           Increment base pointer by 1\n         CR    R3,R4               If we're past end of the op field\n         BH    RETURN0              or\n         CLI   0(R3),C' '            this character is a blank\n         BE    RETURN0                then return, never found dsname\nFINDDSN1 DS    0H\n         CLC   0(4,R3),=C'DSN='    If this is a DSN= keyword\n         BNE   FINDDSN2               then\n         LA    R3,4(,R3)              increment scan base\n         B     GETNAME                and go get the dsname field\nFINDDSN2 DS    0H                    else\n         CLC   0(7,R3),=C'DSNAME='  if this is a DSNAME= keyword\n         BNE   FINDDSN                   then\n         LA    R3,7(,R3)                 increment scan base\n         B     GETNAME                   and go get the dsname field\n*                                    else keep scanning.\nGETNAME  DS    0H                  We found DSN{AME}=; R3 -> name\n         L     R4,IECARDP          Load the address of the current card\n         LA    R4,71(,R4)          Max col for dsname scan (inc col72)\n         CR    R3,R4               If we're past end of the op field\n         BH    RETURN0             then return\n         LR    R2,R4               Init scan length to max address\n         SR    R2,R3               Find the remaining length minus 1\n         XR    R1,R1               Clear work register\n         EX    R2,SCANDSN          Look for end of dsname\n         BNZ   GETSIZE             If end found, R1 has address of end\n         LR    R1,R4               If end ^found, assume end in col 72\nGETSIZE  DS    0H\n         SR    R1,R3               Find the length of the dsname field\n         BNP   RETURN0             Return if zero length\n         LR    R2,R1               Set the scan length if GT than 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Allocate dsname                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nALLOCDSN DS    0H\n         SPACE 1\n         LA    R0,LDWORK           Amount of storage for work area\n         GETMAIN R,LV=(0)          Get a DD statement work area\n         ST    R1,IEEXITWD         Save address of work area\n         LR    R10,R1              Establish addressability\n         USING DWORK,R10\n         LA    R8,DYNAREA          Address dynamic allocation work area\n         USING S99RBP,R8\n         LA    R4,S99RBPTR+4       Address RB pointer\n         USING S99RB,R4\n         ST    R4,S99RBPTR         Make RBPTR point to RB\n         OI    S99RBPTR,S99RBPND   Turn on VL bit\n         XC    S99RB(RBLEN),S99RB  Zero out RB\n         MVI   S99RBLN,RBLEN       Initialize RB length field\n         MVI   S99VERB,S99VRBAL    Init verb field to allocation\n         OI    S99FLAG1,S99NOCNV   Do not use existing allocation\n         LA    R5,S99RB+RBLEN      Point past RB to text unit area\n         USING S99TUPL,R5\n         ST    R5,S99TXTPP         Initialize text pointer address\n         LA    R6,S99TUPL+12       Point past the 3 text unit pointers\n         USING S99TUNIT,R6\n         ST    R6,S99TUPTR         Init pointer to first text unit\n         LA    R7,DALDSNAM         Get the key for DSNAME\n         STH   R7,S99TUKEY         Store in text unit key field\n         LA    R7,1                Indicate 1 parameter for dsname key\n         STH   R7,S99TUNUM         Store in text unit number field\n         LR    R7,R2               Get the length of the dsname\n         STH   R7,S99TULNG         Store in text unit length field\n         BCTR  R7,0                Decrement length for execute\n         EX    R7,MVCTUPAR         Move dsname to text unit\n         LA    R7,1(,R7)           Restore true dsname length\n         LA    R6,S99TUPAR         Point to start of dsn in text unit\n         AR    R6,R7               Add dsn length to point to text TU\n         LA    R5,S99TUPL+4        Locate second text unit pointer\n         ST    R6,S99TUPTR         Init second text unit pointer\n         LA    R7,DALSTATS         Get key for status specification\n         STH   R7,S99TUKEY         Store in text unit key field\n         LA    R7,1                Indicate 1 parameter for status key\n         STH   R7,S99TUNUM         Set text unit number field to 1\n         STH   R7,S99TULNG         Set text unit length field to 1\n         MVI   S99TUPAR,X'08'      Set parm to indicate SHR    #EXIT33\n         LA    R6,S99TUNIT+7       Point just past the second text unit\n         LA    R5,S99TUPL+4        Locate third text unit pointer\n         ST    R6,S99TUPTR         Init third text unit pointer\n         OI    S99TUPTR,S99TUPLN   Turn on VL bit for last pointer\n         LA    R7,DALRTDDN         Get key for returning ddname\n         STH   R7,S99TUKEY         Store key in text unit field\n         LA    R7,1                Indicate only 1 parameter\n         STH   R7,S99TUNUM         Store in text unit number field\n         LA    R7,8                Set length of return ddname to 8\n         STH   R7,S99TULNG         Store in text unit length field\n         LA    R1,DYNAREA          Set parameter for SVC 99\nALLOCATE DS    0H                  Invoke dynamic allocation\n         DYNALLOC\n         LTR   R15,R15             Test return code\n         BNZ   FREEMAIN            Return if terminating error\n         CH    R15,S99ERROR        Test error code\n         BNE   FREEMAIN            Return if not zero\n         CH    R15,S99INFO         Test information code\n         BNE   FREE                If zero error, but nonzero info,\n*                                  then just free the dsn (don't open)\n         MVC   DDNAME(8),S99TUPAR  Store ddname returned from DYNALLOC\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Data set allocated - open it                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,=A(MODELDCB)     (Needed due to nonaddressability)\n         MVC   DCB(DCBSIZE),0(R1)   Initialize DCB with model\n         MVC   DCB+40(8),DDNAME    Insert ddname returned from alloc.\n         MVC   OPEN(OPENSIZE),OPENM Construct OPEN parameter list\n         LA    R2,DCB              Specify address of DCB\n         LA    R1,OPEN              and address of parameter list\nOPENIT   DS    0H                  Open data set\n         OPEN  ((R2)),MF=(E,(1))\n         LTR   R15,R15             If error opening data set,\n         BNZ   FREE                then just free the data set\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Close DCB and free file                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   CLOSE(CLOSESIZ),CLOSEM Get model CLOSE parameter list\n         LA    R2,DCB              Specify address of DCB\n         LA    R1,CLOSE             and address of parameter list\nCLOSEIT  DS    0H                  Close data set\n         CLOSE ((R2)),MF=(E,(1))\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Free file, even if previous errors have been encountered            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R4,S99RBPTR+4       Establish addressability to RBPTR\n         USING S99RB,R4\n         ST    R4,S99RBPTR         Make RBPTR point to RB\n         OI    S99RBPTR,S99RBPND   Turn on VL bit\n         XC    S99RB(RBLEN),S99RB  Zero out RB\n         MVI   S99RBLN,RBLEN       Initialize RB length field\n         MVI   S99VERB,S99VRBUN    Init verb field to unallocation\n         OI    S99FLAG1,S99NOCNV   Do not use existing allocation\n         LA    R5,S99RB+RBLEN      Point past RB to text unit area\n         USING S99TUPL,R5\n         ST    R5,S99TXTPP         Initialize text pointer address\n         LA    R6,S99TUPL+42       Point past the 1 text unit pointer\n         USING S99TUNIT,R6\n         ST    R6,S99TUPTR         Init pointer to first text unit\n         OI    S99TUPTR,S99TUPLN   Turn on VL bit for last pointer\n         LA    R7,DUNDDNAM         Get key for ddname\n         STH   R7,S99TUKEY         Store key in text unit field\n         LA    R7,1                Indicate only 1 parameter\n         STH   R7,S99TUNUM         Store in text unit number field\n         LA    R7,8                Get length of ddname field\n         STH   R7,S99TULNG         Store in text unit length field\n         MVC   S99TUPAR(8),DDNAME  Move ddname to text unit parm field\n         LA    R1,DYNAREA          Set parameter for SVC 99\nFREE     DS    0H                  Invoke dynamic allocation\n         DYNALLOC\n*                                  {Ignore unallocation errors}\n         B     FREEMAIN            Free storage and return\n         EJECT\nFREEMAIN DS    0H\n         SPACE 1\n         ICM   R1,15,IEEXITWD\n         BZ    RETURN0\n         LA    R0,LDWORK\n         FREEMAIN R,A=(1),LV=(0)\n         XR    R0,R0\n         ST    R0,IEEXITWD\n         B     RETURN0\n         EJECT\nCONTCARD DS    0H\n         SPACE 1\n*              R0\n*              R1\n*              R2    Miscellaneous uses\n*              R3    Address of the operand to output\n*              R4    Length of the operand to output\n*              R5    Length of the collected operand\n*              R6    Pointer to operands collected from input\n*              R7    Base register for SUBMIT JCL control information\n*              R8    Pointer to where to put operands on JCL card\n*              R9    Pointer to last available column on JCL card\n*              R10   Work area base register\n*              R11   Parameter list base register\n*              R12   Static program base register\n*              R13   Dynamic base register and save area pointer\n*              R14\n*              R15\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Get-a-card reentry:                                                 *\n*                                                                     *\n* If we're finished processing JOB card stuff, just free the workarea *\n* and return without adding any more cards.  Then ask for more cards  *\n* from the input dataset.                                             *\n*                                                                     *\n* Return a JOB continuation card.  If this is to be the last card in  *\n* the sequence, then also free the JOB card work area.                *\n*                                                                     *\n* We may be being called at any point in our processing of the JOB    *\n* statement operands saved from input JOB statement processing.       *\n*                                                                     *\n* First of all, if there are any pending unmoved operands or          *\n* suboperands, we process them first.  Then...                        *\n*                                                                     *\n* We decide what to do by interrogating JWARET, which contains the    *\n* address of the place to resume processing of JOB card operands once *\n* any data to be moved to the card has been fully taken care of.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING JWA,R10\n         SPACE 1\n         ICM   R10,15,IEEXITWD     Get address of JOB card work area\n         BZ    DISASTER            If none, disaster\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* See if we're doing JOB card finish-up.                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    JWAFLAGS,JWADONE    If JOB card generation finished,\n         BO    FREEJWA             then go free the JWA and return.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Initialize the job card depending on the card count.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R9,JWACARD+71       Point to last available col for ops\n         ICM   R2,15,JWACOUNT      Get card count so far\n         BNZ   NOT1STJ             If zero, then...\n*                                   Initialize JCL card area\n         MVC   JWASLSL,=C'//'       Put slash-slash\n*                                   (Jobname is already there)\n         MVC   JWABJOBB,CBJOBB      Put \"JOB\" verb\n         MVC   JWAJOBOP,BLANKS      Put blanks in rest of card\n         LA    R8,JWAJOBOP          Point to where operands will start\n         LR    R0,R9               End-start tells us how long the\n         SR    R0,R8                max operand can be on this card\n         ST    R0,JWAMAX           Set max length of an operand\n         B     JDOIT                Go to process state\n         SPACE 1\nNOT1STJ  DS    0H                  Else not the first output card\n         SPACE 1\n         MVC   JWASLSL,=C'//'       Initialize continuation card\n         MVC   JWACARD+2(78),BLANKS Put blanks in rest of card\n         LA    R8,JWAOPS            Point to where operands will start\n         SPACE 1\nJDOIT    DS    0H                  Job card initialized, proceed\n         SPACE 1\n         LA    R2,1(,R2)\n         ST    R2,JWACOUNT         Increment output card count\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If there are any unmoved operands waiting to be processed, do 'em.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   R3,15,JWAUPTR       If there are any unmoved operands\n         BZ    NOUNMOVD            then...\n*                                   R3 -> unmoved operand\n         L     R4,JWAUEND           End minus start...\n         SR    R4,R3                R4 = length of the unmoved operand\n         BAL   R14,INSERTOP        Try to add unmoved operands\n         ICM   R0,15,JWAUPTR       If still unmoved stuff left\n         BNZ   CRETURN             then return to try next time\n*                                  If succeeded, we're ready to proceed\nNOUNMOVD DS    0H                  No unmoved operands...\n         SPACE 1\n         L     R6,JWASAVE6         Restore regs left by INSERTOP\n         L     R15,JWARET          Get continuation address\n         BR    R15                 Branch to where we're supposed to go\n         EJECT\nJSTART   DS    0H                  Initial state - process input op's\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Processing:                                                         *\n*                                                                     *\n*  Get first operand (by calling SCANCOMA).                           *\n*                                                                     *\n*  (1) Looking-for-accounting-info.                                   *\n*                                                                     *\n*      Case:                                                          *\n*           (no operand) - emit default accounting info               *\n*                          emit default programmer name               *\n*                          go to no-more-operands                     *\n*           (x=y)        - emit default accounting info               *\n*                          emit default programmer name               *\n*                          go to process-keyword-operands             *\n*           \"*\",\"\"       - emit default accounting info               *\n*                          get next operand by calling SCANCOMA       *\n*                          go to looking-for-programmer-name          *\n*           other        - emit this operand for accounting info      *\n*                          get next operand by calling SCANCOMA       *\n*                          go to looking-for-programmer-name          *\n*                                                                     *\n*  (2) Looking-for-programmer-name.                                   *\n*                                                                     *\n*      Case:                                                          *\n*           (no operand) - emit default programmer name               *\n*                          go to no-more-operands                     *\n*           (x=y)        - emit default programmer name               *\n*                          go to process-keyword-operands             *\n*           \"*\",\"\"       - emit default programmer name               *\n*                          get next operand by calling SCANCOMA       *\n*                          go to process-keyword-operands             *\n*           other        - emit this operand for programmer name      *\n*                          get next operand by calling SCANCOMA       *\n*                          go to process-keyword-operands             *\n*                                                                     *\n*  (3) Process-keyword-operands.                                      *\n*                                                                     *\n*      Turn JWACKLST bit on: checking for last JOB card operand,      *\n*      which the emit process will save instead of emitting.          *\n*                                                                     *\n*      Case:                                                          *\n*           (no operand) - go to no-more-operands                     *\n*           (x=y)        - emit this operand                          *\n*                          get next operand by calling SCANCOMA       *\n*                          go to process-keyword-operands             *\n*           \"*\",\"\"       - flag as an error                           *\n*                          but emit this operand anyway               *\n*                          get next operand by calling SCANCOMA       *\n*                          go to process-keyword-operands             *\n*           other        - flag as an error                           *\n*                          but emit this operand anyway               *\n*                          get next operand by calling SCANCOMA       *\n*                          go to process-keyword-operands             *\n*                                                                     *\n*  (4) No-more-operands.                                              *\n*                                                                     *\n*      Turn JWACKLST bit off.                                         *\n*                                                                     *\n*      For each operand in required-operand-list,                     *\n*      if operand has not been encountered, emit default operand.     *\n*                                                                     *\n*  (5) Process-last-operand.                                          *\n*                                                                     *\n*      Emit the last keyword operand (if there was one), which was    *\n*      saved during keyword operand processing instead of being       *\n*      emitted.                                                       *\n*                                                                     *\n*  (6) Finished.                                                      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  Note:  The reason we save the last operand and put it out last is  *\n*         in case the last JOB statement operand takes up 68 bytes    *\n*         on the input JOB card image.  In such a case, we would not  *\n*         have room to insert a comma after it, and so we must make   *\n*         it the last operand on our generated JOB card as well.      *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 1\n         LA    R6,JWADATA          Point to where to get first input\n         BAL   R14,SCANCOMA        Get a JCL operand\n         ST    R15,JWAONEXT        Save address of next operand\n         LTR   R15,R15             If none,\n         BNZ   L1A1                then\n         L     R3,IEACCTIP          get address of default account info\n         L     R4,IEACCTLP          get -> len of default account info\n         LH    R4,0(,R4)            get length of default account info\n         EMIT  ,                    Output the operand\n         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34\n         L     R4,JWAUIDL           get length of default prgrmr name\n         LA    R4,1(,R4)            unreduce for non-execute\n         EMIT  ,                    Output the operand\n         B     LNOMORE              go to no-more-operands\nL1A1     DS    0H                  Else we got an operand.\n         L     R5,JWAONEXT\n         SR    R5,R6               R5 = length of input operand\n         BAL   R14,SCANEQAL        See if operand contains an \"=\"\n         LTR   R15,R15             If it does,\n         BZ    L1NEQ               then...\n         L     R3,IEACCTIP          get address of default account info\n         L     R4,IEACCTLP          get -> len of default account info\n         LH    R4,0(,R4)            get length of default account info\n         EMIT  ,                    Output the operand\n         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34\n         L     R4,JWAUIDL           get length of default prgrmr name\n         LA    R4,1(,R4)            unreduce for non-execute\n         EMIT  ,                    Output the operand\n         B     LKEYWORD             go to process keyword operands\nL1NEQ    DS    0H                  Else (it doesn't contain \"=\")\n         CH    R5,=H'1'            Check length of value\n         BL    L1DEFLT             If value = \"\"\n         BH    L1NSTAR              or\n         CLI   0(R6),C'*'            value = '*'\n         BNE   L1NSTAR                then\nL1DEFLT  DS    0H                   (generate default value)\n         L     R3,IEACCTIP          get address of default account info\n         L     R4,IEACCTLP          get -> len of default account info\n         LH    R4,0(,R4)            get length of default account info\n         EMIT  ,                       Output the operand\n         NEXT  ,                       Get next JCL operand\n         B     LPRGRMR                 Go to look for programmer name\nL1NSTAR  DS    0H                  Else...\n         LR    R3,R6               Get address of this operand\n         LR    R4,R5               Get length of this operand\n         EMIT  ,                   Emit this one for accounting info\n         NEXT  ,                   Get next JCL operand\n         B     LPRGRMR             Go to look for programmer name.\n         SPACE 1\nLPRGRMR  DS    0H                  Looking for programmer name.\n         SPACE 1\n*\n* At this point we have just scanned up the next JCL operand.\n*\n         ICM   R15,15,JWAONEXT     If no operand\n         BNZ   L2A1                then\n         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34\n         L     R4,JWAUIDL           get length of default prgrmr name\n         LA    R4,1(,R4)            unreduce for non-execute\n         EMIT  ,                    Output the operand\n         B     LNOMORE              Go to no-more-operands\nL2A1     DS    0H                  Else (an operand was found)...\n         L     R5,JWAONEXT\n         SR    R5,R6               R5 = length of input operand\n         BAL   R14,SCANEQAL        See if operand contains an \"=\"\n         LTR   R15,R15             If it does,\n         BZ    L2NEQ               then...\n         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34\n         L     R4,JWAUIDL           get length of default prgrmr name\n         LA    R4,1(,R4)            unreduce for non-execute\n         EMIT  ,                    Output the operand\n         B     LKEYWORD             Go to process keyword operands\nL2NEQ    DS    0H                  Else (no \"=\") ...\n         SPACE 1\n         CH    R5,=H'1'            Check length of value\n         BL    L2DEFLT             If value = \"\"\n         BH    L2NSTAR              or\n         CLI   0(R6),C'*'            value = '*'\n         BNE   L2NSTAR                then\nL2DEFLT  DS    0H                   (generate default value)\n         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34\n         L     R4,JWAUIDL           get length of default prgrmr name\n         LA    R4,1(,R4)            unreduce for non-execute\n         EMIT  ,                    Output the operand\n         NEXT  ,                    Get next JCL operand\n         B     LKEYWORD            else go to process keyword operands\nL2NSTAR  DS    0H                  Else...\n         LR    R3,R6               Get address of this operand\n         LR    R4,R5               Get length of this operand\n         EMIT  ,                   Emit this one for programmer name\n         NEXT  ,                   Get next JCL operand\n         B     LKEYWORD            else go to process keyword operands\n         SPACE 1\nLKEYWORD DS    0H                  Process keyword=value operands\n         SPACE 1\n         OI    JWAFLAGS,JWACKLST   Start checking for last operand.\n         SPACE 1\n*\n* At this point we have just scanned up the next JCL operand.\n*\n         ICM   R5,15,JWAONEXT      If no operand\n         BZ    LNOMORE             then go to no-more-operands\n         SR    R5,R6               Else R5 = length of input operand\n         BAL   R14,SCANEQAL        See if operand contains an \"=\"\n         LTR   R15,R15             If it does,\n         BZ    L3NEQ               then...\n*                                  R15 -> value following \"=\" sign\n*                                  R1 = length of keyword before \"=\"\n*                                  R2 = length of value after \"=\"\n*                                  R5 = length of entire operand\n*                                  R6 -> entire operand, keyword\n         LR    R14,R1              Get length of keyword\n         CH    R14,=H'8'           If longer than 8\n         BH    UNKKWD              then assume unknown keyword\n         MVC   JWAKEY,BLANKS       Clear keyword test area\n         BCTR  R14,0               Else reduce for execute\n         EX    R14,MVCKEY          Move keyword to test area\n         SPACE 1\n         LA    R14,KEYTABLE        Start searching keyword table\nKEYLOOP  DS    0H\n         C     R14,=A(KEYTBEND)    Loop until end of keyword table\n         BNL   UNKKWD              at which point keyword is unknown\n         CLC   JWAKEY,0(R14)       If keyword matches this one\n         BE    KEYFOUND            then we got it\n         LA    R14,12(,R14)        else bump to next table entry\n         B     KEYLOOP             and keep searching\nKEYFOUND DS    0H                  Found a key\n         L     R14,8(,R14)         Get address of associated processor\n         BR    R14                 Go to it\n         SPACE 1\nKTIME    DS    0H                  Processor for TIME=\n         SPACE 1\n         OI    JWAFLAGS,JWATIME    Indicate TIME keyword found\n         B     UNKKWD              Emit like any other keyword\n         SPACE 1\nKREGION  DS    0H                  Processor for REGION=\n         SPACE 1\n         OI    JWAFLAGS,JWAREGN    Indicate REGION keyword found\n         B     UNKKWD              Emit like any other keyword\n         SPACE 1\n*MSGCLAS DS    0H                  Processor for MSGCLASS=\n*        SPACE 1\n*        OI    JWAFLAGS,JWAMSGC    Indicate MSGCLASS keyword found\n*        B     UNKKWD              Emit like any other keyword\n*        SPACE 1\nKNOTIFY  DS    0H                  Processor for NOTIFY=\n         SPACE 1\n         CH    R2,=H'1'            If value length is 1\n         BNE   UNKKWD               and\n         CLI   0(R15),C'*'           value = '*'\n         BNE   UNKKWD                 then\n         MVC   JWABUILD(7),=C'NOTIFY=' start to build new operand\n*                                      (deleted by usermod...)  #EXIT34\n         L     R14,JWAUIDL             get length to execute\n         EX    R14,KNMOVE              move userid to JWABUILD+7\n         LA    R3,JWABUILD             get address of new operand\n         LA    R4,7+1(,R14)            get length of new operand\n         B     KEMIT                   emit NOTIFY=userid\n         SPACE 1\nKPASSWOR DS    0H                  Processor for PASSWORD=      #EXIT43\n         SPACE 1                                                #EXIT43\n         LTR   R2,R2               If value length is nonzero   #EXIT43\n         BP    UNKKWD              then don't do anything else  #EXIT43\n         MVC   JWABUILD(9),=C'PASSWORD=' Start to build new op  #EXIT43\n         LA    R3,JWABUILD+9       New password will go here    #EXIT43\n         BAL   R14,FILLINPW        Make user fill in password   #EXIT43\n         LA    R3,JWABUILD         Get address of new operand   #EXIT43\n         LA    R4,9(,R15)          Get length of new operand    #EXIT43\n         B     KEMIT               Emit PASSWORD=password       #EXIT43\n         SPACE 1                                                #EXIT43\n*                                  else emit like any other keyword\n         SPACE 1\nUNKKWD   DS    0H                  Unknown keyword - just put it out\n         SPACE 1\n         LR    R3,R6               Get address of this operand\n         LR    R4,R5               Get length of this operand\n         SPACE 1\nKEMIT    DS    0H                  Branch here to emit keyword\n         SPACE 1\n         EMIT  ,                   Emit this one for programmer name\n         NEXT  ,                   Get next JCL operand\n         B     LKEYWORD            Go to process next keyword operand\nL3NEQ    DS    0H                  Else (no \"=\") ...\n         TELL  BADOPMSG            Tell user it's a bad operand\n         LR    R1,R6               Get address of this operand\n         LR    R0,R5               Get length of this operand\n         TPUT  (1),(0),R           Show user the bad operand\n*                                  But emit it anyway...\n         LR    R3,R6               Get address of this operand\n         LR    R4,R5               Get length of this operand\n         EMIT  ,                   Emit this one for programmer name\n         NEXT  ,                   Get next JCL operand\n         B     LKEYWORD            Go to process next keyword operand\n         SPACE 1\nLNOMORE  DS    0H                  No more input operands to process.\n         SPACE 1\n         NI    JWAFLAGS,255-JWACKLST Stop checking for last operand.\n         SPACE 1\n*\n* Add any additional operands we might want to add, like default\n* values for TIME and REGION or whatever.\n*\n         SPACE 1\n         TM    JWAFLAGS,JWATIME    If no TIME= specified by user\n         BO    NODTIME             then\n         LA    R3,DFLTTIME\n         LA    R4,L'DFLTTIME\n         EMIT  ,                   Output the operand\n         SPACE 1\nNODTIME  DS    0H\n         SPACE 1\n         TM    JWAFLAGS,JWAREGN    If no REGION= specified by user\n         BO    NODREGN             then\n         LA    R3,DFLTREGN\n         LA    R4,L'DFLTREGN\n         EMIT  ,                   Output the operand\n         SPACE 1\nNODREGN  DS    0H\n*        SPACE 1\n*        TM    JWAFLAGS,JWAMSGC    If no MSGCLASS= specified by user\n*        BO    NODMSGC             then\n*        LA    R3,DFLTMSGC\n*        LA    R4,L'DFLTMSGC\n*        EMIT  ,                   Output the operand\n*        SPACE 1\n*ODMSGC  DS    0H\n         SPACE 1\n* OK, no more special requests, time to put out the last operand.\n         SPACE 1\n         ICM   R3,15,JWALSTOP      Get address of saved last operand\n         BZ    NOMOREOP            If none, bypass this\n         L     R4,JWALSTOL         Get length of saved last operand\n         EMIT  ,                   Output the last operand\nNOMOREOP DS    0H\n         SPACE 1\n* OK, nothing more to do, this is the last card.\n         SPACE 1\n         BCTR  R8,0                Bump back to last generated char\n         CLI   0(R8),C','          If there was a comma,\n         BNE   NOBLKCOM             then\n         MVI   0(R8),C' '            blank it out\nNOBLKCOM DS    0H\n         SPACE 1\n         LA    R15,JWACARD\n         ST    R15,IECARDP         Set pointer to our JCL card\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* At this point we have nothing more to do except return the last     *\n* JOB statement card and free the workarea.  Of course, we can't      *\n* free the workarea while we're returning a JCL card in it            *\n* (he realizes now).  So, we ask to insert one more card, which is    *\n* actually a lie, because that time we're going to get control only   *\n* to FREEMAIN the JWA and return with no card at all.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         OI    JWAFLAGS,JWADONE    Indicate we're finished generating\n         B     RETURN4             Return asking to insert another card\n         EJECT\nCRETURN  DS    0H                  Here when returning for continuation\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This is where we come when we've squeezed as many operands on a     *\n* new JCL card as will fit.  We finish up the card, save values in    *\n* the work area, and return, asking SUBMIT to give us another chance  *\n* to insert a card.  We will come back in the state of processing we  *\n* left in, to insert the operand we were trying to when we found we   *\n* didn't have room.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*\n* Set new value for maximum length of an operand for a card\n*\n         LA    R0,JWACARD+71-JWAOPS\n         ST    R0,JWAMAX           Set max length of an operand\n         SPACE 1\n         LA    R15,JWACARD\n         ST    R15,IECARDP         Set pointer to our JCL card\n         B     RETURN4             Return asking for another insert\n         EJECT\nBADJOB   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Error in job card - display message and return                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R0,=A(BADJMSG)      Get address of message area\n         ST    R0,IEMSGP           Store address of message area\n         LA    R15,IEMSG           RC = issue message and reenter exit\n         B     RETURN              Return\n         EJECT\nBADCJOB  DS    0H\n         SPACE 1                                                #EXIT48\n****************************************************************#EXIT48\n*                                                               #EXIT48\n* Non-JOB card found when JOB card continuation expected.       #EXIT48\n*                                                               #EXIT48\n* If this is a comment card between pieces of a JOB statement,  #EXIT48\n* which can happen only when the fix for APAR OY37954 is on,    #EXIT48\n* then do the same as we do if both JOB and COMMENT bits are on #EXIT48\n* - in other words, throw away the comment card.                #EXIT48\n*                                                               #EXIT48\n****************************************************************#EXIT48\n         SPACE 1                                                #EXIT48\n         TM    IESTMTP2,IESCOMNT   If this is a //* inside JOB  #EXIT48\n         BO    THROWCOM            then return asking for more  #EXIT48\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Error in job card continuation - display message and return         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R0,=A(BADJCMSG)     Get address of message area\n         ST    R0,IEMSGP           Store address of message area\n         LA    R15,IEMSG           RC = issue message and reenter exit\n         B     RETURN              Return\n         EJECT\nMSGRTN   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Message return entry:                                               *\n*                                                                     *\n* Clear IECARDP and IEMSGP, signal submit abort, and return           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SR    R0,R0\n         ST    R0,IECARDP          Clear statement pointer\n         ST    R0,IEMSGP           Clear message pointer\n         MVI   IETAKEEX,X'00'      Turn off all \"take exit\" switches\n         LA    R15,IEABORT         Load abort return code\n         B     RETURN              Return\n         EJECT\nDISASTER DS    0H                  Severe internal error\n         SPACE 1\n         TELL  DISMSG\n         SPACE 1\n         LA    R15,16\n         B     RETURN\n         EJECT\nTHROWCOM DS    0H                  //* between JOB cards        #EXIT42\n         SPACE 1                                                #EXIT42\n         SR    R0,R0                                            #EXIT42\n         ST    R0,IECARDP          Clear statement pointer      #EXIT42\n         LA    R15,IECONTIN        Set return code to request   #EXIT42\n         B     RETURN              another card and return      #EXIT42\n         SPACE 1                                                #EXIT42\nRETURN0  DS    0H                  Return(0) - just gimme next card\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Normal return when requesting to receive the next JCL card          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R15,IECONTIN        Set return code to request another\n         B     RETURN              card and return to caller\n         EJECT\nRETURN4  DS    0H                  Return(4) - call me to give you one\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Normal return when requesting to generate the next card myself      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R15,IERETURN        Set return code to get to insert a\n         B     RETURN              card next time and return to caller\n         EJECT\nRETURN   DS    0H                  Return to caller of SUBMIT exit\n         SPACE 1\n         ST    R15,16(,R13)        Store return code into save area\n*                                  (it will be loaded by LM below)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Subroutines                                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         EJECT\nFILLINPW DS    0H                  Fill in ungiven password     #EXIT43\n*                                                               #EXIT43\n*************************************************************** #EXIT43\n*                                                               #EXIT43\n* This routine is called whenever there is a password parameter #EXIT43\n* that needs to have a password filled in.  The user is given a #EXIT43\n* print-inhibited prompt to type the password for the \"card\".   #EXIT43\n*                                                               #EXIT43\n* On entry, R3 points to the place to store the password.       #EXIT43\n* This place must be 8 bytes long.                              #EXIT43\n*                                                               #EXIT43\n* On return, R15 contains the length of the specified password. #EXIT43\n*                                                               #EXIT43\n*************************************************************** #EXIT43\n*                                                               #EXIT43\n         ICM   R15,15,IEUSRIDP       Else get address of userid\n         BZR   R14                   If none,                   #EXIT43\n         CLC   0(7,R15),BLANKS        or userid is blank,\n         BER   R14                     then nobody to prompt    #EXIT43\n         SPACE 1\nTPROMPT  DS    0H                    Else prompt to enter a password\n         L     R1,=A(GETPSWD)                                   #EXIT32\n         L     R0,=A(GETPSWDL)                                  #EXIT32\n         TPUT  (1),(0),ASIS        Ask user to enter password   #EXIT32\nTGET     DS    0H\n         MVC   0(8,R3),BLANKS      Clear input area             #EXIT43\n         TCLEARQ INPUT             Flush any outstanding terminal input\n         TGET  (R3),8              Read the password from the terminal\n         CH    R15,=H'12'          If TGET RC = 12 (input too long),\n         BNE   TGETN12             then\n         TELL  PSWDERR              tell user password's no good\n         B     TPROMPT               and retry\nTGETN12  DS    0H                  else\n         CH    R15,=H'8'           if TGET RC = 8 (attention hit),\n         BE    FIXPWDCD            then return without password #EXIT32\nTGETOK   DS    0H                  else presume TGET was OK\n         CLC   0(8,R3),BLANKS      If tgotten passwd yet blank  #EXIT43\n         BE    TPROMPT             then prompt for it again\n         OC    0(8,R3),BLANKS      else translate to upper case #EXIT43\n*                                  Now figure out how long the  #EXIT43\n         LA    R15,0(,R3)          new password is.  Initialize #EXIT43\n         LA    R0,8                pointers and count.          #EXIT43\nTGOTLOOP DS    0H                  Loop searching for blank     #EXIT43\n         CLI   0(R15),C' '         When blank found             #EXIT43\n         BE    TGOTBLAN            then we are done             #EXIT43\n         LA    R15,1(,R15)         Else bump pointer            #EXIT43\n         BCT   R0,TGOTLOOP         loop till count exhausted    #EXIT43\nTGOTBLAN DS    0H                  Blank or EOPW found          #EXIT43\n         SR    R15,R3              Return length in R15         #EXIT43\n         BR    R14                 Return to caller             #EXIT43\n         EJECT\nFREEJWA  DS    0H                  Here if called to free JWA\n         SPACE 1\n         LR    R1,R10              Free the JOB card work area\n         L     R0,JWALEN\n         FREEMAIN R,A=(1),LV=(0)\n         XR    R0,R0\n         ST    R0,IEEXITWD         Clear exit work area pointer\n         ST    R0,IECARDP          Not returning a JCL card this time\n         B     RETURN0             Return asking for next card, please\n         EJECT\nSKIPBLAN DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to scan current card for a non-blank character          *\n*                                                                     *\n*  Entry point:  SKIPBLAN                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R1 = pointer to where scan for a nonblank is to begin           *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    R15 = pointer to where the first nonblank was found              *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return with R15 -> where first nonblank was found              *\n*    Error (non-blank not found on current card) -                    *\n*      Return with R15 = 0                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING CARDSECT,R9\n         SPACE 1\n         LR    R15,R1              Get card scan pointer\n         LA    R0,1                Set card scan pointer increment\n         LA    R1,CURRCARD+71      Set card scan limit\n         CR    R15,R1              If already past it\n         BH    SKBLERR              then return in failure\nSKBLLOOP DS    0H                  Loop until R15 -> a nonblank\n         CLI   0(R15),C' '          or we hit column 71\n         BNER  R14                 When nonblank found, success\n         BXLE  R15,R0,SKBLLOOP     Loop until blank found or...\nSKBLERR  XR    R15,R15             ...end of card\n         BR    R14                 Error exit - nonblank not found\n         EJECT\nSCANBLAN DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to scan current card for a blank character              *\n*                                                                     *\n*  Entry point:  SCANBLAN                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R1 = pointer to where scan for a blank is to begin              *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    R15 = pointer to where the first blank was found                 *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return with R15 = pointer to first blank (or column 72)        *\n*    Error (blank not found on current card) -                        *\n*      Return with R15 = 0                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING CARDSECT,R9\n         SPACE 1\n         LR    R15,R1              Get card scan pointer\n         LA    R0,1                Set card scan pointer increment\n         LA    R1,CURRCARD+71      Set card scan limit\nCKBLANK  DS    0H                  Loop until R15 -> a nonblank\n         CLI   0(R15),C' '         When blank found,\n         BER   R14                 exit with success\n         CLI   0(R15),C''''        When apostrophe found,\n         BE    QUOTLOOP             go to scan quoted data\n         B     BLANLOOP            Otherwise continue loop\nCKQUOTE  DS    0H                  Looping inside quoted string...\n         CLI   0(R15),C''''        When closing apostrophe found,\n         BE    BLANLOOP             exit to blank-scanning loop\nQUOTLOOP DS    0H                  Otherwise\n         BXLE  R15,R0,CKQUOTE       scan for closing quote only\n         BR    R14                 Exit as if blank found if at col 71\nBLANLOOP DS    0H\n         BXLE  R15,R0,CKBLANK      Scan for blank until column 71\n         BR    R14                 Exit as if blank found if at col 71\n         EJECT\nSCANCOMA DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to scan collected operands for an operand string        *\n*  delimited by a comma                                               *\n*                                                                     *\n*  Entry point:  SCANCOMA                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R6 = pointer to the current operand to start scanning from      *\n*    JWAEND points to the end of all input operands.                  *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    R15 = pointer to character position following end of operand     *\n*          (either pointer to a comma or equal to end of operands)    *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return with R15 -> character position following end of operand *\n*    Error (no more operands to process) -                            *\n*      Return with R15 = 0                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R15,R15             Provisionally clear return pointer\n         LR    R1,R6               Get pointer to this operand\n         C     R1,JWAEND           If already at end of operands\n         BNLR  R14                 then return \"no more\" error\n         XR    R2,R2               Clear parenthesis count\n         LR    R15,R1              Get operand scan pointer\n         LA    R0,1                Set operand scan pointer increment\n         L     R1,JWAEND           Set operand scan limit\n         BCTR  R1,0                Decrement for stupid BXLE loop\n         SPACE 1\nSCLOOP   DS    0H                  Loop looking for terminating comma\n         SPACE 1\n         CLI   0(R15),C','         When comma found,\n         BE    SCCOMMLP            process it.\n         CLI   0(R15),C''''        When apostrophe found,\n         BE    SCQUOTLP            switch to inside-quoted-string scan\n         CLI   0(R15),C'('         When left parenthesis found,\n         BE    SCLPLOOP            make a note of it\n         CLI   0(R15),C')'         When right parenthesis found,\n         BE    SCRPLOOP            make a note of it\n         B     SCCONT              Otherwise continue loop\n         SPACE 1\nSCCOMMLP DS    0H                  Comma found\n         LTR   R2,R2               If parenthesis count is zero\n         BZR   R14                 then exit with success\n         B     SCCONT              else continue looping\nSCLPLOOP DS    0H                  Left parenthesis found\n         LA    R2,1(,R2)           Increment parenthesis count\n         B     SCCONT              Continue scan\nSCRPLOOP DS    0H                  Right parenthesis found\n         LTR   R2,R2               If unmatched parenthesis,\n         BNP   SCCONT              then treat as normal char anyhow\n         BCTR  R2,0                Else decrement parenthesis count\n         B     SCCONT              and continue looping\nSCQUOTE  DS    0H                  Looping inside quoted string...\n         CLI   0(R15),C''''        When closing apostrophe found,\n         BE    SCCONT               exit to normal loop\nSCQUOTLP DS    0H                  Otherwise\n         BXLE  R15,R0,SCQUOTE       scan for closing quote only\n         BR    R14                 If at end, return success anyhow\nSCCONT   DS    0H                  Normal continuation\n         BXLE  R15,R0,SCLOOP       Scan for comma until operand end\n         BR    R14                 If at end, return success anyhow\n         EJECT\nSCANCOM2 DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to scan a single operand for suboperands                *\n*  delimited by commas                                                *\n*                                                                     *\n*  Entry point:  SCANCOM2                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R3 = pointer to the current operand to start scanning from      *\n*     JWAUEND points to the end of the whole operand.                 *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    R15 = pointer to character position following a suboperand       *\n*          (either pointer to a comma or equal to end of operand)     *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return with R15 set to pointer to position following operand   *\n*    Error (no more operands to process) -                            *\n*      Return with R15 = 0                                            *\n*                                                                     *\n*  Note:  This is functionally identical to SCANCOMA (modulo          *\n*         register assignments, etc.) except that it ignores          *\n*         parentheses.  Hence, its ability to break up operands       *\n*         in a  way compatible with JCL parsing.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R15,R15             Provisionally clear return pointer\n         LR    R1,R3               Get pointer to this operand\n         C     R1,JWAUEND          If already at end of operands\n         BNLR  R14                 then return \"no more\" error\n         LR    R15,R1              Get operand scan pointer\n         LA    R0,1                Set operand scan pointer increment\n         L     R1,JWAUEND          Set operand scan limit\n         BCTR  R1,0                Decrement for stupid BXLE loop\n         SPACE 1\nS2LOOP   DS    0H                  Loop looking for terminating comma\n         SPACE 1\n         CLI   0(R15),C','         When comma found,\n         BER   R14                 return.\n         CLI   0(R15),C''''        When apostrophe found,\n         BE    S2QUOTLP            switch to inside-quoted-string scan\n         B     S2CONT              Otherwise continue loop\n         SPACE 1\nS2QUOTE  DS    0H                  Looping inside quoted string...\n         CLI   0(R15),C''''        When closing apostrophe found,\n         BE    S2CONT               exit to normal loop\nS2QUOTLP DS    0H                  Otherwise\n         BXLE  R15,R0,S2QUOTE       scan for closing quote only\n         BR    R14                 If at end, return success anyhow\nS2CONT   DS    0H                  Normal continuation\n         BXLE  R15,R0,S2LOOP       Scan for comma until operand end\n         BR    R14                 If at end, return success anyhow\n         EJECT\nSCANEQAL DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to scan current operand for an equal sign               *\n*                                                                     *\n*  Entry point:  SCANEQAL                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R6 = pointer to where scan for an \"=\" is to begin               *\n*     R5 = length of operand to scan                                  *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    R15 = pointer to the operand following the \"=\" sign              *\n*    R1  = length of keyword preceding \"=\" sign                       *\n*    R2  = length of operand following \"=\" sign                       *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return with R15 = pointer to operand                           *\n*    Error (operand does not contain \"=\" -                            *\n*      Return with R15 = 0                                            *\n*                                                                     *\n*  Notes:                                                             *\n*                                                                     *\n*    Since valid JCL keywords cannot contain quotes or parentheses    *\n*    in their names, it is assumed that if a quote or parenthesis is  *\n*    found before an = is found, there will be no =, and the operand  *\n*    will be treated as a positional operand.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    R15,R6              Get card scan pointer\n         LTR   R0,R5               Get operand length for count\n         BZ    SCEQFAIL            If zero, no \"=\"\nSCEQLOOP DS    0H\n         CLI   0(R15),C'='         When equals sign found\n         BE    SCEQSUCC            go process it\n         CLI   0(R15),C''''        When quote found\n         BE    SCEQFAIL            then assume not valid\n         CLI   0(R15),C'('         When left parenthesis found\n         BE    SCEQFAIL            then assume not valid\n         LA    R15,1(,R15)\n         BCT   R0,SCEQLOOP\n         B     SCEQFAIL\nSCEQSUCC DS    0H\n         LR    R1,R15\n         SR    R1,R6               Get length of keyword before \"=\"\n         BNP   SCEQFAIL            If not positive, error\n         LA    R15,1(,R15)         Bump past comma\n         LR    R2,R5               Get length of entire operand\n         SR    R2,R1               Subtract length of keyword\n         BCTR  R2,0                Subtract 1\n         BR    R14                 Return with operand length in R2\n         SPACE 1\nSCEQFAIL DS    0H                  No \"=\"\n         XR    R15,R15             Set all return pointers to zero\n         XR    R1,R1\n         XR    R2,R2\n         BR    R14\n         EJECT\nINSERTOP DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  Subroutine to add an operand to the existing JCL card.             *\n*                                                                     *\n*  Entry point:  INSERTOP                                             *\n*                                                                     *\n*  Input:                                                             *\n*                                                                     *\n*     R3 = pointer to the operand to insert on the current JCL card   *\n*     R4 = length of that operand                                     *\n*     R8 = pointer to the location on the card to insert an operand   *\n*     R9 = pointer to the last available column on that card          *\n*    R14 = return address                                             *\n*                                                                     *\n*  Output:                                                            *\n*                                                                     *\n*    Data is moved to the card as requested                           *\n*    R8 is updated to point to the next available column on card      *\n*                                                                     *\n*  Exit:                                                              *\n*                                                                     *\n*    Normal -                                                         *\n*      Return via R14 with JWAUPTR = zero                             *\n*    Error (no room to insert the  entire operand) -                  *\n*      Return via R14 with JWAUPTR -> unmoved portion of operand      *\n*                                                                     *\n*  Processing:                                                        *\n*                                                                     *\n*    If the operand to be printed on the JCL card is longer than      *\n*    71-3 (68) bytes, it can't be fit on a card in one piece.         *\n*    In this case, it is scanned for commas (where the operand        *\n*    can be broken up) and each piece goes through the following      *\n*    handling.  Otherwise the entire operand goes through the         *\n*    following handling:                                              *\n*                                                                     *\n*    If there is enough room on the output JCL card to hold the       *\n*    entire operand as is, it is moved to the card.  Otherwise,       *\n*    this routine returns in failure, which means that the current    *\n*    JCL card must be returned to the caller and another one set      *\n*    up on the next call to hold this operand.  However, if this      *\n*    operand is longer than 68 bytes, it can't be put on the card     *\n*    and an internal error must be signalled.                         *\n*                                                                     *\n*    When this routine must return in failure, the address of the     *\n*    start and end of the operand that it couldn't put on the card    *\n*    are saved in the work area so that the next call to this exit    *\n*    will know that this needs to be taken care of before anything    *\n*    else.                                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*     R3 = pointer to the operand to insert on the current JCL card   *\n*     R4 = length of that operand                                     *\n*     R8 = pointer to the location on the card to insert an operand   *\n*     R9 = pointer to the last available column on that card          *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Set the address of the end of the operand string being processed    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R15,0(R3,R4)        Address + length = end\n         ST    R15,JWAUEND         Store end-of-operand address\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If this is the last operand found on the input JOB statements, and  *\n* we are also checking for the last operand, then don't emit it now.  *\n* Instead, save its address and length so that it can be emitted when *\n* asked for again.                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         C     R15,JWAEND          If end of operand is the same as\n         BNE   NOTLSTOP             the end of all the operands,\n         TM    JWAFLAGS,JWACKLST     and we are checking for the last\n         BZ    NOTLSTOP               JOB operand, then...\n         ST    R3,JWALSTOP             save address of this operand\n         ST    R4,JWALSTOL             save length of this operand\n         XR    R0,R0                   make a zero\n         ST    R0,JWAUPTR              clear unmoved stuff pointer\n         BR    R14                     return to caller\n         SPACE 1\nNOTLSTOP DS    0H                  Else not last operand to be saved...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the complete operand is too long to fit on a JCL card, even by   *\n* itself, then start breaking it up at commas and process the pieces. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,JWAMAX           Get value of max operand length\n*                                  (even tho we're about to chAnge it)\n*\n* Set new value for maximum length of an operand for a card\n* (after the first operand, all the rest can fill up a whole card -\n* only the first one (after JOB) must fit on first card)\n*\n         LA    R0,JWACARD+71-JWAOPS\n         ST    R0,JWAMAX           Set max length of an operand\n         SPACE 1\n         CR    R4,R1               If length of operand is less'n max\n         BL    INNOBRK             then process as is\n*                                  Otherwise break it up\n         SPACE 1\n         ST    R14,JWASAVE         Save return register\n         SPACE 1\nCOM2LOOP DS    0H                  Loop processing suboperands\n         SPACE 1\n*                                  R3 -> next suboperand to scan\n         BAL   R14,SCANCOM2        Find next break point of operand\n         LTR   R15,R15             R15 -> comma or end of operand\n         BZ    COM2FIN             If no more operands, finished\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*     R15 -> end of operand (either comma or end of whole thing)      *\n*     R3 = pointer to the operand and suboperand                      *\n*     R15-R3, therefore, = length of that suboperand                  *\n*     R8 = pointer to the location on the card to insert an operand   *\n*     R9 = pointer to the last available column on that card          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the operand was terminated by a comma, include the comma in the  *\n* length so that the comma gets moved too.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   0(R15),C','         If the operand is terminated by a\n         BNE   COM2NOTC             comma, then include the comma in\n         LA    R15,1(,R15)           the length of the operand 2 move.\nCOM2NOTC DS    0H\n         SPACE 1\n         LR    R4,R15              Compute end - start giving...\n         SR    R4,R3                length of this suboperand\n         BNP   COM2SKIP            If not positive, bypass it\n         C     R4,JWAMAX           If length of operand is more'n max\n         BH    COM2DIE             then give up this whole JCL card\n         ST    R3,JWAUPTR          Store pointer in case we fail\n         LR    R1,R8               Output operand loc plus our length\n         AR    R1,R4               gives location of last output col\n         CR    R1,R9               If that's past last column\n         BH    COM2FAIL            then return failure - no room\n         LR    R1,R4               Get length of data to move\n         BCTR  R1,0                Reduce length for execute\n         EX    R1,INSMVC           Move operand to output JCL card\n         AR    R8,R4               Bump output pointer by operand len\nCOM2SKIP DS    0H\n         LR    R3,R15              Point to suboperand following comma\n         B     COM2LOOP            Go scan this next suboperand\n         SPACE 1\nCOM2FIN  DS    0H                  Succeeded in moving all pieces\n         SPACE 1\n         XR    R14,R14             Make a zero\n         ST    R14,JWAUPTR         Clear unmoved operand address\n         L     R14,JWASAVE         Reload return address\n         BR    R14                 Return in success\n         SPACE 1\nCOM2FAIL DS    0H                  Failed to move all pieces\n         SPACE 1\n         ST    R3,JWAUPTR          Set address of unmoved operand\n         L     R14,JWASAVE         Reload return address\n         BR    R14                 Return in failure\n         SPACE 1\nCOM2DIE  DS    0H                  Even suboperands are too long!!!\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Even suboperands are too long - display message and return          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TELL  DIEMSG              Display error message\n         LR    R1,R3               Get address of bad operand\n         LR    R0,R4               Get length of bad operand\n         TPUT  (1),(0),R           Show user the bad operand\n         L     R0,=A(DIEJMSG)      Get address of message area\n         ST    R0,IEMSGP           Store address of message area\n         LA    R15,IEMSG           RC = issue message and reenter exit\n         B     RETURN              Return\n         SPACE 1\nINNOBRK  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Since the whole operand we were asked to move is not greater than   *\n* 68 bytes in length, we can definitely move it to a JCL card...      *\n* if not this one, then the next one.  We see if we can fit it on     *\n* the remainder of the current card.  If so, fine.  If not, we tell   *\n* SUBMIT to accept this card and let us insert another one, which     *\n* will start with this operand that we couldn't process yet.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    R15,R8              Output operand loc plus our length\n         AR    R15,R4              gives location of last output col\n         CR    R15,R9              If that's past last column\n*                                  (or even =, since we need \",\" after)\n         BNL   INSFAIL             then return failure - no room\n         LTR   R15,R4              Get length of data to move\n         BNP   INSKIPMV            If zero, skip move\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,INSMVC          Move operand to output JCL card\nINSKIPMV DS    0H\n         AR    R8,R4               Bump output pointer by operand len\n         MVI   0(R8),C','          Move a comma to the output\n         LA    R8,1(,R8)           Bump past comma\n         XR    R0,R0               Make a zero\n         ST    R0,JWAUPTR          Clear unmoved-operand pointer\n         BR    R14                 Return success\n         SPACE 1\nINSFAIL  DS    0H                  Unable to move this operand\n         SPACE 1\n         ST    R3,JWAUPTR          Set pointer to unmoved data\n         BR    R14                 Return in failure\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Executed instructions                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING USERSECT,R8\n         SPACE 1\nUIDMOVE1 MVC   JWANAME(*-*),USERID      Move userid to jobname area\nUIDCOMP1 CLC   CURRCARD+2(*-*),USERID   Compare jobname to userid\nMOVEJWA  MVC   0(*-*,R2),0(R3)     Move operands to JOB stmt work area\nSCANDSN  TRT   0(*-*,R3),CHARTBL        Find end of dsname\nMVCTUPAR MVC   S99TUPAR(*-*),0(R3)      Move dsname to text unit\nINSMVC   MVC   0(*-*,R8),0(R3)     Executed: move operand to JCL card\nMVCKEY   MVC   JWAKEY(*-*),0(R6)   Executed: move keyword to test area\nKNMOVE   MVC   JWABUILD+7(*-*),JWAUID Move uid to op build area #EXIT34\nMVCUID   MVC   JWAUID(*-*),USERID  Executed: move userid to JWA #EXIT34\n         SPACE 1\n         DROP  R8\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Constants                                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCBJOBB   DC    CL5' JOB '\nCJOB     EQU   CBJOBB+1,4,C'C'     JOB card verb\nCSSSPASS DC    C'//*PASSWORD '     PASSWORD card stuff          #EXIT32\nPASWORDB EQU   CSSSPASS+3,9,C' '   C'PASSWORD '                 #EXIT32\nBLANKS   DC    CL80' '             General purpose blanks\n         SPACE 1\n*QUALTBL DC    256X'00'            TRT table to scan for equal  #EXIT32\n*        ORG   EQUALTBL+C'='                                    #EXIT32\n*        DC    X'01'                                            #EXIT32\n*        ORG   ,                                                #EXIT32\n         SPACE 1\nCHARTBL  DC    256XL1'01'          TRT table to find end of dsname\n         ORG   CHARTBL+C'.'\n         DC    X'00'               Period\n         ORG   CHARTBL+C'$'\n         DC    X'00'               Dollar sign\n         ORG   CHARTBL+C'#'\n         DC    X'00'               Sharp sign (gridlet)\n         ORG   CHARTBL+C'@'\n         DC    X'00'               At sign\n         ORG   CHARTBL+C'A'\n         DC    XL9'00'             A thru I\n         ORG   CHARTBL+C'J'\n         DC    XL9'00'             J thru R\n         ORG   CHARTBL+C'S'\n         DC    XL8'00'             S thru Z\n         ORG   CHARTBL+C'0'\n         DC    XL10'00'            0 thru 9\n         ORG   ,\n         SPACE 1\nJCHARTBL DC    256XL1'01'          TRT table to validate jobname\n         ORG   JCHARTBL+C'$'\n         DC    X'00'               Dollar sign\n         ORG   JCHARTBL+C'#'\n         DC    X'00'               Sharp sign (gridlet)\n         ORG   JCHARTBL+C'@'\n         DC    X'00'               At sign\n         ORG   JCHARTBL+C'A'\n         DC    XL9'00'             A thru I\n         ORG   JCHARTBL+C'J'\n         DC    XL9'00'             J thru R\n         ORG   JCHARTBL+C'S'\n         DC    XL8'00'             S thru Z\n         ORG   JCHARTBL+C'0'\n         DC    XL10'00'            0 thru 9\n         ORG   ,\n         SPACE 1\nDFLTTIME DC    C'TIME=1'           Default value for TIME= parameter\nDFLTREGN DC    C'REGION=10240K'    Default value for REGION= parameter\n*FLTMSGC DC    C'MSGCLASS=H'       Default value for MSGCLASS= parm\n         SPACE 1\nOPENM    OPEN  (0,(INPUT)),MF=L\nCLOSEM   CLOSE (0),MF=L\n         SPACE 1\n         LTORG\n         SPACE 1\nKEYTABLE DS    0A\n         DC    CL8'TIME    ',A(KTIME)\n         DC    CL8'REGION  ',A(KREGION)\n*        DC    CL8'MSGCLASS',A(KMSGCLAS)\n         DC    CL8'NOTIFY  ',A(KNOTIFY)\n         DC    CL8'PASSWORD',A(KPASSWOR)                        #EXIT43\nKEYTBEND EQU   *\n         SPACE 1\nGETPSWD  DC    C'Enter password for job being submitted:'\n         DC    X'24'               Print-bypass character\nGETPSWDL EQU   *-GETPSWD           Length of message for TPUT\n         SPACE 1\nBADJMSG  DS    0H\n         DC    Y(BADJTEXT-BADJMSG+L'BADJTEXT) Length of error message\nBADJTEXT DC    C'Invalid or missing JOB statement - SUBMIT processing tX\n               erminated.'\n         SPACE 1\nBADJCMSG DS    0H\n         DC    Y(BDJCTEXT-BADJCMSG+L'BDJCTEXT) Length of error message\nBDJCTEXT DC    C'Missing JOB statement continuation - SUBMIT processingX\n                terminated.'\n         SPACE 1\nDIEJMSG  DS    0H\n         DC    Y(DIEJTEXT-DIEJMSG+L'DIEJTEXT) Length of error message\nDIEJTEXT DC    C'Unable to generate JOB statement - SUBMIT processing tX\n               erminated.'\n         SPACE 1\nPSWDERR  DC    C'Password too long!'\nDIEMSG   DC    C'SUBMIT failed, operand too long to fit on JCL card:'\nBADOPMSG DC    C'SUBMIT JOB card syntax error - invalid operand:'\nDISMSG   DC    C'IKJEFF10 SUBMIT exit internal error finding workarea'\n         SPACE 1\n         PUSH  PRINT\n         PRINT NOGEN\nMODELDCB DCB   MACRF=E,DSORG=PO,   Treat all datasets as PO            X\n               DDNAME=X            DDNAME not specified\n         POP   PRINT\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IKJEFF10 Dynamic Work Areas                                         *\n*                                                                     *\n* Work areas are allocated as follows:                                *\n*                                                                     *\n*  (1) For the duration of JOB card processing, to build the new      *\n*      JOB card and write it out in 80-byte chunks                    *\n*                                                                     *\n*  (2) For PROCLIB DD statement processing, to do dynamic allocation  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IKJEFF10 JOB Card Work Area                                         *\n*                                                                     *\n*  For the duration of JOB card processing, to build the new          *\n*  JOB card and write it out in 80-byte chunks                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nJWA      DSECT ,                   Work area for JOB card processing\n         SPACE 2\nJWALEN   DS    A                   Length of this work area\nJWASAVE  DS    A                   A save area for subroutine calls\nJWAOFF   DS    A                   Offset of where we are in operands\nJWAEND   DS    A                   Address of end of collected operands\nJWARET   DS    A                   Continuation of output processing\nJWAONEXT DS    A                   Address of next operand to process\nJWAUPTR  DS    A                   Address of unmoved operand\nJWAUEND  DS    A                   Address of end of unmoved operand\nJWACOUNT DS    A                   Card count\nJWAMAX   DS    A                   Maximum size of an operand\nJWASAVE6 DS    A                   Another register save area\n*        DS    A                   (Deleted by usermod...)      #EXIT34\nJWAUIDL  DS    A                   Length of the userid minus 1\nJWALSTOP DS    A                   Address of last JOB stmt operand\nJWALSTOL DS    A                   Length of last JOB stmt operand\nJWAFLAGS DS    X\nJWATIME  EQU   B'10000000'         1 = TIME= found\nJWAREGN  EQU   B'01000000'         1 = REGION= found\n*WAMSGC  EQU   B'00100000'         1 = MSGCLASS= found\nJWADONE  EQU   B'00010000'         1 = finished processing JOB card\nJWACKLST EQU   B'00001000'         1 = checking for last operand\nJWAJCONT EQU   B'00000100'         1 = JOB card cont. expected  #EXIT28\nJWAKEY   DS    CL8                 Keyword from X=Y syntax\nJWAUID   DS    CL8                 Userid                       #EXIT34\nJWABUILD DS    CL80                Area to build new JCL operands\nJWACARD  DS    CL80                Area to build new JCL JOB cards\n         ORG   JWACARD             Map individual portions thereof\nJWASLSL  DS    C'//'\nJWANAME  DS    CL8                 Jobname\nJWABJOBB DS    C' JOB '\nJWAJOBOP DS    CL(80-(*-JWACARD))  First operands go here\nJWAOPS   EQU   JWACARD+3,80-3      Other operands go here\n         ORG   ,\nJWADATA  DS    0C                  Area to build JOB card...\n         SPACE 2\nJWAINCR  EQU   512                 JOB card work area size increment\n         EJECT\n***********************************************************************\n*                                                                     *\n* IKJEFF10 DD Card Work Area                                          *\n*                                                                     *\n*  For PROCLIB DD statement processing, to do dynamic allocation      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDWORK    DSECT ,                   Work area for DD card processing\n         SPACE 2\nSAVEAREA DS    18F                 Register save area\n         SPACE 1\nDDNAME   DS    CL8                 DD name\n         SPACE 1\n         PUSH  PRINT\n         PRINT NOGEN\nDCB      DCB   MACRF=E,DSORG=PO,   Treat all datasets as PO            X\n               DDNAME=X            DDNAME not specified\n         POP   PRINT\nDCBSIZE  EQU   *-DCB\nOPEN     OPEN  (0,(INPUT)),MF=L\nOPENSIZE EQU   *-OPEN\nCLOSE    CLOSE (0),MF=L\nCLOSESIZ EQU   *-CLOSE\n         SPACE 1\nDYNAREA  DS    CL120               Work area for dynamic allocation\n         SPACE 1                                                #EXIT32\nWORKEND  DS    0D                  Round to next doubleword\n         SPACE 2\nLDWORK   EQU   *-DWORK             Length of DD card workarea\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DSECT describing current JCL statement (pointed to by IECARDP)      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCARDSECT DSECT\n         SPACE 2\nCURRCARD DS    CL80\nCURRPSWD EQU   CURRCARD+12,8,C'C'  Area to read in the password\nCURRLST9 EQU   CURRCARD+71,9,C'C'  Area to move data around     #EXIT32\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DSECT describing submitter's TSO userid (pointed to by IEUSRIDP)    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nUSERSECT DSECT\n         SPACE 2\nUSERID   DS    CL8\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* System macro expansions                                             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This system mapping macro formats the parameter list and assigns    *\n* equates for the fields passed to this exit.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         IKJEFFIE IETYPE=SUBMIT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Dynamic allocation control block definitions and equates            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         IEFZB4D0\n         SPACE 2\n         IEFZB4D2\n         SPACE 2\nRBLEN    EQU   (S99RBEND-S99RB)\n         SPACE 3\n         END\n./ ADD NAME=IUCVUDP  0100-07332-07332-0900-01245-01245-00000-SEB\n         TITLE 'IUCVUDP  - Macros'\n         MACRO\n&SYM     TELL  &MSG,&MSGLEN\n         LCLC  &L\n&L       SETC  '&MSGLEN'\n         AIF   ('&L' NE '').GOTLEN\n&L       SETC  'L''&MSG'\n.GOTLEN  ANOP\n&SYM     LA    R1,&MSG\n         LA    R0,&L\n         TPUT  (1),(0),R\n         MEND\n         EJECT\n         MACRO\n&SYM     IPTELL &A,&B\n&SYM     TM    &A,&B\n         BNO   NOT_&B\n         TELL  MSG_&B\nNOT_&B   DS    0H\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWX &WHAT\n&SYM     XR    R0,R0\n         IC    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(3),DOUBLE\n         OI    NUMAREA+3-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWA &WHAT\n&SYM     ICM   R0,15,&WHAT\n         ST    R0,DOUBLE\n         UNPK  NUMAREA(9),DOUBLE(5)\n         TR    NUMAREA(8),HEXTBL\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(8),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+8\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWB &WHAT\n&SYM     XR    R0,R0\n         XR    R1,R1\n         ICM   R1,B'1000',&WHAT\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT.(3),=C' B\"'\n         LA    R14,MSGAREA+L'MSG_SHOW_&WHAT+3\n         LA    R15,8\nLOOP&SYSNDX DS 0H\n         XR    R0,R0\n         SLDL  R0,1\n         STC   R0,0(,R14)\n         OI    0(R14),X'F0'\n         LA    R14,1(,R14)\n         BCT   R15,LOOP&SYSNDX\n         MVI   0(R14),C'\"'\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+3+9\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWH &WHAT\n&SYM     LH    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(5),DOUBLE\n         OI    NUMAREA+5-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWF &WHAT\n&SYM     L     R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(11),DOUBLE\n         OI    NUMAREA+11-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWC &WHAT,&HOWLONG\n&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT\n         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG\n         MEND\n         MACRO\n&SYM     ISEND &WHAT,&BUFA,&BUFL,&ANSL\n         LCLC  &AL,&BL\n&AL      SETC  '&ANSL'\n&BL      SETC  '&BUFL'\n         AIF   ('&AL' NE '').AOK\n&AL      SETC  '256'\n.AOK     ANOP\n         AIF   ('&BL' NE '').BOK\n&BL      SETC  '40'\n.BOK     ANOP\n&SYM     DS    0H\n         TELL  MSG_&WHAT\n         AIF   ('&BL' EQ '0').NOMBUF\n         MVC   MYBUFFER(&BL),&BUFA\n.NOMBUF  ANOP  ,\n         MVC   MYBUFLEN,=Y(&BL)\n         MVC   MYANSLEN,=Y(&AL)\n         LA    R0,&WHAT\n         BAL   R14,SENDIUCV\n         MEND\n         MACRO\n&SYM     CKAUD &WHAT\n&SYM     LA    R8,MYEXTBUF\n         ICM   R15,7,IPAUDIT\n.******* N     R15,=B'11111110111111001111000000000000'\n         BZ    OK&SYSNDX\n         TELL  MSG_&WHAT._FAILED\n         B     SHOW_IPAUDIT_FIELDS\nOK&SYSNDX DS   0H\n         MEND\n         EJECT\n         MACRO\n&SYM     CKRET &WHAT\n&SYM     TM    ARETURN,X'80'\n         BZ    OL&SYSNDX\n         TELL  MSG_&WHAT._FAILED\n         B     SHOW_REASON\nOL&SYSNDX DS   0H\n         MEND\n         EJECT\n         TITLE 'IUCVUDP  - Program to demonstrate TCP/IP UDP via IUCV'\n***********************************************************************\n*                                                                     *\n* IUCVUDP  - Program to demonstrate TCP/IP UDP via IUCV               *\n*                                                                     *\n* Reference:                                                          *\n*                                                                     *\n*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *\n*                                                                     *\n*       TCP/IP for MVS Version 2:                                     *\n*       Using TCP/IP Sockets Using the MVS/Assembler/IUCV Interface   *\n*       Draft                                                         *\n*       Ron Lane, IBM T.J. Watson Research Center, TCP/IP Development *\n*       Yorktown Heights, NY                                          *\n*       Presented at SHARE 78, Anaheim, CA, March 1992                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    MYEXTBUF\nR7       EQU   7    External interrupt buffer base register\nR8       EQU   8    IPARML base register\nR9       EQU   9    Yet another static base register\nR10      EQU   10   Another static base register\nR11      EQU   11   .\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nIUCVUDP  CSECT\nIUCVUDP  AMODE 31\nIUCVUDP  RMODE 24\n         SAVE  (14,12),,IUCVUDP_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         LA    R10,4095(,R12)\n         LA    R10,1(,R10)\n         LA    R9,4095(,R10)\n         LA    R9,1(,R9)\n         USING IUCVUDP,R12,R10,R9\n         XR    R7,R7               Clear external interrupt buffer addr\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LA    R0,AREA_TO_CLEAR\n         LA    R1,LENGTH_OF_AREA_TO_CLEAR\n         XR    R14,R14\n         XR    R15,R15\n         MVCL  R0,R14              Clear getmained area\n         LR    R1,R2               Restore input parameter address\n         ST    R12,SAVER12\n         ST    R10,SAVER10\n         ST    R9,SAVER9\n         EJECT\n         TELL  MSG_HELLO\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Store PC numbers into areas that IUCV can use.                      *\n*                                                                     *\n***********************************************************************\n*\n         LA    R1,IUCVPTRS         Point to area to fill in\n         L     R15,=V(SNMPGPCN)    Routine to get the PC numbers\n         BALR  R14,R15             Go get the PC numbers\n         BNZ   NOPCNUMS            If error, no PC numbers\n*\n***********************************************************************\n*                                                                     *\n* Specify the External Interrupt Buffer used for IUCV calls.          *\n*                                                                     *\n***********************************************************************\n*\n         GETMAIN R,LV=EXTBUFDL\n         LR    R7,R1\n         ST    R7,EXTBUFAD         Set address of buffer for IUCV\n         XC    0(EXTBUFDL,R7),0(R7)\n         USING EXTBUFD,R7\n         ST    R13,EXTDATD\n         MVC   EXTSTUFF,=CL8'EXTSTUFF'\n         LA    R6,MYEXTBUF\n         LA    R8,MYEXTBUF\n         USING IPARML,R8           Field defined by SNMPPCN macro\n         ST    R6,@IPARML\n         SHOWA EXTBUFAD\n         SHOWA @IPARML\n         ST    R6,IUCVDBFR         Field defined by SNMPPCN macro\n*\nGO       DS    0H\n*\n         TELL  MSG_IUCV_DCLB\n*\n         IUCV  DCLBFR,                                                 X\n               PRMLIST=(R6),                                           X\n               BUFFER=(R6),                                            X\n               CONTROL=NO,                                             X\n               MF=L\n*\n* Register me to GCS as an IUCV user.\n*\n         MVC   MYNAME,=CL8'SEBTEST '\n         MVC   MYUSERID,=CL8'TCPIP '\n         LA    R2,MYNAME\n*\n         TELL  MSG_MINI_SET\n         IUCVMINI SET,                                                 X\n               NAME=(R2),          pick an 8-byte task-unique name     X\n               EXIT=IUCVIR,        routine to handle \"interrupts\"      X\n               UWORD=EXTSTUFF,     address passed to exit routine      X\n               ERROR=NOGCSSET\n*\n         LTR   R15,R15\n         BNZ   SETFAIL\n*\n* Connect me to TCP/IP\n*\n         MVC   MYUSRDTA(16),ZEROES\n         MVC   MYMSGLIM,=F'2'\n         LA    R6,MYEXTBUF\n         ST    R6,@IPARML\n         SHOWA @IPARML\n*\n         TELL  MSG_IUCV_CONN\n*\n         IUCV  CONNECT,                                                X\n               PRMLIST=(R6),                                           X\n               USERID=MYUSERID,                                        X\n               USERDTA=MYUSRDTA,                                       X\n               MSGLIM=MYMSGLIM,                                        X\n               PRMDATA=YES,                                            X\n               CONTROL=NO,                                             X\n               PRTY=NO,                                                X\n               MF=L\n*\n         LA    R2,MYNAME\n*\n         TELL  MSG_MCOM_CONN\n*\n         IUCVMCOM CONNECT,                                             X\n               NAME=(R2),                                              X\n               PRMLIST=(R6),       IPARML formatted by IUCV MF=L call  X\n               ERROR=NOGCSCON\n*\n         LTR   R15,R15\n         BNZ   CONFAIL\n*\n* PATHID should be in IPARML now (first 2 bytes thereof, and also the\n* first 2 bytes of External Interrupt Buffer).\n*\n         SHOWH IPPATHID\n*\n* Now wait for interrupt routine to respond.  It needs to do nothing,\n* just notify me that it was invoked as a Connection Complete interrupt\n* which it can verify in IR by: CLI IPTYPE,IPTYPCC...\n*\n         BAL   R14,WAIT            Wait for Connection Complete\n*\n* Now send a message to TCP/IP that we intend to do Socket Programming.\n*\n         XC    SOCKETNO,SOCKETNO   Preset socket number to zero\n         XC    MESSAGE1(MESSAGE1_LENGTH),MESSAGE1\n         MVC   APICONST,=CL8'IUCVAPI ' Say we want to send more msgs\n         XC    MAXSOCK,MAXSOCK     Max # sockets (<= 2000, 0=deflt=50)\n         MVC   FLAG,=H'2'          Say we want to do sockets\n         UNPK  SUBTSKID+1(7),X'21D'(4) TCB address\n         TR    SUBTSKID+1(6),HEXTBL\n         MVI   SUBTSKID+0,C'T'\n         MVI   SUBTSKID+7,C' '\n         SHOWC SUBTSKID,8\n*\n         ISEND TCPIP_SEND_INITIAL,MESSAGE1,MESSAGE1_LENGTH,8\n         CKAUD TCPIP_SEND_INITIAL\n         CKRET TCPIP_SEND_INITIAL\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n*\n* On return the reply buffer + 4 contains the maximum socket number.\n*\n         MVC   MAXSOCK#,AREASON\n         SHOWF MAXSOCK#\n*\n* Try some random stuff.\n*\n         ISEND TCPIP_GETHOSTID,0,0,8\n         CKAUD TCPIP_GETHOSTID\n         SHOWA ARETURN\n         MVC   MYIPADDR(4),ARETURN\n         SHOWA MYIPADDR\n*\nNAMELEN  EQU   64\n*\n         ISEND TCPIP_GETHOSTNAME,0,0,NAMELEN+8\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         CKAUD TCPIP_GETHOSTNAME\n         SHOWC AHOSTNAM,NAMELEN\n*\n* Send \"socket\" message to TCP/IP.\n*\n         MVC   MESSAGE1+0(4),=A(PF_INET)     domain\n******** MVC   MESSAGE1+4(4),=A(SOCK_DGRAM)  type:stream=tcp,dgram=udp\n         MVC   MESSAGE1+4(4),=A(SOCK_STREAM) type:stream=tcp,dgram=udp\n         MVC   MESSAGE1+8(4),=A(0)           protocol ???\n         MVC   MESSAGE1+12(4),=A(3)          choose a socket number?\n*\n         ISEND TCPIP_SOCKET,MESSAGE1,16,16\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         CKAUD TCPIP_SOCKET\n*\n* On return the reply buffer + 0 contains the socket number.\n*\n         L     R15,ARETURN         TCP/IP ANSBUF first word = socket #\n         STH   R15,SOCKETNO\n         SHOWH SOCKETNO\n*\n* Send \"bind\" message to TCP/IP.\n* Must specify IP address of my own machine.  This was obtained\n* via \"gethostid\".\n*\n         MVC   MESSAGE1+0(2),=Y(PF_INET)  sin_family\n         MVC   MESSAGE1+2(2),=Y(0)        sin_port\n         MVC   MESSAGE1+4(4),MYIPADDR     sin_addr\n         MVC   MESSAGE1+8(8),ZEROES       sin_zero\n*\nBIND     DS    0H\n*\n         ISEND TCPIP_BIND,MESSAGE1,16,16\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         CKAUD TCPIP_BIND\n         CKRET TCPIP_BIND\n*\n* Send \"connect\" message to TCP/IP.\n* Must specify IP address of the other machine.  There is no support\n* for \"gethostbyname\"  :-(\n*\n         MVC   YRIPADDR(4),=YL1(140,102,17,232) SecurID CISCO\n         MVC   PORT,=Y(3020)\n*\n         MVC   MESSAGE1+0(2),=Y(PF_INET)  sin_family\n         MVC   MESSAGE1+2(2),PORT         sin_port\n         MVC   MESSAGE1+4(4),YRIPADDR     sin_addr\n         MVC   MESSAGE1+8(8),ZEROES       sin_zero\n*\nCONNECT  DS    0H\n*\n         ISEND TCPIP_CONNECT,MESSAGE1,16,16\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         CKAUD TCPIP_CONNECT\n         CKRET TCPIP_CONNECT\n*\n* loop\n*\n*   \"send hi there\"\n*   \"receive 1000\"\n*   \"quit\"\n*\n*   ask \"Send, receive, or quit?\"\n*   get answer\n*   case answer\n*         \"send\"    -> ask data-to-send, call send data-to-send\n*         \"receive\" -> ask length-to-receive, call receive length---\n*         \"quit\"    -> exit loop\n*\n*\nLOOP     DS    0H\n         TELL  MSG_ASK_SEND_RECEIVE_OR_QUIT\n         TCLEARQ INPUT\n         TGET  ANSWER,L'ANSWER\n         LA    R1,ANSWER\n         LA    R0,ANSWER+L'ANSWER\nALOOP1   DS    0H                  Scan for first word of answer\n         CR    R1,R0\n         BNL   NOANSWER\n         CLI   0(R1),C' '\n         BE    ANEXT1\n         CLI   0(R1),C's'\n         BE    ASEND\n         CLI   0(R1),C'S'\n         BE    ASEND\n         CLI   0(R1),C'r'\n         BE    ARECV\n         CLI   0(R1),C'R'\n         BE    ARECV\n         CLI   0(R1),C'q'\n         BE    AQUIT\n         CLI   0(R1),C'Q'\n         BE    AQUIT\n         B     ABAD\nANEXT1   LA    R1,1(,R1)\n         B     ALOOP1\nABAD     DS    0H\n         TELL  MSG_BAD_ANSWER\n         B     LOOP\nNOANSWER DS    0H\n         B     LOOP\nASEND    DS    0H\nANEXT2   LA    R1,1(,R1)\nALOOP2   CR    R1,R0\n         BNL   ASKSEND\n         CLI   0(R1),C' '\n         BNE   ANEXT2\nANEXT3   LA    R1,1(,R1)\nALOOP3   CR    R1,R0\n         BNL   ASKSEND\n         CLI   0(R1),C' '\n         BE    ANEXT3\nGOTSEND  DS    0H\n         LR    R15,R0\n         BCTR  R15,0\nALOOP4   CLI   0(R15),C' '\n         BNE   AEND4\n         BCT   R15,ALOOP4\nAEND4    DS    0H\n*                                  R1 ->  first nonblank data\n*                                  R15 -> last  nonblank data\n         LA    R14,1(,R15)\n         SR    R14,R1              R0 = length to send\n         B     SEND\nASKSEND  DS    0H\n         TELL  MSG_ASK_DATA_TO_SEND\n         TCLEARQ INPUT\n         TGET  ANSWER,L'ANSWER\n         LA    R1,ANSWER\n         LA    R14,L'ANSWER\n         B     SEND\nSEND     DS    0H\n         XC    SENDPRE(L'SENDPRE),SENDPRE\n         MVI   SENDBUF,C' '\n         MVC   SENDBUF+1(L'SENDBUF-1),SENDBUF\n         BCTR  R14,0\n         EX    R14,MVCSEND\n         LA    R1,SENDBUF+L'SENDBUF-2\n         MVI   0(R1),X'0D'         Carriage return\n         MVI   1(R1),X'25'         Line feed\n         SHOWC SENDBUF,L'SENDBUF\n         TR    SENDBUF,EBCDIC_TO_ASCII\n         SHOWC SENDBUF,L'SENDBUF\n*\n* Send \"write\" message to TCP/IP.\n*\n         ISEND TCPIP_WRITE,SENDPRE,L'SENDBUF+L'SENDPRE,8\n         CKAUD TCPIP_WRITE\n         CKRET TCPIP_WRITE\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         B     LOOP\n*\nMVCSEND  MVC   SENDBUF(*-*),0(R1)\n*\nARECV    DS    0H\n*\n*\n* Send \"receive\" message to TCP/IP.\n*\nRECEIVE_LENGTH EQU 128\n*\nRECEIVE  DS    0H\n*\n         ISEND TCPIP_READ,0,0,RECEIVE_LENGTH+24\n         CKAUD TCPIP_READ\n         CKRET TCPIP_READ\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n*                                  ANSBUF + 8 = source address & port\n*                                  for RECEIVE only, not READ\n         SHOWF IPBFLN1F\n         SHOWF IPBFLN2F\n         SHOWC ARECDATA,RECEIVE_LENGTH\n* Translate from ASCII to EBCDIC.\n         MVC   ERECDATA,ARECDATA\n         TR    ERECDATA,ASCII_TO_EBCDIC\n         SHOWC ERECDATA,RECEIVE_LENGTH\n         B     LOOP\n*\nAQUIT    DS    0H\n*\n*\n* Send \"close\"  message to TCP/IP.\n*\n         ISEND TCPIP_CLOSE,0,0,8\n         CKAUD TCPIP_CLOSE\n         CKRET TCPIP_CLOSE\n         SHOWF ARETURN             ANSBUF + 0 = return code\n         SHOWF AREASON             ANSBUF + 4 = reason code\n         SHOWA AREASON             ANSBUF + 4 = reason code\n*\n* On return the reply buffer...?\n*\n*\n* ---\n*\n* other things that we will want to do\n*\n*        ISEND TCPIP_SEND,\n*        ISEND TCPIP_RECV,\n*\n* ---\n*\n         EJECT\n         B     RETURN0             Return with code 0\n         EJECT\nSHOW_IPAUDIT_FIELDS DS 0H\n         SPACE 1\n         IPTELL IPAUDIT1,IPADRPLE\n         IPTELL IPAUDIT1,IPADSNPX\n         IPTELL IPAUDIT1,IPADSNAX\n         IPTELL IPAUDIT1,IPADANPX\n         IPTELL IPAUDIT1,IPADANAX\n         IPTELL IPAUDIT1,IPADRJCT\n         IPTELL IPAUDIT1,IPADPRMD\n         IPTELL IPAUDIT2,IPADRCPX\n         IPTELL IPAUDIT2,IPADRCAX\n         IPTELL IPAUDIT2,IPADRPPX\n         IPTELL IPAUDIT2,IPADRPAX\n         IPTELL IPAUDIT2,IPADSVRD\n         IPTELL IPAUDIT2,IPADRLST\n         IPTELL IPAUDIT3,IPADBLEN\n         IPTELL IPAUDIT3,IPADALEN\n         IPTELL IPAUDIT3,IPADBTOT\n         IPTELL IPAUDIT3,IPADATOT\n         SPACE 1\n         SHOWB IPAUDIT1\n         SHOWB IPAUDIT2\n         SHOWB IPAUDIT3\n         B     RETURN12\n         EJECT\nSHOW_REASON DS 0H\n         SPACE 1\n         SHOWF AREASON\n         L     R15,AREASON\n         CH    R15,=H'999'\n         BH    RETURN12\n         SLL   R15,4\n         LA    R2,TCPERRAD(R15)\n         MVC   TCPERROR(16),0(R2)\n         SHOWC TCPERROR,16\n         B     RETURN12\n         EJECT\nNOPCNUMS DS    0H                  Cannot find PC numbers\n         SPACE 1\n         TELL  MSG_NOPCNUMS\n         B     RETURN12\n         EJECT\nNOGCSSET DS    0H\n         ST    R15,MYERROR\n         SHOWF MYERROR\n         TELL  MSG_NOGCSSET\n         B     RETURN12\n         EJECT\nNOGCSCON DS    0H\n         ST    R15,MYERROR\n         SHOWF MYERROR\n         TELL  MSG_NOGCSCON\n         B     RETURN12\n         EJECT\nSETFAIL  DS    0H\n         SPACE 1\n         TELL  MSG_SETFAIL\n         B     RETURN12\n         EJECT\nCONFAIL  DS    0H\n         SPACE 1\n         TELL  MSG_CONFAIL\n         B     RETURN12\n         EJECT\nRETURN12 DS    0H\n         TELL  MSG_FAILED\n         LA    R15,12              Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H\n         TELL  MSG_GOODBY\n         XR    R15,R15             Set return code to zero\n         B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LTR   R1,R7\n         BZ    NOFREEXB\n         LA    R0,EXTBUFDL\n         FREEMAIN R,LV=(0),A=(1)   Free the external interrupt buffer\nNOFREEXB DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nWAIT     DS    0H\n*\n         ST    R14,WAIT_R14\n         CLC   ECB(4),=F'0'\n         BNE   NOWAIT\n         TELL  MSG_WAITING\n         CLC   ECB(4),=F'0'\n         BNE   NOWAIT\n         WAIT  ECB=ECB             Wait for interrupt\n         TELL  MSG_WAITED\nNOWAIT   DS    0H\n         L     R14,WAIT_R14\n         BR    R14\n         EJECT\nSENDIUCV DS    0H\n*\n***********************************************************************\n*                                                                     *\n* Called for every TCP/IP request.  On entry it is assumed that the   *\n* fields BUFFER and BUFLEN are set.  R0 contains the request number.  *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,SENDIUCV_R14    Save return address\n         XC    IPAUDIT(3),IPAUDIT  Clear error flags\n         LA    R2,MYNAME\n         LA    R6,MYEXTBUF\n         LA    R4,MYBUFFER\n         LH    R5,MYBUFLEN\n         STH   R0,TARGCLAS         target class\n*\n*              DATA=PRMMSG,        code this if data inline\n*              PRMMSG=........,    code this if data inline\n*\n         TELL  MSG_IUCV_SEND\n*\n         LTR   R5,R5\n         BZ    SEND_WITH_DATA_PRMMSG\n*\n         IUCV SEND,                                                    X\n               PRMLIST=(R6),       formatted by IUCV MF=L              X\n               TRGCLS=TARGCLAS,    fullword with operation & socket #  X\n               DATA=BUFFER,        code this if data in buffer         X\n               BUFFER=(R4),                                            X\n               BUFLEN=(R5),                                            X\n               ANSBUF=MYANSBUF,                                        X\n               ANSLEN=MYANSLEN,                                        X\n               TYPE=2WAY,                                              X\n               PRTY=NO,                                                X\n               MF=L\n         B     RIUCVSEN\n*\nSEND_WITH_DATA_PRMMSG DS 0H\n*\n         IUCV SEND,                                                    X\n               PRMLIST=(R6),       formatted by IUCV MF=L              X\n               TRGCLS=TARGCLAS,    fullword with operation & socket #  X\n               DATA=PRMMSG,                                            X\n               PRMMSG=ZEROES,                                          X\n               ANSBUF=MYANSBUF,                                        X\n               ANSLEN=MYANSLEN,                                        X\n               TYPE=2WAY,                                              X\n               PRTY=NO,                                                X\n               MF=L\n         B     RIUCVSEN\n*\nRIUCVSEN DS    0H\n*\n         XC    ECB,ECB\n*\n         TELL  MSG_MCOM_SEND\n*\n         IUCVMCOM SEND,                                                X\n               NAME=(R2),                                              X\n               PRMLIST=(R6),       formatted by IUCV MF=L              X\n               ERROR=BADISEND\n*\n         LTR   R15,R15\n         BNZ   ICFAIL\n*\n* Wait for TCP/IP to return reply via interrupt.\n*\n         BAL   R14,WAIT            Wait for interrupt response\n         B     SENDIUCR\n*\nBADISEND DS    0H\n         ST    R15,MYERROR\n         SHOWF MYERROR\n         TELL  MSG_SENDFAIL\n         B     SENDIUCR\nICFAIL   DS    0H\n         TELL  MSG_ICFAIL\n         B     SENDIUCR\n*\nSENDIUCR DS    0H\n         L     R14,SENDIUCV_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\n         DROP  R7,R8,R9,R10,R12,R13\n         EJECT\nIUCVIR   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This is the routine that handles simulated external interrupts,     *\n* which is how TCP/IP passes information back to this program.        *\n*                                                                     *\n* On entry, R1 points to 4 bytes in front of the UWORD location.      *\n*                                                                     *\n***********************************************************************\n*\n         STM   R14,R12,12(R13)\n         L     R15,4(,R1)\n         L     R7,0(,R15)          R7 = UWORD = address of MYEXTBUF\n         USING EXTBUFD,R7\n         L     R11,EXTDATD\n         USING DATD,R11\n         L     R12,SAVER12\n         L     R10,SAVER10\n         L     R9,SAVER9\n         USING IUCVUDP,R12,R10,R9\n         TELL  MSG_IR_CALLED\n         LA    R6,MYEXTBUF         MYEXTBUF\n         LR    R8,R6               MYEXTBUF\n         USING IPARML,R8\n         ST    R8,@IPARML\n         SHOWA @IPARML\n         CLC   EXTSTUFF(8),=CL8'EXTSTUFF'\n         BE    EXTSTUFF_OK\n         SHOWC EXTSTUFF,8\nEXTSTUFF_OK DS 0H\n         TELL  MSG_FROM_EXTBUF\n         SHOWB IPTYPE\n*\n         POST  ECB                 Post ECB\n*\n         TELL  MSG_ECBPOSTED\n         LM    R14,R12,12(R13)\n         BR    R14                 Return to caller\n         EJECT\n         DROP  R7,R8,R11\n         EJECT\n         LTORG\n         EJECT\nMSG_HELLO     DC C'IUCV: Demonstrating IUCV interface to TCP/IP.'\nMSG_GOODBY    DC C'IUCV: Completed.'\nMSG_FAILED    DC C'IUCV: Terminated. '\nMSG_NOPCNUMS  DC C'IUCV: SNMPGPCN failed, no PC numbers set.'\nMSG_NOGCSSET  DC C'IUCV: IUCVMINI SET failed, error routine taken.'\nMSG_SETFAIL   DC C'IUCV: IUCVMINI SET failed, nonzero return code.'\nMSG_NOGCSCON  DC C'IUCV: IUCVMINI CONNECT failed, error routine taken.'\nMSG_CONFAIL   DC C'IUCV: IUCVMINI CONNECT failed, nonzero return code.'\nMSG_SENDFAIL  DC C'IUCV: IUCVMCOM SEND failed, error routine taken.'\nMSG_ICFAIL    DC C'IUCV: IUCVMCOM SEND failed, nonzero return code.'\nMSG_WAITING   DC C'IUCV: Waiting for external interrupt routine.'\nMSG_WAITED    DC C'IUCV: Returned from wait.'\nMSG_IUCV_DCLB DC C'IUCV: Doing IUCV DCLBFR.'\nMSG_MINI_SET  DC C'IUCV: Doing IUCVMINI SET.'\nMSG_IUCV_CONN DC C'IUCV: Doing IUCV CONNECT.'\nMSG_MCOM_CONN DC C'IUCV: Doing IUCVMCOM CONNECT.'\nMSG_IUCV_SEND DC C'IUCV: Doing IUCV SEND.'\nMSG_MCOM_SEND DC C'IUCV: Doing IUCVMCOM SEND.'\nMSG_ASK_SEND_RECEIVE_OR_QUIT DC C'IUCV: S(end), R(eceive), or Q(uit)?'\nMSG_ASK_DATA_TO_SEND         DC C'IUCV: Enter data to send:'\nMSG_BAD_ANSWER               DC C'IUCV: Bad answer (not S, R, or Q).'\n*\nMSG_IR_CALLED   DC C'IUCVIR: Interrupt routine called.'\nMSG_ECBPOSTED   DC C'IUCVIR: ECB posted.'\nMSG_FROM_EXTBUF DC C'IUCVIR: Data from MYEXTBUF.'\n*\nMSG_TCPIP_SEND_INITIAL         DC C'IUCV: Doing TCP/IP SEND INITIAL.'\nMSG_TCPIP_ACCEPT               DC C'IUCV: Doing TCP/IP ACCEPT.'\nMSG_TCPIP_BIND                 DC C'IUCV: Doing TCP/IP BIND.'\nMSG_TCPIP_CLOSE                DC C'IUCV: Doing TCP/IP CLOSE.'\nMSG_TCPIP_CONNECT              DC C'IUCV: Doing TCP/IP CONNECT.'\nMSG_TCPIP_FCNTL                DC C'IUCV: Doing TCP/IP FCNTL.'\nMSG_TCPIP_GETHOSTID            DC C'IUCV: Doing TCP/IP GETHOSTID.'\nMSG_TCPIP_GETHOSTNAME          DC C'IUCV: Doing TCP/IP GETHOSTNAME.'\nMSG_TCPIP_GETPEERNAME          DC C'IUCV: Doing TCP/IP GETPEERNAME.'\nMSG_TCPIP_GETSOCKNAME          DC C'IUCV: Doing TCP/IP GETSOCKNAME.'\nMSG_TCPIP_GETSOCKOPT           DC C'IUCV: Doing TCP/IP GETSOCKOPT.'\nMSG_TCPIP_IOCTL                DC C'IUCV: Doing TCP/IP IOCTL.'\nMSG_TCPIP_LISTEN               DC C'IUCV: Doing TCP/IP LISTEN.'\nMSG_TCPIP_READ                 DC C'IUCV: Doing TCP/IP READ.'\nMSG_TCPIP_READV                DC C'IUCV: Doing TCP/IP READV.'\nMSG_TCPIP_RECV                 DC C'IUCV: Doing TCP/IP RECV.'\nMSG_TCPIP_RECVFROM             DC C'IUCV: Doing TCP/IP RECVFROM.'\nMSG_TCPIP_RECVMSG              DC C'IUCV: Doing TCP/IP RECVMSG.'\nMSG_TCPIP_SELECT               DC C'IUCV: Doing TCP/IP SELECT.'\nMSG_TCPIP_SEND                 DC C'IUCV: Doing TCP/IP SEND.'\nMSG_TCPIP_SENDTO               DC C'IUCV: Doing TCP/IP SENDTO.'\nMSG_TCPIP_SETSOCKOPT           DC C'IUCV: Doing TCP/IP SETSOCKOPT.'\nMSG_TCPIP_SHUTDOWN             DC C'IUCV: Doing TCP/IP SHUTDOWN.'\nMSG_TCPIP_SOCKET               DC C'IUCV: Doing TCP/IP SOCKET.'\nMSG_TCPIP_WRITE                DC C'IUCV: Doing TCP/IP WRITE.'\nMSG_TCPIP_WRITEV               DC C'IUCV: Doing TCP/IP WRITEV.'\nMSG_TCPIP_GETCLIENTID          DC C'IUCV: Doing TCP/IP GETCLIENTID.'\nMSG_TCPIP_GIVESOCKET           DC C'IUCV: Doing TCP/IP GIVESOCKET.'\nMSG_TCPIP_TAKESOCKET           DC C'IUCV: Doing TCP/IP TAKESOCKET.'\nMSG_TCPIP_SEND_INITIAL_FAILED  DC C'IUCV: TCP/IP SEND INITIAL failed.'\nMSG_TCPIP_ACCEPT_FAILED        DC C'IUCV: TCP/IP ACCEPT failed.'\nMSG_TCPIP_BIND_FAILED          DC C'IUCV: TCP/IP BIND failed.'\nMSG_TCPIP_CLOSE_FAILED         DC C'IUCV: TCP/IP CLOSE failed.'\nMSG_TCPIP_CONNECT_FAILED       DC C'IUCV: TCP/IP CONNECT failed.'\nMSG_TCPIP_FCNTL_FAILED         DC C'IUCV: TCP/IP FCNTL failed.'\nMSG_TCPIP_GETHOSTID_FAILED     DC C'IUCV: TCP/IP GETHOSTID failed.'\nMSG_TCPIP_GETHOSTNAME_FAILED   DC C'IUCV: TCP/IP GETHOSTNAME failed.'\nMSG_TCPIP_GETPEERNAME_FAILED   DC C'IUCV: TCP/IP GETPEERNAME failed.'\nMSG_TCPIP_GETSOCKNAME_FAILED   DC C'IUCV: TCP/IP GETSOCKNAME failed.'\nMSG_TCPIP_GETSOCKOPT_FAILED    DC C'IUCV: TCP/IP GETSOCKOPT failed.'\nMSG_TCPIP_IOCTL_FAILED         DC C'IUCV: TCP/IP IOCTL failed.'\nMSG_TCPIP_LISTEN_FAILED        DC C'IUCV: TCP/IP LISTEN failed.'\nMSG_TCPIP_READ_FAILED          DC C'IUCV: TCP/IP READ failed.'\nMSG_TCPIP_READV_FAILED         DC C'IUCV: TCP/IP READV failed.'\nMSG_TCPIP_RECV_FAILED          DC C'IUCV: TCP/IP RECV failed.'\nMSG_TCPIP_RECVFROM_FAILED      DC C'IUCV: TCP/IP RECVFROM failed.'\nMSG_TCPIP_RECVMSG_FAILED       DC C'IUCV: TCP/IP RECVMSG failed.'\nMSG_TCPIP_SELECT_FAILED        DC C'IUCV: TCP/IP SELECT failed.'\nMSG_TCPIP_SEND_FAILED          DC C'IUCV: TCP/IP SEND failed.'\nMSG_TCPIP_SENDTO_FAILED        DC C'IUCV: TCP/IP SENDTO failed.'\nMSG_TCPIP_SETSOCKOPT_FAILED    DC C'IUCV: TCP/IP SETSOCKOPT failed.'\nMSG_TCPIP_SHUTDOWN_FAILED      DC C'IUCV: TCP/IP SHUTDOWN failed.'\nMSG_TCPIP_SOCKET_FAILED        DC C'IUCV: TCP/IP SOCKET failed.'\nMSG_TCPIP_WRITE_FAILED         DC C'IUCV: TCP/IP WRITE failed.'\nMSG_TCPIP_WRITEV_FAILED        DC C'IUCV: TCP/IP WRITEV failed.'\nMSG_TCPIP_GETCLIENTID_FAILED   DC C'IUCV: TCP/IP GETCLIENTID failed.'\nMSG_TCPIP_GIVESOCKET_FAILED    DC C'IUCV: TCP/IP GIVESOCKET failed.'\nMSG_TCPIP_TAKESOCKET_FAILED    DC C'IUCV: TCP/IP TAKESOCKET failed.'\n*\nMSG_SHOW_IPPATHID  DC  C'IUCV: PATHID             = '\nMSG_SHOW_IPAUDIT1  DC  C'IUCV: IPAUDIT1           = '\nMSG_SHOW_IPAUDIT2  DC  C'IUCV: IPAUDIT2           = '\nMSG_SHOW_IPAUDIT3  DC  C'IUCV: IPAUDIT3           = '\nMSG_SHOW_IPBFLN1F  DC  C'IUCV: IPNFLN1F           = '\nMSG_SHOW_IPBFLN2F  DC  C'IUCV: IPNFLN2F           = '\nMSG_SHOW_ARETURN   DC  C'IUCV: ANSBUF return code = '\nMSG_SHOW_AREASON   DC  C'IUCV: ANSBUF reason code = '\nMSG_SHOW_AHOSTNAM  DC  C'IUCV: ANSBUF host name   = '\nMSG_SHOW_ARECFROM  DC  C'IUCV: RECEIVE addr/port (ASCII)  = '\nMSG_SHOW_ARECDATA  DC  C'IUCV: RECEIVE data      (ASCII)  = '\nMSG_SHOW_ERECFROM  DC  C'IUCV: RECEIVE addr/port (EBCDIC) = '\nMSG_SHOW_ERECDATA  DC  C'IUCV: RECEIVE data      (EBCDIC) = '\nMSG_SHOW_SOCKETNO  DC  C'IUCV: Socket number      = '\nMSG_SHOW_SUBTSKID  DC  C'IUCV: Subtask ID         = '\nMSG_SHOW_MYERROR   DC  C'IUCV: Error code         = '\nMSG_SHOW_MAXSOCK#  DC  C'IUCV: Max socket number  = '\nMSG_SHOW_TCPERROR  DC  C'IUCV: TCP error code     = '\n*\nMSG_SHOW_EXTBUFAD  DC  C'IUCV: EXTBUFAD contains '\nMSG_SHOW_@IPARML   DC  C'IUCV: IPARML (EXTBUF) at '\nMSG_SHOW_EXTSTUFF  DC  C'IUCVIR: Uh-oh, EXTSTUFF  = '\nMSG_SHOW_IPTYPE    DC  C'IUCVIR: IPTYPE           = '\nMSG_SHOW_MYIPADDR  DC  C'IUCV: MYIPADDR           = '\nMSG_SHOW_SENDBUF   DC  C'IUCV: SENDBUF            = '\n*\nMSG_IPADRPLE DC C'IPADRRPLE: REPLY TOO LONG FOR BUFFER'\nMSG_IPADSNPX DC C'IPADSNPX : PROTECTION EXCEPTION ON SEND BUFFER'\nMSG_IPADSNAX DC C'IPADSNAX : ADDRESSING EXCEPTION ON SEND BUFFER'\nMSG_IPADANPX DC C'IPADANPX : PROTECTION EXCEPTION ANSWER BUFFER'\nMSG_IPADANAX DC C'IPADANAX : ADDRESSING EXCEPTION ANSWER BUFFER'\nMSG_IPADRJCT DC C'IPADRJCT : MESSAGE WAS REJECTED'\nMSG_IPADPRMD DC C'IPADPRMD : REPLY SENT IN PARAMETER LIST'\n*\nMSG_IPADRCPX DC C'IPADRCPX : PROTECTION EXCEPTION RECEIVE BUFFER'\nMSG_IPADRCAX DC C'IPADRCAX : ADDRESSING EXCEPTION RECEIVE BUFFER'\nMSG_IPADRPPX DC C'IPADRPPX : PROTECTION EXCEPTION REPLY BUFFER'\nMSG_IPADRPAX DC C'IPADRPAX : ADDRESSING EXCEPTION REPLY BUFFER'\nMSG_IPADSVRD DC C'IPADSVRD : PATH WAS SEVERED'\nMSG_IPADRLST DC C'IPADRLST : INVALID RECEIVE/REPLY LIST'\n*\nMSG_IPADBLEN DC C'IPADBLEN : BAD LENGTH IN SEND BUFFER LIST'\nMSG_IPADALEN DC C'IPADALEN : BAD LENGTH IN SEND ANSWER LIST'\nMSG_IPADBTOT DC C'IPADBTOT : INVALID TOTAL SEND BUFFER LENGTH'\nMSG_IPADATOT DC C'IPADATOT : INVALID TOTAL SEND ANSWER LENGTH'\n*\n         DS    0C\n*\nTCPERRAD EQU   *-16\n  DC CL16'EPERM'        1               /* Not owner */\n  DC CL16'ENOENT'       2               /* No such file or directory */\n  DC CL16'ESRCH'        3               /* No such process */\n  DC CL16'EINTR'        4               /* Interrupted system call */\n  DC CL16'EIO'          5               /* I/O error */\n  DC CL16'ENXIO'        6               /* No such device or address */\n  DC CL16'E2BIG'        7               /* Arg list too long */\n  DC CL16'ENOEXEC'      8               /* Exec format error */\n  DC CL16'EBADF'        9               /* Bad file number */\n  DC CL16'ECHILD'       10              /* No children */\n  DC CL16'EAGAIN'       11              /* No more processes */\n  DC CL16'ENOMEM'       12              /* Not enough core */\n  DC CL16'EACCES'       13              /* Permission denied */\n  DC CL16'EFAULT'       14              /* Bad address */\n  DC CL16'ENOTBLK'      15              /* Block device required */\n  DC CL16'EBUSY'        16              /* Mount device busy */\n  DC CL16'EEXIST'       17              /* File exists */\n  DC CL16'EXDEV'        18              /* Cross-device link */\n  DC CL16'ENODEV'       19              /* No such device */\n  DC CL16'ENOTDIR'      20              /* Not a directory*/\n  DC CL16'EISDIR'       21              /* Is a directory */\n  DC CL16'EINVAL'       22              /* Invalid argument */\n  DC CL16'ENFILE'       23              /* File table overflow */\n  DC CL16'EMFILE'       24              /* Too many open files */\n  DC CL16'ENOTTY'       25              /* Not a typewriter */\n  DC CL16'ETXTBSY'      26              /* Text file busy */\n  DC CL16'EFBIG'        27              /* File too large */\n  DC CL16'ENOSPC'       28              /* No space left on device */\n  DC CL16'ESPIPE'       29              /* Illegal seek */\n  DC CL16'EROFS'        30              /* Read-only file system */\n  DC CL16'EMLINK'       31              /* Too many links */\n  DC CL16'EPIPE'        32              /* Broken pipe */\n  DC CL16' '   33\n  DC CL16' '   34\n  DC CL16'EWOULDBLOCK'  35              /* Operation would block */\n  DC CL16'EINPROGRESS'  36              /* Operation now in progress */\n  DC CL16'EALREADY'     37              /* Operation already in\\\n  DC CL16'ENOTSOCK'     38              /* Socket operation on\\\n  DC CL16'EDESTADDRREQ' 39              /* Destination address required\n  DC CL16'EMSGSIZE'     40              /* Message too long */\n  DC CL16'EPROTOTYPE'   41              /* Protocol wrong type for\\\n  DC CL16'ENOPROTOOPT'  42              /* Protocol not available */\n  DC CL16'EPROTONOSUPPORT' 43           /* Protocol not supported */\n  DC CL16'ESOCKTNOSUPPORT' 44           /* Socket type not supported */\n  DC CL16'EOPNOTSUPP'   45              /* Operation not supported on\\\n  DC CL16'EPFNOSUPPORT' 46              /* Protocol family not\\\n  DC CL16'EAFNOSUPPORT' 47              /* Address family not supported\n  DC CL16'EADDRINUSE'   48              /* Address already in use */\n  DC CL16'EADDRNOTAVAIL' 49             /* Can't assign requested\\\n  DC CL16'ENETDOWN'     50              /* Network is down */\n  DC CL16'ENETUNREACH'  51              /* Network is unreachable */\n  DC CL16'ENETRESET'    52             /* Network dropped connection on\n  DC CL16'ECONNABORTED' 53              /* Software caused connection\\\n  DC CL16'ECONNRESET'   54              /* Connection reset by peer */\n  DC CL16'ENOBUFS'      55              /* No buffer space available */\n  DC CL16'EISCONN'      56              /* Socket is already connected\\\n  DC CL16'ENOTCONN'     57              /* Socket is not connected */\n  DC CL16'ESHUTDOWN'    58              /* Can't send after socket\\\n  DC CL16'ETOOMANYREFS' 59              /* Too many references: can't\\\n  DC CL16'ETIMEDOUT'    60              /* Connection timed out */\n  DC CL16'ECONNREFUSED' 61              /* Connection refused */\n  DC CL16'ELOOP'        62              /* Too many levels of symbolic\\\n  DC CL16'ENAMETOOLONG' 63              /* File name too long */\n  DC CL16'EHOSTDOWN'    64              /* Host is down */\n  DC CL16'EHOSTUNREACH' 65              /* No route to host */\n  DC CL16'ENOTEMPTY'    66              /* Directory not empty */\n  DC CL16'EPROCLIM'     67              /* Too many processes */\n  DC CL16'EUSERS'       68              /* Too many users */\n  DC CL16'EDQUOT'       69              /* Disc quota exceeded */\n  DC CL16'ESTALE'       70              /* Stale NFS file handle */\n  DC CL16'EREMOTE'      71              /* Too many levels of remote in\n  DC CL16'ENOSTR'       72              /* Device is not a stream */\n  DC CL16'ETIME'        73              /* Timer expired */\n  DC CL16'ENOSR'        74              /* Out of streams resources */\n  DC CL16'ENOMSG'       75              /* No message of desired type *\n  DC CL16'EBADMSG'      76              /* Trying to read unreadable\\\n  DC CL16'EIDRM'        77              /* Identifier removed */\n  DC CL16'EDEADLK'      78              /* Deadlock condition. */\n  DC CL16'ENOLCK'       79              /* No record locks available.*/\n  DC CL16'ENONET'       80              /* Machine is not on the\\\n  DC CL16'ERREMOTE'     81              /* Object is remote */\n  DC CL16'ENOLINK'      82              /* the link has been severed */\n  DC CL16'EADV'         83              /* advertise error */\n  DC CL16'ESRMNT'       84              /* srmount error */\n  DC CL16'ECOMM'        85              /* Communication error on send\\\n  DC CL16'EPROTO'       86              /* Protocol error */\n  DC CL16'EMULTIHOP'    87              /* multihop attempted */\n  DC CL16'EDOTDOT'      88              /* Cross mount point (not an\\\n  DC CL16'EREMCHG'      89              /* Remote address changed */\n         SPACE 1\nASCII_TO_EBCDIC DS 0C              from 'TCPIP.STANDARD.TCPXLBIN'\n         SPACE 1\n         DC    X'00010203372D2E2F1605250B0C0D0E0F'\n         DC    X'101112133C3D322618193F271C1D1E1F'\n         DC    X'405A7F7B5B6C507D4D5D5C4E6B604B61'\n         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'\n         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'\n         DC    X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'\n         DC    X'79818283848586878889919293949596'\n         DC    X'979899A2A3A4A5A6A7A8A9C04FD0A107'\n         DC    X'00010203372D2E2F1605250B0C0D0E0F'\n         DC    X'101112133C3D322618193F271C1D1E1F'\n         DC    X'405A7F7B5B6C507D4D5D5C4E6B604B61'\n         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'\n         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'\n         DC    X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'\n         DC    X'79818283848586878889919293949596'\n         DC    X'979899A2A3A4A5A6A7A8A9C04FD0A107'\n         SPACE 1\nEBCDIC_TO_ASCII DS 0C              from 'TCPIP.STANDARD.TCPXLBIN'\n         SPACE 1\n         DC    X'00010203FF09FF7FFFFFFF0B0C0D0E0F'\n         DC    X'10111213FFFF08FF1819FFFF1C1D1E1F'\n         DC    X'FFFFFFFFFF0A171BFFFFFFFFFF050607'\n         DC    X'FFFF16FFFFFFFF04FFFFFFFF1415FF1A'\n         DC    X'20FFFFFFFFFFFFFFFFFFFF2E3C282B7C'\n         DC    X'26FFFFFFFFFFFFFFFFFF21242A293B5E'\n         DC    X'2D2FFFFFFFFFFFFFFFFFFF2C255F3E3F'\n         DC    X'FF5EFFFFFFFFFFFFFF603A2340273D22'\n         DC    X'FF616263646566676869FF7BFFFFFFFF'\n         DC    X'FF6A6B6C6D6E6F707172FFFFFFFFFFFF'\n         DC    X'FF7E737475767778797AFFFFFF5BFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFF5DFFFF'\n         DC    X'7B414243444546474849FFFFFFFFFFFF'\n         DC    X'7D4A4B4C4D4E4F505152FFFFFFFFFF82'\n         DC    X'5CFF535455565758595AFFFFFFFFFFFF'\n         DC    X'30313233343536373839FFFFFFFF82FF'\n         SPACE 1\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n*\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\nZEROES   DC    XL256'00'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n*\nSAVEAREA DS    18F\n*\nSAVER12  DS    F\nSAVER10  DS    F\nSAVER9   DS    F\n*\nAREA_TO_CLEAR EQU *\n*\nDOUBLE   DS    D                   For conversions\nMYIPADDR DS    F                   My IP address\nYRIPADDR DS    F                   Your IP address\n@IPARML  DS    A                   Address of IPARML\nSENDIUCV_R14 DS A                  Save area for SENDIUCV subroutine\nWAIT_R14     DS A                  Save area for WAIT     subroutine\n*\nIUCVSAVE DS    0F\nIUCVSR14 DS    F\nIUCVSR15 DS    F\nIUCVSR0  DS    F\nIUCVSR1  DS    F\nIUCVSR2  DS    F\nIUCVSR3  DS    F\nIUCVSR4  DS    F\nIUCVSR5  DS    F\nIUCVSR6  DS    F\nIUCVSR7  DS    F\nIUCVSR8  DS    F\nIUCVSR9  DS    F\nIUCVSR10 DS    F\nIUCVSR11 DS    F\nIUCVSR12 DS    F\n*\nMYBUFLEN DS    H\nMYANSLEN DS    H\nPORT     DS    H\n*\nIRSTUFF  DS    F                   R1 points here at entry to I.R.\nMYERROR  DS    F\nMYUWORD  DS    F                   User word for interrupt\nMYMSGLIM DS    F                   Message limit for IUCV CONNECT\nEXTBUFAD DS    F                   Address of external interrupt buffer\nTARGCLAS DS    F                   Target class\nMAXSOCK# DS    F                   Maximum socket number\n*\nSOCKETNO EQU   TARGCLAS+2,2,C'H'\n*\n* Fields to send to TCP/IP\n*\nMESSAGE1 DS    0XL20\nAPICONST DS    CL8\nMAXSOCK  DS    H\nFLAG     DS    H\nSUBTSKID DS    CL8\nMESSAGE1_LENGTH EQU *-MESSAGE1\n*\nTCPERROR DS    CL16\n*\nMYNAME   DS    CL8                 Name IUCV knows me by\nMYUSERID DS    CL8                 Name to ask for TCP/IP by\nMYUSRDTA DS    XL16                User data for IUCV CONNECT\n         DS    0D\nMYANSBUF DS    XL256\nMYBUFFER DS    XL256\n*\nARETURN  EQU   MYANSBUF+0,4,C'F'   TCP/IP return code\nAREASON  EQU   MYANSBUF+4,4,C'F'   TCP/IP reason code\nAHOSTNAM EQU   MYANSBUF+8,0,C'C'\nARECFROM EQU   MYANSBUF+8,16,C'C'\nARECDATA EQU   MYANSBUF+24,0,C'C'\n*\nERECFROM DS    CL16\nERECDATA DS    CL256\n*\nNUMAREA  DS    CL12                Area for number conversion\nTXTAREA  DS    CL64                Area for text\nMSGAREA  DS    CL218               Area for message text\nANSWER   DS    CL200\nSENDPRE  DS    CL20\nSENDBUF  DS    CL236\n*\n         SNMPPCN SECT=CSECT\n*\nLENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR\n*\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\nEXTBUFD  DSECT ,                   Map the external interrupt buffer\n*\nEXTSTUFF DS    XL16\nMYEXTBUF DS    XL40\nECB      DS    F\nEXTDATD  DS    F\n*\nEXTBUFDL EQU   *-EXTBUFD\n*\n         EJECT\n*\n***********************************************************************\n* Miscellaneous equates                                               *\n***********************************************************************\n*\n*\n* equates for TCP/IP requests\n*\nTCPIP_SEND_INITIAL  EQU 0\nTCPIP_ACCEPT        EQU 1\nTCPIP_BIND          EQU 2\nTCPIP_CLOSE         EQU 3\nTCPIP_CONNECT       EQU 4\nTCPIP_FCNTL         EQU 5\nTCPIP_GETHOSTID     EQU 7\nTCPIP_GETHOSTNAME   EQU 8\nTCPIP_GETPEERNAME   EQU 9\nTCPIP_GETSOCKNAME   EQU 10\nTCPIP_GETSOCKOPT    EQU 11\nTCPIP_IOCTL         EQU 12\nTCPIP_LISTEN        EQU 13\nTCPIP_READ          EQU 14\nTCPIP_READV         EQU 14\nTCPIP_RECV          EQU 16\nTCPIP_RECVFROM      EQU 16\nTCPIP_RECVMSG       EQU 16\nTCPIP_SELECT        EQU 19\nTCPIP_SEND          EQU 20\nTCPIP_SENDTO        EQU 22\nTCPIP_SETSOCKOPT    EQU 23\nTCPIP_SHUTDOWN      EQU 24\nTCPIP_SOCKET        EQU 25\nTCPIP_WRITE         EQU 26\nTCPIP_WRITEV        EQU 26\nTCPIP_GETCLIENTID   EQU 30\nTCPIP_GIVESOCKET    EQU 31\nTCPIP_TAKESOCKET    EQU 32\n*\nPF_INET             EQU  2\n*\nSOCK_STREAM         EQU  1       stream socket\nSOCK_DGRAM          EQU  2       datagram socket\nSOCK_RAW            EQU  3       raw-protocol interface\nSOCK_RDM            EQU  4       reliably-delivered message\nSOCK_SEQPACKET      EQU  5       sequenced packet stream\n*\n         EJECT\n*\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n*\n******** MVPXVMCV ,                VMCF stuff\n*\n         COPY  IPARML              Map the IPARML dsect\n*\n         PRINT NOGEN\n*\n         IEFJESCT\n         IEFJSCVT\n         CVT   DSECT=YES\n         IHAPSA\n*\n         END\n./ ADD NAME=PBRHLPA  0100-07332-07332-0900-00014-00014-00000-SEB\nPBRHLPA  CSECT\n         USING PBRHLPA,15\n         ST    14,SALVE\n         L     15,=V(PBRHLPR)\n         DROP  15\n         BALR  14,15\n         USING *,14\n         L     14,SALVE\n         DROP  14\n         LR    15,0\n         BR    14\n         SPACE 1\nSALVE    DS    F\n         END\n./ ADD NAME=PROMPT   0100-07332-07332-0900-00143-00143-00000-SEB\n         TITLE 'PROMPT - PROGRAM TO TEST PUTGET ROUTINES'\n***********************************************************************\n*                                                                     *\n* PROMPT - A TSO COMMAND PROCESSOR TO TEST THE PUTGET ROUTINE.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nPROMPT   CSECT\n         SAVE  (14,12),,PROMPT_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING PROMPT,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS\n         EJECT\n         MVC   CPPL(16),0(R1)      SAVE CPPL\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         LA    R0,ECB\n         ST    R0,IOPLECB\n         MVC   PGLIST(PGLEN),SPGLIST\n         LOAD  EP=IKJPTGT          LOAD PUTGET FROM OUR LIBRARY\n         ST    R0,@PUTGET          SAVE ITS ADDRESS\n         SPACE 3\nREPEAT   DS    0H                  MAIN PROGRAM LOOP\n         XC    ECB,ECB             CLEAR ECB\n         L     R15,@PUTGET\n         PUTGET PARM=PGLIST,MF=(E,IOPL),ENTRY=(15),                    X\n               OUTPUT=(PROMOLD1,MULTLVL,PROMPT)\n         MVC   RMSG(L'SRMSG),SRMSG\n         LR    R4,R15              SAVE RETURN CODE\n         CVD   R4,DOUBLE\n         UNPK  RCODE(2),DOUBLE\n         OI    RCODE+1,X'F0'\n         LA    R1,RMSG\n         LA    R0,L'RMSG+2\n         TPUT  (1),(0),R\n         L     R3,PGLIST+12        GET ADDRESS OF INPUT BUFFER\n         LTR   R3,R3               IF NONE,\n         BZ    RETURNP              DON'T DISPLAY IT\n         LA    R1,4(,R3)           POINT TO INPUT TEXT\n         LH    R0,0(,R3)           GET LENGTH OF INPUT BUFFER\n         SH    R0,=H'4'            SUBTRACT HEADER LENGTH\n         BZ    RETURNP             IF NULL LINE, PROGRAM TERMINATED\n         TPUT  (1),(0),R           ECHO INPUT BUFFER TO TERMINAL\n         EJECT\nRETURNP  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         DELETE EP=IKJPTGT\n         SPACE\n         LR    R15,R4              SET RETURN CODE TO = PUTGET RC\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nPROMOLD1 DC    A(PROMOLD2,1,PROMMSG1)\nPROMOLD2 DC    A(0,1,PROMMSG2)\n         SPACE 1\nSPGLIST  PUTGET MF=L,OUTPUT=(*-*,MULTLVL,PROMPT)\nPGLEN    EQU   *-SPGLIST\n         SPACE 1\nPROMMSG1 WTO   MF=L,' PLEASE REPLY TO PROMPT+'\nPROMMSG2 WTO   MF=L,' PLEASE ENTER SOMETHING IN REPLY TO THE PROMPT MESX\n               SAGE DISPLAYED ABOVE'\n         SPACE 1\nSRMSG    DC    C'PROMPT: PUTGET RETURN CODE WAS '\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\n@PUTGET  DS    A                   ADDRESS OF PUTGET ROUTINE\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\nCPPL     DS    0A\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\nIOPL     DS    0A\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\nPGLIST   PUTGET MF=L\n         SPACE 1\nRMSG     DS    CL(L'SRMSG)\nRCODE    DS    CL2\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=RECSIZE  0100-07332-07332-0900-00037-00037-00000-SEB\n***********************************************************************\n*                                                                     *\n* PROCEDURE NAME:  RECSIZE                                            *\n*                                                                     *\n* FUNCTION:  TO RETURN THE RECORD SIZE OF A FILE TO A PL/1 PROGRAM.   *\n*                                                                     *\n* DECLARATION:                                                        *\n*                                                                     *\n*     DCL RECSIZE EXTERNAL ENTRY(FILE) RETURNS(FIXED(31) BIN);        *\n*                                                                     *\n* SAMPLE INVOCATION:                                                  *\n*                                                                     *\n*     I = RECSIZE(SYSPRINT);                                          *\n*                                                                     *\n***********************************************************************\n         SPACE\nRECSIZE  CSECT\n         USING RECSIZE,15\n         STM   14,4,12(13)\n         LM    2,3,0(1)            R2 -> ADDR(DCLCB), R3 -> RETURN AREA\n         L     2,0(,2)             R2 -> DCLCB\n         L     1,4(,12)            R1 -> PRV\n         AH    1,2(,2)              ADD OFFSET OF FCB PTR IN PRV\n         ICM   4,15,0(1)           R4 -> FCB\n         BZ    NODCB               IF NO FCB, TRY USING RECSZ IN DCLCB\n         ICM   4,15,20(4)          R4 -> DCB\n         BZ    NODCB               IF NO DCB, TRY USING RECSZ IN DCLCB\n         LH    0,82(,4)            R0 = DCBLRECL\n         B     RETURN\nNODCB    DS    0H                  NO DCB, USE RECSIZE FIELD IN DCLCB\n         L     4,12(,2)            R4 -> DENV\n         L     4,16(,4)            R4 -> NREC\n         L     0,0(,4)             USE RECSIZE FIELD IN DENV\nRETURN   ST    0,0(,3)             STORE RESULT IN RETURN AREA\n         LM    14,4,12(13)\n         BR    14\n         END\n./ ADD NAME=TCBMAP   0100-07332-07332-0900-00267-00267-00000-SEB\n         TITLE 'TCBMAP - MAPS TCB TREE SYSTEM CONTROL BLOCKS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TCB POINTER\nR4       EQU   4    JPQ POINTER\nR5       EQU   5    LLS POINTER\nR6       EQU   6    RB POINTER\nR7       EQU   7    CDE POINTER\nR8       EQU   8    DEB POINTER\nR9       EQU   9    BRANCH AND LINK REGISTER\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nTCBMAP   CSECT\n         SAVE  (14,12),,TCBMAP_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING TCBMAP,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE CLEAR LINE TO BLANKS\n         EJECT\n         L     R3,X'21C'           TCB\n         L     R3,X'7C'(,R3)       JSTCB\nDOIT     DS    0H\n         BAL   R14,PROCESS\n         ICM   R15,7,X'89'(R3)     DAUGHTER TCB\n         BZ    NODTR\n         LR    R3,R15              IF EXISTS, USE IT\n         B     DOIT\nNODTR    DS    0H                  ELSE\n         ICM   R15,7,X'81'(R3)     SISTER TCB\n         BZ    NOSISTER\n         LR    R3,R15              IF EXISTS, USE IT\n         B     DOIT\nNOSISTER DS    0H                  ELSE\n         ICM   R15,7,X'85'(R3)     MOTHER TCB\n         BZ    NOMORE\n         LR    R3,R15              IF EXISTS, THEN\n         B     NODTR               PROCESS ITS SISTER, ETC.\nNOMORE   DS    0H\n         B     RETURN\n         EJECT\nPROCESS  DS    0H\n         ST    R14,PRCSSAVE        SAVE RETURN REGISTER\nTCBLOOP  DS    0H\n         BAL   R9,OUTPUT           TPUT \" \"\n         MVC   LINE(L'TCBMSG),TCBMSG\n         STCM  R3,7,DOUBLE         TCB ADDRESS\n         UNPK  LINE+L'TCBMSG(7),DOUBLE(4)\n         TR    LINE+L'TCBMSG(6),HEXTBL\n         MVI   LINE+L'TCBMSG+6,C' '\n         BAL   R9,OUTPUT           TPUT \"PROCESSING TCB\"\n         L     R6,0(,R3)           RB\n         MVC   LINE(L'RBMSG),RBMSG\n         STCM  R6,7,DOUBLE         RB ADDRESS\n         UNPK  LINE+L'RBMSG(7),DOUBLE(4)\n         TR    LINE+L'RBMSG(6),HEXTBL\n         MVI   LINE+L'RBMSG+6,C' '\n         BAL   R9,OUTPUT           TPUT \"PROCESSING RB\"\nRBLOOP   DS    0H\n         TM    X'A'(R6),X'C0'      CHECK RB TYPE\n         BZ    PRB\n         BO    SVRB\n         LA    R1,=C'IRB '\n         B     RBTYPE\nSVRB     LA    R1,=C'SVRB'\nRBTYPE   DS    0H\n         STCM  R6,7,DOUBLE         RB ADDRESS\n         UNPK  LINE+0(7),DOUBLE(4)\n         TR    LINE+0(6),HEXTBL\n         MVI   LINE+6,C' '\n         MVC   LINE+8(4),0(R1)\n         BAL   R9,OUTPUT           TPUT RB TYPE\n         B     RBNEXT\nPRB      DS    0H\n         L     R7,X'C'(R6)         RBCDE\n         STCM  R6,7,DOUBLE         RB ADDRESS\n         UNPK  LINE+0(7),DOUBLE(4)\n         TR    LINE+0(6),HEXTBL\n         MVI   LINE+6,C' '\n         MVC   LINE+8(8),8(R7)\n         BAL   R9,OUTPUT           TPUT CDE NAME TO IDENTIFY RB\nRBNEXT   DS    0H\n         TM    X'B'(R6),X'80'      IF NEXTRB POINTS TO TCB\n         BO    ENDRB               THEN NO MORE RB'S. ELSE\n         ICM   R6,7,X'1D'(R6)      NEXT RB\n         B     RBLOOP\nENDRB    DS    0H\n         MVC   LINE(L'JPQMSG),JPQMSG\n         BAL   R9,OUTPUT           TPUT \"MAPPING JOB PACK QUEUE\"\n         ICM   R4,15,X'2C'(R3)     JPQ\nCDELOOP  BZ    ENDCDE\n         STCM  R4,7,DOUBLE         CDE ADDRESS\n         UNPK  LINE+0(7),DOUBLE(4)\n         TR    LINE+0(6),HEXTBL\n         MVI   LINE+6,C' '\n         MVC   LINE+8(8),8(R4)\n         BAL   R9,OUTPUT           TPUT CDE MODULE NAME\n         ICM   R4,15,0(R4)\n         B     CDELOOP\nENDCDE   DS    0H\nTCB2LOOP DS    0H\n         MVC   LINE(L'LLSMSG),LLSMSG\n         BAL   R9,OUTPUT           TPUT \"MAPPING LOAD LIST\"\n         ICM   R5,15,X'24'(R3)     LLS\nLLSLOOP  BZ    ENDLLS\n         L     R4,4(,R5)           CDE FOR LOAD LIST ENTRY\n         STCM  R4,7,DOUBLE         CDE ADDRESS\n         UNPK  LINE+0(7),DOUBLE(4)\n         TR    LINE+0(6),HEXTBL\n         MVI   LINE+6,C' '\n         MVC   LINE+8(8),8(R4)\n         BAL   R9,OUTPUT           TPUT CDE MODULE NAME\n         ICM   R5,15,0(R5)\n         B     LLSLOOP\nENDLLS   DS    0H\n         ICM   R8,7,9(R3)          DEB\n         BNZ   GOTDEBS\n         MVC   LINE(L'NODEBS),NODEBS\n         BAL   R9,OUTPUT           TPUT \"NO OPEN DATA SETS\"\n         B     ENDDEB\nGOTDEBS  DS    0H\n         MVC   LINE(L'DEBMSG),DEBMSG\n         STCM  R8,7,DOUBLE         DEB ADDRESS\n         UNPK  LINE+L'DEBMSG(7),DOUBLE(4)\n         TR    LINE+L'DEBMSG(6),HEXTBL\n         MVI   LINE+L'DEBMSG+6,C' '\n         BAL   R9,OUTPUT           TPUT \"MAPPING DEB CHAIN\"\nDEBLOOP  DS    0H\n         L     R10,X'18'(,R8)      DCB\n         L     R11,X'C'(,R3)       TIOT\n         AH    R11,X'28'(,R10)     ADD TIOT OFFSET FROM DCB\n         STCM  R8,7,DOUBLE         DEB ADDRESS\n         MVC   LINE(4),=C'DEB='\n         UNPK  LINE+4(7),DOUBLE(4)\n         TR    LINE+4(6),HEXTBL\n         MVI   LINE+4+6,C' '\n         MVC   LINE+12(4),=C'DCB='\n         STCM  R10,7,DOUBLE        DCB ADDRESS\n         UNPK  LINE+16(7),DOUBLE(4)\n         TR    LINE+16(6),HEXTBL\n         MVI   LINE+16+6,C' '\n         MVC   LINE+24(8),4(R11)   DDNAME\n         MVI   LINE+32,C' '\n         ICM   R10,7,X'C'(R11)     JFCB ADDRESS\n         MVC   LINE+33(44),X'10'(R10)   DSNAME\n         LA    R1,LINE+33+44-1\nDSNLOOP  CLI   0(R1),C' '\n         BNE   DSNEND\n         BCTR  R1,0\n         B     DSNLOOP\nDSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         CLI   X'10'+44(R10),C' '  IF THERE IS A MEMBER NAME IN JFCB\n         BE    NOMEMBER            THEN\n         MVI   1(R1),C'('\n         MVC   2(8,R1),X'10'+44(R10)\n         LA    R1,9(,R1)\nMEMLOOP  CLI   0(R1),C' '\n         BNE   MEMEND\n         BCTR  R1,0\n         B     MEMLOOP\nMEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         MVI   1(R1),C')'\nNOMEMBER DS    0H\n         BAL   R9,OUTPUT           TPUT DEB=ADDR DCB=ADDR DDNAME\n         ICM   R8,7,5(R8)\n         BNZ   DEBLOOP\nENDDEB   DS    0H\n         L     R14,PRCSSAVE        RETURN\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         TR    LINE(L'LINE),TRTBL\n         LA    R1,LINE\n         LA    R0,L'LINE\n         SVC   93                  TPUT LINE,LENGTH(LINE)\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE CLEAR LINE TO BLANKS\n         BR    R9                  RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nTCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '\nRBMSG    DC    C'---MAPPING RBS (REQUEST BLOCKS) - '\nJPQMSG   DC    C'---MAPPING CDES FOR TCB FROM JOB PACK QUEUE'\nLLSMSG   DC    C'---MAPPING CDES FOR TCB FROM LOAD LIST'\nNODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'\nDEBMSG   DC    C'---MAPPING DEBS - '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE\nLINE     DS    CL128               WORD AREA FOR OUTPUT LINES\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=TMPOFF   0100-07332-07332-0900-00010-00010-00000-SEB\nTMPOFF   CSECT\n         SPACE\n         STM   14,12,12(13)\n         LR    12,15\n         USING TMPOFF,12\n         STTMPMD OFF\n         L     14,12(,13)\n         LM    0,12,20(13)\n         BR    14\n         END\n./ ADD NAME=TMPON    0100-07332-07332-0900-00014-00014-00000-SEB\nTMPON    CSECT\n         SPACE\n         STM   14,12,12(13)\n         LR    12,15\n         USING TMPON,12\n         STTMPMD ON\n         TPUT  MSGF,MSGFL,FULLSCR\n         L     14,12(,13)\n         LM    0,12,20(13)\n         BR    14\n         SPACE\nMSGF     DC    X'27F140'\nMSGFL    EQU   *-MSGF\n         END\n./ ADD NAME=VITWHR   0100-07332-07332-0900-00295-00295-00000-SEB\n         TITLE 'VITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'VITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *\n* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *\n* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *\n* VALUES AS ISPF SHARED VARIABLES.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nVITWHR   CSECT\n         SAVE  (14,12),,VITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING VITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         CLEAR XIPSWHR COMMUNICATION FIELD\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         MVI   VITPLACE,C' '\n         MVC   VITPLACE+1(L'VITPLACE-1),VITPLACE\n         MVI   VITNAME,C' '\n         MVC   VITNAME+1(L'VITNAME-1),VITNAME\n         MVI   VITLOC,C' '\n         MVC   VITLOC+1(L'VITLOC-1),VITLOC\n         MVI   VITOFF,C' '\n         MVC   VITOFF+1(L'VITOFF-1),VITOFF\n*\n* SET VITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR\n*\n         MVC   VITPLACE(4),ADPLFMT1\n         CLI   VITPLACE,C' '\n         BE    VITERROR\n         CLI   VITPLACE,C'E'\n         BE    VITERRNP\n         B     VITOK\nVITERROR DS    0H                  ERROR - MODULE NOT FOUND\n         MVC   VITPLACE(11),=C'UNAVAILABLE'\nVITERRNP DS    0H                  STORAGE ERROR - RETAIN VITPLACE\n         MVC   VITNAME(11),=C'UNAVAILABLE'\n         MVC   VITLOC(11),=C'UNAVAILABLE'\n         B     VITSET\nVITOK    DS    0H\n*\n* SET VITNAME = THE NAME OF THE LOAD MODULE\n*\n         MVC   VITNAME(8),ADPLCOM1\n*\n* SET VITLOC = THE DECIMAL OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         CVD   R0,DOUBLE\n         UNPK  VITLOC(10),DOUBLE\n         OI    VITLOC+9,X'F0'\n*\n* SET VITOFF = THE HEX OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         ST    R0,DOUBLE\n         UNPK  VITOFF(9),DOUBLE(5)\n         TR    VITOFF(8),HEXTBL\n         MVC   VITOFF+8(8),=CL8'         '\n         LA    R1,VITOFF\n         LA    R15,7\nVOLOOP   DS    0H\n         CLI   0(R1),C'0'\n         BNE   VOLEND\n         LA    R1,1(,R1)\n         BCT   R15,VOLOOP\nVOLEND   DS    0H\n         MVC   VITOFF(8),0(R1)\n         SPACE 1\nVITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE ISPF DIALOG SERVICES TO SET THE THREE VALUES AS      *\n* ISPF DIALOG VARIABLES.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LOAD  EPLOC==CL8'ISPLINK'\n         ST    R0,@ISPLINK\n*\n* ISPEXEC VDEFINE (VITNAME VITPLACE VITLOC VITOFF)\n*\n         LA    R1,=C'VDEFINE '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         LA    R1,VITPLACE\n         ST    R1,ISPPARMS+8\n         LA    R1,=C'CHAR '\n         ST    R1,ISPPARMS+12\n         LA    R1,=F'11'\n         ST    R1,ISPPARMS+16\n         OI    ISPPARMS+16,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VPUT (VITNAME VITPLACE VITLOC VITOFF) SHARED\n*\n         LA    R1,=C'VPUT    '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         LA    R1,=C'SHARED '\n         ST    R1,ISPPARMS+8\n         OI    ISPPARMS+8,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDELETE (VITNAME VITPLACE VITLOC VITOFF)\n*\n         LA    R1,=C'VDELETE '\n         ST    R1,ISPPARMS+0\n         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'\n         ST    R1,ISPPARMS+4\n         OI    ISPPARMS+4,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* GOODBYE\n*\n         DELETE EPLOC==CL8'ISPLINK '\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\n@ISPLINK DS    A                   ADDRESS OF ISPLINK\nISPPARMS DS    6A                  PARMS FOR ISPLINK\n         SPACE 1\nVITPLACE DS    CL11                VALUE OF ISPF VARIABLE\nVITNAME  DS    CL11                VALUE OF ISPF VARIABLE\nVITLOC   DS    CL11                VALUE OF ISPF VARIABLE\nVITOFF   DS    CL11                VALUE OF ISPF VARIABLE\n         DS    CL8                 PADDING\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORK AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=VMCFTCP  0100-07332-07332-0900-01370-01370-00000-SEB\n         TITLE 'VMCF     - Macros'\n         MACRO\n&SYM     TELL  &MSG,&MSGLEN\n         LCLC  &L\n&L       SETC  '&MSGLEN'\n         AIF   ('&L' NE '').GOTLEN\n&L       SETC  'L''&MSG'\n.GOTLEN  ANOP\n&SYM     LA    R1,&MSG\n         LA    R0,&L\n         TPUT  (1),(0),R\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWX &WHAT\n&SYM     XR    R0,R0\n         IC    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(3),DOUBLE\n         OI    NUMAREA+3-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWH &WHAT\n&SYM     LH    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(5),DOUBLE\n         OI    NUMAREA+5-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWF &WHAT\n&SYM     L     R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(11),DOUBLE\n         OI    NUMAREA+11-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWC &WHAT,&HOWLONG\n&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT\n         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG\n         MEND\n         EJECT\n         TITLE 'VMCF     - Program to demonstrate TCP/IP via VMCF'\n***********************************************************************\n*                                                                     *\n* VMCF     - Program to demonstrate TCP/IP via VMCF                   *\n*                                                                     *\n* Reference:                                                          *\n*                                                                     *\n*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *\n*       Chapter 5: Virtual Machine Communication Facility Interface   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    VMCF CVT\nR4       EQU   4    SSCT\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    Base register for Connection Information Record\nR10      EQU   10   Static base register for interrupt routine\nR11      EQU   11   Dynamic base register\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nVMCF     CSECT\n         SAVE  (14,12),,VMCF_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING VMCF,R12\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R11,R13\n         USING DATD,R11\n         LR    R1,R2               Restore input parameter address\n         EJECT\n         TELL  MSG_HELLO\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Locate the VMCF CVT by searching through subsystem control blocks   *\n*                                                                     *\n***********************************************************************\n*\n         L     R4,FLCCVT-PSA(0)          Get address of CVT\n         L     R4,CVTJESCT-CVT(,R4)      Get address of JESCT\n         ICM   R4,15,JESSSCT-JESCT(R4)   Get address of SSCT\n         BZ    NOVMCF                    If none, error\n         USING SSCT,R4\nFINDVMCF DS    0H\n         CLC   SSCTSNAM,=C'VMCF'\n         BE    FOUNVMCF\n         ICM   R4,15,SSCTSCTA\n         BNZ   FINDVMCF\n         B     NOVMCF\n         SPACE 1\nFOUNVMCF DS    0H\n         TELL  MSG_VMCF_FOUND\n         SPACE 1\n         L     R3,SSCTSUSE         Get address of VMCF CVT\n         USING MVPXVMCV,R3\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Initialize VMCF parameters.                                         *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,AREA_TO_CLEAR\n         LA    R1,LENGTH_OF_AREA_TO_CLEAR\n         XR    R14,R14\n         XR    R15,R15\n         MVCL  R0,R14              Clear entire dynamic area to zero\n*\n         ST    R11,TOKEN           Token = address of our work area\n*\n         LA    R14,VMCBLOK         Address of VMCBLOK\n         LA    R15,IREP            Address of EP of routine to handle\n*                                  simulated external interrupts\n         LA    R0,TOKEN            Address of token\n         STM   R14,R0,VMCFPARM     Build parameter list\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Start by issuing a VMCF AUTHORIZE call.                             *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_ISSUING_VMCF_AUTHORIZE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n*        MVI   V1,VMCPAUTS         Set AUTHORIZE flag in VMCBLOK\n         MVI   V1,VMCFAUTHORIZESPECIFICFLAG\n         LA    R0,VMCFAUTHORIZEFUNCTION\n         STH   R0,FUNC             Set FUNC = AUTHORIZE\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* \"Set Control Register Zero.\"                                        *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SETTING_CONTROL_REGISTER_ZERO\n         LA    R0,1                Desired control register 0 value\n         BAL   R14,SETCR0          Issue the VMCF request\n*\n***********************************************************************\n*                                                                     *\n* \"Set System Mask.\"                                                  *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SETTING_SYSTEM_MASK\n         LA    R0,1                Desired system mask value\n         BAL   R14,SSM             Issue the VMCF request\n*\n***********************************************************************\n*                                                                     *\n* Begin TCP/IP Service.                                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_BEGIN_TCPIP_SERVICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,BEGINTCPIPSERVICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Specify the Notifications to Receive.                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_HANDLE_NOTICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,HANDLENOTICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n*\n* What the hell, ask for every damn notification.\n*\n* Slow code, but easier to read for brain-damaged IBM 370 assembler.\n*\n         XR    R0,R0\n         A     R0,=A(MASKCONNECTIONSTATECHANGED)\n         A     R0,=A(MASKDATADELIVERED)\n         A     R0,=A(MASKBUFFERSPACEAVAILABLE)\n         A     R0,=A(MASKCONNECTIONSTATECHANGED)\n         A     R0,=A(MASKDATADELIVERED)\n         A     R0,=A(MASKURGENTPENDING)\n         A     R0,=A(MASKUDPDATAGRAMDELIVERED)\n         A     R0,=A(MASKUDPDATAGRAMSPACEAVAILABLE)\n         A     R0,=A(MASKRAWIPPACKETSDELIVERED)\n         A     R0,=A(MASKRAWIPSPACEAVAILABLE)\n         A     R0,=A(MASKRESOURCESAVAILABLE)\n         A     R0,=A(MASKUDPRESOURCESAVAILABLE)\n         A     R0,=A(MASKPINGRESPONSE)\n         ST    R0,VADB             Set note mask\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Fill in Connection Information Record with data about the           *\n* connection we wish to establish.                                    *\n*                                                                     *\n* Get IP address and port number with which to communicate.           *\n*                                                                     *\n***********************************************************************\n*\n         LA    R9,CIRA\n         USING CIR,R9\n         MVC   CONNECTION,=Y(UNSPECIFIEDCONNECTION)\n         MVC   OPENATTEMPTTIMEOUT,=A(DEFAULTOPENTIMEOUT)\n         MVC   SECURITY,=Y(DEFAULTSECURITY)\n         MVC   COMPARTMENT,=Y(DEFAULTCOMPARTMENT)\n         MVI   PRECEDENCE,DEFAULTPRECEDENCE\n         MVC   BYTESTOREAD,=F'0'\n         MVC   UNACKEDBYTES,=F'0'\n         MVI   CONNECTIONSTATE,TRYINGTOOPEN  \"active open\"\n         MVC   LOCALSOCKET_ADDRESS,=A(UNSPECIFIEDADDRESS)\n         MVC   LOCALSOCKET_PORT,=A(UNSPECIFIEDPORT)\n         MVC   FOREIGNSOCKET_ADDRESS,YOUR_IP_ADDRESS\n         MVC   FOREIGNSOCKET_PORT,YOUR_PORT\n         DROP  R9\n         B     AROUND_MY_AND_YOUR_CONSTANTS\n         SPACE 1\nMY_IP_ADDRESS    DC Y(140,102,4,1)     ip address for MVS\nMY_PORT          DC H'25'              smtp\nYOUR_IP_ADDRESS  DC Y(140,102,30,3)    ip address for support2\nYOUR_PORT        DC H'25'              smtp\n         SPACE 1\nAROUND_MY_AND_YOUR_CONSTANTS DS 0H\n*\n***********************************************************************\n*                                                                     *\n* Open TCP Connection.                                                *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_OPEN_TCP\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,OPENTCP\n         LA    R0,VMCFSENDRECEIVEFUNCTION\n         STH   R0,FUNC             Set function code = SEND/RECV\n         LH    R0,=Y(UNSPECIFIEDCONNECTION)\n         STH   R0,CONN             Set connection type\n         LA    R0,CIRA             Address of Connection Information\n         ST    R0,VADA              Record initialized by me\n         LA    R0,CIRB             Address of Connection Information\n         ST    R0,VADB              Record for TCP/IP to fill in\n         LA    R0,CIRLEN\n         ST    R0,LENA             Length of Connection Information Rec\n         LA    R0,CIRLEN\n         ST    R0,LENB             Length of Connection Information Rec\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Wait until the connection state is changed.                         *\n*                                                                     *\n***********************************************************************\n*\n         CLC   ECB(4),=F'0'\n         BNE   NOWAIT\n         TELL  MSG_WAITING_FOR_OPEN_TO_COMPLETE\n         WAIT  ECB=ECB             Wait for response to external 'rupt\nNOWAIT   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* Show connection.                                                    *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SHOWING_CIRA\n         LA    R9,CIRA\n         BAL   R14,SHOWCONN\n         TELL  MSG_SHOWING_CIRB\n         LA    R9,CIRB\n         BAL   R14,SHOWCONN\n*\n***********************************************************************\n*                                                                     *\n* Close TCP Connection.                                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_CLOSE_TCP\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,CLOSETCP\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Address of Connection Information\n         ST    R0,VADA              Record initialized by me\n         LA    R0,CIRB             Address of Connection Information\n         ST    R0,VADB              Record for TCP/IP to fill in\n         LA    R0,CIRLEN\n         ST    R0,LENA             Length of Connection Information Rec\n         LA    R0,CIRLEN\n         ST    R0,LENB             Length of Connection Information Rec\n         LA    R9,CIRB             TCP-sent Connection Information Rec.\n         USING CIR,R9\n         LH    R0,CONNECTION       Get connection number\n         DROP  R9\n         STH   R0,CONN             Set connection number\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* End TCP/IP Service.                                                 *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_END_TCPIP_SERVICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,ENDTCPIPSERVICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n* ... Expected response from TCP/IP:  VMCF REJECT function...\n*\n*\n***********************************************************************\n*                                                                     *\n* End by issuing a VMCF UNAUTHORIZE call.                             *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_ISSUING_VMCF_UNAUTHORIZE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   V1,0\n         LA    R0,VMCFUNAUTHORIZEFUNCTION\n         STH   R0,FUNC             Set FUNC = UNAUTHORIZE\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n         EJECT\n         B     RETURN0             Return with code 0\n         EJECT\nNOVMCF   DS    0H                  Cannot find VMCF subssytem\n         SPACE 1\n         TELL  MSG_NOVMCF\n         B     RETURN12\n         EJECT\nRETURN12 DS    0H\n         TELL  MSG_FAILED\n         LA    R15,12              Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H\n         TELL  MSG_GOODBY\n         XR    R15,R15             Set return code to zero\n         B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nIREP     DC    A(VMCFIR)           Address of routine to handle\n*                                  simulated external interrupts\n         EJECT\nCALLVMCF DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine calls VMCF.  On entry it is assumed that VMCBLOK    *\n* and TOKEN have been filled in appropriately.                        *\n*                                                                     *\n* The VMCF PC number is in the VMCF CVT field named PCVMCF.           *\n*                                                                     *\n***********************************************************************\n*\n*        MVI   RETCODE,X'FF'       See if RETCODE is really set\n*\n         MVC   JOBNAME,=CL8'TCPIP' Set jobname in VMCBLOK\n         LA    R1,2                Increment global MSGID by 2\n         A     R1,GMSGID           to keep it a unique even number\n         ST    R1,GMSGID\n         ST    R1,MSGID            Set MSGID in VMCBLOK\n*\n         XC    ECB,ECB             Clear ECB\n*\n         LA    R1,VMCFPARM         Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCVMCF           Get PC number of VMCF interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSETCR0   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine performs the fake \"set control register 0\" function.   *\n* On entry, general register 0 contains the desired contents of       *\n* the fake control register 0.                                        *\n*                                                                     *\n***********************************************************************\n*\n         ST    R0,CR0              Store desired control register data\n         LA    R1,CR0              Get address thereof\n         ST    R1,SETPARM1         Store into parameter list\n         LA    R1,SETPARM          Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCSETCR0         Get PC number of SETCR0 interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSSM      DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine performs the fake \"set system mask\" function.          *\n* On entry, general register 0 contains the desired contents of       *\n* the fake system mask.                                               *\n*                                                                     *\n***********************************************************************\n*\n         STC   R0,SYSMASK          Store desired system mask data\n         LA    R1,SYSMASK          Get address thereof\n         ST    R1,SETPARM1         Store into parameter list\n         LA    R1,SETPARM          Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCSSM            Get PC number of SSM interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSHOWVMCF DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine displays the response from VMCF after a call.  It   *\n* shows the contents of the control blocks after the call, not what   *\n* happens when the simulated external interrupt routine gets control. *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,SHOWVMCF_R14    Save return address\n         TELL  MSG_AFTER_CALL\n         SHOWX RETCODE\n         SHOWX V1\n         SHOWX CALLCODE\n         SHOWH CONN\n         L     R14,SHOWVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSHOWCONN DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine displays fields from the Connection Information     *\n* Record after a call, not what happens when the simulated external   *\n* interrupt routine gets control.  On entry R9 must be set to the     *\n* address of the Connection Information Record being displayed.       *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,SHOWCONN_R14    Save return address\n         USING CIR,R9\n         SHOWH CONNECTION\n         SHOWX CONNECTIONSTATE\n*\n* Interpret connection state.\n*\n         MVI   TXTAREA,C' '\n         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA\n         CLI   CONNECTIONSTATE,CONNECTIONCLOSING\n         BNE   NOT_CONNECTIONCLOSING\n         MVC   TXTAREA(17),=C'CONNECTIONCLOSING'\n         B     TELL_CONNECTIONSTATE\nNOT_CONNECTIONCLOSING DS 0H\n         CLI   CONNECTIONSTATE,LISTENING\n         BNE   NOT_LISTENING\n         MVC   TXTAREA(9),=C'LISTENING'\n         B     TELL_CONNECTIONSTATE\nNOT_LISTENING         DS 0H\n         CLI   CONNECTIONSTATE,NONEXISTENT\n         BNE   NOT_NONEXISTENT\n         MVC   TXTAREA(11),=C'NONEXISTENT'\n         B     TELL_CONNECTIONSTATE\nNOT_NONEXISTENT       DS 0H\n         CLI   CONNECTIONSTATE,OPEN\n         BNE   NOT_OPEN\n         MVC   TXTAREA(4),=C'OPEN'\n         B     TELL_CONNECTIONSTATE\nNOT_OPEN              DS 0H\n         CLI   CONNECTIONSTATE,RECEIVINGONLY\n         BNE   NOT_RECEIVINGONLY\n         MVC   TXTAREA(13),=C'RECEIVINGONLY'\n         B     TELL_CONNECTIONSTATE\nNOT_RECEIVINGONLY     DS 0H\n         CLI   CONNECTIONSTATE,SENDINGONLY\n         BNE   NOT_SENDINGONLY\n         MVC   TXTAREA(11),=C'SENDINGONLY'\n         B     TELL_CONNECTIONSTATE\nNOT_SENDINGONLY       DS 0H\n         CLI   CONNECTIONSTATE,TRYINGTOOPEN\n         BNE   NOT_TRYINGTOOPEN\n         MVC   TXTAREA(12),=C'TRYINGTOOPEN'\n         B     TELL_CONNECTIONSTATE\nNOT_TRYINGTOOPEN      DS 0H\n         MVC   TXTAREA(3),=C'???'\nTELL_CONNECTIONSTATE  DS 0H\n         TELL  TXTAREA\n         DROP  R9\n         L     R14,SHOWCONN_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\n         DROP  R11,R12\n         EJECT\nVMCFIR   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This is the routine that handles simulated external interrupts,     *\n* which is how TCP/IP passes information back to this program.        *\n*                                                                     *\n***********************************************************************\n*\n         STM   R14,R12,12(R13)\n         LR    R10,R15\n         USING VMCFIR,R10\n         LM    R3,R4,0(R1)         R3 -> interrupt code, R4 ->  token\n         L     R11,0(,R4)          Get token = work area address\n         USING DATD,R11\n         TELL  MSG_IR_CALLED\n         LH    R5,0(,R3)           Interrupt code\n         STH   R5,INTERRUPT_CODE\n         SHOWH INTERRUPT_CODE\n*\n* Interpret interrupt code.\n*\n         MVI   TXTAREA,C' '\n         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA\n         CH    R5,=Y(TIMERINTERRUPTCODE)\n         BNE   IRNOTTIMERINTERRUPTCODE\n         MVC   TXTAREA(18),=C'TIMERINTERRUPTCODE'\n         B     TELL_INTERRUPTCODE\nIRNOTTIMERINTERRUPTCODE           DS 0H\n         CH    R5,=Y(VMCFINTERRUPTCODE)\n         BNE   IRNOTVMCFINTERRUPTCODE\n         MVC   TXTAREA(17),=C'VMCFINTERRUPTCODE'\n         B     TELL_INTERRUPTCODE\nIRNOTVMCFINTERRUPTCODE            DS 0H\n         CH    R5,=Y(IUCVINTERRUPTCODE)\n         BNE   IRNOTIUCVINTERRUPTCODE\n         MVC   TXTAREA(17),=C'IUCVINTERRUPTCODE'\n         B     TELL_INTERRUPTCODE\nIRNOTIUCVINTERRUPTCODE            DS 0H\n         CH    R5,=Y(LDSFINTERRUPTCODE)\n         BNE   IRNOTLDSFINTERRUPTCODE\n         MVC   TXTAREA(17),=C'LDSFINTERRUPTCODE'\n         B     TELL_INTERRUPTCODE\nIRNOTLDSFINTERRUPTCODE            DS 0H\n         CH    R5,=Y(INTERVALTIMERINTERRUPTCODE)\n         BNE   IRNOTINTERVALTIMERINTERRUPTCODE\n         MVC   TXTAREA(26),=C'INTERVALTIMERINTERRUPTCODE'\n         B     TELL_INTERRUPTCODE\nIRNOTINTERVALTIMERINTERRUPTCODE   DS 0H\n         MVC   TXTAREA(1),=C'?'\nTELL_INTERRUPTCODE DS 0H\n*\n* Show contents of VMCF interrupt header.\n*\n         TELL  MSG_SHOWING_INTERRUPT_HEADER\n         SHOWX V1\n         SHOWX V2\n         SHOWH FUNC\n         SHOWF MSGID\n         SHOWC JOBNAME,8\n         SHOWF ANINTEGR\n         SHOWH CONN\n         SHOWX CALLCODE\n         SHOWX RETCODE\n*\n         POST  ECB                 Post ECB\n*\n         LM    R14,R12,12(R13)\n         BR    R14                 Return to caller\n         SPACE 1\n         DROP  R10,R11\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\nMSG_HELLO  DC  C'VMCF: Program demonstrating TCP/IP via VMCF interface'\nMSG_GOODBY DC  C'VMCF: Completed.'\nMSG_FAILED DC  C'VMCF: Terminated. '\nMSG_NOVMCF DC  C'VMCF: Subsystem VMCF is not active or not found.'\nMSG_VMCF_FOUND                    DC C'VMCF: Found VMCF subsystem.'\nMSG_SETTING_CONTROL_REGISTER_ZERO DC C'VMCF: Setting control register zX\n               ero to 1.'\nMSG_SETTING_SYSTEM_MASK           DC C'VMCF: Setting system mask to 1.'\nMSG_WAITING_FOR_OPEN_TO_COMPLETE  DC C'VMCF: Waiting for OPEN to compleX\n               te.'\nMSG_SHOWING_CIRA  DC C'VMCF: Showing Connection Information Record A.'\nMSG_SHOWING_CIRB  DC C'VMCF: Showing Connection Information Record B.'\nMSG_SHOWING_INTERRUPT_HEADER DC C'VMCF: Showing Interrupt Header.'\nMSG_AFTER_CALL               DC C'VMCF: After call...'\nMSG_SHOW_V1                  DC C'VMCF:             V1       = '\nMSG_SHOW_V2                  DC C'VMCF:             V2       = '\nMSG_SHOW_FUNC                DC C'VMCF:             FUNC     = '\nMSG_SHOW_MSGID               DC C'VMCF:             MSGID    = '\nMSG_SHOW_JOBNAME             DC C'VMCF:             JOBNAME  = '\nMSG_SHOW_ANINTEGR            DC C'VMCF:             ANINTEGR = '\nMSG_SHOW_CALLCODE            DC C'VMCF:             CALLCODE = '\nMSG_SHOW_RETCODE             DC C'VMCF:             RETCODE  = '\nMSG_SHOW_CONN                DC C'VMCF:             CONN     = '\nMSG_SHOW_CONNECTION          DC C'VMCF: CIR Connection number = '\nMSG_SHOW_CONNECTIONSTATE     DC C'VMCF: CIR Connection state  = '\nMSG_ISSUING_VMCF_AUTHORIZE   DC C'VMCF: Issuing AUTHORIZE call.'\nMSG_ISSUING_VMCF_UNAUTHORIZE DC C'VMCF: Issuing UNAUTHORIZE call.'\nMSG_BEGIN_TCPIP_SERVICE      DC C'VMCF: Issuing BEGINtcpIPservice.'\nMSG_END_TCPIP_SERVICE        DC C'VMCF: Issuing ENDtcpIPservice.'\nMSG_HANDLE_NOTICE            DC C'VMCF: Issuing HANDLEnotice.'\nMSG_OPEN_TCP                 DC C'VMCF: Issuing OPENtcp.'\nMSG_CLOSE_TCP                DC C'VMCF: Issuing CLOSEtcp.'\nMSG_IR_CALLED                DC C'VMCFIR: Interrupt routine called.'\nMSG_SHOW_INTERRUPT_CODE      DC C'VMCFIR: Interrupt code:'\n         EJECT\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 1\nAREA_TO_CLEAR EQU *\n         SPACE 1\nDOUBLE   DS    D                   For conversions\nECB      DS    F                   Event control block\nGMSGID   DS    F                   Message ID for transaction tracking\nCR0      DS    F                   Fake control register 0\nSYSMASK  DS    X                   Fake system mask\nCALLVMCF_R14 DS A                  Save area for CALLVMCF subroutine\nSHOWVMCF_R14 DS A                  Save area for SHOWVMCF subroutine\nSHOWCONN_R14 DS A                  Save area for SHOWCONN subroutine\n         SPACE 1\nVMCFPARM DS    3A                  VMCF parameter list\n         ORG   VMCFPARM\nPARM1    DS    A                   VMCF parm 1: address of VMCBLOK\nPARM2    DS    A                   VMCF parm 2: address of EP of I.R.\nPARM3    DS    A                   VMCF parm 3: address of token\n         SPACE 1\nSETPARM  DS    A                   Other parameter list\n         ORG   SETPARM\nSETPARM1 DS    A                   used by SETCR0 and SSM services\n         SPACE 1\nTOKEN    DS    D                   Token used by AUTHORIZE call\nINTERRUPT_CODE DS H\nNUMAREA  DS    CL12                Area for number conversion\nTXTAREA  DS    CL64                Area for text\nMSGAREA  DS    CL218               Area for message text\n*\n*----------------------------------------------------------------------\n*\nVMCBLOK  DS    0D                  VMCF parameter block\n         ORG   VMCBLOK\nV1       DS    X                   Out: Set to VMCPAUTS for AUTHORIZE\n*                                  In:  May be VMCMRESP or VMCMRJCT\nV2       DS    X                   Out: Must be zero\nFUNC     DS    H\nMSGID    DS    F                   Out: Unique even number for each\n*                                       outstanding transaction\nJOBNAME  DS    CL8                 Out: 'TCPIP' to talk to TCPIP\nVADA     DS    A\nLENA     DS    F\nVADB     DS    A\nLENB     DS    F\n*\n* User-doubleword field is divided into the following fields:\n*\nANINTEGR DS    F\nCONN     DS    H\nCALLCODE DS    X                   In:  What I set if V1 = VMCMRESP\nRETCODE  DS    X                   In:  Pascal return code\n         SPACE 1\nVMCBLOK_LEN EQU *-VMCBLOK\n*\n*----------------------------------------------------------------------\n*\nCIRA     DS    CL(CIRLEN)          Connection Information Record A\nCIRB     DS    CL(CIRLEN)          Connection Information Record B\n*\n*----------------------------------------------------------------------\n*\nLENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR\n         SPACE 1\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\nCIR      DSECT ,                   Map Connection Information Record\n         SPACE 1\nCONNECTION            DS  H\nOPENATTEMPTTIMEOUT    DS  F\nSECURITY              DS  H\nCOMPARTMENT           DS  H\nPRECEDENCE            DS  X\nBYTESTOREAD           DS  F\nUNACKEDBYTES          DS  F\nCONNECTIONSTATE       DS  X\nLOCALSOCKET           DS  0F,3H\n         ORG   LOCALSOCKET\nLOCALSOCKET_ADDRESS   DS  F\nLOCALSOCKET_PORT      DS  H\nFOREIGNSOCKET         DS  0F,3H\n         ORG   FOREIGNSOCKET\nFOREIGNSOCKET_ADDRESS DS F\nFOREIGNSOCKET_PORT    DS  H\n         SPACE 1\nCIRLEN   EQU   *-CIR\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Miscellaneous constants.                                            *\n*                                                                     *\n***********************************************************************\n*\n*\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Equates for the CALLCODE field.  These are listed in the manual,    *\n* but I found it easier to extract them from 'TCPIP.COMMMAC(CMCOMM)'  *\n* and convert the PASCAL declaration, adjusting the numbers to match  *\n* the assembler EQU listing in the manual.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used by the program to initiate a function.       *\n*                                                                     *\n***********************************************************************\n*\nABORTTCP          EQU  100\nBEGINTCPIPSERVICE EQU  101\nCLOSETCP          EQU  102\nCLOSEUDP          EQU  103\nENDTCPIPSERVICE   EQU  104\nHANDLENOTICE      EQU  105\nISHOSTLOCAL       EQU  106\nMONITORCOMMAND    EQU  107\nMONITORQUERY      EQU  108\nNOCALL            EQU  109\nOPENTCP           EQU  110\nOPENUDP           EQU  111\nRESERVEDCALL2     EQU  112\nRECEIVETCP        EQU  113\nRECEIVEUDP        EQU  114\nNRECEIVEUDP       EQU  115\nSTATUSUDP         EQU  116\nRESERVEDCALL3     EQU  117\nSENDTCP           EQU  118\nSENDUDP           EQU  119\nSTATUSTCP         EQU  120\nFRECEIVETCP       EQU  121\nFSENDTCP          EQU  122\nCLOSERAWIP        EQU  123\nOPENRAWIP         EQU  124\nRECEIVERAWIP      EQU  125\nSENDRAWIP         EQU  126\nPINGREQ           EQU  127\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used by TCPIP to send a notification.             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nBUFFERSPACEAVAILABLE EQU 10\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a connection on which a TCP send        *\n*               request was previously rejected due to insufficient   *\n*               resources.                                            *\n*                                                                     *\nCONNECTIONSTATECHANGED EQU 11\n*                                                                     *\n*              This notification is given when a TCP connection       *\n*              receives information from the network that causes      *\n*              the state of the connection to change. Such changes    *\n*              may arise when the remote client opens, closes, or     *\n*              aborts the connection.                                 *\n*                                                                     *\nDATADELIVERED  EQU 12\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier TcpReceive request now         *\n*              contains data.                                         *\n*                                                                     *\nUSERDEFINEDNOTIFICATION EQU 13\n*                                                                     *\n*              For use by user-written programs.                      *\n*                                                                     *\nDATAGRAMSPACEAVAILABLE EQU 14\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which an IP send request  *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nURGENTPENDING  EQU 15\n*                                                                     *\n*              This notification is given when the TCP-IP service     *\n*               is informed by the foreign site that there is         *\n*               urgent data not yet delivered to the client.          *\n*                                                                     *\nUDPDATAGRAMDELIVERED EQU 16\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier UdpReceive request now         *\n*              contains a  datagram.                                  *\n*                                                                     *\nUDPDATAGRAMSPACEAVAILABLE EQU 17\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which an UDP send request *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nEXTERNALINTERRUPT EQU 18\n*                                                                     *\n*              This special notification is returned when             *\n*               a non-VMCF external interrupt arrives for             *\n*               the client.  Typically, this external interrupt       *\n*               will be CPexternalCOMMAND, and will be interpreted    *\n*               by the client as a directive to commit suicide        *\n*                                                                     *\nUSERDELIVERSLINE EQU 19\n*                                                                     *\n*              The user has entered a line of data at the terminal.   *\n*                                                                     *\nUSERWANTSATTENTION EQU 20\n*                                                                     *\n*              The user has hit an attention key, such as a PF key.   *\n*                                                                     *\nTIMEREXPIRED EQU 21\n*                                                                     *\n*              A timer has expired                                    *\n*                                                                     *\nFSENDRESPONSE  EQU 22\n*                                                                     *\n*              Response has been received for TcpFSend call           *\n*                                                                     *\nFRECEIVEERROR  EQU 23\n*                                                                     *\n*              This notification is given when a TcpFReceive call     *\n*              resulted in an error, instead of a DATAdelivered       *\n*              notification.  Every TcpFReceive call will eventually  *\n*              generate either DATAdelivered or RECEIVEerror.         *\n*                                                                     *\nRAWIPPACKETSDELIVERED EQU 24\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier RawIpReceive request now       *\n*              contains data.                                         *\n*                                                                     *\nRAWIPSPACEAVAILABLE EQU 25\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which a RawIpSend request *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nIUCVINTERRUPT  EQU 26\n*                                                                     *\n*              This special notification is returned when a           *\n*              IUCV external interrupt arrives for the client.        *\n*                                                                     *\nIOINTERRUPT EQU 27\n*                                                                     *\n*              This notification is given when an I/O interrupt       *\n*              occurs on a device which the client program has        *\n*              specified in a NotifyIo() call.                        *\n*                                                                     *\nRESOURCESAVAILABLE EQU 28\n*                                                                     *\n*              This notification is given to a client who previously  *\n*              tried to do TcpOpen but got ZEROresources.  When       *\n*              all resources necessary for open are available (TCB    *\n*              and SCB plus incoming and outgoing data buffer),       *\n*              this notice is given.                                  *\n*                                                                     *\nUDPRESOURCESAVAILABLE EQU 29\n*                                                                     *\n*              Similar to RESOURCESavailable, for UdpOpen.            *\n*                                                                     *\nPINGRESPONSE EQU 30\n*                                                                     *\n*              Sent when a ping response is received, or when the     *\n*              request times out                                      *\n*                                                                     *\nSMSGRECEIVED EQU 31\n*                                                                     *\n*              Sent when a CP Special Message (SMSG) is received      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used for the connection states.                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nCONNECTIONCLOSING EQU 0\n*                                                                     *\n*    Data may no longer be transmitted on this connection             *\n*     since the TCP-IP service is in the process of closing           *\n*     down the connection.                                            *\n*                                                                     *\nLISTENING         EQU 1\n*                                                                     *\n*    Waiting for a foreign site to open a connection.                 *\n*                                                                     *\nNONEXISTENT       EQU 2\n*                                                                     *\n*    The connection no longer exists.                                 *\n*                                                                     *\nOPEN              EQU 3\n*                                                                     *\n*    Data can go either way on the connection.                        *\n*                                                                     *\nRECEIVINGONLY     EQU 4\n*                                                                     *\n*    Data can be received but not sent on this connection,            *\n*     because the client has done a one-way close.                    *\n*                                                                     *\nSENDINGONLY       EQU 5\n*                                                                     *\n*    Data can be sent out but not received on this                    *\n*     connection.  This means that the foreign site has               *\n*     done a one-way close.                                           *\n*                                                                     *\nTRYINGTOOPEN      EQU 6\n*                                                                     *\n*    Trying to contact a foreign site to establish                    *\n*     a connection.                                                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used for the notification mask in the             *\n* HANDLEnotice call.                                                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nMASKBUFFERSPACEAVAILABLE         EQU X'00000001'\nMASKCONNECTIONSTATECHANGED       EQU X'00000002'\nMASKDATADELIVERED                EQU X'00000004'\nMASKURGENTPENDING                EQU X'00000020'\nMASKUDPDATAGRAMDELIVERED         EQU X'00000040'\nMASKUDPDATAGRAMSPACEAVAILABLE    EQU X'00000080'\nMASKRAWIPPACKETSDELIVERED        EQU X'00004000'\nMASKRAWIPSPACEAVAILABLE          EQU X'00008000'\nMASKRESOURCESAVAILABLE           EQU X'00040000'\nMASKUDPRESOURCESAVAILABLE        EQU X'00080000'\nMASKPINGRESPONSE                 EQU X'00100000'\n*\n*\n***********************************************************************\n*                                                                     *\n* We need to copy more equates from 'TCPIP.COMMMAC(CMCOMM)' because   *\n* IBM did not provide documentation for everything.  So here goes...  *\n* Some of these are in the manual, but I include everything.          *\n*                                                                     *\n***********************************************************************\n*\nDEFAULTSECURITY         EQU  0\nDEFAULTCOMPARTMENT      EQU  0\nDEFAULTPRECEDENCE       EQU  0\nUNSPECIFIEDADDRESS      EQU  0\nUNSPECIFIEDPORT         EQU  X'FFFF'\nBROADCASTADDRESS        EQU  X'FFFFFFFF'\nWAITFOREVER             EQU  2147483647   (MAXint)\n*\nDEFAULTOPENTIMEOUT      EQU  30\n*\n*    These are the return codes that the client might see as a result\n*     of issuing an IP or TCP request.  They must be in the range\n*     LOWerrorCODE .. HIGHerrorCODE.  HIGHerrorCODE = 0.\n*\nHIGHERRORCODE              EQU 0\nLOWERRORCODE               EQU -128\nOK                         EQU 0\nABNORMALCONDITION          EQU -1  { nonfatal VMCF error }\nALREADYCLOSING             EQU -2  { connection already closing }\nBADLENGTHARGUMENT          EQU -3  { length parameter is invalid }\nCANNOTSENDDATA             EQU -4\nCLIENTRESTART              EQU -5\nCONNECTIONALREADYEXISTS    EQU -6\nDESTINATIONUNREACHABLE     EQU -7  { from remote site or gateway }\nERRORINPROFILE             EQU -8\nFATALERROR                 EQU -9  { fatal VMCF error }\nHASNOPASSWORD              EQU -10  { errors         }\nINCORRECTPASSWORD          EQU -11  { ... in opening }\nINVALIDREQUEST             EQU -12\nINVALIDUSERID              EQU -13  { ... file       }\nINVALIDVIRTUALADDRESS      EQU -14  { ... used       }\nKILLEDBYCLIENT             EQU -15\nLOCALPORTNOTAVAILABLE      EQU -16\nMINIDISKINUSE              EQU -17  { ... by         }\nMINIDISKNOTAVAILABLE       EQU -18  { ... MonCommand }\nNOBUFFERSPACE              EQU -19\nNOMOREINCOMINGDATA         EQU -20\nNONLOCALADDRESS            EQU -21\nNOOUTSTANDINGNOTIFICATIONS EQU -22\nNOSUCHCONNECTION           EQU -23\nNOTCPIPSERVICE             EQU -24\nNOTYETBEGUN                EQU -25  { Client hasn't called BeginTcpIp}\nNOTYETOPEN                 EQU -26  { Client hasn't called TcpOpen }\nOPENREJECTED               EQU -27\nPARAMLOCALADDRESS          EQU -28  { Invalid .....      }\nPARAMSTATE                 EQU -29  { ... values...      }\nPARAMTIMEOUT               EQU -30  { ... specified ...  }\nPARAMUNSPECADDRESS         EQU -31  { ... in Connection  }\nPARAMUNSPECPORT            EQU -32  { ..Information Record }\nPROFILENOTFOUND            EQU -33\nRECEIVESTILLPENDING        EQU -34\nREMOTECLOSE                EQU -35  { Foreign client closing }\nREMOTERESET                EQU -36\nSOFTWAREERROR              EQU -37  { WISCNET software error }\nTCPIPSHUTDOWN              EQU -38\nTIMEOUTCONNECTION          EQU -39\nTIMEOUTOPEN                EQU -40\nTOOMANYOPENS               EQU -41\nUNAUTHORIZEDUSER           EQU -43\nUNEXPECTEDSYN              EQU -44\nUNIMPLEMENTEDREQUEST       EQU -45\nUNKNOWNHOST                EQU -46  { we lack info in our tables }\nUNREACHABLENETWORK         EQU -47\nUNSPECIFIEDCONNECTION      EQU -48\nVIRTUALMEMORYTOOSMALL      EQU -49\nWRONGSECORPRC              EQU -50  { wrong security or priority }\nX25TOOCONGESTED            EQU -51  { no virtual circuits available }\nYOUREND                    EQU -55\nZERORESOURCES              EQU -56\n*\n* UDP specific errors\n*\nUDPLOCALADDRESS            EQU -57  {Invalid local address}\nUDPUNSPECADDRESS           EQU -59  {Unspecified local address}\nUDPUNSPECPORT              EQU -60  {Unspecified local port}\nUDPZERORESOURCES           EQU -61  {No space available to continue}\n*\n* New errors, not yet sorted alphabetically\n*\nFSENDSTILLPENDING          EQU -62  {TcpFSend is still outstanding }\n*\n* Error codes from FSD\n*\nHOSTMSGTOOBIG              EQU -63\nCHANNELWRITEIOERR          EQU -64\nUNKNOWNSENSEBYTE           EQU -65\nSERIES1DOWN                EQU -71\nIMPISDOWN                  EQU -72\nHOSTDEAD                   EQU -73\nBADIMPMSG                  EQU -74\nHOSTNOTREADY               EQU -75\nS1APPLNOTREADY             EQU -76\nWRITEBUFFERREADY           EQU -77\nLOOPX25ADDRESS             EQU -78\nDROPPEDBYOPERATOR          EQU -79\nERROROPENINGORREADINGFILE  EQU -80\nFILEFORMATINVALID          EQU -81\n*\n**********************************************************************\n*                                                                    *\n*                        Ip Datagram Section                         *\n*                                                                    *\n**********************************************************************\n*\nANYCONNECTION     EQU UNSPECIFIEDCONNECTION\n*\n*     { This indicates that the request is to be done on any\n*        connection. }\n*\nNOTIPNOTIFICATION EQU 0\n*\n*     { This is given in the Protocol field during an\n*        asynchronous notification if the notification is not\n*        relevant to a particular protocol other than TCP. }\n*\nANYPROTOCOL       EQU 0 { Used as a Wild Card }\n*\n* The following definitions are used to describe an IP datagram.\n* For more information, see RFC 791, pages 11 - 23. Due to the\n* variable length of the options list, it is not declared as a\n* separate field; the client is responsible for determining\n* which characters in the data portion of the datagram are options.\n*\nMINIMUMIPHEADERSIZE EQU 20\n*\n*  { Implementation limits on the size of raw IP datagrams }\n*\nMAX512DATAGRAMSIZE   EQU 512\nMAX512IPDATA         EQU MAX512DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX1024DATAGRAMSIZE  EQU 1024\nMAX1024IPDATA        EQU MAX1024DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX2048DATAGRAMSIZE  EQU 2048\nMAX2048IPDATA        EQU MAX2048DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX4096DATAGRAMSIZE  EQU 4096\nMAX4096IPDATA        EQU MAX4096DATAGRAMSIZE-MINIMUMIPHEADERSIZE\n*\n*  { 8192 datagram is actually a little larger, to accommodate NFS.\n*    NFS wants to send UDP data of 8K plus 200.  Add the UDP header\n*    size, the IP header size, and 100 bytes for good measure. }\n*\nMAX8192DATAGRAMSIZE  EQU 8192+8+MINIMUMIPHEADERSIZE+200+100\nMAX8192IPDATA        EQU MAX8192DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX16384DATAGRAMSIZE EQU 16384\nMAX16384IPDATA       EQU MAX16384DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX32768DATAGRAMSIZE EQU 32768\nMAX32768IPDATA       EQU MAX32768DATAGRAMSIZE-MINIMUMIPHEADERSIZE\n*\n* The possible flag bits:  (see RFC 791, page 13) }\n*\nIPMAYFRAGMENT        EQU 0\nIPDONTFRAGMENT       EQU 16384 { Bit 1 of the halfword }\nIPLASTFRAGMENT       EQU 0\nIPMOREFRAGMENTS      EQU 8192 { Bit 2 of the halfword }\n*\n* The bit flags for the IP type-of-service field: RFC 791, p. 12 }\n*\nLOWDELAY             EQU 16\nNORMALDELAY          EQU 0\nHIGHTHROUGHPUT       EQU 8\nNORMALTHROUGHPUT     EQU 0\nHIGHRELIABILITY      EQU 4\nNORMALRELIABILITY    EQU 0\n*\n* UDP header size }\n*\nUDPHEADERSIZE        EQU 8\n*\n* Max data returned on an old-style UdpReceive.  This number\n* will never change. }\n*\nOLDSTYLEMAXUDPDATA   EQU 2040-MINIMUMIPHEADERSIZE-UDPHEADERSIZE\n*\n* Well known protocol numbers }\n*\nICMPPROTOCOLNUMBER   EQU 1\nTCPPROTOCOLNUMBER    EQU 6\nUDPPROTOCOLNUMBER    EQU 17\n*\n* Maximum number of IP protocols }\n*\nIPPROTO_MAX       EQU 256  { Don't even think of changing this number }\n*\nDISABLEALLINTERRUPTS   EQU  X'00'\nENABLEALLINTERRUPTS    EQU  255  { a byte with every bit set to one }\nFIXEDOVERFLOWMASK      EQU  X'08'\nDECIMALOVERFLOWMASK    EQU  X'04'\nEXPONENTUNDERFLOWMASK  EQU  X'02'\nSIGNIFICANCEMASK       EQU  X'01'\nLENGTHOFVIRTUALADDRESS EQU  4\nLENGTHOFDISKLABEL      EQU  6\nCPEXTERNALCOMMAND      EQU  X'40'\nMESSAGENUMBERLIMIT     EQU  1000000000\n*\n*  { This limit is made smaller than necessary so\n*     wrap-around arithmetic is easier. }\n*\nTIMERINTERRUPTCODE     EQU X'1004'\nVMCFINTERRUPTCODE      EQU X'4001'\nIUCVINTERRUPTCODE      EQU X'4000'\nLDSFINTERRUPTCODE      EQU X'2402'\nINTERVALTIMERINTERRUPTCODE EQU X'0080'\nANYOLDADDRESS          EQU 0\n*\n*  { These are all the possible VMCF function calls. }\n*\nVMCFAUTHORIZEFUNCTION   EQU X'0000'\nVMCFUNAUTHORIZEFUNCTION EQU X'0001'\nVMCFSENDFUNCTION        EQU X'0002'\nVMCFSENDRECEIVEFUNCTION EQU X'0003'\nVMCFSENDXFUNCTION       EQU X'0004'\nVMCFRECEIVEFUNCTION     EQU X'0005'\nVMCFCANCELFUNCTION      EQU X'0006'\nVMCFREPLYFUNCTION       EQU X'0007'\nVMCFQUIESCEFUNCTION     EQU X'0008'\nVMCFRESUMEFUNCTION      EQU X'0009'\nVMCFIDENTIFYFUNCTION    EQU X'000A'\nVMCFREJECTFUNCTION      EQU X'000B'\n*\n*  { The IUCV function codes.  The ord of this enum type gives the\n*    actual function code. }\n*\nIUCVQUERYFUNCTION       EQU   0\nIUCVTESTMSGFUNCTION     EQU   1\nIUCVRTRVBFRFUNCTION     EQU   2\nIUCVDESCRIBEFUNCTION    EQU   3\nIUCVSENDFUNCTION        EQU   4\nIUCVRECEIVEFUNCTION     EQU   5\nIUCVREPLYFUNCTION       EQU   6\nIUCVTESTCMPLFUNCTION    EQU   7\nIUCVREJECTFUNCTION      EQU   8\nIUCVPURGEFUNCTION       EQU   9\nIUCVACCEPTFUNCTION      EQU   10\nIUCVCONNECTFUNCTION     EQU   11\nIUCVDCLBFRFUNCTION      EQU   12\nIUCVQUIESCEFUNCTION     EQU   13\nIUCVRESUMEFUNCTION      EQU   14\nIUCVSEVERFUNCTION       EQU   15\nIUCVSETMASKFUNCTION     EQU   16\nIUCVSETCMASKFUNCTION    EQU   17\n*\n* These are the IUCV external interrupt types\n*\nIUCVPENDINGCONNECTION     EQU X'01'\nIUCVCONNECTIONCOMPLETE    EQU X'02'\nIUCVSEVEREDCONNECTION     EQU X'03'\nIUCVQUIESCEDCONNECTION    EQU X'04'\nIUCVRESUMEDCONNECTION     EQU X'05'\nIUCVINCOMINGPREPLY        EQU X'06'\nIUCVINCOMINGREPLY         EQU X'07'\nIUCVINCOMINGPMESSAGE      EQU X'08'\nIUCVINCOMINGMESSAGE       EQU X'09'\n*\n*  { These are V1 flags for the authorize command. }\n*\nVMCFAUTHORIZESPECIFICFLAG EQU X'80'\nVMCFPRIORITYFLAG          EQU X'40'\nVMCFSMSGFLAG              EQU X'20'\n*\n*  { These are V1 flags for a Final Response Interrupt. }\n*\nVMCFFINALRESPONSECODE     EQU X'80'\nVMCFREJECTRESPONSECODE    EQU X'40'\nVMCFPRIORITYRESPONSECODE  EQU X'20'\nMAXSMSGLENGTH             EQU 240  { Maximum SMSG data }\nANINTEGERFLAGREQUESTERR   EQU X'80000000'\n*     { Used only when REJECTing FSENDtcp and FRECEIVEtcp calls }\nIUCVADDRESSLISTSIZE       EQU 20\nNOHOST EQU 0    { an always-invalid InternetAddress }\n*\n*    Because we use 0.0.0.0 as a flag meaning\n*    'NO host', we assume that zero is never allowed as a\n*    valid internet address. RFC 820 lists it as \"reserved\".\n*\nMAXWORDTYPELENGTH        EQU 100\nMAXDESCRIPTORSETLENGTH   EQU 64\n*\n*\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n*\n* The following macro needs 'TCPIP.COMMMAC'.                    \\\n*\n         MVPXVMCV ,                VMCF stuff\n*\n         PRINT NOGEN\n*\n         IEFJESCT\n         IEFJSCVT\n         CVT   DSECT=YES\n         IHAPSA\n*\n         END\n./ ADD NAME=VMCFUDP  0100-07332-07332-0900-01474-01474-00000-SEB\n         TITLE 'VMCFUDP  - Macros'\n         MACRO\n&SYM     INTERP &TYPE,&FIELD\n.*\n.* example: INTERP H,FUNC,FOO,BAR,BAZ,FROB\n.*\n         LCLA  &I,&L,&LEN,&UNKL\n         LCLC  &NUMVAL,&VAL,&UNK,&LABEL,&LABEND\n         AIF   ('&TYPE' EQ 'F').F\n         AIF   ('&TYPE' EQ 'H').H\n         AIF   ('&TYPE' EQ 'C').C\n         MNOTE 8,'Unknown type.  Use F, H, or C.'\n         MEXIT\n.F       ANOP\n&SYM     L     R0,&FIELD\n         AGO   .DOIT\n.H       ANOP\n&SYM     LH    R0,&FIELD\n         AGO   .DOIT\n.C       ANOP\n&SYM     XR    R0,R0\n         IC    R0,&FIELD\n         AGO   .DOIT\n.DOIT    ANOP\n         MVI   TXTAREA,C' '\n         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA\n&I       SETA  3\n&L       SETA  0\n&LABEND  SETC  '$&SYSNDX'\n&UNK     SETC  '&FIELD value is unrecognizable'\n&UNKL    SETA  K'&UNK\n.LOOP    ANOP\n&L       SETA  &L+1\n&LABEL   SETC  '@&SYSNDX&L'\n         AIF   (&I GT N'&SYSLIST).ENDLOOP\n&VAL     SETC  '&FIELD: &SYSLIST(&I)'\n&NUMVAL  SETC  '&SYSLIST(&I)'\n&LEN     SETA  K'&VAL\n         C     R0,=A(&NUMVAL)\n         BNE   &LABEL\n         MVC   TXTAREA(&LEN),=C'&VAL'\n         B     &LABEND\n&LABEL   DS    0H\n&I       SETA  &I+1\n         AGO   .LOOP\n.ENDLOOP ANOP\n         MVC   TXTAREA(&UNKL),=C'&UNK'\n&LABEND  DS    0H\n         TELL  TXTAREA\n         MEND\n         MACRO\n&SYM     TELL  &MSG,&MSGLEN\n         LCLC  &L\n&L       SETC  '&MSGLEN'\n         AIF   ('&L' NE '').GOTLEN\n&L       SETC  'L''&MSG'\n.GOTLEN  ANOP\n&SYM     LA    R1,&MSG\n         LA    R0,&L\n         TPUT  (1),(0),R\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWX &WHAT\n&SYM     XR    R0,R0\n         IC    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(3),DOUBLE\n         OI    NUMAREA+3-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWH &WHAT\n&SYM     LH    R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(5),DOUBLE\n         OI    NUMAREA+5-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWF &WHAT\n&SYM     L     R0,&WHAT\n         CVD   R0,DOUBLE\n         UNPK  NUMAREA(11),DOUBLE\n         OI    NUMAREA+11-1,X'F0'\n         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         LTR   R0,R0\n         BNM   *+8\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11\n         MEND\n         EJECT\n         MACRO\n&SYM     SHOWC &WHAT,&HOWLONG\n&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT\n         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '\n         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT\n         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL\n         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG\n         MEND\n         EJECT\n         TITLE 'VMCFUDP  - Program to demonstrate TCP/IP UDP via VMCF'\n***********************************************************************\n*                                                                     *\n* VMCFUDP  - Program to demonstrate TCP/IP UDP via VMCF               *\n*                                                                     *\n* Reference:                                                          *\n*                                                                     *\n*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *\n*       Chapter 5: Virtual Machine Communication Facility Interface   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    VMCF CVT\nR4       EQU   4    SSCT\nR5       EQU   5    Miscellaneous data items\nR6       EQU   6    Base register for Connection Information Record\nR7       EQU   7    .\nR8       EQU   8    Internal return address\nR9       EQU   9    Yet another static base register\nR10      EQU   10   Another static base register\nR11      EQU   11   Dynamic base register\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nVMCFUDP  CSECT\n         SAVE  (14,12),,VMCFUDP_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         LA    R10,4095(,R12)\n         LA    R10,1(,R10)\n         LA    R9,4095(,R10)\n         LA    R9,1(,R9)\n         USING VMCFUDP,R12,R10,R9\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R11,R13\n         USING DATD,R11\n         LR    R1,R2               Restore input parameter address\n         ST    R12,SAVER12\n         ST    R10,SAVER10\n         ST    R9,SAVER9\n         EJECT\n         TELL  MSG_HELLO\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Locate the VMCF CVT by searching through subsystem control blocks   *\n*                                                                     *\n***********************************************************************\n*\n         L     R4,FLCCVT-PSA(0)          Get address of CVT\n         L     R4,CVTJESCT-CVT(,R4)      Get address of JESCT\n         ICM   R4,15,JESSSCT-JESCT(R4)   Get address of SSCT\n         BZ    NOVMCF                    If none, error\n         USING SSCT,R4\nFINDVMCF DS    0H\n         CLC   SSCTSNAM,=C'VMCF'\n         BE    FOUNVMCF\n         ICM   R4,15,SSCTSCTA\n         BNZ   FINDVMCF\n         B     NOVMCF\n         SPACE 1\nFOUNVMCF DS    0H\n         TELL  MSG_VMCF_FOUND\n         SPACE 1\n         L     R3,SSCTSUSE         Get address of VMCF CVT\n         USING MVPXVMCV,R3\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Initialize VMCF parameters.                                         *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,AREA_TO_CLEAR\n         LA    R1,LENGTH_OF_AREA_TO_CLEAR\n         XR    R14,R14\n         XR    R15,R15\n         MVCL  R0,R14              Clear entire dynamic area to zero\n*\n         ST    R11,TOKEN           Token = address of our work area\n*\n         LA    R14,VMCBLOK         Address of VMCBLOK\n         LA    R15,IREP            Address of EP of routine to handle\n*                                  simulated external interrupts\n         LA    R0,TOKEN            Address of token\n         STM   R14,R0,VMCFPARM     Build parameter list\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Start by issuing a VMCF AUTHORIZE call.                             *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_ISSUING_VMCF_AUTHORIZE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n*        MVI   V1,VMCPAUTS         Set AUTHORIZE flag in VMCBLOK\n         MVI   V1,VMCFAUTHORIZESPECIFICFLAG\n         LA    R0,VMCFAUTHORIZEFUNCTION\n         STH   R0,FUNC             Set FUNC = AUTHORIZE\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* \"Set Control Register Zero.\"                                        *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SETTING_CONTROL_REGISTER_ZERO\n         LA    R0,1                Desired control register 0 value\n         BAL   R14,SETCR0          Issue the VMCF request\n*\n***********************************************************************\n*                                                                     *\n* \"Set System Mask.\"                                                  *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SETTING_SYSTEM_MASK\n         LA    R0,1                Desired system mask value\n         BAL   R14,SSM             Issue the VMCF request\n*\n***********************************************************************\n*                                                                     *\n* Begin TCP/IP Service.                                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_BEGIN_TCPIP_SERVICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,BEGINTCPIPSERVICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Specify the Notifications to Receive.                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_HANDLE_NOTICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,HANDLENOTICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n*\n* What the hell, ask for every damn notification.\n*\n* Slow code, but easier to read for brain-damaged IBM 370 assembler.\n*\n         XR    R0,R0\n         A     R0,=A(MASKCONNECTIONSTATECHANGED)\n         A     R0,=A(MASKDATADELIVERED)\n         A     R0,=A(MASKBUFFERSPACEAVAILABLE)\n         A     R0,=A(MASKCONNECTIONSTATECHANGED)\n         A     R0,=A(MASKDATADELIVERED)\n         A     R0,=A(MASKURGENTPENDING)\n         A     R0,=A(MASKUDPDATAGRAMDELIVERED)\n         A     R0,=A(MASKUDPDATAGRAMSPACEAVAILABLE)\n         A     R0,=A(MASKRAWIPPACKETSDELIVERED)\n         A     R0,=A(MASKRAWIPSPACEAVAILABLE)\n         A     R0,=A(MASKRESOURCESAVAILABLE)\n         A     R0,=A(MASKUDPRESOURCESAVAILABLE)\n         A     R0,=A(MASKPINGRESPONSE)\n         ST    R0,VADB             Set note mask\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Open UDP Connection.                                                *\n*                                                                     *\n***********************************************************************\n*\n         B     AROUND_MY_AND_YOUR_CONSTANTS\n         SPACE 1\n         DS    0F\nMY_IP_ADDRESS    DC Y(140,102,4,1)     ip address for MVS\nMY_PORT          DC H'25'              smtp\nYOUR_IP_ADDRESS  DC Y(140,102,30,3)    ip address for support2\nYOUR_PORT        DC H'25'              smtp\n         SPACE 1\nAROUND_MY_AND_YOUR_CONSTANTS DS 0H\n         SPACE 1\n         TELL  MSG_OPEN_UDP\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,OPENUDP\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,ARBNUM\n         STH   R0,CONN             Connection number:  An arbitrary\n*                                  number, which your program will use\n*                                  in subsequent actions involving\n*                                  this port.\n         LA    R0,0                Zero\n         ST    R0,VADA\n         LH    R0,MY_PORT          Local port number or UNSPECIFIEDport\n         ST    R0,VADB              Record for TCP/IP to fill in\n         LA    R0,1\n         ST    R0,LENA             Length of zero\n         L     R0,MY_IP_ADDRESS\n         ST    R0,LENB             Local address\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* Show connection.                                                    *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_SHOWING_CIRA\n         LA    R6,CIRA\n         BAL   R14,SHOWCONN\n         TELL  MSG_SHOWING_CIRB\n         LA    R6,CIRB\n         BAL   R14,SHOWCONN\n*\n***********************************************************************\n*                                                                     *\n* Close UDP Connection.                                               *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_CLOSE_UDP\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,CLOSEUDP\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,0\n         ST    R0,VADA             Zero\n         LA    R0,0\n         ST    R0,VADB             Zero\n         LA    R0,1\n         ST    R0,LENA             One\n         LA    R0,0\n         ST    R0,LENB             Zero\n         LA    R0,ARBNUM\n         STH   R0,CONN             Connection number we opened with?\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n***********************************************************************\n*                                                                     *\n* End TCP/IP Service.                                                 *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_END_TCPIP_SERVICE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   CALLCODE,ENDTCPIPSERVICE\n         LA    R0,VMCFSENDFUNCTION\n         STH   R0,FUNC             Set function code = SEND\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n*\n* ... Expected response from TCP/IP:  VMCF REJECT function...\n*\n*\n***********************************************************************\n*                                                                     *\n* End by issuing a VMCF UNAUTHORIZE call.                             *\n*                                                                     *\n***********************************************************************\n*\n         TELL  MSG_ISSUING_VMCF_UNAUTHORIZE\n         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block\n         MVI   V1,0\n         LA    R0,VMCFUNAUTHORIZEFUNCTION\n         STH   R0,FUNC             Set FUNC = UNAUTHORIZE\n         LA    R0,CIRA             Set address of\n         ST    R0,VADA             Connection Information Record\n         LA    R0,1\n         ST    R0,LENA             Set LENA = 1\n         BAL   R14,CALLVMCF        Issue the VMCF request\n         BAL   R14,SHOWVMCF        Show VMCF response if any\n         EJECT\n         B     RETURN0             Return with code 0\n         EJECT\nNOVMCF   DS    0H                  Cannot find VMCF subssytem\n         SPACE 1\n         TELL  MSG_NOVMCF\n         B     RETURN12\n         EJECT\nRETURN12 DS    0H\n         TELL  MSG_FAILED\n         LA    R15,12              Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H\n         TELL  MSG_GOODBY\n         XR    R15,R15             Set return code to zero\n         B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nIREP     DC    A(VMCFIR)           Address of routine to handle\n*                                  simulated external interrupts\n         EJECT\nCALLVMCF DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine calls VMCF.  On entry it is assumed that VMCBLOK    *\n* and TOKEN have been filled in appropriately.                        *\n*                                                                     *\n* The VMCF PC number is in the VMCF CVT field named PCVMCF.           *\n*                                                                     *\n***********************************************************************\n*\n*        MVI   RETCODE,X'FF'       See if RETCODE is really set\n*\n         MVC   JOBNAME,=CL8'TCPIP' Set jobname in VMCBLOK\n         LA    R1,2                Increment global MSGID by 2\n         A     R1,GMSGID           to keep it a unique even number\n         ST    R1,GMSGID\n         ST    R1,MSGID            Set MSGID in VMCBLOK\n*\n         XC    ECB,ECB             Clear ECB\n*\n         LA    R1,VMCFPARM         Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCVMCF           Get PC number of VMCF interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSETCR0   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine performs the fake \"set control register 0\" function.   *\n* On entry, general register 0 contains the desired contents of       *\n* the fake control register 0.                                        *\n*                                                                     *\n***********************************************************************\n*\n         ST    R0,CR0              Store desired control register data\n         LA    R1,CR0              Get address thereof\n         ST    R1,SETPARM1         Store into parameter list\n         LA    R1,SETPARM          Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCSETCR0         Get PC number of SETCR0 interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSSM      DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine performs the fake \"set system mask\" function.          *\n* On entry, general register 0 contains the desired contents of       *\n* the fake system mask.                                               *\n*                                                                     *\n***********************************************************************\n*\n         STC   R0,SYSMASK          Store desired system mask data\n         LA    R1,SYSMASK          Get address thereof\n         ST    R1,SETPARM1         Store into parameter list\n         LA    R1,SETPARM          Point to parameter list\n         ST    R14,CALLVMCF_R14    Save return address\n         ESAR  R14                 Save secondary ASID\n         STM   R14,R12,12(R13)     Save all registers\n         L     R2,PCSSM            Get PC number of SSM interface\n         PC    0(R2)               Call VMCF\n         L     R14,12(,R13)        Get saved secondary ASID\n         SSAR  R14                 Restore secondary ASID\n         LM    R2,12,28(R13)       Restore rest of registers\n         L     R14,CALLVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSHOWVMCF DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine displays the response from VMCF after a call.  It   *\n* shows the contents of the control blocks after the call, not what   *\n* happens when the simulated external interrupt routine gets control. *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,SHOWVMCF_R14    Save return address\n         TELL  MSG_AFTER_CALL\n         SHOWX RETCODE\n         BAL   R8,INTERPRET_RETCODE\n         SHOWX V1\n         SHOWX CALLCODE\n         BAL   R8,INTERPRET_CALLCODE\n         SHOWH CONN\n         L     R14,SHOWVMCF_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\nSHOWCONN DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine displays fields from the Connection Information     *\n* Record after a call, not what happens when the simulated external   *\n* interrupt routine gets control.  On entry R6 must be set to the     *\n* address of the Connection Information Record being displayed.       *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,SHOWCONN_R14    Save return address\n         USING CIR,R6\n         SHOWH CONNECTION\n         SHOWX CONNECTIONSTATE\n         BAL   R8,INTERPRET_CONNECTIONSTATE\n         DROP  R6\n         L     R14,SHOWCONN_R14    Load return address\n         BR    R14                 Return to caller\n         EJECT\n         DROP  R9,R10,R11,R12\n         EJECT\nVMCFIR   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This is the routine that handles simulated external interrupts,     *\n* which is how TCP/IP passes information back to this program.        *\n*                                                                     *\n***********************************************************************\n*\n         STM   R14,R12,12(R13)\n         LM    R3,R4,0(R1)         R3 -> interrupt code, R4 ->  token\n         L     R11,0(,R4)          Get token = work area address\n         USING DATD,R11\n         L     R12,SAVER12\n         L     R10,SAVER10\n         L     R9,SAVER9\n         USING VMCFUDP,R12,R10,R9\n         TELL  MSG_IR_CALLED\n         LH    R5,0(,R3)           Interrupt code\n         STH   R5,INTERRUPT_CODE\n         SHOWH INTERRUPT_CODE\n         BAL   R8,INTERPRET_INTERRUPT_CODE\n         TELL  MSG_SHOWING_INTERRUPT_HEADER\n         SHOWX V1\n         SHOWX V2\n         SHOWH FUNC\n         BAL   R8,INTERPRET_FUNC\n         SHOWF MSGID\n         SHOWC JOBNAME,8\n         SHOWF ANINTEGR\n         SHOWH CONN\n         SHOWX CALLCODE\n         BAL   R8,INTERPRET_CALLCODE\n         SHOWX RETCODE\n         BAL   R8,INTERPRET_RETCODE\n*\n         POST  ECB                 Post ECB\n*\n         LM    R14,R12,12(R13)\n         BR    R14                 Return to caller\n         EJECT\nINTERPRET_CONNECTIONSTATE DS 0H\n         USING CIR,R6\n         INTERP C,CONNECTIONSTATE,                                     X\n               CONNECTIONCLOSING,                                      X\n               LISTENING,                                              X\n               NONEXISTENT,                                            X\n               OPEN,                                                   X\n               RECEIVINGONLY,                                          X\n               SENDINGONLY,                                            X\n               TRYINGTOOPEN\n         BR    R8\n         DROP  R6\n*\nINTERPRET_INTERRUPT_CODE DS 0H\n         INTERP H,INTERRUPT_CODE,                                      X\n               TIMERINTERRUPTCODE,                                     X\n               VMCFINTERRUPTCODE,                                      X\n               IUCVINTERRUPTCODE,                                      X\n               LDSFINTERRUPTCODE,                                      X\n               INTERVALTIMERINTERRUPTCODE\n         BR    R8\n*\nINTERPRET_FUNC DS 0H\n         INTERP H,FUNC,                                                X\n               VMCFAUTHORIZEFUNCTION,                                  X\n               VMCFUNAUTHORIZEFUNCTION,                                X\n               VMCFSENDFUNCTION,                                       X\n               VMCFSENDRECEIVEFUNCTION,                                X\n               VMCFSENDXFUNCTION,                                      X\n               VMCFRECEIVEFUNCTION,                                    X\n               VMCFCANCELFUNCTION,                                     X\n               VMCFREPLYFUNCTION,                                      X\n               VMCFQUIESCEFUNCTION,                                    X\n               VMCFRESUMEFUNCTION,                                     X\n               VMCFIDENTIFYFUNCTION,                                   X\n               VMCFREJECTFUNCTION\n         BR    R8\n*\nINTERPRET_RETCODE DS 0H\n         INTERP C,RETCODE,                                             X\n               OK,                                                     X\n               ABNORMALCONDITION,                                      X\n               ALREADYCLOSING,                                         X\n               BADLENGTHARGUMENT,                                      X\n               CANNOTSENDDATA,                                         X\n               CLIENTRESTART,                                          X\n               CONNECTIONALREADYEXISTS,                                X\n               DESTINATIONUNREACHABLE,                                 X\n               ERRORINPROFILE,                                         X\n               FATALERROR,                                             X\n               HASNOPASSWORD,                                          X\n               INCORRECTPASSWORD,                                      X\n               INVALIDREQUEST,                                         X\n               INVALIDUSERID,                                          X\n               INVALIDVIRTUALADDRESS,                                  X\n               KILLEDBYCLIENT,                                         X\n               LOCALPORTNOTAVAILABLE,                                  X\n               MINIDISKINUSE,                                          X\n               MINIDISKNOTAVAILABLE,                                   X\n               NOBUFFERSPACE,                                          X\n               NOMOREINCOMINGDATA,                                     X\n               NONLOCALADDRESS,                                        X\n               NOOUTSTANDINGNOTIFICATIONS,                             X\n               NOSUCHCONNECTION,                                       X\n               NOTCPIPSERVICE,                                         X\n               NOTYETBEGUN,                                            X\n               NOTYETOPEN,                                             X\n               OPENREJECTED,                                           X\n               PARAMLOCALADDRESS,                                      X\n               PARAMSTATE,                                             X\n               PARAMTIMEOUT,                                           X\n               PARAMUNSPECADDRESS,                                     X\n               PARAMUNSPECPORT,                                        X\n               PROFILENOTFOUND,                                        X\n               RECEIVESTILLPENDING,                                    X\n               REMOTECLOSE,                                            X\n               REMOTERESET,                                            X\n               SOFTWAREERROR,                                          X\n               TCPIPSHUTDOWN,                                          X\n               TIMEOUTCONNECTION,                                      X\n               TIMEOUTOPEN,                                            X\n               TOOMANYOPENS,                                           X\n               UNAUTHORIZEDUSER,                                       X\n               UNEXPECTEDSYN,                                          X\n               UNIMPLEMENTEDREQUEST,                                   X\n               UNKNOWNHOST,                                            X\n               UNREACHABLENETWORK,                                     X\n               UNSPECIFIEDCONNECTION,                                  X\n               VIRTUALMEMORYTOOSMALL,                                  X\n               WRONGSECORPRC,                                          X\n               X25TOOCONGESTED,                                        X\n               YOUREND,                                                X\n               ZERORESOURCES,                                          X\n               UDPLOCALADDRESS,                                        X\n               UDPUNSPECADDRESS,                                       X\n               UDPUNSPECPORT,                                          X\n               UDPZERORESOURCES,                                       X\n               FSENDSTILLPENDING,                                      X\n               HOSTMSGTOOBIG,                                          X\n               CHANNELWRITEIOERR,                                      X\n               UNKNOWNSENSEBYTE,                                       X\n               SERIES1DOWN,                                            X\n               IMPISDOWN,                                              X\n               HOSTDEAD,                                               X\n               BADIMPMSG,                                              X\n               HOSTNOTREADY,                                           X\n               S1APPLNOTREADY,                                         X\n               WRITEBUFFERREADY,                                       X\n               LOOPX25ADDRESS,                                         X\n               DROPPEDBYOPERATOR,                                      X\n               ERROROPENINGORREADINGFILE,                              X\n               FILEFORMATINVALID\n         BR    R8\n*\nINTERPRET_CALLCODE DS 0H\n         INTERP C,CALLCODE,                                            X\n               ABORTTCP,                                               X\n               BEGINTCPIPSERVICE,                                      X\n               CLOSETCP,                                               X\n               CLOSEUDP,                                               X\n               ENDTCPIPSERVICE,                                        X\n               HANDLENOTICE,                                           X\n               ISHOSTLOCAL,                                            X\n               MONITORCOMMAND,                                         X\n               MONITORQUERY,                                           X\n               NOCALL,                                                 X\n               OPENTCP,                                                X\n               OPENUDP,                                                X\n               RESERVEDCALL2,                                          X\n               RECEIVETCP,                                             X\n               RECEIVEUDP,                                             X\n               NRECEIVEUDP,                                            X\n               STATUSUDP,                                              X\n               RESERVEDCALL3,                                          X\n               SENDTCP,                                                X\n               SENDUDP,                                                X\n               STATUSTCP,                                              X\n               FRECEIVETCP,                                            X\n               FSENDTCP,                                               X\n               CLOSERAWIP,                                             X\n               OPENRAWIP,                                              X\n               RECEIVERAWIP,                                           X\n               SENDRAWIP,                                              X\n               PINGREQ\n         BR    R8\n         EJECT\n         DROP  R11\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\nMSG_HELLO  DC  C'VMCF: Program demonstrating TCP/IP via VMCF interface'\nMSG_GOODBY DC  C'VMCF: Completed.'\nMSG_FAILED DC  C'VMCF: Terminated. '\nMSG_NOVMCF DC  C'VMCF: Subsystem VMCF is not active or not found.'\nMSG_VMCF_FOUND                    DC C'VMCF: Found VMCF subsystem.'\nMSG_SETTING_CONTROL_REGISTER_ZERO DC C'VMCF: Setting control register zX\n               ero to 1.'\nMSG_SETTING_SYSTEM_MASK           DC C'VMCF: Setting system mask to 1.'\nMSG_WAITING_FOR_OPEN_TO_COMPLETE  DC C'VMCF: Waiting for OPEN to compleX\n               te.'\nMSG_SHOWING_CIRA  DC C'VMCF: Showing Connection Information Record A.'\nMSG_SHOWING_CIRB  DC C'VMCF: Showing Connection Information Record B.'\nMSG_SHOWING_INTERRUPT_HEADER DC C'VMCF: Showing Interrupt Header.'\nMSG_AFTER_CALL               DC C'VMCF: After call...'\nMSG_SHOW_V1                  DC C'VMCF:             V1       = '\nMSG_SHOW_V2                  DC C'VMCF:             V2       = '\nMSG_SHOW_FUNC                DC C'VMCF:             FUNC     = '\nMSG_SHOW_MSGID               DC C'VMCF:             MSGID    = '\nMSG_SHOW_JOBNAME             DC C'VMCF:             JOBNAME  = '\nMSG_SHOW_ANINTEGR            DC C'VMCF:             ANINTEGR = '\nMSG_SHOW_CALLCODE            DC C'VMCF:             CALLCODE = '\nMSG_SHOW_RETCODE             DC C'VMCF:             RETCODE  = '\nMSG_SHOW_CONN                DC C'VMCF:             CONN     = '\nMSG_SHOW_CONNECTION          DC C'VMCF: CIR Connection number = '\nMSG_SHOW_CONNECTIONSTATE     DC C'VMCF: CIR Connection state  = '\nMSG_ISSUING_VMCF_AUTHORIZE   DC C'VMCF: Issuing AUTHORIZE call.'\nMSG_ISSUING_VMCF_UNAUTHORIZE DC C'VMCF: Issuing UNAUTHORIZE call.'\nMSG_BEGIN_TCPIP_SERVICE      DC C'VMCF: Issuing BEGINtcpIPservice.'\nMSG_END_TCPIP_SERVICE        DC C'VMCF: Issuing ENDtcpIPservice.'\nMSG_HANDLE_NOTICE            DC C'VMCF: Issuing HANDLEnotice.'\nMSG_OPEN_UDP                 DC C'VMCF: Issuing OPENudp.'\nMSG_CLOSE_UDP                DC C'VMCF: Issuing CLOSEudp.'\nMSG_IR_CALLED                DC C'VMCFIR: Interrupt routine called.'\nMSG_SHOW_INTERRUPT_CODE      DC C'VMCFIR: Interrupt code:'\n         EJECT\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' ...........<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F\n         SPACE 1\nSAVER12  DS    F\nSAVER10  DS    F\nSAVER9   DS    F\n         SPACE 1\nAREA_TO_CLEAR EQU *\n         SPACE 1\nDOUBLE   DS    D                   For conversions\nECB      DS    F                   Event control block\nGMSGID   DS    F                   Message ID for transaction tracking\nCR0      DS    F                   Fake control register 0\nSYSMASK  DS    X                   Fake system mask\nCALLVMCF_R14 DS A                  Save area for CALLVMCF subroutine\nSHOWVMCF_R14 DS A                  Save area for SHOWVMCF subroutine\nSHOWCONN_R14 DS A                  Save area for SHOWCONN subroutine\n         SPACE 1\nVMCFPARM DS    3A                  VMCF parameter list\n         ORG   VMCFPARM\nPARM1    DS    A                   VMCF parm 1: address of VMCBLOK\nPARM2    DS    A                   VMCF parm 2: address of EP of I.R.\nPARM3    DS    A                   VMCF parm 3: address of token\n         SPACE 1\nSETPARM  DS    A                   Other parameter list\n         ORG   SETPARM\nSETPARM1 DS    A                   used by SETCR0 and SSM services\n         SPACE 1\nTOKEN    DS    D                   Token used by AUTHORIZE call\nINTERRUPT_CODE DS H\nNUMAREA  DS    CL12                Area for number conversion\nTXTAREA  DS    CL64                Area for text\nMSGAREA  DS    CL218               Area for message text\n*\n*----------------------------------------------------------------------\n*\nVMCBLOK  DS    0D                  VMCF parameter block\n         ORG   VMCBLOK\nV1       DS    X                   Out: Set to VMCPAUTS for AUTHORIZE\n*                                  In:  May be VMCMRESP or VMCMRJCT\nV2       DS    X                   Out: Must be zero\nFUNC     DS    H\nMSGID    DS    F                   Out: Unique even number for each\n*                                       outstanding transaction\nJOBNAME  DS    CL8                 Out: 'TCPIP' to talk to TCPIP\nVADA     DS    A\nLENA     DS    F\nVADB     DS    A\nLENB     DS    F\n*\n* User-doubleword field is divided into the following fields:\n*\nANINTEGR DS    F\nCONN     DS    H\nCALLCODE DS    X                   In:  What I set if V1 = VMCMRESP\nRETCODE  DS    X                   In:  Pascal return code\n         SPACE 1\nVMCBLOK_LEN EQU *-VMCBLOK\n*\n*----------------------------------------------------------------------\n*\nCIRA     DS    CL(CIRLEN)          Connection Information Record A\nCIRB     DS    CL(CIRLEN)          Connection Information Record B\n*\n*----------------------------------------------------------------------\n*\nLENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR\n         SPACE 1\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\nARBNUM   EQU   1                   Arbitrary connection number\n         EJECT\nCIR      DSECT ,                   Map Connection Information Record\n         SPACE 1\nCONNECTION            DS  H\nOPENATTEMPTTIMEOUT    DS  F\nSECURITY              DS  H\nCOMPARTMENT           DS  H\nPRECEDENCE            DS  X\nBYTESTOREAD           DS  F\nUNACKEDBYTES          DS  F\nCONNECTIONSTATE       DS  X\nLOCALSOCKET           DS  0F,3H\n         ORG   LOCALSOCKET\nLOCALSOCKET_ADDRESS   DS  F\nLOCALSOCKET_PORT      DS  H\nFOREIGNSOCKET         DS  0F,3H\n         ORG   FOREIGNSOCKET\nFOREIGNSOCKET_ADDRESS DS F\nFOREIGNSOCKET_PORT    DS  H\n         SPACE 1\nCIRLEN   EQU   *-CIR\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Miscellaneous constants.                                            *\n*                                                                     *\n***********************************************************************\n*\n*\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Equates for the CALLCODE field.  These are listed in the manual,    *\n* but I found it easier to extract them from 'TCPIP.COMMMAC(CMCOMM)'  *\n* and convert the PASCAL declaration, adjusting the numbers to match  *\n* the assembler EQU listing in the manual.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used by the program to initiate a function.       *\n*                                                                     *\n***********************************************************************\n*\nABORTTCP          EQU  100\nBEGINTCPIPSERVICE EQU  101\nCLOSETCP          EQU  102\nCLOSEUDP          EQU  103\nENDTCPIPSERVICE   EQU  104\nHANDLENOTICE      EQU  105\nISHOSTLOCAL       EQU  106\nMONITORCOMMAND    EQU  107\nMONITORQUERY      EQU  108\nNOCALL            EQU  109\nOPENTCP           EQU  110\nOPENUDP           EQU  111\nRESERVEDCALL2     EQU  112\nRECEIVETCP        EQU  113\nRECEIVEUDP        EQU  114\nNRECEIVEUDP       EQU  115\nSTATUSUDP         EQU  116\nRESERVEDCALL3     EQU  117\nSENDTCP           EQU  118\nSENDUDP           EQU  119\nSTATUSTCP         EQU  120\nFRECEIVETCP       EQU  121\nFSENDTCP          EQU  122\nCLOSERAWIP        EQU  123\nOPENRAWIP         EQU  124\nRECEIVERAWIP      EQU  125\nSENDRAWIP         EQU  126\nPINGREQ           EQU  127\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used by TCPIP to send a notification.             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nBUFFERSPACEAVAILABLE EQU 10\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a connection on which a TCP send        *\n*               request was previously rejected due to insufficient   *\n*               resources.                                            *\n*                                                                     *\nCONNECTIONSTATECHANGED EQU 11\n*                                                                     *\n*              This notification is given when a TCP connection       *\n*              receives information from the network that causes      *\n*              the state of the connection to change. Such changes    *\n*              may arise when the remote client opens, closes, or     *\n*              aborts the connection.                                 *\n*                                                                     *\nDATADELIVERED  EQU 12\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier TcpReceive request now         *\n*              contains data.                                         *\n*                                                                     *\nUSERDEFINEDNOTIFICATION EQU 13\n*                                                                     *\n*              For use by user-written programs.                      *\n*                                                                     *\nDATAGRAMSPACEAVAILABLE EQU 14\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which an IP send request  *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nURGENTPENDING  EQU 15\n*                                                                     *\n*              This notification is given when the TCP-IP service     *\n*               is informed by the foreign site that there is         *\n*               urgent data not yet delivered to the client.          *\n*                                                                     *\nUDPDATAGRAMDELIVERED EQU 16\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier UdpReceive request now         *\n*              contains a  datagram.                                  *\n*                                                                     *\nUDPDATAGRAMSPACEAVAILABLE EQU 17\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which an UDP send request *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nEXTERNALINTERRUPT EQU 18\n*                                                                     *\n*              This special notification is returned when             *\n*               a non-VMCF external interrupt arrives for             *\n*               the client.  Typically, this external interrupt       *\n*               will be CPexternalCOMMAND, and will be interpreted    *\n*               by the client as a directive to commit suicide        *\n*                                                                     *\nUSERDELIVERSLINE EQU 19\n*                                                                     *\n*              The user has entered a line of data at the terminal.   *\n*                                                                     *\nUSERWANTSATTENTION EQU 20\n*                                                                     *\n*              The user has hit an attention key, such as a PF key.   *\n*                                                                     *\nTIMEREXPIRED EQU 21\n*                                                                     *\n*              A timer has expired                                    *\n*                                                                     *\nFSENDRESPONSE  EQU 22\n*                                                                     *\n*              Response has been received for TcpFSend call           *\n*                                                                     *\nFRECEIVEERROR  EQU 23\n*                                                                     *\n*              This notification is given when a TcpFReceive call     *\n*              resulted in an error, instead of a DATAdelivered       *\n*              notification.  Every TcpFReceive call will eventually  *\n*              generate either DATAdelivered or RECEIVEerror.         *\n*                                                                     *\nRAWIPPACKETSDELIVERED EQU 24\n*                                                                     *\n*              This notification is given when the client buffer      *\n*              indicated in an earlier RawIpReceive request now       *\n*              contains data.                                         *\n*                                                                     *\nRAWIPSPACEAVAILABLE EQU 25\n*                                                                     *\n*              This notification is given when buffer space becomes   *\n*               available for a datagram on which a RawIpSend request *\n*               was previously rejected due to insufficient resources *\n*                                                                     *\nIUCVINTERRUPT  EQU 26\n*                                                                     *\n*              This special notification is returned when a           *\n*              IUCV external interrupt arrives for the client.        *\n*                                                                     *\nIOINTERRUPT EQU 27\n*                                                                     *\n*              This notification is given when an I/O interrupt       *\n*              occurs on a device which the client program has        *\n*              specified in a NotifyIo() call.                        *\n*                                                                     *\nRESOURCESAVAILABLE EQU 28\n*                                                                     *\n*              This notification is given to a client who previously  *\n*              tried to do TcpOpen but got ZEROresources.  When       *\n*              all resources necessary for open are available (TCB    *\n*              and SCB plus incoming and outgoing data buffer),       *\n*              this notice is given.                                  *\n*                                                                     *\nUDPRESOURCESAVAILABLE EQU 29\n*                                                                     *\n*              Similar to RESOURCESavailable, for UdpOpen.            *\n*                                                                     *\nPINGRESPONSE EQU 30\n*                                                                     *\n*              Sent when a ping response is received, or when the     *\n*              request times out                                      *\n*                                                                     *\nSMSGRECEIVED EQU 31\n*                                                                     *\n*              Sent when a CP Special Message (SMSG) is received      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used for the connection states.                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nCONNECTIONCLOSING EQU 0\n*                                                                     *\n*    Data may no longer be transmitted on this connection             *\n*     since the TCP-IP service is in the process of closing           *\n*     down the connection.                                            *\n*                                                                     *\nLISTENING         EQU 1\n*                                                                     *\n*    Waiting for a foreign site to open a connection.                 *\n*                                                                     *\nNONEXISTENT       EQU 2\n*                                                                     *\n*    The connection no longer exists.                                 *\n*                                                                     *\nOPEN              EQU 3\n*                                                                     *\n*    Data can go either way on the connection.                        *\n*                                                                     *\nRECEIVINGONLY     EQU 4\n*                                                                     *\n*    Data can be received but not sent on this connection,            *\n*     because the client has done a one-way close.                    *\n*                                                                     *\nSENDINGONLY       EQU 5\n*                                                                     *\n*    Data can be sent out but not received on this                    *\n*     connection.  This means that the foreign site has               *\n*     done a one-way close.                                           *\n*                                                                     *\nTRYINGTOOPEN      EQU 6\n*                                                                     *\n*    Trying to contact a foreign site to establish                    *\n*     a connection.                                                   *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* These equates are used for the notification mask in the             *\n* HANDLEnotice call.                                                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\nMASKBUFFERSPACEAVAILABLE         EQU X'00000001'\nMASKCONNECTIONSTATECHANGED       EQU X'00000002'\nMASKDATADELIVERED                EQU X'00000004'\nMASKURGENTPENDING                EQU X'00000020'\nMASKUDPDATAGRAMDELIVERED         EQU X'00000040'\nMASKUDPDATAGRAMSPACEAVAILABLE    EQU X'00000080'\nMASKRAWIPPACKETSDELIVERED        EQU X'00004000'\nMASKRAWIPSPACEAVAILABLE          EQU X'00008000'\nMASKRESOURCESAVAILABLE           EQU X'00040000'\nMASKUDPRESOURCESAVAILABLE        EQU X'00080000'\nMASKPINGRESPONSE                 EQU X'00100000'\n*\n*\n***********************************************************************\n*                                                                     *\n* We need to copy more equates from 'TCPIP.COMMMAC(CMCOMM)' because   *\n* IBM did not provide documentation for everything.  So here goes...  *\n* Some of these are in the manual, but I include everything.          *\n*                                                                     *\n***********************************************************************\n*\nDEFAULTSECURITY         EQU  0\nDEFAULTCOMPARTMENT      EQU  0\nDEFAULTPRECEDENCE       EQU  0\nUNSPECIFIEDADDRESS      EQU  0\nUNSPECIFIEDPORT         EQU  X'FFFF'\nBROADCASTADDRESS        EQU  X'FFFFFFFF'\nWAITFOREVER             EQU  2147483647   (MAXint)\n*\nDEFAULTOPENTIMEOUT      EQU  30\n*\n*    These are the return codes that the client might see as a result\n*     of issuing an IP or TCP request.  They must be in the range\n*     LOWerrorCODE .. HIGHerrorCODE.  HIGHerrorCODE = 0.\n*\nHIGHERRORCODE              EQU 0\nLOWERRORCODE               EQU -128\nOK                         EQU 0\nABNORMALCONDITION          EQU -1  { nonfatal VMCF error }\nALREADYCLOSING             EQU -2  { connection already closing }\nBADLENGTHARGUMENT          EQU -3  { length parameter is invalid }\nCANNOTSENDDATA             EQU -4\nCLIENTRESTART              EQU -5\nCONNECTIONALREADYEXISTS    EQU -6\nDESTINATIONUNREACHABLE     EQU -7  { from remote site or gateway }\nERRORINPROFILE             EQU -8\nFATALERROR                 EQU -9  { fatal VMCF error }\nHASNOPASSWORD              EQU -10  { errors         }\nINCORRECTPASSWORD          EQU -11  { ... in opening }\nINVALIDREQUEST             EQU -12\nINVALIDUSERID              EQU -13  { ... file       }\nINVALIDVIRTUALADDRESS      EQU -14  { ... used       }\nKILLEDBYCLIENT             EQU -15\nLOCALPORTNOTAVAILABLE      EQU -16\nMINIDISKINUSE              EQU -17  { ... by         }\nMINIDISKNOTAVAILABLE       EQU -18  { ... MonCommand }\nNOBUFFERSPACE              EQU -19\nNOMOREINCOMINGDATA         EQU -20\nNONLOCALADDRESS            EQU -21\nNOOUTSTANDINGNOTIFICATIONS EQU -22\nNOSUCHCONNECTION           EQU -23\nNOTCPIPSERVICE             EQU -24\nNOTYETBEGUN                EQU -25  { Client hasn't called BeginTcpIp}\nNOTYETOPEN                 EQU -26  { Client hasn't called TcpOpen }\nOPENREJECTED               EQU -27\nPARAMLOCALADDRESS          EQU -28  { Invalid .....      }\nPARAMSTATE                 EQU -29  { ... values...      }\nPARAMTIMEOUT               EQU -30  { ... specified ...  }\nPARAMUNSPECADDRESS         EQU -31  { ... in Connection  }\nPARAMUNSPECPORT            EQU -32  { ..Information Record }\nPROFILENOTFOUND            EQU -33\nRECEIVESTILLPENDING        EQU -34\nREMOTECLOSE                EQU -35  { Foreign client closing }\nREMOTERESET                EQU -36\nSOFTWAREERROR              EQU -37  { WISCNET software error }\nTCPIPSHUTDOWN              EQU -38\nTIMEOUTCONNECTION          EQU -39\nTIMEOUTOPEN                EQU -40\nTOOMANYOPENS               EQU -41\nUNAUTHORIZEDUSER           EQU -43\nUNEXPECTEDSYN              EQU -44\nUNIMPLEMENTEDREQUEST       EQU -45\nUNKNOWNHOST                EQU -46  { we lack info in our tables }\nUNREACHABLENETWORK         EQU -47\nUNSPECIFIEDCONNECTION      EQU -48\nVIRTUALMEMORYTOOSMALL      EQU -49\nWRONGSECORPRC              EQU -50  { wrong security or priority }\nX25TOOCONGESTED            EQU -51  { no virtual circuits available }\nYOUREND                    EQU -55\nZERORESOURCES              EQU -56\n*\n* UDP specific errors\n*\nUDPLOCALADDRESS            EQU -57  {Invalid local address}\nUDPUNSPECADDRESS           EQU -59  {Unspecified local address}\nUDPUNSPECPORT              EQU -60  {Unspecified local port}\nUDPZERORESOURCES           EQU -61  {No space available to continue}\n*\n* New errors, not yet sorted alphabetically\n*\nFSENDSTILLPENDING          EQU -62  {TcpFSend is still outstanding }\n*\n* Error codes from FSD\n*\nHOSTMSGTOOBIG              EQU -63\nCHANNELWRITEIOERR          EQU -64\nUNKNOWNSENSEBYTE           EQU -65\nSERIES1DOWN                EQU -71\nIMPISDOWN                  EQU -72\nHOSTDEAD                   EQU -73\nBADIMPMSG                  EQU -74\nHOSTNOTREADY               EQU -75\nS1APPLNOTREADY             EQU -76\nWRITEBUFFERREADY           EQU -77\nLOOPX25ADDRESS             EQU -78\nDROPPEDBYOPERATOR          EQU -79\nERROROPENINGORREADINGFILE  EQU -80\nFILEFORMATINVALID          EQU -81\n*\n**********************************************************************\n*                                                                    *\n*                        Ip Datagram Section                         *\n*                                                                    *\n**********************************************************************\n*\nANYCONNECTION     EQU UNSPECIFIEDCONNECTION\n*\n*     { This indicates that the request is to be done on any\n*        connection. }\n*\nNOTIPNOTIFICATION EQU 0\n*\n*     { This is given in the Protocol field during an\n*        asynchronous notification if the notification is not\n*        relevant to a particular protocol other than TCP. }\n*\nANYPROTOCOL       EQU 0 { Used as a Wild Card }\n*\n* The following definitions are used to describe an IP datagram.\n* For more information, see RFC 791, pages 11 - 23. Due to the\n* variable length of the options list, it is not declared as a\n* separate field; the client is responsible for determining\n* which characters in the data portion of the datagram are options.\n*\nMINIMUMIPHEADERSIZE EQU 20\n*\n*  { Implementation limits on the size of raw IP datagrams }\n*\nMAX512DATAGRAMSIZE   EQU 512\nMAX512IPDATA         EQU MAX512DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX1024DATAGRAMSIZE  EQU 1024\nMAX1024IPDATA        EQU MAX1024DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX2048DATAGRAMSIZE  EQU 2048\nMAX2048IPDATA        EQU MAX2048DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX4096DATAGRAMSIZE  EQU 4096\nMAX4096IPDATA        EQU MAX4096DATAGRAMSIZE-MINIMUMIPHEADERSIZE\n*\n*  { 8192 datagram is actually a little larger, to accommodate NFS.\n*    NFS wants to send UDP data of 8K plus 200.  Add the UDP header\n*    size, the IP header size, and 100 bytes for good measure. }\n*\nMAX8192DATAGRAMSIZE  EQU 8192+8+MINIMUMIPHEADERSIZE+200+100\nMAX8192IPDATA        EQU MAX8192DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX16384DATAGRAMSIZE EQU 16384\nMAX16384IPDATA       EQU MAX16384DATAGRAMSIZE-MINIMUMIPHEADERSIZE\nMAX32768DATAGRAMSIZE EQU 32768\nMAX32768IPDATA       EQU MAX32768DATAGRAMSIZE-MINIMUMIPHEADERSIZE\n*\n* The possible flag bits:  (see RFC 791, page 13) }\n*\nIPMAYFRAGMENT        EQU 0\nIPDONTFRAGMENT       EQU 16384 { Bit 1 of the halfword }\nIPLASTFRAGMENT       EQU 0\nIPMOREFRAGMENTS      EQU 8192 { Bit 2 of the halfword }\n*\n* The bit flags for the IP type-of-service field: RFC 791, p. 12 }\n*\nLOWDELAY             EQU 16\nNORMALDELAY          EQU 0\nHIGHTHROUGHPUT       EQU 8\nNORMALTHROUGHPUT     EQU 0\nHIGHRELIABILITY      EQU 4\nNORMALRELIABILITY    EQU 0\n*\n* UDP header size }\n*\nUDPHEADERSIZE        EQU 8\n*\n* Max data returned on an old-style UdpReceive.  This number\n* will never change. }\n*\nOLDSTYLEMAXUDPDATA   EQU 2040-MINIMUMIPHEADERSIZE-UDPHEADERSIZE\n*\n* Well known protocol numbers }\n*\nICMPPROTOCOLNUMBER   EQU 1\nTCPPROTOCOLNUMBER    EQU 6\nUDPPROTOCOLNUMBER    EQU 17\n*\n* Maximum number of IP protocols }\n*\nIPPROTO_MAX       EQU 256  { Don't even think of changing this number }\n*\nDISABLEALLINTERRUPTS   EQU  X'00'\nENABLEALLINTERRUPTS    EQU  255  { a byte with every bit set to one }\nFIXEDOVERFLOWMASK      EQU  X'08'\nDECIMALOVERFLOWMASK    EQU  X'04'\nEXPONENTUNDERFLOWMASK  EQU  X'02'\nSIGNIFICANCEMASK       EQU  X'01'\nLENGTHOFVIRTUALADDRESS EQU  4\nLENGTHOFDISKLABEL      EQU  6\nCPEXTERNALCOMMAND      EQU  X'40'\nMESSAGENUMBERLIMIT     EQU  1000000000\n*\n*  { This limit is made smaller than necessary so\n*     wrap-around arithmetic is easier. }\n*\nTIMERINTERRUPTCODE     EQU X'1004'\nVMCFINTERRUPTCODE      EQU X'4001'\nIUCVINTERRUPTCODE      EQU X'4000'\nLDSFINTERRUPTCODE      EQU X'2402'\nINTERVALTIMERINTERRUPTCODE EQU X'0080'\nANYOLDADDRESS          EQU 0\n*\n*  { These are all the possible VMCF function calls. }\n*\nVMCFAUTHORIZEFUNCTION   EQU X'0000'\nVMCFUNAUTHORIZEFUNCTION EQU X'0001'\nVMCFSENDFUNCTION        EQU X'0002'\nVMCFSENDRECEIVEFUNCTION EQU X'0003'\nVMCFSENDXFUNCTION       EQU X'0004'\nVMCFRECEIVEFUNCTION     EQU X'0005'\nVMCFCANCELFUNCTION      EQU X'0006'\nVMCFREPLYFUNCTION       EQU X'0007'\nVMCFQUIESCEFUNCTION     EQU X'0008'\nVMCFRESUMEFUNCTION      EQU X'0009'\nVMCFIDENTIFYFUNCTION    EQU X'000A'\nVMCFREJECTFUNCTION      EQU X'000B'\n*\n*  { The IUCV function codes.  The ord of this enum type gives the\n*    actual function code. }\n*\nIUCVQUERYFUNCTION       EQU   0\nIUCVTESTMSGFUNCTION     EQU   1\nIUCVRTRVBFRFUNCTION     EQU   2\nIUCVDESCRIBEFUNCTION    EQU   3\nIUCVSENDFUNCTION        EQU   4\nIUCVRECEIVEFUNCTION     EQU   5\nIUCVREPLYFUNCTION       EQU   6\nIUCVTESTCMPLFUNCTION    EQU   7\nIUCVREJECTFUNCTION      EQU   8\nIUCVPURGEFUNCTION       EQU   9\nIUCVACCEPTFUNCTION      EQU   10\nIUCVCONNECTFUNCTION     EQU   11\nIUCVDCLBFRFUNCTION      EQU   12\nIUCVQUIESCEFUNCTION     EQU   13\nIUCVRESUMEFUNCTION      EQU   14\nIUCVSEVERFUNCTION       EQU   15\nIUCVSETMASKFUNCTION     EQU   16\nIUCVSETCMASKFUNCTION    EQU   17\n*\n* These are the IUCV external interrupt types\n*\nIUCVPENDINGCONNECTION     EQU X'01'\nIUCVCONNECTIONCOMPLETE    EQU X'02'\nIUCVSEVEREDCONNECTION     EQU X'03'\nIUCVQUIESCEDCONNECTION    EQU X'04'\nIUCVRESUMEDCONNECTION     EQU X'05'\nIUCVINCOMINGPREPLY        EQU X'06'\nIUCVINCOMINGREPLY         EQU X'07'\nIUCVINCOMINGPMESSAGE      EQU X'08'\nIUCVINCOMINGMESSAGE       EQU X'09'\n*\n*  { These are V1 flags for the authorize command. }\n*\nVMCFAUTHORIZESPECIFICFLAG EQU X'80'\nVMCFPRIORITYFLAG          EQU X'40'\nVMCFSMSGFLAG              EQU X'20'\n*\n*  { These are V1 flags for a Final Response Interrupt. }\n*\nVMCFFINALRESPONSECODE     EQU X'80'\nVMCFREJECTRESPONSECODE    EQU X'40'\nVMCFPRIORITYRESPONSECODE  EQU X'20'\nMAXSMSGLENGTH             EQU 240  { Maximum SMSG data }\nANINTEGERFLAGREQUESTERR   EQU X'80000000'\n*     { Used only when REJECTing FSENDtcp and FRECEIVEtcp calls }\nIUCVADDRESSLISTSIZE       EQU 20\nNOHOST EQU 0    { an always-invalid InternetAddress }\n*\n*    Because we use 0.0.0.0 as a flag meaning\n*    'NO host', we assume that zero is never allowed as a\n*    valid internet address. RFC 820 lists it as \"reserved\".\n*\nMAXWORDTYPELENGTH        EQU 100\nMAXDESCRIPTORSETLENGTH   EQU 64\n*\n*\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n*\n* The following macro needs 'TCPIP.COMMMAC'.                    \\\n*\n         MVPXVMCV ,                VMCF stuff\n*\n         PRINT NOGEN\n*\n         IEFJESCT\n         IEFJSCVT\n         CVT   DSECT=YES\n         IHAPSA\n*\n         END\n./ ADD NAME=XABDGET  0100-07332-07332-0900-00455-00455-00000-SEB\n         TITLE 'XABDGET  - VERB EXIT INTERFACE MODULE'\n***********************************************************************\n*                                                                     *\n* XABDGET  - VERB EXIT INTERFACE MODULE                               *\n*                                                                     *\n* THIS MODULE HAS SEVERAL ENTRY POINTS, ALL USED TO ENABLE A PROGRAM  *\n* TO RUN AS A TSO COMMAND PROCESSOR OR AN IPCS VERB EXIT:             *\n*                                                                     *\n* XABDGET - DETERMINE IF THE PROGRAM WAS INVOKED AS A VERB EXIT AND   *\n*           RETURN THE ADDRESS OF THE ABDPL IF SO, OTHERWISE BUILD    *\n*           A FAKE ABDPL AND RETURN ITS ADDRESS.                      *\n* XABDFRE - FREE THE FAKE ABDPL BUILT BY XABDGET.                     *\n* XABDMEM - FAKE STORAGE ACCESS ROUTINE.                              *\n* XABDPRT - FAKE OUTPUT WRITING ROUTINE.                              *\n*                                                                     *\n* (THERE MAY BE OTHERS, LIKE A FAKE FORMATTER, IN THE FUTURE.)        *\n*                                                                     *\n* NOTE: CURRENTLY THERE IS NO \"XABDFRE\" ENTRY POINT - THE XABDGET     *\n*       EP WITH R1 = 0 IS A GET REQUEST, ELSE A FREE REQUEST.         *\n*                                                                     *\n* 09/26/1997 SEB1525 - replaced XPUTLINE with direct call to PUTLINE  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    NUMBER OF ELEMNTS IN PARAMETER LIST\nR4       EQU   4    ADDRESS OF ABDPL\nR5       EQU   5    ADDRESS OF ABDPL EXTENSION\nR6       EQU   6    ADDRESS OF OUTPUT BUFFER\nR7       EQU   7    .\nR8       EQU   8    SAVED PARM POINTER\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXABDGET  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDGET_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XABDGET,R12\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* XABDGET IS CALLED WITH R1 CONTAINING:                               *\n*    THE ADDRESS OF THE FAKE ABDPL, IF IT IS TO BE FREED.             *\n*    ZEROES, IF AN ABDPL IS TO BE OBTAINED.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R1,R1\n         BNZ   FREEPL\n         EJECT\nGETPL    DS    0H                  R1 = 0, GET AN ABDPL\n         SPACE 1\n         L     R1,4(,R13)          GET SA WHERE CALLER SAVED REGS\n         L     R1,24(,R1)          GET R1 PASSED TO CALLER\n         LR    R8,R1               SAVE FOR FUTURE USE\n         LR    R2,R1               POINT TO FIRST PARM\n* COUNT # OF PARMS PASSED.  IF GE 7, ASSUME CALLED AS VERB EXIT.\n         LA    R0,6                INITIALIZE PARAMETER COUNT\n         LA    R3,1                CLEAR PARAMETER COUNT\nPARMLOOP TM    0(R2),X'80'         IF VL BIT (LAST PARM ADDR) FOUND,\n         BO    LASTPARM            THEN WE GOT IT\n         LA    R3,1(,R3)\n         LA    R2,4(,R2)           ELSE BUMP POINTER\n         BCT   R0,PARMLOOP         AND CONTINUE LOOPING\nLASTPARM LTR   R0,R0               IF LESS THAN 7 PARMS (R0 ^= 0)\n         BNZ   GETFAKE             THEN NOT INVOKED AS VERB EXIT\n         L     R15,X'21C'          -> TCB\n         L     R15,X'B4'(,R15)     -> JSCB\n         L     R15,X'15C'(,R15)    -> ACTIVE JSCB\n         L     R15,X'108'(,R15)    -> PSCB\n         C     R15,8(,R1)          IF PARM 3 -> PSCB (INVOKED AS CMD)\n******** BE    GETFAKE             THEN NOT INVOKED AS VERB EXIT\n         BNE   RETURN0             ELSE RETURN, R1 -> ABDPL\n         SPACE 1\n* ELSE WE HAVE TO BUILD OUR OWN FAKE ABDPL\n         SPACE 1\nGETFAKE  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* WE ACQUIRE A WORK AREA WITH THE FOLLOWING CONTIGUOUS AREAS:         *\n*                                                                     *\n*   THE ABDPL                                                         *\n*   THE ABDPL EXTENSION                                               *\n*   OUR OWN AREA, INCLUDING OUTPUT BUFFER, CPPL, AND LOTS OF OTHERS.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         GETMAIN R,LV=TOTAREAL     GET STORAGE FOR ABDPL ET AL.\n         LR    R4,R1               SAVE ITS ADDRESS\n         USING ABDPL,R4\n         LA    R5,ADPLLEN(,R4)     ADDRESS THE EXTENSION\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n*\n* INITIALIZE ABDPL\n*\n         XC    ABDPL(ADPLLEN),ABDPL\n         L     R15,X'21C'          ->TCB\n         ST    R15,ADPLTCB         SET TCB OF CURRENT TASK\n         L     R15,X'224'          ->ASCB\n         LH    R15,X'24'(,R15)     ASID\n         STH   R15,ADPLASID        ADDRESS SPACE IDENTIFIER\n         MVI   ADPLFLAG,ADPLSYTM   SET VS1 BIT (REALLY \"FAKE\" BIT)\n         LA    R15,OURBUF\n         ST    R15,ADPLBUF         ADDRESS OF OUTPUT BUFFER\n         L     R15,=V(XABDPRT)\n         ST    R15,ADPLPRNT        ADDRESS OF PRINT ROUTINE\n         L     R15,X'10'\n         ST    R15,ADPLCVT         ADDRESS OF CVT\n         L     R15,=V(XABDMEM)\n         ST    R15,ADPLMEMA        ADDRESS OF MEMORY ACCESS ROUTINE\n*        L     R15,=V(XABDFMT)\n*        ST    R15,ADPLFRMT        ADDRESS OF FORMAT ROUTINE\n*\n         ST    R5,ADPLEXT          ADDRESS OF EXTENSION\n*        L     R15,=V(XABDSRV)\n*        ST    R15,ADPLSERV        ADDRESS OF SERVICES ROUTER\n*\n* INITIALIZE ADPL EXTENSION\n*\n         XC    ADPLEXTN(ADPLEXTL),ADPLEXTN\n* CHECK # OF PARMS PASSED.  IF 4, ASSUME CPPL PASSED\n         L     R15,X'21C'          GET TCB ADDRESS\n         L     R15,X'B4'(,R15)     GET JSCB ADDRESS\n         L     R15,X'15C'(,R15)    GET ADDRESS OF ACTIVE JSCB\n         L     R15,X'108'(,R15)    GET ADDRESS OF PSCB\n         CH    R3,=H'4'            IF AT LEAST 4 PARMS\n         BL    NOTTSOCP            AND\n         C     R15,8(,R8)          PARM 3 -> PSCB (INVOKED AS CMD)\n         BNE   NOTTSOCP            THEN\n         ST    R8,ADPLCPPL          INPUT PARM -> CPPL\n         L     R1,0(,R8)            POINT TO COMMAND BUFFER\n         LH    R14,0(,R1)           GET LENGTH OF COMMAND BUFFER\n         LH    R15,2(,R1)           GET OFFSET TO FIRST OPERAND\n         LA    R15,4(R15,R1)        ABSOLUTE ADDRESS OF OPERAND\n         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER\n         ALR   R14,R1               POINT TO END OF COMMAND BUFFER\n         SR    R14,R15              SUBTRACT OFFSET TO FIRST OPERAND\n         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST\n         B     AFTTSOCP            ELSE\nNOTTSOCP DS    0H                   ...BUILD OUR OWN CPPL\n         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS\n         MVC   CPPLUPT,X'34'(R15)   SAVE UPT ADDRESS\n         L     R15,X'30'(,R15)      GET ADDRESS OF RELOGON BUFFER\n         L     R15,X'100'(,R15)     GET ADDRESS OF ECT\n         ST    R15,CPPLECT          SAVE ECT ADDRESS\n         XC    CPPLCBUF,CPPLCBUF    NO COMMAND BUFFER\n         LA    R1,OURCPPL\n         ST    R1,ADPLCPPL          SET CPPL ADDRESS\n         L     R1,0(,R8)            ASSUME FIRST PARM IS A CALL PARM\n         LA    R15,2(,R1)           ADDRESS OF PARM TEXT\n         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER\n         LH    R14,0(,R1)           GET LENGTH OF PARM FIELD\n         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST\nAFTTSOCP DS    0H\n         L     R1,ADPLCPPL\n         MVC   IOPLUPT,CPPLUPT-OURCPPL(R1) PTR TO UPT\n         MVC   IOPLECT,CPPLECT-OURCPPL(R1) PTR TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB              PTR TO USER'S ECB\n         LA    R0,1                DEFINE 1 MESSAGE SEGMENT\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR\n*\n* INITIALIZE OUTPUT BUFFER TO BLANKS\n*\n         MVI   OURBUFB,C' '        BLANK REQUIRED FOR PUTLINE\n         MVI   OURBUF,C' '\n         MVC   OURBUF+1(OURBUFL-1),OURBUF\n         EJECT\n         LR    R1,R4               SET ABDPL POINTER FOR RETURN\n         B     RETURN0\n         EJECT\nFREEPL   DS    0H                  R1 -> ABDPL TO BE FREED\n         SPACE 1\n         TM    ADPLFLAG-ABDPL(R1),ADPLSYTM  IF VS1/FAKE FLAG SET,\n         BZ    RETURN0             THEN\n         FREEMAIN R,LV=TOTAREAL,A=(1) FREE IT\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 1\nRETURN   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n*                                 R1 CONTAINS ABDPL POINTER           *\n***********************************************************************\n         SPACE 1\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         ST    R1,24(,R13)         STORE ABDPL PTR (R1) IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES, ETC.                                                  *\n***********************************************************************\n         SPACE 1\n         LTORG\n         SPACE 3\n         DROP  R12\n         TITLE 'XABDPRT  - VERB EXIT FAKE OUTPUT PRINT ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXABDPRT  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDPRT\n         LR    R12,R15\n         USING XABDPRT,R12\n         LR    R4,R1               SAVE ABDPL ADDRESS\n         USING ABDPL,R4\n         L     R5,ADPLEXT\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n         SPACE 1\n         ST    R13,OURSAVE+4       SET UP SAVE AREA\n         LA    R1,OURSAVE\n         ST    R1,8(,R13)\n         LR    R13,R1\n         SPACE 1\n         TR    OURBUF(OURBUFL),PRTTRTBL  FIX ALL BAD CHARACTERS\n         SPACE 1\n         LA    R0,OURBUFL+1        LENGTH OF OUTPUT BUFFER\n         LA    R1,OURBUFB          THE OUTPUT BUFFER\n         BAL   R14,PUTLINE         Call PUTLINE to display line\n         LTR   R15,R15             IF PUTLINE FAILED\n         BZ    PRTPUTOK            THEN\n         LA    R1,400(,R15)         ABEND WITH PUTLINE RC + 400\n         ABEND (1),DUMP\n         SPACE 1\nPRTPUTOK DS    0H\n         MVI   OURBUF,C' '         CLEAR OUTPUT BUFFER TO BLANKS\n         MVC   OURBUF+1(OURBUFL-1),OURBUF\n         B     PRTRET0\n         EJECT\nPRTRET4  DS    0H                  RETURN WITH CODE 4\n         LA    R15,4               SET RETURN CODE TO FOUR\n         B     PRTRET\nPRTRET0  DS    0H                  RETURN WITH CODE 0\n         XR    R15,R15             SET RETURN CODE TO ZERO\n******** B     PRTRET\nPRTRET   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\n         L     R13,4(,R13)         RESTORE SAVE AREA POINTER\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\nPRTTRTBL DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/........\u00a0,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         TITLE 'PUTLINE SUBROUTINE'\n         SPACE\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the TSO user using the TSO        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* The message is assumed to begin with a message ID unless            *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTLIN14        Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVCPUT          Else move message to work area\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\nPUTRETRY DS    0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,OURWORK\n         UNPK  OURWORK(2),OURWORK(8)\n         OI    OURWORK+1,X'F0'\n         MVC   PUTWA+1(L'PUTFMSG1),PUTFMSG1\n         MVC   PUTWA+1+L'PUTFMSG1(2),OURWORK\n         MVC   PUTWA+1+L'PUTFMSG1+2(L'PUTFMSG2),PUTFMSG2\n         TPUT  PUTWA+1,L'PUTFMSG1+2+L'PUTFMSG2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTLIN14        Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTRETRY\n*\nMVCPUT   MVC   MSGWA(*-*),0(R1)    Executed\n*\nPUTFMSG1 DC    C'*** XABDGET: PUTLINE error code '\nPUTFMSG2 DC    C' trying to issue the following message:'\n         EJECT\n         LTORG\n         EJECT\n         TITLE 'XABDMEM  - VERB EXIT FAKE MEMORY ACCESS ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXABDMEM  CSECT\n         SPACE 1\n         SAVE  (14,12),,XABDMEM\n         LR    R12,R15\n         USING XABDMEM,R12\n         LR    R4,R1               SAVE ABDPL ADDRESS\n         USING ABDPL,R4\n         L     R5,ADPLEXT\n         USING ADPLEXTN,R5\n         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA\n         USING OURAREA,R6\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR NOW, JUST RETURN THE ADDRESS AS IS.                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     MEMRET0             RETURN OK, ADDRESS IN R0\n         SPACE 1\n         EJECT\nMEMRET4  DS    0H                  RETURN WITH CODE 4\n         LA    R15,4               SET RETURN CODE TO FOUR\n         B     MEMRET\nMEMRET0  DS    0H                  RETURN WITH CODE 0\n         XR    R15,R15             SET RETURN CODE TO ZERO\n******** B     MEMRET\nMEMRET   DS    0H                  RETURN\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n*                                 R0 CONTAINS ADDRESS OF DATA         *\n***********************************************************************\n         SPACE 1\n         STM   R15,R0,16(R13)      STORE VALUES IN SAVE AREA\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n         LTORG\n***********************************************************************\n* MAP OF THE ADDITIONAL AREA FOLLOWING ABDPL AND ADPLEXT              *\n***********************************************************************\n         SPACE 1\nOURAREA  DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nOURSAVE  DS    9D                  SAVE AREA IF NEEDED\nOURWORK  DS    D                   MISCELLANEOUS WORKAREA\nPUTLIN14 DS    A                   PUTLINE SAVE AREA\nOURPLIST DS    0A                  PARAMETER LIST\nOURPARM1 DS    A                   PARAMETER 1\nOURPARM2 DS    A                   PARAMETER 2\nOURPARM3 DS    A                   PARAMETER 3\nOURPARM4 DS    A                   PARAMETER 4\nOURCPPL  DS    0F       TSO COMMAND PROCESSOR PARAMETER LIST\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n*\nIOPL     DS    0A\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nECB      DS    F                   ECB for TSO routines\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL256               PUTLINE message work area\nPUTWA    DS    CL256               PUTLINE message work area\n*\n         SPACE 1\nOURBUFB  DS    CL1                 LEADING BLANK REQUIRED FOR XPUTLINE\nOURBUF   DS    CL133               OUTPUT BUFFER\nOURBUFL  EQU   *-OURBUF\n         SPACE 1\n         DS    0D                  ALIGN TO DOUBLEWORD\n         SPACE 2\nOURAREAL EQU   *-OURAREA           LENGTH OF OUR AREA\n         EJECT\n         BLSABDPL\n         EJECT\n***********************************************************************\n* ADDITIONAL EQUATES                                                  *\n***********************************************************************\n         SPACE 1\nTOTAREAL EQU   ADPLLEN+ADPLEXTL+OURAREAL\n         SPACE 1\n         END\n./ ADD NAME=XACF2    0100-07332-07332-0900-00309-00309-00000-SEB\n         MACRO\n&LABEL   WTT   &TEXT,&HOW\n         LCLC  &LAPOST,&LBLA,&LBLB\n&LAPOST  SETC  'L'''\n&LBLA    SETC  'WTT&SYSNDX.A'\n&LBLB    SETC  'WTT&SYSNDX.B'\n         CNOP  0,4\n&LABEL   BAL   1,&LBLB\n&LBLA    DC    C&TEXT\n&LBLB    DS    0H\n         LA    1,0(,1)\n         LA    0,&LAPOST.&LBLA\n         TPUT  (1),(0),&HOW\n         MEND\n         MACRO\n&LABEL   ASK4  &THING\n         LCLA  &THINGLN\n&THINGLN SETA  L'&THING\n         WTT   'Enter &THING (&THINGLN):',ASIS\n         TCLEARQ INPUT\n         TGET  &THING,&THINGLN\n         TR    &THING.(&THINGLN),UPTBL\n         MEND\n         TITLE 'XACF2    - subroutine to test acf2 access'\n***********************************************************************\n*                                                                     *\n* XACF2    - subroutine to test acf2 access                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   Static base register\nR13      EQU   13   Dynamic base register and save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXACF2    CSECT\n         SAVE  (14,12),,XACF2_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XACF2,R12\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               Restore input parameter address\n         EJECT\n         ASK4  DSNAME\n         ASK4  VOLUME\n         ASK4  PROGRAM\n         ASK4  DDNAME\n         EJECT\n*        ZAP   DATE,=P'0'\n*        LA    R0,RULEREC\n*        L     R1,=A(L'RULEREC)\n*        XR    R14,R14\n*        XR    R15,R15\n*        MVCL  R0,R14\n*        LA    R0,WORKAREA\n*        L     R1,=A(L'WORKAREA)\n*        XR    R14,R14\n*        XR    R15,R15\n*        MVCL  R0,R14\n         EJECT\n***********************************************************************\n*                                                                     *\n* Set the values we want to test access for.                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XC    ACDSV(LACDSV),ACDSV\n         SPACE 1\n         MVI   ACFSPREQ,ACFSPRAC   Validate dsname, volume, ddname\n         OI    ACFSPREQ,ACFSPRFF   Indicate extended parameter list\n         MVI   ACFSPID1,ACFSPIOP   Open request\n         MVI   ACFSPID1,ACFSPIUR   User callable request\n         MVI   ACFSPAC1,ACFSPAIN   Access is input only\n         LA    R1,MSGBUF\n         ST    R1,ACFSPMSG         Our own message buffer.\n*\n* The above should be user-settable.\n*\n         SPACE 1\n         LA    R1,DSNAME\n         ST    R1,ACFSPDSN           ADDRESS OF 44 BYTE DSNAME\n         LA    R1,VOLUME\n         ST    R1,ACFSPVOL           ADDRESS OF 6 BYTE VOLSER\n         LA    R1,PROGRAM\n         ST    R1,ACFSPPGM           ADDRESS OF 8 BYTE PROGRAM NAME\n         LA    R1,DDNAME\n         ST    R1,ACFSPDDN           ADDRESS OF 8 BYTE DDNAME\n         EJECT\n***********************************************************************\n*                                                                     *\n* Call ACFSVC to do the validation testing.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ACFSVC PARMLIST,TYPE=S,CVT=FIND,NONE=RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* Interpret the return code.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    R2,R15              Return code\n*        LR    R3,R1               Pointer to one-byte access flag\n*        LR    R4,R0               Contains information about access\n         B     ACFRET(R2)\nACFRET   B     RC0                 Return code = 0\n         EX    0,*                 Return code = 4\n         EX    0,*                 Return code = 8\n         B     RC12                Return code = 12\n         B     RC16                Return code = 16\n         EJECT\nRC0      DS    0H                  Request is valid\n         SPACE 1\n         WTT   'Access permitted.'\n         B     RETURN\n         SPACE 1\nRC12     DS    0H                  Request is not valid; msg returned.\n         SPACE 1\n         WTT   'Access denied.'\n         B     SEEWHY\n         SPACE 1\nRC16     DS    0H                  Invalid SVC input; msg returned.\n         SPACE 1\n         WTT   'Invalid SVC input parameter.'\n         B     SEEWHY\n         EJECT\nSEEWHY   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Inspect message returned by ACFSVC, pointed to by ???.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R2,ACFSPMSG         Get address of message buffer\n         LH    R0,0(,R2)\n         SH    R0,=H'4'\n         LA    R1,4(,R2)\n         TPUT  (1),(0),R           Display the message\n         B     RETURN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*        SPACE 1\n*HKACC   DS    0H\n*        SPACE 1\n*        MVC   ANSWER(L'ANSWERT),ANSWERT\n*        MVI   AREAD,C'P'\n*        MVI   AWRITE,C'P'\n*        MVI   AALLOC,C'P'\n*        MVI   AEXEC,C'P'\n*        TM    0(R3),X'80'\n*        BNE   NOREADA\n*        MVI   AREAD,C'A'\n*        B     NOREAD\n*OREADA  TM    0(R3),X'40'\n*        BNE   NOREAD\n*        MVI   AREAD,C'L'\n*OREAD   DS    0H\n*        TM    0(R3),X'20'\n*        BNE   NOWRITEA\n*        MVI   AWRITE,C'A'\n*        B     NOWRITE\n*OWRITEA TM    0(R3),X'10'\n*        BNE   NOWRITE\n*        MVI   AWRITE,C'L'\n*OWRITE  DS    0H\n*        TM    0(R3),X'08'\n*        BNE   NOALLOCA\n*        MVI   AALLOC,C'A'\n*        B     NOALLOC\n*OALLOCA TM    0(R3),X'04'\n*        BNE   NOALLOC\n*        MVI   AALLOC,C'L'\n*OALLOC  DS    0H\n*        TM    0(R3),X'02'\n*        BNE   NOEXECA\n*        MVI   AEXEC,C'A'\n*        B     NOEXEC\n*OEXECA  TM    0(R3),X'01'\n*        BNE   NOEXEC\n*        MVI   AEXEC,C'L'\n*OEXEC   DS    0H\n*        LA    R1,ANSWER\n*        LA    R0,ANSWERL\n*        TPUT  (1),(0),R\n*        SPACE 1\n***********************************************************************\n* Return to calling environment - R2 contains return code             *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* Subroutines                                                         *\n***********************************************************************\n         EJECT\n***********************************************************************\n* Executed instructions                                               *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n* Declaratives                                                        *\n***********************************************************************\n         SPACE 1\nANSWERT  DS    0C\n         DC    C'READ('\n         DC    C' '\n         DC    C') WRITE('\n         DC    C' '\n         DC    C') ALLOC('\n         DC    C' '\n         DC    C') EXEC('\n         DC    C' '\n         DC    C')'\n         ORG   ,\nANSWERTL EQU   *-ANSWERT\n         SPACE 1\nUPTBL    DC    256YL1(*-UPTBL)\n         ORG   UPTBL+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         SPACE 1\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\n@ACFINT  DS    A                   Address of ACFINT\nPARMLIST DS    0D                  Parameter list\n         SPACE 1\n         ACDSV DSECT=NO\nLACDSV   EQU   *-ACDSV\n         SPACE 1\nANSWER   DS    0C\n         ORG   ANSWER\n         DC    C'READ('\nAREAD    DC    C' '\n         DC    C') WRITE('\nAWRITE   DC    C' '\n         DC    C') ALLOC('\nAALLOC   DC    C' '\n         DC    C') EXEC('\nAEXEC    DC    C' '\n         DC    C')'\n         ORG   ,\nANSWERL  EQU   *-ANSWER\nDSNAME   DS    CL44\nVOLUME   DS    CL6\nPROGRAM  DS    CL8\nDDNAME   DS    CL8\n*ATE     DS    PL4\n*ULEREC  DS    CL512\n*ORKAREA DS    CL1024\nMSGBUF   DS    CL128\n         SPACE 2\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n         SPACE 1\n         ACCVT\n         SPACE 1\n         END\n./ ADD NAME=XALCMOD  0100-07332-07332-0900-02667-02667-00000-SEB\n         TITLE 'XALCMOD  - modify TSO file allocation'\n***********************************************************************\n*                                                                     *\n* XALCMOD  - modify TSO file allocation                               *\n*                                                                     *\n* This is the replacement for XALCAPP/XALCREM/XAPPEND/XREMOVE.        *\n*                                                                     *\n* The syntax is:  XALCMOD +                                           *\n*                         option(file1(dsn11 dsn12 ...) +             *\n*                                file2(dsn21 dsn22 ...) +             *\n*                                ... +                                *\n*                               )  +                                  *\n*                         INFORM | ACTINFORM | FAILINFORM | NOINFORM  *\n*                                                                     *\n* where:                                                              *\n*       \"option\" is required and one of:                              *\n*       INSERT/FRONT/BACK/DELETE/SETUP                                *\n*                                                                     *\n* and zero or more filei(dsni) specifications are required.           *\n*                                                                     *\n* One or more dsni's may occur within the parentheses; if no dsni's   *\n* are specified, the filei is ignored.                                *\n*                                                                     *\n* Return codes:                                                       *\n*                                                                     *\n*   0 - allocation request OK, changes occurred                       *\n*   4 - allocation request processed, no changes occurred             *\n*   8 - one or more requested datasets unavailable, partially done    *\n*  12 - specification error or failure, allocation as before          *\n*  16 - severe error, allocation may be munged                        *\n*                                                                     *\n*************************************************************** #TSO158\n*                                                               #TSO158\n* Change activity:                                              #TSO158\n*                                                               #TSO158\n* 11/14/91 - SEB1525 - added support for 'CCF.*' data sets.     #TSO158\n* 10/15/96 - SEB1525 - changes required for new UCB access.     #TSO???\n*                                                               #TSO158\n***********************************************************************\n*\n         GBLA  &CATLIM             Max # of datasets we can concatenate\n&CATLIM  SETA  50                  <== Change this value if desired\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    Address of FDB (user input file dataset block)\nR4       EQU   4    Address of DSL (already allocated data set list)\nR5       EQU   5    Pointer into variable part of DSL (each dsname)\nR6       EQU   6    Pointer into variable part of FDB (each dsname)\nR7       EQU   7    Used for building concatenation ddname list\nR8       EQU   8    Miscellaneous uses\nR9       EQU   9    Counter for looping through FDB or DSL dsnames\nR10      EQU   10   Dynamic base register\nR11      EQU   11   Second static base register\nR12      EQU   12   First static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         EJECT\nXALCMOD  CSECT\nXALCMOD  AMODE 31\nXALCMOD  RMODE ANY\n         B     XALCMOD_START-XALCMOD(,R15)\n         DC             YL1(XALCMOD_EYECATCHER_END-XALCMOD_EYECATCHER)\nXALCMOD_EYECATCHER      DC C'XALCMOD &SYSDATE &SYSTIME'\nXALCMOD_EYECATCHER_END  EQU *\nSECOND_BASE_CON         DC A(XALCMOD+4096)\nXALCMOD_START           DS 0H\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         L     R11,SECOND_BASE_CON-XALCMOD(,R15)\n         USING XALCMOD,R12,R11\n         LR    R2,R1               Save CPPL address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R10,R13\n         USING DATD,R10\n         EJECT\n         USING CPPL,R2             Addressability to CPPL\n*\n         ST    R2,CPPLADDR\n         MVC   IOPLUPT,CPPLUPT         PTR TO UPT\n         MVC   IOPLECT,CPPLECT         PTR TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB              PTR TO USER'S ECB\n*                                  Initialize PARSE fields\n         XC    ANSWER,ANSWER\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R14,ECB\n         L     R15,=V(XALCMPCL)\n         LA    R0,ANSWER\n         L     R1,CPPLCBUF\n         STM   R14,R1,PPLECB\n         ST    R10,PPLUWA          User work area = \"DATD\"\n         ST    R10,PPLVEWA         User work area = \"DATD\"\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\n         LA    R0,1                DEFINE 1 MESSAGE SEGMENT\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR\n*                                  Initialize other data areas\n         XC    FRSTFDB,FRSTFDB     Clear file-dataset block pointer\n         XC    LASTFDB,LASTFDB     Clear file-dataset block pointer\n         STM   R11,R12,MYBASES     Base registers used in PARSE exits\n         MVI   FLAGS,X'00'         Clear flags\n*\n         DROP  R2                  Addressability to CPPL not needed\n*\n* Initialize dynamic allocation control blocks.\n* S99VERB and S99TXTPP are set by the individual subroutines.\n*\n         LA    R14,S99RBP          Address of SVC 99 work area\n         LA    R15,ENDS99          Compute length thereof\n         SR    R15,R14\n         XR    R0,R0\n         XR    R1,R1\n         MVCL  R14,R0              Move zeroes to all of SVC 99 w/a\n         LA    R1,S99RB\n         ST    R1,S99RBPTR\n         OI    S99RBPTR,X'80'\n         MVI   S99RBLN,20          Length of SVC 99 request block\n         OI    S99FLG11,S99NOCNV   Don't use existing allocation\n         LA    R14,TUADSNAM        Allocation text unit pointers\n         LA    R15,TUASTATS        \" (VL bit set depending on call)\n         LA    R0,TUAPERMA         \"\n         LA    R1,TUADDNAM         \"\n         LA    R2,TUAUNIT          \"\n         STM   R14,R2,TUPLALLC     \"\n         LA    R14,TUUDDNAM        Unallocation text unit pointers\n         LA    R15,TUUUNALC        \"\n         STM   R14,R15,TUPLUNAL+0  \"\n         OI    TUPLUNAL+4,X'80'    \"\n         LA    R14,TUCDDNAM        Concatenation text unit pointers\n         LA    R15,TUCPERMC        \"\n         STM   R14,R15,TUPLCCAT+0  \"\n         OI    TUPLCCAT+4,X'80'    \"\n*\n         MVC   TUADSNAM(4),=Y(DALDSNAM,1)\n         MVC   TUADDNAM(4),=Y(DALDDNAM,1)\n         MVC   TUASTATS(6),=Y(DALSTATS,1,1)\n*        MVC   TUAVLSER(6),=Y(DALVLSER,1,6)\n         MVC   TUAUNIT(6),=Y(DALUNIT,1,4)\n         MVC   TUAPERMA(2),=Y(DALPERMA)\n         MVC   TUARTDDN(6),=Y(DALRTDDN,1,8)\n         MVC   TUUDDNAM(4),=Y(DUNDDNAM,1)\n         MVC   TUUUNALC(2),=Y(DUNUNALC)\n         MVC   TUCDDNAM(2),=Y(DCCDDNAM)\n         MVC   TUCPERMC(2),=Y(DCCPERMC)\n*\n***********************************************************************\n*                                                                     *\n* Invoke the PARSE service routine to get the parameters              *\n*                                                                     *\n***********************************************************************\n*\n         XC    ECB,ECB             Clear ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL) Call PARSE service routine\n         LTR   R15,R15             If return code nonzero\n         BNZ   RETURN12            then failure, return code(12)\n*\n***********************************************************************\n*                                                                     *\n* Set FRONT/BACK/INSERT/DELETE/SETUP and INFORM/etc.                  *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,ANSWER\n         USING PDL,R1\n         MVC   WHAT(1),PWHAT+1     FRONT, BACK, INSERT, DELETE, SETUP\n         XR    R15,R15             Clear insert register\n         IC    R15,PINFORM+1       INFORM/ACTINFORM/FAILINFOR/NOINFORM\n         STC   R15,MSGLEVEL        Save message level\nNO_MSGLEVEL DS 0H\n         DROP  R1\n*\n***********************************************************************\n*                                                                     *\n* Process each file(dsn dsn ...) combination.                         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n         USING FDB,R3              Addressability to file-ds blocks\n         USING FDBDATAD,R6\n         USING DSLIST,R4\n         USING DSLDATAD,R5\n*                                                                     *\n         ICM   R3,15,FRSTFDB       Get address of first FDB\n         BZ    ENDFDB              Skip if no FDB's\nLOOPFDB  DS    0H\n         BAL   R14,PROCFDB         Process this file\n         LR    R1,R3               Get address of this FDB\n         L     R0,FDBLEN           Get length of this FDB\n         L     R3,FDBNEXT          Get address of next FDB and then...\n         FREEMAIN R,LV=(0),A=(1)   free this FDB\n         LTR   R3,R3               If there is another FDB\n         BNZ   LOOPFDB             then go to process it\nENDFDB   DS    0H\n*\n* Finished.  Now figure out what return code to return.\n*\n         TM    FLAGS,DISASTER      If recovery failed and allocation\n         BO    RETURN16            is munged, then return code(16)\n         TM    FLAGS,DDFAILED      Else if a dd couldn't be processed\n         BO    RETURN12            then return code(12)\n         TM    FLAGS,DSNSKIPD      Else if some dsn's were bypassed\n         BO    RETURN8             then return code(8)\n         TM    FLAGS,DIDSTUFF      Else if reallocation was done\n         BO    RETURN0             then return code(0)\n         B     RETURN4             else no changes, return code(4)\n*\nRETURN16 LA    R2,16               Return with code 16\n         B     FLUSH_STACK_AND_RETURN\nRETURN12 LA    R2,12               Return with code 12\n         B     FLUSH_STACK_AND_RETURN\nRETURN8  LA    R2,8                Return with code 8\n         B     RETURN\nRETURN4  LA    R2,4                Return with code 4\n         B     RETURN\nRETURN0  XR    R2,R2               Return with code 0\n         B     RETURN\n         EJECT\nFLUSH_STACK_AND_RETURN DS 0H       Return in failure\n         TCLEARQ INPUT\n         MVC   FLUSH(LENFLUSH),MFLUSH Set up stack list form\n         XC    ECB,ECB             Clear ECB and flush the input stack\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R15,R15\n         BZ    RETURN\n         LA    R1,MSG_STACK_ERROR\n         LA    R0,L'MSG_STACK_ERROR\n         BAL   R14,PUTLINE\n*\nRETURN   DS    0H                  R2 contains return code\n*\n         IKJRLSA ANSWER            Free IKJPARS storage if any\n*\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*\nPROCFDB  DS    0H\n*\n*\n***********************************************************************\n*                                                                     *\n* This routine processes each file(dsn1 dsn2 dsn3 ...) specification. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* R3 -> the current FDB (file-dataset block.                          *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PROCFDB_R14     Save return register\n         NI    FLAGS,255-DDFREED-DELETING  Clear appropriate flags\n*\n***********************************************************************\n*                                                                     *\n*      Determine the current allocation environment associated with   *\n*      DDNAME filei.  Do this by scanning the TIOT for filei,         *\n*      including its concatenations (i.e. any following blank dd's).  *\n*      Acquire an area of storage large enough to hold information    *\n*      for all the currently allocated data sets.  Then, from all     *\n*      TIOT entries for these, collect the following information:     *\n*                                                                     *\n*       Data set name (from the JFCB)                                 *\n*       (If a member name is present, abort this with an error.)      *\n*       Volume serial (from the JFCB)                                 *\n*       (If more than one volume, abort this with an error.)          *\n*       Unit name (from the UCB)                                      *\n*       (If not a DASD volume, abort this with an error.)             *\n*                                                                     *\n*      If the disposition is not SHR, abort this with an error.       *\n*                                                                     *\n*      In addition, the following text units must be present:         *\n*                                                                     *\n*       DDNAME (to be filled in later, NOT copied from TIOT)          *\n*       Permanently allocated attribute                               *\n*                                                                     *\n***********************************************************************\n*\n* Scan the TIOT to see how many concatenated allocations to this file\n*\n         L     R15,X'21C'          TCB\n         L     R15,12(,R15)        TIOT\n         USING TIOT1,R15\n         LA    R15,TIOENTRY        POINT TO FIRST TIOT ENTRY\n         XR    R14,R14             CLEAR REG USED TO INSERT LENGTH\n         XR    R2,R2               Set data set count to zero\nLOOPTIOT DS    0H\n         USING TIOENTRY,R15\n         TM    TIOESTTA,TIOSLTYP   If TIOT entry not in use\n         BO    SKIPTIOT            then skip this entry\n         CLC   TIOEDDNM,FDBDDN     If TIOT ddname matches ours\n         BE    GOTTIOT             then skip this entry\nSKIPTIOT DS    0H\n         IC    R14,TIOELNGH        Get length of current TIOT entry\n         ALR   R15,R14             Add length to get to next entry\n         CLI   TIOELNGH,X'00'      If not yet end of TIOT\n         BNE   LOOPTIOT            then continue\n         B     EXITTIOT            else we're through.\n*\nGOTTIOT  DS    0H                  Found our ddname\n         LR    R8,R15              Save address of this entry\nGOT_ANOTHER_TIOT DS 0H\n         LA    R2,1(,R2)           Show at least 1 dataset allocated\nSKIPTIOT2 DS   0H                  Scan for all following blank dd's\n         IC    R14,TIOELNGH        Get length of current TIOT entry\n         ALR   R15,R14             Add length to get to next entry\n         CLI   TIOELNGH,X'00'      If end of TIOT\n         BE    EXITTIOT            then we're through\nLOOPTIOT2 DS   0H\n         TM    TIOESTTA,TIOSLTYP   If TIOT entry not in use\n         BO    SKIPTIOT2           then skip this entry\n         CLC   TIOEDDNM,BLANKS     If TIOT ddname is not blank\n         BE    GOT_ANOTHER_TIOT    then we're through.\n******** B     EXITTIOT            then we're through.\n*\nEXITTIOT DS    0H                  Else we got nothing...\n         DROP  R15\n*\n* R4 will -> DSLIST buffer for this file\n* Assume number of allocations is in R2\n* R8 -> TIOT entry for file (the first one)\n*\n         USING TIOENTRY,R8\n         LR    R14,R2              Number of data sets allocated\n         MH    R14,=Y(DSLDATAL)    Length of variable portion of dslist\n         AH    R14,=Y(DSLISTL)     Length of fixed portion of dslist\n         GETMAIN R,LV=(R14)        Get a DSLIST buffer\n         LR    R4,R1               Address it\n         ST    R14,DSLLEN          Save length of this DSLIST buffer\n         AR    R14,R4\n         ST    R14,DSLEND          Save address of end of the buffer\n         STH   R2,DSLCOUNT         Save number of data sets\n         LTR   R9,R2               Get number of datasets allocarted\n         BZ    AFTDSL              If zero, then skip the following.\n         LA    R5,DSLDATA          Point to first dataset section\n*                                  R8 -> first TIOT entry for file\nSTORE_DSL_DATA_LOOP DS 0H          Loop through allocated data sets\n*\n* R8 -> each TIOT entry as we loop through (R9) times.\n*\n*----------------------------------------------------------------------\n*\n* Watch out - need SWA below the line to do this!!!!!!!!\n*\n*----------------------------------------------------------------------\n*\n         XR    R7,R7\n         ICM   R7,7,TIOEJFCB       Get JFCB address\n         LA    R7,16(,R7)          Bump past SWA prefix\n         USING INFMJFCB,R7\n         CLI   JFCBDSNM,C' '       If data set name is blank\n         BE    ERROR_BLANK_DSNAME  then error - not a data set\n         MVC   DSLDSN(44),JFCBDSNM Move JFCB data set name to DSLIST\n         LA    R1,DSLDSN           Beginning of dsname\n         LA    R2,DSLDSN+43        Last byte of dsname\nGET_DSLDSN_BLANK DS 0H\n         CLI   0(R2),C' '          Search for last nonblank\n         BNE   GOT_DSLDSN_LENGTH\n         BCT   R2,GET_DSLDSN_BLANK\nGOT_DSLDSN_LENGTH DS 0H\n         SR    R2,R1               Last blank minus start\n         LA    R2,1(,R2)           plus 1\n         STH   R2,DSLDSNL          gives length of data set name\n         CLC   JFCBELNM(8),BLANKS  If member name is not blank\n         BNE   ERROR_ALLOC_MEMBER  then error - allocated with member\n         XR    R14,R14\n         ICM   R14,7,TIOEFSRT      Get address of UCB\n         BZ    ERROR_BAD_UCB_ADDR  If none, wrong kind of allocation\n         USING UCBCMSEG,R14\n         CLC   =CL3'UCB',UCBNAME   Get device name from UCB\n         BE    USE_UCBCHAN_INSTEAD\n         MVC   DSLUNAME(3),UCBNAME\n         MVI   DSLUNAME+3,C' '\n         B     UCBNAME_MOVED\nUSE_UCBCHAN_INSTEAD DS 0H\n*        UNPK  DSLUNAME(5),UCBCHAN(3)\n*        TR    DSLUNAME(4),HEXTBL\n         MVC   DSLUNAME,BLANKS     4-digit device NG, don't use unit #\nUCBNAME_MOVED       DS 0H\n         CLI   JFCBNVOL,1          If more than 1 volume serial\n         BH    ERROR_MULTIPLE_VOL  then error - multivolume data set\n         MVC   DSLVOL(6),JFCBVOLS  Move JFCB volume serial to DSLIST\n         TM    JFCBIND2,JFCSHARE   If disposition is not SHR\n         BNO   ERROR_DISP_NOT_SHR  then error - invalid disposition\n         MVI   DSLFLAGS,X'00'      Clear flags\n         LA    R5,DSLDATAL(,R5)    Bump to next dataset section\n         XR    R14,R14             Clear insert register\nBUMP_TO_NEXT_TIOT_ENTRY DS 0H\n         IC    R14,TIOELNGH            Get length of current TIOT entry\n         ALR   R8,R14                  Add length to get to next entry\n         TM    TIOESTTA,TIOSLTYP       If TIOT entry not in use\n         BO    BUMP_TO_NEXT_TIOT_ENTRY then skip this entry\n         BCT   R9,STORE_DSL_DATA_LOOP Continue until no more datasets\n*\nAFTDSL   DS    0H\n         XR    R7,R7               Initialize concatenation stuff\n         STH   R7,C9NUMBER\n*\n***********************************************************************\n*                                                                     *\n* Proceed depending on the value of the \"what processing\" keyword.    *\n*                                                                     *\n***********************************************************************\n*\n         CLI   WHAT,FRONT\n         BE    DOFRONT\n         CLI   WHAT,BACK\n         BE    DOBACK\n         CLI   WHAT,INSERT\n         BE    DOINSERT\n         CLI   WHAT,DELETE\n         BE    DODELETE\n         CLI   WHAT,SETUP\n         BE    DOSETUP\n         EJECT\nDOFRONT  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine does processing when the keyword request is FRONT.     *\n*                                                                     *\n***********************************************************************\n*\n* If a ddname without dsnames was specified, take no action.\n*\n         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested\n         BL    DONE                If none, take no action\n         BH    DOFRONT_MULTIPLE_INPUT_DSNS If more than one, go...\n*\n* Only one input dsn specified for this ddname:\n*\n         LA    R6,FDBDATA          Point to first and only input dsn\n*\n* If filei is not allocated, then allocate filei to dsni and exit.\n*\n         CLC   DSLCOUNT,=H'0'      If there are no datasets\n         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.\n*\n* If dsni is the first name in dslist, exit doing nothing.\n*\n         LA    R5,DSLDATA          Point to first dslist data set\n         CLC   FDBDSN,DSLDSN       If requested dataset in front now,\n         BE    DO_NOTHING          then exit - already allocated as is\n*\n* Set up the file name and the data set name to be allocated.\n*\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n*\n* Remove all occurrences of input dsn from dslist so that they will\n* be \"moved\" from their currently-allocated position to the front.\n*\n         BAL   R14,REMOVEI         Remove DSNAME from DSLIST\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* Allocate filei to dsni.\n*\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the file to the dataset.\n         LTR   R15,R15             If failure\n         BZ    DOFRONT_OK_SO_FAR   then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOFRONT_OK_SO_FAR DS 0H\n*\n* For each non-removed dataset in dslist, generate a file name and\n* allocate that file name to the dataset.\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DOFRONT_END_LOOP\nDOFRONT_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOFRONT_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOFRONT_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOFRONT_LOOP\n*\nDOFRONT_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n*\nDOFRONT_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested\n*\n* If filei is not allocated, then just allocate the dsns to filei.\n*\n         MVC   DDNAME,FDBDDN       Set up ddname\n         MVC   DDNAMEL,FDBDDNL\n         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname\n         BE    DOFRONT_ALLOCATE_MI then just allocate input dsns.\n*\n* If the first n data set names in the dslist match the dsni's, exit.\n*\n         LA    R5,DSLDATA          Point to allocated dsnames list\n         LA    R6,FDBDATA          Point to requested dsnames list\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\n         CH    R9,DSLCOUNT         If more dsns wanted than allocated\n         BH    DOFRONT_MATCH_LOST  then input dsn's don't all match up\nDOFRONT_MATCH_LOOP DS 0H\n         C     R5,DSLEND           If we reached end of dslist\n         BNL   DOFRONT_MATCH_LOST  then input dsns don't all match up\n         CLC   FDBDSN,DSLDSN       If data set names don't match\n         BNE   DOFRONT_MATCH_LOST  then input dsns don't all match up\n         LA    R5,DSLDATAL(,R5)    Bump\n         LA    R6,FDBDATAL(,R6)    Bump\n         BCT   R9,DOFRONT_MATCH_LOOP Loop\n         B     DO_NOTHING          If we made it, all match, do nothing\nDOFRONT_MATCH_LOST DS 0H           Otherwise they don't all match...\n*\n* For each dsnij found somewhere in the dslist, remove it from dslist.\n*\n         LA    R6,FDBDATA          Point to requested dsnames list\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\nDOFRONT_REMOVEI_LOOP DS 0H         For each requested dsname...\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI          Remove DSNAME from DSLIST\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,DOFRONT_REMOVEI_LOOP\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For j = 1 thru n, allocate files to dsnij's.  The first allocation\n* will be to filei, and the others will be to generated file names.\n* (Note that we come here when filei isn't already allocated.)\n*\nDOFRONT_ALLOCATE_MI DS 0H\n         LA    R6,FDBDATA          Point to first requested dataset.\n         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)\nDOFRONT_MI_LOOP DS 0H\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the dsname\n         LTR   R15,R15             If failure\n         BZ    DOFRONT_MI_CONTINUE  then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOFRONT_MI_CONTINUE DS 0H\n         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.\n         BCT   R9,DOFRONT_MI_LOOP\n*\n* For each non-removed dataset in dslist, generate a file name\n* and allocate that file name to the dataset.\n* (There may be none in dslist, so take that into account.)\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DOFRONT_MO_END_LOOP\nDOFRONT_MO_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOFRONT_MO_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOFRONT_MO_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOFRONT_MO_LOOP\n*\nDOFRONT_MO_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n         EJECT\nDOBACK   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine does processing when the keyword request is BACK.      *\n*                                                                     *\n***********************************************************************\n*\n* If a ddname without dsnames was specified, take no action.\n*\n         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested\n         BL    DONE                If none, take no action\n         BH    DOBACK_MULTIPLE_INPUT_DSNS If more than one, go...\n*\n* Only one input dsn specified for this ddname:\n*\n         LA    R6,FDBDATA          Point to first and only input dsn\n*\n* If filei is not allocated, then allocate filei to dsni and exit.\n*\n         CLC   DSLCOUNT,=H'0'      If there are no datasets\n         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.\n*\n* If dsni is the last name in dslist, exit doing nothing.\n*\n         L     R5,DSLEND\n         SH    R5,=Y(DSLDATAL)     Point to last dslist data set\n         CLC   FDBDSN,DSLDSN       If requested dataset in back now,\n         BE    DO_NOTHING          then exit - already allocated as is\n*\n* Remove all occurrences of input dsn from dslist so that they will\n* be \"moved\" from their currently-allocated position to the back.\n*\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI         Remove DSNAME from DSLIST\n*\n* Unallocate filei.\n*\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, allocate that dataset.\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DOBACK_END_LOOP\nDOBACK_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOBACK_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOBACK_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOBACK_LOOP\nDOBACK_END_LOOP DS 0H\n*\n* Allocate dsni.\n*\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the file to the dataset.\n         LTR   R15,R15             If failure\n         BZ    DOBACK_OK_SO_FAR    then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOBACK_OK_SO_FAR DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n*\nDOBACK_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested\n*\n* If filei is not allocated, then just allocate the dsns to filei.\n*\n         MVC   DDNAME,FDBDDN       Set up ddname\n         MVC   DDNAMEL,FDBDDNL\n         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname\n         BE    DOBACK_ALLOCATE_MI then just allocate input dsns.\n*\n* If the last n data set names in the dslist match the dsni's, exit.\n*\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\n         CH    R9,DSLCOUNT         If more dsns wanted than allocated\n         BH    DOBACK_MATCH_LOST   then input dsn's don't all match up\n         L     R5,DSLEND\n         LA    R1,DSLDATAL\n         MH    R1,FDBCOUNT\n         SR    R5,R1               Point to nth-from-last data set\n         LA    R6,FDBDATA          Point to requested dsnames list\nDOBACK_MATCH_LOOP DS 0H\n         C     R5,DSLEND           If we reached end of dslist\n         BNL   DOBACK_MATCH_LOST   then input dsns don't all match up\n         CLC   FDBDSN,DSLDSN       If data set names don't match\n         BNE   DOBACK_MATCH_LOST   then input dsns don't all match up\n         LA    R5,DSLDATAL(,R5)    Bump\n         LA    R6,FDBDATAL(,R6)    Bump\n         BCT   R9,DOBACK_MATCH_LOOP Loop\n         B     DO_NOTHING          If we made it, all match, do nothing\nDOBACK_MATCH_LOST DS 0H            Otherwise they don't all match...\n*\n* For each dsnij found somewhere in the dslist, remove it from dslist.\n*\n         LA    R6,FDBDATA          Point to requested dsnames list\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\nDOBACK_REMOVEI_LOOP DS 0H          For each requested dsname...\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI          Remove DSNAME from DSLIST\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,DOBACK_REMOVEI_LOOP\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, allocate that dataset.\n* The first allocation will be to filei, and the others will be to\n* generated file names.\n* (There may be none in dslist, so take that into account.)\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DOBACK_MO_END_LOOP\nDOBACK_MO_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOBACK_MO_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOBACK_MO_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOBACK_MO_LOOP\nDOBACK_MO_END_LOOP DS 0H\n*\n* For j = 1 thru n, allocate files to dsnij's.  The first allocation\n* was to filei, and the others will be to generated file names.\n* (Note that we come here when filei isn't already allocated.)\n*\nDOBACK_ALLOCATE_MI DS 0H\n         LA    R6,FDBDATA          Point to first requested dataset.\n         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)\nDOBACK_MI_LOOP DS 0H\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the dsname\n         LTR   R15,R15             If failure\n         BZ    DOBACK_MI_CONTINUE   then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOBACK_MI_CONTINUE DS 0H\n         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.\n         BCT   R9,DOBACK_MI_LOOP\n         B     DO_CONCATENATION    Go concatenate allocated files.\n         EJECT\nDOINSERT DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine does processing when the keyword request is INSERT.    *\n*                                                                     *\n***********************************************************************\n*\n* If a ddname without dsnames was specified, take no action.\n*\n         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested\n         BL    DONE                If none, take no action\n         BH    DOINSERT_MULTIPLE_INPUT_DSNS If more than one, go...\n*\n* Only one input dsn specified for this ddname:\n*\n         LA    R6,FDBDATA          Point to first and only input dsn\n*\n* If filei is not allocated, then allocate filei to dsni and exit.\n*\n         CLC   DSLCOUNT,=H'0'      If there are no datasets\n         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.\n*\n* Find the first \"system\" data set in the dslist.\n* If there is none, then go to process as for BACK.\n*\n* Note: A \"system\" data set is currently considered to be a data set\n*       whose high-level qualifier is one of the following:\n*\n*       SYS1, CSD, ISP, SYSALL, CCF                             #TSO158\n*\n         LA    R5,DSLDATA          Point to first data set in dslist\n         XR    R1,R1               Clear before-system-ds counter\nDOINSERT_FIND_SYSTEM_DS_LOOP DS 0H\n         C     R5,DSLEND           Loop until end of dslist\n         BNL   DOBACK              If none, go process like BACK\n         CLC   =C'SYS1.',DSLDSN    Test for system-data-set-ness\n         BE    DOINSERT_FOUND_SYSTEM_DS\n         CLC   =C'CSD.',DSLDSN\n         BE    DOINSERT_FOUND_SYSTEM_DS\n         CLC   =C'ISP.',DSLDSN\n         BE    DOINSERT_FOUND_SYSTEM_DS\n         CLC   =C'SYSALL.',DSLDSN\n         BE    DOINSERT_FOUND_SYSTEM_DS\n         CLC   =C'CCF.',DSLDSN                                  #TSO158\n         BE    DOINSERT_FOUND_SYSTEM_DS                         #TSO158\n         LA    R1,1(,R1)           Increment before-system-ds counter\n         LA    R5,DSLDATAL(,R5)\n         B     DOINSERT_FIND_SYSTEM_DS_LOOP\nDOINSERT_FOUND_SYSTEM_DS DS 0H\n         ST    R5,PSYSDS           Save address of system data set\n*\n* If the first \"system\" data set is the same as dsni, then do nothing.\n*\n         CLC   DSLDSN,FDBDSN\n         BE    DO_NOTHING\n*\n* If the first data set in dslist is a \"system\" data set,\n* then go to process as for FRONT.\n*\n         LTR   R1,R1               If no before-system-ds data sets\n         BZ    DOFRONT             then go process like FRONT\n*\n         SH    R5,=Y(DSLDATAL)     Get address of dataset before sys ds\n         ST    R5,BSYSDS           Save it\n         STH   R1,BSDCOUNT         # of datasets before system one\n         LH    R15,DSLCOUNT        Get total dslist count\n         SR    R15,R1              Subtract before-system count\n         STH   R15,PSDCOUNT        # of datasets from system one onward\n*\n* If dsni immediately precedes the first \"system\" data set, do nothing.\n*\n         L     R5,BSYSDS           Point to first \"system\" data set\n         CLC   DSLDSN,FDBDSN\n         BE    DO_NOTHING\n*\n* Remove all occurrences of input dsn from dslist so that they will\n* be \"moved\" from their currently-allocated position to the INSERT.\n*\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI         Remove DSNAME from DSLIST\n*\n* Unallocate filei.\n*\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, up to but not including the\n* first \"system\" data set, allocate that dataset.\n*\n         LA    R5,DSLDATA\n         LH    R9,BSDCOUNT\n         LTR   R9,R9\n         BZ    DOINSERT_BEFORE_END_LOOP\nDOINSERT_BEFORE_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOINSERT_BEFORE_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOINSERT_BEFORE_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOINSERT_BEFORE_LOOP\nDOINSERT_BEFORE_END_LOOP DS 0H\n*\n* Allocate dsni.\n*\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the file to the dataset.\n         LTR   R15,R15             If failure\n         BZ    DOINSERT_OK_SO_FAR  then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOINSERT_OK_SO_FAR DS 0H\n*\n* For each non-removed dataset in dslist starting from the first\n* \"system\" data set, allocate that data set.\n*\n         L     R5,PSYSDS\n         LH    R9,PSDCOUNT\n         LTR   R9,R9\n         BZ    DOINSERT_AFTER_END_LOOP\nDOINSERT_AFTER_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOINSERT_AFTER_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOINSERT_AFTER_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOINSERT_AFTER_LOOP\nDOINSERT_AFTER_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n*\nDOINSERT_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested\n*\n* If filei is not allocated, then just allocate the dsns to filei.\n*\n         MVC   DDNAME,FDBDDN       Set up ddname\n         MVC   DDNAMEL,FDBDDNL\n         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname\n         BE    DOINSERT_ALLOCATE_MI then just allocate input dsns.\n*\n* Find the first \"system\" data set in the dslist.\n* If there is none, then go to process as for BACK.\n*\n* Note: A \"system\" data set is currently considered to be a data set\n*       whose high-level qualifier is one of the following:\n*\n*       SYS1, CSD, ISP, SYSALL, CCF                             #TSO158\n*\n         LA    R5,DSLDATA          Point to first data set in dslist\n         XR    R1,R1               Clear before-system-ds counter\nDOINSERT_MIND_SYSTEM_DS_LOOP DS 0H\n         C     R5,DSLEND           Loop until end of dslist\n         BNL   DOBACK              If none, then go process like BACK\n         CLC   =C'SYS1.',DSLDSN    Test for system-data-set-ness\n         BE    DOINSERT_MOUND_SYSTEM_DS\n         CLC   =C'CSD.',DSLDSN\n         BE    DOINSERT_MOUND_SYSTEM_DS\n         CLC   =C'ISP.',DSLDSN\n         BE    DOINSERT_MOUND_SYSTEM_DS\n         CLC   =C'SYSALL.',DSLDSN\n         BE    DOINSERT_MOUND_SYSTEM_DS\n         CLC   =C'CCF.',DSLDSN                                  #TSO158\n         BE    DOINSERT_MOUND_SYSTEM_DS                         #TSO158\n         LA    R1,1(,R1)           Increment before-system-ds counter\n         LA    R5,DSLDATAL(,R5)\n         B     DOINSERT_MIND_SYSTEM_DS_LOOP\nDOINSERT_MOUND_SYSTEM_DS DS 0H\n*\n* If the first data set in dslist is a \"system\" data set,\n* then go to process as for FRONT.\n*\n         LTR   R1,R1               If no before-system-ds data sets\n         BZ    DOFRONT             then go process like FRONT\n*\n* Else save info about where the first \"system\" data set is.\n*\n         ST    R5,PSYSDS           Save address of system data set\n         SH    R5,=Y(DSLDATAL)     Get address of dataset before sys ds\n         ST    R5,BSYSDS           Save it\n         STH   R1,BSDCOUNT         # of datasets before system one\n         LH    R15,DSLCOUNT        Get total dslist count\n         SR    R15,R1              Subtract before-system count\n         STH   R15,PSDCOUNT        # of datasets from system ds onward\n*\n* If the first n data sets in the portion of dslist starting with the\n* first \"system\" data set matches the dsni's, then exit doing nothing.\n*\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\n         CH    R9,PSDCOUNT         If more dsns wanted than allocated\n         BH    DOINSERT_SYS_LOST   then input dsn's don't all match up\n         L     R5,PSYSDS           Point to first \"system\" data set\n         LA    R6,FDBDATA          Point to requested dsnames list\nDOINSERT_SYS_LOOP DS 0H\n         C     R5,DSLEND           If we reached end of dslist\n         BNL   DOINSERT_SYS_LOST   then input dsns don't all match up\n         CLC   FDBDSN,DSLDSN       If data set names don't match\n         BNE   DOINSERT_SYS_LOST   then input dsns don't all match up\n         LA    R5,DSLDATAL(,R5)    Bump\n         LA    R6,FDBDATAL(,R6)    Bump\n         BCT   R9,DOINSERT_SYS_LOOP Loop\n         B     DO_NOTHING          If we made it, all match, do nothing\nDOINSERT_SYS_LOST DS 0H            Otherwise they don't all match...\n*\n* If the last n data set names in the dslist preceding the first\n* \"system\" data set match the dsni's, then exit doing nothing.\n*\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\n         CH    R9,BSDCOUNT         If more dsns wanted than alloc'd\n         BH    DOINSERT_BEF_LOST   then input dsn's don't all match up\n         L     R5,PSYSDS\n         LA    R1,DSLDATAL\n         MH    R1,FDBCOUNT\n         SR    R5,R1               Point to nth-from-system data set\n         LA    R6,FDBDATA          Point to requested dsnames list\nDOINSERT_BEF_LOOP DS 0H\n         C     R5,DSLEND           If we reached end of dslist\n         BNL   DOINSERT_BEF_LOST   then input dsns don't all match up\n         CLC   FDBDSN,DSLDSN       If data set names don't match\n         BNE   DOINSERT_BEF_LOST   then input dsns don't all match up\n         LA    R5,DSLDATAL(,R5)    Bump\n         LA    R6,FDBDATAL(,R6)    Bump\n         BCT   R9,DOINSERT_BEF_LOOP Loop\n         B     DO_NOTHING          If we made it, all match, do nothing\nDOINSERT_BEF_LOST DS 0H            Otherwise they don't all match...\n*\n* For each dsnij found somewhere in the dslist, remove it from dslist.\n*\n         LA    R6,FDBDATA          Point to requested dsnames list\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\nDOINSERT_REMOVEI_LOOP DS 0H        For each requested dsname...\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI          Remove DSNAME from DSLIST\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,DOINSERT_REMOVEI_LOOP\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, up to but not including the\n* first \"system\" data set, allocate that dataset.\n*\n         LA    R5,DSLDATA\n         LH    R9,BSDCOUNT\n         LTR   R9,R9\n         BZ    DOINSERT_MO_BEFORE_END_LOOP\nDOINSERT_MO_BEFORE_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOINSERT_MO_BEFORE_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOINSERT_MO_BEFORE_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOINSERT_MO_BEFORE_LOOP\nDOINSERT_MO_BEFORE_END_LOOP DS 0H\n*\n* For j = 1 thru n, allocate files to dsnij's.  The first allocation\n* was to filei, and the others will be to generated file names.\n* (Note that we come here when filei isn't already allocated.)\n*\nDOINSERT_ALLOCATE_MI DS 0H\n         LA    R6,FDBDATA          Point to first requested dataset.\n         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)\nDOINSERT_MI_LOOP DS 0H\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the dsname\n         LTR   R15,R15             If failure\n         BZ    DOINSERT_MI_CONTINUE then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOINSERT_MI_CONTINUE DS 0H\n         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.\n         BCT   R9,DOINSERT_MI_LOOP\n*\n* For each non-removed dataset in dslist starting from the first\n* \"system\" data set, allocate that data set.\n*\n         L     R5,PSYSDS\n         LH    R9,PSDCOUNT\n         LTR   R9,R9\n         BZ    DOINSERT_MO_AFTER_END_LOOP\nDOINSERT_MO_AFTER_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DOINSERT_MO_AFTER_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDOINSERT_MO_AFTER_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DOINSERT_AFTER_LOOP\nDOINSERT_MO_AFTER_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n         EJECT\nDODELETE DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine does processing when the keyword request is DELETE.    *\n*                                                                     *\n***********************************************************************\n*\n         OI    FLAGS,DELETING      Show we are deleting\n*\n* If a ddname without dsnames was specified, take no action.\n*\n         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested\n         BL    DONE                If none, take no action\n         BH    DODELETE_MULTIPLE_INPUT_DSNS If more than one, go...\n*\n* Only one input dsn specified for this ddname:\n*\n         LA    R6,FDBDATA          Point to first and only input dsn\n*\n* If filei is not allocated, then do nothing and exit.\n*\n         CLC   DSLCOUNT,=H'0'      If there are no datasets\n         BE    DO_NOTHING          then go allocate filei to dsni.\n*\n* Set up the file name and the data set name to be removed therefrom.\n*\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n*\n* Remove all occurrences of input dsn from dslist.\n* If no names were removed, there is no need to reallocate the file.\n*\n         BAL   R14,REMOVEI         Remove DSNAME from DSLIST\n         LTR   R1,R1               If no dsnames were removed\n         BZ    DO_NOTHING          then exit, nothing to be done\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, allocate that dataset.\n* The first allocation will use the specified file name, and others\n* will use a system-generated file name.\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DODELETE_END_LOOP\nDODELETE_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DODELETE_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDODELETE_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DODELETE_LOOP\n*\nDODELETE_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n*\nDODELETE_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested\n*\n* If filei is not allocated, then do nothing and exit.\n*\n         MVC   DDNAME,FDBDDN       Set up ddname\n         MVC   DDNAMEL,FDBDDNL\n         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname\n         BE    DO_NOTHING          then nothing to be done\n*\n* For each dsnij found somewhere in the dslist, remove it from dslist.\n*\n         XR    R2,R2               Clear count of removed dsns\n         LA    R6,FDBDATA          Point to requested dsnames list\n         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)\nDODELETE_REMOVEI_LOOP DS 0H        For each requested dsname...\n         MVC   DSNAME,FDBDSN\n         BAL   R14,REMOVEI         Remove DSNAME from DSLIST\n         NI    FDBFLAGS,255-FDBDELNF Preset dataset-found flag\n         LTR   R1,R1               If requested dataset was not found,\n         BNZ   DODELETE_REMOVEI_NF then...\n         OI    FDBFLAGS,FDBDELNF    indicate so in file-dataset block\nDODELETE_REMOVEI_NF DS 0H\n         AR    R2,R1               Accumulate removed-dsn count\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,DODELETE_REMOVEI_LOOP\n         LTR   R2,R2               If nothing was removed\n         BZ    DO_NOTHING          then leave allocation as is\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For each non-removed dataset in dslist, generate a file name\n* and allocate that file name to the dataset.\n* (There may be none in dslist, so take that into account.)\n*\n         LA    R5,DSLDATA\n         LH    R9,DSLCOUNT\n         LTR   R9,R9\n         BZ    DODELETE_MO_END_LOOP\nDODELETE_MO_LOOP DS 0H\n         TM    DSLFLAGS,DSLREMOV   Skip names that were \"removed\"\n         BO    DODELETE_MO_CONTINUE\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\nDODELETE_MO_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,DODELETE_MO_LOOP\n*\nDODELETE_MO_END_LOOP DS 0H\n         B     DO_CONCATENATION    Go concatenate allocated files.\n         EJECT\nDOSETUP  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine does processing when the keyword request is SETUP.     *\n*                                                                     *\n***********************************************************************\n*\n* If a ddname without dsnames was specified, take no action except for\n* freeing the file.\n*\n         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested\n         BL    UNSETUP             If none, just free the file.\n         BH    DOSETUP_MULTIPLE_INPUT_DSNS If more than one, go...\n*\n* Only one input dsn specified for this ddname:\n*\n         LA    R6,FDBDATA          Point to first and only input dsn\n*\n* If filei is not allocated, then allocate filei to dsni and exit.\n*\n         CLC   DSLCOUNT,=H'0'      If there are no datasets\n         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.\n*\n* Set up the file name and the data set name to be allocated.\n*\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* Allocate filei to dsni.\n*\n         B     SINGLE_ALLOCATE     Go allocate filei to dsni.\n*\nDOSETUP_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested\n*\n* If filei is not allocated, then just allocate the dsns to filei.\n*\n         MVC   DDNAME,FDBDDN       Set up ddname\n         MVC   DDNAMEL,FDBDDNL\n         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname\n         BE    DOSETUP_ALLOCATE_MI then just allocate input dsns.\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n*\n* For j = 1 thru n, allocate files to dsnij's.  The first allocation\n* will be to filei, and the others will be to generated file names.\n* (Note that we come here when filei isn't already allocated.)\n*\nDOSETUP_ALLOCATE_MI DS 0H\n         LA    R6,FDBDATA          Point to first requested dataset.\n         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)\nDOSETUP_MI_LOOP DS 0H\n         MVC   DSNAME,FDBDSN\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS\n         BAL   R14,ALLOC1          Allocate the dsname\n         LTR   R15,R15             If failure\n         BZ    DOSETUP_MI_CONTINUE  then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\nDOSETUP_MI_CONTINUE DS 0H\n         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.\n         BCT   R9,DOSETUP_MI_LOOP\n         B     DO_CONCATENATION    Go concatenate allocated files.\nUNSETUP  DS    0H\n*\n* If filei with no dsni's specified, just free indicated file.\n*\n         MVC   DDNAME,FDBDDN\n         MVC   DDNAMEL,FDBDDNL\n*\n* Unallocate filei.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         OI    FLAGS,DDFREED       Else indicate file's been freed.\n         B     NOTIFY\n         EJECT\nDO_CONCATENATION DS 0H\n*\n* Concatenate filei with the list of generated file names.\n*\n         BAL   R14,CONCAT1         Do concatenation\n         LTR   R15,R15             If failure\n         BNZ   FAILED               then abort.\n         B     NOTIFY              Return.\n         EJECT\nSINGLE_ALLOCATE DS 0H              Allocate one file to one dsn.\n*\n* It is assumed that R6 already points to the correct FDBDATA entry.\n*\n         BCTR  R7,0                Indicate no concatenation wanted\n         MVC   DDNAME,FDBDDN       Set up file name\n         MVC   DDNAMEL,FDBDDNL\n         MVC   DSNAME,FDBDSN       Set up data set name\n         MVC   DSNAMEL,FDBDSNL\n         MVC   UNIT,BLANKS         Volume/unit not known\n         BAL   R14,ALLOC1          Allocate the file to the dataset\n         LTR   R15,R15             If allocation failed\n         BZ    NOTIFY              then\n         OI    FDBFLAGS,FDBERROR    indicate so\n         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset\n         B     NOTIFY              Return with allocation.\n         EJECT\nDO_NOTHING DS 0H                   Exit doing nothing\n         CLI   MSGLEVEL,INFORM     Display messages only for INFORM\n         BH    DO_NOTHING_END\n         LA    R6,FDBDATA\n         LH    R9,FDBCOUNT\n         LTR   R9,R9\n         BZ    DO_NOTHING_END\nDO_NOTHING_LOOP DS 0H\n         BAL   R14,NOTIFY_NOTHING\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,DO_NOTHING_LOOP\nDO_NOTHING_END DS 0H\n         B     DONE\n         EJECT\nNOTIFY   DS    0H\n         OI    FLAGS,DIDSTUFF      Show something has been changed\n         LA    R6,FDBDATA\n         LH    R9,FDBCOUNT\n         LTR   R9,R9\n         BZ    NOTIFY_END\nNOTIFY_LOOP DS 0H\n         TM    FDBFLAGS,FDBDELNF\n         BO    ALLOCATED_NOTHING\n         TM    FDBFLAGS,FDBERROR\n         BO    ALLOCATED_BAD\n         BAL   R14,NOTIFY_GOOD\n         B     ALLOCATED_GOOD_OR_BAD\nALLOCATED_NOTHING DS 0H\n         BAL   R14,NOTIFY_NOTHING\n         B     ALLOCATED_GOOD_OR_BAD\nALLOCATED_BAD DS 0H\n         BAL   R14,NOTIFY_BAD\n******** B     ALLOCATED_GOOD_OR_BAD\nALLOCATED_GOOD_OR_BAD DS 0H\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,NOTIFY_LOOP\nNOTIFY_END DS  0H\n******** B     DONE\n         EJECT\nDONE     DS    0H\n*\n***********************************************************************\n*                                                                     *\n* Allocations finished for this file.  Free DSLIST buffer and return. *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,DSLLEN           Get length of DSLIST buffer\n         FREEMAIN R,LV=(0),A=(R4)  Free the DSLIST buffer\n         L     R14,PROCFDB_R14     Load return register\n         BR    R14                 Return to caller\n         EJECT\nFAILED   DS    0H                  Here if reallocation failed\n*\n         OI    FLAGS,DDFAILED      Indicate failure and recovery coming\n         LA    R6,FDBDATA\n         LH    R9,FDBCOUNT\n         LTR   R9,R9\n         BZ    FAILED_END\nFAILED_LOOP DS 0H\n         BAL   R14,NOTIFY_BAD\n         LA    R6,FDBDATAL(,R6)\n         BCT   R9,FAILED_LOOP\nFAILED_END DS  0H\n******** B     RECOVER\n         EJECT\nRECOVER  DS    0H\n*\n***********************************************************************\n*                                                                     *\n*     Recovery step, executed only if an allocation or concatenation  *\n*     fails.  This attempts to reallocate the original datasets to    *\n*     the specified file name.                                        *\n*                                                                     *\n* Any failure here is a major disaster and should be reported as such *\n*                                                                     *\n***********************************************************************\n*\n* If file has not been unallocated, no recovery is necessary.\n*\n         TM    FLAGS,DDFREED\n         BZ    DONE\n*\n* Restore original dslist (i.e. \"unremove\" any removed dsns).\n*\n         LA    R5,DSLDATA          Point to first data entry\n         LH    R9,DSLCOUNT          Number of times to loop\n         LTR   R9,R9\n         BZ    RECOVER_UNREMOVE_END If none, finished\nRECOVER_UNREMOVE_LOOP DS 0H\n         NI    DSLFLAGS,255-DSLREMOV Unmark dataset as not removed\n         LA    R5,DSLDATAL(,R5)    Bump to next entry\n         BCT   R9,RECOVER_UNREMOVE_LOOP and continue search.\nRECOVER_UNREMOVE_END DS 0H\n         XR    R7,R7               Clear concatenation register\n         MVC   DDNAME,FDBDDN       Set file name to be processed\n         MVC   DDNAMEL,FDBDDNL\n*\n* Unallocate filei if necessary.\n*\n         BAL   R14,FREE1           Unallocate the file.\n         LTR   R15,R15             If failure\n         BNZ   RECOVER_FAILED       then we're really in trouble.\n*\n* If dslist is empty, exit.\n*\n         CLC   DSLCOUNT,=H'0'\n         BE    RECOVER_DONE\n*\n* For each of the datasets in dslist, allocate it.  The first one will\n* be allocated to the file name and the others will get generated ones.\n*\n         LA    R5,DSLDATA          Point to first dslist entry\n         LH    R9,DSLCOUNT         Get count of data set names\n         LTR   R9,R9\n         BZ    RECOVER_END_LOOP\nRECOVER_LOOP DS 0H\n         MVC   DSNAME,DSLDSN\n         MVC   DSNAMEL,DSLDSNL\n         MVC   UNIT,DSLUNAME\n         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname\n         LTR   R15,R15             If failure\n         BNZ   RECOVER_FAILED       then abort.\nRECOVER_CONTINUE DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.\n         BCT   R9,RECOVER_LOOP\nRECOVER_END_LOOP DS 0H\n*\n* Concatenate filei with the list of generated file names.\n*\n         BAL   R14,CONCAT1         Do concatenation\n         LTR   R15,R15             If failure\n         BNZ   RECOVER_FAILED       then abort.\n*\nRECOVER_DONE DS 0H                 Recovery successful.\n         NI    FLAGS,255-DDFREED   Reset damage-done flag.\n         B     DONE\n*\nRECOVER_FAILED DS 0H\n         OI    FLAGS,DISASTER      Indicate we really are in trouble\n         MVC   MSGWA(L'MSG_RECOVER_NG_1),MSG_RECOVER_NG_1\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_RECOVER_NG_DDNAME\n         LA    R1,MSGWA+L'MSG_RECOVER_NG_1+1(R15)\n         MVC   0(L'MSG_RECOVER_NG_2,R1),MSG_RECOVER_NG_2\n         LA    R0,L'MSG_RECOVER_NG_2(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         B     DONE\n*\nMVC_RECOVER_NG_DDNAME MVC MSGWA+L'MSG_RECOVER_NG_1(*-*),FDBDDN\n*\n         EJECT\nNOTIFY_GOOD DS 0H\n         CLI   MSGLEVEL,ACTINFORM  Display messages only for\n         BHR   R14                  INFORM and ACTINFORM\n         ST    R14,NOTIFY_R14\n         MVC   MSGWA(L'MSG_ALLOCED_1),MSG_ALLOCED_1\n         LH    R15,FDBDSNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCED_DSNAME\n         LA    R1,MSGWA+L'MSG_ALLOCED_1+1(R15)\n         TM    FLAGS,DELETING\n         BO    NOTIFY_GOOD_DELETING\n         MVC   0(L'MSG_ALLOCED_2,R1),MSG_ALLOCED_2\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCED_2_DDNAME\n         LA    R1,L'MSG_ALLOCED_2+1(R15,R1)\n         B     NOTIFY_GOOD_AFT_DELETING\nNOTIFY_GOOD_DELETING DS 0H\n         MVC   0(L'MSG_ALLOCED_4,R1),MSG_ALLOCED_4\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCED_4_DDNAME\n         LA    R1,L'MSG_ALLOCED_4+1(R15,R1)\nNOTIFY_GOOD_AFT_DELETING DS 0H\n         MVC   0(L'MSG_ALLOCED_3,R1),MSG_ALLOCED_3\n         LA    R0,L'MSG_ALLOCED_3(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         L     R14,NOTIFY_R14\n         BR    R14\n*\nMVC_ALLOCED_DSNAME MVC MSGWA+L'MSG_ALLOCED_1(*-*),FDBDSN\nMVC_ALLOCED_2_DDNAME MVC L'MSG_ALLOCED_2(*-*,R1),FDBDDN\nMVC_ALLOCED_4_DDNAME MVC L'MSG_ALLOCED_4(*-*,R1),FDBDDN\n*\n         EJECT\nNOTIFY_BAD  DS 0H\n         CLI   MSGLEVEL,FAILINFORM Display messages only for\n         BHR   R14                  INFORM, ACTINFORM, FAILINFORM\n         ST    R14,NOTIFY_R14\n         TM    FLAGS,DELETING\n         BO    NOTIFY_BAD_DELETING\n         MVC   MSGWA(L'MSG_ALLOCNG_1),MSG_ALLOCNG_1\n         LH    R15,FDBDSNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCNG_1_DSNAME\n         LA    R1,MSGWA+L'MSG_ALLOCNG_1+1(R15)\n         B     NOTIFY_BAD_AFT_DELETING\nNOTIFY_BAD_DELETING DS 0H\n         MVC   MSGWA(L'MSG_ALLOCNG_4),MSG_ALLOCNG_4\n         LH    R15,FDBDSNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCNG_4_DSNAME\n         LA    R1,MSGWA+L'MSG_ALLOCNG_4+1(R15)\nNOTIFY_BAD_AFT_DELETING DS 0H\n         TM    FLAGS,DELETING\n         BO    NOTIFY_BAD_DELETING_AGAIN\n         MVC   0(L'MSG_ALLOCNG_2,R1),MSG_ALLOCNG_2\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCNG_2_DDNAME\n         LA    R1,L'MSG_ALLOCNG_2+1(R15,R1)\n         B     NOTIFY_BAD_AFT_DELETING_AGAIN\nNOTIFY_BAD_DELETING_AGAIN DS 0H\n         MVC   0(L'MSG_ALLOCNG_5,R1),MSG_ALLOCNG_5\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_ALLOCNG_5_DDNAME\n         LA    R1,L'MSG_ALLOCNG_5+1(R15,R1)\nNOTIFY_BAD_AFT_DELETING_AGAIN DS 0H\n         MVC   0(L'MSG_ALLOCNG_3,R1),MSG_ALLOCNG_3\n         LA    R0,L'MSG_ALLOCNG_3(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         L     R14,NOTIFY_R14\n         BR    R14\n*\nMVC_ALLOCNG_1_DSNAME MVC MSGWA+L'MSG_ALLOCNG_1(*-*),FDBDSN\nMVC_ALLOCNG_4_DSNAME MVC MSGWA+L'MSG_ALLOCNG_4(*-*),FDBDSN\nMVC_ALLOCNG_2_DDNAME MVC L'MSG_ALLOCNG_2(*-*,R1),FDBDDN\nMVC_ALLOCNG_5_DDNAME MVC L'MSG_ALLOCNG_5(*-*,R1),FDBDDN\n*\n         EJECT\nNOTIFY_NOTHING DS 0H\n         CLI   MSGLEVEL,INFORM     Display messages only for INFORM\n         BHR   R14\n         ST    R14,NOTIFY_R14\n         MVC   MSGWA(L'MSG_NOTHING_1),MSG_NOTHING_1\n         LH    R15,FDBDSNL\n         BCTR  R15,0\n         EX    R15,MVC_NOTHING_DSNAME\n         LA    R1,MSGWA+L'MSG_NOTHING_1+1(R15)\n         TM    FLAGS,DELETING\n         BO    NOTHING_DELETING\n         MVC   0(L'MSG_NOTHING_2,R1),MSG_NOTHING_2\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_NOTHING_2_DDNAME\n         LA    R1,L'MSG_NOTHING_2+1(R15,R1)\n         B     NOTHING_AFT_DELETING\nNOTHING_DELETING DS 0H\n         MVC   0(L'MSG_NOTHING_4,R1),MSG_NOTHING_4\n         LH    R15,FDBDDNL\n         BCTR  R15,0\n         EX    R15,MVC_NOTHING_4_DDNAME\n         LA    R1,L'MSG_NOTHING_4+1(R15,R1)\nNOTHING_AFT_DELETING DS 0H\n         MVC   0(L'MSG_NOTHING_3,R1),MSG_NOTHING_3\n         LA    R0,L'MSG_NOTHING_3(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         L     R14,NOTIFY_R14\n         BR    R14\n*\nMVC_NOTHING_DSNAME MVC MSGWA+L'MSG_NOTHING_1(*-*),FDBDSN\nMVC_NOTHING_2_DDNAME MVC L'MSG_NOTHING_2(*-*,R1),FDBDDN\nMVC_NOTHING_4_DDNAME MVC L'MSG_NOTHING_4(*-*,R1),FDBDDN\n*\n         EJECT\nREMOVEI  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine searches the dslist for entries whose data set name *\n* matches the name in the FDB, and removes them from the dslist.      *\n* It does this by turning on the flag bit that marks an entry removed.*\n* On return R1 contains the number of entries deleted.                *\n* Do not use R2 or R9 in this routine!                                *\n*                                                                     *\n***********************************************************************\n*\n         LA    R5,DSLDATA          Point to first data entry\n         LH    R15,DSLCOUNT        Number of times to loop\n         XR    R1,R1               Clear removed-dsn count\n         LTR   R15,R15\n         BZR   R14                 If none, finished\nREMOVEI_LOOP DS 0H\n         CLC   DSNAME,DSLDSN       If data set name matches\n         BNE   REMOVEI_SKIP        then\n         OI    DSLFLAGS,DSLREMOV    mark dataset as removed\n         LA    R1,1(,R1)            increment removed-dsn count\nREMOVEI_SKIP DS 0H\n         LA    R5,DSLDATAL(,R5)    Bump to next entry\n         BCT   R15,REMOVEI_LOOP    and continue search.\n         BR    R14                 Return to caller\n         EJECT\nALLOC1   DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine allocates the file specified in DDNAME              *\n* to the dataset specified in DSNAME.                                 *\n*                                                                     *\n* Initially the DDNAME is set to the \"major\" DDNAME.  This routine,   *\n* once it successfully allocates a file to that DDNAME, sets the      *\n* DDNAME to blank.  When the DDNAME is blank upon entry, this routine *\n* uses a system-generated file name.                                  *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,ALLOC1_R14      Save return register\n         MVI   S99VERB,S99VRBAL    Set verb code = allocation\n         LA    R1,TUPLALLC         Point to relevant text units\n         ST    R1,S99TXTPP         Set text unit pointers\n         MVI   A9STATUS,X'08'      Set disposition = SHR\n         LTR   R7,R7               If concatenations already started\n         BNP   ALLOC1_USE_PASSED_DDNAME then\n         LA    R1,TUARTDDN          Set text unit to return ddname\n         ST    R1,TUPLALLC+12       Store into text unit parameter list\n         B     ALLOC1_AFTER_PASSED_DDNAME\nALLOC1_USE_PASSED_DDNAME  DS 0H    Else...\n         MVC   A9DDNLEN,DDNAMEL     Move ddname length to text unit\n         MVC   A9DDNAME,DDNAME      Move ddname to text unit\n         LA    R1,TUADDNAM          Set text unit to use given ddname\n         ST    R1,TUPLALLC+12       Store into text unit parameter list\nALLOC1_AFTER_PASSED_DDNAME DS 0H\n         MVC   A9DSNLEN,DSNAMEL    Move ddname length to text unit\n         MVC   A9DSNAME,DSNAME     Move ddname to text unit\n         CLC   UNIT,BLANKS         If unit name given,\n         BE    ALLOC1_UNIT_BLANK   then...\n         MVC   A9UNIT,UNIT          Move unit name to text unit\n         NI    TUPLALLC_VL_NO_UNIT,X'7F'  Include unit name\n         OI    TUPLALLC_VL,X'80'     by setting the VL bit accordingly\n         B     ALLOC1_UNIT_DONE    else...\nALLOC1_UNIT_BLANK DS 0H             Unit name is blank...\n         OI    TUPLALLC_VL_NO_UNIT,X'80'  Omit unit name\n         NI    TUPLALLC_VL,X'7F'     by setting the VL bit accordingly\nALLOC1_UNIT_DONE        DS 0H\n*\n         LA    R1,S99RBP           Point to request block pointer\nA1SVC99  DYNALLOC                  Call SVC 99\n         LTR   R15,R15             If allocation failed,\n         BNZ   ALLOC1_FAILED       then indicate so.\n         LTR   R7,R7               Concatenations?\n         BM    ALLOC1_RETURN       If we don't want 'em, skip it.\n         BP    ALLOC1_CONT_CONCAT  If we started, add more.\n******** BZ    ALLOC1_START_CONCAT Else start 'em.\nALLOC1_START_CONCAT DS 0H          Set up first file to be concat'd\n         MVC   C9STUFF+0(2),DDNAMEL Set concat file #1 length\n         MVC   C9STUFF+2(8),DDNAME  Set concat file #1 name\n         LA    R15,1\n         STH   R15,C9NUMBER        Initialize concat file counter\n         LA    R7,C9STUFF+2        Initialize concat file pointer\n         AH    R7,DDNAMEL          Bump to next concat file place\n         B     ALLOC1_RETURN\nALLOC1_CONT_CONCAT DS 0H\n         LA    R15,1               Increment number of files to concat\n         AH    R15,C9NUMBER\n         CH    R15,=H'&CATLIM'     We can't handle more than this many\n         BH    ALLOC1_TOO_MANY     because we didn't allow that much rm\n         STH   R15,C9NUMBER\n         LH    R15,A9RETDDL        Get length of returned ddname\n         STH   R15,0(,R7)          Store into concatenation parm\n         BCTR  R15,0               Reduce for execute\n         EX    R15,ALLOC1_MVC_RETURNED_DDNAME Move ret'd DD to cc parm\n         LA    R7,2+1(R15,R7)      Bump to next concat file place\nALLOC1_RETURN DS 0H\n         XR    R15,R15             Set success return code\n         L     R14,ALLOC1_R14      Restore return register\n         BR    R14                 Return to caller\nALLOC1_FAILED DS 0H                Allocation failed\n         BAL   R14,DAIRFAIL        Report allocation error\n         LA    R15,12              Set error return code\n         L     R14,ALLOC1_R14      Restore return register\n         BR    R14\nALLOC1_TOO_MANY DS 0H              Too many files to concatenate\n         MVC   MSGWA(L'MSG_TOO_MANY_1),MSG_TOO_MANY_1\n         LH    R15,DDNAMEL\n         BCTR  R15,0\n         EX    R15,MVC_TOO_MANY_DDNAME\n         LA    R1,MSGWA+L'MSG_TOO_MANY_1+1(R15)\n         MVC   0(L'MSG_TOO_MANY_2,R1),MSG_TOO_MANY_2\n         LA    R0,L'MSG_TOO_MANY_2(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE         Report allocation error\n         LA    R15,16              Set error return code\n         L     R14,ALLOC1_R14      Restore return register\n         BR    R14\n*\nALLOC1_MVC_RETURNED_DDNAME MVC 2(*-*,R7),A9RETDDN  Executed\nMVC_TOO_MANY_DDNAME MVC MSGWA+L'MSG_TOO_MANY_1(*-*),DDNAME\n*\n         EJECT\nFREE1    DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine unallocates the file specified in DDNAME.           *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,FREE1_R14       Save return register\n         MVI   S99VERB,S99VRBUN    Set verb code = unallocation\n         LA    R1,TUPLUNAL         Point to relevant text units\n         ST    R1,S99TXTPP         Set text unit pointers\n         MVC   U9DDNLEN,DDNAMEL    Move ddname length to text unit\n         MVC   U9DDNAME,DDNAME     Move ddname to text unit\n         LA    R1,S99RBP           Point to request block pointer\nU1SVC99  DYNALLOC                  Call SVC 99\n         LTR   R15,R15             If unallocation went OK,\n         BZ    FREE1_RETURN        then just return.\n*\n* If the unallocation error is \"file not freed, is not allocated\",\n* then ignore the error.\n*\n         CH    R15,=H'4'           If return code is 4\n         BNE   FREE1_NOT_NOT_ALLOCATED and\n         CLC   S99ERROR(2),=X'0438'     error code is \"file not allocd\"\n         BE    FREE1_RETURN              then return as if free was OK\nFREE1_NOT_NOT_ALLOCATED DS 0H\n         BAL   R14,DAIRFAIL        Else report unallocation error\n         LA    R15,12              Set error return code\n         L     R14,FREE1_R14       Restore return register\n         BR    R14\nFREE1_RETURN DS 0H\n         XR    R15,R15             Set success return code\n         L     R14,FREE1_R14       Restore return register\n         BR    R14                 Return to caller\n         EJECT\nCONCAT1  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This subroutine concatenates files.                                 *\n* If there is only one file to be \"concatenated\", this routine does   *\n* not do anything, since the file is already allocated as desired.    *\n*                                                                     *\n***********************************************************************\n*\n         XR    R15,R15             Preset return code\n         CLC   C9NUMBER,=H'1'      If zero or one file to concatenate\n         BNHR  R14                 then return doing nothing.  Else...\n         ST    R14,CONCAT1_R14     Save return register\n         MVI   S99VERB,S99VRBCC    Set verb code = concatenation\n         LA    R1,TUPLCCAT         Point to relevant text units\n         ST    R1,S99TXTPP         Set text unit pointers\n         LA    R1,S99RBP           Point to request block pointer\nC1SVC99  DYNALLOC ,                Call SVC 99\n         LTR   R15,R15             If concatenation went OK,\n         BZ    CONCAT1_RETURN      then just return.\n         BAL   R14,DAIRFAIL        Else report concatenation error\n         LA    R15,12              Set error return code\n         L     R14,CONCAT1_R14     Restore return register\n         BR    R14\nCONCAT1_RETURN DS 0H\n         XR    R15,R15             Set success return code\n         L     R14,CONCAT1_R14     Restore return register\n         BR    R14                 Return to caller\n         EJECT\nERROR_BLANK_DSNAME DS 0H\n*\n         MVC   MSGWA(L'MSG_BLANK_DSNAME),MSG_BLANK_DSNAME\n         MVC   MSGWA+L'MSG_BLANK_DSNAME(8),FDBDDN\n         LA    R0,L'MSG_BLANK_DSNAME+8\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         B     ERROR_RETURN\n*\nERROR_ALLOC_MEMBER DS 0H\n*\n         MVC   MSGWA(L'MSG_ALLOC_MEMBER),MSG_ALLOC_MEMBER\n         MVC   MSGWA+L'MSG_ALLOC_MEMBER(8),FDBDDN\n         LH    R1,FDBDDNL\n         LA    R1,MSGWA+L'MSG_ALLOC_MEMBER(R1)\n         B     FILL_IN_ERROR_DSNAME\n*\nERROR_MULTIPLE_VOL DS 0H\n*\n         MVC   MSGWA(L'MSG_MULTIPLE_VOL),MSG_MULTIPLE_VOL\n         MVC   MSGWA+L'MSG_MULTIPLE_VOL(8),FDBDDN\n         LH    R1,FDBDDNL\n         LA    R1,MSGWA+L'MSG_MULTIPLE_VOL(R1)\n         B     FILL_IN_ERROR_DSNAME\n*\nERROR_DISP_NOT_SHR DS 0H\n*\n         MVC   MSGWA(L'MSG_DISP_NOT_SHR),MSG_DISP_NOT_SHR\n         MVC   MSGWA+L'MSG_DISP_NOT_SHR(8),FDBDDN\n         LH    R1,FDBDDNL\n         LA    R1,MSGWA+L'MSG_DISP_NOT_SHR(R1)\n         B     FILL_IN_ERROR_DSNAME\n*\nERROR_BAD_UCB_ADDR DS 0H\n*\n         MVC   MSGWA(L'MSG_BAD_UCB_ADDR),MSG_BAD_UCB_ADDR\n         MVC   MSGWA+L'MSG_BAD_UCB_ADDR(8),FDBDDN\n         LH    R1,FDBDDNL\n         LA    R1,MSGWA+L'MSG_BAD_UCB_ADDR(R1)\n         B     FILL_IN_ERROR_DSNAME\n*\nFILL_IN_ERROR_DSNAME DS 0H\n         MVC   0(2,R1),=C': '\n         MVC   2(44,R1),DSLDSN\n         LA    R1,2(,R1)\n         AH    R1,DSLDSNL\n         USING INFMJFCB,R7\n         CLC   JFCBELNM,BLANKS\n         BE    FIEDNM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCBELNM\n         DROP  R7\n         LA    R1,8(,R1)\n         LA    R0,8\nFIEDLOOP DS 0H\n         CLI   0(R1),C' '\n         BNE   FIEDEND\n         BCTR  R1,0\n         BCT   R0,FIEDLOOP\nFIEDEND  DS 0H\n         MVI   1(R1),C')'\n         LA    R1,2(,R1)\nFIEDNM   DS    0H\n         LR    R0,R1\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n******** B     ERROR_RETURN\n*\nERROR_RETURN DS 0H\n*\n         OI    FLAGS,DDFAILED      Indicate file processing aborted\n         MVC   MSGWA(L'MSG_FILE_LOSSAGE),MSG_FILE_LOSSAGE\n         MVC   MSGWA+L'MSG_FILE_LOSSAGE(8),FDBDDN\n         LA    R0,L'MSG_FILE_LOSSAGE+8\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         L     R14,PROCFDB_R14     Load return register\n         BR    R14                 Return to caller\n         EJECT\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the tso user using the tso        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* If R1 is zero, the message has already been built in the workarea   *\n* MSGWA.  The message is assumed to begin with a message ID unless    *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTLINE_R14     Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVC_PUT         Else move message to work area\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\nPUTLINE_RETRY DS 0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         MVC   PUTWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1\n         MVC   PUTWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE\n         MVC   PUTWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X\n               ,MSG_PUTLINE_FAILURE2\n         TPUT  PUTWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTLINE_R14     Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTLINE_RETRY\n*\nMVC_PUT  MVC   MSGWA(*-*),0(R1)    Executed\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* IKJPARS verify exit for file(dsn dsn ...) keyword/value pairs       *\n*                                                                     *\n* See TSO Extensions Programming Services, p. 5-69, for how to code   *\n* verify exit routines associated with the IKJUNFLD macro.  This is   *\n* used to process keywords whose names aren't known until run time.   *\n* The file names used by XALCMOD, file1(dsn1 dsn2) file3(dsn4), are   *\n* a good example of this.                                             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* On entry R1 -> the verify exit parameter list, mapped by the        *\n* IKJVEPL macro.  This contains in turn a pointer to the PPE          *\n* (parse parameter element) that describes the unidentified keyword   *\n* the file name, in our case), mapped by the IKJPPE macro.            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*       VEPL     DSECT                                                *\n*       VEPLID   DS  CL4                IDENTIFIER                    *\n*       VEPLVERS DS  FL2                VERSION NUMBER                *\n*       VEPLLEN  DS  FL2                LENGTH OF THE VEPL            *\n*       VEPLPPE  DS  F                  PTR TO PPE                    *\n*       VEPLWRKA DS  F                  PTR TO USER SUPPLIED WORKAREA *\n*       VEPLMSG1 DS  F                  PTR TO 1ST LEVEL MSG INSERT   *\n*       VEPLM1LN DS  H                  LENGTH OF 1ST LEVEL INSERT    *\n*       VEPLRSV1 DS  CL2                RESERVED                      *\n*       VEPLMSG2 DS  F                  PTR TO SECOND LEVEL MSG       *\n*       VEPLM2LN DS  H                  LENGTH OF SECOND LEVEL MSG    *\n*       VEPLRSV2 DS  CL2                RESERVED                      *\n*       VEPLCVER EQU  1                 CURRENT VERSION NUMBER        *\n*                                                                     *\n********************************************************************* *\n*                                                                     *\n*       PPE      DSECT                                                *\n*       PPEID    DS  CL4            IDENTIFIER                        *\n*       PPEVERS  DS  FL2            VERSION NUMBER                    *\n*       PPELEN   DS  FL2            LENGTH OF THE PPE                 *\n*       PPEOPER  DS  F              PTR TO THE OPERAND                *\n*       PPEVEXIT DS  A              ADDRESS OF THE VERIFY EXIT        *\n*       PPEOPLEN DS  H              LENGTH OF THE OPERAND             *\n*       PPEFLAGS DS  CL1            FLAG BYTE                         *\n*       PPELST   EQU X'80'          CURRENT OPERAND IS IN A LIST      *\n*       PPENDLST EQU X'40'          LAST OPERAND WAS LAST IN LIST     *\n*       PPENDOP  EQU X'20'          LAST OPERAND WAS THE LAST ONE     *\n*       PPENWLST EQU X'10'          BEGIN A NEW SUBLIST               *\n*       PPERSVD2 DS  CL1            RESERVED                          *\n*       PPECVER  EQU 1              CURRENT VERSION NUMBER            *\n*                                                                     *\n***********************************************************************\n*\nVFYEXIT  DS    0H\n*\n         STM   R14,R12,12(R13)     Save registers\n         LR    R9,R1               Get address of VEPL\n         USING VEPL,R9\n         L     R7,VEPLPPE          Get address of PPE describing file\n         USING PPE,R7\n         L     R10,VEPLWRKA        Get address of our workarea (DATD)\n         LM    R11,R12,MYBASES     Get addressability\n         LA    R14,SAVE2           Chain to new save area\n         ST    R13,4(,R14)\n         ST    R14,8(,R13)\n         LR    R13,R14\n*\n* If we've already gone through a list, then something is wrong.\n*\n         TM    FLAGS,DONEWVFY      If a list of subfields was done once\n         BO    DUPLICATE_KEYWORDS  then error - duplicate keywords\n*\n* If a list of suboperands was specified, reject the list.\n*\n         TM    PPEFLAGS,PPELST     If in a list of operands\n         BO    VFYLSTNG            then error\n*\n* If this is the \"no-more-keywords\" call, process accordingly.\n*\n         XR    R15,R15             Set return code to zero\n         TM    PPEFLAGS,PPENDOP    If previous operand was the last\n         BNO   VFYNL               then\n         OI    FLAGS,DONEWVFY       indicate done with verify\n         B     VFYRET               and return.\n*\nVFYNL    DS    0H                  Else there's a keyword to process...\n*\n         LH    R2,PPEOPLEN         Get length of file keyword\n         LTR   R2,R2\n         BZ    VFYLSTNG            If ddname missing, assume syntax bug\n         CH    R2,=H'8'            Cannot be longer than 8 character\n         BH    DDNAME_INVALID\n         L     R1,PPEOPER          Get address of ddname\n         CLI   0(R1),X'F0'         First character cannot be numeric\n         BNL   DDNAME_INVALID      (PARSE flags other bad characters)\n*\n         LA    R2,FDBL             Get size of a file-dataset block\n         GETMAIN R,LV=(R2)\n         ICM   R3,R15,LASTFDB      Get address of current FDB\n         BNZ   GOTFDBL             If zero (no FDB's yet), then ...\n         ST    R1,FRSTFDB          Store pointer\n         B     AFTFDBL\nGOTFDBL  DS    0H\n         ST    R1,FDBNEXT\nAFTFDBL  DS    0H\n         ST    R1,LASTFDB\n         LR    R3,R1\n         XC    FDBNEXT,FDBNEXT     Clear chain pointer\n         ST    R2,FDBLEN           Save length of this FDB\n         XC    FDBCOUNT,FDBCOUNT   Set number of dsnames to zero\n         MVI   FDBDDN,C' '         Clear ddname to blanks\n         MVC   FDBDDN+1(7),FDBDDN\n         LA    R15,FDBDATA         Initialize offset of dsnames\n         ST    R15,FDBOFF\n         L     R1,PPEOPER          Get address of file keyword\n         LH    R2,PPEOPLEN         Get length of file keyword\n         STH   R2,FDBDDNL          Store length of file\n         BCTR  R2,0                Reduce length for execute\n         EX    R2,MVC_FDBDDN       Move file keyword to FDB\n         XR    R15,R15             Set return code to zero\n*\nVFYRET   DS    0H\n         L     R13,4(,R13)         Reload save area pointer\n         L     R14,12(,R13)        Restore registers\n         LM    R0,R12,20(R13)      Restore registers\n         BR    R14                 Return to caller\n*\nDDNAME_INVALID DS 0H\n*        LA    R1,MSG_DDNAME_NG\n*        LA    R0,L'MSG_DDNAME_NG\n*        BAL   R14,PUTLINE\n*        LA    R15,8\n         LA    R15,12              Let PARSE say \"invalid keyword\"\n         B     VFYRET\n*\nVFYLSTNG DS    0H                  List is no good\n         LA    R1,MSG_LIST_NG\n         LA    R0,L'MSG_LIST_NG\n         BAL   R14,PUTLINE\n         LA    R15,16              Abort the parse - no way to reenter\n         B     VFYRET\n*\nDUPLICATE_KEYWORDS DS 0H           More than one of FRONT/BACK/etc.\n         LA    R1,MSG_DUP_KEYS\n         LA    R0,L'MSG_DUP_KEYS\n         BAL   R14,PUTLINE\n         LA    R15,16              Abort the parse - no way to reenter\n         B     VFYRET\n*\nMVC_FDBDDN MVC FDBDDN(*-*),0(R1)   Executed\n*\n         DROP  R9,R7\n         EJECT\n*\nDSNEXIT  DS    0H                  IKJPARSE validity check exit\n*\n***********************************************************************\n*                                                                     *\n* This exit gets control to process each data set name encountered    *\n* within an unidentified keyword's subfield.  It must be sensitive to *\n* which file-dataset block is current.                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* See TSO Extensions Programming Services, p. 5-67, for how to code   *\n* validity check exit routines.                                       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* On entry R1 -> the following parameter list:                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* +0    PDEADR   DS  F           Address of PDE for this operand      *\n* +4    USERWORD DS  F           Address of user work area            *\n* +8    VALMSG   DS  F           Address of 2nd lvl msg, initially 0  *\n*                                                                     *\n***********************************************************************\n*\n         STM   R14,R12,12(R13)     Save registers\n         L     R9,0(,R1)           R9->PDE\n         L     R10,4(,R1)          Get address of our work area\n         LM    R11,R12,MYBASES     Get addressability\n         LA    R14,SAVE2           Chain to new save area\n         ST    R13,4(,R14)\n         ST    R14,8(,R13)\n         LR    R13,R14\n*\n         TM    14(R9),X'80'        If a member name was specified\n         BO    MEMBER_NAME_NOT_ALLOWED then error\n         L     R3,LASTFDB\n         LH    R2,FDBCOUNT         Get count of data set names so far\n         LA    R2,1(,R2)           Increment count\n         CH    R2,=H'&CATLIM'\n         BH    TOO_MANY_DSNS_PER_FILE\n         STH   R2,FDBCOUNT\n         L     R6,FDBOFF           Get offset of where to put dsn\n         MVC   FDBDSN,BLANKS\n         L     R7,0(,R9)           Get address of the dsname\n         LH    R2,4(,R9)           Get length of the dsname\n         STH   R2,FDBDSNL          Store dataset name length\n         BCTR  R2,0\n         EX    R2,MVC_VAL_DSN      Move PDE dsname to FDB dsname\n         MVI   FDBFLAGS,X'00'      Clear flags\n         LA    R6,FDBDATAL(,R6)\n         ST    R6,FDBOFF           Increment offset\n******** B     VALRET0             Return OK\n*\nVALRET0  DS    0H\n         XR    R15,R15\nVALRET   DS    0H\n         L     R13,4(,R13)         Reload save area pointer\n         L     R14,12(,R13)        Restore registers\n         LM    R0,R12,20(R13)      Restore registers\n         BR    R14                 Return to caller\n*\nMEMBER_NAME_NOT_ALLOWED DS 0H\n         LA    R1,MSG_MEMBER_NG\n         LA    R0,L'MSG_MEMBER_NG\n         MVC   MSGWA(L'MSG_MEMBER_NG),MSG_MEMBER_NG\n         LH    R2,4(,R9)\n         LTR   R2,R2\n         BZ    MNANODS\n         L     R15,0(,R9)\n         BCTR  R2,0\n         EX    R2,MNAMVCD\n         LA    R2,1(,R2)\nMNANODS  DS    0H\n         LA    R1,MSGWA+L'MSG_MEMBER_NG(R2)\n         MVI   0(R1),C'('\n         L     R15,8(,R9)\n         LH    R2,12(,R9)\n         BCTR  R2,0\n         EX    R2,MNAMVCM\n         LA    R1,1(R2,R1)\n         MVI   1(R1),C')'\n         LA    R0,2(,R1)\n         LA    R1,MSGWA\n         SR    R0,R1\n         XR    R1,R1\n         BAL   R14,PUTLINE\n         LA    R15,8\n         B     VALRET\n*\nMNAMVCD  MVC   MSGWA+L'MSG_MEMBER_NG(*-*),0(R15)\nMNAMVCM  MVC   1(*-*,R1),0(R15)\n*\nTOO_MANY_DSNS_PER_FILE DS 0H\n         MVC   VFYWORK+00(L'MSG_TMDPF1),MSG_TMDPF1\n         MVC   VFYWORK+L'MSG_TMDPF1(8),FDBDDN\n         LA    R1,VFYWORK\n         LA    R0,L'MSG_TMDPF1+8\n         BAL   R14,PUTLINE\n         LA    R15,12\n         B     VALRET\n*\nMVC_VAL_DSN MVC FDBDSN(*-*),0(R7)  Executed\n*\n         EJECT\nDAIRFAIL DS    0H                  Display DYNALLOC failure message\n*\n***********************************************************************\n*                                                                     *\n* If DYNALLOC request failed, call DAIRFAIL to display message.       *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,DAIRFAIL_R14    Save return register\n         ST    R15,DYNARC          Store return code from SVC99\n         LA    R14,S99RB           +00->address of SVC99RB\n         LA    R15,DYNARC          +04->address of return code\n         LA    R0,=F'0'            +08->address of IKJEFF02 not present\n         LA    R1,=X'0032'         +0C->request for msg using PUTLINE\n         L     R2,CPPLADDR         +10->address of CPPL for PUTLINE\n         STM   R14,R2,DFPARMS      Set up parameter list for DAIRFAIL\n         XR    R0,R0               +14=zeroes\n         ST    R0,DFPARMS+20       Set up parameter list for DAIRFAIL\n         LA    R1,DFPARMS          Address DAIRFAIL parameter list\n         LINK  EP=IKJEFF18         Call DAIRFAIL service routine\n         LTR   R15,R15             If DAIRFAIL failed,\n         BZ    DAIRFAIL_OK         then...\n         LA    R1,MSG_DAIRFAIL_MSG\n         LA    R0,L'MSG_DAIRFAIL_MSG\n         BAL   R14,PUTLINE         Display failure message\nDAIRFAIL_OK DS 0H\n         L     R14,DAIRFAIL_R14    Restore return register\n         BR    R14\n         EJECT\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n*\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\nBLANKS   DC    CL44' '\n*\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n*\nMSG_TMDPF1       DC C'XALCMOD001 More than &CATLIM data sets specified X\n               for file '\nMSG_MEMBER_NG    DC C'XALCMOD002 Member name not allowed, '\nMSG_LIST_NG      DC C'XALCMOD003 Invalid syntax: nested list or extra pX\n               arentheses found'\nMSG_DUP_KEYS     DC C'XALCMOD003 Invalid syntax: duplicate or conflictiX\n               ng keyword options'\n*SG_DDNAME_NG    DC C'XALCMOD003 Invalid file name syntax'\nMSG_FILE_LOSSAGE DC C'XALCMOD004 No processing done for file '\nMSG_BLANK_DSNAME DC C'XALCMOD005 Unnamed data set allocated to file '\nMSG_ALLOC_MEMBER DC C'XALCMOD006 Data set with member allocated to '\nMSG_MULTIPLE_VOL DC C'XALCMOD007 Multivolume data set allocated to '\nMSG_DISP_NOT_SHR DC C'XALCMOD008 Data set with DISP OLD allocated to '\nMSG_BAD_UCB_ADDR DC C'XALCMOD009 Data set not on DASD allocated to '\n*\nMSG_NOTHING_1 DC C'XALCMOD010 '\nMSG_NOTHING_2 DC C' already allocated to file '\nMSG_NOTHING_4 DC C' already absent from file '\nMSG_NOTHING_3 DC C'.'\n*\nMSG_ALLOCED_1 DC C'XALCMOD011 '\nMSG_ALLOCED_2 DC C' allocation added to file '\nMSG_ALLOCED_4 DC C' allocation removed from file '\nMSG_ALLOCED_3 DC C'.'\n*\nMSG_ALLOCNG_1 DC C'XALCMOD012 Unable to allocate '\nMSG_ALLOCNG_4 DC C'XALCMOD012 Unable to remove '\nMSG_ALLOCNG_2 DC C' to file '\nMSG_ALLOCNG_5 DC C' from file '\nMSG_ALLOCNG_3 DC C'.'\n*\nMSG_RECOVER_NG_1 DC C'XALCMOD013 Unable to recover allocation of file '\nMSG_RECOVER_NG_2 DC C'.'\n*\nMSG_TOO_MANY_1 DC C'XALCMOD014 Attempt to allocate more than &CATLIM daX\n               ta sets to file '\nMSG_TOO_MANY_2 DC C'.'\n*\nMSG_STACK_ERROR  DC C'XALCMOD015 STACK service routine failure'\nMSG_DAIRFAIL_MSG DC C'XALCMOD016 DAIRFAIL error, unable to show why dynX\n               amic allocation request failed.'\n*\nMSG_PUTLINE_FAILURE1 DC C'*** XALCMOD: PUTLINE error code '\nMSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'\n*\n         EJECT\n         LTORG\n*\n         DROP  R12\n         EJECT\n***********************************************************************\n* PARSE CONTROL BLOCKS CSECT                                          *\n***********************************************************************\n*\nXALCMPCL IKJPARM DSECT=PDL\nXALCMPCL AMODE 31\nXALCMPCL RMODE ANY\n*\n* Damn fool aliases don't work.  Maybe the presence of IKJUNFLD\n* introduces new IKJPARS bugs.  Anyhow, I'm not using them unless\n* they work - trying to keep parse complexity down a bit.\n*\nPWHAT    IKJKEYWD\n         IKJNAME 'FRONT',SUBFLD=ALSUBF     ALIAS=('F')\n         IKJNAME 'BACK',SUBFLD=ALSUBF\n         IKJNAME 'INSERT',SUBFLD=ALSUBF    ALIAS=('I','IN')\n         IKJNAME 'DELETE',SUBFLD=ALSUBF\n         IKJNAME 'SETUP',SUBFLD=ALSUBF\n*\nPINFORM  IKJKEYWD\n         IKJNAME 'INFORM'\n         IKJNAME 'ACTINFORM'\n         IKJNAME 'FAILINFORM'\n         IKJNAME 'NOINFORM'\nINFORM     EQU 1\nACTINFORM  EQU 2\nFAILINFORM EQU 3\nNOINFORM   EQU 4\n*\nALSUBF   IKJSUBF\n*\n* The following handles all operands of the form file(dsn dsn dsn).\n*\n         IKJUNFLD VERIFCK=VFYEXIT,SUBFLD=PSUBF\n*\nPSUBF    IKJSUBF\nPDSN     IKJPOSIT DSNAME,LIST,USID,VALIDCK=DSNEXIT\n*\n         IKJENDP\n*\n*\nXALCMOD  CSECT\n*\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n*\nDATD     DSECT ,                   Dynamically acquired work area\n*\nSAVEAREA DS    18F                 OS save area\nSAVE2    DS    18F                 Save area for PARSE exit routines\nDOUBLE   DS    D                   Conversion work area\nPROCFDB_R14  DS F                  Return register save\nPUTLINE_R14  DS F                  Return register save\nREMOVEI_R14  DS F                  Return register save\nNOTIFY_R14   DS F                  Return register save\nALLOC1_R14   DS F                  Return register save\nFREE1_R14    DS F                  Return register save\nCONCAT1_R14  DS F                  Return register save\nDAIRFAIL_R14 DS F                  Return register save\nFRONT14  DS    F                   Return register save\nBACK14   DS    F                   Return register save\nINSERT14 DS    F                   Return register save\nDELETE14 DS    F                   Return register save\nFRSTFDB  DS    A                   Pointer to chain of file-dsn blocks\nLASTFDB  DS    A                   Pointer to last file-dsn block\nMYBASES  DS    2A                  Base regs for IKJPARS exit routines\nCPPLADDR DS    A                   Address of CPPL\nPSYSDS   DS    A                   Ptr to first system DS    for INSERT\nBSYSDS   DS    A                   Ptr to last pre-system DS for INSERT\nBSDCOUNT DS    H                   # of DS before system DS  for INSERT\nPSDCOUNT DS    H                   # of DS from system DS on for INSERT\nDYNARC   DS    F                   SVC 99 return code\nDFPARMS  DS    6A                  DAIRFAIL parameter list\n*\nDDNAMEL  DS    H                   Length of file name being processed\nDDNAME   DS    CL8                 File name being processed\nDSNAMEL  DS    H                   Length of dsname being processed\nDSNAME   DS    CL44                Data set name being processed\nVOLSER   DS    CL6                 Volume serial\nUNIT     DS    CL4                 Unit name\nFLAGS    DS    X                   Flags\nDDFREED  EQU   B'10000000'          1 = file has been unallocated\nDELETING EQU   B'01000000'          1 = deleting, 0 = allocating\nDIDSTUFF EQU   B'00100000'          1 = a reallocation has been done\nDSNSKIPD EQU   B'00010000'          1 = skipped one but realloc done\nDDFAILED EQU   B'00001000'          1 = free/alc failed, recover alloc\nDISASTER EQU   B'00000100'          1 = recovery failed, alloc now bad\nDONEWVFY EQU   B'00000010'          1 = verify exit processed all names\n*        EQU   B'00000001'          Reserved\n*\nWHAT     DS    X                   FRONT, BACK, INSERT, DELETE, SETUP\nFRONT    EQU   1\nBACK     EQU   2\nINSERT   EQU   3\nDELETE   EQU   4\nSETUP    EQU   5\n*\nMSGLEVEL DS    X                   Value of INFORM/etc.\n*\nECB      DS    F                   ECB for TSO routines\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL256               PUTLINE message work area\nPUTWA    DS    CL256               PUTLINE message work area\n*\nVFYWORK  DS    CL80                Verify exit work area\n*\nFLUSH    STACK MF=L,DELETE=ALL\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\nPPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS\n*\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n*\n***********************************************************************\n*                                                                     *\n* DYNAMIC ALLOCATION PARAMETER LISTS                                  *\n*                                                                     *\n* (with apologies to 'SYS1.MACLIB(IEFZB4D0)' and friends)             *\n*                                                                     *\n* Tough on IBM.  If they want me to use their macro, let them         *\n* provide a DSECT=NO version.                                         *\n*                                                                     *\n***********************************************************************\n*\nS99RBP   DS    0D                  SVC 99 input request block\n*\nS99RBPTR DS    A                   Request block pointer\nS99RB    DS    0D                  Request block\nS99RBLN  DC    YL1(20)             Length of request block\nS99VERB  DS    YL1                 Verb code\nS99VRBAL EQU   X'01'                Allocation\nS99VRBUN EQU   X'02'                Unallocation\nS99VRBCC EQU   X'03'                Concatenation\nS99VRBDC EQU   X'04'                Deconcatenation\nS99VRBRI EQU   X'05'                Remove in-use\nS99VRBDN EQU   X'06'                DDNAME allocation\nS99VRBIN EQU   X'07'                Information retrieval\nS99FLG11 DS    XL1                 First flags byte\nS99ONCNV EQU   X'80'               Don't use non-convertible allocation\nS99NOCNV EQU   X'40'               Don't use existing allocation\nS99FLG12 DS    XL1                 Second flags byte\nS99ERROR DS    XL2                 Error reason code\nS99INFO  DS    XL2                 Information reason code\nS99TXTPP DS    A                   Pointer to list of text units\n         DS    F                   Reserved\n         DS    4XL1                Flags for authorized functions\nS99RBEND EQU   *                   End marker\n*\n*\n* SVC 99 text unit pointer list for allocation functions\n*\nTUPLALLC DS    0F                  Allocate dsname\n         DC    A(TUADSNAM)\n         DC    A(TUASTATS)\n         DC    A(TUAPERMA)\n         DS    A TUADDNAM or TUARTDDN, depending on call\nTUPLALLC_VL_NO_UNIT EQU *-4\n         DC    A(TUAUNIT)\nTUPLALLC_VL EQU *-4\n*\n* SVC 99 text unit for allocation of a dsname\n*\nTUADSNAM DS    0H\n         DC    Y(DALDSNAM)         Key\n         DC    H'1'                Number\nA9DSNLEN DS    H                   Length of dsname\nA9DSNAME DS    CL44                Dsname\n*\n* SVC 99 text unit for specification of a ddname\n*\nTUADDNAM DS    0H\n         DC    Y(DALDDNAM)         Key\n         DC    H'1'                Number\nA9DDNLEN DS    H                   Length of ddname\nA9DDNAME DS    CL8                 Ddname\n*\n* SVC 99 text unit for data set status\n*\nTUASTATS DS    0H\n         DC    Y(DALSTATS)         Key\n         DC    H'1'                Number\n         DC    H'1'                Length\nA9STATUS DS    XL1                 Data set status\n*\n* SVC 99 text unit for volume serial\n*\n*UAVLSER DS    0H\n*        DC    Y(DALVLSER)         Key\n*        DC    H'1'                Number\n*        DC    H'6'                Length\n*9VOLSER DS    CL6                 Volume serial\n*\n* SVC 99 text unit for unit specification\n*\nTUAUNIT  DS    0H\n         DC    Y(DALUNIT)          Key\n         DC    H'1'                Number\n         DC    H'3'                Length\nA9UNIT   DS    CL6                 Unit name\n*\n* SVC 99 text unit for permanently allocated attribute\n*\nTUAPERMA DS    0H\n         DC    Y(DALPERMA)         Key\n         DC    H'0'                Number\n*\n* SVC 99 text unit to return ddname\n*\nTUARTDDN DS    0H\n         DC    Y(DALRTDDN)         Key\n         DC    H'1'                Number\nA9RETDDL DC    H'8'                Length\nA9RETDDN DS    CL8                 DDname\n*\n* SVC 99 text unit pointer list for unallocation functions\n*\nTUPLUNAL DS    0F\n         DC    A(TUUDDNAM)\n         DC    A(TUUUNALC)\n*\n* SVC 99 text unit for unallocation of a ddname\n*\nTUUDDNAM DS    0H\n         DC    Y(DUNDDNAM)         Key\n         DC    H'1'                Number\nU9DDNLEN DS    H                   Length of ddname\nU9DDNAME DS    CL8                 Ddname\n*\n* SVC 99 text unit for unallocation even if permanently allocated\n*\nTUUUNALC DS    0H\n         DC    Y(DUNUNALC)         Key\n         DC    H'0'                Number\n*\n*\n* SVC 99 text unit pointer list for concatenation functions\n*\nTUPLCCAT DS    0F\n         DC    A(TUCDDNAM)\n         DC    A(TUCPERMC)\n*\n* SVC 99 text unit for concatenation of a ddname\n*\nTUCDDNAM DS    0H\n         DC    Y(DCCDDNAM)         Key\nC9NUMBER DS    H                   Number (2 to &CATLIM)\n*                                  Area to hold up to &CATLIM\nC9STUFF  DS    XL(&CATLIM*(2+8))    contiguous HL2-CL8 fields...\n*\n* SVC 99 text unit for permanently concatenated\n*\nTUCPERMC DS    0H\n         DC    Y(DCCPERMC)         Key\n         DC    H'0'                Number\n         SPACE 2\nENDS99   DS    0D                  End of dynamic allocation area\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\nFDB      DSECT ,                   Map file-dataset blocks\n*\nFDBNEXT  DS    A                   Pointer to next FDB\nFDBLEN   DS    A                   Length of this FDB\nFDBOFF   DS    A                   Offset of next dsn slot\nFDBCOUNT DS    H                   Number of data set names\nFDBDDNL  DS    H                   Length of ddname\nFDBDDN   DS    CL8                 File name (ddname)\nFDBDATA  DS    &CATLIM.CL(FDBDATAL) Data set name data (max of &CATLIM)\n*\nFDBL     EQU   *-FDB               Length of file-dataset block\n*\nFDBDATAD DSECT ,                   Map FDBDATA entries\n*\nFDBDSNL  DS    H                   Length of this dsn\nFDBDSN   DS    CL44                The dsn\nFDBFLAGS DS    X                   Flags\nFDBERROR EQU   B'10000000'          1 = allocation failed\nFDBDELNF EQU   B'01000000'          1 = dataset to be removed not found\n*        EQU   B'00100000'          Reserved\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nFDBDATAL EQU   *-FDBDATAD          Length of each FDBDATA entry\n         EJECT\nDSLIST   DSECT                     DSLIST buffer mapping\n*\nDSLLEN   DS    F                   Length of this dslist buffer\nDSLEND   DS    A                   Address of the end of dslist buffer\nDSLCOUNT DS    H                   Number of data sets in list\nDSLDATA  EQU   *                   Data repeated for each data set\n*\nDSLISTL  EQU   *-DSLIST            Length of fixed portion of DSLIST\n*\n*\nDSLDATAD DSECT ,                   Map DSLDATA entries\n*\nDSLDSNL  DS    H                   Length of data set name\nDSLDSN   DS    CL44                Data set name\nDSLVOL   DS    CL6                 Volume serial\nDSLUNAME DS    CL4                 Unit name\n         DS    C                   Filler for unpacking hex data\nDSLFLAGS DS    X                   Flags\nDSLREMOV EQU   B'10000000'          1 = remove from new allocation\n*        EQU   B'01000000'          Reserved\n*        EQU   B'00100000'          Reserved\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nDSLDATAL EQU   *-DSLDATAD          Length of each DSLDATA entry\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n*\n         IKJVEPL                   Parse verify exit parameter list\n         EJECT\n         IKJPPE                    Parse parameter element\n         EJECT\n         IKJCPPL\n         EJECT\n         PRINT NOGEN\n*\n         IEFTIOT1                  Map the TIOT\n*\nJFCB_DSECT DSECT ,                 needed to avoid USING warnings 10/96\n*\n         IEFJFCBN                  Map the JFCB\n*\nUCB_DSECT DSECT ,                  needed to avoid USING warnings 10/96\n*\n         IEFUCBOB                  Map the UCB\n         IEFZB4D2                  Map dynamic allocation text units\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XALCUNIT 0100-07332-07332-0900-00210-00210-00000-SEB\n         TITLE 'XALCUNIT - TSO command processor'\n***********************************************************************\n*                                                                     *\n* XALCUNIT - TSO command processor to return allocation information   *\n*            (in particular, ddname) about a particular unit address  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Syntax:   XALCUNIT unitnumber                                       *\n*                                                                     *\n* (example: XALCUNIT C65)                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    ADDRESS OF UNIT NUMBER\nR7       EQU   7    ADDRESS THE PDL (PARSE OUTPUT)\nR8       EQU   8    ADDRESS THE UCB\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXALCUNIT CSECT\n         SAVE  (14,12),,XALCUNIT_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XALCUNIT,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         USING CPPL,R2             ADDRESS INPUT CPPL\n         XC    ANSWER,ANSWER\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R14,ECB\n         L     R15,=V(XALCUPCL)\n         LA    R0,ANSWER\n         L     R1,CPPLCBUF\n         STM   R14,R1,PPLECB\n         ST    R13,PPLUWA          USER WORK AREA = \"DATD\"\n         XC    ECB,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   RETURN12\n         L     R7,ANSWER\n         USING PDL,R7\n         L     R6,PDLUNIT+0        Get address of unit number\n         SPACE 1\n         L     R3,540              Get address of TCB\n         L     R3,12(,R3)          Get address of TIOT\n         USING TIOT1,R3\n         LA    R3,TIOENTRY         Point to first TIOT entry\n         XR    R4,R4               Clear reg used to insert length\n         XR    R5,R5               Clear register for 24-bit address\nLOOP     DS    0H\n         USING TIOENTRY,R3\n         TM    TIOESTTA,TIOSLTYP   If TIOT entry is not in use\n         BO    SKIP                then skip it\n         ICM   R5,B'0111',TIOEFSRT Get address of UCB from TIOT\n         BZ    SKIP                If none, this is not a winner\n         USING UCBCMSEG,R5\n         CLC   0(3,R6),UCBNAME     See if device names match\n         BNE   SKIP                If so, we found an allocation\nWIN      DS    0H                  We found an allocation\n         SPACE 1\n*                                  Temporary...\n* What we have to do is save nonblank ddnames so that we can print\n* out concatenation numbers.  We should also print out the unit #.\n*\n*\n*\n         TPUT  TIOEDDNM,8\n         SPACE 1\nSKIP     DS    0H\n         IC    R4,TIOELNGH         Get length of TIOT entry\n         ALR   R3,R4               Add length to get to next entry\n         CLI   TIOELNGH,X'00'      If next entry says \"end of TIOT\"\n         BNE   LOOP                then end, else continue\n         SPACE 1\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         LA    R2,12               SET RETURN CODE TO TWELVE\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         XR    R2,R2               SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *\n***********************************************************************\nRETURNP  DS    0H\n         SPACE\n         LA    R1,ANSWER\n         IKJRLSA (1)               RELEASE PARSE STORAGE\n         SPACE\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *\n***********************************************************************\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n*******************************************************************\n*\n*  Parse validity check exit for unitname.\n*\n*******************************************************************\n         SPACE 1\nUNITCHK  DS   0H\n         SPACE 1\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING UNITCHK,R12\n         SPACE 1\n         L     R8,0(,R1)           Get address of unit number PDE\n         L     R5,0(,R8)           Get address of unit number\n         LH    R6,4(,R8)           Get length of unit number\n         LA    R0,3\n         CR    R6,R0               Length must be equal to 3\n         BNE   UNITNG\n         TRT   0(3,R5),UNITTBL     Check for valid characters\n         BZ    UNITOK\nUNITNG   LA    R15,4               Invalid unit number\n         B     UNITRET\nUNITOK   XR    R15,R15             Valid unit number\nUNITRET  L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14                 Return to PARSE\n         SPACE 1\nUNITTBL  DC    256YL1(1)           All characters invalid except...\n         ORG   UNITTBL+C'0'        0-9\n         DC    10YL1(0)             and\n         ORG   UNITTBL+C'A'        A-F\n         DC    6YL1(0)\n         ORG   ,\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* PARSE CONTROL BLOCKS CSECT                                          *\n***********************************************************************\n         SPACE 1\nXALCUPCL IKJPARM DSECT=PDL\n         SPACE\nPDLUNIT  IKJIDENT 'UNIT NUMBER',UPPERCASE,                             X\n               PROMPT='UNIT NUMBER',VALIDCK=UNITCHK,                   X\n               MAXLNTH=3,FIRST=ALPHANUM,OTHER=ALPHANUM\n         SPACE\n         IKJENDP\n         SPACE\nXALCUNIT CSECT\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\n         SPACE\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\n         SPACE 1\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJCPPL\n         IEFTIOT1\n         IEFUCBOB PREFIX=YES       UCB MAPPING MACRO\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XALLOCSV 0100-07332-07332-0900-00243-00243-00000-SEB\n         TITLE 'XALLOCSV - SAVE CURRENT ALLOCATION INFO IN A DATA SET'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nXALLOCSV CSECT\n         SAVE  (14,12),,XALLOCSV_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XALLOCSV,R12\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         L     R1,4(,R13)\n         LM    R0,R1,20(R1)\n         USING DATD,R13\n         EJECT\n         LA    R7,4                INITIALIZE RETURN CODE\n         MVI   FLAGS,X'00'         INITIALIZE FLAGS\n         LR    R2,R1               POINT TO CPPL\n         USING CPPL,R2\n         MVC   OUTDCB(OUTDCBL),OUTDCBS\n         LA    R1,OUTDCB           SET UP DCB AND OPEN FOR OUTPUT\n         ST    R1,OUTDCBO\n         MVI   OUTDCBO,X'8F'\n         OPEN  MF=(E,OUTDCBO)      OPEN OUTPUT FILE\n         L     R3,CPPLECT          ADDRESS THE ECT\n         USING ECT,R3\n         TM    ECTSWS,ECTNOPD      IF AN OPERAND ON COMMAND\n         BO    NOARGDD             THEN\n         L     R4,CPPLCBUF          POINT TO COMMAND BUFFER\n         LA    R14,4(,R4)           GET ADDRESS OF START OF COMMAND\n         AH    R14,2(,R4)           ADD OFFSET OF OPERAND\n* R14 POINTS TO BEGINNING OF OPERAND\n         LA    R0,0(,R4)            GET ADDRESS OF COMMAND BUFFER\n         AH    R0,0(,R4)            ADD LENGTH OF COMMAND BUFFER\n* R0 POINTS TO END OF COMMAND BUFFER\n         LR    R1,R14\nOPLOOP   CR    R1,R0\n         BNL   ENDOP\n         CLI   0(R1),C' '\n         BE    ENDOP\n         CLI   0(R1),C','\n         BE    ENDOP\n         CLI   0(R1),X'05'\n         BE    ENDOP\n         CLI   0(R1),C'/'          CHECK FOR POSSIBLE /*\n         BE    ENDOP\n         LA    R1,1(,R1)\n         B     OPLOOP\nENDOP    DS    0H                  R1 POINTS TO END OF OPERAND\n         SR    R1,R14              R1 = LENGTH OF OPERAND\n         BNP   NOARGDD              IF ZERO, NO OPERAND\n         CH    R1,=H'8'             IF GREATER THAN 8,\n         BNH   LE8                  THEN\n         LA    R7,12                SET RETURN CODE TO 12\n         PUT   OUTDCB,INVALID       PUT OUT AN ERROR MESSAGE\n         B     RETURN               AND RETURN.\nLE8      DS    0H\n         OI    FLAGS,DDFLAG        INDICATE DD SPECIFIED\n         MVC   ARGDD,BLANKS\n         MVC   TESTDD,BLANKS       BLANK OUT BOTH DD FIELDS\n         BCTR  R1,0\n         EX    R1,MOVEDD           MOVE OPERAND TO ARGUMENT DDNAME\n         MVC   MASKDD,ARGDD        MOVE ARGUMENT DD TO MASK\n         TR    ARGDD,ARGTABLE      TRANSLATE ARGUMENT ASTERISKS\n         TR    MASKDD,MSKTABLE     CREATE MASK FOR COMPARES\n         DROP  R2,R3\nNOARGDD DS     0H\n         SPACE\n         L     R3,540              TCB\n         L     R3,12(,R3)          TIOT\n         USING TIOT1,R3\n         LA    R3,TIOENTRY         POINT TO FIRST TIOT ENTRY\n         XR    R4,R4               CLEAR REG USED TO INSERT LENGTH\nLOOP     DS    0H\n         USING TIOENTRY,R3\n         TM    TIOESTTA,TIOSLTYP   IF ENTRY NOT IN USE\n         BO    SKIP                THEN SKIP\n         TM    FLAGS,DDFLAG        IF TESTING FOR SPECIFIC DDNAME\n         BZ    GOAHEAD             THEN\n         CLC   TIOEDDNM,BLANKS      IF TIOT DDNAME IS NOT BLANK\n         BE    NOMOVETT             THEN\n         MVC   TESTDD,TIOEDDNM       USE IT FOR COMPARISONS\n         OC    TESTDD,MASKDD         OR IT W/MASK TO MASK GENERIC POS.\nNOMOVETT DS    0H                   (ELSE USE PREV. NONBLANK TIOT DD)\n         CLC   TESTDD,ARGDD         IF ARGUMENT DD DOES NOT MATCH\n         BNE   SKIP                 THEN SKIP THIS ENTRY\nGOAHEAD  DS    0H                  ELSE PROCESS THIS ENTRY\n         MVI   DATALINE,C' '       ELSE CLEAR OUTPUT LINE\n         MVC   DATALINE+1(L'DATALINE-1),DATALINE\n         MVC   DDNAME,TIOEDDNM     MOVE DDNAME TO OUTPUT LINE\n         CLC   DDNAME,BLANKS       IF DDNAME IS BLANK\n         BNE   NOTBLANK            THEN\n         MVC   DDNAME(2),=X'7D7D'   MOVE DOUBLE APOSTROPHES TO OUTPUT\nNOTBLANK ICM   R5,7,TIOEFSRT       GET ADDRESS OF UCB\n         BZ    NOUCB               IF NONE, OTHER KIND OF ALLOCATION\n         USING UCBCMSEG,R5\n         MVC   VOLSER,UCBVOLI      MOVE VOLUME SERIAL TO OUTPUT LINE\n         B     AFTUCB\n         SPACE\nNOUCB    DS    0H\n         TM    TIOELINK,TIOTTERM   IF DEVICE IS A TERMINAL\n         BZ    NOTTERM             THEN\n         MVI   DSNAME,C'*'                SAY SO\n         B     NOJFCB              ELSE\nNOTTERM  DS    0H\n         TM    TIOELINK,TIOESSDS   IF A SUBSYSTEM DATA SET\n         BZ    AFTUCB              THEN\n         MVC   VOLSER(6),=C'SYSOUT'      SAY SO\n         B     NOJFCB              ELSE\n         SPACE\nAFTUCB   DS    0H\n         SPACE\n         ICM   R6,7,TIOEJFCB       GET ADDRESS OF JFCB\n         BZ    NOJFCB\n         MVC   DSNAME(44),0+16(R6) MOVE DSNAME TO OUTPUT LINE\n         CLC   DSNAME(9),=C'NULLFILE '\n         BNE   NOTDUMMY\n         CLC   VOLSER(6),BLANKS\n         BNE   NOTDUMMY\n         MVC   VOLSER(5),=C'DUMMY'\nNOTDUMMY DS    0H\n         CLI   44+16(R6),C' '      IF A MEMBER NAME PRESENT\n         BE    NOMEM               THEN\n         LA    R1,DSNAME+44        SCAN FOR LAST NONBLANK IN DSNAME\n         LA    R0,44\nDSNLOOP  CLI   0(R1),C' '\n         BNE   ENDDSN\n         BCTR  R1,0\n         BCT   R0,DSNLOOP\nENDDSN   DS    0H\n         MVI   1(R1),C'('           MOVE LEFT PAREN\n         MVC   2(8,R1),44+16(R6)  MOVE MEMBER NAME IN\n         LA    R1,2+8(,R1)         SCAN FOR LAST NONBLANK IN MEMBER\n         LA    R0,8\nMEMLOOP  CLI   0(R1),C' '\n         BNE   ENDMEM\n         BCTR  R1,0\n         BCT   R0,MEMLOOP\nENDMEM   MVI   1(R1),C')'\nNOMEM    DS    0H\nNOJFCB   DS    0H\n         SPACE\n         CLC   VOLSER(6),BLANKS\n         BNE   NOTVBLK\n         MVC   VOLSER(2),=X'7D7D'\nNOTVBLK  DS    0H\n         PUT   OUTDCB,DATALINE     WRITE LINE OUT TO DATA SET\n         XR    R7,R7               INDICATE DATA DISPLAYED\n         SPACE\nSKIP     DS    0H\n         IC    R4,TIOELNGH         ELSE GET LENGTH OF THIS ENTRY\n         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY\n         CLI   TIOELNGH,X'00'      IF END OF TIOT\n         BNE   LOOP                THEN END, ELSE CONTINUE\n         SPACE\n         LTR   R7,R7               IF DATA WAS NOT DISPLAYED\n         BZ    RETURN              THEN\n         PUT   OUTDCB,NOTHING       SAY NOTHING FOUND\n         SPACE\nRETURN   DS    0H\n         CLOSE MF=(E,OUTDCBO)\n         LR    R1,R13\n         LA    R0,SIZDATD\n         L     R13,4(,R13)\n         ST    R7,16(,R13)         STORE RETURN CODE\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         TITLE 'XALLOCSV - DATA AREAS'\nMOVEDD   MVC   ARGDD(0),0(R14)     MOVE OPERAND TO TEST DDNAME\n         SPACE\nBLANKS   DC    CL8' '              ALL-PURPOSE BLANKS\n         SPACE\nNOTHING  DC    CL80''''' '''' ''''  ''NO ALLOCATIONS FOR FILE NAME'''\n         SPACE\nINVALID  DC    CL80''''' '''' ''''  ''INVALID FILE NAME SPECIFIED'''\n         SPACE\nARGTABLE DC    256YL1(*-ARGTABLE)  TRANSLATE TABLE FOR DD ARGUMENT\n         ORG   ARGTABLE+C'*'        WHICH CHANGES ASTERISKS\n         DC    X'FF'                TO ALL 1-BITS\n         ORG   ARGTABLE+X'81'       AND SHIFTS TO UPPER CASE\n         DC    C'ABCDEFGHI'\n         ORG   ARGTABLE+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   ARGTABLE+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         SPACE\nMSKTABLE DC    256YL1(0)           TRANSLATE TABLE FOR DD MASK\n         ORG   MSKTABLE+C'*'        WHICH CHANGES ALL CHARS TO 0-BITS\n         DC    X'FF'                EXCEPT ASTERISKS, WHICH ARE 1-BITS\n         ORG\n         PRINT NOGEN\nOUTDCBS  DCB   DDNAME=CSDALLOC,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,    X\n               BLKSIZE=1680\nOUTDCBL  EQU   *-OUTDCBS\n         EJECT\nDATD     DSECT\nSAVEAREA DS    18F\nARGDD    DS    CL8\nMASKDD   DS    CL8\nTESTDD   DS    CL8\nFLAGS    DS    X\nDDFLAG   EQU   X'80'               1 = A DDNAME WAS SPECIFIED\nDISPLAYD EQU   X'40'               1 = RESPONSE WAS DISPLAYED\nOUTDCB   DS    CL(OUTDCBL)\nOUTDCBO  OPEN  (*-*),MF=L\nDATALINE DS    CL80\n         ORG   DATALINE\nDDNAME   DS    CL8\n         DS    C\nVOLSER   DS    CL6\n         DS    C\nDSNAME   DS    CL44\n         ORG\n         SPACE\nSIZDATD  EQU   *-DATD\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJECT\n         EJECT\nTIOT     DSECT\n         IEFTIOT1 ,                MAP TIOT - NEED DST1.AMODGEN\n         IEFUCBOB ,                MAP UCB  - NEED DST1.AMODGEN\nXALLOCSV CSECT\n         LTORG\n         END\n./ ADD NAME=XAMODE   0100-07332-07332-0900-00058-00058-00000-SEB\n         TITLE 'XAMODE   - Function that returns current AMODE'\n***********************************************************************\n*                                                                     *\n* XAMODE   - Function that returns current AMODE                      *\n*                                                                     *\n* This function returns either 24 or 31 as the return code / integer  *\n* value to its caller.                                                *\n*                                                                     *\n* PL/1 invocation:                                                    *\n*                                                                     *\n*  DCL XAMODE ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *\n*                                                                     *\n*  CALL XAMODE;                                                       *\n*  SELECT PLIRETV();                                                  *\n*   WHEN (24) ...                                                     *\n*   WHEN (31) ...                                                     *\n*  END;                                                               *\n*                                                                     *\n* FORTRAN invocation:                                                 *\n*                                                                     *\n*  INTEGER*4 XAMODE,IRC                                               *\n*                                                                     *\n*  IRC = XAMODE()                                                     *\n*  IF (IRC.EQ.24) ...                                                 *\n*  IF (IRC.EQ.31) ...                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXAMODE   CSECT\nXAMODE   AMODE ANY\nXAMODE   RMODE ANY\n         BSM   R15,0               Get AMODE into hi-ord bit of reg 15\n         LTR   R15,R15             Test high-order bit (sign)\n         LA    R0,24               Return AMODE 24\n         LR    R15,R0              (for PL/1 and FORTRAN)\n         BNMR  R14                 if high-order bit is zero.\n         LA    R0,31               Return AMODE 31\n         LR    R15,R0              (for PL/1 and FORTRAN)\n         BR    R14                 if high-order bit is one.\n         SPACE 1\n         END\n./ ADD NAME=XCLIST   0100-07332-07332-0900-00101-00101-00000-SEB\n         TITLE 'XCLIST - SUBROUTINE TO RUN A CLIST FROM A PL/1 PROGRAM'\n***********************************************************************\n*                                                                     *\n* XCLIST - PL/1 SUBROUTINE TO EXECUTE A CLIST (OR NORMAL TSO COMMAND) *\n*          FROM WITHIN A PROGRAM.  THIS PROGRAM WAS WRITTEN IN ORDER  *\n*          TO ENABLE THE M6A PROJECT TO PROCEED, AS A SEMITEMPORARY   *\n*          MEASURE PRIOR TO ONE OF THE FOLLOWING BECOMING TRUE:       *\n*                                                                     *\n* (1) TONE SOFTWARE FIXES THE INTEXEC FEATURE OF PROCMAN.             *\n* (2) TSO/EXTENSIONS RELEASE 2 (INCLUDING TSO SERVICE FACILITY)       *\n*     IS INSTALLED.                                                   *\n* (3) THE PROJECT CONVERTS TO ISPF.                                   *\n*                                                                     *\n*          THE PROGRAM WORKS LIKE XCMD IN THAT IT SCANS THE COMMAND   *\n*          BUFFER AND PASSES CONTROL TO THE REQUESTED COMMAND         *\n*          PROCESSOR.  HOWEVER, IT IS DIFFERENT IN THAT IT ALSO       *\n*          PROCESSES ALL COMMANDS PLACED ON THE INPUT STACK BY THE    *\n*          INITIAL COMMAND.                                           *\n*          AT THE PRESENT TIME NO TASK LIBRARY SPECIFICATIONS ARE     *\n*          USED BY THIS COMMAND.  HOWEVER, THIS CAN EASILY BE         *\n*          GOTTEN AROUND BY INVOKING XCMD VIA THIS FACILITY, SINCE    *\n*          THE INITIAL COMMAND DOES NOT HAVE TO BE A CLIST AS LONG    *\n*          AS SOMETHING IS PLACED ON THE INPUT STACK WHILE THE        *\n*          INITIAL COMMAND IS PROCESSED.                              *\n*                                                                     *\n* THE SUBROUTINE IS INVOKED AS FOLLOWS:                               *\n*                                                                     *\n*    CALL XCLIST ('CLISTNAME CLISTOPERANDS ETC.');                    *\n*                                                                     *\n* A DECLARATION SHOULD BE INCLUDED IN THE PL/1 PROGRAM AS FOLLOWS:    *\n*                                                                     *\n*    DCL XCLIST EXT ENTRY(CHAR(*) VAR) OPTIONS(ASSEMBLER RETCODE);    *\n*                                                                     *\n* INPUT IS A PL/1 VARYING-LENGTH CHARACTER STRING (YOU KNOW, A        *\n* HALFWORD CONTAINING THE COMMAND LENGTH FOLLOWED BY THE COMMAND).    *\n*                                                                     *\n* THE RETURN CODE FROM THE LAST COMMAND EXECUTED IS RETURNED TO       *\n* THE CALLING PROGRAM.                                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*                                                                     *\n* 09/84 - FIX BUG IN NOT RETURNING RC 12 FROM ISPEXEC COMMAND         *\n*                                                                     *\n* 01/25/85 - RETURN THE RETURN CODE IN REGISTER 0 TO MAKE IT          *\n*            AVAILABLE TO FORTRAN CALLERS.  THE FORTRAN INTERFACE     *\n*            IS SOMETHING LIKE THIS:                                  *\n*                                                                     *\n*      INTEGER*2    ILEN                                              *\n*      INTEGER*4    IRC                                               *\n*      INTEGER*4    XCLIST                                            *\n*      CHARACTER*2  CMDLEN                                            *\n*      CHARACTER*80 CMD                                               *\n*      DATA ILEN/80/                                                  *\n*      EQUIVALENCE (ILEN,CMDLEN)                                      *\n*      CMD = 'WHATEVER YOUR COMMAND IS'                               *\n*      IRC = XCLIST(CMDLEN // CMD)                                    *\n*C     ... IRC IS THE RETURN CODE FROM THE COMMAND.                   *\n*                                                                     *\n* 01/30/85 - XCLIST WILL NOW ISSUE A WRITE-TO-PROGRAMMER MESSAGE      *\n*            IF IT IS INVOKED IN A NON-TSO ENVIRONMENT.  ALSO,        *\n*            USER ABEND 1500 WILL BE ISSUED IN THIS CASE.             *\n*                                                                     *\n* 05/01/87 - (1) AMODE/RMODE SUPPORT ADDED.                           *\n*            (2) BUG FIXED CALLING XCLIST WITH SYNTACTICALLY INVALID  *\n*                COMMANDS MORE THAN ONCE FROM THE SAME PROGRAM.       *\n*                                                                     *\n*                THIS APPEARS TO BE A BUG IN IKJSCAN RATHER THAN IN   *\n*                XCLIST.  BUT WE WILL TRY TO PROGRAM AROUND IT ANYHOW *\n*                                                                     *\n* 12/15/87 - (1) In preparation for TSO/E Release 4, which causes     *\n*                some more TSO commands to be APF authorized, XCLIST  *\n*                will now use the TSO service facility to invoke      *\n*                TSO commands which it finds in the TSO authorized    *\n*                command names table (IKJEFTE2).                      *\n*                                                                     *\n* 05/17/88 - (1) ISPF 2.3.0 no longer has an ISPCALL command.         *\n*                Therefore, XCLIST will now use the name IKJEFG00     *\n*                rather than ISPCALL when it invokes the CALL command.*\n*                                                                     *\n* 03/28/89 - The body of the code for XCLIST has been moved into the  *\n*            linklist-resident routine XTSEXEC.  XCLIST is now a stub *\n*            that LINKs to XTSEXEC.  In this way the code may be      *\n*            enhanced, upgraded and tested, with new features of      *\n*            TSO/Extensions in mind.                                  *\n*                                                                     *\n***********************************************************************\n         EJECT\nXCLIST   CSECT\nXCLIST   AMODE ANY\nXCLIST   RMODE ANY\n         STM   14,12,12(13)\n         USING XCLIST,15\n         LINK  EPLOC=$XTSEXEC\n         L     14,12(,13)          preserve regs 15 and 0\n         LM    1,12,24(13)\n         BR    14\n         SPACE\n$XTSEXEC DC    CL8'XTSEXEC '\n         END\n./ ADD NAME=XCONCAT  0100-07332-07332-0900-00298-00298-00000-SEB\n         TITLE 'XCONCAT - TSO COMMAND TO CONCATENATE FILES          '\n***********************************************************************\n*                                                                     *\n* XCONCAT - TSO COMMAND TO CONCATENATE 2 OR MORE PREALLOCATED FILES   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    ADDRESS OF COMMAND PROCESSOR PARAMETER LIST\nR5       EQU   5    USED FOR DAIRFAIL STORAGE\nR6       EQU   6    ADDRESS OF THE COMMAND BUFFER\nR7       EQU   7    DDNAME COUNTER\nR8       EQU   8    DDNAME POINTER\nR9       EQU   9    CONSTANT 8 FOR DDNAME MOVES\nR10      EQU   10   ADDRESS OF THE DAPB0C PARAMETER BLOCK\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXCONCAT CSECT\n         SAVE  (14,12),,XCONCAT_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XCONCAT,R12\n         LR    R4,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         USING CPPL,R4             MAP INPUT PARAMETER LIST\n         EJECT\n         MVC   DAPLUPT,CPPLUPT         PTR TO UPT\n         MVC   DAPLECT,CPPLECT         PTR TO ECT\n         MVC   DAPLPSCB,CPPLPSCB       PTR TO PSCB\n         MVC   CSPLUPT,CPPLUPT         PTR TO  UPT\n         MVC   CSPLECT,CPPLECT         PTR TO  ECT\n         MVC   IOPLUPT,CPPLUPT         PTR TO UPT\n         MVC   IOPLECT,CPPLECT         PTR TO ECT\n         LA    R0,ECB\n         ST    R0,DAPLECB              PTR TO CP'S ECB\n         ST    R0,CSPLECB              PTR TO  CP'S ECB\n         ST    R0,IOPLECB              PTR TO USER'S ECB\n         MVI   FLAG,X'00'              REQUEST SYNTAX CHECKS\n         LA    R0,FLAG\n         ST    R0,CSPLFLG              PTR TO  FLAG WORD\n         LA    R0,CSOA\n         ST    R0,CSPLOA               PTR TO OUTPUT AREA (CSOA DSECT)\n         MVC   CSPLCBUF,CPPLCBUF       PTR TO COMMAND BUFFER\n         SPACE 2\n         L     R6,CPPLCBUF         GET ADDRESS OF COMMAND BUFFER\n         LH    R0,0(,R6)           GET LENGTH OF COMMAND BUFFER\n         SLL   R0,2                MULTIPLY BY 4 TO BE REALLY SAFE\n         AH    R0,=H'12'           AND ADD 12 FOR THE PREFIX\n         ST    R0,DALEN            SAVE THIS LENGTH\n         GETMAIN R,LV=(0)          ASSUME THIS WILL HOLD ALL DDNAMES\n         LR    R10,R1\n         USING DAPB0C,R10\n         ST    R10,DAPLDAPB            PTR TO DAIR PARAMETER BLOCK\n         XC    DAPB0C(12),DAPB0C       CLEAR THE PARAMETER BLOCK\n         MVI   DA0CCD+1,X'0C'          SET DAIR ENTRY CODE\n         XR    R7,R7               INITIALIZE DDNAME COUNTER\n         LA    R8,DA0CDDN          INITIALIZE DDNAME POINTER\n         SPACE 2\nGETDDN   XC    ECB,ECB\n         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  SCAN FOR A DDNAME\n         TM    CSOAFLG,CSOABAD+CSOAQM+CSOAEXEC\n         BNZ   ERROR1\n         TM    CSOAFLG,CSOANOC\n         BO    NOMORE\n         LA    R7,1(,R7)           INCREMENT DDNAME COUNTER\n         LA    R9,8                SET DDNAME LENGTH REGISTER\n         L     R14,CSOACNM\n         LH    R15,CSOALNM\n         ICM   R15,8,=X'40'\n         MVCL  R8,R14              MOVE DDNAME TO DAPB0C PARM LIST\n         B     GETDDN\n         SPACE 1\nNOMORE   DS    0H                  NO MORE DDNAMES, FINISHED\n         STH   R7,DA0CNUMB\n         CH    R7,=H'2'\n         BL    ERROR2\n         SPACE 2\n         XC    ECB,ECB\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)\n******   LA    R1,DAPL             THIS WAS ONCE PUT IN TO PERMIT DAIR\n******   LINK  EP=IKJDAIR          TESTING UNDER TSO TEST WITH BREAKPTS\nAFTLINK  DS    0H                  BREAKPOINT AFTER DAIR WAS CALLED\n         ORG   *-2\nLINKDAIR DS    0H                  BREAKPOINT WHEN DAIR ABOUT TO BE\n         ORG\n         LTR   R15,R15\n         BZ    RETURN0\n         SPACE 1\n***********************************************************************\n* IF CONCATENATION REQUEST FAILED, CALL DAIRFAIL TO DISPLAY MESSAGE.  *\n***********************************************************************\n         SPACE 1\n         ST    R15,DAIRRC          STORE RETURN CODE FROM DAIR\n         L     R0,DFGETWD          GET SUBPOOL & LENGTH FOR STORAGE\n         GETMAIN R,LV=(0)          GET STORAGE FOR DAIRFAIL\n         LR    R5,R1               ADDRESS DAIRFAIL PARAMETER LIST\n         LA    R14,DAPL            +00->ADDRESS OF DAPL\n         LA    R15,DAIRRC          +04->ADDRESS OF RETURN CODE\n         LA    R0,=F'0'            +08->ADDRESS OF IKJEFF02 NOT PRESENT\n         LA    R1,=H'1'            +0C->REQUEST FOR MSG USING PUTLINE\n         LA    R2,CPPL             +10->ADDRESS OF CPPL FOR PUTLINE\n         XR    R3,R3               +14=ZEROES\n         STM   R14,R3,0(R5)        SET UP PARAMETER LIST FOR DAIRFAIL\n         LR    R1,R5               USING PARAMETER LIST,\n         LINK  EP=IKJEFF18         CALL DAIRFAIL SERVICE ROUTINE\n         LTR   R1,R15              IF DAIRFAIL FAILED,\n         BNZ   ABEND               THEN BLOW UP\n         LR    R1,R5               ELSE...\n         L     R0,DFGETWD\n         FREEMAIN R,LV=(0),A=(1)   FREE THE STORAGE\n         B     RETURN12            RETURN WITH CODE 12\n         EJECT\nERROR1   DS    0H\n         SPACE 1\n         LA    R1,BADPARMS         ADDRESS OF ERROR MESSAGE\n         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT\n         SPACE 2\nERROR2   DS    0H\n         SPACE 1\n         LA    R1,BADDDS           ADDRESS OF ERROR MESSAGE\n******** B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT\n         SPACE 2\nTERMPUT  DS    0H                  DISPLAY MSG: R1 -> MSG HEADER\n         SPACE 1\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP STACK LIST FORM\n         LA    R0,1                DEFINE 1 MESSAGE SEGMENT\n         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R1,R15\n         BNZ   ABEND\n******** B     RETURN12            RETURN WITH CODE 12\n         SPACE 2\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         SPACE 1\n         MVC   FLUSH(LENFLUSH),MFLUSH SET UP STACK LIST FORM\n         XC    ECB,ECB             CLEAR ECB AND FLUSH THE INPUT STACK\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R1,R15\n         BNZ   ABEND\n         SPACE 2\nSTACKOK  LA    R15,12              SET RETURN CODE TO 12\n         B     RETURN\n         SPACE 3\nABEND    ABEND (1),DUMP            BAD RC FROM SOMETHING, BLOW UP\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R14,R15\n         LR    R1,R10              FREE THE DAPB0C BUFFER\n         L     R0,DALEN\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R14,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* NO EXECUTED INSTRUCTIONS                                            *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nDFGETWD  DC    0F'0',YL1(78),AL3(24) GETMAIN/FREEMAIN: SP=78,LV=24\n         SPACE 1\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n         SPACE 1\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n         SPACE 2\nBADPARMS WTO   MF=L,'XCONCAT: INVALID DDNAME(S) ENTERED.'\n         SPACE 1\nBADDDS   WTO   MF=L,'XCONCAT: AT LEAST TWO DDNAMES REQUIRED.'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F                 OS SAVE AREA\n         SPACE 1\nECB      DS    F                   ECB FOR TSO ROUTINES\nFLAG     DS    F                   FLAG WORD FOR IKJSCAN\nDALEN    DS    F                   LENGTH OF DA0C BUFFER\nDAIRRC   DS    F                   RETURN CODE FROM DAIR\n         SPACE 1\nOLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR\nOLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS\nOLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT\n         SPACE 1\nFLUSH    STACK MF=L,DELETE=ALL\n         SPACE 1\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 1\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\nDAPL     DS    0A\n         SPACE 1\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         SPACE 2\nCSPL     DS    0A\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE 1\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         SPACE 1\nCSOA     DS    0A\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE 1\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN\n         DS    CL1      RESERVED\n         SPACE 2\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE 1\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n* DYNAMIC ALLOCATION PARAMETER BLOCK TO CONCATENATE DDNAMES           *\n***********************************************************************\n         IKJDAP0C\n         SPACE\nDA0CDDN  DS    0CL8                DDNAMES\n         EJECT\n         IKJCPPL\n         EJECT\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XDECONC  0100-07332-07332-0900-00290-00290-00000-SEB\n         TITLE 'XDECONC - TSO COMMAND TO DECONCATENATE FILES'\n***********************************************************************\n*                                                                     *\n* XDECONC - TSO COMMAND TO DECONCATENATE A CONCATENATED FILE NAME     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    ADDRESS OF COMMAND PROCESSOR PARAMETER LIST\nR5       EQU   5    USED FOR DAIRFAIL STORAGE\nR6       EQU   6    ADDRESS OF THE COMMAND BUFFER\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXDECONC CSECT\n         SAVE  (14,12),,XDECONC_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XDECONC,R12\n         LR    R4,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         USING CPPL,R4             MAP INPUT PARAMETER LIST\n         EJECT\n         MVC   DAPLUPT,CPPLUPT         PTR TO UPT\n         MVC   DAPLECT,CPPLECT         PTR TO ECT\n         MVC   DAPLPSCB,CPPLPSCB       PTR TO PSCB\n         MVC   CSPLUPT,CPPLUPT         PTR TO  UPT\n         MVC   CSPLECT,CPPLECT         PTR TO  ECT\n         MVC   IOPLUPT,CPPLUPT         PTR TO UPT\n         MVC   IOPLECT,CPPLECT         PTR TO ECT\n         LA    R0,ECB\n         ST    R0,DAPLECB              PTR TO CP'S ECB\n         ST    R0,CSPLECB              PTR TO  CP'S ECB\n         ST    R0,IOPLECB              PTR TO USER'S ECB\n         MVI   FLAG,X'00'              REQUEST SYNTAX CHECKS\n         LA    R0,FLAG\n         ST    R0,CSPLFLG              PTR TO  FLAG WORD\n         LA    R0,CSOA\n         ST    R0,CSPLOA               PTR TO OUTPUT AREA (CSOA DSECT)\n         MVC   CSPLCBUF,CPPLCBUF       PTR TO COMMAND BUFFER\n         LA    R1,DAPB10\n         ST    R1,DAPLDAPB             PTR TO DAIR PARAMETER BLOCK\n         XC    DAPB10(16),DAPB10       CLEAR THE PARAMETER BLOCK\n         MVI   DA10CD+1,X'10'          SET DAIR ENTRY CODE\n         MVI   DA10DDN,C' '            CLEAR DDNAME TO BLANKS\n         MVC   DA10DDN+1(7),DA10DDN\n         SPACE 2\nGETDDN   XC    ECB,ECB\n         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  SCAN FOR A DDNAME\n         TM    CSOAFLG,CSOABAD+CSOAQM+CSOAEXEC  BAD DD SYNTAX?\n         BNZ   ERROR1\n         TM    CSOAFLG,CSOANOC     NO DDNAME?\n         BO    ERROR2\n         TM    CSOAFLG,CSOAVWP     TOO MANY DDNAMES?\n         BO    ERROR3\n         L     R14,CSOACNM         GET ADDRESS OF DDNAME\n         LH    R15,CSOALNM         GET LENGTH OF DDNAME\n         BCTR  R15,0\n         EX    R15,MOVEDDN         MOVE DDNAME TO DAPB10 PARM LIST\n         SPACE 2\n         XC    ECB,ECB\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPL) DO IT TO IT\n         LTR   R15,R15\n         BZ    RETURN0\n         SPACE 1\n***********************************************************************\n* IF DECONCATENATION REQUEST FAILED, CALL DAIRFAIL TO DISPLAY MESSAGE *\n***********************************************************************\n         SPACE 1\n         ST    R15,DAIRRC          STORE RETURN CODE FROM DAIR\n         L     R0,DFGETWD          GET SUBPOOL & LENGTH FOR STORAGE\n         GETMAIN R,LV=(0)          GET STORAGE FOR DAIRFAIL\n         LR    R5,R1               ADDRESS DAIRFAIL PARAMETER LIST\n         LA    R14,DAPL            +00->ADDRESS OF DAPL\n         LA    R15,DAIRRC          +04->ADDRESS OF RETURN CODE\n         LA    R0,=F'0'            +08->ADDRESS OF IKJEFF02 NOT PRESENT\n         LA    R1,=H'1'            +0C->REQUEST FOR MSG USING PUTLINE\n         LA    R2,CPPL             +10->ADDRESS OF CPPL FOR PUTLINE\n         XR    R3,R3               +14=ZEROES\n         STM   R14,R3,0(R5)        SET UP PARAMETER LIST FOR DAIRFAIL\n         LR    R1,R5               USING PARAMETER LIST,\n         LINK  EP=IKJEFF18         CALL DAIRFAIL SERVICE ROUTINE\n         LTR   R1,R15              IF DAIRFAIL FAILED,\n         BNZ   ABEND               THEN BLOW UP\n         LR    R1,R5               ELSE...\n         L     R0,DFGETWD\n         FREEMAIN R,LV=(0),A=(1)   FREE THE STORAGE\n         B     RETURN12            RETURN WITH CODE 12\n         EJECT\nERROR1   DS    0H\n         SPACE 1\n         LA    R1,INVALID          ADDRESS OF ERROR MESSAGE\n         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT\n         SPACE 2\nERROR2   DS    0H\n         SPACE 1\n         LA    R1,MISSING          ADDRESS OF ERROR MESSAGE\n         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT\n         SPACE 2\nERROR3   DS    0H\n         SPACE 1\n         LA    R1,TOOMANY          ADDRESS OF ERROR MESSAGE\n******** B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT\n         SPACE 2\nTERMPUT  DS    0H                  DISPLAY MSG: R1 -> MSG HEADER\n         SPACE 1\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP STACK LIST FORM\n         LA    R0,1                DEFINE 1 MESSAGE SEGMENT\n         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R1,R15\n         BNZ   ABEND\n******** B     RETURN12            RETURN WITH CODE 12\n         SPACE 2\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         SPACE 1\n         MVC   FLUSH(LENFLUSH),MFLUSH SET UP STACK LIST FORM\n         XC    ECB,ECB             CLEAR ECB AND FLUSH THE INPUT STACK\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R1,R15\n         BNZ   ABEND\n         SPACE 2\nSTACKOK  LA    R15,12              SET RETURN CODE TO 12\n         B     RETURN\n         SPACE 3\nABEND    ABEND (1),DUMP            BAD RC FROM SOMETHING, BLOW UP\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE\nMOVEDDN  MVC   DA10DDN(0),0(R14)   EXECUTED: MOVE DDNAME TO DAIR BLOCK\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nDFGETWD  DC    0F'0',YL1(78),AL3(24) GETMAIN/FREEMAIN: SP=78,LV=24\n         SPACE 1\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n         SPACE 1\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n         SPACE 2\nINVALID WTO    MF=L,'XDECONC: INVALID DDNAME ENTERED.'\n         SPACE 1\nMISSING  WTO   MF=L,'XDECONC: A DDNAME IS REQUIRED.'\n         SPACE 1\nTOOMANY  WTO   MF=L,'XDECONC: ONLY ONE DDNAME PERMITTED.'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F                 OS SAVE AREA\n         SPACE 1\nECB      DS    F                   ECB FOR TSO ROUTINES\nFLAG     DS    F                   FLAG WORD FOR IKJSCAN\nDALEN    DS    F                   LENGTH OF DA10 BUFFER\nDAIRRC   DS    F                   RETURN CODE FROM DAIR\n         SPACE 1\nOLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR\nOLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS\nOLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT\n         SPACE 1\nFLUSH    STACK MF=L,DELETE=ALL\n         SPACE 1\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 1\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\nDAPL     DS    0A\n         SPACE 1\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         SPACE 2\nCSPL     DS    0A\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE 1\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         SPACE 1\nCSOA     DS    0A\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE 1\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN\n         DS    CL1      RESERVED\n         SPACE 2\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE 1\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 2\n***********************************************************************\n* DYNAMIC ALLOCATION PARAMETER BLOCK TO DECONCATENATE DDNAMES         *\n***********************************************************************\nDAPB10   DS    0A\n***********************************************************************\n* THIS OPERATION CODE CAUSES THE PREVIOUSLY CONCATENATED DDNAME  TO   *\n* BE DECONCATENATED                                                   *\n***********************************************************************\nDA10CD   DS    CL2      DAIR ENTRY CODE\nDA10FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0\n         DS    X\nDA10DARC DS    H        DYN ALLOC RETURN CODE\n         DS    CL2      RESERVED\nDA10DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE\n         SPACE 3\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJCPPL\n         EJECT\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XFINDM   0100-07332-07332-0900-00154-00154-00000-SEB\n         TITLE 'XFINDM - INSTREAM MACRO'\n         MACRO\n&NAME    TEPUT &A,&L\n.* NEW IMPROVED TPUT MACRO\n&NAME    LA    R1,&A                    LOAD PARAMETER REG 1\n         LA    R0,&L                    LOAD PARAMETER REG 0\n         SVC   93                       ISSUE TPUT SVC\n         MEND\n         TITLE 'XFINDM - TELLS WHERE MEMBER IS IN PDS CONCATENATION'\nXFINDM   CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,XFINDM_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XFINDM,R12\n         L     R4,0(,R1)               ADDRESS OF PARAMETER STRING\n         LH    R2,0(,R4)               LENGTH OF PARAMETER STRING\n         LTR   R2,R2                   IF PARM LENGTH NOT ZERO,\n         BZ    NODDNAME                THEN...\n         CH    R2,=H'8'                 IF PARM LENGTH EXCEEDS 8,\n         BNH   DDNAMEOK                 THEN...\n         TEPUT BADDD,L'BADDD             'INVALID DDNAME'\n         B     RETURN                   ELSE...\nDDNAMEOK MVC   SYSLIB+40(8),BLANKS       MOVE BLANKS TO DCB DDNAME\n         BCTR  R2,0                      USING PARM LENGTH,\n         EX    R2,MOVEDD                 MOVE DDNAME TO DCB\n         B     OPEN                    ELSE (ZERO PARM LENGTH)...\nNODDNAME TEPUT DEFAULT,L'DEFAULT        'NO DDNAME, USING SYSLIB'\nOPEN     MVC   DD1,SYSLIB+40           MOVE DDNAME TO MESSAGE\n         OPEN  SYSLIB                  OPEN THE PDS\n         TM    SYSLIB+48,X'10'         IF PDS WAS NOT OPENED,\n         BNO   NOSYSLIB                THEN FAIL. ELSE...\n         MVC   BLDLNAME,BLANKS         MOVE BLANKS TO BLDL LIST NAME\n         BLDL  SYSLIB,BLDLLIST         DO DUMMY BLDL ON BLANK MEMBER\n         B     DUMBLDL(R15)            CHECK BLDL RETURN CODE\nDUMBLDL  B     DSORGOK                 RC=0 - DSORG OK\n         B     DSORGOK                 RC=4 - DSORG OK\n         MVC   DD2,DD1                 RC=8 - BLDL I/O ERROR\n         TEPUT BADDSORG,L'BADDSORG     'BAD DSORG (NOT PO)'\n         B     END                      AND FAIL.\n         SPACE\nDSORGOK  DS    0H                      DSORG IS PO - CONTINUE\n         L     R15,X'21C'              TCB\n         L     R5,12(,R15)             TIOT\n         AH    R5,SYSLIB+40            ADD TIOT OFFSET FROM DCB\n* R5 NOW POINTS TO THE FIRST TIOT ENTRY FOR THE DDNAME.\n         SPACE\nASK      TEPUT PROMPT,L'PROMPT         ASK FOR A MEMBER NAME\n         TGET  MEMNAME,8               READ IN A MEMBER NAME\n         CH    R15,=H'12'              IF INPUT LONGER THAN 8 CHARS\n         BE    TOOLONG                 THEN MEMBER NAME TOO LONG\n         CH    R15,=H'8'               ELSE IF ATTENTION INTERRUPT\n         BE    ATTN                    THEN REPROMPT\n         LTR   R15,R15                 ELSE IF OTHER BAD RETURN CODE\n         BNZ   TGETERR                 THEN DISASTROUS ERROR. ELSE...\n         OC    MEMNAME,BLANKS          SHIFT NAME TO UPPER CASE\n         CLC   MEMNAME,BLANKS          IF NO NAME ENTERED (NULL LINE),\n         BE    END                     THEN GO CLOSE PDS & END. ELSE...\n         MVC   BLDLNAME,MEMNAME        MOVE NAME TO BLDL LIST\n         BLDL  SYSLIB,BLDLLIST         DO BLDL FOR THE MEMBER\n         B     GO(R15)                 BRANCH DEPENDING ON RETURN CODE\nGO       B     BLDL0                   RC=0 - MEMBER FOUND\n         B     BLDL4                   RC=4 - MEMBER NOT FOUND\n         B     BLDL8                   RC=8 - UNEXPECTED ERROR\n         SPACE\nBLDL0    DS    0H                      BLDL RC=0: SUCCESSFUL\n         XR    R3,R3                   CLEAR INSERT REG\n         ICM   R3,1,K                  PICK UP CONCATENATION INDEX\n         MH    R3,=H'20'               CONVERT TO OFFSET INTO TIOT\n* (ASSUME THAT, SINCE ALL DD ENTRIES ARE FOR PDS'S AND PDS'S CANNOT\n*  RESIDE ON MORE THAN ONE VOLUME, ALL TIOT ENTRIES FOR THIS DDNAME\n*  ARE 20 BYTES IN LENGTH SINCE THEY CONTAIN 1 UCB ADDRESS EACH.)\n         ALR   R3,R5                   CONVERT TO TIOT-ENTRY ADDRESS\n         ICM   R4,7,12(R3)             GET JFCB ADDRESS\n         MVC   DSNAME,16(R4)           MOVE DSNAME FROM JFCB TO MESSAGE\n         MVC   DSNMSG(8),BLDLNAME      MOVE MEMBER NAME TO MESSAGE\n         TEPUT DSNMSG,DSNMSGL          TELL USER WHERE MEMBER CAME FROM\n         B     ASK                     AND GO GET ANOTHER MEMBER NAME.\n         SPACE\nBLDL4    DS    0H                      BLDL RC=4: MEMBER NOT FOUND\n         MVC   NOTFOUND(8),BLDLNAME    MOVE MEMBER NAME TO MESSAGE\n         TEPUT NOTFOUND,L'NOTFOUND     DISPLAY NOT-FOUND MESSAGE\n         B     ASK                     AND GO GET ANOTHER MEMBER NAME.\n         SPACE\nBLDL8    DS    0H                      BLDL RC=8: DIRECTORY I/O ERROR\n         TEPUT ERROR8,L'ERROR8         TELL USER THE SAD NEWS\n         B     ASK                     AND GO GET ANOTHER MEMBER NAME.\n         SPACE\nTOOLONG  DS    0H                      USER ENTERED TOO MUCH DATA\n         TEPUT MSGTL,L'MSGTL           'INPUT TOO LONG'\n         TCLEARQ INPUT                 PURGE EXTRA TERMINAL INPUT\n         B     ASK                     AND GO GET ANOTHER MEMBER NAME.\n         SPACE\nATTN     DS    0H                      USER HIT THE PA1/ATTN KEY\n         TEPUT ATTNMSG,L'ATTNMSG       'ATTENTION INTERRUPT'\n         TCLEARQ INPUT                 PURGE EXTRA TERMINAL INPUT\n         B     ASK                     AND GO GET ANOTHER MEMBER NAME.\n         SPACE\nNOSYSLIB DS    0H                      PDS NOT ALLOCATED/OPENED\n         TEPUT NOLIBS,NOLIBSL          'REQUESTED DDNAME NOT OPENED'\n         B     RETURN                  END\n         SPACE\nTGETERR  TEPUT ERRORT,L'ERRORT         'TGET ERROR'\n         SPACE\nEND      CLOSE SYSLIB                  FINISH UP\nRETURN   LM    R14,R12,12(R13)\n         XR    R15,R15                 RETURN CODE(0) - ALWAYS\n         BR    R14\n         TITLE 'XFINDM - DATA AREAS'\nMOVEDD   MVC   SYSLIB+40(0),2(R4)      EXECUTED - MOVE DDNAME TO DCB\nBLANKS   DC    CL8' '                  GENERAL PURPOSE BLANKS\nMEMNAME  DS    CL8                     THE MEMBER NAME IS READ IN HERE\nBLDLLIST DC    Y(1,LISTLEN)            BLDL LIST TO LOOK FOR 1 MEMBER\nBLDLNAME DS    CL8                     BLDL MEMBER NAME\nTTR      DS    XL3                     TTR OF MEMBER\nK        DS    X                       CONCATENATION # (0=1ST LIBRARY)\n*** REFERENCE FOR ABOVE FIELDS: DATA MANAGEMENT SERVICES GUIDE ***\nLISTLEN  EQU   *-BLDLNAME              LENGTH OF BLDL LIST\n         PRINT NOGEN\nSYSLIB   DCB   DDNAME=SYSLIB,DSORG=PO,MACRF=R PDS DCB DEFAULT IS SYSLIB\n         PRINT GEN\n         SPACE\nPROMPT   DC    C'ENTER MEMBER NAME OR A NULL LINE TO END'\nDSNMSG   DC    C'         IS LOCATED IN '\nDSNAME   DS    CL44\nDSNMSGL  EQU   *-DSNMSG\nNOTFOUND DC    C'         NOT FOUND'\nERROR8   DC    C'BLDL FAILED, PROBABLE I/O ERROR ON DIRECTORY'\nMSGTL    DC    C'INPUT LONGER THAN 8 CHARACTERS'\nATTNMSG  DC    C'ATTENTION INTERRUPT, INPUT IGNORED'\nERRORT   DC    C'TGET ERROR, PROCESSING TERMINATED'\nNOLIBS   DC    C'UNABLE TO OPEN '\nDD1      DC    CL8' '\n         DC    C' - PROCESSING TERMINATED'\nNOLIBSL  EQU   *-NOLIBS\nDEFAULT  DC    C'NO DDNAME PARM SPECIFIED, USING DEFAULT OF SYSLIB'\nBADDD    DC    C'INVALID DDNAME PARM SPECIFIED, PROCESSING TERMINATED'\nBADDSORG DC    C'INVALID DSORG (NOT PARTITIONED) ON DD         '\nDD2      EQU   *-8,8,C'C'\n         END\n./ ADD NAME=XGET     0100-07332-07332-0900-00014-00014-00000-SEB\nXGET     CSECT\n*\n* DCL XGET ENTRY(CHAR(*), FIXED(15) BIN) EXTERNAL OPTIONS(ASM INTER);\n*\n         SAVE  (14,12),,XGET_&SYSDATE._&SYSTIME\n         LR    12,15\n         USING XGET,12\n         LM    1,2,0(1)            GET ADDRESS OF VAR & ADDR OF LENGTH\n         LH    0,0(,2)             GET LENGTH OF VARIABLE\n         TGET  (1),(0)\n         L     14,12(,13)          RETURN WITH RC FROM TGET\n         LM    0,12,20(13)\n         BR    14\n         END\n./ ADD NAME=XIPMAP   0100-07332-07332-0900-00667-00667-00000-SEB\n         TITLE 'XIPMAP - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         EJECT\n         MACRO\n&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE\n         AIF   ('&REG' EQ '*').NOSTORE\n&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED\n         AGO   .AFT\n.NOSTORE ANOP\n&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED\n.AFT     ANOP\n         UNPK  &PLACE.(9),&STG.(5)\n         TR    &PLACE.(8),HEXTBL\n         MVI   &PLACE.+8,C&FILL\n         MEND\n         TITLE 'XIPMAP - IPCS VERB EXIT TO MAP TCB TREE CONTROL BLOCKS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TCB POINTER\nR4       EQU   4    ABDPL ADDRESS\nR5       EQU   5    LLS POINTER\nR6       EQU   6    RB POINTER\nR7       EQU   7    CDE POINTER\nR8       EQU   8    DEB POINTER\nR9       EQU   9    DCB POINTER\nR10      EQU   10   JPQ POINTER\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPMAP   CSECT\n         SAVE  (14,12),,XIPMAP-&SYSDATE-&SYSTIME\n         LR    R12,R15\n         USING XIPMAP,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO\n         USING LINEDSCT,R11            OUTPUT BUFFER\n         XC    WHRADDR,WHRADDR\n         XC    FIRSTTCB,FIRSTTCB\n         EJECT\n*\n* Instead of using the low-core pointer to get to the TCB,\n* use the ASID to locate the ASCB (via the ASVT) and get the\n* first TCB from there.  In that way, setting the ASID via\n* SETDEF will affect which address space gets mapped.\n*\n*        LA    R3,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY218),TRY218\n*        BAL   R14,OUTPUT\n*        LA    R3,X'218'\n*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY224),TRY224\n*        BAL   R14,OUTPUT\n*\n* Try to get ASCB.  Instead of relying on the low-core pointer,\n* use the ASID to locate it via the ASVT.  In that way, setting\n* the ASID with SETDEF will cause this exit to pick up the right one.\n*\n*----------------------------------------------------------------------\n*        LA    R3,X'224'            TRY VIA ASCB\n*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB\n*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP\n*----------------------------------------------------------------------\n         L     R3,ADPLCVT          Get CVT pointer\n         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT\n         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump\n         L     R3,0(,R3)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID\n         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump\n         L     R3,0(,R3)           Load the ASCB address\n         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump\n         L     R3,X'6C'(,R3)       GET POINTER TO ASXB\n         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP\n         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB\n         ST    R3,FIRSTTCB         Save it for module findings\nFINDTOP  DS    0H                  SCAN FOR TOP TCB\n         LR    R2,R3               SAVE ACTUAL TCB ADDRESS\n         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP\n         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB\n         BZ    USETCB              IF NONE, THIS IS THE TOP TCB\n         LR    R3,R15              IF THERE IS A MOTHER,\n         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT\nUSETCB   DS    0H                  START WITH THIS TCB\n         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN\n         SPACE 1\n*******                            (WE DON'T DO THIS ANY MORE)\n*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB\n*******\n*\n         BAL   R14,OUTPUT          Print a blank line\n         MVC   LINE(L'HIMSG),HIMSG\n         LH    R2,ADPLASID\n         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID\n         BAL   R14,OUTPUT          PRINT \"HI THERE\" MESSAGE\n         BAL   R14,OUTPUT          Print a blank line\n*\nDOIT     DS    0H\n         BAL   R14,PROCESS\n         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB\n         BNZ   DOIT\nNODTR    DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'80' SISTER TCB\n         BNZ   DOIT\nNOSISTER DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'84' MOTHER TCB\n         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE\n         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP\n         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE\n         B     NODTR               PROCESS ITS SISTER, ETC.\nNOMORE   DS    0H\n         B     RETURN0\n         EJECT\nPROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED\n         SPACE\n         ST    R14,PRCSSAVE        SAVE RETURN REGISTER\n         BAL   R14,OUTPUT          PRINT A BLANK LINE\n         MVC   LINE(L'TCBMSG),TCBMSG\n         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING TCB\"\n         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP\n         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE\n         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE\n         BZ    NOTCBCMP            IF THERE IS ONE, THEN...\n         MVC   LINE(L'CMPMSG),CMPMSG\n         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT\n         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG\n         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA\n         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT\n         BAL   R14,OUTPUT          PRINT COMPLETION CODE\nNOTCBCMP DS    0H\n         L     R6,COPYTCB+0        ADDRESS OF RB\n         MVC   LINE(L'RBMSG),RBMSG\n         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING RB\"\nRBLOOP   DS    0H\n         LR    R2,R6               SAVE TRUE RB ADDRESS\n         SH    R6,=H'32'           POINT TO RB PREFIX\n         BM    BADRB               IF MAKES IT GO NEGATIVE, BAD ADDR\n         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP\n         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT\n         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS\n         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE\n         BZ    PRB\n         BO    SVRB\n         LA    R1,=CL8'(IRB)'\n         B     RBTYPE\nSVRB     LA    R1,=CL8'(SVRB)'\nRBTYPE   DS    0H\n         MVC   LINE+10(8),0(R1)    MOVE RB TYPE\n         B     RBOUT\nPRB      DS    0H\n         XR    R7,R7\n         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE\n         BNZ   GOTACDE             IF ZERO, THEN...\n         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO\n         BZ    NOCDE                 THEN\n         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO\n         B     RBOUT                 ELSE\nNOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE\n         B     RBOUT\nGOTACDE  DS    0H\n         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE\n         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP\n         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME\nRBOUT    DS    0H\n         MVC   LINE+21(4),=C'INT='\n         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE\n         TR    LINE+25(2),HEXTBL\n         MVI   LINE+27,C' '\n         MVC   LINE+29(4),=C'PSW='\n         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW\n         TR    LINE+33(8),HEXTBL\n         MVI   LINE+41,C' '\n         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW\n         TR    LINE+42(8),HEXTBL\n         MVI   LINE+50,C' '\n         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW\n         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS\n         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB\nRBNEXT   DS    0H\n         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB\n         BO    ENDRB               THEN NO MORE RB'S. ELSE\n         XR    R6,R6\n         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB\n         B     RBLOOP\nBADRB    DS    0H                  RB STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'RBERRMSG),RBERRMSG\n         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB\n         BAL   R14,OUTPUT\nENDRB    DS    0H\n         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE\n         BZ    ENDCDE\n         MVC   LINE(L'JPQMSG),JPQMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING JOB PACK QUEUE\"\nCDELOOP  DS    0H\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\n         ICM   R10,15,0(R10)\n         BNZ   CDELOOP\nENDCDE   DS    0H\nTCB2LOOP DS    0H\n         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS\n         BZ    ENDLLS\n         MVC   LINE(L'LLSMSG),LLSMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING LOAD LIST\"\nLLSLOOP  DS    0H\n         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP\n         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS\n         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\nNEXTLLS  DS    0H\n         LTR   R5,R2               GET ADDRESS OF NEXT LLS\n         BZ    ENDLLS\n         B     LLSLOOP\nBADLLS   DS    0H                  ERROR ACCESSING LLS\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'LLSERMSG),LLSERMSG\n         GDUMP R5,LINE+L'LLSERMSG\n         BAL   R14,OUTPUT\n         SPACE 1\nENDLLS   DS    0H\n         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB\n         BNZ   GOTDEBS\n         MVC   LINE(L'NODEBS),NODEBS\n         BAL   R14,OUTPUT          PRINT \"NO OPEN DATA SETS\"\n         B     ENDDEB\nGOTDEBS  DS    0H\n         MVC   LINE(L'DEBMSG),DEBMSG\n         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB\n         BAL   R14,OUTPUT          PRINT \"MAPPING DEB CHAIN\"\nDEBLOOP  DS    0H\n         MVC   LINE(4),=C'DEB='\n         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB\n         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP\n         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT\n         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB\n         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE\n         MVC   LINE+14(4),=C'DCB='\n         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB\n         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP\n         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT\n         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB\n         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP\n         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT\n         MVI   LINE+36,C' '\n         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT\n         LA    R9,X'10'(,R9)       ADDRESS OF JFCB\n         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP\n         MVC   LINE+37(44),0(R9)   DSNAME\n         LA    R1,LINE+37+44-1\nDSNLOOP  CLI   0(R1),C' '\n         BNE   DSNEND\n         BCTR  R1,0\n         B     DSNLOOP\nDSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB\n         BE    NOMEMBER            THEN\n         MVI   1(R1),C'('\n         MVC   2(8,R1),44(R9)\n         LA    R1,9(,R1)\nMEMLOOP  CLI   0(R1),C' '\n         BNE   MEMEND\n         BCTR  R1,0\n         B     MEMLOOP\nMEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER\n         LA    R1,1(,R1)\n         MVI   0(R1),C')'\nNOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK\n         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,\n         BZ    PRINTDEB            THEN...\n         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW\n         B     PRINTDEB\nBADDCB   DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+14(L'DCBERMSG),DCBERMSG\n         GDUMP R9,LINE+14+L'DCBERMSG\n         B     PRINTDEB\nBADTIOT  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+28(L'TIOERMSG),TIOERMSG\n         GDUMP R2,LINE+28+L'TIOERMSG\n         B     PRINTDEB\nBADJFCB  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+37(L'JFERRMSG),JFERRMSG\n         GDUMP R9,LINE+37+L'JFERRMSG\n         B     PRINTDEB\nPRINTDEB DS    0H\n         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME\n         B     NEXTDEB             GO TO NEXT DEB\nBADOTHER DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n******** B     NEXTDEB\nNEXTDEB  DS    0H\n         XR    R8,R8\n         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB\n         BZ    ENDDEB\n         B     DEBLOOP\nBADDEB   DS    0H                  ERROR ACCESSING DEB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'DEBERMSG),DEBERMSG\n         GDUMP R8,LINE+L'DEBERMSG\n         BAL   R14,OUTPUT\nENDDEB   DS    0H\nENDPROC  DS    0H\n         L     R14,PRCSSAVE        RETURN\n         BR    R14\n         EJECT\nDUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE\n*\n* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,\n* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.\n*\n         SPACE 1\n         ST    R14,DCDESAVE        SAVE RETURN REGISTER\n         ST    R10,DOUBLE          CDE ADDRESS\n         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP\n         USING CDENTRY,R10\n         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE\n         MVC   LNCDNAME(8),CDNAME   CDE NAME\n         MVC   LNCDEPEQ(3),=C'EP='\n         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE\n         TM    CDATTR,CDREN\n         BZ    NOTRENT\n         MVC   LNCDRENT,=C'RENT'\nNOTRENT  TM    CDATTR,CDSER\n         BZ    NOTREUS\n         MVC   LNCDREUS,=C'REUS'\nNOTREUS  TM    CDATTR2,CDEANYM\n         BZ    NOTANY\n         MVC   LNCDANY,=C'ANY'\nNOTANY   TM    CDATTR2,CDOLY\n         BZ    NOTOVLY\n         MVC   LNCDOVLY,=C'OVLY'\nNOTOVLY  TM    CDATTR2,CDSYSLIB\n         BZ    NOTSYSL\n         MVC   LNCDSYSL,=C'SYSLIB'\nNOTSYSL  TM    CDATTR2,CDAUTH\n         BZ    NOTAUTH\n         MVC   LNCDAUTH,=C'AUTH'\nNOTAUTH  DS    0H\n         B     OUTCDE\nBADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CDERRMSG),CDERRMSG\n         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS\nOUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME\n         L     R14,DCDESAVE        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         EJECT\nBAD21C   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER21CMSG),ER21CMSG\n         GDUMP R3,LINE+L'ER21CMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBAD218   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER218MSG),ER218MSG\n         GDUMP R3,LINE+L'ER218MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBAD224   DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER224MSG),ER224MSG\n         GDUMP R3,LINE+L'ER224MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADTCB   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'TCBERMSG),TCBERMSG\n         GDUMP R3,LINE+L'TCBERMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASCB  DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASCBEMSG),ASCBEMSG\n         GDUMP R3,LINE+L'ASCBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASXB  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASXBEMSG),ASXBEMSG\n         GDUMP R3,LINE+L'ASXBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADCVT   DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CVTEMSG),CVTEMSG\n         GDUMP R3,LINE+L'CVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADCASVT DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CASVEMSG),CASVEMSG\n         GDUMP R3,LINE+L'CASVEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nBADASVT  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASVTEMSG),ASVTEMSG\n         GDUMP R3,LINE+L'ASVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R14,FMSAVE\n         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON\n         BM    FMASIS              THEN\n         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD\nFMASIS   DS    0H\n         ICM   R15,15,WHRADDR\n         BNZ   FMGOTWHR\n         ST    R0,FMWORK\n         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF\n         ST    R0,WHRADDR\n         LR    R15,R0\n         L     R0,FMWORK\nFMGOTWHR DS    0H\n         L     R14,FIRSTTCB        Get address of first TCB\n         ST    R14,ADPLCOM1        Set first-TCB pointer for XIPSWHR\n         LR    R1,R4               POINT TO ABDPL\n         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME\n         CLI   ADPLFMT1,C' '       IF NOT FOUND...\n         BE    FMNF\n         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...\n         BE    FMERR\n         MVC   LINE+52(16),ADPLCOM1\n         B     FMRET\nFMERR    DS    0H\n         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '\n         B     FMRET\nFMNF     DS    0H\n         MVC   LINE+52(16),=CL16'(UNKNOWN)       '\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15\n         BNZ   RETURN0\n         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         ICM   R15,R15,WHRADDR\n         BZ    NODELETE\n         DELETE EPLOC==CL8'XIPSWHR'\nNODELETE DS    0H\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nHIMSG    DC    C'                 MAP FOR ASID '\nTCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '\nCMPMSG   DC    C'*** COMPCODE='\nRTM2MSG  DC    C' RTWA AT '\nRBMSG    DC    C'---MAPPING RBS - '\nJPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'\nLLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'\nNODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'\nDEBMSG   DC    C'---MAPPING DEBS - '\nTRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'\nTRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'\nER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'\nER224MSG DC    C'ERROR - ASCB UNAVAILABLE'\nTCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '\nASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '\nASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '\nRBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '\nCDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '\nLLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '\nDEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '\nDCBERMSG DC    C'DCB UNAVAILABLE AT '\nTIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '\nJFERRMSG DC    C'JFCB UNAVAILABLE AT '\nCVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '\nCASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '\nASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE\nDCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE\nFIRSTTCB DS    A                   Address of first TCB to search\n         SPACE 1\nCOPYTCB  DS    CL256               COPY OF MOST OF TCB\nCOPYDEB  DS    CL32                COPY OF MOST OF DEB\nRBPREFIX DS    CL32                COPY OF RB PREFIX\nCOPYRB   DS    CL64                COPY OF MOST OF RB\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER\nLINE     DS    CL132               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\nLNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK\n         DS    CL2\nLNCDNAME DS    CL8                 NAME\n         DS    CL3\nLNCDEPEQ DS    C'EP='              \"EP=\"\nLNCDEPA  DS    CL8                 ENTRY POINT\n         DS    CL3                 FOLLOWED BY ATTRIBUTES\nLNCDRENT DS    C'RENT'\n         DS    CL1\nLNCDREUS DS    C'REUS'\n         DS    CL1\nLNCDANY  DS    C'ANY'\n         DS    CL1\nLNCDOVLY DS    C'OVLY'\n         DS    CL1\nLNCDSYSL DS    C'SYSLIB'\n         DS    CL1\nLNCDAUTH DS    C'AUTH'\n         DS    CL1\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         BLSABDPL\n         SPACE 1\n         IHACDE\n         SPACE 1\n         END\n./ ADD NAME=XIPSWHR  0100-07332-07332-0900-00495-00495-00000-SEB\n         TITLE 'XIPSWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XIPSWHR - VERB EXIT SUBROUTINE TO LOCATE AN ADDRESS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE IS INVOKED FROM IPCS VERB EXITS TO RETURN           *\n* INFORMATION ABOUT AN ADDRESS.                                       *\n*                                                                     *\n* ON ENTRY REGISTER 1 POINTS TO THE ABDPL (EXIT PARAMETER LIST),      *\n*      AND REGISTER 0 CONTAINS THE ADDRESS TO BE SEARCHED FOR.        *\n*                                                                     *\n* In addition, the following field must be filled in by the caller:   *\n*                                                                     *\n*    ADPLCOM1 - 4 bytes - the address of the first TCB to search,     *\n*                         or zeroes if not known.                     *\n*                                                                     *\n* ON RETURN THE FOLLOWING FIELDS OF THE PARAMETER LIST ARE FILLED:    *\n*                                                                     *\n*    ADPLCOM1 - 8 BYTES - THE NAME OF THE MODULE IT WAS FOUND IN.     *\n*                                                                     *\n*    ADPLCOM3 - 8 BYTES - EBCDIC REPRESENTATION OF THE OFFSET,        *\n*                         INCLUDING LEADING PLUS SIGN.                *\n*                                                                     *\n*    ADPLFMT1 - ONE OF THE FOLLOWING 4-CHARACTER VALUES:              *\n*                                                                     *\n*    \"JPA \"  -  THE ADDRESS IS IN A MODULE IN THE JOB PACK AREA.      *\n*    \"PLPA\"  -  THE ADDRESS IS IN A PAGEABLE LINK PACK AREA MODULE.   *\n*    \"MLPA\"  -  THE ADDRESS IS IN A MODULE IN THE MLPA.               *\n*    \"NUC \"  -  THE ADDRESS IS IN THE NUCLEUS.                        *\n*    \"ERR \"  -  A STORAGE ERROR OCCURRED TRYING TO LOCATE IT.         *\n*    \"    \"  -  BLANK IF THE ADDRESS WAS NOT FOUND.                   *\n*                                                                     *\n*    ADPLFMT2 - THE BINARY VALUE OF THE OFFSET.                       *\n*                                                                     *\n* NOTE: THIS ROUTINE MUST BE INVOKED VIA LINK OR LOAD/BASSM,          *\n*       SINCE IT RUNS IN AMODE 31.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    INPUT ADDRESS TO BE SEARCHED FOR\nR6       EQU   6    POINTER TO TCB\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   .\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPSWHR  CSECT\nXIPSWHR  AMODE 31\nXIPSWHR  RMODE 24\n         SAVE  (14,12),,XIPSWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XIPSWHR,R12\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LR    R5,R0               SAVE INPUT ADDRESS PARAMETER\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         EJECT\n         N     R5,=X'7FFFFFFF'     CLEAR HIGH ORDER BIT OF ADDRESS\n         MVC   ADPLFMT1(4),=C'    '\n         EJECT\n*\n* If a TCB address has been provided by the caller, it will be in\n* the ADPLCOM1 field and nonzero.  In this case, use that as the\n* first TCB to search, since that should have been chosen to work\n* with the current ASID.\n*\n         ICM   R6,15,ADPLCOM1      Get communication word TCB address\n         BNZ   GOT1TCB             If provided, skip TCB search\n         EJECT\n*\n* We don't do this anymore.  Must go by current ASID.\n*\n* FIRST SEARCH THE JOB PACK AREA.\n*        SPACE 1\n*        LA    R6,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R6,4                GET PSATOLD FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB\n*        LTR   R6,R6               IF POINTER AT 21C IS ZEROES,\n*        BNZ   GOT1TCB             THEN...\n*        LA    R6,X'218'\n*        GSTOR R6,4                GET PSATNEW FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB\n*        LTR   R6,R6               IF POINTER AT 218 IS ZEROES,\n*        BNZ   GOT1TCB             THEN...\n*        LA    R6,X'224'            TRY VIA ASCB\n*        GSTOR R6,4                GET PSA'S ASCB PTR FROM DUMP\n*        L     R6,0(,R6)           ADDRESS OF CURRENT ASCB\n*        GSTOR R6,X'70'            GET CURRENT ASCB FROM DUMP\n*        L     R6,X'6C'(,R6)       GET POINTER TO ASXB\n*        GSTOR R6,8                GET ASXB FROM DUMP\n*        L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB\n*\n         L     R6,ADPLCVT          Get CVT pointer\n         LA    R6,X'22C'(,R6)      CVT+22C -> ASVT\n         GSTOR R6,4                Get loc of CVT's ASVT ptr from dump\n         L     R6,0(,R6)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R6,X'20C'(R2,R6)    Point to ASCB address for this ASID\n         GSTOR R6,4                Get ASCB address from dump\n         L     R6,0(,R6)           Load the ASCB address\n         GSTOR R6,X'70'            Get the ASCB from dump\n         L     R6,X'6C'(,R6)       GET POINTER TO ASXB\n         GSTOR R6,8                GET ASXB FROM DUMP\n         L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB\n*\nGOT1TCB  DS    0H                  SCAN FOR TOP TCB\n         SPACE 1\n         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP\n         USING TCB,R6\n*\n* WE DON'T GO DIRECTLY TO THE JOB STEP TCB ANY MORE, SINCE UNDER\n* PIE/SESSIONS THERE MAY BE MORE THAN ONE.  INSTEAD, WE GO TO THE\n* TOP OF THE TCB TREE EVERY TIME, AND THEN DESCEND LEVELS UNTIL\n* WE FIND THE LEVEL WITH THE JOB STEP TCB'S.  ALL THE SISTERS IN\n* THAT LEVEL ARE THEN PROCESSED.\n*\n****     LA    R6,TCBJSTCB         POINTER TO JOB STEP TCB\n****     GSTOR R6,4                GET TCBJSTCB FROM DUMP\n****     L     R6,0(,R6)           ADDRESS OF JOB STEP TCB\n****     GSTOR R6,X'A0'            GET MOST OF JSTCB FROM DUMP\n****     L     R7,TCBJPQ           ADDRESS OF FIRST CDE IN JOB PACK Q\n****     LTR   R7,R7               IF NO CDE'S IN JOB PACK QUEUE\n****     BNZ   LOOPCDE             THEN...\n*\n* IF JSTCB HAS NO JOB PACK QUEUE, THIS MAY BE A DUMP OF JES2 OR\n* SOMETHING WHERE THE JSTCB IS NOT THE TCB WITH THE JPQ.  WE MUST\n* THEN SEARCH FOR THE TCB WITH THE GOODS.\n*\nFINDTOP  DS    0H\n         L     R7,TCBOTC           GET ADDRESS OF MOTHER TCB\n         LTR   R7,R7               IF ZERO, THEN...\n         BZ    TRYJPQ               THIS IS THE TOP TCB\n         LR    R6,R7               ELSE GET ADDRESS OF THIS TCB\n         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP\n         B     FINDTOP             CONTINUE SEARCHING FOR TOP TCB\nTRYJPQ   DS    0H                  R6 --> TOP TCB FROM DUMP\n         MVC   COPYTCB(X'A0'),0(R6)\n         LA    R6,COPYTCB\n         L     R7,TCBJPQ           OK, TRY THE JOB PACK QUEUE HERE\n         LTR   R7,R7               IF WE GOT ONE,\n         BNZ   LOOPCDE             THEN GO TO SCAN IT.\n         L     R7,TCBLTC           ELSE GET NEXT DAUGHTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    ENDCDE              THEN GIVE UP, NO JOB PACK FOUND\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         B     TRYJPQ              AND TRY IT AGAIN.\nLOOPCDE  DS    0H                  LOOP THROUGH CDE'S\n         LTR   R7,R7               UNTIL NO MORE\n         BZ    ENDCDE\n         GSTOR R7,32               GET CDE FROM DUMP\n         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA\n         LA    R7,COPYCDE\n         USING CDENTRY,R7\n         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,\n         BO    CONTCDE             THEN SKIP IT\n         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST\n         LTR   R3,R3               IF NONE\n         BZ    CONTCDE             THEN SKIP THIS CDE, GO TO NEXT ONE\n         GSTOR R3,16               GET XTLST FROM DUMP\n         USING XTLST,R3\n         L     R0,XTLMSBAA         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         XR    R1,R1\n         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTCDE             THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTCDE             THEN THIS IS NOT THE ONE\n         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'JPA ' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT              GO TO FORMAT OFFSET AND RETURN\nCONTCDE  DS    0H\n         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN\n         B     LOOPCDE             CONTINUE LOOPING\nENDCDE   DS    0H                  SCANNED ALL OF JPQ - NOT FOUND YET\n         SPACE 1\nJSSISTER DS    0H\n         L     R7,TCBNTC           GET SISTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    NOSISTER            THEN THROUGH WITH SISTER TASKS\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         MVC   COPYTCB(X'A0'),0(R6)\n         LA    R6,COPYTCB\n         L     R7,TCBJPQ           TRY THE JOB PACK QUEUE HERE\n         LTR   R7,R7               IF WE GOT ONE,\n         BNZ   LOOPCDE             THEN GO TO SCAN IT\n         B     JSSISTER            ELSE TRY NEXT SISTER\nNOSISTER DS    0H\n         L     R7,TCBLTC           GET NEXT DAUGHTER TASK\n         LTR   R7,R7               IF NONE,\n         BZ    ENDJSTS             THEN GIVE UP, NO JOB PACK FOUND\n         LR    R6,R7               ELSE...\n         GSTOR R6,X'A0'            GET IT FROM THE DUMP\n         B     TRYJPQ              AND TRY IT AGAIN.\nENDJSTS  DS    0H                  NO MORE JOB STEP TCB'S\n         EJECT\n* THEN SEARCH THE LINK PACK AREA.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTLPDIR         POINTER TO LPA DIRECTORY\n         GSTOR R3,3                GET CVTLPDIR FROM DUMP\n         XR    R7,R7\n         ICM   R7,7,0(R3)          ADDRESS OF LPA DIRECTORY\n         USING LPDE,R7\nLOOPLPDE DS    0H                  LOOP THROUGH LPDE'S\n         LA    R2,LPDEXTAD+4       GET TRUE ADDR OF NEXT LPDE IN CHAIN\n         GSTOR R7,40               GET LPA DIRECTORY FROM DMP\n         ICM   R0,15,LPDENTP       UNTIL NO MORE\n         BZ    ENDLPDE\n         TM    LPDEATTR,LPDEMIN    IF THIS IS A MINOR LPDE,\n         BO    CONTLPDE            THEN SKIP IT\n         L     R0,LPDEXTAD         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         ICM   R1,15,LPDEXTLN      GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTLPDE            THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTLPDE            THEN THIS IS NOT THE ONE\n         LR    R1,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R1,R0                GIVES OFFSET WITHIN PLPA MODULE\n         ST    R1,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'PLPA' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),LPDENAME PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nCONTLPDE DS    0H\n         LR    R7,R2               GET (SAVED) ADDRESS OF NEXT LPDE\n         B     LOOPLPDE            CONTINUE LOOPING\nENDLPDE  DS    0H                  SCANNED ALL PLPA - NOT FOUND YET\n         EJECT\n* THEN SEARCH THE MLPA.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTQLPAQ         POINTER TO MLPA CDE'S\n         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP\n         L     R3,0(,R3)           ADDRESS OF POINTER TO 1ST LPA Q CDE\n         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP\n         L     R7,0(,R3)           ADDRESS OF FIRST CDE IN LPA Q\nLOOPMLPA DS    0H                  LOOP THROUGH CDE'S\n         LTR   R7,R7               UNTIL NO MORE\n         BZ    ENDMLPA\n         GSTOR R7,32               GET CDE FROM DUMP\n         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA\n         LA    R7,COPYCDE\n         USING CDENTRY,R7\n         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,\n         BO    CONTMLPA            THEN SKIP IT\n         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST\n         GSTOR R3,16               GET XTLST FROM DUMP\n         USING XTLST,R3\n         L     R0,XTLMSBAA         GET LOAD POINT\n         N     R0,=X'7FFFFFFF'\n         XR    R1,R1\n         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH\n         ALR   R1,R0               CONVERT IT TO LOAD END POINT\n         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT\n         BH    CONTMLPA            THEN THIS IS NOT THE ONE\n         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END\n         BNH   CONTMLPA            THEN THIS IS NOT THE ONE\n         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'MLPA' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nCONTMLPA DS    0H\n         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN\n         B     LOOPMLPA            CONTINUE LOOPING\nENDMLPA  DS    0H                  SCANNED ALL MLPA - NOT FOUND YET\n         EJECT\n* THEN SEARCH THE NUCLEUS MAP.\n         SPACE 1\n         L     R3,ADPLCVT          ADDRESS OF CVT\n         USING CVT,R3\n         LA    R3,CVTNUCMP         POINTER TO NUCLEUS MAP\n         GSTOR R3,4                GET ADDR OF NUCMAP FROM DUMP\n         L     R3,0(,R3)           ADDRESS OF NUCMAP\n         LR    R2,R5               SET ADDRESS FOR COMPARISONS\n         LR    R7,R3               SAVE DUMP ADDRESS\n         GSTOR R3,16               GET NUCMAP HEADER FROM DUMP\n         L     R9,X'08'(,R3)       GET ADDRESS OF LAST NUCMAP ENTRY\n         LA    R8,16               SET NUCMAP ENTRY INCREMENT\nLOOPNUC  DS    0H                  LOOP THROUGH CDE'S\n         BXH   R7,R8,ENDNUC        BUMP TO NEXT NUCMAP ENTRY UNTIL LAST\n         LR    R3,R7               GET ADDRESS OF NUCMAP ENTRY\n         GSTOR R3,16               GET NUCMAP ENTRY FROM DUMP\n         TM    X'0C'(R3),X'10'     IF THIS IS NOT A CSECT ENTRY\n         BNO   LOOPNUC             THEN CONTINUE\n         L     R0,X'08'(,R3)       GET LOCATION OF NUCLEUS CSECT\n         CR    R2,R0               IF ADDRESS LESS THAN NUC CSECT LOC\n         BL    LOOPNUC             THEN THIS IS NOT THE ONE\n         XR    R1,R1\n         ICM   R1,7,X'0D'(R3)      GET LENGTH\n         ALR   R1,R0               ADD LOC GIVING END POINT\n         CR    R2,R1               IF ADDRESS NOT LESS THAN END POINT\n         BNL   LOOPNUC             THEN THIS IS NOT THE ONE\n*                                  ELSE ADDRESS MINUS LOAD POINT\n         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE\n         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'NUC ' TELL WHERE IT WAS FOUND\n         MVC   ADPLCOM1(8),0(R3)    PUT MODULE NAME IN RETURN FIELD\n         B     FORMAT\nENDNUC   DS    0H\n         SPACE 1\n* IF ALL FAILS, NOT FOUND.\n         SPACE 1\n         B     NOTFOUND\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         SPACE 1\n         MVC   ERRBUG(L'BUGMSG),BUGMSG\n         STCM  R0,15,OFFWORK\n         UNPK  ERRWORK(9),OFFWORK(5)\n         TR    ERRWORK(8),HEXTBL\n         MVI   ERRWORK+8,C' '\n         LA    R1,ERRBUG\n         LA    R0,L'ERRBUG\n         TPUT  (1),(0),R\n         SPACE 1\n         XR    R2,R2\n         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'ERR ' TELL WHY IT WAS NOT FOUND\n         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD\n         MVC   ADPLCOM1+1(7),ADPLCOM1\n         B     FORMAT\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         XR    R2,R2\n         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD\n         MVC   ADPLFMT1(4),=C'    ' TELL WHERE IT WAS NOT FOUND\n         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD\n         MVC   ADPLCOM1+1(7),ADPLCOM1\n         B     FORMAT\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BASSM R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nFORMAT   DS    0H                  FORMAT OFFSET AND RETURN\n         MVI   ADPLCOM3,C'+'       BEGIN FORMATTING OFFSET FIELD\n         MVI   ADPLCOM3+1,C' '     CLEAR OFFSET RETURN FIELD TO BLANKS\n         MVC   ADPLCOM3+2(6),ADPLCOM3+1\n         UNPK  OFFWORK(7),ADPLFMT2+1(4) FORMAT OFFSET FIELD IN WORKAREA\n         TR    OFFWORK(6),HEXTBL\n         LA    R0,5                SKIP OVER LEADING ZEROES\n         LA    R1,OFFWORK\nOFFLOOP  DS    0H\n         CLI   0(R1),C'0'\n         BNE   OFFEND\n         LA    R1,1(,R1)\n         BCT   R0,OFFLOOP\nOFFEND   DS    0H\n         LA    R15,OFFWORK+5\n         SR    R15,R1\n         EX    R15,OFFMOVE\n         B     RETURN\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BSM   0,R14               RETURN IN CALLER'S ADDRESSING MODE\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\nOFFMOVE  MVC   ADPLCOM3+1(*-*),0(R1) MOVE FORMATTED OFFSET TO FIELD\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nBUGMSG   DC    C'XIPSWHR: STORAGE NOT AVAILABLE AT ADDRESS '\nERRMSG   DC    C'XIPSWHR: ERROR ACCESSING STORAGE IN MODULE SEARCH.'\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nCOPYCDE  DS    CL32                WORK AREA FOR CDE'S\nCOPYTCB  DS    CL(X'A0')           WORK AREA FOR TCB'S\nOFFWORK  DS    CL8                 WORK AREA TO BUILD OFFSET\nERRBUG   DS    CL(L'BUGMSG+9)\nERRWORK  EQU   *-9,9,C'C'\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL132               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XIPWHR   0100-07332-07332-0900-00322-00322-00000-SEB\n         TITLE 'XIPWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XIPWHR - IPCS VERB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXIPWHR   CSECT\n         SAVE  (14,12),,XIPWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XIPWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* EXTRACT THE PARAMETER (MUST BE AN ADDRESS).\n         SPACE 1\n         L     R5,ADPLOPTR         GET ADDRESS OF OPERAND FIELD\n         LTR   R5,R5               IF ZERO,\n         BZ    MISSING              THEN MISSING\n         LH    R6,ADPLOPLN         GET LENGTH OF OPERAND FIELD\n         LTR   R6,R6               IF ZERO,\n         BNP   MISSING              THEN MISSING\n         LA    R1,0(R5,R6)         POINT TO END OF OPERAND FIELD\n         BCTR  R1,0                POINT TO LAST CHARACTER OF OPERAND\n         CLI   0(R1),C'.'          IF A PERIOD\n         BNE   NOTPD               THEN\n         BCTR  R6,0                 REDUCE LENGTH BY 1\nNOTPD    LTR   R6,R6               IF REMAINING LENGTH IS ZERO\n         BNP   INVALID             THEN BAD ADDRESS\n         CH    R6,=H'8'            IF MORE THAN 8 CHARACTERS,\n         BH    TOOLONG              THEN TOO LONG\n         BCTR  R6,0                ELSE REDUCE FOR EXECUTES\n         EX    R6,TRTOP            SCAN FOR VALID HEX CHARACTERS\n         BNZ   INVALID             IF BAD CHARACTERS, INVALID\n         EX    R6,MVCOP            ELSE MOVE OPERAND TO SAFE AREA\n         EX    R6,TROP             TRANSLATE ABCDEF TO FAFBFCFDFEFF\n         LA    R6,1(,R6)           ADD 1 FOR PACKING EXTRA BYTE\n         EX    R6,PACKOP           CREATE FULLWORD HEX ADDRESS FIELD\n*                                  THIS SETS FIELD \"ADDRESS\"\n         EJECT\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear XIPSWHR communication word\n         L     R0,ADDRESS          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         UNPK  LINE+00(9),ADDRESS(5)\n         TR    LINE+00(8),HEXTBL\n         MVI   LINE+08,C'.'\n         CLC   ADPLFMT1(4),=C'    '\n         BE    NOTFOUND\n         CLC   ADPLFMT1(4),=C'JPA '\n         BE    INJPA\n         CLC   ADPLFMT1(4),=C'PLPA'\n         BE    INPLPA\n         CLC   ADPLFMT1(4),=C'MLPA'\n         BE    INMLPA\n         CLC   ADPLFMT1(4),=C'NUC '\n         BE    INNUC\n         CLC   ADPLFMT1(4),=C'ERR '\n         BE    INERROR\n         B     INLIMBO\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NFMSG),NFMSG\n         B     ERROUT\n         EJECT\nINERROR  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'ERMSG),ERMSG\n         B     ERROUT\n         SPACE 1\nINVALID  MVC   LINE(L'INVMSG),INVMSG\n         B     ERROUT\n         SPACE 1\nTOOLONG  MVC   LINE(L'TLMSG),TLMSG\n         B     ERROUT\n         SPACE 1\nMISSING  MVC   LINE(L'MISSMSG),MISSMSG\n         B     ERROUT\n         SPACE 1\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERMSG),ERMSG\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nINJPA    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'JPAMSG),JPAMSG\n         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'JPAMSG+08,C' '\n         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'JPAMSG+10,C' '\n         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINPLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'PLPAMSG),PLPAMSG\n         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'PLPAMSG+08,C' '\n         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'PLPAMSG+10,C' '\n         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINMLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'MLPAMSG),MLPAMSG\n         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'MLPAMSG+08,C' '\n         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'MLPAMSG+10,C' '\n         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINNUC    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NUCMSG),NUCMSG\n         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'NUCMSG+08,C' '\n         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'NUCMSG+10,C' '\n         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINLIMBO  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG\n         MVC   LINE+09+LIMBOFF(4),ADPLFMT1\n         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'LIMBOMSG+08,C' '\n         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'LIMBOMSG+10,C' '\n         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\nTRTOP    TRT   0(*-*,R5),VALTBL    SCAN FOR VALID HEX CHARACTERS\nMVCOP    MVC   OPWORK(*-*),0(R5)   MOVE OPERAND TO SAFE AREA\nTROP     TR    OPWORK(0),FTBL      TRANSLATE ABCDEF TO FAFBFCFDFEFF\nPACKOP   PACK  ADDRESS(5),OPWORK(0) CREATE BINARY VALUE FROM OPERAND\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nMISSMSG  DC    C'ADDRESS OPERAND MISSING'\nTLMSG    DC    C'ADDRESS OPERAND TOO LONG'\nINVMSG   DC    C'ADDRESS OPERAND SYNTAX ERROR'\nJPAMSG   DC    C'  FOUND IN JPA MODULE '\nPLPAMSG  DC    C'  FOUND IN PLPA MODULE '\nMLPAMSG  DC    C'  FOUND IN MLPA MODULE '\nNUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '\nNFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'\nERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'\nLIMBOMS1 DC    C'  FOUND IN '\nLIMBOMS2 DC    CL4'    '\nLIMBOMS3 DC    C' MODULE '\nLIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'\nLIMBOFF  EQU   LIMBOMS2-LIMBOMS1\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nADDRESS  DS    A                   THE ADDRESS TO BE SEARCHED ON\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XITMAP   0100-07332-07332-0900-00676-00676-00000-SEB\n         TITLE 'XITMAP - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         EJECT\n         MACRO\n&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE\n         AIF   ('&REG' EQ '*').NOSTORE\n&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED\n         AGO   .AFT\n.NOSTORE ANOP\n&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED\n.AFT     ANOP\n         UNPK  &PLACE.(9),&STG.(5)\n         TR    &PLACE.(8),HEXTBL\n         MVI   &PLACE.+8,C&FILL\n         MEND\n         TITLE 'XITMAP - IPCS TCB EXIT TO MAP RB CONTROL BLOCKS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    TCB POINTER\nR4       EQU   4    ABDPL ADDRESS\nR5       EQU   5    LLS POINTER\nR6       EQU   6    RB POINTER\nR7       EQU   7    CDE POINTER\nR8       EQU   8    DEB POINTER\nR9       EQU   9    DCB POINTER\nR10      EQU   10   JPQ POINTER\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITMAP   CSECT\n         SAVE  (14,12),,XITMAP-&SYSDATE-&SYSTIME\n         LR    R12,R15\n         USING XITMAP,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO\n         USING LINEDSCT,R11            OUTPUT BUFFER\n         XC    WHRADDR,WHRADDR\n         XC    FIRSTTCB,FIRSTTCB\n         EJECT\n         L     R3,ADPLTCB          GET TCB PASSED FOR TCB EXIT\n         LTR   R3,R3               IF TCB ADDRESS IS ZERO\n         BZ    SCANTREE            THEN SCAN TCB TREE FOR ALL TASKS,\n         BAL   R14,PROCESS         ELSE JUST PROCESS THIS ONE\n         B     RETURN0             AND RETURN.\n         SPACE 1\nSCANTREE DS    0H                  PROCESS ALL TCB'S...\n*\n*\n* Instead of using the low-core pointer to get to the TCB,\n* use the ASID to locate the ASCB (via the ASVT) and get the\n* first TCB from there.  In that way, setting the ASID via\n* SETDEF will affect which address space gets mapped.\n*\n*        LA    R3,X'21C'           ADDRESS OF CVTTCBP\n*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY218),TRY218\n*        BAL   R14,OUTPUT\n*        LA    R3,X'218'\n*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB\n*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,\n*        BNZ   FINDTOP             THEN...\n*        MVI   LINE,C' '\n*        MVC   LINE+1(L'LINE-1),LINE\n*        MVC   LINE(L'TRY224),TRY224\n*        BAL   R14,OUTPUT\n*\n* Try to get ASCB.  Instead of relying on the low-core pointer,\n* use the ASID to locate it via the ASVT.  In that way, setting\n* the ASID with SETDEF will cause this exit to pick up the right one.\n*\n*----------------------------------------------------------------------\n*        LA    R3,X'224'            TRY VIA ASCB\n*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP\n*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB\n*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP\n*----------------------------------------------------------------------\n         L     R3,ADPLCVT          Get CVT pointer\n         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT\n         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump\n         L     R3,0(,R3)           Load address of CVT's ASVT pointer\n         LH    R2,ADPLASID         Get the current ASID\n         SLA   R2,2                Multiply by 4 making index into ASVT\n         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID\n         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump\n         L     R3,0(,R3)           Load the ASCB address\n         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump\n         L     R3,X'6C'(,R3)       GET POINTER TO ASXB\n         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP\n         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB\n         ST    R3,FIRSTTCB         Save for future module findings\nFINDTOP  DS    0H                  SCAN FOR TOP TCB\n         LR    R2,R3               SAVE ACTUAL TCB ADDRESS\n         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP\n         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB\n         BZ    USETCB              IF NONE, THIS IS THE TOP TCB\n         LR    R3,R15              IF THERE IS A MOTHER,\n         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT\nUSETCB   DS    0H                  START WITH THIS TCB\n         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN\n         SPACE 1\n*******                            (WE DON'T DO THIS ANY MORE)\n*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB\n*******\n*\n         BAL   R14,OUTPUT          Print a blank line\n         MVC   LINE(L'HIMSG),HIMSG\n         LH    R2,ADPLASID\n         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID\n         BAL   R14,OUTPUT          PRINT \"HI THERE\" MESSAGE\n         BAL   R14,OUTPUT          Print a blank line\n*\nDOIT     DS    0H\n         BAL   R14,PROCESS\n         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB\n         BNZ   DOIT\nNODTR    DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'80' SISTER TCB\n         BNZ   DOIT\nNOSISTER DS    0H                  ELSE\n         ICM   R3,15,COPYTCB+X'84' MOTHER TCB\n         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE\n         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP\n         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE\n         B     NODTR               PROCESS ITS SISTER, ETC.\nNOMORE   DS    0H\n         B     RETURN0\n         EJECT\nPROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED\n         SPACE\n         ST    R14,PRCSSAVE        SAVE RETURN REGISTER\n         BAL   R14,OUTPUT          PRINT A BLANK LINE\n         MVC   LINE(L'TCBMSG),TCBMSG\n         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING TCB\"\n         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP\n         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE\n         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE\n         BZ    NOTCBCMP            IF THERE IS ONE, THEN...\n         MVC   LINE(L'CMPMSG),CMPMSG\n         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT\n         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG\n         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA\n         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT\n         BAL   R14,OUTPUT          PRINT COMPLETION CODE\nNOTCBCMP DS    0H\n         L     R6,COPYTCB+0        ADDRESS OF RB\n         MVC   LINE(L'RBMSG),RBMSG\n         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS\n         BAL   R14,OUTPUT          PRINT \"PROCESSING RB\"\nRBLOOP   DS    0H\n         LR    R2,R6               SAVE TRUE RB ADDRESS\n         SH    R6,=H'32'           POINT TO RB PREFIX\n         BM    BADRB               IF IT MAKES IT GO NEGATIVE, BAD ADDR\n         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP\n         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT\n         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS\n         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE\n         BZ    PRB\n         BO    SVRB\n         LA    R1,=CL8'(IRB)'\n         B     RBTYPE\nSVRB     LA    R1,=CL8'(SVRB)'\nRBTYPE   DS    0H\n         MVC   LINE+10(8),0(R1)    MOVE RB TYPE\n         B     RBOUT\nPRB      DS    0H\n         XR    R7,R7\n         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE\n         BNZ   GOTACDE             IF ZERO, THEN...\n         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO\n         BZ    NOCDE                 THEN\n         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO\n         B     RBOUT                 ELSE\nNOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE\n         B     RBOUT\nGOTACDE  DS    0H\n         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE\n         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP\n         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME\nRBOUT    DS    0H\n         MVC   LINE+21(4),=C'INT='\n         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE\n         TR    LINE+25(2),HEXTBL\n         MVI   LINE+27,C' '\n         MVC   LINE+29(4),=C'PSW='\n         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW\n         TR    LINE+33(8),HEXTBL\n         MVI   LINE+41,C' '\n         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW\n         TR    LINE+42(8),HEXTBL\n         MVI   LINE+50,C' '\n         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW\n         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS\n         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB\nRBNEXT   DS    0H\n         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB\n         BO    ENDRB               THEN NO MORE RB'S. ELSE\n         XR    R6,R6\n         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB\n         B     RBLOOP\nBADRB    DS    0H                  RB STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'RBERRMSG),RBERRMSG\n         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB\n         BAL   R14,OUTPUT\nENDRB    DS    0H\n         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE\n         BZ    ENDCDE\n         MVC   LINE(L'JPQMSG),JPQMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING JOB PACK QUEUE\"\nCDELOOP  DS    0H\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\n         ICM   R10,15,0(R10)\n         BNZ   CDELOOP\nENDCDE   DS    0H\nTCB2LOOP DS    0H\n         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS\n         BZ    ENDLLS\n         MVC   LINE(L'LLSMSG),LLSMSG\n         BAL   R14,OUTPUT          PRINT \"MAPPING LOAD LIST\"\nLLSLOOP  DS    0H\n         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP\n         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS\n         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY\n         BAL   R14,DUMPCDE         WRITE OUT CDE INFO\nNEXTLLS  DS    0H\n         LTR   R5,R2               GET ADDRESS OF NEXT LLS\n         BZ    ENDLLS\n         B     LLSLOOP\nBADLLS   DS    0H                  ERROR ACCESSING LLS\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'LLSERMSG),LLSERMSG\n         GDUMP R5,LINE+L'LLSERMSG\n         BAL   R14,OUTPUT\n         SPACE 1\nENDLLS   DS    0H\n         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB\n         BNZ   GOTDEBS\n         MVC   LINE(L'NODEBS),NODEBS\n         BAL   R14,OUTPUT          PRINT \"NO OPEN DATA SETS\"\n         B     ENDDEB\nGOTDEBS  DS    0H\n         MVC   LINE(L'DEBMSG),DEBMSG\n         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB\n         BAL   R14,OUTPUT          PRINT \"MAPPING DEB CHAIN\"\nDEBLOOP  DS    0H\n         MVC   LINE(4),=C'DEB='\n         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB\n         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP\n         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT\n         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB\n         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE\n         MVC   LINE+14(4),=C'DCB='\n         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB\n         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP\n         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT\n         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB\n         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP\n         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT\n         MVI   LINE+36,C' '\n         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT\n         LA    R9,X'10'(,R9)       ADDRESS OF JFCB\n         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP\n         MVC   LINE+37(44),0(R9)   DSNAME\n         LA    R1,LINE+37+44-1\nDSNLOOP  CLI   0(R1),C' '\n         BNE   DSNEND\n         BCTR  R1,0\n         B     DSNLOOP\nDSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME\n         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB\n         BE    NOMEMBER            THEN\n         MVI   1(R1),C'('\n         MVC   2(8,R1),44(R9)\n         LA    R1,9(,R1)\nMEMLOOP  CLI   0(R1),C' '\n         BNE   MEMEND\n         BCTR  R1,0\n         B     MEMLOOP\nMEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER\n         LA    R1,1(,R1)\n         MVI   0(R1),C')'\nNOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK\n         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,\n         BZ    PRINTDEB            THEN...\n         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW\n         B     PRINTDEB\nBADDCB   DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+14(L'DCBERMSG),DCBERMSG\n         GDUMP R9,LINE+14+L'DCBERMSG\n         B     PRINTDEB\nBADTIOT  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+28(L'TIOERMSG),TIOERMSG\n         GDUMP R2,LINE+28+L'TIOERMSG\n         B     PRINTDEB\nBADJFCB  DS    0H                  ERROR ACCESSING DCB\n         MVC   LINE+37(L'JFERRMSG),JFERRMSG\n         GDUMP R9,LINE+37+L'JFERRMSG\n         B     PRINTDEB\nPRINTDEB DS    0H\n         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME\n         B     NEXTDEB             GO TO NEXT DEB\nBADOTHER DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n******** B     NEXTDEB\nNEXTDEB  DS    0H\n         XR    R8,R8\n         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB\n         BZ    ENDDEB\n         B     DEBLOOP\nBADDEB   DS    0H                  ERROR ACCESSING DEB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'DEBERMSG),DEBERMSG\n         GDUMP R8,LINE+L'DEBERMSG\n         BAL   R14,OUTPUT\nENDDEB   DS    0H\nENDPROC  DS    0H\n         L     R14,PRCSSAVE        RETURN\n         BR    R14\n         EJECT\nDUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE\n*\n* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,\n* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.\n*\n         SPACE 1\n         ST    R14,DCDESAVE        SAVE RETURN REGISTER\n         ST    R10,DOUBLE          CDE ADDRESS\n         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP\n         USING CDENTRY,R10\n         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE\n         MVC   LNCDNAME(8),CDNAME   CDE NAME\n         MVC   LNCDEPEQ(3),=C'EP='\n         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE\n         TM    CDATTR,CDREN\n         BZ    NOTRENT\n         MVC   LNCDRENT,=C'RENT'\nNOTRENT  TM    CDATTR,CDSER\n         BZ    NOTREUS\n         MVC   LNCDREUS,=C'REUS'\nNOTREUS  TM    CDATTR2,CDEANYM\n         BZ    NOTANY\n         MVC   LNCDANY,=C'ANY'\nNOTANY   TM    CDATTR2,CDOLY\n         BZ    NOTOVLY\n         MVC   LNCDOVLY,=C'OVLY'\nNOTOVLY  TM    CDATTR2,CDSYSLIB\n         BZ    NOTSYSL\n         MVC   LNCDSYSL,=C'SYSLIB'\nNOTSYSL  TM    CDATTR2,CDAUTH\n         BZ    NOTAUTH\n         MVC   LNCDAUTH,=C'AUTH'\nNOTAUTH  DS    0H\n         B     OUTCDE\nBADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CDERRMSG),CDERRMSG\n         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS\nOUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME\n         L     R14,DCDESAVE        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         EJECT\nBAD21C   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER21CMSG),ER21CMSG\n         GDUMP R3,LINE+L'ER21CMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBAD218   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER218MSG),ER218MSG\n         GDUMP R3,LINE+L'ER218MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBAD224   DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ER224MSG),ER224MSG\n         GDUMP R3,LINE+L'ER224MSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADTCB   DS    0H                  ERROR ACCESSING TCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'TCBERMSG),TCBERMSG\n         GDUMP R3,LINE+L'TCBERMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASCB  DS    0H                  ERROR ACCESSING ASCB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASCBEMSG),ASCBEMSG\n         GDUMP R3,LINE+L'ASCBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASXB  DS    0H                  ERROR ACCESSING ASXB\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASXBEMSG),ASXBEMSG\n         GDUMP R3,LINE+L'ASXBEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADCVT   DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CVTEMSG),CVTEMSG\n         GDUMP R3,LINE+L'CVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADCASVT DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'CASVEMSG),CASVEMSG\n         GDUMP R3,LINE+L'CASVEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nBADASVT  DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ASVTEMSG),ASVTEMSG\n         GDUMP R3,LINE+L'ASVTEMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE(L'ERRMSG),ERRMSG\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R14,FMSAVE\n         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON\n         BM    FMASIS              THEN\n         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD\nFMASIS   DS    0H\n         ICM   R15,15,WHRADDR\n         BNZ   FMGOTWHR\n         ST    R0,FMWORK\n         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF\n         ST    R0,WHRADDR\n         LR    R15,R0\n         L     R0,FMWORK\nFMGOTWHR DS    0H\n         L     R14,FIRSTTCB\n         ST    R14,ADPLCOM1        Get first TCB address for XIPSWHR\n         LR    R1,R4               POINT TO ABDPL\n         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME\n         CLI   ADPLFMT1,C' '       IF NOT FOUND...\n         BE    FMNF\n         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...\n         BE    FMERR\n         MVC   LINE+52(16),ADPLCOM1\n         B     FMRET\nFMERR    DS    0H\n         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '\n         B     FMRET\nFMNF     DS    0H\n         MVC   LINE+52(16),=CL16'(UNKNOWN)       '\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15\n         BNZ   RETURN0\n         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         ICM   R15,R15,WHRADDR\n         BZ    NODELETE\n         DELETE EPLOC==CL8'XIPSWHR'\nNODELETE DS    0H\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nHIMSG    DC    C'                 MAP FOR ASID '\nTCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '\nCMPMSG   DC    C'*** COMPCODE='\nRTM2MSG  DC    C' RTM2 AT '\nRBMSG    DC    C'---MAPPING RBS - '\nJPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'\nLLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'\nNODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'\nDEBMSG   DC    C'---MAPPING DEBS - '\nTRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'\nTRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'\nER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'\nER224MSG DC    C'ERROR - ASCB UNAVAILABLE'\nTCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '\nASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '\nASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '\nRBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '\nCDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '\nLLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '\nDEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '\nDCBERMSG DC    C'DCB UNAVAILABLE AT '\nTIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '\nJFERRMSG DC    C'JFCB UNAVAILABLE AT '\nCVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '\nCASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '\nASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE\nDCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE\nFIRSTTCB DS    A                   First TCB address\n         SPACE 1\nCOPYTCB  DS    CL256               COPY OF MOST OF TCB\nCOPYDEB  DS    CL32                COPY OF MOST OF DEB\nRBPREFIX DS    CL32                COPY OF RB PREFIX\nCOPYRB   DS    CL64                COPY OF MOST OF RB\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER\nLINE     DS    CL132               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\nLNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK\n         DS    CL2\nLNCDNAME DS    CL8                 NAME\n         DS    CL3\nLNCDEPEQ DS    C'EP='              \"EP=\"\nLNCDEPA  DS    CL8                 ENTRY POINT\n         DS    CL3                 FOLLOWED BY ATTRIBUTES\nLNCDRENT DS    C'RENT'\n         DS    CL1\nLNCDREUS DS    C'REUS'\n         DS    CL1\nLNCDANY  DS    C'ANY'\n         DS    CL1\nLNCDOVLY DS    C'OVLY'\n         DS    CL1\nLNCDSYSL DS    C'SYSLIB'\n         DS    CL1\nLNCDAUTH DS    C'AUTH'\n         DS    CL1\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         BLSABDPL\n         SPACE 1\n         IHACDE\n         SPACE 1\n         END\n./ ADD NAME=XITSAV   0100-07332-07332-0900-00437-00437-00000-SEB\n         TITLE 'XITSAV - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   ('&LENGTH' EQ '(0)').GOTLEN\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)\nR8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA\nR9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITSAV   CSECT\n         SAVE  (14,12),,XITSAV_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XITSAV,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\nPROCESS  DS    0H\n         SPACE 1\n         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE\n         ST    R0,WHRADDR\n         SPACE 1\n         L     R3,ADPLTCB          R3 = ADDRESS OF TCB\n         USING TCB,R3\n         XR    R7,R7               INITIALIZE HSA POINTER\n         LA    R3,TCBFSA           POINTER TO ADDRESS OF FIRST SAVEAREA\n         GSTOR R3,4                GET TCBFSA FROM DUMP\n         ICM   R3,15,0(R3)         ADDRESS OF FIRST SAVE AREA\n         BNZ   LOOP                IF NONE, THEN...\n         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nLOOP     DS    0H\n         LTR   R3,R3               UNTIL NO MORE\n         BZ    ENDLOOP\n         MVC   LINE(L'SAMSG),SAMSG \"SAVE AREA AT \"\n         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA\n         ST    R8,OPWORK           DISPLAY IT\n         UNPK  LINESAA+0(9),OPWORK(5)\n         TR    LINESAA+0(8),HEXTBL\n         MVI   LINESAA+8,C'.'\n         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP\n         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA\nCONTLOOP DS    0H\n         SPACE\n         MVC   LINEL1(4),=C'WD1='\n         UNPK  LINEN1(9),SAWD1(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'HSA='\n         UNPK  LINEN2(9),SAHSA(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'LSA='\n         UNPK  LINEN3(9),SALSA(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         BAL   R14,OUTPUT\n         C     R7,SAHSA            CHECK HSA POINTER\n         BE    HSAOK               IF IT DOESN'T MATCH, THEN...\n         MVC   LINEL1(L'IBCMSG),IBCMSG\n         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN\nHSAOK    DS    0H\n         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS\n         MVC   LINEL1(4),=C'R14='\n         UNPK  LINEN1(9),SAR14(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR14\n         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R15='\n         UNPK  LINEN1(9),SAR15(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR15\n         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS\n         SPACE 1\n         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED\n         LTR   R9,R9               IF ZERO, IGNORE IT\n         BZ    NOEP\n         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA\n         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION\n         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT\n         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND\n         BNE   NOEP                THEN NO EP DATA\n         XR    R2,R2               CLEAR INSERT REG\n         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER\n         LTR   R2,R2               IF ZERO\n         BZ    NOEP                THEN NO EP DATA\n         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW\n         BNH   SETMAX\n         LA    R2,EPLENGTH\nSETMAX   DS    0H\n         LA    R9,4\n         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF\n         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...\n         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY\n         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED\n         MVC   LINEEP1(6),=CL6'AT EP '\n         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE\n         EX    R2,EPMVC            TRANSLATE EP DATA\nNOEP     DS    0H\n         SPACE 1\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R0 ='\n         UNPK  LINEN1(9),SAR00(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R1 ='\n         UNPK  LINEN1(9),SAR01(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R2 ='\n         UNPK  LINEN2(9),SAR02(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R3 ='\n         UNPK  LINEN3(9),SAR03(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R4 ='\n         UNPK  LINEN4(9),SAR04(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R5 ='\n         UNPK  LINEN1(9),SAR05(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R6 ='\n         UNPK  LINEN2(9),SAR06(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R7 ='\n         UNPK  LINEN3(9),SAR07(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R8 ='\n         UNPK  LINEN4(9),SAR08(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R9 ='\n         UNPK  LINEN1(9),SAR09(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R10='\n         UNPK  LINEN2(9),SAR10(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R11='\n         UNPK  LINEN3(9),SAR11(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R12='\n         UNPK  LINEN4(9),SAR12(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         BAL   R14,OUTPUT          JUST A BLANK LINE\n         SPACE\n         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nSANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP\n         SPACE 1\n         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG\n         BAL   R14,OUTPUT\n         B     ERROUT\n         SPACE 1\nENDLOOP  DS    0H\n         B     RETURN0\n         SPACE 2\nEPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERRMSG),ERRMSG\n******** B     ERROUT\n         SPACE 1\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED\n         LTR   R0,R0               IF ADDRESS IS ZEROES,\n         BZR   R14                 THEN PRINT NOTHING, NOT AN EP\n         ST    R14,FMSAVE\n         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS\nFMDOIT   DS    0H\n         XR    R0,R0\n         ST    R0,ADPLCOM1\n         L     R0,FMWHERE\n         LR    R1,R4\n         L     R15,WHRADDR\n         BALR  R14,R15\n         CLI   ADPLFMT1,C' '\n         BE    FMNF\n         MVC   LINEMOD(16),ADPLCOM1\n         B     FMRET\nFMNF     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *\n* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS\n         BE    FMFAIL              THEN DON'T TRY AGAIN\n         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS\n         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE\nFMFAIL   DS    0H                  ELSE GIVE UP\n         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '\n         XC    FMWHERE,FMWHERE\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         LTR   R15,R15             IF LINE NOT PRINTED\n         BNZ   RETURN0             THEN...\nNORETYET DS    0H\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         DELETE EP=XIPSWHR\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nNOSAMSG  DC    C'NO SAVE AREA CHAIN FOR THIS TCB'\nIBCMSG   DC    C'*** INVALID BACK CHAIN ***'\nSANAMSG  DC    C'STORAGE UNAVAILABLE'\nSAMSG    DC    C'SAVE AREA AT '\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\nCOPYSA   DS    18F                 WORK AREA FOR SAVE AREA\n         ORG   COPYSA\nSAWD1    DS    F                   00 = FIRST WORD\nSAHSA    DS    F                   04 = HSA\nSALSA    DS    F                   08 = LSA\nSAR14    DS    F                   0C = REG14\nSAR15    DS    F                   10 = REG15\nSAR00    DS    F                   14 = REG0\nSAR01    DS    F                   18 = REG1\nSAR02    DS    F                   1C = REG2\nSAR03    DS    F                   20 = REG3\nSAR04    DS    F                   24 = REG4\nSAR05    DS    F                   28 = REG5\nSAR06    DS    F                   2C = REG6\nSAR07    DS    F                   30 = REG7\nSAR08    DS    F                   34 = REG8\nSAR09    DS    F                   38 = REG9\nSAR10    DS    F                   3C = REG10\nSAR11    DS    F                   40 = REG11\nSAR12    DS    F                   44 = REG12\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\n         DS    CL(L'SAMSG)         \"SAVE AREA AT \"\nLINESAA  DS    CL8                 ADDRESS OF SAVE AREA\n         DS    CL2                 \"  \"\nLINEL1   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN1   DS    CL8                 \"NNNNNNNN\"\nLINEB1   DS    CL1                 \" \"\nLINEL2   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN2   DS    CL8                 \"NNNNNNNN\"\nLINEB2   DS    CL1                 \" \"\nLINEL3   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN3   DS    CL8                 \"NNNNNNNN\"\nLINEB3   DS    CL1                 \" \"\nLINEL4   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN4   DS    CL8                 \"NNNNNNNN\"\nLINEB4   DS    CL1                 \" \"\nLINEL5   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN5   DS    CL8                 \"NNNNNNNN\"\nLINEB5   DS    CL1                 \" \"\n         ORG   LINEL2\n         DS    CL1\nLINEMOD  DS    CL16                \"WHERE\" DATA\n         DS    CL1\nLINEEP1  DS    CL6                 \"AT EP \"\nLINEEP2  DS    CL(EPLENGTH)\n         SPACE 1\nEPLENGTH EQU   78-(LINEEP2-LINE)\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IKJTCB\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XITWHR   0100-07332-07332-0900-00260-00260-00000-SEB\n         TITLE 'XITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'XITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXITWHR   CSECT\n         SAVE  (14,12),,XITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear communication word\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         UNPK  LINE+00(9),ADPLTCB(5)\n         TR    LINE+00(8),HEXTBL\n         MVI   LINE+08,C'.'\n         CLC   ADPLFMT1(4),=C'    '\n         BE    NOTFOUND\n         CLC   ADPLFMT1(4),=C'JPA '\n         BE    INJPA\n         CLC   ADPLFMT1(4),=C'PLPA'\n         BE    INPLPA\n         CLC   ADPLFMT1(4),=C'MLPA'\n         BE    INMLPA\n         CLC   ADPLFMT1(4),=C'NUC '\n         BE    INNUC\n         CLC   ADPLFMT1(4),=C'ERR '\n         BE    INERROR\n         B     INLIMBO\n         EJECT\nNOTFOUND DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NFMSG),NFMSG\n         B     ERROUT\n         EJECT\nINERROR  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'ERMSG),ERMSG\n         B     ERROUT\n         SPACE 1\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERMSG),ERMSG\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nINJPA    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'JPAMSG),JPAMSG\n         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'JPAMSG+08,C' '\n         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'JPAMSG+10,C' '\n         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINPLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'PLPAMSG),PLPAMSG\n         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'PLPAMSG+08,C' '\n         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'PLPAMSG+10,C' '\n         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINMLPA   DS    0H\n         SPACE 1\n         MVC   LINE+09(L'MLPAMSG),MLPAMSG\n         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'MLPAMSG+08,C' '\n         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'MLPAMSG+10,C' '\n         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINNUC    DS    0H\n         SPACE 1\n         MVC   LINE+09(L'NUCMSG),NUCMSG\n         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'NUCMSG+08,C' '\n         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'NUCMSG+10,C' '\n         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nINLIMBO  DS    0H\n         SPACE 1\n         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG\n         MVC   LINE+09+LIMBOFF(4),ADPLFMT1\n         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1\n         MVI   LINE+09+L'LIMBOMSG+08,C' '\n         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0\n         MVI   LINE+09+L'LIMBOMSG+10,C' '\n         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nJPAMSG   DC    C'  FOUND IN JPA MODULE '\nPLPAMSG  DC    C'  FOUND IN PLPA MODULE '\nMLPAMSG  DC    C'  FOUND IN MLPA MODULE '\nNUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '\nNFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'\nERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'\nLIMBOMS1 DC    C'  FOUND IN '\nLIMBOMS2 DC    CL4'    '\nLIMBOMS3 DC    C' MODULE '\nLIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'\nLIMBOFF  EQU   LIMBOMS2-LIMBOMS1\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=XLBRKS   0100-07332-07332-0900-00348-00348-00000-SEB\n         TITLE 'XLBRKS - INSTREAM MACRO DEFINITIONS'\n         MACRO\n&LABEL   CLRLINE\n&LABEL   MVI   DATALINE,C' '\n         MVC   DATALINE+1(255),DATALINE\n         MVC   DATALINE+256(L'DATALINE-256),DATALINE\n         MEND\n         SPACE 5\n         MACRO\n&LABEL   TUPT  &ADDR,&LEN\n&LABEL   LA    R1,&ADDR                    LOAD PARAMETER REG 1\n         LA    R0,&LEN                     LOAD PARAMETER REG 0\n         SVC   93                          ISSUE TPUT SVC\n         MEND\n         TITLE 'XLBRKS - COMMAND TO DISPLAY BREAKPOINTS UNDER TEST'\n***********************************************************************\n* SYNTAX: ... XLB | XLBRKS                                            *\n*        (WHERE ... IS HELP OR SOME OTHER MEANS OF GETTING THIS TSO   *\n* COMMAND INTO THE TEST ENVIRONMENT)                                  *\n*    OPERANDS:   \"S\", IF SPECIFIED, CAUSES SUBCOMMAND CHAINS TO BE    *\n* DISPLAYED FOR ACTIVE AND DEFERRED BREAKPOINTS.                      *\n* CHANGE ACTIVITY:                                                    *\n*     11/84 - SOME TEST CONTROL BLOCKS ARE NOW ABOVE THE 16MB LINE.   *\n*             THEREFORE, THIS PROGRAM MUST RUN IN 31-BIT MODE.        *\n*     05/85 - ADDRESSES MAY BE 31-BIT, SO MUST DISPLAY 4 BYTES.       *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2                   ADDRESS OF CPPL\nR3       EQU   3                   ADDRESS OF BREAK ELEMENT\nR4       EQU   4                   ADDRESS OF DEFERRED ELEMENT QUEUE\nR5       EQU   5                   ADDRESS OF DBE (DEFER BREAK ELEMENT)\nR6       EQU   6                   ADDRESS OF PDL (PARSE) FOR DBE\nR7       EQU   7                   ADDRESS OF EBCDIC BREAK DESCRIPTOR\nR8       EQU   8                   ADDRESS OF PDE OF OPERAND FOR DBE\nR9       EQU   9                   ADDRESS OF TCOMTAB\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                  STATIC BASE REGISTER\nR13      EQU   13                  DYNAMIC BASE REGISTER\nR14      EQU   14\nR15      EQU   15\nXLBRKS   CSECT\nXLBRKS   AMODE 31\nXLBRKS   RMODE 24\n         SAVE  (14,12),,XLBRKS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XLBRKS,R12\n         LR    R2,R1\n         USING CPPL,R2\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         L     R9,540                  TCB FOR THIS PROGRAM\nTESTLOOP CLC   21(3,R9),=X'000000'     CHECK TESTRAN FIELD IN TCB\n         BNE   TESTOK                  IF NONE, THEN\n         ICM   R9,7,133(R9)             TRY NEXT (MOTHER) TCB\n         BNZ   TESTLOOP                 UNTIL NO MORE, AT WHICH POINT\n         TUPT  NOTEST,L'NOTEST          SAY 'TEST NOT ACTIVE'\n         LA    R15,12                   AND QUIT.\n         B     RETURN\n         SPACE 1\nTESTOK   DS    0H                      R9 POINTS TO TEST'S TCB\n         L     R9,20(,R9)              POINT R9 TO TCOMTAB (TCBTRN)\n         N     R9,=X'00FFFFFF'         CLEAR HIGH-ORDER BYTE\n         USING TCOMTAB,R9\n         SPACE 1\n         NI    FLAGS,255-DISPSUBS    INIT SUBCOMMANDS NOT DISPLAYED\n         L     R15,CPPLECT\n         USING ECT,R15\n         TM    ECTSWS,ECTNOPD      IF THERE IS AN OPERAND ON THE CMD\n         DROP  R15\n         BO    NOOPERS             THEN\n         L     R14,CPPLCBUF         POINT TO COMMAND BUFFER\n         LA    R15,4(,R14)          POINT TO TEXT PART OF COMMAND\n         AH    R15,2(,R14)          POINT TO COMMAND OPERAND\n         OI    0(R15),X'40'         TRANSLATE IT TO UPPER CASE\n         CLI   0(R15),C'S'          IF OPERAND IS AN \"S\"\n         BNE   NOOPERS              THEN\n         OI    FLAGS,DISPSUBS        INDICATE SUBCOMMANDS TO BE DSPLYD\nNOOPERS  DS    0H\n         SPACE 1\n         ICM   R3,15,BREAKTAB          ADDR OF ACTIVE BREAK ELEMENT Q\n         BNZ   ACTIVEOK                IF NONE, THEN\n         TUPT  NOACTIVE,L'NOACTIVE      SAY NO ACTIVE BREAKPOINTS\n         B     TRYDEFER                 AND GO LOOK AT DEFERRED ONES\n         SPACE 2\nACTIVEOK DS    0H                      ELSE PROCESS ACTIVE BREAKPOINTS\n         USING BRKELEM,R3\n         CLRLINE ,                     INIT OUTPUT LINE TO BLANKS\n         MVC   AT(4),=C' AT '          MOVE IN AN \"AT\"\n         UNPK  WHERE(9),BRKADDR(5)     CONVERT BREAKPOINT ADDRESS\n         TR    WHERE(8),HEXTBL          TO DISPLAY\n         MVI   WHERE+8,C'.'            ADD A PERIOD\n         UNPK  INSTR(13),BRKINST(7)    CONVERT SAVED INSTRUCTION\n         TR    INSTR(12),HEXTBL         TO DISPLAY\n         MVI   INSTR+12,C' '           OVERLAY LEFTOVER CRUD\n***********************************************************************\n* CHECK LENGTH OF INSTRUCTION (2, 4, OR 6 DEPENDING ON OPCODE) AND    *\n* BLANK OUT REST OF IT                                                *\n***********************************************************************\n         CLI   BRKINST,X'40'           IF OPCODE LESS THAN 40\n         BNL   COMPC0                  THEN\n         MVC   INSTR+4(4),=C'    '      BLANK OUT BYTES 3 AND 4\nCOMPC0   CLI   BRKINST,X'C0'           IF OPCODE LESS THAN C0\n         BNL   AFTINSTR                THEN\n         MVC   INSTR+8(4),=C'    '      BLANK OUT BYTES 5 AND 6\nAFTINSTR DS    0H\n         LA    R1,DESC                 POINT TO DESCRIPTION LOC, BUT...\n         TM    BRKFLGS,BRKRANGE        IF A RANGE OF BREAKPOINTS\n         BZ    NORANGE                 THEN\n         MVC   DESC(L'RANGELBL),RANGELBL   SAY \"+... FROM\"\n         LH    R0,BRKDISP                  GET OFFSET OF BREAKPOINT\n         UNPK  DESC+1(5),BRKDISP(3)        CONVERT OFFSET TO\n         TR    DESC+1(4),HEXTBL             PRINTABLE HEX DISPLAY\n         MVI   DESC+5,C' '\n         LA    R1,DESC+L'RANGELBL       & POINT PAST RANGE DESCRIPTION.\nNORANGE  DS    0H\n         ICM   R7,15,BRKNAME           ADDRESS OF BREAKPOINT DESCRIPTN\n         BZ    BRKERR1                 IF NONE, ERROR IN BREAK CHAIN\n         LH    R15,0(,R7)              LENGTH OF DESCRIPTION\n         LTR   R15,R15                 IF ZERO,\n         BZ    BRKERR1                   ERROR IN BREAKPOINT CHAIN\n         BCTR  R15,0                   USING THIS LENGTH,\n         EX    R15,MOVEDESC            MOVE IN BREAKPOINT ADDRESS\n         B     DISPLAY1\nBRKERR1  DS    0H\n         MVC   AT(L'ERR1MSG),ERR1MSG   IF ERROR, SAY SO\nDISPLAY1 DS    0H\n         TR    DATALINE(256),TRTBL\n         TR    DATALINE+256(L'DATALINE-256),TRTBL\n         TUPT  DATALINE,L'DATALINE     DISPLAY BREAKPOINT INFO\n         SPACE 2\n         TM    FLAGS,DISPSUBS          IF DISPLAYING SUBCOMMANDS\n         BZ    NOCHAIN                 AND\n         ICM   R15,15,BRKCHAIN         IF A SUBCOMMAND CHAIN EXISTS\n         BZ    NOCHAIN                 THEN\n         LH    R1,0(,R15)               GET LENGTH OF SUBCOMMAND CHAIN\n         LA    R15,2(,R15)              GET ADDRESS OF SUBCOMMAND CHAIN\n         BAL   R14,DISPSUB              DISPLAY SUBCOMMAND CHAIN\n         SPACE 2\nNOCHAIN  DS    0H                      NO SUBCOMMANDS TO BE DISPLAYED\n         ICM   R3,15,BRKLINK           REPEAT UNTIL NO MORE ACTIVE\n         BNZ   ACTIVEOK                 BREAKPOINTS, THEN...\n         SPACE 3\nTRYDEFER DS    0H                      PROCESS DEFERRED BREAKPOINTS\n         ICM   R4,15,DEFERTAB          GET ADDR OF DEFERRED ELEMENT Q\n         BNZ   DEFEROK                 IF NONE, THEN\n         TUPT  NODEFER,L'NODEFER        SAY NO DEFERRED BREAKPOINTS\n         B     RETURN0                  AND RETURN TO TEST.\n         SPACE 1\nDEFEROK  DS    0H                      ADDRESS THE DEFER MODULE ELEMENT\n         USING DME,R4\nPROCDME  ICM   R5,15,DMEDBE            GET ADDR OF DEFER BREAK ELEMENT\n         BZ    NEXTDME                 IF NONE, ERROR, TRY NEXT DME\n         USING DBE,R5\nPROCDBE  ICM   R6,15,DBEPDL            GET ADDRESS OF PARSE-CREATED PDL\n         BZ    NEXTDBE                 IF NONE, ERROR, TRY NEXT DBE\n         LA    R8,8(,R6)               POINT TO PDE FOR BRKPT ADDRESS\n         SPACE 1\nPROCPDE  DS    0H                      PROCESS THIS PDE TO GET INFO\n         CLRLINE ,                     REINIT OUTPUT LINE TO BLANKS\n         MVC   DATALINE(L'DEFERLBL),DEFERLBL   MOVE IN DEFER LABEL\n         TM    32(R8),X'10'            IF BREAKPOINT IS MARKED OFF,\n         BO    NXTINLST                THEN BYPASS THIS PDE. ELSE...\n         LR    R0,R8                   POINT TO FIRST PDE OF RANGE\n         LA    R1,DATALINE+L'DEFERLBL  POINT TO WHERE TO BUILD STRING\n         L     R15,TSTADDR             GET ADDRESS OF IKJEGBLD ROUTINE\n         BALR  R14,R15                 CALL IKJEGBLD TO GET \"AT\" STRING\n***********************************************************************\n* NOTE THAT IKJEGBLD SETS R1 TO POINT TO THE END OF THE STRING, I.E.  *\n* THE LOCATION WHERE WE CAN MOVE IN ADDITIONAL DATA IN CASE THIS WAS  *\n* A RANGE SPECIFICATION AND WE HAVE TO PROCESS THE SECOND ADDRESS OF  *\n* THE RANGE.                                                          *\n***********************************************************************\nPROCPDE2 OC    36(4,R8),36(R8)         IF A SECOND ADDRESS IN RANGE,\n         BZ    DSPDEFER                THEN\n         LA    R0,36(,R8)               POINT TO SECOND PDE OF RANGE\n         MVI   0(R1),C':'               MOVE COLON AFTER END OF STRING\n         LA    R1,1(,R1)                BUMP PAST COLON TO PUT NEW DATA\n         L     R15,TSTADDR              GET ADDR OF IKJEGBLD AGAIN\n         BALR  R14,R15                  CALL IKJEGBLD FOR \"AT\" STRING\n         SPACE 1\nDSPDEFER DS    0H\n         TR    DATALINE(256),TRTBL\n         TR    DATALINE+256(L'DATALINE-256),TRTBL\n         TUPT  DATALINE,L'DATALINE     DISPLAY THE DEFERRED BREAKPOINT\n         SPACE 2\n         TM    FLAGS,DISPSUBS          IF DISPLAYING SUBCOMMANDS\n         BZ    NXTINLST                AND\n         TM    90(R6),X'80'            A SUBCOMMAND CHAIN EXISTS\n         BZ    NXTINLST                THEN\n         L     R15,84(,R6)              GET ADDRESS OF SUBCOMMAND CHAIN\n         LTR   R1,R15                   IF BAD ADDRESS\n         BZ    *+8                      THEN CAUSE ERROR DISPLAY. ELSE\n         LH    R1,88(,R6)               GET LENGTH OF SUBCOMMAND CHAIN\n         BAL   R14,DISPSUB              DISPLAY ORIGINAL SUBCOMMAND\n         SPACE 1\nNXTINLST DS    0H\n         CLC   72(4,R8),=X'FF000000'   IF THERE'S ANOTHER ADDR IN LIST\n         BE    NEXTDBE                 THEN\n         L     R8,72(,R8)               GET PDE FOR NEXT ADDR IN LIST\n         B     PROCPDE                  AND GO PROCESS IT.\nNEXTDBE  ICM   R5,15,DBEDBE            ELSE GO TO NEXT DBE\n         BNZ   PROCDBE                 WHEN NO MORE DBE'S\nNEXTDME  ICM   R4,15,DMEDME            GET NEXT DME\n         BNZ   PROCDME                 UNTIL NO MORE DME'S.\n         SPACE 4\nRETURN0  XR    R15,R15                 SET RETURN CODE TO ZERO\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)            STORE RETURN CODE\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nDISPSUB  DS    0H                  SUBROUTINE TO DISPLAY SUBCOMMAND\n         SPACE\n***********************************************************************\n* THIS SUBROUTINE DISPLAYS THE CONTENTS OF A SUBCOMMAND CHAIN.        *\n* ON ENTRY R15 CONTAINS THE ADDRESS OF THE SUBCOMMAND CHAIN BUFFER TO *\n* BE DISPLAYED. R1 CONTAINS THE LENGTH OF THE SUBCOMMAND CHAIN.       *\n* R14 CONTAINS THE RETURN ADDRESS. THIS SUBROUTINE ALTERS R0 AND R1.  *\n***********************************************************************\n         SPACE\n         CLRLINE ,                      REINIT OUTPUT LINE TO BLANKS\n         LTR   R1,R1                    IF ZERO,\n         BZ    BRKERR2                   ERROR IN SUBCOMMAND CHAIN\n         CH    R1,=H'256'               IF GREATER THAN 256,\n         BH    BRKERR3                   ERROR IN SUBCOMMAND CHAIN\n         MVC   DATALINE(L'SUBLBL),SUBLBL  MOVE IN SUBCOMMAND IDENT\n         BCTR  R1,0                     USING THIS LENGTH,\n         EX    R1,SUBMOVE               MOVE IN SUBCOMMAND STRING\n         B     DISPLAY2\nBRKERR2  DS    0H\n         MVC   DATALINE(L'ERR2MSG),ERR2MSG   IF ERROR, SAY SO\n         B     DISPLAY2\nBRKERR3  DS    0H\n         MVC   DATALINE(L'ERR3MSG),ERR3MSG   IF ERROR, SAY SO\nDISPLAY2 DS    0H\n         TR    DATALINE(256),TRTBL\n         TR    DATALINE+256(L'DATALINE-256),TRTBL\n         TUPT  DATALINE,L'DATALINE     DISPLAY (SUB)COMMAND STRING\n         BR    R14                 RETURN TO CALLER\n         EJECT\n***********************************************************************\n*  DATA AREAS                                                         *\n***********************************************************************\n         SPACE\n*  EXECUTED INSTRUCTIONS\n         SPACE\nMOVEDESC MVC   0(0,R1),2(R7)           MOVE DESCRIPTION TO DATA LINE\nSUBMOVE  MVC   DATALINE+L'SUBLBL(0),0(R15) MOVE SUBCOMMAND TO DATA LINE\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256                   TABLE FOR HEX CONVERSION\nRANGELBL DC    C'+0000 FROM '\nSUBLBL   DC    C' SUBCOMMAND: '\nDEFERLBL DC    C' DEFERRED BREAKPOINT AT '\nNOTEST   DC    C'TEST NOT ACTIVE'\nNOACTIVE DC    C'NO ACTIVE BREAKPOINTS'\nNODEFER  DC    C'NO DEFERRED BREAKPOINTS'\nERR1MSG  DC    C'*** ERROR IN BREAKPOINT CHAIN ***'\nERR2MSG  DC    C' *** ERROR IN SUBCOMMAND CHAIN ***'\nERR3MSG  DC    C' *** INVALID SUBCOMMAND CHAIN ***'\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE 3\n         LTORG\n         EJECT\nDATD     DSECT ,                       REENTRANT WORK AREA\n         SPACE 1\nSAVEAREA DS    9D                      OS SAVE AREA\n         SPACE 1\nFLAGS    DS    X\nDISPSUBS EQU   X'80'                   1 = DISPLAY SUBCOMMANDS\n         SPACE 1\nDATALINE DS    0CL320                  PLACE TO BUILD OUTPUT\nWHERE    DS    CL9                     BREAKPOINT INSTRUCTION ADDRESS\n         DS    C' '                    FILLER\nINSTR    DS    CL12                    INSTRUCTION IMAGE\nAT       DS    C' AT '                 FILLER\nDESC     DS    CL(L'DATALINE-(*-DATALINE))   THE REST OF IT\n         SPACE 1\nSIZDATD  EQU   *-DATD                  LENGTH OF WORK AREA\n         TITLE 'XLBRKS - TSO TEST CONTROL BLOCKS'\n***********************************************************************\n* THE INFORMATION IN THE FOLLOWING DSECT MAPPINGS IS TAKEN FROM:      *\n* OS/VS2 MVS TSO COMMAND PROCESSOR LOGIC VOLUME III: TEST             *\n* AND IS COPYRIGHT BY IBM.                                            *\n***********************************************************************\n         SPACE 1\nBRKELEM  DSECT ,                       MAPPING OF BREAK ELEMENT\n         SPACE 1\nBRKLINK  DS    A                       LINK PTR TO NEXT BREAK ELEMENT\nBRKADDR  DS    A                       ABS ADDR IN PP WHERE SVC97 SET\nBRKINST  DS    XL8                     SAVED INSTRUCTION\nBRKFLGS  DS    X                       FLAGS\nBALSW    EQU   X'80'                   SAVED INSTRUCTION IS BAL(R)\nBRKRANGE EQU   X'40'                   ELEMENT IS PART OF RANGE OF ADDR\nBRKLIST  EQU   X'20'                   ELEMENT IS PART OF LIST OF ADDRS\nBRKNONOT EQU   X'10'                   NONOTIFY ACTIVE\nBRKDISP  DS    H                       DISPLACEMENT FROM START OF RANGE\nBRKNAME  DS    A                       PTR TO 1ST EBCDIC ADDR ENTERED\nBRKCHAIN DS    A                       PTR TO EBCDIC SUBCOMMAND CHAIN\nBRKCOUNT DS    A                       COUNT-1 IN LOW-ORDER 2 BYTES\n*                                      (HI-ORDER USED BY SVC97)\nBRKRB    DS    A                       ADDR OF RB FOR MODULE\n         SPACE 2\nDME      DSECT ,                       DEFER MODULE ELEMENT\n         SPACE 1\nDMEDME   DS    A                       PTR TO NEXT DME OR ZEROES\nDMEDBE   DS    A                       PTR TO 1ST DEFER BREAK ELEMENT\nDMELOAD  DS    CL8                     NAME OF LOAD MODULE\n         SPACE 2\nDBE      DSECT ,                       DEFER BREAK ELEMENT\n         SPACE 1\nDBEDBE   DS    A                       PTR TO NEXT DBE OR ZEROES\nDBEPDL   DS    A                       PTR TO PDL FOR AT DEFER SUBCMD\nDBEINBUF DS    A                       PTR TO INPUT BUF W/ SUBCOMMAND\n         EJECT\n         TCOMTAB\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJECT\n         END\n./ ADD NAME=XLL      0100-07332-07332-0900-02926-02926-00000-SEB\n         TITLE 'XLL - INTRODUCTION'\n***********************************************************************\n* THIS PROGRAM SCANS A LOAD MODULE FOR OCCURRENCES OF A SPECIFIED     *\n* CHARACTER STRING. IT ALSO DISPLAYS CSECT NAMES.                     *\n***********************************************************************\n* NON-REENTRANT, NON-REUSABLE                                         *\n* REQUIRED MACRO LIBRARY: DST1.AMODGEN                                *\n* REQUIRED FILES:                                                     *\n*   SYSIN       -   INPUT CONTROL STATEMENTS                          *\n*   SYSPRINT    -   MESSAGES AND OUTPUT                               *\n*   SYSLIB      -   LOAD MODULE LIBRARY                               *\n* (NOTE: THESE FILE NAMES MAY BE OVERRIDDEN IN STANDARD IBM UTILITY   *\n* \"PARM 2\" FORMAT, E.G. BY THE DRAPER \"XINVOKE\" COMMAND OPERANDS      *\n* SYSIN(XXX), SYSPRINT(XXX), SYSLIB(XXX).)                            *\n***********************************************************************\n* OPTIONAL PARAMETERS:                                                *\n* (1) A STANDARD OS EXEC PARAMETER STRING.  IF NON-NULL, DEFINES THE  *\n*     NAME OF AN ISPF PANEL AND THIS UTILITY WILL FUNCTION AS AN ISPF *\n*     DIALOG, IN WHICH CASE DDNAMES SYSPRINT AND SYSIN ARE NOT USED.  *\n*     (AN ISPF TEMP TABLE IS CREATED WHOSE NAME IS THE PANEL NAME.)   *\n*     THE PARM FIELD CONTAINS THE PANEL NAME FOLLOWED BY AN OPTIONAL  *\n*     ALTERNATE DDNAME FOR SYSLIB, SEPARATED BY BLANKS.               *\n* (2) AN ALTERNATE-DDNAME LIST (SEE ABOVE).                           *\n***********************************************************************\n         TITLE 'XLL - INTERNAL MACRO DEFINITIONS'\n         MACRO\n&NAME    MSG\n.********************************************************************\n.* THIS MACRO IS USED TO GENERATE A MESSAGE TO BE WRITTEN ON THE\n.* OUTPUT FILE.  IT IS REFERENCED BY THE \"WRTMSG\" MACRO (Q.V.)\n.* INPUT IS POSITIONAL PARAMETERS WITH 1 TO 3 SUBPARAMETERS EACH,\n.* DEFINING THE ADDRESS, LENGTH, AND TYPE OF EACH ITEM TO BE\n.* DISPLAYED.  VALID TYPES ARE:\n.*      W  -  CHARACTER FORMAT WITH TRAILING BLANKS TRIMMED\n.*      C  -  CHARACTER FORMAT WITH ALL BLANKS INCLUDED\n.*      X  -  HEXADECIMAL FORMAT TO BE CONVERTED TO HEX DISPLAY\n.*      F  -  FULLWORD FORMAT TO BE CONVERTED TO NUMERIC DISPLAY\n.*      H  -  HALFWORD FORMAT TO BE CONVERTED TO NUMERIC DISPLAY\n.* IF LENGTH OR TYPE IS OMITTED, IT WILL BE TAKEN FROM THE DEFAULT\n.* FOR THE SPECIFIED SYMBOL.\n.* NOTE 1: LENGTH AND TYPE ARE IGNORED WHEN A QUOTED STRING IS\n.*   SPECIFIED INSTEAD OF A SYMBOLIC ADDRESS, AND SHOULD BE OMITTED.\n.* NOTE 2: THE LENGTH MAY BE SPECIFIED IN A REGISTER AS (#), BUT\n.*   THE ADDRESS MUST BE WRITTEN AS AN S-TYPE EXPRESSION, E.G. 0(#),\n.*   IN ORDER FOR A REGISTER DESIGNATION TO BE USED FOR IT.\n.* NOTE 3: SYMBOLS WITH TYPE OF C DEFAULT TO TYPE W UNLESS OVERRIDDEN.\n.* NOTE 4: ALL SYMBOLS MUST BE ADDRESSABLE, BUT THEY NEED NOT BE IN\n.*   THE PROGRAM AREA, BECAUSE S-TYPE ADDRESS CONSTANTS ARE GENERATED\n.*   FOR ALL SYMBOLS.\n.*********************************************************************\n         LCLA  &I\n         LCLC  &LENGTH,&TYPE,&LREG\n&I       SETA  0                   INITIALIZE PARAMETER COUNTER\n&NAME    DS    0C\n.LOOP    ANOP  ,                   LOOP FOR EACH POSITIONAL PARAMETER\n&I       SETA  &I+1                INCREMENT PARAMETER COUNTER\n         AIF   (&I GT N'&SYSLIST).ENDLOOP UNTIL END OF ALL PARAMETERS\n         AIF   ('&SYSLIST(&I)'(1,1) NE '''').NOTCHAR\n.* QUOTED CHARACTER STRING - GENERATE INLINE DATA\n         DC    C&SYSLIST(&I)\n         AGO   .LOOP\n.NOTCHAR ANOP  ,                   ELSE NOT A QUOTED STRING...\n         AIF   ('&SYSLIST(&I,2)' EQ '').IMPLEN   CHECK LENGTH SUBPARM\n         AIF   ('&SYSLIST(&I,2)'(1,1) EQ '(').REGLEN   IF NOT REG SPEC\n&LENGTH  SETC  '&SYSLIST(&I,2)'    THEN LENGTH IS NUMERIC VALUE\n         AGO   .AFTLEN             ELSE\n.REGLEN  ANOP                       LENGTH-IN-REGISTER SPECIFIED...\n&LREG    SETC  '&SYSLIST(&I,2)'(2,K'&SYSLIST(&I,2)-2) EXTRACT REGISTER#\n&LENGTH  SETC  '128+&LREG'          SPECIFY LENGTH IS A REGISTER SPEC.\n         AGO   .AFTLEN\n.IMPLEN  ANOP  ,                   OTHERWISE IMPLICIT LENGTH USED\n&LENGTH  SETC  'L''&SYSLIST(&I,1)' USE LENGTH OF DEFINED SYMBOL\n.AFTLEN  ANOP  ,                   END OF LENGTH PROCESSING\n         AIF   ('&SYSLIST(&I,3)' EQ '').IMPTYPE  CHECK TYPE SUBPARM\n&TYPE    SETC  '&SYSLIST(&I,3)'    IF ENTERED, USE AS TYPE VALUE\n         AGO   .AFTTYPE            ELSE...\n.IMPTYPE ANOP  ,                    TYPE NOT SPECIFIED...\n&TYPE    SETC  T'&SYSLIST(&I,1)     USE TYPE OF DEFINED SYMBOL\n.AFTTYPE ANOP  ,                   END OF TYPE PROCESSING\n         AIF   ('&TYPE' EQ 'X').TYPEX\n         AIF   ('&TYPE' EQ 'F').TYPEF\n         AIF   ('&TYPE' EQ 'H').TYPEH\n         AIF   ('&TYPE' EQ 'W').TYPEW\n.* SEE NOTE 3 ABOVE PER THE FOLLOWING\n         AIF (T'&SYSLIST(&I,1) EQ 'C' AND '&SYSLIST(&I,3)' EQ '').TYPEW\n         AIF   ('&TYPE' EQ 'C').TYPEC\n         MNOTE 12,'UNSUPPORTED TYPE &TYPE FOR OPERAND &SYSLIST(&I,1)'\n         AGO   .LOOP\n.TYPEC   ANOP  ,                   TYPE = C\n&TYPE    SETC  '04'\n         AGO   .GEN\n.TYPEX   ANOP  ,                   TYPE = X\n&TYPE    SETC  '08'\n         AGO   .GEN\n.TYPEF   ANOP  ,                   TYPE = F\n.TYPEH   ANOP  ,                   TYPE = H\n&TYPE    SETC  '0C'                NOTE - LENGTH DETERMINED BY SYMBOL\n         AGO   .GEN\n.TYPEW   ANOP  ,                   TYPE = W\n&TYPE    SETC  '00'\n.GEN     ANOP  ,                   GENERATE CODE FOR THIS PARAMETER\n         DC    X'&TYPE',YL1(&LENGTH),SL2(&SYSLIST(&I,1))\n         AGO   .LOOP               AND CONTINUE WITH NEXT PARAMETER\n.ENDLOOP ANOP  ,\n         DC    X'3F'                           END OF MESSAGE INDICATOR\n         SPACE\n         MEND\n         EJECT\n         MACRO\n&LABEL   WRTMSG &MSG,&USE15=NO\n.********************************************************************\n.* THIS MACRO IS USED TO DISPLAY A MESSAGE OR A DATA LINE ON THE\n.* \"SYSPRINT\" OUTPUT FILE.  THE REQUIRED POSITIONAL OPERAND IS THE\n.* LABEL OF A \"MSG\" MACRO DEFINING THE MESSAGE TO BE DISPLAYED.\n.* THE \"CC\" FIELD CONTAINS THE ASA CONTROL CHARACTER TO BE USED WITH\n.* THE MESSAGE; THE PROGRAMMER SHOULD BE SURE THAT IT CONTAINS THE\n.* CORRECT VALUE AT THE TIME THE MACRO IS EXECUTED.\n.* SPECIFY \"USE15=YES\" IF THE MESSAGE TO BE DISPLAYED USES REGISTER 15\n.* AS A BASE REGISTER; EXTRA CODE IS GENERATED IN THIS CASE TO SAVE\n.* THE CURRENT CONTENTS OF REGISTER 15 IN THE FIRST WORD OF THE OS\n.* SAVE AREA (NOTE NONSTANDARD LINKAGE DESCRIBED IN THE \"WRITE\"\n.* SUBROUTINE OF THE PROGRAM, WHICH THIS MACRO INVOKES).\n.* NOTE: A REGISTER SPECIFICATION FOR THE MESSAGE, I.E. (#), CAN BE\n.*       USED IN THIS MACRO, IF THE REGISTER HAS BEEN PREVIOUSLY\n.*       LOADED WITH THE ADDRESS OF A \"MSG\" MACRO INSTRUCTION.\n.* NOTE: AS WITH THE MSG MACRO, S-TYPE CONSTANTS ARE GENERATED FOR\n.*       ALL OPERANDS.\n.*********************************************************************\n&LABEL   DS    0H\n         AIF   ('&USE15' NE 'YES').N15\n         ST    15,0(,13)             SAVE REG 15 IN CASE IT IS USED\n.N15     L     15,WRTADDR            GET ADDR OF MSG WRITER SUBROUTINE\n         BALR  0,15                  CALL MSG WRITER, PLIST IN REG 0\n         AIF   ('&MSG'(1,1) EQ '(').ZEROOFF\n         DC    S(&MSG)               ADDRESS OF MESSAGE STRING\n         AGO   .AFTDC\n.ZEROOFF DC    S(0&MSG)              ADDRESS OF MESSAGE STRING\n.AFTDC   ANOP\n         MEND\n         EJECT\n         MACRO\n&NAME    SCAN  &KEYNUM,&MAXLEN=128\n.*********************************************************************\n.* THIS MACRO INVOKES THE \"SCAN\" SUBROUTINE.  THE POSITIONAL OPERAND\n.* SPECIFIES THE RELATIVE NUMBER OF THE OPERAND TO BE SCANNED FOR\n.* (FOR INFORMATIONAL MESSAGE PURPOSES ONLY).  THE \"MAXLEN\" OPERAND\n.* SPECIFIES THE MAXIMUM LENGTH THAT THE OPERAND MAY POSSESS.  IF THIS\n.* OPERAND IS OMITTED, NO MAXIMUM LENGTH IS REQUIRED AND THE STRING\n.* MAY CONTAIN QUOTATION-MARK SYNTAX.\n.*********************************************************************\n&NAME    L     R15,SCANADDR              GET ADDR OF SCAN SUBROUTINE\n         BALR  R14,R15                   CALL THE SCAN SUBROUTINE\n         DC    YL1(&KEYNUM,&MAXLEN)      OPERAND # AND MAX VALUE LENGTH\n         MEND\n         EJECT\n         MACRO\n&NAME    LOADSA &LOC,&ERRET=WRTERROR\n.*********************************************************************\n.* *** USED BY THE \"WRITE\" SUBROUTINE ONLY. ***\n.* THIS MACRO LOADS REGISTER 15 WITH THE ADDRESS VALUE TAKEN FROM THE\n.* S-TYPE (BASE-DISPLACEMENT) CONSTANT LOCATED AT THE ARGUMENT ADDRESS.\n.* REGISTER 14 IS USED IN CONJUNCTION WITH 15 TO EFFECT THE CONVERSION.\n.* \"REGSAVE\" IS USED AS A TABLE OF REGISTER VALUES FROM THE CALLER.\n.*********************************************************************\n&NAME    XR    R14,R14                 CLEAR REG 14\n         ICM   R15,B'1100',&LOC        PICK UP S-FORMAT B2D2\n         SLDL  R14,4                   SHIFT BASEREG INTO REG 14\n         LTR   R14,R14                 BASE REG CANNOT BE 0\n         BNP   &ERRET                  IF IT IS, GO TO ERROR ROUTINE\n         SRL   R15,20                  REG 15 = DISPLACEMENT VALUE\n         SLA   R14,2                   MUL REG 14 BY 4 FOR INDEX\n         AL    R15,REGSAVE(R14)        BASE+DISPL=ADDR OF DATA IN R15\n         MEND\n         EJECT\n         MACRO\n&NAME    CGETMAIN\n.*********************************************************************\n.* THIS MACRO IS THE EQUIVALENT OF THE SYSTEM MACRO INVOCATION\n.* \"GETMAIN RC,LV=(0)\".  HOWEVER, IT GENERATES BETTER CODE.\n.* NOTE THAT REGISTER 0 MUST CONTAIN THE LENGTH TO BE GETMAINED.\n.*********************************************************************\n&NAME    XR    R15,R15                 CLEAR PARAMETER REGISTER\n         XR    R1,R1                   CLEAR PARAMETER REGISTER\n         SVC   120                     ISSUE GETMAIN SVC\n         MEND\n         TITLE 'XLL - PROGRAM TO SCAN FOR STRINGS IN A LOAD MODULE'\nXLL      CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,XLL_&SYSDATE_&SYSTIME\n         LR    R12,R15             SET LOCAL BASE REGISTER\n         USING XLL,R12\n         L     R14,ADCOMMON\n         ST    R13,4(,R14)         STORE HSA ADDRESS\n         ST    R14,8(,R13)\n         LR    R13,R14             ADDRESS SAVEAREA IN COMMON AREA\n         USING COMMON,R13\n         B     BEGIN               BRANCH AROUND RETURNING CODE\n         SPACE\nADCOMMON DC    A(COMMON)           ADDRESS OF COMMON AREA\n         EJECT\nBEGIN    DS    0H\n         TM    0(R1),X'80'         IF ONLY 1 PARM PASSED\n         BO    NOALTDD             THEN NO ALTERNATE DDNAMES\n         TM    4(R1),X'80'         IF MORE THAN 2 PARMS PASSED\n         BZ    NOALTDD             THEN NO ALTERNATE DDNAMES\n         L     R2,4(,R1)           ELSE GET ADDRESS OF ALT DD LIST\n         USING ALTDDS,R2\n         LH    R0,ALTDDLEN         GET LENGTH OF ALTERNATE DD LIST\n         CH    R0,=Y(ALTIN-ALTDDS+8-2)\n         BL    NOSYSIN\n         CLI   ALTIN,C' '          IF ALTERNATE SYSIN DD SPECIFIED\n         BNH   NOSYSIN             THEN\n         MVC   SYSIN+40(8),ALTIN        USE IT\nNOSYSIN  DS    0H\n         CH    R0,=Y(ALTPRINT-ALTDDS+8-2)\n         BL    NOPRINT\n         CLI   ALTPRINT,C' '       IF ALTERNATE SYSPRINT DD SPECIFIED\n         BNH   NOPRINT             THEN\n         MVC   SYSPRINT+40(8),ALTPRINT  USE IT\nNOPRINT  DS    0H\n         CH    R0,=Y(ALTLIB-ALTDDS+8-2)\n         BL    NOSYSLIB\n         CLI   ALTLIB,C' '         IF ALTERNATE SYSLIB DD SPECIFIED\n         BNH   NOSYSLIB            THEN\n         MVC   SYSLIB+40(8),ALTLIB      USE IT\nNOSYSLIB DS    0H\n         DROP  R2\nNOALTDD  DS    0H\n         SPACE\n         OI    DIALOGSW,PARMSCAN   INDICATE SCANNING PARM STRING\n         L     R1,0(,R1)           GET ADDRESS OF EXEC PARM STRING\n         LH    R2,0(,R1)           GET LENGTH OF EXEC PARM STRING\n         LTR   R2,R2               IF PARM STRING IS NONZERO,\n         BZ    NOTISPF             THEN...\n         LA    R15,2(,R1)           SET START FOR SCAN OF PARM FIELD\n         ST    R15,SCANPTR          SET START FOR SCAN OF PARM FIELD\n         ALR   R15,R2               SET END OF PARM FIELD ADDRESS\n         ST    R15,SCANEPTR         SET END FOR SCAN OF PARM FIELD\n         SCAN  1,MAXLEN=8           SCAN FOR FIRST OPERAND OF PARM FLD\n         LTR   R8,R8                CHECK FIRST PARM OPERAND\n         BZ    NOTISPF              IF NONE, NOT ISPF MODE\n         BM    BADRET               IF INVALID, TERMINATE\n         OI    DIALOGSW,ISPFMODE+TBCREATE SET ISPF DIALOG MODE\n         BCTR  R15,0                ELSE USING LENGTH OF OPERAND 1\n         EX    R15,MVCPANEL         MOVE IT TO PANEL NAME\n         SCAN  2,MAXLEN=8           NOW SCAN FOR 2ND OPERAND\n         LTR   R8,R8                CHECK IF ALTERNATE DD FOR SYSLIB\n         BZ    NOPARM2              IF NONE, USE SYSLIB\n         BM    BADRET               IF INVALID, TERMINATE\n         MVC   SYSLIB+40(8),BLANKS  ELSE CLEAR SYSLIB DD PREP TO MOVE\n         BCTR  R15,0                USING LENGTH OF OPERAND 2\n         EX    R15,MVCSYSDD         MOVE IT TO SYSLIB DD NAME\nNOPARM2  DS    0H\n         MVC   TABLE,PANEL         SET TABLE NAME = PANEL NAME\n         LOAD  EPLOC==CL8'ISPLINK' LOAD THE ISPLINK MODULE\n         ST    R0,@ISPLINK         SAVE THE ENTRY ADDRESS\n* ISPEXEC VDEFINE XLLCMD CHAR(LENGTH(XLLCMD))\n         LA    R14,=C'VDEFINE'     SERVICE NAME\n         LA    R15,=C'(XLLCMD)'    VARIABLE NAME\n         LA    R0,XLLCMD           DATA ADDRESS\n         LA    R1,=C'CHAR'         DATA TYPE\n         LA    R2,=A(L'XLLCMD)     DATA LENGTH\n         STM   R14,R2,ISPPARMS     STORE INTO PARAMETER LIST\n         OI    ISPPARM5,X'80'      INDICATE END OF LIST\n         LA    R1,ISPPARMS         POINT TO PARAMETER LIST\n         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK\n         BALR  R14,R15             CALL ISPLINK TO DEFINE XLLCMD\n* ISPEXEC VDEFINE XLLROW CHAR(LENGTH(XLLROW)) NOBSCAN\n         LA    R14,=C'(XLLROW)'    VARIABLE NAME\n         LA    R15,XLLROW          DATA ADDRESS\n         STM   R14,R15,ISPPARM2    STORE INTO PARAMETER LIST\n         LA    R14,=A(L'XLLROW)    DATA LENGTH\n         LA    R15,=C'(NOBSCAN)'   INDICATE NO SCAN FOR TRAILING BLANKS\n         STM   R14,R15,ISPPARM5    STORE INTO PARAMETER LIST\n         OI    ISPPARM6,X'80'      INDICATE END OF LIST\n         LA    R1,ISPPARMS         POINT TO PARAMETER LIST\n         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK\n         BALR  R14,R15             CALL ISPLINK TO DEFINE XLLROW\n         B     AFTISPF\n         SPACE\nNOTISPF  DS    0H                  IF NOT ISPF MODE, USE SYSIN/SYSPRINT\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         TM    SYSPRINT+48,X'10'   IF SYSPRINT NOT OPEN\n         BNO   BADRET              THEN BOMB\n         TM    SYSIN+48,X'10'      IF SYSIN NOT OPEN\n         BNO   BADRET              THEN BOMB\nAFTISPF  DS    0H\n         SPACE\n         MVC   SYSLIBD+40(8),SYSLIB+40   MOVE SYSLIB DDNAME TO DIR DCB\n         NI    DIALOGSW,255-PARMSCAN     NO LONGER SCANNING PARM FIELD\n         SPACE\n         OPEN  (SYSLIB,(INPUT))\n         TM    SYSLIB+48,X'10'     IF SYSLIB NOT OPEN\n         BNO   BADRET              THEN BOMB\n         L     R15,540             GET TCB ADDRESS\n         L     R15,12(,R15)        GET TIOT ADDRESS\n         AH    R15,SYSLIB+40       ADD TIOT OFFSET ==> TIOT ENTRY ADDR\n         ICM   R15,7,12(R15)       GET JFCB ADDRESS (-16) FOR SYSLIB\n         L     R14,SYSLIB+44       GET DEB ADDRESS\n         TM    8(R14),X'01'        IF CONCATENATED DATA SETS,\n         BZ    NOTCCAT             THEN\n         LA    R1,BEGINCON          SET UP MESSAGE FOR CONCATENATION\n         B     SAYHELLO            ELSE\nNOTCCAT  LA    R1,BEGINMSG          SET UP MESSAGE FOR SPECIFIC DATASET\nSAYHELLO WRTMSG (1),USE15=YES      SAY HI\n         XR    R10,R10             CLEAR OVERLAY TABLE ADDRESS\n         SPACE\n***********************************************************************\n* SET UP ATTENTION EXIT ROUTINE.                                      *\n***********************************************************************\n         SPACE\n         TM    DIALOGSW,ISPFMODE   IF NOT IN ISPF DIALOG MODE\n         BO    GETSYSIN            THEN\n         L     R15,540              GET TCB ADDRESS\n         L     R15,12(,R15)         GET TIOT ADDRESS\n         AH    R15,SYSIN+40         ADD TIOT OFFSET ==> TIOT ENTRY ADDR\n         TM    3(R15),X'20'         IF SYSIN ALLOCATED TO TERMINAL\n         BZ    GETSYSIN             THEN\n         OI    SWITCH,SYSINTRM       INDICATE SO AND SET UP ATTN EXIT\n         STAX  ATTNEXIT,USADDR=COMMON,REPLACE=NO\n         SPACE 3\nGETSYSIN DS    0H\n         NI    SWITCH,255-ATTN     INITIALIZE ATTENTION INDICATOR\n         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE\n         BZ    SYSINGET            THEN\n* ISPEXEC TBTOP TABLE-NAME\n         LA    R14,=C'TBTOP'       SERVICE NAME\n         LA    R15,TABLE           TABLE NAME\n         STM   R14,R15,ISPPARMS    STORE INTO PARAMETER LIST\n         OI    ISPPARM2,X'80'      INDICATE END OF LIST\n         LA    R1,ISPPARMS         POINT TO PARAMETER LIST\n         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK\n         BALR  R14,R15             CALL ISPLINK TO DISPLAY TABLE\n* ISPEXEC TBDISPL TABLE-NAME PANEL-NAME\n         LA    R14,=C'TBDISPL'     SERVICE NAME\n         LA    R15,TABLE           TABLE NAME\n         LA    R0,PANEL            PANEL NAME\n         LA    R1,MSGID            MESSAGE ID\n         STM   R14,R1,ISPPARMS     STORE INTO PARAMETER LIST\n         OI    ISPPARM4,X'80'      INDICATE END OF LIST\n         LA    R1,ISPPARMS         POINT TO PARAMETER LIST\n         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK\n         BALR  R14,R15             CALL ISPLINK TO DISPLAY TABLE\n         LTR   R15,R15             IF END KEY HIT (OR OTHER ERROR)\n         BNZ   EOF                 THEN GO TO TERMINATION\n         LA    R1,XLLCMD           ELSE POINT TO COMMAND FIELD AS INPUT\n         B     INPUTOK             AND PROCESS INPUT.\nSYSINGET DS    0H                  ELSE...\n         GET   SYSIN               READ A CONTROL STATEMENT\n         TM    SWITCH,ATTN         IF ATTENTION INTERRUPT OCCURRED\n         BZ    INPUTOK             THEN\n         NI    SWITCH,255-ATTN      RESET FLAG\n         WRTMSG INPUTMSG            TELL USER INPUT NO GOOD\n         B     GETSYSIN             AND TRY AGAIN.\nINPUTOK  DS    0H\n         ST    R1,SCANPTR          INITIALIZE SCANNING PARAMETER\n         LA    R15,80(,R1)         POINT TO END OF CONTROL STATEMENT\n         ST    R15,SCANEPTR        INITIALIZE SCANNING PARAMETER\n         MVI   CC,C'-'             SET ASA CONTROL = TRIPLE SPACE\n         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE\n         BZ    ECHOMSG             THEN\n         OI    DIALOGSW,TBCREATE    INDICATE REUSE OF TABLE REQUIRED\n         B     AFTECHO             ELSE...\nECHOMSG  WRTMSG SYSINMSG           ECHO SYSIN - R1 ALREADY POINTS TO IT\n         MVI   CC,C'0'             SET ASA DOUBLE SPACE FOR NEXT MSGS\nAFTECHO  DS    0H\n         SPACE\n***********************************************************************\n* THE \"SCAN\" SUBROUTINE IS INVOKED TO EXTRACT EACH KEYWORD FROM THE   *\n* CONTROL STATEMENT.  ON RETURN R8 HAS THE ADDRESS OF THE KEYWORD,    *\n* AND R15 HAS ITS LENGTH. IF R15 IS ZERO NO KEYWORD IS PRESENT.       *\n***********************************************************************\n         SCAN  0,MAXLEN=8          SCAN 1ST KEYWORD (COMMAND)\n         LTR   R15,R15             IF NO COMMAND FOUND,\n         BNP   GETSYSIN            THEN IGNORE THIS CARD, GET ANOTHER\n         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTES\n         LA    R14,COMMAND         GET READY TO SET UP COMMAND NAME\n         MVC   0(8,R14),BLANKS     BLANK OUT COMMAND NAME AREA\n         EX    R15,MVCCMD          MOVE COMMAND FROM STMT TO STORAGE\n         LA    R6,CMDTABLE         BEGIN COMMAND TABLE SEARCH\n         LA    R0,12               SET BXLE REGISTER\n         LA    R1,CMDTBEND-12      SET BXLE REGISTER\nCMDLOOP  EX    R15,COMPCMD         COMPARE COMMAND TO TABLE ENTRY\n         BE    CMDFOUND            IF EQUAL, EXIT LOOP\n         BXLE  R6,R0,CMDLOOP       ELSE CONTINUE SEARCH\nCMDNF    WRTMSG CNFMSG             AT END SAY COMMAND INVALID\n         B     GETSYSIN            AND GET ANOTHER CONTROL STATEMENT.\n         SPACE\nCMDFOUND DS    0H                  COMMAND FOUND IN TABLE - PROCESS IT\n         TM    8(R6),REQLOAD       IF A MODULE MUST BE LOADED\n         BZ    CMDDOIT              AND\n         TM    SWITCH,LOADED        THERE ISN'T ONE\n         BO    CMDDOIT              THEN\n         WRTMSG NUTS                 SAY SO AND REJECT COMMAND\n         B     GETSYSIN            ELSE...\nCMDDOIT  DS    0H                  COMMAND OK TO PROCESS\n         L     R15,8(,R6)          LOAD ADDRESS OF COMMAND PROCESSOR\n         ST    R12,SAVEBASE        SAVE OUR BASE REGISTER\n         BALR  R14,R15             CALL IT\n         L     R12,SAVEBASE        RESTORE OUR BASE REGISTER\n         B     GETSYSIN             THEN GET NEXT CONTROL STATEMENT\n         SPACE 2\nEOF      DS    0H                  END OF FILE ON SYSIN CONTROL STMTS\nENDRTE   EQU   EOF                 (ALSO \"END\" COMMAND PROCESSOR)\n         SPACE\n         OI    SWITCH,CLEANUP      INDICATE FINAL CLEANUP REQUIRED\n         ICM   R15,15,@NAMERTE     LOAD ADDRESS OF NAME PROCESSOR\n         ST    R12,SAVEBASE        SAVE OUR BASE REGISTER\n         BALR  R14,R15             CALL NAME RTE TO CLEAN UP ONLY\n         L     R12,SAVEBASE        RESTORE OUR BASE REGISTER\n         SPACE\n         TM    SWITCH,SYSINTRM     IF SYSIN ALLOCATED TO TERMINAL,\n         BZ    NOUNSTAX            THEN\n         STAX  ,                    CANCEL ATTENTION EXIT\nNOUNSTAX DS    0H\n         SPACE\n         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE\n         BZ    ENDNISPF            THEN\n* ISPEXEC TBEND TABLE-NAME\n         LA    R14,=C'TBEND'\n         LA    R15,TABLE\n         STM   R14,R15,ISPPARMS\n         OI    ISPPARM2,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15              CLEAN UP\n*\n* ISPEXEC VDELETE (XLLCMD XLLROW)\n*\n         LA    R14,=C'VDELETE'\n         LA    R15,=C'(XLLCMD XLLROW)'\n         STM   R14,R15,ISPPARMS\n         OI    ISPPARM2,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         SPACE\n         DELETE EPLOC==CL8'ISPLINK' RELEASE ISPLINK\n         B     AFTNISPF            ELSE\n         SPACE\nENDNISPF DS    0H                   NOT IN ISPF MODE\n         CLOSE (SYSIN,,SYSPRINT)    SO CLOSE SYSIN AND SYSPRINT\nAFTNISPF DS    0H\n         CLOSE (SYSLIB)            WRAP IT UP\n         XR    R15,R15             RETURN CODE(ZERO)\n         B     RETURN              RETURN TO SYSTEM\n         SPACE 2\nBADRET   DS    0H                  COME HERE ON BAD RETURN\n         SPACE\n         LA    R15,12              RETURN CODE(12)\n         SPACE\nRETURN   L     R13,4(,R13)         MAINLINE RETURN POINT\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 4\nMVCCMD   MVC   0(0,R14),0(R8)      EXECUTED: MOVE COMMAND FROM INPUT\nCOMPCMD  CLC   COMMAND(0),0(R6)    EXECUTED: COMPARE CMD TO TABLE ENTRY\nMVCPANEL OC    PANEL(0),0(R8)      EXECUTED: MOVE PANEL NAME FROM PARM\nMVCSYSDD OC    SYSLIB+40(0),0(R8)  EXECUTED: MOVE PARM DD TO SYSLIB DCB\n         SPACE\nCMDTABLE DS    0X                  TABLE OF VALID XLL COMMANDS\n         DC    CL8'NAME    ',YL1(NOTHING),AL3(NAMERTE)\n         DC    CL8'FIND    ',YL1(REQLOAD),AL3(FINDRTE)\n         DC    CL8'LIST    ',YL1(REQLOAD),AL3(LISTRTE)\n         DC    CL8'MAP     ',YL1(REQLOAD),AL3(MAPRTE)\n         DC    CL8'AMAP    ',YL1(REQLOAD),AL3(AMAPRTE)\n         DC    CL8'WHERE   ',YL1(REQLOAD),AL3(WHERERTE)\n         DC    CL8'DIR     ',YL1(NOTHING),AL3(DIRRTE)\n         DC    CL8'END     ',YL1(NOTHING),AL3(ENDRTE)\nCMDTBEND EQU   *                   END OF COMMAND TABLE\nNOTHING  EQU   X'00'               ... NO SPECIAL REQUIREMENTS\nREQLOAD  EQU   X'80'               1 = MODULE MUST BE LOADED TO EXECUTE\n         SPACE\n@NAMERTE EQU   CMDTABLE+8          ADDRESS OF \"NAME\" COMMAND PROCESSOR\n         SPACE\n         USING INFMJFCB-16,R15\nBEGINMSG MSG   'XLL FOR ',(JFCBDSNM,44,W),' ON VOLUME ',(JFCBVOLS,6,C)\nBEGINCON MSG   'XLL FOR ',(JFCBDSNM,44,W),' ET AL. (CONCATENATION)'\n         DROP  R15\nSYSINMSG MSG   (0(R1),80,C)        USED TO PRINT CONTROL STATEMENT\nCNFMSG   MSG   '*INVALID COMMAND'\nNUTS     MSG   '*NO MODULE IS CURRENTLY LOADED, COMMAND REJECTED'\nINPUTMSG MSG   '*ATTENTION INTERRUPT - REENTER'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - NAME COMMAND PROCESSOR'\n***********************************************************************\n* \"NAME\" COMMAND PROCESSOR                                            *\n* THIS COMMAND CAUSES A MODULE TO BE LOADED INTO MAIN STORAGE AND ITS *\n* CESD ENTRIES COLLECTED IN BOTH ADDRESS AND NAME ORDER.  SYNTAX:     *\n*              N(AME)  LOADNAME  CSECTNAME                            *\n* WHERE: LOADNAME IS REQUIRED AND IS THE NAME OF THE LOAD MODULE ON   *\n*        THE SYSLIB LIBRARY                                           *\n*        CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE CONTROL  *\n*        SECTION TO BE PROCESSED BY SUBSEQUENT FIND COMMANDS.  IF     *\n*        THIS IS OMITTED THEN ALL CSECTS ARE PROCESSED.               *\n***********************************************************************\n         SPACE\nNAMERTE  DS    0H\n         SPACE\n***********************************************************************\n* ESTABLISH ADDRESSABILITY HERE FOR ALL TABLES CREATED IN THIS RTE.   *\n***********************************************************************\n         USING ESDTABLE,R5           ADDRESS THE ESD TABLE\n         USING ESDENTRY,R6           ADDRESS EACH ENTRY WITHIN IT\n         USING OVLYTBL,R10           ADDRESS THE OVERLAY TBL ENTRIES\n         SPACE\n         ST    R14,SAVE14          SAVE RETURN REGISTER\n         LR    R12,R15\n         USING NAMERTE,R12\n         XR    R7,R7               CLEAR READ BUFFER ADDRESS\n         TM    SWITCH,CLEANUP      IF CALLED ONLY TO CLEAN UP (END),\n         BO    NAMPURGE            THEN FREE UP EVERYTHING AND RETURN\n         SCAN  1,MAXLEN=8          ELSE SCAN 1ST KEYWORD (LOAD MODULE)\n         LTR   R8,R8               CHECK RETURN FROM SCAN\n         BM    NAMPURGE            IF LOAD MODULE NAME INVALID, FAIL\n         BP    NK1OK               IF NO LOAD MODULE NAME ENTERED,\n         LA    R1,NOOPMSG           THEN SAY SO\n         B     NAMEERR              AND FINISH\nNK1OK    LA    R14,KEYWORD         ELSE READY TO SET UP LOAD MOD NAME\n         MVC   0(8,R14),BLANKS     BLANK OUT NAME AREA\n         BCTR  R15,0               REDUCE LOAD NAME LENGTH FOR EXECUTES\n         EX    R15,MVCNAME         MOVE NAME FROM STMT TO STORAGE\n         MVC   CSECT,BLANKS        INIT CSECT NAME = BLANK\n         SCAN  2,MAXLEN=8          SCAN 2ND KEYWORD (CSECT NAME)\n         LTR   R8,R8               CHECK RETURN FROM SCAN\n         BM    NAMPURGE            IF CSECT NAME INVALID, FAIL\n         BZ    NOCSECT             IF CSECT OMITTED, PROCESS WITHOUT IT\n         LA    R14,CSECT           ELSE READY TO SET UP CSECT NAME\n         BCTR  R15,0               REDUCE CSECTNAME LENGTH FOR EXECUTES\n         EX    R15,MVCNAME         MOVE CSECT NAME FROM STMT TO STORAGE\nNOCSECT  DS    0H\n         CLI   LOADMOD,C' '        IF NO CURRENT LOAD MODULE\n         BE    NAFREE              THEN DON'T FREE OR DELETE ANYTHING\n         CLC   LOADMOD,KEYWORD     ELSE IF NEW LOAD MOD = OLD LOAD MOD\n         BE    ENDLNKS             THEN KEEP IT, DON'T DO ANOTHER LOAD\n         BAL   R14,FREELOAD        ELSE FREE CURRENT MODULE STORAGE\nNAFREE   DS    0H                  NOW WE HAVE NO LOAD MODULE AROUND\n         MVC   LOADMOD,KEYWORD     SET UP LOAD MODULE NAME\n         BLDL  SYSLIB,BLDLLIST     SEE IF LOAD MODULE EXISTS IN LIBRARY\n         LTR   R15,R15             IF BLDL SUCCESSFUL\n         BZ    BLDL0               THEN GO AHEAD\n         L     R1,BLDLXMSG-4(R15)  ELSE GET MESSAGE FOR BLDL ERROR\n         B     NAMEERR             AND GO TO DISPLAY ERROR MESSAGE\n         SPACE\nBLDL0    DS    0H                  BLDL SUCCESSFUL - CONTINUE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         AGO   .NOLMTST            TEST FOR LOAD MOD VALIDITY IS N.G.\n         MVC   TESTBYTE,PDS2INDC   GET INDICATOR BYTE\n         NI    TESTBYTE,B'00011111' CLEAR EXTRANEOUS BITS\n         CLI   TESTBYTE,22         TO GET # OF USER DATA HALFWORDS\n         BE    ISAMOD              THIS MUST BE EXACTLY 22 OR ELSE...\n         LA    R1,BLDL0MSG          SAY SO\n         B     NAMEERR              AND FINISH\nISAMOD   DS    0H\n.NOLMTST ANOP\n         TM    PDS2ATR1,PDS2OVLY   IF MODULE HAS THE OVERLAY ATTRIBUTE\n         BNO   NOTOVLY             THEN\n         XR    R2,R2                CLEAR INSERT REG\n         IC    R2,PDS2NL            GET NUMBER OF OVERLAY SEGMENTS\n         LA    R2,1(,R2)            ADD 1 TO INCLUDE ENTRY ZERO\n         SLA   R2,OVSHIFT           CONVERT TO LENGTH OF ALL ENTRIES\n         LR    R0,R2                THIS IS THE REQUIRED LENGTH\n         CGETMAIN ,                 GET STORAGE FOR OVERLAY TABLE\n         LTR   R15,R15              IF STORAGE NOT AVAILABLE,\n         BNZ   NOTENUF              THEN BLOW UP. ELSE...\n*** ASSUME R15 = 0\n         ST    R15,LOADADDR         CLEAR LOAD MODULE ADDRESS\n         LR    R10,R1               SET ADDRESS OF OVERLAY TABLE\n         LR    R0,R10               ADDRESS OF OVERLAY TABLE\n         LR    R1,R2                LENGTH OF OVERLAY TABLE\n         XR    R14,R14              CLEAR FROM-ADDRESS REG\n*** ASSUME R15 = 0 (RETURN CODE FROM SUCCESSFUL GETMAIN)\n******** XR    R15,R15              CLEAR FROM-LENGTH REG\n         MVCL  R0,R14               CLEAR ALL OF THE TABLE TO ZEROES\n         ST    R2,OVTBLEN           STORE LENGTH OF REQUIRED STORAGE\n         MVI   CURSEG#+1,0          SET CURRENT SEGMENT NUMBER = 0\n         MVC   MAXSEG#+1(1),PDS2NL  SET MAXIMUM SEGMENT NUMBER\n         OI    SWITCH,NEWSEG        INDICATE A NEW SEGMENT WILL COME\n         B     AFTOVLY              DON'T SET TOTAL MODULE LENGTH\nNOTOVLY  DS    0H\n         SPACE\n***********************************************************************\n* FOR A NON-OVERLAY MODULE,                                           *\n* ALLOCATE STORAGE FOR THE LOAD MODULE ITSELF USING THE TOTAL LENGTH  *\n* FROM THE PDS DIRECTORY ENTRY.                                       *\n***********************************************************************\n         SPACE\n         XR    R0,R0               CLEAR INSERT REG\n         ICM   R0,7,PDS2STOR       LENGTH OF MAIN STORAGE FOR MODULE\n         ST    R0,LOADLEN          STORE LENGTH OF LOAD MODULE\n         CGETMAIN ,                GET A BUFFER FOR THE LOAD MODULE\n         LTR   R15,R15             IF STORAGE NOT AVAILABLE\n         BNZ   NOTENUF             THEN GO TO SAY SO\n         ST    R1,LOADADDR         ELSE SAVE ADDRESS OF LOAD MOD BUFFER\n         AL    R1,LOADLEN          ADD LENGTH OF LOAD MODULE\n         SPACE\nAFTOVLY  DS    0H\n         SPACE\n***********************************************************************\n* SET UP TO READ LOAD MODULE RECORDS BY ISSUING FIND MACRO USING THE  *\n* TTR FROM THE BLDL DIRECTORY DATA.                                   *\n* REFERENCE FOR LOAD MODULE RECORD FORMATS: LINKAGE EDITOR LOGIC      *\n***********************************************************************\n         SPACE 2\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         FIND  SYSLIB,LOADMOD+8,C  FIND START OF MEMBER USING TTR\n         LTR   R15,R15             IF FIND FAILED,\n         BZ    FINDOK              THEN\n         LA    R1,FINDMSG           SAY SO\n         B     NAMEERR              AND FINISH\nFINDOK   DS    0H                  ELSE READY TO READ DATA\n         LH    R0,SYSLIB+62        GET LOAD LIBRARY BLOCKSIZE\n         CGETMAIN ,                USE IT TO GET A READ BUFFER\n         LTR   R15,R15             IF NOT ENOUGH STORAGE\n         BNZ   NOTENUF             THEN GO TO SAY SO\n         LR    R7,R1               ELSE SET READ BUFFER ADDRESS\n         NI    SWITCH,255-CESDRECS-INTEXT-SEGTAB INITIALIZE SWITCH\n* BYPASS END-OF-FILE / CONTROL-RECORD CHECK, GO READ FIRST MODULE REC\n         B     READ1ST              GO READ FIRST MODULE RECORD\n         SPACE\nREADLOOP DS    0H                  READ NON-TEXT LOAD MODULE RECORDS\n         TM    0(R7),X'08'         IF END-OF-MODULE ON IN LAST REC READ\n         BO    ENDRECS             THEN GO TO END-OF-DATA ROUTINE\n         LTR   R10,R10             ELSE IF PROCESSING AN OVERLAY MODULE\n         BZ    READ1ST              AND\n         TM    0(R7),X'04'           END-OF-SEGMENT ON IN LAST REC READ\n         BZ    READ1ST                THEN\n         OI    SWITCH,NEWSEG           INDICATE A NEW SEGMENT IS COMING\nREAD1ST  DS    0H                  ELSE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         READ  DECB,SF,,(R7),'S',MF=E  READ RECORD (R7 -> READ BUFFER)\n         CHECK DECB                WAIT FOR I/O TO COMPLETE\n         TM    0(R7),X'01'         IF THIS IS A CONTROL RECORD,\n         BO    CONTROL             THEN PROCESS CONTROL & TEXT RECORD\n         TM    0(R7),X'20'         ELSE IF THIS IS A CESD RECORD,\n         BNO   READLOOP            THEN PROCESS, ELSE GO GET ANOTHER.\n         SPACE\nTHISCESD DS    0H                  THIS IS A CESD RECORD\n         OI    SWITCH,CESDRECS     IF WE GOT A CESD, INDICATE SO\n         LA    R3,8(,R7)           INIT R3 -> 1ST ESD ENTRY IN RECORD\n         LH    R4,6(,R7)           GET COUNT OF ESD DATA IN RECORD\n         ALR   R4,R3               R4 -> END OF ESD ENTRIES IN RECORD\nCESDLOOP DS    0H                  LOOP TO PROCESS EACH ENTRY IN RECORD\n         CR    R3,R4               WHEN NO MORE ESD'S IN THIS RECORD,\n         BNL   READLOOP             GO READ ANOTHER LOAD MODULE RECORD\n         MVC   TESTTYPE,8(R3)      PICK UP ESD TYPE INDICATION\n         NI    TESTTYPE,X'0F'      ZERO OUT THE SUBCLASSIFICATION BITS\n         CLI   TESTTYPE,ESDPC      IF THIS ENTRY IS PC (PRIVATE CODE)\n         BE    ESDTYPOK             THEN GO PROCESS IT\n         CLI   TESTTYPE,ESDSD      IF THIS ENTRY IS SD (SECTION DEF.)\n         BE    ESDTYPOK             THEN GO PROCESS IT\n         CLI   TESTTYPE,ESDCM      IF THIS ENTRY IS CM (COMMON)\n         BE    ESDTYPOK             THEN GO PROCESS IT\n         LA    R3,16(,R3)          ELSE BUMP TO NEXT CESD ENTRY\n         B     CESDLOOP            CONTINUE WITH NEXT ENTRY\nESDTYPOK DS    0H\n         SPACE 2\n***********************************************************************\n* WE STORE THE ESD ENTRIES IN THE TABLE IN ASCENDING ORDER OF         *\n* ALPHABETIC NAMES, BUT LINKED IN ASCENDING ORDER OF RELATIVE         *\n* ADDRESSES.  A SCAN FOR NAME MAY BE DONE BY MEANS OF A BINARY SEARCH *\n* (ALTHOUGH THIS HAS YET TO BE IMPLEMENTED), WHEREAS A SEARCH BY      *\n* RELATIVE ADDRESS MUST BE DONE BY MEANS OF CHAINING THROUGH THE LINK *\n* FIELDS.  NOTE THAT FOR A PRIVATE CODE ENTRY THE NAME $PRIVATE IS    *\n* USED IN THE TABLE.                                                  *\n***********************************************************************\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         ICM   R15,15,ESDBUFAD     GET ADDRESS OF OUR ESD TABLE BUFFER\n         BNZ   GOTESDBF            IF WE DON'T HAVE ONE YET, THEN...\n         LA    R14,INITLNTH+ESDHDRLN GET LENGTH FOR INITIAL BUFFER\n         LR    R0,R14\n         CGETMAIN ,                  GET STORAGE FOR ESD TABLE\n         LTR   R15,R15               IF WE DIDN'T GET IT\n         BNZ   NOTENUF               THEN GO TO SAY SO\n         ST    R1,ESDBUFAD           ELSE SET ESD TABLE ADDRESS\n         LR    R5,R1                 R5 -> ESD TABLE\n         ST    R14,ESDBUFLN          LENGTH OF ESD BUFFER TO FREE\n         ST    R14,ESDTBLEN          LENGTH OF ESD BUFFER FOR OUR USE\n         LA    R0,ESDHDRLN           INITIALIZE OFFSET OF\n         ST    R0,ESDAVAIL            FIRST UNUSED ENTRY SLOT\n***  ASSUME  R15 = ZERO  (RETURN CODE FROM SUCCESSFUL GETMAIN)\n         ST    R15,ESD#ENTS          INITIAL NUMBER OF ENTRIES = 0\n         ST    R15,ESDLKHDR          CLEAR LINK POINTER\nGOTESDBF DS    0H                  WE NOW HAVE AN ESD BUFFER\n         LA    R15,ESDENTLN        GET OFFSET OF END OF NEXT SLOT\n         A     R15,ESDAVAIL        IF NEXT AVAILABLE SLOT\n         C     R15,ESDTBLEN         IS NOT WITHIN END OF BUFFER,\n         BNH   ESDROOM             THEN...\n* ADD LENGTH FOR NEW ENTRIES TO THE BUFFER LENGTH\n         LA    R0,INITLNTH           COMPUTE LENGTH OF NEW BUFFER\n         AL    R0,ESDTBLEN           AND PUT IT IN\n         ST    R0,ESDTBLEN            LENGTH FIELD OF OLD BUFFER\n         CGETMAIN ,                  GET A NEW BUFFER\n         LTR   R15,R15               IF WE DIDN'T GET IT\n         BNZ   NOTENUF               THEN GO TO SAY SO\n         LR    R0,R1                    ADDRESS OF NEW BUFFER\n         L     R1,ESDTBLEN-ESDTABLE(,R5) LENGTH OF NEW BUFFER\n         L     R14,ESDBUFAD             ADDRESS OF OLD BUFFER\n         L     R15,ESDBUFLN              LENGTH OF OLD BUFFER\n         LR    R5,R0                 POINT TO THE NEW BUFFER NOW\n         MVCL  R0,R14                MOVE OLD BUFFER DATA TO NEW BUFFER\n         L     R1,ESDBUFAD           GET ADDRESS OF OLD BUFFER\n         L     R0,ESDBUFLN           GET LENGTH OF OLD BUFFER\n         FREEMAIN R,A=(1),LV=(0)     FREE THE OLD BUFFER\n         ST    R5,ESDBUFAD           STORE THE NEW ESD BUFFER ADDRESS\n         MVC   ESDBUFLN,ESDTBLEN     STORE THE NEW ESD BUFFER LENGTH\nESDROOM  DS    0H                  WE NOW HAVE ROOM TO ADD NEW ENTRIES\n         L     R6,ESDAVAIL         GET OFFSET OF UNUSED ESD SLOT\n         ALR   R6,R5               CONVERT TO ADDR OF END OF LAST ENTRY\n         LA    R0,ESDHDRLN(,R5)    SET ADDR OF 1ST ENTRY FOR INSERTION\n         SPACE\nESDADDLP DS    0H                  WE NOW HAVE ROOM TO ADD NEW ENTRIES\n***********************************************************************\n* CHECK EACH CURRENT ESD TABLE ENTRY.  IF THE SORTING FIELD IN THIS   *\n* ENTRY IS LESS THAN OR EQUAL TO THE SORTING FIELD IN THE ENTRY BEING *\n* ADDED, THEN INSERT THE NEW ENTRY HERE.  OTHERWISE KEEP MOVING       *\n* BACKWARDS UNTIL SUCH AN ENTRY IS FOUND OR WE REACH THE BEGINNING OF *\n* THE ENTRIES.                                                        *\n***********************************************************************\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         SH    R6,=Y(ESDENTLN)     BUMP TO PREVIOUS ESD TABLE ENTRY\n         CR    R6,R0               IF IT PUTS US IN FRONT OF 1ST ENTRY,\n         BL    ESDADDHR            THEN GO TO INSERT NEW ENTRY HERE\n         CLC   ESDNAME,ESDNAME-ESDENTRY(R3) ELSE COMPARE THIS ENTRY\n         BNH   ESDADDHR            IF THIS IS THE PLACE, GO TO INSERT\n         MVC   ESDENTRY+ESDENTLN(ESDENTLN),ESDENTRY    ELSE MOVE ENTRY\n         B     ESDADDLP             UP TO NEXT SLOT AND TRY NEXT LOC.\nESDADDHR DS    0H                  TIME TO INSERT THE NEW ENTRY HERE\n         LA    R6,ESDENTLN(,R6)    BUMP TO POINT TO NEW ENTRY SLOT\n         MVC   ESDENTRY(16),0(R3)  MOVE FIXED CESD ENTRY DATA TO SLOT\n         XR    R0,R0               CLEAR INSERT REG\n         ICM   R0,7,ESDADDR        GET RELADDR OF ESD CONTROL SECTION\n         XR    R14,R14\n         ICM   R14,7,ESDLEN        GET LENGTH OF ESD CONTROL SECTION\n         ALR   R0,R14              RELADDR + LENGTH ...\n         ST    R0,ESDNADDR          GIVES ADDRESS OF DATA FF. CSECT\n         CLC   ESDNAME(8),BLANKS   IF NAME IS BLANK,\n         BNE   NOTBLANK            THEN...\n         CLI   ESDTYPE,ESDPC         IF PRIVATE CODE\n         BNE   NOTPRIV                  THEN\n         MVC   ESDNAME(8),$PRIVATE        CALL IT PRIVATE CODE\nNOTPRIV  DS    0H                  ELSE\n         CLI   ESDTYPE,ESDPCOV       IF PRIVATE CODE MARKED DELETE\n         BNE   NOTBLANK              THEN\n         TM    SWITCH,SEGTAB           IF A SEGMENT TABLE NOT FOUND YET\n         BO    SETENTAB                  THEN\n         MVC   ESDNAME(8),$SEGTAB          CALL IT A SEGMENT TABLE\n         OI    SWITCH,SEGTAB               AND INDICATE THAT ONE EXISTS\n         B     NOTBLANK                  ELSE\nSETENTAB MVC   ESDNAME(8),$ENTAB           CALL IT AN ENTRY TABLE\nNOTBLANK DS    0H\n         SPACE 2\n***********************************************************************\n* IF WE ARE PROCESSING AN OVERLAY MODULE, WE MUST COMPUTE THE TOTAL   *\n* CUMULATIVE STORAGE REQUIRED FOR EACH SEGMENT OF THE MODULE.  THIS   *\n* IS DONE BY ADDING THE LENGTH OF THE CONTROL SECTION TO THE          *\n* ADDRESS OF THE CONTROL SECTION, GIVING THE LARGEST POSSIBLE UPPER   *\n* BOUND, AND PLACING THE MAXIMUM SUCH VALUE IN THE                    *\n* APPROPRIATE ENTRY IN THE OVERLAY TABLE.                             *\n***********************************************************************\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         LTR   R10,R10             IF OVERLAY MODULE\n         BZ    ESDNOTOV            THEN...\n         XR    R1,R1               CLEAR INSERT REG\n         IC    R1,ESDSEGNO          GET SEGMENT NUMBER FOR THIS CSECT\n         SLA   R1,OVSHIFT           CONVERT TO INDEX\n         XR    R15,R15\n         ICM   R15,7,ESDADDR        GET CURRENT RELATIVE ADDRESS\n         L     R0,OVSEGHI(R1)       GET HIGH BOUND OF SEGMENT SO FAR\n         LTR   R0,R0                IF NO SEGMENT DATA YET\n         BZ    ESDSETOF             OR\n         CL    R15,OVSEGLO(R1)       ESD LESS THAN CURRENT LOW BOUND\n         BNL   ESDAFTST               THEN\nESDSETOF ST    R15,OVSEGLO(R1)         SET NEW LOW BOUND OF SEGMENT\nESDAFTST DS    0H\n         L     R15,ESDNADDR         GET ENDING ADDRESS OF THIS CSECT\n         CLR   R15,R0               IF THIS EXCEEDS PREV HIGH BOUND\n         BNH   ESDNOTOV             THEN\n         LA    R15,7(,R15)           ROUND UP TO DOUBLEWORD BOUNDARY\n         N     R15,=X'FFFFFFF8'      AND\n         ST    R15,OVSEGHI(R1)       STORE AS NEW SEGMENT HIGH BOUND\nESDNOTOV DS    0H\n         SPACE 2\n         LA    R15,ESDENTLN        LENGTH OF AN ESD ENTRY\n         A     R15,ESDAVAIL        PLUS LOCATION OF SLOT JUST FILLED\n         ST    R15,ESDAVAIL        GIVES UPDATED OFFSET OF UNUSED SLOT\n         LA    R15,1\n         A     R15,ESD#ENTS\n         ST    R15,ESD#ENTS        UPDATE NUMBER OF ESD ENTRIES BY 1\n         LA    R3,16(,R3)          BUMP UP INPUT CESD ENTRY POINTER\n         B     CESDLOOP            GO PROCESS NEXT CESD ENTRY.\n         SPACE 4\nCONTROL  DS    0H                  THIS IS A CONTROL RECORD\n         SPACE\n***********************************************************************\n* LOAD MODULE CONTROL RECORD PROCESSING:  THE CONTROL RECORD CONTAINS *\n* A CHANNEL COMMAND WORD (CCW) AT LOCATION 8 THAT CAN BE USED TO READ *\n* THE TEXT RECORD WHICH FOLLOWS.  WE USE THE DATA ADDRESS PORTION OF  *\n* THIS CCW TO DETERMINE THE OFFSET IN THE LOAD MODULE BUFFER WHERE    *\n* THE TEXT IS TO BE LOADED, AND THE BYTE COUNT TO GET THE LENGTH OF   *\n* THE BLOCK OF TEXT, WHICH IS THEN READ DIRECTLY INTO THE LOAD MODULE *\n* BUFFER AT THE SPECIFIED RELATIVE LOCATION.                          *\n***********************************************************************\n         SPACE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         XR    R2,R2               CLEAR INSERT REG\n         ICM   R2,7,9(R7)          GET DATA ADDRESS FROM CCW IN RECORD\n         LH    R4,14(,R7)          GET BYTE COUNT (LENGTH) FROM CCW\n         LTR   R10,R10             IF MODULE IS IN OVERLAY STRUCTURE\n         BZ    CTLNOTOV            THEN...\n         TM    SWITCH,NEWSEG        IF THIS WILL BE 1ST OF NEW SEGMENT\n         BZ    SAMESEG              THEN\n         NI    SWITCH,255-NEWSEG     RESET FLAG\nADDAGAIN DS    0H                    TO PREVENT INFINITE LOOPING,\n         TM    SWITCH,ATTN           CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE              WHILE WE...\n         LA    R14,1                 ADD 1 TO CURRENT-SEGMENT NUMBER\n         AH    R14,CURSEG#           UNTIL NON-NULL SEGMENT FOUND\n         STH   R14,CURSEG#           GET CURRENT SEGMENT NUMBER\n         SLA   R14,OVSHIFT           CONVERT TO INDEX INTO SEGMENT TBL\n         L     R0,OVSEGHI(R14)       GET HIGH BOUND OF SEGMENT\n         S     R0,OVSEGLO(R14)       SUBTRACT LOW BOUND OF SEGMENT\n         ST    R0,OVSEGLEN(R14)      GIVES LENGTH OF THIS SEGMENT\n         BZ    ADDAGAIN              IF ZERO, SKIP SEGMENT, USE NEXT 1\nSAMESEG  LH    R14,CURSEG#          NOW GET CURRENT SEGMENT NUMBER\n         SLA   R14,OVSHIFT          CONVERT TO INDEX INTO SEGMENT TABLE\n         L     R1,OVSEGADR(R14)     GET ADDR OF BUFFER FOR THIS SEG.\n         LTR   R1,R1                IF NO STORAGE ALLOCATED FOR IT YET\n         BNZ   CTLGOTIT             THEN\n         L     R0,OVSEGLEN(R14)      GET LENGTH OF THIS SEGMENT\n         CGETMAIN ,                  ACQUIRE THE STORAGE\n         LTR   R15,R15               IF STORAGE NOT AVAILABLE\n         BNZ   NOTENUF               THEN BLOW UP, ELSE....\n         ST    R1,OVSEGADR(R14)      SAVE ADDRESS OF STORAGE BUFFER\nCTLGOTIT DS    0H                   R1 NOW POINTS TO SEGMENT BUFFER\n         SL    R2,OVSEGLO(R14)      SUBTRACT LOW BOUND FROM DATA ADDR\n         ALR   R2,R1                ADD BUF ADDR GIVING OFFSET IN BUF\n         B     CTLAFTOV             AND CONTINUE\nCTLNOTOV DS    0H                  ELSE NON-OVERLAY MODULE...\n         AL    R2,LOADADDR          JUST ADD BUFFER ADDR TO GET OFFSET\nCTLAFTOV DS    0H                  NON-OVERLAY MODULE...\n         OI    SWITCH,INTEXT       INDICATE READING TEXT IN CASE OF EOF\n         READ  DECB,SF,,(R2),(R4),MF=E  READ TEXT RECORD INTO BUFFER\n         CHECK DECB                 USING OFFSET & LENGTH FROM CTL CCW\n         NI    SWITCH,255-INTEXT   TURN OFF TEXT READING INDICATOR\n         B     READLOOP            GO TO GET ANOTHER LOAD MODULE RECORD\n         SPACE 3\nENDRECS  DS    0H                  END OF FILE ON LOAD MODULE RECORDS\n         SPACE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    NAMPURGE\n         TM    SWITCH,INTEXT       IF EOF ENCOUNTERED WHEN TEXT EXPCTD\n         BO    IOERROR             THEN ERROR - SAY SO. ELSE...\n         TM    SWITCH,CESDRECS     IF NO CESD RECORDS IN LOAD MODULE\n         BZ    IOERROR             THEN ERROR - SAY SO. ELSE...\n***********************************************************************\n* FINISH PROCESSING THE EXTERNAL SYMBOL DICTIONARY TABLE ENTRIES.     *\n***********************************************************************\n         L     R15,ESDAVAIL        GET OFFSET OF AVAILABLE SLOT\n         ALR   R15,R5              CONVERT OFFSET TO VIRTUAL ADDRESS\n         BCTR  R15,0               CONVERT TO BXLE-COMPATIBLE FORMAT\n         ST    R15,ESDENDAD        STORE END-OF-ESD-ENTRIES ADDRESS\n         SPACE 4\n***********************************************************************\n* AFTER THE ESD TABLE HAS BEEN BUILT AND ALL ENTRIES INSERTED, DO FOR *\n* EACH ENTRY THE FOLLOWING:                                           *\n* SET THE LINK POINTER BY ORDER OF CONTROL SECTION OFFSET             *\n* CONCATENATED WITH SEGMENT NUMBER.  IN THIS WAY THE CESD ENTRIES     *\n* WILL BE ORDERED IN A SINGLY LINKED LIST BY (1) RELATIVE ADDRESS AND *\n* (2) OVERLAY SEGMENT.                                                *\n***********************************************************************\n         SPACE 2\n         LA    R6,ESDHDRLN(,R5)    POINT TO WHERE 1ST ENTRY IS\n         LA    R0,ESDENTLN         SET BXLE REGISTER\n         L     R1,ESDENDAD         SET BXLE REGISTER\nLNKLOOP1 DS    0H                  LOOP UNTIL OUT OF INPUT ENTRIES\n         LA    R14,ESDLKHDR-ESDTABLE(,R5) POINT TO 1ST ENTRY IN CHAIN\nLNKLOOP2 ICM   R15,15,0(R14)       POINT TO ESD ENTRY TO COMPARE\n         BZ    LNKINSRT            IF NO MORE, GO INSERT @ END OF CHAIN\n         CLC   ESDARG-ESDENTRY(L'ESDARG,R15),ESDARG   COMPARE ARGUMENTS\n         BH    LNKINSRT            IF NOT THE PLACE, THEN GET THE NEXT\n         LA    R14,ESDLINKP-ESDENTRY(,R15)  CANDIDATE FOR INSERTION AND\n         B     LNKLOOP2                     TRY IT.\nLNKINSRT DS    0H                  WHEN PLACE FOUND TO INSERT...\n         MVC   ESDLINKP,0(R14)     LINK NEXT ENTRY TO OUR ENTRY\n         ST    R6,0(,R14)          LINK US TO PREVIOUS ENTRY\n         BXLE  R6,R0,LNKLOOP1      CONTINUE WITH NEXT INPUT ENTRY\n         SPACE 2\nENDLNKS  DS    0H                  ESD TABLE ALL SET UP, NO MORE WORK\n         SPACE\n         TM    SWITCH,LOADED       IF LOAD MODULE PREVIOUSLY LOADED\n         BZ    LOADIT              THEN...\n         LA    R1,LOADMSGA          GO TO SAY IT IS BEING RETAINED\n         B     AFTLDED             ELSE...\nLOADIT   BAL   R14,FREEREAD         FREE THE READ BUFFER\n         OI    SWITCH,LOADED        INDICATE THAT THE MODULE IS LOADED\n         XR    R0,R0                CLEAR INSERT REG\n         IC    R0,PDS2CNCT          GET BLDL CONCATENATION NUMBER\n         MH    R0,=H'20'            CONVERT TO INDEX INTO TIOT ENTRY\n         AH    R0,SYSLIB+40         ADD TIOT OFFSET TO GET IXD OFFSET\n         L     R15,540              GET TCB ADDRESS\n         L     R15,12(,R15)         GET TIOT ADDRESS\n         ALR   R15,R0               ADD TO TIOT ADDR TO GET ENTRY ADDR\n         ICM   R15,7,12(R15)        GET JFCB ADDRESS (-16) FOR SYSLIB\n         LA    R1,LOADMSGG          GO SAY IT IS LOADED OK\nAFTLDED  WRTMSG (R1),USE15=YES     TELL USER IT'S LOADED 1 WAY OR OTHER\n***********************************************************************\n* NOW SET STARTING ABSOLUTE ADDRESS OF THE CSECT BEING PROCESSED.     *\n* IF NO CSECT SPECIFIED, THEN USE ADDRESS OF ENTIRE LOAD MODULE.      *\n***********************************************************************\n         SPACE\n         CLI   CSECT,C' '          IF NO SPECIFIC CSECT REQUESTED\n         BE    WHOLEMOD            THEN USE ENTIRE MODULE. ELSE...\n         L     R5,ESDBUFAD         ADDRESS THE ESD TABLE\n         LA    R6,ESDHDRLN(,R5)    POINT TO BEGINNING OF ESD TABLE\n         LA    R0,ESDENTLN         SET BXLE REGISTER\n         L     R1,ESDENDAD         SET BXLE REGISTER\nCFNLOOP  DS    0H                  UNTIL END OF ESD ENTRIES (ALPH ORD)\n         CLC   CSECT,ESDNAME       COMPARE CSECT NAME WITH ENTRY NAME\n         BE    CSECTF              IF MATCH, EXIT LOOP\n         BXLE  R6,R0,CFNLOOP       ELSE CONTINUE WITH NEXT ESD ENTRY\nCSECTNF  DS    0H                  IF CSECT NAME NOT FOUND...\n         WRTMSG CSNFMSG             SAY SO\n         MVC   CSECT,BLANKS         AND USE ENTIRE LOAD MODULE INSTEAD\n         B     WHOLEMOD            ELSE...\nCSECTF   DS    0H                   STORE ADDRESS OF ACTIVE ESD ENTRY\n         XR    R15,R15              CLEAR INSERT REG\n         ICM   R15,7,ESDADDR        GET OFFSET OF CONTROL SECTION\n         LTR   R10,R10              IF OVERLAY MODULE\n         BZ    CSNOTOV              THEN...\n         XR    R1,R1                 CLEAR INSERT REG\n         IC    R1,ESDSEGNO           GET SEGMENT NUMBER\n         SLA   R1,OVSHIFT            CONVERT TO INDEX\n         SL    R15,OVSEGLO(R1)       CVT MOD OFFSET TO OFF WITHIN SEG\n         AL    R15,OVSEGADR(R1)      ADD VIRTUAL ADDR OF SEGMENT BUFFER\n         B     CSAFTOV              ELSE...\nCSNOTOV  DS    0H                    (NOT OVERLAY)...\n         AL    R15,LOADADDR          ADD VIRTUAL ADDRESS OF LOAD MODULE\nCSAFTOV  DS    0H\n         ST    R15,ADRSTART         R15 GIVES STARTING ADDRESS OF CSECT\n         ST    R6,CURRESD           SAVE ESD ENTRY ADDR FOR THIS CSECT\n         B     GOODRET              RETURN TO MAINLINE\n         SPACE\nWHOLEMOD DS    0H                  NO VALID CSECT ENTERED, USE ALL.\n         LTR   R10,R10             IF OVERLAY MODULE\n         BZ    WHOLESET            THEN\n         XR    R0,R0                MAKE A ZERO\n         ST    R0,CURRESD           CLEAR ESD ENTRY ADDRESS\n         ST    R0,ADRSTART          CLEAR STARTING ADDRESS\n         B     GOODRET             ELSE\nWHOLESET DS    0H                  (NOT OVERLAY - USE ENTIRE MODULE)\n         MVC   ADRSTART,LOADADDR    STARTING ADDRESS = LOAD MOD ADDR\n         B     GOODRET\n         EJECT\nNOTENUF  DS    0H                  INSUFFICIENT STORAGE\n         SPACE\n         LA    R1,NOSTRG           GO SAY THERE'S NOT ENOUGH STORAGE\n         B     NAMEERR             AND GO FINISH UP.\n         SPACE\nIOERROR  DS    0H                  HERE WHEN LOGICAL I/O ERROR IN MOD\n         SPACE\n         LA    R1,IOERMSG          GO TO SAY SOMETHING'S WRONG WITH\n******** B     NAMEERR              THE LOAD MODULE\n         EJECT\nNAMEERR  DS    0H\n         SPACE\n***********************************************************************\n* FAILURE IN \"NAME\" COMMAND PROCESSING - CLEAR OUT ALL PREVIOUSLY SET *\n* FIELDS ASSOCIATED WITH LOAD MODULE OR CSECT NAMES                   *\n***********************************************************************\n         SPACE\n         WRTMSG (R1)               DISPLAY ERROR MESSAGE\n         SPACE\nNAMPURGE DS    0H                  GO HERE IF NO MSG TO BE DISPLAYED\n         SPACE\n         NI    SWITCH,255-ATTN\n         MVC   LOADMOD,BLANKS      CLEAR MODULE NAME\n         MVC   CSECT,BLANKS        CLEAR CSECT NAME\n         BAL   R14,FREELOAD        FREE CURRENT MODULE STORAGE IF ANY\n         B     COMMONRT            RETURN TO MAINLINE\n         EJECT\nFREELOAD DS    0H                  SUBROUTINE TO FREE MODULE STORAGE\n         SPACE\n         TM    SWITCH,LOADED       IF A MODULE IS STILL LOADED\n         BZ    FREEOVLY            THEN\n         ICM   R1,15,LOADADDR        GET ADDRESS OF LOAD MODULE\n         BZ    FREEOVLY              IF NONE (OVERLAY), SKIP FREE\n         L     R0,LOADLEN            GET LENGTH OF LOAD MODULE\n         FREEMAIN R,LV=(0),A=(1)     DELETE IT\n         SPACE\nFREEOVLY DS    0H\n         LTR   R10,R10             IF THERE IS AN OVERLAY TABLE\n         BZ    FREEESD             THEN\n* FIRST, FREE ALL THE SEGMENT BUFFERS\n         LH    R4,MAXSEG#          GET NUMBER OF OVERLAY SEGMENTS\n         XR    R2,R2               INITIALIZE INDEX REGISTER\nFREEOVLP LA    R2,OVENTLB(,R2)     INCREMENT INDEX REGISTER\n         L     R1,OVSEGADR(R2)     GET ADDRESS OF SEGMENT BUFFER\n         LTR   R1,R1               IF THERE IS ONE,\n         BZ    NOFROVSG            THEN\n         L     R0,OVSEGLEN(R2)      GET LENGTH OF SEGMENT BUFFER\n         FREEMAIN R,LV=(0),A=(1)    AND FREE IT\nNOFROVSG BCT   R4,FREEOVLP         CONTINUE FOR EVERY SEGMENT DEFINED\n* NOW, FREE THE OVERLAY TABLE\n         L     R0,OVTBLEN          GET LENGTH OF OVERLAY TABLE\n         LR    R1,R10              GET ADDRESS OF OVERLAY TABLE\n         FREEMAIN R,LV=(0),A=(1)   FREE IT\n         SPACE\nFREEESD  DS    0H\n         NI    SWITCH,255-LOADED   SET FLAG OFF\n         XR    R10,R10             CLEAR OVERLAY TABLE ADDRESS\n         ST    R10,LOADADDR        CLEAR LOAD MODULE ADDRESS\n         ST    R10,LOADLEN         CLEAR LOAD MODULE LENGTH\n         ST    R10,CURRESD         CLEAR ESD ENTRY ADDRESS\n         ST    R10,ADRSTART        CLEAR CSECT FIELDS\n         ICM   R1,15,ESDBUFAD      IF THERE WAS AN ESD TABLE ALLOCATED\n         BZ    FREEREAD            THEN\n         L     R0,ESDBUFLN           GET LENGTH OF IT\n         FREEMAIN R,LV=(0),A=(1)     FREE IT\n         ST    R10,ESDBUFAD          CLEAR ITS ADDRESS\n         ST    R10,ESDBUFLN          AND CLEAR ITS LENGTH\n         SPACE\nFREEREAD DS    0H                  SUBROUTINE TO FREE THE READ BUFFER\n         LTR   R1,R7               GET ADDRESS OF THE READ BUFFER\n         BZR   R14                 IF THERE IS ONE, THEN\n         LH    R0,SYSLIB+62          PICK UP BLOCKSIZE=LENGTH OF BUFFER\n         FREEMAIN R,LV=(0),A=(1)     FREE THE READ BUFFER\n         XR    R7,R7                 AND CLEAR ITS POINTER\n         BR    R14                 RETURN TO CALLER\n         EJECT\nMVCNAME  MVC   0(0,R14),0(R8)      EXECUTED: MOVE NAME FROM INPUT\n         SPACE\nBLDLXMSG DC    A(BLDL4MSG,BLDL8MSG) BLDL ERROR MESSAGE VECTOR\n         SPACE\nNOOPMSG  MSG   '*NO OPERANDS, COMMAND REJECTED'\n         AGO   .NOLMTS2\nBLDL0MSG MSG   '*MEMBER ',LOADMOD,' IS NOT A LOAD MODULE'\n.NOLMTS2 ANOP\nBLDL4MSG MSG   '*LOAD MODULE ',LOADMOD,' NOT FOUND'\nBLDL8MSG MSG   '*DIRECTORY ERROR - LIBRARY MAY NOT BE A PDS'\nFINDMSG  MSG   '*FIND ERROR FOR ',LOADMOD,' - RETURN CODE = ',ERRCODE\nNOSTRG   MSG   '*NOT ENOUGH STORAGE TO PROCESS MODULE ',LOADMOD\nLOADMSGA MSG   'MODULE ',LOADMOD,' IS ALREADY LOADED'\n         USING INFMJFCB-16,R15\nLOADMSGG MSG   'MODULE ',LOADMOD,' LOADED FROM ',                      X\n               (JFCBDSNM,44,W),' ON ',(JFCBVOLS,6,C)\n         DROP  R15\nCSNFMSG  MSG   '*CSECT ',CSECT,' NOT FOUND IN MODULE ',LOADMOD\nIOERMSG  MSG   '*LOGICAL I/O ERROR IN LOAD MODULE ',LOADMOD\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - FIND COMMAND PROCESSOR'\n***********************************************************************\n* \"FIND\" COMMAND PROCESSOR                                            *\n* THIS COMMAND SEARCHES THE CURRENT LOAD MODULE (OR CSECT, IF ONE WAS *\n* SPECIFIED ON THE MOST RECENT NAME COMMAND) FOR A SPECIFIED STRING   *\n* (WHICH MAY BE SPECIFIED GENERICALLY OR EXPLICITLY, IN ONE OF        *\n* SEVERAL FORMATS).  SYNTAX:                                          *\n*              F(IND)  STRING  ALIGNMENT                              *\n* WHERE: STRING IS REQUIRED UNLESS ONE HAS BEEN SPECIFIED ON A        *\n*        PREVIOUS FIND COMMAND (FORMATS BELOW)                        *\n*        ALIGNMENT IS OPTIONAL AND SPECIFIES DOUBLEWORD, FULLWORD,    *\n*        HALFWORD, OR NO ALIGNMENT (THESE MAY BE ABBREVIATED)         *\n* THE FIRST OPERAND OF THE FIND COMMAND MUST BE IN ONE OF THE         *\n* FOLLOWING FORMATS:                                                  *\n* NNN...N    WHERE EACH N IS A MEMBER OF THE SET 0123456789ABCDEF,*   *\n* X'NNN...N' WHERE EACH N IS A MEMBER OF THE SET 0123456789ABCDEF,*   *\n* C'NNN...N' WHERE EACH N IS ANY CHARACTER, 2 QUOTES REPRESENTING 1   *\n* G'NNN...N' WHERE EACH N IS ANY CHARACTER, 2 QUOTES REPRESENTING 1   *\n* F'...N'    WHERE ...N IS A # BETWEEN -2147483648 AND 2147483647     *\n* H'...N'    WHERE ...N IS A # BETWEEN -32768 AND 32767               *\n* *          AN ASTERISK, MEANING USE THE PREVIOUSLY SPECIFIED STRING *\n* THE SECOND OPERAND OF THE FIND COMMAND MUST BE ANY ABBREVIATION OF  *\n* ONE OF THE FOLLOWING:                                               *\n* NOALIGN, HALFWORD, FULLWORD, DOUBLEWORD                             *\n* IF THIS OPERAND IS OMITTED, THE DEFAULT ALIGNMENT FOR THE TYPE OF   *\n* THE SPECIFIED STRING IS USED.  IF BOTH OPERANDS ARE OMITTED, THE    *\n* STRING AND ALIGNMENT MOST RECENTLY SPECIFIED ARE USED.              *\n***********************************************************************\n         SPACE\nFINDRTE  DS    0H\n         SPACE\n         ST    R14,SAVE14          SAVE RETURN REGISTER\n         LR    R12,R15\n         USING FINDRTE,R12\n         MVI   FINDSW,X'00'        INITIALIZE SWITCH\n         XR    R4,R4               SET FIND COUNT TO ZERO\n         LH    R5,DATALEN          GET CURRENT DATA LENGTH (IF ANY)\n         SPACE\n         SCAN  1                   SCAN FIND STRING\n         LTR   R8,R8               IF R8 LESS THAN 0, ERR MSG ALREADY\n         BP    FK1OK               WRITTEN BY SCAN FOR BAD QUOTES. ELSE\n         BM    COMMONRT            IF R8 = 0 THEN (NO OPERANDS ENT'D)\n*** ASSUME R8 = 0\n         LTR   R5,R5               IF A CURRENT FIND STRING EXISTS\n         BNZ   FINDPROC            THEN USE IT, SCAN NO MORE\n         LA    R1,FNOOPMSG         ELSE SAY \"MISSING OPERAND\"\n         B     FINDWRT             AND TERMINATE FIND PROCESSING\n         SPACE\nFK1OK    DS    0H                  ELSE PARSE THE FIND STRING\n         SPACE\n***********************************************************************\n* DETERMINE WHAT KIND OF STRING OPERAND THIS IS.                      *\n* FIRST OF ALL, IT MAY BE A SINGLE ASTERISK, WHICH IS VALID ONLY IF   *\n* THERE WAS A PREVIOUS FIND STRING SPECIFIED ONCE.                    *\n***********************************************************************\n         SPACE\n         CH    R15,H1              IF THE LENGTH OF THIS OPERAND IS 1\n         BNE   NOT1AST              AND\n         CLI   0(R8),C'*'           IT IS A SINGLE ASTERISK,\n         BNE   NOT1AST              THEN\n         LTR   R5,R5               IF THERE WAS A PREVIOUS FIND STRING\n         BNZ   GETALIGN            THEN USE PREV.STRING W.NEW ALIGNMENT\n         LA    R1,FNOOPMSG         ELSE SAY \"MISSING OPERAND\"\n         B     FINDWRT             AND TERMINATE FIND PROCESSING\n         SPACE\nNOT1AST  DS    0H                  ELSE NOT ONE ASTERISK, IT'S FOR REAL\n         LR    R9,R15              SAVE LENGTH OF OPERAND\n         STH   R15,STRINGL         SET LENGTH OF TEXT OF STRING\n         BCTR  R15,0               ADJUST FOR EXECUTES\n         EX    R15,SAVFNSTR        SAVE TEXT OF FIND STRING FOR DISPLAY\n         CH    R9,H1               OPERAND LENGTH MUST BE AT LEAST 2\n         BNH   FNULL               OTHERWISE CAN'T BE A VALID OPERAND\n         CLI   1(R8),C''''         CHECK IF 2ND CHAR IS A QUOTE\n         BNE   FIMPLHEX            IF NOT, MUST BE IMPLICIT HEX. ELSE..\n         MVC   STRTYPE,0(R8)       SET STRING TYPE FROM 1ST CHAR\n         LA    R1,0(R8,R15)        POINT TO LAST CHAR IN OPERAND\n         CLI   0(R1),C''''         IF LAST CHAR IS NOT A QUOTE\n         BNE   FINVALID            THEN GO REJECT THE INVALID STRING\n         LA    R0,2(,R8)           ELSE POINT TO 1ST CHAR WITHIN QUOTES\n         ST    R0,STRADDR          STORE ITS ADDRESS\n         SR    R1,R0               GET LENGTH OF DATA INSIDE QUOTES\n         BNP   FNULL               IF ZERO-LENGTH DATA, INVALID STRING\n         STH   R1,STRLEN           ELSE SAVE DATA LENGTH WITHIN QUOTES\n         ALR   R0,R1               R0 -> END OF STRING DATA (ADDR+LEN)\n*\n* STRING OPERAND IS IN FORMAT _'...' - NOW CHECK THE STRING TYPE\n*\n         CLI   STRTYPE,C'X'        IF X'...'\n         BE    FINDQX              THEN PROCESS HEX STRING\n         CLI   STRTYPE,C'C'        IF C'...'\n         BE    FINDQC              THEN PROCESS CHARACTER STRING\n         CLI   STRTYPE,C'G'        IF G'...'\n         BE    FINDQG              THEN PROCESS GENERIC CHAR STRING\n         CLI   STRTYPE,C'F'        IF F'...'\n         BE    FINDQF              THEN PROCESS FULLWORD STRING\n         CLI   STRTYPE,C'H'        IF H'...'\n         BE    FINDQH              THEN PROCESS HALFWORD STRING\n         B     FBADTYPE            OF NONE OF THE ABOVE, BAD OPERAND\n         EJECT\nFIMPLHEX DS    0H                  NO QUOTES - IMPLICIT HEX FORMAT\n         ST    R8,STRADDR          OPERAND ADDRESS = STRING ADDRESS\n         STH   R9,STRLEN           OPERAND LENGTH = STRING LENGTH\n         LA    R0,0(R8,R9)         R0 -> END OF OPERAND/STRING\n         MVI   STRTYPE,C'X'        SET STRING TYPE = HEX\n******** B     FINDQX              FALL THROUGH TO HEX-DATA PROCESSING\n         EJECT\nFINDQX   DS    0H                  HEX STRING, SET UP FOR HEX FMT DATA\n         L     R15,STRADDR         R15 -> EACH INPUT CHARACTER\n         XR    R14,R14             R14 = OFFSET OF OUTPUT CHARACTER\nFXLOOP1  DS    0H                  2 LOOPS HANDLE PAIRS OF INPUT CHARS\n         CR    R15,R0              DO UNTIL END OF INPUT STRING\n         BNL   FXEND               (FOR ALL CHARACTERS IN STRING)\n         CLI   0(R15),C','         BYPASSING ALL COMMAS\n         BNE   FXNOTCMA\n         LA    R15,1(,R15)\n         B     FXLOOP1\nFXNOTCMA MVC   XCVAREA+0(1),0(R15) MOVE 1ST CHAR TO CONVERSION AREA\nFXLOOP2  LA    R15,1(,R15)         PROCESS 2ND CHARACTER OF PAIR\n         CR    R15,R0              IF NO CHARACTER (I.E.ODD # OF CHARS)\n         BL    FXNASTK             THEN\n         MVI   XCVAREA+1,C'*'       PRETEND THERE'S AN ASTERISK THERE\n         B     FXAFTNC2             AND GENERATE A MASK CHAR FOR IT.\nFXNASTK  CLI   0(R15),C','         ELSE IF THIS CHAR IS A COMMA\n         BE    FXLOOP2             THEN IGNORE IT\n         MVC   XCVAREA+1(1),0(R15) ELSE MOVE 2ND CHAR TO CONVERSN AREA\nFXAFTNC2 DS    0H                  OK, NOW PROCESS THE MOVED CHAR PAIR\n         TRT   XCVAREA(2),VALIDXTB CHECK BOTH CHARS ARE VALID HEX-FMT\n         BNZ   FINVALID            IF NOT, GO REJECT THE STRING. ELSE\n         MVC   XCVAREA2(2),XCVAREA SET UP CONVERSION FOR COMPARE MASK\n         TR    XCVAREA(2),XTCTBL   PREPARE FOR STRING CREATION\n         TR    XCVAREA2(2),XTMTBL  PREPARE FOR MASK CREATION\n         CH    R14,=H'128'         LENGTH MUST NEVER EXCEED 128\n         BH    FINVALID            BUT AS LONG AS IT DOESN'T...\n         LA    R1,DATAAREA(R14)    POINT TO OFFSET IN DATA AREA\n         PACK  0(2,R1),XCVAREA(3)  CREATE 1 HEX BYTE OF DATA\n         LA    R1,MASKAREA(R14)    POINT TO OFFSET IN MASK AREA\n         PACK  0(2,R1),XCVAREA2(3) CREATE 1 HEX BYTE OF MASK\n         CLI   0(R1),X'FF'         IF 0123456789ABCDEF ... NOT * ...\n         BE    MASKONLY            THEN (REAL DATA PRESENT) ...\n         OI    FINDSW,REALDATA      INDICATE IT'S NOT ONLY MASK CHARS\nMASKONLY DS    0H\n         LA    R14,1(,R14)         BUMP UP WORK AREA OFFSET\n         LA    R15,1(,R15)         BUMP UP INPUT POINTER\n         B     FXLOOP1             CONTINUE UNTIL NO MORE CHARACTERS\n         SPACE\nFXEND    DS    0H\n         SPACE\n***********************************************************************\n* AT THIS POINT THE HEX STRING HAS BEEN BUILT.  NOW MAKE SURE THAT IT *\n* IS ACCEPTABLE.  R14 CONTAINS THE LENGTH OF THE DATA.                *\n***********************************************************************\n         SPACE\n         LTR   R5,R14              R5 = LENGTH OF DATA\n         BZ    FNULL               NULL DATA STRING IS INVALID\n         TM    FINDSW,REALDATA     IF REAL-DATA SWITCH IS OFF,\n         BNO   FALLASTS            THEN STRING IS ALL *'S AND NO GOOD\n         B     GETALIGN            ELSE GO PROCESS THE NEXT OPERAND.\n         EJECT\nFINDQC   DS    0H                  CHARACTER STRING (NON-GENERIC)\n         SPACE\n         OI    FINDSW,REALDATA     FOR C-TYPE INDICATE ALL DATA IS REAL\n         SPACE\nFINDQG   DS    0H                  CHARACTER STRING (GENERIC)\n         SPACE\n         L     R15,STRADDR         POINT TO EACH CHAR IN STRING\n         LA    R14,DATAAREA        POINT TO OUTPUT AREA TO MOVE CHARS\n         LA    R1,MASKAREA         POINT TO OUTPUT AREA TO BUILD MASK\nFCLOOP   CR    R15,R0              DO UNTIL END OF STRING\n         BNL   FCEND               (FOR ALL CHARS IN INPUT STRING)\n         CLI   0(R15),C''''        IF INPUT IS A QUOTE\n         BNE   FCNQUOTE            THEN\n         CLI   1(R15),C''''         IF FOLLOWING CHAR IS NOT A QUOTE\n         BNE   FINVALID             THEN STRING IS INVALID\n         LA    R15,1(,R15)          ELSE BUMP INPUT PTR PAST ONE QUOTE\n         B     GMSKONLY             AND TREAT AS NON-MASK CHARACTER\nFCNQUOTE DS    0H                  ELSE (NON-QUOTE CHARACTER) ...\n         CLI   STRTYPE,C'G'        IF THIS IS A GENERIC STRING REQUEST\n         BNE   GMSKONLY             AND\n         CLI   0(R15),C'*'          IF THIS IS THE MASK CHARACTER\n         BNE   GMSKONLY              THEN...\n         MVI   0(R1),X'FF'            PUT 1-BITS IN THE MASK\n         MVI   0(R14),X'FF'           MOVE 1-BITS TO DATA AREA\n         B     AFTGMASK            ELSE DO LIKE THE REST...\nGMSKONLY MVI   0(R1),X'00'          PUT 0-BITS IN THE MASK\n         MVC   0(1,R14),0(R15)      MOVE THE INPUT CHAR TO DATA AREA\n         OI    FINDSW,REALDATA      INDICATE THAT REAL DATA IS PRESENT\nAFTGMASK DS    0H\n         LA    R14,1(,R14)         BUMP UP WORK AREA POINTER\n         LA    R1,1(,R1)           BUMP UP MASK AREA POINTER\n         LA    R15,1(,R15)         BUMP UP INPUT AREA POINTER\n         B     FCLOOP              AND CONTINUE.\n         SPACE\nFCEND    DS    0H\n         TM    FINDSW,REALDATA     IF REAL-DATA SWITCH IS OFF,\n         BNO   FALLASTS            THEN STRING IS ALL *'S AND NO GOOD\n         LA    R0,DATAAREA         ELSE\n         SLR   R14,R0               COMPUTE LENGTH OF CHARACTER DATA\n         LR    R5,R14               SAVE IT AS THE DATA LENGTH\n         B     GETALIGN             AND GO PROCESS THE NEXT OPERAND.\n         EJECT\nFINDQF   DS    0H                  FULLWORD STRING\nFINDQH   DS    0H                  HALFWORD STRING\n         SPACE\n* VALIDATE F/H INPUT.  IT MAY HAVE A + OR - SIGN IN FRONT, BUT THE REST\n* OF IT MUST BE NUMERIC.\n         SPACE\n         STCM  R4,15,MASKAREA      NO MASK USED WITH THIS TYPE OF DATA\n         L     R14,STRADDR         POINT TO EACH CHAR OF INPUT STRING\n         LH    R15,STRLEN          GET LENGTH OF THE INPUT STRING\n         CLI   0(R14),C'+'         IF FIRST CHAR IS A PLUS SIGN\n         BE    F#PLUS              THEN PROCESS POSITIVE INTEGER\n         CLI   0(R14),C'-'         IF FIRST CHAR IS A MINUS SIGN\n******** BE    F#MINUS             THEN PROCESS NEGATIVE INTEGER\n         BNE   FNOSIGN             ELSE NO SIGN, PROCESS AS POSITIVE\nF#MINUS  OI    FINDSW,NEGATIVE     IF MINUS SIGN, INDICATE NEGATIVE\nF#PLUS   DS    0H                  IF PLUS SIGN, INDICATE NOTHING\n         LA    R14,1(,R14)         BUMP INPUT POINTER PAST SIGN\n         BCTR  R15,0               DECREMENT LENGTH ACCORDINGLY\nFNOSIGN  DS    0H                  NOW WE HAVE ADDR & LEN OF UNSIGNED\n         LTR   R15,R15             IF DATA LENGTH ZERO,\n         BNP   FINVALID            THEN GO TO REJECT INVALID STRING\n         CLI   STRTYPE,C'F'        IF STRING TYPE IS FULLWORD\n         BE    CHK2TO31            THEN CHECK RANGE FOR FULLWORD. ELSE\n         CH    R15,=H'5'           MAX LENGTH FOR HALFWORD TYPE IS 5\n         BH    FINVALID            IF TOO LONG, REJECT\n         BL    FLENOK              IF LESS, OK\n         CLC   0(5,R14),=C'32768'  CHECK AGAINST MINIMUM/MAXIMUM VALUE\n         B     RANGECHK            GO INSPECT CONDITION CODE\nCHK2TO31 DS    0H                  CHECK RANGE FOR FULLWORD\n         CH    R15,=H'10'          MAX LENGTH FOR FULLWORD TYPE IS 10\n         BH    FINVALID            IF TOO LONG, REJECT\n         BL    FLENOK              IF LESS, OK\n         CLC   0(10,R14),=C'2147483648'  CHECK MINIMUM/MAXIMUM VALUE\nRANGECHK DS    0H                  CHECK RESULTS FOR BOTH TYPES\n         BH    FINVALID            IF OUTSIDE BOUNDS, REJECT\n         BL    FLENOK              IF WITHIN BOUNDS, OK\n         TM    FINDSW,NEGATIVE     IF EQUAL, CAN ONLY BE NEGATIVE\n         BZ    FINVALID            OTHERWISE REJECT\n         CLI   STRTYPE,C'F'        IF F'-2147483648'\n         BNE   FLENOK              THEN (TO AVOID S0C9)...\n         LA    R0,X'80'\n         SLL   R0,24                SET R0 = X'80000000' EXPLICITLY\n         B     STORFULL             AND GO TO STORE THE VALUE.\nFLENOK   DS    0H                  ELSE OK, GO ON\n         BCTR  R15,0               ADJUST LENGTH FOR EXECUTE\n         EX    R15,TRTNUM          VALUE MUST BE NUMERIC\n         BNZ   FINVALID            OTHERWISE INVALID STRING, REJECT\n         EX    R15,PACKIT          CONVERT TO DECIMAL\n         CVB   R0,DOUBLE           AND THEN TO BINARY\n         TM    FINDSW,NEGATIVE     IF IT HAD A MINUS SIGN\n         BNO   NOLCR               THEN\n         LCR   R0,R0                MAKE IT NEGATIVE\nNOLCR    CLI   STRTYPE,C'H'        IF TYPE = HALFWORD\n         BNE   STORFULL            THEN\n         STCM  R0,B'0011',DATAAREA  STORE 2 BYTES OF BINARY DATA\n         LA    R5,2                 SET DATA LENGTH = 2\n         B     GETALIGN            ELSE (TYPE = FULLWORD) ...\nSTORFULL STCM  R0,B'1111',DATAAREA  STORE 4 BYTES OF BINARY DATA\n         LA    R5,4                 SET DATA LENGTH = 5\n******** B     GETALIGN            GO PROCESS NEXT OPERAND\n         EJECT\nGETALIGN DS    0H\n         SPACE\n***********************************************************************\n* GET THE NEXT OPERAND, WHICH WILL BE THE REQUESTED ALIGNMENT OF THE  *\n* STRING.  THE DEFAULT IS DETERMINED BY THE STRING TYPE.  VALID       *\n* VALUES ARE FULLWORD, HALFWORD, DOUBLEWORD, AND NO ALIGNMENT.        *\n***********************************************************************\n         SPACE\n         SCAN  2,MAXLEN=11         SCAN ALIGNMENT OPERAND\n         STH   R5,DATALEN          SAVE DATA LENGTH FOR FUTURE USE\n         LTR   R8,R8               IF INVALID VALUE\n         BM    BADALIGN             THEN REJECT, CANCEL FIND\n         BZ    ALIGNDEF            IF NO VALUE, USE DEFAULT ALIGNMENT\n         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTES\n         LA    R14,ALIGNTBL        POINT TO ALIGNMENT VALUE TABLE\n         LA    R0,12               SET BXLE REGISTER\n         LA    R1,ALIGNEND-12      SET BXLE REGISTER\nALGNLOOP DS    0H                  SEARCH 4 VALUE USING ENTERED LENGTH\n         EX    R15,COMPALGN        COMPARE OPERAND TO ALIGNMENT VALUE\n         BE    ALIGNSET            IF EQUAL, A GOOD ALIGNMENT FOUND\n         BXLE  R14,R0,ALGNLOOP     ELSE CONTINUE SEARCH ON TABLE\n         MVC   ALGNTEST,BLANKS     NOT FOUND: BLANK ALIGNMENT WORK AREA\n         EX    R15,MVALTEST        MOVE BAD VALUE TO MESSAGE AREA\n         WRTMSG ALIGNMSG           SAY ALIGNMENT INVALID\nBADALIGN ST    R4,ALGNADDR         CANCEL CURRENT ALIGNMENT\n         B     COMMONRT            RETURN WITHOUT PROCESSING\n         SPACE\nALIGNDEF DS    0H                  ALIGNMENT DEFAULT GETS SET HERE\n         CLI   STRTYPE,C'F'        IF DATA TYPE = FULLWORD\n         BNE   ALIGNNTF            THEN\n         LA    R14,FULLWORD         USE FULLWORD ALIGNMENT\n         B     ALIGNSET            ELSE\nALIGNNTF CLI   STRTYPE,C'H'        IF DATA TYPE = HALFWORD\n         BNE   ALIGNNTH            THEN\n         LA    R14,HALFWORD         USE HALFWORD ALIGNMENT\n         B     ALIGNSET            ELSE (HEX OR CHAR) ...\nALIGNNTH LA    R14,NOALIGN          USE NO ALIGNMENT\n         SPACE\nALIGNSET DS    0H                  R1 NOW POINTS TO ALIGNMENT ENTRY\n         ST    R14,ALGNADDR        SAVE POINTER TO ALIGNMENT VALUE\n         MVC   ALGNMASK,11(R14)    USE CORRESPONDING ALIGNMENT BIT MASK\n******** B     FINDPROC            GO TO ACTUALLY DO THE FIND\n         EJECT\nFINDPROC DS    0H                  OPERANDS FULLY SCANNED. NOW GO.\n         SPACE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         CLI   CSECT,C' '          IF A CSECT NAME SPECIFIED\n         BE    FDOALL              THEN\n         L     R6,CURRESD           GET ITS ESD ENTRY ADDRESS\n         L     R3,ADRSTART          GET STARTING ADDRESS\n         B     FINDGO               ELSE...\nFDOALL   DS    0H                  NO CSECT SPECIFIED, LOOP FOR ALL\n* NOTE R6 USED INSTEAD OF R5 BECAUSE R5 IS HOLDING STRING LENGTH\n         L     R6,ESDBUFAD          GET ADDRESS OF ESD TABLE\n         ICM   R6,15,ESDLKHDR-ESDTABLE(R6) GET FIRST ESD ENTRY ADDRESS\nFREPEAT  BZ    NOTFOUND             AT END, NO MORE OCCURRENCES\n         XR    R3,R3                CLEAR FOR INSERT\n         ICM   R3,7,ESDADDR         GET RELATIVE ADDRESS OF CSECT\n         LTR   R10,R10              IF OVERLAY MODULE,\n         BZ    FINITNOV             THEN...\n         XR    R1,R1                 CLEAR INSERT REG\n         IC    R1,ESDSEGNO           GET SEGMENT NUMBER OF THIS CSECT\n         SLA   R1,OVSHIFT            CONVERT TO INDEX\n         SL    R3,OVSEGLO(R1)        SUBTRACT LOWER BOUND\n         AL    R3,OVSEGADR(R1)       ADD ADDR OF SEGMENT BUFFER\n         B     FINDGO               ELSE...\nFINITNOV AL    R3,LOADADDR           JUST ADD ADDRESS OF MODULE BUFFER\n         SPACE\nFINDGO   LA    R9,256              SET UP A CONSTANT '256'\n         XR    R7,R7               CLEAR INSERT REG\n         ICM   R7,7,ESDLEN         GET LENGTH OF THIS CONTROL SECTION\n         SR    R7,R5               SUBTRACT STRING LENGTH FROM ENDADDR\n         BM    FNEXTCS             IF DATA LONGER THAN CSECT, NOT FOUND\n         LA    R7,1(,R7)           ELSE ADD 1: HOW MANY CHARS TO SCAN\n***********************************************************************\n* R7 = TOTAL LENGTH FOR SCAN OF A CONTROL SECTION.\n***********************************************************************\n* IF FIRST CHARACTER OF STRING IS NOT MASKED, SET UP TRANSLATION TABLE\n* FOR QUICK SCAN.\n***********************************************************************\n         CLI   MASKAREA,X'00'      IF FIRST CHAR IS A MASK CHAR,\n         BNE   COMPWMSK            THEN CAN'T USE TRT. ELSE 1ST IS REAL\nUSETRT   DS    0H                   SO SET UP TRANSLATION TABLE\n         XC    SCANTBL,SCANTBL      BY FIRST CLEARING IT TO ZEROES\n         XR    R15,R15              AND THEN\n         IC    R15,DATAAREA         TAKING THE FIRST ARGUMENT BYTE\n         LA    R0,1                 AND SETTING THE CORRESPONDING\n         STC   R0,SCANTBL(R15)      TABLE BYTE TO X'01'.\nFINDLOOP DS    0H                  MAIN LOOP FOR CHARACTER SCAN\n         CLI   MASKAREA,X'00'      IF FIRST CHAR IS MASKED,\n         BNE   COMPWMSK            THEN DO STRAIGHT COMPARE,\nFTRTLOOP DS    0H                  ELSE DO TRT-SCAN FOR FIRST CHAR:\n         CR    R7,R9               IF LENGTH EXCEEDS 256,\n         BNH   LE256LFT            THEN BREAK UP THE SCAN BY\n         TRT   0(256,R3),SCANTBL    SCANNING 256 BYTES UNTIL\n         BNZ   CHAR1FND             CHARACTER IS FOUND OR\n         ALR   R3,R9                UNTIL LESS THAN 256 BYTES\n         SLR   R7,R9                ARE LEFT TO SCAN.\n         B     FTRTLOOP\nLE256LFT DS    0H                  WHEN LESS THAN 256 BYTES LEFT\n         LTR   R15,R7              GET LENGTH OF REMAINING DATA\n         BNP   FNEXTCS             IF ZERO, END OF SCAN, NOTHING LEFT\n         BCTR  R15,0               ADJUST FOR EXECUTE\n         EX    R15,TRTSCAN         EXECUTE SCAN FOR FIRST CHARACTER\n         BZ    FNEXTCS             IF FAILS, END OF SCAN, NOTHING LEFT\nCHAR1FND DS    0H                  SCAN ENCOUNTERED THE 1ST CHARACTER\n* TRT HAS SET R1 -> FIRST CHAR THAT MATCHES.  NOW CHECK ENTIRE STRING\n         LR    R15,R1              THIS LOC MINUS PREVIOUS LOC\n         SR    R15,R3              GIVES R15 = LENGTH JUST SCANNED\n         SR    R7,R15              REDUCE TOTAL LENGTH REMAINING\n         LR    R3,R1               SET NEW SCAN ADDRESS FOR NEXT TIME\n         B     COMPARE             GO SEE IF THE WHOLE STRING MATCHES\n         SPACE\nCOMPWMSK DS    0H                  FOR DATA WHOSE 1ST CHAR IS MASKED...\n         LTR   R7,R7               WHILE REMAINING LENGTH GT 0, COMPARE\n         BNP   FNEXTCS             OTHERWISE SEARCH IS TERMINATED.\n         SPACE\nCOMPARE  DS    0H                  R3 -> POSSIBLE MATCH. NOW CHK ALGNMT\n         ICM   R15,1,ALGNMASK      PICK UP ALIGNMENT BIT MASK\n         BZ    FALIGNOK            IF ZERO, NOALIGN SPECIFIED, NO CHECK\n         STC   R3,TESTBYTE         TEST LOW-ORDER ADDRESS BYTE\n         EX    R15,TESTMASK        TEST BITS OF IT FOR ALIGNMENT\n         BNZ   FCONTINU            IF IT FAILS TEST, SKIP THIS, GO ON\nFALIGNOK DS    0H                  ALIGNMENT IS ACCEPTED...\n         LR    R15,R5              GET LENGTH OF THE DATA\n         BCTR  R15,0               REDUCE FOR EXECUTES\n         LTR   R15,R15             IF DATA LENGTH IS 1\n         BNZ   MAYNOTBE             AND\n         CLI   MASKAREA,X'00'        FIRST CHAR IS REAL (NOT MASKED),\n         BE    THISISIT               THEN WE HAVE FOUND A TRUE MATCH.\nMAYNOTBE DS    0H                  ELSE COMPARE THE REST OF THE DATA\n         EX    R15,MVCTEST         MOVE LOAD MODULE DATA TO TEST AREA\n         EX    R15,OCTEST          \"OR\" IT WITH THE COMPARE MASK\n         EX    R15,CLCTEST         COMPARE ARGUMENT WITH MASKED DATA\n******** BE    THISISIT            IF IT MATCHES, GREAT, DISPLAY IT\n         BNE   FCONTINU            IF NOT, GO TO CONTINUE SCANNING\n         SPACE\nTHISISIT DS    0H                  WE HAVE FOUND AN OCCURRENCE...\n         SPACE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         LR    R1,R3               GET DATA ADDRESS IN MODULE\n         LTR   R10,R10             IF OVERLAY MODULE\n         BZ    THISNOV             THEN\n         XR    R15,R15              CLEAR INSERT REG\n         IC    R15,ESDSEGNO         GET CURRENT SEGMENT NUMBER\n         SLA   R15,OVSHIFT          CONVERT TO INDEX\n         S     R1,OVSEGADR(R15)     SEGMENT BUF ADDR MINUS DATA ADDRESS\n         A     R1,OVSEGLO(R15)      PLUS OFFSET OF SEGMENT IN MODULE\n         B     THISSET              GIVES OFFSET OF FOUND DATA\nTHISNOV  DS    0H                  ELSE...\n         S     R1,LOADADDR          DATA ADDRESS MINUS LOAD MODULE ADDR\nTHISSET  STCM  R1,7,FINDADR1       GIVES OFFSET OF FOUND DATA\n         SPACE\n***********************************************************************\n* R1 = OFFSET OF THE FOUND DATA WITHIN THE LOAD MODULE.               *\n* THE DATA IS WITHIN THE CSECT REFERENCED BY R6.                      *\n***********************************************************************\n         SPACE\n         LA    R4,1(,R4)           INCREMENT FIND COUNT BY 1\n         XR    R0,R0               CLEAR INSERT REG\n         ICM   R0,7,ESDADDR        GET CONTROL SECTION OFFSET\n         SLR   R1,R0               DATA LOCATION MINUS CSECT LOCATION\n         STCM  R1,7,FINDADR2        GIVES OFFSET OF DATA IN CTL SECTION\n***********************************************************************\n* NOW TELL USER THAT THE STRING HAS BEEN FOUND.  DISPLAY INFORMATION  *\n***********************************************************************\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         TM    FINDSW,FINDHEAD     IF HEADING HAS NOT BEEN WRITTEN YET,\n         BO    NOHEAD              THEN...\n         MVI   CC,C'0'              SET UP DOUBLE SPACE ASA CONTROL\n         WRTMSG HEADMSG             WRITE THE HEADING, AND\n         OI    FINDSW,FINDHEAD      TURN THE HEADING INDICATOR ON.\nNOHEAD   DS    0H                  NOW HANDLE THE INFO TO BE DISPLAYED\n         CLI   STRTYPE,C'G'        IF A \"G-STRING\"\n         BNE   DISPLAYX            THEN\n         LA    R1,GDATAMSG          DISPLAY THE INFO IN CHAR FORMAT\n         B     DISPLAY             ELSE\nDISPLAYX LA    R1,DATAMSG           DISPLAY THE INFO IN HEX FORMAT\nDISPLAY  WRTMSG (R1)               DO IT\n         MVI   CC,C' '             SET SINGLE SPACE ASA FOR NEXT MSG\n         SPACE\nFCONTINU DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         LA    R3,1(,R3)           BUMP UP TO NEXT DATA IN LOAD MODULE\n         BCT   R7,FINDLOOP         DECR REM CHAR COUNT & KEEP SCANNING\nFNEXTCS  DS    0H                  UNTIL SCANNING LENGTH EXHAUSTED\n         CLI   CSECT,C' '          AT WHICH POINT, IF USING ALL CSECTS\n         BNE   NOTFOUND            THEN\n         ICM   R6,15,ESDLINKP       GET ADDR OF NEXT ESD ENTRY\n         B     FREPEAT              AND CONTINUE UNTIL CSECTS EXHAUSTED\n*                                  ELSE ONLY 1 CSECT - NO DATA LEFT\n         SPACE 2\nNOTFOUND DS    0H                  NO MORE DATA TO SEARCH; FIND IS OVER\n         SPACE\n         ST    R4,FNDCOUNT         STORE OCCURRENCE COUNT FOR MESSAGE\n         LA    R1,FOUNDMSG         TELL HOW MANY WERE FOUND\n         B     FINDWRT             GO TO DISPLAY MESSAGE\n         SPACE\nFNULL    LA    R1,NULLMSG          NULL STRING IS INVALID\n         B     FBADWRT             GO TO DISPLAY MESSAGE\n         SPACE\nFBADTYPE LA    R1,BADTMSG          BAD TYPE CODE\n         B     FBADWRT             GO TO DISPLAY MESSAGE\n         SPACE\nFALLASTS LA    R1,ASTSMSG          STRING CANNOT BE ALL ASTERISKS\n         B     FBADWRT             GO TO DISPLAY MESSAGE\n         SPACE\nFINVALID LA    R1,INVCSMSG         STRING IS NOT VALID\n******** B     FBADWRT             GO TO DISPLAY MESSAGE\n         SPACE\nFBADWRT  XR    R0,R0               FIND COMMAND ERROR\n         STH   R0,STRINGL          ERROR OCCURRED, CANCEL FIND STRING\n         STH   R0,DATALEN          ERROR OCCURRED, CANCEL FIND STRING\n         MVI   CC,C'0'             SET DOUBLE SPACE ASA CONTROL\n         WRTMSG (R1)               GIVE USER THE WORD\n         B     COMMONRT            RETURN TO MAINLINE\nFINDWRT  MVI   CC,C'0'             SET DOUBLE SPACE ASA CONTROL\n         WRTMSG (R1)               GIVE USER THE WORD\n         B     GOODRET             RETURN TO MAINLINE\n         SPACE\nSAVFNSTR MVC   STRING(0),0(R8)     EXECUTED: SAVE FIND STRING FOR DISPL\nTRTNUM   TRT   0(0,R14),NUMTBL     EXECUTED: VERIFY NUMERIC OPERAND\nPACKIT   PACK  DOUBLE,0(0,R14)     EXECUTED: CONVERT CHAR TO DECIMAL\nCOMPALGN CLC   0(0,R8),0(R14)      EXECUTED: COMPARE ALIGNMENT VALUE\nMVALTEST MVC   ALGNTEST(0),0(R8)   EXECUTED: STORE ALIGNMENT MASK\nTRTSCAN  TRT   0(0,R3),SCANTBL     EXECUTED: SCAN FOR FIND STRING DATA\nMVCTEST  MVC   TESTAREA(0),0(R3)   EXECUTED: MOVE DATA TO COMPARE SPOT\nOCTEST   OC    TESTAREA(0),MASKAREA EXECUTED: MASK THE COMPARE DATA\nCLCTEST  CLC   DATAAREA(0),TESTAREA EXECUTED: COMPARE DATA W/ARGUMENT\nTESTMASK TM    TESTBYTE,X'00'      EXECUTED: CHECK ALIGNMENT ADDR BITS\n         SPACE\nFNDCOUNT DS    F                   NUMBER OF TIMES STRING FOUND\nSTRADDR  DS    F                   ADDRESS OF CHAR STRING ON CTL STMT\nSTRLEN   DS    H                   LENGTH OF CHAR STRING ON CTL STMT\nDATALEN  DS    H                   LENGTH OF ACTUAL FIND STRING\nFINDADR1 DS    XL3                 OFFSET OF DATA IN THE LOAD MODULE\nFINDADR2 DS    XL3                 OFFSET OF DATA IN CONTROL SECTION\nSTRTYPE  DS    C                   TYPE OF CHARACTER STRING ON CARD\nALGNMASK DS    C                   TM MASK FOR ALIGNMENT CHECK\nXCVAREA  DS    CL3                 HEX CONVERSION AREA FOR STRING\nXCVAREA2 DS    CL3                 HEX CONVERSION AREA FOR MASK\n         SPACE\nFINDSW   DS    X                   SWITCHES AND FLAGS\n         SPACE\nREALDATA EQU   B'10000000'         IF OFF, X/G STRING IS ONLY ASTERISKS\nNEGATIVE EQU   B'01000000'         IF ON, F/H STRING HAS A MINUS SIGN\nFINDHEAD EQU   B'00100000'         IF ON, HEADING HAS BEEN DISPLAYED\n*        EQU   B'00010000'         RESERVED\n*        EQU   B'00001000'         RESERVED\n*        EQU   B'00000100'         RESERVED\n*        EQU   B'00000010'         RESERVED\n*        EQU   B'00000001'         RESERVED\n         SPACE\n$FINDSTR DC    C' FIND STRING '    CONSTANT FOR MESSAGES\n         SPACE\nFNOOPMSG MSG   '*NO',($FINDSTR,,C),'HAS BEEN SPECIFIED'\nINVCSMSG MSG   '*INVALID CHARACTERS IN',($FINDSTR,,C)\nNULLMSG  MSG   '*INVALID',($FINDSTR,,C),'LENGTH'\nBADTMSG  MSG   '*INVALID TYPE PREFIX ON',($FINDSTR,,C)\nASTSMSG  MSG   '*A',($FINDSTR,,C),'OF ALL MASK SYMBOLS IS NOT ALLOWED'\nALIGNMSG MSG   '*INVALID ALIGNMENT SPECIFICATION - ',ALGNTEST\nHEADMSG  MSG   ' LOAD MODULE OFFSET    CSECT     OFFSET    DATA'\nDATAMSG  MSG   '  ',(LOADMOD,8,C),'   ',FINDADR1,'   ',(ESDNAME,8,C),  X\n               '   ',FINDADR2,'    ',(0(R3),(R5),X)\nGDATAMSG MSG   '  ',(LOADMOD,8,C),'   ',FINDADR1,'   ',(ESDNAME,8,C),  X\n               '   ',FINDADR2,'    ',(0(R3),(R5),C)\nFOUNDMSG MSG   'TOTAL OF ',FNDCOUNT,' OCCURRENCES FOUND IN ',          X\n               LOADMOD,' ',(CSECT,,C)\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - LIST COMMAND PROCESSOR'\n***********************************************************************\n* \"LIST\" COMMAND PROCESSOR                                            *\n* THIS COMMAND PRODUCES A HEXADECIMAL AND EBCDIC LIST OF ONE OR ALL   *\n* CONTROL SECTIONS OF THE CURRENT LOAD MODULE, 16 BYTES/LINE. SYNTAX: *\n*              L(IST)  CSECTNAME                                      *\n* WHERE: CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE ONLY     *\n*        CONTROL SECTION TO BE LISTED.  IF THIS IS OMITTED THEN IF    *\n*        A CSECT WAS SPECIFIED ON THE PREVIOUS NAME COMMAND, THAT     *\n*        CSECT IS LISTED, OTHERWISE ALL CSECTS ARE LISTED.            *\n***********************************************************************\n         SPACE\nLISTRTE  DS    0H\n         SPACE\n         ST    R14,SAVE14\n         LR    R12,R15\n         USING LISTRTE,R12\n         MVI   LISTSW,X'00'        CLEAR FLAGS\n         MVC   LISTNAME,CSECT      INIT NAME OF CSECT TO BE LISTED\n         SCAN  1,MAXLEN=8          SCAN FOR NAME OF CSECT TO LIST\n         LTR   R8,R8               CHECK IF VALID NAME WAS ENTERED\n         BM    COMMONRT            IF INVALID, THEN RETURN TO CALLER\n         BZ    LNOCSECT            IF A CSECT NAME WAS ENTERED, THEN\n         MVC   LISTNAME,BLANKS      CLEAR NAME OUT AND\n         BCTR  R15,0                USING LENGTH OF OPERAND\n         EX    R15,LISTMOVE         MOVE NAME OF CSECT TO BE LISTED\nLNOCSECT DS    0H\n         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE\n         ICM   R6,15,ESDLKHDR      GET FIRST ESD ENTRY IN PHYS ORDER\nLISTLOOP BZ    LISTDONE            LOOP WHILE NOT ZERO\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         CLI   LISTNAME,C' '       IF A SPECIFIC CSECT REQUESTED\n         BE    LISTTHIS            THEN\n         CLC   LISTNAME,ESDNAME     IF REQUESTED CSECT DOES NOT MATCH\n         BNE   DONTLIST             THEN SKIP THIS CONTROL SECTION\n         OI    LISTSW,LCSECTD       ELSE SAY REQUESTED CSECT LOCATED\nLISTTHIS DS    0H                  LIST THIS CONTROL SECTION\n         MVI   CC,C'1'             DO A PAGE EJECT\n         WRTMSG LISTHDR            WRITE THE HEADING\n         MVI   CC,C'0'             DO A DOUBLE SPACE NEXT TIME\n         XR    R0,R0               CLEAR REGISTER FOR INSERTS\n         ICM   R0,7,ESDLEN         CHECK CSECT LENGTH\n         BZ    DONTLIST            IF ZERO, SKIP LISTING OF IT\n         LTR   R10,R10             IF OVERLAY MODULE\n         BZ    LSTNOTOV            THEN...\n         XR    R1,R1                CLEAR INSERT REG\n         IC    R1,ESDSEGNO          GET SEGMENT NUMBER\n         SLA   R1,OVSHIFT           CONVERT TO INDEX\n         L     R9,OVSEGADR(R1)      GET ADDRESS OF SEGMENT BUFFER\n         SL    R9,OVSEGLO(R1)       SUBTRACT OFFSET RELATIVE TO MODULE\n         B     LSTAFTOV            ELSE...\nLSTNOTOV DS    0H                  NOT OVERLAY...\n         L     R9,LOADADDR          GET ADDRESS OF LOAD MODULE\nLSTAFTOV DS    0H                  ANYHOW...\n         XR    R3,R3               CLEAR REGISTER FOR INSERTS\n         ICM   R3,7,ESDADDR        GET ADDRESS OF START OF CSECT\n         ALR   R3,R9               CONVERT TO ABSOLUTE ADDRESS\n         ICM   R4,15,ESDNADDR      GET ADDRESS OF END OF CSECT\n         ALR   R4,R9               CONVERT TO ABSOLUTE ADDRESS\n         ST    R4,LISTEND          SAVE ADDRESS OF END OF CSECT\n         LR    R1,R3               POINT TO FIRST WORD TO CONVERT\nFMTLOOP  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         LR    R14,R3              GET OFFSET OF NEXT DATA TO LIST\n         SLR   R14,R9              CONVERT TO RELATIVE ADDRESS IN LOAD\n         STCM  R14,7,LISTLOC1      STORE RELATIVE ADDR OF CURRENT LINE\n         ICM   R0,7,ESDADDR\n         SLR   R14,R0              CONVERT TO RELATIVE ADDRESS IN CSECT\n         STCM  R14,7,LISTLOC2      STORE ADDRESS OF CURRENT LINE\n         MVI   LISTLINE,C' '       CLEAR LINE TO BLANKS\n         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE\n         LA    R14,LISTLINE+0      INITIALIZE OUTPUT POINTER FOR LINE\n         LA    R0,4                SET COUNTER OF # OF WORDS / LINE\nFMTLOOP2 DS    0H\n         L     R15,LISTEND\n         SLR   R15,R1              GET LENGTH OF REMAINING DATA\n         STH   R15,LISTLEN\n         CH    R15,=H'4'           IF LESS THAN 4\n         BNL   FMTMOVE4            THEN...\n         BCTR  R15,0                REDUCE LENGTH FOR EXECUTES\n         EX    R15,FMTMOVE0         MOVE DATA FROM MODULE TO WORK AREA\n         LH    R15,LISTLEN          GET LENGTH +1 FOR UNPACK SOURCE\n         SLL   R15,4+1              GET (LENGTH+1)*2 FOR UNPACK DEST\n         AH    R15,LISTLEN          PUT LENGTHS TOGETHER FOR EXECUTE\n         EX    R15,FMTUNPK0         MOVE TO HEX AREA\n         LH    R15,LISTLEN          GET LENGTH AGAIN\n         SLL   R15,1                MULTIPLY BY 2\n         BCTR  R15,0                ADJUST FOR EXECUTE\n         EX    R15,FMTTRAN0         TRANSLATE\n         ALR   R14,R15              POINT TO END OF TRANSLATED DATA\n         MVI   1(R14),C' '          BLANK OUT FOLLOWING POSITION\n         AH    R1,LISTLEN           BUMP INPUT POINTER\n         B     FMTCHAR              AND EXIT FORMATTING\nFMTMOVE4 DS    0H                  ELSE...\n         MVC   LISTWORK(4),0(R1)   MOVE DATA FROM MODULE TO WORK AREA\n         UNPK  0(9,R14),LISTWORK(5)  AND THEN TO HEX AREA TO AVOID 0C4\n         TR    0(8,R14),LISTXTBL   TRANSLATE\n         MVI   8(R14),C' '         BLANK OUT THE FOLLOWING POSITION\n         LA    R1,4(,R1)           BUMP INPUT POINTER\n         LA    R14,9(,R14)         BUMP OUTPUT POINTER\n         C     R1,LISTEND          IF END OF CSECT TO BE LISTED\n         BNL   FMTCHAR             THEN EXIT\n         BCT   R0,FMTLOOP2         CONTINUE FOR ALL WORDS ON LINE\nFMTCHAR  LR    R2,R1\n         SLR   R2,R3               SET R2 = LENGTH OF CHAR DATA\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         WRTMSG LISTMSG            DISPLAY THE LINE\n         MVI   CC,C' '             SET ASA CONTROL = SINGLE SPACE\n         C     R1,LISTEND          IF END OF CSECT TO BE LISTED\n         BNL   DONTLIST            THEN EXIT\n         LR    R3,R1               ELSE PREPARE FOR NEXT LINE OF DATA\n         B     FMTLOOP             CONTINUE WITH NEXT LINE\n         SPACE\nDONTLIST DS    0H\n         TM    LISTSW,LCSECTD      IF REQUESTED CSECT WAS LISTED\n         BO    LISTDONG            THEN GO TO SUCCESSFUL TERMINATION\n         ICM   R6,15,ESDLINKP      ELSE GET NEXT ESD ENTRY (PHYS ORDER)\n         B     LISTLOOP            AND CONTINUE LOOP\n         SPACE\nLISTDONE DS    0H                  END OF ALL LISTING & LCSECTD = OFF\n         CLI   LISTNAME,C' '       IF A SPECIFIC CSECT WAS REQUESTED\n         BE    LISTDONG            THEN\n         WRTMSG LISTFAIL           PUT OUT ERROR MESSAGE\n         B     COMMONRT            ELSE\nLISTDONG MVI   CC,C'1'             EJECT THE PAGE\n         WRTMSG LISTEMSG           SAY WE ARE DONE\n         B     GOODRET\n         SPACE\nLISTMOVE MVC   LISTNAME(0),0(R8)   EXECUTED: MOVE CSECT NAME\nFMTMOVE0 MVC   LISTWORK(0),0(R1)   EXECUTED: MOVE DATA FROM MODULE\nFMTUNPK0 UNPK  0(0,R14),LISTWORK(0) EXECUTED: MOVE DATA TO HEX AREA\nFMTTRAN0 TR    0(0,R14),LISTXTBL   EXECUTED: TRANSLATE HEX DATA\n         SPACE\nLISTEND  DS    A                   ADDRESS OF END OF CSECT\nLISTLEN  DS    H                   LENGTH REMAINING TO LIST\nLISTWORK DS    XL5                 WORK AREA\nLISTLOC1 DS    XL3                 LOCATION OF CURRENT LINE\nLISTLOC2 DS    XL3                 LOCATION OF CURRENT LINE\nLISTNAME DS    CL8                 NAME OF CSECT FOR LISTING\n         SPACE\nLISTSW   DS    X\nLCSECTD  EQU   B'10000000'         1 = REQUESTED CSECT HAS BEEN LISTED\n         SPACE\nLISTLINE DS    CL36                OUTPUT LINE AREA\n         SPACE\nLISTHDR  MSG   'LOAD MODULE ',(LOADMOD,,C),'   CSECT ',(ESDNAME,8,C),  X\n               '   LENGTH ',ESDLEN,                                    X\n               '   SEGMENT ',(ESDSEGNO,1,H)\nLISTMSG  MSG   LISTLOC1,' ',LISTLOC2,'  ',                             X\n               (LISTLINE,35,C),'  *',(0(R3),(R2),C),'*'\nLISTEMSG MSG   (BLANKS,15,C),'END OF LIST'\nLISTFAIL MSG   '*CSECT ',LISTNAME,' NOT FOUND'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - MAP/AMAP COMMAND PROCESSOR'\n***********************************************************************\n* \"MAP\" COMMAND PROCESSOR                                             *\n*        -- AND --                                                    *\n* \"AMAP\" COMMAND PROCESSOR                                            *\n* THIS COMMAND DISPLAYS PERTINENT INFORMATION ABOUT THE CURRENT       *\n* ENVIRONMENT, INCLUDING CONTROL SECTION NAMES AND RELATIVE ADDRESSES *\n* IN PHYSICAL ORDER (FOR \"MAP\") OR ALPHABETICAL ORDER (FOR \"AMAP\").   *\n*              M(AP)  CSECTNAME                                       *\n*                  -- OR --                                           *\n*              A(MAP) CSECTNAME                                       *\n* WHERE: CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE ONLY     *\n*        CONTROL SECTION TO BE LISTED.  IF THIS IS OMITTED THEN ALL   *\n*        CSECTS ARE LISTED.  IF AN INVALID NAME IS ENTERED THEN NO    *\n*        CSECTS ARE LISTED.                                           *\n***********************************************************************\n         SPACE\nMAPRTE   DS    0H                  MAP COMMAND PROCESSOR SAME AS...\nAMAPRTE  DS    0H                  AMAP COMMAND PROCESSOR\n         SPACE\n         ST    R14,SAVE14          SAVE RETURN REGISTER\n         LR    R12,R15\n         USING MAPRTE,R12\n         NI    MAPSW,255-MCFOUND   INITIALIZE FLAGS\n         MVI   CC,C'0'             SET UP ASA DOUBLE SPACING\n         WRTMSG MHDMSG             WRITE MAP HEADING\n         CLI   CSECT,C' '          IF A CSECT IS CURRENTLY ACTIVE\n         BE    MNOCSECT            THEN\n         MVI   CC,C' '              SET UP ASA SINGLE SPACING\n         WRTMSG CSECTMSG            WRITE CSECT HEADER\n         MVI   CC,C'0'              RESTORE ASA DOUBLE SPACING\nMNOCSECT DS    0H\n         LH    R14,STRINGL         IF THERE IS A CURRENT FIND STRING\n         LTR   R14,R14\n         BZ    MNOFS               THEN\n         WRTMSG FSMSG               DISPLAY IT\n         ICM   R1,15,ALGNADDR       AND IF THERE IS A CURRENT ALIGNMENT\n         BZ    MNOFS                THEN\n         WRTMSG ALMSG                DISPLAY IT\nMNOFS    DS    0H\n         MVC   MAPCSECT,BLANKS     CLEAR CSECT NAME FOR DISPLAY\n         SCAN  1,MAXLEN=8          SCAN FOR NAME OF CSECT TO MAP\n         LTR   R8,R8               CHECK IF A VALID NAME ENTERED\n         BM    COMMONRT            IF INVALID, RETURN TO CALLER\n         BZ    MAPITALL            IF A CSECT NAME WAS ENTERED, THEN\n         BCTR  R15,0                USING ITS LENGTH,\n         EX    R15,MOVEMAPC         MOVE NAME TO CSECT NAME FOR COMPARE\nMAPITALL DS    0H                  ELSE MAP ALL CSECTS IN LOAD MODULE\n         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE\n         CLI   COMMAND,C'A'        IF THIS IS THE \"AMAP\" COMMAND,\n         BNE   MAPCHAIN            THEN\n         LA    R6,ESDHDRLN(,R5)     GET FIRST ESD ENTRY IN ALPHA ORDER\nACHKZERO C     R6,ESDENDAD          LOOP UNTIL END OF ALPHA LIST\n         BH    COMMAPRT             WHEN FINISHED, GO TO COMMON RETURN\n         B     MAPLOOP             ELSE\nMAPCHAIN ICM   R6,15,ESDLKHDR       GET FIRST ESD ENTRY IN PHYS ORDER\nMCHKZERO BZ    COMMAPRT             LOOP WHILE NOT ZERO\nMAPLOOP  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         CLI   MAPCSECT,C' '        IF A SPECIFIC CSECT REQUESTED\n         BE    MAPTHIS              THEN\n         CLC   MAPCSECT,ESDNAME      IF REQUESTED CSECT DOES NOT MATCH\n         BNE   DONTMAP               THEN SKIP THIS CONTROL SECTION\n         OI    MAPSW,MCFOUND         ELSE INDICATE CSECT FOUND\nMAPTHIS  DS    0H                   DISPLAY INFO ON ESD ENTRY <- R6\n         MVC   MAPID,BLANKS         CLEAR MAP ID OUTPUT\n         MVC   TESTTYPE,ESDTYPE     MOVE ESD TYPE FOR TESTING\n         NI    TESTTYPE,X'0F'       ZERO OUT IRRELEVANT BITS\n         CLI   TESTTYPE,ESDSD       IF SECTION DEFINITION\n         BNE   MAPNOTSD             THEN\n         MVC   MAPID(5),=C'CSECT'    MOVE IN CSECT IDENTIFIER\n         MVC   MAPID+7(8),ESDNAME    MOVE IN CSECT NAME\n         B     MAPTHIS2             ELSE\nMAPNOTSD CLI   TESTTYPE,ESDPC       IF PRIVATE CODE\n         BNE   MAPNOTPC\n         CLC   ESDNAME,$PRIVATE\n         BNE   MAPNPRIV\n         MVC   MAPID(12),=C'PRIVATE CODE'\n         B     MAPTHIS2             ELSE\nMAPNPRIV CLC   ESDNAME,$SEGTAB\n         BNE   MAPNSEGT\n         MVC   MAPID(13),=C'SEGMENT TABLE'\n         B     MAPTHIS2             ELSE\nMAPNSEGT CLC   ESDNAME,$ENTAB\n         BNE   MAPNENTT\n         MVC   MAPID(11),=C'ENTRY TABLE'\n         B     MAPTHIS2             ELSE\nMAPNENTT MVC   MAPID(9),=C'(UNKNOWN)'\n         B     MAPTHIS2             ELSE\nMAPNOTPC CLI   TESTTYPE,ESDCM        IF COMMON\n         BNE   MAPNOTCM\n         MVC   MAPID(6),=C'COMMON'\n         MVC   MAPID+7(8),ESDNAME\n         B     MAPTHIS2\nMAPNOTCM MVC   MAPID(5),=C'(UNKN)'\n         MVC   MAPID+6(8),ESDNAME\nMAPTHIS2 WRTMSG MAPMSG              DISPLAY INFO ON ESD ENTRY <- R6\nDONTMAP  DS    0H\n         TM    MAPSW,MCFOUND       IF REQUESTED CSECT HAS BEEN MAPPED\n         BO    COMMAPRT            THEN TERMINATE MAPPING\n         MVI   CC,C' '             ELSE ASA SINGLE SPACE NEXT MESSAGE\n         CLI   COMMAND,C'A'        IF THIS IS THE \"AMAP\" COMMAND\n         BNE   MAPNEXT             THEN\n         LA    R6,ESDENTLN(,R6)     GET NEXT ESD ENTRY (ALPHA ORDER)\n         B     ACHKZERO             AND CONTINUE LOOP\nMAPNEXT  DS    0H                  ELSE\n         ICM   R6,15,ESDLINKP       GET NEXT ESD ENTRY (PHYSICAL ORDER)\n         B     MCHKZERO             AND CONTINUE LOOP\n         SPACE\nCOMMAPRT DS    0H                  COMMON MAP/AMAP TERMINATION\n         MVI   CC,C'0'             SET ASA DOUBLE SPACING\n         WRTMSG MAPENMSG           SAY END OF MAP\n         B     GOODRET             RETURN TO MAINLINE\n         SPACE 2\nMOVEMAPC MVC   MAPCSECT(0),0(R8)   EXECUTED: MOVE CSECT NAME FOR (A)MAP\n         SPACE\nMAPSW    DS    X                   FLAGS\nMCFOUND  EQU   B'10000000'         1 = REQUESTED CSECT HAS BEEN MAPPED\n         SPACE\nMAPID    DS    CL15\n         SPACE\nMHDMSG   MSG   (BLANKS,16,C),'  LOAD MODULE: ',(LOADMOD,8,C),          X\n               '   LENGTH: ',(PDS2STOR,3,X),                           X\n               '   ENTRY POINT: ',(PDS2EPA,3,X)\nCSECTMSG MSG   (BLANKS,6,C),'CURRENT CONTROL SECTION: ',CSECT\nFSMSG    MSG   'CURRENT FIND STRING: ',(STRING,(R14),C)\nALMSG    MSG   'CURRENT ALIGNMENT IS ',(0(R1),11,W)\nMAPMSG   MSG   (MAPID,,C),                                             X\n               ' EXTENDS FROM ',ESDADDR,' TO ',(ESDNADDR+1,3,X),       X\n               ' - LENGTH IS ',ESDLEN,' - SEGMENT ',(ESDSEGNO,1,H)\nMAPENMSG MSG   (BLANKS,16,C),'END OF MAP'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - WHERE COMMAND PROCESSOR'\n***********************************************************************\n* \"WHERE\" COMMAND PROCESSOR                                           *\n* THIS COMMAND DISPLAYS THE CONTROL SECTION AND RELATIVE LOCATION     *\n* WITHIN THE CONTROL SECTION FOR A GIVEN HEXADECIMAL OFFSET.          *\n* SYNTAX:                                                             *\n*              W(HERE) HEXOFFSET                                      *\n* WHERE: HEXOFFSET IS REQUIRED AND SPECIFIES A HEXADECIMAL VALUE      *\n*        REPRESENTING AN OFFSET FROM THE LOAD POINT OF THE MODULE.    *\n*        IF THE MODULE IS AN OVERLAY MODULE THEN ALL LOCATIONS IN     *\n*        ALL OVERLAY SEGMENTS ARE DISPLAYED.                          *\n***********************************************************************\n         SPACE\nWHERERTE DS    0H\n         SPACE\n         ST    R14,SAVE14          SAVE RETURN REGISTER\n         LR    R12,R15\n         USING WHERERTE,R12\n         NI    WHERESW,255-WFOUND  INITIALIZE FLAGS\n         MVI   CC,C'0'             SET UP ASA DOUBLE SPACING\n         MVC   MAPCSECT,BLANKS     CLEAR CSECT NAME FOR DISPLAY\n         SCAN  1,MAXLEN=10         SCAN FOR OFFSET TO LOCATE\n         LTR   R8,R8               CHECK IF A VALID VALUE ENTERED\n         BM    COMMONRT            IF INVALID, RETURN TO CALLER\n         BNZ   WDOIT               IF NO OPERAND WAS ENTERED, THEN\n         LA    R1,WNOOPMSG          SAY 'MISSING OPERAND\"\n         B     WHEREWRT             AND RETURN.\nWDOIT    DS    0H                  ELSE PROCESS OPERAND\n         LA    R1,0(R8,R15)        GET ADDRESS OF LAST CHARACTER\n         BCTR  R1,0                IN OPERAND\n         CLI   0(R1),C'.'          IF IT IS A PERIOD\n         BNE   WNOTPD              THEN\n         BCTR  R15,0                REDUCE OPERAND LENGTH BY 1\nWNOTPD   DS    0H\n         CLI   0(R8),C'+'          IF STARTS WITH A PLUS SIGN\n         BNE   WNOTPLUS            THEN\n         BCTR  R15,0                REDUCE OPERAND LENGTH BY 1\n         LA    R8,1(,R8)            BUMP UP OPERAND POINTER\nWNOTPLUS DS    0H\n         LTR   R14,R15             IF LENGTH ZERO OR NEGATIVE\n         BNP   WINVOP              THEN INVALID OPERAND\n         CH    R14,=H'8'           IF LENGTH GREATER THAN 8\n         BH    WINVOP              THEN INVALID OPERAND\n         BCTR  R14,0               REDUCE LENGTH FOR EXECUTE\n         EX    R14,WVERIFY         CHECK ALL VALID HEX CHARACTERS\n         BNZ   WINVOP              IF BAD, INVALID OPERAND\n         EX    R14,WMOVE           ELSE MOVE OPERAND TO WORK AREA\n         EX    R14,WTRANS          TRANSLATE ABCDEF TO X'FA' ETC.\n         EX    R15,WPACK           PACK INTO LOCATION (USING LENGTH+1)\n         L     R2,WLOC             GET LOCATION INTO REGISTER\n         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE\n         ICM   R6,15,ESDLKHDR      GET FIRST ESD ENTRY IN PHYS ORDER\nWCHKZERO BZ    WEND                LOOP WHILE NOT ZERO\nWLOOP    DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         XR    R14,R14             CLEAR INSERT REG\n         ICM   R14,7,ESDADDR       GET ESD BEGINNING ADDRESS\n         CR    R2,R14              IF LOCATION EQ OR GT THIS CSECT LOC\n         BL    WNEXT               AND\n         C     R2,ESDNADDR         LOCATION LESS THAN CSECT END\n         BNL   WNEXT               THEN THIS IS THE ONE\n         OI    WHERESW,WFOUND       INDICATE LOCATION FOUND\n         LR    R0,R2                LOCATION MINUS ADDRESS\n         SLR   R0,R14               GIVES OFFSET WITHIN CSECT\n         ST    R0,WOFFSET           STORE OFFSET FOR DISPLAY\n         WRTMSG WHEREMSG            DISPLAY INFO ON ESD ENTRY\n         MVI   CC,C' '              ASA SINGLE SPACE NEXT MESSAGE\nWNEXT    DS    0H\n         ICM   R6,15,ESDLINKP       GET NEXT ESD ENTRY (PHYSICAL ORDER)\n         B     WCHKZERO             AND CONTINUE LOOP\n         SPACE\nWINVOP   DS    0H                  INVALID OPERAND...\n         LA    R1,WINVMSG          SAY SO\n         B     WHEREWRT            AND RETURN\n         SPACE\nWEND     DS    0H                  END OF WHERE PROCESSING\n         TM    WHERESW,WFOUND      IF LOCATION NOT FOUND,\n         BO    GOODRET             THEN\n         LA    R1,WNFMSG            SAY NOT FOUND\n******** B     WHEREWRT             GO TO DISPLAY MESSAGE\n         SPACE\nWHEREWRT WRTMSG (R1)\n         B     COMMONRT\n         SPACE 2\nWVERIFY  TRT   0(0,R8),WTRTBL      EXECUTED: VERIFY HEX CHARACTERS\nWMOVE    MVC   WWORK(0),0(R8)      EXECUTED: MOVE OPERAND TO WORK AREA\nWTRANS   TR    WWORK(0),XTCTBL     EXECUTED: TRANSLATE ABCDEF ETC.\nWPACK    PACK  WLOC(5),WWORK(0)    EXECUTED: PACK DATA INTO LOCATION\n         SPACE\nWOFFSET  DS    F                   OFFSET FOR DISPLAY\nWLOC     DS    F                   FULLWORD LOCATION OFFSET\n         DS    C                   SLACK BYTE FOR CONVERSION\nWWORK    DS    CL9                 WORK AREA FOR CONVERSION\n         SPACE\nWHERESW  DS    X                   FLAGS\nWFOUND   EQU   B'10000000'         1 = OFFSET HAS BEEN LOCATED\n         SPACE\nWTRTBL   DC    256X'01'            TABLE TO VERIFY HEX CHARACTERS\n         ORG   WTRTBL+C'A'\n         DC    6X'00'              ABCDEF ARE OK\n         ORG   WTRTBL+C'0'\n         DC    10X'00'             0123456789 ARE OK\n         ORG\n         SPACE\nWNOOPMSG MSG   '*MISSING OPERAND'\nWINVMSG  MSG   '*INVALID OPERAND'\nWHEREMSG MSG   (WLOC+1,3,X),'.  LOCATED AT +',(WOFFSET+1,3,X),         X\n               ' IN CSECT ',(ESDNAME,8,C),' - SEGMENT ',(ESDSEGNO,1,H)\nWNFMSG   MSG   (WLOC+1,3,X),'.  NOT WITHIN LOAD MODULE ',LOADMOD\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - DIR COMMAND PROCESSOR'\n***********************************************************************\n* \"DIR\" COMMAND PROCESSOR                                             *\n* THIS COMMAND DISPLAYS ALL MEMBER NAMES FOR THE CURRENTLY ALLOCATED  *\n* LIBRARIES.  ALIASES ARE INCLUDED IN THE SEQUENCE.                   *\n* SYNTAX:                                                             *\n*              D(IR)  ARGUMENT                                        *\n* WHERE: ARGUMENT IS OPTIONAL AND SPECIFIES A MEMBER NAME MASK        *\n* CONSISTING OF VALID CHARACTERS AND/OR ASTERISKS.  THE NAME MAY BE   *\n* SHORT, IN WHICH CASE IT IS PADDED WITH ASTERISKS.  THIS PROVIDES    *\n* FOR ONLY THOSE MEMBER NAMES WHICH MATCH THE MASK SPECIFICATION TO   *\n* BE DISPLAYED.  IF IT IS OMITTED, ALL MEMBER NAMES ARE DISPLAYED.    *\n***********************************************************************\n         SPACE\nDIRRTE   DS    0H\n         SPACE\n         ST    R14,SAVE14          SAVE RETURN REGISTER\n         LR    R12,R15\n         USING DIRRTE,R12\n         SCAN  1,MAXLEN=8          SCAN FOR AN OPERAND\n         LTR   R8,R8\n         BM    COMMONRT            IF SCAN ERROR, RETURN\n         BP    DIROPER             IF NO OPERAND, THEN\n         OI    DIRSW,DIRALLM        INDICATE TO PROCESS ALL MEMBERS\n         B     DIROPEN             ELSE\nDIROPER  DS    0H\n         NI    DIRSW,255-DIRALLM   INDICATE NOT PROCESSING ALL MEMBERS\n         LA    R0,DIRARG           POINT TO MOVE DESTINATION\n         LA    R1,8                GET LENGTH OF MOVE\n         LR    R14,R8              POINT TO MOVE SOURCE (OPERAND)\n         ICM   R15,8,=C'*'         LENGTH PLUS FILL CHARACTER\n         MVCL  R0,R14              MOVE OPERAND TO ARGUMENT, PAD='*'\n         MVC   DIRMASK,DIRARG      ALSO MOVE TO MASK AREA\n         TR    DIRARG,XTATBL       TRANSLATE ARGUMENT FROM '*' TO X'FF'\n         TR    DIRMASK,XTMTBL      TRANSLATE MASK TO X'00'S AND X'FF'S\nDIROPEN  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    COMMONRT\n         OPEN  SYSLIBD             OPEN TO READ DIRECTORY BLOCKS\nDIRINIT  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    DIRCLOSE\n         NI    DIRSW,255-DIRDSHD   INITIALIZE SWITCH\n         LA    R4,DIROUT           POINT TO OUTPUT AREA\n         LA    R5,DIROUT+L'DIROUT-11 POINT TO LAST VALID OUTPUT AREA\n         XR    R7,R7               CLEAR COUNT OF OUTPUT MEMBER NAMES\n         XR    R3,R3               CLEAR COUNT OF TOTAL MEMBER NAMES\nRDBLOCK  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    DIRCLOSE\n         GET   SYSLIBD             READ A DIRECTORY BLOCK\n         LH    R2,0(,R1)           GET BYTE COUNT OF CURRENT BLOCK\n         LA    R6,2(,R1)           POINT TO DATA IN BLOCK\n         BCTR  R2,0                SUBTRACT 2 FROM BYTE COUNT\n         BCTR  R2,0\nCHECKFF  CLC   0(8,R6),=8X'FF'     IF FFFFFFFF (END OF DIRECTORY)\n         BE    ENDDIR              THEN END OF MEMBERS. ELSE...\n         TM    DIRSW,DIRALLM       IF PROCESSING ONLY SOME MEMBERS\n         BO    DIRNOCHK             AND\n         CLC   0(8,R6),DIRARG        ENTRY HIGHER THAN LAST POSSIBLE\n         BH    ENDDIR                 THEN DON'T READ ANY UNNEC. BLOCKS\nDIRNOCHK TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    DIRCLOSE\n         CR    R4,R5               IF AT END OF CURRENT OUTPUT\n         BL    DIROUTOK            THEN\n         BAL   R14,DIROUTP          WRITE OUT A MEMBER LINE\nDIROUTOK DS    0H\n         TM    DIRSW,DIRALLM       IF PROCESSING ALL MEMBER NAMES\n         BO    DIRACC              THEN ACCEPT THIS NAME\n         MVC   DIRWORK,0(R6)       ELSE MOVE MEMBER NAME TO WORK AREA\n         OC    DIRWORK,DIRMASK     \"OR\" IT WITH THE MASK\n         CLC   DIRWORK,DIRARG      COMPARE WITH OPERAND ARGUMENT\n         BNE   DIRSKIP             IF NOT EQUAL, SKIP THIS NAME\nDIRACC   DS    0H\n         TM    11(R6),X'80'        IF THIS IS AN ALIAS NAME\n         BNO   DNTALIAS            THEN\n         MVC   0(2,R4),=C'A:'       INDICATE ALIAS IN OUTPUT\nDNTALIAS MVC   2(8,R4),0(R6)       MOVE MEMBER NAME TO OUTPUT\n         LA    R7,1(,R7)           INCREMENT OUTPUT MEMBER NAME COUNT\n         LA    R3,1(,R3)           INCREMENT TOTAL MEMBER NAME COUNT\n         LA    R4,11(,R4)          BUMP OUTPUT POINTER\nDIRSKIP  DS    0H\n         IC    R1,11(,R6)          PICK UP COUNT OF USER DATA HALFWORDS\n         SLL   R1,27               ERASE HIGH-ORDER 3 BITS\n         SRL   R1,26               AND MULTIPLY VALUE BY 2\n         LA    R1,12(,R1)          ADD 12 FOR MEMBER NAME AND TTR INFO\n         ALR   R6,R1               BUMP UP DATA POINTER\n         SR    R2,R1               BUMP DOWN REMAINING BYTE COUNT\n         BZ    RDBLOCK             IF NO MORE DATA IN BLOCK, NEXT BLOCK\n         B     CHECKFF             ELSE CONTINUE SCANNING THIS BLOCK\nENDDIR   DS    0H                  FF'S FOUND - LOGICAL END OF DIRBLKS\n         LTR   R3,R3               IF NO MEMBER NAMES AT ALL\n         BZ    DIRDOIT             OR\n         LTR   R7,R7                ANY MEMBER NAMES LEFT OVER\n         BZ    DIRFEOV             THEN\nDIRDOIT  BAL   R14,DIROUTP          WRITE CURRENT OUTPUT\nDIRFEOV  DS    0H\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BO    DIRCLOSE\n         FEOV  SYSLIBD             FORCE END OF VOLUME TO GO TO NEXT\n         B     DIRINIT             LIBRARY IN CONCATENATION & CONTINUE\n         SPACE\nDIREND   DS    0H                  REAL EOF ON DIRECTORY BLOCKS\n         MVI   CC,C'-'             TRIPLE SPACE FOR END MESSAGE\n         WRTMSG DIREMSG\nDIRCLOSE DS    0H\n         CLOSE SYSLIBD\n         MVI   CC,C'0'\n         B     GOODRET             RETURN TO MAINLINE\n         SPACE\nDIROUTP  DS    0H                  SUBROUTINE TO WRITE OUT MEMBER DATA\n         SPACE\n         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT\n         BOR   R14\n         TM    DIRSW,DIRDSHD       IF NO DATA SET HEADING DISPLAYED\n         BO    DIRWRT1             THEN\n         OI    DIRSW,DIRDSHD        INDICATE HEADING DISPLAYED\n         L     R15,540              GET TCB ADDRESS\n         L     R15,12(,R15)         GET TIOT ADDRESS\n         AH    R15,SYSLIBD+40       ADD TIOT OFFSET\n         ICM   R15,7,12(R15)        GET JFCB ADDRESS MINUS 16\n         MVI   CC,C'0'\n         WRTMSG DIRHEAD,USE15=YES   WRITE HEADING FOR LIBRARY\n         MVI   CC,C'0'\nDIRWRT1  DS    0H\n         LTR   R3,R3               IF MEMBER COUNT = 0\n         BNZ   DIRWRT2             THEN\n         LA    R1,DIRNOMEM          SAY NO MEMBERS IN DATA SET\n         B     DIRWRT\nDIRWRT2  LA    R1,DIRMSG            WRITE CURRENT OUTPUT\nDIRWRT   WRTMSG (1)\n         MVI   CC,C' '\n         MVI   DIROUT,C' '          CLEAR OUTPUT LINE TO BLANKS\n         MVC   DIROUT+1(L'DIROUT-1),DIROUT\n         LA    R4,DIROUT           POINT TO OUTPUT AREA\n         XR    R7,R7               CLEAR COUNT OF OUTPUT MEMBER NAMES\n         BR    R14                 RETURN\n         SPACE 2\nDIRSW    DC    X'00'\nDIRDSHD  EQU   X'80'               1 = DATA SET HEADING DISPLAYED\nDIRALLM  EQU   X'40'               1 = PROCESS ALL MEMBER NAMES\n         SPACE\nDIRARG   DS    CL8                 ARGUMENT FOR SELECTIVE MEMBER LIST\nDIRMASK  DS    CL8                 MASK FOR SELECTIVE MEMBER LIST\nDIRWORK  DS    CL8                 WORK AREA TO CHECK MEMBER NAME\n         SPACE\nDIROUT   DC    CL80' '             OUTPUT AREA TO BUILD MEMBER NAMES\n         SPACE\nDIRMSG   MSG   (DIROUT,,C)         FORMAT FOR OUTPUT DATA\n         USING INFMJFCB-16,R15\nDIRHEAD  MSG   'MEMBERS OF ',(JFCBDSNM,44,W),' ON ',(JFCBVOLS,6,C),':'\n         DROP  R15\nDIREMSG  MSG   'END OF DIRECTORY DISPLAY'\nDIRNOMEM MSG   'NO MEMBERS FOUND'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XLL - SCAN SUBROUTINE'\n***********************************************************************\n* \"SCAN\" SUBROUTINE                                                   *\n* THIS ROUTINE IS INVOKED BY THE \"SCAN\" MACRO.                        *\n* THIS ROUTINE EXTRACTS THE NEXT KEYWORD VALUE FROM THE CURRENT       *\n* CONTROL STATEMENT.  ON RETURN THE FOLLOWING REGISTERS ARE SET:      *\n* R8 - POINTS TO THE KEYWORD.                                         *\n* R15 - CONTAINS THE LENGTH OF THE KEYWORD.                           *\n* IF R15 IS ZERO, NO KEYWORD WAS FOUND.                               *\n* IF R8 IS ZERO, NO KEYWORD WAS FOUND.                                *\n* IF R8 IS NEGATIVE, AN ERROR WAS FOUND DURING SCANNING WHICH CAUSED  *\n* A MESSAGE TO BE WRITTEN OUT TO THE SYSPRINT FILE.                   *\n* THE FIELDS \"SCANPTR\" AND \"SCANEPTR\" ARE USED BY THIS SUBROUTINE AND *\n* MUST BE SET BY THE CALLER ON THE FIRST CALL AFTER AN INPUT CONTROL  *\n* STATEMENT IS READ.                                                  *\n* THIS ROUTINE MODIFIES REGISTERS R1, R2, R15.                        *\n* R2 IS THE BASE REGISTER.                                            *\n* R15 IS THE ENTRY REGISTER.                                          *\n* R14 IS THE LINK REGISTER - POINTS AS FOLLOWS:                       *\n*     +0 IS THE RELATIVE NUMBER OF THE OPERAND BEING SCANNED FOR.     *\n*     +1 IS THE MAXIMUM LENGTH (X'80' MEANS THERE IS NO MAXIMUM AND   *\n*        QUOTED-STRING SYNTAX IS PERMITTED).                          *\n*     +2 IS THE RETURN LOCATION TO BRANCH TO.                         *\n***********************************************************************\n         SPACE\nSCAN     DS    0H\n         SPACE\n         LR    R2,R15\n         USING SCAN,R2\n         XR    R15,R15             CLEAR LENGTH REGISTER\n         L     R1,SCANPTR          GET ADDRESS OF WHERE TO BEGIN SCAN\nSNLOOP1  CLM   R1,7,SCANEPTR+1     LOOP UNTIL END OF STATEMENT\n         BNL   NOMOREK             AT WHICH POINT NOTHING WAS FOUND\n         CLI   0(R1),C' '          SCAN UNTIL A NON-BLANK IS FOUND\n         BNE   GOTKWD\n         LA    R1,1(,R1)\n         B     SNLOOP1\nGOTKWD   DS    0H                  NON-BLANK FOUND: START OF KEYWORD\n         LR    R8,R1               SAVE ADDRESS: R8 -> THE KEYWORD\n         CLI   0(R14),0            IF A COMMAND BEING SCANNED\n         BNE   SNLOOP2             THEN\n         CLI   0(R8),C'*'           IF A COMMENT\n         BE    NOMOREK              THEN PRETEND NOTHING WAS ENTERED\nSNLOOP2  CLM   R1,7,SCANEPTR+1     LOOP AGAIN UNTIL END OF STATEMENT\n         BNL   GOTKEND             AT WHICH POINT END OF KEYWORD\n         CLI   0(R1),C' '          IF A BLANK\n         BE    GOTKEND             THEN TERMINATE KEYWORD\n         TM    1(R14),X'80'        ELSE IF A MAXIMUM LENGTH REQUIRED\n         BZ    SNINCR1             THEN DON'T LOOK FOR QUOTES\n         CLI   0(R1),C''''         ELSE IF A SINGLE QUOTE\n         BE    GOTQUOTE            THEN GO PROCESS QUOTED SUBSTRING\nSNINCR1  LA    R1,1(,R1)           ELSE KEEP SCANNING\n         B     SNLOOP2\nGOTQUOTE DS    0H                  IF WE FOUND A QUOTE...\n         LA    R1,1(,R1)           BUMP TO FOLLOWING CHARACTER\n         CLM   R1,7,SCANEPTR+1     IF END OF CONTROL STATEMENT HERE\n         BNL   SCANERR             THEN ERROR - MISSING END QUOTE\n         CLI   0(R1),C''''         IF ANYTHING BUT ANOTHER QUOTE\n         BNE   GOTQUOTE            THEN KEEP LOOPING HERE\n         LA    R1,1(,R1)           IF ANOTHER QUOTE, BUMP PAST IT\n         CLM   R1,7,SCANEPTR+1     IF END OF STATEMENT FOLLOWS\n         BNL   GOTKEND             THEN END OF ENTIRE KEYWORD STRING\n         CLI   0(R1),C''''         IF YET ANOTHER QUOTE,\n         BE    GOTQUOTE            THEN 2 QUOTES IS OK IN QUOTES STRING\n         CLI   0(R1),C' '          IF NONBLANK/NONQUOTE FOLLOWS,\n         BNE   SNLOOP2             THEN RESUME UNQUOTED SCANNING. ELSE\nGOTKEND  DS    0H                  END OF KEYWORD FOUND HERE...\n         LR    R15,R1              ADDRESS OF TERMINATING LOCATION\n         SR    R15,R8              MINUS START ==> LENGTH OF KEYWORD\n         TM    1(R14),X'80'        IF NO LENGTH CHECK REQUESTED\n         BO    RETSCAN             THEN RETURN WITH R15 = KEYWORD LEN\n         CLM   R15,1,1(R14)        ELSE IF LENGTH EXCEEDS MAXIMUM\n         BNH   RETSCAN             THEN\n         TM    DIALOGSW,PARMSCAN    IF SCANNING PARM FIELD\n         BZ    SCANWRT              THEN\n         WTO   MF=(E,WTOIVPRM)       SAY INVALID PARM FIELD SPECIFIED\n         B     SCANFAIL              WRITE TO PROGRAMMER AN ERROR MSG\nSCANWRT  DS    0H                   ELSE\n         CLI   0(R14),0             IF A COMMAND BEING SCANNED\n         BNE   SCNKWDM              THEN\n         LA    R8,TOOLONGC           SAY THAT\n         B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH\nSCNKWDM  DS    0H                   ELSE\n         LA    R8,TOOLONGO           SAY SO\n         B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH\nSCANERR  DS    0H                  IF AN ERROR IN QUOTED STRING...\n         LA    R8,NOENDQ            SAY ENDING QUOTE IS MISSING\n******** B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH\nSCANMSG  WRTMSG (R8)\nSCANFAIL XR    R15,R15             SET R15 = 0 (INDICATE NO KEYWORD)\n         XR    R8,R8               SET R8 = -1 (NEGATIVE)\n         BCT   R8,RETSCAN           AND RETURN TO CALLER.\nNOMOREK  DS    0H                  NO KEYWORD FOUND...\n         XR    R8,R8               CLEAR KEYWORD PTR (LENGTH STILL 0)\nRETSCAN  ST    R1,SCANPTR          UPDATE SCAN POINTER\n         B     2(,R14)             RETURN TO CALLER\n         SPACE\nNOENDQ   MSG   '*MISSING END QUOTE ON OPERAND'\nTOOLONGC MSG   '*COMMAND NAME TOO LONG'\nTOOLONGO MSG   '*OPERAND ',(0(R14),1,H),                               X\n               ' CANNOT EXCEED ',(1(R14),1,H),' CHARACTERS'\n         SPACE\nWTOIVPRM WTO   MF=L,ROUTCDE=11,'XLL: INVALID PARM FIELD SPECIFIED'\n         SPACE\n         LTORG\n         SPACE\n         DROP  R2\n         TITLE 'XLL - ATTENTION EXIT ROUTINE'\n         SPACE\n***********************************************************************\n* THIS ROUTINE RECEIVES CONTROL WHEN AN ATTENTION INTERRUPTION IS\n* RECEIVED.\n***********************************************************************\n         SPACE\nATTNEXIT DS    0H\n         SPACE\n         L     R2,8(,R1)           GET ADDRESS OF USER PARM LIST\n         OI    SWITCH-COMMON(R2),ATTN  INDICATE ATTENTION OCCURRED\n         BR    R14                 RETURN TO SYSTEM\n         TITLE 'XLL - COMMON AREA'\nCOMMON   DS    0D\n         SPACE\n***********************************************************************\n* SAVE AREAS\n***********************************************************************\nSAVEAREA DS    18F                 OS SAVE AREA\nSAVED14  EQU   SAVEAREA+12,4,C'F'\nSAVED15  EQU   SAVEAREA+16,4,C'F'\nSAVED0   EQU   SAVEAREA+20,4,C'F'\nSAVED1   EQU   SAVEAREA+24,4,C'F'\nSAVEBASE DS    F                   BASE REGISTER SAVE FOR MAINLINE\nSAVE14   DS    F                   SAVE AREA FOR COMMAND PROCESSORS\n         SPACE\n***********************************************************************\n* SUBROUTINE ADDRESSES\n***********************************************************************\nSCANADDR DC    A(SCAN)             ADDRESS OF THE SCAN SUBROUTINE\nWRTADDR  DC    V(WRITE)            ADDRESS OF THE WRITE SUBROUTINE\n         SPACE\n***********************************************************************\n* COMMON RETURN POINTS USED BY ALL COMMAND PROCESSING SUBROUTINES     *\n***********************************************************************\nGOODRET  DS    0H                  COMMON RETURN POINT FOR SUCCESSES\n         MVI   XLLCMD,C' '         CLEAR COMMAND VARIABLE TO BLANKS\n         MVC   XLLCMD+1(L'XLLCMD-1),XLLCMD\nCOMMONRT DS    0H                  COMMON RETURN POINT FOR ALL COMMANDS\n         L     R14,SAVE14          RELOAD RETURN REGISTER\n         TM    SWITCH,ATTN         IF NO ATTENTION INTERRUPT OCCURRED,\n         BZR   R14                 THEN RETURN TO MAINLINE\n         NI    SWITCH,255-ATTN     ELSE RESET ATTENTION FLAG\n         WRTMSG ATTNMSG            SEND USER A MESSAGE\n         BR    R14                 RETURN TO MAINLINE\n         SPACE\nATTNMSG  MSG   'ATTENTION INTERRUPT, ENTER NEW XLL COMMAND'\n         SPACE\n***********************************************************************\n* WORK AREAS AND OTHER DECLARATIVES\n***********************************************************************\nDOUBLE   DS    D                   CONVERSION WORK AREA\nTESTBYTE EQU   DOUBLE+7,1,C'C'     OVERLAY FOR ALIGNMENT TESTING\n         SPACE\nSCANPTR  DS    F                   USED BY THE SCAN SUBROUTINE\nSCANEPTR DS    F                   USED BY THE SCAN SUBROUTINE\nERRCODE  DS    F                   USED WHEN OS MACRO FAILURE\nESDBUFAD DC    F'0'                POINTER TO ESD BUFFER\nESDBUFLN DC    F'0'                LENGTH OF ESD BUFFER\nESDENDAD DC    F'0'                ADDRESS OF END OF ESD ENTRIES\nLOADLEN  DS    F                   LENGTH OF LOAD MODULE\nLOADADDR DS    F                   ADDRESS OF LOAD MODULE\nADRSTART DS    F                   ADDRESS OF BEGINNING OF CSECT\nCURRESD  DC    F'0'                ADDR OF ESD ENTRY FOR ACTIVE CSECT\nALGNADDR DC    F'0'                ADDRESS OF ALIGNMENT TABLE ENTRY\nSTRINGL  DC    H'0'                LENGTH OF SAVED STRING (0 = NONE)\nTESTTYPE DS    C                   ESD TYPE FOR TESTING\nALGNTEST DS    CL11                USED TO DETERMINE ALIGNMENT SPEC.\n         SPACE\nSWITCH   DC    X'00'               VARIOUS SWITCHES AND FLAGS\n         SPACE\nCESDRECS EQU   B'10000000'         ON WHEN CESD RECORD(S) ARE FOUND\nLOADED   EQU   B'01000000'         ON WHEN A MODULE IS LOADED\nINTEXT   EQU   B'00100000'         ON WHEN READING A TEXT RECORD\nSEGTAB   EQU   B'00010000'         ON WHEN A SEGMENT TABLE FOUND\nSYSINTRM EQU   B'00001000'         ON WHEN SYSIN ALLOCATED TO TERMINAL\nATTN     EQU   B'00000100'         ON WHEN ATTENTION EXIT TAKEN\nNEWSEG   EQU   B'00000010'         ON WHEN NEXT SEGMENT IS COMING\nCLEANUP  EQU   B'00000001'         ON WHEN NAME RTE CALLED TO END UP\n         SPACE\nDIALOGSW DC    X'00'               VARIOUS FLAGS RELATING TO ISPF USAGE\n         SPACE\nISPFMODE EQU   B'10000000'         ON WHEN ISPF DIALOG MODE IN USE\nTBCREATE EQU   B'01000000'         ON WHEN TABLE MUST BE (RE)CREATED\nPARMSCAN EQU   B'00100000'         ON WHEN SCANNING PARM FIELD\n*        EQU   B'00010000'         RESERVED\n*        EQU   B'00001000'         RESERVED\n*        EQU   B'00000100'         RESERVED\n*        EQU   B'00000010'         RESERVED\n*        EQU   B'00000001'         RESERVED\n         SPACE\nALIGNTBL DS    0X                  TABLE OF VALID ALIGNMENT SPEC'S\nNOALIGN  DC    CL11'NOALIGN    ',B'00000000'\nNOALMASK EQU   *-1,1,C'B'\nHALFWORD DC    CL11'HALFWORD   ',B'00000001'\nHALFMASK EQU   *-1,1,C'B'\nFULLWORD DC    CL11'FULLWORD   ',B'00000011'\nFULLMASK EQU   *-1,1,C'B'\nDOUBWORD DC    CL11'DOUBLEWORD ',B'00000111'\nDOUBMASK EQU   *-1,1,C'B'\nALIGNEND EQU   *                   END OF ALIGNMENT TABLE\n         SPACE\n         READ  DECB,SF,SYSLIB,,'S',MF=L DECB TO READ LOAD MOD RECORDS\n         SPACE\nBLANKS   DC    CL16' '             GENERAL PURPOSE BLANKS\nSTRING   DS    CL80                SAVED TEXT OF FIND STRING\nDATAAREA DS    CL128               DATA AREA FOR STRING CONVERSION\nMASKAREA DS    CL128               DATA AREA FOR COMPARE MASK\nTESTAREA DS    CL128               DATA AREA FOR COMPARE OPERATION\nCC       DC    C'1'                ASA CONTROL CHARACTER FOR WRITES\n         SPACE\n***********************************************************************\n* MISCELLANEOUS CONSTANTS\n***********************************************************************\n         SPACE\n$PRIVATE DC    CL8'$PRIVATE'\n$SEGTAB  DC    CL8'$SEGTAB '\n$ENTAB   DC    CL8'$ENTAB  '\n         SPACE\n***********************************************************************\n* TRANSLATION TABLES\n***********************************************************************\n         SPACE\nLWRTXTBL DC    C'0123456789ABCDEF' TABLE\nLISTXTBL EQU   *-256                    FOR CONVERTING HEX TO CHARACTER\n         SPACE\nVALIDXTB DC    256X'01'            TABLE OF VALID HEX-STRING CHARACTERS\n         ORG   VALIDXTB+C'A'       ABCDEF\n         DC    6X'00'\n         ORG   VALIDXTB+C'0'       0123456789\n         DC    10X'00'\n         ORG   VALIDXTB+C'*'       *\n         DC    X'00'\n         ORG\nXTCTBL$  DC    (256-C'*')YL1(*-XTCTBL) TABLE TO BUILD HEX COMPARESTRING\nXTCTBL   EQU   XTCTBL$-C'*'        REAL LABEL FOR ABOVE TABLE\n         ORG   XTCTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     STANDARD HEX TRANSLATIONS\n         ORG   XTCTBL+C'*'\n         DC    X'FF'               TREAT ASTERISK AS ALL 1-BITS\n         ORG\nXTMTBL   DC    256X'00'            TABLE TO BUILD HEX COMPARE MASK\n         ORG   XTMTBL+C'*'         CHANGES EVERYTHING TO 0-BITS\n         DC    X'FF'               EXCEPT ASTERISKS WHICH BECOME 1-BITS\n         ORG\nXTATBL   DC    256YL1(*-XTATBL)    TABLE TO BUILD ARGUMENT STRING\n         ORG   XTATBL+C'*'         LEAVES EVERYTHING AS IS\n         DC    X'FF'               EXCEPT ASTERISKS WHICH BECOME 1-BITS\n         ORG\nNUMTBL   DC    256X'01'            TABLE TO VERIFY NUMERICS\n         ORG   NUMTBL+C'0'\n         DC    10X'00'\n         ORG\nSCANTBL  DS    XL256               DYNAMICALLY SET TBL 4 QUICK SCANNING\n         SPACE 2\nCOMMAND  DS    CL8                 THIS IS WHERE THE COMMAND NAME GOES\nKEYWORD  DS    CL8                 THIS IS WHERE THE MODULE NAME GOES\nCSECT    DC    CL8' '              THIS IS WHERE THE CSECT NAME GOES\nMAPCSECT DC    CL8' '              NAME OF THE CSECT TO BE MAPPED\n         SPACE 2\n* DATA AREAS USED IN ISPF DIALOG MODE\n         SPACE\nTABLE    DC    CL8' '              ISPF TABLE NAME FOR DIALOG MODE\nPANEL    DC    CL8' '              ISPF PANEL NAME FOR DIALOG MODE\nMSGID    DC    CL8' '              ISPF MESSAGE ID FOR DIALOG MODE\nXLLCMD   DC    CL80' '             ISPF INPUT FIELD\nXLLROW   DC    CL79' '             ISPF OUTPUT FIELD\n@ISPLINK DS    A                   ADDRESS OF ISPLINK MODULE\nISPPARMS DS    0A                  PARAMETERS FOR ISPLINK\nISPPARM1 DS    A\nISPPARM2 DS    A\nISPPARM3 DS    A\nISPPARM4 DS    A\nISPPARM5 DS    A\nISPPARM6 DS    A\nISPPARM7 DS    A\n         EJECT\n         DS    0F                  ALIGN THE FOLLOWING\nBLDLLIST EQU   *                   BLDL LIST WITH 1 ENTRY\nH1       DC    H'1'                THIS DOUBLES AS A LITERAL CONSTANT\n         DC    H'58'\nLOADMOD  DC    CL8' '              LOAD MODULE NAME FOR BLDL AND LOAD\nTTR      DS    CL3\nK        DS    CL1\nZ        DS    CL1\nC        DS    CL1\n         DS    CL44\nBLDLEND  EQU   *                   END OF THE BLDL LIST\n         ORG   LOADMOD             THE FF. MACRO MAPS DIRECTORY ENTRY\n         SPACE 4\n         IHAPDS DSECT=NO,PDSBLDL=YES\n         SPACE 4\n         ORG   BLDLEND\n         EJECT\n***********************************************************************\n* DATA CONTROL BLOCKS                                                 *\n***********************************************************************\n         SPACE\n         PRINT NOGEN\n         SPACE\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GL,DSORG=PS,EODAD=EOF,               X\n               RECFM=FB,LRECL=80\n         SPACE\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,                      X\n               RECFM=FBA,LRECL=121,BLKSIZE=6171\n         SPACE\nSYSLIB   DCB   DDNAME=SYSLIB,MACRF=R,DSORG=PO,RECFM=U,EODAD=ENDRECS\n         SPACE\nSYSLIBD  DCB   DDNAME=SYSLIB,MACRF=GL,DSORG=PS,RECFM=F,LRECL=256,      X\n               BLKSIZE=256,EODAD=DIREND\n         SPACE\n         PRINT GEN\n         SPACE\nCOMMNEND EQU   *                   DISPLAY LOCATION OF END OF COMMON\nCOMMNLNG EQU   *-COMMON            DISPLAY LENGTH OF COMMON AREA\n         SPACE\n         DROP  R5,R6,R13\n         EJECT\n***********************************************************************\n* *** DSECTS ***                                                      *\n***********************************************************************\n         SPACE\nALTDDS   DSECT\n*\n*    ALTERNATE DDNAME LIST FOR STANDARD UTILITIES:\n*\nALTDDLEN DS    H\n         DS    CL8    1    SYSLIN\n         DS    CL8    2    NAME (FOR LKED)\n         DS    CL8    3    SYSLMOD\nALTLIB   DS    CL8    4    SYSLIB\nALTIN    DS    CL8    5    SYSIN\nALTPRINT DS    CL8    6    SYSPRINT\n         DS    CL8    7    SYSPUNCH\n         DS    CL8    8    SYSUT1\n         DS    CL8    9    SYSUT2\n         SPACE\nESDTABLE DSECT ,                   LAYOUT OF ESD TABLE\n         SPACE\nESDTBLEN DS    F                   LENGTH OF THIS BUFFER INCLUDING HDR\n*                  (WHICH ALSO EQUALS THE OFFSET OF END OF THIS BUFFER)\nESD#ENTS DS    F                   NUMBER OF ENTRIES IN BUFFER\nESDAVAIL DS    F                   OFFSET OF FIRST UNUSED BUFFER SLOT\nESDLKHDR DS    F                   PTR TO FIRST ENTRY IN PHYSICAL ORDER\n         SPACE\nESDENTRY DS    0C                  CESD ENTRIES BEGIN HERE\n*\n* NOTE THAT THE FIRST 16 BYTES OF EACH ESD ENTRY CORRESPOND TO THE\n* LOAD MODULE CESD ENTRY MAPPING.\n*\nESDNAME  DS    CL8                 EXTERNAL SYMBOL NAME (CSECT NAME)\nESDTYPE  DS    X                   TYPE OF ENTRY (00=SD,04=PC,05=CM)\nESDSD    EQU   X'00'               SECTION DEFINITION\nESDLD    EQU   X'01'               LABEL REFERENCE\nESDER    EQU   X'02'               EXTERNAL REFERENCE\nESDPR    EQU   X'06'               PSEUDO REGISTER\nESDPC    EQU   X'04'               PRIVATE CODE\nESDCM    EQU   X'05'               COMMON\nESDWX    EQU   X'0A'               WEAK EXTERNAL REFERENCE\nESDPCOV  EQU   X'14'               PRIVATE CODE MARKED DELETE\n*                                  (SEGMENT TABLE OR ENTRY TABLE)\nESDADDR  DS    XL3                 ASSIGNED ADDRESS OF SYMBOL (REL.)\nESDSEGNO DS    X                   SEGMENT NUMBER (OVERLAY ONLY)\nESDARG   EQU   ESDADDR,*-ESDADDR,C'X'  COMPARE ARGUMENT FOR LINKING\nESDLEN   DS    XL3                 LENGTH OF CONTROL SECTION\n         SPACE\nESDNADDR DS    XL4                 OFFSET OF NEXT CSECT (ADDR + LENGTH)\nESDLINKP DS    AL4                 CHAIN POINTER FOR PHYSICAL ORDER\n         SPACE\nESDENTLN EQU   *-ESDENTRY          LENGTH OF ONE OF OUR ESD ENTRIES\n         SPACE\nESDHDRLN EQU   ESDENTRY-ESDTABLE   LENGTH OF THE ESD TABLE HEADER\n         SPACE\n*** EQUATES ***\n         SPACE\nINIT#ENT EQU   16                  INITIAL NUMBER OF ENTRIES PER BUFFER\n         SPACE\nINITLNTH EQU   INIT#ENT*ESDENTLN   LENGTH OF ALL ENTRIES WITHOUT HEADER\n         EJECT\nOVLYTBL  DSECT ,                   OVERLAY SEGMENT CONTROL TABLE\n         SPACE\n***********************************************************************\n* THERE IS ONE 16-BYTE ENTRY IN THIS TABLE FOR EACH SEGMENT IN THE    *\n* LOAD MODULE; EACH ENTRY CONTAINS THE ADDRESS OF THE IN-STORAGE      *\n* BUFFER ALLOCATED TO HOLD ALL THE CSECTS FROM ONE SEGMENT.  THE      *\n* SEGMENT NUMBER IS USED AS AN INDEX INTO THE TABLE. SINCE THERE IS   *\n* NO ZERO-NUMBERED SEGMENT, THE FIRST 16 BYTES OF THE TABLE ARE USED  *\n* TO HOLD CONTROL INFORMATION ABOUT THE OVERLAY SEGMENTS AND TABLE.   *\n***********************************************************************\n         SPACE\nOVSEGADR DS    A                   ADDRESS OF MODULE SEGMENT BUFFER\nOVSEGHI  DS    A                   HIGH BOUND OF MODULES IN SEGMENT\nOVSEGLO  DS    A                   LOW BOUND OF MODULES IN SEGMENT\nOVSEGLEN DS    A                   LENGTH OF SEGMENT (OVSEGHI-OVSEGLO)\n         SPACE\n         ORG   OVLYTBL             DEFINE CONTENTS OF ENTRY 0\n         SPACE\nOVTBLEN  DS    F                   LENGTH OF OVERLAY CONTROL TABLE\nCURSEG#  DS    H                   CURRENT SEGMENT NUMBER\nMAXSEG#  DS    H                   MAXIMUM SEGMENT NUMBER\n         SPACE\n         ORG\n         SPACE\nOVENTLB  EQU   *-OVLYTBL           LENGTH OF EACH ENTRY IN TABLE\nOVSHIFT  EQU   4                   AMOUNT TO SHIFT REGISTER FOR INDEX\n         EJECT\n         IEFJFCBN ,                MAP THE JOB FILE CONTROL BLOCK\n         EJECT\n         TITLE 'XLL - WRITE MODULE FOR GENERAL PURPOSE MESSAGE OUTPUT'\nWRITE    CSECT\n         SAVE  (14,12),,WRITE\n         BALR  R12,0\n         USING *,12\n         LA    R1,WRTSAVE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R9,R13              SAVE HSA ADDRESS\n         LR    R13,R1\n         USING COMMON,R9\n***********************************************************************\n* THIS SUBROUTINE USES NONSTANDARD LINKAGE.                           *\n* REGISTER 14 DOES NOT CONTAIN RETURN ADDRESS.                        *\n* REGISTER 1 DOES NOT CONTAIN ADDRESS OF PARAMETER LIST.              *\n* REGISTER 0 POINTS TO A PARAMETER LIST AS FOLLOWS:                   *\n*    +0 ... S-TYPE ADDRESS OF MESSAGE STRING                          *\n*    +2 IS THE RETURN ADDRESS (NOT IN REG14)                          *\n***********************************************************************\n* CALLING SEQUENCE IS AS FOLLOWS:                                     *\n*        ST    15,0(,13)           TEMPORARY REG 15 SAVE IF NEEDED    *\n*        L     15,=V(WRITE)        ADDRESS OF THIS ROUTINE            *\n*        BALR  0,15                CALL ROUTINE PASSING PLIST IN REG0 *\n*        DC    S(MSG)              ADDRESS OF MESSAGE STRING          *\n*        ...   INSTRUCTIONS CONTINUE HERE                             *\n***********************************************************************\n         SPACE\n***********************************************************************\n* CHECK FOR ATTENTION INTERRUPT.  IF ANY, RETURN WITHOUT PROCESSING   *\n***********************************************************************\n         SPACE\n         TM    SWITCH,ATTN\n         BO    WRTRET\n         SPACE\n***********************************************************************\n* SET UP OUR OWN SAVE AREA FOR QUICK REFERENCE TO S-CON REGISTERS     *\n***********************************************************************\n         MVC   REGSAVE(4*(12+1)),SAVED0      GET CALLER'S REGS 0-12\n         MVC   REGSAVE+(4*13)(4),WRTSAVE+4   GET CALLER'S REG 13\n         MVC   REGSAVE+(4*14)(4),SAVED14     GET CALLER'S REG 14\n         MVC   REGSAVE+(4*15)(4),SAVEAREA    GET CALLER'S REG15\n*\n* THE ABOVE ASSUMES THAT THE CALLER OF THIS ROUTINE ISSUED THE\n* INSTRUCTION \"ST 15,0(,13)\".\n*\n         L     R1,REGSAVE+(4*0)    PICK UP CALLER'S REG 0 IN OUR REG 1\n         LOADSA 0(R1),ERRET=BADPARM GET ADDR OF MESSAGE STRING IN R15\n         LA    R14,0(,R15)         SAVE IT TO POINT TO START OF MESSAGE\n         MVC   CCC(1),CC           SAVE CONTROL CHARACTER\n         LA    R15,SYSPRINT        GET ADDRESS OF PRINT DCB\n         ST    R15,DCBADDR         SAVE IT\n         LA    R3,WRAREA+L'WRAREA  POINT TO END OF WORK AREA\n         MVI   WRAREA,C' '         INIT WORK AREA TO BLANKS\n         MVC   WRAREA+1(L'WRAREA-1),WRAREA\n         LA    R2,WRAREA           INITIALIZE OUTPUT POINTER\n         LR    R1,R14              INITIALIZE SCANNING POINTER\nWRTLOOP1 TM    0(R1),X'C0'         SCAN MESSAGE STRING UNTIL\n         BZ    WRTGCNTL             A BYTE CONTAINING B'00......' IN\n         LA    R1,1(,R1)            LEFT HALF IS ENCOUNTERED.\n         B     WRTLOOP1            THAT WILL BE A CONTROL BYTE.\nWRTGCNTL DS    0H                  R1 -> CONTROL BYTE\n         LR    R15,R1              CURRENT LOCATION MINUS PREV START...\n         SR    R15,R14             R15 = LENGTH OF CHARACTERS SO FAR\n         BNP   WRTLZERO            IF ZERO, NO INTERVENING DATA, SKIP\n         BCTR  R15,0               ADJUST FOR EXECUTE\n         EX    R15,WRTMVC14        MOVE INTERVENING DATA TO OUTPUT\n         LA    R2,1(R15,R2)        BUMP OUTPUT POINTER PAST MOVED DATA\nWRTLZERO DS    0H\n         CLI   0(R1),X'3F'         IF HEX 3F FOUND (END-OF-MESSAGE)\n         BE    WRTFINIS            THEN END OF MESSAGE, FINISH. ELSE...\n* WE HAVE A 4-BYTE CONTROL SEQUENCE AS FOLLOWS:\n* +0 IS A 1-BYTE TYPE CODE\n* +1 IS A 1-BYTE LENGTH CODE\n* +2 IS THE S-CON OF THE DATA\n* DETERMINE LENGTH OF DATA TO BE WRITTEN\n         TM    1(R1),X'80'         IF THIS IS A REGISTER-LENGTH SPEC,\n         BZ    WRTNOREG            THEN...\n         IC    R14,1(,R1)          LENGTH CODE CONTAINS REGISTER NUMBER\n         SLL   R14,25              ERASE HIGH-ORDER INDICATOR BIT\n         SRL   R14,25              LEAVING THE REGISTER NUMBER ONLY\n         LTR   R14,R14             IF REGISTER NUMBER IS ZERO\n         BNP   WRTERROR            THEN ERROR, BASE CANNOT BE ZERO\n         SLA   R14,2               ELSE MULTIPLY BY 4 FOR INDEX\n         L     R4,REGSAVE(R14)     LENGTH=CONTENTS OF CALLER'S REGISTER\n         LTR   R4,R4               IF ZERO LENGTH,\n         BZ    WRTCOMMN            THEN BYPASS PROCESSING THIS FIELD\n         CH    R4,=H'128'          IF LENGTH EXCEEDS THE MAXIMUM\n         BNL   WRTERROR            THEN ERROR - LENGTH TOO BIG\n         B     AFTREGLN            ELSE OK, PROCESS THE LENGTH\nWRTNOREG DS    0H                  LENGTH IS NOT REGISTER BUT ACTUAL...\n         XR    R4,R4               CLEAR INSERT REG\n         ICM   R4,1,1(R1)          PICK UP LENGTH FROM STRING\n         BZ    WRTERROR            IF ZERO, PARAMETER ERROR, REJECT\nAFTREGLN DS    0H                  LENGTH IS OK, NOW USE IT\n         LOADSA 2(R1)              SET R15 = ADDRESS OF THE DATA\n* NOW R15 CONTAINS THE VIRTUAL STORAGE ADDRESS OF THE DATA TO BE\n* MOVED TO THE PLACE THAT R2 POINTS TO.\n         XR    R14,R14             CLEAR INSERT REG\n         IC    R14,0(,R1)          PICK UP TYPE INDICATOR\n         B     WRTTYPE(R14)        BRANCH DEPENDING ON TYPE\nWRTTYPE  B     TYPEW               X'00' - TYPE = W\n         B     TYPEC               X'04' - TYPE = C\n         B     TYPEX               X'08' - TYPE = X\n         B     TYPEFH              X'0C' - TYPE = F OR H\n*                                  ANYTHING ELSE - ASSUME TYPE W\n         EJECT\n***********************************************************************\n* TYPE W - CHARACTER TERMINATED BY FIRST BLANK\n***********************************************************************\n         SPACE\nTYPEW    DS    0H\n         SPACE\n         LR    R0,R4               PICK UP DATA LENGTH\n         LA    R15,0(,R15)         PURIFY INPUT REGISTER\n         LR    R14,R15             SAVE ADDRESS OF START OF INPUT\nWLOOP1   CLI   0(R14),C' '         SCAN FOR FIRST BLANK\n         BE    WENDLOOP             WHILE\n         LA    R14,1(,R14)          BUMPING INPUT POINTER\n         BCT   R0,WLOOP1            UNTIL END OF DATA\nWENDLOOP SR    R14,R15             GET LENGTH OF DATA TO BE MOVED\n         BNP   WRTCOMMN            IF ZERO, NO MOVE, CONTINUE\n         B     TWCMOVE             GO TO ACTUALLY MOVE THE DATA\n         EJECT\n***********************************************************************\n* TYPE C - CHARACTER INCLUDING ALL BLANKS\n***********************************************************************\n         SPACE\nTYPEC    DS    0H\n         SPACE\n         LR    R14,R4              PICK UP DATA LENGTH\nTWCMOVE  DS    0H                  MOVE FOR TYPES W AND C\n         BCTR  R14,0               REDUCE FOR EXECUTE\n         EX    R14,WRTMVC15        MOVE DATA TO OUTPUT AREA\n         EX    R14,TRCHAR          TRANSLATE DATA TO PRINTABLE\n         LA    R2,1(R14,R2)        BUMP UP OUTPUT POINTER\n         B     WRTCOMMN            GO FINISH UP\n         EJECT\n***********************************************************************\n* TYPE X - HEX TO BE CONVERTED TO  READABLE DISPLAY\n***********************************************************************\n         SPACE\nTYPEX    DS    0H\n         SPACE\n         LR    R14,R4              PICK UP DATA LENGTH\n         XR    R0,R0               CLEAR INSERT REG\nXLOOP    IC    R0,0(,R15)          PICK UP BYTE OF HEX INPUT DATA\n         STC   R0,1(,R2)           STORE INTO OUTPUT AREA 2ND BYTE\n         NI    1(R2),X'0F'         ZERO LEFT HALF, KEEP RIGHT HALF\n         SRL   R0,4                ISOLATE LEFT HEX DIGIT\n         STC   R0,0(,R2)           STORE INTO OUTPUT AREA 1ST BYTE\n         TR    0(2,R2),LWRTXTBL              TRANSLATE TO PRINTABLE\n         LA    R2,2(,R2)           BUMP UP OUTPUT POINTER\n         LA    R15,1(,R15)         BUMP UP INPUT POINTER\n         BCT   R14,XLOOP           CONTINUE UNTIL LENGTH EXHAUSTED\n         B     WRTCOMMN            GO FINISH UP\n         EJECT\n***********************************************************************\n* TYPE H OR F - HALFWORD OR FULLWORD, TO BE DISPLAYED AS NUMERIC\n***********************************************************************\n         SPACE\nTYPEFH   DS    0H\n         SPACE\n         CH    R4,=H'4'            IF GREATER THAN MAXIMUM LENGTH OF 4,\n         BH    WRTERROR            THEN PARAMETER ERROR, REJECT\n         IC    R14,MASKS-1(R4)     PUT MASK FOR ICM INSTRUCTION IN R14\n         XR    R0,R0               CLEAR INSERT REG\n         EX    R14,WRTICM          LOAD R0 WITH FULLWORD/HALFWORD\n         CVD   R0,WDOUBLE          CONVERT TO PACKED DECIMAL\n         MVI   CONVWORK,C' '       CLEAR DATA AREA TO BLANKS\n         MVC   CONVWORK+1(L'CONVWORK-1),CONVWORK\n         MVC   CONVWORK(12),=X'F02020202020202020202020' EDIT-PATTERN\n         LR    R15,R1              SAVE INPUT SCAN REGISTER\n         LA    R1,CONVWORK+11      INITIALIZE MARK REGISTER\n         EDMK  CONVWORK(12),WDOUBLE+2  FORMAT THE NUMERIC VALUE\n         BNM   NOMINSGN            IF RESULT NEGATIVE,\n         BCTR  R1,0                THEN ADJUST MARK REGISTER\n         MVI   0(R1),C'-'           AND MOVE MINUS SIGN IN.\nNOMINSGN DS    0H                  ANYHOW...\n         MVC   0(12,R2),0(R1)      MOVE EDITED VALUE TO OUTPUT\n         LR    R1,R15              RESTORE SCANNING REGISTER\n         LA    R14,12              SET LENGTH OF MOVED OUTPUT FOR LOOP\nFLOOP1   CLI   0(R2),C' '          SCAN FOR FIRST BLANK FOLLOWING VALUE\n         BE    WRTCOMMN\n         LA    R2,1(,R2)\n         BCT   R14,FLOOP1          LOOP FOR BLANKS UNTIL MAX LENGTH\n         B     WRTCOMMN            THEN GO FINISH\n         EJECT\nWRTERROR DS    0H\n         SPACE\n***********************************************************************\n* UNABLE TO CONSTRUCT MESSAGE SEGMENT - JUST PUT IN SPECIAL CHAR AND GO\n***********************************************************************\n         SPACE\n         MVI   0(R2),C'?'          STICK IN DUMMY CHARACTER\n         LA    R2,1(,R2)           BUMP UP OUTPUT POINTER\n         SPACE\nWRTCOMMN DS    0H\n         SPACE\n***********************************************************************\n* ALL COME TOGETHER HERE TO BUMP TO THE NEXT SEGMENT\n***********************************************************************\n         SPACE\n         CR    R2,R3               IF AT END OF OUTPUT AREA\n         BNH   WRTYETOK            THEN (OUT OF ROOM)...\n         LA    R1,WTO1002           ADDRESS OF WTO MESSAGE\n         LA    R2,1002              ABEND CODE\n         B     WRTABEND             GO BLOW UP\nWRTYETOK DS    0H                  ELSE STILL ENOUGH ROOM FOR MESSAGE\n         LA    R1,4(,R1)           BUMP PAST CONTROL FIELD\n         LR    R14,R1              SET POINTER TO START OF NEW DATA\n         B     WRTLOOP1            CONTINUE PROCESSING FIELDS\n         SPACE 2\nBADPARM  DS    0H                  INVALID S-TYPE SPECS ON INPUT\n         LA    R1,WTO1001          ADDRESS OF WTO MESSAGE\n         LA    R2,1001             ABEND CODE\n         B     WRTABEND            GO BOMB OUT\n         SPACE 2\nWRTFINIS DS    0H\n         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE,\n         BZ    WRTPRINT            THEN...\n         TM    DIALOGSW,TBCREATE    IF TABLE MUST BE CREATED\n         BZ    WRTNOCRE             THEN\n         NI    DIALOGSW,255-TBCREATE RESET SWITCH\n* ISPEXEC TBCREATE TABLE-NAME () NAME-LIST NOWRITE REPLACE\n         LA    R1,WRTTBA1          POINT TO TBCREATE PARAMETERS\n         L     R15,@ISPLINK        CALL ISPLINK TO RESET TABLE\n         BALR  R14,R15\nWRTNOCRE DS    0H\n         MVC   XLLROW,WRAREA       MOVE OUR DATA TO ISPF AREA\n*\n* THE FOLLOWING THREE INSTRUCTIONS ARE PRESENT BECAUSE ISPF FORCES\n* LEFT JUSTIFICATION FOR ALL TABLE VARIABLES.  TO DEFEAT THIS, WE\n* FORCE THE FIRST CHARACTER OF A TABLE ROW VARIABLE TO BE ALWAYS\n* NONBLANK.  THIS CAN BE DONE BY CHANGING INITIAL BLANKS TO NULLS,\n* WHICH WILL DISPLAY AS BLANKS ON THE SCREEN (AS LONG AS NO ONE\n* SUBMITS AN APAR COMPLAINING THAT ISPF DOES NOT TRANSLATE INVALID\n* CHARACTERS ON TABLE DISPLAYS).\n*\n         CLI   XLLROW,C' '         IF FIRST CHAR OF TABLE VAR IS BLANK\n         BNE   *+8                 THEN\n         MVI   XLLROW,X'00'         CHANGE IT TO A NULL CHARACTER\n* ISPEXEC TBADD TABLE-NAME\n         LA    R1,WRTADD1          POINT TO TBADD PARAMETERS\n         L     R15,@ISPLINK        CALL ISPLINK TO ADD TO TABLE\n         BALR  R14,R15\n         B     WRTRET\nWRTPRINT DS    0H                  ELSE WRITE TO SYSPRINT\n         L     R1,DCBADDR          GET PRINT DCB ADDRESS\n         PUT   (1),CCC              WRITE OUT THE RECORD\n         SPACE 2\nWRTRET   DS    0H\n         L     R13,4(,R13)         GO BACK NOW\n         LM    R14,12,12(R13)\n         L     R15,20(,R13)        PICK UP SAVED REGISTER 0 IN R15\n         B     2(,R15)             BRANCH TO RETURN ADDRESS IN CALLER\n         SPACE 4\nWRTABEND DS    0H                  CATASTROPHIC ERROR IN WRITE ROUTINE\n         SPACE\n         WTO   MF=(E,(1))          TELL THE OPERATOR\n         LR    R1,R2               GET ABEND CODE IN CORRECT REG\n         ABEND (1),DUMP            GOODBYE FOREVER\n         EJECT\n* EXECUTED INSTRUCTIONS\n         SPACE\nTRCHAR   TR    0(0,R2),CHARTBL     TRANSLATE CHAR DATA TO PRINTABLE\nWRTMVC14 MVC   0(0,R2),0(R14)      MOVE DATA TO OUTPUT\nWRTMVC15 MVC   0(0,R2),0(R15)      MOVE DATA TO OUTPUT\nWRTICM   ICM   R0,0,0(R15)         LOAD R0 WITH FULLWORD OR HALFWORD\n         SPACE\n* CONSTANTS\n         SPACE\nWRTADD1  DC    A(WRTTBADD)         PARAMETER FOR ISPLINK\nWRTADD2  DC    X'80',AL3(TABLE)    PARAMETER FOR ISPLINK\nWRTTBA1  DC    A(WRTTBC1)          PARAMETER FOR ISPLINK\nWRTTBA2  DC    A(TABLE)            PARAMETER FOR ISPLINK\nWRTTBA3  DC    A(WRTTBC3)          PARAMETER FOR ISPLINK\nWRTTBA4  DC    A(WRTTBC4)          PARAMETER FOR ISPLINK\nWRTTBA5  DC    A(WRTTBC5)          PARAMETER FOR ISPLINK\nWRTTBA6  DC    X'80',AL3(WRTTBC6)  PARAMETER FOR ISPLINK\nWRTTBADD DC    C'TBADD'            PARAMETER FOR ISPLINK\nWRTTBC1  DC    C'TBCREATE'         PARAMETER FOR ISPLINK\nWRTTBC3  DC    C'()'               PARAMETER FOR ISPLINK\nWRTTBC4  DC    C'(XLLROW)'         PARAMETER FOR ISPLINK\nWRTTBC5  DC    C'NOWRITE'          PARAMETER FOR ISPLINK\nWRTTBC6  DC    C'REPLACE'          PARAMETER FOR ISPLINK\n         SPACE\nMASKS    DS    0H                  USED IN EXECUTED ICM INSTRUCTION\n         DC    B'00000001'         ICM MASK TO LOAD DATA LENGTH 1\n         DC    B'00000011'         ICM MASK TO LOAD DATA LENGTH 2\n         DC    B'00000111'         ICM MASK TO LOAD DATA LENGTH 3\n         DC    B'00001111'         ICM MASK TO LOAD DATA LENGTH 4\n         EJECT\n         LTORG\n         EJECT\nWTO1001  WTO   MF=L,                                                   X\n               'XLL/WRITE: INVALID PARAMETERS PASSED TO SUBROUTINE'\n         SPACE\nWTO1002  WTO   MF=L,                                                   X\n               'XLL/WRITE: MESSAGE EXCEEDS MAXIMUM PERMISSIBLE LENGTH'\n         SPACE\nCHARTBL  DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'.ABCDEFGHI......'\n         DC    C'.JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         EJECT\nWRTSAVE  DS    18F                 OS SAVE AREA\nREGSAVE  DS    16F                 SA FOR CALLER'S S-CON REGS\nWDOUBLE  DS    D                   FOR CONVERSION OF NUMERIC DATA\nDCBADDR  DS    A                   ADDRESS OF DCB FOR PUTS\nCONVWORK DS    CL24                CONVERSION DATA AREA\nWRAWTO   DS    AL4                 WTO HEADER IF HAVE TO USE WTP\n         ORG   *-1                 REDEFINE AS...\nCCC      DS    C                   ASA CONTROL CHARACTER AREA\nWRAREA   DS    CL256               DATA AREA TO CONSTRUCT MESSAGE\n         SPACE\n         END\n./ ADD NAME=XLNKLST  0100-07332-07332-0900-00812-00812-00000-SEB\n         TITLE 'XLNKLST - TSO COMMAND TO ALLOCATE THE LINK LIST'\n***********************************************************************\n*                                                                     *\n* XLNKLST - TSO COMMAND TO ALLOCATE THE LINK LIST                     *\n*                                                                     *\n* SYNTAX:   XLNKLST 'FILENAME' LPA/NOLPA LINKLIST/NOLINKLIST REUSE    *\n*                                                                     *\n* PROCESSING:  SCAN THE LPA LIST AND THE LINK LIST TABLE AND          *\n*              ALLOCATE THE DATASETS THEREIN TO THE REQUESTED DDNAME. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    CVT ADDRESS\nR4       EQU   4    LPA LIST ADDRESS\nR5       EQU   5    LINK LIST TABLE ADDRESS\nR6       EQU   6    COUNT OF LIBRARIES TO ALLOCATE\nR7       EQU   7    PDL ADDRESS\nR8       EQU   8    USED TO LOOP THROUGH LIBRARY ENTRIES\nR9       EQU   9    USED TO LOOP THROUGH LIBRARY ENTRIES\nR10      EQU   10   POINTER TO DDNAMES FOR CONCATENATION\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXLNKLST  CSECT\nXLNKLST  AMODE 31\nXLNKLST  RMODE 24\n         SPACE 1\n         SAVE  (14,12),,XLNKLST_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XLNKLST,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n***********************************************************************\n* INITIALIZATION                                                      *\n***********************************************************************\n         USING CPPL,R2             ADDRESS INPUT CPPL\n         ST    R2,DFCPPLP          SAVE IT FOR DAIRFAIL\n         XC    ANSWER,ANSWER\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R14,ECB\n         ST    R14,IOPLECB\n         L     R15,=V(XFLNKPCL)\n         LA    R0,ANSWER\n         L     R1,CPPLCBUF\n         STM   R14,R1,PPLECB\n         ST    R13,PPLUWA          USER WORK AREA = \"DATD\"\n         MVC   PTLIST(PTLISTL),SPTLIST\n         LA    R14,1\n         LA    R15,OUTHDR\n         LA    R0,L'OUTLINE+4\n         SLL   R0,16\n         STM   R14,R0,OLD\n         XC    DDBUFFER,DDBUFFER\n         EJECT\n***********************************************************************\n*                                                                     *\n* PARSE THE INPUT COMMAND                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XC    ECB,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   BLOWUP\n         L     R7,ANSWER\n         USING PDL,R7\n         EJECT\n***********************************************************************\n*                                                                     *\n* SET UP POINTERS TO LPA LIST AND LINK LIST.                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R3,X'10'\n         USING CVT,R3\n         L     R2,CVTSMEXT         POINT TO CVT VIRTUAL STORAGE EXT\n         USING CVTVSTGX,R2\n         L     R4,CVTEPLPS\n         USING LPAT,R4\n         L     R5,CVTLLTA\n         USING LLT,R5\n         EJECT\n***********************************************************************\n*                                                                     *\n* FIRST, DETERMINE HOW MUCH SPACE WE NEED TO STORE DDNAMES.           *\n* THIS IS CALCULATED FROM THE NUMBER OF LIBRARIES IN THE LPA LIST     *\n* PLUS THE NUMBER OF LIBRARIES IN THE LINK LIST.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R6,R6\n         CLI   XFLPA+1,2           IF \"NOLPA\" WAS SPECIFIED\n         BE    EXLPA               THEN EXCLUDE LPA LIBRARIES\n         A     R6,LPATCNT          ELSE ADD IN # OF LPA LIBRARIES\nEXLPA    DS    0H\n         CLI   XFLNK+1,2           IF \"NOLINKLIST\" WAS SPECIFIED\n         BE    EXLINK              THEN EXCLUDE LINK LIST LIBRARIES\n         A     R6,LLTCOUNT         ELSE ADD IN # OF LNKLIST LIBRARIES\nEXLINK   DS    0H\n         LTR   R6,R6               IF LIBRARY COUNT IS ZERO,\n         BP    OKSOFAR             THEN...\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE\n         MVC   OUTLINE(L'NOLIBMSG),NOLIBMSG\n         BAL   R14,PUTLINE          PUT OUT ERROR MESSAGE AND TERMINATE\n         B     BLOWUP\nOKSOFAR  DS    0H\n         ST    R6,LIBCOUNT\n         LR    R1,R6               COPY NUMBER OF DDNAMES\n         MH    R1,=H'10'           MULTIPLY BY LENGTH OF A DDNM ENTRY\n         LA    R1,4(,R1)           ADD LENGTH FOR TEXT UNIT PREFIX\n         STH   R1,DDBUFLEN         SAVE LENGTH\n         LR    R0,R1\n         GETMAIN R,LV=(0)          GET STORAGE FOR A DDNAME BUFFER\n         ST    R1,DDBUFFER         SAVE ITS ADDRESS\n         MVC   0(2,R1),=X'0001'    SET KEY FOR CONCATENATING DDNAMES\n         STH   R6,2(,R1)           SET NUMBER OF DDNAMES\n         EJECT\n***********************************************************************\n*                                                                     *\n* NOW, ALLOCATE LIBRARIES.  THE FIRST ONE WILL BE ALLOCATED TO THE    *\n* FILE NAME SPECIFIED ON THE COMMAND, AND THE OTHERS WILL ALL GET     *\n* SYSTEM-GENERATED DDNAMES.                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R10,DDBUFFER        GET ADDRESS OF DDNAME BUFFER\n         LA    R10,4(,R10)         POINT TO FIRST DDNAME TO PUT IN\n         ST    R10,FIRSTDDN        SAVE ADDRESS OF IT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* INITIALIZE DYNAMIC ALLOCATION PARAMETER LIST                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,S99RB\n         ST    R1,S99RBPTR\n         OI    S99RBPTR,X'80'\n         XC    S99RB(S99RBEND-S99RB),S99RB\n         MVI   S99RBLN,S99RBEND-S99RB\n         EJECT\n***********************************************************************\n*                                                                     *\n* IF \"REUSE\" WAS SPECIFIED, FREE THE FILE FIRST.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   XFREUSE+1,X'01'     IF REUSE WAS SPECIFIED\n         BNE   NOUNALC             THEN\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET UP FOR UNALLOCATION                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   S99VERB,S99VRBUN    DO UNALLOCATION\n         LA    R1,TUPLUNAL         LIST OF TEXT UNIT POINTERS\n         ST    R1,S99TXTPP         SET TEXT UNITS FOR UNALLOCAT ION\n         SPACE 1\n         LA    R1,DUNDDNAM         FREE DDNAME\n         ST    R1,TUPLUNAL+X'00'\n         LA    R1,DUNUNALC         EVEN IF PERMANENTLY ALLOCATED\n         ST    R1,TUPLUNAL+X'04'\n         OI    TUPLUNAL+X'04',X'80' MARK END OF TEXT UNITS\n         SPACE 1\n         MVC   DUNUNALC(4),=X'00070000'     KEY, NUMBER\n         MVC   DUNDDNAM(4),=X'00010001'     KEY, NUMBER\n         L     R15,XFFILE+0         GET ADDRESS OF SPECIFIED DDNAME\n         LH    R1,XFFILE+4          GET LENGTH OF SPECIFIED DDNAME\n         STH   R1,DDLEN99           SET DDNAME LENGTH\n         BCTR  R1,0                 REDUCE LENGTH FOR EXECUTE\n         EX    R1,MOVEDD99          MOVE DDNAME TO TEXT UNIT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DO DYNAMIC UNALLOCATION                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST\n         DYNALLOC ,                UNALLOCATE THE FILE NAME\n         ST    R15,DRETCODE        SAVE RETURN CODE\n         LTR   R15,R15             IF RETURN CODE NONZERO,\n         BZ    NOUNALC             THEN...\n         CLC   S99ERROR(2),=X'0438' IF ERROR = DDNAME NOT FOUND\n         BE    NOUNALC              THEN STILL OK\n         BAL   R14,DYNALERR         ELSE REPORT FREE ERROR\n         B     BLOWUP               AND TERMINATE.\nNOUNALC  DS    0H                  FILE IS NOW UNALLOCATED\n         EJECT\n***********************************************************************\n*                                                                     *\n* SET UP FOR ALLOCATION                                               *\n*                                                                     *\n* NOTE: WE SPECIFY THAT AN EXISTING ALLOCATION IS NOT TO BE USED,     *\n*       EVEN IF IT IS CONVERTIBLE.  THIS PREVENTS A CURRENT           *\n*       ALLOCATION WITH THE WRONG VOLUME SERIAL FROM BEING USED.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   S99FLG11,S99ONCNV+S99NOCNV DON'T USE AN EXISTING ALLOC'N\n         SPACE 1\n         MVI   S99VERB,S99VRBAL    DO ALLOCATION\n         LA    R1,TUPLALLC         LIST OF TEXT UNIT POINTERS\n         ST    R1,S99TXTPP         SET TEXT UNITS FOR ALLOCATION\n         SPACE 1\n         LA    R1,DALDSNAM         DSNAME\n         ST    R1,TUPLALLC+X'04'\n         LA    R1,DALSTATS         DISP=(SHR,\n         ST    R1,TUPLALLC+X'08'\n         LA    R1,DALNDISP                   KEEP)\n         ST    R1,TUPLALLC+X'0C'\n         LA    R1,DALPERMA         PERMANENT ALLOCATION REQUEST ED\n         ST    R1,TUPLALLC+X'10'\n         OI    TUPLALLC+X'10',X'80' MARK END OF TEXT UNITS\n         SPACE 1\n         MVC   DALDSNAM(6),=X'00020001002C' KEY, NUMBER, LENGTH\n         MVC   DALSTATS(7),=X'00040001000108' DISP=(SHR,\n         MVC   DALNDISP(7),=X'00050001000108'           KEEP)\n         MVC   DALPERMA(4),=X'00520000'     KEY, NUMBER, LENGTH\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* UNLESS \"NOLPA\" WAS SPECIFIED,                                       *\n* GO THROUGH THE LPA TABLE AND ALLOCATE THE LIBRARIES SPECIFIED.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   XFLPA+1,2           IF \"NOLPA\" WAS SPECIFIED\n         BE    SKIPLPA             THEN SKIP LPA LIBRARIES\n         ICM   R8,15,LPATCNT       GET NUMBER OF LPA LIBRARIES\n         BZ    SKIPLPA             SKIP IF NONE\n         LA    R9,LPATNTRY         POINT TO FIRST LPA LIBRARY ENTRY\nLPALOOP  DS    0H                  LOOP FOR ALL LPA LIBRARIES...\n         BAL   R14,ALLOCDSN        ALLOCATE THE DATA SET\n         LTR   R15,R15             IF ALLOCATION FAILED,\n         BNZ   BLOWUP              THEN REPORT ERROR\n         LA    R9,45(,R9)          BUMP TO NEXT LPA LIBRARY ENTRY\n         BCT   R8,LPALOOP          CONTINUE\n         SPACE 1\nSKIPLPA  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* UNLESS \"NOLINK\" WAS SPECIFIED,                                      *\n* GO THROUGH LINK LIST TABLE AND ALLOCATE THE LIBRARIES SPECIFIED.    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   XFLNK+1,2           IF \"NOLINK\" WAS SPECIFIED\n         BE    SKIPLNK             THEN SKIP LINK LIBRARIES\n         ICM   R8,15,LLTCOUNT      GET NUMBER OF LLT LIBRARIES\n         BZ    SKIPLNK             SKIP IF NONE\n         LA    R9,LLTENTRY         POINT TO FIRST LLT LIBRARY ENTRY\nLNKLOOP  DS    0H                  LOOP FOR ALL LLT LIBRARIES...\n         BAL   R14,ALLOCDSN        ALLOCATE THE DATA SET\n         LTR   R15,R15             IF ALLOCATION FAILED,\n         BNZ   BLOWUP              THEN REPORT ERROR\n         LA    R9,45(,R9)          BUMP TO NEXT LLT LIBRARY ENTRY\n         BCT   R8,LNKLOOP          CONTINUE\n         SPACE 1\nSKIPLNK  DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n* NOW CONCATENATE THE LIBRARIES TO THE REQUESTED FILE NAME.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CH    R6,=H'1'            IF ONLY ONE LIBRARY\n         BE    CONCATOK            THEN SKIP CONCATENATION\n         SPACE 1\n         MVI   S99VERB,S99VRBCC    NOW, DO CONCATENATION\n         LA    R1,TUPLCONC         TEXT UNIT POINTERS FOR CONCATENATION\n         ST    R1,S99TXTPP         SET TEXT UNITS FOR CONCATENATION\n         L     R1,DDBUFFER         GET ADDRESS OF DDNAMES\n         ST    R1,TUPLCONC+0\n         LA    R1,DCCPERMC         SPECIFY PERMANENT CONCATENATION\n         ST    R1,TUPLCONC+4       (THE SIOT'S WILL SHOW SAME DDNAME)\n         OI    TUPLCONC+4,X'80'\n         MVC   DCCPERMC(8),=X'00040000' PERMANENTLY CONCATENATED\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DO DYNAMIC CONCATENATION                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST\n         DYNALLOC ,                CONCATENATE THE FILES\n         ST    R15,DRETCODE        SAVE RETURN CODE\n         LTR   R15,R15             IF RETURN CODE NONZERO,\n         BZ    CONCATOK            THEN...\n         BAL   R14,DYNALERR         DISPLAY ERROR MESSAGE\n         B     BLOWUP               AND QUIT\nCONCATOK DS    0H                  ELSE...\n         B     RETURN0              EVERYTHING OK\n         EJECT\nALLOCDSN DS    0H                  SUBROUTINE TO ALLOCATE LIBRARY\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SUBROUTINE TO ALLOCATE A LIBRARY                                    *\n*                                                                     *\n* THE FIRST LIBRARY FOUND IS ALLOCATED TO THE DDNAME REQUESTED ON THE *\n* COMMAND; ALL OTHERS USE SYSTEM GENERATED DDNAMES.                   *\n*                                                                     *\n* LATER THE CONCATENATE OPERATION WILL GIVE ALL OF THE LIBRARIES      *\n* THE DDNAME OF THE FIRST ONE.                                        *\n*                                                                     *\n* ON ENTRY R9 POINTS TO THE LPAT OR LLT ENTRY (YL1(LENGTH),CL44(DSN)) *\n* R10 POINTS TO THE PLACE TO PUT THE DDNAME FOR FUTURE CONCATENATION  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    R14,AD14            SAVE RETURN REGISTER\n         MVC   DSNAME99(44),1(R9)  MOVE LPATDSN TO DSNAME TEXT UNIT\n         C     R10,FIRSTDDN        IF THIS IS THE FIRST DDNAME\n         BNE   NOT1STDD            THEN...\n         MVI   DDNAME99,C' '        CLEAR TEXT UNIT DDNAME TO BLANKS\n         MVC   DDNAME99+1(7),DDNAME99\n         L     R15,XFFILE+0         GET ADDRESS OF SPECIFIED DDNAME\n         LH    R1,XFFILE+4          GET LENGTH OF SPECIFIED DDNAME\n         STH   R1,DDLEN99           SET DDNAME LENGTH\n         BCTR  R1,0                 REDUCE LENGTH FOR EXECUTE\n         EX    R1,MOVEDD99          MOVE DDNAME TO TEXT UNIT\n         MVC   0(2,R10),=X'0008'    SET DD LENGTH TO 8\n         MVC   2(8,R10),DDNAME99    MOVE DDNAME TO CONCAT AREA\n         MVC   DALDDNAM(4),=X'00010001' BUILD TEXT UNIT TO PASS DDNAME\n         LA    R1,DALDDNAM          SPECIFY DDNAME TO BE ALLOCATED\n         ST    R1,TUPLALLC+X'00'    AS A TEXT UNIT\n         B     AFT1STDD            ELSE...\nNOT1STDD DS    0H\n         MVI   DDNAME99,C' '        CLEAR TEXT UNIT DDNAME TO BLANKS\n         MVC   DDNAME99+1(7),DDNAME99\n         LA    R0,8                 SET DDNAME LENGTH FOR RETURN\n         STH   R0,DDLEN99\n         MVC   DALRTDDN(2),=X'00550001' BUILD TEXT UNIT TO RETURN DD\n         LA    R1,DALRTDDN         RETURN DDNAME\n         ST    R1,TUPLALLC+X'00'\nAFT1STDD DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DO DYNAMIC ALLOCATION                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST\n         DYNALLOC ,                ALLOCATE THE DATASET\n         ST    R15,DRETCODE        SAVE RETURN CODE\n         LTR   R15,R15             IF RETURN CODE NONZERO,\n         BZ    ALLOCOK             THEN...\n         BAL   R14,DYNALERR         DISPLAY ERROR MESSAGE\n         B     BLOWUP               AND QUIT.\nALLOCOK  DS    0H                  ELSE DATASET SUCCESSFULLY ALLOCATED\n         C     R10,FIRSTDDN        IF THIS IS NOT THE FIRST DDNAME\n         BE    NOCPYLPA            THEN\n         MVC   0(2,R10),=X'0008'    SET LENGTH OF DDNAME\n         MVC   2(8,R10),DDNAME99    MOVE RETURNED DDNAME\nNOCPYLPA DS    0H\n         LA    R10,10(,R10)        BUMP DDNAME POINTER FOR CONCATS\n         L     R15,DRETCODE        LOAD DYNALLOC RETURN CODE\n         L     R14,AD14            LOAD RETURN REGISTER\n         BR    R14                 RETURN TO CALLER\n         EJECT\nDYNALERR DS    0H                  SVC99 ERROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SUBROUTINE TO DISPLAY DYNALLOC ERROR MESSAGE USING DAIRFAIL         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    R14,DYNER14         SAVE RETURN REGISTER\n         LA    R14,S99RB           PARM 1 = SVC 99 REQUEST BLOCK\n         LA    R15,DRETCODE        PARM 2 = SVC 99 RETURN CODE\n         LA    R0,=F'0'            PARM 3 = ADDRESS OF IKJEFF02\n         LA    R1,=X'0032'         PARM 4 = USE PUTLINE FOR SVC99 ERROR\n         STM   R14,R1,DFPARMS      PARM 5 (CPPL ADDR) WAS SET IN INIT.\n         XC    DFBUFP,DFBUFP       PARM 6 = WTP BUFFER (NOT USED)\n         LA    R1,DFPARMS          POINT TO DAIRFAIL PARAMETER LIST\n         LINK  EP=IKJEFF18         CALL DAIRFAIL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    DYNALRET            IF DAIRFAIL FAILED,\n         MVI   OUTLINE,C' '        THEN...\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE\n         MVC   OUTLINE(L'DFERR),DFERR\n         BAL   R14,PUTLINE          PUT OUT ERROR MESSAGE AND TERMINATE\nDYNALRET L     R14,DYNER14         RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         EJECT\nBLOWUP   DS    0H                  A FAILURE HAS OCCURRED...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* CLEAR TYPED-AHEAD INPUT AND FLUSH THE STACK ON ERROR                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TCLEARQ INPUT             CLEAR TERMINAL INPUT\n         SPACE 1\n         STACK MF=(E,IOPL),PARM=FLUSH  FLUSH INPUT STACK (CLIST)\n         SPACE 1\n******** B     RETURN12            RETURN CODE(12)\n         EJECT\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         SPACE 1\n         LA    R2,12               SET RETURN CODE TO TWELVE\n         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE\n         SPACE 2\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         XR    R2,R2               SET RETURN CODE TO ZERO\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *\n***********************************************************************\n         SPACE 1\nRETURNP  DS    0H\n         SPACE\n         ICM   R1,15,DDBUFFER      GET ADDRESS OFF DDNAME BUFFER\n         BZ    NOFREE              IF THERE IS ONE, THEN...\n         LH    R0,DDBUFLEN          GET ITS LENGTH\n         FREEMAIN R,LV=(0),A=(1)    FREE STORAGE FOR DDNAME BUFFER\nNOFREE   DS    0H\n         L     R1,ANSWER\n         IKJRLSA (1)               RELEASE PARSE STORAGE\n         SPACE 1\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nPUTLINE  DS    0H\n         SPACE 1\n***********************************************************************\n* PUTLINE SUBROUTINE  - LINK REGISTER IS R14                          *\n* MESSAGE MUST BE MOVED TO \"OUTLINE\" BEFORE CALLING.                  *\n***********************************************************************\n         SPACE 1\n         ST    R14,PUTL14\n         TR    OUTLINE(L'OUTLINE),TRANSTBL\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15\n         BZ    PUTLOK              BRANCH TO LOW CORE IF PUTLINE FAILS\n         LA    R1,PUTLERR\n         LA    R0,L'PUTLERR\n         TPUT  (1),(0),R\nPUTLOK   L     R14,PUTL14\n         BR    R14\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\nMOVEDD99 MVC   DDNAME99(0),0(R15)  MOVE DDNAME TO TEXT UNIT\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nSPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nPTLISTL  EQU   *-SPTLIST\n         SPACE 2\nFLUSH    STACK MF=L,DELETE=ALL\n         SPACE 2\nBLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS\n         SPACE 2\nTRANSTBL DS    0C\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/........\u00a0,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    C'................'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE 1\n         DC    C'0123456789ABCDEF'\nTRTBL    EQU   *-256\n         EJECT\n***********************************************************************\n* MESSAGES                                                            *\n***********************************************************************\n         SPACE 2\nNOLIBMSG DC    C'XLNKLST: NO LIBRARIES FOUND IN REQUEST.'\nDFERR    DC    C'XLNKLST: ERROR IN DAIRFAIL ROUTINE.'\nPUTLERR  DC    C'*** XLNKLST PUTLINE FAILURE ***'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* PARSE CONTROL BLOCKS CSECT                                          *\n***********************************************************************\n         SPACE 1\nXFLNKPCL IKJPARM DSECT=PDL\n         SPACE 1\nXFFILE   IKJIDENT 'FILE NAME',                                         X\n               PROMPT='DDNAME TO BE ALLOCATED TO SYSTEM LINK LIST',    X\n               MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\n         SPACE 1\nXFLPA    IKJKEYWD\n         IKJNAME 'LPA'\n         IKJNAME 'NOLPA'\n         SPACE 1\nXFLNK    IKJKEYWD\n         IKJNAME 'LINKLIST'\n         IKJNAME 'NOLINKLIST'\n         SPACE 1\nXFREUSE  IKJKEYWD\n         IKJNAME 'REUSE'\n         SPACE 1\n         IKJENDP\n         SPACE\nXLNKLST  CSECT\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPUTL14   DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE\nAD14     DS    A                   SAVE AREA FOR ALLOCDSN SUBROUTINE\nDYNER14  DS    A                   SAVE AREA FOR DYNALERR SUBROUTINE\nLIBCOUNT DS    F                   NUMBER OF LIBRARIES TO BE ALLOCATED\nDRETCODE DS    A                   RETURN CODE FROM SVC 99\nDDBUFFER DS    A                   ADDRESS OF DD NAME BUFFER\nDDBUFLEN DS    H                   LENGTH OF DD NAME BUFFER\nFIRSTDDN DS    A                   ADDRESS OF FIRST DD NAME\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\n         SPACE 1\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 1\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE 1\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\n         SPACE 1\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE 1\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 1\nOLD      DS    0A\nOLD1     DC    F'1'\nOLD2     DC    A(OUTHDR)\nOUTHDR   DC    Y(L'OUTLINE+4,0)\nOUTLINE  DS    CL79\n         SPACE 2\n***********************************************************************\n* DYNAMIC ALLOCATION CONTROL BLOCKS                                   *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n* COPIED FROM: 'SYS1.MACLIB(IEFZB4D0)'\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                SVC 99 INPUT REQUEST BLOCK\n***********************************************************************\nS99RBP   DS     0D\nS99RBPTR DS     F                      REQUEST BLOCK POINTER\nS99RBPND EQU    X'80'                  LAST POINTER INDICATOR\nS99RB    DS     0D                     REQUEST BLOCK\n         DS     0F\nS99RBLN  DS     CL1                    LENGTH OF REQUEST BLOCK\nS99VERB  DS     CL1                    VERB CODE\nS99VRBAL EQU    X'01'                  ALLOCATION\nS99VRBUN EQU    X'02'                  UNALLOCATION\nS99VRBCC EQU    X'03'                  CONCATENATION\nS99VRBDC EQU    X'04'                  DECONCATENATION\nS99VRBRI EQU    X'05'                  REMOVE IN-USE\nS99VRBDN EQU    X'06'                  DDNAME ALLOCATION\nS99VRBIN EQU    X'07'                  INFORMATION RETRIEVAL\nS99FLAG1 DS     0CL2                   FLAGS\nS99FLG11 DS     CL1                    FIRST FLAGS BYTE\nS99ONCNV EQU    X'80'                  ALLOC FUNCTION-DO NOT USE AN\n*                                      EXISTING ALLOCATION THAT DOES\n*                                      NOT HAVE THE CONVERTIBLE\n*                                      ATTRIBUTE TO SATISFY A REQUEST\nS99NOCNV EQU    X'40'                  ALLOC FUNCTION-DO NOT USE AN\n*                                      EXISTING ALLOCATION TO SATISFY\n*                                      THE REQUEST\nS99NOMNT EQU    X'20'                  ALLOC FUNCTION-DO NOT MOUNT\n*                                      VOLUMES OR CONSIDER OFFLINE\n*                                      UNITS (THIS FLAG OVERRIDES\n*                                      S99MOUNT AND S99OFFLN BELOW)\nS99JBSYS EQU    X'10'                  ALLOC FUNC-JOB RELATED SYSOUT\nS99CNENQ EQU    X'08'                  ALL FUNCTIONS-ISSUE A   @ZA32641\n*                                      CONDITIONAL ENQ ON TIOT @ZA32641\n*                                      RESOURCE. IF NOT        @ZA32641\n*                                      AVAILABLE, RETURN AN    @ZA32641\n*                                      ERROR CODE TO USER.     @ZA32641\nS99FLG12 DS     CL1                    SECOND BYTE OF FLAGS\nS99RSC   DS     0CL4                   REASON CODE FIELDS\nS99ERROR DS     XL2                    ERROR REASON CODE\nS99INFO  DS     XL2                    INFORMATION REASON CODE\nS99TXTPP DS     F                      ADDR OF LIST OF TEXT UNIT PTRS\nS99RSV01 DS     F                      RESERVED\nS99FLAG2 DS     0CL4                   FLAGS FOR AUTHORIZED FUNCTIONS\nS99FLG21 DS     CL1                    FIRST BYTE OF FLAGS\nS99WTVOL EQU    X'80'                  ALLOC FUNCTION-WAIT FOR\n*                                      VOLUMES\nS99WTDSN EQU    X'40'                  ALLOC FUNCTION-WAIT FOR DSNAME\nS99NORES EQU    X'20'                  ALLOC FUNCTION-DO NOT DO\n*                                      DATA SET RESERVATION\nS99WTUNT EQU    X'10'                  ALLOC FUNCTION-WAIT FOR UNITS\nS99OFFLN EQU    X'08'                  ALLOC FUNCTION-CONSIDER OFFLINE\n*                                      UNITS\nS99TIONQ EQU    X'04'                  ALL FUNCTIONS-TIOT ENQ ALREADY\n*                                      DONE\nS99CATLG EQU    X'02'                  ALLOC FUNCTION-SET SPECIAL\n*                                      CATALOG DATA SET INDICATORS\nS99MOUNT EQU    X'01'                  ALLOC FUNCTION-MAY MOUNT VOLUME\nS99FLG22 DS     CL1                    SECOND BYTE OF FLAGS\nS99UDEVT EQU    X'80'                  ALLOCATION FUNCTION-UNIT NAME\n*                                      PARM IS A DEVICE TYPE\nS99PCINT EQU    X'40'                  ALLOC FUNCTION-ALLOC    @Y30QPPB\n*                                      PRIVATE CATALOG TO      @Y30QPPB\n*                                      INITIATOR               @Y30QPPB\nS99DYNDI EQU    X'20'                  ALLOC FUNCTION-NO JES3  @ZA63125\n*                                      DSN INTEGRITY PROCESS   @ZA63125\nS99FLG23 DS     CL1                    THIRD BYTE OF FLAGS\nS99FLG24 DS     CL1                    FOURTH BYTE OF FLAGS\nS99RBEND EQU    *                      END MARKER\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST FOR ALLOCATION FUNCTIONS\n***********************************************************************\nTUPLALLC DS    8F                      TEXT UNIT POINTER LIST\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST FOR UNALLOCATION FUNCTIONS\n***********************************************************************\nTUPLUNAL EQU   TUPLALLC                TEXT UNIT POINTER LIST\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST FOR CONCATENATION FUNCTIONS\n***********************************************************************\nTUPLCONC EQU   TUPLALLC                TEXT UNIT POINTER LIST\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION OF A DDNAME FOR DSNAME\n***********************************************************************\nDALDDNAM DS    0H                      TEXT UNIT\n         DC    XL2'0001'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\nDDLEN99  DC    XL2'0008'               LENGTH OF DDNAME\nDDNAME99 DC    CL8' '                  DDNAME\n***********************************************************************\n* SVC 99 TEXT UNIT FOR RETURN OF A DDNAME FOR DSNAME\n***********************************************************************\nDALRTDDN EQU   DALDDNAM                TEXT UNIT\n***********************************************************************\n* SVC 99 TEXT UNIT FOR UNALLOCATION OF A DDNAME\n***********************************************************************\nDUNDDNAM EQU   DALDDNAM                TEXT UNIT\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION BY DSNAME\n***********************************************************************\nDALDSNAM DS    0H                      TEXT UNIT\n         DC    XL2'0002'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\nDSLEN99  DC    XL2'0000'               LENGTH OF DSNAME\nDSNAME99 DC    CL44' '                 DSNAME\n***********************************************************************\n* SVC 99 TEXT UNIT FOR DATA SET STATUS\n***********************************************************************\nDALSTATS DS    0H                      TEXT UNIT\n         DC    XL2'0004'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0001'               LENGTH OF STATUS\n         DC    X'08'                   STATUS = SHR\n*              X'01'                   STATUS = OLD\n***********************************************************************\n* SVC 99 TEXT UNIT FOR NORMAL DISPOSITION\n***********************************************************************\nDALNDISP DS    0H                      TEXT UNIT\n         DC    XL2'0005'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0001'               LENGTH OF NORMAL DISPOSITION\n         DC    X'08'                   DISP = KEEP\n***********************************************************************\n* SVC 99 TEXT UNIT FOR PERMANENTLY ALLOCATED ATTRIBUTE\n***********************************************************************\nDALPERMA DS    0H                      TEXT UNIT\n         DC    XL2'0052'               KEY\n         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES\n***********************************************************************\n* SVC 99 TEXT UNIT FOR PERMANENTLY CONCATENATED ATTRIBUTE\n***********************************************************************\nDCCPERMC DS    0H                      TEXT UNIT\n         DC    XL2'0004'               KEY\n         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES\n***********************************************************************\n* SVC 99 TEXT UNIT FOR FREE EVEN IF PERMANENTLY ALLOCATED ATTRIBUTE\n***********************************************************************\nDUNUNALC DS    0H                      TEXT UNIT\n         DC    XL2'0007'               KEY\n         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES\n         EJECT\n***********************************************************************\n* DAIRFAIL (IKJEFF18) PARAMETER LIST                                  *\n***********************************************************************\n         SPACE 1\nDFPARMS  DS    0A\n         SPACE 1\nDFS99RBP DC    A(S99RB)            ADDRESS OF SVC 99 REQUEST BLOCK\nDFRCP    DC    A(DRETCODE)         ADDRESS OF SVC 99 RETURN CODE\nDFJEFF02 DS    A                   ADDRESS OF EP OF IKJEFF02 OR ZEROES\nDFIDP    DS    A                   ADDRESS OF 2-BYTE ID AREA\nDFCPPLP  DS    A                   ADDRESS OF CPPL\nDFBUFP   DS    A                   ADDRESS OF BUFFER NOT NEEDED\n         EJECT\n***********************************************************************\n* END OF DATD DSECT                                                   *\n***********************************************************************\n         SPACE 1\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* DSECT'S FOR WHICH NO MACRO WAS FOUND                                *\n***********************************************************************\n         SPACE 1\nLPAT     DSECT ,                   LPA LIST TABLE\n         SPACE 1\nLPATHDR  DS    0CL8                TABLE HEADER\nLPATID   DS    CL4'LPAT'           TABLE ID 'LPAT'\nLPATCNT  DS    F                   NUMBER OF ENTRIES IN TABLE\nLPATNTRY DS    0CL8                TABLE ENTRY\n         SPACE 1\nLPATDSLN DS    XL1                 LENGTH OF DATA SET NAME\nLPATDSN  DS    CL44                DATA SET NAME\n         SPACE 3\nLLT      DSECT ,                   LINK LIST TABLE\n         SPACE 1\nLLTHEAD  DS    0CL8                TABLE HEADER\nLLTID    DS    CL4'LLT '           TABLE ID 'LLT '\nLLTCOUNT DS    F                   NUMBER OF ENTRIES IN TABLE\nLLTENTRY DS    0CL8                ENTRIES IN TABLE\n         SPACE 1\nLLTDSLTH DS    XL1                 LENGTH OF DATASET NAME\nLLTDSN   DS    CL44                DATASET NAME\n         SPACE 2\nLLTAPFTB DSECT ,                   LNKLST APF LIBRARIES TABLE\nLLTANTRY EQU   *                   LNKLST DATA SET ENTRIES\nLLTAFLGS DS    CL1                 FLAG BYTE\nLLTAPFIN EQU   B'10000000'          LIBRARY IS IN APF TABLE\nLLTARSV1 EQU   B'01111111'          RESERVED\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJCPPL\n         SPACE 1\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XLSYMS   0100-07332-07332-0900-00211-00211-00000-SEB\n         TITLE 'XLSYMS - INSTREAM MACRO DEFINITIONS'\n         MACRO\n&LABEL   CLRLINE\n&LABEL   MVI   DATALINE,C' '\n         MVC   DATALINE+1(L'DATALINE-1),DATALINE\n         MEND\n         SPACE 5\n         MACRO\n&LABEL   TUPT  &ADDR\n&LABEL   LA    R1,&ADDR                    LOAD PARAMETER REG 1\n         LA    R0,L'&ADDR                  LOAD PARAMETER REG 0\n         SVC   93                          ISSUE TPUT SVC\n         MEND\n         TITLE 'XLSYMS - COMMAND TO DISPLAY EQUATED SYMBOLS UNDER TEST'\n***********************************************************************\n* SYNTAX: ... XLSYMS                                                  *\n*        (WHERE ... IS HELP OR SOME OTHER MEANS OF GETTING THIS TSO   *\n* COMMAND INTO THE TEST ENVIRONMENT)                                  *\n*    THERE ARE NO OPERANDS.                                           *\n* NOTE: THIS COMMAND DISPLAYS ONLY SYMBOLS DEFINED BY THE EQUATE      *\n*       SUBCOMMAND OF TEST OR THE EQUATE OPERAND OF THE GETMAIN       *\n*       SUBCOMMAND OF TEST.                                           *\n* CHANGE ACTIVITY:                                                    *\n*     11/84 - SOME TEST CONTROL BLOCKS ARE NOW ABOVE THE 16MB LINE.   *\n*             THEREFORE, THIS PROGRAM MUST RUN IN 31-BIT MODE.        *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9                   ADDRESS OF TCOMTAB\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12                  STATIC BASE REGISTER\nR13      EQU   13                  DYNAMIC BASE REGISTER\nR14      EQU   14\nR15      EQU   15\nXLSYMS   CSECT\nXLSYMS   AMODE 31\nXLSYMS   RMODE 24\n         SAVE  (14,12),,XLSYMS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XLSYMS,R12\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         L     R9,540                  TCB FOR THIS PROGRAM\nTESTLOOP CLC   21(3,R9),=X'000000'     CHECK TESTRAN FIELD IN TCB\n         BNE   TESTOK                  IF NONE, THEN\n         ICM   R9,7,133(R9)             TRY NEXT (MOTHER) TCB\n         BNZ   TESTLOOP                 UNTIL NO MORE, AT WHICH POINT\n         TUPT  NOTEST                   SAY 'TEST NOT ACTIVE'\n         LA    R15,12                   AND QUIT.\n         B     RETURN\n         SPACE 1\nTESTOK   DS    0H                      R9 POINTS TO TEST'S TCB\n         L     R9,20(,R9)              POINT R9 TO TCOMTAB (TCBTRN)\n         N     R9,=X'00FFFFFF'         CLEAR HIGH-ORDER BYTE\n         USING TCOMTAB,R9\n         SPACE 1\n         NI    FLAGS,255-HEADSW    INITIALIZE HEADING SWITCH\n         ICM   R3,15,SYMTABLE      GET ADDRESS OF ACTIVE SYMBOL ENTRIES\n         BNZ   EQSOK               IF NONE, THEN...\n         TUPT  NOEQS                SAY SO\n         B     RETURN0              AND RETURN.\nEQSOK    DS    0H                  ELSE...\n         USING SYMELEM,R3           ESTABLISH ADDRESSABILITY\n         TM    FLAGS,HEADSW        IF NO HEADING PRINTED YET\n         BO    NOHEAD              THEN\n         TUPT  HEADING              DISPLAY HEADING\n         MVI   DASHES,C'-'\n         MVC   DASHES+1(L'DASHES-1),DASHES\n         TUPT  DASHES\n         OI    FLAGS,HEADSW         AND INDICATE HEADING DISPLAYED\nNOHEAD   DS    0H\n         CLRLINE ,                 CLEAR OUTPUT LINE TO BLANKS\n         UNPK  WHERE(9),ADDRSYM(5) CONVERT SYMBOL ADDRESS\n         TR    WHERE(8),HEXTBL     TO DISPLAY\n         MVI   WHERE+8,C'.'        ADD A PERIOD\n         XR    R4,R4               CLEAR INSERT REGISTER\n         IC    R4,ATTRTYPE         GET TYPE CODE\n         SRA   R4,2                DIVIDE BY 4\n         LA    R4,TYPE(R4)         POINT TO CORRESPONDING TYPE\n         MVC   DATATYPE,0(R4)      MOVE TYPE TO OUTPUT LINE\n         LH    R4,ATTRLNTH         GET LENGTH ATTRIBUTE OF SYMBOL\n         CVD   R4,DOUBLE           CONVERT TO DISPLAY\n         MVC   DATALEN-1(4),=X'40202120'\n         ED    DATALEN-1(4),DOUBLE+6\n         ICM   R4,7,ATTRMULT       GET MULTIPLICITY ATTRIBUTE OF SYMBOL\n         CVD   R4,DOUBLE           CONVERT TO DISPLAY\n         MVC   DATAMULT-1(10),=X'40202020202020202120'\n         ED    DATAMULT-1(10),DOUBLE+3\n         LH    R15,SYMLNGTH        GET LENGTH OF SYMBOL NAME\n         BCTR  R15,0               REDUCE FOR EXECUTE\n         EX    R15,MOVENAME        MOVE SYMBOL NAME TO OUTPUT LINE\n         TR    DATALINE(L'DATALINE),TRTBL\n         TUPT  DATALINE            DISPLAY SYMBOL INFORMATION\n         ICM   R3,15,CHAIN         GET ADDRESS OF NEXT SYMBOL\n         BNZ   EQSOK               REPEAT UNTIL NO MORE SYMBOL ENTRIES\n         SPACE\nRETURN0  XR    R15,R15                 SET RETURN CODE TO ZERO\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)            STORE RETURN CODE\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n*  DATA AREAS                                                         *\n***********************************************************************\n         SPACE\n*  EXECUTED INSTRUCTIONS\n         SPACE\nMOVENAME MVC   DATASYMB(0),SYMBOL  EXECUTED: MOVE SYMBOL NAME TO OUTPUT\nHEADING  DC    C' SYMBOL   ADDRESS    TYPE   LENGTH  MULTIPLICITY'\nNOTEST   DC    C'TEST NOT ACTIVE'\nNOEQS    DC    C'NO EQUATED SYMBOLS'\nTYPE     DC    C'CXBIFHEDAYSVPZ'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256                   TABLE FOR HEX CONVERSION\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'.ABCDEFGHI......'\n         DC    C'.JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE 3\n         LTORG\n         EJECT\nDATD     DSECT ,                       REENTRANT WORK AREA\n         SPACE 1\nSAVEAREA DS    9D                      OS SAVE AREA\n         SPACE 1\nDOUBLE   DS    D                       FOR NUMERIC CONVERSIONS\nFLAGS    DS    X\nHEADSW   EQU   X'80'                   1 = HEADING DISPLAYED\n         SPACE 1\nDATABEG  DS    0C                      PLACE TO BUILD OUTPUT\nDATASYMB DS    CL8' '\n         DS    C'  '                   FILLER\nWHERE    DS    CL9' ',C' '\n         DS    C'  '                   FILLER\nDATATYPE DS    C' ',CL3' '\n         DS    C'  '                   FILLER\nDATALEN  DS    CL3' ',CL3' '\n         DS    C'  '                   FILLER\nDATAMULT DS    CL8' ',C' '\n         SPACE 1\nDATAEND  EQU   *\n         SPACE 1\nDATALINE EQU   DATABEG,DATAEND-DATABEG,C'C'\nDASHES   EQU   DATABEG,L'HEADING,C'C'\n         SPACE 1\nSIZDATD  EQU   *-DATD                  LENGTH OF WORK AREA\n         TITLE 'XLSYMS - TSO TEST CONTROL BLOCKS'\n***********************************************************************\n* THE FOLLOWING INFORMATION IS TAKEN FROM:                            *\n* OS/VS2 MVS TSO COMMAND PROCESSOR LOGIC VOLUME III: TEST             *\n* AND IS COPYRIGHT BY IBM.                                            *\n***********************************************************************\nSYMELEM  DSECT ,                   MAPPING OF SYMBOL TABLE ENTRY\n         SPACE 1\nCHAIN    DS    A                   ADDR OF NEXT SYMBOL TABLE IN STORAGE\nADDRSYM  DS    A                   POINTER TO SYMBOL LOCATION\nATTRTYPE DS    XL1                 INTERNAL CODE FOR TYPE\n*                                  00 - CHARACTER FORMAT\n*                                  04 - HEXADECIMAL FORMAT\n*                                  08 - BINARY FORMAT\n*                                  0C - INSTRUCTION FORMAT\n*                                  10 - FIXED POINT, FULLWORD FORMAT\n*                                  14 - FIXED POINT, HALFWORD FORMAT\n*                                  18 - FLOATING POINT, FULLWORD FORMAT\n*                                  1C - FLOATING POINT, DOUBLEWORD FMT\n*                                  20 - ADDRESS CONSTANT, A OR Q FMT\n*                                  24 - ADDRESS CONSTANT, Y FORMAT\n*                                  28 - ADDRESS = BASE-DISPLACEMENT FMT\n*                                  2C - EXTERNAL (V-TYPE) FORMAT (N/A)\n*                                  30 - PACKED DECIMAL FORMAT\n*                                  34 - ZONED DECIMAL FORMAT\nATTRMULT DS    XL3                 MULTIPLICITY FACTOR\nATTRLNTH DS    H                   LENGTH ATTRIBUTE\nSYMLNGTH DS    H                   SYMBOL LENGTH\nSYMBOL   DS    CL8                 SYMBOL IN EBCDIC AS ENTERED IN\n*                                  EQUATE SUBCOMMAND\n         EJECT\n         TCOMTAB\n         END\n./ ADD NAME=XPROC    0100-07332-07332-0900-02585-02585-00000-SEB\n         TITLE 'XPROC copyright notice'\n***********************************************************************\n*                                                                     *\n*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n         TITLE 'XPROC macros'\n         MACRO\n&SYM     ERROR &MSG,&FLUSH=YES\n&SYM     L     R1,=A(&MSG)         Get address of error message\n         LA    R0,L'&MSG           Get length of error message\n         BAL   R14,PUTLINE         Display error message\n         AIF   ('&FLUSH' EQ 'NO').MEND\n         B     FLUSHIT             Fail\n.MEND    MEND\n         TITLE 'XPROC - CLIST-style command line parser for REXX'\n***********************************************************************\n*                                                                     *\n* XPROC    - CLIST-style command line parser for REXX                 *\n*                                                                     *\n* Author:  S. Bacher 06/89                                            *\n*                                                                     *\n* Syntax:  XPROC {inputvar} number {positional-parameter-variables}*  *\n*                                  {keyword-and-maybe-value-specs}*   *\n*                                                                     *\n*        where: \"inputvar\" is a valid CLIST/REXX variable name        *\n*               and the part of the command that follows \"inputvar\"   *\n*               looks exactly like the syntax of the CLIST \"PROC\"     *\n*               statement.                                            *\n*                                                                     *\n* Example: /* REXX */                                                 *\n*          PARSE ARG OPERANDS                                         *\n*          \"XPROC OPERANDS 2 FILE DSN VOL() SHR COUNT(1) KEY('A B')\"  *\n*                                                                     *\n*          Note that everything, including \"inputvar\", must be quoted *\n*          under REXX to prevent substitution.                        *\n*                                                                     *\n* Function:  To parse the value of a string (accessed as \"inputvar\")  *\n*            according to the PROC-style specifications and place     *\n*            the results in REXX variables.  If \"inputvar\" is         *\n*            omitted, the argument to the REXX exec is parsed.        *\n*                                                                     *\n* Return codes:                                                       *\n*                                                                     *\n* 0 - normal operation                                                *\n* 12 - error(s) occurred, prompting not possible                      *\n*                                                                     *\n* Note:  This can be used in CLISTs as well.  One use might be to     *\n*        parse a non-command-buffer line, e.g. edit macro text.       *\n*                                                               #TSO147\n* Change activity:                                              #TSO147\n*                                                               #TSO147\n* 10/24/89 - SEB1525 - Bug fix when bigger keyword area needed. #TSO147\n* 01/30/91 - SEB1525 - Extended to permit the specification of        *\n*                      options via the syntax keyword/option.         *\n*                      First option so supported is lowercase.        *\n* 04/13/92 - SEB1525 - Bug fix when prototype has quoted data.  #TSO159\n* 12/15/92 - SEB1525 - Pass REXX env block from ECT to IRXEXCOM #TSO162\n*                      to solve problem with IPCS/ISPF          #TSO162\n* 01/14/02 - SEB1525 - Pass ECT to IKJCT441 for IPCS/ISPF.      #TSO172\n*                      Fix developed by:                        #TSO172\n*                      Steven D. McGinty                        #TSO172\n*                      <sm122284@exchange.SanDiegoCA.ncr.com>   #TSO172\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    Used by SCAN and PUTLINE; other temporary uses\nR4       EQU   4    Positional parameter info\nR5       EQU   5    Positional parameter info\nR6       EQU   6    Keyword count\nR7       EQU   7    Address of IKJPARS PDL answer area\nR8       EQU   8    Used to loop through parameters\nR9       EQU   9    Dynamic base register\nR10      EQU   10   Static base register\nR11      EQU   11   Static base register\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXPROC    CSECT\nXPROC    AMODE 31\nXPROC    RMODE ANY\n         SAVE  (14,12),,XPROC_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XPROC,R12\n         LA    R11,4095(,R12)\n         USING XPROC+4095,R11\n         LA    R10,4095(,R11)\n         USING XPROC+4095+4095,R10\n*\n* Allocate storage to hold work area plus copies of positional and\n* keyword parameters.  Since the maximum length required to hold\n* all the parameters is obviously the length of the command buffer,\n* use that as the amount to add.\n*\n         LR    R2,R1               Save input parameter address\n         LA    R4,SIZDATD            Get length of basic workarea\n         L     R3,CPPLCBUF-CPPL(,R2) Point to command buffer\n         AH    R4,0(,R3)             Add length of command buffer\n         LR    R0,R4\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R9,R13\n         USING DATD,R9\n         ST    R4,DATDLEN          Save length of getmained area\n         LA    R0,WORDCOPY         Point to variable area\n         ST    R0,WORDPTR          Save address of it\n         MVC   CPPL(16),0(R2)      Set up our copy of CPPL\n         MVC   IOPLUPT,CPPLUPT     Pointer TO UPT\n         MVC   IOPLECT,CPPLECT     Pointer TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB          Pointer to user's ECB\n         MVC   PTLIST(LENPUTL),MPTLIST Set up PUTLINE list form\n         LA    R0,1                Define 1 message segment\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           Make PUTLINE output line descriptor\n*                                  Initialize other data areas\n         STM   R11,R12,MYBASES     Base registers used in PARSE exits\n         MVI   FLAGS,X'00'         Clear flags\n         XR    R0,R0               Make a zero\n         ST    R0,APOSD\n         ST    R0,LPOSD\n         ST    R0,AKEYD\n         ST    R0,LKEYD\n         ST    R0,AKEYE\n         ST    R0,POSCOUNT\n         ST    R0,KEYCOUNT\n         ST    R0,PWADDR\n         ST    R0,PWLEN\n         ST    R0,VBUFADDR\n         ST    R0,VBUFLEN\n         ST    R0,ARGADDR\n         ST    R0,ARGLEN\n*\n         EJECT\n*\n***********************************************************************\n*\n* First, set things up so that SCAN can start scanning.  On entry to\n* the command, CPPLCBUF points to the command buffer.  Halfword 1 is\n* the length of the buffer plus 4, and halfword 2 is the offset of the\n* first operand (if any) past the command name in the buffer (set by\n* TSO's call to IKJSCAN).\n*\n***********************************************************************\n*\n         L     R2,CPPLCBUF\n         LR    R1,R2\n         AH    R1,0(,R2)\n         ST    R1,SCANEPTR         Save end of command buffer\n         LA    R1,4(,R2)\n         AH    R1,2(,R2)\n         ST    R1,SCANPTR          Initialize scan pointer\n         XR    R0,R0\n         ST    R0,PARCOUNT         Initialize parenthesis count\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for first operand - must be input variable name *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN            Return R15 -> arg\n         B     NOOPERANDS          No value\n         B     ARG1OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG1OK   DS    0H\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Validate first argument as a variable name so that it can be used   *\n* to retrieve CLIST/REXX variable value.                              *\n*                                                                     *\n* We may not really have to do that here - just verify that it's not  *\n* a positional count.  If it is a positional count, set the address   *\n* and length of the input variable to zero (extension to XPROC will   *\n* get value to parse from REXX argument string in that case).         *\n*                                                                     *\n***********************************************************************\n*\n         LR    R3,R1               Save address\n         LR    R4,R2               Save length\n         CH    R2,=H'256'          If it's too long for EX instruction\n         BH    ERROR_FIRST_ARG     then first arg is invalid\n         BCTR  R2,0                Reduce for execute\n         EX    R2,TRTPOSCT         Scan for numerics\n         BNZ   NOTPOSCOUNT         If any non-numerics, not a count\n         XR    R0,R0               Else make a zero\n         ST    R0,PVARADDR         Clear address of the variable\n         ST    R0,PVARLEN          Clear length of the variable\n         B     ISACOUNT            Process this as the pos parm count\n         SPACE 1\nNOTPOSCOUNT DS 0H                  Not a count - assume a variable name\n         LR    R14,R3              Get address of variable name\n         LA    R1,PVAR             Point to place to build var name\n         ST    R1,PVARADDR         Save address of the variable\n         ST    R4,PVARLEN          Save length of the variable\n         BCTR  R4,0                Reduce for execute\n         EX    R4,MVCWORD          Move word to PVAR\n         EX    R4,UPWORD           Translate to uppercase\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for next operand - must be count of positionals *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN\n         B     NOPOSCOUNT          No value\n         B     ARG2OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG2OK   DS    0H                  We have what should be a count...\n         LR    R3,R1               Get address of argument\n         LR    R4,R2               Get length of argument\nISACOUNT DS    0H                  Here for first non-alpha arg...\n*\n***********************************************************************\n*                                                                     *\n* Validate this argument as a number so that it can be used to count  *\n* the number of positional parameters.                                *\n*                                                                     *\n***********************************************************************\n*\n         BCTR  R4,0                Reduce for execute\n         CH    R4,=H'7'            If positional count more than 8 digs\n         BH    BADPOSCOUNT         then invalid value\n         EX    R4,TRTPOSCT         Scan for numerics\n         BNZ   BADPOSCOUNT         If any non-numerics, invalid value\n         EX    R4,PACKIT           Convert to numeric\n         CVB   R0,DOUBLE           Get binary value\n         ST    R0,POSCOUNT         Store positional parameter count\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* We are about to start collecting all parameter names, both          *\n* positional and keyword.  While we do this, we determine how much    *\n* space will be needed for IKJPARS control blocks.                    *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(min(name,234))) *\n*   For each keyword with a value:   66 + (2 * length(min(name,237))) *\n*                                       + length(name)                *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,7                Set PCL amount to initial value\n         ST    R0,PCLLEN\n         XR    R0,R0               Set quoted-value-strings length\n         ST    R0,QVALLEN\n         LA    R0,8                Set PDL initial total length\n         ST    R0,PDLLEN\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for as many positional parameters   *\n* as we have defined.                                                 *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R5,15,POSCOUNT      Get count of positional parameters\n         BZ    NOPOZZES            If zero, no positional parameters\n         MH    R5,=Y(POSDDATL)     Get total length to acquire\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15             If GETMAIN failed,\n         BNZ   BADPOSCOUNT         then positional count too big\n         ST    R1,APOSD            Save address of this area\n         ST    R5,LPOSD            Save length of this area\n         LR    R4,R1               Address first entry in area\n         USING POSDDATA,R4\n*\n***********************************************************************\n*                                                                     *\n* Loop (positional-parameter-count) times, collecting variable names. *\n*                                                                     *\n***********************************************************************\n*\n         NI    FLAGS,255-FLAGPOSD  Not currently processing anything\n         NI    FLAGS,255-FLAGKEYD\n         XR    R0,R0               Zero out error fields\n         ST    R0,LASTADDR\n         ST    R0,LASTLEN\n         ST    R0,LASTAREA\n         L     R8,POSCOUNT         Get count of positional parameters\nPPLOOP   DS    0H                  R5 contains count of parms to get\n         BAL   R14,SCAN            Get a positional parame\n         B     PPMISSING           No value\n         B     PPADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     PPLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     PPSLASH             \"/\" found\n         SPACE 1\nPPLP     DS    0H                  \"(\" found when a positional expected\n         C     R8,POSCOUNT         If no pos. parms found yet\n         BE    ERROR_NO_WANT_LP    then this is truly an error; else\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec not allowed\n         SPACE 1\nPPSLASH  DS    0H                  \"/\" found when a positional expected\n         BAL   R14,DOOPTS          Process options\n         B     PPLOOP\n         SPACE 1\nPPADD    DS    0H                  Add a positional parameter\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nCDPPLOOP DS    0H                  Loop to check for duplicates\n         CR    R2,R4               until we hit current PP slot\n         BNL   CDPPLEND\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   CDPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nCDPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         B     CDPPLOOP\nCDPPLEND DS    0H                  End loop to check for duplicates\n         LA    R2,1(,R15)          Get length\n         ST    R1,POSDADDR         Save address of this pos. parm.\n         ST    R2,POSDLEN          Save length of this pos. parm.\n         XR    R0,R0               Clear other fields\n         ST    R0,POSDPCEA\n         MVI   POSDFLGS,0\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         OI    FLAGS,FLAGPOSD      Say currently processing positional\n         NI    FLAGS,255-FLAGKEYD\n*\n* PCE length for positional param: 56 + (2 * length(min(name,234)))\n* PDE length for positional param: 8\n*\n         LR    R15,R2              Get length of positional parm name\n         CH    R15,=H'234'         If longer than 255-21\n         BNH   *+8                 then\n         LA    R15,255-21           set length to 255-21\n         ST    R15,POSDMAXL        Store this length\n         SLA   R15,1               2 * length(min(name,234))\n         LA    R15,56(,R15)        56 + (2 * length(min(name,234)))\n         ST    R15,POSDPCEL        Set length of PCE for this parameter\n         A     R15,PCLLEN          Accumulate PCL length\n         ST    R15,PCLLEN\n         LA    R1,8                Length of PDE for positional = 8\n         A     R1,PDLLEN           Accumulate PDL length\n         ST    R1,PDLLEN\n         LA    R4,POSDDATL(,R4)    Bump pointer\n         BCT   R8,PPLOOP           Loop until count exhausted\n         SPACE 1\nNOPOZZES DS    0H                  Here if no positional parameters\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for keyword and value parameters.   *\n* We don't know how much we'll need yet, so we'll get a chunk of it   *\n* and hope for the best.                                              *\n*                                                                     *\n***********************************************************************\n*\n         L     R5,KEYDINCR         Get estimated initial length\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,AKEYD            Save address of this area\n         ST    R5,LKEYD            Save length of this area\n         XR    R4,R4               Start things off\n         USING KEYDDATA,R4\n         LA    R0,0(R1,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n*\n***********************************************************************\n*                                                                     *\n* Loop collecting keywords and keyword/value pairs.                   *\n*                                                                     *\n***********************************************************************\n*\n         XR    R6,R6               Clear keyword count\nKVLOOP   DS    0H\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVEND               No more\n         B     KVADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVSLASH             \"/\" found\n         SPACE 1\nKVLP     DS    0H                  \"(\" found when a keyword expected\n         LTR   R6,R6               If we've seen keyword parms already\n         BNZ   ERROR_NO_WANT_LP    then this is truly an error\n         ICM   R0,15,POSCOUNT      Else if no positional parameters\n         BZ    ERROR_NO_WANT_LP    then this is truly an error.  Else,\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec w/p.p. not allowed\n         SPACE 1\nKVSLASH  DS    0H                  \"/\" found when a keyword expected\n         BAL   R14,DOOPTS          Process options\n         B     KVLOOP\n         SPACE 1\nKVADD    DS    0H                  Add a keyword parameter\n         OI    FLAGS,FLAGKEYD      Say we're currently processing\n         NI    FLAGS,255-FLAGPOSD  keyword/value parameters\n         LTR   R4,R4               If we haven't got any keywords yet\n         BNZ   KVNZ                then\n         L     R4,AKEYD             point to first entry in area\n         B     KVA                  and do our stuff.\nKVNZ     DS    0H                  Else...\n         LA    R4,KEYDDATL(,R4)    Bump pointer\n         C     R4,AKEYE            If this takes us past end of buffer\n         BL    KVA                 then...                      #TSO147\n         STM   R1,R2,SCANRES       Store result of scan\n         L     R5,LKEYD             get length of current area\n         A     R5,KEYDINCR          increment it\n         GETMAIN RC,LV=(R5),LOC=ANY get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         LR    R2,R1               Address of new key area\n         LR    R0,R2               Address of new key area\n         L     R14,AKEYD           Address of old key area\n         L     R1,LKEYD            Length of old key area\n         LR    R15,R1              Length of old key area\n         MVCL  R0,R14              Move old key data to new key data\n         LR    R4,R0               Point to slot in new key area\n         L     R1,AKEYD            Address of old key area\n         L     R0,LKEYD            Length of old key area\n         FREEMAIN RC,LV=(0),A=(1)  Free the old key area\n         ST    R2,AKEYD            Save address of new area\n         ST    R5,LKEYD            Save length of new area\n         LA    R0,0(R2,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n         LM    R1,R2,SCANRES       Load results of scan\nKVA      DS    0H\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    KVPPLEND            If none, don't check 'em, obviously\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nKVPPLOOP DS    0H                  Loop to check for duplicates\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   KVPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         BCT   R8,KVPPLOOP         until no more positionals\nKVPPLEND DS    0H                  End loop to check for duplicates\n*                                  Now check against keywords so far\n         LTR   R8,R6               Get count of keywords\n         BZ    KVKWLEND            If none so far, don't check 'em\n         L     R2,AKEYD            Get address of first keyword\n         LA    R0,1(,R15)          Get true length\nKVKWLOOP DS    0H                  Loop to check for duplicates\n         C     R0,KEYWORDL-KEYDDATA(,R2)\n         BNE   KVKWNEXT            If lengths don't match, continue\n         L     R14,KEYWORDA-KEYDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVKWNEXT LA    R2,KEYDDATL(,R2)    Else continue\n         BCT   R8,KVKWLOOP         until no more keywords\nKVKWLEND DS    0H                  End loop to check for duplicates\n         LA    R6,1(,R6)           Increment keyword count\n         LA    R2,1(,R15)          Get length\n         ST    R1,KEYWORDA         Save address of this pos. parm.\n         ST    R2,KEYWORDL         Save length of this pos. parm.\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         XR    R0,R0               Clear other keyword/value fields\n         ST    R0,KEYDVALA\n         ST    R0,KEYDVALL\n         ST    R0,KEYDPCEA\n         ST    R0,KEYDPCEL\n         ST    R0,KEYDMAXL\n         ST    R0,KEYSUBOF\n         MVI   KEYFLAGS,0\nKVOLOOP  DS    0H\n*\n* Now get the next thing, which might be a parenthesized default value\n* or a slashed keyword processing option\n*\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVFINEND            No more\n         B     KVFINADD            Unquoted name, it's another keyword\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVVALUE             \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVOPTION            \"/\" found\n         SPACE 1\nKVOPTION DS    0H                  We (probably) have a /option...\n         BAL   R14,DOOPTS          Process options\n         B     KVOLOOP\n         SPACE 1\nKVVALUE  DS    0H                  We (probably) have a value...\n         SPACE 1\n*\n* Scan for the value (can be any kind of string).\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVNULL              End of buffer, value is null\n         B     KVWORD              Unquoted name, it's a value\n         B     KVSTRING            Quoted string found, it's a value\n         B     KVERROR             \"(\" found, should never happen\n         B     KVNULL              \")\" found, value is null\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVWORD   DS    0H                  Unquoted word is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVSTRING DS    0H                  Quoted string is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         OI    KEYFLAGS,KEYFQUOT   Indicate it's a quoted string\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVGETRP  DS    0H                  Time to terminate the value...\n*\n* Scan for the right parenthesis that ends the value spec\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVFINEND            End of buffer\n         B     KVEXTRA             Unquoted name, shouldn't be there\n         B     KVEXTRA             Quoted string, shouldn't be there\n         B     KVERROR             \"(\" found, should never happen\n         B     KVFINLOP            \")\" found, OK, continue looping\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVEXTRA  DS    0H\n*                                  (future extension, but for now)\n         LR    R3,R1               Get address of extraneous data\n******** LR    R2,R2               Get length of extraneous data\n         LA    R1,MSG_EXTRANEOUS   Ignore extraneous info\n         LA    R0,L'MSG_EXTRANEOUS\n         BAL   R14,PUTLINE\n         B     KVGETRP             Keep looking for that right paren\n         SPACE 1\nKVNULL   DS    0H\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         LA    R14,KVLOOP          (but it's null)\n         B     KVACCUM             Accumulate length, then get next KW\n         SPACE 1\nKVFINLOP DS    0H                  End keyword(value), another follows\n         LA    R14,KVLOOP          Proceed to KVLOOP after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINADD DS    0H                  End this keyword, another follows\n         LA    R14,KVADD           Proceed to KVADD after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINEND DS    0H                  End this keyword, no more follow\n         LA    R14,KVEND           Proceed to KVEND after doing...\n******** B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVACCUM  DS    0H\n*\n*   Calculate PCE and PDE lengths for keyword parameter\n*   For each keyword with a value:\n*     66 + (2 * length(min(name,237))) + length(name)\n*   For each keyword without value:\n*     11 + length(name)\n*\n* We're going to use the same storage to build unquoted values of\n* keywords, so add that length in too.\n*\n         STM   R1,R2,SCANRES       Save results of scan\n         L     R15,KEYWORDL        Get length of keyword name\n         TM    KEYFLAGS,KEYFDVAL   If a value specified\n         BNO   PCKWNVAL            then...\n         CH    R15,=H'237'         min(name,237)\n         BNH   *+8\n         LA    R15,237\n         ST    R15,KEYDMAXL        Save this length\n         SLA   R15,1               2 * length(min(name,237))\n         LA    R15,66(,R15)        66 + (2 * length(min(name,237)))\n         A     R15,KEYWORDL        66 + ... + length(name)\n         LA    R1,8                Accumulate PDL length for subfield\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         TM    KEYFLAGS,KEYFQUOT   If value is quoted string\n         BNO   PCKWNEXT            then...\n         L     R1,KEYDVALL          accumulate value length\n         A     R1,QVALLEN\n         ST    R1,QVALLEN          (actual'll be less, but never more)\n         B     PCKWNEXT\nPCKWNVAL DS    0H                  No value specified...\n         LA    R15,11(,R15)        just 11 + length(name)\nPCKWNEXT DS    0H\n         ST    R15,KEYDPCEL        Save PCE length\n         A     R15,PCLLEN          Accumulate PCL length for keyword\n         ST    R15,PCLLEN\n         LA    R1,2                Accumulate PDL length for keyword\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         LM    R1,R2,SCANRES       Load results of scan\n         BR    R14                 Go to KVADD or KVEND or KVLOOP\n         SPACE 1\nKVEND    DS    0H                  No more parameters of any kind\n         SPACE 1\n         ST    R6,KEYCOUNT         Save number of keywords\n         SPACE 1\n         EJECT\n***********************************************************************\n*                                                                     *\n* Prepare to build control blocks for IKJPARS for the parameters,     *\n* like so:                                                            *\n*                                                                     *\n*          IKJPARM                                                    *\n*                                                                     *\n*   For each positional parameter \"pp\":                               *\n*                                                                     *\n*          IKJIDENT 'POSITIONAL PARAMETER pp',                        *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,   /* only if /QUOTABLE option is specified */  *\n*                FIRST=ANY,OTHER=ANY,                                 *\n*                PROMPT='POSITIONAL PARAMETER pp'                     *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\";               *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv',SUBFLD=kvsubfld                               *\n*                                                                     *\n*   For each keyword parameter \"kw\" without a value:                  *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv'                                               *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\", as above:     *\n*                                                                     *\n* kvsubfld IKJSUBF                                                    *\n*          IKJIDENT 'VALUE FOR KEYWORD kv',                           *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,                                                *\n*                PROMPT='VALUE FOR KEYWORD kv'                        *\n*                                                                     *\n*          IKJENDP                                                    *\n*                                                                     *\n* Note that the default value from the specifications is not part of  *\n* the IKJPARS parameters.  Rather, the absence of the keyword is      *\n* detected after the call to PARSE and, at that point, the default    *\n* value is used if the terminal user did not provide one.             *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(name))          *\n*   For each keyword with a value:   66 + (3 * length(name))          *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n* We're going to use the same storage to build unquoted values of     *\n* keywords, so add that length in too.  Also, we want to include      *\n* storage for the final call to IKJCT441 to update all parameters.    *\n* How much storage is needed to build the parameter list:  9 words    *\n* for each parameter, plus 4 extra words = 13*4.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n* Get storage for the PCL plus dequoted value strings plus IKJCT441 PL\n*\n         L     R1,PDLLEN\n         LA    R1,7(,R1)           Round PDL length\n         N     R1,=X'FFFFFFF8'      up to doubleword boundary\n         ST    R1,PDLLEN           Store length of PDL\n         LA    R1,8\n         A     R1,QVALLEN          Quoted-string-length + fudge factor\n         ST    R1,QVALLEN          Store length of quoted-value area\n         A     R1,PCLLEN           Get length of PCL plus quoted area\n         L     R0,POSCOUNT         Get count of positional parameters\n         A     R0,KEYCOUNT         Add count of positional parameters\n         MH    R0,=Y(13*4)         Compute # of plists required\n         ST    R0,VUPLEN           Store length of IKJCTT41 parm list\n         AR    R0,R1               Add to total length\n         ST    R0,PWLEN            Store length of this area\n         GETMAIN RC,LV=(0),LOC=ANY Get it\n         LTR   R15,R15             If didn't get it, error\n         BNZ   GETMAIN_FAILURE\n         ST    R1,PWADDR           Save address thereof\n         LR    R4,R1               Initialize PCL entry pointer\n         LA    R5,8                Initialize PDL offset value\n         XR    R0,R0               Clear other PCE-related junk\n         ST    R0,FIRSTKEY\n         ST    R0,SUBTOSET\n*\n* Build the IKJPARM part of the PCL.\n*\n* PCE contents:  +0 (2)  Length of entire PCL\n*                +2 (2)  Length of PDL returned by PARSE\n*                +4 (2)  Offset in PDL to first IKJKEYWD PCE\n*                        (or to end-of-field indicator, i.e.\n*                        the x'0000' in an IKJSUBF or IKJENDP)\n*\n*        ...   ..,0(,R4)           Leave this unset for now...\n         L     R0,PDLLEN\n         STH   R0,2(,R4)           IKJPARM +2 (2) Length of PDL\n*        ...   ..,4(,R4)           Leave this unset for now...\n         LA    R4,6(,R4)           Bump past this PCE\n*\n* For each positional parameter, build an IKJIDENT PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 56 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 x000' (x = 1 if CHAR, else 0)\n*                +7 (1)  X'00' (FIRST=ANY)\n*                +8 (1)  X'00' (OTHER=ANY)\n*                +9 (2)  Length of 'POSITIONAL PARAMETER pp' + 4\n*                                  (25 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*                +* (1)  Length of 'POSITIONAL PARAMETER pp' - 1\n*                                  (20 + length(name))\n*                +* (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    PBPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nPBPPLOOP DS    0H                  Loop to build PCE's\n         ST    R4,POSDPCEA-POSDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'10010100'   +0 (1) Flags\n         TM    POSDFLGS-POSDDATA(R2),POSDASIS If /ASIS option given\n         BZ    PBPPNASI                       then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PBPPAEND                       else\nPBPPNASI MVI   1(R4),B'00000000'   +1 (1) Flags\nPBPPAEND DS    0H\n         L     R14,POSDPCEL-POSDDATA(,R2) Get length of PCE\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         TM    POSDFLGS-POSDDATA(R2),POSDCHAR If /QUOTABLE option given\n         BZ    PBPPNCHA                       then\n         MVI   6(R4),B'00001000'   +6 (1) Flags\n         B     PBPPCEND                       else\nPBPPNCHA MVI   6(R4),B'00000000'   +6 (1) Flags\nPBPPCEND DS    0H\n         MVI   7(R4),X'00'         +7 (1) X'00' (FIRST=ANY)\n         MVI   8(R4),X'00'         +8 (1) X'00' (OTHER=ANY)\n         L     R15,POSDMAXL-POSDDATA(,R2) Get length of name for prompt\n         LA    R0,25(,R15)         21 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,13+21(,R4)       Point to where to move param name\n         BCTR  R15,0               Reduce length for execute\n         L     R1,POSDADDR-POSDDATA(,R2) Get address of parameter name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,21(,R15)         21 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,1+21(,R4)        Point to where to move param name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,PBPPLOOP          until no more positionals\nPBPPLEND DS    0H                  End loop\n*\n* For each keyword parameter, build an IKJKEYWD PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0100 0000' (IKJKEYWD)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 6\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*\n* If the keyword has a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0100' (IKJNAME, has subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 7 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*                +* (2)  offset (plus 1) in PCL to subfield PCE\n*\n* A subfield will be built as well.  But not now.\n*\n* If the keyword doesn't have a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0000' (IKJNAME, no subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 5 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PBKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPBKWLOOP DS    0H                  Loop to build PCE's\n*\n* Build IKJKEYWD PCE\n*\n         ICM   R0,15,FIRSTKEY      If this is first keyword\n         BNZ   *+8                 then\n         ST    R4,FIRSTKEY         set address of first keyword PCE\n         ST    R4,KEYDPCEA-KEYDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'01000000'   +0 (1) Flags (IKJKEYWD)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         LA    R0,6\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         LA    R4,6(,R4)           Bump PCE pointer\n*\n* Build IKJNAME PCE, format of which depends if with value or not.\n*\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If a value specified\n         BNO   PBKWNVAL            then...\n         MVI   0(R4),B'01100100'   +0 (1) Flags (IKJNAME, has subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,7(,R15)                7 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n         ST    R4,KEYSUBOF-KEYDDATA(,R2) Save where to set subfield off\n*        ...   ...0(,R4)           Leave subfield offset out for now\n         LA    R4,2(,R4)           Bump to end of PCE\n         B     PBKWNEXT\nPBKWNVAL DS    0H                  No value specified...\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS was specified\n         BO    ERROR_ASIS_NEEDS_VAL           then error\n         MVI   0(R4),B'01100000'   +0 (1) Flags (IKJNAME, no subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,5(,R15)                5 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n******** LA    R4,0(,R4)           Bump to end of PCE\nPBKWNEXT DS    0H\n         LA    R5,2(,R5)           Increment PDE offset\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PBKWLOOP          until no more keywords\nPBKWLEND DS    0H                  End loop\n*\n* For each keyword parameter with a value, build subfield PCE's.\n*\n* Build an IKJSUBF PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*                +1 (2)  Offset in PCL to next end-of-field indicator\n*                        (either the next IKJSUBF or the IKJENDP).\n*                        If the subfield had keywords, this would have\n*                        to point to the next IKJKEYWD PCE therein.\n*\n* Build an IKJIDENT PCE for the keyword value.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 50 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 1000' (CHAR)\n*                +7 (1)  X'01' (FIRST= is not applicable)\n*                +8 (1)  X'01' (OTHER= is not applicable)\n*                +9 (2)  Length of 'VALUE FOR KEYWORD pp' + 4\n*                                  (22 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*                +* (1)  Length of 'VALUE FOR KEYWORD pp' - 1\n*                                  (17 + length(name))\n*                +* (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PSKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPSKWLOOP DS    0H                  Loop to build subfield PCE's\n         ICM   R14,15,KEYSUBOF-KEYDDATA(R2) Get where to put sub offset\n         BZ    PSNOSUB             If none, skip\n         LA    R0,1(,R4)           Get address of PCE we're building\n         S     R0,PWADDR           Convert to offset plus 1\n         STH   R0,0(,R14)          Set keyword PCE's subfield offset\n*\n* Build IKJSUBF PCE\n*\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PSNSUBST            to set, then\n         LR    R0,R4                get address of this IKJSUBF PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPSNSUBST DS    0H\n         ST    R4,SUBTOSET         Set address of subfield to set\n         MVI   0(R4),B'00000000'   +0 (1) Flags (end-of-field indicator\n*        ...   ...,1(,R4)          +1 (1) Offset of next SUBF or ENDP\n         LA    R4,3(,R4)           Bump PCE pointer\n         MVI   0(R4),B'10010100'   +0 (1) Flags (IKJIDENT, PROMPT)\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS option given\n         BZ    PSNASIS                        then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PSNAEND                        else\nPSNASIS  MVI   1(R4),B'00000000'   +1 (1) Flags\nPSNAEND  DS    0H\n         L     R15,KEYDMAXL-KEYDDATA(,R2) Get length of name for prompt\n         LR    R14,R15\n         SLA   R14,1               2 * length(name)\n         LA    R14,50(,R14)        50 + (2 * length(name))\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         MVI   6(R4),B'00001000'   +6 (1) Flags (CHAR)\n         MVI   7(R4),X'01'         +7 (1) X'01' (FIRST=n/a)\n         MVI   8(R4),X'01'         +8 (1) X'01' (OTHER=n/a)\n         LA    R0,22(,R15)         18 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,13+18(,R4)       Point to where to move keyword name\n         BCTR  R15,0               Length minus 1 for store & execute\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,18(,R15)         18 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,1+18(,R4)        Point to where to move keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\nPSNOSUB  DS    0H\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PSKWLOOP          until no more keywords\nPSKWLEND DS    0H                  End loop\n         SPACE 1\n*\n* Build the IKJENDP part of the PCL.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*\n         MVI   0(R4),B'00000000'   +0 (1) Flags\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PENSUBST            to set, then\n         LR    R0,R4                get address of this IKJENDP PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPENSUBST DS    0H\n         ICM   R1,15,FIRSTKEY      If no keyword PCE built\n         BNZ   PEGOTKEY            then\n         ST    R4,FIRSTKEY          make this the one\nPEGOTKEY DS    0H\n         L     R15,PWADDR          Get address of start of PCE\n         L     R0,FIRSTKEY         Load offset of first key/or/etc.PCE\n         SR    R0,R15              Convert to offset\n         STH   R0,4(,R15)          Set offset in IKJPARM PCE\n         LA    R4,1(,R4)           Bump past this PCE\n         LR    R0,R4\n         S     R0,PWADDR           Convert to offset\n         ST    R0,PCLLEN           Set actual PCL length\n         L     R1,PWADDR           Get address of IKJPARM PCE\n         STH   R0,0(,R1)           IKJPARM +0 (2) Length of PCL\n         ST    R4,QOFF             Save address of where to build\n*                                   unquoted strings\n*\n* Note that unquoted strings won't be built until/unless we assign\n* default values from them after a successful parse of the arguments.\n*\n         EJECT\n*\n* Next steps:  If initial variable specified, use IKJCT441 to get its\n*              value.  Otherwise use REXX call to get at arguments.\n*              Make a command buffer out of this and call IKJPARS.\n*              If parsing successful, go thru each positional and\n*              keyword parameter, getting its value, and assign all\n*              the values using IKJCT441.\n*\n         ICM   R0,15,PVARADDR      Get address of first-arg variable\n         BZ    NOVAR               If none, try REXX arg call\n         ST    R0,CVNAMEA          Set address of variable name\n         L     R0,PVARLEN          Get length of first-arg variable\n         ST    R0,CVNAMEL          Set length of variable name\n         LA    R0,TSVERETR         Return variable value\n*                                  (create variable if doesn't exist)\n         ST    R0,CVENTRY          Set entry code\n         XR    R0,R0\n         ST    R0,CVVALUEA         Address of variable value\n         ST    R0,CVVALUEL         Length of variable value\n         ST    R0,CVTOKEN          Token\n         LA    R14,CVENTRY         Store into IKJCT441 parameter list\n         LA    R15,CVNAMEA\n         LA    R0,CVNAMEL\n         LA    R1,CVVALUEA\n         LA    R2,CVVALUEL\n         LA    R3,CVTOKEN\n         L     R4,CPPLECT          Address of passed ECT        #TSO172\n         STM   R14,R4,CVPARMS                                   #TSO172\n         OI    CVPARM7,X'80'       Set VL bit                   #TSO172\n         LA    R1,CVPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         CH    R15,=H'4'           Get return code\n         BNH   GETVAROK            If not 0 or 4, error\n         BAL   R14,ERROR_GETTING_VAR\n         B     FLUSHIT\n         SPACE 1\nNOVAR    DS    0H                  No variable, try REXX arg call\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Invoke the IRXEXCOM routine to fetch the ARG information.           *\n*                                                                     *\n* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *\n*                                                                     *\n***********************************************************************\n*\n* Build the SHVBLOCK\n*\n* To store the argument value, we try using ARGWA, a 512-byte area\n* that is already part of our workarea, to avoid unnecessary GETMAINs.\n*\n* If that doesn't turn out to be big enough, we'll have to GETMAIN,\n* but it's best to avoid that.\n*\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVPRIV     Fetch private information\n         LA    R1,L'ARGWA\n         ST    R1,SHVBUFL          Length of 'fetch' value buffer\n         LA    R1,ARGWA\n         ST    R1,SHVVALA          Address of value buffer\n         LA    R1,=C'ARG'          Name of thing to be fetched\n         ST    R1,SHVNAMA          Address of variable name\n         LA    R1,3                Length('ARG')\n         ST    R1,SHVNAML          Length of variable name\n         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1\n         XR    R15,R15             IRXEXCOM parm 2\n         LR    R0,R15              Parm 3 must be same as Parm 2\n         LA    R1,SHVBLOCK         IRXEXCOM parm 4\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\nRETRYIRX DS    0H\n*        XR    R0,R0               Don't specify an environment #TSO162\n         L     R1,CPPLECT          Get passed ECT address       #TSO162\n         L     R0,ECTENVBK-ECT(,R1) Get addr of REXX envir. blk #TSO162\n         LA    R1,IRPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTEXCO-TSVT(,R15) Get address of IRXEXCOM\n         BALR  R14,R15             Call REXX arg access routine\n         LTR   R15,R15             If rc zero\n         BZ    OKIRX               then OK\n         CH    R15,=Y(SHVTRUNC)    If value was truncated\n         BE    OOPSIRX             then need more room to hold value\n         B     ERROR_IRXEXCOM      Else error\nOOPSIRX  DS    0H                  Not enough room to hold value\n         ICM   R1,15,ARGADDR       Get address of arg buffer\n         BZ    NOARGYET            If nonzero, then...\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOARGYET DS    0H\n         LA    R0,1024             Increment arg len so far\n         A     R0,ARGLEN\n         ST    R0,ARGLEN\n         ST    R0,SHVBUFL          Reset length of fetch buffer\n         GETMAIN RC,LV=(0),LOC=ANY\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,ARGADDR\n         ST    R1,SHVVALA          Reset address of value buffer\n         B     RETRYIRX            Try again\nOKIRX    DS    0H                  Everything OK\n         MVC   CVVALUEL,SHVVALL    Set length of arg value\n         MVC   CVVALUEA,SHVVALA    Set address of arg value\n         SPACE 1\nGETVAROK DS    0H\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Build a fake command buffer containing the value of the variable,   *\n* for use by IKJPARS.  Format:                                        *\n* ___________________________________________________________________ *\n* |            |       |                                            | *\n* | valuelen+4 | zero  |  value text                                | *\n* |____________|_______|____________________________________________| *\n*                                                                     *\n***********************************************************************\n*\n         LA    R2,4                Get 4 + ...\n         A     R2,CVVALUEL             length of variable value\n         ST    R2,VBUFLEN          Save length\n         GETMAIN RC,LV=(R2),LOC=ANY Get a fake command buffer\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,VBUFADDR         Save address of fake command buffer\n         SLL   R2,16               Make buffer prefix\n         ST    R2,0(,R1)           Store into fake command buffer\n         LA    R2,4(,R1)           Address of fake command buffer text\n         L     R14,CVVALUEA        Address of variable value\n         L     R15,CVVALUEL        Length of variable value\n         LR    R3,R15              Length of fake command buffer text\n         MVCL  R2,R14              Move variable value to fake buffer\n*\n***********************************************************************\n*                                                                     *\n* Set up to call IKJPARS.                                             *\n*                                                                     *\n***********************************************************************\n*\n         XC    ANSWER,ANSWER       Clear PDL address field\n         MVC   PPLUPT,CPPLUPT      Address of UPT\n         MVC   PPLECT,CPPLECT      Address of ECT\n         LA    R14,ECB             Address of ECB\n         L     R15,PWADDR          Address of the PCL we built\n         LA    R0,ANSWER           Address of PARSE answer area\n         L     R1,VBUFADDR         Address of our fake command buffer\n         STM   R14,R1,PPLECB       Set rest of PPL\n         ST    R9,PPLUWA           User work area = \"DATD\"\n         ST    R9,PPLVEWA          (we don't use verify exit, but...)\n         SPACE 1\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   ERROR_PARSE_FAILURE\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now that PARSE has successfully gotten values for all parameters,   *\n* go through them and retrieve their values, which will be used to    *\n* set variables via IKJCT441.                                         *\n*                                                                     *\n***********************************************************************\n*\n         L     R7,ANSWER           Get address of PDL\n         L     R5,PWADDR           Get address of PCL-et-al work area\n         A     R5,PCLLEN           Bump past PCL part\n         A     R5,QVALLEN          Bump past unquoted-string part\n         LA    R5,3(,R5)           Round up to\n         N     R5,=X'FFFFFFFC'      fullword boundary\n         ST    R5,VUPADDR          Save address of this plist\n*\n* Format of each block of IKJCT441 parameter list:\n*\n*  +00 -> Entry code (TSVEUPDT)\n*  +04 -> Address of variable name\n*  +08 -> Length of variable name\n*  +0C -> Address of variable value\n*  +10 -> Length of variable value\n*  +14 -> Token (zero, not used)\n*  +18 -> ECT                                                   #TSO172\n*  +1C -> Return code from IKJCT441\n*  +20 -> Address of next block of this parameter list or X'80000000'\n*  +24 ... not part of plist, but space to hold the address of value\n*  +28 ... not part of plist, but space to hold the length of value\n*  +2C ... not part of plist, but space to hold the return code\n*  +30 ... not part of plist, but space to hold the address of link\n*\n         XR    R0,R0\n         ST    R0,CVTOKEN\n*        MVC   CVECT,=X'FFFFFFFF'                               #TSO172\n         LA    R15,TSVEUPDT        Entry code = update variable\n         ST    R15,CVENTRY         Set entry code\n         L     R4,POSCOUNT         Get # of positionals\n         A     R4,KEYCOUNT           + # of keywords\n         BZ    NOUPDATE            If no parameters, no updating.\n         L     R15,VUPADDR         Get address of the plist\nBPLOOP   DS    0H\n         LR    R5,R15              Point to this element of parm list\n         LA    R15,CVENTRY\n         ST    R15,X'00'(,R5)      Parameter 1: entry code\n*                                  Set later...\n*        ST       ,X'04'(,R5)      Parameter 2: address of var name\n*                                  Set later...\n*        ST       ,X'08'(,R5)      Parameter 3: length of var name\n         LA    R15,X'24'(,R5)      Value address slot\n         ST    R15,X'0C'(,R5)      Parameter 4: address of var value\n         LA    R15,X'28'(,R5)      Value length slot\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         LA    R15,CVTOKEN         Dummy token\n         ST    R15,X'14'(,R5)      Parameter 6: token (not used)\n*        LA    R15,CVECT           Dummy ECT                    #TSO172\n         L     R15,CPPLECT         Address of passed ECT        #TSO172\n         ST    R15,X'18'(,R5)      Parameter 7: ECT             #TSO172\n         LA    R15,X'2C'(,R5)      Return code slot\n         ST    R15,X'1C'(,R5)      Parameter 8: IKJCT441 return code\n         LA    R15,X'30'(,R5)      Link slot\n         ST    R15,X'20'(,R5)      Parameter 9: next element in list\n         LA    R15,X'34'(,R5)\n         ST    R15,X'30'(,R5)      Address of next plist block\n         OI    X'20'(R5),X'80'     Set VL bit\n         BCT   R4,BPLOOP           Continue\n         L     R0,=X'00000000'     At end,\n         ST    R0,X'30'(,R5)       clear last link pointer in list\n         L     R5,VUPADDR          Point to first plist block again\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through positional parameters, setting things up.            *\n*                                                                     *\n* Format of PDE for a positional parameter (IKJIDENT):                *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    BPPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nBPPPLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         LA    R15,POSDADDR-POSDDATA(,R2) Get address of param name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,POSDLEN-POSDDATA(,R2) Get length of param name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         L     R15,POSDPCEA-POSDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPPPPRES            then...\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPPPSET             else...\nBPPPPRES DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPPPSET  DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,BPPPLOOP          until no more positionals\nBPPPLEND DS    0H                  End loop\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through keyword parameters, setting things up.               *\n*                                                                     *\n* Format of PDE for a keyword parameter (IKJKEYWD):                   *\n*                                                                     *\n* +0 (2) Number (0 if not specified, 1 if specified)                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Format of PDE for a keyword value parameter (IKJIDENT):             *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    BPKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nBPKWLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         ST    R2,SAVER2           Save register to protect from TRT's\n         LA    R15,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,KEYWORDL-KEYDDATA(,R2) Get length of keyword name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If keyword(value),\n         BO    BPKWDVAL            then process value subfield\n*\n* Keyword without value is set to keyword name if specified, else null\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWWPRS            then...\n         XR    R15,R15              say it's set to a null value\n         ST    R15,X'24'(,R5)       set address of variable value\n         ST    R15,X'28'(,R5)       set length of variable value\n         B     BPKWNEXT            else...\nBPKWWPRS DS    0H                  (operand is present)\n         L     R14,X'04'(,R5)       get address of variable name\n         L     R15,X'08'(,R5)       get length of variable name\n         ST    R14,X'0C'(,R5)      Parameter 4: address of var value\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         B     BPKWNEXT\n         SPACE 1\nBPKWDVAL DS    0H                  Else keyword with a value specified\n*\n* Keyword with value:  If keyword is present, set from value subfield\n* (which must be present according to the PARS rules).  Otherwise,\n* set value from default from XPROC statement, unquoting if needed.\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWVPRS            then...\n         L     R14,KEYDVALA-KEYDDATA(,R2) get address of default value\n         L     R15,KEYDVALL-KEYDDATA(,R2) get length of default value\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFQUOT If value is quoted,\n         BNO   BPKWVSET            then...\n*                                   unquote it\n         LA    R1,1(,R14)          Get address of quoted string + 1\n         LR    R3,R15              Get length of quoted string\n         SH    R3,=H'2'            minus 2 to get length between quotes\n         BZ    BPKWNULL            If '', set variable to null value\n         LR    R15,R1\n         LR    R14,R1              Save address of string input\n         ST    R14,SCANPTR\n         AR    R14,R3              Save address of end of it\n         ST    R14,SCANEPTR\n         L     R14,QOFF            Get where to build unquoted string\n         LA    R0,256              Make a constant value of 256\nBPGOTQL  CR    R3,R0               If length greater than 256\n         BNH   BPGOTQX             then...\n         TRT   0(256,R15),STBLQUOT  scan for \"'\"\n         BNZ   BPGOTQT              If we found it, go. Else\n         MVC   0(256,R14),0(R15)    copy unquoted data to area\n         AR    R14,R0               Increment output pointer by 256\n         AR    R15,R0               Increment input pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    BPGOTQL              Either continue scanning\n         B     BPGOTQE              or, if length zero, finished\nBPGOTQX  DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,BPGQTRT           Scan for \"'\"\n         BNZ   BPGOTQT              If found something, go\n         B     BPGOTQE              else end of string\nBPGOTQT  DS    0H                  Reached \"'\"\n         CLI   1(R1),C''''         Another \"'\" has to follow\n         BNE   0(0)                (else abend)\n         LR    R3,R1               Get length we just scanned\n         SR    R3,R15\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGQNMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,1(R14,R3)       Bump past it and following quote\n         LA    R15,2(,R1)          Bump to location past \"''\"\n         L     R3,SCANEPTR\n         SR    R3,R15              R3 := length remaining to scan\n         BP    BPGOTQL             If something left, continue scan\nBPGOTQE  DS    0H                  End of quoted string\n         L     R3,SCANEPTR\n         SR    R3,R15              Get length remaining to move\n         BZ    BPGENMV             If zero, skip move\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGENMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,0(R14,R3)       Bump past it\n         LR    R15,R14\n         S     R15,QOFF            Get length of unquoted string\n         L     R1,QOFF             Get address of unquoted string\n         ST    R14,QOFF            Update where to build next string\n         LR    R14,R1\n         B     BPKWDSET            Set address and length of string\nBPKWVSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         B     BPKWNEXT\nBPKWVPRS DS    0H                  (operand is present)\n         L     R15,KEYSUBOF-KEYDDATA(,R2) Get where subfield offset is\n         LH    R15,0(,R15)         Get offset+1 of IKJSUBF PCE\n         LA    R15,2(,R15)         Bump to associated IKJIDENT PCE\n         A     R15,PWADDR          Convert to address of subfield\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPKWDPRS            then...\nBPKWNULL DS    0H\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPKWDSET            else...\nBPKWDPRS DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPKWDSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\nBPKWNEXT DS    0H                  Continue\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         L     R2,SAVER2           Restore register clobbered by TRT\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,BPKWLOOP          until no more positionals\nBPKWLEND DS    0H                  End loop\n*\n* Now call IKJCT441 to do all the variable updates.\n*\n         L     R1,VUPADDR          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         L     R5,VUPADDR\nRCLOOP   DS    0H\n         LA    R5,0(,R5)           Clear VL bit if any\n         LTR   R5,R5\n         BZ    RCEND\n         L     R15,X'2C'(,R5)      Get return code set by IKJCT441\n         CH    R15,=H'4'           If return code\n         BNH   RCNEXT              If not 0 or 4, error\n         BAL   R14,ERROR_PUTTING_VAR\n         OI    FLAGS,FLAGPUTE\nRCNEXT   L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         B     RCLOOP\nRCEND    DS    0H\n         TM    FLAGS,FLAGPUTE      If a variable update error,\n         BO    FLUSHIT             then flush\n         SPACE 1\nNOUPDATE DS    0H                  Here if no call to IKJCT441 needed\n         SPACE 1\n         B     RETURN0             Everything fine, return code(0)\n         EJECT\n*\nTRTPOSCT TRT   0(*-*,R3),NUMTBL    Executed: scan word for numerics\nPACKIT   PACK  DOUBLE(8),0(*-*,R3) Executed: convert word to decimal\nVERIFYP  TRT   0(*-*,R14),VERTBL   Executed: verify syntax of parameter\nMVCWORD  MVC   0(*-*,R1),0(R14)    Executed: move parameter to wordarea\nUPWORD   TR    0(*-*,R1),UPTBL     Executed: translate to uppercase\nCOMPWORD CLC   0(*-*,R1),0(R14)    Executed: compare parameters\nMVCTOPCE MVC   0(*-*,R4),0(R1)     Executed: move parameter name to PCE\nBPGQTRT  TRT   0(*-*,R15),STBLQUOT Executed: scan for \"'\" mark\nBPGQMVC  MVC   0(*-*,R14),0(R15)   Executed: copy unquoted data to area\n*\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Various error conditions.                                           *\n*                                                                     *\n***********************************************************************\n*\nERROR_GETTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,CVNAMEL          Length of variable name\n         L     R3,CVNAMEA          Address of variable name\n         ERROR MSG_GETTING_VAR,FLUSH=NO\n         B     ERROR441\n         SPACE 1\nERROR_PUTTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,X'08'(,R5)       -> Length of variable name\n         L     R2,0(,R2)           Length of variable name\n         L     R3,X'04'(,R5)       -> Address of variable name\n         L     R3,0(,R3)           Address of variable name\n         ERROR MSG_PUTTING_VAR,FLUSH=NO\n******** B     ERROR441\n         SPACE 1\nERROR441 DS    0H\n         XR    R2,R2               No additional information for...\n         XR    R3,R3\n         L     R4,RC441            Load IKJCT441 return code\n         CH    R4,=H'81'           Check IKJCT441 return code\n         BH    ERROR441_MISC       > 81\n         BE    ERROR441_RC81       = 81\n         B     *(R4)               Else branch based on return code\n         B     ERROR441_MISC       04: Variable cannot be rescanned\n*                                  (not treated as an error here)\n         B     ERROR441_RC08       08: Variable is a CLIST BIF\n         B     ERROR441_RC12       12: Variable is a CLIST label\n         B     ERROR441_RC16       16: Variable is unmodifiable\n         B     ERROR441_MISC       20: n/a\n         B     ERROR441_RC24       24: Variable is a CLIST subprocedure\n         B     ERROR441_MISC       28: n/a\n         B     ERROR441_RC32       32: GETMAIN/FREEMAIN failure\n         B     ERROR441_RC36       36: Variable length is invalid\n         B     ERROR441_RC40       40: Not in CLIST or REXX environment\n         B     ERROR441_MISC       44: invalid entry code\n         B     ERROR441_MISC       48: n/a\n         B     ERROR441_MISC       52: n/a\n         B     ERROR441_MISC       56: n/a\n         B     ERROR441_MISC       60: n/a\n         B     ERROR441_MISC       64: n/a\n         B     ERROR441_MISC       68: n/a\n         B     ERROR441_MISC       72: n/a\n         B     ERROR441_RC76       76: Variable is undefined &SYSX...\n         B     ERROR441_RC80       80: Variable name invalid for REXX\nERROR441_RC08 ERROR MSG_IKJCT441_RC08,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC12 ERROR MSG_IKJCT441_RC12,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC16 ERROR MSG_IKJCT441_RC16,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC24 ERROR MSG_IKJCT441_RC24,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC32 ERROR MSG_IKJCT441_RC32,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC36 ERROR MSG_IKJCT441_RC36,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC40 ERROR MSG_IKJCT441_RC40,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC76 ERROR MSG_IKJCT441_RC76,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC80 ERROR MSG_IKJCT441_RC80,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC81 ERROR MSG_IKJCT441_RC81,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_MISC DS 0H\n         CVD   R4,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IKJCT441_RC,FLUSH=NO\n         L     R14,E44114\n         BR    R14\n         SPACE 1\nNOOPERANDS DS  0H                  No input variable\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_OPERANDS\n         SPACE 1\nNOPOSCOUNT DS  0H                  No count of positional parameters\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_POS_COUNT\n         SPACE 1\nBADPOSCOUNT DS 0H                  Bad count of positional parameters\n         LA    R2,1(,R4)           Get length of bad data\n         ERROR MSG_BAD_POS_COUNT\n         SPACE 1\nERROR_NO_WANT_LP DS 0H             Left parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_LP\n         SPACE 1\nERROR_NO_WANT_RP DS 0H             Right parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_RP\n         SPACE 1\nERROR_NO_WANT_QS DS 0H             Quoted string found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_QS\n         SPACE 1\nERROR_NO_WANT_SL DS 0H             Slash found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_SL\n         SPACE 1\nPPMISSING DS   0H                  Positional parm not found, expected\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_TOO_FEW_PPARMS\n         SPACE 1\nERROR_PARM_TOO_LONG DS 0H\n         LA    R2,252              Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_PARM_TOO_LONG\n         SPACE 1\nERROR_PARM_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_INVALID\n         SPACE 1\nERROR_PARM_DUPLICATE DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_DUPLICATE\n         SPACE 1\nERROR_OPT_TOO_LONG DS 0H\n         LA    R2,L'OPTION         Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_OPT_TOO_LONG\n         SPACE 1\nERROR_OPT_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_INVALID\n         SPACE 1\nERROR_OPT_POS_ONLY DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_POS_ONLY\n         SPACE 1\nERROR_ASIS_NEEDS_VAL DS 0H\n         L     R3,KEYWORDA-KEYDDATA(,R2)\n         L     R2,KEYWORDL-KEYDDATA(,R2)\n         ERROR MSG_ASIS_NEEDS_VAL\n         SPACE 1\nERROR_PP_WITH_LP DS 0H             Positional parm with left paren\n         ERROR MSG_PP_WITH_LP\n         SPACE 1\nERROR_FIRST_ARG DS 0H              Bad first argument\n         LR    R2,R4               Length of offending parameter\n         ERROR MSG_VAR_TOO_LONG\n         SPACE 1\nERROR_IRXEXCOM DS 0H               IRXEXCOM failed\n         C     R15,=F'-2'          Insufficient storage?\n         BE    GETMAIN_FAILURE\n         C     R15,=F'-1'          No valid REXX environment?\n         BE    ERROR_REXX_REQUIRED\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(3),DOUBLE(8)\n         OI    DOUBLE+2,X'F0'\n         LA    R2,3                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IRXEXCOM_FAIL\n         SPACE 1\nERROR_REXX_REQUIRED DS 0H\n         XR    R2,R2\n         XR    R3,R3\n         ERROR MSG_REXX_REQUIRED\nERROR_PARSE_FAILURE DS 0H          IKJPARS failed\n         CH    R15,=H'4'\n         BE    FLUSHIT\n         CH    R15,=H'20'\n         BE    FLUSHIT\n         CH    R15,=H'32'\n         BE    FLUSHIT\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_PARSE_FAILURE\n         SPACE 1\nGETMAIN_FAILURE DS 0H              Insufficient storage\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_GETMAIN_FAIL\n         SPACE 1\nKVERROR  DS    0H                  This should never happen\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_KV_ERROR\n         SPACE 1\nFLUSHIT  DS    0H                  Return in failure\n         SPACE 1\n         TCLEARQ INPUT             Flush terminal input\n         MVC   FLUSH(LENFLUSH),MFLUSH Set up STACK list form\n         XC    ECB,ECB             Clear ECB and flush the input stack\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R15,R15             If STACK failed,\n         BZ    RETURN12            then...\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_STACK_ERROR,FLUSH=NO\nRETURN12 DS    0H\n         LA    R2,12               Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H                  Return with code 0\n         XR    R2,R2               Set return code to zero\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H                  R2 contains return code\n         SPACE 1\n         ICM   R1,15,PWADDR        If there was a parse work area\n         BZ    NOFREEPW            then free it\n         L     R0,PWLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPW DS    0H\n         SPACE 1\n         ICM   R1,15,VBUFADDR      If there was a fake command buffer\n         BZ    NOFREEVBUF          then free it\n         L     R0,VBUFLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEVBUF DS  0H\n         SPACE 1\n         ICM   R1,15,ARGADDR       If there was an arg buffer\n         BZ    NOFREEARG           then free it\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEARG DS   0H\n         SPACE 1\n         ICM   R1,15,AKEYD         If there was a keyword/value area\n         BZ    NOFREEKEYD          then free it\n         L     R0,LKEYD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEKEYD DS  0H\n         SPACE 1\n         ICM   R1,15,APOSD         If there was a pos parm area,\n         BZ    NOFREEPOSD          then free it\n         L     R0,LPOSD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPOSD DS  0H\n         SPACE 1\n         IKJRLSA ANSWER            Free IKJPARS storage if any\n         SPACE 1\n         L     R0,DATDLEN          Get length of work area\n         LR    R1,R13              Get address of work area\n         L     R13,4(,R13)         Unchain save area\n         ST    R2,16(,R13)         Store return code in save area\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* Subroutines                                                         *\n***********************************************************************\n         EJECT\nDOOPTS   DS    0H                  Process options following \"/\"\n         SPACE 1\n         ST    R14,DOOPT14         Save return address\n         TM    FLAGS,FLAGPOSD+FLAGKEYD Must be processing either a\n         BZ    ERROR_NO_WANT_SL    positional or a keyword\n*\n* Process the option following the slash.\n*\n         BAL   R14,SCAN            Scan for option name\n         B     DOOPTRET            None, skip\n         B     OPTNAME             Unquoted name, process\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nOPTNAME  DS    0H                  Option name found\n*\n* Validate option name and process it.\n*\n         CH    R2,=Y(L'OPTION)     If too long\n         BH    ERROR_OPT_TOO_LONG  then error\n         MVI   OPTION,C' '         Clear option field to blanks\n         MVC   OPTION+1(L'OPTION-1),OPTION\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         LA    R1,OPTION           Point to place to move option name\n         EX    R15,MVCWORD         Move option name to option area\n         EX    R15,UPWORD          Translate to uppercase\n*\n* Time to process the options\n*\n         TM    FLAGS,FLAGPOSD      If currently processing positional\n         BO    DOOPTP              then check positional options\n         B     DOOPTK              else check keyword options\n         SPACE 1\nDOOPTP   DS    0H\n         L     R1,LASTAREA         Point to current PP area\n******** CLC   =C'OPTIONAL ',OPTION\n******** BE    DOOPTP_OPTIONAL\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTP_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    DOOPTP_CHAR\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTP_OPTIONAL DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDOPT\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_ASIS     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_CHAR     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDCHAR\n         B     DOOPTRET\n         SPACE 1\nDOOPTK   DS    0H\n         L     R1,LASTAREA         Point to current KV area\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTK_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    ERROR_OPT_POS_ONLY\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTK_ASIS    DS 0H\n         OI    KEYFLAGS-KEYDDATA(R1),KEYFASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTRET DS    0H\n         L     R14,DOOPT14\n         BR    R14\n         EJECT\nSCAN     DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine scans the command buffer for operands.  It returns the *\n* address of the next operand in R1 and its length in R2 (when there  *\n* are no more operands, R1 and R2 are zeroed).  The operand may be a  *\n* name, a number, a parenthesis, or a quoted string. If it's a quoted *\n* string, it will be returned as is, quotes and all.                  *\n*                                                                     *\n* Return is as follows:                                               *\n*                                                                     *\n* To return address + 0  ... no value found                           *\n* To return address + 4  ... unquoted string found                    *\n* To return address + 8  ... quoted string found                      *\n* To return address + 12 ... left parenthesis found                   *\n* To return address + 16 ... right parenthesis found                  *\n*                                                                     *\n* SCANPTR -> area to scan; SCANEPTR -> end thereof                    *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,SCANPTR          Point to data to scan\n         XR    R2,R2               Clear TRT register\n         L     R3,SCANEPTR         Point to end of data to scan\n         SR    R3,R1               Get length of data to scan\n         LA    R0,256              Set up constant 256\n         LTR   R3,R3               If length is zero\n         BZ    SCANEND             then finished, return no value\nSCANLOOP DS    0H                  Do TRT for remaining length\n         CR    R3,R0               If length greater than 256\n         BNH   SCANLEFF            then...\n         TRT   0(256,R1),STBL0      scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n         AR    R1,R0                Else increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    SCANLOOP             Either continue scanning\n         B     SCANEND              or exit (no value), length now zero\nSCANLEFF DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,SCANTRT           Scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n******** B     SCANEND              If none found, exit in failure\nSCANEND  DS    0H                  Reached end of data\n         XR    R1,R1               Clear scanning registers\n         XR    R2,R2\n         BR    R14                 Return with no value\nSCANGOT1 DS    0H                  R1 -> something we found\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         B     *(R2)               R2 tells what kind it is\n         B     GOTWORD             4:  Found nonblank\n         B     GOTLP               8:  Found (\n         B     GOTRP               12: Found )\n         B     GOTSLASH            16: Found /\n         B     GOTQUOTE            20: Found '\n         SPACE 1\nGOTWORD  DS    0H                  Found a nonblank (word)\n*                                  R1 -> it, R3 = length to scan\n*\n* Scan for end-of-word\n*\n         LR    R15,R1              Save address of the word\nGOTWORDL CR    R3,R0               If length greater than 256\n         BNH   GOTWORDX            then...\n         TRT   0(256,R1),STBLWORD   scan for important characters\n         BNZ   GOTWORDT             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTWORDL             Either continue scanning\n         B     GOTWORDE             or go if length zero\nGOTWORDX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTWTRT           Scan for important characters\n         BNZ   GOTWORDT             If found something, go\n         L     R1,SCANEPTR          Else end of text = end of word\n         B     GOTWORDE\nGOTWORDT L     R3,SCANEPTR         R3 := length remaining to scan\n         SR    R3,R1               R1 -> character\n         B     *(R2)               Branch depending on R2\n         B     GOTWORDE            4:  Found whitespace, end of word\n         B     GOTWLP              8:  Found (\n         B     GOTWRP              12: Found )\n         B     GOTWS               16: Found /\n         SPACE 1\nGOTWORDE DS    0H                  Found whitespace or end of word\n         LR    R2,R1               Set length of word found\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     4(,R14)             Return to caller with unquoted word\nGOTWLP   DS    0H                  Found \"(\" in word\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         B     GOTWNEXT            Else process as constituent char\nGOTWRP   DS    0H                  Found a right parenthesis \")\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BZ    GOTWORDE            If now zero, not nested, end of word\n         B     GOTWNEXT            Else process as constituent char\nGOTWS    DS    0H                  Found a slash \"/\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWNEXT            If inside (), treat as constituent\n         B     GOTWORDE            Else treat as end of word\n         SPACE 1\nGOTWNEXT LA    R1,1(,R1)           Bump text pointer\n         BCT   R3,GOTWORDL         Decrement count, scan if nonzero\n         B     GOTWORDE            end of word\n         SPACE 1\nGOTLP    DS    0H                  Found a left parenthesis \"(\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If count was nonzero, start of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         LA    R2,1                Else set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     12(,R14)            Return single left parenthesis\n         SPACE 1\nGOTRP    DS    0H                  Found a right parenthesis \")\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    SCANRETP            If was zero, not nested, return \")\"\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BNZ   GOTWORD             If now nonzero, part of word\nSCANRETP DS    0H                  Return the parenthesis\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     16(,R14)            Return single right parenthesis\n         SPACE 1\nGOTQUOTE DS    0H                  Found a single quote \"'\"\n*                                  R1 -> it, R3 = length to scan\n         LR    R15,R1              Save address of the quoted string\n         LA    R1,1(,R1)           Bump past initial quote\n         BCT   R3,GOTQL            Decrement length to scan\n         B     ERRQUOTE            If nothing left, error\nGOTQL    CR    R3,R0               If length greater than 256\n         BNH   GOTQX               then...\n         TRT   0(256,R1),STBLQUOT   scan for \"'\"\n         BNZ   GOTQT                If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTQL                Either continue scanning\n         B     ERRQUOTE             or, if length zero, error\nGOTQX    DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTQTRT           Scan for \"'\"\n         BNZ   GOTQT                If found something, go\n         B     ERRQUOTE             Else error\nGOTQT    DS    0H                  Reached \"'\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         BNP   GOTQE               If zero, it's the ending quote\n         CLI   1(R1),C''''         If not \"''\"\n         BNE   GOTQE               then it's the ending quote\n         LA    R1,2(,R1)           Else bump past \"''\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    GOTQL               If something left, continue scan\n         B     ERRQUOTE            Else error\nGOTQE    DS    0H                  End of quoted string\n         LA    R1,1(,R1)           Bump past final quote mark\n         LR    R2,R1               Set length of string including \"'\"s\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     8(,R14)             Return quoted string to caller\n         SPACE 1\nGOTSLASH DS    0H                  Found a slash \"/\"\n*                                  R1 -> it, R3 = length to scan\n         CH    R3,=H'2'            If not enough room for \"/*\"\n         BL    GOTSL               then treat as real slash\n         CLI   1(R1),C'*'          If not \"/*\"\n         BNE   GOTSL               then treat as real slash\n         LA    R1,2(,R1)           Else start of comment: bump text ptr\n         SH    R3,=H'2'            Decrement length to scan\n         BNP   SCANEND             If nothing left, end of text\nGOTCOMML CR    R3,R0               If length greater than 256\n         BNH   GOTCOMMX            then...\n         TRT   0(256,R1),STBLCOMM   scan for \"*\"\n         BNZ   GOTCOMME             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTCOMML             Either continue scanning\n         B     SCANEND              or, if length zero, end of text\nGOTCOMMX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTCTRT           Scan for \"*\"\n         BNZ   GOTCOMME             If found something, go\n         B     SCANEND              Else end of text\nGOTCOMME DS    0H                   Reached an \"*\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         CH    R3,=H'2'            If not enough room for \"*/\"\n         BL    GOTCOMMC            then continue scanning for it\n         CLI   1(R1),C'/'          If not \"*/\"\n         BNE   GOTCOMMC            then continue scanning for it\n         LA    R1,2(,R1)           Else bump past \"*/\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    SCANLOOP            If something left, continue scan\n         B     SCANEND             Else end of text\nGOTCOMMC DS    0H                  \"*\" but no \"/\"\n         LA    R1,1(,R1)           Bump past \"*\"\n         BCT   R3,GOTCOMML         Decrement length, continue if nzero\n         B     SCANEND             Else end of text\nGOTSL    DS    0H                  Found a slash \"/\" without a \"*\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If inside (), treat as constituent\nRETSLASH DS    0H                  Else treat as single slash \"/\"\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     20(,R14)            Return single slash\n         SPACE 1\nERRQUOTE DS    0H                  Mismatched quotes\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_QUOTE_ERROR\n         SPACE 1\nSCANTRT  TRT   0(*-*,R1),STBL0      (Executed instruction)\nGOTWTRT  TRT   0(*-*,R1),STBLWORD   (Executed instruction)\nGOTCTRT  TRT   0(*-*,R1),STBLCOMM   (Executed instruction)\nGOTQTRT  TRT   0(*-*,R1),STBLQUOT   (Executed instruction)\n         SPACE 1\nSTBL0    DC    256YL1(4)           Table to scan for good stuff\n         ORG   STBL0+C' '          Blank\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C','          Comma\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+X'05'         Tab\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C'('          Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBL0+C')'          Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBL0+C'/'          Slash\n         DC    YL1(16)             might be part of /*\n         ORG   STBL0+C''''         Quote\n         DC    YL1(20)             is special\n         ORG   ,\n         SPACE 1\nSTBLWORD DC    256YL1(0)           Table to scan for end of word\n         ORG   STBLWORD+C' '       Blank\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C','       Comma\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+X'05'      Tab\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C'('       Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBLWORD+C')'       Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBLWORD+C'/'       Slash\n         DC    YL1(16)             might be part of /*\n         ORG   ,\n         SPACE 1\nSTBLCOMM DC    256YL1(0)           Table to scan for \"*/\"\n         ORG   STBLCOMM+C'*'\n         DC    1YL1(1)\n         ORG   ,\n         SPACE 1\nSTBLQUOT DC    256YL1(0)           Table to scan for \"'\"\n         ORG   STBLQUOT+C''''\n         DC    1YL1(1)\n         ORG   ,\nVERTBL   DC    256YL1(1)           Table to verify parameter syntax\n         ORG   VERTBL+C'_'         Underscore is valid (?)\n         DC    YL1(0)               valid?\n         ORG   VERTBL+C'@'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'#'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'$'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'a'         Lower case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'j'\n         DC    9YL1(0)\n         ORG   VERTBL+C's'\n         DC    8YL1(0)\n         ORG   VERTBL+C'A'         Upper case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'J'\n         DC    9YL1(0)\n         ORG   VERTBL+C'S'\n         DC    8YL1(0)\n         ORG   VERTBL+C'0'         Numerics are valid (except 1st pos)\n         DC    10YL1(0)\n         ORG   ,\nUPTBL    DC    256YL1(*-UPTBL)     Table to translate to uppercase\n         ORG   UPTBL+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         EJECT\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the TSO user using the TSO        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* R3 points to additional data to be displayed, and R2 is its length. *\n* If R1 is zero, the message has already been built in the workarea   *\n* MSGWA.  The message is assumed to begin with a message ID unless    *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTL14          Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVCPUT          Else move message to work area\n         LTR   R2,R2               If additional data,\n         BZ    PUTIT               then\n         LA    R1,MSGWA+1(R15)      Point to end of message\n         CH    R2,=H'256'           (Use max length of 256)\n         BNH   *+8\n         LA    R2,256\n         BCTR  R2,0                 Reduce data length for execute\n         EX    R2,MVCPUT2           Move additional data to work area\n         LA    R15,1(R15,R2)        Add length of data to msg length\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\nPUTLINE_RETRY DS 0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         MVC   MSGWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X\n               ,MSG_PUTLINE_FAILURE2\n         TPUT  MSGWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTL14          Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTLINE_RETRY\n*\nMVCPUT   MVC   MSGWA(*-*),0(R1)    Executed\nMVCPUT2  MVC   0(*-*,R1),0(R3)     Executed\n         EJECT\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n*\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\nMSG_NO_OPERANDS    DC C'XPROC001 No operands specified.'\nMSG_REXX_REQUIRED  DC C'XPROC002 Not in REXX: input variable required.'\nMSG_NO_POS_COUNT   DC C'XPROC003 Missing positional parameter count.'\nMSG_BAD_POS_COUNT  DC C'XPROC004 Invalid positional parameter count: '\nMSG_QUOTE_ERROR    DC C'XPROC005 Missing end quote.'\nMSG_NO_WANT_LP     DC C'XPROC006 \"(\" found where not expected.'\nMSG_NO_WANT_RP     DC C'XPROC007 \")\" found where not expected.'\nMSG_NO_WANT_QS     DC C'XPROC008 Quoted string in invalid position.'\nMSG_TOO_FEW_PPARMS DC C'XPROC009 Fewer positional parms than expected.'\nMSG_PP_WITH_LP     DC C'XPROC010 Value not allowed on positional: '\nMSG_PARM_TOO_LONG  DC C'XPROC011 Parameter name too long (> 255): '\nMSG_PARM_INVALID   DC C'XPROC012 Invalid syntax in parameter name: '\nMSG_PARM_DUPLICATE DC C'XPROC013 Duplicate parameter name: '\nMSG_EXTRANEOUS     DC C'XPROC014 Extraneous data ignored in value: '\nMSG_VAR_TOO_LONG   DC C'XPROC015 Variable name too long (> 256): '\nMSG_GETTING_VAR    DC C'XPROC016 Error accessing value of variable: '\nMSG_PUTTING_VAR    DC C'XPROC017 Error storing value of variable: '\nMSG_IKJCT441_RC    DC C'XPROC018 IKJCT441 return code is: '\nMSG_PARSE_FAILURE  DC C'XPROC019 PARSE service routine failure, code: '\nMSG_GETMAIN_FAIL   DC C'XPROC020 Not enough main storage to execute.'\nMSG_IRXEXCOM_FAIL  DC C'XPROC021 IRXEXCOM failure, error code: '\nMSG_STACK_ERROR    DC C'XPROC022 STACK service routine failure, code: '\nMSG_NO_WANT_SL     DC C'XPROC023 \"/\" found where not expected.'\nMSG_OPT_TOO_LONG   DC C'XPROC024 Option name too long: '\nMSG_OPT_INVALID    DC C'XPROC025 Invalid option name: '\nMSG_ASIS_NEEDS_VAL DC C'XPROC026 ASIS invalid with valueless keyword: '\nMSG_OPT_POS_ONLY   DC C'XPROC027 Option valid only for positional: '\n*\nMSG_KV_ERROR       DC C'XPROC999 Internal error in keyword value scan.'\n*\nMSG_PUTLINE_FAILURE1 DC C'*** XPROC: PUTLINE error code '\nMSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'\n*\nISMSG    DC    C'*** XPROC ignoring slash after this parameter: ' dummy\n         SPACE 1\n         EJECT\n***********************************************************************\n* Constants                                                           *\n***********************************************************************\n         SPACE 1\nKEYDINCR DC    A(100*KEYDDATL)     Initial & increment key area length\n         SPACE 1\nNUMTBL   DC    256YL1(1)           Table to validate numerics\n         ORG   NUMTBL+C'0'\n         DC    10YL1(0)\n         ORG   ,\n         EJECT\nMSG_IKJCT441_RC08 DC C'XPROC508 Variable is a CLIST built-in function.'\nMSG_IKJCT441_RC12 DC C'XPROC512 Variable is a CLIST label.'\nMSG_IKJCT441_RC16 DC C'XPROC516 CLIST variable cannot be updated.'\nMSG_IKJCT441_RC24 DC C'XPROC524 Variable is a CLIST subprocedure.'\nMSG_IKJCT441_RC32 DC C'XPROC532 GETMAIN or FREEMAIN storage failure.'\nMSG_IKJCT441_RC36 DC C'XPROC536 Variable name or value too long.'\nMSG_IKJCT441_RC40 DC C'XPROC540 No valid CLIST or REXX environment.'\nMSG_IKJCT441_RC76 DC C'XPROC576 Undefined &&SYSX CLIST variable.'\nMSG_IKJCT441_RC80 DC C'XPROC580 Variable name invalid for REXX.'\nMSG_IKJCT441_RC81 DC C'XPROC581 Internal REXX routine failure.'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F                 OS save area\nSAVE2    DS    18F                 Save area for PARSE exit routines\nDOUBLE   DS    D                   Conversion work area\nDATDLEN  DS    F                   Length of this work area\nPUTL14   DS    F                   Return register save\nE44114   DS    F                   Return register save\nDOOPT14  DS    F                   Return register save\nSAVER2   DS    A                   Save for TRT register\nMYBASES  DS    2A                  Base regs for IKJPARS exit routines\nSCANRES  DS    2A                  Used to save output from SCAN\nWORDPTR  DS    A                   Address of next slot for word copy\nPWADDR   DS    A                   Address of IKJPARS PCL area\nPWLEN    DS    F                   Length of IKJPARS PCL area\nPCLLEN   DS    F                   Actual length of the IKJPARS PCL\nQOFF     DS    A                   Address of quoted-value-string area\nQVALLEN  DS    F                   Length of quoted-value-string area\nVUPADDR  DS    F                   Address of IKJCT441 update parm list\nVUPLEN   DS    F                   Length of IKJCT441 update parm list\nPDLLEN   DS    F                   Length of the IKJPARS PDL\nVBUFADDR DS    A                   Address of fake command buffer\nVBUFLEN  DS    A                   Length of fake command buffer\nARGADDR  DS    A                   Address of ARG buffer\nARGLEN   DS    F                   Length of ARG buffer\nSCANPTR  DS    A                   Scanning pointer\nSCANEPTR DS    A                   Scanning end pointer\nPARCOUNT DS    F                   Parenthesis count\nPVARADDR DS    A                   Address of input variable name\nPVARLEN  DS    F                   Length of input variable name\nPOSCOUNT DS    F                   Positional parameter count\nKEYCOUNT DS    F                   Keyword count\nLASTAREA DS    A                   Address of last pos or key area\nLASTADDR DS    A                   Address of last processed thing\nLASTLEN  DS    F                   Length of last processed thing\nAPOSD    DS    A                   Address of positional parm area\nLPOSD    DS    A                   Length of positional parm area\nAKEYD    DS    A                   Address of keyword/value area\nLKEYD    DS    A                   Length of keyword/value area\nAKEYE    DS    A                   Address of end of keyword/value area\nFIRSTKEY DS    A                   Address of first IKJKEYWD PCE\nSUBTOSET DS    A                   Address of previous IKJSUBF PCE\nFLAGS    DS    X                   Flags\nFLAGPUTE EQU   B'10000000'         1 = error putting variable values\nFLAGPOSD EQU   B'01000000'         1 = currently processing positionals\nFLAGKEYD EQU   B'00100000'         1 = currently processing keywords\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nECB      DS    F                   ECB for TSO routines\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL512               PUTLINE message work area\nARGWA    DS    CL512               ARG message work area\n*\nFLUSH    STACK MF=L,DELETE=ALL\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nCPPL     DS    0A\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n*\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n*\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\nPPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS\n*\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE 1\nCVPARMS  DS    0F                  Variable access facility parm list\nCVPARM1  DS    A                   Parameter 1: entry code\nCVPARM2  DS    A                   Parameter 2: address of var name\nCVPARM3  DS    A                   Parameter 3: length of var name\nCVPARM4  DS    A                   Parameter 4: address of var value\nCVPARM5  DS    A                   Parameter 5: length of var value\nCVPARM6  DS    A                   Parameter 6: token (not used)\nCVPARM7  DS    A                   Parameter 7: ECT             #TSO172\n*\nCVENTRY  DS    A                   Entry code\nCVNAMEA  DS    A                   Address of variable name\nCVNAMEL  DS    A                   Length of variable name\nCVVALUEA DS    A                   Address of variable value\nCVVALUEL DS    A                   Length of variable value\nCVTOKEN  DS    A                   Token (not used)\n* CVECT  DS    A                   ECT (not used)               #TSO172\n*\nRC441    DS    F                   Return code from IKJCT441\n         SPACE 1\n         SPACE 1\nIRPARMS  DS    0F                  IRXEXCOM parameter list\nIRPARM1  DS    A                   Parameter 1: CL8'IRXEXCOM'\nIRPARM2  DS    A                   Parameter 2: same as parameter 3\nIRPARM3  DS    A                   Parameter 3: same as parameter 2\nIRPARM4  DS    A                   Parameter 4: SHVBLOCK\n*\n***********************************************************************\n*                                                                     *\n* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *\n*                                                                     *\n***********************************************************************\n*\nSHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK\nSHVNEXT  DS  A                        Chain pointer to next SHVBLOCK\nSHVUSER  DS  F                        Used during \"FETCH NEXT\"\n*                                      Contains length of buffer\n*                                      pointed to by SHVNAMA\nSHVCODES DS  0F\nSHVCODE  DS  CL1                      Function code - indicates type\n*                                      of variable access request\nSHVRET   DS  XL1                      Return codes\n         DS  H'0'                     Reserved (should be 0)\nSHVBUFL  DS  F                        Length of fetch value buffer\nSHVNAMA  DS  A                        Address of variable name\nSHVNAML  DS  F                        Length of variable name\nSHVVALA  DS  A                        Address of value buffer\nSHVVALL  DS  F                        Length of value buffer\n*                                      (Set on fetch)\nSHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK\n         SPACE 1\n**********************************************************************/\n*   SHARED VARIABLE REQUEST BLOCK - function codes                   */\n**********************************************************************/\n         SPACE 1\nSHVFETCH EQU   C'F'            Copy value of shared variable\nSHVSTORE EQU   C'S'            Set variable from given value\nSHVDROPV EQU   C'D'            Drop variable\nSHVSYFET EQU   C'f'            Symbolic name retrieve\nSHVSYSET EQU   C's'            Symbolic name set\nSHVSYDRO EQU   C'd'            Symbolic name drop\nSHVNEXTV EQU   C'N'            Fetch \"next\" variable\nSHVPRIV  EQU   C'P'            Fetch private information\n         SPACE 1\n**********************************************************************/\n*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */\n**********************************************************************/\n        SPACE 1\nSHVCLEAN EQU   X'00'           Execution was OK\nSHVNEWV  EQU   X'01'           Variable did not exist\nSHVLVAR  EQU   X'02'           Last variable transferred (\"N\")\nSHVTRUNC EQU   X'04'           Truncation occurred for \"Fetch\"\nSHVBADN  EQU   X'08'           Invalid variable name\nSHVBADV  EQU   X'10'           Invalid value specified\nSHVBADF  EQU   X'80'           Invalid function code (SHVCODE)\n         SPACE 1\n**********************************************************************/\n*        R15 return codes                                            */\n**********************************************************************/\n         SPACE 1\nSHVRCOK  EQU    0              Entire Plist chain processed\nSHVRCINV EQU   -1              Invalid entry conditions\nSHVRCIST EQU   -2              Insufficient storage available\n         SPACE\n*\nPVAR     DS    CL256               Area to build input variable name\nOPTION   DS    CL16                Area to build option name\n         SPACE 1\nSIZDATD  EQU   *-DATD              Length of fixed part of work area\n         SPACE 1\nWORDCOPY EQU   *                   Area to put copies of keyword names\n         EJECT\nPOSDDATA DSECT ,                   Info on positional parameter specs\n         SPACE 1\n*                                  (POSCOUNT) occurrences of...\n*\nPOSDADDR DS    A                   Address of positional parameter name\nPOSDLEN  DS    A                   Length of positional parameter name\nPOSDPCEA DS    A                   Address of PCE for this parameter\nPOSDPCEL DS    A                   Length of PCE for this parameter\nPOSDMAXL DS    A                   Maximum length for prompting message\nPOSDFLGS DS    X                   Flags\nPOSDOPT  EQU   B'10000000'          1 = parameter is optional\nPOSDCHAR EQU   B'01000000'          1 = value is possibly-quoted string\nPOSDASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nPOSDDATL EQU   *-POSDDATA          Length of an occurrence\n         EJECT\nKEYDDATA DSECT ,                   Info on keyword/value specs\n         SPACE 1\n*                                  some # of occurrences of...\n*\nKEYWORDA DS    A                   Address of keyword\nKEYWORDL DS    A                   Length of keyword\nKEYDVALA DS    A                   Address of keyword's default value\nKEYDVALL DS    A                   Length of keyword's default value\nKEYDPCEA DS    A                   Address of PCE for this parameter\nKEYDPCEL DS    A                   Length of PCE for this parameter\nKEYDMAXL DS    A                   Maximum length for prompting message\nKEYSUBOF DS    A                   Where to store subfield offset\nKEYFLAGS DS    X                   Flags\nKEYFDVAL EQU   B'10000000'          1 = a default value was specified\nKEYFQUOT EQU   B'01000000'          1 = default value is quoted string\nKEYFASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nKEYDDATL EQU   *-KEYDDATA          Length of an occurrence\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n         SPACE 1\n         IKJTSVT\n         SPACE 1                                                #TSO162\n         IKJECT ,                                               #TSO162\n         SPACE 1\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XPUT     0100-07332-07332-0900-00052-00052-00000-SEB\nXPUT     CSECT\n*\n* DCL XPUT EXTERNAL ENTRY(CHAR(*) VAR) OPTIONS(ASM INTER);\n*\n         SAVE  (14,12),,XPUT_&SYSDATE._&SYSTIME\n         LR    12,15\n         USING XPUT,12\n         L     1,0(,1)             POINT TO PARM STRING\n         LH    0,0(,1)             GET LENGTH OF STRING\n         LA    1,2(,1)             GET ADDRESS OF STRING\n         LTR   0,0                 IF LENGTH IS ZERO\n         BZ    AFTTPUT             THEN DO NOTHING\n         CLI   0(1),X'27'          IF FIRST CHAR IS ESCAPE CHARACTER\n         BNE   TPUTEDIT            THEN\n         TPUT  (1),(0),FULLSCR      DO TPUT FULLSCR WITHOUT TRANSLATING\n         B     AFTTPUT             ELSE\nTPUTEDIT LR    15,0                GET LENGTH OF PARM STRING\n         LR    4,1                 POINT TO STRING\n         LA    3,256\nCHECKTR  LTR   15,15               IF LENGTH ZERO\n         BZ    AFTTR               THEN PUT IT OUT\n         CR    15,3                IF LENGTH GREATER THAN 256\n         BNH   LASTTR              THEN\n         TR    0(256,4),TABLE      TRANSLATE INVALID CHARACTERS\n         AR    4,3                 BUMP STRING POINTER\n         SR    15,3                DECREMENT LENGTH\n         B     CHECKTR             CONTINUE\nLASTTR   BCTR  15,0                REDUCE FOR EXECUTE\n         EX    15,TR               TRANSLATE TO PRINTABLE\nAFTTR    DS    0H                  GET LENGTH OF STRING\n         TPUT  (1),(0),R            DO TPUT EDIT\nAFTTPUT  L     14,12(,13)          RETURN WITH RC FROM TPUT\n         LM    0,12,20(13)\n         BR    14\nTR       TR    0(0,4),TABLE\nTABLE    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'.ABCDEFGHI......'\n         DC    C'.JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         END\n./ ADD NAME=XQSCAN   0100-07332-07332-0900-00704-00704-00000-SEB\n         TITLE 'XQSCAN - DISPLAY ENQ DATA'\n***********************************************************************\n* THIS PROGRAM IS *** NOT *** REENTRANT.  TOO BAD.                    *\n***********************************************************************\n***********************************************************************\n* INFORMATION ON THE GQSCAN MACRO INSTRUCTION MAY BE FOUND IN:        *\n*      OS/VS2 SYSTEM PROGRAMMING LIBRARY: SUPERVISOR                  *\n*                     GC28-1046-0                                     *\n*             FIRST EDITION (DECEMBER, 1980)                          *\n*                  WITH TNL GN28-4917                                 *\n***********************************************************************\n         TITLE 'XQSCAN - INSTREAM MACROS'\n         MACRO\n&LABEL   WTT   &TEXT\n         LCLC  &LAPOST,&LBLA,&LBLB\n&LAPOST  SETC  'L'''\n&LBLA    SETC  'WTT&SYSNDX.A'\n&LBLB    SETC  'WTT&SYSNDX.B'\n         CNOP  0,4\n&LABEL   BAL   1,&LBLB\n&LBLA    DC    C&TEXT\n&LBLB    DS    0H\n         LA    1,0(,1)\n         LA    0,&LAPOST.&LBLA\n         BAL   14,PUTLINE\n         MEND\n         TITLE 'XQSCAN - SET UP FOR HASP MACROS'\n         COPY  $HASPGBL\n         $HASPEQU\n         TITLE 'XQSCAN - DISPLAY ENQ DATA'\n* PARM VALUE IS ONE CHARACTER AS FOLLOWS:\n*    C - DISPLAY ALL CONFLICTS\n*    R - DISPLAY ALL RESERVES\n*    ALL - DISPLAY EVERYTHING IN THE SYSTEM\n*    J=... DISPLAY FOR SPECIFIED JOBNAME\n*    ANYTHING ELSE - DISPLAY FOR SPECIFIED MAJOR NAME (QNAME)\n*    NULL - PROGRAM PROMPTS FOR MAJOR AND MINOR ENQ NAMES\n         EJECT\nXQSCAN   CSECT\n         SAVE  (14,12),,XQSCAN_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XQSCAN,R12\n         LA    R15,SAVEAREA\n         ST    R13,4(,R15)\n         ST    R15,8(,R13)\n         LR    R13,R15\n         USING SAVEAREA,R13\n         EJECT\n         L     R15,X'21C'          TCB\n         L     R15,X'B4'(,R15)     JSCB\n         L     R15,X'15C'(,R15)    Active JSCB\n         L     R15,X'108'(,R15)    PSCB\n         L     R15,X'30'(,R15)     UPT\n         ST    R15,IOPLUPT\n         L     R15,X'224'          ASCB\n         L     R15,X'6C'(,R15)     ASXB\n         L     R15,X'14'(,R15)     LWA\n         L     R15,X'20'(,R15)     LWA\n         ST    R15,IOPLECT\n         LA    R15,ECB\n         ST    R15,IOPLECB\n         L     R1,0(,R1)           GET PARM VALUE\n         LH    R3,0(,R1)           GET LENGTH OF PARMS\n         LA    R9,2(,R1)           POINT TO BEGINNING OF PARMS\n         LTR   R3,R3               IF NO PARM SPECIFIED\n         BZ    NOPARMS             THEN NO PARM\nPROCPRMS OI    0(R9),C' '          SHIFT TO UPPER CASE\n         CLI   0(R9),C'R'          IF PARM IS 'R'\n         BNE   NOTRES               AND\n         CH    R3,=H'1'              PARM LENGTH IS 1\n         BNE   NOTRES                 THEN\n         OI    FLAGSA,FLAGRYES         DISPLAY RESERVE DATA ONLY\n         B     AFTPARMS            ELSE\nNOTRES   DS    0H\n         CLI   0(R9),C'C'          IF PARM IS 'C'\n         BNE   NOCONF               AND\n         CH    R3,=H'1'              PARM LENGTH IS 1\n         BNE   NOCONF                 THEN CONFLICTS ONLY WAS REQUESTED\n         MVC   WAITCNT,=F'1'        SET WAITCNT = 1\n         OI    FLAGSB,FLAGWAIT      INDICATE WAIT COUNT SPECIFIED\n         B     AFTPARMS            ELSE\nNOCONF   DS    0H\n         CH    R3,=H'3'            IF PARM LENGTH = 3\n         BNE   NOTALL               AND\n         CLC   0(3,R9),=C'ALL'       PARM IS 'ALL'\n         BE    AFTPARMS               THEN DISPLAY EVERYTHING\nNOTALL   DS    0H\n         CH    R3,=H'2'            IF PARM LENGTH >= 2\n         BL    NOTJEQ               AND\n         CLC   0(2,R9),=C'J='        PARM STARTS WITH J=\n         BNE   NOTJEQ                 THEN\n         SH    R3,=H'2'                GET REMAINING PARM (JOBNAME) LEN\n         BNP   GETJOBN                 IF ZERO, PROMPT FOR JOBNAME\n         CH    R3,=H'8'                IF JOBNAME LENGTH GT 8\n         BH    JERROR                  THEN ERROR\n         MVC   JOBNAME,BLANKS          ELSE CLEAR JOBNAME TO BLANKS\n         BCTR  R3,0                    PREPARE TO EXECUTE...\n         EX    R3,MVJOBNM              MOVE PARM INTO JOBNAME\n         B     TESTJOBN                GO TO PROCESS JOBNAME\nNOTJEQ   DS    0H                  ELSE ANYTHING ELSE, ASSUME QNAME\n         CH    R3,=H'8'            IF QNAME LENGTH GT 8\n         BH    QERROR              THEN ERROR\n         MVC   MAJOR,BLANKS        ELSE CLEAR QNAME TO BLANKS\n         BCTR  R3,0                PREPARE TO EXECUTE...\n         EX    R3,MVQNAME          MOVE PARM INTO QNAME\n         LA    R0,MAJOR            PLACE ADDRESS OF QNAME\n         ST    R0,QNAME            IN PARAMETER LIST\n         B     AFTPARMS            GO PROCESS QNAME BY ITSELF\n         SPACE\nMVJOBNM  OC    JOBNAME(0),2(R9)    MOVE PARM FIELD TO JOBNAME\nMVQNAME  OC    MAJOR(0),0(R9)      MOVE PARM FIELD TO QNAME\n         SPACE\nNOPARMS  DS    0H                  NO PARMS SPECIFIED...\n* IF NO PARMS ENTERED, PROMPT THE USER FOR VARIOUS INFO...\nGETQNAME WTT   'XQSCAN: ENTER MAJOR NAME (QNAME) OR PRESS ENTER:'\n         TCLEARQ INPUT             PURGE TERMINAL INPUT\n         TGET  MAJOR,8             GET QNAME\n         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED\n         BNE   MAJNOT12            THEN\nQERROR   WTT   'XQSCAN: QNAME EXCEEDS 8 CHARACTERS'\n         B     GETQNAME             PROMPT AGAIN\nMAJNOT12 LTR   R1,R1               IF USER ENTERED NOTHING\n         BZ    NORNAME             THEN GO ASK FOR JOBNAME. ELSE...\n         OC    MAJOR,BLANKS         TRANSLATE TO UPPERCASE\n         LA    R0,MAJOR             PLACE ADDRESS OF QNAME\n         ST    R0,QNAME             IN PARAMETER LIST\nNOQNAME  DS    0H\nGETRNAME WTT   'XQSCAN: ENTER MINOR NAME (RNAME) OR PRESS ENTER:'\n         TCLEARQ INPUT             PURGE TERMINAL INPUT\n         TGET  MINOR,255           GET RNAME\n         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED\n         BNE   MINNOT12            THEN\nRERROR   WTT   'XQSCAN: RNAME EXCEEDS 255 CHARACTERS'\n         B     GETRNAME             PROMPT AGAIN\nMINNOT12 LTR   R1,R1               IF USER ENTERED NOTHING\n         BZ    NOJOBN              THEN ASK FOR NOTHING ELSE. ELSE...\n         OC    MINOR,BLANKS         TRANSLATE TO UPPERCASE\n         LA    R0,MINOR             PLACE ADDRESS OF RNAME\n         ST    R0,RNAME             IN PARAMETER LIST\n         STC   R1,RNMLEN            PUT LENGTH OF NAME IN PARM LIST\n         B     NOJOBN               CONTINUE (CAN ASK FOR NOTHING ELSE)\nNORNAME  DS    0H\nGETJOBN  WTT   'XQSCAN: ENTER JOBNAME OR PRESS ENTER:'\n         TCLEARQ INPUT             PURGE TERMINAL INPUT\n         TGET  JOBNAME,8           GET JOB NAME\n         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED\n         BNE   GOTJOBN             THEN\nJERROR   WTT   'XQSCAN: JOBNAME EXCEEDS 8 CHARACTERS'\n         B     GETJOBN              PROMPT AGAIN\nGOTJOBN  LTR   R1,R1               IF USER ENTERED NOTHING\n         BZ    NOJOBN              THEN DO NOTHING. ELSE...\n         OC    JOBNAME,BLANKS      SHIFT TO UPPER CASE\nTESTJOBN DS    0H                  RETRIEVE ASID OF JOBNAME\n         CLC   JOBNAME,=CL8'*MASTER*' IF MASTER SCHEDULER REQUESTED\n         BNE   NOTMSTR             THEN\n         LA    R0,1                 SET ASID = 01\n         B     MOVEASID            ELSE\nNOTMSTR  DS    0H                   NOT MASTER SCHEDULER\n         L     R1,X'10'             GET ADDRESS OF CVT\n         L     R1,X'22C'(,R1)       GET ADDRESS OF ASVT\n         L     R15,X'204'(,R1)      GET MAX # OF ADDRESS SPACES\n         BCTR  R15,0                SUBTRACT 1 TO POINT TO LAST ONE\n         SLA   R15,2                MULTIPLY BY FOUR\n         LA    R1,X'210'(,R1)       POINT TO FIRST ASVT ENTRY\n         ALR   R15,R1               GET ADDRESS OF LAST ASVT ENTRY\n         LA    R14,4\nASVTLOOP TM    0(R1),X'80'          IF ASVT ENTRY IS AVAILABLE\n         BO    ASVTCONT             THEN NOT THIS ONE, CONTINUE\n         L     R2,0(,R1)            ELSE GET ADDRESS OF ITS ASCB\n         L     R2,X'38'(,R2)        GET ADDRESS OF ITS CSCB\n         CLC   8(8,R2),JOBNAME      IF JOBNAME MATCHES\n         BNE   ASVTCONT             THEN (WE FOUND IT) ...\n         LH    R0,X'1E'(,R2)        GET ASID FROM CSCB\n         B     MOVEASID             ELSE\nASVTCONT BXLE  R1,R14,ASVTLOOP      CONTINUE UNTIL FOUND OR NONE LEFT\n*\n* IF JOB NOT FOUND VIA ASVT SCAN, TRY JES CONTROL BLOCK SCAN.\n*\n         L     R1,X'10'            GET ADDRESS OF CVT\n         USING CVTMAP,R1           ESTABLISH ADDRESSABILITY TO CVT\n         L     R1,CVTJESCT         GET ADDRESS OF JES CONTROL TABLE\n         USING JESCT,R1            ESTABLISH ADDRESSABILITY TO JSECT\n         L     R1,JESSSCT          GET ADDRESS OF SUBSYSTEM CONTROL TBL\n         USING SSCT,R1             ESTABLISH ADDRESSABILITY TO SSCT\n*        L     R1,SSCTSSVT         GET ADDRESS OF SUBSYSTEM VECTOR TBL\n*        USING SSVT,R1             ESTABLISH ADDRESSABILITY TO SSVT\n* following due to JES2 3.1.3...\n         L     R1,SSCTSUS2         Get address of JES2 HCCT\n         USING HCCT,R1             ESTABLISH ADDRESSABILITY TO HCCT\n         ICM   R1,15,CCTJXCLS      GET ADDRESS OF SUBSYSTEM JOB BLOCK\n         BZ    JNOTFOUN            IF ZERO, JOB NOT FOUND. ELSE...\nSJBLOOP  DS    0H                  CHAIN THROUGH SJB'S\n         USING SJB,R1              ESTABLISH ADDRESSABILITY TO SJB\n         CLC   SJBJOBNM,JOBNAME    IF JOBNAME MATCHES,\n         BNE   NEXTSJB             THEN (WE FOUND IT)...\n         LH    R0,SJBASID           GET ASID FROM SJB\n         B     MOVEASID             AND STORE IT. ELSE...\nNEXTSJB  ICM   R1,15,SJBXQCHN      GET NEXT SJB IN CHAIN\n         BNZ   SJBLOOP             IF THERE IS ONE, CONTINUE. ELSE...\nJNOTFOUN DS    0H\n         WTT   'XQSCAN: JOBNAME NOT FOUND'\n         B     GETJOBN\nMOVEASID DS    0H\n         ST    R0,ASID             PUT ASID INTO PARAMETER LIST\n         MVC   SYSNAME,CSDL        SYSNAME REQUIRED FOR ASID\n         LA    R0,SYSNAME\n         ST    R0,SYSNM            PUT ADDRESS IN PARAMETER LIST\n         OI    FLAGSB,FLAGSYSN     INDICATE SYSNAME SPECIFIED\nNOJOBN   DS    0H\n         SPACE\nAFTPARMS DS    0H                  ALL PARMS HAVE BEEN HANDLED\n         L     R0,INCR             GET FIRST LENGTH OF AREA\n         ST    R0,AREALEN          SAVE IT\n         GETMAIN R,LV=(0)          GET IT\n         ST    R1,AREAPTR          SAVE ADDRESS OF AREA\n         SPACE\nRETRY    DS    0H\n         L     R1,AREAPTR          GET ADDRESS OF CURRENT AREA\n         EJECT\n***********************************************************************\n         SPACE\n         GQSCAN MF=(E,QSPARMS)     SCAN ENQ INFO\n         SPACE\n***********************************************************************\n         EJECT\nAFTQCSAN DS    0H\n         STM   R0,R1,GQREGS        SAVE RETURN PARAMETER REGISTERS\n         LR    R10,R1              GET NUMBER OF RIBS RETURNED\n         LTR   R2,R15              TEST RETURN CODE FROM GQSCAN\n         BZ    DISPLAY             IF ZERO, GO SHOW USER\n         CH    R2,=H'4'            IF RC=4 (NO DATA)\n         BNE   TRY8                THEN\n         WTT   'XQSCAN: FOUND NO ENQ/RESERVE DATA FOR REQUEST.'\n         B     RETURN\n         SPACE\nTRY8     CH    R2,=H'8'            IF RC=8 (TOO MUCH DATA)\n         BNE   TRY12               THEN\n         L     R0,AREALEN           GET CURRENT AREA LENGTH\n         L     R1,AREAPTR           GET CURRENT AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)    FREE EXISTING AREA\n         L     R0,INCR              GET AREA LENGTH INCREMENT\n         AL    R0,AREALEN           INCREASE THE LENGTH\n         ST    R0,AREALEN           SAVE IT\n         GETMAIN RC,LV=(0)          TRY TO GET IT\n         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA IF ANY\n         LTR   R15,R15              IF COULD NOT GET IT\n         BZ    RETRY                THEN\n         L     R0,AREALEN           GET LENGTH\n         S     R0,INCR              GO BACK TO PREVIOUS LENGTH\n         GETMAIN R,LV=(0)           GET IT (WE KNOW THAT WE CAN)\n         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA\n         WTT   'XQSCAN: COULD NOT GET STORAGE TO DISPLAY ALL DATA'\n         B     RETRY                AND TRY AGAIN.\n         SPACE\nTRY12    CH    R2,=H'12'\n         BNE   TRY16\n         WTT   'XQSCAN: FAILED, GQSCAN ERROR CODE 12'\n         B     RETURN\nTRY16    CH    R2,=H'16'\n         BNE   NOT16\n         WTT   'XQSCAN: FAILED, GQSCAN ERROR CODE 16'\n         B     RETURN\nNOT16    DS    0H\n         WTT   'XQSCAN: UNEXPECTED ERROR CODE = ABEND CODE'\n         ABEND (R2),DUMP\n         EJECT\nDISPLAY  DS    0H                  OK - NOW DISPLAY INFO\n         SPACE\n         L     R3,AREAPTR          START OF Q INFO\n         USING RIB,R3              ADDRESS THE BASIC FIXED RIB\nCONTINUE DS    0H\n         LH    R8,LRIBFIX          LENGTH OF FIXED RIB\n         ALR   R8,R3                PLUS ADDRESS OF FIXED RIB\n         USING RIBVAR,R8            GIVES VARIABLE SECTION OF RIB\n* SHOULD WE DISPLAY THIS ONE?\n         XR    R0,R0               CLEAR INSERT REGISTER\n         IC    R0,RIBSCOPE         GET SCOPE VALUE\n         SRL   R0,4\n         SLL   R0,4                EXTRACT LEFT NIBBLE ONLY\n         STC   R0,SCOPEBIT         STORE IT\n         CLI   SCOPEBIT,RIBSYS     IF SCOPE = SYSTEM\n         BNE   NOTSYS              THEN\n         MVC   SCOPE,=CL7'SYSTEM'   SAY SO\n         B     AFTSCOPE            ELSE\nNOTSYS   CLI   SCOPEBIT,RIBSYSS    IF SCOPE = SYSTEMS\n         BNE   NOTSYSS             THEN\n         MVC   SCOPE,=CL7'SYSTEMS'  SAY SO\n         B     AFTSCOPE            ELSE\nNOTSYSS  CLI   SCOPEBIT,RIBSTEP    IF SCOPE = STEP\n         BNE   NOTSTEP             THEN\n         MVC   SCOPE,=CL7'STEP'     SAY SO\n         B     AFTSCOPE            ELSE\nNOTSTEP  CLI   SCOPEBIT,RIBGLBL    IF SCOPE = GLOBAL\n         BNE   NOTGLBL             THEN\n         MVC   SCOPE,=CL7'GLOBAL'   SAY SO\n         B     AFTSCOPE            ELSE\nNOTGLBL  CLI   SCOPEBIT,0          IF SCOPE = LOCAL\n         BNE   NOTZERO             THEN\n         MVC   SCOPE,=CL7'LOCAL'    SAY SO\n         B     AFTSCOPE            ELSE\nNOTZERO  MVC   SCOPE,=CL7'???????'  I DON'T KNOW WHAT IT IS\nAFTSCOPE DS    0H\n***\n         AGO   .NOHMTSK            BYPASS EXTRA DISPLAYS\n***\n         WTT   ' '                 DISPLAY A BLANK LINE\n         MVC   TPUTAREA+00(007),=C'QNAME: '\n         MVC   TPUTAREA+07(008),RIBQNAME\n         LA    R1,TPUTAREA\n         LA    R0,7+8\n         BAL   R14,PUTLINE         DISPLAY QNAME\n         XR    R9,R9               CLEAR INSERT REGISTER\n         ICM   R9,1,RIBRNMLN       GET LENGTH OF RNAME\n         BZ    NODISMIN            IF THERE IS ONE (NONZERO), THEN\n         MVC   TPUTAREA+00(007),=C'RNAME: '\n         BCTR  R9,0\n         EX    R9,MVCRNAME\n         EX    R9,TRNAME\n         LA    R1,TPUTAREA\n         LA    R0,8(,R9)\n         BAL   R14,PUTLINE         DISPLAY RNAME\n         CH    R9,=H'7'            IF LENGTH OF RNAME BETWEEN 1 & 8\n         BH    NODISMIN            AND\n         EX    R9,TRTNAME           INVALID CHARACTERS PRESENT\n         BZ    NODISMIN            THEN\n         XC    HEXNAME(8),HEXNAME\n         EX    R9,MVCNAME\n         LA    R9,1(,R9)\n         MVC   TPUTAREA+00(015),=C'      (HEX:  X'''\n         MVC   TPUTAREA+15(007),HEXNAME\n         UNPK  TPUTAREA+15(015),TPUTAREA+15(08)\n         TR    TPUTAREA+15(014),XXXTBL\n         MVC   TPUTAREA+29(002),=C''')'\n         LA    R1,TPUTAREA\n         LA    R0,31\n         BAL   R14,PUTLINE         DISPLAY RNAME IN HEX\n         B     NODISMIN            BRANCH AROUND EXECUTED INSTRUCTIONS\n         SPACE\nMVCRNAME MVC   TPUTAREA+07(000),RIBRNAME\nTRNAME   TR    TPUTAREA+07(000),DISPTBL\nTRTNAME  TRT   RIBRNAME(0),TRTABLE\nMVCNAME  MVC   HEXNAME(0),RIBRNAME\n         SPACE 2\nNODISMIN DS    0H\n         MVC   TPUTAREA+00(007),=C'SCOPE: '\n         MVC   TPUTAREA+07(007),SCOPE\n         LA    R1,TPUTAREA\n         LA    R0,14\n         BAL   R14,PUTLINE         DISPLAY SCOPE\n***\n         AGO   .NOHMTSK            DON'T DISPLAY HOW MANY TASKS OWN\n***\n         MVC   TPUTAREA+00(002),BLANKS\n         L     R0,RIBNTO\n         CVD   R0,DOUBLE\n         MVC   TPUTAREA+02(012),=X'F02020202020202020202020'\n         LA    R1,TPUTAREA+02+11\n         EDMK  TPUTAREA+02(012),DOUBLE+2\n         BNM   *+10\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         MVC   TPUTAREA+02(012),0(R1)\n         LA    R15,TPUTAREA+02+11\n         SR    R15,R1\n         LA    R1,TPUTAREA+02+1(R15)\n         CLC   RIBNTO,=F'1'\n         BNE   MORETHN1\n         MVC   0(10,R1),=C' TASK OWNS'\n         B     AFTTHN1\nMORETHN1 MVC   0(109,R1),=C' TASKS OWN'\nAFTTHN1  MVC   10(14,1),=C' THIS RESOURCE'\n         LA    R0,24(,R1)\n         LA    R1,TPUTAREA\n         SLR   R0,R1\n         BAL   R14,PUTLINE\n***\n.NOHMTSK ANOP  ,                   DON'T DISPLAY HOW MANY TASKS OWN\n***\n         EJECT\n         ICM   R0,15,RIBNTWE       # OF TASK WAITING FOR EXCLUSIVE\n         BZ    NOWE                IF NONE, BYPASS\n         MVC   TPUTAREA+00(031),=C' TASKS WAITING FOR ACCESS=OLD: '\n         CVD   R0,DOUBLE           CONVERT # OF TASKS TO DECIMAL\n         LA    R1,TPUTAREA+31+11\n         MVC   TPUTAREA+31(012),=X'F02020202020202020202020'\n         EDMK  TPUTAREA+31(012),DOUBLE+2\n         BNM   *+10\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         MVC   TPUTAREA+31(012),0(R1)\n         LA    R15,TPUTAREA+31+11\n         SR    R15,R1\n         LA    R0,TPUTAREA+31+1(R15)\n         LA    R1,TPUTAREA\n         SLR   R0,R1\n         BAL   R14,PUTLINE\nNOWE     DS    0H\n         SPACE\n         ICM   R0,15,RIBNTWS       # OF TASK WAITING FOR SHARED\n         BZ    NOWS                IF NONE, BYPASS\n         MVC   TPUTAREA+00(031),=C' TASKS WAITING FOR ACCESS=SHR: '\n         CVD   R0,DOUBLE           CONVERT # OF TASKS TO DECIMAL\n         LA    R1,TPUTAREA+31+11\n         MVC   TPUTAREA+31(012),=X'F02020202020202020202020'\n         EDMK  TPUTAREA+31(012),DOUBLE+2\n         BNM   *+10\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         MVC   TPUTAREA+31(012),0(R1)\n         LA    R15,TPUTAREA+31+11\n         SR    R15,R1\n         LA    R0,TPUTAREA+31+1(R15)\n         LA    R1,TPUTAREA\n         SLR   R0,R1\n         BAL   R14,PUTLINE\n         SPACE\nNOWS     DS    0H\n         ICM   R7,15,RIBNRIBE      GET NUMBER OF EXTENTS RETURNED\n         BZ    NOEXTS              IF NONE, BYPASS\n         LR    R6,R8               BUMP PAST VARIABLE PART OF RIB\n         AH    R6,RIBVLEN          BUMP PAST VARIABLE PART OF RIB\n         USING RIBE,R6             RIB EXTENT\nEXTLOOP  DS    0H\n         SPACE 2\n         TM    RIBERFLG,RIBETYPE   IF ACCESS IS EXCLUSIVE\n         BO    SHARED              THEN\n         MVC   TYPE,=CL3'OLD'       SAY SO\n         B     AFTTYPE             ELSE\nSHARED   MVC   TYPE,=CL3'SHR'       SAY SHARED\nAFTTYPE  DS    0H\n         TM    RIBERFLG,RIBERESV\n         BO    ISRESV\n         MVI   WHATISIT,C' '\n         B     AFTRESV\nISRESV   MVI   WHATISIT,C'R'\nAFTRESV  DS    0H\n         TM    RIBESFLG,RIBESTAT   1 = OWNS IT, 0 = WAITING FOR IT\n         BO    STATOWN\n         MVI   STAT,C'W'\n         B     AFTSTAT\nSTATOWN  MVI   STAT,C' '\nAFTSTAT  DS    0H\n         MVC   TPUTAREA+00(255),BLANKS\n         MVC   TPUTAREA+00(001),STAT       WAIT OR OWN\n         MVC   TPUTAREA+02(001),RIBEASID+1 ASID\n         UNPK  TPUTAREA+02(003),TPUTAREA+02(02)\n         TR    TPUTAREA+02(002),XXXTBL\n         MVI   TPUTAREA+04,C' '\n         MVC   TPUTAREA+05(007),SCOPE      STEP, SYSTEM, SYSTEMS\n         MVC   TPUTAREA+13(003),TYPE       OLD OR SHR\n         MVC   TPUTAREA+17(001),WHATISIT   ENQUEUE OR RESERVE\n         MVC   TPUTAREA+19(008),RIBEJBNM   JOBNAME\n         TR    TPUTAREA+19(008),DISPTBL\n         MVC   TPUTAREA+28(008),RIBQNAME   MAJOR NAME\n         TR    TPUTAREA+28(008),DISPTBL\n         XR    R15,R15\n         ICM   R15,1,RIBRNMLN\n         BZ    NODRNAME\n         BCTR  R15,0\n         EX    R15,DRNAME\n         EX    R15,DRTR\n         B     NODRNAME\nDRNAME   MVC   TPUTAREA+37(000),RIBRNAME   MINOR NAME\nDRTR     TR    TPUTAREA+37(000),DISPTBL\nNODRNAME DS    0H\n         LA    R0,TPUTAREA+37+1(R15)\n         LA    R1,TPUTAREA\n         SLR   R0,R1\n         BAL   R14,PUTLINE\n         CLC   RIBESYSN,NONAME\n         BE    NOSYS\n         CLC   RIBESYSN,CSDL\n         BE    NOSYS\n         MVC   TPUTAREA+00(015),=C'    SYSTEM:    '\n         MVC   TPUTAREA+15(008),RIBESYSN\n         LA    R1,TPUTAREA\n         LA    R0,23\n         BAL   R14,PUTLINE\n         EJECT\nNOSYS    DS    0H\n         AH    R6,LRIBE            ADDR(RIBE)+LENGTH(RIBE) -> NEXT RIBE\n         BCT   R7,EXTLOOP          LOOP UNTIL NO MORE EXTENTS\n         SPACE\nNOEXTS   DS    0H\n         LA    R3,0(,R6)           END OF PREV RIBE = BEGIN NEXT RIBE\n         BCT   R10,CONTINUE        CONTINUE UNTIL NO MORE RIBS\n         B     RETURN              AND THEN FINISH.\n         EJECT\nRETURN   DS    0H\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)\n         XR    R15,R15             RETURN CODE(0)\n         BR    R14\n         EJECT\nPUTLINE  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* R1 = address of message text                                        *\n* R0 = length of message text                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    R14,PUTL14          Save return address\n         LR    R14,R0              Get length of message\n         BCTR  R14,0               Adjust for EX\n         EX    R14,MOVELINE        Move message to buffer\n         LA    R14,5(,R14)         Get message length + 4\n         SLL   R14,16              Shift into left half\n         ST    R14,MSGBUFF         Set message buffer prefix\n         XC    ECB,ECB\n         PUTLINE PARM=PUTLIST,OUTPUT=(MSGBUFF,TERM,SINGLE,DATA),       X\n               MF=(E,IOPL)\n         LTR   R15,R15             If PUTLINE completed OK\n         BZ    PUTLRET             then just return\n         LA    R1,MSGBUFF+4        Else point to message\n         LH    R0,MSGBUFF+0        Get length of message\n         SH    R0,=H'4'            Subtract prefix length\n         TPUT  (1),(0),R\nPUTLRET  DS    0H\n         L     R14,PUTL14          Restore return address\n         BR    R14                 Return to caller\n         SPACE 1\nMOVELINE MVC   MSGBUFF+4(*-*),0(R1) Move PUTLINE message to buffer\nPUTL14   DS    A\nIOPL     DS    0A\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\nECB      DS    A\nPUTLIST  PUTLINE MF=L              PUTLINE parameter list\nOLD      DS    F                   PUTLINE output line descriptor\nMSGBUFF  DS    F,CL256             PUTLINE message buffer\n         EJECT\nSAVEAREA DS    9D\nDOUBLE   DS    D\n* VALUES PASSED BACK FROM THE GQSCAN SERVICE\nGQREGS   DS    2F\n         ORG   GQREGS\nGQREG0   DS    F                   REGISTER ZERO FROM GQSCAN\n         ORG   GQREG0\nLRIBFIX  DS    H                   LENGTH OF EACH FIXED RIB\nLRIBE    DS    H                   LENGTH OF EACH RIBE\nGQREG1   DS    F                   REGISTER ONE FROM GQSCAN\n         ORG   GQREG1\nNUMRIBS  DS    F                   NUMBER OF RIBS COPIED\nTOK      DC    F'0'                TOKEN FOR GQSCAN PROCESSING (UNUSED)\nSCOPEBIT DC    X'00'\nSCOPE    DC    CL7' '\nTYPE     DC    CL3' '\nWHATISIT DC    CL1' '\nSTAT     DC    CL1' '\nHEXNAME  DS    XL8\nSYSNAME  DC    CL8' '\nJOBNAME  DC    CL8' '\nMAJOR    DC    CL8' '\nMINOR    DC    CL256' '\nBLANKS   DC    CL256' '\n         SPACE\nINCR     DC    F'4096'             INCREMENT FOR GETMAINS\nNONAME   DC    CL8'NONAME'         DEFAULT SYSTEM NAME\nCSDL     DC    CL8'CSDL'           EXPECTED SYSTEM NAME\n         SPACE\nTRTABLE  DC    256YL1(1)\n         ORG   TRTABLE+X'40'\n         DC    YL1(0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)\n         DC    YL1(0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)\n         DC    YL1(0,0,2,3,4,5,6,7,8,9,0,0,0,0,0,0)\n         DC    YL1(1,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)\n         ORG   TRTABLE+X'81'\n         DC    YL1(0,0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'91'\n         DC    YL1(0,0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'A2'\n         DC    YL1(0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'C1'\n         DC    YL1(0,0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'D1'\n         DC    YL1(0,0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'E2'\n         DC    YL1(0,0,0,0,0,0,0,0)\n         ORG   TRTABLE+X'F0'\n         DC    YL1(0,0,0,0,0,0,0,0,0,0)\n         ORG\nTRTTBL   DC    256YL1(1)\n         ORG   TRTTBL+X'81'\n         DC    YL1(0,0,0,0,0,0)\n         ORG   TRTTBL+C'A'\n         DC    YL1(0,0,0,0,0,0)\n         ORG   TRTTBL+C'0'\n         DC    YL1(0,0,0,0,0,0,0,0,0,0)\n         ORG\nTRTBL    DC    256YL1(*-TRTBL)\n         ORG   TRTBL+X'81'\n         DC    X'FAFBFCFDFEFF'\n         ORG   TRTBL+C'A'\n         DC    X'FAFBFCFDFEFF'\n         ORG\nDISPTBL  DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'.ABCDEFGHI......'\n         DC    C'.JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nXXXTBL   EQU   *-256\n         EJECT\nQSPARMS  DS    0F\n         SPACE\n***********************************************************************\n*           PARAMETER LIST TO ISGQSCAN MAPPED AS FOLLOWS:             *\n***********************************************************************\n         SPACE\nAREAPTR  DC    A(0)           AREAPTR    ADDR OF USER SPECIFIED AREA\nAREALEN  DC    A(0)           AREALEN    SIZE OF USER SPECIFIED AREA\nQNAME    DC    A(0)           QNAME      QNAME (MAJOR NAME) ADDRESS\nRNAME    DC    A(0)           RNAME      RNAME (MINOR NAME) ADDRESS\nSYSNM    DC    A(0)           SYSNM      SYSNAME ADDRESS\nASID     DC    A(0)           ASID       ASID VALUE\nREQCNT   DC    A(0)           REQCNT     REQUEST COUNT\nOWNCNT   DC    A(0)           OWNCNT     OWNER COUNT\nWAITCNT  DC    A(0)           WAITCNT    WAIT COUNT\nTOKEN    DC    A(TOK)         TOKEN      TOKEN ADDRESS\nREQLIM   DC    A(32767)       REQLIM     REQUEST LIMIT = MAX\nFLAGSA   DC    BL1'11100000'  FLAGSA     RESERVE/SCOPE FLAGS\n*                            1.......    SCOPE=STEP\n*                            .1......    SCOPE=SYSTEM\n*                            ..1.....    SCOPE=SYSTEMS\n*                            ...1....    SCOPE=LOCAL\n*                            ....1...    SCOPE=GLOBAL\nFLAGRNO  EQU   B'00000100'   .....1..    RESERVE=NO\nFLAGRYES EQU   B'00000010'   ......1.    RESERVE=YES\n*                            .......1    RESERVED\nFLAGSB   DC  BL1'00000000'    FLAGSB     VARIABLE SPECIFIED FLAGS\nFLAGSYSN EQU   B'10000000'   1.......    SYSNAME SPECIFIED\n*                            .1......    REQCNT SPECIFIED\n*                            ..1.....    OWNCNT SPECIFIED\nFLAGWAIT EQU   B'00010000'   ...1....    WAITCNT SPECIFIED\nFLAGTOK  EQU   B'00001000'   ....1...    TOKEN SPECIFIED\n*                            .....1..    RESERVED\n*                            ......1.    RESERVED\n*                            .......1    RESERVED\nRNMLEN   DC    YL1(0)                    RNAME LENGTH\n         SPACE\n         LTORG\n         SPACE\nTPUTAREA DS    CL280\n         EJECT\n         ISGRIB ,   MAP THE DATA PASSED BACK BY ISGQSCAN\n SPACE\n CSECT\n SPACE\n         CVT    DSECT=YES,PREFIX=YES\n SPACE\n CSECT\n SPACE\n         IEZDEB\n SPACE\n CSECT\n SPACE\n         IEFJESCT\n SPACE\n CSECT\n SPACE\n         IEFJSCVT\n SPACE\n CSECT\n SPACE\n         $XECB\n SPACE\n CSECT\n SPACE\n         $SCAT\n SPACE\n CSECT\n SPACE\n         $HFAME\n SPACE\n CSECT\n SPACE\n         $HCCT\n SPACE\n CSECT\n SPACE\n         $SJB\n SPACE\n CSECT\n SPACE\n         $TQE\n         TITLE ' '                 CLEAR TITLE GENERATED BY HASP MACROS\n         CSECT\n         END\n./ ADD NAME=XRXDEQ   0100-07332-07332-0900-00141-00141-00000-SEB\n         TITLE 'XRXDEQ   - REXX dequeue LINK module'\n***********************************************************************\n*                                                                     *\n* XRXDEQ   - REXX dequeue LINK module                                 *\n*                                                                     *\n* This routine is designed to allow a REXX exec to dequeue on a       *\n* specified QNAME and RNAME.  It MUST be invoked as follows:          *\n*                                                                     *\n*   ADDRESS LINK \"XRXDEQ qname,rname\"                                 *\n*                                                                     *\n* No blanks are permitted.  LINK must be specified because the ENQ    *\n* is task-related (see XRXENQ).                                       *\n*                                                                     *\n* Case MUST be exact.                                                 *\n*                                                                     *\n* On entry register 1 points to a pair of parameter addresses:        *\n*                                                                     *\n* Parameter 1 --> the address of the remaining text in the buffer     *\n* Parameter 2 --> the length of the remaining text in the buffer      *\n*                                                                     *\n* See TSO/E REXX Reference, p. 25, for more information.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   Static base register\nR13      EQU   13   Dynamic base register and save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXRXDEQ   CSECT\n         SAVE  (14,12),,XRXDEQ_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XRXDEQ,R12\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         LM    R3,R4,0(R2)         Get parameters 1 and 2\n         L     R3,0(,R3)           Get address of remaining text\n         L     R4,0(,R4)           Get length of remaining text\n         LA    R5,0(R3,R4)         Point to end of remaining text\n         LTR   R15,R4              If length is zero,\n         BNP   ERROR               then error\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,FINDCOMA        Scan for comma\n         BZ    ERROR               If none found, error\n         LR    R6,R1               Location of comma\n         SR    R6,R3               Get length of text up to comma\n         BNP   ERROR               If zero, error\n         CH    R6,=H'8'            If too long, error\n         BH    ERROR\n         LA    R7,1(,R1)           Point past comma\n         SR    R5,R7               Get length of rname\n         BNP   ERROR               If zero, error\n         CH    R5,=H'256'          If too long, error\n         BH    ERROR\n* R3 = address of qname\n* R6 = length of qname\n* R7 = address of rname\n* R5 = length of rname\n         MVI   QNAME,C' '          Clear qname to blanks\n         MVC   QNAME+1(L'QNAME-1),QNAME\n         LR    R15,R6\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,MVCQNAME        Move qname\n         MVI   RNAME,C' '          Clear rname to blanks\n         MVC   RNAME+1(L'RNAME-1),RNAME\n         LR    R15,R5\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,MVCRNAME        Move rname\n         SPACE 1\n         LA    R2,QNAME\n         LA    R3,RNAME\n         MVC   DEQLIST($DEQLEN),$DEQLIST\n         DEQ   ((R2),(R3),(R5),SYSTEMS),RET=HAVE,MF=(E,DEQLIST)\n         B     RETURN              Return with DEQ return code\n         SPACE 1\nERROR    DS    0H                  Bad parameters\n         L     R15,=F'-1'          Signal failure\n         B     RETURN\n         SPACE 1\n***********************************************************************\n* Return to calling environment - R15 contains return code            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\nFINDCOMA TRT   0(*-*,R3),TRTBL     Executed: scan for comma\nMVCQNAME MVC   QNAME(*-*),0(R3)    Executed: move qname\nMVCRNAME MVC   RNAME(*-*),0(R7)    Executed: move rname\n         SPACE 1\n$DEQLIST DEQ   (,,,SYSTEMS),RET=HAVE,MF=L\n$DEQLEN  EQU   *-$DEQLIST\n         SPACE 1\nTRTBL    DC    256YL1(0)           Table to scan for comma\n         ORG   TRTBL+C','\n         DC    YL1(1)\n         ORG   ,\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F\nQNAME    DS    CL8\nRNAME    DS    CL256\nDEQLIST  DEQ   (,,,SYSTEMS),RET=HAVE,MF=L\n         SPACE 2\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\n         END\n./ ADD NAME=XRXENQ   0100-07332-07332-0900-00141-00141-00000-SEB\n         TITLE 'XRXENQ   - REXX enqueue LINK module'\n***********************************************************************\n*                                                                     *\n* XRXENQ   - REXX enqueue LINK module                                 *\n*                                                                     *\n* This routine is designed to allow a REXX exec to enqueue on a       *\n* specified QNAME and RNAME.  It MUST be invoked as follows:          *\n*                                                                     *\n*   ADDRESS LINK \"XRXENQ qname,rname\"                                 *\n*                                                                     *\n* No blanks are permitted.  LINK must be specified because the ENQ    *\n* will go away (due to task termination) otherwise.                   *\n*                                                                     *\n* Case MUST be exact.                                                 *\n*                                                                     *\n* On entry register 1 points to a pair of parameter addresses:        *\n*                                                                     *\n* Parameter 1 --> the address of the remaining text in the buffer     *\n* Parameter 2 --> the length of the remaining text in the buffer      *\n*                                                                     *\n* See TSO/E REXX Reference, p. 25, for more information.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    .\nR4       EQU   4    .\nR5       EQU   5    .\nR6       EQU   6    .\nR7       EQU   7    .\nR8       EQU   8    .\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   Static base register\nR13      EQU   13   Dynamic base register and save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXRXENQ   CSECT\n         SAVE  (14,12),,XRXENQ_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XRXENQ,R12\n         LR    R2,R1               Save input parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         LM    R3,R4,0(R2)         Get parameters 1 and 2\n         L     R3,0(,R3)           Get address of remaining text\n         L     R4,0(,R4)           Get length of remaining text\n         LA    R5,0(R3,R4)         Point to end of remaining text\n         LTR   R15,R4              If length is zero,\n         BNP   ERROR               then error\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,FINDCOMA        Scan for comma\n         BZ    ERROR               If none found, error\n         LR    R6,R1               Location of comma\n         SR    R6,R3               Get length of text up to comma\n         BNP   ERROR               If zero, error\n         CH    R6,=H'8'            If too long, error\n         BH    ERROR\n         LA    R7,1(,R1)           Point past comma\n         SR    R5,R7               Get length of rname\n         BNP   ERROR               If zero, error\n         CH    R5,=H'256'          If too long, error\n         BH    ERROR\n* R3 = address of qname\n* R6 = length of qname\n* R7 = address of rname\n* R5 = length of rname\n         MVI   QNAME,C' '          Clear qname to blanks\n         MVC   QNAME+1(L'QNAME-1),QNAME\n         LR    R15,R6\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,MVCQNAME        Move qname\n         MVI   RNAME,C' '          Clear rname to blanks\n         MVC   RNAME+1(L'RNAME-1),RNAME\n         LR    R15,R5\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,MVCRNAME        Move rname\n         SPACE 1\n         LA    R2,QNAME\n         LA    R3,RNAME\n         MVC   ENQLIST($ENQLEN),$ENQLIST\n         ENQ   ((R2),(R3),E,(R5),SYSTEMS),RET=HAVE,MF=(E,ENQLIST)\n         B     RETURN              Return with ENQ return code\n         SPACE 1\nERROR    DS    0H                  Bad parameters\n         L     R15,=F'-1'          Signal failure\n         B     RETURN\n         SPACE 1\n***********************************************************************\n* Return to calling environment - R15 contains return code            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\nFINDCOMA TRT   0(*-*,R3),TRTBL     Executed: scan for comma\nMVCQNAME MVC   QNAME(*-*),0(R3)    Executed: move qname\nMVCRNAME MVC   RNAME(*-*),0(R7)    Executed: move rname\n         SPACE 1\n$ENQLIST ENQ   (,,E,,SYSTEMS),RET=HAVE,MF=L\n$ENQLEN  EQU   *-$ENQLIST\n         SPACE 1\nTRTBL    DC    256YL1(0)           Table to scan for comma\n         ORG   TRTBL+C','\n         DC    YL1(1)\n         ORG   ,\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F\nQNAME    DS    CL8\nRNAME    DS    CL256\nENQLIST  ENQ   (,,E,,SYSTEMS),RET=HAVE,MF=L\n         SPACE 2\nSIZDATD  EQU   *-DATD              Length of dynamic work area\n         EJECT\n         END\n./ ADD NAME=XRXVARS  0100-07332-07332-0900-00246-00246-00000-SEB\n*\n***********************************************************************\n*                                                                     *\n* XRXVARS - SEB1525 09/18/89                                          *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*\n*  This routine returns the names of all current REXX variables and\n*  queues them on the REXX data stack.  The names are selected based\n*  on a prefix given in the parameter field.\n*\n*  Particularly useful if a stem (varname.) is given as the argument.\n*\n*  Invocation:  CALL 'wherever.load(XRXVARS)' 'variable-prefix'\n*\n***********************************************************************\n         PRINT NOGEN\nXRXVARS  CSECT\nXRXVARS  AMODE 31\nXRXVARS  RMODE ANY\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,XRXVARS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XRXVARS,R12\n         LR    R2,R1               Save parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING DATD,R13\n         MVI   FLAGS,0             Random initializations\n         L     R4,0(,R2)           Get address of parm string\n         LH    R3,0(,R4)           R3 = length of parm\n         LA    R4,2(,R4)           R4 = address of parm\n         LOAD  EP=IRXSTK                Get address of IRXSTK routine\n         ST    R0,@IRXSTK               Save it\n         LOAD  EP=IRXEXCOM              Get address of IRXEXCOM routine\n         ST    R0,@IRXEXCO              Save it\n*\n***********************************************************************\n*                                                                     *\n* Invoke the IRXEXCOM routine to retrieve all variable names.         *\n*                                                                     *\n* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *\n*                                                                     *\n***********************************************************************\n*\n* Build the SHVBLOCK\n*\n* To store the argument value, we try using ARGWA, a 512-byte area\n* that is already part of our workarea, to avoid unnecessary GETMAINs.\n*\n* If that doesn't turn out to be big enough, we'll have to GETMAIN,\n* but it's best to avoid that.\n*\nCONTINUE DS    0H\n         XC    VARNAME(L'VARNAME),VARNAME\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVNEXTV    Fetch \"next\" variable\n         LA    R1,L'VARNAME\n         ST    R1,SHVUSER          Length of name buffer\n         LA    R1,VARNAME\n         ST    R1,SHVNAMA          Address of name buffer\n         LA    R1,1\n         ST    R1,SHVBUFL          Length of dummy value buffer\n         LA    R1,DUMBUF\n         ST    R1,SHVVALA          Address of dummy value buffer\n*                 SHVNAML will contain the length of the name returned\n         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1\n         XR    R15,R15             IRXEXCOM parm 2\n         LR    R0,R15              Parm 3 must be same as Parm 2\n         LA    R1,SHVBLOCK         IRXEXCOM parm 4\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\n         XR    R0,R0               Don't specify an environment block\n         L     R15,@IRXEXCO        Get address of IRXEXCOM\n         LA    R1,IRPARMS          Point to parameter list\n         BALR  R14,R15             Call REXX arg access routine\n         LTR   R15,R15             Check RC\n         BM    BADEXCOM\n         TM    SHVRET,SHVLVAR      If no more variables\n         BO    ENDIT               then finished\n*\n* Compare variable prefix here...\n*\n         LTR   R15,R3\n         BZ    QUEUEIT             If no prefix given, accept all\n         BCTR  R15,0               Else reduce length for execute\n         EX    R15,CLCNAME         If prefix doesn't match\n         BNE   CONTINUE            then continue\nQUEUEIT  DS    0H\n*\n* Queue line onto REXX data stack\n*\n         MVC   IRFUNCT,=CL8'QUEUE'\n         LA    R1,VARNAME\n         ST    R1,IRSTRADR\n         L     R1,SHVNAML\n         ST    R1,IRSTRLEN\n         XR    R1,R1\n         ST    R1,IRRETCD\n         LA    R14,IRFUNCT\n         LA    R15,IRSTRADR\n         LA    R0,IRSTRLEN\n         LA    R1,IRRETCD\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\n         XR    R0,R0               Don't specify an environment block\n         LA    R1,IRPARMS          Point to parameter list\n         L     R15,@IRXSTK         Get address of IRXSTK\n         BALR  R14,R15             Call REXX stack access routi ne\n         LTR   R15,R15             Check rc\n         BNZ   BADSTK\nSTACKOK  DS    0H                  R15 = 0\n         B     CONTINUE\n         SPACE 1\nENDIT    DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in save area\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\nERROR    DS    0H\n         L     R15,=F'-1'          Load error code\n         B     ENDIT\n         SPACE 1\nBADEXCOM DS    0H\n         LA    R1,1111             U1111 for error in IRXEXCOM\n         ABEND (1)\n         SPACE 1\nBADSTK   DS    0H\n         LR    R1,R15              Make abend code the return code\n         ABEND (1)\n         SPACE 1\n         EJECT\nCLCNAME  CLC   0(*-*,R4),VARNAME   Executed: compare variable prefix\n         EJECT\nDATD     DSECT\nSAVEAREA DS    18F\n@IRXSTK  DS    A                   Address of REXX stack routine\n@IRXEXCO DS    A                   Address of REXX access routine\nFLAGS    DC    X'00'               Flags\n*        EQU   B'10000000'          Reserved\n*        EQU   B'01000000'          Reserved\n*        EQU   B'00100000'          Reserved\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nVARNAME  DS    CL256               Area where variable name is returned\nDUMBUF   DS    CL1                 We don't care about the value\n*\nIRPARMS  DS    0A                  Parameter list for IRX routines\nIRPARM1  DS    A                   Address of parameter 1\nIRPARM2  DS    A                   Address of parameter 2\nIRPARM3  DS    A                   Address of parameter 3\nIRPARM4  DS    A                   Address of parameter 4\n*                                  Parameters used by IRXSTK\nIRFUNCT  DS    CL8                 Parameter 1: function to perform\nIRSTRADR DS    CL8                 Parameter 2: address of string\nIRSTRLEN DS    CL8                 Parameter 3: length of string\nIRRETCD  DS    CL8                 Parameter 4: return code\n*                                  Parameters used by IRXEXCOM\n*\n***********************************************************************\n*                                                                     *\n* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *\n*                                                                     *\n***********************************************************************\n*\nSHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK\nSHVNEXT  DS  A                        Chain pointer to next SHVBLOCK\nSHVUSER  DS  F                        Used during \"FETCH NEXT\"\n*                                      Contains length of buffer\n*                                      pointed to by SHVNAMA\nSHVCODES DS  0F\nSHVCODE  DS  CL1                      Function code - indicates type\n*                                      of variable access request\nSHVRET   DS  XL1                      Return codes\n         DS  H'0'                     Reserved (should be 0)\nSHVBUFL  DS  F                        Length of fetch value buffer\nSHVNAMA  DS  A                        Address of variable name\nSHVNAML  DS  F                        Length of variable name\nSHVVALA  DS  A                        Address of value buffer\nSHVVALL  DS  F                        Length of value buffer\n*                                      (Set on fetch)\nSHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK\n         SPACE 1\n**********************************************************************/\n*   SHARED VARIABLE REQUEST BLOCK - function codes                   */\n**********************************************************************/\n         SPACE 1\nSHVFETCH EQU   C'F'            Copy value of shared variable\nSHVSTORE EQU   C'S'            Set variable from given value\nSHVDROPV EQU   C'D'            Drop variable\nSHVSYFET EQU   C'f'            Symbolic name retrieve\nSHVSYSET EQU   C's'            Symbolic name set\nSHVSYDRO EQU   C'd'            Symbolic name drop\nSHVNEXTV EQU   C'N'            Fetch \"next\" variable\nSHVPRIV  EQU   C'P'            Fetch private information\n         SPACE 1\n**********************************************************************/\n*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */\n**********************************************************************/\n        SPACE 1\nSHVCLEAN EQU   X'00'           Execution was OK\nSHVNEWV  EQU   X'01'           Variable did not exist\nSHVLVAR  EQU   X'02'           Last variable transferred (\"N\")\nSHVTRUNC EQU   X'04'           Truncation occurred for \"Fetch\"\nSHVBADN  EQU   X'08'           Invalid variable name\nSHVBADV  EQU   X'10'           Invalid value specified\nSHVBADF  EQU   X'80'           Invalid function code (SHVCODE)\n         SPACE 1\n**********************************************************************/\n*        R15 return codes                                            */\n**********************************************************************/\n         SPACE 1\nSHVRCOK  EQU    0              Entire Plist chain processed\nSHVRCINV EQU   -1              Invalid entry conditions\nSHVRCIST EQU   -2              Insufficient storage available\n         SPACE 1\nSIZDATD  EQU   *-DATD\n         END\n./ ADD NAME=XTSEXEC  0100-07332-07332-0900-01723-01723-00000-SEB\n         SPLEVEL SET=2\n         TITLE 'XTSEXEC - RUN-TIME TSO COMMAND OR CLIST EXECUTOR'\n***********************************************************************\n*                                                                     *\n* XTSEXEC - Run-time executor of TSO command or CLIST.                *\n*                                                                     *\n*          This linklist-resident routine is LINKed to from the CCF   *\n*          subroutine XCLIST.  The code herein used to be part of the *\n*          XCLIST routine in CCF.LINK.LOAD, but has been separated    *\n*          to facilitate system-dependent enhancements, upgrades and  *\n*          testing.  The XCLIST in CCF.LINK.LOAD merely issues a LINK *\n*          to this routine, passing the contents of register 1 thru.  *\n*                                                                     *\n*          Adjustments to support various features of TSO/Extensions  *\n*          are expected throughout the life of this module.           *\n*                                                                     *\n* The XCLIST subroutine is invoked as follows:                        *\n*                                                                     *\n* From PL/1:                                                          *\n*                                                                     *\n*    DCL XCLIST EXT ENTRY(CHAR(*) VAR) OPTIONS(ASSEMBLER RETCODE);    *\n*    CALL XCLIST ('CLISTNAME CLISTOPERANDS ETC.');                    *\n*                                                                     *\n* From FORTRAN:                                                       *\n*                                                                     *\n*      INTEGER*2    ILEN                                              *\n*      INTEGER*4    IRC                                               *\n*      INTEGER*4    XCLIST                                            *\n*      CHARACTER*2  CMDLEN                                            *\n*      CHARACTER*80 CMD                                               *\n*      DATA ILEN/80/                                                  *\n*      EQUIVALENCE (ILEN,CMDLEN)                                      *\n*      CMD = 'WHATEVER YOUR COMMAND IS'                               *\n*      IRC = XCLIST(CMDLEN // CMD)                                    *\n*C     ... IRC IS THE RETURN CODE FROM THE COMMAND.                   *\n*                                                                     *\n* Input is a PL/1 varying-length character string (you know, a        *\n* halfword containing the command length followed by the command).    *\n*                                                                     *\n* The return code from the last command executed is returned to       *\n* the calling program.                                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  LINKAGE EDITOR ATTRIBUTES:  REENTRANT, REUSABLE                    *\n*  AMODE:  ANY     RMODE: ANY                                         *\n*  MACRO LIBRARIES REQUIRED:  DST1.AMODGEN                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n*   R3  -->  CPPL (COMMAND PROCESSOR PARAMETER LIST)                  *\n*   R4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *\n*   R5  -->  CBUF (COMMAND BUFFER)                                    *\n*   R6  -->  (available)                                              *\n*   R7  -->  ADDRESS OF OUR INPUT STACK                               *\n*   R8  -->  STATIC BASE REGISTER FOR PUTLINE SUBROUTINE              *\n*   R9  -->  SECONDARY STATIC BASE REGISTER                           *\n*   R10 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 0                      *\n*   R11 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 1                      *\n*   R12 -->  PRIMARY STATIC BASE REGISTER                             *\n*   R13 -->  SAVE AREA POINTER                                        *\n*                                                                     *\n* NOTE: REGISTER USAGE IN EXIT ROUTINES MAY DEVIATE FROM THE ABOVE.   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*                                                                     *\n* 05/02/89 - Born out of the ashes of XCLIST (SEB1525).               *\n*            Contains code to process commands under all versions of  *\n*            TSO/Extensions for MVS/XA.                               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nXTSEXEC  CSECT\nXTSEXEC  AMODE ANY\nXTSEXEC  RMODE ANY\n         SAVE  (14,12),,XTSEXEC_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         LA    R9,4095(,R12)\n         LA    R9,1(,R9)\n         USING XTSEXEC,R12,R9\n         L     R3,0(,R1)           SAVE PARAMETER LIST ADDRESS\n         XR    R11,R11             CLEAR SUBPOOL 1 STORAGE REGISTER\n         LA    R0,SIZDATD0         GET LENGTH OF SUBPOOL 1 STORAGE\n         GETMAIN R,LV=(0),LOC=BELOW GET SUBPOOL 1 STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R10,R1              ADDRESS SUBPOOL 0 STORAGE\n         USING DATD0,R10\n         SPACE\n*\n* BUILD CPPL FROM SYSTEM CONTROL BLOCKS\n*\n         USING PSA,0\n         L     R15,PSATOLD          GET TCB ADDRESS\n         USING TCB,R15\n         L     R15,TCBJSCB          GET JSCB ADDRESS\n         USING IEZJSCB,R15\n         L     R15,JSCBACT          GET ADDRESS OF ACTIVE JSCB\n         L     R15,JSCBPSCB         GET ADDRESS OF PSCB\n         LTR   R15,R15             IF THERE'S NO PSCB\n         BNZ   PSCBOK              THEN...\n         LA    R1,NTSOMSG           Issued in non-TSO environment\n         WTO   MF=(E,(1))           Write to programmer\n         ABEND 1500                 AND BLOW UP, NO DUMP REQUIRED\n         SPACE 1\nPSCBOK   DS    0H\n         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS\n         USING PSCB,R15\n         MVC   CPPLUPT,PSCBUPT      SAVE UPT ADDRESS\n         L     R15,PSCBRLGB         GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,R15\n         L     R4,RLGBECT           GET ADDRESS OF ECT\n         ST    R4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE\n         USING ECT,R4\n         SPACE 2\n*\n* Locate the LWA (logon work area) to find the addresses of the TSO\n* tables that define which TSO commands can be accessed and how.\n*\n         L     R15,PSAAOLD         Get ASCB address\n         USING ASCB,R15\n         L     R15,ASCBASXB        Get ASXB address\n         USING ASXB,R15\n         L     R2,ASXBLWA          Get LWA address\n         USING LWA,R2\n         CLC   LWAPECT(4),CPPLECT  Check that ECT addresses match\n         BE    ECTSOK\n         LA    R1,NECTMSG           ECT pointer mismatch\n         WTO   MF=(E,(1))           Write to programmer\nECTSOK   DS    0H\n         L     R15,LWATNS          Get address of IKJEFTNS\n         ST    R15,D0NSADDR        (TSO commands invalid in background)\n         L     R15,LWATE2          Get address of IKJEFTE2\n         ST    R15,D0E2ADDR        (TSO commands that run authorized)\n         L     R14,CPPLUPT\n         L     R15,CPPLECT\n         LA    R0,D0ECB\n         STM   R14,R0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST\n         L     R1,CPPLPSCB\n         LA    R2,DAPB2C\n         STM   R14,R2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST\n         LA    R0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE\n         SLL   R0,16               SHIFT INTO LEFT HALF FOR DAIR CB\n         STCM  R0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD\n         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS\n         MVC   DA2CDDN+1(7),DA2CDDN\n         MVC   D0BLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK\n         MVC   D0ATTACH(LATTACHL),LATTACH  SET UP ATTACH LIST FORM\n         MVC   PTPB(12),LPUTLINE           SET UP PUTLINE LIST FORM\n         MVC   PGPB(LPUTGETL),LPUTGET      SET UP PUTGET LIST FORM\n         MVC   D0ESTAE(LESTAEL),LESTAE     SET UP ESTAE LIST FORM\n         MVC   D0STAX(LSTAXL),LSTAX        SET UP STAX LIST FORM\n         LA    R0,1\n         LA    R1,D0MSGHDR\n         XR    R2,R2\n         STM   R0,R2,D0MSGOLD      INITIALIZE PUTLINE WORK AREA\n         LA    R1,D0PGHDR\n         STM   R0,R1,D0PGOLD       INITIALIZE PUTGET MODE MSG AREA\n         LA    R1,D0PGOLD\n         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    R1,D0MSGOLD\n         ST    R1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    R0,D0CMDECB\n         LA    R1,D0ATNECB\n         STM   R0,R1,D0ECBLST      INITIALIZE ECB LIST\n         OI    D0ECBLST+4,X'80'\n*** NOTE: R2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.\n         ST    R2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE\n         ST    R2,D0RETCD          INITIALIZE RETURN CODE TO ZERO\n         MVI   D0RETURN,D0RETNO    Initialize returning status to NO\n         SPACE\n***********************************************************************\n* Before setting up handlers, save current state so that it can be    *\n* restored if things get interrupted.                                 *\n***********************************************************************\n         SPACE\n         MVC   D0CMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND\n         L     R2,ECTIOWA          GET ADDRESS OF ORIGINAL INPUT STACK\n         ST    R2,D0SVIOA          SAVE INPUT STACK IN OUR WORK AREA\n         LA    R0,PUTLINE          ADDRESS OF PUTLINE SUBROUTINE\n         ST    R0,D0PLADDR         SAVE IT FOR EXIT ROUTINES\n         SPACE\n***********************************************************************\n* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *\n* NOTE: THE DATD0 DSECT IS PASSED TO BOTH ROUTINES.  SINCE THE        *\n*       ADDRESS OF DATD0 IS IN R10, THAT REGISTER IS USED AS THE      *\n*       PARAMETER ADDRESS IN THE ESTAE AND STAX MACRO INSTRUCTIONS.   *\n***********************************************************************\n         SPACE\n         LA    R14,STAEEXIT\n         ESTAE (R14),PARAM=(R10),MF=(E,D0ESTAE)\n         LTR   R15,R15             IF ESTAE FAILED,\n         BZ    ESTAEOK             THEN\n         LA    R1,=C'ESTAE'         BLOW UP\n         LA    R0,5\n         B     ERROR\nESTAEOK  OI    D0FLAGS,D0ESTON     ELSE INDICATE ESTAE IS ACTIVE\n         LA    R14,STAXEXIT\n         STAX  (R14),USADDR=(R10),REPLACE=NO,MF=(E,D0STAX)\n         CH    R15,=H'4'           IF STAX FAILED,\n         BNH   STAXOK              THEN\n         LA    R1,=C'STAX'          BLOW UP\n         LA    R0,4\n         B     ERROR\nSTAXOK   OI    D0FLAGS,D0STXON     ELSE INDICATE STAX IS ACTIVE\n         EJECT\n***********************************************************************\n* Determine which version of TSO/Extensions is active.                *\n* Reference: TSO/Extensions Version 2 Programming Services (SC28-1875 *\n*            Chapter 2. Considerations for Using TSO/E Services       *\n*            Determining the Version and Release of TSO/E Installed   *\n***********************************************************************\n         SPACE 1\n         MVI   D0TSOE,C'0'         Initialize TSO/E version to (none)\n         L     R15,X'10'           Get address of CVT\n         L     R15,CVTTVT-CVT(,R15) Get address of TSVT\n         LTR   R15,R15             If there is none,\n         BZ    TSOEV0              then don't change it\n         USING TSVT,R15            Else set it...\n         MVC   D0TSOE,TSVTLVER     C'1' = version 1, C'2' = version 2\n         SPACE 1\nTSOEV0   DS    0H\n         SPACE 1\n***********************************************************************\n* ALLOCATE SUBPOOL 1 STORAGE FOR SCAN SERVICE ROUTINE                 *\n***********************************************************************\n         SPACE\n         GETMAIN R,LV=SIZDATD1,SP=1,LOC=BELOW GET SUBPOOL 1 STORAGE\n         LR    R11,R1              ADDRESS SUBPOOL 1 STORAGE\n         USING DATD1,R11\n         EJECT\n***********************************************************************\n* ALLOCATE SUBPOOL 1 STORAGE FOR INITIAL COMMAND BUFFER               *\n***********************************************************************\n         SPACE\n         LA    R2,4                ADD 4 TO ...\n         AH    R2,0(,R3)            LENGTH OF COMMAND STRING\n         LA    R0,1                GET SUBPOOL NUMBER\n         SLL   R0,24               SHIFT TO HIGH ORDER BYTE\n         ALR   R0,R2               ADD IN LENGTH\n         AH    R0,=Y(7+8)          ROUND TO DOUBLEWORD BOUNDARY\n         N     R0,=F'-8'            SO THAT WE CAN\n         LR    R14,R0                PAD IT AND SAVE IT FOR MVCL\n         GETMAIN R,LV=(0),LOC=BELOW GET SUBPOOL 1 STORAGE\n         LR    R5,R1               FOR INITIAL COMMAND BUFFER\n         LR    R15,R14             GET LENGTH OF GETMAINED BUFFER\n         SH    R15,=H'4'           MINUS 4 FOR PREFIX\n         LA    R14,4(,R5)          GET ADDRESS OF OUTPUT BUFFER TEXT\n         LA    R0,2(,R3)           GET ADDRESS OF INPUT COMMAND STRING\n         LH    R1,0(,R3)           GET LENGTH OF INPUT COMMAND STRING\n         MVCL  R14,R0              MOVE COMMAND STRING TO THE BUFFER\n*                                  (INCLUDING NULL PADDING)\n         SLL   R2,16               SHIFT BUFFER LENGTH INTO LEFT HALF\n         ST    R2,0(,R5)           CREATE COMMAND BUFFER PREFIX\n         SPACE\n         L     R14,CPPLUPT\n         L     R15,CPPLECT\n         LA    R0,D0ECB\n         LA    R1,D1CSFLG\n         LA    R2,CSOA\n         STM   R14,R2,CSPL         SET UP IKJSCAN PARAMETER LIST\n         MVI   D1CSFLG,0           PREPARE TO SYNTAX CHECK COMMAND\n         SPACE\n***********************************************************************\n* PREPARE TO INVOKE COMMANDS BY SAVING THE CURRENT INPUT STACK AND    *\n* INITIALIZING IT TO A TERMINAL ELEMENT (A LA ISPF).                  *\n***********************************************************************\n         SPACE\n         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later,\n         BNL   INITSTK2            then do it the TSO/E Version 2 way\n*                                  else do it the TSO/E Version 1 way\n         OI    D0FLAGS,D0STKMOD    INDICATE INPUT STACK ADDR ALTERED\n         XR    R0,R0               MAKE A ZERO\n         ST    R0,ECTIOWA          CLEAR INPUT STACK ADDRESS\n         ST    R0,D0ECB            CLEAR ECB FOR STACK\n*\n* SET UP A TERMINAL ELEMENT AS THE BOTTOM ELEMENT OF NEW INPUT STACK\n*\n         MVC   D0STACK(STKINITL),STKINIT Set up stack macro form\n         STACK PARM=D0STACK,MF=(E,IOPL)\n         LTR   R15,R15             IF STACK SUCCESSFUL,\n         BZ    STACKOK             THEN TERMINATE OUR PROCESSING.\n         LA    R1,=C'STACK DATASET=*' ELSE BLOW UP\n         LA    R0,15\n         B     ERROR\n         SPACE\nSTACKOK  DS    0H\n         SPACE\n***********************************************************************\n* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *\n* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *\n* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *\n* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *\n* NOTE THAT WE CAN'T DO THIS \"LEGALLY\" BY USING THE STACK MACRO TO    *\n* SET UP SYSTSPRT AS THE BOTTOM ELEMENT, SINCE THAT WOULD CAUSE IT    *\n* TO BE REOPENED FOR OUTPUT AND PREVIOUS TSO OUTPUT WOULD BE LOST.    *\n***********************************************************************\n         SPACE\n         L     R2,D0SVIOA          Get address of original input stack\n         L     R7,ECTIOWA          GET ADDRESS OF OUR NEW INPUT STACK\n         L     R14,4(,R7)          GET ADDRESS OF OUR BOTTOM ELEMENT\n         L     R15,4(,R2)          GET ADDRESS OF THEIR BOTTOM ELEMENT\n         MVC   0(4,R14),0(R15)     MOVE THEIR ELEMENT TO OUR ELEMENT\n         B     AINITSTK            Else...\n         SPACE 1\nINITSTK2 DS    0H                  Set input stack for TSO/E Version 2\n*\n***********************************************************************\n* Make a new input stack by issuing STACK ENVIRON=CREATE, which makes *\n* a new ECT and a new IOWA.  We don't use the new ECT, but we do use  *\n* the new IOWA, altering the current ECT to point to it.              *\n***********************************************************************\n*\n         MVC   D0STACK2(STKCREAL),STKECREA Set up stack macro form\n         XC    D0ECB,D0ECB         Clear ECB\n         STACK PARM=D0STACK2,MF=(E,IOPL) Stack ENVIRON=CREATE\n         LTR   R15,R15             If STACK failed,\n         BZ    ENVCREOK            then blow up\n         LA    R1,=C'STACK ENVIRON=CREATE'\n         LA    R0,20\n         B     ERROR\nENVCREOK DS    0H                  STACK created new ECT...\n*\n***********************************************************************\n* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *\n* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *\n* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *\n* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *\n***********************************************************************\n*\n         OI    D0FLAGS,D0STKMOD    Indicate input stack addr altered\n         L     R15,D0STACK2+STPBECTA-STPB Get address of new ECT\n         ST    R15,D0NEWECT               Save it\n         MVC   ECTIOWA(4),ECTIOWA-ECT(R15) Copy IOWA pointer to ours\n*\n* Put a barrier element on the stack.\n*\n         MVC   D0STACK2(STKBARRL),STKBARR Set up stack list form\n         XC    D0ECB,D0ECB         Clear ECB\n         STACK PARM=D0STACK2,MF=(E,IOPL) STACK BARRIER=*\n         LTR   R15,R15             IF STACK UNSUCCESSFUL,\n         BZ    BARRIERD            THEN TERMINATE OUR PROCESSING.\n         LA    R1,=C'STACK BARRIER=*'\n         LA    R0,15\n         B     ERROR\nBARRIERD DS    0H\n*\n* Use PUTGET SUBSTACK=YES in conjunction with the barrier.\n*\n         MVC   PGPB(LPUTSUBL),LPUTSUB Set up PUTGET SUBSTACK=YES form\n         LA    R1,D0PGOLD\n         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK\n         SPACE 1\nAINITSTK DS    0H                  ECT ready with new stack\n         SPACE\n***********************************************************************\n* THE COMMAND BUFFER PASSED TO US IS SCANNED AS A TSO COMMAND, THE    *\n* FIRST OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR     *\n* CLIST, AND IF SO, IT IS THEN INVOKED.                               *\n***********************************************************************\n         SPACE\n         ST    R5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS\n         MVC   D0OFFSET,2(R5)      SAVE POSSIBLE CLIST NAME OFFSET\n         LR    R1,R5               POINT TO COMMAND BUFFER\n         BAL   R14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER\n         B     GOSCAN(R15)         BRANCH BASED ON RETURN CODE\nGOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME\n         B     RETURN              RC=4 - NO COMMAND NAME, RETURN NIL\n         B     SCAN8               RC=8 - INVALID COMMAND NAME\n         LH    R15,D0SCANRC        RC=12 - SCAN ERROR\n         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    R0,4\n         B     ERROR\n         SPACE\nSCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    R1,SYNMSG\n         LA    R0,L'SYNMSG\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         B     RETURN\n         SPACE\nSCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK\n         BAL   R14,CKCMD           CHECK EXISTENCE OF COMMAND\n         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         LTR   R15,R15             IF COMMAND IS NOT SUPPORTED\n         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT\n         BAL   R14,ATTACH          ELSE ATTACH THE COMMAND\n         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         B     PROCXC              GO PROCESS ADDITIONAL STACKED CMD'S\n         EJECT\nRETURN   DS    0H\n         SPACE\n***********************************************************************\n*           *** RETURN TO CALLING PROGRAM ***                         *\n*         CLEAR OUR STACK, RESTORE ORIGINAL ONE,                      *\n*                 FREE STORAGE AND EXIT                               *\n***********************************************************************\n         SPACE\n         CLI   D0RETURN,D0RETYES   If we're already returning,\n         BNE   NORETYES            then...\n         LA    R1,RETYMSG           Attempt to return again (literally)\n         WTO   MF=(E,(1))           Write to programmer\n         ABEND 1501,DUMP            Abend (stack error or something)\nNORETYES DS    0H\n         MVI   D0RETURN,D0RETYES   Indicate we are returning\n         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,\n         BZ    AFTFREE1            THEN\n         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE\n         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED\nAFTFREE1 DS    0H\n         TM    D0FLAGS,D0STKMOD    IF INPUT STACK ADDRESS WAS ALTERED,\n         BZ    AFTSTKRS            THEN\n         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later\n         BNL   FREESTK2            then unstack the new way\n*                                  else unstack the old way\nSTKCHECK DS    0H                   CHECK CURRENT INPUT STACK\n         CLC   0(4,R7),4(R7)        IF TOP ELEMENT NOT = BOTTOM ELEMENT\n         BE    STKCLRD              THEN\n         LA    R1,FLUSHTOP           CALL STACK TO FLUSH TOP ELEMENT\n         BAL   R14,FLUSH             UNTIL\n         B     STKCHECK              ALL STACK ELEMENTS ARE CLEARED.\nSTKCLRD  DS    0H                  WHEN STACK IS CLEARED...\n*\n* NOTE THAT WE DON'T PROCESS THE BOTTOM ELEMENT OF OUR STACK VIA STACK!\n* IT CANNOT BE DELETED IF IT IS A TERMINAL ELEMENT, AND IF IT IS A\n* DATASET ELEMENT WE DEFINITELY DON'T WANT TO CLOSE IT, SO WE JUST\n* LET IT DISAPPEAR (UN)NATURALLY.\n*\n         B     AFTSTKRS\n         SPACE 1\nFREESTK2 DS    0H                  Unstack the TSO/E Version 2 way...\n         MVC   D0STACK2(STKDELBL),STKDELB\n         XC    D0ECB,D0ECB\n         STACK PARM=D0STACK2,MF=(E,IOPL)\n         LTR   R15,R15\n         BZ    AFTSTKDB\n         LA    R1,=C'STACK DELETE=BARRIER'\n         LA    R0,20\n         B     ERROR\n         SPACE 1\nAFTSTKDB DS    0H\n*\n***********************************************************************\n* Clear things out by issuing STACK ENVIRON=DESTROY.  This SHOULD     *\n* have the effect of deleting all the elements from the IOWA that     *\n* we have been using.  Then restore the old IOWA pointer to the ECT.  *\n***********************************************************************\n*\n         MVC   D0STACK2(STKDESTL),STKEDEST Set up stack macro form\n         L     R15,D0NEWECT               Get address of new ECT\n         ST    R15,D0STACK2+STPBECTA-STPB Store into stack parm list\n         ST    R15,IOPLECT         Store into IOPL for STACK to see\n         XC    D0ECB,D0ECB         Clear ECB\n         STACK PARM=D0STACK2,MF=(E,IOPL) Stack ENVIRON=DESTROY\n         LTR   R15,R15             If STACK failed,\n         BZ    ENVDESOK            then blow up\n*                                  (but before blowing up, patch up)\n         MVC   D0BADECT,IOPLECT     Save address of bad? model ECT\n         MVC   D0BADIOW,ECTIOWA     Save address of bad? IOWA\n         MVC   IOPLECT,CPPLECT      Restore our ECT pointer\n         MVC   ECTIOWA(4),D0SVIOA   RESTORE ORIGINAL INPUT STACK ADDR\n         NI    D0FLAGS,255-D0STKMOD INDICATE INPUT STACK RESTORED\n*                                  (now things are patched up...)\n         LA    R1,=C'STACK ENVIRON=DESTROY'\n         LA    R0,21\n         B     ERROR\nENVDESOK DS    0H                  STACK back to normal, almost...\n         MVC   IOPLECT,CPPLECT     Restore our ECT pointer\n         SPACE 1\nAFTSTKRS DS    0H                  Unstacked, one way or the other\n         SPACE 1\n         MVC   ECTIOWA(4),D0SVIOA   RESTORE ORIGINAL INPUT STACK ADDR\n         NI    D0FLAGS,255-D0STKMOD INDICATE INPUT STACK RESTORED\n         TM    D0FLAGS,D0ECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,\n         BZ    AFTCMDRS            THEN\n         MVC   ECTPCMD(16),D0CMDS   RESTORE ECTPCMD AND ECTSCMD.\nAFTCMDRS DS    0H\n         TM    D0FLAGS,D0STXON     IF STAX IS ACTIVE\n         BNO   OFFSTAX             THEN\n         STAX  ,                    CANCEL STAX\nOFFSTAX  DS    0H\n         TM    D0FLAGS,D0ESTON     IF ESTAE IS ACTIVE\n         BNO   OFFESTAE            THEN\n         ESTAE 0                    CANCEL ESTAE\nOFFESTAE DS    0H\n         SPACE\nFINALRET DS    0H\n         L     R15,D0RETCD         PICK UP RETURN CODE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        PASS BACK RETURN CODE IN R15\n         ST    R15,20(,R13)        PASS BACK RETURN CODE IN R0 FOR FTN\n         FREEMAIN R,LV=SIZDATD0,A=(1)  FREE SUBPOOL 0 STORAGE\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nLPUTLINE PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)\nLPUTGET  PUTGET  MF=L,OUTPUT=(*-*,,MODE)\nLPUTGETL EQU   *-LPUTGET\nLPUTSUB  PUTGET  MF=L,OUTPUT=(*-*,,MODE),SUBSTACK=YES\nLPUTSUBL EQU   *-LPUTSUB\nSTKINIT  STACK MF=L,DATASET=*      STACK TERMINAL ELEMENT LIST FORM\nSTKINITL EQU   *-STKINIT           LENGTH OF STACK LIST FORM\nFLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM\nFLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM\nSTKECREA STACK MF=L,ENVIRON=CREATE  TSO/E Version 2 ECT builder\nSTKCREAL EQU   *-STKECREA          LENGTH OF STACK LIST FORM\nSTKEDEST STACK MF=L,ENVIRON=DESTROY TSO/E Version 2 ECT remover\nSTKDESTL EQU   *-STKEDEST          LENGTH OF STACK LIST FORM\nSTKBARR  STACK MF=L,BARRIER=*\nSTKBARRL EQU   *-STKBARR           LENGTH OF STACK LIST FORM\nSTKDELB  STACK MF=L,DELETE=BARRIER\nSTKDELBL EQU   *-STKDELB           LENGTH OF STACK LIST FORM\nLATTACH  ATTACH SF=L,SHSPV=78,SZERO=NO\nLATTACHL EQU   *-LATTACH\nLESTAE   ESTAE MF=L\nLESTAEL  EQU   *-LESTAE\nLSTAX    STAX  MF=L,REPLACE=NO\nLSTAXL   EQU   *-LSTAX\n         SPACE\nMODEDATA DC    Y(MODELEN,0)\nMODEMSG  DC    C' XCLIST'          LEADING BLANK REQUIRED - NO MSGID\nMODELEN  EQU   *-MODEDATA\n         SPACE 1\n         DC    C'0123456789ABCDEF'\nHEXTR    EQU   *-256\n         SPACE\n         LTORG\n         TITLE 'XTSEXEC - STACKED COMMAND PROCESSING'\nPROCXC   DS    0H\n         SPACE\n***********************************************************************\n*               STACKED COMMAND PROCESSING                            *\n*                                                                     *\n* FOR THIS ROUTINE, ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *\n* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *\n* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY REACHING     *\n* THE BOTTOM LEVEL OF THE INPUT STACK.                                *\n*                                                                     *\n* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *\n* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *\n* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *\n* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *\n* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *\n* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *\n* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *\n* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *\n* ORIGINALLY FROM ISPF MODULE ISPCAT (OR CAT).) WHEN THIS SITUATION   *\n* IS DETECTED, THE RETURN CODE FROM PUTGET IS CHECKED; IF THE INPUT   *\n* WAS OBTAINED FROM THE TERMINAL BUT NOT FROM THE BOTTOM LEVEL OF     *\n* THE INPUT STACK, THE PROBABLE EXPLANATION IS THAT A \"TERMIN\"        *\n* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *\n* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *\n* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE EXIT.    *\n*                                                                     *\n* THIS GIVES RISE TO A PROBLEM IN CLISTS THAT CONTAIN TERMIN          *\n* STATEMENTS:  IF CONTROL IS RETURNED TO THE CLIST BY THE USER'S      *\n* ENTRY OF A TERMIN STRING, AND THE CLIST ISSUES NO MORE TSO COMMANDS *\n* BUT DOES SOME CLIST PROCESSING AND TERMINATES, THIS SUBROUTINE HAS  *\n* NO WAY OF KNOWING THAT THE COMMAND RETRIEVED FOLLOWING THE TERMIN   *\n* STATEMENT CAME FROM OUTSIDE THE CLIST UNTIL IT HAS ALREADY BEEN     *\n* RETRIEVED, BY WHICH TIME IT IS TOO LATE TO DO ANYTHING ABOUT IT.    *\n* THEREFORE, CLISTS SHOULD CONTAIN AT LEAST ONE COMMAND (A NULL       *\n* COMMAND IS SUFFICIENT) FOLLOWING RETURN FROM A TERMIN STATEMENT.    *\n* (ISPF AVOIDS THIS PROBLEM BY REFUSING TO SUPPORT TERMIN ENTIRELY.)  *\n*                                                                     *\n***********************************************************************\n         SPACE\n***********************************************************************\n* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *\n* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *\n* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *\n* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *\n***********************************************************************\n         SPACE\n         LTR   R1,R5               GET ADDRESS OF PUTGET BUFFER\n         BZ    XCGET               IF A PUTGET BUFFER EXISTS, THEN...\n         LA    R0,1                 GET SUBPOOL NUMBER\n         SLL   R0,24                SHIFT INTO HIGH-ORDER BYTE\n         AH    R0,0(,R5)            ADD IN LENGTH OF PUTGET BUFFER\n         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER\n         XR    R5,R5                CLEAR PUTGET BUFFER POINTER\n         SPACE\nXCGET    DS    0H\n         SPACE\n         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later\n         BNL   PROC2               then process commands the new way\n*                                  else process commands the old way\n         SPACE\n***********************************************************************\n* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *\n* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK, I.E. THE STACK      *\n* LEVEL AT THIS POINT IS NOT THE SAME AS THE BOTTOM ELEMENT.  SUCH    *\n* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *\n* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSING COMMANDS    *\n* UNTIL THE STACK LEVEL REACHES THE BOTTOM AGAIN.  NOTE THAT ANY      *\n* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *\n* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *\n* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *\n* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *\n***********************************************************************\n         SPACE\n         CLC   0(4,R7),4(R7)       IF TOP STK ELEMENT = BOTTOM ELEMENT\n         BE    ENDCMDS             THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *\n***********************************************************************\n         SPACE\n         XC    D0PGHDR(4),D0PGHDR  SET UP BAD (NULL) MODE MESSAGE\n         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE\n         CH    R15,=H'24'          IF INVALID PARAMETERS ON PUTGET,\n         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..\n         CLC   0(4,R7),4(R7)        IF TOP STK ELEMENT = BOTTOM ELEMENT\n         BE    ENDCMDS              THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *\n***********************************************************************\n         SPACE\n         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE\n         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG                OR\n         CH    R15,=H'24'            INVALID PARAMETERS ON PUTGET,\n         BE    BADPG                  THEN REALLY BAD PUTGET, BLOW UP.\n         CLC   0(4,R7),4(R7)       ELSE IF TOP ELEMENT = BOTTOM ELEMENT\n         BNE   PUTGETOK            THEN (TERMIN ENVIRONMENT NOT VALID)\n         LA    R1,TERMMSG           DISPLAY MESSAGE TELLING USER THAT\n         LA    R0,L'TERMMSG         THE COMMAND WAS NOT EXECUTED SINCE\n         BAL   R14,PUTLINE          IT WASN'T SUPPOSED TO BE RETRIEVED\n         B     ENDCMDS              AND THEN RETURN TO CALLING PGM.\n         SPACE 1\nPROC2    DS    0H                  Process commands the TSO/E V.2 way\n         SPACE 1\n***********************************************************************\n* At this point we are ready to get the next command, but only if a   *\n* new element has been placed on the input stack, I.E. the stack      *\n* level at this point is not the barrier element.  Such can occur if  *\n* we have executed a CLIST or if we have invoked a command that       *\n* stacks other commands.  We keep processing commands until the stack *\n* barrier element is reached.  Note that any error encountered during *\n* a previous pass through this loop will have caused us to issue a    *\n* stack flush, which will result in termination of new stack elements *\n* (and exit from loop) unless the element is a CLIST with             *\n* CONTROL MAIN or CONTROL NOFLUSH active.                             *\n***********************************************************************\n* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *\n***********************************************************************\n         SPACE\n         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE\n         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE\n         CH    R15,=H'40'          IF BARRIER HIT,\n         BE    ENDCMDS             then no more command\n******** B     PUTGETOK            else process command\n         SPACE 1\nPUTGETOK DS    0H\n         CLI   D0STATUS,D0ATTN     IF ATTENTION INTERRUPT OCCURRED,\n         BNE   PGNOATTN            THEN\n         LA    R1,FLUSHTOP          FLUSH THE STACK (EVEN IF\n         BAL   R14,FLUSH             CONTROL NOFLUSH IS ACTIVE)\n         B     PROCXC               AND CONTINUE\n         SPACE\nPGNOATTN DS    0H                  ELSE GO AHEAD AND PROCESS THIS LINE\n         ST    R5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS\n         XC    D0OFFSET,D0OFFSET   SET COMMAND BUFFER OFFSET TO ZERO\n         LR    R1,R5               POINT TO THE COMMAND BUFFER\n         BAL   R14,SCAN            SCAN NEXT OPERAND OF THE COMMAND\n         B     GOSCANX(R15)        BRANCH BASED ON RETURN CODE\nGOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME\n         B     PROCXC              RC=4 - NO COMMAND NAME\n         B     SCANX8              RC=8 - INVALID COMMAND NAME\n         LH    R15,D0SCANRC        RC=12 - SCAN ERROR\n         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    R0,4\n         B     ERROR\n         SPACE\nSCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    R1,SYNMSG\n         LA    R0,L'SYNMSG\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         B     PROCXC\n         SPACE\nSCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK\n         BAL   R14,CKCMD           CHECK VALIDITY OF COMMAND\n         LTR   R15,R15             IF COMMAN IS NOT VALID,\n         BNZ   PROCXC              THEN CONTINUE WITH THE NEXT ONE\n         BAL   R14,ATTACH          ELSE INVOKE THE COMMAND\n         TM    D0FLAGS,D0SUBER     IF SUBROUTINE ERROR,\n         BO    ERROR               THEN GO TO DISPLAY MESSAGE\n         B     PROCXC              ELSE GO TO GET THE NEXT COMMAND\n         SPACE 2\nBADPG    LA    R1,=C'PUTGET'       FATAL PUTGET ERROR\n         LA    R0,6\n         B     ERROR\n         EJECT\nENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS\n         XR    R15,R15\n         ICM   R15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT\n         ST    R15,D0RETCD         SAVE THE RETURN CODE\n         SPACE\n***********************************************************************\n* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *\n* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *\n* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*\n***********************************************************************\n         SPACE\n         B     RETURN              RETURN TO CALLING PROGRAM\n         EJECT\nERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END\n         SPACE\n***********************************************************************\n* MISCELLANEOUS ERROR DISPLAY.                                        *\n* R0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *\n* R1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *\n* R15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *\n***********************************************************************\n         SPACE\n         MVC   D0MSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE\n         LTR   R14,R0              GET LENGTH OF FUNCTION TYPE\n         BNP   AFTFUNC             IF NONE, BYPASS\n         BCTR  R14,0               ELSE REDUCE LENGTH FOR EXECUTE\n         EX    R14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE\nAFTFUNC  LA    R1,D0MSG+L'ERRMSG1+1(R14)  POINT TO NEXT PART OF MESSAGE\n         MVC   0(L'ERRMSG2,R1),ERRMSG2    SET UP SECOND PART OF MESSAGE\n         CVD   R15,D0DOUBLE               CONVERT ERROR CODE TO DISPLAY\n         UNPK  L'ERRMSG2(2,R1),D0DOUBLE\n         OI    L'ERRMSG2+1(R1),X'F0'\n         LA    R0,L'ERRMSG1+L'ERRMSG2+3(R14)  GET LENGTH OF MSG IN R0\n         XR    R1,R1               INDICATE MESSAGE ALREADY IN WORKAREA\n         BAL   R14,PUTLINE         DISPLAY THE MESSAGE\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           FLUSH THE INPUT STACK\n         B     RETURN              RETURN TO CALLING PROGRAM\n         SPACE\nERRMSG1  DC    C'XTS00006 XCLIST/XTSEXEC FAILED, '\nERRMSG2  DC    C' ERROR CODE '\n         SPACE\nMOVEFUNC MVC   D0MSG+L'ERRMSG1(0),0(R1)  MOVE FUNCTION TO ERROR MESSAGE\n         TITLE 'XTSEXEC - SCAN SUBROUTINE'\n***********************************************************************\n* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *\n* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE XTSEXEC COMMAND     *\n* BUFFER.  ON ENTRY R1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *\n* BE SCANNED.  ON RETURN THE FIELD D0COMMND CONTAINS THE OPERAND,     *\n* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *\n* SYNTACTICALLY INVALID.  R15 IS SET TO ZERO IF THE OPERAND IS A      *\n* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *\n* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *\n* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *\n* THE FLAG D0EXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *\n* NO FURTHER OPERANDS IN THE XTSEXEC COMMAND BUFFER FOLLOWING THE     *\n* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *\n***********************************************************************\n         SPACE\nSCAN     DS    0H\n         ST    R14,D0SCAN14        SAVE RETURN REGISTER\n         MVI   D0COMMND,C' '       SET COMMAND NAME FIELD TO BLANKS\n         MVC   D0COMMND+1(7),D0COMMND\n         NI    D0FLAGS,255-D0EXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW\n         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF\n         ST    R1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM\n         XC    D0ECB,D0ECB         CLEAR ECB\n         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER\n         STH   R15,D0SCANRC        SAVE IKJSCAN RETURN CODE\n         LTR   R15,R15             IF SCAN FAILED,\n         BZ    SCANOK              THEN...\n         LA    R15,12               INDICATE SCAN FAILURE\n         B     SCANRET              AND RETURN. ELSE...\nSCANOK   DS    0H                  CHECK RESULTS OF SCAN\n         TM    CSOAFLG,CSOAQM+CSOABAD IF ANY SYNTAX ERROR\n         BNZ   SCANBAD             THEN RETURN INDICATING BAD SYNTAX\n         TM    CSOAFLG,CSOANOC     IF NO COMMAND NAME WAS FOUND,\n         BNO   NOTNOC              THEN...\n         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS\n         LA    R15,4                RETURN INDICATING NOTHING FOUND\n         B     SCANRET             ELSE...\nNOTNOC   DS    0H                  (AN OPERAND EXISTS)\n         LH    R1,CSOALNM          PICK UP LENGTH OF OPERAND\n         LTR   R1,R1               IF LENGTH IS ZERO,\n         BNP   SCANBAD             THEN...\n         L     R15,CSOACNM         GET ADDRESS OF OPERAND\n         BCTR  R1,0                REDUCE OPERAND LENGTH FOR EXECUTE\n         EX    R1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA\n         XR    R15,R15             INDICATE VALID COMMAND NAME\n         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,\n         BZ    *+8                 THEN...\n         OI    D0FLAGS,D0EXEC       INDICATE IMPLICIT EXEC\n         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,\n         BNO   *+8                 THEN...\n         OI    ECTSWS,ECTNOPD       SAY SO IN ECT\n         B     SCANRET             RETURN\nSCANBAD  DS    0H                  SYNTAX ERROR\n         LA    R15,8               RETURN INDICATING BAD SYNTAX\n******** B     SCANRET\nSCANRET  L     R14,D0SCAN14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE 2\nMOVECMD  MVC   D0COMMND(0),0(R15)  MOVE COMMAND NAME TO NAME AREA\n         SPACE\n         LTORG\n         TITLE 'XTSEXEC - CKCMD SUBROUTINE'\nCKCMD    DS    0H\n         SPACE\n         ST    R14,D0CKCM14        SAVE RETURN REGISTER\n         NI    D0FLAGS,255-D0SUBER TURN OFF ERROR INDICATOR\n         NI    D0FLAGS,255-D0AUTH  Also assume not APF authorized\n         TM    D0FLAGS,D0EXEC      IF IMPLICIT %CLIST,\n         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...\n******** CLC   D0COMMND(5),=CL5'TEST '     IF COMMAND = TEST\n******** BE    NGCMD                       THEN REJECT\n         CLC   D0COMMND(8),=CL8'ISPEXEC '  IF COMMAND = ISPEXEC\n         BE    NGCMD                       THEN REJECT\n*\n******** BE    PROCESS_ISPEXEC_COMMAND future enhancement...\n*\n         MVC   D0MODULE,D0COMMND   ELSE SET COMMAND NAME = SAME NAME\n         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         CLC   =C'TIME ',D0MODULE  IF COMMAND = TIME\n         BNE   NOTTIME             THEN\n         MVC   D0MODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTTIME  CLC   =C'CALL ',D0MODULE  IF COMMAND = CALL\n         BNE   NOTCALL             THEN\n******** MVC   D0MODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL\n         MVC   D0MODULE,=CL8'IKJEFG00' SET MODULE NAME = IKJEFG00\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTCALL  CLC   =C'TEST ',D0MODULE  If command = TEST\n         BNE   NOTTEST             then\n         OI    D0FLAGS,D0AUTH       indicate APF authorization required\n         B     TSEVENT              and process without searching.\nNOTTEST  DS    0H\n         SPACE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Before searching for the command, search the table of authorized    *\n* TSO commands to see if it requires APF authorization.  If it does,  *\n* indicate so.  We will still have to search for it.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R15,D0E2ADDR        Get address of IKJEFTE2\n         LA    R1,16(,R15)         Point to first entry\nE2LOOP   DS    0H                  Loop\n         CLI   0(R1),C' '           until blank entry found\n         BE    NOTAUTH              at which point it's not authorized\n         CLC   0(8,R1),D0MODULE     but if we found the module name\n         BE    NEEDAUTH             then mark it authorized\n         LA    R1,8(,R1)            else bump to next entry\n         B     E2LOOP               and continue.\nNEEDAUTH DS    0H                  Here if module is in E2 table\n         OI    D0FLAGS,D0AUTH      Indicate APF authorization required\n*\n* ... we should probably bypass the search - TSO service'll do it NEhow\n*\nNOTAUTH  DS    0H                  Here if module is not authorized\n         SPACE 1\n***********************************************************************\n* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *\n* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *\n* WE WILL EMULATE THE TMP AND ISPF COMMAND SEARCH CODE INSTEAD.       *\n***********************************************************************\n         SPACE\n         DROP  R12,R9              (temporary base reg suppression)\n         STM   R3,R9,32(R13)       SAVE REGISTERS USED BY LPA SEARCH\n         LM    R0,R1,D0MODULE      LOAD COMMAND NAME INTO PARM REGS\n         L     R3,16               R3 = CVT ADDRESS\n         L     R15,X'160'(,R3)     R15 -> LPA DIRECTORY SEARCH ROUTINE\n         BALR  R14,R15             CALL LPA DIRECTORY SEARCH\n***********************************************************************\n* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *\n* TO THE NEXT SEQUENTIAL INSTRUCTION AND R14 IS SET TO ZERO.  IF THE  *\n* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *\n* AT +4 PAST HERE AND R14 IS NONZERO.                                 *\n***********************************************************************\n         LA    R14,0               IF SUCCESSFUL, SET R14 = 0\n         LM    R3,R9,32(R13)       RESTORE REGISTERS USED BY LPA SEARCH\n         USING XTSEXEC,R12,R9      (restore addressability)\n         LTR   R14,R14             IF COMMAND NAME WAS FOUND,\n         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...\n         LA    R0,D0MODULE         SET EPLOC PARAMETER FOR IDENTIFY\n         XR    R1,R1               SET ENTRY ADDRESS PARM FOR IDENTIFY\n         IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND\n         CH    R15,=H'8'           IF RC=8, COMMAND IS IN JPA\n         BE    TSEVENT             SO GO USE IT\n         CH    R15,=H'20'          IF RC=20, COMMAND IS IN JPA\n         BE    TSEVENT             SO GO USE IT\n         BLDL  0,D0BLDL            IF NONE OF THE ABOVE, TRY BLDL\n         LTR   R15,R15             SEE IF BLDL SUCCESSFUL\n         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND\n******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST\n         SPACE\nIMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST\n         MVC   D0MODULE,=CL8'EXEC' SET COMMAND NAME = \"EXEC\"\n         NI    D0FLAGS,255-D0AUTH  Show not APF authorized after all\n         LH    R15,D0OFFSET        PICK UP OFFSET OF CLIST NAME\n         LTR   R15,R15             IF ZERO OFFSET, THEN IGNORE\n         BNP   AFTBLNKX\n         BCTR  R15,0               REDUCE FOR EXECUTE\n         BCTR  R15,0               AND FOR MOVE CHARACTERS\n         MVI   4(R5),C' '          SET BUFFER PRECEDING CLIST NAME\n         EX    R15,MVCBLANK         TO BLANKS\nAFTBLNKX XC    2(2,R5),2(R5)       SET COMMAND BUFFER OFFSET = ZERO\n         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         SPACE\nTSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND\n         SPACE\n***********************************************************************\n* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *\n* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *\n* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *\n* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *\n* AS THIS ROUTINE WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *\n***********************************************************************\n         SPACE\n         L     R1,ECTPCMD\n         L     R15,ECTPCMD+4\n         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND\n         XR    R15,R15             INDICATE COMMAND IS OK\n         B     CKCMDRET            AND RETURN\n         SPACE\nNGCMD    DS    0H                  COMMAND NOT VALID (TEST, ETC.)\n         MVC   D0MSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE\n         MVC   D0MSG+L'TESTMSG1(8),D0COMMND  MOVE IN COMMAND NAME\n         LA    R1,D0MSG+L'TESTMSG1 POINT TO BEGINNING OF NAME\n         LA    R14,8               MAX COUNT FOR NAME LENGTH\nNGLOOP   CLI   0(R1),C' '          SCAN FOR FIRST BLANK\n         BE    NGBLANK              FOLLOWING COMMAND NAME\n         LA    R1,1(,R1)             UNTIL\n         BCT   R14,NGLOOP             LENGTH OF NAME EXHAUSTED\nNGBLANK  DS    0H\n         MVC   0(L'TESTMSG2,R1),TESTMSG2  MOVE END OF MESSAGE\n         LA    R0,L'TESTMSG2(,R1)  END OF MESSAGE\n         LA    R14,D0MSG           MINUS BEGINNING OF MESSAGE\n         SLR   R0,R14              GIVES LENGTH OF MESSAGE\n         XR    R1,R1               INDICATE MESSAGE ALREADY BUILT\n         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    R1,12               SET ECT RETURN CODE TO 12\n         STCM  R1,7,ECTRTCD        AS IF COMMAND NOT FOUND\n         LA    R1,FLUSHALL\n         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK\n         LA    R15,8               INDICATE COMMAND INVALID\nCKCMDRET L     R14,D0CKCM14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nMVCBLANK MVC   5(0,R5),4(R5)       FINISH MOVING BLANKS INTO CMD BUFFER\n         SPACE\nTESTMSG1 DC    C'XTS00002 XCLIST/XTSEXEC DOES NOT SUPPORT THE '\nTESTMSG2 DC    C' COMMAND'\n         SPACE\n         LTORG\n         TITLE 'XTSEXEC - ATTACH SUBROUTINE'\nATTACH   DS    0H\n         SPACE\n***********************************************************************\n*                                                                     *\n* This subroutine does one of the following:                          *\n*                                                                     *\n* (1) If the command requires APF authorization, invokes the TSO      *\n*     Authorized Service Facility to invoke it.                       *\n* (2) Otherwise, attaches the command as a subtask directly.          *\n*                                                                     *\n***********************************************************************\n         SPACE\n         ST    R14,D0ATT14         SAVE RETURN REGISTER\n         SPACE\n         TM    D0FLAGS,D0AUTH      If command requires authorization\n         BO    ATTTSF              then go invoke TSO service facility\n         SPACE\n         XC    D0CMDECB,D0CMDECB   CLEAR ATTACH ECB\n         XC    D0ATNECB,D0ATNECB   CLEAR ATTENTION ECB\n         NI    D0FLAGS,255-D0SUBER CLEAR ERROR FLAG\n         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG\n         NI    ECTSWS2,255-ECTNOQPR ENABLE \"? PROMPT HELP\"\n         LA    R1,CPPL             POINT TO CPPL\n         ATTACH EPLOC=D0MODULE,SF=(E,D0ATTACH),ECB=D0CMDECB,           X\n               ESTAI=(STAIEXIT,DATD0) ATTACH THE COMMAND\n         LTR   R15,R15             IF ATTACH FAILED,\n         BZ    ATTACHOK            THEN\n         LA    R1,=C'ATTACH'        BLOW UP\n         LA    R0,6\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\nATTACHOK DS    0H\n         LR    R2,R1               SAVE TCB ADDRESS\n         USING TCB,R2\n         WAIT  1,ECBLIST=D0ECBLST  WAIT FOR COMPLETION OR ATTENTION\n         MVC   ECTRTCD,TCBCMPC     MOVE TCB COMPLETION CODE TO ECT\n         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED\n         ST    R2,DA2CTCB          SAVE TCB ADDRESS FOR DAIR\n         XC    D0ECB,D0ECB         CLEAR ECB\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE\n         ST    R15,D0DAIRRC        SAVE DAIR RETURN CODE\n         OI    D0FLAGS,D0DETACH    INDICATE DETACH IN PROGRESS\n         LA    R1,DA2CTCB          POINT TO TCB ADDRESS\n         DETACH (1),STAE=YES       DETACH THE COMMAND\n         NI    D0FLAGS,255-D0DETACH INDICATE DETACH NOT IN PROGRESS\n         CH    R15,=H'4'           IF DETACH FAILED,\n         BNH   DETACHOK\n         LA    R1,=C'DETACH'        BLOW UP\n         LA    R0,6\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\n         DROP  R2\nDETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH\n         ICM   R15,15,D0DAIRRC     IF DAIR RETURN CODE NOT ZERO,\n         BZ    DAIROK              THEN...\n         LA    R1,=C'DAIR'          BLOW UP\n         LA    R0,4\n         OI    D0FLAGS,D0SUBER\n         B     ATTRET\nDAIROK   DS    0H\n         SPACE\n         CLI   D0STATUS,D0ATTN     IF COMMAND TERMINATED BY ATTENTION,\n         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK\n         CLI   D0STATUS,D0ABEND    ELSE IF THE COMMAND ABENDED,\n         BNE   ATTRET              THEN\nABFLUSH  OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT\n         LA    R1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH\n         B     FLUSHCMD             AND FLUSH THE INPUT STACK.\nATTFLUSH LA    R1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH\nFLUSHCMD BAL   R14,FLUSH           FLUSH THE INPUT STACK\nATTRET   L     R14,D0ATT14         RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nATTTSF   DS    0H                  Here if command is APF authorized\n         SPACE\n         XR    R0,R0               Make a zero\n         ST    R0,D0TSFRC          Initialize TSO command return code\n         ST    R0,D0TSFRS          Initialize TSO command reason code\n         ST    R0,D0TSFAC          Initialize TSO command abend code\n         LA    R1,TSFFLAGS         Point to flags\n         ST    R1,D0TSFP1          Store parameter 1\n         L     R2,CPPLCBUF         Get address of command buffer\n         LA    R1,4(,R2)           Point to command buffer text\n         ST    R1,D0TSFP2          Store parameter 2\n         LH    R1,0(,R2)           Get length of command buffer\n         SH    R1,=H'4'            Adjust length to length of text\n         ST    R1,D0TSFLEN         Store length\n         LA    R1,D0TSFLEN         Get address of length\n         ST    R1,D0TSFP3          Store parameter 3\n         LA    R1,D0TSFRC          Point to where to store return code\n         ST    R1,D0TSFP4          Store parameter 4\n         LA    R1,D0TSFRS          Point to where to store reason code\n         ST    R1,D0TSFP5          Store parameter 5\n         LA    R1,D0TSFAC          Point to where to store abend code\n         ST    R1,D0TSFP6          Store parameter 6\n         OI    D0TSFP6,X'80'       Set VL bit\n         LA    R1,D0TSFP1          Point to parameter list\n         L     R15,X'10'           Get address of CVT\n         L     R15,CVTTVT-CVT(,R15) Get address of TSVT\n         L     R15,TSVTASF-TSVT(,R15) Get address of IKJEFTSR\n         BALR  R14,R15             Call IKJEFTSR\n         SPACE\n* OK, now process all those godawful return codes.  Who designed this!\n         SPACE\n         B     TSFRC(R15)          Branch depending on return code\nTSFRC    B     TSFRC0              0 = OK\n         B     TSFRC4              4 = nonzero return code from command\n         B     TSFRC8              8 = attention interrupt\n         B     TSFRC12             12 = abend\n         B     TSFRC16             16 = parm address in protected stg.\n         B     TSFRC20             20 = error in parameter list\n         B     TSFRC24             24 = unexpected TSO failure\n         B     TSFRC28             28 = AMODE 24 but parms are AMODE 31\n         SPACE\nTSFRC0   EQU   ATTRET              0 = OK\nTSFRC4   EQU   ATTRET              4 = nonzero return code from command\n         SPACE\nTSFRC8   DS    0H                  8 = attention interrupt\n         SPACE\n         MVC   D0MSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   D0MSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE\n         LA    R0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG\n         XR    R1,R1               INDICATE MESSAGE SET UP\n         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE\n         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE\n         B     ATTFLUSH            Return to flush stack for attn & ret\n         SPACE\nTSFRC12  DS    0H                  12 = abend\n         SPACE\n         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED\n         MVC   D0ABCODE(3),D0TSFAC+1 STORE ABEND CODE\n         SPACE\n***********************************************************************\n* DISPLAY \"ENDED DUE TO ERROR\" MESSAGE                                *\n***********************************************************************\n         SPACE\n         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE\n         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095\n         BNH   TSFUSRAB                     THEN MUST BE A SYSTEM ABEND\n         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO\n         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN\n         MVZ   D0SYSTEM(3),=X'000000'\n         TR    D0SYSTEM(3),=C'0123456789ABCDEF'\n         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE\n         B     TSFANYAB                     GO TO DISPLAY IT\nTSFUSRAB MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND\n         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         XR    R0,R0\n         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE\n         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY\n         UNPK  D0USER(4),D0DOUBLE\n         OI    D0USER+3,X'F0'\n         LA    R0,D0USERL                   GET LENGTH OF MESSAGE\nTSFANYAB DS    0H\n         XR    R1,R1               INDICATE MESSAGE SET UP\n         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE\n         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE\n         B     ABFLUSH\nTSFRC16  DS    0H                  16 = parm address in protected stg.\nTSFRC20  DS    0H                  20 = error in parameter list\nTSFRC24  DS    0H                  24 = unexpected TSO failure\nTSFRC28  DS    0H                  28 = AMODE 24 but parms are AMODE 31\n         ABEND (15),DUMP           Abend for now...\n         SPACE\nTSFFLAGS DS    0F                  First parm to IKJEFTSR (flags)\n         DC    X'0000'             First 2 bytes must be zeroes\n         DC    X'01'               Take a dump in case of ABEND\n         DC    X'01'               Invoke as command, not as CLIST\n*                                  (so stacked commands are handled\n*                                   by us instead of IKJEFTSR)\n         TITLE 'XTSEXEC - PUTGET SUBROUTINE'\n***********************************************************************\n* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *\n* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *\n* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *\n* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *\n* USER IS IN A CLIST AND THE \"NOPAUSE\" PROFILE OPTION IS ACTIVE), IT  *\n* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *\n* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *\n* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *\n* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS \"TRICK\" WAS   *\n* USED IN ISPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.         *\n*                                                                     *\n* UPON RETURN, R5 CONTAINS THE ADDRESS OF THE INPUT BUFFER RETURNED   *\n* BY PUTGET IF THE RETURN CODE IS 0 OR 4, ELSE R5 CONTAINS ZERO.      *\n*                                                                     *\n***********************************************************************\n         SPACE\nPUTGET   DS    0H\n         ST    R14,D0PG14          SAVE RETURN REGISTER\nPGRETRY  DS    0H\n         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG\n         XR    R5,R5               SET PUTGET BUFFER ADDRESS TO ZERO\n         ST    R5,D0ECB            CLEAR ECB\n         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET\n         CH    R15,=H'24'          IF RETURN CODE GREATER THAN 24,\n         BH    PGERROR              THEN BLOW UP\n         B     PGGO(R15)           ELSE PROCESS EACH POSSIBLE R.C.\nPGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL\n         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST\n         B     PUTGET8         8 = ATTENTION INTERRUPTION\n         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE\n         B     PGERROR        16 = ERROR\n         B     PGERROR        20 = ERROR\n         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT\n         SPACE\nPUTGET8  MVI   D0STATUS,D0ATTN     RC=8: INDICATE ATTENTION INTERRUPT\n         B     PGRETURN              AND RETURN\nPUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,\n         BO    PGERROR                    THEN UNRECOVERABLE ERROR\n         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN\n         B     PGRETRY                AND REISSUE PUTGET\nPGERROR  DS    0H                  BAD RETURN CODE?\n         CH    R15,=H'40'          If RC = 40 (SUBSTACK found barrier)\n         BE    PGRETURN            then return OK, caller will handle\n         OI    D0FLAGS,D0SUBER     Else bad RC, unrecoverable error\n         B     PGRETURN            SO JUST RETURN.\nPGGOTLN  L     R5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER\nPGRETURN L     R14,D0PG14          RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         TITLE 'XTSEXEC - PUTLINE SUBROUTINE'\n***********************************************************************\n* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *\n* PUTLINE SERVICE ROUTINE.  AT ENTRY R1 CONTAINS THE ADDRESS OF THE   *\n* MESSAGE TO BE DISPLAYED, AND R0 CONTAINS THE LENGTH OF THE MESSAGE. *\n* IF R1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *\n* D0MSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *\n* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *\n* STRIPPED OFF BY PUTLINE ANYHOW.                                     *\n* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *\n* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *\n* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *\n***********************************************************************\n         SPACE\nPUTLINE  DS    0H\n         ST    R14,D0PUTL14        SAVE RETURN REGISTER\n         BALR  R8,0                SET UP LOCAL ADDRESSABILITY\n         USING *,R8\n         DROP  R12,R9\n         LTR   R15,R0              LOAD LENGTH VALUE\n         BZ    PUTLRET             IF ZERO, DON'T DO ANYTHING\n         BM    PUTLCMD             If negative, displaying command buf\n         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTE\n         LTR   R1,R1               IF R1 IS ZERO,\n         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...\n         EX    R15,MOVEPUT         MOVE MESSAGE TO WORK AREA\n         B     PUTIT               Go to it\nPUTLCMD  DS    0H                  Here to display a command\n         LCR   R15,R15             Make length positive again\n         MVI   D0MSG,C' '          Blank to stop message ID stripping\n         CH    R15,=Y(L'D0MSG-1)   To maximum length\n         BNH   PUTLMC\n         MVC   D0MSG+1(L'D0MSG-1),0(R1) Move most of command to W/A\n         MVC   D0MSG+L'D0MSG-3(3),=CL3'...'  Ellipsis\n         LA    R15,L'D0MSG-1-1+1   Add 1 for initial blank\n         B     PUTIT               Go do it\nPUTLMC   DS    0H                  Else\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,MOVEPUTC        Move command to work area\n         LA    R15,1(,R15)         Add 1 for initial blank\n******** B     PUTIT               Go do it\nPUTIT    DS    0H\n         LA    R15,5(,R15)         RESTORE LENGTH + 4 FOR HEADER\n         SLL   R15,16              SHIFT LENGTH INTO LEFT HALF OF HDR\n         STCM  R15,15,D0MSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR\n         XC    D0ECB,D0ECB         CLEAR ECB\n         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE\n         LTR   R15,R15             IF PUTLINE OK\n         BZ    PUTLRET             THEN RETURN\n         CH    R15,=H'8'           ELSE IF ATTENTION INTERRUPT\n         BNE   PUTERROR            THEN\n         MVI   D0STATUS,D0ATTN      INDICATE SO\n         B     PUTLRET             ELSE PUTLINE ERROR\nPUTERROR DS    0H\n         MVC   D0MSGBUF(L'BADPUT),BADPUT  Move message to 24-bit stg\n         LA    R1,D0MSGBUF\n         LA    R0,L'D0MSGBUF\n         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT\n******** B     PUTLRET\nPUTLRET  L     R14,D0PUTL14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\nMOVEPUT  MVC   D0MSG(0),0(R1)      MOVE MESSAGE TO WORK AREA\nMOVEPUTC MVC   D0MSG+1(0),0(R1)    MOVE COMMAND TO WORK AREA\nBADPUT   DC    C'*** XTS00008: XCLIST/XTSEXEC PUTLINE FAILURE ***'\n         SPACE\n         LTORG\n         SPACE\n         USING XTSEXEC,R12,R9\n         DROP  R8\n         TITLE 'XTSEXEC - FLUSH SUBROUTINE'\n***********************************************************************\n* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *\n* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *\n* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *\n* ADDITIONAL COMMANDS \"STACKED\" WITH FIELD MARKS ARE NOT EXECUTED.    *\n* ON ENTRY TO THIS SUBROUTINE R1 POINTS TO THE LIST FORM OF THE STACK *\n* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *\n* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *\n* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *\n* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *\n* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *\n* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *\n***********************************************************************\n         SPACE\nFLUSH    DS    0H\n         ST    R14,D0FLSH14        SAVE RETURN REGISTER\n         MVC   D0STACK(STKINITL),0(R1) SET UP STACK LIST FORM\n         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE\n         XC    D0ECB,D0ECB         CLEAR ECB\n         STACK PARM=D0STACK,MF=(E,IOPL)  FLUSH THE STACK\n         LTR   R15,R15             IF STACK FAILED\n         BZ    FLUSHRET            THEN SAY SO\n         LA    R1,BADSTACK\n         LA    R0,L'BADSTACK\n         BAL   R14,PUTLINE\nFLUSHRET LA    R14,12              SET RETURN CODE TO 12 WHEN FLUSHING\n         ST    R14,D0RETCD\n         L     R14,D0FLSH14        RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         SPACE\n         LTORG\n         SPACE\n         DROP  R11,R12,R9\n         TITLE 'XTSEXEC - STAI EXIT FOR ABENDING COMMANDS'\nSTAIEXIT DS    0H\n         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER\n         USING STAIEXIT,R12\n         LA    R3,12               CHECK IF REGISTER 0 = \"12\"\n         CR    R0,R3               IF AN SDWA IS AVAILABLE,\n         BE    NOSDWA              THEN...\n         LM    R10,R11,0(R1)        R10 -> WORKAREA, R11 = ABEND CODE\n         B     AFTSDWA             ELSE...\nNOSDWA   LR    R10,R2               R10 -> WORKAREA\n         LR    R11,R1               R11 = ABEND COMPLETION CODE\n         XR    R1,R1                Clear SDWA address - ain't none\nAFTSDWA  DS    0H\n         ST    R1,D0SDWA           Save address of SDWA\n         ST    R14,D0STAI14        SAVE RETURN REGISTER\n         L     R4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT\n         TM    D0FLAGS,D0DETACH    IF DETACH IN PROGRESS\n         BZ    NOT33E               AND\n         CLM   R11,7,=X'33E000'      ABEND CODE IS S33E\n         BNE   NOT33E                 THEN...\n         MVC   D0MSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   D0MSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE\n         LA    R0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG\n         B     ANYABEND                GO TO DISPLAY THE MESSAGE\nNOT33E   DS    0H\n         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED\n         STCM  R11,7,D0ABCODE      STORE ABEND CODE\n         SPACE\n***********************************************************************\n* DISPLAY \"ENDED DUE TO ERROR\" MESSAGE                                *\n***********************************************************************\n         SPACE\n         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE\n         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095\n         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND\n         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO\n         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN\n         MVZ   D0SYSTEM(3),=X'000000'\n         TR    D0SYSTEM(3),=C'0123456789ABCDEF'\n         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE\n         B     ANYABEND                     GO TO DISPLAY IT\nUSRABEND MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND\n         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         XR    R0,R0\n         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE\n         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY\n         UNPK  D0USER(4),D0DOUBLE\n         OI    D0USER+3,X'F0'\n         LA    R0,D0USERL                   GET LENGTH OF MESSAGE\nANYABEND DS    0H\n         XR    R1,R1               INDICATE MESSAGE SET UP\n         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE\n         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE\n         L     R2,D0STAI14         Get return register\n         LA    R15,16              Set return code in case no SDWA\n         ICM   R3,15,D0SDWA        Get SDWA address\n         BZR   R2                  If none, just branch back w/rc=16\n         SETRP WKAREA=(R3),RC=16   Let ABEND continue without ESTAI\n         BR    R2                  Return to caller\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XTSEXEC - STAE EXIT FOR INTERNAL ABEND'\nSTAEEXIT DS    0H\n         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER\n         USING STAEEXIT,R12\n         LA    R3,12               CHECK IF REGISTER 0 = \"12\"\n         CR    R0,R3               IF AN SDWA IS AVAILABLE,\n         BE    NOSDWAE             THEN...\n         L     R10,0(,R1)           R10 -> WORKAREA\n         B     AFTSDWAE            ELSE...\nNOSDWAE  LR    R10,R2               R10 -> WORKAREA\nAFTSDWAE DS    0H\n         L     R4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT\n         MVC   ECTIOWA(4),D0SVIOA  RESTORE ECT INPUT STACK ADDRESS\n         MVC   ECTPCMD(16),D0CMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES\n         XR    R15,R15             CONTINUE WITH ABNORMAL TERMINATION\n         BR    R14                 AND RETURN\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         TITLE 'XTSEXEC - STAX EXIT FOR ATTENTION INTERRUPT'\nSTAXEXIT DS    0H\n         SPACE\n         LR    R12,R15             SAVE ENTRY ADDRESS\n         USING STAXEXIT,R12\n         L     R10,8(,R1)          GET ADDRESS OF USER PARAMETER LIST\n         LR    R9,R14              SAVE RETURN ADDRESS\n         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE\n         MVI   D0STATUS,D0ATTN     INDICATE ATTENTION OCCURRED\n         POST  D0ECB,0             POST SERVICE ROUTINES ECB\n         POST  D0ATNECB,0          POST ECB FOR COMMAND ATTACH\n         BR    R9                  RETURN TO SYSTEM\n         SPACE\n         LTORG\n         SPACE\n         DROP  R12\n         EJECT\n***********************************************************************\n* MESSAGES                                                            *\n***********************************************************************\n         SPACE\nNTSOMSG  WTO   MF=L,                                                   X\n               ROUTCDE=11,          ISSUE WRITE TO PROGRAMMER MESSAGE  X\n               'XTS00009 XCLIST/XTSEXEC ISSUED IN NON-TSO ENVIRONMENT'\nNECTMSG  WTO   MF=L,                                                   X\n               ROUTCDE=11,                                             X\n               'XTS00010 Warning: The ECT addresses in the LWA (logon wX\n               ork area) and the RLGB (relogon buffer) do not match.  XX\n               CLIST is using the ECT address from the RLGB.'\nRETYMSG  WTO   MF=L,                                                   X\n               ROUTCDE=11,          ISSUE WRITE TO PROGRAMMER MESSAGE  X\n               'XTS00011 XCLIST/XTSEXEC TERMINATION SEVERE ERROR'\n         SPACE\nSYNMSG   DC    C'XTS00001 INVALID COMMAND SYNTAX'\nTERMMSG  DC    C'XTS00005 COMMAND INPUT IGNORED, CLIST HAS TERMINATED'\nBADSTACK DC    C'XTS00007 XCLIST/XTSEXEC ERROR FLUSHING STACK'\n         SPACE\nABEMSGID DC    C'XTS00003 '\nABEMSG1  DC    C' ENDED DUE TO ERROR, '\nABEMSG2  DC    C' ABEND CODE '\n         SPACE\nATNMSGID DC    C'XTS00004 '\nATTNMSG  DC    C' TERMINATED BY ATTENTION INTERRUPTION'\n         EJECT\n         USING XTSEXEC,R12,R9\n         USING DATD1,R11\n         TITLE 'XTSEXEC - DATA AREAS'\nDATD0    DSECT\n         SPACE\nD0SAVE   DS    9D                  OS SAVE AREA\nD0DOUBLE DS    D                   FOR NUMERIC CONVERSIONS\nD0SCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE\nD0CKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE\nD0ATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE\nD0PUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE\nD0PG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE\nD0FLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE\nD0STAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE\nD0ECB    DS    F                   ECB FOR TSO SERVICE ROUTINES\nD0CMDECB DS    F                   ECB FOR ATTACHED COMMANDS\nD0ATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS\nD0ECBLST DS    2A                  ECB LIST\nD0PLADDR DS    A                   ADDRESS OF PUTLINE SUBROUTINE\nD0E2ADDR DS    A                   Address of IKJEFTE2\nD0NSADDR DS    A                   Address of IKJEFTNS\nD0SDWA   DS    A                   Address of SDWA\nD0BADECT DS    A                   Address of possible bad model ECT\nD0BADIOW DS    A                   Address of possible bad IOWA\n         SPACE\nCPPL     DS    0F                  COMMAND PROCESSOR PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCPPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n         SPACE\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n         SPACE 2\nIOPL     DS    0F                  I/O SERVICE ROUTINE PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJIOPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 2\nPTPB     DS    0F                  PUTLINE PARAMETER BLOCK\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJPTPB)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *\n*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *\n*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL4      INTERNAL PUTLINE USAGE\nPTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE\nPTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=\n*                       ADDR,FORMAT) IS SPECIFIED\n         SPACE\nPGPB     DS    0H                  PUTGET PARAMETER BLOCK\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJPGPB)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *\n*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *\n*    RETURNING INFORMATION.                                           *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL12     INTERNAL TO GETLINE/PUTLINE\nPGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE\n         SPACE\nDAPL     DS    0F                  DYNAMIC ALLOCATION PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJDAPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\n         SPACE\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         SPACE\nDAPB2C   DS    0F                  DAIR PARAMETER LIST FOR CODE 2C\n         SPACE\n***********************************************************************\n* COPIED FROM SYS1.MACLIB(IKJDAP2C) BECAUSE THE MACRO FORCES A DSECT  *\n***********************************************************************\n* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *\n* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *\n* WHICH ATTACHES SUB-TASKS                                            *\n***********************************************************************\n         SPACE\nDA2CCD   DS    CL2      DAIR ENTRY CODE\nDA2CFLG  DS    H        FLAG FIELD\nDA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE\nDA2CDDN  DS    CL8        DDNAME\n         SPACE\nD0STACK  STACK MF=L,DELETE=ALL     USED FOR ANY STACK DELETE FUNCTION\n         SPACE\nD0STACK2 STACK MF=L,ENVIRON=CREATE USED FOR ANY STACK ENVIRON FUNCTION\n         SPACE\nD0ATTACH ATTACH SF=L\n         SPACE\nD0ESTAE  ESTAE MF=L\n         SPACE\nD0STAX   STAX  MF=L\n         SPACE\nD0NEWECT DS    A              Address of ECT created by ENVIRON=CREATE\nD0RETCD  DS    F                   RETURN CODE FROM COMMAND\nD0DAIRRC DS    F                   RETURN CODE FROM IKJDAIR\nD0SVIOA  DS    F                   SAVE INPUT STACK ADDRESS\nD0SCANRC DS    H                   RETURN CODE FROM IKJSCAN\nD0OFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME\nD0CMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND\nD0COMMND DS    CL8                 COMMAND NAME FROM SCAN\nD0BLDL   DS    F                   BLDL LIST FOR COMMAND CHECK\nD0MODULE DS    CL8                 MODULE NAME FOR COMMAND\n         DS    XL4                 FILLER FOR BLDL\nD0ABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT\nD0FLAGS  DS    X                   FLAGS\nD0EXEC   EQU   B'10000000'          1 = IMPLICIT EXEC COMMAND (%)\nD0STKMOD EQU   B'01000000'          1 = ECT INPUT STACK ADDR ALTERED\nD0ECTMOD EQU   B'00100000'          1 = ECT PCMD/SCMD WAS ALTERED\nD0ESTON  EQU   B'00010000'          1 = ESTAE SUCCESSFUL\nD0STXON  EQU   B'00001000'          1 = STAX SUCCESSFUL\nD0SUBER  EQU   B'00000100'          1 = SEVERE ERROR IN SUBROUTINE\nD0DETACH EQU   B'00000010'          1 = DETACH IN PROGRESS\nD0AUTH   EQU   B'00000001'          1 = command requires authorization\nD0RETURN DS    X                   Return status flag\nD0RETNO  EQU   0                    Not returning\nD0RETYES EQU   1                    Returning\nD0STATUS DS    X                   COMMAND STATUS FLAG\nD0NORMAL EQU   0                    COMMAND COMPLETED NORMALLY\nD0ATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED\nD0ABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED\nD0TSOE   DS    X                   TSO/E version number\n         SPACE\n***********************************************************************\n* Fields used by the TSO Authorized Service Facility                  *\n***********************************************************************\n         SPACE\nD0TSFPLS DS    0A\nD0TSFP1  DS    A                   TSO Service Facility parameter 1\nD0TSFP2  DS    A                   TSO Service Facility parameter 2\nD0TSFP3  DS    A                   TSO Service Facility parameter 3\nD0TSFP4  DS    A                   TSO Service Facility parameter 4\nD0TSFP5  DS    A                   TSO Service Facility parameter 5\nD0TSFP6  DS    A                   TSO Service Facility parameter 6\nD0TSFRC  DS    A                   Return code from TSO command\nD0TSFRS  DS    A                   Reason code from TSO command\nD0TSFAC  DS    A                   Abend code from TSO command\nD0TSFLEN DS    A                   Length of command\n         SPACE\n***********************************************************************\n* PUTGET MODE MESSAGE AREA                                            *\n***********************************************************************\n         SPACE\nD0PGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nD0PGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nD0PGHDR  DS    2Y                  MESSAGE HEADER\nD0PGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT\n         SPACE\n***********************************************************************\n* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *\n* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *\n***********************************************************************\n         SPACE\nD0MSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nD0MSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nD0MSGHDR DS    2Y                  MESSAGE HEADER\nD0MSG    DS    CL128               MESSAGE TEXT\nD0MSG1   EQU   D0MSG+L'ABEMSGID    OFFSET OF \"ENDED DUE TO ERROR\"\nD0MSG2   EQU   D0MSG1+8+L'ABEMSG1  OFFSET OF \"SYSTEM\" OR \"USER\"\nD0SYSTEM EQU   D0MSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE\nD0USER   EQU   D0MSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE\nD0SYSL   EQU   D0SYSTEM+3-D0MSG    LENGTH OF SYSTEM ABEND MESSAGE\nD0USERL  EQU   D0USER+4-D0MSG      LENGTH OF USER ABEND MESSAGE\n         SPACE 2\nD0MSGBUF DS    CL256               Area to build messages\n         SPACE 2\nSIZDATD0 EQU   *-DATD0\n         EJECT\nDATD1    DSECT\n         SPACE\n***********************************************************************\n* ALL STORAGE USED BY IKJSCAN IS ALLOCATED IN SUBPOOL 1 BECAUSE       *\n* THAT'S WHAT WE WERE TOLD TO DO BY THE GUIDE TO WRITING A TMP OR A   *\n* COMMAND PROCESSOR.                                                  *\n***********************************************************************\n         SPACE\nCSPL     DS    0D                  COMMAND SCAN PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCSPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         SPACE\nCSOA     DS    0H                  COMMAND SCAN OUTPUT AREA\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCSOA)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME\n         DS    CL1      RESERVED\n         SPACE\nD1CSFLG  DS    F                   COMMAND SCAN FLAG WORD\n         SPACE 2\nSIZDATD1 EQU   *-DATD1\n         SPACE 2\nXTSEXEC  CSECT\n         EJECT\n         IKJECT\n         EJECT\n         IKJSTPB\n         EJECT\n         IKJPSCB\n         EJECT\n         IKJRLGB\n         EJECT\n         IKJEFLWA\n         EJECT\n         IKJTSVT\n         EJECT\n         PRINT NOGEN\n         IHASDWA\n         IEZJSCB\n         IKJTCB\n         IHAASCB\n         IHAASXB\n         IHAPSA\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XTSOVAR  0100-07332-07332-0900-00570-00570-00000-SEB\n         TITLE 'XTSOVAR  - CLIST VARIABLE ACCESS FOR PL/1'\n***********************************************************************\n*                                                                     *\n* XTSOVAR  - CLIST VARIABLE ACCESS FOR PL/1                           *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* XTSOVAR - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST        *\n* VARIABLE ACCESS FACILITY FOR PL/1.                                  *\n*                                                                     *\n* PL/1 INVOCATION:                                                    *\n*                                                                     *\n* DCL VALUE    CHAR(256) VAR;                                         *\n* DCL XTSOVAR ENTRY (CHAR(*),      /* 'R(EAD)' OR 'W(RITE)'       */  *\n*                    CHAR(*) VAR,  /* THE NAME OF THE VARIABLE    */  *\n*                    CHAR(*) VAR)  /* THE VALUE TO BE READ OR SET */  *\n*              EXTERNAL;           /* DON'T SAY OPTIONS(ASM)!!!!! */  *\n* DCL PLIRETV BUILTIN;                                                *\n*                                                                     *\n* /* SAMPLE CODE TO READ THE VALUE OF A VARIABLE */                   *\n*                                                                     *\n* CALL XTSOVAR ('R','SYSDVAL',VALUE);                                 *\n* IF PLIRETV ^= 0 THEN DO;                                            *\n*  PUT LIST('ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',PLIRETV);  *\n* END;                                                                *\n* PUT LIST('THE VALUE OF &SYDSVAL IS:', VALUE);                       *\n*                                                                     *\n* /* SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE */                 *\n*                                                                     *\n* VALUE = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL';       *\n* CALL XTSOVAR ('W','SYSDVAL',VALUE);                                 *\n*                                                                     *\n*  ***********    S P E C I F I C A T I O N S    ***********          *\n*                                                                     *\n* PROGRAM NAME:  XTSOVAR                                              *\n* AUTHOR:        STEVE BACHER (SEB1525)                               *\n* DATE:          06/13/85                                             *\n* FUNCTION:      TO BE INVOKED FROM A PL/1 PROGRAM FOR THE PURPOSE    *\n*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *\n*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *\n* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *\n*                THE TARGET STRING MUST BE DECLARED LARGE ENOUGH TO   *\n*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *\n*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *\n* INPUT:         A STANDARD PL/1 PARAMETER LIST AS FOLLOWS:           *\n*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *\n*                CHARACTER IS \"R\" (READ, I.E. RETRIEVE A VALUE) OR    *\n*                \"W\" (WRITE, I.E. UPDATE A VALUE).                    *\n*  PARAMETER 2:  A VARYING-LENGTH CHARACTER STRING WHICH CONTAINS THE *\n*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *\n*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *\n*  PARAMETER 3:  A VARYING-LENGTH CHARACTER STRING USED AS FOLLOWS:   *\n*                FOR \"R\" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *\n*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *\n*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *\n*                FOR \"W\" (WRITE) MODE, CONTAINS THE VALUE TO BE       *\n*                ASSIGNED TO THE CLIST VARIABLE.                      *\n* RETURN CODES:                                                       *\n*  0 - FUNCTION SUCCESSFUL.                                           *\n*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *\n*        THE MAXIMUM DECLARED LENGTH OF THE THIRD PARAMETER, AND THE  *\n*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN CODE   *\n*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *\n* ABEND CODES:                                                        *\n* 0C3 (PL/1 ONCODE 8093 - \"ERROR\" CONDITION RAISED) - ISSUED WHEN AN  *\n* ERROR OTHER THAN TRUNCATION OCCURS.                                 *\n*                                                                     *\n* THE REASON CODE (IN PLIRETV) IS AS FOLLOWS:                         *\n*                                                                     *\n* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *\n* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *\n* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *\n*                                                                     *\n* PROCESSING:                                                         *\n*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *\n*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *\n*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *\n*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *\n*                                                                     *\n*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *\n*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *\n*                                                                     *\n* DOCUMENTATION:                                                      *\n* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *\n* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 2.  *\n*                                                                     *\n* RESTRICTIONS: THIS PROGRAM REQUIRES THE H ASSEMBLER, BECAUSE I WAS  *\n* PERVERSE ENOUGH TO USE LONG SYMBOLIC NAMES.  BESIDES, ONCE YOU USE  *\n* THE \"CVT\" MACRO YOU HAVE TO USE THE H ASSEMBLER.                    *\n*                                                                     *\n* ACKNOWLEDGMENTS:                                                    *\n* THANKS TO LARRY JONES (LLJ4266) FOR TECHNICAL ASSISTANCE.           *\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*  07/02/87 - NOW AMODE(ANY) AND RMODE(ANY).                          *\n*  12/28/87 - TSO/E RELEASE 4 SUPPORT.                                *\n*  05/01/89 - TSO/E VERSION 2 SUPPORT.                                *\n*  08/17/89 - Support for REXX: switches to AMODE(31) to access.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    RETURN CODE FROM IKJCT441\nR5       EQU   5    RESERVED FOR PL/1\nR6       EQU   6    POINTER TO DOPE VECTOR FOR ARG 1\nR7       EQU   7    POINTER TO DOPE VECTOR FOR ARG 2\nR8       EQU   8    POINTER TO DOPE VECTOR FOR ARG 3\nR9       EQU   9    ADDRESS OF VARIABLE NAME\nR10      EQU   10   LENGTH OF VARIABLE NAME\nR11      EQU   11   STATIC BASE REGISTER\nR12      EQU   12   RESERVED FOR PL/1\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXTSOVAR  CSECT\nXTSOVAR  AMODE ANY\nXTSOVAR  RMODE ANY\n         SAVE  (14,12),,&SYSDATE._&SYSTIME\n         LR    R11,R15\n         USING XTSOVAR,R11\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* VALIDITY CHECK PARAMETER LIST                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    8(R1),X'80'         IF VL BIT DOESN'T SHOW 3 PARMS\n         BZ    WRONG_NUMBER_ARGS   THEN ERRROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* PROCESS PARAMETERS PASSED FROM PL/1                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LM    R6,R8,0(R1)         GET POINTERS TO DOPE VECTORS\n         CLI   6(R6),X'00'         IF ARG1 IS NOT CHAR(*) {FIXED},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         CLI   6(R7),X'80'         IF ARG2 IS NOT CHAR(*) {VARYING},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         CLI   6(R8),X'80'         IF ARG3 IS NOT CHAR(*) {VARYING},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FIRST ARGUMENT MUST BE \"R\" (READ) OR \"W\" (WRITE).               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,0(,R6)           GET ADDRESS OF ARG1 CHAR STRING\n         CLI   0(R1),C'R'          MUST BE UPPER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'W'          OR UPPER CASE W\n         BE    ENTRY_CODE_WRITE\n         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W\n         BE    ENTRY_CODE_WRITE\n         B     WRONG_ENTRY_CODE    ELSE ERROR\n         SPACE 1\nENTRY_CODE_READ DS 0H\n         MVI   MODE,TSVERETR       INDICATE READ MODE\n         B     SET_NAME_LENGTH\n         SPACE 1\nENTRY_CODE_WRITE DS 0H\n         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE\n         B     SET_NAME_LENGTH\n         SPACE 2\nSET_NAME_LENGTH DS 0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME STRING\n         LH    R10,0(,R1)          GET CURRENT LENGTH OF STRING\n         LA    R9,2(,R1)           POINT TO TEXT OF STRING\n         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO\n         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)\n         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND\n         BNE   NOAMP               THEN...\n         LA    R9,1(,R9)            BUMP PAST IT\n         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.\nNOAMP    DS    0H                  ANYHOW...\n         LA    R15,0(R9,R10)       POINT TO END OF STRING\n         BCTR  R15,0               BUMP BACK TO LAST CHARACTER\nBLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS\n         BNE   ENDNAME\n         BCTR  R15,0\n         BCT   R10,BLOOP\nENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH\nNOCHECK  DS    0H\n         SPACE 2\nSETPARMS DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET UP PARAMETERS TO PASS TO IKJCT441                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R0,R0               MAKE A ZERO\n         XR    R1,R1\n         IC    R1,MODE             PICK UP MODE\n         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST\n         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME\n         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME\n         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME\n         CLI   MODE,TSVERETR       IF MODE IS READ,\n         BNE   NOTREAD             THEN...\n         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME\n         B     AFTREAD             ELSE...\nNOTREAD  DS    0H                   (SET TO UPDATE)\n         L     R1,0(,R8)            GET POINTER TO VARIABLE VALUE\n         LH    R2,0(,R1)            GET LENGTH OF VARIABLE VALUE\n         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE\n         LA    R2,2(,R1)            GET ADDRESS OF VARIABLE VALUE\n         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE\nAFTREAD  DS    0H\n         ST    R0,CTOKEN           SET TOKEN (NOT USED)\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARMS       SET UP PARAMETER LIST\n         OI    CPARM6,X'80'        SET VL BIT\n         LA    R1,CPARMS           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R4,R15              GET RETURN CODE\n         BZ    OK                  IF ZERO, OK\n         CH    R4,=H'76'           IF RETURN CODE IS 76\n         BE    RC76                 OR\n         CH    R4,=H'80'             RETURN CODE IS 80\n         BE    RC80                 OR\n         CH    R4,=H'81'             RETURN CODE IS 81\n         BE    RC81                 OR\n         CH    R4,=H'40'             RETURN CODE IS 40 OR LESS\n         BH    RCOTHER                THEN\nRET441   B     RET441(R4)              BRANCH DEPENDING ON RETURN CODE\n         B     OK                  RC=4 IS OK\n         B     RC8\n         B     RC12\n         B     RC16\n         B     RCOTHER\n         B     RC24\n         B     RCOTHER\n         B     RC32\n         B     RC36\n         B     RC40\n         SPACE 1\nOK       DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   MODE,TSVERETR       IF NOT READ MODE,\n         BNE   RETURN              THEN JUST RETURN. ELSE (READ MODE)..\n         L     R2,0(,R8)           POINT TO CHAR(*) VAR ARG 3\n         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE\n         LA    R0,2(,R2)           SET ADDRESS OF WHERE TO MOVE IT\n         LH    R1,4(,R8)           SET LENGTH OF WHERE TO MOVE IT\n         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE\n         LR    R15,R9              SET LENGTH OF WHAT TO MOVE\n         L     R3,=A(MVCL+X'80000000')  Get address of 31-bit code\n         LA    R4,AFTMVCL               Get return address\n         BSM   R4,R3               Save current AMODE in R4, go to 31\nMVCL     DS    0H\n         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3\n         BSM   0,R4                Return to previous AMODE\nAFTMVCL  DS    0H\n*\n* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT\n* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE\n* CAN RETURN THIS AS THE RETURN CODE.\n*\n* SET LENGTH FIELD OF CHAR(*) VARYING ACCORDING TO HOW MUCH MOVED.\n*\n         SR    R9,R15              LENGTH MINUS TRUNCATION\n         STH   R9,0(,R2)           GIVES LENGTH(STRING) TO BE SET\n         B     RETURN              RETURN WITH CODE IN R15\n         EJECT\nRC8      DS    0H\n         LA    R1,MSG8\n         B     ERROR\n         SPACE 1\nRC12     DS    0H\n         LA    R1,MSG12\n         B     ERROR\n         SPACE 1\nRC16     DS    0H\n         LA    R1,MSG16\n         B     ERROR\n         SPACE 1\nRC24     DS    0H\n         LA    R1,MSG24\n         B     ERROR\n         SPACE 1\nRC32     DS    0H\n         LA    R1,MSG32\n         B     ERROR\n         SPACE 1\nRC36     DS    0H\n         LA    R1,MSG36\n         B     ERROR\n         SPACE 1\nRC40     DS    0H\n         LA    R1,MSG40\n         B     ERROR\n         SPACE 1\nRC76     DS    0H\n         LA    R1,MSG76\n         B     ERROR\n         SPACE 1\nRC80     DS    0H\n         LA    R1,MSG80\n         B     ERROR\n         SPACE 1\nRC81     DS    0H\n         LA    R1,MSG81\n         B     ERROR\n         SPACE 1\nRCOTHER  DS    0H\n         MVC   OTHERMSG(MSGOTHER_LENGTH),MSGOTHER\n         CVD   R4,OTHERRC\n         UNPK  OTHERMSG+MSGOTHER_LENGTH(2),OTHERRC\n         OI    OTHERMSG+MSGOTHER_LENGTH+1,X'F0'\n         MVI   OTHERMSG+MSGOTHER_LENGTH+2,C'.'\n         LA    R1,OTHERMSG\n         LA    R0,MSGOTHER_LENGTH+3\n         STH   R0,0(,R1)\n         B     ERROR\n         SPACE 1\n         EJECT\nERROR    DS    0H\n         SPACE 1\n         USING PSA,0\n         L     R15,PSATOLD           GET TCB ADDRESS\n         USING TCB,R15\n         L     R15,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R15\n         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R15,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R15\n         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE\n         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,R15\n         L     R8,RLGBECT            GET ADDRESS OF ECT\n         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE\n         LA    R15,ECB\n         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\n         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)\n         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR\n         XC    ECB,ECB              CLEAR ECB FOR PUTLINE\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15              IF PUTLINE FAILED,\n         BZ    PUTLOK               THEN...\nDOTPUT   DS    0H                    try to display message via TPUT\n*\n* Note: This will work only if the load module is loaded below the\n*       line.  But since this won't get executed unless there's a\n*       PUTLINE failure, which really shouldn't occur, we won't\n*       worry about it.\n*\n         LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE\n         LA    R0,L'PUTLFAIL\n         TPUT  (1),(0),R\n         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE\n         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE\n         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK\n         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK\n         TPUT  (1),(0),R             AND DISPLAY VIA TPUT\nPUTLOK   DS    0H\n         SPACE 1\nABENDIT  DS    0H                   FORCE ONCODE8093\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R15,500(,R4)         SET REASON CODE = RC + 500\n         ST    R15,68(,R12)         STORE IN PLIRETV AREA\n         EX    0,*                  FORCE 0C3 ABEND\n         EJECT\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* STORE RETURN CODE IN TCA+X'44'.  THIS IS NECESSARY TO ALLOW THE     *\n* CALLER TO PICK UP THE RETURN CODE VIA \"PLIRETV\" DESPITE NOT BEING   *\n* ABLE TO SPECIFY OPTIONS(RETCODE) IN THE DECLARE.                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    R15,68(,R12)        STORE RETURN CODE IN PL/1 TCA\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* ERROR ROUTINES                                                      *\n***********************************************************************\n         SPACE 1\nWRONG_NUMBER_ARGS DS 0H\n         LA    R1,WRONG_NUMBER_ARGS_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nINVALID_ARG_TYPE  DS 0H\n         LA    R1,INVALID_ARG_TYPE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nWRONG_ENTRY_CODE  DS 0H\n         LA    R1,WRONG_ENTRY_CODE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE\nLENPUTL  EQU   *-MPTLIST\n         SPACE\nWRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X\n               ' XTSOVAR: WRONG NUMBER OF ARGUMENTS PASSED TO XTSOVAR.'\nINVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X\n               ' XTSOVAR: INVALID ARGUMENT TYPES PASSED TO XTSOVAR.'\nWRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X\n               ' XTSOVAR: CODE PASSED TO XTSOVAR NOT \"R\" OR \"W\".'\nMSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN\nMSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'\nMSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'\nMSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'\nMSG24    WTO   MF=L,' XTSVAR24: REQUESTED CLIST VARIABLE IS A PROCEDUREX\n                NAME.'\nMSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'\nMSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME TOO LONG OR NULL.'\nMSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'\nMSG76    WTO   MF=L,' XTSVAR76: UNDEFINED &&SYSX CLIST VARIABLE.'\nMSG80    WTO   MF=L,' XTSVAR80: VARIABLE NAME NOT VALID FOR REXX.'\nMSG81    WTO   MF=L,' XTSVAR81: REXX ROUTINE DETECTED AN ERROR.'\n         SPACE 1\nMSGOTHER WTO   MF=L,' XTSOVAR: CLIST VARIABLE ACCESS RETURN CODE '\nMSGOTHER_LENGTH EQU *-MSGOTHER\n         SPACE 1\nPUTLFAIL DC    C'XTSOVAR: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING IX\n               SSUED VIA TPUT:'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R11\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F                 OS SAVE AREA\nOTHERRC  DS    D\n         SPACE\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\nOLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG\n         SPACE\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 2\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\n         SPACE 1\nCENTRY   DC    A(0)                ENTRY CODE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nMODE     DS    C                   R(EAD) OR W(RITE)\n         SPACE 2\nOTHERMSG DS    0A\n         DS    CL(MSGOTHER_LENGTH+3)\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJECT\n         SPACE 1\n         IKJCPPL\n         SPACE 1\n         IKJTSVT\n         SPACE 1\n         PRINT NOGEN\n         IHAPSA\n         SPACE 1\n         CVT   DSECT=YES\n         SPACE 1\n         IKJTCB\n         SPACE 1\n         IEZJSCB\n         SPACE 1\n         IKJPSCB\n         SPACE 1\n         IKJRLGB\n         END\n./ ADD NAME=XTSVAR   0100-07332-07332-0900-00600-00600-00000-SEB\n         TITLE 'XTSVAR  - CLIST VARIABLE ACCESS FOR FORTRAN'\n***********************************************************************\n*                                                                     *\n* XTSVAR  - CLIST VARIABLE ACCESS FOR FORTRAN                         *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* XTSVAR - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST         *\n* VARIABLE ACCESS FACILITY FOR FORTRAN.                               *\n*                                                                     *\n* FORTRAN INVOCATION:                                                 *\n*                                                                     *\n*       INTEGER*4 FUNCTION XTSVAR(RW,VARNAM,VARVAL,LENGTH)            *\n* C                                                                   *\n*       CHARACTER RW*1,VARNAM*(*),VARVAL*(*)                          *\n*       INTEGER*4 LENGTH                                              *\n* C                                                                   *\n* C  INPUT:                                                           *\n* C    RW     - READ/WRITE FLAG, EITHER 'R' OR 'W' OR 'r' OR 'w'      *\n* C    VARNAM - TSO VARIABLE NAME                                     *\n* C                                                                   *\n* C  OUTPUT:                                                          *\n* C    VARVAL - VALUE OF TSO VARIABLE                                 *\n* C    LENGTH - LENGTH OF VARVAL STRING, OR 0 IF VALUE IS <NULL>      *\n* C    XTSVAR - .EQ.0 => SUCCESS                                      *\n* C             .GT.0 => TRUNCATION OR OTHER ERROR AS FOR XTSOVAR     *\n*                                                                     *\n*                                                                     *\n* C  SAMPLE CODE TO READ THE VALUE OF A VARIABLE                      *\n*                                                                     *\n*   RC = XTSVAR ('R','SYSDVAL',VARVAL,LENGTH)                         *\n*   IF (RC.NE.0) THEN                                                 *\n*    WRITE (6,100) RC                                                 *\n* 100 FORMAT(' ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',I10)     *\n*   ENDIF                                                             *\n*    WRITE (6,200) VARVAL                                             *\n* 200 FORMAT(' THE VALUE OF &SYSDVAL IS:',A.... whatever              *\n*  C FOR A LENGTH OF \"LENGTH\"                                         *\n*                                                                     *\n* C  SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE                    *\n*                                                                     *\n* C NOTE THAT THE \"LENGTH\" VARIABLE MUST BE SPECIFIED THO NOT USED    *\n*                                                                     *\n* VARVAL = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL'       *\n* CALL XTSVAR  ('W','SYSDVAL',VARVAL, LENGTH)                         *\n*                                                                     *\n*  ***********    S P E C I F I C A T I O N S    ***********          *\n*                                                                     *\n* PROGRAM NAME:  XTSVAR                                               *\n* AUTHOR:        STEVE BACHER (SEB1525)                               *\n* DATE:          06/25/87                                             *\n* FUNCTION:      TO BE INVOKED FROM A FORTRAN PROGRAM FOR THE PURPOSE *\n*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *\n*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *\n* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *\n*                THE TARGET STRING MUST BE DEFINED LARGE ENOUGH TO    *\n*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *\n*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *\n* INPUT:         A STANDARD FORTRAN PARAMETER LIST AS FOLLOWS:        *\n*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *\n*                CHARACTER IS \"R\" (READ, I.E. RETRIEVE A VALUE) OR    *\n*                \"W\" (WRITE, I.E. UPDATE A VALUE).                    *\n*  PARAMETER 2:  A FIXED-LENGTH CHARACTER STRING WHICH CONTAINS THE   *\n*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *\n*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *\n*  PARAMETER 3:  A FIXED-LENGTH CHARACTER STRING USED AS FOLLOWS:     *\n*                FOR \"R\" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *\n*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *\n*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *\n*                FOR \"W\" (WRITE) MODE, CONTAINS THE VALUE TO BE       *\n*                ASSIGNED TO THE CLIST VARIABLE.                      *\n*  PARAMETER 4:  A FULLWORD INTEGER USED AS FOLLOWS:                  *\n*                FOR \"R\" (READ) MODE, WILL CONTAIN THE LENGTH OF THE  *\n*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *\n*                FOR \"W\" (WRITE) MODE, IS NOT USED, BUT YOU MAY NOT   *\n*                SPECIFY ANYTHING OTHER THAN AN INTEGER*4 VARIABLE    *\n*                FOR THIS PARAMETER.                                  *\n* RETURN VALUE (INTEGER):                                             *\n*  0 - FUNCTION SUCCESSFUL.                                           *\n*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *\n*        THE CHARACTER STRING LENGTH OF THE THIRD PARAMETER, AND THE  *\n*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN VALUE  *\n*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *\n* ABEND CODES:                                                        *\n* Unn - ISSUED WHEN AN ERROR OTHER THAN TRUNCATION OCCURS.            *\n*                                                                     *\n* THE USER ABEND CODE IS:                                             *\n*                                                                     *\n* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *\n* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *\n* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *\n*                                                                     *\n* PROCESSING:                                                         *\n*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *\n*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *\n*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *\n*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *\n*                                                                     *\n*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *\n*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *\n*                                                                     *\n* DOCUMENTATION:                                                      *\n* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *\n* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 3.  *\n*                                                                     *\n* RESTRICTIONS: THIS PROGRAM REQUIRES THE H ASSEMBLER, BECAUSE I WAS  *\n* PERVERSE ENOUGH TO USE LONG SYMBOLIC NAMES.  BESIDES, ONCE YOU USE  *\n* THE \"CVT\" MACRO YOU HAVE TO USE THE H ASSEMBLER.                    *\n*                                                                     *\n* ACKNOWLEDGMENTS:                                                    *\n* THIS IS A MODIFIED VERSION OF XTSOVAR, THE EQUIVALENT ROUTINE FOR   *\n* PL/1 PROGRAMS.  SEE XTSOVAR FOR FURTHER ACKNOWLEDGMENTS.            *\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*  12/28/87 - SUPPORT FOR TSO/E RELEASE 4.                            *\n*  05/01/89 - SUPPORT FOR TSO/E VERSION 2.                            *\n*  08/17/89 - Support for REXX: switches to AMODE(31) to access.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    RETURN CODE FROM IKJCT441\nR5       EQU   5    POINTER TO PARAMETER LIST\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9    ADDRESS OF VARIABLE NAME\nR10      EQU   10   LENGTH OF VARIABLE NAME\nR11      EQU   11   STATIC BASE REGISTER\nR12      EQU   12   RESERVED FOR PL/1\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXTSVAR   CSECT\nXTSVAR   AMODE ANY\nXTSVAR   RMODE ANY\n         SAVE  (14,12),,&SYSDATE._&SYSTIME\n         LR    R11,R15\n         USING XTSVAR,R11\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* VALIDITY CHECK PARAMETER LIST                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    8(R1),X'80'         IF VL BIT SHOWS 3 PARMS PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    12(R1),X'80'        IF VL BIT DOESN'T SHOW 4 PARMS\n         BZ    WRONG_NUMBER_ARGS   THEN ERRROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* PROCESS PARAMETERS PASSED FROM FORTRAN                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    R5,R1               Save pointer to parameter list\n         USING FP,R5               Establish addressability to parms\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FIRST ARGUMENT MUST BE \"R\" (READ) OR \"W\" (WRITE).               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,FP_RW_A          GET ADDRESS OF ARG1 CHAR STRING\n         CLI   0(R1),C'R'          MUST BE UPPER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'W'          OR UPPER CASE W\n         BE    ENTRY_CODE_WRITE\n         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W\n         BE    ENTRY_CODE_WRITE\n         B     WRONG_ENTRY_CODE    ELSE ERROR\n         SPACE 1\nENTRY_CODE_READ DS 0H\n         MVI   MODE,TSVERETR       INDICATE READ MODE\n         B     SET_NAME_LENGTH\n         SPACE 1\nENTRY_CODE_WRITE DS 0H\n         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE\n         B     SET_NAME_LENGTH\n         SPACE 2\nSET_NAME_LENGTH DS 0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R9,FP_VARNAME_A     Point to variable name string text\n         L     R1,FP_VARNAME_L     Point to length of variable name\n         L     R10,0(,R1)          Load length of variable name string\n         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO\n         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)\n         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND\n         BNE   NOAMP               THEN...\n         LA    R9,1(,R9)            BUMP PAST IT\n         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.\nNOAMP    DS    0H                  ANYHOW...\n         LA    R15,0(R9,R10)       POINT TO END OF STRING\n         BCTR  R15,0               BUMP BACK TO LAST CHARACTER\nBLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS\n         BNE   ENDNAME\n         BCTR  R15,0\n         BCT   R10,BLOOP\nENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH\nNOCHECK  DS    0H\n         SPACE 2\nSETPARMS DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET UP PARAMETERS TO PASS TO IKJCT441                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R0,R0               MAKE A ZERO\n         XR    R1,R1\n         IC    R1,MODE             PICK UP MODE\n         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST\n         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME\n         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME\n         CLI   MODE,TSVERETR       IF MODE IS READ,\n         BNE   NOTREAD             THEN...\n         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME\n         B     AFTREAD             ELSE...\nNOTREAD  DS    0H                   (SET TO UPDATE)\n         L     R1,FP_VARVALUE_L     POINT TO VARIABLE VALUE LENGTH\n         L     R2,0(,R1)            LOAD LENGTH OF VARIABLE VALUE\n         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE\n         L     R2,FP_VARVALUE_A     GET ADDRESS OF VARIABLE VALUE\n         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE\nAFTREAD  DS    0H\n         ST    R0,CTOKEN           SET TOKEN (NOT USED)\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARMS       SET UP PARAMETER LIST\n         OI    CPARM6,X'80'        SET VL BIT\n         LA    R1,CPARMS           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R4,R15              GET RETURN CODE\n         BZ    OK                  IF ZERO, OK\n         CH    R4,=H'76'           IF RETURN CODE IS 76\n         BE    RC76                 OR\n         CH    R4,=H'80'             RETURN CODE IS 80\n         BE    RC80                 OR\n         CH    R4,=H'81'             RETURN CODE IS 81\n         BE    RC81                 OR\n         CH    R4,=H'40'             RETURN CODE IS 40 OR LESS\n         BH    RCOTHER                THEN\nRET441   B     RET441(R4)              BRANCH DEPENDING ON RETURN CODE\n         B     OK                  RC=4 IS OK\n         B     RC8\n         B     RC12\n         B     RC16\n         B     RCOTHER\n         B     RC24\n         B     RCOTHER\n         B     RC32\n         B     RC36\n         B     RC40\n         SPACE 1\nOK       DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   MODE,TSVERETR       IF NOT READ MODE,\n         BNE   RETURN              THEN JUST RETURN. ELSE (READ MODE)..\n         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE\n         L     R0,FP_VARVALUE_A    POINT TO VALUE AREA (WHERE TO MOVE)\n         L     R1,FP_VARVALUE_L    POINT TO LENGTH OF VALUE AREA\n         L     R1,0(,R1)           SET LENGTH OF WHERE TO MOVE IT\n         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE\n         LR    R15,R9              SET LENGTH OF WHAT TO MOVE\n         O     R15,=X'40000000'    SET FILL CHARACTER TO BLANK\n         L     R3,=A(MVCL+X'80000000')  Get address of 31-bit code\n         LA    R4,AFTMVCL               Get return address\n         BSM   R4,R3               Save current AMODE in R4, go to 31\nMVCL     DS    0H\n         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3\n         BSM   0,R4                Return to previous AMODE\nAFTMVCL  DS    0H\n         N     R15,=X'00FFFFFF'    CLEAR FILL CHARACTER, LEAVE LENGTH\n*\n* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT\n* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE\n* CAN RETURN THIS AS THE RETURN CODE.\n*\n* SET LENGTH FIELD (ARG 4) ACCORDING TO HOW MUCH MOVED.\n*\n         SR    R9,R15              LENGTH MINUS TRUNCATION\n         L     R1,FP_LENGTH_A      GET ADDRESS OF VALUE LENGTH AREA\n         ST    R9,0(,R1)           RETURN LENGTH TO THE CALLER\n         B     RETURN              RETURN WITH CODE IN R15\n         EJECT\nRC8      DS    0H\n         LA    R1,MSG8\n         B     ERROR\n         SPACE 1\nRC12     DS    0H\n         LA    R1,MSG12\n         B     ERROR\n         SPACE 1\nRC16     DS    0H\n         LA    R1,MSG16\n         B     ERROR\n         SPACE 1\nRC24     DS    0H\n         LA    R1,MSG24\n         B     ERROR\n         SPACE 1\nRC32     DS    0H\n         LA    R1,MSG32\n         B     ERROR\n         SPACE 1\nRC36     DS    0H\n         LA    R1,MSG36\n         B     ERROR\n         SPACE 1\nRC40     DS    0H\n         LA    R1,MSG40\n         B     ERROR\n         SPACE 1\nRC76     DS    0H\n         LA    R1,MSG76\n         B     ERROR\n         SPACE 1\nRC80     DS    0H\n         LA    R1,MSG80\n         B     ERROR\n         SPACE 1\nRC81     DS    0H\n         LA    R1,MSG81\n         B     ERROR\n         SPACE 1\nRCOTHER  DS    0H\n         MVC   OTHERMSG(MSGOTHER_LENGTH),MSGOTHER\n         CVD   R4,OTHERRC\n         UNPK  OTHERMSG+MSGOTHER_LENGTH(2),OTHERRC\n         OI    OTHERMSG+MSGOTHER_LENGTH+1,X'F0'\n         MVI   OTHERMSG+MSGOTHER_LENGTH+2,C'.'\n         LA    R1,OTHERMSG\n         LA    R0,MSGOTHER_LENGTH+3\n         STH   R0,0(,R1)\n         B     ERROR\n         EJECT\nERROR    DS    0H\n         SPACE 1\n         USING PSA,0\n         L     R15,PSATOLD           GET TCB ADDRESS\n         USING TCB,R15\n         L     R15,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R15\n         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R15,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R15\n         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE\n         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,R15\n         L     R8,RLGBECT            GET ADDRESS OF ECT\n         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE\n         LA    R15,ECB\n         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\n         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)\n         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR\n         XC    ECB,ECB              CLEAR ECB FOR PUTLINE\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15              IF PUTLINE FAILED,\n         BZ    PUTLOK               THEN...\nDOTPUT   DS    0H                    try to display message via TPUT\n*\n* Note: This will work only if the load module is loaded below the\n*       line.  But since this won't get executed unless there's a\n*       PUTLINE failure, which really shouldn't occur, we won't\n*       worry about it.\n*\n         LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE\n         LA    R0,L'PUTLFAIL\n         TPUT  (1),(0),R\n         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE\n         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE\n         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK\n         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK\n         TPUT  (1),(0),R             AND DISPLAY VIA TPUT\nPUTLOK   DS    0H\n         SPACE 1\nABENDIT  DS    0H                   FORCE ONCODE8093\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R1,500(,R4)          SET REASON CODE = RC + 500\n         ABEND (1),DUMP             FORCE U(N+500) ABEND\n         EJECT\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET RETURN CODE IN REGISTER 0.  THIS IS NECESSARY TO ALLOW THE      *\n* CALLER TO PICK UP THE RETURN CODE FROM A FORTRAN FUNCTION CALL.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,20(,R13) (SAVED R0)  SET RETURN CODE FOR FORTRAN\n         ST    R15,16(,R13) (SAVED R15) SET RET CODE FOR EVERYONE ELSE\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* ERROR ROUTINES                                                      *\n***********************************************************************\n         SPACE 1\nWRONG_NUMBER_ARGS DS 0H\n         LA    R1,WRONG_NUMBER_ARGS_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nINVALID_ARG_TYPE  DS 0H\n         LA    R1,INVALID_ARG_TYPE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nWRONG_ENTRY_CODE  DS 0H\n         LA    R1,WRONG_ENTRY_CODE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE\nLENPUTL  EQU   *-MPTLIST\n         SPACE\nWRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X\n               ' XTSVAR: WRONG NUMBER OF ARGUMENTS PASSED TO XTSVAR.'\nINVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X\n               ' XTSVAR: INVALID ARGUMENT TYPES PASSED TO XTSVAR.'\nWRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X\n               ' XTSVAR: CODE PASSED TO XTSVAR NOT \"R\" OR \"W\".'\nMSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN\nMSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'\nMSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'\nMSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'\nMSG24    WTO   MF=L,' XTSVAR24: REQUESTED CLIST VARIABLE IS A PROCEDUREX\n                NAME.'\nMSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'\nMSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME TOO LONG OR NULL.'\nMSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'\nMSG76    WTO   MF=L,' XTSVAR76: UNDEFINED &&SYSX CLIST VARIABLE.'\nMSG80    WTO   MF=L,' XTSVAR80: VARIABLE NAME NOT VALID FOR REXX.'\nMSG81    WTO   MF=L,' XTSVAR81: REXX ROUTINE DETECTED AN ERROR.'\n         SPACE 1\nMSGOTHER WTO   MF=L,' XTSVAR: CLIST VARIABLE ACCESS RETURN CODE '\nMSGOTHER_LENGTH EQU *-MSGOTHER\n         SPACE\nPUTLFAIL DC    C'XTSVAR: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING ISX\n               SUED VIA TPUT:'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R11\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F                 OS SAVE AREA\nOTHERRC  DS    D\n         SPACE\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\nOLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG\n         SPACE\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 2\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\n         SPACE 1\nCENTRY   DC    A(0)                ENTRY CODE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nMODE     DS    C                   R(EAD) OR W(RITE)\n         SPACE 1\nOTHERMSG DS    0A\n         DS    CL(MSGOTHER_LENGTH+3)\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MAPPING OF PARAMETER LIST PASSED FROM FORTRAN                       *\n***********************************************************************\n         SPACE 1\nFP       DSECT\n         SPACE 1\nFP_RW_A       DS A                 Address of R/W parameter\nFP_VARNAME_A  DS A                 Address of variable name\nFP_VARVALUE_A DS A                 Address of variable value\nFP_LENGTH_A   DS A                 Address of variable value length\nFP_RW_L       DS A                 Address of length of R/W parameter\nFP_VARNAME_L  DS A                 Address of length of variable name\nFP_VARVALUE_L DS A                 Address of length of variable value\nFP_LENGTH_L   DS A                 Address of nothing much\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJECT\n         SPACE 1\n         IKJCPPL\n         SPACE 1\n         IKJTSVT\n         SPACE 1\n         PRINT NOGEN\n         IHAPSA\n         SPACE 1\n         CVT   DSECT=YES\n         SPACE 1\n         IKJTCB\n         SPACE 1\n         IEZJSCB\n         SPACE 1\n         IKJPSCB\n         SPACE 1\n         IKJRLGB\n         END\n./ ADD NAME=XTSVARV  0100-07332-07332-0900-00538-00538-00000-SEB\n         TITLE 'XTSVARV  - CLIST VARIABLE ACCESS FOR PL/1'\n***********************************************************************\n*                                                                     *\n* XTSVARV  - CLIST VARIABLE ACCESS FOR PL/1                           *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* XTSVARV - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST        *\n* VARIABLE ACCESS FACILITY FOR PL/1.                                  *\n*                                                                     *\n* PL/1 INVOCATION:                                                    *\n*                                                                     *\n* DCL VALUE    CHAR(256) VAR;                                         *\n* DCL XTSVARV ENTRY (CHAR(*),      /* 'R(EAD)' OR 'W(RITE)'       */  *\n*                    CHAR(*) VAR,  /* THE NAME OF THE VARIABLE    */  *\n*                    CHAR(*) VAR)  /* THE VALUE TO BE READ OR SET */  *\n*              EXTERNAL;           /* DON'T SAY OPTIONS(ASM)!!!!! */  *\n* DCL PLIRETV BUILTIN;                                                *\n*                                                                     *\n* /* SAMPLE CODE TO READ THE VALUE OF A VARIABLE */                   *\n*                                                                     *\n* CALL XTSVARV ('R','SYSDVAL',VALUE);                                 *\n* IF PLIRETV ^= 0 THEN DO;                                            *\n*  PUT LIST('ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',PLIRETV);  *\n* END;                                                                *\n* PUT LIST('THE VALUE OF &SYDSVAL IS:', VALUE);                       *\n*                                                                     *\n* /* SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE */                 *\n*                                                                     *\n* VALUE = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL';       *\n* CALL XTSVARV ('W','SYSDVAL',VALUE);                                 *\n*                                                                     *\n*  ***********    S P E C I F I C A T I O N S    ***********          *\n*                                                                     *\n* PROGRAM NAME:  XTSVARV                                              *\n*                (ALIAS \"XSTDVL\" ESTABLISHED FOR FORTRAN.)            *\n* FUNCTION:      TO BE INVOKED FROM A PL/1 PROGRAM FOR THE PURPOSE    *\n*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *\n*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *\n* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *\n*                THE TARGET STRING MUST BE DECLARED LARGE ENOUGH TO   *\n*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *\n*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *\n* INPUT:         A STANDARD PL/1 PARAMETER LIST AS FOLLOWS:           *\n*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *\n*                CHARACTER IS \"R\" (READ, I.E. RETRIEVE A VALUE) OR    *\n*                \"W\" (WRITE, I.E. UPDATE A VALUE).                    *\n*  PARAMETER 2:  A VARYING-LENGTH CHARACTER STRING WHICH CONTAINS THE *\n*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *\n*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *\n*  PARAMETER 3:  A VARYING-LENGTH CHARACTER STRING USED AS FOLLOWS:   *\n*                FOR \"R\" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *\n*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *\n*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *\n*                FOR \"W\" (WRITE) MODE, CONTAINS THE VALUE TO BE       *\n*                ASSIGNED TO THE CLIST VARIABLE.                      *\n* RETURN CODES:                                                       *\n*  0 - FUNCTION SUCCESSFUL.                                           *\n*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *\n*        THE MAXIMUM DECLARED LENGTH OF THE THIRD PARAMETER, AND THE  *\n*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN CODE   *\n*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *\n* ABEND CODES:                                                        *\n* 0C3 (PL/1 ONCODE 8093 - \"ERROR\" CONDITION RAISED) - ISSUED WHEN AN  *\n* ERROR OTHER THAN TRUNCATION OCCURS.                                 *\n*                                                                     *\n* THE REASON CODE (IN PLIRETV) IS AS FOLLOWS:                         *\n*                                                                     *\n* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *\n* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *\n* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *\n*                                                                     *\n* PROCESSING:                                                         *\n*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *\n*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *\n*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *\n*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *\n*                                                                     *\n*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *\n*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *\n*                                                                     *\n* DOCUMENTATION:                                                      *\n* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *\n* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 2.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    RETURN CODE FR OM IKJCT441\nR5       EQU   5    RESERVED FOR PL/1\nR6       EQU   6    POINTER TO DOPE VECTOR FOR ARG 1\nR7       EQU   7    POINTER TO DOPE VECTOR FOR ARG 2\nR8       EQU   8    POINTER TO DOPE VECTOR FOR ARG 3\nR9       EQU   9    ADDRESS OF VARIABLE NAME\nR10      EQU   10   LENGTH OF VARIABLE NAME\nR11      EQU   11   STATIC BASE REGISTER\nR12      EQU   12   RESERVED FOR PL/1\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXTSVARV  CSECT\n         SAVE  (14,12),,&SYSDATE._&SYSTIME\n         LR    R11,R15\n         USING XTSVARV,R11\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS\n         EJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* VALIDITY CHECK PARAMETER LIST                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED\n         BO    WRONG_NUMBER_ARGS   THEN ERROR\n         TM    8(R1),X'80'         IF VL BIT DOESN'T SHOW 3 PARMS\n         BZ    WRONG_NUMBER_ARGS   THEN ERRROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* PROCESS PARAMETERS PASSED FROM PL/1                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LM    R6,R8,0(R1)         GET POINTERS TO DOPE VECTORS\n         CLI   6(R6),X'00'         IF ARG1 IS NOT CHAR(*) {FIXED},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         CLI   6(R7),X'80'         IF ARG2 IS NOT CHAR(*) {FIXED},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         CLI   6(R8),X'80'         IF ARG3 IS NOT CHAR(*) {FIXED},\n         BNE   INVALID_ARG_TYPE    THEN ERROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FIRST ARGUMENT MUST BE \"R\" (READ) OR \"W\" (WRITE).               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,0(,R6)           GET ADDRESS OF ARG1 CHAR STRING\n         CLI   0(R1),C'R'          MUST BE UPPER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R\n         BE    ENTRY_CODE_READ\n         CLI   0(R1),C'W'          OR UPPER CASE W\n         BE    ENTRY_CODE_WRITE\n         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W\n         BE    ENTRY_CODE_WRITE\n         B     WRONG_ENTRY_CODE    ELSE ERROR\n         SPACE 1\nENTRY_CODE_READ DS 0H\n         MVI   MODE,TSVERETR       INDICATE READ MODE\n         B     SET_NAME_LENGTH\nENTRY_CODE_WRITE DS 0H\n         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE\n         B     SET_NAME_LENGTH\n         SPACE 2\nSET_NAME_LENGTH DS 0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME STRING\n         LH    R10,0(,R1)          GET CURRENT LENGTH OF STRING\n         LA    R9,2(,R1)           POINT TO TEXT OF STRING\n         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO\n         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)\n         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND\n         BNE   NOAMP               THEN...\n         LA    R9,1(,R9)            BUMP PAST IT\n         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.\nNOAMP    DS    0H                  ANYHOW...\n         LA    R15,0(R9,R10)       POINT TO END OF STRING\n         BCTR  R15,0               BUMP BACK TO LAST CHARACTER\nBLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS\n         BNE   ENDNAME\n         BCTR  R15,0\n         BCT   R10,BLOOP\nENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH\nNOCHECK  DS    0H\n         SPACE 2\nSETPARMS DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET UP PARAMETERS TO PASS TO IKJCT441                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    R0,R0               MAKE A ZERO\n         XR    R1,R1\n         IC    R1,MODE             PICK UP MODE\n         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST\n         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME\n         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME\n         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME\n         CLI   MODE,TSVERETR       IF MODE IS READ,\n         BNE   NOTREAD             THEN...\n         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME\n         B     AFTREAD             ELSE...\nNOTREAD  DS    0H                   (SET TO UPDATE)\n         L     R1,0(,R8)            GET POINTER TO VARIABLE VALUE\n         LH    R2,0(,R1)            GET LENGTH OF VARIABLE VALUE\n         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE\n         LA    R2,2(,R1)            GET ADDRESS OF VARIABLE VALUE\n         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE\nAFTREAD  DS    0H\n         ST    R0,CTOKEN           SET TOKEN (NOT USED)\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARMS       SET UP PARAMETER LIST\n         OI    CPARM6,X'80'        SET VL BIT\n         LA    R1,CPARMS           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LR    R4,R15\n         B     RET441(R4)          BRANCH DEPENDING ON RETURN CODE\nRET441   B     OK                  RC=0 IS OK\n         B     OK                  RC=4 IS OK\n         B     RC8\n         B     RC12\n         B     RC16\n         B     RC20\n         B     RC24\n         B     RC28\n         B     RC32\n         B     RC36\n         B     RC40\n         B     RC44\n         B     RC48\n         B     RC52\n         B     RC56\n         B     RC60\n         SPACE 1\nOK       DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   MODE,TSVERETR       IF READ MODE\n         BNE   RETURN              THEN...\n         L     R2,0(,R8)           POINT TO CHAR(*) VAR ARG 3\n         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE\n         LA    R0,2(,R2)           SET ADDRESS OF WHERE TO MOVE IT\n         LH    R1,4(,R8)           SET LENGTH OF WHERE TO MOVE IT\n         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE\n         LR    R15,R9              SET LENGTH OF WHAT TO MOVE\n         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3\n*\n* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT\n* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE\n* CAN RETURN THIS AS THE RETURN CODE.\n*\n* SET LENGTH FIELD OF CHAR(*) VARYING ACCORDING TO HOW MUCH MOVED.\n*\n         SR    R9,R15              LENGTH MINUS TRUNCATION\n         STH   R9,0(,R2)           GIVES LENGTH(STRING) TO BE SET\n         B     RETURN              RETURN WITH CODE IN R15\n         SPACE 1\nRC8      DS    0H\n         LA    R1,MSG8\n         B     ERROR\n         SPACE 1\nRC12     DS    0H\n         LA    R1,MSG12\n         B     ERROR\n         SPACE 1\nRC16     DS    0H\n         LA    R1,MSG16\n         B     ERROR\n         SPACE 1\nRC20     DS    0H\n         LA    R1,MSG20\n         B     ERROR\n         SPACE 1\nRC24     DS    0H\n         LA    R1,MSG24\n         B     ERROR\n         SPACE 1\nRC28     DS    0H\n         LA    R1,MSG28\n         B     ERROR\n         SPACE 1\nRC32     DS    0H\n         LA    R1,MSG32\n         B     ERROR\n         SPACE 1\nRC36     DS    0H\n         LA    R1,MSG36\n         B     ERROR\n         SPACE 1\nRC40     DS    0H\n         LA    R1,MSG40\n         B     ERROR\n         SPACE 1\nRC44     DS    0H\n         LA    R1,MSG44\n         B     ERROR\n         SPACE 1\nRC48     DS    0H\n         LA    R1,MSG48\n         B     ERROR\n         SPACE 1\nRC52     DS    0H\n         LA    R1,MSG52\n         B     ERROR\n         SPACE 1\nRC56     DS    0H\n         LA    R1,MSG56\n         B     ERROR\n         SPACE 1\nRC60     DS    0H\n         LA    R1,MSG60\n         B     ERROR\n         EJECT\nERROR    DS    0H\n         SPACE 1\n         USING PSA,0\n         L     R15,PSATOLD           GET TCB ADDRESS\n         USING TCB,R15\n         L     R15,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R15\n         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R15,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R15\n         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE\n         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,R15\n         L     R8,RLGBECT            GET ADDRESS OF ECT\n         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE\n         LA    R15,ECB\n         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL\n         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM\n         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)\n         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR\n         XC    ECB,ECB              CLEAR ECB FOR PUTLINE\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15              IF PUTLINE FAILED,\n         BZ    PUTLOK               THEN...\nDOTPUT   LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE\n         LA    R0,L'PUTLFAIL\n         TPUT  (1),(0),R\n         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE\n         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE\n         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK\n         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK\n         TPUT  (1),(0),R             AND DISPLAY VIA TPUT\nPUTLOK   DS    0H\n         SPACE 1\nABENDIT  DS    0H                   FORCE ONCODE8093\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R15,500(,R4)         SET REASON CODE = RC + 500\n         ST    R15,68(,R12)         STORE IN PLIRETV AREA\n         EX    0,*                  FORCE 0C3 ABEND\n         EJECT\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* STORE RETURN CODE IN TCA+X'44'.  THIS IS NECESSARY TO ALLOW THE     *\n* CALLER TO PICK UP THE RETURN CODE VIA \"PLIRETV\" DESPITE NOT BEING   *\n* ABLE TO SPECIFY OPTIONS(RETCODE) IN THE DECLARE.                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    R15,68(,R12)        STORE RETURN CODE IN PL/1 TCA\n         SPACE 1\n         LR    R1,R13\n         L     R13,4(,R13)\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* ERROR ROUTINES                                                      *\n***********************************************************************\n         SPACE 1\nWRONG_NUMBER_ARGS DS 0H\n         LA    R1,WRONG_NUMBER_ARGS_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nINVALID_ARG_TYPE  DS 0H\n         LA    R1,INVALID_ARG_TYPE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         SPACE 1\nWRONG_ENTRY_CODE  DS 0H\n         LA    R1,WRONG_ENTRY_CODE_MESSAGE\n         XR    R4,R4\n         B     ERROR\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE\nLENPUTL  EQU   *-MPTLIST\n         SPACE\nWRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X\n               ' XTSVARV: WRONG NUMBER OF ARGUMENTS PASSED TO XTSVARV.'\nINVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X\n               ' XTSVARV: INVALID ARGUMENT TYPES PASSED TO XTSVARV.'\nWRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X\n               ' XTSVARV: CODE PASSED TO XTSVARV NOT \"R\" OR \"W\".'\nMSG0     WTO   MF=L,' XTSVAR00: INVALID PARAMETERS PASSED TO XTSVARV.'\nMSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN\nMSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'\nMSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'\nMSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'\nMSG20    WTO   MF=L,' XTSVAR20: CLIST VARIABLE ACCESS RETURN CODE 20.'\nMSG24    WTO   MF=L,' XTSVAR24: CLIST VARIABLE ACCESS RETURN CODE 24.'\nMSG28    WTO   MF=L,' XTSVAR28: CLIST VARIABLE ACCESS RETURN CODE 28.'\nMSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'\nMSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME IS TOO LONG.'\nMSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'\nMSG44    WTO   MF=L,' XTSVAR44: CLIST VARIABLE ACCESS RETURN CODE 44.'\nMSG48    WTO   MF=L,' XTSVAR48: CLIST VARIABLE ACCESS RETURN CODE 48.'\nMSG52    WTO   MF=L,' XTSVAR52: CLIST VARIABLE ACCESS RETURN CODE 52.'\nMSG56    WTO   MF=L,' XTSVAR56: CLIST VARIABLE ACCESS RETURN CODE 56.'\nMSG60    WTO   MF=L,' XTSVAR60: CLIST VARIABLE ACCESS RETURN CODE 60.'\n         SPACE\nPUTLFAIL DC    C'XTSVARV: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING IX\n               SSUED VIA TPUT:'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R11\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F                 OS SAVE AREA\n         SPACE\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\nOLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG\n         SPACE\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE 2\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\n         SPACE 1\nCENTRY   DC    A(0)                ENTRY CODE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nMODE     DS    C                   R(EAD) OR W(RITE)\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJECT\n         SPACE 1\n         IKJCPPL\n         SPACE 1\n         IKJTSVT\n         SPACE 1\n         PRINT NOGEN\n         IHAPSA\n         SPACE 1\n         CVT   DSECT=YES\n         SPACE 1\n         IKJTCB\n         SPACE 1\n         IEZJSCB\n         SPACE 1\n         IKJPSCB\n         SPACE 1\n         IKJRLGB\n         END\n./ ADD NAME=XUSERS   0100-07332-07332-0900-00390-00390-00000-SEB\n         TITLE 'XUSERS - TSO command to display users logged on'\n*\n***********************************************************************\n*                                                                     *\n* XUSERS - based on the USERS program by PQS1448 (Peter Stasiowski).  *\n*                                                                     *\n* Rewritten as a TSO command processor by SEB1525 (Steve Bacher) 7/88 *\n*                                                                     *\n***********************************************************************\n* This TSO command takes no operands (yet).\n***********************************************************************\n*\n***********************************************************************\n* INFORMATION ON THE GQSCAN MACRO INSTRUCTION MAY BE FOUND IN:        *\n*      OS/VS2 SYSTEM PROGRAMMING LIBRARY: SUPERVISOR                  *\n*                     GC28-1046-0                                     *\n*             FIRST EDITION (DECEMBER, 1980)                          *\n*                  WITH TNL GN28-4917                                 *\n***********************************************************************\n         SPACE 1\nXUSERS   CSECT\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2   Misc.\nR3       EQU   3   Address of each basic fixed RIB\nR4       EQU   4   Address of output area\nR5       EQU   5   Address of end of output area\nR6       EQU   6   Address of each RIB extent\nR7       EQU   7   RIB extent counter\nR8       EQU   8   Address of variable section of RIB\nR9       EQU   9   RIB counter\nR10      EQU   10  Count of user names\nR11      EQU   11  Address of user name buffer\nR12      EQU   12  Base register\nR13      EQU   13  Save area pointer\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SAVE  (14,12),,XUSERS_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XUSERS,R12\n         LR    R2,R1               Save parameter address\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R15,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n*\n* Initialization\n*\n         USING CPPL,R2\n         SPACE 1\n         MVC   PTLIST(LENPUTL),MPTLIST\n         MVC   PTDATA(LENPUTD),MPTDATA\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         MVC   MAJOR,=CL8'SYSIKJUA'\n         MVC   MINOR,BLANKS\n         MVC   TPUTAREA,BLANKS\n         LA    R0,ECB\n         ST    R0,IOPLECB\n         XR    R0,R0\n         ST    R0,GQREG0\n         ST    R0,GQREG1\n         ST    R0,TOK\n         ST    R0,AREAPTR\n         ST    R0,AREALEN\n         ST    R0,QNAME\n         ST    R0,RNAME\n         ST    R0,SYSNM\n         ST    R0,ASID\n         ST    R0,REQCNT\n         ST    R0,OWNCNT\n         ST    R0,WAITCNT\n         LA    R0,TOK              Address of token\n         ST    R0,TOKEN\n         MVC   REQLIM,=A(32767)    Request limit = max\n         MVI   FLAGSA,B'11100000'  Scope=step, system, and systems\n         MVI   FLAGSB,B'00000000'  Scope=step, system, and systems\n         MVI   RNMLEN,0            RNAME length\n         LA    R0,MAJOR            PLACE ADDRESS OF QNAME\n         ST    R0,QNAME            IN PARAMETER LIST\n         L     R0,INCR             GET FIRST LENGTH OF AREA\n         ST    R0,AREALEN          SAVE IT\n         GETMAIN R,LV=(0)          GET IT\n         ST    R1,AREAPTR          SAVE ADDRESS OF AREA\n         SPACE\n         L     R0,=A(UBUFLEN)      Get storage to hold enough userids\n         GETMAIN R,LV=(0)\n         LR    R11,R1\n         ST    R11,UBUFPTR\n         XR    R10,R10\n         SPACE\nRETRY    DS    0H\n         L     R1,AREAPTR          GET ADDRESS OF CURRENT AREA\n         EJECT\n***********************************************************************\n         SPACE\n         GQSCAN MF=(E,QSPARMS)     SCAN ENQ INFO\n         SPACE\n***********************************************************************\n         EJECT\nAFTQCSAN DS    0H\n         STM   R0,R1,GQREGS        SAVE RETURN PARAMETER REGISTERS\n         LR    R9,R1               GET NUMBER OF RIBS RETURNED\n         LTR   R2,R15              TEST RETURN CODE FROM GQSCAN\n         BZ    DISPLAY             IF ZERO, GO SHOW USER\n         CH    R2,=H'4'            IF RC=4 (NO DATA)\n         BNE   TRY8                THEN\n         LA    R1,MSG_NODATA        Say no TSO users\n         BAL   R14,PUTMSG\n         LA    R15,4                Set return code to 4\n         B     RETURN\n         SPACE\nTRY8     CH    R2,=H'8'            IF RC=8 (TOO MUCH DATA)\n         BNE   NOT8                THEN\n         L     R0,AREALEN           GET CURRENT AREA LENGTH\n         L     R1,AREAPTR           GET CURRENT AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)    FREE EXISTING AREA\n         L     R0,INCR              GET AREA LENGTH INCREMENT\n         AL    R0,AREALEN           INCREASE THE LENGTH\n         ST    R0,AREALEN           SAVE IT\n         GETMAIN RC,LV=(0)          TRY TO GET IT\n         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA IF ANY\n         LTR   R15,R15              IF COULD NOT GET IT\n         BZ    RETRY                THEN\n         L     R0,AREALEN           GET LENGTH\n         S     R0,INCR              GO BACK TO PREVIOUS LENGTH\n         GETMAIN R,LV=(0)           GET IT (WE KNOW THAT WE CAN)\n         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA\n         LA    R1,NEEDED_MORE_DATA\n         BAL   R14,PUTMSG\n         B     RETRY                AND TRY AGAIN.\n         SPACE\nNOT8     DS    0H\n         LA    R1,ABENDMSG\n         BAL   R14,PUTMSG\n         ABEND (R2),DUMP\n         EJECT\nDISPLAY  DS    0H                  OK - NOW DISPLAY INFO\n         SPACE\n         L     R3,AREAPTR          START OF Q INFO\n         USING RIB,R3              ADDRESS THE BASIC FIXED RIB\nCONTINUE DS    0H\n         LH    R8,LRIBFIX          LENGTH OF FIXED RIB\n         ALR   R8,R3                PLUS ADDRESS OF FIXED RIB\n         USING RIBVAR,R8            GIVES VARIABLE SECTION OF RIB\n         ICM   R7,15,RIBNRIBE      GET NUMBER OF EXTENTS RETURNED\n         BZ    NOEXTS              IF NONE, BYPASS\n         LR    R6,R8               BUMP PAST VARIABLE PART OF RIB\n         AH    R6,RIBVLEN          BUMP PAST VARIABLE PART OF RIB\n         USING RIBE,R6             RIB EXTENT\nEXTLOOP  DS    0H\n         LA    R10,1(,R10)         Increment userid count\n         CH    R10,=Y(512)         If more than we can handle\n         BNH   OKSOFAR             then...\n         LA    R1,TOOMANYUSERS\n         BAL   R14,PUTMSG\n         LA    R15,16\n         B     RETURN\n         SPACE 1\nOKSOFAR  DS    0H\n         MVC   0(8,R11),RIBRNAME   Add user name to user name buffer\n         LA    R11,8(,R11)         Get ready for next user name\n         SPACE\n         AH    R6,LRIBE            ADDR(RIBE)+LENGTH(RIBE) -> NEXT RIBE\n         BCT   R7,EXTLOOP          LOOP UNTIL NO MORE EXTENTS\n         SPACE\nNOEXTS   DS    0H\n         LA    R3,0(,R6)           END OF PREV RIBE = BEGIN NEXT RIBE\n         BCT   R9,CONTINUE         CONTINUE UNTIL NO MORE RIBS\n         SPACE\n*\n***********************************************************************\n*                                                                     *\n* All user names stored in the user name buffer.  Now write out stuff *\n*                                                                     *\n***********************************************************************\n*\n         MVC   TPUTAREA+0(L'TSOUSERS),TSOUSERS\n         CVD   R10,DOUBLE          Convert number of TSO users\n         MVC   TPUTAREA+L'TSOUSERS(4),=X'40202120'\n         ED    TPUTAREA+L'TSOUSERS(4),DOUBLE+6\n         LA    R4,TPUTAREA+L'TSOUSERS+4\n         BAL   R14,LINEOUT         Write \"TSO USERS nnn\"\n         MVC   TPUTAREA,BLANKS\n*\n***********************************************************************\n*                                                                     *\n* Sort the userids by name.  This code taken from PQS1448 \"USERS\" cmd *\n*                                                                     *\n***********************************************************************\n*\nSRT      CH    R10,=H'1'           Skip sort if only one user\n         BNH   PRT\nSRT1     LR    R0,R10              Get number of user names - 1\n         BCTR  R0,0\n         XR    R15,R15             Set something-moved flag = off\n         L     R1,UBUFPTR          Get address of first user name\nSRT2     CLC   0(8,R1),8(R1)       If username(i) > username(i+1)\n         BNH   SRT3                then...\n         MVC   DOUBLE(8),0(R1)      swap usernames\n         MVC   0(8,R1),8(R1)\n         MVC   8(8,R1),DOUBLE\n         LA    R15,1                set something-moved flag = on\nSRT3     LA    R1,8(,R1)           Next username\n         BCT   R0,SRT2             Loop until all usernames processed\n         LTR   R15,R15             If anything was moved this round,\n         BNZ   SRT1                then do another sorting loop\n         SPACE 1\nPRT      DS    0H                  Now ready to print sorted userids\n         SPACE 1\n         L     R11,UBUFPTR         Point to sorted user names\n         LA    R4,TPUTAREA         Point to output area\n         LA    R5,TPUTAREA+L'TPUTAREA-9 Point to end of output area\n         SPACE 1\nWRITEM   DS    0H\n         CR    R4,R5               If at end of output line\n         BNH   NOOUT               then\n         BAL   R14,LINEOUT          write out the current line\nNOOUT    DS    0H\n         MVC   0(8,R4),0(R11)      Move userid\n         MVI   8(R4),C' '          Separate user names\n         LA    R4,9(,R4)           Bump line pointer\n         LA    R11,8(,R11)         Bump user buffer pointer\n         BCT   R10,WRITEM          Loop (#-of-users) times\n         BAL   R14,LINEOUT         Then write out last line if any\n         XR    R15,R15             Set return code to zero\n         EJECT\nRETURN   DS    0H\n         L     R0,AREALEN\n         L     R1,AREAPTR\n         FREEMAIN R,LV=(0),A=(1)\n         L     R0,=A(UBUFLEN)\n         L     R1,UBUFPTR\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        Store return code in savearea\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nLINEOUT  DS    0H                  Write a line\n         LR    R2,R14              Save return address\n         LR    R0,R4               Point to end of data written so far\n         LA    R1,TPUTAREA         Point to beginning of data\n         SR    R0,R1               Get length of data\n         BNPR  R2                  If no data to write, skip\n         AH    R0,=H'4'            Set up header for PUTLINE\n         SLL   R0,16\n         ST    R0,TPUTHDR\n         PUTLINE PARM=PTDATA,MF=(E,IOPL),                              X\n               OUTPUT=(TPUTHDR,TERM,SINGLE,DATA)\n         LA    R4,TPUTAREA         Place to put next user name\n         LTR   R15,R15             Check return code from PUTLINE\n         BZR   R2                  If OK, return\n         LR    R2,R15              Else save return code\n         TPUT  BADPUT,L'BADPUT     Write error message\n         LA    R0,L'TPUTAREA\n         LA    R1,TPUTAREA\n         SLR   R0,R1\n         TPUT  (1),(0),R           Write line we tried to put out\n         ABEND (R2),DUMP           Abend with PUTLINE RC as user code\n         EJECT\nPUTMSG   DS    0H                  Display message via PUTLINE\n*\n*                                  R1 -> message header || text\n*\n         LR    R2,R14              Save return address\n         LA    R0,1                Define 1 message segment\n         STM   R0,R1,OLD           Set up output line descriptor\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R1,R15              If PUTLINE OK,\n         BZR   R2                  then return. Else\n         ABEND (1),DUMP            Abend with PUTLINE RC as user code\n         EJECT\n         SPACE\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n         SPACE\nMPTDATA  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,DATA)\nLENPUTD  EQU   *-MPTDATA\n         SPACE\nINCR     DC    F'8192'             INCREMENT FOR GETMAINS\n         SPACE\n         SPACE 1\nBLANKS   DC    CL256' '\n         EJECT\nTSOUSERS DC    C'TSO USERS '\nBADPUT   DC    C'XUSERS PUTLINE failure trying to write this line:'\nABENDMSG WTO   MF=L,'XUSERS002 XUSERS failed, GQSCAN error code = ABENDX\n                code of following ABEND.'\nTOOMANYUSERS WTO MF=L,                                                 X\n               'XUSERS003 More than 512 TSO users logged on.'\nMSG_NODATA WTO MF=L,'XUSERS001 No TSO users are logged on.'\nNEEDED_MORE_DATA WTO MF=L,'XUSERS needed more storage to get all data.'\n         EJECT\n         LTORG\n         SPACE\n         EJECT\nDATD     DSECT\n         SPACE 1\nSAVEAREA DS    9D\nDOUBLE   DS    D\n*\n* VALUES PASSED BACK FROM THE GQSCAN SERVICE\n*\nGQREGS   DS    2F\n         ORG   GQREGS\nGQREG0   DS    F                   REGISTER ZERO FROM GQSCAN\n         ORG   GQREG0\nLRIBFIX  DS    H                   LENGTH OF EACH FIXED RIB\nLRIBE    DS    H                   LENGTH OF EACH RIBE\nGQREG1   DS    F                   REGISTER ONE FROM GQSCAN\n         ORG   GQREG1\nNUMRIBS  DS    F                   NUMBER OF RIBS COPIED\nTOK      DC    F'0'                TOKEN FOR GQSCAN PROCESSING (UNUSED)\nMAJOR    DC    CL8' '\nMINOR    DC    CL256' '\nQSPARMS  DS    0F\n         SPACE\n***********************************************************************\n*           PARAMETER LIST TO ISGQSCAN MAPPED AS FOLLOWS:             *\n***********************************************************************\n         SPACE\nAREAPTR  DC    A(0)           AREAPTR    ADDR OF USER SPECIFIED AREA\nAREALEN  DC    A(0)           AREALEN    SIZE OF USER SPECIFIED AREA\nQNAME    DC    A(0)           QNAME      QNAME (MAJOR NAME) ADDRESS\nRNAME    DC    A(0)           RNAME      RNAME (MINOR NAME) ADDRESS\nSYSNM    DC    A(0)           SYSNM      SYSNAME ADDRESS\nASID     DC    A(0)           ASID       ASID VALUE\nREQCNT   DC    A(0)           REQCNT     REQUEST COUNT\nOWNCNT   DC    A(0)           OWNCNT     OWNER COUNT\nWAITCNT  DC    A(0)           WAITCNT    WAIT COUNT\nTOKEN    DC    A(TOK)         TOKEN      TOKEN ADDRESS\nREQLIM   DC    A(32767)       REQLIM     REQUEST LIMIT = MAX\nFLAGSA   DC    BL1'11100000'  FLAGSA     RESERVE/SCOPE FLAGS\n*                            1.......    SCOPE=STEP\n*                            .1......    SCOPE=SYSTEM\n*                            ..1.....    SCOPE=SYSTEMS\n*                            ...1....    SCOPE=LOCAL\n*                            ....1...    SCOPE=GLOBAL\nFLAGRNO  EQU   B'00000100'   .....1..    RESERVE=NO\nFLAGRYES EQU   B'00000010'   ......1.    RESERVE=YES\n*                            .......1    RESERVED\nFLAGSB   DC  BL1'00000000'    FLAGSB     VARIABLE SPECIFIED FLAGS\nFLAGSYSN EQU   B'10000000'   1.......    SYSNAME SPECIFIED\n*                            .1......    REQCNT SPECIFIED\n*                            ..1.....    OWNCNT SPECIFIED\nFLAGWAIT EQU   B'00010000'   ...1....    WAITCNT SPECIFIED\nFLAGTOK  EQU   B'00001000'   ....1...    TOKEN SPECIFIED\n*                            .....1..    RESERVED\n*                            ......1.    RESERVED\n*                            .......1    RESERVED\nRNMLEN   DC    YL1(0)                    RNAME LENGTH\n         SPACE\nUBUFPTR  DC    A(0)\nUBUFLEN  EQU   512*8               Room for 512 userids\n         SPACE\nECB      DS    F                   ECB FOR TSO ROUTINES\nOLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR\nOLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS\nOLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT\n         SPACE 1\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nPTDATA   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,DATA)\n         SPACE 1\nIOPL     DS    0H\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 1\nTPUTHDR  DS    F\nTPUTAREA DS    CL(8*9)\n         SPACE 1\nSIZDATD  EQU   *-DATD\n         EJECT\n         ISGRIB ,   MAP THE DATA PASSED BACK BY ISGQSCAN\n         SPACE\n         IKJCPPL\n         SPACE\n         CVT    DSECT=YES,PREFIX=YES\n         SPACE\n         END\n./ ADD NAME=XUSING   0100-07332-07332-0900-00490-00490-00000-SEB\n         TITLE 'XUSING - TSO COMMAND TO DISPLAY WHO''S USING A DEVICE'\n***********************************************************************\n*                                                                     *\n* SYNTAX:   XUSING VOLUME(VOLSER) UNIT(UNITNUMBER) DEVICE(UNITNUMBER) *\n*                                                                     *\n* RETURN CODE: 0 - NOBODY IS USING THE DEVICE                         *\n*              4 - SOMEBODY IS USING THE DEVICE                       *\n*              8 - DEVICE NOT FOUND                                   *\n*             12 - INVALID INPUT TO COMMAND                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    ADDRESS THE CVT\nR4       EQU   4    ADDRESS THE PDL (PARSE OUTPUT)\nR5       EQU   5    ADDRESS THE UCB\nR6       EQU   6    .\nR7       EQU   7    LINK REGISTER FOR PUTLINE\nR8       EQU   8    ADDRESS OF FIRST IOQ FOR UCB\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXUSING   CSECT\n         SAVE  (14,12),,XUSING_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XUSING,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         USING CPPL,R2             ADDRESS INPUT CPPL\n         XC    ANSWER,ANSWER\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R14,ECB\n         ST    R14,IOPLECB\n         L     R15,=V(XFVOLPCL)\n         LA    R0,ANSWER\n         L     R1,CPPLCBUF\n         STM   R14,R1,PPLECB\n         ST    R13,PPLUWA          USER WORK AREA = \"DATD\"\n         MVC   PTLIST(PTLISTL),SPTLIST\n         LA    R14,1\n         LA    R15,OUTHDR\n         LA    R0,L'OUTLINE+4\n         SLL   R0,16\n         STM   R14,R0,OLD\n         SPACE\n         XC    ECB,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   RETURN12\n         L     R4,ANSWER\n         USING PDL,R4\n         MVC   SRCHVOL,BLANKS\n         MVC   SRCHCUU,BLANKS\n         MVI   FLAGS,X'00'         INITIALIZE FLAGS\n         TM    PDLVOL+6,X'80'      IF VOLUME SERIAL WAS SPECIFIED,\n         BNO   BYPVOL              THEN...\n         TM    PDLUNIT+6,X'80'      If unit name was also specified,\n         BO    ERRBOTH               then error - can't specify both\n         L     R14,PDLVOL+0         Get address of volume serial\n         LH    R15,PDLVOL+4         Get length of volume serial\n         BCTR  R15,0\n         EX    R15,MVCVOL           Move volume serial to work area\n         OI    FLAGS,VOLSPEC        INDICATE VOL SER SPECIFIED\n         B     MOVEDONE\n         SPACE 1\nMVCVOL   MVC   SRCHVOL(0),0(R14)   Move volume serial to work area\n         SPACE 1\nBYPVOL   DS    0H                  No volume - look for unit\n         TM    PDLUNIT+6,X'80'     If unit name was not specified\n         BNO   ERRNONE              then error - need at least one\n         L     R14,PDLUNIT+0       Get address of unit number\n         MVC   SRCHCUU(3),0(R14)   Move unit number to work area\n         OI    FLAGS,CUUSPEC        INDICATE UNIT NAME SPECIFIED\nMOVEDONE DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Locate the UCB for this volume or unit.                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R3,X'10'            GET CVT ADDRESS\n         USING CVTMAP,R3           SET UP ADDRESSABILITY TO CVT\n         XC    WORKAREA,WORKAREA   CLEAR WORK AREA\n         LA    R14,WORKAREA        GET ADDRESS OF WORK AREA\n         LA    R15,DEVCLASS        GET ADDRESS OF AREA CONTAINING\n         MVI   DEVCLASS,X'00'      THE DEVICE CLASS TO BE SEARCHED\n         LA    R0,ADDRUCB          GET ADDRESS OF WORD WHERE SCAN\n*                                  SERVICE WILL STORE THE UCB ADDRESS\n         STM   R14,R0,PARMLIST\n         OI    PARMUCB,X'80'       INDICATE END OF PARMLIST\n         XR    R8,R8               CLEAR ENTRY COUNT\nSEARCH   DS    0H\n         LA    R1,PARMLIST         PUT PARMLIST ADDRESS IN REGISTER 1\n         L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS\n         BALR  R14,R15             GO TO SCAN SERVICE.\n         LTR   R15,R15             HAS A UCB BEEN RETURNED?\n         BNZ   NOMATCH             NO, AT END OF DEVICE CLASS AND\n*                                  NO MATCH FOUND\n         L     R5,ADDRUCB          GET UCB ADDR RETURNED BY SCAN SRVCE\n         SH    R5,=Y(UCBOB-UCB)    Bump back to UCB prefix\n         USING UCB,R5              SET UP ADDRESSABILITY TO UCB\n         TM    FLAGS,VOLSPEC       IF VOLUME SERIAL REQUESTED,\n         BZ    NOCHKVOL            THEN\n         CLC   SRCHVOL,UCBVOLI      IS THIS THE VOL WE'RE LOOKING FOR?\n         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.\nNOCHKVOL DS    0H\n         TM    FLAGS,CUUSPEC       IF UNIT NUMBER REQUESTED,\n         BZ    NOCHKCUU            THEN\n         CLC   SRCHCUU,UCBNAME      IS THIS THE CUU WE'RE LOOKING FOR?\n         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.\nNOCHKCUU DS    0H\n*                                  NOTE:  THE WORK AREA MUST NOT BE\n*                                         CHANGED BETWEEN CALLS TO\n*                                         THE SCAN SERVICE ROUTINE\n         SPACE\nFOUND    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Now see if any jobs have this unit allocated, and who they are.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R8,UCBEXTPT         Get address of UCB extension\n         USING UCBCMEXT,R8\n         LH    R9,UCBASID          Get ASID that has this UCB allocated\n         LTR   R9,R9\n         BZ    NOTALLOC\n         L     R15,X'10'           Get CVT address\n         USING CVT,R15\n         L     R10,CVTASVT         Get ASVT address\n         DROP  R15\n         USING ASVT,R10\n         BCTR  R9,0\n         SLA   R9,2                Convert ASID to ASVT index\n         L     R11,ASVTENTY(R9)    Get ASCB address for this ASID\n         USING ASCB,R11\n         L     R6,ASCBCSCB         Get CSCB address\n         USING CHAIN,R6\n*\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE\n         MVC   OUTMSGID(L'MSGID),MSGID\n         MVC   OUTVOL,UCBVOLI\n         MVC   OUTUNIT,UCBNAME\n         UNPK  OUTASID(5),UCBASID(3)\n         TR    OUTASID(4),TRTBL\n         MVI   OUTASID+4,C' '\n         MVC   OUTNAME1,CHAIN+X'08'\n         MVC   OUTNAME2,CHAIN+X'10'\n         MVC   OUTNAME3,CHAIN+X'20'\n         LA    R1,OUTLINE\n         LA    R0,L'OUTLINE\n         BAL   R7,PUTLINE          DISPLAY THIS ENTRY LINE\n*\n         B     RETURN0             Return, somebody has it allocated\n         SPACE\nNOMATCH  DS    0H\n         MVC   OUTLINE(L'NOTFOUND),NOTFOUND\n         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED\n         BZ    WASNTVOL            THEN\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(7),=C'VOLUME '\n         MVC   OUTLINE+(NFSTUFF-NF1)+7(6),SRCHVOL\n         B     AFTWASNT\nWASNTVOL DS    0H                  Else must have been a unit number\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(10),=C'UNIT NAME '\n         MVC   OUTLINE+(NFSTUFF-NF1)+10(3),SRCHCUU\nAFTWASNT DS    0H\n         LA    R0,L'NOTFOUND+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN8\n         EJECT\nNOTALLOC DS    0H\n         MVC   OUTLINE(L'NAMSG),NAMSG\n         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED\n         BZ    XASNTVOL            THEN\n         MVC   OUTLINE+(NASTUFF-NA1)+0(7),=C'VOLUME '\n         MVC   OUTLINE+(NASTUFF-NA1)+7(6),SRCHVOL\n         B     AFTXASNT\nXASNTVOL DS    0H                  Else must have been a unit number\n         MVC   OUTLINE+(NASTUFF-NA1)+0(10),=C'UNIT NAME '\n         MVC   OUTLINE+(NASTUFF-NA1)+10(3),SRCHCUU\nAFTXASNT DS    0H\n         LA    R0,L'NAMSG+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN4\n         EJECT\nERRBOTH  DS    0H\n         MVC   OUTLINE(L'BOTHMSG),BOTHMSG\n         LA    R0,L'BOTHMSG+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN12\n         SPACE 2\nERRNONE  DS    0H\n         MVC   OUTLINE(L'NONEMSG),NONEMSG\n         LA    R0,L'NONEMSG+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN12\n         EJECT\nRETURN4  DS    0H                  RETURN WITH CODE 4\n         SPACE\n         LA    R2,4                SET RETURN CODE TO FOUR\n         B     RETURNP\n         SPACE 2\nRETURN8  DS    0H                  RETURN WITH CODE 8\n         SPACE\n         LA    R2,8                SET RETURN CODE TO EIGHT\n         B     RETURNP\n         SPACE 2\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         SPACE\n         LA    R2,12               SET RETURN CODE TO TWELVE\n         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE\n         SPACE 2\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R2,R2               SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *\n***********************************************************************\nRETURNP  DS    0H\n         SPACE\n         LA    R1,ANSWER\n         IKJRLSA (1)               RELEASE PARSE STORAGE\n         SPACE\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *\n***********************************************************************\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* PUTLINE SUBROUTINE  - LINK REGISTER IS R7                           *\n***********************************************************************\n         SPACE\nPUTLINE  DS    0H\n         TR    OUTLINE(L'OUTLINE),TRANSTBL\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15\n         BNZ   0(,R15)             BRANCH TO LOW CORE IF PUTLINE FAILS\n         BR    R7\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\nSPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nPTLISTL  EQU   *-SPTLIST\n         SPACE 1\nMSGID    DC    C'XUSING01:'\nNA1      DC    C'XUSING03: '\nNASTUFF  DC    CL13' '\nNA3      DC    C' NOT ALLOCATED'\nNAMSG    EQU   NA1,*-NA1,C'C'\n         SPACE\nNF1      DC    C'XUSING02: '\nNFSTUFF  DC    CL13' '\nNF3      DC    C' NOT FOUND'\nNOTFOUND EQU   NF1,*-NF1,C'C'\n         SPACE\nBLANKS   EQU   NFSTUFF,8,C'C'      GENERAL PURPOSE BLANKS\n         SPACE\nTESTTBL  DC    256YL1(*-TESTTBL)\n         ORG   TESTTBL+C'*'\n         DC    X'FF'\n         ORG\n         SPACE\nMASKTBL  DC    256X'00'\n         ORG   MASKTBL+C'*'\n         DC    X'FF'\n         ORG\n         SPACE\nTRANSTBL DS    0C\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/........\u00a0,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    C'................'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nTRTBL    EQU   *-256\n         EJECT\nBOTHMSG  DC    C'XUSING05: Specify VOLUME or UNIT name, not both.'\nNONEMSG  DC    C'XUSING04: Either a VOLUME or a UNIT name is required.'\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n*******************************************************************\n*\n*  Parse validity check exit for unitname.\n*\n*******************************************************************\n         SPACE 1\nUNITCHK  DS   0H\n         SPACE 1\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING UNITCHK,R12\n         SPACE 1\n         L     R8,0(,R1)           Get address of unit number PDE\n         L     R5,0(,R8)           Get address of unit number\n         LH    R6,4(,R8)           Get length of unit number\n         LA    R0,3\n         CR    R6,R0               Length must be equal to 3\n         BNE   UNITNG\n         TRT   0(3,R5),UNITTBL     Check for valid characters\n         BZ    UNITOK\nUNITNG   LA    R15,4               Invalid unit number\n         B     UNITRET\nUNITOK   XR    R15,R15             Valid unit number\nUNITRET  L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14                 Return to PARSE\n         SPACE 1\nUNITTBL  DC    256YL1(1)           All characters invalid except...\n         ORG   UNITTBL+C'0'        0-9\n         DC    10YL1(0)             and\n         ORG   UNITTBL+C'A'        A-F\n         DC    6YL1(0)\n         ORG   ,\n         SPACE 1\n         DROP  R12\n         EJECT\n***********************************************************************\n* PARSE CONTROL BLOCKS CSECT                                          *\n***********************************************************************\n         SPACE 1\nXFVOLPCL IKJPARM DSECT=PDL\n         SPACE\nXFVOLUME IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=SUBVOL\n         SPACE\nXFUNIT   IKJKEYWD\n         IKJNAME 'UNIT',ALIAS='DEVICE',SUBFLD=SUBUNIT\n         SPACE\nSUBVOL   IKJSUBF\nPDLVOL   IKJIDENT 'VOLUME SERIAL',UPPERCASE,                           X\n               PROMPT='VOLUME SERIAL',                                 X\n               MAXLNTH=6,FIRST=ANY,OTHER=ANY\n         SPACE\nSUBUNIT  IKJSUBF\nPDLUNIT  IKJIDENT 'UNIT NUMBER',UPPERCASE,                             X\n               PROMPT='UNIT NUMBER',VALIDCK=UNITCHK,                   X\n               MAXLNTH=3,FIRST=ALPHANUM,OTHER=ALPHANUM\n         SPACE\n         IKJENDP\n         SPACE\nXUSING   CSECT\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\n         SPACE\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE\nPARMLIST DS    3F                  PARMLIST MAPPING\n         ORG   PARMLIST\nPARMWA   DS    F                   ADDRESS OF 100-BYTE WORK AREA\nPARMDEVT DS    F                   ADDRESS OF BYTE CONTAINING\n*                                  THE DEVICE TYPE TO BE SEARCHED\nPARMUCB  DS    F                   ADDRESS OF WORD TO CONTAIN THE\n*                                  UCB ADDRESS\n         SPACE\nDEVCLASS DS    CL1                 BYTE CONTAINING DEVICE CLASS TO\n*                                  TO BE SEARCHED FOR\nADDRUCB  DS    F                   WORD IN WHICH UCB SCAN WILL\n*                                  PLACE THE ADDRESS OF THE UCB\n         DS    0D                  ALIGN TO DOUBLE-WORD BOUNDARY.\n*                                  WORK AREA FOR SCAN SERVICE MUST\n*                                  BE ON A DOUBLE-WORD BOUNDARY.\nWORKAREA DS    CL100               WORK AREA\nSRCHVOL  DS    CL6                 VOLSER TO BE FOUND\nSRCHCUU  DS    CL3                 UNIT TO BE FOUND\nFLAGS    DS    X\nVOLSPEC  EQU   X'80'               ON IF VOL SER SPECIFIED\nCUUSPEC  EQU   X'40'               ON IF UNIT NAME SPECIFIED\nALLOCD   EQU   X'20'               ON IF UCB IS ALLOCATED BY SOMEBODY\n         SPACE\nOLD      DS    0A\nOLD1     DC    F'1'\nOLD2     DC    A(OUTHDR)\nOUTHDR   DC    Y(L'OUTLINE+4,0)\nOUTLINE  DS    CL79\n         ORG   OUTLINE\nOUTMSGID DS    CL(L'MSGID)\n         DS    CL2\nOUTVOL   DS    CL6\n         DS    CL2\nOUTUNIT  DS    CL3\n         DS    CL2\nOUTASID  DS    CL4\n         DS    CL2\nOUTNAME1 DS    CL8\n         DS    CL2\nOUTNAME2 DS    CL8\n         DS    CL2\nOUTNAME3 DS    CL8\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJCPPL\n         IEFUCBOB PREFIX=YES       UCB MAPPING MACRO\n         IHAASVT                   ASCB MAPPING MACRO\n         IHAASCB                   ASCB MAPPING MACRO\n         IEECHAIN                  CSCB MAPPING MACRO\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XVOLUME  0100-07332-07332-0900-00573-00573-00000-SEB\n         TITLE 'XVOLUME - TSO COMMAND TO DISPLAY INFO ON VOLSER'\n***********************************************************************\n*                                                                     *\n* XVOLUME - A TSO COMMAND CREATED FROM THE TEXT OF A SAMPLE PROGRAM   *\n*           FOUND IN THE XA SPL: SYSTEM MACROS AND FACILITIES MANUAL  *\n*           TO DO A UCB SCAN.                                         *\n*                                                                     *\n* SYNTAX:   XVOLUME VOLUME(VOLSER) UNIT(UNITNAME) DEVICE(DEVTYPE)     *\n* ALIAS:    XVOL                                                      *\n*                                                                     *\n* RETURN CODES: 0 - SUCCESSFUL COMPLETION                             *\n*               4 - REQUESTED THING(S) NOT FOUND                      *\n*                                                                     *\n* This version of the command uses the UCBSCAN macro et al., required *\n* for support of dynamic UCB's.  January 1996 SEB                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    ADDRESS THE CVT\nR4       EQU   4    ADDRESS THE PDL (PARSE OUTPUT)\nR5       EQU   5    ADDRESS THE UCB\nR6       EQU   6    .\nR7       EQU   7    LINK REGISTER FOR PUTLINE\nR8       EQU   8    COUNT OF VOLUME ENTRIES FOUND\nR9       EQU   9    .\nR10      EQU   10   .\nR11      EQU   11   .\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXVOLUME  CSECT\nXVOLUME  AMODE 31\nXVOLUME  RMODE ANY\n         SAVE  (14,12),,XVOLUME_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XVOLUME,R12\n         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         EJECT\n         USING CPPL,R2             ADDRESS INPUT CPPL\n         XC    ANSWER,ANSWER\n         MVC   IOPLUPT,CPPLUPT\n         MVC   IOPLECT,CPPLECT\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R14,ECB\n         ST    R14,IOPLECB\n         L     R15,=V(XFVOLPCL)\n         LA    R0,ANSWER\n         L     R1,CPPLCBUF\n         STM   R14,R1,PPLECB\n         ST    R13,PPLUWA          USER WORK AREA = \"DATD\"\n         MVC   PTLIST(PTLISTL),SPTLIST\n         LA    R14,1\n         LA    R15,OUTHDR\n         LA    R0,L'OUTLINE+4\n         SLL   R0,16\n         STM   R14,R0,OLD\n         SPACE\n         MVI   UVTATTR,10          SET LENGTH OF ATTRIBUTE AREA\n         LA    R1,UVTATTR          SET ATTRIBUTE AREA ADDRESS\n         ST    R1,UVTDEVT           IN UNIT TABLE\n         LA    R0,UVTABLE\n         LA    R1,UVFLAGS\n         STM   R0,R1,UVPARMS       INITIALIZE PARMS FOR IEFEB4UV\n         LOAD  EPLOC==CL8'IEFEB4UV',ERRET=NOUV GET UNIT VERIFIER MODULE\n         ST    R0,@EB4UV           STORE ADDRESS OF IEFEB4UV\nNOUV     DS    0H\n         SPACE\n         XC    ECB,ECB\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   RETURN12\n         L     R4,ANSWER\n         USING PDL,R4\n         MVC   SRCHVOL,BLANKS\n         MVC   SRCHCUU,BLANKS\n         MVC   SRCHDEV,BLANKS\n         MVI   FLAGS,X'00'         INITIALIZE FLAGS\n         TM    PDLVOL+6,X'80'      IF VOLUME SERIAL WAS SPECIFIED,\n         BNO   BYPVOL              THEN...\n         L     R14,PDLVOL+0         GET ADDRESS OF VOLUME SERIAL\n         LH    R15,PDLVOL+4         GET LENGTH OF VOLUME SERIAL\n         BCTR  R15,0\n         EX    R15,MVCVOL           MOVE VOLUME SERIAL TO WORK AREA\n         MVC   VOLTEST,SRCHVOL\n         TR    VOLTEST,TESTTBL      CREATE VOL SER TESTING FIELD\n         MVC   VOLMASK,SRCHVOL\n         TR    VOLMASK,MASKTBL      CREATE VOL SER TESTING MASK\n         OI    FLAGS,VOLSPEC        INDICATE VOL SER SPECIFIED\nBYPVOL   DS    0H\n         TM    PDLUNIT+6,X'80'     IF UNIT OR DEVICE WAS SPECIFIED,\n         BNO   BYPUNIT             THEN...\n         L     R14,PDLUNIT+0        GET ADDRESS OF VOLUME SERIAL\n         LH    R15,PDLUNIT+4        GET LENGTH OF VOLUME SERIAL\n         BCTR  R15,0\n         CH    R15,=H'2'            IF LENGTH OF UNIT IS 3,\n         BNE   ISADEV               THEN\n         EX    R15,MVCCUU            MOVE UNIT NUMBER TO WORK AREA\n         MVC   CUUTEST,SRCHCUU\n         TR    CUUTEST,TESTTBL       CREATE UNIT NAME TESTING FIELD\n         MVC   CUUMASK,SRCHCUU\n         TR    CUUMASK,MASKTBL       CREATE UNIT NAME TESTING MASK\n         OI    FLAGS,CUUSPEC        INDICATE UNIT NAME SPECIFIED\n         B     AFTDEV               ELSE\nISADEV   EX    R15,MVCDEV            MOVE DEVICE NAME TO WORK AREA\n         MVC   DEVTEST,SRCHDEV\n         TR    DEVTEST,TESTTBL       CREATE DEVICE TESTING FIELD\n         MVC   DEVMASK,SRCHDEV\n         TR    DEVMASK,MASKTBL       CREATE DEVICE TESTING MASK\n         OI    FLAGS,DEVSPEC        INDICATE DEVICE TYPE SPECIFIED\nAFTDEV   DS    0H\nBYPUNIT  DS    0H\n         L     R3,X'10'            GET CVT ADDRESS\n         USING CVTMAP,R3           SET UP ADDRESSABILITY TO CVT\n         XC    WORKAREA,WORKAREA   CLEAR WORK AREA\n         LA    R14,WORKAREA        GET ADDRESS OF WORK AREA\n         LA    R15,DEVCLASS        GET ADDRESS OF AREA CONTAINING\n         MVI   DEVCLASS,X'00'      THE DEVICE CLASS TO BE SEARCHED\n         LA    R0,ADDRUCB          GET ADDRESS OF WORD WHERE SCAN\n*                                  SERVICE WILL STORE THE UCB ADDRESS\n         STM   R14,R0,PARMLIST\n         OI    PARMUCB,X'80'       INDICATE END OF PARMLIST\n         XR    R8,R8               CLEAR ENTRY COUNT\nSEARCH   DS    0H\n         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               X\n               DYNAMIC=YES,DEVCLASS=ALL,RANGE=ALL,                     X\n               MF=(E,PUCBSCAN),PLISTVER=MAX\n* ------ LA    R1,PARMLIST         PUT PARMLIST ADDRESS IN REGISTER 1\n* ------ L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS\n* ------ BALR  R14,R15             GO TO SCAN SERVICE.\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    MATCH               IF ZERO, MATCH WAS FOUND\n         CH    R15,=H'4'           IF FOUR,\n         BE    NOMATCH             NO MORE MATCHING UCB'S\n         B     ERRORUCB            OTHERWISE SOME KIND OF ERROR\n         SPACE\nMATCH    DS    0H\n*                                  NO MATCH FOUND\n* ------ L     R5,ADDRUCB          GET UCB ADDR RETURNED BY SCAN SRVCE\n         LA    R5,UCBAREA\n         USING UCBOB,R5            SET UP ADDRESSABILITY TO UCB\n         TM    FLAGS,VOLSPEC       IF VOLUME SERIAL REQUESTED,\n         BZ    NOCHKVOL            THEN\n         MVC   VOLUCBT,UCBVOLI      MOVE UCB VOLSER TO WORKAREA\n         OC    VOLUCBT,VOLMASK      OR IT WITH THE MASK\n         CLC   VOLUCBT,VOLTEST      IS THIS THE VOL WE'RE LOOKING FOR?\n         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.\nNOCHKVOL DS    0H\n         TM    FLAGS,CUUSPEC       IF UNIT NUMBER REQUESTED,\n         BZ    NOCHKCUU            THEN\n         MVC   CUUUCBT,UCBNAME      MOVE UCB UNIT NAME TO WORKAREA\n         OC    CUUUCBT,CUUMASK      OR IT WITH THE MASK\n         CLC   CUUUCBT,CUUTEST      IS THIS THE CUU WE'RE LOOKING FOR?\n         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.\nNOCHKCUU DS    0H\n*                                  NOTE:  THE WORK AREA MUST NOT BE\n*                                         CHANGED BETWEEN CALLS TO\n*                                         THE SCAN SERVICE ROUTINE\n         SPACE\nFOUND    DS    0H\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE\n         STCM  R5,15,OUTMSGID          PUT UCB ADDRESS IN MESSAGE\n         UNPK  OUTMSGID(9),OUTMSGID(5)\n         TR    OUTMSGID(8),TRTBL\n         MVI   OUTMSGID+8,C' '\n         MVC   OUTVOL,UCBVOLI\n*XXX\n         CLC   =CL3'UCB',UCBNAME\n         BNE   MVUCBNAM\n         UNPK  OUTUNIT(5),UCBCHAN(3)\n         TR    OUTUNIT(4),TRTBL\n         MVI   OUTUNIT+4,C' '\n         B     AFTMVUCB\nMVUCBNAM MVC   OUTUNIT+1(3),UCBNAME\nAFTMVUCB DS    0H\n         UNPK  OUTXTYPE(9),UCBTYP(5)\n         TR    OUTXTYPE(8),TRTBL\n         MVI   OUTP1,C'('\n         MVI   OUTX1,C'X'\n         MVI   OUTQ1,C''''\n         MVI   OUTQ2,C''''\n         MVI   OUTP2,C')'\n         MVC   OUTTYPE,=CL8'        '\n         TM    UCBSTAT,B'10000000'\n         BZ    *+10\n         MVC   OUTSTAT1(3),=CL3'ONL'\n         TM    UCBSTAT,B'01000000'\n         BZ    *+10\n         MVC   OUTSTAT2(3),=CL3'CHG'\n         TM    UCBSTAT,B'00100000'\n         BZ    *+10\n         MVC   OUTSTAT3(3),=CL3'RSV'\n         TM    UCBSTAT,B'00010000'\n         BZ    *+10\n         MVC   OUTSTAT4(3),=CL3'UNL'\n         TM    UCBSTAT,B'00001000'\n         BZ    *+10\n         MVC   OUTSTAT5(3),=CL3'ALC'\n         TM    UCBSTAT,B'00000100'\n         BZ    *+10\n         MVC   OUTSTAT6(3),=CL3'PRS'\n         TM    UCBSTAT,B'00000010'\n         BZ    *+10\n         MVC   OUTSTAT7(3),=CL3'SYR'\n         TM    UCBSTAT,B'00000001'\n         BZ    *+10\n         MVC   OUTSTAT8(3),=CL3'DAD'\n         L     R15,@EB4UV          GET ADDRESS OF IEFEB4UV\n         LTR   R15,R15             IF IT WAS NOT SUCCESSFULLY LOADED\n         BZ    DISPLAY             THEN BYPASS UNIT NAME ACCESS\n         MVC   UVTDEVT,UCBTYP      SET DEVICE TYPE TO BE CONVERTED\n         LA    R1,UVPARMS          GET ADDRESS OF PARMLIST FOR IEFEB4UV\n         BASSM R14,R15             CALL IEFEB4UV IN ITS AMODE\n         LTR   R15,R15             CHECK RETURN CODE FROM IEFEB4UV\n         BZ    DEVFOUND            IF ZERO, WE GOT A UNIT NAME\n         CH    R15,=H'4'           IF FOUR, NO UNIT NAME FOUND\n         BE    DISPLAY             SO JUST LEAVE IT BLANK.\n*                                  OTHERWISE A BAD RETURN CODE\n         MVC   OUTTYPE,=CL8'(UVRC??)'\n         CVD   R15,DOUBLE          CONVERT RETURN CODE TO DECIMAL\n         UNPK  OUTTYPE+5(2),DOUBLE\n         OI    OUTTYPE+6,X'F0'     AND PUT IT IN OUTPUT TYPE\n         B     DISPLAY\nDEVFOUND DS    0H\n         TM    UVTATTR+1,B'00010000' IF UNIT NAME CONTAINS TP DEVICES\n         BZ    NOTTP                 THEN\n         MVC   OUTTYPE,=C'(TP DEV)'    INDICATE TP DEVICE IN OUTPUT\n         B     DISPLAY               ELSE\nNOTTP    MVC   OUTTYPE,UVTNAME         MOVE EBCDIC NAME TO OUTPUT LINE\nDISPLAY  DS    0H\n         TM    FLAGS,DEVSPEC       IF DEVICE TYPE REQUESTED,\n         BZ    NOCHKDEV            THEN\n         MVC   DEVUCBT,OUTTYPE      MOVE DEVICE NAME TO WORKAREA\n         OC    DEVUCBT,DEVMASK      OR IT WITH THE MASK\n         CLC   DEVUCBT,DEVTEST      IS THIS THE DEV WE'RE LOOKING FOR?\n         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.\nNOCHKDEV DS    0H\n         LA    R8,1(,R8)           INCREMENT COUNT OF ENTRIES DISPLAYED\n         LA    R1,OUTLINE\n         LA    R0,L'OUTLINE\n         BAL   R7,PUTLINE          DISPLAY THIS ENTRY LINE\n         B     SEARCH              CONTINUE SEARCH\n         SPACE\nNOMATCH  DS    0H\n         LTR   R8,R8               IF ENTRIES HAVE BEEN FOUND,\n         BNZ   RETURN0             THEN RETURN NORMALLY. ELSE...\n         MVC   OUTLINE(L'NOTFOUND),NOTFOUND\n         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED\n         BZ    WASNTVOL            THEN\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(7),=C'VOLUME '\n         MVC   OUTLINE+(NFSTUFF-NF1)+7(6),SRCHVOL\n         B     AFTWASNT\nWASNTVOL DS    0H\n         TM    FLAGS,CUUSPEC       IF A UNIT NUMBER WAS REQUESTED\n         BZ    WASNTCUU            THEN\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(10),=C'UNIT NAME '\n         MVC   OUTLINE+(NFSTUFF-NF1)+10(3),SRCHCUU\n         B     AFTWASNT\nWASNTCUU DS    0H\n         TM    FLAGS,DEVSPEC       IF A DEVICE TYPE WAS REQUESTED\n         BZ    WASNTDEV            THEN\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(5),=C'UNIT '\n         MVC   OUTLINE+(NFSTUFF-NF1)+5(8),SRCHDEV\n         B     AFTWASNT\nWASNTDEV DS    0H\n         MVC   OUTLINE+(NFSTUFF-NF1)+0(13),=C'UCB ENTRIES  '\nAFTWASNT DS    0H\n         LA    R0,L'NOTFOUND+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN4\n         SPACE\nERRORUCB DS    0H\n         MVC   OUTLINE(L'UBLEWIT),UBLEWIT\n         LA    R0,L'UBLEWIT+4\n         STH   R0,OUTHDR\n         BAL   R7,PUTLINE\n         B     RETURN12\n         EJECT\nRETURN4  DS    0H                  RETURN WITH CODE 4\n         SPACE\n         LA    R2,4                SET RETURN CODE TO FOUR\n         B     RETURNP\n         SPACE 2\nRETURN12 DS    0H                  RETURN WITH CODE 12\n         SPACE\n         LA    R2,12               SET RETURN CODE TO TWELVE\n         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE\n         SPACE 2\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n         XR    R2,R2               SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *\n***********************************************************************\nRETURNP  DS    0H\n         SPACE\n         L     R1,ANSWER\n         IKJRLSA (1)               RELEASE PARSE STORAGE\n         SPACE\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *\n***********************************************************************\nRETURN   DS    0H\n         DELETE EPLOC==CL8'IEFEB4UV'\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* PUTLINE SUBROUTINE  - LINK REGISTER IS R7                           *\n***********************************************************************\n         SPACE\nPUTLINE  DS    0H\n         TR    OUTLINE(L'OUTLINE),TRANSTBL\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15\n         BNZ   0(,R15)             BRANCH TO LOW CORE IF PUTLINE FAILS\n         BR    R7\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE\nMVCVOL   OC    SRCHVOL(0),0(R14)   MOVE VOLUME SERIAL FOLDING TO UPPER\nMVCCUU   OC    SRCHCUU(0),0(R14)   MOVE UNIT NUMBER FOLDING TO UPPER\nMVCDEV   OC    SRCHDEV(0),0(R14)   MOVE DEVICE NAME FOLDING TO UPPER\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE\nSPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nPTLISTL  EQU   *-SPTLIST\n         SPACE\nUVFLAGS  DS    0X                  FLAGS FOR IEFEB4UV\n         DC    B'00100001'         RETURN UNIT NAME,\n*                                  CONVERT DEVICE NAME TO LOOK-UP VALUE\n         DC    B'00000000'         NO OTHER OPTIONS REQUESTED\n         SPACE\nMSGID    DC    C'XVOL001:'\nNF1      DC    C'XVOL002: '\nNFSTUFF  DC    CL13' '\nNF3      DC    C' NOT FOUND'\nNOTFOUND EQU   NF1,*-NF1,C'C'\n         SPACE\nUBLEWIT  DC    C'XVOL003: UCBSCAN SERVICE FAILURE.'\n         SPACE\nBLANKS   EQU   NFSTUFF,8,C'C'      GENERAL PURPOSE BLANKS\n         SPACE\nTESTTBL  DC    256YL1(*-TESTTBL)\n         ORG   TESTTBL+C'*'\n         DC    X'FF'\n         ORG\n         SPACE\nMASKTBL  DC    256X'00'\n         ORG   MASKTBL+C'*'\n         DC    X'FF'\n         ORG\n         SPACE\nTRANSTBL DS    0C\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/........\u00a0,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4BAD4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4BBD4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nTRTBL    EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* PARSE CONTROL BLOCKS CSECT                                          *\n***********************************************************************\n         SPACE 1\nXFVOLPCL IKJPARM DSECT=PDL\n         SPACE\nXFVOLUME IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=SUBVOL\n         SPACE\nXFUNIT   IKJKEYWD\n         IKJNAME 'UNIT',ALIAS='DEVICE',SUBFLD=SUBUNIT\n         SPACE\nSUBVOL   IKJSUBF\nPDLVOL   IKJIDENT 'VOLUME SERIAL',                                     X\n               PROMPT='VOLUME SERIAL OR VOLUME SERIAL MASK',           X\n               MAXLNTH=6,FIRST=ANY,OTHER=ANY\n         SPACE\nSUBUNIT  IKJSUBF\nPDLUNIT  IKJIDENT 'UNIT NAME',                                         X\n               PROMPT='UNIT NUMBER, DEVICE TYPE, OR MASK',             X\n               MAXLNTH=8,FIRST=ANY,OTHER=ANY\n         SPACE\n         IKJENDP\n         SPACE\nXVOLUME  CSECT\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nECB      DS    F                   ECB FOR TSO SERVICE ROUTINES\n@EB4UV   DC    A(0)                ADDRESS OF IEFEB4UV\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\n         SPACE\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n         SPACE\nPARMLIST DS    3F                  PARMLIST MAPPING\n         ORG   PARMLIST\nPARMWA   DS    F                   ADDRESS OF 100-BYTE WORK AREA\nPARMDEVT DS    F                   ADDRESS OF BYTE CONTAINING\n*                                  THE DEVICE TYPE TO BE SEARCHED\nPARMUCB  DS    F                   ADDRESS OF WORD TO CONTAIN THE\n*                                  UCB ADDRESS\n         SPACE\nDEVCLASS DS    CL1                 BYTE CONTAINING DEVICE CLASS TO\n*                                  TO BE SEARCHED FOR\nADDRUCB  DS    F                   WORD IN WHICH UCB SCAN WILL\n*                                  PLACE THE ADDRESS OF THE UCB\n         DS    0D                  ALIGN TO DOUBLE-WORD BOUNDARY.\n*                                  WORK AREA FOR SCAN SERVICE MUST\n*                                  BE ON A DOUBLE-WORD BOUNDARY.\nWORKAREA DS    0F,CL100            WORK AREA\nUCBAREA  DS    0F,CL48             WORK AREA\nSRCHVOL  DS    CL6                 VOLSER TO BE FOUND\nSRCHCUU  DS    CL3                 UNIT TO BE FOUND\nSRCHDEV  DS    CL8                 DEVICE TO BE FOUND\nUCBT     DS    CL8                 AREA FOR COMPARISONS\nVOLUCBT  EQU   UCBT,6,C'C'\nCUUUCBT  EQU   UCBT,3,C'C'\nDEVUCBT  EQU   UCBT,8,C'C'\nVOLTEST  DS    CL6                 VOL FOR COMPARISONS\nCUUTEST  DS    CL3                 CUU FOR COMPARISONS\nDEVTEST  DS    CL8                 DEV FOR COMPARISONS\nVOLMASK  DS    CL6                 MASK FOR COMPARISONS\nCUUMASK  DS    CL3                 MASK FOR COMPARISONS\nDEVMASK  DS    CL8                 MASK FOR COMPARISONS\nFLAGS    DS    X\nVOLSPEC  EQU   X'80'               ON IF VOL SER SPECIFIED\nCUUSPEC  EQU   X'40'               ON IF UNIT NAME SPECIFIED\nDEVSPEC  EQU   X'20'               ON IF DEVICE TYPE SPECIFIED\n         SPACE\n         UCBSCAN MF=(L,PUCBSCAN),PLISTVER=MAX\n         SPACE\nUVPARMS  DS    0F                  PARAMETER LIST FOR IEFEB4UV\n         SPACE\nUVPARM1  DC    A(UVTABLE)          ADDRESS OF UNIT TABLE\nUVPARM2  DC    A(UVFLAGS)          ADDRESS OF FLAGS\n         SPACE\nUVTABLE  DS    0F                  UNIT TABLE FOR IEFEB4UV\nUVTNAME  DS    CL8                 UNIT NAME RETURNED BY IEFEB4UV\nUVTDEVT  DS    XL4                 DEVICE TYPE TO BE CONVERTED\nUVTATTRP DS    A(UVTATTR)          ZERO OR ADDRESS OF ATTRIBUTE AREA\n         SPACE\nUVTATTR  DC    X'0A',9X'00'        10-BYTE ATTRIBUTE AREA\n         SPACE\nOLD      DS    0A\nOLD1     DC    F'1'\nOLD2     DC    A(OUTHDR)\nOUTHDR   DC    Y(L'OUTLINE+4,0)\nOUTLINE  DS    CL79\n         ORG   OUTLINE\nOUTMSGID DS    CL8                 FORMERLY CL(L'MSGID)\n         DS    CL3\nOUTVOL   DS    CL6\n         DS    CL2\nOUTUNIT  DS    CL4\n         DS    CL2\nOUTTYPE  DS    CL8\n         DS    CL1\nOUTP1    DC    C'('\nOUTX1    DC    C'X'\nOUTQ1    DC    C''''\nOUTXTYPE DS    CL8\nOUTQ2    DC    C''''\nOUTP2    DC    C')'\n*\n* New output fields added 05/15/87\n*\n         DS    CL1\nOUTSTAT  EQU   *\nOUTSTAT1 DS    CL3\n         DS    CL1\nOUTSTAT2 DS    CL3\n         DS    CL1\nOUTSTAT3 DS    CL3\n         DS    CL1\nOUTSTAT4 DS    CL3\n         DS    CL1\nOUTSTAT5 DS    CL3\n         DS    CL1\nOUTSTAT6 DS    CL3\n         DS    CL1\nOUTSTAT7 DS    CL3\n         DS    CL1\nOUTSTAT8 DS    CL3\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         IKJCPPL\n         EJECT\nDSECTUCB DSECT ,\n         SPACE 1\n         IEFUCBOB ,                UCB MAPPING MACRO\n         EJECT\n         CVT   DSECT=YES\n         END\n./ ADD NAME=XVX      0100-07332-07332-0900-01517-01517-00000-SEB\n         TITLE 'XVX - DISPLAY VIRTUAL STORAGE UNDER ISPF'\n***********************************************************************\n*                                                                     *\n* XVX - ISPF DIALOG DRIVER TO DISPLAY VIRTUAL STORAGE                 *\n*                                                                     *\n* VERSION 2 - MODIFIED FOR ISPF VERSION 2                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    MISCELLANEOUS USES\nR3       EQU   3    MISCELLANEOUS USES\nR4       EQU   4    LENGTH OF ARGUMENT FIELD\nR5       EQU   5    BASE ADDRESS FIELD\nR6       EQU   6    CURRENT ADDRESS FIELD\nR7       EQU   7    WORK REGISTER TO BUILD DISPLAY\nR8       EQU   8    WORK REGISTER TO BUILD DISPLAY\nR9       EQU   9    *** AVAILABLE  ***\nR10      EQU   10   DATA BUFFER ADDRESS\nR11      EQU   11   STATIC BASE REGISTER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXVX      CSECT\n         SAVE  (14,12),,XVX_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         LA    R11,2048(,R12)\n         LA    R11,2048(,R11)\n         USING XVX,R12,R11\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE\n         LOAD  EPLOC==CL8'ISPLINK' FETCH ISPLINK MODULE\n         ST    R0,@ISPLINK         SAVE ITS ADDRESS\n         EJECT\n***********************************************************************\n* DETERMINE NUMBER OF OUTPUT LINES IN DYNAMIC AREA ON PANEL XVX       *\n* THIS SHOULD BE THE NUMBER OF TERMINAL LINES MINUS 3, BUT IS         *\n* ESTABLISHED BY THE PANEL DEFINITION.  THEREFORE, WE USE THE         *\n* PQUERY SERVICE TO OBTAIN THE INFORMATION.                           *\n***********************************************************************\n         SPACE\n*\n* SET UP FOR VDEFINES. NOTE BOOTSTRAP VDEFINE FOR VXLINES FOR PQUERY.\n*\n         LA    R14,=C'VDEFINE'\n         ST    R14,ISPPARM1\n*\n* ISPEXEC VDEFINE VXLINES FIXED(4)\n*\n         LA    R15,$VXLINES\n         LA    R0,VXLINES\n         LA    R1,=C'FIXED'\n         LA    R2,$FOUR\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15             IF FIRST CALL TO ISPLINK FAILED,\n         LTR   R15,R15             THEN RETURN (NOT UNDER ISPF).\n         BNZ   NOISPF\n*\n* ISPEXEC PQUERY PANEL(XVX) AREANAME(VX) DEPTH(VXLINES)\n*\n         LA    R1,@PQUERY\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         CH    R15,H8              IF PQUERY FAILED,\n         BNE   NOTPQ8              THEN SHOW ERROR PANEL AND QUIT\n*\n* ISPEXEC DISPLAY PANEL(XVXERROR)\n*\n         LA    R1,@ERRDISP\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         B     RETURN\nNOTPQ8   DS    0H                  PQUERY SUCCESSFUL...\n         L     R0,VXLINES          GET MAX NUMBER OF LINES FROM PQUERY\n         STH   R0,#SHOW            SET NUMBER OF LINES TO SHOW\n         STH   R0,#CURSHOW         SET NUMBER OF LINES TO SHOW\n         MVI   #OLDSHOW,X'80'      FORCE NO PREVIOUS SHOW VALUE\n         MVC   PANEL,$XVX          SET UP PANEL NAME\n         LR    R2,R0               SAVE # OF LINES\n         MH    R0,=H'80'           MULTIPLY # OF LINES BY WIDTH\n         ST    R0,VXLEN            SET DYNAMIC SCREEN AREA SIZE\n         SLA   R2,4                MULTIPLY BY 16 FOR MAX DATA LENGTH\n         LA    R2,1(,R2)           ADD 1 FOR PADDING FOR UNPACKS\n         ST    R2,BUFLEN           GIVING LENGTH OF DATA BUFFER\n         LR    R0,R2               PUT IT BACK IN REGISTER 0\n         GETMAIN R,LV=(0)          GET STORAGE FOR THE DATA BUFFER\n         ST    R1,BUFADDR          SAVE ADDRESS OF THE DATA BUFFER\n*\n* DETERMINE MAXIMUM NUMBER OF LINES THAT CAN BE DISPLAYED\n*\n         L     R0,VXLINES          GET NUMBER OF LINES\n         CH    R0,=H'40'           IF NUMBER OF LINES EXCEEDS 40\n         BNH   INIT                THEN\n         LA    R1,@ERRDISP          DISPLAY ERROR PANEL\n         L     R15,@ISPLINK         (CAN'T PROCESS THAT MANY LINES)\n         BALR  R14,R15\n         B     RETURN               AND QUIT.\n         EJECT\n***********************************************************************\n* INITIALIZE VARIABLES                                                *\n***********************************************************************\n         SPACE\nINIT     DS    0H\n         SPACE\n         MVC   MSGID,$XVX          INITIALIZE MESSAGE ID\n         MVI   ZCMD,C'0'           INITIALIZE COMMAND = \"0\"\n         MVI   ZCMD+1,C' '\n         MVC   ZCMD+2(L'ZCMD-2),ZCMD+1\n         MVC   ZVERB,BLANKS\n         XR    R5,R5               INITIAL BASE ADDRESS = ZERO\n         XR    R6,R6               INITIAL CURRENT ADDRESS = ZERO\n         ST    R6,ZSCROLLN         INITIAL SCROLL AMOUNT = ZERO\n         STM   R5,R6,SYMFIRST      CLEAR SYMBOL CHAIN POINTERS\n         ST    R5,STACKPTR         CLEAR BACKTRACKING STACK\n         NI    BOOLEANS,255-BINMODE INITIALIZE MODE FLAG\n         MVC   SCRSHIFT,INITSLA    INITIALIZE LINES->BYTES SHIFT INSTR\n         EJECT\n*\n* ISPEXEC VDEFINE ZCMD CHAR(LENGTH(ZCMD))\n*\n         LA    R15,=C'ZCMD '\n         LA    R0,ZCMD\n         LA    R1,=C'CHAR'\n         LA    R2,=A(L'ZCMD)\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE ZVERB CHAR(LENGTH(ZVERB))\n*\n         LA    R15,$ZVERB\n         LA    R0,ZVERB\n         LA    R1,=C'CHAR'\n         LA    R2,$EIGHT           LENGTH OF ZVERB\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE ZSCROLLA CHAR(4)\n*\n         LA    R15,$ZSCRLLA\n         LA    R0,ZSCROLLA\n         LA    R1,=C'CHAR'\n         LA    R2,$FOUR\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE ZSCROLLN FIXED(4)\n*\n         LA    R15,$ZSCRLLN\n         LA    R0,ZSCROLLN\n         LA    R1,=C'FIXED'\n         LA    R2,$FOUR\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE VXLVLIN FIXED(4)\n*\n         LA    R15,=C'VXLVLIN '\n         LA    R0,VXLVLIN\n         LA    R1,=C'FIXED'\n         LA    R2,$FOUR\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE VADDR HEX(4)\n*\n         LA    R15,=C'VADDR '\n         LA    R0,VADDR\n         LA    R1,=C'HEX'\n         LA    R2,$FOUR\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE VLABEL CHAR(8)\n*\n         LA    R15,=C'VLABEL '\n         LA    R0,VLABEL\n         LA    R1,=C'CHAR'\n         LA    R2,$EIGHT           LENGTH OF VLABEL\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC VDEFINE VX CHAR(VXLEN)\n*\n         LA    R15,$VX\n         LA    R0,VX\n         LA    R1,=C'CHAR'\n         LA    R2,VXLEN\n         STM   R15,R2,ISPPARM2\n         OI    ISPPARM5,X'80'\n         LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n*\n* ISPEXEC CONTROL DISPLAY REFRESH\n*\n         LA    R1,@REFRESH\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         EJECT\n***********************************************************************\n* SET UP ESPIE ENVIRONMENT TO CATCH PROTECTION EXCEPTIONS.            *\n* SPIE WON'T WORK BECAUSE AMODE WILL BE 31 WHEN PROGRAM CHECKS OCCUR. *\n***********************************************************************\n         SPACE\nSETSPIE  ESPIE SET,SPIEEXIT,(4,5)  TRAP 0C4'S AND 0C5'S\n         ST    R1,PREVSPIE         SAVE PREVIOUS PIE ADDRESS\n         EJECT\nLOOP     DS    0H                  MAIN PROCESSING LOOP\n         SPACE\n***********************************************************************\n* INITIALIZE FLAGS AND DEFAULT SCROLLING NUMBER OF BYTES              *\n***********************************************************************\n         SPACE\n         NI    BOOLEANS,255-BADADDR-DOPUSH-DOUPDATE-RETRY  INIT FLAGS\n         STM   R5,R6,SAVEADRS      SET SAVED BASE & CURRENT ADDRESSES\n         MVI   MSGNO,0             CLEAR MESSAGE ID\n         SPACE\n***********************************************************************\n* EXTRACT ARGUMENT FROM ZCMD FIELD                                    *\n***********************************************************************\n         SPACE\n         MVI   ARGUMENT,C' '\n         MVC   ARGUMENT+1(L'ARGUMENT-1),ARGUMENT\n         LA    R0,ZCMD\n         LR    R1,R0\n         LA    R14,1\n         LA    R15,ZCMD+L'ZCMD-1\nZCMDLOOP DS    0H\n         CLI   0(R1),C' '\n         BE    ZCMDEND\n         BXLE  R1,R14,ZCMDLOOP\nZCMDEND  DS    0H\n         SR    R1,R0\n         LTR   R4,R1               SET ARGUMENT LENGTH\n         BNP   NOARG\n         BCTR  R1,0\n         EX    R1,MVCARG           MOVE FIRST WORD OF ZCMD TO ARGUMENT\nNOARG    DS    0H\n         CLC   ZVERB,BLANKS        IF ZVERB IS NULL\n         BNE   CMDSRCH             THEN\n         MVC   ZVERB,CLOCATE        INIT SET ZVERB = 'LOCATE'\n         LTR   R4,R4                IF ARGUMENT LENGTH = ZERO\n         BZ    RETSUCC              THEN PROCESS AS NULL COMMAND\n         LTR   R1,R1                IF ARGUMENT LENGTH = ONE\n         BNP   CMDSRCH              OR\n         CLI   ARGUMENT,C'.'        ARGUMENT DOES NOT START W/PERIOD\n         BE    DEFLABEL             OR\n         CLI   ARGUMENT,C'!'        ARGUMENT DOES NOT START WITH \"!\"\n         BNE   CMDSRCH              THEN GO TO PROCESS LOCATE COMMAND\n         SPACE\nDEFLABEL DS    0H                  ELSE ARGUMENT STARTS WITH PERIOD\n*\n* ARG STARTS WITH PERIOD, IS A LABEL DEFINITION\n* EXTRACT NAME OF LABEL AND ADD IT TO IMMEDIATE-SYMBOL CHAIN\n*\n         CH    R4,=H'9'            IF LENGTH OF LABEL GREATER THAN 8\n         BH    DEFLBLNG            THEN LABEL IS NO GOOD\n         MVC   VLABEL,BLANKS       SET UP TEST LABEL IN UPPER CASE\n         OC    VLABEL,ARGUMENT+1\n         TRT   VLABEL,NAMETBL      VERIFY VALID CHARS\n         BNZ   DEFLBLNG\n         TM    VLABEL,X'F0'        LABEL CANNOT START WITH NUMERIC\n         BNO   DEFLBLOK\nDEFLBLNG MVI   MSGNO,15            IF BAD LABEL, SAY SO\n         B     RETFAIL\nDEFLBLOK DS    0H\n         ST    R6,VADDR            SET ADDRESS FOR MESSAGES\n         MVI   MSGNO,17            SAY LABEL REASSIGNED, BUT...\n         LM    R15,R0,VLABEL       PUT SYMBOL ARGUMENT NAME IN REGS\n         BAL   R14,GETISYM         GET IMMEDIATE SYMBOL\n         LTR   R14,R1              IF ONE WAS FOUND (SET R14=0 IF NOT)\n         BZ    DSSETNEW            THEN...\n         CLI   ARGUMENT,C'!'        IF REASSIGN REQUESTED\n         BE    DSSETSYM             THEN DO REASSIGN\n         MVI   MSGNO,24             ELSE SAY LABEL ALREADY EXISTS\n         B     RETFAIL              AND FLAG AS ERROR.\nDSSETNEW MVI   MSGNO,16            ELSE SAY LABEL ASSIGNED AS NEW\n         LA    R0,SYMLEN           GET LENGTH OF A SYMBOL ENTRY\n         GETMAIN R,LV=(0)          GET STORAGE FOR ONE\n         USING SYM,R1\n*** ASSUME R14 = 0\n         ST    R14,SYMNEXT         CLEAR CHAIN POINTER\n         ICM   R15,15,SYMLAST      GET ADDRESS OF LAST SYMBOL\n         BZ    DSNOLAST            IF THERE IS ONE,\n         ST    R1,SYMNEXT-SYM(,R15) THEN CHAIN THIS OFF IT\n         B     DSAFTLST            ELSE\nDSNOLAST ST    R1,SYMFIRST          CHAIN THIS OFF HEADER\nDSAFTLST ST    R1,SYMLAST          SET NEW LAST-ENTRY POINTER\nDSSETSYM DS    0H                  LABEL NAME ALREADY EXISTS\n         MVC   SYMNAME,VLABEL      ELSE SET NAME\n         ST    R6,SYMADDR          SET ADDRESS=CURRENT ADDRESS\n         B     RETSUCC\n         DROP  R1\nCMDSRCH  DS    0H\n*\n* SEARCH THE TABLE OF COMMANDS FOR THE COMMAND VERB\n*\n         LA    R1,CMDTABLE\n         LA    R14,12\n         LA    R15,CMDEND-12\nCMDLOOP  CLC   0(8,R1),ZVERB\n         BE    CMDFOUND\n         BXLE  R1,R14,CMDLOOP\n*                                  ELSE COMMAND NOT FOUND...\n         MVI   MSGNO,03             SAY INVALID COMMAND\n         B     RETFAIL\n         SPACE\nCMDFOUND DS    0H\n         L     R15,8(,R1)          GET ADDRESS OF COMMAND PROCESSOR\n         BR    R15                 PROCESS THE COMMAND\n         SPACE\nRETFAIL  DS    0H                  RETURN ADDRESS IF FAILURE\n         LM    R5,R6,SAVEADRS      RESTORE SAVED BASE & CURRENT ADDR'S\n         B     DISPLAY             AND GO REDISPLAY SAME SCREEN\n         SPACE\nRETPUSH  DS    0H\n         OI    BOOLEANS,DOPUSH     INDICATE STACK ELEMENT TO BE PUSHED\n         B     RETSUCC             PROCESS NORMALLY\n         SPACE\nRETUPDT  DS    0H\n         OI    BOOLEANS,DOUPDATE   INDICATE STACK ELEMENT TO BE UPDATED\n******** B     RETSUCC             PROCESS NORMALLY\n         EJECT\nRETSUCC  DS    0H                  COMMAND SUCCESSFUL\n         SPACE\n***********************************************************************\n* PROCESS BASE ADDRESS IN R5 AND PROCESS CURRENT ADDRESS IN R6        *\n***********************************************************************\n         SPACE\n         LR    R0,R6               CURRENT ADDRESS MINUS BASE ADDRESS\n         SR    R0,R5               GIVES CURRENT OFFSET\n         LPR   R0,R0               GET ABSOLUTE VALUE OF OFFSET\n         SRA   R0,24               IF IT IS TOO LARGE (GT FFFFFF),\n         BZ    *+6                 THEN...\n         LR    R5,R6                RESET BASE SO THAT OFFSET = ZERO\n         SPACE\n***********************************************************************\n* PREPARE FOR DATA MOVEMENT FROM VIRTUAL STORAGE TO BUFFER AREA.      *\n* SET UP CODE TO MOVE DATA USING CURRENT SHOW VALUE                   *\n***********************************************************************\n         SPACE\n         NI    BOOLEANS,255-RETRY  INITIALIZE RETRY FLAG\n         LH    R0,#SHOW            GET # OF LINES TO SHOW\n         CH    R0,#OLDSHOW         IF SAME AS PREVIOUS # OF LINES\n         BE    DONTGEN             THEN BYPASS CODE GENERATION. ELSE\n         STH   R0,#OLDSHOW         RESET PREVIOUS SHOW VALUE\nGETDATA  DS    0H                  (RETRY POINT FOR DATA ACCESS)\n*\n* AT THIS POINT R0 CONTAINS THE # OF LINES TO DISPLAY.\n*\n         STH   R0,#CURSHOW         SET # OF LINES CURRENTLY SHOWN\n         LA    R1,MVCAREA          INITIALIZE POINTER TO CODE AREA\n         LH    R14,MVCBIN+2        INITIALIZE MVC ADDRESS 1\n         LH    R15,MVCBIN+4        INITIALIZE MVC ADDRESS 2\nGENMLOOP DS    0H                  GENERATE MVC INSTRUCTIONS IN AREA\n         MVI   0(R1),X'D2'         BUILD MVC OP CODE\n         STCM  R14,3,2(R1)         SET UP DESTINATION ADDRESS\n         STCM  R15,3,4(R1)         SET UP SOURCE ADDRESS\n         CH    R0,=H'16'           DO IN GROUPS OF 16 LINES\n         BNH   GENMREST            UNTIL 16 LINES OR LESS ARE LEFT\n         MVI   1(R1),X'FF'         BUILD LENGTH OPERAND = 256 BYTES\n         LA    R1,6(,R1)           BUMP CODE POINTER\n         LA    R14,256(,R14)       INCREMENT ADDRESS 1\n         LA    R15,256(,R15)       INCREMENT ADDRESS 2\n         SH    R0,=H'16'           DECREMENT LENGTH REMAINING TO MOVE\n         B     GENMLOOP            AND CONTINUE LOOP\nGENMREST DS    0H                  NOW HANDLE REMAINING LENGTH\n         SLA   R0,4                # OF LINES * 16 = # OF BYTES TO MOVE\n         BCTR  R0,0                REDUCE BY 1 FOR MVC LENGTH\n         STC   R0,1(,R1)           BUILD LENGTH OPERAND\n         MVC   6(2,R1),BR14        BUILD \"BR 14\" OP CODE TO FINISH\nDONTGEN  DS    0H                  END OF CODE GENERATION\n         SPACE\n***********************************************************************\n* NOW WE CAN ACTUALLY MOVE DATA FROM REQUESTED AREA TO OUR BUFFER     *\n***********************************************************************\n         SPACE\n         L     R10,BUFADDR         SET ADDRESSABILITY TO BUFFER\n         OI    BOOLEANS,PROT       SET PROTECTION FLAG FOR ESPIE\n         NI    BOOLEANS,255-ABENDED    INITIALIZE PGM CHECK FLAG\n         LA    R0,MOVEFAIL\n         ST    R0,ERRET            SET RETURN ADDRESS (AMODE 24)\n         L     R15,=A(MOVE31+X'80000000')\n         BSM   0,R15               SWITCH TO AMODE 31\nMOVE31   DS    0H\n         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE\n         BO    MOVEBIN             THEN DO SMALLER MOVE. ELSE...\n*\n* IF 0C4 OCCURS, ESPIE EXIT WILL CAUSE CONTROL TO GO TO \"MOVEFAIL\".\n*\n* NOTE: MOVES MUST BE DONE IN 256-BYTE GROUPS TO INSURE MAXIMUM\n* CONSISTENCY OF DISPLAYED STORAGE.  USING MVCL WOULD NOT GUARANTEE\n* THIS SINCE IT IS INTERRUPTIBLE.\n*\n         BAL   R14,MVCAREA         CALL GENERATED CODE TO MOVE DATA\n         B     MOVEDOK\n         SPACE\nMOVEBIN  DS    0H\n         LH    R14,#CURSHOW        GET # OF LINES TO SHOW CURRENTLY\n         SLA   R14,2               MULTIPLY BY 4 TO GET # OF BYTES\n         BCTR  R14,0               REDUCE FOR EXECUTE\n         EX    R14,MVCBIN          MOVE DATA FROM STORAGE TO BUFFER\n         B     MOVEDOK\n*\n* END ESPIE-PROTECTED CODE\n*\nMOVEFAIL DS    0H                  0C4 OCCURRED DURING DATA MOVE...\n         SPACE\n*\n* NOTE THAT THE ESPIE EXIT SETS THIS RETURN POINT AS AMODE 24\n*\n         SPACE\n***********************************************************************\n* IF A PROTECTION EXCEPTION OCCURRED TRYING TO ACCESS THE REQUESTED   *\n* VIRTUAL STORAGE AREA, IT MAY BE BECAUSE WE WERE TRYING TO ACCESS A  *\n* BLOCK OF DATA THAT SPANNED 2 SEGMENTS THE SECOND OF WHICH WAS       *\n* INACCESSIBLE.  IF THIS IS THE CASE WE WISH TO RETRY THE ACCESS AND  *\n* ONLY DISPLAY THE FIRST SEGMENT.  SINCE WE MUST DISPLAY DATA IN      *\n* 16-BYTE LINES, THIS CAN WORK ONLY IF THE REQUESTED ADDRESS          *\n* REFERENCES AT LEAST 16 BYTES OF ACCESSIBLE STORAGE.                 *\n* NOTE THAT THE TEST WAS CHANGED FROM 4K TO 2K TO PREPARE FOR NEW     *\n* STORAGE PROTECTION FEATURES OF MVS/SP2.                             *\n***********************************************************************\n         SPACE\n         TM    BOOLEANS,RETRY      IF THIS WAS 2ND ATTEMPT,\n         BO    MOVERROR            THEN DATA CANNOT BE ACCESSED\n         LR    R0,R6               ELSE GET CURRENT ADDRESS\n         N     R0,=X'FFFFF800'     CONVERT TO 2K-SEGMENT ADDRESS\n         AH    R0,=H'2048'         GET ADDRESS OF NEXT 2K SEGMENT\n         SLR   R0,R6               GET LENGTH OF DATA IN THIS SEGMENT\n         TM    BOOLEANS,BINMODE    IF IN BINARY MODE,\n         BZ    RXSHIFT             THEN...\n         SRA   R0,2                 DIVIDE BY 4 TO GET # OF LINES\n         B     RTSHIFT             ELSE...\nRXSHIFT  SRA   R0,4                 DIVIDE BY 16 TO GET # OF LINES\nRTSHIFT  BZ    MOVERROR            IF 0, CANNOT RETRY, ERROR\n         CH    R0,#CURSHOW         WE CAN RETRY ONLY IF # OF LINES IS\n         BNL   MOVERROR             LESS THAN # WE TRIED TO ACCESS.\n         MVI   #OLDSHOW,X'80'      FORCE REGENERATION OF CODE NEXT TIME\n         OI    BOOLEANS,RETRY      INDICATE ANOTHER ATTEMPT\n         B     GETDATA             AND GO TO TRY IT AGAIN.\n         SPACE\nMOVERROR DS    0H                  ACCESS TO DATA FAILED...\n         NI    BOOLEANS,255-RETRY  TURN OFF RETRY INDICATOR\n         MVI   MSGNO,07            SAY STORAGE NOT ACCESSIBLE\n         B     RETFAIL             AND GO TO RESHOW CURRENT DISPLAY\nMOVEDOK  DS    0H                  DATA MOVEMENT WAS OK\n         SPACE\n         LA    R15,MOVE24\n         BSM   0,R15               SWITCH TO AMODE 24\nMOVE24   DS    0H\n         NI    BOOLEANS,255-PROT   TURN OFF PROTECTION TRAP\n         TM    BOOLEANS,DOPUSH     IF WE'RE SUPPOSED TO PUSH,\n         BZ    AFTPUSH             THEN\nPUSH     DS    0H                   PUSH ADDRESS ONTO BACKTRACK STACK\n*\n* THIS ROUTINE PUSHES THE CURRENT BASE AND ADDRESS ONTO THE\n* BACKTRACKING STACK.\n*\n         L     R1,STACKPTR         GET CURRENT STACK POINTER\n         LA    R1,8(,R1)           INCREMENT BY 1 ENTRY\n         CH    R1,=H'128'          IF THIS EXCEEDS SIZE OF STACK\n         BH    STKOVFLO            THEN PROCESS STACK OVERFLOW\n         ST    R1,STACKPTR         ELSE STORE NEW STACK POINTER\n         LA    R1,BKSTACK-8(R1)    ADDRESS NEW CURRENT STACK ELEMENT\n         STM   R5,R6,0(R1)         STORE CURRENT BASE & ADDR IN STACK\n         B     AFTPUSH             ELSE...\nSTKOVFLO DS    0H\n         MVC   BKSTACK(8*15),BKSTACK+8 SHIFT ENTRIES 2 THRU 16 OVER\n         STM   R5,R6,BKSTACK+8*15  STORE CURRENT BASE & ADDR IN STACK\nAFTPUSH  DS    0H\n         SPACE\n         TM    BOOLEANS,DOUPDATE   IF WE'RE SUPPOSED TO UPDATE,\n         BZ    AFTUPDT             THEN\nUPDATE   DS    0H                   UPDATE ADDRESS ON BACKTRACK STACK\n*\n* THIS ROUTINE INSERTS THE CURRENT BASE AND ADDRESS INTO THE\n* CURRENT STACK ENTRY, REPLACING THE PREVIOUS CONTENTS.\n*\n         ICM   R1,15,STACKPTR      GET CURRENT STACK POINTER\n         BZ    AFTUPDT             IF STACK IS NOT EMPTY, THEN...\n         LA    R1,BKSTACK-8(R1)     POINT TO CURRENT STACK ENTRY\n         STM   R5,R6,0(R1)          STORE CURRENT BASE & ADDR IN STACK\nAFTUPDT  DS    0H\n         SPACE\n* CLEAR THE OUTPUT AREA TO BLANKS\n         SPACE\n         LA    R0,VX               SET OUTPUT ADDRESS\n         LA    R1,VXEND-VX         SET OUTPUT LENGTH\n         XR    R14,R14             CLEAR INPUT POINTER\n         LA    R15,X'40'           SET UP SOURCE PADDING CHARACTER\n         SLL   R15,24              SET UP SOURCE MVCL REGISTER LENGTH\n         MVCL  R0,R14              CLEAR OUTPUT AREA TO BLANKS\n*\n* FOR EACH 16 BYTES OF BUFFER STORAGE, CONSTRUCT AN OUTPUT LINE\n* (INPUT POINTER IS R10)\n*\n         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE\n         BZ    SETXINCR            THEN\n         LA    R1,4                 SET BUMPING INCREMENT TO 4\n         B     SETAINCR            ELSE\nSETXINCR LA    R1,16                SET BUMPING INCREMENT TO 16\nSETAINCR DS    0H\n         LA    R2,VX               SET INITIAL OUTPUT POINTER\n         LR    R7,R6               SET CURRENT ADDRESS - BASE ADDRESS\n         SR    R7,R5                = INITIAL OFFSET FROM BASE\n         LR    R8,R6               SET INITIAL ADDRESS VALUE\n         LH    R15,#CURSHOW        GET NUMBER OF LINES TO FORMAT\nOUTLOOP  DS    0H\n         LA    R14,C'+'            USE A PLUS SIGN UNLESS\n         LTR   R7,R7\n         BNM   *+8                 CURRENT LINE OFFSET IS NEGATIVE,\n         LA    R14,C'-'            IN WHICH CASE USE A MINUS SIGN\n         LPR   R0,R7               GET ABSOLUTE VALUE OF OFFSET\n         ST    R0,DOUBLE           CONVERT RELATIVE OFFSET TO HEX\n         UNPK  LOCOFF(9),DOUBLE(5)  DISPLAY IN LOCATION OFFSET FIELD\n         TR    LOCOFF(8),HEXTBL\n         LA    R3,LOCOFF-1         SCAN FOR LEADING ZEROES IN OFFSET\n         LA    R0,7\nEDITLOOP CLI   1(R3),C'0'\n         BNE   EDITEND\n         MVI   1(R3),C' '          REPLACING THEM WITH BLANKS\n         LA    R3,1(,R3)\n         BCT   R0,EDITLOOP\nEDITEND  DS    0H\n         STC   R14,0(,R3)          STORE SIGN INTO OFFSET DISPLAY\n         MVI   0(R2),C' '          CLEAR OUTPUT LINE TO BLANKS\n         MVC   1(79-1,R2),0(R2)\n         MVC   0(8,R2),LOCOFF      MOVE OFFSET DISPLAY TO OUTPUT LINE\n         MVI   8(R2),C' '\n         ST    R8,DOUBLE           GET ADDRESS TO CONVERT TO HEX DSPL\n         UNPK  10(9,R2),DOUBLE+0(5)\n         TR    10(8,R2),HEXTBL\n         MVI   18(R2),X'02'        MOVE ATTR CHAR FOR DATA FIELDS\n         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE\n         BO    UNBIN               THEN GO TO DO BINARY DECONVERSION\n         UNPK  20(9,R2),0(5,R10)   ELSE DISPLAY HEX DATA\n         TR    20(8,R2),HEXTBL\n         MVI   28(R2),C' '\n         UNPK  29(9,R2),4(5,R10)\n         TR    29(8,R2),HEXTBL\n         MVI   37(R2),C' '\n         UNPK  38(9,R2),8(5,R10)\n         TR    38(8,R2),HEXTBL\n         MVI   46(R2),C' '\n         UNPK  47(9,R2),12(5,R10)\n         TR    47(8,R2),HEXTBL\n         MVI   55(R2),C' '\n         MVI   56(R2),X'01'        MOVE ATTR CHAR FOR ADDRESS FIELDS\n         MVI   57(R2),C'*'\n         MVC   58(16,R2),0(R10)\n         TR    58(16,R2),TRANSTBL\n         MVI   74(R2),C'*'\n         B     UNDONE              ELSE\nUNBIN    DS    0H                  BINARY DATA TO BE DISPLAYED\n         MVC   20(1,R2),0(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA\n         MVC   20+1(8,R2),20(R2)   PROPAGATE THROUGH OUTPUT SECTION\n         NC    20(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS\n         TR    20(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES\n         MVI   20+4(R2),C' '       BLANK OUT THE MIDDLE PART\n         MVC   30(1,R2),1(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA\n         MVC   30+1(8,R2),30(R2)   PROPAGATE THROUGH OUTPUT SECTION\n         NC    30(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS\n         TR    30(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES\n         MVI   30+4(R2),C' '       BLANK OUT THE MIDDLE PART\n         MVC   40(1,R2),2(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA\n         MVC   40+1(8,R2),40(R2)   PROPAGATE THROUGH OUTPUT SECTION\n         NC    40(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS\n         TR    40(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES\n         MVI   40+4(R2),C' '       BLANK OUT THE MIDDLE PART\n         MVC   50(1,R2),3(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA\n         MVC   50+1(8,R2),50(R2)   PROPAGATE THROUGH OUTPUT SECTION\n         NC    50(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS\n         TR    50(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES\n         MVI   50+4(R2),C' '       BLANK OUT THE MIDDLE PART\n         MVI   60(R2),X'01'        MOVE ATTR CHAR FOR DATA FIELDS\n         UNPK  61(3,R2),0(2,R10)   MOVE HEX BYTE IN\n         TR    61(2,R2),HEXTBL\n         MVI   61+2(R2),C' '\n         UNPK  64(3,R2),1(2,R10)   MOVE HEX BYTE IN\n         TR    64(2,R2),HEXTBL\n         MVI   64+2(R2),C' '\n         UNPK  67(3,R2),2(2,R10)   MOVE HEX BYTE IN\n         TR    67(2,R2),HEXTBL\n         MVI   67+2(R2),C' '\n         UNPK  70(3,R2),3(2,R10)   MOVE HEX BYTE IN\n         TR    70(2,R2),HEXTBL\n         MVI   70+2(R2),C' '\n         MVI   74(R2),C'*'\n         MVC   75(4,R2),0(R10)\n         TR    75(4,R2),TRANSTBL\n         MVI   79(R2),C'*'\nUNDONE   DS    0H                  OK - OUTPUT LINE COMPLETE\n         ALR   R7,R1               BUMP CURRENT OFFSET\n         ALR   R8,R1               BUMP CURRENT ADDRESS\n         LA    R2,80(,R2)          BUMP OUTPUT POINTER\n         ALR   R10,R1              BUMP INPUT POINTER\n         BCT   R15,OUTLOOP         REPEAT FOR ALL OUTPUT LINES\n         SPACE\n         MVI   ZCMD,C' '           SET ZCMD TO BLANKS\n         MVC   ZCMD+1(L'ZCMD-1),ZCMD\n         BCTR  R8,0                GET ADDRESS OF LAST BYTE MOVED\n         LTR   R8,R8               IF ADDRESS PAST 7FFFFFFF,\n         BNM   DISPLAY             THEN\n         MVI   MSGNO,08             SAY WRAPAROUND OCCURRED\n******** B     DISPLAY\n         EJECT\nDISPLAY  DS    0H\n         SPACE\n***********************************************************************\n* ISPEXEC DISPLAY PANEL(PANEL) MSG(MSGID)                             *\n***********************************************************************\n         SPACE\n         LA    R14,$DISPLAY\n         LA    R15,PANEL\n         LA    R0,MSGID\n         STM   R14,R0,ISPPARMS\n         XR    R15,R15             CLEAR INSERT REG\n         ICM   R15,1,MSGNO         GET MESSAGE NUMBER\n         BNZ   DISPMSG             IF ZERO, THEN...\n         OI    ISPPARM2,X'80'       SET # OF PARMS TO 2 TO IGNORE MSGID\n         B     DISPPNL             ELSE...\nDISPMSG  CVD   R15,DOUBLE\n         UNPK  MSGID+3(3),DOUBLE+6(2) CONVERT TO CHARACTER 999\n         OI    MSGID+5,X'F0'        TO CREATE MESSAGE ID NUMBER\n         OI    ISPPARM3,X'80'       SET # OF PARMS TO 3\nDISPPNL  LA    R1,ISPPARMS\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         LTR   R15,R15             IF RETURN CODE IS NONZERO\n         BNZ   RETURN0             THEN EXIT FUNCTION\n         MVC   PANEL,BLANKS        CLEAR PANEL NAME FOR EFFICIENCY\n         MVI   MSGNO,0             CLEAR MESSAGE ID FIELD\n         SPACE\n***********************************************************************\n* ISPEXEC VGET (ZVERB ZSCROLLA ZSCROLLN) SHARED                       *\n***********************************************************************\n         SPACE\n         LA    R1,@VGET\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         SPACE\n         B     LOOP                LOOP UNTIL NONZERO RC FROM DISPLAY\n         SPACE 2\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE\n***********************************************************************\n* RESTORE ESPIE ENVIRONMENT                                           *\n***********************************************************************\n         SPACE\n         L     R1,PREVSPIE         RESTORE PREVIOUS PIE ADDRESS\n         ESPIE RESET,(1)           RESTORE CALLER'S ESPIE\n         SPACE 2\nRETURN   DS    0H\n         SPACE\n         L     R2,SYMFIRST         FREE ALL SYMBOL TABLE STORAGE\nFREELOOP LTR   R1,R2\n         BZ    FREED\n         L     R2,SYMNEXT-SYM(,R2)\n         LA    R0,SYMLEN\n         FREEMAIN R,LV=(0),A=(1)\n         B     FREELOOP\nFREED    DS    0H\n         SPACE\n*\n* ISPEXEC VRESET\n*\n         LA    R1,@VRESET\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         SPACE\n         LM    R0,R1,BUFLA         FREE THE DATA BUFFER\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE\nNOISPF   DS    0H\n         SPACE\n         DELETE EPLOC==CL8'ISPLINK' RELEASE ISPLINK MODULE\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         XR    R15,R15             SET RETURN CODE TO ZERO\nBR14     BR    R14\n         EJECT\nCMDTABLE DS    0H\n         SPACE\nCLOCATE  DC    CL8'LOCATE  ',AL4(LOCATE)\nCRESET   DC    CL8'RESET   ',AL4(RESET)\nCUP      DC    CL8'UP      ',AL4(UP)\nCDOWN    DC    CL8'DOWN    ',AL4(DOWN)\nCLEFT    DC    CL8'XVXLEFT ',AL4(XVXLEFT)\nCRIGHT   DC    CL8'XVXRIGHT',AL4(XVXRIGHT)\nCLOAD    DC    CL8'LOAD    ',AL4(LOAD)\nCDELETE  DC    CL8'DELETE  ',AL4(DELETE)\nCLABELS  DC    CL8'LABELS  ',AL4(LABELS)\nCBASE    DC    CL8'BASE    ',AL4(BASE)\nCSHOW    DC    CL8'SHOW    ',AL4(SHOW)\nCDROP    DC    CL8'DROP    ',AL4(DROP)\nCBACK    DC    CL8'BACK    ',AL4(BACK)\nCCLEAR   DC    CL8'CLEAR   ',AL4(CLEAR)\nCBINARY  DC    CL8'BINARY  ',AL4(BINARY)\n         SPACE\nCMDEND   EQU   *\n         EJECT\nRESET    DS    0H                  PROCESS RESET COMMAND\n         SPACE\n         LTR   R4,R4                IF ARGUMENT IS NULL\n         BNZ   SETORIG              THEN\n         LR    R5,R6                 RESET BASE SO THAT OFFSET = ZERO\n         B     RETUPDT               RETURN TO MODIFY STACK. ELSE...\nSETORIG  XR    R3,R3                SET SIGN INDICATOR\n         CLI   ARGUMENT,C'+'        IF THERE IS A SIGN PRECEDING IT\n         BE    RESUPSGN             THEN\n         CLI   ARGUMENT,C'-'\n         BNE   AFTUPSGN\n         BCTR  R3,0                  SET SIGN INDICATOR\nRESUPSGN DS    0H                    IF A SIGN...\n         BCTR  R4,0                   REDUCE ARGUMENT LENGTH BY 1\n         MVC   ARGUMENT(L'ARGUMENT-1),ARGUMENT+1 SHIFT ARG LEFT 1\nAFTUPSGN BAL   R14,HEXIN           CONVERT ARGUMENT FROM HEX TO BINARY\n         TM    BOOLEANS,BADADDR    IF CONVERSION FAILED,\n         BZ    RESARGOK            THEN\n         MVI   MSGNO,01             SAY INVALID HEX VALUE\n         B     RETFAIL              AND RETURN.\nRESARGOK DS    0H\n         LTR   R3,R3               IF SIGN WAS MINUS\n         BZ    *+6                 THEN\n         LCR   R1,R1                SET NEW OFFSET NEGATIVE\n         LR    R5,R6               CURRENT ADDRESS MINUS NEW OFFSET\n         SR    R5,R1               GIVES NEW BASE ADDRESS\n         B     RETUPDT             RETURN TO MODIFY STACK\n         EJECT\nUP       DS    0H                  PROCESS UP COMMAND\nDOWN     DS    0H                    AND DOWN COMMAND\n         SPACE\n         LTR   R4,R4               IF THERE'S AN ARGUMENT\n         BZ    UPDOWNOK            THEN (NOT ACCEPTED AS SCROLL AMOUNT)\n         MVI   MSGNO,09             SAY INVALID SCROLL AMOUNT\n         B     RETFAIL              AND RETURN.\nUPDOWNOK DS    0H                  ELSE PROCESS SCROLL REQUEST\n         SPACE\n*\n* IF THE SHOW COMMAND WAS USED TO PRODUCE A SHORT DISPLAY, WE WILL\n* HAVE TO ADJUST THE SCROLL AMOUNT.  THIS DOES NOT APPLY TO A\n* DISPLAY SHORTENED TEMPORARILY BY STORAGE PROTECTION.\n*\n         CLI   ZSCROLLA,C'M'       IF SCROLL AMOUNT = MAX\n         BNE   SCRNOTM              THEN\n         MVI   MSGNO,25              SAY MAX IS INVALID\n         B     RETFAIL                AND RETURN.\nSCRNOTM  DS    0H                  ELSE\n         L     R1,ZSCROLLN         GET SCROLL AMOUNT\n         LH    R0,#SHOW            GET CURRENT AMOUNT TO SHOW\n         CLI   ZSCROLLA,C'P'       IF SCROLL AMOUNT = PAGE\n         BNE   SCRNOTP              AND\nSCRPAGE  CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT\n         BNH   SCROK                  THEN\n         LR    R1,R0                   USE SHOW AMOUNT\n         B     SCROK\nSCRNOTP  DS    0H                  ELSE\n         CLI   ZSCROLLA,C'C'       IF SCROLL AMOUNT = CURSOR\n         BNE   SCRNOTC             THEN\n*\n* FOR CURSOR SCROLLING, THE SCROLL AMOUNT RETURNED BY ISPF IS:\n* THE RELATIVE ROW NUMBER IF \"DOWN\" IS THE SCROLLING DIRECTION.\n* THE DISTANCE OF THE ROW FROM THE BOTTOM IF \"UP\" IS THE DIRECTION.\n* IN THE CASE OF \"UP\", WE HAVE TO FIGURE OUT WHAT THE DISTANCE OF\n* THE CURRENT ROW IS FROM THE LAST ROW SHOWN.\n*\n         CLI   ZVERB,C'D'           IF COMMAND = DOWN\n         BE    SCRPAGE               THEN ANALYZE SAME AS PAGE\n         L     R14,VXLVLIN           ELSE GET LAST VISIBLE LINE\n         LR    R15,R14               LVLINE MINUS SCROLL AMOUNT\n         SR    R15,R1                GIVES RELATIVE ROW NUMBER\n         LR    R1,R0                 PROVISIONALLY SCROLL LIKE PAGE\n         CR    R15,R0                IF AMOUNT WITHIN SHOW AMOUNT\n         BH    SCROK                  THEN SET SCROLL AMOUNT =\n         CR    R1,R14\n         BNH   *+6\n         LR    R1,R14\n         SR    R1,R15                  MIN(SHOW,LVLINE) - ROW NUM\n         B     SCROK\nSCRNOTC  DS    0H                  ELSE\n         CLI   ZSCROLLA,C'D'       IF SCROLL AMOUNT = DATA\n         BNE   SCRNOTD              AND\n         BCTR  R0,0\n         CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT - 1\n         BNH   SCROK                  THEN\n         LR    R1,R0                   USE SHOW AMOUNT - 1\n         B     SCROK\nSCRNOTD  DS    0H                  ELSE\n         CLI   ZSCROLLA,C'H'       IF SCROLL AMOUNT = HALF\n         BNE   SCRNOTH              AND\n         LH    R0,#SHOW\n         SRA   R0,1\n         CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT / 2\n         BNH   SCROK                  THEN\n         LR    R1,R0                   USE SHOW AMOUNT / 2\n******** B     SCROK\nSCRNOTH  DS    0H                  ELSE\nSCROK    DS    0H                  SCROLL AMOUNT IS IN R1\n         EX    0,SCRSHIFT          MULTIPLY BY 4|16 TO GET # OF BYTES\n         CLI   ZVERB,C'U'          IF COMMAND IS UP\n         BNE   *+6                 THEN\n         LCR   R1,R1                MAKE SCROLL BYTES NEG (TO SUBTRACT)\n         AR    R6,R1               ADD SCROLL BYTES TO CURRENT ADDRESS\n         B     RETUPDT             RETURN TO MODIFY STACK\n         EJECT\nXVXLEFT  DS    0H                  PROCESS LEFT COMMAND\nXVXRIGHT DS    0H                     AND RIGHT COMMAND\n         SPACE\n         LA    R1,1                INIT AMOUNT = 1\n         LTR   R4,R4               BUT IF ARGUMENT NOT NULL\n         BZ    LROK                THEN\n         BAL   R14,HEXIN            EXTRACT HEX VALUE OF ARGUMENT\n         TM    BOOLEANS,BADADDR     IF CONVERSION UNSUCCESSFUL\n         BO    LRERR                OR\n         LR    R0,R1                MORE THAN 6 HEX CHARACTERS\n         SRA   R0,24                 ARE SIGNIFICANT\n         BZ    LROK                 THEN\nLRERR    MVI   MSGNO,02              SAY INVALID HEX OFFSET\n         B     RETFAIL               RETURN IN ERROR. ELSE...\nLROK     CLI   ZVERB+3,C'L'        IF COMMAND = (XVX)LEFT\n         BNE   *+6                 THEN\n         LCR   R1,R1                MAKE SCROLL BYTES NEG (TO SUBTRACT)\n         AR    R6,R1               ADD SCROLL BYTES TO CURRENT ADDRESS\n         B     RETUPDT             RETURN TO MODIFY STACK\n         EJECT\nLOAD     DS    0H                  PROCESS LOAD COMMAND\n         SPACE\n         LTR   R15,R4               IF ARGUMENT LENGTH 0\n         BNP   LDLENERR             OR\n         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8\n         BNH   LDLENOK              THEN\nLDLENERR MVI   MSGNO,10              SAY INVALID OPERAND\n         B     RETFAIL             AND RETURN IN ERROR. ELSE...\nLDLENOK  DS    0H                  OK TO LOAD MODULE\n         MVC   LOADNAME,BLANKS\n         BCTR  R15,0\n         EX    R15,MVCLOAD         SET UP LOAD MODULE NAME\n         LOAD  EPLOC=LOADNAME,ERRET=LOADERR\n         LR    R6,R0               SET NEW ADDRESS = LOAD ENTRY POINT\n         N     R6,=X'7FFFFFFF'     CLEAR HIGH-ORDER BIT\n         LR    R5,R6               SET BASE ADDRESS = NEW CURRENT\n         MVI   MSGNO,12            TELL USER IT HAS BEEN DONE\n         B     RETPUSH             RETURN TO PUSH NEW VALUE ON STACK\nLOADERR  MVI   MSGNO,11            IF LOAD FAILED, SAY SO\n         B     RETFAIL             AND RETURN IN ERROR\n         EJECT\nDELETE   DS    0H                  PROCESS DELETE COMMAND\n         SPACE\n         LTR   R15,R4               IF ARGUMENT LENGTH 0\n         BNP   DELENERR             OR\n         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8\n         BNH   DELENOK              THEN\nDELENERR MVI   MSGNO,10              SAY INVALID OPERAND\n         B     RETFAIL               AND RETURN IN ERROR\nDELENOK  DS    0H                  ELSE OK\n         MVC   LOADNAME,BLANKS\n         BCTR  R15,0\n         EX    R15,MVCLOAD         SET UP LOAD MODULE NAME\n         DELETE EPLOC=LOADNAME\n         LTR   R15,R15\n         BNZ   DELETERR\n         MVI   MSGNO,13             TELL USER IT HAS BEEN DONE\n         B     RETSUCC              AND RETURN\nDELETERR DS    0H\n         MVI   MSGNO,14              SAY DELETE FAILED\n         B     RETFAIL               AND RETURN IN ERROR\n         EJECT\nLABELS   DS    0H                  PROCESS LABELS COMMAND\n         SPACE\n         XR    R3,R3               INITIALIZE LABEL COUNT\n         ICM   R2,15,SYMFIRST      GET FIRST SYMBOL\nLABELTST BZ    LABELEND            IF NO MORE, EXIT\n         USING SYM,R2\n         LTR   R3,R3               IF THIS IS THE FIRST TO DISPLAY\n         BNZ   LABELDIS            THEN\n*\n* ISPEXEC CONTROL DISPLAY LINE START(4)\n*\n         LA    R1,@LINE4\n         L     R15,@ISPLINK\n         BALR  R14,R15\nLABELDIS DS    0H\n         LA    R3,1(,R3)           ELSE INCREMENT LABEL COUNT\n         MVC   OUTNAME(8),SYMNAME\n         MVI   OUTNAME+8,C' '\n         MVC   HEXWORK(4),SYMADDR\n         UNPK  OUTADDR(9),HEXWORK(5)\n         TR    OUTADDR(8),HEXTBL\n         MVI   OUTADDR+8,C' '\n         LA    R1,OUTAREA\n         LA    R0,L'OUTAREA\n         TPUT  (1),(0),R           DISPLAY LABEL INFORMATION\nLABELNXT ICM   R2,15,SYMNEXT       ELSE GET NEXT SYMBOL IN CHAIN\n         B     LABELTST            AND CHECK IT\n         DROP  R2\nLABELEND MVI   ZCMD,C' '           CLEAR AREA TO BLANK\n         MVC   ZCMD+1(L'ZCMD-1),ZCMD\n         LTR   R3,R3               IF LABELS WERE FOUND\n         BNP   LABELMSG            THEN REFRESH THE DISPLAY\n*\n* ISPEXEC CONTROL DISPLAY REFRESH\n*\n         LA    R1,@REFRESH\n         L     R15,@ISPLINK\n         BALR  R14,R15\n         B     RETSUCC             ELSE\nLABELMSG MVI   MSGNO,18             SAY NO LABELS DEFINED\n         B     RETSUCC             RETURN TO CALLER\n         EJECT\nLOCATE   DS    0H                  PROCESS LOCATE COMMAND (OR ADDRESS)\n         SPACE\n*** ASSUME R4 IS NONZERO\n         SPACE\n         LA    R1,ARGUMENT-1(R4)   POINT TO LAST CHARACTER OF ARGUMENT\n         XR    R15,R15             CLEAR INDIRECTION COUNT\n         ST    R15,INDIRECT        STORE INDIRECTION COUNT\nPCLOOP   CLI   0(R1),C'?'          FOR EVERY QUESTION MARK\n         BE    GOTINDXX             OR\n         CLI   0(R1),C'%'            PERCENT SIGN\n         BNE   NOPCENTS               AT END OF ARG, DO:\nGOTINDXX LA    R15,1(,R15)         INCREMENT INDIRECTION COUNT\n         BCTR  R1,0                BUMP BACK\n         ST    R15,INDIRECT        STORE INDIRECTION COUNT\n         BCT   R4,PCLOOP           REDUCE LENGTH AND CONTINUE\n         B     PROCPCNT            IF ?-%'S ONLY, DO ONLY INDIRECTION\n         SPACE\nNOPCENTS DS    0H                  ELSE...\n         BAL   R14,GETADDR         RESOLVE ADDRESS\n         TM    BOOLEANS,BADADDR    IF ERROR OCCURRED,\n         BO    RETFAIL             THEN RETURN, DO NOTHING. ELSE\n         LR    R6,R1               SET NEW CURRENT ADDRESS\n         TM    BOOLEANS,KEEPBASE   IF BASE IS TO BE ALTERED\n         BO    PROCPCNT            THEN\n         LR    R5,R6                SET NEW BASE FROM NEW CURRENT ADDR\n         SPACE\nPROCPCNT DS    0H                  NOW PROCESS INDIRECTION REQUESTS\n         ICM   R15,15,INDIRECT     GET INDIRECTION COUNT\n         BZ    RETPUSH             IF NO INDIRECTION, PUSH AND RETURN\n         LA    R1,ARGUMENT(R4)     POINT TO FIRST INDIRECTION SYMBOL\n         LA    R0,BADIND           SET UP ERROR ROUTINE IF 0C4 OCCURS\n         ST    R0,ERRET             WHILE ACCESSING DATA\n         L     R14,=A(STARTIND+X'80000000')\n         BSM   0,R14               SWITCH TO AMODE 31\nSTARTIND OI    BOOLEANS,PROT       INTERCEPT PROTECTION VIOLATIONS\n*\n* IF 0C4 OCCURS, ESPIE EXIT WILL CAUSE CONTROL TO GO TO \"BADIND\".\n*\nINDLOOP  L     R6,0(,R6)           GET VALUE AT SPECIFIED ADDRESS\n         CLI   0(R1),C'%'          IF 24-BIT INDIRECT ADDRESSING\n         BNE   INDCONT              REQUESTED (\"%\" SIGNS), THEN...\n         N     R6,=X'00FFFFFF'       CLEAR HIGH-ORDER BYTE OF ADDRESS\nINDCONT  LA    R1,1(,R1)           BUMP TO NEXT INDIRECTION SYMBOL\n         BCT   R15,INDLOOP         CONTINUE UNTIL NO MORE % SIGNS\n*\n* END ESPIE-PROTECTED CODE\n*\n         NI    BOOLEANS,255-PROT   TURN OFF PROTECTION TRAP\n         LA    R14,ENDIND          SWITCH TO AMODE 24\n         BSM   0,R14\nENDIND   DS    0H\n         N     R6,=X'7FFFFFFF'     CLEAR HIGH-ORDER BIT\n         LR    R5,R6               SET BASE ADDRESS = CURRENT ADDRESS\n         B     RETPUSH             RETURN TO PUSH GOOD ADDR ON STACK\n         SPACE\nBADIND   DS    0H                  0C4 OCCURRED DURING INDIRECTION\n*\n* NOTE THAT THE ESPIE EXIT SETS THIS RETURN POINT AS AMODE 24\n*\n         MVI   MSGNO,19            SAY ERROR OCCURRED\n         B     RETFAIL             RETURN WITH BAD ADDRESS\n         EJECT\nBASE     DS    0H                  PROCESS BASE COMMAND\n         SPACE\n         LR    R1,R6               SET RESULT TO CURRENT ADDRESS\n         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO\n         BZ    RETBASE             THEN RETURN WITH THAT BASE. ELSE...\n         BAL   R14,GETADDR         RESOLVE ADDRESS\n         TM    BOOLEANS,BADADDR    IF ERROR OCCURRED,\n         BO    RETFAIL             THEN RETURN, DO NOTHING. ELSE...\nRETBASE  LR    R5,R1               SET NEW BASE = RESULT\n         B     RETUPDT             RETURN TO MODIFY STACK\n         EJECT\nSHOW     DS    0H                  PROCESS SHOW COMMAND\n         SPACE\n         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO\n         BNZ   SHOWVFY             THEN (USE DEFAULT VALUE)...\n         L     R1,VXLINES           USE DEFAULT VALUE\n         B     SHOWSET             RETURN WITH GOOD ADDRESS\nSHOWVFY  DS    0H                  CONVERT TO NUMERIC IN R1\n         CH    R4,=H'2'            IF LENGTH OF ARGUMENT GREATER THAN 2\n         BH    SHOWERR             THEN ERROR - INVALID SHOW AMOUNT\n         LR    R15,R4              ELSE...\n         BCTR  R15,0                USING LENGTH OF ARGUMENT\n         EX    R15,VERIFY           CHECK ALL NUMERICS IN ARGUMENT\n         BNZ   SHOWERR              IF ARGUMENT NOT NUMERIC, ERROR\n         EX    R15,SHOPACK         USING LENGTH COMPUTED PREVIOUSLY,\n         CVB   R1,DOUBLE           PUT SHOW AMOUNT IN R1\n         LTR   R1,R1               IF VALUE LESS THAN 1\n         BNP   SHOWERR             THEN ERROR\n         C     R1,VXLINES          ELSE IF VALUE EXCEEDS MAX ALLOWABLE\n         BH    SHOWERR             THEN ERROR\nSHOWSET  STH   R1,#SHOW            ELSE SAVE NEW SHOW VALUE\n         B     RETSUCC\nSHOWERR  MVI   MSGNO,20            SAY ERROR OCCURRED\n         B     RETFAIL             RETURN IN FAILURE\n         EJECT\nDROP     DS    0H                  PROCESS DROP COMMAND\n         SPACE\n         LTR   R15,R4               IF ARGUMENT LENGTH 0\n         BNP   DROPERR              OR\n         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8\n         BNH   DROPOK               THEN\nDROPERR  MVI   MSGNO,15              SAY INVALID LABEL\n         B     RETFAIL               RETURN IN FAILURE\nDROPOK   DS    0H                  ELSE OK\n         MVC   LOADNAME,BLANKS\n         BCTR  R15,0\n         EX    R15,MVCLOAD         SET UP LABEL NAME\n         LA    R2,SYMFIRST         INIT PREVIOUS-ENTRY POINTER\n         USING SYM,R1\nDROPLOOP ICM   R1,15,SYMNEXT-SYM(R2) GET ADDR OF SYMBOL TABLE ENTRY\n         BZ    DROPNF              IF NONE LEFT, SYMBOL NOT FOUND\n         CLC   LOADNAME,SYMNAME    IF THIS IS A MATCH\n         BE    DROPIT              THEN DROP IT\n         LR    R2,R1               ELSE SAVE ADDRESS OF JUST-PROCESSED\n         B     DROPLOOP            AND GO TO NEXT ENTRY.\nDROPNF   DS    0H                  IF NOT FOUND...\n         MVI   MSGNO,21            SAY LABEL NOT FOUND\n         B     RETFAIL             AND RETURN WITH BAD ADDRESS\nDROPIT   DS    0H                  LABEL FOUND...\n         MVC   SYMNEXT-SYM(4,R2),SYMNEXT  CHAIN CURRENT NEXT TO PREV'S\n         CL    R1,SYMLAST          IF THIS IS LAST IN CHAIN,\n         BNE   *+8                 THEN\n         ST    R2,SYMLAST           SET NEW LAST-IN-CHAIN POINTER\n         ICM   R0,15,SYMFIRST      IF THE FIRST IS ZERO (IE NONE LEFT)\n         BNZ   *+8                 THEN\n         ST    R0,SYMLAST           SET LAST TO ZERO TOO\n         LA    R0,SYMLEN           GET LENGTH OF AN ENTRY\n         FREEMAIN R,LV=(0),A=(1)   FREE THE DROPPED ENTRY\n         B     RETSUCC             RETURN.\n         DROP  R1\n         EJECT\nBACK     DS    0H                  PROCESS BACK COMMAND\n         SPACE\n         ICM   R1,15,STACKPTR      GET CURRENT STACK POINTER\n         BZ    NOBACK              IF ZERO, THEN CANNOT BACKTRACK\n         SH    R1,H8               DECREMENT STACK POINTER\n         BZ    NOBACK              IF ZERO, THEN CANNOT BACKTRACK\n         ST    R1,STACKPTR         ELSE POP ENTRY FROM THE STACK\n         LA    R14,BKSTACK-8(R1)   RESTORE BASE AND ADDRESS\n         LM    R5,R6,0(R14)         FROM STACK\n         B     RETSUCC              AND RETURN.\nNOBACK   MVI   MSGNO,22            ERROR - SAY YOU CAN'T BACKTRACK\n         B     RETFAIL             AND RETURN IN ERROR.\n         EJECT\nCLEAR    DS    0H                  PROCESS CLEAR COMMAND\n         SPACE\n         XC    STACKPTR,STACKPTR   SET STACK POINTER TO ZERO\n         B     RETPUSH             RETURN TO PUSH CURR ADDR ON STACK\n         EJECT\nBINARY   DS    0H                  PROCESS BINARY COMMAND\n         SPACE\n         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO\n         BZ    BINON               THEN SET BINARY MODE ON.\n         CH    R4,=H'2'            IF ARGUMENT LENGTH IS 2\n         BNE   BINTRY3              AND\n         CLC   ARGUMENT(2),=C'ON'    VALUE IS \"ON\"\n         BE    BINON                  THEN SET BINARY MODE ON\nBINTRY3  CH    R4,=H'3'            ELSE IF ARGUMENT LENGTH IS 3\n         BNE   BINERR               AND\n         CLC   ARGUMENT(3),=C'OFF'   VALUE IS \"OFF\"\n         BE    BINOFF                 THEN SET BINARY MODE OFF\nBINERR   MVI   MSGNO,23            ELSE SAY INVALID PARAMETER\n         B     RETFAIL             AND RETURN IN ERROR.\nBINON    DS    0H                  BINARY ON REQUESTED\n         OI    BOOLEANS,BINMODE    SET BINARY MODE FLAG ON\n         MVI   SCRSHIFT+3,2        SET SHIFT INSTRUCTION TO MULT BY 4\n         B     RETSUCC             AND RETURN.\nBINOFF   DS    0H                  BINARY OFF REQUESTED\n         NI    BOOLEANS,255-BINMODE SET BINARY MODE FLAG OFF\n         MVI   SCRSHIFT+3,4        SET SHIFT INSTRUCTION TO MULT BY 16\n         B     RETSUCC             AND RETURN.\n         EJECT\n***********************************************************************\n* ESPIE EXIT ROUTINE.                                                 *\n* THIS RECEIVES CONTROL IN AMODE 24, IN WHICH ESPIE MACRO WAS ISSUED. *\n***********************************************************************\n         SPACE\nSPIEEXIT DS    0H\n         USING *,R15\n         TM    BOOLEANS,PROT       IF PROTECTION EXCEPTION WAS EXPECTED\n         BZ    REALABND            THEN\n         NI    BOOLEANS,255-PROT    TURN OFF PROTECTION FLAG\n         OI    BOOLEANS,ABENDED     INDICATE INVALID ADDRESS\n         L     R0,ERRET             SET CONTINUATION ADDRESS & AMODE\n         ST    R0,76(,R1)           UPDATE OPSW IN EPIE W.NEW ADDRESS\n         BR    R14                  RETURN TO SYSTEM\nREALABND DS    0H                  ELSE REAL ABEND\n         LR    R2,R1               SAVE PIE ADDRESS IN R2 4 DEBUG\n         LA    R1,ABENDMSG\n         LA    R0,L'ABENDMSG\n         TPUT  (1),(0),R\n         ABEND X'0C4',DUMP         ABEND - NOTE PIE IN REG 2\nABENDMSG DC    C'XVX: SYSTEM ABEND...REG2->EPIE, 2R%+4C = PSW ADDR'\n         DROP  R15\n         EJECT\n***********************************************************************\n* SUBROUTINES                                                         *\n***********************************************************************\n         SPACE\nGETADDR  DS    0H                  SUBROUTINE TO RESOLVE ADDRESS\n*\n* THIS ROUTINE RESOLVES THE ADDRESS REFERENCED BY THE VALUE OF THE\n* FIELD \"ARGUMENT\".  THE LENGTH OF \"ARGUMENT\" IS CONTAINED IN R4\n* (THIS WILL HAVE BEEN ADJUSTED FOR EXTRA CHARACTERS LIKE PERCENT\n* SIGNS THAT ARE VALID ONLY FOR CERTAIN COMMANDS).\n* ON RETURN R1 = VALUE OF ADDRESS (LIKE R6).\n*\n         ST    R14,GETAD14         SAVE RETURN REGISTER\n         NI    BOOLEANS,255-KEEPBASE INITIALIZE BASE-ALTERATION FLAG\n         XR    R3,R3               SET SIGN INDICATOR\n         CLI   ARGUMENT,C'+'       IF ARGUMENT STARTS WITH A PLUS SIGN\n         BE    GASIGN              THEN PROCESS OFFSET LOCATE\n         CLI   ARGUMENT,C'-'       IF ARGUMENT STARTS WITH MINUS SIGN\n         BNE   GASTD               THEN\n         BCTR  R3,0                 SET SIGN INDICATOR NEGATIVE\nGASIGN   DS    0H                  OFFSET LOCATE...\n         OI    BOOLEANS,KEEPBASE   INDICATE BASE IS TO BE UNCHANGED\n         BCTR  R4,0                SUBTRACT 1 FROM LENGTH OF ARGUMENT\n         MVC   ARGUMENT(L'ARGUMENT-1),ARGUMENT+1 AND SHIFT ARG LEFT\n         BAL   R14,HEXIN           CONVERT HEX ARGUMENT TO BINARY\n         TM    BOOLEANS,BADADDR    IF INVALID HEX\n         BO    GETRET              THEN ERROR\n         LTR   R3,R3               IF SIGN WAS MINUS\n         BZ    *+6                 THEN\n         LCR   R1,R1                TAKE NEGATIVE VALUE\n         ALR   R1,R5               SET RESULT = BASE ADDRESS + VALUE\n         B     GETRET              AND RETURN TO CALLER.\n         SPACE\nGASTD    DS    0H                  STANDARD ADDRESS LOCATE\n         LA    R1,ARGUMENT-1(R4)   POINT TO LAST CHARACTER OF ARGUMENT\n         CLI   0(R1),C'.'          IF LAST CHAR IS A PERIOD\n         BNE   NOTPD               THEN\n         BCTR  R4,0                REDUCE ARGUMENT LENGTH BY 1\n         B     ISADDR              AND ALWAYS PROCESS AS AN ADDRESS\nNOTPD    DS    0H                  ELSE VALUE DOES NOT END IN PERIOD\n*\n* MAY BE A LABEL...SEE IF IT IS A SYMBOL FROM THE TABLE\n*\n         LR    R15,R4              USING LENGTH OF ARGUMENT,\n         BCTR  R15,0\n         EX    R15,TRTARG          VERIFY VALID CHARACTERS\n         BNZ   ISADDR              IF BAD CHARS, TREAT AS ADDRESS\n         TM    ARGUMENT,X'F0'      IF BEGINS WITH NUMERIC,\n         BO    ISADDR              THEN TREAT AS ADDRESS. ELSE...\n         MVC   VLABEL,BLANKS       CLEAR LABEL AREA TO BLANKS\n         EX    R15,MVCLABEL        MOVE ARGUMENT TO LABEL\n         LM    R15,R0,VLABEL       PICK UP VALUE AND USE IT AS A LABEL\n         BAL   R14,GETISYM         SEARCH FOR SYMBOL IN TABLE\n         LTR   R1,R1               IF NOT FOUND,\n         BZ    ISADDR               THEN ASSUME ADDRESS, PROCESS THUS\n         USING SYM,R1\n         L     R1,SYMADDR          ELSE USE ADDRESS FROM THE TABLE\n         DROP  R1\n         B     GETRET              AND PROCESS AS GOOD ADDRESS\nISADDR   DS    0H\n         BAL   R14,HEXIN           EXTRACT HEX VALUE FROM ARGUMENT\n         TM    BOOLEANS,BADADDR    IF ERROR DETECTED,\n         BO    GETRET               THEN JUST RETURN.\n         N     R1,=X'7FFFFFFF'     ZERO THE HIGH-ORDER BIT\nGETRET   DS    0H\n         L     R14,GETAD14         RESTORE RETURN ADDRESS\n         BR    R14                 RETURN TO CALLER\n         EJECT\nHEXIN    DS    0H\n*\n* THIS SUBROUTINE RETURNS A BINARY VALUE IN R1 BASED ON \"ARGUMENT\".\n* REMEMBER, R4 CONTAINS THE LENGTH OF \"ARGUMENT\" TO BE CONVERTED.\n* NOTE: R2 IS ALTERED.\n*\n* A VALUE ENDING IN \"N\" IS ASSUMED TO BE A DECIMAL VALUE.\n* OTHERWISE IT IS ASSUMED TO BE A HEX VALUE.\n*\n         LTR   R15,R4              USING LENGTH OF ARGUMENT\n         BNZ   HEXINNT0            IF LENGTH IS ZERO\n         MVI   MSGNO,03             THEN SAY INVALID COMMAND\n         B     HEXERROR\nHEXINNT0 DS    0H\n         LA    R1,ARGUMENT-1(R15)  POINT TO LAST CHAR OF ARGUMENT\n         CLI   0(R1),C'N'          IF VALUE ENDS IN \"N\",\n         BNE   HEXNOTN             THEN\n         BCTR  R15,0               SUBTRACT 1 FROM LENGTH OF ARG\n         LTR   R15,R15             IF REMAINING LENGTH IS ZERO\n         BNP   HEXINVCH            THEN FLAG AS ERROR\n         BCTR  R15,0               USING LENGTH OF ARGUMENT\n         EX    R15,VERIFY          CHECK ALL NUMERICS IN ARGUMENT\n         BNZ   HEXINVCH            IF ARGUMENT NOT NUMERIC, INVALID\n         CH    R15,=H'9'           IF TOO LONG TO BE A FIXED(31) BIN\n         BH    HEX2LONG            THEN VALUE TOO LONG\n         BL    HEXNLOK             IF LENGTH = 10 THEN\n         CLC   ARGUMENT(10),=C'2147483647'\n         BH    HEX2LONG            THEN VALUE TOO LONG\nHEXNLOK  DS    0H                  ELSE VALID NUMERIC VALUE\n         EX    R15,SHOPACK         PACK INTO \"DOUBLE\"\n         CVB   R1,DOUBLE           RETURN WITH DECIMAL AMOUNT IN R1\n         BR    R14                 RETURN TO CALLER\n         SPACE\nHEXNOTN  DS    0H\n         CH    R15,H8               USING LENGTH OF ARGUMENT\n         BNH   HEXINNT8            IF LENGTH IS GREATER THAN 8\nHEX2LONG MVI   MSGNO,05             THEN SAY ADDRESS TOO LONG\n         B     HEXERROR\nHEXINNT8 DS    0H\n         BCTR  R15,0\n         EX    R15,XVERIFY          CHECK HEX CHARS IN ARGUMENT\n         BZ    HEXINOK              IF ARGUMENT NOT HEX\nHEXINVCH MVI   MSGNO,06              THEN SAY BAD ADDRESS\n******** B     HEXERROR\nHEXERROR DS    0H                  IF ERROR OCCURRED...\n         OI    BOOLEANS,BADADDR    INDICATE ADDRESS IS BAD\n         BR    R14                 AND RETURN TO CALLER\nHEXINOK  DS    0H                  ELSE AMOUNT IS OK\n         MVC   HEXWORK(8),BLANKS\n         EX    R15,HEXMVC          MOVE TO WORKAREA\n         EX    R15,HEXTR           TRANSLATE\n         LA    R15,1(,R15)         ADD 1 FOR PACKING\n         EX    R15,HEXPACK         AND PACK\n         ICM   R1,15,DOUBLE+3      RETURN WITH HEX AMOUNT IN R1\n         BR    R14                 RETURN TO CALLER\n         SPACE\nXVERIFY  TRT   ARGUMENT(0),XVERTBL VERIFY HEX CHARS IN ARGUMENT\nHEXMVC   OC    HEXWORK(0),ARGUMENT MOVE TO WORK AREA\nHEXTR    TR    HEXWORK(0),HEXINTBL TRANSLATE IN PREPARATION FOR HEXIN\nHEXPACK  PACK  DOUBLE,HEXWORK(0)   PACK ARGUMENT FOR CONVERSION\n         EJECT\nGETISYM  DS    0H\n*\n* THIS SUBROUTINE RETURNS THE ADDRESS OF AN IMMEDIATE SYMBOL ENTRY.\n* ON ENTRY REGS 15 AND 0 CONTAIN THE SYMBOL NAME.\n* ON RETURN R1 CONTAINS THE ADDRESS OF THE ENTRY, OR ZERO IF NONE.\n*\n         ICM   R1,15,SYMFIRST      GET FIRST SYMBOL\nGETITEST BZR   R14                 IF NONE, RETURN WITH NONE\n         USING SYM,R1\n         CL    R15,SYMNAME         COMPARE FIRST 4 CHARS\n         BNE   GETINEXT            IF NOT EQUAL, GET NEXT ENTRY\n         CL    R0,SYMNAME+4        COMPARE THE REST\n         BER   R14                 IF EQUAL, RETURN, GOT IT\nGETINEXT ICM   R1,15,SYMNEXT       ELSE GET NEXT SYMBOL IN CHAIN\n         B     GETITEST            AND CHECK IT\n         DROP  R1\n         EJECT\n***********************************************************************\n* EXECUTED INSTRUCTIONS                                               *\n***********************************************************************\n         SPACE\nMVCARG   OC    ARGUMENT(0),ZCMD    EXTRACT ARGUMENT FROM ZCMD FIELD\nMVCLOAD  OC    LOADNAME(0),ARGUMENT MOVE ARGUMENT TO LOAD NAME\nMVCLABEL OC    VLABEL(0),ARGUMENT  MOVE ARGUMENT TO LABEL NAME\nMVCBIN   MVC   0(0,R10),0(R6)      MOVE DATA FROM STORAGE TO BUFFER\nTRTARG   TRT   ARGUMENT(0),NAMETBL VERIFY VALID CHARACTERS\nVERIFY   TRT   ARGUMENT(0),VERTBL  VERIFY NUMERICS IN ARGUMENT\nSHOPACK  PACK  DOUBLE,ARGUMENT(0)  PACK ARGUMENT FOR CONVERSION\n         SPACE 2\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 1\n$XVX     DC    CL8'XVX'            APPLICATION ID PREFIX\n         ORG   $XVX+3              DON'T WASTE ANY PRECIOUS BYTES\nBLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS\n         SPACE 1\n@ERRDISP DS    0A                  PARAMETERS FOR ISPLINK DISPLAY\n         DC    A($DISPLAY)\n         DC    X'80'\n         DC    AL3($XVXERR)\n         SPACE 1\n@REFRESH DS    0A                  PARAMETERS FOR ISPLINK CONTROL\n         DC    A($CONTROL)\n         DC    A($DISPLAY)\n         DC    X'80'\n         DC    AL3($REFRESH)\n         SPACE 1\n@LINE4   DS    0A                  PARAMETERS FOR ISPLINK CONTROL\n         DC    A($CONTROL)\n         DC    A($DISPLAY)\n         DC    A($LINE)\n         DC    X'80'\n         DC    AL3($FOUR)\n         SPACE 1\n@VGET    DS    0A                  PARAMETERS FOR ISPLINK VGET\n         DC    A($VGET)\n         DC    A($GETVARS)\n         DC    X'80'\n         DC    AL3($SHARED)\n         SPACE 1\n@VRESET  DS    0A                  PARAMETERS FOR ISPLINK VRESET\n         DC    X'80'\n         DC    AL3($VRESET)\n         SPACE 1\n@PQUERY  DS    0A                  PARAMETERS FOR ISPLINK PQUERY\n         DC    A($PQUERY)          1. SERVICE NAME\n         DC    A($XVX)             2. PANEL NAME\n         DC    A($VX)              3. AREA NAME\n         DC    A(BLANKS)           4. AREATYPE OMITTED\n         DC    A(BLANKS)           5. WIDTH OMITTED\n         DC    X'80'               6. DEPTH INTO VXLINES\n         DC    AL3($VXLINES)       7. ALL OTHER PARAMETERS OMITTED\n         SPACE 1\n         LTORG\n         SPACE 1\n$FOUR    DC    F'4'\n$EIGHT   DC    F'8'\nH8       EQU   $EIGHT+2,2,C'H'\n$DISPLAY DC    C'DISPLAY '\n$REFRESH DC    C'REFRESH '\n$CONTROL DC    C'CONTROL'\n$LINE    DC    C'LINE '\n$VGET    DC    C'VGET'\n$GETVARS DC    C'('\n$ZVERB   DC    C'ZVERB '\n$ZSCRLLA DC    C'ZSCROLLA '\n$ZSCRLLN DC    C'ZSCROLLN '\n         DC    C')'\n$SHARED  DC    C'SHARED'\n$VRESET  DC    C'VRESET'\n$PQUERY  DC    C'PQUERY'\n$VX      DC    C'VX '\n$VXLINES DC    C'VXLINES '\n$XVXERR  DC    C'XVXERROR'\n         SPACE 1\nINITSLA  SLA   R1,4                INITIAL SHIFT FOR LINES TO BYTES\n         SPACE 1\nTRANSTBL DS    0C\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/........\u00a0,%_>?'\n         DC    C'.........`:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    C'................'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\nVERTBL   DC    256X'01'\n         ORG   VERTBL+C'0'\n         DC    10X'00'\n         ORG\n         SPACE\nXVERTBL  DC    256X'01'\n         ORG   XVERTBL+X'81'\n         DC    6X'00'\n         ORG   XVERTBL+C'A'\n         DC    6X'00'\n         ORG   XVERTBL+C'0'\n         DC    10X'00'\n         ORG\n         SPACE\nHEXINTBL DC    256YL1(*-HEXINTBL)\n         ORG   HEXINTBL+X'81'\n         DC    X'FAFBFCFDFEFF'\n         ORG   HEXINTBL+C'A'\n         DC    X'FAFBFCFDFEFF'\n         ORG\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         SPACE\nNAMETBL  DC    256X'01'            TABLE TO VERIFY NAMES\n         ORG   NAMETBL+C' '\n         DC    X'00'\n         ORG   NAMETBL+C'@'\n         DC    X'00'\n         ORG   NAMETBL+C'#'\n         DC    X'00'\n         ORG   NAMETBL+C'$'\n         DC    X'00'\n         ORG   NAMETBL+C'A'\n         DC    9X'00'\n         ORG   NAMETBL+C'J'\n         DC    9X'00'\n         ORG   NAMETBL+C'S'\n         DC    8X'00'\n         ORG   NAMETBL+C'0'\n         DC    10X'00'\n         ORG\nBINTBL   DC    C'0',128C'1'        TABLE TO TRANSLATE TO BINARY DISPLAY\n         SPACE 2\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D\nPANEL    DS    CL8                 PANEL NAME\nMSGID    DS    CL8                 MESSAGE ID\nZVERB    DS    CL8                 COMMAND VERB FIELD\nLOADNAME DS    CL8                 LOAD MODULE NAME FOR LOADS\nVLABEL   DS    CL8                 LABEL NAME FOR PROCESSING\nVADDR    DS    A                   ADDRESS FOR MESSAGES\nPREVSPIE DS    A                   ADDRESS OF PREVIOUS ESPIE ELEMENT\nERRET    DS    A                   RETURN ADDRESS FOR ESPIE PROCESSING\nGETAD14  DS    A                   SAVE AREA FOR SUBROUTINE\n@ISPLINK DS    A                   ADDRESS OF ISPLINK\nISPPARMS DS    0A                  PARAMETERS FOR ISPLINK\nISPPARM1 DS    A\nISPPARM2 DS    A\nISPPARM3 DS    A\nISPPARM4 DS    A\nISPPARM5 DS    A\nISPPARM6 DS    A\nZSCROLLA DS    CL4                 SCROLL AMOUNT CHARACTER VALUE\nZSCROLLN DS    F                   SCROLL AMOUNT NUMERIC VALUE\nSAVEADRS DS    2F                  SAVED BASE ADDRESS & CURRENT ADDRESS\nSYMFIRST DS    A                   ADDRESS OF IMMEDIATE-SYMBOL CHAIN\nSYMLAST  DS    A                   ADDRESS OF LAST IMMEDIATE SYMBOL\nINDIRECT DS    F                   INDIRECT ADDRESSING COUNT\nBUFLA    DS    2A                  LENGTH AND ADDRESS OF DATA BUFFER\n         ORG   BUFLA\nBUFLEN   DS    F                   LENGTH OF DATA BUFFER\nBUFADDR  DS    A                   ADDRESS OF DATA BUFFER\nSTACKPTR DS    A                   POINTER INTO BACKTRACKING STACK\nBKSTACK  DS    16D                 BACKTRACKING STACK FOR BACK COMMAND\nSCRSHIFT SLA   0,0                 INSTR TO CONVERT LINES TO BYTES\nMVCAREA  DS    13H                 AREA TO BUILD CODE TO MOVE DATA\nMSGNO    DS    X                   NUMERIC MESSAGE ID\nARGUMENT DS    CL72                TEXT OF ARGUMENT\nZCMD     DS    CL72                COMMAND INPUT FIELD\n         ORG   ZCMD                OVERLAY THIS AREA FOR...\nOUTAREA  DS    0CL18               OUTPUT AREA FOR LABEL DISPLAY\nOUTNAME  DS    CL8\n         DS    C\nOUTADDR  DS    CL8\n         DS    C\n         ORG\nVXLEN    DS    F                   SIZE OF DYNAMIC SCREEN AREA\nVXLINES  DS    F                   NUMBER OF PANEL OUTPUT LINES\nVXLVLIN  DS    F                   LAST VISIBLE LINE FROM PANEL\n#SHOW    DS    H                   NUMBER OF OUTPUT LINES TO SHOW\n#OLDSHOW DS    H                   PREVIOUS VALUE TO SHOW\n#CURSHOW DS    H                   NUMBER OF LINES CURRENTLY SHOWN\nVXNAME   DS    CL6                 VARIABLE NAMES FOR VDEFINES\nHEXWORK  DS    CL9                 WORK AREA FOR HEXIN\nLOCOFF   DS    CL9                 OFFSET OF LOCATION\nBOOLEANS DS    X                   BITS\nPROT     EQU   B'10000000'         1 = PROTECTION EXCEPTION EXPECTED\nBADADDR  EQU   B'01000000'         1 = BAD ADDRESS SPECIFIED\nABENDED  EQU   B'00100000'         1 = ESPIE TRAPPED PROGRAM CHECK\nKEEPBASE EQU   B'00010000'         1 = LOCATE CMD NOT TO ALTER BASE\nDOPUSH   EQU   B'00001000'         1 = PUSH A BACKTRACK STACK ADDRESS\nDOUPDATE EQU   B'00000100'         1 = UPDATE CURRENT BACKTRACK ADDRESS\nRETRY    EQU   B'00000010'         1 = RETRY AFTER PROTECTION EXCEPTION\nBINMODE  EQU   B'00000001'         1 = BINARY MODE ACTIVE\nVX       DS    40CL80              AREA TO BUILD OUTPUT SCREEN DATA\nVXEND    EQU   *\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         EJECT\nSYM      DSECT ,                   MAP THE SYMBOL CHAIN ENTRIES\nSYMNEXT  DS    A                   ADDRESS OF NEXT ELEMENT IN CHAIN\nSYMNAME  DS    CL8                 SYMBOL NAME\nSYMADDR  DS    A                   ADDRESS OF SYMBOL\nSYMLEN   EQU   *-SYM               LENGTH OF A SYMBOL ENTRY\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 1\n         END\n./ ADD NAME=XWRITENR 0100-07332-07332-0900-00197-00197-00000-SEB\n         TITLE 'XWRITENR copyright notice'\n***********************************************************************\n*                                                                     *\n*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n         TITLE 'XWRITENR - REXX external function to simulate WRITENR'\nXWRITENR CSECT\nXWRITENR AMODE ANY\nXWRITENR RMODE ANY\n         SPACE\n***********************************************************************\n*\n* Syntax:  call XWRITENR \"anything at all\"\n*\n***********************************************************************\n*                                                                *\n* Input:       (R1) = address of IRXEFPL parameter list:         *\n*                                                                *\n*              Offset:                                           *\n*               00 = Reserved                                    *\n*               04 = Reserved                                    *\n*               08 = Reserved                                    *\n*               0C = Reserved                                    *\n*               10 = Address of the parsed argument list         *\n*               14 = Address of the address of the EVALBLOCK     *\n*                                                                *\n******************************************************************\n*                                                                *\n* Output:      R15 = return code from PUTLINE                    *\n*                                                                *\n******************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SAVE  (14,12),,XWRITENR_&SYSDATE._&SYSTIME\n         BALR  R12,0\n         USING *,R12\n         SPACE\n         L     R2,16(,R1)          R2 = address of parsed argument list\n         L     R6,20(,R1)          R6 = address of address of EVALBLOCK\n         L     R6,0(,R6)           R6 = address of EVALBLOCK\n         L     R4,4(,R2)           R4 = length of message\n         L     R5,0(,R2)           R5 = address of text of message\n         C     R5,=X'FFFFFFFF'     If number of arguments not 1\n         BE    ERROR               then error\n         L     R0,8(,R2)\n         C     R0,=X'FFFFFFFF'     If number of arguments not 1\n         BNE   ERROR               then error\n         LTR   R15,R4              If message length is zero\n         BZ    RETURN              then return code(zero)\n         LA    R0,DYSIZE           Get size of dynamic area w/o message\n         AR    R0,R4               Add length of message\n         GETMAIN R,LV=(0)          Get dynamic storage area\n         SPACE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         SPACE\nLENOK    DS    0H\n         CH    R4,=H'256'          If message is 256 chars or less\n         BH    MOVELONG            then...\n         LR    R14,R4\n         BCTR  R14,0                decrement length for move\n         EX    R14,MOVEMSG          Move message to buffer\n         B     MSGMOVED            else...\nMOVELONG DS    0H\n         LA    R0,PUTBUF+4         Address of message destination\n         LR    R1,R4               Length of message destination\n         LR    R14,R5              Address of message source\n         LR    R15,R4              Length of message source\n         MVCL  R0,R14              Move message to buffer\nMSGMOVED DS    0H\n         LA    R14,4(,R4)         Add length of header\n         SLL   R14,16             Shift: 1st HWD = hdr, 2nd = no 2ndary\n         ST    R14,PUTBUF         Put in first 2 halfwords in header\n         SPACE\n         LA    R1,IOPLSP           Set up IOPL\n         USING IOPL,R1\n         SPACE\n         USING PSA,0\n         L     R8,PSATOLD           GET TCB ADDRESS\n         USING TCB,R8\n         L     R8,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R8\n         L     R8,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R8,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R8\n         MVC   IOPLUPT,PSCBUPT      PUT UPT ADDRESS IN IOPL\n         L     R8,PSCBRLGB          GET ADDR OF RELOGON BUFFER\n         USING RLGB,R8\n         MVC   IOPLECT,RLGBECT      PUT ADDRESS OF ECT IN IOPL\n         SPACE\n         SR    R0,R0\n         ST    R0,ECB              Zero out ECB\n         ST    R0,IOPLIOPB         Zero out IOPL parm block address\n         LA    R0,ECB\n         ST    R0,IOPLECB          Finish up IOPL\n         MVC   PUTBLK(LPUTBLK),PUTMAST     Build PUTLINE MF=L\n         DROP  R1\n         EJECT\n         PUTLINE PARM=PUTBLK,OUTPUT=(PUTBUF,TERM,SINGLE,DATA),         +\n               TERMPUT=(ASIS),                                         +\n               MF=(E,(1))\n         EJECT\nENDIT    LR    R3,R15              Save return code\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         CVD   R3,DOUBLE           Return code\n         UNPK  16(2,R6),DOUBLE     Generate 2 digits\n         OI    17(R6),X'F0'\n         CLI   16(R6),C'0'         If first digit is 0\n         BNE   NOTZ                then\n         MVC   16(1,R6),17(R6)      make it a 1-digit number\n         MVI   17(R6),C' '\n         LA    R0,1                 set length to 1\n         ST    R0,8(,R6)            set EVLEN (in EVALBLOCK) to length\nNOTZ     DS    0H\n         LA    R0,DYSIZE           Get length of storage w/o message\n         AR    R0,R4               Add length of message\n         LA    R1,DYNAM            Get address of storage\n         L     R13,4(0,R13)\n         FREEMAIN R,LV=(0),A=(1)\nRETURN   DS    0H\n         RETURN (14,12),T,RC=0\n         SPACE 2\nERROR    DS    0H                  Here if wrong # of arguments\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         MVC   16(2,R6),=C'-2'     Return value\n         B     RETURN\n         SPACE 2\nMOVEMSG  MVC   PUTBUF+4(0),0(R5)\n         EJECT\nPUTMAST  PUTLINE MF=L\n         EJECT\nDYNAM    DSECT\n         SPACE\nSAVEAREA DS    9D\nDOUBLE   DS    D          Work area for conversions\n         SPACE\nPUTBLK   PUTLINE MF=L\nLPUTBLK  EQU   *-PUTBLK\n         SPACE\nIOPLSP   DS    4F        INPUT OUTPUT PARAMETER BLOCK\nECB      DS    F\n         SPACE\nPUTBUF   DS    F          MESSAGE HEADER\n         SPACE\n*                                  (Actual message buffer variable)\n         SPACE\nDYSIZE   EQU   *-DYNAM             Length of dynamic area w/o msg buf\n         EJECT\n*\n*  STORAGE DEFINITIONS:\n*\n         SPACE\n         IKJIOPL\n         SPACE\n         IKJCPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJECT\n         SPACE\n         IKJPSCB\n         EJECT ,\n         IHAPSA\n         EJECT ,\n         IKJTCB\n         EJECT ,\n         IEZJSCB\n         EJECT ,\n         IKJRLGB\n         EJECT\n         SPACE 5\n         END\n./ ADD NAME=YITADDR  0100-07332-07332-0900-00250-00250-00000-SEB\n         TITLE 'YITADDR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BASSM R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITADDR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), RETURNS THE HEX ADDRESS AS A       *\n* CLIST VARIABLE.                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITADDR  CSECT\n         SAVE  (14,12),,YITADDR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITADDR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         MVI   YITHEX,C' '\n         MVC   YITHEX+1(L'YITHEX-1),YITHEX\n*\n* SET YITHEX = THE VALUE\n*\n         ST    R0,DOUBLE\n         UNPK  YITHEX(9),DOUBLE(5)\n         TR    YITHEX(8),HEXTBL\n         SPACE 1\nYITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *\n* VALUE AS A CLIST VARIABLE.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARM1\n         L     R1,ADPLCPPL\n         USING CPPL,R1\n         L     R1,CPPLECT\n         DROP  R1\n         ST    R1,CPARM7\n         OI    CPARM7,X'80'\n         LA    R0,TSVEUPDT\n         ST    R0,CENTRY\n         XR    R0,0\n         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME\n         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME\n         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE\n*\n* SET YITHEX\n*\n         LA    R14,=C'YITHEX'\n         LA    R15,6\n         LA    R0,YITHEX\n         LA    R1,L'YITHEX\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nCALL441  DS    0H\n         LA    R1,CPARM1           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R15,R15             IF RETURN CODE IS ZERO\n         BZR   R2                  THEN EVERYTHING IS OK\n         MVC   LINE(L'ERR441),ERR441\n         CVD   R15,DOUBLE\n         UNPK  LINE+L'ERR441(2),DOUBLE\n         OI    LINE+L'ERR441+1,X'F0'\n         BAL   R14,OUTPUT\n         BR    R2\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BASSM R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERR441   DC    C'YITADDR: CLIST VARIABLE ACCESS FACILITY ERROR '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\nCPARM7   DS    A                   POINTER TO IPCS'S ECT\n         SPACE 1\nCENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nYITHEX   DS    CL8                 VALUE OF CLIST VARIABLE\n         DS    CL4                 PADDING\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         IKJCPPL\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=YITSAV   0100-07332-07332-0900-00432-00432-00000-SEB\n         TITLE 'YITSAV - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   ('&LENGTH' EQ '(0)').GOTLEN\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3    DUMP STORAGE ACCESS REGISTER\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)\nR8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA\nR9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITSAV   CSECT\n         SAVE  (14,12),,YITSAV_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITSAV,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ADDRESS OF ABDPL\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\nPROCESS  DS    0H\n         SPACE 1\n         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE\n         ST    R0,WHRADDR\n         SPACE 1\n         XR    R7,R7               INITIALIZE HSA POINTER\n         ICM   R3,15,ADPLTCB       ADDRESS OF FIRST SAVE AREA\n         BNZ   LOOP                IF NONE, THEN...\n         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO\n         BAL   R14,OUTPUT\n         B     RETURN0\n         SPACE 1\nLOOP     DS    0H\n         LTR   R3,R3               UNTIL NO MORE\n         BZ    ENDLOOP\n         MVC   LINE(L'SAMSG),SAMSG \"SAVE AREA AT \"\n         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA\n         ST    R8,OPWORK           DISPLAY IT\n         UNPK  LINESAA+0(9),OPWORK(5)\n         TR    LINESAA+0(8),HEXTBL\n         MVI   LINESAA+8,C'.'\n         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP\n         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA\nCONTLOOP DS    0H\n         SPACE\n         MVC   LINEL1(4),=C'WD1='\n         UNPK  LINEN1(9),SAWD1(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'HSA='\n         UNPK  LINEN2(9),SAHSA(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'LSA='\n         UNPK  LINEN3(9),SALSA(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         BAL   R14,OUTPUT\n         C     R7,SAHSA            CHECK HSA POINTER\n         BE    HSAOK               IF IT DOESN'T MATCH, THEN...\n         MVC   LINEL1(L'IBCMSG),IBCMSG\n         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN\nHSAOK    DS    0H\n         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS\n         MVC   LINEL1(4),=C'R14='\n         UNPK  LINEN1(9),SAR14(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR14\n         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R15='\n         UNPK  LINEN1(9),SAR15(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         L     R0,SAR15\n         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS\n         SPACE 1\n         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED\n         LTR   R9,R9               IF ZERO, IGNORE IT\n         BZ    NOEP\n         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA\n         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION\n         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT\n         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND\n         BNE   NOEP                THEN NO EP DATA\n         XR    R2,R2               CLEAR INSERT REG\n         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER\n         LTR   R2,R2               IF ZERO\n         BZ    NOEP                THEN NO EP DATA\n         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW\n         BNH   SETMAX\n         LA    R2,EPLENGTH\nSETMAX   DS    0H\n         LA    R9,4\n         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF\n         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...\n         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY\n         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED\n         MVC   LINEEP1(6),=CL6'AT EP '\n         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE\n         EX    R2,EPMVC            TRANSLATE EP DATA\nNOEP     DS    0H\n         SPACE 1\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R0 ='\n         UNPK  LINEN1(9),SAR00(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         BAL   R14,OUTPUT\n         MVC   LINEL1(4),=C'R1 ='\n         UNPK  LINEN1(9),SAR01(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R2 ='\n         UNPK  LINEN2(9),SAR02(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R3 ='\n         UNPK  LINEN3(9),SAR03(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R4 ='\n         UNPK  LINEN4(9),SAR04(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R5 ='\n         UNPK  LINEN1(9),SAR05(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R6 ='\n         UNPK  LINEN2(9),SAR06(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R7 ='\n         UNPK  LINEN3(9),SAR07(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R8 ='\n         UNPK  LINEN4(9),SAR08(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         MVC   LINEL1(4),=C'R9 ='\n         UNPK  LINEN1(9),SAR09(5)\n         TR    LINEN1(8),HEXTBL\n         MVI   LINEB1,C' '\n         MVC   LINEL2(4),=C'R10='\n         UNPK  LINEN2(9),SAR10(5)\n         TR    LINEN2(8),HEXTBL\n         MVI   LINEB2,C' '\n         MVC   LINEL3(4),=C'R11='\n         UNPK  LINEN3(9),SAR11(5)\n         TR    LINEN3(8),HEXTBL\n         MVI   LINEB3,C' '\n         MVC   LINEL4(4),=C'R12='\n         UNPK  LINEN4(9),SAR12(5)\n         TR    LINEN4(8),HEXTBL\n         MVI   LINEB4,C' '\n         BAL   R14,OUTPUT\n         SPACE\n         BAL   R14,OUTPUT          JUST A BLANK LINE\n         SPACE\n         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nSANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP\n         SPACE 1\n         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG\n         BAL   R14,OUTPUT\n         B     ERROUT\n         SPACE 1\nENDLOOP  DS    0H\n         B     RETURN0\n         SPACE 2\nEPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED\n         EJECT\nSTORERR  DS    0H                  ERROR ACCESSING STORAGE\n         MVC   LINE(L'ERRMSG),ERRMSG\n******** B     ERROUT\n         SPACE 1\nERROUT   DS    0H\n         BAL   R14,OUTPUT\n         B     RETURN0\n         EJECT\nFINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME\n*                                  R0 CONTAINS ADDRESS TO SEARCH ON\n         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED\n         LTR   R0,R0               IF ADDRESS IS ZEROES,\n         BZR   R14                 THEN PRINT NOTHING, NOT AN EP\n         ST    R14,FMSAVE\n         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS\nFMDOIT   DS    0H\n         XR    R0,R0\n         ST    R0,ADPLCOM1\n         L     R0,FMWHERE\n         LR    R1,R4\n         L     R15,WHRADDR\n         BASSM R14,R15\n         CLI   ADPLFMT1,C' '\n         BE    FMNF\n         MVC   LINEMOD(16),ADPLCOM1\n         B     FMRET\nFMNF     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *\n* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS\n         BE    FMFAIL              THEN DON'T TRY AGAIN\n         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS\n         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE\nFMFAIL   DS    0H                  ELSE GIVE UP\n         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '\n         XC    FMWHERE,FMWHERE\nFMRET    DS    0H\n         L     R14,FMSAVE\n         BR    R14\n         EJECT\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         LTR   R15,R15             IF LINE NOT PRINTED\n         BNZ   RETURN0             THEN...\nNORETYET DS    0H\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         DELETE EP=XIPSWHR\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'\nNOSAMSG  DC    C'SAVEA AREA POINTER IS ZERO'\nIBCMSG   DC    C'*** INVALID BACK CHAIN ***'\nSANAMSG  DC    C'STORAGE UNAVAILABLE'\nSAMSG    DC    C'SAVE AREA AT '\n         SPACE\nVALTBL   DC    256YL1(1)\n         ORG   VALTBL+X'81'\n         DC    6YL1(0)             LOWER CASE ABCDEF\n         ORG   VALTBL+C'A'\n         DC    6YL1(0)             UPPER CASE ABCDEF\n         ORG   VALTBL+C'0'\n         DC    10YL1(0)            0123456789\n         ORG\n         SPACE\nFTBL     DC    256YL1(*-FTBL)\n         ORG   FTBL+X'81'\n         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF\n         ORG   FTBL+C'A'\n         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF\n         ORG\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nOUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE\nFMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE\nFMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE\nWHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE\n         DS    XL1                 PADDING FOR CONVERSION\nOPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION\nCOPYSA   DS    18F                 WORK AREA FOR SAVE AREA\n         ORG   COPYSA\nSAWD1    DS    F                   00 = FIRST WORD\nSAHSA    DS    F                   04 = HSA\nSALSA    DS    F                   08 = LSA\nSAR14    DS    F                   0C = REG14\nSAR15    DS    F                   10 = REG15\nSAR00    DS    F                   14 = REG0\nSAR01    DS    F                   18 = REG1\nSAR02    DS    F                   1C = REG2\nSAR03    DS    F                   20 = REG3\nSAR04    DS    F                   24 = REG4\nSAR05    DS    F                   28 = REG5\nSAR06    DS    F                   2C = REG6\nSAR07    DS    F                   30 = REG7\nSAR08    DS    F                   34 = REG8\nSAR09    DS    F                   38 = REG9\nSAR10    DS    F                   3C = REG10\nSAR11    DS    F                   40 = REG11\nSAR12    DS    F                   44 = REG12\n         ORG\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         ORG   LINE\n         DS    CL(L'SAMSG)         \"SAVE AREA AT \"\nLINESAA  DS    CL8                 ADDRESS OF SAVE AREA\n         DS    CL2                 \"  \"\nLINEL1   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN1   DS    CL8                 \"NNNNNNNN\"\nLINEB1   DS    CL1                 \" \"\nLINEL2   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN2   DS    CL8                 \"NNNNNNNN\"\nLINEB2   DS    CL1                 \" \"\nLINEL3   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN3   DS    CL8                 \"NNNNNNNN\"\nLINEB3   DS    CL1                 \" \"\nLINEL4   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN4   DS    CL8                 \"NNNNNNNN\"\nLINEB4   DS    CL1                 \" \"\nLINEL5   DS    CL4                 \"XXX=\"\n         DS    CL1                 \" \"\nLINEN5   DS    CL8                 \"NNNNNNNN\"\nLINEB5   DS    CL1                 \" \"\n         ORG   LINEL2\n         DS    CL1\nLINEMOD  DS    CL16                \"WHERE\" DATA\n         DS    CL1\nLINEEP1  DS    CL6                 \"AT EP \"\nLINEEP2  DS    CL(EPLENGTH)\n         SPACE 1\nEPLENGTH EQU   78-(LINEEP2-LINE)\n         ORG\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IKJTCB\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n./ ADD NAME=YITWHR   0100-07332-07332-0900-00299-00299-00000-SEB\n         TITLE 'YITWHR - MACROS'\n         MACRO\n&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR\n&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL\n         AIF   (&LENGTH LT 4096).LAR0\n         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH\n         AGO   .GOTLEN\n.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH\n.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST\n         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS\n         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR\n         BALR  R14,R15                 CALL IT\n         LTR   R15,R15                 IF RETURN CODE NONZERO\n         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE\n         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG\n         MEND\n         TITLE 'YITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *\n* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *\n* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *\n* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *\n* VALUES AS CLIST VARIABLES (JEEZ, I HOPE THIS WORKS).                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST\nR5       EQU   5    ADDRESS OF OPERAND\nR6       EQU   6    LENGTH OF OPERAND\nR7       EQU   7    POINTER TO CDE\nR8       EQU   8    USED IN NUCMAP SCANNING\nR9       EQU   9    USED IN NUCMAP SCANNING\nR10      EQU   10   POINTER TO PARAMETER LIST EXTENSION\nR11      EQU   11   POINTER TO OUTPUT BUFFER\nR12      EQU   12   STATIC BASE REGISTER\nR13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nYITWHR   CSECT\n         SAVE  (14,12),,YITWHR_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING YITWHR,R12\n******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         LA    R0,SIZDATD\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DATD,R13\n         SPACE 1\n         XR    R1,R1               INDICATE ABDPL GET\n         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL\n         BALR  R14,R15\n         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS\n         USING ABDPL,R4\n         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO\n         USING LINE,R11                OUTPUT BUFFER\n         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO\n         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION\n         EJECT\n* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.\n* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES\n* THE CORRECT ASID, ETC.\n         SPACE 1\n         XR    R0,R0\n         ST    R0,ADPLCOM1         Clear communication word\n         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE\n         LR    R1,R4               GET ADDRESS OF ABDPL\n         SPACE 1\n         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE\n         SPACE 1\n         MVI   YITPLACE,C' '\n         MVC   YITPLACE+1(L'YITPLACE-1),YITPLACE\n         MVI   YITNAME,C' '\n         MVC   YITNAME+1(L'YITNAME-1),YITNAME\n         MVI   YITLOC,C' '\n         MVC   YITLOC+1(L'YITLOC-1),YITLOC\n*\n* SET YITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR\n*\n         MVC   YITPLACE(4),ADPLFMT1\n         CLI   YITPLACE,C' '\n         BE    YITERROR\n         CLI   YITPLACE,C'E'\n         BE    YITERRNP\n         B     YITOK\nYITERROR DS    0H                  ERROR - MODULE NOT FOUND\n         MVC   YITPLACE(11),=C'UNAVAILABLE'\nYITERRNP DS    0H                  STORAGE ERROR - RETAIN YITPLACE\n         MVC   YITNAME(11),=C'UNAVAILABLE'\n         MVC   YITLOC(11),=C'UNAVAILABLE'\n         B     YITSET\nYITOK    DS    0H\n*\n* SET YITNAME = THE NAME OF THE LOAD MODULE\n*\n         MVC   YITNAME(8),ADPLCOM1\n*\n* SET YITLOC = THE OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE\n*\n         L     R0,ADPLFMT2\n         CVD   R0,DOUBLE\n         UNPK  YITLOC(10),DOUBLE\n         OI    YITLOC+9,X'F0'\n         SPACE 1\nYITSET   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *\n* THREE VALUES AS CLIST VARIABLES.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    R14,CENTRY\n         LA    R15,CNAMEA\n         LA    R0,CNAMEL\n         LA    R1,CVALUEA\n         LA    R2,CVALUEL\n         LA    R3,CTOKEN\n         STM   R14,R3,CPARM1\n         OI    CPARM6,X'80'\n         LA    R0,TSVEUPDT\n         ST    R0,CENTRY\n         XR    R0,0\n         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME\n         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME\n         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE\n         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE\n*\n* SET YITPLACE\n*\n         LA    R14,=C'YITPLACE'\n         LA    R15,8\n         LA    R0,YITPLACE\n         LA    R1,L'YITPLACE\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* SET YITNAME\n*\n         LA    R14,=C'YITNAME'\n         LA    R15,7\n         LA    R0,YITNAME\n         LA    R1,L'YITNAME\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* SET YITLOC\n*\n         LA    R14,=C'YITLOC'\n         LA    R15,6\n         LA    R0,YITLOC\n         LA    R1,L'YITLOC\n         STM   R14,R1,CNAMEA\n         BAL   R2,CALL441\n*\n* RETURN TO CALLER\n*\n         B     RETURN0\n         SPACE 2\nCALL441  DS    0H\n         LA    R1,CPARM1           POINT TO PARAMETER LIST\n         L     R15,X'10'               GET ADDRESS OF CVT\n         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE\n         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441\n         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE\n         LTR   R15,R15             IF RETURN CODE IS ZERO\n         BZR   R2                  THEN EVERYTHING IS OK\n         MVC   LINE(L'ERR441),ERR441\n         CVD   R15,DOUBLE\n         UNPK  LINE+L'ERR441(2),DOUBLE\n         OI    LINE+L'ERR441+1,X'F0'\n         BAL   R14,OUTPUT\n         BR    R2\n         SPACE 2\nOUTPUT   DS    0H\n         ST    R14,OUTSAVE\n         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS\n         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE\n         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE\n         BALR  R14,R15             CALL IT\n         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER\n         L     R14,OUTSAVE\n         BR    R14                 RETURN\n         EJECT\nRETURN0  DS    0H                  RETURN WITH CODE 0\n         SPACE 1\n         LR    R1,R4               INDICATE ABDPL FREE\n         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL\n         BALR  R14,R15\n         SPACE 1\n         XR    R15,R15             SET RETURN CODE TO ZERO\n         SPACE 2\n***********************************************************************\n* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *\n***********************************************************************\nRETURN   DS    0H\n         SPACE\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA\n         LA    R0,SIZDATD\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* DECLARATIVES                                                        *\n***********************************************************************\n         SPACE 2\nERR441   DC    C'YITWHR: CLIST VARIABLE ACCESS FACILITY ERROR '\n         SPACE\nTRTBL    DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C'................'\n         DC    C' .........\u00a0.<(+|'\n         DC    C'&&.........!$*);^'\n         DC    C'-/.........,%_>?'\n         DC    C'..........:#@''=\"'\n         DC    X'4B8182838485868788894B4B4B4B4B4B'\n         DC    X'4B9192939495969798994B4B4B4B4B4B'\n         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'\n         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'\n         DC    C'{ABCDEFGHI......'\n         DC    C'}JKLMNOPQR......'\n         DC    C'\\.STUVWXYZ......'\n         DC    C'0123456789......'\n         SPACE\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         EJECT\n         LTORG\n         SPACE 3\n         DROP  R12\n         EJECT\n***********************************************************************\n* WORK AREA                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA\n         SPACE 1\nSAVEAREA DS    18F\nDOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION\nOUTSAVE  DS    A\n         SPACE 1\nCPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS\n         SPACE 1\nCPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE\nCPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME\nCPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME\nCPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE\nCPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE\nCPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)\n         SPACE 1\nCENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE\nCNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME\nCNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME\nCVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME\nCVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE\nCTOKEN   DC    A(0)                TOKEN (NOT USED)\n         SPACE 1\nYITPLACE DS    CL11                VALUE OF CLIST VARIABLE\nYITNAME  DS    CL11                VALUE OF CLIST VARIABLE\nYITLOC   DS    CL11                VALUE OF CLIST VARIABLE\n         SPACE 2\nSIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA\n         SPACE 3\nLINE     DSECT ,                   MAP THE OUTPUT BUFFER\n         DS    CL133               WORD AREA FOR OUTPUT LINES\n         EJECT\n***********************************************************************\n* MACRO EXPANSIONS                                                    *\n***********************************************************************\n         SPACE 2\n         IHACDE\n         EJECT\n         IHAXTLST\n         EJECT\n         IHALPDE\n         EJECT\n         IKJTCB\n         EJECT\n         IKJTSVT\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         BLSABDPL\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C": {"ttr": 14597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x15.\\x15.\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 5422, "newlines": 5422, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00170-00170-00000-SEB\n------------------------------------------------------------------------\nName:     BREAKUP\nType:     C\nPurpose:  Break up a data set into a bunch of smaller data sets\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     CHEX\nType:     C\nPurpose:  Interactive hex calculator\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     FLDATA\nType:     C\nPurpose:  Demonstrate C fldata() function\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     FLENGTH\nType:     C\nPurpose:  Show number of bytes in a data set using C fseek()\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     FTPCLI\nType:     C\nPurpose:  FTP client\nRequires:\nUsed by:\nComments: TCP/IP For MVS\n------------------------------------------------------------------------\nName:     GFTP\nType:     C\nPurpose:  Get a file via FTP\nRequires:\nUsed by:\nComments: TCP/IP For MVS\n------------------------------------------------------------------------\nName:     GSVCTEST\nType:     C\nPurpose:  Example of using the generalized SVC routine in C\nRequires: GSVC H\n          XGSVC C\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     HEXDUMP\nType:     C\nPurpose:  Dump contents of a file in hex dump format\nRequires:\nUsed by:\nComments: Not sure what the difference is between this and HEXDUMP2\n------------------------------------------------------------------------\nName:     HEXDUMP2\nType:     C\nPurpose:  Dump contents of a file in hex dump format\nRequires:\nUsed by:\nComments: Not sure what the difference is between this and HEXDUMP\n------------------------------------------------------------------------\nName:     HEXIN\nType:     C\nPurpose:  Subroutine to convert a hex string to binary data\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     HTTPDO\nType:     C\nPurpose:  Line-mode Web (HTTP) client\nRequires:\nUsed by:\nComments: Requires TCP/IP for MVS\n------------------------------------------------------------------------\nName:     JAY\nType:     C\nPurpose:  Convert date between Julian and Gregorian\nRequires:\nUsed by:\nComments: Like CLIST J but doesn't know how to get current date\n------------------------------------------------------------------------\nName:     MAKENULL\nType:     C\nPurpose:  Demonstrate creation of null records by a C program\nRequires:\nUsed by:\nComments: Because C used to not make null records properly (does it now?\n------------------------------------------------------------------------\nName:     MAKEUP\nType:     C\nPurpose:  Create an IEBUPDTE stream from a PDS\nRequires:\nUsed by:\nComments: Compare BREAKUP\n------------------------------------------------------------------------\nName:     MATCH\nType:     C\nPurpose:  Pattern matcher, sort of like grep\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     NUSERS\nType:     C\nPurpose:  Display ASVT entries and number of TSO users logged on\nRequires:\nUsed by:\nComments: (Did I write this?)\n------------------------------------------------------------------------\nName:     REXXIT\nType:     C\nPurpose:  Demonstrate REXX interface from C, I guess\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     REXXJCL\nType:     C\nPurpose:  Demonstrate REXX interface from C, I guess\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     SIGFAIL\nType:     C\nPurpose:  Demonstrate that MVS does not handle SIGINT properly\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     SMTPDOG\nType:     C\nPurpose:  Send mail messages via SMTP\nRequires:\nUsed by:  CLIST MAILDSN,MAILFILE\nComments: Requires TCP/IP for MVS\n------------------------------------------------------------------------\nName:     TSOPREF\nType:     C\nPurpose:  Show TSO userid and prefix\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     XGALLOC\nType:     C\nPurpose:  Perform allocation from a non-TSO environment\nRequires:\nUsed by:\nComments: Used by MVS Gopher server\n------------------------------------------------------------------------\nName:     XPASTE\nType:     C\nPurpose:  Perform X Window System \"paste\" operation\nRequires: TCP/IP X11\nUsed by:\nComments: You can \"paste\" data from a remote workstation onto a 3270...\n------------------------------------------------------------------------\nName:     X800\nType:     C\nPurpose:  Show all possible \"words\" that spell out a 7-digit pbone #\nRequires:\nUsed by:\nComments:\n------------------------------------------------------------------------\n./ ADD NAME=BREAKUP  0100-07332-07332-0900-00102-00102-00000-SEB\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint\nmain(argc,argv)\nint    argc;\nchar **argv;\n{\n char *infile;\n char *cp;\n int   rc;\n int   size;\n int   count;\n int   filenum;\n FILE *ifp;\n FILE *ofp;\n char  outfile[128];\n char  inline[2048];\n\n if (argc != 3) {\n   fprintf(stderr,\"Usage: %s filename lines\\n\",argv[0]);\n   return 12;\n }\n infile = argv[1];\n size   = atoi(argv[2]);\n if (size == 0) {\n   fprintf(stderr,\"Usage: %s filename lines (nonzero)\\n\",argv[0]);\n   return 12;\n }\n ofp = NULL;\n rc = 0;\n count = 0;\n filenum = 0;\n ifp = fopen(infile,\"r\");\n if (!ifp) {\n   perror(infile);\n   return 12;\n }\n for (;;) {\n   fgets(inline,sizeof(inline),ifp);\n   if (ferror(ifp)) {\n     fprintf(stderr,\"Error reading %s\\n\",infile);\n     rc++;\n     break;\n   }\n   if (feof(ifp)) break;\n   /*\n   if ((cp=strchr(inline,'\\n'))) *cp = '\\0';\n   */\n   count++;\n   if (count > size) count = 1;\n   if (count == 1) {\n     if (ofp) {\n       if (fclose(ofp) < 0) {\n         fprintf(stderr,\"Error closing %s\\n\",outfile);\n         rc++;\n       }\n       else {\n         fprintf(stderr,\"%s created (%d lines)\\n\",outfile,size);\n       }\n       ofp = NULL;\n     }\n     filenum++;\n     sprintf(outfile,\"%s.PART%d\",infile,filenum);\n     for (cp=outfile;*cp;cp++) *cp=toupper(*cp);\n     fprintf(stderr,\"Creating file %s\\n\",outfile);\n     ofp = fopen(outfile,\"w,recfm=vb,lrecl=255,blksize=6233\");\n     if (!ofp) {\n       perror(outfile);\n       fprintf(stderr,\"Processing aborted.\\n\");\n       rc++;\n       break;\n     }\n   }\n   fputs(inline,ofp);\n   if (ferror(ofp)) {\n     fprintf(stderr,\"Error writing to %s\\n\",outfile);\n     fprintf(stderr,\"Processing aborted.\\n\");\n     rc++;\n     break;\n   }\n }\n\n if (ofp) {\n   if (fclose(ofp) < 0) {\n     fprintf(stderr,\"Error closing %s\\n\",outfile);\n     rc++;\n   }\n   else {\n     fprintf(stderr,\"%s created (%d lines)\\n\",outfile,count);\n   }\n   ofp = NULL;\n }\n\n if (fclose(ifp) < 0) {\n   fprintf(stderr,\"Error closing %s\\n\",infile);\n }\n\n return 0;\n\n}\n./ ADD NAME=CHEX     0100-07332-07332-0900-00170-00170-00000-SEB\n/* HEXCOMP: Program to do hex calculations */\n#pragma runopts(execops)\n#include <stdio.h>\n#include <signal.h>\n#include <string.h>\n\n#define BOOL  char\n#define FALSE ((BOOL)0)\n#define TRUE  ((BOOL)1)\n#define STRING_EQUAL(a,b)  (strcmp((a),(b)) == 0)\n\nstatic BOOL bad = FALSE;\n\nstatic void handler();\nstatic void getvalue();\nstatic int  hexin();\n\nmain(argc,argv)\nint argc;\nchar **argv;\n{\n char *ep;\n char expression [100];\n char operand1   [100];\n char operand2   [100];\n char operation  [100];\n int  value1, value2;\n char operator;\n int  result;\n\nsignal(SIGFPE,handler);\nwhile(TRUE) {\n bad = FALSE;\n printf(\"Enter hex expression: xxx + yyy or xxx - yyy\\n\");\n if (gets(expression) == NULL) {\n  printf(\"End of program signalled by EOF\\n\");\n  break;\n }\n if (STRING_EQUAL(expression,\"\")) {\n  printf(\"End of program signalled by null expression\\n\");\n  break;\n }\n\n ep = expression;\n\n getvalue(&ep,\" +-*/\",operand1); /* scan for operand */\n\n value1 = hexin(operand1);   /* convert it to hex */\n\n getvalue(&ep,\" 0123456789abcdefABCDEF\",operation); /* scan for op */\n\n if (strlen(operation) != 1) {\n  printf(\"Invalid expression\\n\");\n  bad = TRUE;\n }\n else {\n  getvalue(&ep,\" +-*/\",operand2); /* scan for operand */\n  value2 = hexin(operand2);   /* convert it to hex */\n  operator = operation[0];\n  if (!bad) {\n   switch (operator) {\n    case '+': result = value1 + value2; break;\n    case '-': result = value1 - value2; break;\n    case '*': result = value1 * value2; break;\n    case '/': result = value1 / value2; break;\n    default:\n              printf(\"Invalid operator\\n\");\n              bad = TRUE;\n              break;\n   }; /* end switch */\n  }; /* end if (!bad) */\n }; /* end else */\n\n if (!bad) {\n  printf(\"%X %c %X = %X\\n\",value1,operator,value2,result);\n }\n\n }; /* end while(TRUE) */\n\n return;\n\n}; /* end main() */\n\n\n /********************************************************************/\n\n#pragma page()\n\n void getvalue(ep,delims,newexpr)\n\n /* This subroutine extracts the next character value from the\n    input expression and removes it from the expression.    */\n\n  char **ep;\n  char *delims;\n  char *newexpr;\n\n {\n  register int i;\n\n  *ep += strspn(*ep,\" \"); /* bump past leading blanks */\n\n  if (**ep == '\\0') {\n   if (!bad) printf(\"Incomplete expression\\n\");\n   bad = TRUE;\n   strcpy(newexpr,\"\");  /* return null string if no nonblanks */\n   return;\n  }\n\n  memcpy(newexpr,*ep,i=strcspn(*ep,delims));\n  newexpr[i] = '\\0';\n\n  *ep += i;\n\n return;\n\n }; /* end getvalue */\n\n\n /********************************************************************/\n\n#pragma page()\n\n int hexin(expr)\n\n /* This subroutine takes a character string consisting of hex\n    character representations and returns a binary fullword\n    containing the hexadecimal data. */\n\n  char *expr;\n{\n int thing;\n int l;\n\n l = strlen(expr);\n if (l==0) {\n  printf(\"Missing value\\n\");\n  bad = TRUE;\n  return(0);\n }\n if (l>8) {\n  printf(\"Hex value too long\\n\");\n  bad = TRUE;\n  return(0);\n }\n\n if (strspn(expr,\" 0123456789abcdefABCDEF\")<l) {\n  printf(\"Invalid hex characters entered\\n\");\n  bad = TRUE;\n  return(0);\n }\n\n sscanf(expr,\"%x\",&thing);\n\n return(thing);\n\n}; /* end hexin */\n\n /********************************************************************/\n\n#pragma page()\n\n\nvoid handler()\n{\n\n perror(\"Overflow or division by zero (can't tell which)\");\n bad = TRUE;\n\n};\n./ ADD NAME=FLDATA   0100-07332-07332-0900-00184-00184-00000-SEB\n#pragma runopts(trap(off))\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n/*-------------------------------------------------------------------*/\n\nstatic int option_a = 0;\nstatic int option_b = 0;\n\n/*-------------------------------------------------------------------*/\n\nstatic void\noption_error(n,o)\n char *n;\n char  o;\n{\n fprintf(stderr,\"%s: invalid option %c\\n\",n,o);\n abort();\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\ndo_fldata(filetag,fp)\n char *filetag;\n FILE *fp;\n{\n int       flret;\n char      filename[256];\n fldata_t *F;\n fldata_t  fstruct;\n\n F = &fstruct;\n\n memset(F, 0, sizeof fstruct);\n\n flret = fldata(fp, filename, F);\n printf(\"%s: fldata rc=%d,filename=%s\\n\", filetag, flret, filename);\n\n printf(\"\\n\");\n printf(\"__recfmF ........... %d\\n\", F->__recfmF   );\n printf(\"__recfmV ........... %d\\n\", F->__recfmV   );\n printf(\"__recfmU ........... %d\\n\", F->__recfmU   );\n printf(\"__recfmS ........... %d\\n\", F->__recfmS   );\n printf(\"__recfmBlk ......... %d\\n\", F->__recfmBlk );\n printf(\"__recfmASA ......... %d\\n\", F->__recfmASA );\n printf(\"__recfmM ........... %d\\n\", F->__recfmM       );\n printf(\"__dsorgPO .......... %d\\n\", F->__dsorgPO      );\n printf(\"__dsorgPDSmem ...... %d\\n\", F->__dsorgPDSmem  );\n printf(\"__dsorgPDSdir ...... %d\\n\", F->__dsorgPDSdir  );\n printf(\"__dsorgPS .......... %d\\n\", F->__dsorgPS      );\n printf(\"__dsorgConcat ...... %d\\n\", F->__dsorgConcat  );\n printf(\"__dsorgMem ......... %d\\n\", F->__dsorgMem     );\n printf(\"__dsorgHiper ....... %d\\n\", F->__dsorgHiper   );\n printf(\"__dsorgTemp ........ %d\\n\", F->__dsorgTemp    );\n printf(\"__dsorgVSAM ........ %d\\n\", F->__dsorgVSAM    );\n printf(\"__dsorgHFS ......... %d\\n\", F->__dsorgHFS     );\n printf(\"__openmode ......... \");\n switch (F->__openmode) {\n   case __TEXT:    printf(\"__TEXT\");                         break;\n   case __BINARY:  printf(\"__BINARY\");                       break;\n   case __RECORD:  printf(\"__RECORD\");                       break;\n   default:        printf(\"%d\",F->__openmode);\n }\n printf(\"\\n\");\n printf(\"__modeflag ......... \");\n switch (F->__modeflag) {\n   case __READ:    printf(\"__READ\");                         break;\n   case __WRITE:   printf(\"__WRITE\");                        break;\n   case __APPEND:  printf(\"__APPEND\");                       break;\n   case __UPDATE:  printf(\"__UPDATE\");                       break;\n   default:        printf(\"%d\",F->__modeflag);\n }\n printf(\"\\n\");\n printf(\"__reserve2 ......... %d\\n\", F->__reserve2     );\n printf(\"__device ........... \");\n switch (F->__device) {\n   case __DISK:       printf(\"__DISK\");                      break;\n   case __TERMINAL:   printf(\"__TERMINAL\");                  break;\n   case __PRINTER:    printf(\"__PRINTER\");                   break;\n   case __TAPE:       printf(\"__TAPE\");                      break;\n   case __TDQ:        printf(\"__TDQ\");                       break;\n   case __DUMMY:      printf(\"__DUMMY\");                     break;\n   case __MSGFILE:    printf(\"__MSGFILE\");                   break;\n   case __MEMORY:     printf(\"__MEMORY\");                    break;\n   case __HFS:        printf(\"__HFS\");                       break;\n   case __HIPERSPACE: printf(\"__HIPERSPACE\");                break;\n   case __OTHER:      printf(\"__OTHER\");                     break;\n   default:           printf(\"%d\",F->__device);\n }\n printf(\"\\n\");\n printf(\"__blksize .......... %l\\n\", F->__blksize      );\n printf(\"__maxreclen ........ %l\\n\", F->__maxreclen    );\n printf(\"__vsamtype ......... \");\n switch (F->__vsamtype) {\n   case __NOTVSAM:    printf(\"__NOTVSAM\");                   break;\n   case __ESDS:       printf(\"__ESDS\");                      break;\n   case __KSDS:       printf(\"__KSDS\");                      break;\n   case __RRDS:       printf(\"__RRDS\");                      break;\n   case __ESDS_PATH:  printf(\"__ESDS_PATH\");                 break;\n   case __KSDS_PATH:  printf(\"__KSDS_PATH\");                 break;\n   default:           printf(\"%d\",F->__vsamtype);\n }\n printf(\"\\n\");\n printf(\"__vsamkeylen ....... %l\\n\", F->__vsamkeylen   );\n printf(\"__vsamRKP .......... %l\\n\", F->__vsamRKP      );\n if (F->__dsname)\n   printf(\"__dsname ........... %s\\n\", F->__dsname       );\n else\n   printf(\"__dsname is null\\n\");\n printf(\"__reserve4 ......... %d\\n\", F->__reserve4     );\n printf(\"\\n\");\n\n return;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\ndoit(filenamep)\n char *filenamep;\n{\n char *filetag;\n FILE *fp;\n\n if (!filenamep) {\n   fp = stdin;\n   filetag = \"standard input\";\n }\n else {\n   fp = fopen(filenamep,option_b ? \"rb\" : \"r\");\n   filetag = filenamep;\n }\n if (!fp) {\n   perror(filetag);\n }\n else {\n   do_fldata(filetag,fp);\n   printf(\"\\nFLDATA output complete for %s\\n\",filetag);\n   if (filenamep) {\n     if (fclose(fp) != 0) {\n       perror(filetag);\n       fprintf(stderr,\"Error closing %s\\n\",filetag);\n     }\n     else {\n       printf(\"Closed %s\\n\", filetag);\n     }\n   }\n }\n return;\n\n}\n\n/*-------------------------------------------------------------------*/\n\nmain(argc,argv)\n int argc;\n char **argv;\n{\n int i;\n int arg_index;\n char *x;\n\n arg_index = 0;\n while ((arg_index++)<argc && *(x = argv[arg_index]+0) == '-') {\n  for (x++;*x;x++) {\n    switch (*x) {\n       case 'a': option_a = 1; break;\n       case 'b': option_b = 1; break;\n       default : option_error(argv[0],*x);\n    };\n  };\n }\n if (arg_index >= argc) doit(NULL);\n else {\n   for (i=arg_index; i<argc; i++) {\n     doit(argv[i]);\n   }\n }\n return 0;\n}\n\n./ ADD NAME=FLENGTH  0100-07332-07332-0900-00035-00035-00000-SEB\n#include <stdio.h>\n\nint\nmain(argc,argv)\nint     argc;\nchar  **argv;\n{\n char  *filename;\n FILE  *fp;\n long   position;\n long   len;\n\n if (argc != 2) {\n   fprintf(stderr,\"Usage: flength filename\\n\");\n   return 12;\n }\n filename = argv[1];\n if (!(fp = fopen(filename,\"r\"))) {\n   perror(filename);\n   return 12;\n }\n\n position = ftell(fp);\n\n fseek(fp, 0, SEEK_END);\n\n len = ftell(fp);\n\n printf(\"File length of %s: %d\\n\", filename, len);\n\n fclose(fp);\n\n return 0;\n\n}\n./ ADD NAME=FTPCLI   0100-07332-07332-0900-00670-00670-00000-SEB\n/* PORT 21 (FTP) client - similar to \"TELNET hostname 21\" */\n\n/* usage: ftpcli remotehost user password getfile putfile */\n\n#ifdef MVS\n#include <manifest.h>\n#include <tcperrno.h>\n#include <ctest.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\n#define  Bool                 int\n\n#ifndef  TRUE\n#define  TRUE                 ((Bool)1)\n#endif\n#ifndef  FALSE\n#define  FALSE                ((Bool)0)\n#endif\n\n#define  CARRIAGE_RETURN      ('\\r')\n#define  READ_BYTES           512\n#define  MYBUF_INITIAL_SIZE   512\n#define  MYBUF_INCREMENT      256\n#define  IBUF_MSGSIZE         512\n#define  OBUF_MSGSIZE         512\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  IPPORT_FTPD          20                /* FTP data port */\n#define  IPPORT_FTP           21                /* FTP control port */\n\n#ifdef MVS\n\n#define  LINE_FEED            (0x25)\n#define  TCPERROR             tcperror\n#define  etoa(x)              ebcdictoascii[x]\n#define  atoe(x)              asciitoebcdic[x]\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\nextern   char                 ebcdictoascii[];\nextern   char                 asciitoebcdic[];\n\n#else\n\n#define  LINE_FEED            (0x0a)\n#define  TCPERROR             perror\n#define  etoa(x)              (x)\n#define  atoe(x)              (x)\n\n#endif\n\ntypedef unsigned int IPADDRESS;\ntypedef          int SOCKETNO;\n\nenum server_retval {\n                    SERVER_OK,\n                    SERVER_READ_ERROR,\n                    SERVER_BUFFER_ERROR,\n                    SERVER_NO_MORE\n                   };\n\nstruct Ftp         {\n char              *text;\n char              *mybufp;\n int                msgid;\n int                mybufl;\n int                nbytes;\n int                ibuflen;\n int                bytes_returned;\n int                g_buf_index;\n IPADDRESS          hostaddress;\n struct hostent    *server_hostent;\n struct hostent    *client_hostent;\n struct sockaddr_in bindsock;\n struct sockaddr_in consock;\n SOCKETNO           controlns;\n SOCKETNO           datans;\n int                backlog;\n int                readrc;\n int                writrc;\n Bool               time_to_go_home;\n Bool               server_has_something_pending;\n Bool               server_finished_replying;\n Bool               sending_text;\n Bool               dont_read;\n char               client_hostname [257];\n char               server_hostname [257];\n char               ibuf [IBUF_MSGSIZE];\n char               obuf [OBUF_MSGSIZE];\n char               g_buf [READ_BYTES];\n};\n\n/* ---- Dump some data. ------------------------------------------- */\n\nstatic void\ndump_it(p,r)\nchar *p;\nint   r;\n{\n int i;\n\n for (i=0;i<77;i++) fprintf(stderr,\"-\"); fprintf(stderr,\"\\n\");\n for (i=0;i<r;i++) {\n   char c = *(p+i);\n   if (isprint(c))  fprintf(stderr,\"%c\",c);\n   else             fprintf(stderr,\"<0x%2.2x>\",c);\n }\n fprintf(stderr,\"\\n\");\n for (i=0;i<77;i++) fprintf(stderr,\"-\"); fprintf(stderr,\"\\n\");\n}\n\n/* --- show stuff returned by FTP server --------------------------- */\n\nstatic void\nshow(c)\nchar *c;\n{\n\n#ifdef MVS\n     /* Last character of output buffer is a CR. No \\n needed. */\n     fprintf(stderr,\"%s\",c);\n#else\n     /* Last character of output buffer is a CR w/o LF.  LF needed. */\n     fprintf(stderr,\"%s\\n\",c);\n#endif\n\n return;\n}\n\n/* ---- Get a character from the server. -------------------------- */\n\nstatic int\nsocket_getchar(F,ns)\nstruct Ftp *F;\nSOCKETNO    ns;\n{\n int        readrc;\n\n if (F->g_buf_index == -1\n  || F->g_buf_index >= F->bytes_returned - 1) {\n   F->g_buf_index = -1;\n   if (F->dont_read) return SOCKET_NO_MORE;\n   readrc = read(ns, F->g_buf, READ_BYTES);\n   if (readrc == -1) return SOCKET_GETCHAR_ERROR;\n   if (readrc == 0)  return SOCKET_NO_MORE;\n   F->bytes_returned = readrc;\n#ifdef MVS\n   {int i;\n    for (i=0;i<F->bytes_returned;i++) F->g_buf[i]=atoe(F->g_buf[i]);\n   }\n#endif\n   /* dump_it(F->g_buf,readrc); */\n }\n return F->g_buf[++F->g_buf_index];\n}\n\n/* ---- Get a line of data from the server. ----------------------- */\n\nstatic enum server_retval\nsocket_read(F,ns)\nstruct Ftp  *F;\nSOCKETNO     ns;\n{\n char       *i_buf;\n int         n_bytes;\n char        delimiter;\n Bool        dont_read;\n int         i_buf_index;\n int         i;\n int         character;\n\n i_buf     = F->obuf;\n n_bytes   = OBUF_MSGSIZE;\n delimiter = LINE_FEED;\n dont_read = F->dont_read;\n\n /* Get characters from the server until delimiter is reached. */\n\n i_buf_index = 0;\n while ((character = socket_getchar(F,ns)) != delimiter) {\n   if (character == SOCKET_GETCHAR_ERROR)  return SERVER_READ_ERROR;\n   if (character == SOCKET_NO_MORE)        return SERVER_NO_MORE;\n   if (i_buf_index >= n_bytes) {\n     fprintf(stderr,\n             \"Warning: The buffer passed to socket_in overflowed.\\n\");\n     fprintf(stderr,\n             \" More than %d bytes collected without %2.2x seen.\\n\",\n             n_bytes,delimiter);\n     fprintf(stderr,\n             \" Returning what we have so far.\\n\");\n     break;\n   }\n   i_buf[i_buf_index++] = (unsigned char)character;\n }\n i_buf[i_buf_index] = '\\0';\n return SERVER_OK;\n}\n\n/* ---- Get a chunk of data from the server. ---------------------- */\n\nstatic Bool\nsocket_in(F,ns)\nstruct Ftp  *F;\nSOCKETNO     ns;\n{\n\n switch (socket_read(F,ns)) {\n   case SERVER_OK:\n                  return TRUE;\n   case SERVER_READ_ERROR:\n                  fprintf(stderr,\"Read error, lost connection\\n\");\n                  F->time_to_go_home = TRUE;\n                  return FALSE;\n   case SERVER_BUFFER_ERROR:\n                  fprintf(stderr,\"Server buffer error\\n\\n\");\n                  F->time_to_go_home = TRUE;\n                  return FALSE;\n   case SERVER_NO_MORE:\n                  F->server_has_something_pending = FALSE;\n                  return TRUE;\n }\n return TRUE;\n}\n\n/* ---- Send a line of data to the server. ------------------------ */\n\nstatic Bool\nsocket_out(F, ns, o_buf, n_bytes)\nstruct Ftp      *F;\nSOCKETNO         ns;\nchar            *o_buf;\nint              n_bytes;\n{\n int             writrc;\n int             needed_bytes   = n_bytes + 2;\n\n if (F->mybufp == NULL) {\n   F->mybufl = MYBUF_INITIAL_SIZE;\n   F->mybufp = (char *)malloc(F->mybufl);\n   fprintf(stderr,\n           \"Allocated %d bytes for output buffer\\n\",F->mybufl);\n }\n\n if (F->mybufl < needed_bytes) {\n   F->mybufl = needed_bytes + MYBUF_INCREMENT;\n   free(F->mybufp);\n   F->mybufp = (char *)malloc(F->mybufl);\n   fprintf(stderr,\n           \"Allocated %d bytes for output buffer\\n\",F->mybufl);\n }\n\n if (F->mybufp == NULL) {\n   fprintf(stderr,\"\\nOops, failed to allocate output buffer!\\n\");\n   return FALSE;\n }\n\n memcpy(F->mybufp,o_buf,n_bytes);\n\n F->mybufp[n_bytes  ] = CARRIAGE_RETURN;\n F->mybufp[n_bytes+1] = LINE_FEED;\n\n#ifdef MVS\n {int i;\n  for (i=0;i<=n_bytes+1;++i) F->mybufp[i] = etoa(F->mybufp[i]);\n }\n#endif\n\n writrc = write(ns, F->mybufp, n_bytes+2);\n if (writrc < 0) {\n   TCPERROR(\"write\");\n   return FALSE;\n }\n\n return TRUE;\n}\n\n/* ---- Format an Internet address. -------------------------------- */\n\nstatic void\nip_address(n,c)\nIPADDRESS n;\nchar     *c;\n{\n char *cp = (char *)&n;\n\n sprintf(c,\"%d.%d.%d.%d\", (unsigned char)*cp,\n                          (unsigned char)*(cp+1),\n                          (unsigned char)*(cp+2),\n                          (unsigned char)*(cp+3));\n return;\n}\n\n/* ---- Format an FTP port address. -------------------------------- */\n\nstatic void\nport_address(addrnum,portnum,c)\nIPADDRESS addrnum;\nint       portnum;\nchar     *c;\n{\n char *ap = (char *)&addrnum;\n char *pp = (char *)&portnum;\n\n fprintf(stderr,\"port_address: addrnum=%8.8X, portnum=%8.8x\\n\",\n        addrnum,portnum);\n\n sprintf(c,\"%d,%d,%d,%d,%d,%d\", (unsigned char)*(ap+0),\n                                (unsigned char)*(ap+1),\n                                (unsigned char)*(ap+2),\n                                (unsigned char)*(ap+3),\n                                (unsigned char)*(pp+2),\n                                (unsigned char)*(pp+3));\n\n return;\n}\n\n/* ---- Close socket. ---------------------------------------------- */\n\nstatic Bool\nftp_close(F,ns)\nstruct Ftp   *F;\nSOCKETNO      ns;\n{\n\n fprintf(stderr,\"Closing socket %d\\n\",ns);\n\n if (close(ns) < 0) {\n   TCPERROR(\"close\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/* ---- Connect to the FTP server host. ---------------------------- */\n\nstatic SOCKETNO\nftp_connect(F,ftphost)\nstruct Ftp *F;\nchar       *ftphost;\n{\n SOCKETNO           ftpsock;\n int                bindrc;\n int                listrc;\n int                connrc;\n char               ipstring[65];\n\n ftpsock = -1;\n gethostname(F->client_hostname,sizeof(F->client_hostname));\n F->client_hostent = gethostbyname(F->client_hostname);\n if (!F->client_hostent) {\n   TCPERROR(\"gethostbyname for client hostname\");\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->client_hostent->h_addr_list[0];\n\n ip_address(F->hostaddress,ipstring);\n fprintf(stderr,\"client %s [%s]\\n\",F->client_hostname,ipstring);\n\n ftpsock = socket(AF_INET, SOCK_STREAM, 0);\n if (ftpsock < 0) {\n   TCPERROR(\"socket\");\n   return -1;\n }\n\n F->bindsock.sin_family      = AF_INET;\n F->bindsock.sin_port        = 0;\n F->bindsock.sin_addr.s_addr = F->hostaddress;\n\n bindrc = bind(ftpsock,&F->bindsock,sizeof(F->bindsock));\n if (bindrc < 0) {\n   TCPERROR(\"bind for client\");\n   return -1;\n }\n\n F->server_hostent = gethostbyname(ftphost);\n if (!F->server_hostent) {\n   fprintf(stderr,\"gethostbyname: unknown host %s\\n\",ftphost);\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->server_hostent->h_addr;\n\n ip_address(F->hostaddress,ipstring);\n fprintf(stderr,\"server %s [%s]\\n\",ftphost,ipstring);\n\n F->consock.sin_family      = AF_INET;\n F->consock.sin_port        = htons(IPPORT_FTP);\n F->consock.sin_addr.s_addr = F->hostaddress;\n\n connrc = connect(ftpsock,&F->consock,sizeof(F->consock));\n if (connrc < 0) {\n   TCPERROR(ftphost);\n   return -1;\n }\n\n return ftpsock;\n}\n\n/* --- Get a response from the FTP server. ------------------ */\n\nstatic Bool\nfrecv(F,ns)\nstruct Ftp    *F;\nSOCKETNO       ns;\n{\n int           n;\n\n F->server_has_something_pending = TRUE;\n F->server_finished_replying     = FALSE;\n F->sending_text                 = FALSE;\n F->dont_read                    = FALSE;\n F->text                         = NULL;\n F->msgid                        = -1;\n\n while (F->server_has_something_pending) {\n\n   if (F->server_finished_replying) F->dont_read = TRUE;\n   if (!socket_in(F, ns)) break;\n   if (F->time_to_go_home) break;\n   if (F->dont_read && !F->server_has_something_pending) break;\n   show(F->obuf);\n   F->msgid = -1;\n   F->text  = NULL;\n   n        = 0;\n   sscanf(F->obuf,\"%d %n\", &F->msgid, &n);\n   F->text = F->obuf + n;\n\n   switch (F->msgid) {\n     case 221: /* Goodbye */\n               F->server_finished_replying = TRUE;\n               F->server_has_something_pending = FALSE;\n            /* F->time_to_go_home          = TRUE; */\n               break;\n     default:\n               F->server_finished_replying = TRUE;\n               F->server_has_something_pending = FALSE;\n               break;\n   }\n\n } /* end while F->server_has_something_pending */\n\n if (F->time_to_go_home) {\n   fprintf(stderr,\"Time to go home\\n\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/* --- Send a request to the FTP server. ----------------------- */\n\nstatic Bool\nfsend(F,ns,text,arg)\nstruct Ftp    *F;\nSOCKETNO      ns;\nchar          *text;\nchar          *arg;\n{\n\n /* first check if there is anything pending from the server */\n\n while (F->server_has_something_pending) {\n   if (F->server_finished_replying) F->dont_read = TRUE;\n   if (!socket_in(F, ns)) break;\n   if (F->time_to_go_home) break;\n   if (F->dont_read && !F->server_has_something_pending) break;\n   show(F->obuf);\n }\n\n if (F->time_to_go_home) return FALSE;\n\n /* now send */\n\n sprintf(F->ibuf,text,arg);\n\n show(F->ibuf);\n\n return socket_out(F,ns,F->ibuf,strlen(F->ibuf));\n}\n\n/* --- Main routine. ------------------------------------------- */\n\nmain(argc,argv)\nint                   argc;\nchar                **argv;\n{\n char                *cp;\n char                *ftphost;\n char                *ftpuser;\n char                *ftppass;\n char                *ftpgetf;\n char                *ftpputf;\n char                *ftptext;\n int                  ftpmsgid;\n int                  n;\n int                  socksize;\n int                  accept_count;\n int                  bytes_to_write;\n int                  fwriterc;\n int                  bytes_written;\n FILE                *ofp;\n struct Ftp          *F;\n struct Ftp           ftp;\n struct sockaddr_in   datasocket;\n struct sockaddr_in   controlsocket;\n char                 port[81];\n\n#define  FSEND(A,B)     if (!fsend(F,F->controlns,(A),(B))) {exit(1);}\n#define  FRECV()        if (!frecv(F,F->controlns))         {exit(1);}\n#define  FEXPECT(A)     switch (F->msgid) {\\\n                          case (A): break;\\\n                          default:  FLOSE();\\\n                        }\n#define  FLOSE()        fprintf(stderr,\"Unexpected response: %d\\n\",\\\n                                       F->msgid);\\\n                        fprintf(stderr,\"Full response follows:\\n\");\\\n                        fprintf(stderr,\"%s\\n\",F->obuf);\\\n                        exit(1);\n\n if (argc != 6) {\n   fprintf(stderr,\n           \"Usage: %s remotehost user password getfile putfile\\n\",\n           argv[0]);\n   exit(1);\n }\n\n ftphost = argv[1];\n ftpuser = argv[2];\n ftppass = argv[3];\n ftpgetf = argv[4];\n ftpputf = argv[5];\n\n ofp = fopen(ftpputf,\"r\");\n if (ofp) {\n   fprintf(stderr,\"%s: File exists.\\n\",ftpputf);\n   fprintf(stderr,\"File transfer not done.\\n\");\n   exit(1);\n }\n (void)fclose(ofp);\n\n ofp = fopen(ftpputf,\"w\");\n if (!ofp) {\n   perror(ftpputf);\n   fprintf(stderr,\"File transfer not done.\\n\");\n   exit(1);\n }\n\n F = &ftp;\n memset(F,0,sizeof(struct Ftp));\n F->g_buf_index = -1;\n\n F->controlns = ftp_connect(F,ftphost);\n if (F->controlns < 0) exit(1);\n\n fprintf(stderr,\"Connected to %s (socket %d).\\n\",\n                ftphost, F->controlns);\n\n FRECV();\n FEXPECT(220);  /* server ready */\n\n FSEND(\"USER %s\",ftpuser);\n FRECV();\n FEXPECT(331);  /* password required */\n\n FSEND(\"PASS %s\",ftppass);\n FRECV();\n FEXPECT(230);  /* user logged in */\n\n /* not done yet */\n\n /* for ftpgetf, must issue RETR command but open data connection first */\n\n F->datans = socket(AF_INET, SOCK_STREAM, 0);\n if (F->datans < 0) {\n   TCPERROR(\"data socket\");\n   exit(1);\n }\n\n listen(F->datans,0);   /* accept only one connection */\n\n /* get port number of data connection */\n\n socksize = sizeof(struct sockaddr);\n getsockname(F->datans,(char *)&datasocket,&socksize);\n socksize = sizeof(struct sockaddr);\n getsockname(F->controlns,(char *)&controlsocket,&socksize);\n datasocket.sin_addr.s_addr = controlsocket.sin_addr.s_addr;\n\n port_address(datasocket.sin_addr.s_addr,datasocket.sin_port,port);\n\n FSEND(\"PORT %s\", port);\n FRECV();\n FEXPECT(200);  /* command successful */\n\n FSEND(\"TYPE %s\",\"A\");          /* ascii type */\n FRECV();\n FEXPECT(200);  /* type set to ... */\n\n FSEND(\"RETR %s\", ftpgetf);\n FRECV();\n FEXPECT(150);  /* data connection for... */\n\n accept_count = 0;\n F->datans = accept(F->datans,NULL,&accept_count);\n if (F->datans < 0) {\n   TCPERROR(\"accept\");\n   exit(1);\n }\n\n /* get data from data connection */\n\n F->time_to_go_home = FALSE;\n F->server_has_something_pending = TRUE;\n\n bytes_to_write = 0;\n bytes_written = 0;\n fprintf(stderr,\"Writing to %s\\n\",ftpputf);\n for (;;) {\n   if (!socket_in(F, F->datans)) exit(1);\n   if (F->time_to_go_home) break;\n   if (!F->server_has_something_pending) break;\n   /* show(F->obuf); */\n   bytes_to_write = strlen(F->obuf)-1;\n   fwriterc = fwrite(F->obuf,1,bytes_to_write,ofp);\n   bytes_written += fwriterc;\n   if (fwriterc < bytes_to_write) {\n     fprintf(stderr,\"Error writing to %s\\n\",ftpputf);\n     break;\n   }\n   bytes_to_write = 1;\n   fwriterc = fwrite(\"\\n\",1,bytes_to_write,ofp);\n   bytes_written += fwriterc;\n   if (fwriterc < bytes_to_write) {\n     fprintf(stderr,\"Error writing to %s\\n\",ftpputf);\n     break;\n   }\n }\n\n if (fclose(ofp) < 0) {\n   fprintf(stderr,\"Error closing %s\\n\",ftpputf);\n }\n else fprintf(stderr,\"%d bytes written to %s\\n\",\n                     bytes_written,ftpputf);\n\n FRECV();\n FEXPECT(226);  /* transfer complete */\n\n (void)ftp_close(F,F->datans);\n\n FSEND(\"QUIT\",NULL);\n FRECV();\n FEXPECT(221);  /* goodbye */\n\n (void)ftp_close(F,F->controlns);\n\n exit(0);\n\n}\n\n./ ADD NAME=GFTP     0100-07332-07332-0900-00786-00786-00000-SEB\n/* usage: gftp remotehost user password getfile putfile */\n\n#define _TCP31_PROTOS\n#define MVS\n\n#ifdef MVS\n#include <manifest.h>\n#include <tcperrno.h>\n#include <ctest.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\n#define  Bool                 int\n\n#ifndef  TRUE\n#define  TRUE                 ((Bool)1)\n#endif\n#ifndef  FALSE\n#define  FALSE                ((Bool)0)\n#endif\n\n#define  CARRIAGE_RETURN      ('\\r')\n#define  READ_BYTES           512\n#define  MYBUF_INITIAL_SIZE   512\n#define  MYBUF_INCREMENT      256\n#define  IBUF_MSGSIZE         512\n#define  OBUF_MSGSIZE         512\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  IPPORT_FTPD          20                /* FTP data port */\n#define  IPPORT_FTP           21                /* FTP control port */\n\n#define  SHOW(A)        fprintf(stderr,\"%s\\n\",(A))\n#define  BLATHER        if (F->verboseflag) fprintf\n#define  FLOSE          fexit(F,1)\n#define  FWIN           fexit(F,0)\n#define  FSEND(A,B)     if (!fsend(F,CS,(A),(B))) {FLOSE;}\n#define  FRECV()        if (!frecv(F,CS,TRUE))    {FLOSE;}\n#define  FEXPECT(A)     if (!fexpect(F,A))        {FLOSE;}\n\n#ifdef MVS\n\n#define  LINE_FEED            (0x25)\n#define  TCPERROR             tcperror\n#define  DELETE_FILE          remove\n#define  etoa(x)              ebcdictoascii[x]\n#define  atoe(x)              asciitoebcdic[x]\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\nextern   char                 ebcdictoascii[];\nextern   char                 asciitoebcdic[];\n\n#else\n\n#define  LINE_FEED            (0x0a)\n#define  TCPERROR             perror\n#define  DELETE_FILE          unlink\n#define  etoa(x)              (x)\n#define  atoe(x)              (x)\n\n#endif\n\ntypedef unsigned int IPADDRESS;\ntypedef          int SOCKETNO;\n\nenum server_retval {\n                    SERVER_OK,\n                    SERVER_READ_ERROR,\n                    SERVER_BUFFER_ERROR,\n                    SERVER_NO_MORE\n                   };\n\nstruct connection  {\n char              *mybufp;\n int                mybufl;\n int                nbytes;\n int                ibuflen;\n int                bytes_returned;\n int                g_buf_index;\n SOCKETNO           ns;\n Bool               time_to_go_home;\n Bool               server_has_nothing;\n Bool               dont_read;\n char               ibuf [IBUF_MSGSIZE];\n char               obuf [OBUF_MSGSIZE];\n char               g_buf [READ_BYTES];\n                   };\n\nstruct Ftp         {\n struct connection  control_connection;\n struct connection  data_connection;\n IPADDRESS          hostaddress;\n struct hostent    *server_hostent;\n struct hostent    *client_hostent;\n struct sockaddr_in bindsock;\n struct sockaddr_in consock;\n int                backlog;\n SOCKETNO           listensocket;\n Bool               verboseflag;\n Bool               replaceflag;\n Bool               listflag;\n Bool               nlstflag;\n Bool               cmsflag;\n Bool               file_existed;\n Bool               file_created;\n Bool               file_opened;\n Bool               control_socket_opened;\n Bool               listen_socket_opened;\n Bool               accept_socket_opened;\n FILE              *ofp;\n char               client_hostname [257];\n char               server_hostname [257];\n char               putfile [257];\n};\n\n/* --- display usage message and exit ------------------------------ */\n\nstatic void\nusage(progname)\nchar *progname;\n{\n\n  fprintf(stderr,\n    \"Usage: %s [-vrlcn] remotehost user password getfile [putfile]\\n\",\n          progname);\n  fprintf(stderr, \"   -v  - verbose mode\\n\");\n  fprintf(stderr, \"   -r  - replace existing file\\n\");\n  fprintf(stderr, \"   -l  - send LIST request instead of RETR\\n\");\n  fprintf(stderr, \"   -n  - send NLST request instead of RETR\\n\");\n  fprintf(stderr, \"   -c  - CMS server compatibility mode\\n\");\n  exit(1);\n}\n\n\n/* ---- Get a character from the server. -------------------------- */\n\nstatic int\nsocket_getchar(F,S)\nstruct Ftp        *F;\nstruct connection *S;\n{\n int        readrc;\n\n if (S->g_buf_index == -1\n  || S->g_buf_index >= S->bytes_returned - 1) {\n   S->g_buf_index = -1;\n   if (S->dont_read) return SOCKET_NO_MORE;\n   readrc = read(S->ns, S->g_buf, READ_BYTES);\n   if (readrc == -1) return SOCKET_GETCHAR_ERROR;\n   if (readrc == 0)  return SOCKET_NO_MORE;\n   S->bytes_returned = readrc;\n#ifdef MVS\n   {int i;\n    for (i=0;i<S->bytes_returned;i++) S->g_buf[i]=atoe(S->g_buf[i]);\n   }\n#endif\n }\n return S->g_buf[++S->g_buf_index];\n}\n\n/* ---- Get a line of data from the server. ----------------------- */\n\nstatic enum server_retval\nsocket_read(F,S)\nstruct Ftp        *F;\nstruct connection *S;\n{\n char       *i_buf;\n int         n_bytes;\n char        delimiter;\n int         i_buf_index;\n int         i;\n int         character;\n\n i_buf     = S->obuf;\n n_bytes   = OBUF_MSGSIZE;\n delimiter = LINE_FEED;\n\n /* Get characters from the server until delimiter is reached. */\n\n i_buf_index = 0;\n while ((character = socket_getchar(F,S)) != delimiter) {\n   if (character == SOCKET_GETCHAR_ERROR)  return SERVER_READ_ERROR;\n   if (character == SOCKET_NO_MORE)        return SERVER_NO_MORE;\n   if (i_buf_index >= n_bytes) {\n     fprintf(stderr,\n             \"Warning: The buffer passed to socket_in overflowed.\\n\");\n     BLATHER(stderr,\n             \" More than %d bytes collected without %2.2x seen.\\n\",\n             n_bytes,delimiter);\n     BLATHER(stderr,\n             \" Returning what we have so far.\\n\");\n     break;\n   }\n   i_buf[i_buf_index++] = (unsigned char)character;\n }\n i_buf[i_buf_index] = '\\0';\n return SERVER_OK;\n}\n\n/* ---- Get a chunk of data from the server. ---------------------- */\n\nstatic Bool\nsocket_in(F,S)\nstruct Ftp        *F;\nstruct connection *S;\n{\n\n S->time_to_go_home = FALSE;\n S->server_has_nothing = FALSE;\n\n switch (socket_read(F,S)) {\n   case SERVER_OK:\n                  return TRUE;\n   case SERVER_READ_ERROR:\n                  fprintf(stderr,\"Read error, lost connection\\n\");\n                  S->time_to_go_home = TRUE;\n                  return FALSE;\n   case SERVER_BUFFER_ERROR:\n                  fprintf(stderr,\"Server buffer error\\n\\n\");\n                  S->time_to_go_home = TRUE;\n                  return FALSE;\n   case SERVER_NO_MORE:\n                  BLATHER(stderr,\"Server returned no more data\\n\");\n                  S->server_has_nothing = TRUE;\n                  return TRUE;\n }\n return TRUE;\n}\n\n/* ---- Send a line of data to the server. ------------------------ */\n\nstatic Bool\nsocket_out(F,S,o_buf,n_bytes)\nstruct Ftp        *F;\nstruct connection *S;\nchar              *o_buf;\nint                n_bytes;\n{\n int               writrc;\n int               needed_bytes = n_bytes + 2;\n\n if (S->mybufp == NULL) {\n   S->mybufl = MYBUF_INITIAL_SIZE;\n   S->mybufp = (char *)malloc(S->mybufl);\n   BLATHER(stderr,\n           \"Allocated %d bytes for output buffer\\n\",S->mybufl);\n }\n\n if (S->mybufl < needed_bytes) {\n   S->mybufl = needed_bytes + MYBUF_INCREMENT;\n   free(S->mybufp);\n   S->mybufp = (char *)malloc(S->mybufl);\n   BLATHER(stderr,\n           \"Allocated %d bytes for output buffer\\n\",S->mybufl);\n }\n\n if (S->mybufp == NULL) {\n   fprintf(stderr,\"\\nOops, failed to allocate output buffer!\\n\");\n   return FALSE;\n }\n\n memcpy(S->mybufp,o_buf,n_bytes);\n\n S->mybufp[n_bytes  ] = CARRIAGE_RETURN;\n S->mybufp[n_bytes+1] = LINE_FEED;\n\n#ifdef MVS\n {int i;\n  for (i=0;i<=n_bytes+1;++i) S->mybufp[i] = etoa(S->mybufp[i]);\n }\n#endif\n\n writrc = write(S->ns, S->mybufp, needed_bytes);\n if (writrc < 0) {\n   TCPERROR(\"write\");\n   return FALSE;\n }\n\n return TRUE;\n}\n\n/* ---- Format an Internet address. -------------------------------- */\n\nstatic void\nip_address(n,c)\nIPADDRESS n;\nchar     *c;\n{\n char *cp = (char *)&n;\n\n sprintf(c,\"%d.%d.%d.%d\", (unsigned char)*cp,\n                          (unsigned char)*(cp+1),\n                          (unsigned char)*(cp+2),\n                          (unsigned char)*(cp+3));\n return;\n}\n\n/* ---- Format an FTP port address. -------------------------------- */\n\nstatic void\nport_address(F,addrnum,portnum,c)\nstruct Ftp *F;   /* needed by BLATHER macro */\nIPADDRESS   addrnum;\nint         portnum;\nchar       *c;\n{\n char *ap = (char *)&addrnum;\n char *pp = (char *)&portnum;\n\n BLATHER(stderr,\"port_address: addrnum=%8.8X, portnum=%8.8X\\n\",\n                addrnum,portnum);\n\n sprintf(c,\"%d,%d,%d,%d,%d,%d\", (unsigned char)*(ap+0),\n                                (unsigned char)*(ap+1),\n                                (unsigned char)*(ap+2),\n                                (unsigned char)*(ap+3),\n                                (unsigned char)*(pp+2),\n                                (unsigned char)*(pp+3));\n\n return;\n}\n\n/* ---- Close socket. ---------------------------------------------- */\n\nstatic Bool\nftp_close(F,s)\nstruct Ftp        *F;\nSOCKETNO           s;\n{\n\n BLATHER(stderr,\"Closing socket %d\\n\",s);\n\n if (close(s) < 0) {\n   TCPERROR(\"close\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/* ---- Connect to the FTP server host. ---------------------------- */\n\nstatic SOCKETNO\nftp_connect(F,ftphost)\nstruct Ftp *F;\nchar       *ftphost;\n{\n SOCKETNO           ftpsock;\n int                bindrc;\n int                listrc;\n int                connrc;\n char               ipstring[65];\n\n ftpsock = -1;\n gethostname(F->client_hostname,sizeof(F->client_hostname));\n F->client_hostent = gethostbyname(F->client_hostname);\n if (!F->client_hostent) {\n   TCPERROR(\"gethostbyname for client hostname\");\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->client_hostent->h_addr_list[0];\n\n ip_address(F->hostaddress,ipstring);\n BLATHER(stderr,\"client %s [%s]\\n\",F->client_hostname,ipstring);\n\n ftpsock = socket(AF_INET, SOCK_STREAM, 0);\n if (ftpsock < 0) {\n   TCPERROR(\"socket\");\n   return -1;\n }\n\n F->bindsock.sin_family      = AF_INET;\n F->bindsock.sin_port        = 0;\n F->bindsock.sin_addr.s_addr = F->hostaddress;\n\n bindrc = bind(ftpsock,&F->bindsock,sizeof(F->bindsock));\n if (bindrc < 0) {\n   TCPERROR(\"bind for client\");\n   return -1;\n }\n\n F->server_hostent = gethostbyname(ftphost);\n if (!F->server_hostent) {\n   fprintf(stderr,\"gethostbyname: unknown host %s\\n\",ftphost);\n   return -1;\n }\n F->hostaddress = *(IPADDRESS *)F->server_hostent->h_addr;\n strcpy(F->server_hostname,ftphost);\n ip_address(F->hostaddress,ipstring);\n BLATHER(stderr,\"server %s [%s]\\n\",F->server_hostname,ipstring);\n\n F->consock.sin_family      = AF_INET;\n F->consock.sin_port        = htons(IPPORT_FTP);\n F->consock.sin_addr.s_addr = F->hostaddress;\n\n connrc = connect(ftpsock,&F->consock,sizeof(F->consock));\n if (connrc < 0) {\n   TCPERROR(ftphost);\n   return -1;\n }\n\n return ftpsock;\n}\n\n/* --- Exit in success or failure. -------------------------- */\n\nstatic void\nfexit(F,rc)\nstruct Ftp *F;\nint         rc;\n{\n struct connection      *CS;\n struct connection      *DS;\n\n CS = &F->control_connection;\n DS = &F->data_connection;\n\n if (rc != 0) {\n   if (F->file_opened) {\n     if (fclose(F->ofp) < 0) {\n       fprintf(stderr,\"Error closing %s\\n\",F->putfile);\n     }\n   }\n   if (F->file_created\n     && !F->file_existed\n#ifdef MVS\n     && !strchr(F->putfile,':') /* don't remove dd:foo */\n#endif\n      ) {\n     if (DELETE_FILE(F->putfile) < 0) {\n       fprintf(stderr,\"Error deleting %s\\n\",F->putfile);\n     }\n     else {\n       BLATHER(stderr,\"File %s deleted.\\n\",F->putfile);\n     }\n   }\n }\n\n if (F->listen_socket_opened) {\n   (void) ftp_close(F,F->listensocket);\n   F->listen_socket_opened = FALSE;\n }\n\n if (F->accept_socket_opened) {\n   (void) ftp_close(F,DS->ns);\n   F->accept_socket_opened = FALSE;\n }\n\n if (F->control_socket_opened) {\n   (void) ftp_close(F,CS->ns);\n   F->control_socket_opened = FALSE;\n }\n\n exit(rc);\n\n}\n\n/* --- Get a response from the FTP server. ------------------ */\n\nstatic Bool\nfrecv(F,S,doread)\nstruct Ftp        *F;\nstruct connection *S;\nBool               doread;\n{\n\n S->dont_read = !doread;\n if (!socket_in(F,S)) return FALSE;\n if (S->time_to_go_home) return FALSE;\n if (S->server_has_nothing) return TRUE;\n if (F->verboseflag) SHOW(S->obuf);\n return TRUE;\n\n}\n\n/* --- Send a request to the FTP server. ----------------------- */\n\nstatic Bool\nfsend(F,S,text,arg)\nstruct Ftp        *F;\nstruct connection *S;\nchar              *text;\nchar              *arg;\n{\n\n /* first check if there is anything pending from the server */\n\n (void)frecv(F,S,FALSE);\n\n /* now send */\n\n sprintf(S->ibuf,text,arg);\n\n if (F->verboseflag) {\n   if (!memcmp(S->ibuf,\"PASS \",5)) {\n     SHOW(\"PASS ********\");\n   }\n   else {\n     SHOW(S->ibuf);\n   }\n }\n\n return socket_out(F,S,S->ibuf,strlen(S->ibuf));\n}\n\n/* --- Retrieve a response and insure it was the expected one. -- */\n\nstatic Bool\nfexpect(F,mesid)\nstruct Ftp         *F;\nchar               *mesid;\n{\n struct connection *S = &F->control_connection;\n\n for (;;) {\n   if (!frecv(F,S,TRUE)) FLOSE;\n   if (S->obuf[0] == '\\0')  continue;\n   if (S->obuf[0] == ' ')   continue;\n   if (strlen(S->obuf) > 3) {\n     if (!memcmp(mesid,S->obuf,3)) {\n       if (S->obuf[3] == '-')  continue;\n       if (S->obuf[3] == '\\0') break;\n       if (S->obuf[3] == ' ')  break;\n     }\n   }\n   fprintf(stderr,\"Unexpected FTP response from %s (not %s):\\n%s\\n\",\n                  F->server_hostname,mesid,S->obuf);\n   FLOSE;\n }\n\n return TRUE;\n}\n/* --- Main routine. ------------------------------------------- */\n\nmain(argc,argv)\nint                   argc;\nchar                **argv;\n{\n char                *cp;\n char                *ftphost = NULL;\n char                *ftpuser = NULL;\n char                *ftppass = NULL;\n char                *ftpgetf = NULL;\n char                *ftpputf = NULL;\n char                *ftptext = NULL;\n int                  n;\n int                  i;\n int                  socksize;\n int                  accept_count;\n int                  bytes_to_write;\n int                  fwriterc;\n int                  bytes_written;\n struct connection   *CS;\n struct connection   *DS;\n struct Ftp          *F;\n struct Ftp           ftp;\n struct sockaddr_in   datasocket;\n struct sockaddr_in   controlsocket;\n char                 port[81];\n\n F = &ftp;\n memset(F,0,sizeof(struct Ftp));\n CS = &F->control_connection;\n DS = &F->data_connection;\n CS->g_buf_index = -1;\n DS->g_buf_index = -1;\n\n for (i=1;i<argc;i++) {\n   if (argv[i][0] != '-') break;\n     /* process flags here */\n   for (cp=&argv[i][1]; *cp; cp++) {\n     switch (tolower(*cp)) {\n       case 'v':  F->verboseflag = TRUE;  break;\n       case 'r':  F->replaceflag = TRUE;  break;\n       case 'l':  F->listflag    = TRUE;  break;\n       case 'n':  F->nlstflag    = TRUE;  break;\n       case 'c':  F->cmsflag     = TRUE;  break;\n       default:   fprintf(stderr,\"Unknown flag: %c\\n\",*cp);\n                  usage(argv[0]);\n                  break;\n     }\n   }\n }\n\n if (F->listflag && F->nlstflag) {\n   fprintf(stderr,\"-l and -n flags are mutually exclusive\\n\");\n   usage(argv[0]);\n }\n\n if (i < argc) ftphost = argv[i++]; else usage(argv[0]);\n if (i < argc) ftpuser = argv[i++]; else usage(argv[0]);\n if (i < argc) ftppass = argv[i++]; else usage(argv[0]);\n if (i < argc) ftpgetf = argv[i++]; else ftpgetf = NULL;\n if (i < argc) ftpputf = argv[i++]; else ftpputf = NULL;\n if (i < argc)                           usage(argv[0]);\n\n if (!ftpgetf && !F->listflag && !F->nlstflag) usage(argv[0]);\n\n if (ftpputf && !strcmp(ftpputf,\"-\")) ftpputf = NULL;\n\n if (ftpputf) strcpy(F->putfile,ftpputf);\n else         strcpy(F->putfile,\"standard output\");\n\n if (ftpputf\n#ifdef MVS\n     && !strchr(ftpputf,':') /* don't check if dd:foo is readable */\n#endif\n    ) {\n   F->ofp = fopen(ftpputf,\"r\");\n   if (F->ofp) {\n     F->file_existed = TRUE;\n     if (F->replaceflag) {\n       BLATHER(stderr,\"%s: File is being replaced.\\n\",ftpputf);\n     }\n     else {\n       fprintf(stderr,\"%s: File exists.  Use -r to replace.\\n\",\n                      ftpputf);\n       fprintf(stderr,\"File transfer not done.\\n\");\n       FLOSE;\n     }\n   }\n   (void)fclose(F->ofp);\n }\n\n if (ftpputf) {\n   F->ofp = fopen(ftpputf,\n#ifdef MVS\n               \"w,recfm=vb,lrecl=259,blksize=6233\"\n#else\n               \"w\"\n#endif\n              );\n   if (!F->ofp) {\n     perror(ftpputf);\n     fprintf(stderr,\"File transfer not done.\\n\");\n     FLOSE;\n   }\n   F->file_created = TRUE;\n   F->file_opened  = TRUE;\n }\n else {\n   F->ofp = stdout;\n }\n\n CS->ns = ftp_connect(F,ftphost);\n if (CS->ns < 0) FLOSE;\n F->control_socket_opened = TRUE;\n\n BLATHER(stderr,\"Connected to %s (socket %d).\\n\", ftphost, CS->ns);\n\n FEXPECT(\"220\");  /* server ready */\n\n FSEND(\"USER %s\",ftpuser);\n FEXPECT(\"331\");  /* password required */\n\n FSEND(\"PASS %s\",ftppass);\n FEXPECT(\"230\");  /* user logged in */\n\n /* for ftpgetf, must issue RETR command but open data connection first */\n\n F->listensocket = socket(AF_INET, SOCK_STREAM, 0);\n if (F->listensocket < 0) {\n   TCPERROR(\"data socket\");\n   FLOSE;\n }\n F->listen_socket_opened = TRUE;\n\n listen(F->listensocket,1); /* accept only one connection */\n\n /* get port number of data connection */\n\n socksize = sizeof(struct sockaddr);\n getsockname(F->listensocket,(char *)&datasocket,&socksize);\n socksize = sizeof(struct sockaddr);\n getsockname(CS->ns,(char *)&controlsocket,&socksize);\n datasocket.sin_addr.s_addr = controlsocket.sin_addr.s_addr;\n\n port_address(F,datasocket.sin_addr.s_addr,datasocket.sin_port,port);\n\n FSEND(\"PORT %s\", port);\n FEXPECT(\"200\");  /* command successful */\n\n FSEND(\"TYPE %s\",\"A\");          /* ascii type */\n FEXPECT(\"200\");  /* type set to ... */\n\n if (F->cmsflag && (F->listflag || F->nlstflag)) {\n   FSEND(\"CWD %s\", ftpgetf);\n   FEXPECT(\"250\");  /* current working dir set to ... */\n   ftpgetf = NULL;\n }\n\n if (F->listflag) {\n   if (!ftpgetf) {FSEND(\"LIST\", NULL);}\n   else          {FSEND(\"LIST %s\", ftpgetf);}\n }\n else if (F->nlstflag) {\n   if (!ftpgetf) {FSEND(\"NLST\", NULL);}\n   else          {FSEND(\"NLST %s\", ftpgetf);}\n }\n else {\n   FSEND(\"RETR %s\", ftpgetf);\n }\n\n if (F->cmsflag && (F->listflag || F->nlstflag)) {\n   FEXPECT(\"125\");  /* List started OK */\n }\n else {\n   FEXPECT(\"150\");  /* data connection for... */\n }\n\n accept_count = 0;\n DS->ns = accept(F->listensocket,NULL,&accept_count);\n if (DS->ns < 0) {\n   TCPERROR(\"accept\");\n   FLOSE;\n }\n F->accept_socket_opened = TRUE;\n\n /* get data from data connection */\n\n bytes_to_write = 0;\n bytes_written = 0;\n BLATHER(stderr,\"Writing to %s\\n\",F->putfile);\n for (;;) {\n   DS->time_to_go_home = FALSE;\n   DS->server_has_nothing = FALSE;\n   if (!socket_in(F, DS)) FLOSE;\n   if (DS->time_to_go_home) break;\n   if (DS->server_has_nothing) break;\n   bytes_to_write = strlen(DS->obuf)-1;\n   fwriterc = fwrite(DS->obuf,1,bytes_to_write,F->ofp);\n   bytes_written += fwriterc;\n   if (fwriterc < bytes_to_write) {\n     fprintf(stderr,\"Error writing to %s\\n\",F->putfile);\n     break;\n   }\n   bytes_to_write = 1;\n   fwriterc = fwrite(\"\\n\",1,bytes_to_write,F->ofp);\n   bytes_written += fwriterc;\n   if (fwriterc < bytes_to_write) {\n     fprintf(stderr,\"Error writing to %s\\n\",F->putfile);\n     break;\n   }\n }\n\n /* Close the data socket before waiting for the server to return\n  * connection acknowledgement.  The VM server enforces this.\n  */\n\n (void) ftp_close(F,DS->ns);\n F->accept_socket_opened = FALSE;\n\n if (F->cmsflag) {\n   FEXPECT(\"250\");  /* ... completed successfully */\n }\n else {\n   FEXPECT(\"226\");  /* transfer complete */\n }\n\n if (ftpputf) {\n   if (fclose(F->ofp) < 0) {\n     fprintf(stderr,\"Error closing %s\\n\",F->putfile);\n   }\n   else BLATHER(stderr,\"%d bytes written to %s\\n\",\n                       bytes_written,F->putfile);\n   F->file_opened = FALSE;\n }\n\n FSEND(\"QUIT\",NULL);\n FEXPECT(\"221\");  /* goodbye */\n\n FWIN;\n\n}\n\n./ ADD NAME=GSVCTEST 0100-07332-07332-0900-00043-00043-00000-SEB\n#include <stdio.h>\n#include <string.h>\n#include \"gsvc.h\"\nmain()\n{\n SVC_REGISTER reg15,reg0,reg1;\n char         data[] = \"This is a test of GSVCTEST.\";\n struct       {\n               short   wtolen;\n               short   wtodum;\n               char    wtotext[257];\n              } wto;\n\n reg15 = (SVC_REGISTER_CONTENTS) 0;\n reg0  = (SVC_REGISTER_CONTENTS) strlen(data);\n reg1  = (SVC_REGISTER_CONTENTS) data;\n reg1 |= 0x01000000;  /* specify \"ASIS\" option */\n\n printf(\"On entry to SVC 93: R15=%8.8X R0=%8.8X R1=%8.8X\\n\",\n        reg15,reg0,reg1);\n\n SVC(93,&reg15,&reg0,&reg1);\n\n printf(\"Return from SVC 93: R15=%8.8X R0=%8.8X R1=%8.8X\\n\",\n        reg15,reg0,reg1);\n\n wto.wtolen = strlen(data) + 4;\n wto.wtodum = 0;\n strcpy(wto.wtotext,data);\n\n reg15 = (SVC_REGISTER_CONTENTS) 0;\n reg0  = (SVC_REGISTER_CONTENTS) 0;\n reg1  = (SVC_REGISTER_CONTENTS) &wto;\n\n printf(\"On entry to SVC 35: R15=%8.8X R0=%8.8X R1=%8.8X\\n\",\n        reg15,reg0,reg1);\n\n SVC(35,&reg15,&reg0,&reg1);\n\n printf(\"Return from SVC 35: R15=%8.8X R0=%8.8X R1=%8.8X\\n\",\n        reg15,reg0,reg1);\n\n}\n./ ADD NAME=HEXDUMP  0100-07332-07332-0900-00071-00071-00000-SEB\n#include <stdio.h>\n#include <ctype.h>\n\nint isascii(char c) {return 1;}\n\nmain(argc,argv)\n int argc;\n char **argv;\n{\n int i;\n void doit();\n if (argc == 1) doit(NULL);\n else for (i=1;i<argc;i++) doit(argv[i]);\n exit(0);\n}\nvoid doit(filenamep)\n char *filenamep;\n{\n FILE *fp;\n char c;\n int i;\n int off;\n int got_something;\n char *lp;\n char error_string[150];\n char xline[39];\n char cline[16];\n if (filenamep == NULL) fp = stdin;\n else fp = fopen(filenamep,\"r\");\n if (fp == NULL)\n   {\n    sprintf(error_string,\"%s open failed\",filenamep);\n    perror(error_string);\n    exit(4);\n   }\n else {\n    if (filenamep) printf(\"\\n%s\\n\\n\",filenamep);\n    off = 0;\n    do {\n         char *xlinep;\n         for (i=0;i<36;i++) xline[i] = ' ';\n         for (i=0;i<16;i++) cline[i] = ' ';\n         xlinep = &xline[0];\n         got_something = 0;\n         for (i=0;i<16;i++) {\n          c=getc(fp);\n          /* if (c==EOF) break; */\n          if (feof(fp)) break;\n          got_something = 1;\n          sprintf(xlinep,\"%2.2X\",(c & 0x000000ff));\n          *(xlinep+2) = ' ';\n          if (isascii(c) && isprint(c)) cline[i] = c;\n          else cline[i] = '.';\n          if (c=='\\n') break;\n          xlinep += ((i%4==3) ? 3 : 2);\n         }\n         if (got_something) {\n            printf(\"%6.6X  %36.36s  *%16.16s*\\n\",off,xline,cline);\n            if (c=='\\n') {\n               printf(\"\\n\");\n               off = 0;\n            }\n            else off += i;\n         }\n       } /* while (c != EOF); */\n         while (!(feof(fp)));\n  }\n  if (filenamep) fclose(fp);\n  return;\n }\n\n./ ADD NAME=HEXDUMP2 0100-07332-07332-0900-00135-00135-00000-SEB\n#include <stdio.h>\n#include <ctype.h>\n\n#define BOOL int\n#ifndef FALSE\n#define FALSE ((BOOL)0)\n#endif\n#ifndef TRUE\n#define TRUE  ((BOOL)1)\n#endif\n\n#ifdef MVS\n#define isascii(A) TRUE\n#endif\n\nstatic BOOL blockmode;\nstatic BOOL lreclmode;\nstatic int  lrecl;\n\n/* ================================================================== */\n\nstatic void\ndoit (char *filenamep)\n{\n FILE *fp;\n char  c;\n int   i;\n int   off;\n int   l;\n BOOL  got_something;\n char *lp;\n char  error_string[150];\n char  xline[39];\n char  cline[16];\n\n if (filenamep == NULL) fp = stdin;\n else fp = fopen(filenamep,\"r\");\n if (fp == NULL)\n   {\n    sprintf(error_string,\"%s open failed\",filenamep);\n    perror(error_string);\n    exit(4);\n   }\n else {\n    if (filenamep) printf(\"\\n%s\\n\\n\",filenamep);\n    off = 0;\n    l   = 0;\n    do {\n         char *xlinep;\n         for (i=0;i<36;i++) xline[i] = ' ';\n         for (i=0;i<16;i++) cline[i] = ' ';\n         xlinep = &xline[0];\n         got_something = FALSE;\n         for (i=0;i<16;i++) {\n          if (lrecl > 0 && l >= lrecl) {\n            break;\n          }\n          c=getc(fp);\n          /* if (c==EOF) break; */\n          if (feof(fp)) break;\n          l++;\n          got_something = TRUE;\n          sprintf(xlinep,\"%2.2X\",(c & 0x000000ff));\n          *(xlinep+2) = ' ';\n          if (isascii(c) && isprint(c)) cline[i] = c;\n          else cline[i] = '.';\n          if (!blockmode && c=='\\n') {\n            break;\n          }\n          xlinep += ((i%4==3) ? 3 : 2);\n         }\n         if (got_something) {\n            printf(\"%6.6X  %36.36s  *%16.16s*\\n\",off,xline,cline);\n            if (!blockmode && c=='\\n') {\n              printf(\"\\n\");\n              off = 0;\n            }\n            else off += i;\n            if (lrecl > 0 && l >= lrecl) {\n              printf(\"\\n\");\n              l = 0;\n            }\n         }\n       } /* while (c != EOF); */\n         while (!(feof(fp)));\n  }\n  if (filenamep) fclose(fp);\n  return;\n}\n\n/* ================================================================== */\n\nmain(argc,argv)\n int argc;\n char **argv;\n{\n int  i;\n int  j;\n BOOL got_a_file;\n BOOL expecting_lrecl;\n\n blockmode       = FALSE;\n lreclmode       = FALSE;\n got_a_file      = FALSE;\n expecting_lrecl = FALSE;\n for (i=1;i<argc;i++) {\n   if (argv[i][0] == '-') {\n\t    j=1;\n\t    while (argv[i][j]) {\n\t       switch (argv[i][j]) {\n          case 'b': blockmode = TRUE;\n                    break;\n          case 'l': lreclmode = TRUE;\n                    expecting_lrecl = TRUE;\n                    break;\n\t\t        default:  fprintf(stderr,\"Usage: hexdump -bl file . . .\\n\");\n\t\t\t\t                exit(12);\n\t\t\t\t                break;\n\t       }\n\t       j++;\n     }\n   }\n   else if (expecting_lrecl) {\n     expecting_lrecl = FALSE;\n     lrecl = atoi(argv[i]);\n   }\n   else {\n     got_a_file = TRUE;\n     doit(argv[i]);\n   }\n }\n if (!got_a_file) doit(NULL);\n exit(0);\n}\n\n./ ADD NAME=HEXIN    0100-07332-07332-0900-00040-00040-00000-SEB\n /********************************************************************/\n\n#pragma page()\n\n int hexin(expr)\n\n /* This subroutine takes a character string consisting of hex\n    character representations and returns a binary fullword\n    containing the hexadecimal data. */\n\n  char *expr;\n{\n int thing;\n int l;\n\n l = strlen(expr);\n if (l==0) {\n  printf(\"Missing value\\n\");\n  bad = TRUE;\n  return(0);\n }\n if (l>8) {\n  printf(\"Hex value too long\\n\");\n  bad = TRUE;\n  return(0);\n }\n\n if (strspn(expr,\" 0123456789abcdefABCDEF\")<l) {\n  printf(\"Invalid hex characters entered\\n\");\n  bad = TRUE;\n  return(0);\n }\n\n sscanf(expr,\"%x\",&thing);\n\n return(thing);\n\n}; /* end hexin */\n\n /********************************************************************/\n./ ADD NAME=HTTPDO   0100-07332-07332-0900-00356-00356-00000-SEB\n/* PORT 80 (WEB) client - similar to \"TELNET hostname 80\" */\n\n#define MVS\n\n#ifdef MVS\n#include <manifest.h>\n#include <tcperrno.h>\n#include <ctest.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\n#define  Bool                 int\n#ifndef  TRUE\n#define  TRUE                 (Bool)1\n#endif\n#ifndef  FALSE\n#define  FALSE                (Bool)0\n#endif\n#define  CARRIAGE_RETURN      ('\\r')\n#define  NULL_CHARACTER       ('\\0')\n#define  READ_BYTES           1024\n#define  MYBUF_INITIAL_SIZE   1024\n#define  MYBUF_INCREMENT      512\n#define  IBUF_MSGSIZE         1024\n#define  OBUF_MSGSIZE         1024\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  SOCKET_READ_NOTHING  (-3)\n\n#ifdef MVS\n#define  LINE_FEED            (0x25)\n#define  etoa(x)              ebcdictoascii[x]\n#define  atoe(x)              asciitoebcdic[x]\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\n#else\n#define  LINE_FEED            (0x0a)\n#define  etoa(x)              (x)\n#define  atoe(x)              (x)\n#endif\n\nenum server_retval {\n                    SERVER_OK,\n                    SERVER_READ_ERROR,\n                    SERVER_BUFFER_ERROR,\n                    SERVER_NO_MORE,\n                    SERVER_READ_NOTHING\n                   };\n\n#ifdef MVS\nextern   char                 ebcdictoascii[];\nextern   char                 asciitoebcdic[];\n#endif\n\n /********************************************************************/\n /*                                                                  */\n /* Error handler.                                                   */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\nerrhand(whats,whatn)\nchar            *whats;\nint              whatn;\n{\n fprintf(stderr,\"\\nError: %s returned %d\\n\",whats,whatn);\n return;\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Input one character from the server.                             */\n /*                                                                  */\n /********************************************************************/\n\nstatic int\nsocket_getchar(ns,dont_read)\n int                   ns;\n Bool                  dont_read;\n {\n  static int           bytes_returned = 0;\n  static char          g_buf[READ_BYTES];\n  static int           g_buf_index = -1;\n         int           readrc;\n\n  if (g_buf_index == -1 || g_buf_index >= bytes_returned-1) {\n    g_buf_index = -1;\n    if (dont_read) return(SOCKET_NO_MORE);\n    else {\n      readrc = read(ns, g_buf, READ_BYTES);\n      if (readrc == -1)     return SOCKET_GETCHAR_ERROR;\n      else if (readrc == 0) return SOCKET_READ_NOTHING;\n      else {\n#ifdef MVS\n            int i;\n            for (i=0;i<readrc;i++) g_buf[i] = atoe(g_buf[i]);\n#endif\n            bytes_returned = readrc;\n           }\n    }\n  }\n  return g_buf[++g_buf_index];\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Input one line of data from the server.                          */\n /*                                                                  */\n /********************************************************************/\n\nstatic enum server_retval\nsocket_in(ns,i_buf,n_bytes,delimiter,dont_read)\n int                   ns;\n char                 *i_buf;\n int                   n_bytes;\n char                  delimiter;\n Bool                  dont_read;\n {\n  int                  i_buf_index;\n  int                  i;\n  int                  character;\n\n  /* Get characters from the server until delimiter is reached. */\n\n  i_buf_index = 0;\n  while ((character = socket_getchar(ns,dont_read)) != delimiter) {\n    if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);\n    if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);\n    if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_NOTHING);\n    if (i_buf_index >= n_bytes) {\n      fprintf(stderr,\"Warning: The buffer passed to socket_in overflowed.\\n\");\n      fprintf(stderr,\" More than %d bytes collected without %2.2x seen.\\n\",\n             n_bytes,delimiter);\n      fprintf(stderr,\" Returning what we have so far.\\n\");\n      break;\n    }\n    i_buf[i_buf_index++] = (unsigned char)character;\n  }\n  i_buf[i_buf_index] = NULL_CHARACTER;\n\n  return(SERVER_OK);\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Output one line of data to the server.                           */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\nsocket_out(ns,o_buf,n_bytes)\n int                   ns;\n char                 *o_buf;\n int                   n_bytes;\n {\n  int                  writrc;\n  int                  j;\n  int                  needed_bytes;\n  static char         *mybufp = NULL;\n  static int           mybufl = 0;\n\n  needed_bytes = n_bytes+2;\n\n  if (mybufp == NULL) {\n    mybufl = MYBUF_INITIAL_SIZE;\n    mybufp = (char *)malloc(mybufl);\n  }\n\n  if (mybufl < needed_bytes) {\n    mybufl = needed_bytes + MYBUF_INCREMENT;\n    free(mybufp);\n    mybufp = (char *)malloc(mybufl);\n  }\n\n  if (mybufp == NULL) {\n    fprintf(stderr,\"\\nWhoops, failed to allocate output buffer!\\n\");\n    abort();\n  }\n\n  memcpy(mybufp,o_buf,n_bytes);\n  mybufp[n_bytes  ] = CARRIAGE_RETURN;\n  mybufp[n_bytes+1] = LINE_FEED;\n\n#ifdef MVS\n  for (j=0;j<=n_bytes+1;++j) mybufp[j] = etoa(mybufp[j]);\n#endif\n\n  writrc = write(ns, mybufp, n_bytes+2);\n  if (writrc < 0) errhand(\"write\",writrc);\n\n  return;\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Client routine.                                                  */\n /*                                                                  */\n /********************************************************************/\n\nmain(argc,argv)\nint               argc;\nchar            **argv;\n{\n\n int                port = 80;      /* port for the HTTP protocol  */\n char              *hostname;\n char              *hostfile;\n char              *cp;\n int                nbytes;         /* size of message buffer        */\n char               ibuf[IBUF_MSGSIZE];    /* the input buffer       */\n char               obuf[OBUF_MSGSIZE];    /* the output buffer      */\n char              *obufp;\n int                ibuflen;\n int                hostaddress;\n char               client_hostname[80];\n struct hostent    *hp;\n struct hostent    *server_hostent;\n struct sockaddr_in consock;        /* used by connect               */\n int                consocklen;     /* used by connect               */\n int                s;              /* the socket descriptor         */\n int                backlog;        /* queue length                  */\n int                listrc;         /* the return code from listen   */\n int                connrc;         /* the return code from connect  */\n int                readrc;         /* the return code from read     */\n int                writrc;         /* the return code from write    */\n enum server_retval socket_in_rc;\n\n Bool               first_time_thru;\n Bool               time_to_go_home;\n Bool               server_has_something_pending;\n Bool               sending_text;\n Bool               something_to_print;\n Bool               dont_read;\n\n if (argc != 3) {\n   fprintf(stderr,\"Usage: %s hostname[:portnumber] url\\n\",argv[0])      ;\n   exit(12);\n }\n\n hostname = argv[1];\n hostfile = argv[2];\n\n cp = strchr(hostname,':');\n if (cp) {\n   *cp = '\\0';\n   port = atoi(cp+1);\n }\n else port = 80;\n\n server_hostent = gethostbyname(hostname);\n if (!server_hostent) {\n    fprintf(stderr,\"Error:  gethostbyname doesn't know host %s\\n\",hostname);\n    exit(12);\n }\n if (!server_hostent) errhand(\"gethostbyname for server hostname\",0);\n\n consock.sin_family = AF_INET;\n consock.sin_port = htons(port);\n consock.sin_addr.s_addr = *((int *)server_hostent->h_addr);\n\n gethostname(client_hostname,sizeof(client_hostname));\n hp = gethostbyname(client_hostname);\n if (!hp) errhand(\"gethostbyname for client hostname\",0);\n hostaddress = *((int *)(hp->h_addr_list[0]));\n\n s = socket(AF_INET, SOCK_STREAM, 0);\n if (s < 0) errhand(\"socket creation\",s);\n\n consocklen = sizeof(consock);\n connrc = connect(s, &consock, consocklen);\n\n if (connrc < 0) {\n   errhand(\"connect\",connrc);\n   exit(connrc);\n }\n\n /**********************************************************************\n *                                                                     *\n * Send the server some input.  For HTTP, this is a URL.               *\n *                                                                     *\n **********************************************************************/\n\n strcpy(ibuf, \"GET \");\n strncpy(ibuf+4,hostfile,sizeof(ibuf)-5);\n\n socket_out(s,ibuf,strlen(ibuf));\n\n server_has_something_pending = TRUE;\n sending_text                 = FALSE;\n something_to_print           = FALSE;\n dont_read                    = FALSE;\n\n while (server_has_something_pending) {\n\n  something_to_print = FALSE;\n\n  socket_in_rc = socket_in(s,obuf,OBUF_MSGSIZE, LINE_FEED, dont_read);\n\n  switch (socket_in_rc) {\n    case SERVER_OK:\n            something_to_print = TRUE;\n            break;\n    case SERVER_READ_NOTHING:\n            server_has_something_pending = FALSE;\n            break;\n    case SERVER_NO_MORE:\n            server_has_something_pending = FALSE;\n            break;\n    case SERVER_READ_ERROR:\n            fprintf(stderr,\"\\n\\nRead error, lost connection.\\n\\n\");\n            time_to_go_home = TRUE;\n            break;\n    case SERVER_BUFFER_ERROR:\n            fprintf(stderr,\"\\n\\nServer buffer error\\n\\n\");\n            time_to_go_home = TRUE;\n            break;\n  };\n\n  if (time_to_go_home) break;\n  if (dont_read && !server_has_something_pending) break;\n\n  obufp = obuf;\n\n  if (something_to_print) {\n    cp = obufp + strlen(obufp) - 1;\n    if (cp >= obufp) {\n      if (*cp == CARRIAGE_RETURN) *cp = '\\0';\n    }\n    printf(\"%s\\n\",obufp);\n  }\n\n  if (time_to_go_home) break;\n\n } /* end while server_has_something_pending */\n\n /********************************************************************/\n /*                                                                  */\n /* Close the original socket.                                       */\n /*                                                                  */\n /********************************************************************/\n\n close(s);\n\n exit(0);\n\n}\n\n./ ADD NAME=JAY      0100-07332-07332-0900-00092-00092-00000-SEB\n/* # pragma runopts(test) */\n# include <stdio.h>\n\nstatic void j_process_julian_date();\nstatic void j_process_some_kind_of_date();\nstatic void j_process_gregorian_date();\nstatic void j_syntax_error();\n\nmain(argc,argv)\n        int argc;\n        char **argv;\n{\n\n if (argc == 1)         /* no date argument specified */\n        j_process_julian_date(\"Sorry, can't get current date, too stupid\");\n else\n if (argc == 2)         /* one date argument specified */\n        j_process_some_kind_of_date(argv[1]);\n else {\n        fprintf(stderr,\"Usage: j [julian_or_gregorian_date]\\n\");\n        exit(1);\n }\n}\n\n void j_process_some_kind_of_date(datep)\n        char *datep;\n{\n\n if (strchr(datep,'/'))         /* date contains a slash */\n        j_process_gregorian_date(datep);\n else\n        j_process_julian_date(datep);\n}\n\nvoid j_process_gregorian_date(datep)\n        char *datep;\n{\n        int     mm,\n                dd,\n                yy;\n        int     j;\n\n static int     days_so_far[12] = {0,31,60,91,121,152,182,213,244,274,305,335};\n\n if (sscanf(datep,\"%d/%d/%d\",&mm,&dd,&yy) != 3)\n        j_syntax_error(datep,\"bad mm or dd or yy\");\n\n if (mm < 1 || mm > 12 || dd < 1 || yy < 1)\n        j_syntax_error(datep,\"mm or dd or yy out of range\");\n j = days_so_far[mm-1] + dd;\n if (yy%4 != 0 && j > 59) j--;\n /* printf(\"Julian date for \\\"%s\\\" is:  %2.2d%3.3d\\n\",datep,yy,j); */\n printf(\"%2.2d%3.3d\\n\",yy,j);\n exit(0);\n}\n\nvoid j_process_julian_date(datep)\n        char *datep;\n{\n        int     n,\n                jjj,\n                nextjjj,\n                yy,\n                sscanf_rc;\n\n static int     days_month[12] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\n if (strchr(datep,'.'))  sscanf_rc = sscanf(datep,\"%d.%d\",&yy,&jjj);\n else                    sscanf_rc = sscanf(datep,\"%2d%d\",&yy,&jjj);\n if (sscanf_rc != 2)\n        j_syntax_error(datep,\"bad yy or jjj\");\n\n if (yy%4 != 0 && jjj > 59) jjj++;\n nextjjj = jjj;\n for (n=0;n<12 && nextjjj>0;n++) {\n        jjj = nextjjj;\n        nextjjj -= days_month[n];\n }\n\n\n /* printf(\"Gregorian date for \\\"%s\\\" is:  %2.2d/%2.2d/%2.2d\\n\",datep,n,jjj,yy);\n printf(\"%2.2d/%2.2d/%2.2d\\n\",n,jjj,yy);\n exit(0);\n}\n\nvoid j_syntax_error(datep,error_code)\n        char *datep;\n        char *error_code;\n{\n fprintf(stderr,\"Invalid date, %s - %s\\n\",datep,error_code);\n exit(1);\n}\n./ ADD NAME=MAKENULL 0100-07332-07332-0900-00064-00064-00000-SEB\n/* makenull.c - this program demonstrates the creation and reading of\n                null records in a C program */\n\n#include <stdio.h>\n\nmain() {\n FILE   *fp;\n char   *cp;\n int     i;\n char   *filename = \"makenull.txt\";\n char    line[512];\n char   *textlines[7] = {\"This is line 1.\",\n            \"This line should be followed by a null line.\",\n            \"\",\n            \"This line should be preceded by a null line.\",\n            \"You should see blank space (one line's worth) between\",\n            \"the previous 2 lines.  If you don't, the program has \",\n            \"handled null records correctly.\"};\n\n /* First, create the file that contains a null record */\n\n remove(filename);\n\n fp = fopen(filename,\"wb,recfm=vb,lrecl=255,blksize=6233\");\n if (!fp) {\n  perror(filename);\n  exit(1);\n }\n\n printf(\"\\nWriting file %s...\\n\\n\",filename);\n\n for (i=0; i<7; i++) {\n  printf(\"%s\\n\",textlines[i]);\n  for (cp = textlines[i]; *cp; cp++) {\n   fwrite(cp,1,1,fp);\n  }\n  fflush(fp);  /* apparently this makes new records in binary mode */\n }\n\n fclose(fp);\n\n /* Now, read back the file we just created. */\n\n fp = fopen(filename,\"r\");\n if (!fp) {\n  perror(filename);\n  exit(1);\n }\n\n printf(\"\\nReading file %s...\\n\\n\",filename);\n\n while (1) {\n  cp = fgets(line, sizeof line, fp);\n  if (cp == NULL) break;\n  while (*cp) {\n   putchar(*cp);\n   cp++;\n  }\n }\n\n fclose(fp);\n\n}\n\n./ ADD NAME=MAKEUP   0100-07332-07332-0900-00203-00203-00000-SEB\n/*\n ***********************************************************************\n *                                                                     *\n * This program takes a PDS and creates an IEBUPDTE stream on stdout.  *\n *                                                                     *\n * The PDS may be FB or VB.                                            *\n *                                                                     *\n * Usage:   makeup pdsname > iebupdte_stream_file                      *\n *                                                                     *\n * or                                                                  *\n *                                                                     *\n * Usage:   makeup pdsname membernamelistfile > iebupdte_stream_file   *\n *                                                                     *\n ***********************************************************************\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#define  Bool       char\n#define  FALSE      (Bool)0\n#define  TRUE       (Bool)1\n#define  EQUAL(X,Y)         (strcmp(X,Y)   == 0)\n#define  UNEQUAL(X,Y)       (strcmp(X,Y)   != 0)\n#define  LESS(X,Y)          (strcmp(X,Y)   <  0)\n#define  GREATER(X,Y)       (strcmp(X,Y)   >  0)\n#define  EQUALM(X,Y,Z)      (memcmp(X,Y,Z) == 0)\n#define  UNEQUALM(X,Y,Z)    (memcmp(X,Y,Z) != 0)\n#define  LESSM(X,Y,Z)       (memcmp(X,Y,Z) <  0)\n#define  GREATERM(X,Y,Z)    (memcmp(X,Y,Z) >  0)\n\ntypedef struct memlink MEMLINK;\n\nstruct memlink {\n                struct memlink *next;\n                char            member[9];\n               };\n\nint\nmain(argc,argv)\nint          argc;\nchar       **argv;\n{\n short       i;\n short       block_count;\n short       bump_amount;\n Bool        no_more;\n Bool        reject;\n char       *cp;\n FILE       *dirfp;\n FILE       *ifp;\n FILE       *mfp;\n char       *pgm;\n char       *pds;\n char       *memlistdsn;\n MEMLINK    *ml;\n MEMLINK    *newml;\n int         linecount;\n char        fulldsn [128];\n char        dirblk  [256];\n char        eline   [256];\n\n /* code to get members and process each one */\n\n switch (argc) {\n   case 2: pgm = argv[0];\n           pds = argv[1];\n           memlistdsn = NULL;\n           break;\n   case 3: pgm = argv[0];\n           pds = argv[1];\n           memlistdsn = argv[2];\n           break;\n   default:\n            fprintf(stderr,\n   \"Usage: %s <pdsname> <optional_file_containing_names_of_members>\\n\",\n                    argv[0]);\n            exit(16);\n }\n\n ml = NULL;\n\n if (memlistdsn) {\n   if (!(mfp = fopen(memlistdsn,\"r\"))) {\n     perror(memlistdsn);\n     exit(12);\n   }\n   while (!feof(mfp)) {\n     *eline = '\\0';\n     fscanf(mfp,\"%s\",eline);\n     if (ferror(mfp)) {\n       fprintf(stderr,\"%s: error reading %s\\n\",pgm,memlistdsn);\n       exit(20);\n     }\n     if (!*eline) continue;\n     if (strlen(eline) > 8) {\n       fprintf(stderr,\"%s: Member name too long, ignored: %s\\n\",\n                      pgm,eline);\n       continue;\n     }\n     newml = (MEMLINK *)malloc(sizeof(MEMLINK));\n     if (!newml) {\n       fprintf(stderr,\"%s: not enough memory for member name list\\n\",\n                      pgm);\n       exit(20);\n     }\n     newml->next = ml;\n     strcpy(newml->member,\"        \");\n     strcpy(newml->member,eline);\n     for (cp = newml->member; *cp; cp++) *cp = toupper(*cp);\n     *cp = ' ';\n     ml = newml;\n   }\n   fclose(mfp);\n }\n\n /* debugging only */\n\n for (newml = ml; newml; newml = newml->next) {\n   fprintf(stderr,\"Selecting member name: <%s>\\n\", newml->member);\n }\n\n if (!(dirfp = fopen(pds,\"rb,recfm=u,lrecl=256\"))) {\n   perror(pds);\n   exit(12);\n }\n\n no_more = FALSE;\n\n do {\n   memset(dirblk,0x00,256);\n   fread(dirblk,256,1,dirfp);\n   if (feof(dirfp)) break;\n   if (ferror(dirfp)) {\n     fprintf(stderr, \"%s: Error reading directory of %s\\n\",\n                     pgm,pds);\n     fclose(dirfp);\n     exit(20);\n   }\n   cp = dirblk;\n   block_count = *(short *)cp - 2;   /* # bytes in dir block */\n   cp += 2;                        /* addr of dir block data */\n   while (block_count > 0) {\n     if (EQUALM(cp,\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",8)) {\n       /*\n       no_more = TRUE;\n       */\n       break;\n     }\n     reject = FALSE;\n     if ((cp[11] & 0x80) != 0) { /* skip aliases */\n       fprintf(stderr,\"Skipping alias:  %-8.8s\\n\",cp);\n       reject = TRUE;\n     }\n     else if (memlistdsn) {\n       for (newml = ml; newml; newml = newml->next) {\n         if (EQUALM(newml->member,cp,8)) break;\n       }\n       if (!newml) {\n         fprintf(stderr,\"Unwanted member: %-8.8s\\n\",cp);\n         reject = TRUE;\n       }\n     }\n     if (!reject) {\n       if (*pds == '\\'')\n            sprintf(fulldsn,\"'%.*s(%-8.8s)'\", strlen(pds)-2,pds+1,cp);\n       else sprintf(fulldsn,\"%s(%-8.8s)\",pds,cp);\n       if (!(ifp = fopen(fulldsn,\"r\"))) {\n         perror(fulldsn);\n         break;\n       }\n       fprintf(stdout,\"./ ADD NAME=%s\\n\",cp);\n       linecount = 0;\n       while(!feof(ifp)) {\n         memset(eline,'\\0',4);\n         (void)fgets(eline,sizeof eline,ifp);\n         if (feof(ifp)) break;\n         if (ferror(ifp)) {\n           fprintf(stderr,\"%s: Error reading %s\",pgm,fulldsn);\n           break;\n         }\n         linecount++;\n         if (EQUALM(eline,\"./\",2)) {\n           fprintf(stderr,\"Warning: ./ found in %-8.8s - line %d\\n\",\n                   cp,linecount);\n         }\n         fputs(eline,stdout);\n       }\n       fclose(ifp);\n     }\n     bump_amount = 12 + ((cp[11] & 0x1f) * 2);\n     cp += bump_amount;\n     block_count -= bump_amount;\n   }\n } while(!no_more);\n\n fprintf(stdout,\"./ ENDUP\\n\");\n\n fclose(dirfp);\n\n exit(0);\n}\n\n./ ADD NAME=MATCH    0100-07332-07332-0900-00336-00336-00000-SEB\n#include <ctest.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define  BOOL      int\n#define  FALSE     (BOOL)0\n#define  TRUE      (BOOL)1\n#define  FAILURE   (-1)\n#define  NULLCHAR  '\\0'\n\ntypedef struct _matcher   MATCHER;\ntypedef struct _matchap   MATCHAP;\ntypedef int             (*OPERATION)();\n\nstruct _matchap {\n                 OPERATION   operation;\n                 int         operi;\n                 char       *operj;\n                };\n\nstruct _matcher {\n                 int         used;\n                 MATCHAP     matchap[1];\n                };\n\n/*-------------------------------------------------------------------*/\n\nstatic BOOL\nsame(s1,s2,len)\nregister  char    *s1;\nregister  char    *s2;\nregister  int      len;\n{\n register char    *p1;\n register char    *p2;\n\n for (p1=s1,p2=s2; len>0 ; p1++,p2++,len--) {\n   if (*p2 != '?' && *p1 != *p2) return FALSE;\n }\n return TRUE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_min(wordp,wordlen,argi,argj,pointer)\nregister char     *wordp;\nregister int       wordlen;\nregister int       argi;\nregister char     *argj;\nregister int       pointer;\n{\n\n if (argi > wordlen) return FAILURE;\n else return pointer;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_bump(wordp,wordlen,argi,argj,pointer)\nregister char     *wordp;\nregister int       wordlen;\nregister int       argi;\nregister char     *argj;\nregister int       pointer;\n{\n\n pointer += argi;\n if (pointer > wordlen) return FAILURE;\n else return pointer;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_match(wordp,wordlen,argi,argj,pointer)\nregister  char     *wordp;\nregister  int       wordlen;\nregister  int       argi;\nregister  char     *argj;\nregister  int       pointer;\n{\n register int       matchptr = wordlen + 1 - argi;\n\n if (pointer > matchptr) return FAILURE;\n else if (!memcmp(wordp+pointer,argj,argi)) return pointer + argi;\n else return FAILURE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_scan(wordp,wordlen,argi,argj,pointer)\nregister  char     *wordp;\nregister  int       wordlen;\nregister  int       argi;\nregister  char     *argj;\nregister  int       pointer;\n{\n register int       matchptr = wordlen + 1 - argi;\n\n for (;pointer <= matchptr; pointer++) {\n   if (!memcmp(wordp+pointer,argj,argi)) return pointer + argi;\n }\n return FAILURE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_wildmatch(wordp,wordlen,argi,argj,pointer)\nregister  char     *wordp;\nregister  int       wordlen;\nregister  int       argi;\nregister  char     *argj;\nregister  int       pointer;\n{\n register int      matchptr = wordlen + 1 - argi;\n\n if (pointer > matchptr) return FAILURE;\n else if (same(wordp+pointer,argj,argi)) return pointer + argi;\n else return FAILURE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic int\ndo_wildscan(wordp,wordlen,argi,argj,pointer)\nregister  char     *wordp;\nregister  int       wordlen;\nregister  int       argi;\nregister  char     *argj;\nregister  int       pointer;\n{\n register int      matchptr = wordlen + 1 - argi;\n\n for (;pointer <= matchptr; pointer++) {\n   if (same(wordp+pointer,argj,argi)) return pointer + argi;\n }\n return FAILURE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic BOOL\napply(matcher,wordp,wordlen)\nMATCHER  *matcher;\nchar     *wordp;\nint       wordlen;\n{\n short    pointer = 0;\n int      m;\n int    (*function)();\n int      argument;\n\n for (m=0; m<matcher->used; m++) {\n\n   pointer = (matcher->matchap[m].operation)\n                                          (wordp,\n                                           wordlen,\n                                           matcher->matchap[m].operi,\n                                           matcher->matchap[m].operj,\n                                           pointer);\n   if (pointer == FAILURE)  return FALSE;\n }\n\n return TRUE;\n}\n\n/*-------------------------------------------------------------------*/\n\nstatic void\nhack(pattern,matcher)\nchar     *pattern;\nMATCHER  *matcher;\n{\n int      min       = 0;\n int      bump      = 0;\n int      matchlen  = 0;\n BOOL     starmode  = FALSE;\n BOOL     matchmode = TRUE;\n BOOL     wildmode  = FALSE;\n BOOL     dataless  = TRUE;\n char    *matchp    = NULL;\n char    *cp        = NULL;\n\n matcher->matchap[0].operation = do_min;\n matcher->matchap[0].operi     = 0;    /* to be filled in later */\n matcher->matchap[0].operj     = NULL; /* to be filled in later */\n matcher->used = 1;\n\n for (cp=pattern;*cp;cp++) {\n   switch (*cp) {\n     case '*':\n              if (matchp) {\n                matcher->matchap[matcher->used].operation =\n                   (matchmode ? (wildmode ? do_wildmatch : do_match)\n                              : (wildmode ? do_wildscan  : do_scan));\n                matcher->matchap[matcher->used].operi    =  matchlen;\n                matcher->matchap[matcher->used].operj    =  matchp;\n                matcher->used++;\n                matchp = NULL;\n                matchlen = 0;\n              }\n              starmode = TRUE;\n              break;\n     case '?':\n              min++;\n              if (starmode || dataless) {\n                bump++;\n              }\n              else {\n                wildmode = TRUE;\n                if (!matchp) matchp = cp;\n                matchlen++;\n              }\n              break;\n     default:\n              dataless = FALSE;\n              min++;\n              if (bump > 0) {\n                matcher->matchap[matcher->used].operation = do_bump;\n                matcher->matchap[matcher->used].operi      = bump;\n                matcher->matchap[matcher->used].operj      = NULL;\n                matcher->used++;\n                bump = 0;\n              }\n              if (starmode) {\n                matchmode = FALSE;\n                wildmode = FALSE;\n              }\n              if (!matchp) matchp = cp;\n              matchlen++;\n              starmode = FALSE;\n              break;\n   }\n }\n\n if (bump > 0) {\n   matcher->matchap[matcher->used].operation = do_bump;\n   matcher->matchap[matcher->used].operi     = bump;\n   matcher->matchap[matcher->used].operj     = NULL;\n   matcher->used++;\n   bump = 0;\n }\n if (starmode) {\n   matchmode = FALSE;\n   wildmode = FALSE;\n }\n if (!matchp) matchp = cp;\n matchlen++;\n if (matchp) {\n   matcher->matchap[matcher->used].operation =\n      (matchmode ? (wildmode ? do_wildmatch : do_match)\n                 : (wildmode ? do_wildscan  : do_scan));\n   matcher->matchap[matcher->used].operi    =  matchlen;\n   matcher->matchap[matcher->used].operj    =  matchp;\n   matcher->used++;\n   matchp = NULL;\n   matchlen = 0;\n }\n\n matcher->matchap[0].operi  = min;\n\n return;\n}\n\n/*-------------------------------------------------------------------*/\n\nint\nmain(argc,argv)\nint       argc;\nchar    **argv;\n{\n char    *pattern;\n char    *filename;\n int      matchersize;\n MATCHER *matcher;\n FILE    *fp;\n int      i;\n char    *wordp;\n int      wordlen;\n char     line[256];\n\n if (argc < 3) {\n   fprintf(stderr,\"Usage: match pattern filename\\n\");\n   exit(12);\n }\n\n if (argc > 3 && (!strcmp(argv[3],\"test\") ||\n                  !strcmp(argv[3],\"TEST\"))) __ctest(NULL);\n\n pattern  = argv[1];\n filename = argv[2];\n\n matchersize = strlen(pattern) * sizeof(MATCHAP) + sizeof(MATCHER);\n matcher = (MATCHER *)malloc(matchersize);\n if (!matcher) {\n   fprintf(stderr,\"match: cannot get %d bytes for matcher\\n\",\n                  matchersize);\n   exit(16);\n }\n hack(pattern,matcher);\n if (!(fp=fopen(filename,\"r\"))) {\n   perror(filename);\n   exit(12);\n }\n\n while (!feof(fp)) {\n   (void)fgets(line,sizeof line,fp);\n   if (feof(fp)) break;\n   if (ferror(fp)) {\n     perror(filename);\n     break;\n   }\n   if (wordp = strchr(line,'\\n')) *wordp = '\\0';\n   wordp = line;\n   for (;;) {\n     wordp += strspn(wordp,\" \");\n     if (*wordp == '\\0') break;\n     wordlen = strcspn(wordp,\" \");\n     *(wordp+wordlen) = '\\0';\n     if (apply(matcher,wordp,wordlen)) {\n       printf(\"%s\\n\",wordp);\n     }\n     else {\n     }\n     wordp += wordlen+1;\n   }\n }\n fclose(fp);\n free(matcher);\n return 0;\n}\n./ ADD NAME=NUSERS   0100-07332-07332-0900-00070-00070-00000-SEB\n#pragma runopts(nospie,nostae)\n#include <stdio.h>\n\nstatic unsigned long * nuser();\n\nmain()\n{printf(\"\\n%d TSO users\\n\",*nuser());}\n\nunsigned long * nuser()\n{\n\n static unsigned long tsoctr;\n\n struct cvt {\n         char            CVT_FILLER1 [556];       /* 0-22C  */\n         struct asvt *   CVTASVT;                 /* 22C    */\n        };\n\n struct ascb {\n         char             ASCB_FILLER1 [36];       /* 0-24  */\n         short            ASCBASID;                /* 24-26 */\n         char             ASCB_FILLER2 [22];       /* 26-3C */\n         struct tsb *     ASCBTSB;                 /* 3C    */\n         char             ASCB_FILLER3 [112];      /* 40-B0 */\n         char *           ASCBJBNS;                /* B0    */\n        };\n\n struct tsb {\n         char NOTHING_MUCH;  /* who cares */\n        };\n\n struct asvtentry {\n         int             asvteword;\n        };\n\n struct asvt {\n         char               ASVT_FILLER1 [516];      /* 0-204 */\n         int                ASVTMAXU;                /* 204   */\n         int                ASVT_FILLER2;            /* 208   */\n         struct asvtentry   ASVTENTY[1];             /* 20C   */\n        };\n\n struct cvt      ** cvtpp = (struct cvt **) 0x10;\n struct cvt       * cvtp;\n struct ascb      * ascbp;\n struct asvtentry   asvte;\n int asid, asid_start, asid_end;\n\n tsoctr = 0;\n cvtp = *cvtpp;\n asid_start = 1;\n asid_end   = cvtp->CVTASVT->ASVTMAXU;\n\n for (asid=asid_start; asid<=asid_end; asid++) {\n    /* get ASVT entry for this ASID */\n    asvte = cvtp->CVTASVT->ASVTENTY[asid-1];\n    if (!(asvte.asvteword & 0x80000000)) { /* this asid is assigned */\n       ascbp = (struct ascb *)(asvte.asvteword & 0x00ffffff);\n       printf(\"ASID %d (%4.4X) TSB %8.8X Name %8.8s\\n\",asid,asid,\n              (ascbp->ASCBTSB),\n              (ascbp->ASCBJBNS) ? ascbp->ASCBJBNS : \"--------\");\n\n       if (ascbp->ASCBTSB != NULL && ascbp->ASCBJBNS != NULL)\n          tsoctr++;\n    }\n    else printf(\"ASID %d (%4.4X) not in use: %8.8X\\n\",\n                asid,asid, (asvte.asvteword));\n }\n return(&tsoctr);\n}\n./ ADD NAME=REXXIT   0100-07332-07332-0900-00479-00479-00000-SEB\n/*\n#pragma linkage(IRXEXCOM,OS)\n#pragma linkage(IRXEXEC,OS)\n#pragma linkage(IRXINIT,OS)\n#pragma linkage(IRXLOAD,OS)\n#pragma linkage(IRXSTK,OS)\n#pragma linkage(IRXTERM,OS)\n*/\n#pragma runopts(noargparse,noredir)\n#include <stdio.h>\n#include \"rexx.h\"\n\n#define Bool        int\n#ifndef FALSE\n#define FALSE       (Bool)0\n#endif\n#ifndef TRUE\n#define TRUE        (Bool)1\n#endif\n\nstatic Rexxfun    irxexcom;\nstatic Rexxfun    irxexec;\nstatic Rexxfun    irxinit;\nstatic Rexxfun    irxload;\nstatic Rexxfun    irxstk;\nstatic Rexxfun    irxterm;\n\nstatic struct envblock  *envblockptr;\nstatic struct instblock *instblockptr;\nstatic char             *commandargs;\nstatic struct execblock  execblk;\n\n/* ================================================================ */\n\nstatic void\ndump_envblock(struct envblock *E)\n{\n fprintf(stdout,\"Dump of ENVBLOCK at %8.8X follows...\\n\\n\",E);\n fprintf(stdout,\"ID.....................%8.8s\\n\", E->id              );\n fprintf(stdout,\"Version................%4.4s\\n\", E->version         );\n fprintf(stdout,\"Length.................%d\\n\",    E->length          );\n fprintf(stdout,\"Parmblock..............%8.8X\\n\", E->parmblock       );\n fprintf(stdout,\"Userfield..............%8.8X\\n\", E->userfield       );\n fprintf(stdout,\"Workblock extension....%8.8X\\n\", E->workblok_ext    );\n fprintf(stdout,\"External entry vector..%8.8X\\n\", E->irxexte         );\n fprintf(stdout,\"Error call address.....%8.8X\\n\", E->error_call_addr );\n fprintf(stdout,\"Error message ID.......%8.8s\\n\", E->error_msgid     );\n fprintf(stdout,\"Primary error message:\\n%80.80s\\n\",\n                E->primary_error_message);\n fprintf(stdout,\"Alternate error message:\\n%160.160s\\n\",\n                E->alternate_error_message);\n fprintf(stdout,\"compgmtb...............%8.8X\\n\", E->compgmtb        );\n fprintf(stdout,\"attnrout_parmptr.......%8.8X\\n\", E->attnrout_parmptr);\n fprintf(stdout,\"\\n\\nEnd of ENVBLOCK dump.\\n\\n\");\n}\n\n/* ================================================================ */\n\nstatic Bool\ncall_irxinit(char *command)\n{\n unsigned int       bitflags;\n int                rexxrc;\n int                irxinitrc;\n int                i;\n void              *parmlist; /* dunno */\n Bool               rc;\n PARAMETER          parameter[11];\n\n /* Set up parameters for IRXINIT:\n  *\n  * Param 1  -  \"INITENVB\"  - could be \"FINDENVB\" to find env block\n  * Param 2  -  \"        \"  - name of parameters module\n  * Param 3  -  address of in-storage parameter list\n  * Param 4  -  address of a user field\n  * Param 5  -  zero\n  * Param 6  -  set to address of environment block\n  * Param 7  -  set to reason code\n  * Param 8  -  zero (default storage allocation)\n  * Param 9  -  set to return code\n  *\n  */\n\n rexxrc = 0;\n\n parameter[ 3] =   (PARAMETER) NULL;       /* no instor param list */\n parameter[ 4] =   (PARAMETER) NULL;       /* no user field */\n parameter[ 5] =   (PARAMETER) 0;\n parameter[ 6] =   (PARAMETER) NULL;\n parameter[ 7] =   (PARAMETER) 0;\n parameter[ 8] =   (PARAMETER) 0;\n parameter[ 9] =   (PARAMETER) 0;\n\n irxinitrc = (*irxinit) (\n                         \"INITENVB\",\n                         \"        \",\n                         &parameter[3],\n                         &parameter[4],\n                         &parameter[5],\n                         &parameter[6],\n                         LASTPARM(&parameter[7]),   /* old REXX */\n                         &parameter[8],\n                         LASTPARM(&parameter[9])    /* new REXX */\n                        );\n\n if (irxinitrc != 0) rc = FALSE;\n else rc = TRUE;\n envblockptr = (struct envblock *)parameter[6];\n rexxrc = parameter[7];\n fprintf(stderr,\"Return code from IRXINIT is %d\\n\", irxinitrc);\n fprintf(stderr,\"Reason code from IRXINIT is %d\\n\", rexxrc   );\n fprintf(stderr,\"IRXINIT returned envblock at %8.8X\\n\", envblockptr);\n if (!memcmp((char *)envblockptr,\"ENVBLOCK\",8)) {\n   fprintf(stderr,\"This is a good environment block address\\n\");\n }\n else {\n   fprintf(stderr,\"This is a BAD environment block address\\n\");\n }\n return TRUE;\n\n}\n\n/* ================================================================ */\n\nstatic Bool\ncall_irxterm(char *command)\n{\n int irxtermrc;\n\n irxtermrc = (*irxterm) ();\n\n if (irxtermrc != 0) {\n   fprintf(stderr,\"Return code from IRXTERM is %d\\n\", irxtermrc);\n   return FALSE;\n }\n else {\n   fprintf(stderr,\"Return code from IRXTERM is %d\\n\", irxtermrc);\n   return TRUE;\n }\n}\n\n/* ================================================================ */\n\nstatic Bool\ncall_irxload(char *command)\n{\n char              *function;\n unsigned int       bitflags;\n int                rexxrc;\n int                irxloadrc;\n int                cmdlen;\n int                scan_count;\n int                i;\n Bool               rc;\n char               exectest[1024];\n PARAMETER          parameter[11];\n\n function = (command ? \"LOAD    \" : \"FREE    \");\n rc = TRUE;\n scan_count = 0;\n cmdlen = strlen(command);\n\n *exectest = '\\0';\n sscanf(command, \"%s %n\", exectest, &scan_count);\n if (strlen(exectest) > 8) {\n   fprintf(stderr,\"Sorry, name of exec is too long: %s\\n\",exectest);\n   return FALSE;\n }\n commandargs = command + scan_count;\n\n if (!rc) return rc;\n\n /* set up exec block */\n\n if (command) {\n   memset(&execblk,0,sizeof(execblk));\n   execblk.length = sizeof(execblk);\n   memcpy (execblk.acryn, \"IRXEXECB\", 8);\n   strncpy(execblk.member,exectest,8);\n   for (i=0;i<8;i++) {\n     if (execblk.member[i] == '\\0') execblk.member[i] = ' ';\n   }\n   /* We may have just clobbered this, so do this after... */\n   memcpy (execblk.ddname, \"GGEXEC  \", 8);\n   memcpy (execblk.subcom, \"        \", 8);\n   parameter[ 2] =   (PARAMETER)&execblk;\n   parameter[ 3] =   (PARAMETER)NULL;   /* set to INSTBLK */\n   fprintf(stderr,\"Loading:%s\\n\", exectest);\n }\n else {\n   parameter[ 2] =   (PARAMETER)NULL;\n   parameter[ 3] =   (PARAMETER)instblockptr;\n }\n parameter[ 4] =   (PARAMETER)envblockptr;\n parameter[ 5] =   (PARAMETER)0;      /* set to return code */\n\n irxloadrc = (*irxload) (\n                         function,\n                         &parameter[2],\n                         LASTPARM(&parameter[3]), /* old REXX */\n                         &parameter[4],\n                         LASTPARM(&parameter[5])  /* new REXX */\n                        );\n\n fprintf(stderr,\"Return code from IRXLOAD is %d\\n\", irxloadrc);\n instblockptr = (struct instblock *)parameter[3];\n return (irxloadrc == 0 ? TRUE : FALSE);\n\n}\n\n/* ================================================================ */\n\nstatic Bool\ncall_irxexec(char *command)\n{\n unsigned int       bitflags;\n int                rexxrc;\n int                irxexecrc;\n int                cmdlen;\n int                i;\n Bool               rc;\n char              *arg2 = \"Argument number two\";\n char              *arg3 = \"This, too, shall pass to the REXX exec.\";\n char               exectest[1024];\n PARAMETER          parameter[11];\n struct {\n         struct {\n                 char   *argstring_ptr;\n                 int     argstring_length;\n                }        argstring[3];\n         int             argstring_end;\n        }                arguments;\n\n rc = TRUE;\n\n /* Set up parameters for IRXEXEC:\n  *\n  * Param 1  -  address of EXECBLK\n  * Param 2  -  address of arguments\n  * Param 3  -  bitflags\n  * Param 4  -  address of INSTBLK\n  * Param 5  -  address of CPPL\n  * Param 6  -  address of EVALBLOCK\n  * Param 7  -  address of 8-byte work area\n  * Param 8  -  address of user field\n  * Param 9  -  address of environment block\n  * Param 10 -  return code\n  *\n  */\n\n if (rc) {\n\n   /* set up arguments  */\n\n   arguments.argstring[0].argstring_ptr    = commandargs;\n   arguments.argstring[0].argstring_length = strlen(commandargs);\n   arguments.argstring[1].argstring_ptr    = arg2;\n   arguments.argstring[1].argstring_length = strlen(arg2);\n   arguments.argstring[2].argstring_ptr    = arg3;\n   arguments.argstring[2].argstring_length = strlen(arg3);\n   arguments.argstring_end    = 0xffffffff;\n\n   /* Invoke the rexx exec */\n\n   fprintf(stderr,\"Executing:%s\\n\", command);\n\n   rexxrc = 0;\n   bitflags = (unsigned int)(INVOKE_EXEC_AS_COMMAND +\n                             RETURN_EXTENDED_RETURN_CODES);\n\n   parameter[ 1] =   (PARAMETER)&execblk;\n   parameter[ 2] =   (PARAMETER)&arguments;\n   parameter[ 3] =   (PARAMETER)bitflags;\n   parameter[ 4] =   (PARAMETER)NULL;  /* no INSTBLK */\n   parameter[ 5] =   (PARAMETER)NULL;  /* no CPPL    */\n   parameter[ 6] =   (PARAMETER)NULL;  /* no eval block */\n   parameter[ 7] =   (PARAMETER)NULL;  /* no work area */\n   parameter[ 8] =   (PARAMETER)NULL;  /* no user field, last parm */\n   parameter[ 9] =   (PARAMETER)NULL;  /* no environment block */\n   parameter[10] =   (PARAMETER)0;     /* return code */\n\n   irxexecrc = (*irxexec) (\n                           &parameter[1],\n                           &parameter[2],\n                           &parameter[3],\n                           &parameter[4],\n                           &parameter[5],\n                           &parameter[6],\n                           &parameter[7],\n                           LASTPARM(&parameter[8]), /* old REXX */\n                           &parameter[9],\n                           LASTPARM(&parameter[10]) /* new REXX */\n                          );\n\n   if (irxexecrc != 0) {\n     fprintf(stderr,\"Return code from IRXEXEC is %d\\n\", irxexecrc);\n     rc = FALSE;\n   }\n   else {\n     rexxrc = parameter[10];\n     fprintf(stderr,\"Return code from %s is %d\\n\", exectest, rexxrc);\n   }\n }\n\n else fprintf(stderr,\"Some kind of problem with exec %s\\n\",exectest);\n\n return rc;\n\n}\n\n/* ================================================================ */\n\nstatic Bool\ncall_irxexcom(char *stuff)\n{\n int              irxexcomrc = 0;\n int              retcode    = 0;\n int              zero       = 0;\n char            *variable_name  = \"FOOVARIABLE\";\n char            *variable_value = \"Value of the FOOVARIABLE variable\";\n struct shvblock  shvblk;\n\n memset(&shvblk,0,sizeof(shvblk));\n\n shvblk.shvcode = 'S';    /* Set variable from given value */\n shvblk.shvnama = variable_name;\n shvblk.shvnaml = strlen(variable_name);\n shvblk.shvvala = variable_value;\n shvblk.shvvall = strlen(variable_value);\n\n irxexcomrc = (*irxexcom) (\n                           \"IRXEXCOM\",\n                           &zero,\n                           &zero,\n                           LASTPARM(&shvblk),\n                           &envblockptr,\n                           LASTPARM(&retcode)\n                          );\n\n fprintf(stderr,\"Return code from IRXEXCOM is %d (%d)\\n\",\n                 irxexcomrc, retcode);\n\n return (irxexcomrc == 0 ? TRUE : FALSE);\n\n}\n\n/* ================================================================ */\n\nstatic void\nrexx_queue(char *qline)\n{\n int retcode  = 0;\n int qlen     = strlen(qline);\n\n retcode = (*irxstk)(\n                     \"QUEUE   \",\n                     &qline,\n                     &qlen,\n                     LASTPARM(&retcode)\n                    );\n\n fprintf(stderr,\"IRXSTK returned code %d\\n\",retcode);\n\n return;\n}\n\n/* ================================================================ */\n\nstatic char *\nrexx_pull()\n{\n int   retcode  = 0;\n char *string   = NULL;\n char *qline    = NULL;\n int   qlen     = 0;\n\n retcode = (*irxstk)(\n                     \"PULL    \",\n                     &qline,\n                     &qlen,\n                     LASTPARM(&retcode)\n                    );\n\n fprintf(stderr,\"IRXSTK returned code %d\\n\",retcode);\n\n if (qline) {\n   string = (char *)malloc(qlen+1);\n   if (!string) {\n     fprintf(stderr,\"Could not malloc %d bytes for pulled string\\n\",\n       qlen+1);\n     return NULL;\n   }\n   memcpy(string,qline,qlen);\n   string[qlen] = '\\0';\n }\n return string;\n}\n\n\n/* ================================================================ */\n\nstatic int\nrexx_queued()\n{\n int   queued   = 0;\n int  retcode   = 0;\n\n queued = (*irxstk)(\n                    \"QUEUED  \",\n                    0,\n                    0,\n                    LASTPARM(&retcode)\n                   );\n\n return retcode;\n}\n\n\n/* ================================================================ */\n\nstatic Rexxfun\nload_it(char *module)\n{\n int (*funcp)();\n\n funcp = (Rexxfun)fetch(module);\n if (!funcp) fprintf(stderr,\"Cannot fetch %s\\n\",module);\n return funcp;\n\n}\n\n/* ================================================================ */\n\nint\nmain(int argc, char **argv) {\n char              *command;\n char              *line;\n\n   command = argv[1];\n\n   fprintf(stderr,\"Command:'%s'\\n\",command);\n\n   envblockptr = (PARAMETER)NULL;\n   irxexcom = load_it(\"IRXEXCOM\");\n   irxexec  = load_it(\"IRXEXEC\");\n   irxinit  = load_it(\"IRXINIT\");\n   irxload  = load_it(\"IRXLOAD\");\n   irxstk   = load_it(\"IRXSTK\");\n   irxterm  = load_it(\"IRXTERM\");\n\n   if (!(irxexcom&&irxexec&&irxinit&&irxload&&irxstk&&irxterm))\n      return 16;\n\n   call_irxinit  (NULL);\n   call_irxload  (command);\n   dump_envblock (envblockptr);\n   call_irxexcom (NULL);\n   rexx_queue    (\"Stacked line number one\");\n   rexx_queue    (\"Stacked line number two\");\n   rexx_queue    (\"Stacked line number three\");\n   dump_envblock (envblockptr);\n   call_irxexec  (command);\n   dump_envblock (envblockptr);\n   call_irxload  (NULL);\n   fprintf(stderr,\"There are %d lines queued.\\n\",rexx_queued());\n   while ((line = rexx_pull()) != NULL)\n         fprintf(stderr,\"Pulled line:'%s'\\n\",line);\n   call_irxterm  (NULL);\n\n   release(\"IRXEXCOM\");\n   release(\"IRXEXEC\");\n   release(\"IRXINIT\");\n   release(\"IRXLOAD\");\n   release(\"IRXSTK\");\n   release(\"IRXTERM\");\n\n   return 0;\n\n}\n./ ADD NAME=REXXJCL  0100-07332-07332-0900-00030-00030-00000-SEB\n#pragma linkage(IRXJCL,OS)\n#pragma runopts(noargparse,noredir)\n#include <stdio.h>\n\nint\nmain(int argc, char **argv) {\n int                rexxrc;\n int              (*irxjcl)();\n char               parm[257];\n\n   printf(\"Command:'%s'\\n\",argv[1]);\n\n   irxjcl = (int(*)())fetch(\"IRXJCL\");\n   if (!irxjcl) {\n     printf(\"Cannot fetch IRXJCL\\n\");\n     return 16;\n   }\n\n   *(short *)parm = strlen(argv[1]);\n   memcpy(parm+2,argv[1],strlen(argv[1]));\n\n   rexxrc = (*irxjcl)(parm);\n\n   printf(\"Return code from exec is %d\\n\", rexxrc);\n\n   release(\"IRXJCL\");\n\n   return rexxrc;\n\n}\n./ ADD NAME=SIGFAIL  0100-07332-07332-0900-00081-00081-00000-SEB\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n\nstatic void\nhandler() {\n printf(\"SIGINT handler has been called.\\n\");\n exit(8);\n}\n\nstatic int\nask(question)\nchar *question;\n{\n char ans[81];\n\n for (;;) {\n   printf(\"%s\",question);\n   fgets(ans,79,stdin);\n   switch (ans[0]) {\n     case 'y':\n     case 'Y': return 1;\n     case 'n':\n     case 'N': return 0;\n     default: printf(\"Bad answer, %s\\n\",ans);\n              continue;\n   }\n }\n}\n\nmain(argc,argv)\nint argc;\nchar **argv;\n{\n int sigp;\n int loopp;\n int i;\n\n printf(\n  \"This program demonstrates that SIGINT is not handled on MVS.\\n\");\n printf(\n  \"It does NOT prove or disprove anything about attention handling\\n\");\n printf(\n  \"in C/370 in general, except possibly for how output to stdout\\n\");\n printf(\n  \"and stderr are affected by an attention interruption.\\n\\n\");\n printf(\n  \"At the end of the program, a line of output is written to each\\n\");\n printf(\n  \"of the two output files.  If you see either one, that means that\\n\");\n printf(\n  \"C/370 has intercepted the attention, but you will observe that\\n\");\n printf(\n  \"it has not been handled by a SIGINT routine and it also has not\\n\");\n printf(\n  \"allowed the program to be terminated by the operating system.\\n\\n\");\n\n sigp  = ask(\"Do you want to signal abort on interrupts? (y or n)\");\n loopp = ask(\"Do you want to loop forever without output? (y or n)\");\n\n if (sigp) {\n   printf(\"Doing signal(SIGINT,handler)\\n\");\n   if (signal(SIGINT,handler) == SIG_ERR)\n       perror(\"Could not set SIGINT\");\n }\n\n printf(\"OK, hit PA1 now\\n\");\n\n if (loopp) {\n   for (;;) ;\n }\n else {\n   for (i=0;i<5000;i++) {\n    printf(\"I=%d\\n\",i);\n   }\n }\n printf(\"I'm finished (on stdout)\\n\");\n fprintf(stderr,\"I'm finished (on stderr)\\n\");\n}\n\n./ ADD NAME=SMTPDOG  0100-07332-07332-0900-00564-00564-00000-SEB\n/* SMTPDOG = \"SMTP do good\" = \"SMTPDO\" with checking responses */\n/* PORT 25 (SMTP) client - similar to \"TELNET hostname 25\" */\n\n/*\n\n SMTP commands and expected responses:\n\nHELP       214\nHELO       250\nMAIL FROM  250\nRCPT TO    250\nDATA       354\n.          250\nQUIT       221\n\n*/\n\n#define _TCP31_PROTOS\n\n#include <bsdtypes.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include <manifest.h>\n#include <socket.h>\n#include <in.h>\n#include <netdb.h>\n\n#define  Bool                 int\n#ifndef  TRUE\n#define  TRUE                 (Bool)1\n#endif\n#ifndef  FALSE\n#define  FALSE                (Bool)0\n#endif\n#define  NULL_CHARACTER       ('\\0')\n#define  READ_BYTES           1024\n#define  MYBUF_INITIAL_SIZE   1024\n#define  MYBUF_INCREMENT      512\n#define  IBUF_MSGSIZE         1024\n#define  OBUF_MSGSIZE         1024\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  SOCKET_READ_NOTHING  (-3)\n\n#define  ASCII_CR             (0x0d)\n#define  ASCII_LF             (0x0a)\n#define  EBCDIC_CR            ('\\r')\n#define  EBCDIC_LF            (0x25)\n\n#ifdef MVS\n#define  etoa(x)              ebcdictoascii[x]\n#define  atoe(x)              asciitoebcdic[x]\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\nextern   char                 ebcdictoascii[];\nextern   char                 asciitoebcdic[];\n#endif\n\n#ifdef MVSOE\n#define  etoa(x)              __etoa(x)\n#define  atoe(x)              __atoe(x)\n#endif\n\nenum server_retval {\n                    SERVER_OK,\n                    SERVER_READ_ERROR,\n                    SERVER_BUFFER_ERROR,\n                    SERVER_NO_MORE,\n                    SERVER_READ_NOTHING\n                   };\n\n /********************************************************************/\n /*                                                                  */\n /* Error handler.                                                   */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\nerrhand(whats,whatn)\nchar            *whats;\nint              whatn;\n{\n fprintf(stderr,\"\\nError: %s returned %d\\n\",whats,whatn);\n return;\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Input one character from the server.                             */\n /*                                                                  */\n /********************************************************************/\n\nstatic int\nsocket_getchar(ns,dont_read)\n int                   ns;\n Bool                  dont_read;\n {\n  static int           bytes_returned = 0;\n  static char          g_buf[READ_BYTES];\n  static int           g_buf_index = -1;\n         int           readrc;\n\n  if (g_buf_index == -1 || g_buf_index >= bytes_returned-1) {\n    g_buf_index = -1;\n    if (dont_read) return(SOCKET_NO_MORE);\n    else {\n      readrc = read(ns, g_buf, READ_BYTES);\n      if (readrc == -1)     return SOCKET_GETCHAR_ERROR;\n      else if (readrc == 0) return SOCKET_READ_NOTHING;\n      else {\n            g_buf[readrc] = NULL_CHARACTER;\n            bytes_returned = readrc;\n           }\n    }\n  }\n  return g_buf[++g_buf_index];\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Input one line of data from the server.                          */\n /*                                                                  */\n /********************************************************************/\n\nstatic enum server_retval\nsocket_in(ns,i_buf,n_bytes,delimiter,dont_read)\n int                   ns;\n char                 *i_buf;\n int                   n_bytes;\n char                  delimiter;\n Bool                  dont_read;\n {\n  int                  i_buf_index;\n  int                  character;\n\n  /* Get characters from the server until delimiter is reached. */\n\n  i_buf_index = 0;\n  while ((character = socket_getchar(ns,dont_read)) != delimiter) {\n    if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);\n    if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);\n    if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_NOTHING);\n    if (i_buf_index >= n_bytes) {\n      fprintf(stderr,\"Warning: The buffer passed to socket_in overflowed.\\n\");\n      fprintf(stderr,\" More than %d bytes collected without %2.2x seen.\\n\",\n             n_bytes,delimiter);\n      fprintf(stderr,\" Returning what we have so far.\\n\");\n      break;\n    }\n    i_buf[i_buf_index++] = (unsigned char)character;\n  }\n  i_buf[i_buf_index] = NULL_CHARACTER;\n\n#ifdef MVS\n  {\n   int i;\n   for (i=0;i<i_buf_index;i++) i_buf[i] = atoe(i_buf[i]);\n  }\n#endif\n\n#ifdef MVSOE\n  __atoe(i_buf);  /* translate from ASCII to EBCDIC */\n#endif\n\n  return(SERVER_OK);\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Output one line of data to the server.                           */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\nsocket_out(ns,o_buf,n_bytes)\n int                   ns;\n char                 *o_buf;\n int                   n_bytes;\n {\n  int                  writrc;\n  int                  needed_bytes;\n  static char         *mybufp = NULL;\n  static int           mybufl = 0;\n\n  needed_bytes = n_bytes+2;\n\n  if (mybufp == NULL) {\n    mybufl = MYBUF_INITIAL_SIZE;\n    mybufp = (char *)malloc(mybufl);\n  }\n\n  if (mybufl < needed_bytes) {\n    mybufl = needed_bytes + MYBUF_INCREMENT;\n    free(mybufp);\n    mybufp = (char *)malloc(mybufl);\n  }\n\n  if (mybufp == NULL) {\n    fprintf(stderr,\"\\nWhoops, failed to allocate output buffer!\\n\");\n    abort();\n  }\n\n  memcpy(mybufp,o_buf,n_bytes);\n\n  mybufp[n_bytes] = NULL_CHARACTER;\n\n#ifdef MVS\n  {\n   int i;\n   for (i=0;i<=n_bytes+1;++i) mybufp[i] = etoa(mybufp[i]);\n  }\n#endif\n\n#ifdef MVSOE\n  __etoa(mybufp);\n#endif\n\n  mybufp[n_bytes  ] = ASCII_CR;\n  mybufp[n_bytes+1] = ASCII_LF;\n\n  writrc = write(ns, mybufp, n_bytes+2);\n  if (writrc < 0) errhand(\"write\",writrc);\n\n  return;\n }\n\n /********************************************************************/\n /*                                                                  */\n /* Send something to the server.                                    */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\nsend_it(s,string,variable,echo)\nint   s;\nchar *string;\nchar *variable;\nBool  echo;\n{\n char               ibuf[IBUF_MSGSIZE];    /* the input buffer       */\n\n if (string) {\n\n  sprintf(ibuf,string,variable);\n  if (echo) {\n    fprintf(stderr,\"Sending:'%s'\\n\",ibuf);\n  }\n  socket_out(s,ibuf,strlen(ibuf));\n\n }\n\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Receive something from the server.                               */\n /*                                                                  */\n /********************************************************************/\n\nstatic Bool\nreceive_it(s,obuf,verbose)\nint   s;\nchar *obuf;\nBool  verbose;\n{\n enum server_retval socket_in_rc;\n char              *cp;\n Bool               got_something_from_server;\n\n socket_in_rc = socket_in(s,obuf,OBUF_MSGSIZE, ASCII_LF, FALSE);\n\n switch (socket_in_rc) {\n  case SERVER_OK:\n            got_something_from_server = TRUE;\n            break;\n  case SERVER_READ_NOTHING:\n            got_something_from_server = FALSE;\n            break;\n  case SERVER_NO_MORE:\n            got_something_from_server = FALSE;\n            break;\n  case SERVER_READ_ERROR:\n            fprintf(stderr,\"\\n\\nRead error, lost connection.\\n\\n\");\n            got_something_from_server = FALSE;\n            break;\n  case SERVER_BUFFER_ERROR:\n            fprintf(stderr,\"\\n\\nServer buffer error\\n\\n\");\n            got_something_from_server = FALSE;\n            break;\n };\n\n if (!got_something_from_server) return FALSE;\n\n cp = obuf + strlen(obuf) - 1;\n if (cp >= obuf) {\n   if (*cp == EBCDIC_CR) *cp = NULL_CHARACTER;\n }\n if (verbose) {\n  printf(\"%s\\n\",obuf);\n }\n\n return TRUE;\n\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Tell server.                                                     */\n /*                                                                  */\n /********************************************************************/\n\nstatic void\ntell_server(s,obuf,textmode,verbose,string,variable)\nint   s;\nchar *obuf;\nBool  textmode;\nBool  verbose;\nchar *string;\nchar *variable;\n{\n\n send_it(s,string,variable,(!textmode && verbose));\n\n if (!textmode) {\n  while (1) {\n   receive_it(s,obuf,verbose);\n   if (strlen(obuf) > 3) {\n     if (obuf[3] == '-') continue;\n   }\n   break;\n  }\n }\n\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Send file.                                                       */\n /*                                                                  */\n /********************************************************************/\n\nstatic int\nsend_file(s,obuf,filename,hostname,verbose,quickquit)\nint   s;\nchar *obuf;\nchar *filename;\nchar *hostname;\nBool  verbose;\nBool  quickquit;\n{\n int   exitrc = 0;\n FILE *fp;\n char *bp;\n char *cp;\n Bool  textmode = FALSE;\n Bool  piped    = FALSE;\n Bool  errors   = FALSE;\n Bool  needtext = FALSE;\n char *er;\n char  buf[2048];\n\n if (!filename) {\n  filename = \"<standard input>\";\n  piped = TRUE;\n  fp = stdin;\n }\n else {\n  fp = fopen(filename,\"r\");\n }\n if (!fp) {\n   perror(filename);\n   return 12;\n }\n\n tell_server (s,obuf,FALSE,verbose,NULL,\"\");\n\n textmode = FALSE;\n\n for (;;) {\n   errors = FALSE;\n   needtext = FALSE;\n   memset(buf,0,2048);\n   bp = buf;\n   if (!fgets(bp, sizeof(buf), fp)) break;\n   if (feof(fp)) bp = \"QUIT\";\n   if (ferror(fp)) {\n     fprintf(stderr,\"*** Error - read error on file: %s\", filename);\n     break;\n   }\n   if ((cp = strchr(bp,'\\n'))) *cp = NULL_CHARACTER;\n   if (!strcmp(bp,\".\")) textmode = FALSE;\n   tell_server (s,obuf,textmode,verbose,\"%s\",bp);\n   if (textmode) {\n     /* */\n   }\n   else {\n    if      (!memcmp(bp,\"HELO\",4))  er = \"250\";\n    else if (!memcmp(bp,\"HELP\",4))  er = \"214\";\n    else if (!memcmp(bp,\"HELO\",4))  er = \"250\";\n    else if (!memcmp(bp,\"MAIL\",4))  er = \"250\";\n    else if (!memcmp(bp,\"RCPT\",4))  er = \"250\";\n    else if (!memcmp(bp,\"DATA\",4)) {er = \"354\"; needtext = TRUE;}\n    else if (!memcmp(bp,\"QUIT\",4))  er = \"221\";\n    else er = NULL;\n   }\n   if (!memcmp(obuf,\"354\",3))       textmode = TRUE;\n   if (!memcmp(obuf,\"250\",3))       textmode = FALSE;\n   if (!memcmp(obuf,\"221\",3))       break;\n   if (!textmode) {\n    if (*obuf != '2')               errors = TRUE;\n    if (er && memcmp(obuf,er,3))    errors = TRUE;\n   }\n\n   if (errors) {\n     exitrc = 1;\n     fprintf(stderr,\"An error occurred while communicating with the\\n\");\n     fprintf(stderr,\"SMTP server.  The command was:\\n\");\n     fprintf(stderr,\"\\n%s\\n\\n\", bp);\n     fprintf(stderr,\"And the response from the server was:\\n\");\n     fprintf(stderr,\"\\n%s\\n\\n\", obuf);\n     if (quickquit || needtext) {\n      tell_server (s,obuf,FALSE,verbose,\"QUIT\",\"\");\n      break;\n     }\n   }\n\n }\n\n if (!piped) (void)fclose(fp);\n\n return exitrc;\n\n}\nstatic void\nusage(x)\nchar *x;\n{\n\n fprintf(stderr,\"Usage: %s [-v] [-q] [-m mailhostname] [file]\\n\",x);\n\n}\n\n /********************************************************************/\n /*                                                                  */\n /* Client routine.                                                  */\n /*                                                                  */\n /********************************************************************/\n\nint\nmain(argc,argv)\nint               argc;\nchar            **argv;\n{\n int                exitrc = 0;\n int                port = 25;      /* port for the SMTP protocol  */\n int                i;\n int                j;\n char              *hostname  = \"mailhost\";\n char              *mailfrom  = NULL;\n char              *mailto    = NULL;\n char              *filename  = NULL;\n char              *cp;\n int                nbytes;         /* size of message buffer        */\n int                hostaddress;\n char               client_hostname[80];\n struct hostent    *hp;\n struct hostent    *server_hostent;\n struct sockaddr_in consock;        /* used by connect               */\n char               obuf[OBUF_MSGSIZE];    /* the output buffer      */\n int                consocklen;     /* used by connect               */\n int                s;              /* the socket descriptor         */\n int                backlog;        /* queue length                  */\n int                listrc;         /* the return code from listen   */\n int                connrc;         /* the return code from connect  */\n int                readrc;         /* the return code from read     */\n int                writrc;         /* the return code from write    */\n Bool               argerror = FALSE;\n Bool               verbose = FALSE;\n Bool               quickquit = FALSE;\n Bool               expecting_mailhost = FALSE;\n\n setenv(\"_EDC_ZERO_RECLEN\",\"Y\",1); /* allow zero-length input records*/\n\n hostname = \"mailhost\";\n\n for (i=1; i<argc; i++) {\n  if (expecting_mailhost) {\n   expecting_mailhost = FALSE;\n   hostname = argv[i];\n  }\n  else if (argv[i][0] == '-') {\n   for (j=1; argv[i][j]; j++) {\n    switch (argv[i][j]) {\n     case 'q':   quickquit = TRUE; break;\n     case 'v':   verbose   = TRUE; break;\n     case 'm':   expecting_mailhost = TRUE; break;\n     default:\n                 fprintf(stderr,\"%s: invalid option %c\\n\",\n                                argv[0], argv[i][j]);\n                 argerror = TRUE;\n    }\n   }\n  }\n  else {\n   if (filename) {\n    fprintf(stderr,\"%s: too many filenames specified\\n\",argv[0]);\n    argerror = TRUE;\n   }\n   else {\n    filename = argv[i];\n   }\n  }\n }\n\n if (expecting_mailhost) {\n  fprintf(stderr,\"%s: the -m flag must be followed by a mail host name.\\n\",\n                 argv[0]);\n  argerror = TRUE;\n }\n\n if (argerror) {\n  usage(argv[0]);\n  exit(1);\n }\n\n port = 25;\n\n server_hostent = gethostbyname(hostname);\n if (!server_hostent) {\n    fprintf(stderr,\"Error:  gethostbyname doesn't know host %s\\n\",hostname);\n    exit(12);\n }\n if (!server_hostent) errhand(\"gethostbyname for server hostname\",0);\n\n consock.sin_family = AF_INET;\n consock.sin_port = port;\n consock.sin_addr.s_addr = *((int *)server_hostent->h_addr);\n\n gethostname(client_hostname,sizeof(client_hostname));\n hp = gethostbyname(client_hostname);\n if (!hp) errhand(\"gethostbyname for client hostname\",0);\n hostaddress = *((int *)(hp->h_addr_list[0]));\n\n s = socket(AF_INET, SOCK_STREAM, 0);\n if (s < 0) errhand(\"socket creation\",s);\n\n consocklen = sizeof(consock);\n connrc = connect(s, &consock, consocklen);\n\n if (connrc < 0) {\n   errhand(\"connect\",connrc);\n   exit(connrc);\n }\n\n exitrc = send_file (s,obuf,filename,hostname,verbose,quickquit);\n\n close(s);\n\n exit(exitrc);\n\n}\n\n./ ADD NAME=TSOPREF  0100-07332-07332-0900-00059-00059-00000-SEB\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n struct tcb  {\n              char           filler1[180];\n              struct jscb   *tcbjscb;\n             };\n\n struct jscb {\n              char           filler1[264];\n              struct pscb   *jscbpscb;\n              char           filler2[ 80];\n              struct jscb   *jscbact;\n             };\n\n struct pscb {\n              char           pscbuser [7];\n              char           pscbusrl;\n              char           filler1 [44];\n              struct upt    *pscbupt;\n             };\n\n struct upt  {\n              char           filler1 [16];\n              char           uptprefx [7];\n              char           uptprefl;\n             };\n\nmain() {\n char         userid[8];\n char         prefix[8];\n struct tcb  *tcbptr;\n struct pscb *pscbptr;\n struct upt  *uptptr;\n\n tcbptr  = *(struct tcb **)0x21c;\n pscbptr = tcbptr->tcbjscb->jscbact->jscbpscb;\n\n if (pscbptr == NULL) {\n   printf(\"TSO is not active.\\n\");\n   return;\n }\n\n uptptr  = pscbptr->pscbupt;\n\n memset(userid,0,8);\n memset(prefix,0,8);\n\n memcpy(userid,pscbptr->pscbuser,pscbptr->pscbusrl);\n\n memcpy(prefix,uptptr->uptprefx,uptptr->uptprefl);\n\n\n printf(\"TSO userid is '%s'\\n\",userid);\n printf(\"TSO prefix is '%s'\\n\",prefix);\n\n\n}\n./ ADD NAME=XGALLOC  0100-07332-07332-0900-00487-00487-00000-SEB\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/*\n ***********************************************************************\n *                                                                     *\n * This is not a main program, nor a subroutine to be linked into an   *\n * existing program, but a routine which is to be called from a        *\n * REXX exec as follows:                                               *\n *                                                                     *\n *  dsn = \"name.of.data.set\"  -- or null to create a temporary         *\n *  dnn = \"ddname\"            -- or null to generate a unique one      *\n *  disp = \"SHR\"              -- or \"OLD\", \"NEW\", \"FREE\" or \"DELETE\"   *\n *  msg1 = \"\"                 -- to be set with an error message       *\n *  msg2 = \"\"                 -- to be set with an error message       *\n *                                                                     *\n *  address LINKMVS \"XGALLOC DSN DDN DISP MSG1 MSG2\"                   *\n *                                                                     *\n *  In addition to possibly updating the indicated variables, this     *\n *  routine returns a return code, which becomes the value of \"RC\".    *\n *                                                                     *\n *  The purpose of this routine is to provide a way for REXX execs     *\n *  to perform allocation and unallocation of data sets from a non-TSO *\n *  environment.  The LINKMVS (or ATTCHMVS) interface allows it to     *\n *  update the specified REXX variables by setting values for the      *\n *  passed parameters without calling REXX routines directly.          *\n *                                                                     *\n *  Use of this routine requires TSO/REXX 3.46 or higher.              *\n *                                                                     *\n ***********************************************************************\n */\n\n#pragma environment(XGALLOC)\n#pragma linkage(ikjeff18,OS)\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <spc.h>\n\n/* #define FETCH  */\n#undef  FETCH\n\n#define  Bool                 char\n#ifndef  TRUE\n#define  TRUE                 1\n#endif\n#ifndef  FALSE\n#define  FALSE                0\n#endif\n\n#define  S99VRBAL  0x01             /* ALLOCATION                    */\n#define  S99VRBUN  0x02             /* UNALLOCATION                  */\n#define  S99VRBCC  0x03             /* CONCATENATION                 */\n#define  S99VRBDC  0x04             /* DECONCATENATION               */\n#define  S99VRBRI  0x05             /* REMOVE IN-USE                 */\n#define  S99VRBDN  0x06             /* DDNAME ALLOCATION             */\n#define  S99VRBIN  0x07             /* INFORMATION RETRIEVAL         */\n#define  S99NOCNV  0x40             /* ALLOC FUNCTION-DO NOT USE AN  */\n                                    /* EXISTING ALLOCATION TO SATISFY*/\n                                    /* THE REQUEST                   */\n#define  DALDDNAM   0x0001          /* DDNAME                        */\n#define  DALDSNAM   0x0002          /* DSNAME                        */\n#define  DALMEMBR   0x0003          /* MEMBER NAME                   */\n#define  DALSTATS   0x0004          /* DATA SET STATUS               */\n#define  DALNDISP   0x0005          /* DATA SET DISPOSITION          */\n#define  DALTRK     0x0007          /* TRACK SPACE TYPE              */\n#define  DALBLKLN   0x0009          /* BLOCK LENGTH                  */\n#define  DALPRIME   0x000a          /* PRIMARY SPACE ALLOCATION      */\n#define  DALSECND   0x000b          /* SECONDARY SPACE ALLOCATION    */\n#define  DALDIR     0x000c          /* DIRECTORY BLOCK ALLOCATION    */\n#define  DALSYSOU   0x0018          /* SYSOUT                        */\n#define  DALSFMNO   0x001a          /* SYSOUT FORMS NUMBER           */\n#define  DALCOPYS   0x001d          /* SYSOUT COPIES                 */\n#define  DALUCS     0x0029          /* UNIVERSAL CHARACTER SET       */\n#define  DALBLKSZ   0x0030          /* DCB BLOCKSIZE                 */\n#define  DALDSORG   0x003c          /* DATA SET ORGANIZATION         */\n#define  DALLRECL   0x0042          /* DCB LOGICAL RECORD LENGTH     */\n#define  DALRECFM   0x0049          /* DCB RECORD FORMAT             */\n#define  DALPERMA   0x0052          /* PERMANENTLY ALLOCATED ATTRIB  */\n#define  DALRTDDN   0x0055          /* RETURN DDNAME                 */\n#define  DALRTDSN   0x0056          /* RETURN DSNAME                 */\n#define  DALRTORG   0x0057          /* RETURN D.S. ORGANIZATION      */\n#define  DALSUSER   0x0058          /* SYSOUT REMOTE WORKSTATION     */\n#define  DUNDDNAM   0x0001          /* DDNAME                        */\n#define  DUNDSNAM   0x0002          /* DSNAME                        */\n#define  DUNUNALC   0x0007          /* UNALLOC OPTION                */\n#define  SHR        0x08\n#define  NEW        0x04\n#define  MOD        0x02\n#define  OLD        0x01\n#define  KEEP       0x08\n#define  DELETE     0x04\n#define  CATLG      0x02\n#define  UNCATLG    0x01\n#define  RECFM_F    0x80\n#define  RECFM_V    0x40\n#define  RECFM_U    0xc0\n#define  RECFM_D    0x20\n#define  RECFM_T    0x20\n#define  RECFM_B    0x10\n#define  RECFM_S    0x08\n#define  RECFM_A    0x04\n#define  RECFM_M    0x02\n#define  RECFM_FB   (RECFM_F | RECFM_B)\n#define  RECFM_VB   (RECFM_V | RECFM_B)\n#define  DSORG_PS   0x4000\n#define  DSORG_PO   0x0200\n\nenum disposition {DISP_SHR,DISP_OLD,DISP_MOD,\n                  DISP_NEW,DISP_KEEP,DISP_DELETE};\n\n#define uppercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);}\n\n#define copy_uppercase(A,B) {char *__cA,*__cB;\\\n                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\\\n                         *__cA = toupper(*__cB);\\\n                     *__cA='\\0';}\n\n#define set2(A,B)   *(short *)(A) = B\n#define set3(A,B)   memset(A,0,3); *(short *)(A+1) = B\n\nstruct _textunit {\n                  unsigned short         key;\n                  unsigned short         num;\n                  struct {\n                          unsigned short len;\n                          char           prm[80];\n                         }               ent;\n                 };\n\nstruct varstring {\n                  short   len;\n                  char    text[1];\n                 };\n\ntypedef struct _textunit TEXTUNIT;\ntypedef struct varstring VARSTRING;\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nallocfail(rc,p99,msg1,msg2)\nint            rc;\n__S99parms    *p99;\nchar          *msg1;\nchar          *msg2;\n{\n int           zero = 0;\n unsigned int  dfid = 0x40320000;\n struct {\n         short first_level_msg_len;\n         short first_level_msg_offset;\n         char  first_level_msg[251];\n         short second_level_msg_len;\n         short second_level_msg_offset;\n         char  second_level_msg[251];\n        }      dfbuffer;\n\n static int (*ikjeff18_pointer)() = NULL;\n\n#ifndef FETCH\n extern int *ikjeff18();\n#endif\n\n strcpy(msg1,\"\");\n strcpy(msg2,\"\");\n\n if (!ikjeff18_pointer) {\n#ifdef FETCH\n   ikjeff18_pointer = (int (*)())fetch(\"IKJEFF18\");\n#else\n   ikjeff18_pointer = (int (*)())ikjeff18;\n#endif\n }\n\n dfbuffer.first_level_msg_len = 4;\n dfbuffer.second_level_msg_len = 4;\n\n if (ikjeff18_pointer) {\n   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {\n     strcpy(msg1,\"IKJEFF18 returned a nonzero return code\");\n   }\n   if (dfbuffer.first_level_msg_len > 0) {\n     strncpy(msg1, dfbuffer.first_level_msg,\n                   dfbuffer.first_level_msg_len-4);\n   }\n   if (dfbuffer.second_level_msg_len > 0) {\n     strncpy(msg2, dfbuffer.second_level_msg,\n                   dfbuffer.second_level_msg_len-4);\n   }\n }\n else {\n#ifdef FETCH\n   strcpy(msg1,\"xgalloc cannot fetch IKJEFF18\");\n#else\n   strcpy(msg1,\"IKJEFF18 was not linked with xgalloc\");\n#endif\n }\n return;\n}\n\n/*--------------------------------------------------------------------*/\n\nstatic void\nsetmsg(msgvar,string)\nVARSTRING *msgvar;\nchar  *string;\n{\n\n msgvar->len = strlen(string);\n memcpy(msgvar->text,string,msgvar->len);\n return;\n}\n\n/*--------------------------------------------------------------------*/\n\nint\nXGALLOC()\n{\n VARSTRING      **reg1;\n VARSTRING       *dsnvar;\n VARSTRING       *ddnvar;\n VARSTRING       *dispvar;\n VARSTRING       *msg1var;\n VARSTRING       *msg2var;\n int              i;\n int              rc;\n int              disp99_1;\n int              disp99_2;\n Bool             unal;\n enum disposition disp;\n short            primary_allocation    = 0;\n short            secondary_allocation  = 0;\n short            directory_blocks      = 0;\n short            dsorg                 = 0;\n char             recfm                 = 0;\n short            lrecl                 = 0;\n short            blocksize             = 0;\n __S99parms       stuff99; /* No \"struct\", despite manual */\n TEXTUNIT        *return_dsname_tup = NULL;\n TEXTUNIT        *return_ddname_tup = NULL;\n TEXTUNIT        *tup [32];\n TEXTUNIT         tu  [32];\n char            *lparp;\n char            *rparp;\n char             dsname  [81];\n char             ddname   [9];\n char             dispname [9];\n char             member  [81];\n char             msg1   [256];\n char             msg2   [256];\n\n reg1 = (VARSTRING **)edcxregs(1);\n\n dsnvar  = reg1[0];\n ddnvar  = reg1[1];\n dispvar = reg1[2];\n msg1var = reg1[3];\n msg2var = reg1[4];\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n strcpy(msg1,\"\");\n strcpy(msg2,\"\");\n\n if (dsnvar->len > 56) {\n   setmsg(msg1var,\"DSNAME argument cannot be longer than 56\");\n   return 16;\n }\n if (ddnvar->len > 8) {\n   setmsg(msg1var,\"DDNAME argument cannot be longer than 8\");\n   return 16;\n }\n if (dispvar->len > 8) {\n   setmsg(msg1var,\"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE\");\n   return 16;\n }\n\n strncpy(dsname,dsnvar->text,dsnvar->len);\n strncpy(ddname,ddnvar->text,ddnvar->len);\n strncpy(dispname,dispvar->text,dispvar->len);\n uppercase_in_place(dsname);\n uppercase_in_place(ddname);\n uppercase_in_place(dispname);\n\n if      (!strcmp(dispname,\"SHR\"))    disp = DISP_SHR;\n else if (!strcmp(dispname,\"OLD\"))    disp = DISP_OLD;\n else if (!strcmp(dispname,\"MOD\"))    disp = DISP_MOD;\n else if (!strcmp(dispname,\"NEW\"))    disp = DISP_NEW;\n else if (!strcmp(dispname,\"FREE\"))   disp = DISP_KEEP;\n else if (!strcmp(dispname,\"KEEP\"))   disp = DISP_KEEP;\n else if (!strcmp(dispname,\"DELETE\")) disp = DISP_DELETE;\n else {\n   setmsg(msg1var,\"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE\");\n   return 16;\n }\n\n switch (disp) {\n   case DISP_SHR:     unal=FALSE; disp99_1=SHR; disp99_2=KEEP; break;\n   case DISP_OLD:     unal=FALSE; disp99_1=OLD; disp99_2=KEEP; break;\n   case DISP_MOD:     unal=FALSE; disp99_1=MOD; disp99_2=CATLG; break;\n   case DISP_NEW:     unal=FALSE; disp99_1=NEW; disp99_2=CATLG; break;\n   case DISP_KEEP:    unal=TRUE; disp99_2=KEEP; break;\n   case DISP_DELETE:  unal=TRUE; disp99_2=DELETE; break;\n }\n\n switch (disp) {\n   case DISP_MOD:\n   case DISP_NEW:\n                 primary_allocation   = 100;\n                 secondary_allocation = primary_allocation;\n                 dsorg                = DSORG_PS;\n                 recfm                = RECFM_VB;\n                 lrecl                = 256;\n                 blocksize            = 23440;\n                 break;\n }\n\n strcpy(member,\"\");\n lparp = strchr(dsname,'(');\n rparp = strchr(dsname,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsname the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n }\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = unal ? S99VRBUN : S99VRBAL;\n stuff99.__S99FLAG1  = S99NOCNV << 8;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tup;\n stuff99.__S99FLAG2  = 0;\n\n for (i=0; i<32; i++) tup[i] = &tu[i];\n\n i = 0;\n\n if (*dsname) {\n   tu[i].key        = unal ? DUNDSNAM : DALDSNAM;\n   tu[i].num        = 1;\n   tu[i].ent.len    = strlen(dsname);\n   copy_uppercase(tu[i].ent.prm,dsname);\n   i++;\n }\n else if (!unal) {\n   tu[i].key        = DALRTDSN;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 44;\n   memset(tu[i].ent.prm,' ',44);\n   return_dsname_tup = &tu[i];\n   i++;\n }\n if (*member) {\n   tu[i].key        = DALMEMBR;\n   tu[i].num        = 1;\n   tu[i].ent.len    = strlen(member);\n   copy_uppercase(tu[i].ent.prm,member);\n   i++;\n }\n if (*ddname) {\n   tu[i].key        = unal ? DUNDDNAM : DALDDNAM;\n   tu[i].num        = 1;\n   tu[i].ent.len    = strlen(ddname);\n   copy_uppercase(tu[i].ent.prm,ddname);\n   i++;\n   if (!unal) {\n     tu[i].key      = DALPERMA;\n     tu[i].num      = 0;\n     i++;\n   }\n }\n else if (!unal) {\n   tu[i].key        = DALRTDDN;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 8;\n   memset(tu[i].ent.prm,' ',8);\n   return_ddname_tup = &tu[i];\n   i++;\n }\n if (unal) {\n   tu[i].key        = DUNUNALC;\n   tu[i].num        = 0;\n   i++;\n }\n else {\n   tu[i].key        = DALSTATS;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 1;\n   tu[i].ent.prm[0] = disp99_1;\n   i++;\n   tu[i].key        = DALNDISP;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 1;\n   tu[i].ent.prm[0] = disp99_2;\n   i++;\n }\n if (recfm) {\n   tu[i].key        = DALRECFM;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 1;\n   tu[i].ent.prm[0] = recfm;\n   i++;\n }\n if (lrecl) {\n   tu[i].key        = DALLRECL;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 2;\n   set2(tu[i].ent.prm,lrecl);\n   i++;\n }\n if (blocksize) {\n   tu[i].key        = DALBLKSZ;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 2;\n   set2(tu[i].ent.prm,blocksize);\n   i++;\n }\n if (blocksize) {\n   tu[i].key        = DALBLKLN;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 3;\n   set3(tu[i].ent.prm,blocksize);\n   i++;\n }\n if (primary_allocation) {\n   tu[i].key        = DALPRIME;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 3;\n   set3(tu[i].ent.prm,primary_allocation);\n   i++;\n }\n if (secondary_allocation) {\n   tu[i].key        = DALSECND;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 3;\n   set3(tu[i].ent.prm,secondary_allocation);\n   i++;\n }\n if (dsorg) {\n   tu[i].key        = DALDSORG;\n   tu[i].num        = 1;\n   tu[i].ent.len    = 2;\n   set2(tu[i].ent.prm,dsorg);\n   i++;\n }\n\n tup[i] = (void *)0x80000000;\n\n rc = svc99(&stuff99);\n\n if (rc == 0) {\n   if (return_dsname_tup) {\n     memcpy(dsnvar->text,(char *)return_dsname_tup->ent.prm,64);\n     dsnvar->len = return_dsname_tup->ent.len;\n   }\n   if (return_ddname_tup) {\n     memcpy(ddnvar->text,(char *)return_ddname_tup->ent.prm,8);\n     ddnvar->len = return_ddname_tup->ent.len;\n   }\n }\n else {\n   allocfail(rc,&stuff99,msg1,msg2);\n }\n setmsg(msg1var,msg1);\n setmsg(msg2var,msg2);\n return rc;\n}\n\n./ ADD NAME=XPASTE   0100-07332-07332-0900-00087-00087-00000-SEB\n\n#include <stdio.h>\n#include <X11/Xlib.h>\n#include <X11/Xutil.h>\n\n\n#ifdef MVS\n#define  LF           0x25\n#else\n#define  LF           0x0a\n#endif\n\nint\nmain(argc, argv)\nint  argc;\nchar **argv;\n{\n    Display       *mydisplay;\n    int            nbytes_return;\n    char          *bytes_return;\n    short          b;\n    char          *server;\n    int            buffer;\n\n /* if (argc <= 1) {\n  *  fprintf(stderr,\"%s: A display host must be specified.\\n\",\n  *                 argv[0]);\n  *  exit(1);\n  * }\n  */\n /* If no display given, use the display in XWINDOWS.DISPLAY. */\n\n    server = (argc > 1) ? argv[1] : NULL;\n\n    mydisplay = XOpenDisplay(server);\n\n    if (mydisplay == NULL) {\n        fprintf(stderr, \"%s: unable to open display '%s'\\n\",\n                        argv[0], XDisplayName(server));\n        exit(1);\n    }\n\n    bytes_return = XFetchBytes(mydisplay, &nbytes_return);\n\n    if (bytes_return) {\n      for (b = 0; b < nbytes_return; b++) {\n        char bp = bytes_return[b];\n        switch (bp) {\n          case LF:   putchar('\\n');\n                     break;\n          default:\n                     putchar(bp);\n                     break;\n        }\n      }\n    }\n    else\n         fprintf(stderr,\"%s: Nothing in %s's cut buffer.\\n\",\n                        argv[0],XDisplayName(server));\n\n    if (bytes_return) XFree(bytes_return);\n\n /*\n  * for (buffer = 0; buffer < 8; buffer++) {\n  *   bytes_return = XFetchBuffer(mydisplay, &nbytes_return, buffer);\n  *   if (bytes_return) {\n  *     printf(\"\\nContents of cut buffer %d:\\n\\n\",buffer);\n  *     for (b = 0; b < nbytes_return; b++) {\n  *       switch (bytes_return[b]) {\n  *         case 0x25: printf(\"\\n\");\n  *                    break;\n  *         default:\n  *                    printf(\"%c\",bytes_return[b]);\n  *                    break;\n  *       }\n  *     }\n  *   }\n  *   else\n  *        fprintf(stderr,\"\\nNothing in cut buffer %d.\\n\",buffer);\n  *   if (bytes_return) XFree(bytes_return);\n  * }\n  */\n\n    XCloseDisplay(mydisplay);\n\n    return 0;\n}\n./ ADD NAME=X800     0100-07332-07332-0900-00083-00083-00000-SEB\n#define LOOPFOR(i) for(i=0;i<3;i++)\n#include <stdio.h>\nchar choices[10][3];\nmain(argc,argv)\n int argc;\n char **argv;\n{\n char number[10];\n int i;\n int j;\n char *letters();\n void prtword();\n\n if (argc != 2) {\n   fprintf(stderr,\"Exactly 1 argument required.\\n\");\n   return;\n }\n else strcpy(number,argv[1]);\n printf(\"For number: %s\\n\",number);\n for (i=0; i<strlen(number); i++) {\n  strcpy(choices[i],letters(number[i]));\n }\n{int i1,i2,i3,i4,i5,i6,i7;\n int output_count = 0;\n LOOPFOR(i1)\n LOOPFOR(i2)\n LOOPFOR(i3)\n LOOPFOR(i4)\n LOOPFOR(i5)\n LOOPFOR(i6)\n LOOPFOR(i7)\n     prtword(i1,i2,i3,i4,i5,i6,i7,&output_count);\n }\n printf(\"\\n\");\n}\n\nvoid prtword(one, two, three, four,\n             five, six, seven, count)\n     int one,two,three,four,five,six,seven;\n     int *count;\n{\n printf(\"%c%c%c%c%c%c%c \",choices[0][one],choices[1][two],\n        choices[2][three],choices[3][four],choices[4][five],\n        choices[5][six], choices[6][seven]);\n if ((*count += 8) > 79) {\n     printf(\"\\n\");\n     *count = 0;\n   }\n }\n\n char *letters(n) int n; {\n  char result[3];\n  switch(n) {\n     case '2':\n      strcpy(result,\"ABC\");\n      break;\n     case '3':\n      strcpy(result,\"DEF\");\n      break;\n     case '4':\n      strcpy(result,\"GHI\");\n      break;\n     case '5':\n      strcpy(result,\"JKL\");\n      break;\n     case '6':\n      strcpy(result,\"MNO\");\n      break;\n     case '7':\n      strcpy(result,\"PRS\");\n      break;\n     case '8':\n      strcpy(result,\"TUV\");\n      break;\n     case '9':\n      strcpy(result,\"WXY\");\n      break;\n     default:\n      strcpy(result,\"?!>\");\n    }\n  return result;\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLIST": {"ttr": 16897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00+\\x84+\\x84\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 11140, "newlines": 11140, "modlines": 0, "user": "SEB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "H": {"ttr": 21257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00008-00008-00000-SEB\n------------------------------------------------------------------------\nName:     GSVC\nType:     C\nPurpose:  defines for use with svc()\nRequires:\nUsed by:  C XGSVC\nComments:\n------------------------------------------------------------------------\n./ ADD NAME=GSVC     0100-07332-07332-0900-00022-00022-00000-SEB\n/* gsvc.h - definitions for use with svc()\n *\n *  Usage:   SVC(SVC_NUMBER   svcnumber,\n *               SVC_REGISTER register15,\n *               SVC_REGISTER register0,\n *               SVC_REGISTER register1)\n *\n */\n\n#define SVC_NUMBER             unsigned char\n#define SVC_REGISTER_CONTENTS  unsigned int\n#define SVC_REGISTER           SVC_REGISTER_CONTENTS *\n\n#define SVC(_num,_r15,_r00,_r01) xgsvc((SVC_NUMBER)     (_num),\\\n                                       (SVC_REGISTER *) (_r15),\\\n                                       (SVC_REGISTER *) (_r00),\\\n                                       (SVC_REGISTER *) (_r01))\nextern void xgsvc(SVC_NUMBER,\n                  SVC_REGISTER *,\n                  SVC_REGISTER *,\n                  SVC_REGISTER *);\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELP": {"ttr": 21259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x03R\\x03R\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 850, "newlines": 850, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00079-00079-00000-SEB\n------------------------------------------------------------------------\nName:     ALLOCLNK\nType:     HELP\nPurpose:  TSO help for ALLOCLNK clist\nRequires: CLIST ALLOCLNK\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     CLIST\nType:     CLIST\nPurpose:  TSO help for CLIST clist\nRequires: CLIST CLIST\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     COMP\nType:     HELP\nPurpose:  TSO help for COMP clist\nRequires: CLIST COMP (q.v.)\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     DU\nType:     HELP\nPurpose:  TSO help for DU clist\nRequires: CLIST DU (q.v.)\nUsed by:\nComments:\n------------------------------------------------------------------------\nName:     FINDMEM\nType:     CLIST\nPurpose:  Display PDS's that contain a given member name.\nRequires: XPROC ASM\n          XFINDM ASM (but see Comments)\n          XLINKLST ASM\nUsed by:\nComments: When there are too many libraries in the linklist (for when\n          no DDNAME is given), or too many datasets allocated to a given\n          DDNAME, ABEND S013-E4 results due to too many extents.  Hence\n          the FINDMEM2 CLIST.\n------------------------------------------------------------------------\nName:     FINDMEM2\nType:     CLIST\nPurpose:  Used internally by the FINDMEM CLIST.\nRequires: LA CLIST\n          XWRITENR ASM\nUsed by:  FINDMEM\nComments: Used in place of XFINDM program\n          See comments under FINDMEM above.\n------------------------------------------------------------------------\nName:     LA\nType:     CLIST\nPurpose:  Display current file allocations and/or generate JCL therefrom\nRequires:\nUsed by:  FINDMEM2\nComments: Part of the RENIX suite and contains relevant code thereto.\n          Requires SWA=BELOW.\n------------------------------------------------------------------------\nName:     Q\nType:     CLIST\nPurpose:  TSO HELP for Q clist\nRequires: CLIST Q (q.v.)\nUsed by:\nComments:\n------------------------------------------------------------------------\n------------------------------------------------------------------------\nName:     XLNKLST\nType:     HELP\nPurpose:  TSO help for XLNKLST command\nRequires: ASM XLNKLST\nUsed by:  (See ASM XLNKLST)\nComments: (See ASM XLNKLST)\n------------------------------------------------------------------------\nName:     XPROC\nType:     HELP\nPurpose:  TSO help for XPROC command\nRequires: ASM XPROC\nUsed by:  (See ASM XPROC)\nComments: Help file contains references to local Draper facilities.\n./ ADD NAME=ALLOCLNK 0100-07332-07332-0900-00033-00033-00000-SEB\n)F Function -\n\n   The ALLOCLNK CLIST allocates the system link list.\n\n   Note 1:  This command requires MVS/SP2.1 (XA) with LLA (link list\n            lookaside) to be installed.\n\n   Note 2:  Even though the command functions successfully, using the\n            generated DD concatenation can result in an S013-E4 ABEND\n            if your installation has many LPA and link list libraries.\n\n)X Syntax -\n\n   ALLOCLNK\n              FILE('file name')\n              LPA\n\n   Required:  none\n\n   Defaults:\n              FILE(SYSLIB)\n              LPA defaults to null\n\n)O Operands -\n\n))FILE(SYSLIB)   - the file name to which the link list libraries\n                   are to be allocated.  It will be reused if it is\n                   already allocated.\n\n))LPA            - If LPA is specified, 'SYS1.LPALIB' is included as\n                   the first library in the concatenation; otherwise\n                   'SYS1.LPALIB' is not used.\n\n./ ADD NAME=CLIST    0100-07332-07332-0900-00049-00049-00000-SEB\n)F Function -\n\n   The CLIST CLIST places you into an interactive TSO mode under which\n   you can enter TSO commands and a subset of command procedure (CLIST)\n   statements, using symbolic substitution and system CLIST variables.\n   Under ISPF it may be used to go into quasi-READY line mode in order\n   to enter multiple TSO commands without full-screen interaction; in\n   addition, it provides a way to type in the ISPEXEC command without\n   creating a CLIST to contain it.\n\n   This is useful for testing CLIST functions without writing a\n   temporary CLIST for that purpose; it is also useful to take\n   advantage of symbolic substitution and variable services in\n   quasi-READY mode.\n\n   You will be prompted for commands interactively until you enter /*\n   or a command that terminates the CLIST (like END or EXIT).\n\n   Entering a single equal sign = causes the last TSO command to be\n   re-executed.\n\n   Entering a double equal sign == causes the last TSO command to be\n   redisplayed so that you may modify it by overtyping and re-execute.\n\n   The following command procedure statements are permitted:\n\n     ATTN\n     CONTROL   (note:  CONTROL options cannot be abbreviated)\n     ERROR     (note:  there is an error exit in effect initially)\n     EXIT\n     LISTDSI\n     SET\n     SYSCALL   (but there isn't any subprocedure to call)\n     TERMIN\n     WRITE\n     WRITENR\n     OPENFILE\n     GETFILE\n     PUTFILE\n     CLOSFILE\n\n   These are not considered TSO commands and therefore cannot be\n   repeated via equal signs.\n\n)X Syntax -\n\n   %CLIST\n\n)O Operands - none\n./ ADD NAME=COMP     0100-07332-07332-0900-00084-00084-00000-SEB\n)F Function -\n\n   The COMP clist compares two datasets.\n\n)X Syntax -\n\n   COMP       'dsname1' 'dsname2'\n              VOL1('volume serial')\n              VOL2('volume serial')\n              OUTPUT('data set name'/*)\n              ISASIZE('number')\n              REPORT(''/NO)\n              NAME('module name')\n              START('column spec')\n              END('column spec')\n              MATCH / MISMATCH ('number')\n              REPLACE\n              REUSE\n\n   Required: 'dsname1' and 'dsname2'\n\n   Defaults:\n              VOL1     defaults to null\n              VOL2     defaults to null\n              OUTPUT(*)\n              ISASIZE(10)\n              REPORT(NO)\n              NAME(PLICOMP)\n              START(0)\n              END(0)\n              MATCH / MISMATCH (0)\n\n)O Operands -\n\n)P'dsname1'      - the first data set to be compared.\n\n)P'dsname2'      - the second data set to be compared.\n\n))VOL1           - the volume on which the first data set resides, if\n                   the data set is not cataloged.\n\n))VOL2           - the volume on which the second data set resides, if\n                   the data set is not cataloged.\n\n))OUTPUT         - the destination for the output.  Default is your\n                   TSO terminal.  If a data set name is specified, it\n                   is created using the ALLOCATE DCB parameters\n                   DSORG(PS) RECFM(V B A) LRECL(155) BLKSIZE(6233).\n\n))ISASIZE        - the ISASIZE value to be passed to the PL/1 program\n                   which does the compare.  Default is 10 (i.e. 10K).\n\n))REPORT         - Default is NO.  If REPORT('') is specified, then\n                   the REPORT parameter is passed to the PL/1 program\n                   which does the compare.  PL1DUMP or PLIDUMP must be\n                   allocated to get this report.\n\n))NAME           - The name of the PL/1 program invoked to do the\n                   compare.  Default is PLICOMP.  It must reside in the\n                   library 'SEB1525.PUB.LOAD' (you may change the name\n                   of the library by editing the CLIST).\n\n))START          - The starting column where the compare is to operate.\n                   If 0 is specified (which is the default), column 1\n                   is used as the starting column (thus 0 = 1).\n                   This operand may be used to prevent sequence numbers\n                   from being included in the compare for\n                   variable-length records (specify START(9)).\n\n))END            - The last column of the data to be compared.\n                   If 0 is specified (which is the default), the last\n                   column is used as the ending column.\n                   This operand may be used to prevent sequence numbers\n                   from being included in the compare for fixed-length\n                   records (e.g. END(72)).\n\n))MATCH          - Same as \"MISMATCH\".  Default is 0.\n\n))MISMATCH       - The number of records which will be buffered to\n                   detect insertions and/or deletions.  The higher\n                   this value is, the more storage will be required.\n                   Default is 0, which will detect no insertions or\n                   deletions.\n\n./ ADD NAME=COMPROC  0100-07332-07332-0900-00043-00043-00000-SEB\n)F Function -\n\n   The COMPROC clist compares a source CLIST with a PROCMAN-\"compiled\"\n   CLIST.\n\n   Two temporary data sets are created and deleted by COMPROC:\n\n    'prefix.clistname.COMPILED.CLIST'\n    'prefix.clistname.ORIGINAL.CLIST'\n\n   If either of these exists prior to invocation of COMPROC, COMPROC\n   will fail.\n\n)X Syntax -\n\n   COMPROC    'clistname'\n              MISMATCH('number')\n\n   Required: 'clistname'\n\n   Defaults:  MISMATCH(64)\n\n   Notes:     You are prompted to enter the names of the libraries\n              from which both CLIST's come.\n\n)O Operands -\n\n)P'clistname'    - the name of the CLIST (1 to 8 characters) to be\n                   compared.  You are prompted to enter the name of\n                   the CLIST library that contains the source CLIST\n                   (press ENTER to accept the default of the system\n                   CLIST library) and also to enter the name of the\n                   load library that contains the PROCMAN-\"compiled\"\n                   CLIST (press ENTER to accept the default of the\n                   system link list library that contains \"compiled\"\n                   CLIST's).  The named CLIST must exist in both\n                   libraries that you respond with.\n\n))MISMATCH       - the number of records which will be buffered by the\n                   compare program to detect insertions and/or\n                   deletions.  The higher this value is, the more\n                   storage will be required.  Default is 64.\n\n./ ADD NAME=DEPROC   0100-07332-07332-0900-00057-00057-00000-SEB\n)F Function -\n\n   The DEPROC clist \"decompiles\" a CLIST \"compiled\" by PROCMAN\n   (it will also decompile a CLIST invoked by EXEC).\n\n)X Syntax -\n\n   DEPROC 'clistname'/'clistdsn'\n          LOADLIB('library name')\n          OUTPUT('data set name'/*)\n\n   Required: 'clistname' or 'clistdsn'\n\n   Note:  You will be prompted to enter values for any required\n          positional parameters, although these values will not\n          be used.\n   Exception: If new keyword values are entered, these values\n          will be reflected in the decompiled PROC statement.\n\n   Examples:\n\n             DEPROC XPRINT\n             DEPROC 'CSD.CMD.CLIST(XPRINT)'\n             DEPROC CMD.CLIST(MYPROC)\n             DEPROC MYPROC LOADLIB(CMD.LOAD) OUTPUT(NEW.SOURCE.CLIST)\n\n)O Operands -\n\n)P'clistname' - (1) the name of the PROCMAN-\"compiled\" clist to be\n                decompiled (1-8 characters).  The clist must reside in\n                the load library specified by the LOADLIB operand\n                (whose default is the system link list load library\n                which contains \"compiled\" system CLIST's).\n                If the clistname is entered with a preceding percent\n                sign (%), the decompiler will restore percent signs\n                that were removed by PROCMAN's NOPERCENT option (except\n                for ISPEXEC SELECT CMD(%...)  percent signs).\n\n                Or...\n\n                (2) a data set name identifying a source CLIST to be\n                decompiled.  LOADLIB is ignored if this is specified.\n\n))LOADLIB     - the name of the library which contains the\n                PROCMAN-\"compiled\" CLIST to be decompiled (this is not\n                applicable if a source CLIST is to be decompiled).\n                Default is the system link list library which contains\n                PROCMAN-\"compiled\" system CLIST's.\n\n))OUTPUT      - the name of a new data set into which the decompiled\n                CLIST is written.  Default is your TSO terminal.\n                If the output is directed to the terminal, no sequence\n                numbers are generated.\n                If the output is directed to a data set, the data set\n                is created as new (it must not already exist), and\n                sequence numbers are generated.\n\n./ ADD NAME=DU       0100-07332-07332-0900-00054-00054-00000-SEB\n)F Function -\n\n   The DU exec displays basic information from the UCB of a\n   specified device, volume or group of devices.\n\n)X Syntax -\n\n   DU         'positional'\n\n   Required: none\n\n   Defaults: 'positional' defaults to * (meaning display all)\n\n   Examples:\n              DU *\n              DU TSVOL\n              DU A40\n              DU ***RES\n              DU 33*0\n              DU 3400\n              DU AUSCOM\n              DU C**\n\n)O Operands -\n\n)P'positional'   - one of the following:\n\n   Null, * or ALL - displays all devices.\n   AUSCOM         - displays all AUSCOM devices.\n   CAEDS / HFGD   - displays all devices of type HFGD.\n   volser         - displays volumes beginning with the string\n                    \"volser\".  Asterisks may be included in the string\n                    as wild cards.\n   unittype       - displays devices of the requested device type.\n                    Asterisks may be included in the string as\n                    wild cards.\n   cuu            - displays devices of the requested unit address.\n                    Asterisks may be included in the string as\n                    wild cards.\n\n   Some of these may be ambiguous.  In general, a string consisting\n   of numbers is assumed to be a unittype specification;\n   a 6-character string is assumed to be a volume serial;\n   a 3-character string with hex characters and asterisks is assumed\n   to be a unit address; otherwise a volume serial string is assumed.\n\n  The following information is displayed:\n\n    UCB address (only if PROFILE MSGID is active)\n    Volume serial\n    Unit address\n    Device type (in character)\n    Device type (in hex)\n\n./ ADD NAME=FINDMEM  0100-07332-07332-0900-00045-00045-00000-SEB\n)F Function -\n\n   The FINDMEM clist locates PDS members in the system link list\n   or in a preallocated concatenation of PDS's.\n\n   You do not specify a member name on the CLIST; instead,\n   you are prompted to enter member names (a null line terminates\n   the CLIST).  Since the location of each requested member is\n   determined by issuing a BLDL, only one PDS name will be\n   displayed; a search through the directories of all PDS's is\n   NOT done.\n\n   (Note: The above is no longer the case, since the underlying\n          program that does the search has been replace with a\n          CLIST that does the search, and also displays other\n          occurrences of the member name in the concatenation.)\n\n)X Syntax -\n\n   FINDMEM    'file'\n              LPA / NOLPA\n\n   Required: none\n\n   Defaults:  'file' defaults to system link list\n                     (including LPA unless NOLPA is specified)\n              LPA / NOLPA defaults to LPA\n\n)O Operands -\n\n)P'file'         - the name of a file currently allocated to one or\n                   more PDS's (a system file such as SYSPROC is\n                   perfectly acceptable).  If this operand is omitted\n                   or specified as *, the system link list plus the\n                   link pack area (SYS1.LPALIB), as defined by the\n                   LPA / NOLPA operand, is used.\n\n))LPA            - If LPA is specified, 'SYS1.LPALIB' is included as\n                   the first library in the concatenation, ahead of the\n                   system link list libraries.  This is the default,\n                   but is not applicable if a file name is specified.\n\n))NOLPA          - If NOLPA is specified, 'SYS1.LPALIB' is not included\n                   in the concatenation.\n\n./ ADD NAME=LA       0100-07332-07332-0900-00053-00053-00000-SEB\n)F Function -\n\n   la - list current file allocations, optionally with volumes, units,\n   dispositions, and/or data set attributes.  A ddname or group of\n   ddnames can be selected.\n\n)X Syntax -\n\n   la {-acjqsuv} {fn {fn}} ...\n\n      fn:   a filename or a filemask with *'s.\n\n   Options: -a   display DCB attributes from the JFCB\n            -c   display file concatenation numbers\n            -j   generate JCL card images\n            -q   queue output on stack instead of writing to output\n            -s   display disposition status (SHR, NEW, MOD, OLD)\n            -u   display volume and unit info\n            -v   display volume info only\n\n   Required:  none\n\n   Defaults:  If no fn's are specified, all files are shown.\n\n)O Operands -\n\n)P'fn'   - a filename (ddname), or a filemask (a ddname with asterisks\n           \"*\" in place of blank or nonblank characters).  Note that\n           this is not the same as filespec wildcarding.  If no fn's\n           are specified, all files are shown.\n\n))-A  - display DCB attributes from the JFCB.\n\n))-C  - display file concatenation numbers (zero-based) along with file\n        names.  Useful if piping the output through grep (e.g. to see\n        certain dsnames only), since concatenated file names show up\n        empty otherwise.\n\n))-J  - generate JCL images instead of information lines.  If this\n        option is selected, then it is as if -asuv was also given.\n        Files with a disposition other than SHR are generated as\n        JCL comments to prevent a potential batch job from being\n        hung up waiting for the TSO session to terminate.\n\n))-Q  - queue lines to data stack instead of outputting.  This can be\n        used in combination with -j to generate JCL for SUBMIT *.\n\n))-S  - show disposition status (SHR, NEW, MOD, OLD).\n\n))-U  - display volume and unit name information only\n\n))-V  - display volume serials only\n\n./ ADD NAME=Q        0100-07332-07332-0900-00031-00031-00000-SEB\n)F Function -\n\n   The Q clist displays system ENQ information.\n\n)X Syntax -\n\n   Q          'value'\n\n   Required:  none\n\n   Defaults:  user is prompted to enter ENQ parameters.\n\n   Examples:  Q C           to display all waits.\n              Q J=ABC1234   to see what ABC1234 is using.\n              Q SYSIKJUA    to see who is logged on to TSO.\n              Q ARCDSN      to see what HSM is migrating/recalling.\n              Q             to be prompted to enter parameters.\n\n)O Operands -\n\n)P'value'        - one of the following:\n\n                    C         - display all conflicts (waits).\n                    R         - display all reserves.\n                    J=jobname - display all resources held by the\n                                specified job or TSO user.\n                    null or * - be prompted to enter a major name\n                                and/or a minor name or jobname.\n                    other     - display all enqueues on the specified\n                                major name (QNAME).\n\n./ ADD NAME=XLNKLST  0100-07332-07332-0900-00054-00054-00000-SEB\n)F Function -\n\n   The XLNKLST command allocates the system link list and/or the\n   LPA list libraries to a specified file name.\n\n   Note 1:  This command requires MVS/SP2.1 (XA) with LLA (link list\n            lookaside) to be installed.\n\n   Note 2:  Even though the command functions successfully, using the\n            generated DD concatenation can result in an S013-E4 ABEND\n            if your installation has many LPA and link list libraries.\n\n)X Syntax -\n\n   XCMD\n   XLNKLST    'filename'\n              LPA / NOLPA\n              LINKLIST / NOLINKLIST\n              REUSE\n\n   Required:  'filename'\n\n   Defaults:  LPA, LINKLIST\n\n   Notes:     It is an error to specify both NOLPA and NOLINKLIST.\n\n\n)O Operands -\n\n)P'filename'     - the file name to which the link list and/or LPA list\n                   libraries are to be allocated.\n\n))LPA            - If LPA is specified, the libraries from the LPA list\n                   (normally 'SYS1.LPALIB') are included in the\n                   concatenation, in front of the link list libraries\n                   if requested.  This is the default.\n\n))NOLPA          - If NOLPA is specified, the libraries from the LPA\n                   list are not included in the concatenation.\n\n))LINKLIST       - If LINKLIST is specified, the libraries from the\n                   system link list are included in the concatenation,\n                   behind the LPA list libraries if requested.  This is\n                   the default.\n\n))NOLINKLIST     - If NOLINKLIST is specified, the libraries from the\n                   system link list are not included in the\n                   concatenation.\n\n))REUSE          - If REUSE is specified, the requested file name will\n                   be unallocated and reused if it is already\n                   allocated.  If you do not specify REUSE, the command\n                   will fail if the file is already allocated.\n\n./ ADD NAME=XPROC    0100-07332-07332-0900-00256-00256-00000-SEB\n***********************************************************************\n*                                                                     *\n* Copyright (c) 1989, 1992 The Charles Stark Draper Laboratory, Inc.  *\n*                                                                     *\n*  This program is provided on an \"as is\" basis. It may be freely     *\n*  distributed as long as it is not offered for commercial sale,      *\n*  nd as long as this copyright notice is included.                   *\n*                                                                     *\n***********************************************************************\n*\n* XPROC 04/13/92 - SEB1525 - Version 2 - /quotable option added\n*\n)F FUNCTION -\n\n The XPROC command parses an argument string into positional and/or\n keyword parameters, similarly to the PROC statement of a CLIST.\n However, XPROC can be used inside a REXX exec to parse the argument\n to the exec, or inside a CLIST or REXX exec to process the value of\n a variable as if it were an argument string.\n\n The values of the parameters specified on the XPROC command cause the\n corresponding REXX or CLIST variables to be set, as they would in a\n CLIST PROC statement.\n\n The rules for entering parameters to be processed by the XPROC command\n are identical to those of the CLIST PROC statement - except that XPROC\n supports extensions to the CLIST PROC syntax by means of options\n preceded by the slash (\"/\") character.\n\n For more information on PROC syntax, consult a TSO/E CLIST manual,\n or use the local Draper command XHELPC PROC to view help for PROC.\n\n Notes: As for any TSO command, it is best to enclose the entire\n       XPROC command in \"double quotes\" when using it from REXX.\n       This includes the variable names.\n\n       When XPROC is used, prompting is not available by default\n       (unlike the PROC statement of a CLIST).  Therefore, it is\n       advisable to precede the call to XPROC with a statement that\n       activates prompting, e.g.\n\n       CALL PROMPT \"ON\"  /* for REXX  */\n       CONTROL PROMPT    /* for CLIST */\n\n       Also, if there is an error in the XPROC command, or the parsing\n       of the argument string fails, a REXX exec (or a CLIST with\n       CONTROL NOFLUSH active) will NOT be flushed, but will continue\n       to execute (with none of the parameters set).  Therefore, you\n       should check the value of RC (for REXX) or &LASTCC (for CLIST)\n       afterwards and EXIT if it is not zero.\n\n)X SYNTAX -\n\n XPROC  {input-variable}\n        positional-number\n        {positional-parameter{/option...} ...}\n        {keyword-parameter{/option...}{({default-value})}{/option...}}\n\n        The number of positional-parameters must be equal to the\n        value of positional-number (which must be a number).\n\n Required: positional-number\n\n Note that the syntax of XPROC is exactly identical to that of\n the PROC statement of CLIST language, except for the optional\n \"input-variable\" and the \"/option\" feature.\n\n Examples:\n\n  The following examples assume a REXX environment:\n\n  Example 1: Define one positional parameter (DATASET),\n             no keyword parameters:\n\n       \"XPROC 1 DATASET\"\n\n  Example 2: Define no positional parameters, and one keyword\n             parameter (TESTING) which has a null default value:\n\n       \"XPROC 0 TESTING\"\n\n  Example 3: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\":\n\n       \"XPROC 1 LIBRARY TRACE SYSOUT(A)\"\n\n  Example 4: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER) and a keyword (OWNER) with a default value of\n             the user's TSO prefix.  Note how we allow REXX to\n             generate the desired default value so it appears in\n             the XPROC command at execution time:\n\n       \"XPROC 3 LIBRARY TYPE MEMBER OWNER('\"SYSVAR(SYSPREF)\"')\"\n\n  Example 5: Define a positional parameter (NAME) and one keyword\n             parameter (TITLE) which has a null default value, and\n             one (SUBJECT) which has the default value \"None\".\n             The values of all three parameters will be processed\n             as is with respect to case.\n\n       XPROC 1 NAME/ASIS TITLE/ASIS() SUBJECT(None)/ASIS\n\n  The following examples work under REXX or CLIST (but be sure to\n  enclose the command in \"double quotes\" under REXX):\n\n  Example 6: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\".  The\n             argument string to be parsed will be taken from the\n             value of the variable \"SYSDVAL\".\n\n       XPROC SYSDVAL 1 LIBRARY TRACE SYSOUT(A)\n\n  Example 7: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER), and a keyword (MARK) with a default value of\n             the current time.  Note how we allow REXX to generate\n             the desired default value so it appears in the XPROC\n             command at execution time.  The argument string to be\n             parsed will be taken from the value of the variable\n             \"STRING\".\n\n       \"XPROC STRING 3 LIBRARY TYPE MEMBER MARK('\"TIME()\"')\"\n\n             Under CLIST, this could be coded as:\n\n       XPROC STRING 3 LIBRARY TYPE MEMBER MARK('&SYSTIME')\n\n             but note that &SYSTIME gets resolved BEFORE the XPROC\n             command executes.  This is the only type of situation\n             where an \"&\" is appropriate.\n\n)O OPERANDS -\n\n))input-variable\n\n   the NAME of a variable from which the argument string to be parsed\n   is to be extracted.  The name must conform to the rules for CLIST or\n   REXX variable names.  The specified variable must be set to the\n   argument string to be processed (no command name included) before\n   XPROC is invoked.\n\n   The input-variable name may be omitted in a REXX exec ONLY, in which\n   case the arguments to the REXX exec are accessed.  This provides the\n   same capability that the PROC statement of a CLIST would.\n\n))positional-number\n\n   a number (0 or greater) which specifies the number of positional\n   parameters that follow.  This is required.  If there are no\n   positional parameters, specify a 0.\n\n))positional-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   Underscores may be part of the name.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands in parameter names.  Ampersands in an XPROC command will\n   cause normal symbolic substitution in CLISTS; they will cause errors\n   under REXX.\n\n))keyword-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   A default value in parentheses may optionally follow the parameter;\n   if there is no default value, the keyword takes on its own name as\n   a value if given by the caller, and a null string otherwise.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands (\"&\") in parameter names.  Ampersands in an XPROC command\n   will cause normal symbolic substitution in CLISTS; they will cause\n   errors under REXX.\n\n))default-value\n\n   Any character string, including the null string.  If it is present,\n   it must follow a valid keyword parameter and be enclosed in\n   parentheses (the right parenthesis may be omitted if this is at the\n   end of the command).  The value may be quoted (with single quotes,\n   with two quotes representing one) or unquoted; however, if it\n   contains any special characters (blanks, unbalanced parentheses,\n   etc.), it must be quoted.\n\n   If the caller provides an alternate value for the associated\n   keyword, the keyword takes on the that value; otherwise it takes on\n   the default value specified by XPROC.  Note that although () may be\n   specified in XPROC for a null string, a caller must type ('') to get\n   the same result.\n\n))option\n\n   Processing options may be associated with positional or keyword\n   parameters by specifying their names following the parameter name\n   delimited by a slash.  For example, assuming positional parameter\n   name PP and keyword parameter name KP, and option name OP1 and OP2,\n   the following are possible:\n\n   PP/OP1\n   KP/OP1\n   KP/OP1(default)\n   KP(default)/OP1\n   PP/OP1/OP2\n   KP/OP1(default)/OP2\n\n   The supported options at this time are ASIS and QUOTABLE.\n\n))ASIS\n\n   If the ASIS option is associated with a positional or keyword\n   parameter that takes a value, the value specified by the user\n   for that parameter is processed in case-retention mode.  In\n   other words, any lower-case characters present in the value\n   are kept as is.  This overrides the default behavior, which\n   converts all parameter values to uppercase (the only behavior\n   available via the PROC statement of CLIST).\n\n   The ASIS option is not valid for keyword parameters that do\n   not take a value (i.e. evaluate to themselves or null).\n\n   Note that default values in the XPROC prototype are always\n   processed asis, regardless of the presence of this option.\n\n   Examples: XPROC 1 NAME/ASIS\n             XPROC 0 TITLE/ASIS(default)\n             XPROC 0 TITLE(default)/ASIS\n\n))QUOTABLE\n\n   If the QUOTABLE option is associated with a positional parameter,\n   the value specified by the user for that parameter may be entered\n   as a quoted string.  In other words, embedded blanks or other\n   special characters may be entered if the string is enclosed in\n   single quotes by the user.  The quotes do not become part of the\n   resulting value; to pass in quotes, the user must provide doubled\n   quotes, similar to the way quotes are specified for keyword values.\n   This overrides the default behavior, which takes a\n   blank-or-comma-delimited string as the value of the positional\n   parameter, without honoring quotes specially.\n\n   Thus, you may define a CLIST or REXX exec that takes a syntax like:\n\n     MYCLIST 'hi there' 'how are you'\n\n   and have the strings entered as positional parameters.\n\n   The QUOTABLE option is valid only for positional parameters,\n   not keyword parameters.\n\n   Examples: XPROC 1 NAME/QUOTABLE\n             XPROC 3 NAME/ASIS/QUOTABLE ADDRESS/QUOTABLE CITY/ASIS\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INCLUDE": {"ttr": 21764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x030\\x030\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 816, "newlines": 816, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00015-00015-00000-SEB\nName:     DCLDCB\nType:     INCLUDE\nPurpose:  Map the DCB control block fields\nRequires:\nUsed by:  PLI PLICOMP\nComments: Copied from IBM assembler macro PL/S statements.  Therefore,\n          probably cannot be legally distributed.\n------------------------------------------------------------------------\nName:     XTSOVAR\nType:     INCLUDE\nPurpose:  Declare entry for XTSOVAR function\nRequires: ASM XTSOVAR\nUsed by:  PLI PBRHELP\nComments: (See ASM XTSOVAR.)\n------------------------------------------------------------------------\n./ ADD NAME=DCLDCB   0100-07332-07332-0900-00792-00792-00000-SEB\n /*******************************************************************/\n /*                                                                 */\n /* THIS IS THE DSORG=PS,DEVD=DA ONLY VERSION OF THE DCB MAP.       */\n /*                                                                 */\n /* DCB FOR PHYSICAL SEQUENTIAL DIRECT ACCESS DEVICES               */\n /*                                                                 */\n /* THIS INCLUDE MEMBER IS A MODIFIED VERSION OF THE IBM MACRO      */\n /* 'SYS1.MACLIB(IHADCB)'.                                          */\n /*                                                                 */\n /* THE DEFAULT BASED POINTER FOR THIS STRUCTURE IS \"DCBPTR.\"       */\n /*                                                                 */\n /* TO USE A DIFFERENT POINTER BASE, INCLUDE THE FOLLOWING          */\n /* STATEMENTS PRECEDING THE INCLUDE FOR THIS MEMBER:               */\n /*                                                                 */\n /* %DCL DCBPTR CHAR.,                                              */\n /* %DCBPTR = 'YOUR_DCB_POINTER_NAME'.,                             */\n /* %ACT DCBPTR.,                                                   */\n /*                                                                 */\n /*                                                                 */\n /*******************************************************************/\n %DCL DCBDV311 CHAR;\n %DCL DCBDV301 CHAR;\n %DCL DCBDV303 CHAR;\n %DCL DCBDV302 CHAR;\n %DCL DCBDV321 CHAR;\n %DCL DCBD1305 CHAR;\n %DCL DCBDV305 CHAR;\n %DCL DCBDV314 CHAR;\n %DCL DCBDV330 CHAR;\n %DCL DCBDV340 CHAR;\n %DCL DCBDV350 CHAR;\n %DCL DCBDV375 CHAR;\n %DCL DCBDV331 CHAR;\n %DCL DCBDV380 CHAR;\n %DCL DCBDVTRM CHAR;\n %DCL DCBUPDT  CHAR;\n %DCL DCBNUPD  CHAR;\n %DCL DCBSVDEB CHAR;\n %DCL DCBBFTA  CHAR;\n %DCL DCBBFTR  CHAR;\n %DCL DCBBFAD  CHAR;\n %DCL DCBBFAF1 CHAR;\n %DCL DCBBFAF2 CHAR;\n %DCL DCBRECD  CHAR;\n %DCL DCBRECF  CHAR;\n %DCL DCBRECV  CHAR;\n %DCL DCBRECU  CHAR;\n %DCL DCBRECCA CHAR;\n %DCL DCBRECCM CHAR;\n %DCL DCBRECC  CHAR;\n %DCL DCBIFNEP CHAR;\n %DCL DCBEX    CHAR;\n %DCL DCBIFPEC CHAR;\n %DCL DCBIFC9  CHAR;\n %DCL DCBIFC12 CHAR;\n %DCL DCBIFER  CHAR;\n %DCL DCBIFNE1 CHAR;\n %DCL DCBIFTIM CHAR;\n %DCL DCBIFNE2 CHAR;\n %DCL DCBIFNE3 CHAR;\n DECLARE\n   1 IHADCB   BASED(DCBPTR),\n    2 IHA_DUMMY0  CHAR(52);              /* DESC'D IN FF. STRUCTURES */\n DECLARE 1 IHADCS00\n       BASED(DCBPTR),\n    2 DCBRELAD    CHAR(4),               /* PARTITIONED ORGANIZATION\n                                            DATA SET -  ADDRESS (IN\n                                            THE FORM TTRN) OF MEMBER\n                                            CURRENTLY USED. ---\n    2 DCBKEYCN    BIT(8),                /* KEYED BLOCK OVERHEAD\n                                            CONSTANT                 */\n    2 DCBFDAD     CHAR(8);               /* FULL DISK ADDRESS IN THE\n                                            FORM OF MBBCCHHR OF\n                                            RECORD THAT WAS JUST\n                                            READ OR WRITTEN          */\n /*                     DIRECT ACCESS DEVICES                        */\n DECLARE 1 IHADCS01\n       BASED(DCBPTR),\n    2 IHA_DUMMY1  CHAR(12),\n    2 DCBDVTBL,                          /* SAME AS DCBDVTBA BELOW   */\n     3 IHA_DUMMY2  CHAR(1),              /* LAST BYTE OF DCBFDAD     */\n     3 DCBDVTBA    BIT(24),              /* ADDR OF ENTRY IN I/O DEVICE\n                                            CHARACTERISTICS TABLE FOR\n                                            DEVICE BEING USED        */\n    2 IHA_DUMMY3  BIT(8),                /* DCBKEYLE - KEY LENGTH    */\n    2 IHA_DUMMY4  BIT(8),                /* DCBDEVT - DEVICE TYPE    */\n %DCBDV311='''00100001''B';              /* 2311 DISK DRIVE          */\n %DCBDV301='''00100010''B';              /* 2301 PARALLEL DRUM       */\n %DCBDV303='''00100011''B';              /* 2303 SERIAL DRUM         */\n %DCBDV302='''00100100''B';              /* 2302 DISK STORAGE        */\n %DCBDV321='''00100101''B';              /* 2321 DATA CELL DRIVE     */\n %DCBD1305='''00100110''B';              /* 2305 DRUM MOD-1          */\n %DCBDV305='''00100111''B';              /* 2305 DRUM MOD-2          */\n %DCBDV314='''00101000''B';              /* 2314/2319 DISK STORAGE   */\n %DCBDV330='''00101001''B';              /* 3330 DISK STORAGE\n                                            3330 MODEL-1\n                                            3330 MODEL-2\n                                            3333 MODEL-1             */\n %DCBDV340='''00101010''B';              /* 3340/3344 DISK STORAGE   */\n %DCBDV350='''00101011''B';              /* 3350  DISK STORAGE\n                                            MODELS A2,B2,C2 @ZA46311 */\n %DCBDV375='''00101100''B';              /* 3375  DISK STORAGE       */\n %DCBDV331='''00101101''B';              /* 3330 MODEL-11 OR\n                                            3333 MODEL-11 DISK STRGE */\n %DCBDV380='''00101110''B';              /* 3380  DISK STORAGE       */\n    2 DCBTRBAL    FIXED(15) BIN;         /* TRACK BALANCE. NUMBER OF\n                                            BYTES REMAINING ON\n                                            CURRENT TRACK AFTER A\n                                            WRITE OPERATION  (THIS\n                                            QUANTITY MAY BE NEGATIVE\n                                            IF THERE  ARE NO BYTES\n                                            REMAINING ON TRACK).     */\n /*                     ACCESS METHOD COMMON INTERFACE               */\n DECLARE 1 IHADCS11\n       BASED(DCBPTR),\n    2 IHA_DUMMYF  CHAR(16),\n    2 DCBRELB,                           /* SAME AS DCBREL BELOW     */\n     3 DCBKEYLE    BIT(8),               /* KEY LENGTH OF DATA SET   */\n     3 DCBREL,                           /* NUMBER OF RELATIVE\n                                            TRACKS OR BLOCKS IN THIS\n                                            DATA SET (BDAM)          */\n      4 DCBDEVT     BIT(8),              /* DEVICE TYPE              */\n %DCBDVTRM='''01001111''B';              /* TERMINAL. (DD TERM=TS)   */\n      4 DUMMY_DEVT2 BIT(16),             /* DEVICE TYPE              */\n    2 DCBBUFCB,                          /* ADDRESS OF BUFFER POOL\n                                            CONTROL BLOCK            */\n     3 DCBBUFNO    BIT(8),               /* NUMBER OF BUFFERS\n                                            REQUIRED FOR THIS DATA\n                                            SET. MAY RANGE FROM 0 TO\n                                            255. IF  UNBLOCKED\n                                            SPANNED RECORDS ARE\n                                            USED, NUMBER OF SEGMENT\n                                            WORK AREAS REQUIRED FOR\n                                            THIS DATA SET.           */\n     3 DCBBUFCA    BIT(24),              /* ADDRESS OF BUFFER POOL\n                                            CONTROL BLOCK            */\n    2 DCBBUFL     FIXED(15) BIN,         /* LENGTH OF BUFFER.  MAY\n                                            RANGE FROM 0 TO  32,767. */\n    2 DCBDSORG,                          /* DATA SET ORGANIZATION    */\n     3 DCBDSRG1 UNALIGNED,               /* FIRST BYTE OF DCBDSORG   */\n      4 DCBDSGIS BIT(1),                 /* IS - INDEXED SEQUENTIAL  */\n      4 DCBDSGPS BIT(1),                 /* PS - PHYSICAL SEQUENTIAL */\n      4 DCBDSGDA BIT(1),                 /* DA - DIRECT ORGANIZATION */\n      4 DCBDSGCX BIT(1),                 /* CX - BTAM/QTAM LINE GRP  */\n      4 IHA_DUMM36 BIT(2),               /* RESERVED                 */\n      4 DCBDSGPO BIT(1),                 /* PO - PARTITIONED ORG.    */\n      4 DCBDSGU  BIT(1),                 /* U - UNMOVABLE, THE DATA\n                                            CONTAINS  LOCATION\n                                            DEPENDENT INFORMATION    */\n     3 DCBDSRG2 UNALIGNED,               /* SECOND BYTE OF DCBDSORG  */\n      4 DCBDSGGS BIT(1),                 /* GS - GRAPHICS ORG.       */\n      4 DCBDSGTX BIT(1),                 /* TX - TCAM LINE GROUP     */\n      4 DCBDSGTQ BIT(1),                 /* TQ - TCAM MESSAGE QUEUE  */\n      4 IHA_DUMM38 BIT(1),               /* RESERVED                 */\n      4 DCBACBM BIT(1),                  /* ACCESS METHOD CONTROL BLK*/\n      4 DCBDSGTR   BIT(1),               /* TR - TCAM 3705           */\n      4 IHA_DUMM39 BIT(2),               /* RESERVED                 */\n    2 DCBIOBAD,                          /* ADDRESS OF IOB WHEN\n                                            CHAINED SCHEDULING USED  */\n     3 DCBODEB,                          /* ADDRESS OF OLD DEB       */\n      4 DCBICQE,                         /* ADDRESS OF ICQE          */\n       5 DCBLNP,                         /* 3525 PRINTER LINE\n                                            POSITION COUNTER         */\n        6 DCBQSLM UNALIGNED,             /* QSAM LOCATE MODE LOGICAL\n                                            RECORD INTERFACE\n                                            INDICATOR BYTE FOR UPDAT\n                                            PROCESSING OF  SPANNED\n                                            RECORDS                  */\n         7 DCB1DVDS BIT(1),              /* ONLY ONE DEVICE ALLOCATED\n                                            TO THIS DATA SET         */\n         7 DCBUPDCM BIT(1),              /* UPDATE COMPLETE, FREE\n                                            OLD DEB                  */\n         7 DCBUPDBT BIT(2),              /* UPDATE BITS              */\n %DCBUPDT ='''10''B';                    /* UPDATE TO TAKE PLACE     */\n %DCBNUPD ='''11''B';                    /* NO UPDATE TO TAKE PLACE  */\n %DCBSVDEB='''01''B';                    /* OLD DEB ADDRESS MUST BE\n                                            SAVED                    */\n         7 IHA_DUMM40 BIT(4),            /* RESERVED                 */\n       5 DCBIOBAA,                       /* SAME AS DCBIOBAD ABOVE   */\n        6 DCBICQEA,                      /* SAVE AS DCBICQE ABOVE    */\n         7 DCBODEBA    BIT(24);          /* ADDRESS OF OLD DEB       */\n DECLARE 1 IHADCS50\n       BASED(DCBPTR),\n    2 IHA_DUMMYG  CHAR(28),\n    2 DCBSVCXL,                          /* SAME AS DCBSVCXA BELOW   */\n     3 IHA_DUMM41 BIT(8),                /* RESERVED                 */\n     3 DCBSVCXA   BIT(24),               /* POINTER TO EXIT LIST OF\n                                            JES C.I. INTERFACE\n                                            CONTROL SVC              */\n /*                     FOUNDATION EXTENSION                         */\n    2 DCBEODAD,                          /* SAME AS DCBEODA BELOW    */\n     3 DCBBFALN,                         /* BUFFER ALIGNMENT BITS    */\n      4 DCBHIARC,                        /* HIERARCHY BITS           */\n       5 DCBBFTEK UNALIGNED,             /* BUFFERING TECHNIQUE BITS */\n        6 DCBH1    BIT(1),               /* HIERARCHY 1 MAIN STORAGE\n                                            - BIT 5 IS ZERO          */\n        6 DCBBFT,                        /* BUFFERING TECHNIQUE      */\n %DCBBFTA ='''110''B';                   /* QSAM LOCATE MODE\n                                            PROCESSING OF SPANNED\n                                            RECORDS - OPEN IS TO\n                                            CONSTRUCT A RECORD AREA\n                                            IF IT AUTOMATICALLY\n                                            CONSTRUCTS BUFFERS       */\n %DCBBFTR ='''010''B';                   /* FOR BSAM CREATE BDAM\n                                            PROCESSING OF UNBLOCKED\n                                            SPANNED RECORDS -\n                                            SOFTWARE TRACK OVERFLOW.\n                                            FOR BSAM INPUT\n                                            PROCESSING OF UNBLOCKED\n                                            SPANNED RECORDS WITH\n                                            KEYS - RECORD OFFSET\n                                            PROCESSING.              */\n         7 DCBBFTS BIT(1),               /* SIMPLE BUFFERING - BIT 3\n                                            IS ZERO                  */\n         7 DCBBFTKR BIT(1),              /* UNBLOCKED SPANNED\n                                            RECORDS - SOFTWARE\n                                            TRACK OVERFLOW (BDAM)    */\n         7 DCBBFTE BIT(1),               /* EXCHANGE BUFFERING - BIT\n                                            1 IS ZERO                */\n        6 DCBBFTKD BIT(1),               /* DYNAMIC BUFFERING (BTAM) */\n        6 DCBH0    BIT(1),               /* HIERARCHY 0 MAIN STORAGE\n                                            - BIT 0 IS ZERO          */\n        6 DCBBFA   BIT(2),               /* BUFFER ALIGNMENT         */\n %DCBBFAD ='''10''B';                    /* DOUBLEWORD BOUNDARY      */\n %DCBBFAF1='''01''B';                    /* FULLWORD NOT A\n                                            DOUBLEWORD BOUNDARY,\n                                            CODED IN  DCB MACRO\n                                            INSTRUCTION              */\n %DCBBFAF2='''11''B';                    /* FULLWORD NOT A\n                                            DOUBLEWORD BOUNDARY,\n                                            CODED IN  DD STATEMENT   */\n     3 DCBEODA     BIT(24),              /* ADDRESS OF A\n                                            USER-PROVIDED ROUTINE TO\n                                            HANDLE END-OF-DATA\n                                            CONDITIONS               */\n    2 DCBEXLST,                          /* ADDRESS OF USER-PROVIDED\n                                            LIST OF EXITS            */\n     3 DCBRECFM  UNALIGNED,              /* RECORD FORMAT            */\n      4 DCBRECLA,                        /* RECORD LENGTH INDICATOR\n                                            - ASCII                  */\n %DCBRECD ='''001''B';                   /* ASCII VARIABLE RECORD\n                                            LENGTH                   */\n       5 DCBRECL  BIT(2),                /* RECORD LENGTH INDICATOR  */\n %DCBRECF ='''10''B';                    /* FIXED RECORD LENGTH      */\n %DCBRECV ='''01''B';                    /* VARIABLE RECORD LENGTH   */\n %DCBRECU ='''11''B';                    /* UNDEFINED RECORD LENGTH  */\n       5 DCBRECTO BIT(1),                /* TRACK OVERFLOW           */\n      4 DCBRECBR BIT(1),                 /* BLOCKED RECORDS          */\n      4 DCBRECSB BIT(1),                 /* FOR FIXED LENGTH RECORD\n                                            FORMAT - STANDARD\n                                            BLOCKS.  FOR VARIABLE\n                                            LENGTH RECORD  FORMAT -\n                                            SPANNED RECORDS          */\n      4 DCBRECCC BIT(2),                 /* CONTROL CHARACTER\n                                            INDICATOR                */\n %DCBRECCA='''10''B';                    /* ASA CONTROL CHARACTER    */\n %DCBRECCM='''01''B';                    /* MACHINE CONTROL CHAR.    */\n %DCBRECC ='''00''B';                    /* NO CONTROL CHARACTER     */\n      4 DCBRECKL BIT(1),                 /* KEY LENGTH (KEYLEN) WAS\n                                            SPECIFIED IN DCB         */\n     3 DCBEXLSA    BIT(24);              /* ADDRESS OF USER-PROVIDED\n                                            LIST OF EXITS            */\n /*                     FOUNDATION BEFORE OPEN                       */\n DECLARE 1 IHADCS24\n       BASED(DCBPTR),\n    2 IHA_DUMMYT  CHAR(40),\n    2 DCBDDNAM    CHAR(8),               /* NAME ON THE DD STATEMENT\n                                            DEFINING THE DATA SET    */\n    2 DCBOFLGS UNALIGNED,                /* FLAGS USED BY OPEN RTE.  */\n     3 DCBOFLWR,                         /* IF ZERO, LAST I/O\n                                            OPERATION WAS READ OR\n                                            POINT. IF ONE, LAST I/O\n                                            OPERATION WAS  WRITE.    */\n      4 DCBOFIOD BIT(1),                 /* DATA SET BEING OPENED FOR\n                                            INPUT OR OUTPUT (BDAM)   */\n     3 DCBOFLRB BIT(1),                  /* LAST I/O OPERATION WAS\n                                            IN READ BACKWARD  MODE   */\n     3 DCBOFEOV BIT(1),                  /* SET TO 1 BY EOV WHEN IT\n                                            CALLS CLOSE  ROUTINE FOR\n                                            CONCATENATION OF DATA\n                                            SETS W/UNLIKE ATTRIBUTES */\n     3 DCBOFOPN BIT(1),                  /* AN OPEN HAS BEEN\n                                            SUCCESSFULLY COMPLETED   */\n     3 DCBOFPPC BIT(1),                  /* SET TO 1 BY PROBLEM\n                                            PROGRAM TO INDICATE A\n                                            CONCATENATION OF UNLIKE\n                                            ATTRIBUTES               */\n     3 DCBOFTM  BIT(1),                  /* TAPE MARK HAS BEEN READ  */\n     3 DCBOFUEX BIT(1),                  /* SET TO 0 BY AN I/O\n                                            SUPPORT FUNCTION WHEN\n                                            THAT FUNCTION TAKES A\n                                            USER EXIT. SET TO 1 ON\n                                            RETURN FROM USER EXIT TO\n                                            THE I/O SUPPORT FUNCTION\n                                            WHICH TOOK THE EXIT.     */\n     3 DCBOFIOF BIT(1),                  /* SET TO 1 BY AN I/O\n                                            SUPPORT FUNCTION IF  DCB\n                                            IS TO BE PROCESSED BY\n                                            THAT FUNCTION            */\n    2 DCBIFLG UNALIGNED,                 /* FLAGS USED BY IOS IN\n                                            COMMUNICATING ERROR\n                                            CONDITIONS AND DETERMINING\n                                            CORRECTIVE PROCEDURES    */\n     3 DCBIBEC  BIT(2),                  /* ERROR CORRECTION INDIC.  */\n %DCBIFNEP='''00''B';                    /* NOT IN ERROR PROCEDURE   */\n %DCBEX   ='''01''B';                    /* ERROR CORRECTION OR IOS\n                                            PAGE FIX IN PROCESS      */\n %DCBIFPEC='''11''B';                    /* PERMANENT ERROR\n                                            CORRECTION               */\n     3 DCBIBPCT,                         /* PRINTER CARRIAGE TAPE\n                                            PUNCH INDICATOR          */\n %DCBIFC9 ='''10''B';                    /* CHANNEL 9 PRINTER CARRIAGE\n                                            TAPE PUNCH SENSED        */\n %DCBIFC12='''01''B';                    /* CHANNEL 12 PRINTER CARRIAGE\n                                            TAPE PUNCH SENSED        */\n      4 DCBICH9 BIT(1),                  /* CHANNEL 9                */\n      4 DCBICH12 BIT(1),                 /* CHANNEL 12               */\n     3 DCBIBIOE BIT(2),                  /* IOS ERROR ROUTINE USE\n                                            INDICATOR                */\n %DCBIFER ='''00''B';                    /* ALWAYS USE I/O\n                                            SUPERVISOR ERROR ROUTINE */\n %DCBIFNE1='''01''B';                    /* NEVER USE I/O SUPERVISOR\n                                            ERROR ROUTINE            */\n %DCBIFTIM='''01''B';                    /* TEST IOS MASK (IMSK) FOR\n                                            ERROR PROCEDURE  (BTAM)  */\n %DCBIFNE2='''10''B';                    /* NEVER USE I/O SUPERVISOR\n                                            ERROR ROUTINE            */\n %DCBIFNE3='''11''B';                    /* NEVER USE I/O SUPERVISOR\n                                            ERROR ROUTINE            */\n     3 IHA_DUMM91 BIT(2),                /* RESERVED                 */\n    2 DCBMACR,                           /* MACRO INSTRUCTION REF.   */\n     3 DCBMACR1 UNALIGNED,               /* FIRST BYTE OF DCBMACR    */\n      4 DCBMRECP BIT(1),                 /* EXECUTE CHANNEL PROGRAM\n                                            (EXCP) ---  ALWAYS ZERO\n                                            (BSAM, QSAM, BPAM,\n                                            BISAM,   QISAM, BDAM)    */\n      4 DCBMRFE,                         /* FOUNDATION EXTENSION IS\n                                            PRESENT (EXCP)           */\n       5 DCBMRGET,                       /* GET (QSAM, QISAM, TCAM)  */\n        6 DCBMRPTQ BIT(1),               /* PUT FOR MESSAGE GROUP\n                                            (QTAM) ---  ALWAYS ZERO\n                                            (BSAM, BPAM, BISAM, BDAM)*/\n      4 DCBMRAPG,                        /* APPENDAGES ARE REQUIRED\n                                            (EXCP)                   */\n       5 DCBMRRD,                        /* READ (BSAM, BPAM, BISAM,\n                                            BDAM, BTAM)              */\n        6 DCBMRWRQ BIT(1),               /* WRITE FOR LINE GROUP\n                                            (QTAM) ---  ALWAYS ZERO\n                                            (QSAM, QISAM)            */\n      4 DCBMRCI,                         /* COMMON INTERFACE (EXCP)  */\n       5 DCBMRMVG,                       /* MOVE MODE OF GET (QSAM)  */\n        6 DCBMRRDK BIT(1),               /* KEY SEGMENT WITH READ\n                                            (BDAM) ---  ALWAYS ZERO\n                                            (BISAM) ---  RESERVED\n                                            (BSAM, BPAM, QTAM, BTAM) */\n      4 DCBMRLCG,                        /* LOCATE MODE OF GET (QSAM)*/\n       5 DCBMRRDI BIT(1),                /* ID ARGUMENT WITH READ\n                                            (BDAM) ---  ALWAYS ZERO\n                                            (BISAM) ---  RESERVED\n                                            (EXCP, BSAM, BPAM, QTAM,\n                                            BTAM)                    */\n      4 DCBMRABC,                        /* USER'S PROGRAM MAINTAINS\n                                            ACCURATE BLK COUNT (EXCP)*/\n       5 DCBMRPT1,                       /* POINT (WHICH IMPLIES\n                                            NOTE) (BSAM, BPAM)       */\n        6 DCBMRSBG,                      /* SUBSTITUTE MODE OF GET\n                                            (QSAM)                   */\n         7 DCBMRDBF BIT(1),              /* DYNAMIC BUFFERING\n                                            (BISAM, BDAM)            */\n      4 DCBMRCRL,                        /* CNTRL (BSAM, QSAM)       */\n       5 DCBMRCHK,                       /* CHECK (BISAM)            */\n        6 DCBMRRDX,                      /* READ EXCLUSIVE (BDAM)    */\n         7 DCBPGFXA BIT(1),              /* PAGE FIX APPENDAGE IS\n                                            SPECIFIED (EXCP)\n                                            ---   RESERVED (BTAM,\n                                            BPAM, QISAM, QTAM)       */\n      4 DCBMRDMG,                        /* DATA MODE OF GET (QSAM)  */\n       5 DCBMRCK  BIT(1),                /* CHECK (BDAM) ---\n                                            RESERVED (EXCP, BSAM,\n                                            BPAM, BISAM, QISAM,\n                                            QTAM, BTAM)              */\n     3 DCBMACR2 UNALIGNED,               /* SECOND BYTE OF DCBMACR   */\n      4 DCBMRSTL BIT(1),                 /* SETL (QISAM) --- ALWAYS\n                                            ZERO (BSAM, QSAM, BPAM,\n                                            BISAM, BDAM)             */\n      4 DCBMRPUT,                        /* PUT (QSAM, TCAM)         */\n       5 DCBMRGTQ BIT(1),                /* GET FOR MESSAGE GROUP\n                                            (QTAM) ---  ALWAYS ZERO\n                                            (BSAM, BPAM, BISAM, BDAM)*/\n      4 DCBMRWRT,                        /* WRITE (BSAM, BPAM,\n                                            BISAM, BDAM, BTAM)       */\n       5 DCBMRRDQ BIT(1),                /* READ FOR LINE GROUP\n                                            (QTAM) ---  ALWAYS ZERO\n                                            (QSAM, QISAM) ---\n                                            RESERVED (EXCP)          */\n      4 DCBMRMVP,                        /* MOVE MODE OF PUT (QSAM)  */\n       5 DCBMRWRK BIT(1),                /* KEY SEGMENT WITH WRITE\n                                            (BDAM) ---  ALWAYS ZERO\n                                            (BISAM) ---  RESERVED\n                                            (EXCP, BSAM, BPAM, QTAM,\n                                            BTAM)                    */\n      4 DCBMR5WD,                        /* FIVE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMRLDM,                       /* LOAD MODE BSAM (CREATE\n                                            BDAM DATA SET)  (BSAM)   */\n        6 DCBMRLCP,                      /* LOCATE MODE OF PUT (QSAM)*/\n         7 DCBMRIDW BIT(1),              /* ID ARGUMENT WITH WRITE\n                                            (BDAM) ---  ALWAYS ZERO\n                                            (BISAM) ---  RESERVED\n                                            (BPAM, QTAM, BTAM)       */\n      4 DCBMR4WD,                        /* FOUR-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMRPT2,                       /* POINT (WHICH IMPLIES\n                                            NOTE) (BSAM, BPAM)       */\n        6 DCBMRTMD,                      /* SUBSTITUTE MODE (QSAM)   */\n         7 DCBMRUIP BIT(1),              /* UPDATE IN PLACE (PUTX)\n                                            (QISAM) ---  ALWAYS ZERO\n                                            (BISAM) ---  RESERVED\n                                            (BDAM, QTAM, BTAM)       */\n      4 DCBMR3WD,                        /* THREE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMRCTL,                       /* CNTRL (BSAM, QSAM)       */\n        6 DCBMRSTK,                      /* SETL BY KEY (QISAM)      */\n         7 DCBMRAWR BIT(1),              /* ADD TYPE OF WRITE (BDAM)\n                                            ---  ALWAYS ZERO (BISAM)\n                                            ---  RESERVED (BPAM,\n                                            QTAM, BTAM)              */\n      4 DCBMR1WD,                        /* ONE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMRSWA,                       /* USER'S PGM HAS PROVIDED A\n                                            SEGMENT WORK AREA POOL\n                                            (BSAM CREATE BDAM, BDAM) */\n        6 DCBMRDMD,                      /* DATA MODE (QSAM)         */\n         7 DCBMRSTI BIT(1);              /* SETL BY ID (QISAM) ---\n                                            ALWAYS ZERO (BISAM) ---\n                                            RESERVED (BPAM, QTAM,\n                                            BTAM)                    */\n /*                     FOUNDATION AFTER OPEN                        */\n DECLARE 1 IHADCS25\n       BASED(DCBPTR),\n    2 IHA_DUMMYU  CHAR(40),\n    2 DCBTIOT     FIXED(15) BIN,         /* OFFSET FROM TIOT ORIGIN\n                                            TO TIOELNGH FIELD IN\n                                            TIOT ENTRY FOR ASSOCIATED\n                                            DD STATEMENT             */\n    2 DCBMACRF,                          /* SAME AS DCBMACR BEFORE\n                                            OPEN                     */\n     3 DCBMACF1 UNALIGNED,               /* FIRST BYTE OF DCBMACRF   */\n      4 DCBMFECP BIT(1),                 /* EXECUTE CHANNEL PROGRAM\n                                            (EXCP)                   */\n      4 DCBMFFE,                         /* FOUNDATION EXTENSION IS\n                                            PRESENT (EXCP)           */\n       5 DCBMFGET,                       /* GET (QSAM, QISAM, TCAM)  */\n        6 DCBMFPTQ BIT(1),               /* PUT FOR MESSAGE GROUP\n                                            (QTAM)                   */\n      4 DCBMFAPG,                        /* APPENDAGES ARE REQUIRED\n                                            (EXCP)                   */\n       5 DCBMFRD,                        /* READ (BSAM, BPAM, BISAM,\n                                            BDAM, BTAM)              */\n        6 DCBMFWRQ BIT(1),               /* WRITE FOR LINE GROUP\n                                            (QTAM)                   */\n      4 DCBMFCI,                         /* COMMON INTERFACE (EXCP)  */\n       5 DCBMFMVG,                       /* MOVE MODE OF GET (QSAM)  */\n        6 DCBMFRDK BIT(1),               /* KEY SEGMENT W.READ(BDAM) */\n      4 DCBMFLCG,                        /* LOCATE MODE OF GET (QSAM)*/\n       5 DCBMFRDI BIT(1),                /* ID ARGUMENT W.READ(BDAM) */\n      4 DCBMFABC,                        /* USER'S PROGRAM MAINTAINS\n                                            ACCURATE BLK COUNT(EXCP) */\n       5 DCBMFPT1,                       /* POINT (WHICH IMPLIES\n                                            NOTE) (BSAM, BPAM)       */\n        6 DCBMFSBG,                      /* SUBSTITUTE MODE OF GET\n                                            (QSAM)                   */\n         7 DCBMFDBF BIT(1),              /* DYNAMIC BUFFERING\n                                            (BISAM, BDAM)            */\n      4 DCBMFCRL,                        /* CNTRL (BSAM, QSAM)       */\n       5 DCBMFCHK,                       /* CHECK (BISAM)            */\n        6 DCBMFRDX BIT(1),               /* READ EXCLUSIVE (BDAM)    */\n      4 DCBMFDMG,                        /* DATA MODE OF GET (QSAM)  */\n       5 DCBMFCK  BIT(1),                /* CHECK (BDAM)             */\n     3 DCBMACF2  UNALIGNED,              /* SECOND BYTE OF DCBMACRF  */\n      4 DCBMFSTL BIT(1),                 /* SETL (QISAM)             */\n      4 DCBMFPUT,                        /* PUT (QSAM, TCAM) - PUT\n                                            OR PUTX (QISAM)          */\n       5 DCBMFGTQ BIT(1),                /* GET FOR MESSAGE GROUP\n                                            (QTAM)                   */\n      4 DCBMFWRT,                        /* WRITE (BSAM, BPAM,\n                                            BISAM, BDAM, BTAM)       */\n       5 DCBMFRDQ BIT(1),                /* READ FOR LINE GROUP(QTAM)*/\n      4 DCBMFMVP,                        /* MOVE MODE OF PUT (QSAM)  */\n       5 DCBMFWRK BIT(1),                /* KEY SEGMENT WITH WRITE\n                                            (BDAM)                   */\n      4 DCBMF5WD,                        /* FIVE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMFLDM,                       /* LOAD MODE BSAM (CREATE\n                                            BDAM DATA SET)  (BSAM)   */\n        6 DCBMFLCP,                      /* LOCATE MODE OF PUT (QSAM)*/\n         7 DCBMFIDW BIT(1),              /* ID ARGUMENT WITH WRITE\n                                            (BDAM)                   */\n      4 DCBMF4WD,                        /* FOUR-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMFPT2,                       /* POINT (WHICH IMPLIES\n                                            NOTE) (BSAM, BPAM)       */\n        6 DCBMFTMD,                      /* SUBSTITUTE MODE (QSAM)   */\n         7 DCBMFUIP BIT(1),              /* UPDATE IN PLACE (PUTX)\n                                            (QISAM)                  */\n      4 DCBMF3WD,                        /* THREE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMFCTL,                       /* CNTRL (BSAM, QSAM)       */\n        6 DCBMFSTK,                      /* SETL BY KEY (QISAM)      */\n         7 DCBMFAWR BIT(1),              /* ADD TYPE OF WRITE (BDAM) */\n      4 DCBMF1WD,                        /* ONE-WORD DEVICE\n                                            INTERFACE (EXCP)         */\n       5 DCBMFSWA,                       /* USER'S PGM HAS PROVIDED A\n                                            SEGMENT WORK AREA POOL\n                                            (BSAM CREATE BDAM, BDAM) */\n        6 DCBMFDMD,                      /* DATA MODE (QSAM)         */\n         7 DCBMFSTI BIT(1),              /* SETL BY ID (QISAM)       */\n    2 DCBDEBAD,                          /* ADDRESS OF ASSOCIATED DEB*/\n     3 DCBIFLGS  UNALIGNED,              /* SAME AS DCBIFLG BEFORE\n                                            OPEN                     */\n      4 DCBIFEC  BIT(2),                 /* ERROR CORRECTION INDIC.  */\n      4 DCBIFPCT,                        /* PRINTER CARRIAGE TAPE\n                                            PUNCH INDICATOR          */\n       5 DCBCH9 BIT(1),                  /* CHANNEL 9                */\n       5 DCBCH12 BIT(1),                 /* CHANNEL 12               */\n      4 DCBIFIOE BIT(2),                 /* IOS ERROR ROUTINE USE IND*/\n      4 DCBIFLDT BIT(1),                 /* 3800 PRINTER             */\n                                         /* LOST DATA INDIC.         */\n      4 IHA_DUMM92 BIT(1),               /* RESERVED                 */\n     3 DCBDEBA     BIT(24);              /* ADDRESS OF ASSOCIATED DEB*/\n DECLARE 1 IHADCS26\n       BASED(DCBPTR),\n    2 IHA_DUMMYV  CHAR(48),\n    2 DCBWRITE,                          /* SAME AS DCBWRITA BELOW   */\n     3 DCBREAD,                          /* SAME AS DCBREADA BELOW   */\n      4 IHA_DUMM93  CHAR(1),             /* DCBOFLGS                 */\n      4 DCBWRITA,                        /* ADDRESS OF WRITE MODULE  */\n       5 DCBREADA    BIT(24);            /* ADDRESS OF READ MODULE   */\n DECLARE 1 IHADCS27\n       BASED(DCBPTR),\n    2 IHA_DUMMYW  CHAR(48),\n    2 DCBGET,                            /* SAME AS DCBGETA BELOW    */\n     3 DCBPUT,                           /* SAME AS DCBPUTA BELOW    */\n      4 IHA_DUMM94 CHAR(1),              /* DCBOFLGS                 */\n      4 DCBGETA,                         /* ADDRESS OF GET MODULE    */\n       5 DCBPUTA     BIT(24);            /* ADDRESS OF PUT MODULE    */\n /*                     QSAM-BSAM-BPAM COMMON INTERFACE              */\n DECLARE 1 IHADCS36\n       BASED(DCBPTR),\n    2 IHA_DUMMAI  CHAR(52),\n    2 DCBGERR,                           /* ADDRESS OF SYNCHRONIZING\n                                            ROUTINE FOR GET          */\n     3 DCBPERR,                          /* ADDRESS OF SYNCHRONIZING\n                                            ROUTINE FOR PUT          */\n      4 DCBCHECK,                        /* ADDRESS OF CHECK MODULE  */\n       5 DCBOPTCD  UNALIGNED,            /* OPTION CODES             */\n        6 DCBOPTW  BIT(1),               /* WRITE VALIDITY CHECK\n                                            (DASD)  (BSAM, BPAM,\n                                            QSAM, ISAM, BDAM)        */\n        6 DCBOPTU  BIT(1),               /* ALLOW DATA CHECK CAUSED\n                                            BY INVALID CHARACTER\n                                            (1403 PRINTER WITH UCS\n                                            FEATURE) (BSAM,BPAM,QSAM)\n                                            OR MSS WINDOW PROCESSING\n                                            REQUESTED (BSAM,QSAM)    */\n        6 DCBOPTC  BIT(1),               /* CHAINED SCHEDULING USING\n                                            PCI  (BSAM, BPAM, QSAM)  */\n        6 DCBOPTH,                       /* 1287/1288 OPTICAL READER\n                                            - HOPPER EMPTY EXIT\n                                            (BSAM, BPAM)             */\n         7 DCBOPTO,                      /* 1285/1287 OPTICAL READER\n                                            - ON-LINE CORRECTION\n                                            (QSAM)                   */\n          8 DCBBCKPT BIT(1),             /* CHANNEL-END APPENDAGE IS\n                                            TO BYPASS DOS EMBEDDED\n                                            CHECKPOINT RECORDS ON\n                                            TAPE  (BSAM, QSAM) ICB226*/\n        6 DCBOPTQ  BIT(1),               /* TRANSLATION TO OR FROM\n                                            ASCII (BSAM, BPAM, QSAM) */\n        6 DCBOPTZ,                       /* MAGNETIC TAPE DEVICES -\n                                            USE REDUCED ERROR\n                                            RECOVERY PROCEDURE\n                                            (EXCP, BSAM, BPAM, QSAM) */\n         7 DCBSRCHD BIT(1),              /* USE SEARCH DIRECT,\n                                            INSTEAD OF SEARCH\n                                            PREVIOUS, ON RECORD\n                                            POSITION SENSING DEVICE\n                                            (EXCP, BSAM, BPAM, QSAM) */\n        6 DCBOPTT  BIT(1),               /* USER TOTALING (BSAM,QSAM)*/\n        6 DCBOPTJ  BIT(1),               /* 3800- DYNAMIC CHAR SEL'N */\n       5 DCBGERRA,                       /* ADDRESS OF SYNCHRONIZING\n                                            ROUTINE FOR GET          */\n        6 DCBPERRA,                      /* ADDRESS OF SYNCHRONIZING\n                                            ROUTINE FOR PUT          */\n         7 DCBCHCKA   BIT(24),           /* ADDRESS OF CHECK MODULE  */\n    2 DCBSYNAD,                          /* ADDRESS OF USER-PROVIDED\n                                            SYNAD ROUTINE            */\n     3 DCBIOBL     BIT(8),               /* IOB LENGTH IN DOUBLEWDS  */\n     3 DCBSYNA     BIT(24),              /* ADDRESS OF USER-PROVIDED\n                                            SYNAD ROUTINE            */\n    2 DCBCIND1 UNALIGNED,                /* CONDITION INDICATORS     */\n     3 DCBCNTOV BIT(1),                  /* DIRECT ACCESS - TRACK\n                                            OVERFLOW IN USE\n                                            (BSAM, BPAM, QSAM)\n                                            2540 CARD PUNCH - DATA\n                                            SET WAS OPENED BUT NO\n                                            DATA WAS WRITTEN  (QSAM) */\n     3 DCBCNSRD BIT(1),                  /* SEARCH DIRECT\n                                            (BSAM, BPAM, QSAM)       */\n     3 DCBCNEVB BIT(1),                  /* END OF VOLUME - USED BY\n                                            EOB ROUTINES\n                                            (BSAM, BPAM, QSAM)       */\n     3 DCBCNEVA BIT(1),                  /* END OF VOLUME - USED BY\n                                            CHANNEL-END APPENDAGE\n                                            ROUTINES(BSAM,BPAM,QSAM) */\n     3 IHA_DUM137 BIT(1),                /* RESERVED                 */\n     3 DCBCNBRM BIT(1),                  /* BLOCKED RECORD BIT\n                                            MODIFIED                 */\n     3 IHA_DUM138 BIT(1),                /* RESERVED                 */\n     3 DCBCNEXB BIT(1),                  /* EXCHANGE BUFFERING\n                                            SUPPORTED  (QSAM)        */\n    2 DCBCIND2  UNALIGNED,               /* CONDITION INDICATORS     */\n     3 DCBCNSTO BIT(1),                  /* PARTITIONED DATA SET -\n                                            STOW HAS BEEN PERFORMED\n                                            (BSAM, BPAM, QSAM)\n                                            SEQUENTIAL DATA SET -\n                                            UPDATE  (BSAM, BPAM)     */\n     3 DCBCNWRO BIT(1),                  /* DIRECT ORGANIZATION DATA\n                                            SET - LAST I/O WAS A\n                                            WRITE RECORD ZERO\n                                            (BSAM, BPAM, QSAM)\n                                            SEQUENTIAL DATA SET -\n                                            UPDATE EOF IS INDICATED\n                                            (BSAM, BPAM)             */\n     3 DCBCNCLO BIT(1),                  /* CLOSE IN PROCESS (QSAM)  */\n     3 DCBCNIOE BIT(1),                  /* PERMANENT I/O ERROR\n                                            (BSAM, BPAM, QSAM)       */\n     3 DCBCNBFP BIT(1),                  /* OPEN ACQUIRED BUFFER POOL\n                                            (BSAM, BPAM, QSAM)       */\n     3 DCBCNCHS BIT(1),                  /* CHAINED SCHEDULING BEING\n                                            SUPPORTED(BSAM,BPAM,QSAM)*/\n     3 DCBCNFEO BIT(1),                  /* FEOV BIT (BSAM,BPAM,QSAM)*/\n     3 DCBCNQSM BIT(1),                  /* ALWAYS ZERO (BSAM, BPAM)\n                                            THIS IS A QSAM DCB (QSAM)*/\n    2 DCBBLKSI    FIXED(15) BIN,         /* MAXIMUM BLOCK SIZE       */\n    2 DCBWCPO     BIT(8),                /* OFFSET OF WRITE CHANNEL\n                                            PGM FROM START OF IOB    */\n    2 DCBWCPL     BIT(8),                /* LENGTH OF WRITE CHANNEL\n                                            PROGRAM                  */\n    2 DCBOFFSR    BIT(8),                /* OFFSET OF READ CCW FROM\n                                            BSAM/BPAM PREFIX  OF IOB */\n    2 DCBOFFSW    BIT(8),                /* OFFSET OF WRITE CCW FROM\n                                            BSAM/BPAM PREFIX OF IOB  */\n    2 DCBIOBA,                           /* FOR NORMAL SCHEDULING,\n                                            ADDRESS OF QSAM OR\n                                            BSAM/BPAM PREFIX OF IOB.\n                                            FOR CHAINED  SCHEDULING,\n                                            ADDRESS OF ICB.\n                                            FOR TSO TERMINAL DATA SET\n                                            OPENED FOR INPUT AND FORMAT\n                                            U, SIMULATED LOW-ORDER FOUR\n                                            BYTES  OF IOBCSW         */\n     3 DCBCICB,                          /* SAME AS DCBCICBA BELOW   */\n      4 IHA_DUM140 BIT(8),               /* DCBNCP (BSAM,BPAM)       */\n      4 DCBCICBA BIT(24);                /* POINTER TO JES C.I.\n                                            CONTROL BLOCK (CICB)     */\n DECLARE 1 IHADCS52\n       BASED(DCBPTR),\n    2 IHA_DUMMAJ  CHAR(80),\n    2 DCBDIRCT,                          /* NUMBER OF BYTES USED IN\n                                            LAST DIRECTORY BLOCK\n                                            (RANGE 0-254) (BSAM,BPAM)*/\n     3 DCBQSWS,                          /* FLAG BYTE                */\n      4 DCBUSASI UNALIGNED,              /* FLAG BYTE FOR ASCII TAPES*/\n       5 IHA_DUM141 BIT(1),              /* RESERVED                 */\n       5 DCBBLBP BIT(1),                 /* BLOCK PREFIX IS FOUR-BYTE\n                                            FIELD CONTAINING BLOCK\n                                            LENGTH IN UNPACKED\n                                            DECIMAL (SPECIFIED BY\n                                            BUFFER=L)                */\n       5 DCBQADFS,                       /* USED TO PERFORM SEQUENCE\n                                            CHECKING WITH MULTIPLE\n                                            FUNCTION SUPPORT FOR 3525\n                                            (BSAM, QSAM)             */\n        6 DCBQADF1 BIT(1),               /* FIRST BIT OF DCBQADFS    */\n        6 DCBQADF2 BIT(1),               /* SECOND BIT OF DCBQADFS   */\n        6 DCBQADF3 BIT(1),               /* THIRD BIT OF DCBQADFS    */\n       5 IHA_DUM142 BIT(2),              /* RESERVED                 */\n       5 DCBQSTRU BIT(1),                /* TRUNC ENTRY POINT ENTERED\n                                            (QSAM)                   */\n     3 DCBBUFOF,                         /* BLOCK PREFIX LENGTH\n                                            (0-99), SPECIFIED BY\n                                            BUFOFF=N OR BUFOFF=L     */\n      4 DCBDIRCQ    BIT(8);              /* NUMBER OF BYTES USED IN\n                                            LAST DIRECTORY BLOCK\n                                            (RANGE 0-254) (QSAM)     */\n /*                      BSAM-QSAM-TCAM INTERFACE                    */\n DECLARE 1 IHADCS37\n       BASED(DCBPTR),\n    2 IHA_DUMMAK  CHAR(60),\n    2 DCBFLAG1 UNALIGNED,                /* SAM-TCAM APP.PROG. FLAGS */\n     3 DCBSTQCK    BIT(1),               /* STOP=QUICK SPECIFIED FOR\n                                            SAM-TCAM DCB             */\n     3 DCBSTFLS    BIT(1),               /* STOP=FLUSH SPECIFIED FOR\n                                            SAM-TCAM DCB             */\n     3 IHA_DUM143  BIT(6);               /* RESERVED (TCAM-SAM)      */\n /*                     BSAM-BPAM INTERFACE                          */\n DECLARE 1 IHADCS38\n       BASED(DCBPTR),\n    2 IHA_DUMMAL  CHAR(72),\n    2 DCBEOBR,                           /* ADDRESS OF END-OF-BLOCK\n                                            MODULE FOR READ          */\n     3 DCBNCP      BIT(8),               /* NUMBER OF CHANNEL PGMS.  */\n                                         /* NUMBER OF READ OR WRITE\n                                            REQUESTS WHICH MAY BE\n                                            ISSUED PRIOR TO A CHECK,\n                                            NUMBER OF IOB'S\n                                            GENERATED.  (99 MAXIMUM) */\n     3 DCBEOBRA    BIT(24),              /* ADDRESS OF END-OF-BLOCK\n                                            MODULE FOR READ          */\n    2 DCBEOBW     PTR,                   /* ADDRESS OF END-OF-BLOCK\n                                            MODULE FOR WRITE. FOR\n                                            BSAM CREATE BDAM\n                                            PROCESSING OF  UNBLOCKED\n                                            SPANNED RECORDS WITH\n                                            BKTEK=R  SPECIFIED,\n                                            ADDRESS OF SEGMENT WORK\n                                            AREA  CONTROL BLOCK      */\n    2 IHA_DUM145  FIXED(15) BIN,         /* DCBDIRCT - NUMBER OF BYTES\n                                            USED IN LAST DIRECTORY\n                                            BLOCK (RANGE 0-254)      */\n    2 DCBLRECL    FIXED(15) BIN,         /* LOGICAL RECORD LENGTH    */\n    2 DCBPOINT,                          /* ADDR OF NOTE/POINT MODULE*/\n     3 DCBCNTRL,                         /* ADDRESS OF CNTRL MODULE  */\n      4 DCBNOTE     PTR;                 /* ADDR OF NOTE/POINT MODULE*/\n /*                     QSAM INTERFACE                               */\n DECLARE 1 IHADCS40\n       BASED(DCBPTR),\n    2 IHA_DUMMAN  CHAR(72),\n    2 DCBEOBAD,                          /* FOR SIMPLE BUFFERING,\n                                            ADDRESS OF LAST  BYTE OF\n                                            CURRENT BUFFER           */\n     3 DCBLCCW     PTR,                  /* FOR EXCHANGE BUFFERING,\n                                            ADDR OF LAST CCW IN LIST */\n    2 DCBCCCW,                           /* FOR EXCHANGE BUFFERING\n                                            ADDR OF CURR OR NEXT CCW */\n     3 DCBRECAD,                         /* ADDRESS OF CURRENT OR\n                                            NEXT LOGICAL RECORD      */\n      4 DCBRECBT UNALIGNED,              /* FLAG BYTE                */\n       5 DCBRCREL,                       /* RELSE MACRO HAS BEEN\n                                            ISSUED  (QSAM WITH\n                                            SIMPLE BUFFERING)        */\n        6 DCBRCTRU BIT(1),               /* TRUNC MACRO HAS BEEN\n                                            ISSUED (QSAM LOCATE MODE)*/\n        6 DCBRCFGT BIT(1),               /* FIRST GET AFTER OPEN\n                                            (QSAM LOCATE MODE)       */\n        6 DCBRCF_DUMMY BIT(2),\n       5 IHA_DUM148 BIT(4),              /* RESERVED                 */\n      4 DCBRECA     BIT(24),             /* ADDRESS OF CURRENT OR\n                                            NEXT LOGICAL RECORD      */\n    2 IHA_DUM149  CHAR(1),               /* DCBQSWS - FLAG BYTE      */\n    2 IHA_DUM150  BIT(8),                /* DCBDIRCQ - NUMBER OF BYTES\n                                            USED IN LAST DIRECTORY\n                                            BLOCK (RANGE 0-254)      */\n    2 IHA_DUM151  FIXED(15) BIN,         /* DCBLRECL - LOG REC LENGTH*/\n    2 IHA_DUM152,                        /* DCBCNTRL - ADDRESS OF\n                                            CNTRL MODULE             */\n     3 DCBEROPT UNALIGNED,               /* ERROR OPTION             */\n      4 DCBERACC BIT(1),                 /* ACCEPT PERMANENT ERROR   */\n      4 DCBERSKP BIT(1),                 /* SKIP PERMANENT ERROR     */\n      4 DCBERABE BIT(1),                 /* ABNORMAL END OF TASK     */\n      4 IHA_DUM153 BIT(5),               /* RESERVED                 */\n     3 IHA_DUM154  BIT(24),              /* DCBCNTRA - ADDRESS OF\n                                            CNTRL MODULE             */\n    2 IHA_DUM155  CHAR(2),               /* RESERVED                 */\n    2 DCBPRECL   FIXED(15) BIN,          /* FORMAT F RECORDS - BLOCK\n                                            LENGTH\n                                            FORMAT U RECORDS - MAXIMUM\n                                            BLOCK LENGTH\n                                            FORMAT V RECORDS -\n                                             UNSPANNED RECORD FORMAT -\n                                              MAXIMUM BLOCK LENGTH\n                                             SPANNED RECORD FORMAT -\n                                              PUT, NOT DATA MODE -\n                                               MAXIMUM BLOCK LENGTH\n                                              PUT, DATA MODE -\n                                               DATA LENGTH\n                                              GET - SEGMENT CONTROL\n                                               CODE OF PREVIOUS SEGMENT\n                                                                     */\n    2 DCBEOB      PTR;                   /* ADDRESS OF END OF BLOCK\n                                            MODULE                   */\n./ ADD NAME=XTSOVAR  0100-07332-07332-0900-00006-00006-00000-SEB\n   /* XTSOVAR program library subroutine */\n   DECLARE XTSOVAR EXTERNAL ENTRY(\n           CHAR(*),      /* R(EAD) or W(RITE)               */\n           CHAR(*) VAR,  /* The name of the CLIST variable  */\n           CHAR(*) VAR)  /* The value to be accessed or set */\n                       ; /* Note: Do not specify OPTIONS!   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACLIB": {"ttr": 22023, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 256, "newlines": 256, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00008-00008-00000-SEB\n------------------------------------------------------------------------\nName:     TCOMTAB\nType:     MACLIB\nPurpose:  TSO TEST workarea\nRequires:\nUsed by:  ASM XLBRKS, ASM XLSYMS\nComments: This may not be legal to distribute.\n------------------------------------------------------------------------\n./ ADD NAME=TCOMTAB  0100-07332-07332-0900-00246-00246-00000-SEB\n         MACRO\n         TCOMTAB\n***********************************************************************\n* THE INFORMATION IN THIS MACRO IS TAKEN FROM:                        *\n* TSO/EXTENSIONS VERSION 2 SYSTEM DIAGNOSIS: COMMAND PROCESSORS, M-Z  *\n* PAGE 18-245: TEST COMMAND (MVS/XA FEATURE)                          *\n* AND IS COPYRIGHT BY IBM.                                            *\n***********************************************************************\n* TEST COMMUNICATION TABLE (TCOMTAB)                                  *\n* THIS TABLE IS BUILT BY IKJEGINT, IS USED BY MANY TEST MODULES, AND  *\n* IS FREED BY IKJEGMNL.                                               *\n***********************************************************************\nTCOMTAB  DSECT\n*        ORG   *-8\n* TCOMID DS    CL8        -8           ID: TCOMID               TSO/EV2\n*        ORG   *+8\nECBPP    DS    A          +0           ECB WAITED ON BY SVC 97 & 61\nECBLIST  DS    0A         +4           BEGINNING OF ECB LIST FOR WAIT\nECBTST   DS    A          +4           PTR TO ECB POSTED BY SVC 97 & 61\nECBTERM  DS    A          +8           PTR TO ECB POSTED BY COMPLETION\n*                                      OF OLDEST SUBTASK OF TEST\nECBTMPS  DS    A          +C           PTR TO ECB POSTED BY TMP STAI\n*                                      EXIT RTE AT ABEND OF ANY SUBTASK\nECBTMPA  DS    A         +10           PTR TO ECB POSTED BY TMP ATTN\n*                                      EXIT RTE OR TEST'S ATTN EXIT RTE\nECBLOG   DS    A         +14           PTR TO ECB POSTED BY STOP/MODIFY\n*                                      TS OPERATOR COMMAND.\nTSTTCB   DS    A         +18           PTR TO TCB FOR TMP/TEST TASK\nPPTCB    DS    A         +1C           PTR TO TCB FOR PROBLEM PROGRAM\n*                                      TASK CURRENTLY QUALIFIED\n         DS    CL8       +20           RESERVED\nOUTBUF   DS    A         +28           PTR TO SMALL GENERAL-PURPOSE WA\n*                                      USED AS AN OUTPUT BUFFER FOR\n*                                      MESSAGES OR DATA\nBLDLARA  DS    0A        +2C           ADDR OF BUILD AREA USED BY\n*                                      IKJEGINT AND IKJEGLDR\nCONAREA  DS    A         +2C           PTR 2 SMALL WA IN WHICH IKJEGCVT\n*                                      RETURNS CONVERTED VALUES\nWORKAREA DS    A         +30           PTR TO A GENERAL WORKAREA WITH\n*                                      GENERAL & RESERVED SECTIONS\n*                                      (SEE TSTCWORK).\nREGSAVE1 DS    A         +34           PTR TO GRSA FOR IKJEGMNL\nREGSAVE2 DS    A         +38           PTR TO GRSA FOR TEST SUBCOMMANDS\nREGSAVE3 DS    A         +3C           PTR TO RGSA RESERVED FOR\n*                                      SUBCOMMAND VALIDCK EXIT RTES\nREGSAVE4 DS    A         +40           PTR TO GRSA RSRVD FOR IKJEGCVT\nREGSAVE5 DS    A         +44           PTR TO GRSA RSRVD FOR IKJEGIO\nREGSAVE6 DS    A         +48           PTR TO GRSA RSRVD FOR IKJEGSRH\nTSTIODSL DS    H         +4C           Length of dsname queue element\nTSTDCBL  DS    H         +4E           Length of DCB used by IKJEGIO\nTPLPTR   DS    A         +50           POINTER TO TPL\nTMPLL    DS    H         +54           LOGICAL LINESZ OF USER'S TERMNL\n         DS    X         +56           Reserved\nTSTESTRC DS    X         +57           ESTAE ERROR RETURN CODE\nTSTWHR   DS    A         +58           COMMUNICATION WORD USED FOR INFO\n*                                      PASSED FROM IKJEGSYM TO IKJEGWHR\nPARMLIST DS    0A        +5C           STANDARD SECTION OF TMP SERVICE\n*                                      ROUTINE PARAMETER LIST\nTSTUPT   DS    A         +5C           POINTER TO UPT\nTSTECT   DS    A         +60           POINTER TO ECT\nTSTCPECB DS    A         +64           POINTER TO ECB (SAVE ECB POINTED\n*                                      TO BY ECBTMPA)\nTSTANSPL DS    A         +68           ANSWER FIELD USED BY ALL MODULES\n*                                      CALLING IKJPARS\nTSTVSMAD DS    A         +6C           Adr of area filled in by VSMLIST\nTSTVSML  DS    A         +70           Len of area filled in by VSMLIST\nTSTRTYCD DS    X         +74           SUBCOMMAND ID\n         DS    XL3       +75           Reserved\nINBUF    DS    A         +78           PTR TO STORAGE CONTAINING A\n*                                      SUBCOMMAND READY FOR PROCESSING\nTSTIODSN DS    A         +7C           PTR TO QUEUE OF DSNAMES USED AS\n*                                      PARAMETERS FOR PRINT KEYWORD\n*                                      WITH LIST TYPE SUBCOMMANDS\nTSTIO    DS    A         +80           POINTER TO IKJEGIO\nTSTFLGSX DS    0A        +84           Additional word for TEST flags\nTSTAMODE DS    XL1       +84           Mask byte for AMODE bit in PSW.\n*                                      If high-order bit is on, tested\n*                                      program was executing in 31-bit\n*                                      mode when last brkpt was reached\nTSTFLGSA DS    XL1       +85           Reserved flag byte\nTSTFLGSB DS    XL1       +86           Reserved flag byte\nTSTFLGSC DS    XL1       +87           Reserved flag byte\n         DS    A         +88           RESERVED\nTSTCONVT DS    A         +8C           POINTER TO IKJEGCVT\nTSTADDR  DS    A         +90           PTR TO IKJEGBLD, A SUBROUTINE\n*                                      WHOSE FUNCTION IS TO ASSEMBLE AN\n*                                      EBCDIC ADDRESS STRING FROM THE\n*                                      COMPONENTS POINTED TO BY AN\n*                                      ADDRESS-TYPE PDE\nTSTSTAE  DS    A         +94           POINTER TO IKJEGSTA\nTSTFLGS  DS    0A        +98           Four byte flags\nTSTFLGS1 DS    X         +98           SWITCHES, BYTE 1\nPCHLSTVL EQU   X'80'                   IKJEGPCH IS PROCESSING A LIST OF\n*                                      VALUES\nFORGOUSE EQU   X'40'                   Used only by IKJEGGO\nTSTPRINT EQU   X'20'                   OUTPUT FROM IKJEGIO IS TO A D.S.\nTSTFIRST EQU   X'10'                   GENERAL PURPOSE SWITCH FOR USE\n*                                      BY ANY SUBCOMMAND OR SUBROUTINE;\n*                                      NOT TO BE PASSED\nRANGESW  EQU   X'08'                   INDICATES A RANGE ADDR PARAMETER\nTSTBUILD EQU   X'04'                   INDICATES THAT A NEW MODULE IS\n*                                      BEING LOADED FOR THE PROBLEM PGM\nENDSW    EQU   X'02'                   INDICATES END PROCESSING HAS\n*                                      BEGUN. TMP WILL FORCE DETACH.\nRUNSW    EQU   X'01'                   INDICATES RUN. TMP WILL NOT\n*                                      FORCE DETACH.\nTSTFLGS2 DS    X         +99           SWITCHES, BYTE 2\nTSTLDF   EQU   X'80'                   INDICATES IKJEGLDF IS RUNNING\n*                                      UNDER SUBTASK TCB\nTSTXCTL  EQU   X'40'                   INDICATES THAT SUBCMD PROCESSOR\n*                                      HAS ISSUED AN XCTL MACRO INSTRN\nTOFFDEF  EQU   X'20'                   INTERNAL SWITCH USED BY IKJEGWHR\n*        EQU   X'10'                   Reserved\nTADDROUT EQU   X'08'                   INTERNAL SWITCH USED BY IKJEGWHR\nTWHRLOAD EQU   X'04'                   INTERNAL SWITCH USED BY IKJEGOFF\nTSTQUAL  EQU   X'02'                   INDICATES QUALIFICATION IS IN\n*                                      PROGRESS\nTMYIOMSG EQU   X'01'                   INTERNAL SWITCH USED BY IKJEGIO\nTSTFLGS3 DS    X         +9A           SWITCHES, BYTE 3\nTSTGOSW  EQU   X'80'                   INDICATES A PSEUDO BREAKPOINT\n*                                      SET BY IKJEGLDR @ EP OF PROB PGM\nTSTSTAI  EQU   X'40'                   INDICATES THAT A TASK OF THE\n*                                      PROBLEM PGM HAS BEGUN TO ABEND\nSYMMESG  EQU   X'20'                   INDICATES THAT IKJEGSYM IS TO\n*                                      WRITE NO DIAGNOSTIC MESSAGES\nTCSECTCK EQU   X'10'                   INTERNAL SWITCH USED BY IKJEGOFF\nTDUPNAME EQU   X'08'                   INTERNAL SWITCH USED BY IKJEGOFF\nTSTLINK  EQU   X'04'                   INTERNAL SWITCH USED BY IKJEGMNL\nTSOHELP  EQU   X'02'                   Indicates that a TSO command\nTSTHELP  EQU   TSOHELP                 processor has been attached\nNOPARMS  EQU   X'01'                   INDICATES SUBCOMMAND ENTERED\n*                                      WITHOUT OPERANDS\nTSTFLGS4 DS    X         +9B           SWITCHES, BYTE 4\nTSTA     EQU   X'80'                   INDICATES INPUT FROM TERMINAL\nTSTB     EQU   X'40'                   INDICATES A TERMINAL ELEMENT HAS\n*                                      BEEN ADDED TO THE INPUT STACK\nTSTFLUSH EQU   X'20'                   INDICATES TO IKJEGMNL THAT THE\n*                                      TCLEARQ MACRO INSTR SHOULD BE\n*                                      ISSUED TO PURGE INPUT BUFFERS\nTSTRETRN EQU   X'10'                   INDICATES A RETRY IS IN PROCESS\nTSTESTAE EQU   X'08'                   IKJEGSTA IS INVOKING I/O FOR MSG\nTSTSVCAB EQU   X'04'                   SVC ABEND IS IN PROCESS\nTSTPERC  EQU   X'02'                   INDICATES THIS RETRY ROUTINE WAS\n*                                      PERCOLATED TO\nTSTVALCK EQU   X'01'                   INDICATES AN IKJPARS VALIDITY\n*                                      CHECK IS IN PROCESS\nBREAKTAB DS    A         +9C           ORIGIN OF ACTIVE BREAK ELEMENT Q\nDEFERTAB DS    A         +A0           ORIGIN OF DEFER ELEMENT QUEUE\nPPLOAD   DS    A         +A4           BASEADDR FOR RELATIVE ADDRESSES;\n*                                      CONTAINS THE LOADED ADDRESS OF\n*                                      THE PROBLEM PROGRAM\nPPTEMP   DS    A         +A8           TEMPORARY BASE FOR RELATIVE\n*                                      ADDRESSES\nSUBCHAIN DS    A         +AC           PTR TO SUBCMD IN MEMORY WHICH IS\n*                                      PART OF A CHAIN ASSOCIATED WITH\n*                                      A BREAKPOINT ELEMENT\nTSTGO    DS    0A        +B0           AREA USED FOR HANDLING PSEUDO\n*                                      BREAKPOINTS\nTSTGOPSW DS    A         +B0           A 4-BYTE SA USED FOR PSEUDO\n*                                      BREAKPOINTS; CONTAINS EITHER THE\n*                                      1ST 2 BYTES OF THE PROBLEM PGM'S\n*                                      ENTRY POINT INSTRUCTION WHEN\n*                                      TSTGOSW CONTAINS '1'B OR PROBLEM\n*                                      PGM RESTART ADDRESS (RBOPSW+4)\n*                                      WHEN TSTGOSW CONTAINS '0'B\nTSTGOWCF DS    X         +B4           WAIT COUNT FROM RBWCF FOR A\n*                                      MODULE OF THE PROBLEM PGM WHEN\n*                                      A PSEUDO BREAKPOINT HAS BEEN SET\nTSTRSVD2 DS    X         +B5           RESERVED\nTSTSVC   SVC   97        +B6           CONTAINS AN SVC 97 INSTRUCTION\n*                                      (X'0A61' THAT IS EXECUTED TO\n*                                      CAUSE A PSEUDO BREAKPOINT TO\n*                                      BE EXECUTED).\nPPRB     DS    A         +B8           PTR TO PRB FOR THE PROBLEM\n*                                      PROGRAM MODULE THAT IS CURRENTLY\n*                                      QUALIFIED\nTSTIODCB DS    A         +BC           PTR TO DCB OPENED TO WRITE TO A\n*                                      DATA SET SPECIFIED IN A PRINT\n*                                      KEYWORD PARAMETER\nCALLPARM DS    A         +C0           HEAD OF CHAIN OF CALL PARAMETER\n*                                      LISTS BUILT BY IKJEGGO WHEN IT\n*                                      IS ENTERED AT EP IKJEGCAL\n         DS    A         +C4           RESERVED\nINTSTDDN DS    CL8       +C8           Ddname for data set specified on\n*                                      the TEST command.  Used by\n*                                      IKJEGINT and IKJEGLDR.\n         ORG   INTSTDDN\nTSTCURLD DS    CL8       +C8           EBCDIC NAME OF CURRENTLY\n*                                      QUALIFIED LOAD MODULE\nTERMDD   DS    CL8       +D0           Ddname for terminal used by\n*                                      DFP loader\n         ORG   TERMDD\nTSTCURCT DS    CL8       +D0           EBCDIC NAME OF CURRENTLY\n*                                      QUALIFIED CSECT\nTSTSYMBA DS    A         +D8           BASE ADDR FOR SYMBOLIC ADDRESSES\nTSTTRN   DS    A         +DC           PTR TO CHAIN OF CONTROL WORDS\n*                                      BUILT BY IKJEGINT FROM INFO\n*                                      SUPPLIED BY THE SVC 61 ROUTINE\n*                                      (SEE IKJEGSVQ)\nSICHAIN  DS    A         +E0           PTR TO SYMBOL INFORMATION BLOCK\n*                                      (SIB) QUEUE BUILT BY IKJEGSYM\nTSTSYMWK DS    A         +E4           PTR TO WORKAREA ACQUIRED FOR\n*                                      SYMBOL PROCESSING\nSYMTABLE DS    A         +E8           PTR TO QUEUE OF TABLE ELEMENTS\n*                                      BUILT BY IKJEGEQU\nPPEXIT   DS    0A        +EC           CONTAINS SVC INSTRUCTIONS\nPPEXIT1  SVC   97        +EC           CONTAINS AN SVC 97 INS (X'0A61')\nPPEXIT2  SVC   3         +EE           CONTAINS AN SVC 3 INST (X'0A03')\nTSTDCB   DS    A         +F0           POINTER TO QUEUE OF DCB'S\n*                                      MAINTAINED IN OVERLAY MODE\nOPCODTAB DS    A         +F4           PTR TO TABLE OF VALID OP CODES\nTSTOPCD2 DS    A         +F8           PTR TO TABLE OF VALID S/370\n*                                      TWO-BYTE OPERATION CODES\n         DS    A         +FC           RESERVED\n         DS    A        +100           RESERVED\nTSTHTCB  DS    A        +104           Pointer to TCB for a TSO command\nTSTOTCB  EQU   TSTHTCB\nTSTAQUAL DS    CL8      +108           Automatic qualification info:\n*                                      load module name\nTSTAQEP  DS    A        +110           PTR TO EP OF THE LOAD MODULE\n*                                      THAT IKJEGMNL LAST AUTOMATICALLY\n*                                      QUALIFIED\nTSTRSTRT DS    A        +114           PTR TO RETRY ROUTINE THAT IS\n*                                      EXECUTED AFTER AN ESTAE EXIT\n*                                      ROUTINE INTERCEPTED AN ABEND\n*                                      IN THE TEST PROGRAM\nTSTSRHT  DS    A        +118           ADDRESS OF RESIDENT BREAKPOINT\n*                                      SEARCH ROUTINE\nTSTSTAX  DS    5A       +11C           STAX PARAMETER LIST\nTSTDSECB DS    A        +130           TEST DISPATCHABILITY ECB\nTSTMNLWK DS    XL56     +134           IKJEGMNL WORK AREA\nTSTIOPRM DS    XL84     +16C           I/O PARAMETER AREA\nTSTSVCM1 DS    A        +1C0           SVC FIRST LEVEL MESSAGE NUMBER\n*                                      FOR USE BY IKJEGMNL OR IKJEGINT\nTSTSVCM2 DS    A        +1C4           SVC SECOND LEVEL MESSAGE NUMBER\n*                                      FOR USE BY IKJEGMNL OR IKJEGINT\nTSTOPCD4 DS    A        +1C8           Pointer to table of A4 opcodes\nTSTOPCD5 DS    A        +1CC           Pointer to table of A5 opcodes\nTSTOPCD6 DS    A        +1D0           Pointer to table of A6 opcodes\nABNDTCB  DS    A        +1D4           Abending TCB address\nTSTECTSV DS    XL56     +1D8           Save area for the ECT\nTSTOPCD7 DS    A        +210           Pointer to table of E4 opcodes\nTSTVPARM DS    0A       +214           Vector facility parameters\nTSTVSS   DS    H        +214           Vector section size\nTSTVPS   DS    H        +216           Vector partial sum number\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSG": {"ttr": 22273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x00N\\x00N\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=XVX00    0100-07332-07332-0900-00027-00027-00000-SEB\nXVX001   'INVALID RESET VALUE     '    .ALARM=YES\n'The RESET command value must be hex (or decimal with N), optionally signed.'\n\nXVX002   'INVALID OFFSET          '    .ALARM=YES\n'The offset for the LEFT or RIGHT command must be hex (or decimal with N).'\n\nXVX003   'INVALID COMMAND         '    .ALARM=YES\n'An invalid hex address or unknown command name was entered.'\n\nXVX004   'ADDRESS TOO HIGH        '    .ALARM=YES\n'The specified address exceeds X''7FFFFFFF''.'\n\nXVX005   'VALUE TOO LONG          '    .ALARM=YES\n'Maximum: 8 hex (optionally followed by period) or 10 decimal (followed by N).'\n\nXVX006   'INVALID ADDRESS         '    .ALARM=YES\n'Address must be 1-8 hex chars plus optional period, or 1-10 digits plus N.'\n\nXVX007   'STORAGE NOT ACCESSIBLE  '    .ALARM=YES\n'Requested storage is fetch protected or not mapped to real storage.'\n\nXVX008   'WRAPAROUND OCCURRED     '    .ALARM=NO\n'The specified storage extends beyond the highest machine address.'\n\nXVX009   'INVALID SCROLL AMOUNT   '    .ALARM=YES\n'Valid amounts are:  P (PAGE), H (HALF), C (CSR), D (DATA) or 1 to 9999.'\n\n./ ADD NAME=XVX01    0100-07332-07332-0900-00030-00030-00000-SEB\nXVX010   'INVALID OPERAND         '    .ALARM=YES\n'A 1-to-8-character load module name must be specified.'\n\nXVX011   'LOAD FAILED             '    .ALARM=YES\n'Load module not found, insufficient storage, or not executable.'\n\nXVX012   'LOAD SUCCESSFUL         '    .ALARM=NO\n'Requested module loaded into main storage; display set to entry point.'\n\nXVX013   'DELETE SUCCESSFUL       '    .ALARM=NO\n'Requested module deleted from main storage.'\n\nXVX014   'DELETE FAILED           '    .ALARM=YES\n'Requested module not deleted from main storage.'\n\nXVX015   'INVALID LABEL           '    .ALARM=YES\n'A label must consist of 1-8 alphanumerics, first character alphabetic.'\n\nXVX016   'LABEL &VLABEL ASSIGNED  '    .ALARM=NO\n'Label &VLABEL has been assigned to address &VADDR..'\n\nXVX017   'LABEL &VLABEL REASSIGNED'    .ALARM=NO\n'Label &VLABEL has been reassigned to address &VADDR..'\n\nXVX018   'NO LABELS DEFINED       '    .ALARM=NO\n'To equate a label to the current address, enter a period plus a valid name.'\n\nXVX019   'ADDRESS NOT ACCESSIBLE  '    .ALARM=YES\n'Storage not accessible at location where indirect addressing was requested.'\n\n./ ADD NAME=XVX02    0100-07332-07332-0900-00018-00018-00000-SEB\nXVX020   'INVALID NUMBER OF LINES '    .ALARM=YES\n'Enter a number between 1 and the maximum number of lines on the display.'\n\nXVX021   'LABEL NOT FOUND         '    .ALARM=YES\n'The requested label is not defined.'\n\nXVX022   'NO PREVIOUS ADDRESS     '    .ALARM=YES\n'Backtracking is not possible; the previous-address stack is empty.'\n\nXVX023   'INVALID PARAMETER       '    .ALARM=YES\n'Either \"ON\" or \"OFF\" must be specified (default is \"ON\").'\n\nXVX024   'LABEL ALREADY DEFINED   '    .ALARM=YES\n'The requested label already exists.  Use the ! prefix to force reassignment.'\n\nXVX025   'INVALID SCROLL AMOUNT   '    .ALARM=YES\n'MAX is not a valid scroll amount with this function.'\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PANEL": {"ttr": 22276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x01\\xca\\x01\\xca\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 458, "newlines": 458, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=TXVX     0100-07332-07332-0900-00034-00034-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |      VIRTUAL STORAGE DISPLAY    |\n                      -----------------------------------\n\n+This option permits the system programmer to \"browse\" live virtual storage in\n his/her own address space (as well as common areas like the nucleus, PLPA,\n CVT, etc.).  Storage is displayed in 16-byte rows in pseudo-dump format.\n\n+Storage integrity is supported across 256-byte blocks provided that\n wraparound does not occur.  In other words, when viewing a section of\n volatile storage, the first 256 bytes, the next 256 bytes and the data\n following the second group of 256 bytes may or may not reflect the same\n machine status, but within each 256-byte group the data will be correct.\n\n+The following topics are presented in sequence, or may be selected by number:\n\n  %1  DISPLAY FORMAT....+Explanation of the display.\n  %2  SCROLLING.........+Manipulating the display.\n  %3  VALUE FORMATS.....+Valid formats for addresses, offsets, etc.\n  %4  PRIMARY COMMANDS..+What can be entered on the command input line.\n  %5  NEW FEATURES......+Version 2 changes.\n)PROC\n &ZSEL = TRANS( &ZCMD\n                1,TXVX1\n                2,TXVX2\n                3,TXVX3\n                4,TXVX4\n                5,TXVX5\n                *,'?'\n                )\n)END\n./ ADD NAME=TXVX1    0100-07332-07332-0900-00026-00026-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |      DISPLAY FORMAT             |\n                      -----------------------------------\n+\n Virtual storage is displayed in rows of 16 bytes in pseudo-dump format (in\n other words, 4 4-byte hex entries and a 16-byte EBCDIC translation line).  In\n addition, two offset fields are displayed on the left side of the screen:\n\n%Virtual offset+- this is the rightmost of the two fields, and identifies the\n virtual address of the data.\n\n%Relative offset+- this is the leftmost of the two fields, and identifies the\n relative offset (positive or negative) of the data from an origin point.  The\n origin point is set to zero at entry to this option and is also set to zero\n when an address is entered (it may also be explicitly changed by the RESET or\n BASE command).  It is maintained during a scrolling operation, so that you can\n find a control block, set the origin of the control block to zero and then\n scroll through the display using the offset fields to indicate where you are in\n the control block.\n%Note:+If the offset overflows, the origin is reset to zero.\n)PROC\n &ZCONT = TXVX10\n)END\n./ ADD NAME=TXVX10   0100-07332-07332-0900-00025-00025-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |   DISPLAY FORMAT (CONTINUED)    |\n                      -----------------------------------\n+\n Virtual storage may also be displayed in%binary+format (rows of 4 bytes in\n binary, hexadecimal and character format), including the same two offset\n fields.  To switch to this format, enter the%BINARY ON+command.  To return to\n normal display format, enter%BINARY OFF.+\n\n%Note:+The following forms are equivalent:\n\n%      BINARY ON  =  BIN ON  =  BINARY  =  BIN\n       BINARY OFF  =  BIN OFF\n+\n In both formats, attempts will be made to show as much storage as is\n accessible.  If not all the storage is accessible, the maximum number of lines\n that can be shown will be shown.  You may also use the%SHOW+command to control\n the number of display lines;%SHOW number+will set the number of lines displayed\n to \"number\", and%SHOW+with no operand will restore the full display.\n)PROC\n &ZCONT = TXVX11\n)END\n./ ADD NAME=TXVX11   0100-07332-07332-0900-00025-00025-00000-SEB\n)BODY DEFAULT(?+_)\n?TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n?SELECTION ===>_ZCMD                                                           +\n?\n?                     -----------------------------------\n                      |   DISPLAY FORMAT (CONTINUED)    |\n                      -----------------------------------\n+\n You may vary the intensity of the display areas as follows:\n\n?%DATAINT +-  show data area in?high intensity,+addresses in low intensity\n?%ADDRINT +-  show data area in low intensity, addresses in?high intensity+\n?%ALLINT  +-  show entire display in?high intensity+\n?%NOINT   +-  show entire display in low intensity\n\n+where \"data area\" refers to the hexadecimal display when binary mode\n is off, and to the binary display when binary mode is on.\n\n+The EBCDIC (character) portion of the display, as well as the\n hexadecimal portion in binary mode, is always of the same intensity\n as the address portion.\n\n+The settings are remembered in your user profile.\n)PROC\n)END\n./ ADD NAME=TXVX2    0100-07332-07332-0900-00024-00024-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |        SCROLLING                |\n                      -----------------------------------\n\n   %UP+and%DOWN+commands or PF keys specify the number of%lines+to move\n    the display (a line is 16 bytes of data except in binary mode, in\n    which case it is 4 bytes).  The default scroll amount may be\n    temporarily overridden in the COMMAND field or permanently reset.\n    You may enter PAGE, HALF, CURSOR (CSR), or DATA, as well as any\n    numeric between 1 and 9999.  A MAX amount is invalid.\n\n   %LEFT+and%RIGHT+commands or PF keys specify the number of%bytes+ to\n    move the display.  If no byte count is specified, the display is\n    moved%1 byte+in the specified direction.  The format for the count\n    on the LEFT and RIGHT commands is described in the VALUE FORMATS\n    section of this tutorial.\n\n    In all scrolling cases, the origin is unchanged; therefore, the\n    offset field changes dynamically.\n)PROC\n)END\n./ ADD NAME=TXVX3    0100-07332-07332-0900-00022-00022-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |         VALUE FORMATS           |\n                      -----------------------------------\n\n+   Values used as addresses or offsets may be entered in hexadecimal\n    or decimal format.\n\n    Hex values consist of from 1 to 8 hex characters (0-9, A-F).\n    If the value is being used as an address (not an offset), an\n    optional period may be included at the end (this period is\n    required if the address is the operand of the WHERE command).\n\n    Decimal values consist of from 1 to 10 decimal digits (0-9)\n    followed by the letter N.\n\n    In most cases the maximum usable value is 2147483647 (hex 7FFFFFFF).\n    However, not all virtual addresses will be accessible.\n)PROC\n)END\n./ ADD NAME=TXVX4    0100-07332-07332-0900-00029-00029-00000-SEB\n)ATTR DEFAULT(!+_)\n)BODY\n!TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n!SELECTION ===>_ZCMD                                                           +\n!\n!                     -----------------------------------\n                      |      PRIMARY COMMANDS           |\n                      -----------------------------------\n\n+The following may be entered on the primary command line:\n\n (1) Any valid virtual address (see the VALUE FORMATS section of this\n     tutorial for description), or label (see the LABELS section).\n     This moves the display and resets the origin to the new address.\n\n     Alternatively, an offset value preceded by a plus or minus sign\n     may be entered.  This causes the display to be moved so that the\n     specified offset from the origin becomes the new top line address.\n\n     Any of the above may be followed by one or more percent signs!%+or question\n     marks!?+indicating levels of indirect addressing (% = 24-bit, ? = 31-bit).\n     Specifying %'s or ?'s alone begins indirection from the top line address.\n\n     If the storage is fetch protected, no change in the display takes place.\n\n                             - continued -\n)PROC\n &ZCONT = TXVX40\n)END\n./ ADD NAME=TXVX40   0100-07332-07332-0900-00024-00024-00000-SEB\n)ATTR DEFAULT(?+_)\n)BODY\n?TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n?SELECTION ===>_ZCMD                                                           +\n?\n?                     -----------------------------------\n                      |      PRIMARY COMMANDS           |\n                      -----------------------------------\n\n+(2) The?LOCATE+command, which specifies an address as described in\n     the preceding tutorial screen and whose processing is identical.\n     This command may be abbreviated to LOC (but not L).\n\n+(3) The?BASE+command, which alters the origin address so that the\n     offsets displayed are from the address specified on this command\n     (which is in a format similar to that for LOCATE but with no\n     indirection permitted).  If no operand is specified on this\n     command, the origin is reset to zero (i.e. the current address\n     is used as the base).\n\n                             - continued -\n)PROC\n &ZCONT = TXVX41\n)END\n./ ADD NAME=TXVX41   0100-07332-07332-0900-00027-00027-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |  PRIMARY COMMANDS - CONTINUED   |\n                      -----------------------------------\n+\n (4) The%WHERE+command, if entered with a load module name, displays\n     the location of the module in the current job pack area and/or the\n     link pack area (PLPA or MLPA).  If entered with an address\n     (which%must+be 1 to 8 hex characters followed by a period), the\n     WHERE command displays the name of the module in the JPA or LPA\n     which occupies the storage at that address.\n\n     If WHERE is entered with no operands, the entire contents of the\n     JPA, LPA and MLPA are displayed.\n\n (5) The%RESET+command, entered with a value (see VALUE FORMATS)\n     optionally preceded by a plus or minus sign, resets the origin\n     so that the offset of the current top line is set to the value\n     specified on the command.  If no operand is entered, the origin\n     is set to zero.\n\n                                 - continued -\n)PROC\n &ZCONT = TXVX42\n)END\n./ ADD NAME=TXVX42   0100-07332-07332-0900-00024-00024-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                     -----------------------------------\n                      |  PRIMARY COMMANDS - CONTINUED   |\n                      -----------------------------------\n+\n (6) The%LOAD+command, entered with a load module name, brings a load\n     module into virtual storage via the MVS LOAD macro.  Upon\n     successful completion of the operation, the display is reset\n     to the%entry point+of the loaded module.\n\n (7) The%DELETE+command, entered with a load module name, issues the\n     MVS DELETE macro to decrease the responsibility count for the\n     specified load module and, if possible, remove it from storage.\n     The user should be sure to DELETE all modules brought into\n     virtual storage via the LOAD command; otherwise these modules\n     will remain in storage for the duration of the logical screen\n     session, possibly causing insufficient storage to be available\n     for other functions.\n                             - continued -\n)PROC\n &ZCONT = TXVX43\n)END\n./ ADD NAME=TXVX43   0100-07332-07332-0900-00027-00027-00000-SEB\n)BODY DEFAULT(@+_)\n@TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n@SELECTION ===>_ZCMD                                                           +\n@\n@                     -----------------------------------\n                      |  DEFINING AND USING LABELS      |\n                      -----------------------------------\n+\n@Labels+may be defined and referenced in a session.  To define a label, enter a\n period@.+followed by a 1-to-8-character label name (the name must consist of\n alphanumerics and nationals with the first character alphabetic or national).\n\n The label will be assigned the current top line display address.\n\n To use a label, simply enter the label name (or@LOCATE labelname+)@without+the\n period.  The display will be set to the requested location.  Percent sign(s)@%+\n or question marks@?+may follow the name if indirect addressing is desired\n (% for 24-bit addresses, ? for 31-bit addresses).\n\n To delete a label, use the@DROP+command (enter: DROP labelname).\n\n To list your currently defined labels, enter the@LABELS+command.\n\n                               - continued -\n)PROC\n &ZCONT = TXVX44\n)END\n./ ADD NAME=TXVX44   0100-07332-07332-0900-00023-00023-00000-SEB\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           +\n%\n%                -------------------------------------------\n                 |  DEFINING AND USING LABELS (CONTINUED)  |\n                 -------------------------------------------\n+\n If a label name conflicts with a command name, use the LOCATE command, e.g.\n\n   LOC BASE\n\n If the syntax of a label name is such that it could be interpreted as an\n address, it will be treated as a label if you have defined it as one; otherwise\n it is considered an address.  To use the address, include a period, e.g.\n\n   LOC ABC4.\n\n If a label already exists, it cannot be reassigned by entering its name with a\n period preceding it.  If you want to override an existing label definition,\n DROP it first, or precede it with an exclamation mark%!+instead of a period.\n)PROC\n &ZCONT = TXVX45\n)END\n./ ADD NAME=TXVX45   0100-07332-07332-0900-00022-00022-00000-SEB\n)ATTR DEFAULT(%!_)\n)BODY\n%TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n%SELECTION ===>_ZCMD                                                           !\n%\n%                     -----------------------------------\n                      |  OTHER PRIMARY COMMANDS         |\n                      -----------------------------------\n!\n An internal stack of up to 16 previously referenced addresses is remembered; if\n you wish to return to the previous address (perhaps because you entered a\n garbage address), enter the%BACK!command to return.\n\n Scrolling does not affect the address portion of the stack, although it does\n update the origin value associated with the current stack entry.  If you wish\n to return to the base location, enter the command%+0!to scroll to it, not the\n BACK command.\n\n To clear the internal stack, enter the%CLEAR!command.\n)PROC\n &ZCONT = TXVX5\n)END\n./ ADD NAME=TXVX5    0100-07332-07332-0900-00025-00025-00000-SEB\n)BODY DEFAULT(!+_)\n!TUTORIAL ------------------- VIRTUAL STORAGE DISPLAY ----------------- TUTORIAL\n!SELECTION ===>_ZCMD                                                           +\n!\n!                     -----------------------------------\n                      | NEW FEATURES WITH VERSION 2     |\n                      -----------------------------------\n\n+XVX version 2 now has the following features to support MVS/XA and ISPF V.2:\n\n (1) 31-bit addresses are supported.  The 31-bit indirection symbol!?+\n     is supported along with the 24-bit indirection symbol!%.+\n\n (2) The scroll amount field may now be specified as any valid normal\n     scroll amount with the exception of MAX - i.e.!PAGE, HALF, CSR\n    +and!DATA+are all acceptable.  The initial scrolling default is PAGE,\n     but you may override this and it will be remembered in your profile.\n\n (3) The LEFT and RIGHT commands (and PF keys) now default to a value of\n    !one byte+rather than taking their default value from the scroll amount.\n\n (4) New commands are provided to selectively alter the intensity of\n     different parts of the display.\n)PROC\n)END\n./ ADD NAME=XVX      0100-07332-07332-0900-00059-00059-00000-SEB\n)ATTR\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n \\  TYPE(TEXT) INTENS(&XVXI01) COLOR(&XVXC01)\n 01 TYPE(DATAOUT) INTENS(&XVXI01)       /* For address and non-data fields */ +\n    COLOR(&XVXC01)\n 02 TYPE(DATAOUT) INTENS(&XVXI02)       /* For the primary data field      */ +\n    COLOR(&XVXC02)\n)BODY\n%XVX --------------------- VIRTUAL STORAGE DISPLAY -----------------------------\n%ADDRESS ==>_ZCMD                                             %SCROLL ===>_Z   +\n+                                                                              \\\n|VX                                                                            |\n)INIT\n .ZVARS = '(XVXAMT)'\n .HELP = TXVX\n IF (&XVXAMT = '')\n  &XVXAMT = 'PAGE'\n IF (&XVXI01 = '')\n  &XVXI01 = 'HIGH'\n IF (&XVXI02 = '')\n  &XVXI02 = 'LOW'\n IF (&XVXC01 = '')\n  &XVXC01 = 'YELLOW'\n IF (&XVXC02 = '')\n  &XVXC02 = 'GREEN'\n)REINIT\n REFRESH(VX,ZCMD,XVXAMT)\n .ATTRCHAR(\\) = 'INTENS(&XVXI01) COLOR(&XVXC01)'\n .ATTRCHAR(01) = 'INTENS(&XVXI01) COLOR(&XVXC01)'\n .ATTRCHAR(02) = 'INTENS(&XVXI02) COLOR(&XVXC02)'\n)PROC\n &VXLVLIN = LVLINE(VX)\n IF (&ZCMD = '%DATAINT')\n  &ZCMD = ''\n  &XVXI01 = 'LOW'\n  &XVXI02 = 'HIGH'\n  &XVXC01 = 'BLUE'\n  &XVXC02 = 'PINK'\n IF (&ZCMD = '%ADDRINT')\n  &ZCMD = ''\n  &XVXI01 = 'HIGH'\n  &XVXI02 = 'LOW'\n  &XVXC01 = 'YELLOW'\n  &XVXC02 = 'GREEN'\n IF (&ZCMD = '%NOINT')\n  &ZCMD = ''\n  &XVXI01 = 'LOW'\n  &XVXI02 = 'LOW'\n  &XVXC01 = 'TURQ'\n  &XVXC02 = 'TURQ'\n IF (&ZCMD = '%ALLINT')\n  &ZCMD = ''\n  &XVXI01 = 'HIGH'\n  &XVXI02 = 'HIGH'\n  &XVXC01 = 'WHITE'\n  &XVXC02 = 'WHITE'\n VPUT (XVXAMT XVXI01 XVXI02) PROFILE\n)END\n Comment in lower case to preserve CAPS OFF.\n./ ADD NAME=XVXERROR 0100-07332-07332-0900-00026-00026-00000-SEB\n%---------------- XVX - VIRTUAL STORAGE DISPLAY ERROR --------------------------\n%COMMAND ==>_ZCMD                                                              +\n\n%\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n%       * *                                                           * *\n%       * *    One of the following errors occurred in panel XVX:     * *\n%       * *                                                           * *\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n%       * *                                                           * *\n%       * *      No dynamic area named VX existed in the panel.       * *\n%       * *                                                           * *\n%       * * The number of lines that XVX tried to display exceeds 40. * *\n%       * * XVX cannot support more than 40 lines of scrollable area  * *\n%       * * in a logical screen display.                              * *\n%       * *                                                           * *\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n%       * *                                                           * *\n%       * *  Press the ENTER key to terminate this option.            * *\n%       * *                                                           * *\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n%       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSLOAD": {"ttr": 22284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PLI": {"ttr": 22531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x073/\\x01\\x073/\\t\\x00\\x0f\\xbc\\x0f\\xbc\\x00\\x00\\xe2\\xc5\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-28T00:00:00", "modifydate": "2007-11-28T09:00:00", "lines": 4028, "newlines": 4028, "modlines": 0, "user": "SEB"}, "text": "./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00043-00043-00000-SEB\n------------------------------------------------------------------------\nName:     PBRHELP\nType:     PLI\nPurpose:  Use BRIF to display TSO command output under ISPF.\nRequires: INCLUDE XTSOVAR\n          ASM     XTSOVAR\n          ASM     PBRHLPA\n          PLI     PBRHLPR\nUsed by:  CLIST BRHELP\nComments:\n------------------------------------------------------------------------\nName:     PBRHLPR\nType:     PLI\nPurpose:  Use BRIF to display TSO command output under ISPF.\nRequires: INCLUDE XTSOVAR\n          ASM     XTSOVAR\n          ASM     PBRHLPA\n          PLI     PBRHELP\nUsed by:  CLIST BRHELP\nComments:\n------------------------------------------------------------------------\nName:     PLICOMP\nType:     PLI\nPurpose:  Compare two data sets.\nRequires: INCLUDE DCLDCB (q.v.)\nUsed by:  CLIST COMP (q.v.)\nComments:\n------------------------------------------------------------------------\nName:     PLIXXC\nType:     PLI\nPurpose:  Do hex calculations.\nRequires: INCLUDE XTSOVAR (q.v.)\n          ASM XGET, XPUT, XTSOVAR\nUsed by:  CLIST HEXADD, HEXSUB, IPCSEQP, SBA\nComments:\n------------------------------------------------------------------------\nName:     XDIS\nType:     PLI\nPurpose:  Disassemble load module CSECTs.\nRequires:\nUsed by:  CLIST COMPDIS (q.v.)\nComments:\n------------------------------------------------------------------------\n./ ADD NAME=PBRHELP  0100-07332-07332-0900-00064-00064-00000-SEB\n PBRHELP: Proc(PARM) options(main);\n\n Dcl PARM char(100) var;\n Dcl ISPLINK entry external options(assembler inter retcode);\n Dcl PBRHLPA entry external options(assembler inter retcode);\n Dcl (PLIRETV, Addr, Bin, Substr, Verify) builtin;\n Dcl PLIXOPT ext char(2) var init('NR');\n Dcl LINES (*) char(72) ctl;\n Dcl I fixed(31) bin;\n Dcl BRHELPLINE       fixed(31) bin static init(-1);\n\n Dcl 1 DIALOG_DATA,\n       2 LINECOUNT fixed(31) bin,\n       2 LINEARRAY ptr;\n\n %INCLUDE XTSOVAR;\n\n Fetch ISPLINK;\n\n BRHELPLINE = GET_LAST_LINE();\n\n Allocate LINES (BRHELPLINE);\n\n Do I = 1 to BRHELPLINE;\n  LINES(I) = GET_LINE(I);\n End;\n\n LINECOUNT = BRHELPLINE;\n LINEARRAY = Addr(LINES);\n\n Call ISPLINK ('BRIF ',\n               'HELP_DATA ',\n               'F ',\n               Bin(72,31),\n               PBRHLPA,\n               ' ', /* cmd-routine */\n               Addr(DIALOG_DATA),\n               'BRHELP  ', /* panel name */\n               ' ',        /* format name        */\n               ' ');       /* no DBCS data       */\n\n Free LINES;\n\n\n\n GET_LAST_LINE: Proc returns(fixed(31) bin);\n  Dcl BRHELPLINE_VALUE static char(10) var;\n  Call XTSOVAR('R','BRHELPLINE',BRHELPLINE_VALUE);\n  Return(BRHELPLINE_VALUE);\n End GET_LAST_LINE;\n\n GET_LINE: Proc(NUM) returns(char(72));\n  Dcl NUM fixed(31) bin;\n  Dcl CNUM static char(11);\n  Dcl THE_LINE static char(72) var;\n  Put string(CNUM) edit(NUM) (X(1),P'ZZZZZZZZZ9');\n  CNUM = Substr(CNUM,Verify(CNUM,' '));\n  Call XTSOVAR('R','SYSOUTLINE'||CNUM,THE_LINE);\n  Return(THE_LINE);\n End GET_LINE;\n\n End PBRHELP;\n\n\n./ ADD NAME=PBRHLPR  0100-07332-07332-0900-00043-00043-00000-SEB\n\n PBRHLPR: Proc (PDATA, /* pointer to output from read rte */\n                LDATA, /* length if RECFM = V... or U */\n                RRNUM, /* relative record number */\n                PDDAT) /* dialog data area address */\n         options(fortran /* retcode is invalid with fortran */)\n         returns(fixed(31) bin);\n\n Dcl PDATA ptr,\n     LDATA fixed(31) bin,\n     RRNUM fixed(31) bin,\n     PDDAT ptr;\n\n Dcl LINES(32767) char(72) based(LINEARRAY);\n\n Dcl 1 DIALOG_DATA based(PDDAT),\n       2 LINECOUNT fixed(31) bin,\n       2 LINEARRAY ptr;\n\n Dcl DATA_LINE        char(72) static;\n Dcl LAST_LINE        char(72) static init(\n '********************* END OF HELP DATA *****************************'\n                                          );\n Dcl (ADDR, PLIRETC, VERIFY, SUBSTR) builtin;\n\n %INCLUDE XTSOVAR;\n\n If RRNUM > LINECOUNT then do;\n  RRNUM = LINECOUNT;\n  PDATA = ADDR(LINES(LINECOUNT));\n  Call PLIRETC(8);\n  Return(8);\n End;\n\n Else do;\n  PDATA = Addr(LINES(RRNUM));\n  Call PLIRETC(0);\n  Return(0);\n End;\n\n\n End PBRHLPR;\n\n./ ADD NAME=PLICOMP  0100-07332-07332-0900-00247-00247-00000-SEB\n*PROCESS MACRO;\n PLICOMP: Proc(PARM) options(main);\n Dcl\n          PARM                           char(100) var;\n Dcl\n          RECORD_SIZE       (2)   static fixed(31) bin,\n          LOOKASIDE_INDEX   (2)   static fixed(15) bin init(0),\n          LOOKASIDE_MAX     (2)   static fixed(15) bin init(0),\n          START_COLUMN            static fixed(15) bin init(0),\n          END_COLUMN              static fixed(15) bin init(0),\n          MISMATCH_COUNT          static fixed(15) bin init(0),\n          RECORD_LENGTH           static fixed(15) bin,\n          COMPARE_LENGTH          static fixed(15) bin,\n          (I,J,K)                 static fixed(15) bin;\n Dcl\n          RECORD            (2)          char(256) var,\n          SAVE_RECORD       (2)          char(256) var,\n          MISMATCH          (2,*) ctl    char(256) var,\n          LOOKASIDE         (2,*) ctl    char(256) var;\n Dcl\n          (INDD1, INDD2)          file   record    input,\n          INDD              (2)   file   variable  init(INDD1,INDD2),\n          SYSPRINT                file   stream    output;\n Dcl\n          PHYSICAL_EOF      (2)   static bit(1)    init((2)(1)'0'B),\n          LOGICAL_EOF       (2)   static bit(1)    init((2)(1)'0'B),\n          RECFM_V           (2)   static bit(1)    init((2)(1)'0'B),\n          MATCH                   static bit(1)    init('0'B),\n          INDDDCB           (2)   static ptr,\n          REC_PTR                 static ptr,\n          DCBPTR                  static ptr,\n          UNMATCHED               static fixed dec init(0),\n          RECNO                   static fixed dec init(0),\n          RECNO_V                 static char(8)   var,\n          RECNO_P                 static pic'ZZZZZZ9',\n          RECNO_C                        char(7)   def RECNO_P,\n          INPUT_REC                      char(256) based(REC_PTR);\n Dcl\n          TRANSLATE_ARRAY   (16) static  char(16)\n                     init('................',  /* 00 - 0F */\n                          '................',  /* 10 - 1F */\n                          '................',  /* 20 - 2F */\n                          '................',  /* 30 - 3F */\n                          ' ...........<(+|',  /* 40 - 4F */\n                          '&.........!$*);^',  /* 50 - 5F */\n                          '-/.........,%_>?',  /* 60 - 6F */\n                          '.........`:#@''=\"', /* 70 - 7F */\n                          '.abcdefghi......',  /* 80 - 8F */\n                          '.jklmnopqr......',  /* 90 - 9F */\n                          '.~stuvwxyz......',  /* A0 - AF */\n                          '................',  /* B0 - BF */\n                          '{ABCDEFGHI......',  /* C0 - CF */\n                          '}JKLMNOPQR......',  /* D0 - DF */\n                          '\\.STUVWXYZ......',  /* E0 - EF */\n                          '0123456789......'), /* F0 - FF */\n\n          TRANS_TABLE                   char(256) def TRANSLATE_ARRAY;\n Dcl\n          DCBADDR        external entry(file) returns(ptr),\n          (Index,Length,Max,Min,Substr,Translate,Unspec,Verify)\n                         builtin,\n          PLIXOPT static external char(2) var init('NR');\n\n %INCLUDE SYSLIB(DCLDCB);\n\n On Endfile(INDD1) PHYSICAL_EOF(1) = '1'B;\n On Endfile(INDD2) PHYSICAL_EOF(2) = '1'B;\n\n Get string(PARM) list(START_COLUMN, END_COLUMN, MISMATCH_COUNT);\n\n Open file(INDD1) input, file(INDD2) input;\n\n Do I = 1 to 2;\n   DCBPTR = DCBADDR(INDD(I));\n   INDDDCB(I) = DCBPTR;\n   RECORD_SIZE(I) = DCBLRECL;\n   RECFM_V(I) = DCBRECL = DCBRECV;\n End;\n\n RECORD_LENGTH = Min(RECORD_SIZE(1),RECORD_SIZE(2));\n\n If START_COLUMN = 0 then START_COLUMN = 1;\n\n If END_COLUMN = 0 then\n   COMPARE_LENGTH = RECORD_LENGTH - START_COLUMN + 1;\n Else\n   COMPARE_LENGTH = Min(END_COLUMN,RECORD_LENGTH) - START_COLUMN + 1;\n\n If COMPARE_LENGTH < 0 then do;\n   Put skip(1) list('Invalid parameters - column conflicts');\n   Return;\n End;\n\n Put skip(1) list('...File compare begins...');\n\n Put edit('Record size of file 1 is:',RECORD_SIZE(1)) (R(FMT));\n Put edit('Record size of file 2 is:',RECORD_SIZE(2)) (R(FMT));\n Put edit('Compare length is:       ',COMPARE_LENGTH) (R(FMT));\n Put skip(1);\n\n FMT: Format(Skip,A(25),P'ZZZZZ9');\n\n If MISMATCH_COUNT ^= 0 then do;\n   Allocate MISMATCH(2,MISMATCH_COUNT);\n   Allocate LOOKASIDE(2,MISMATCH_COUNT);\n End;\n\n LOOP:  Do until (LOGICAL_EOF(1) | LOGICAL_EOF(2)) ;\n\n   Call GET_RECORD(1);\n   Call GET_RECORD(2);\n\n   If LOGICAL_EOF(1) & LOGICAL_EOF(2) then Leave LOOP;\n   IF LOGICAL_EOF(1) then do;\n     Put skip(2) list('More records on file 2 than file 1');\n     Do until (LOGICAL_EOF(2));\n       Put skip(1) list(Translate(RECORD(2),TRANS_TABLE));\n       Call GET_RECORD (2);\n     End;\n     Leave LOOP;\n   End;\n   IF LOGICAL_EOF(2) then do;\n     Put skip(2) list('More records on file 1 than file 2');\n     Do until (LOGICAL_EOF(1));\n       Put skip(1) list(Translate(RECORD(1),TRANS_TABLE));\n       Call GET_RECORD (1);\n     End;\n     Leave LOOP;\n   End;\n   RECNO = RECNO + 1;\n   MATCH = '0'B;\n   If RECORD(1) ^= RECORD(2) then do;\n     SAVE_RECORD(1) = RECORD(1);\n     SAVE_RECORD(2) = RECORD(2);\n     If MISMATCH_COUNT ^= 0 then do;\n       Do I = 1 to MISMATCH_COUNT until (LOGICAL_EOF(1) | MATCH);\n         Call GET_RECORD (1);\n         MISMATCH(1,I) = RECORD(1);\n         If RECORD(1) = RECORD(2) & ^ LOGICAL_EOF(1) then\n           MATCH = '1'B;\n       End;\n       If ^ MATCH then do;\n         LOOKASIDE_MAX(1) = I-1;\n         Do K = 1 to LOOKASIDE_MAX(1);\n           LOOKASIDE(1,K) = MISMATCH(1,K);\n         End;\n         LOOKASIDE_INDEX(1) = 1;\n         LOGICAL_EOF(1) = '0'B;\n         RECORD(1) = SAVE_RECORD(1);\n         Do I = 1 to MISMATCH_COUNT until (LOGICAL_EOF(2) | MATCH);\n           Call GET_RECORD (2);\n           MISMATCH(2,I) = RECORD(2);\n           If RECORD(1) = RECORD(2) & ^LOGICAL_EOF(2) then\n             MATCH = '1'B;\n         End;\n         If ^ MATCH then do;\n           LOOKASIDE_MAX(2) = I-1;\n           Do K = 1 to LOOKASIDE_MAX(2);\n             LOOKASIDE(2,K) = MISMATCH(2,K);\n           End;\n           LOOKASIDE_INDEX(2) = 1;\n           LOGICAL_EOF(2) = '0'B;\n           RECORD(2) = SAVE_RECORD(2);\n           RECNO_P = RECNO;\n           RECNO_V = Substr(RECNO_C,Verify(RECNO_C,' '));\n           Put skip(2)\n               list('Record number '||RECNO_V||' unmatched...');\n           Put skip list (Translate(RECORD(1),TRANS_TABLE));\n           Put skip list (Translate(RECORD(2),TRANS_TABLE));\n           UNMATCHED = UNMATCHED + 1;\n         End;\n         Else do;\n           Put skip(2) list('Records not in file 1 found in file 2');\n           Put skip(1) list(Translate(SAVE_RECORD(2),TRANS_TABLE));\n           Do J = 1 to I-1;\n             Put skip(1)\n                 list(Translate(MISMATCH(2,J),TRANS_TABLE));\n           End;\n         End;\n       End;\n       Else do;\n         Put skip(2) list('Records found in file 1 but not file 2');\n         Put skip(1) list(Translate(SAVE_RECORD(1),TRANS_TABLE));\n         Do J = 1 to I-1;\n           Put skip(1)\n               list(Translate(MISMATCH(1,J),TRANS_TABLE));\n         End;\n       End;\n     End;\n     Else do;\n       RECNO_P = RECNO;\n       RECNO_V = Substr(RECNO_C,Verify(RECNO_C,' '));\n       Put skip(2) list('Record number '||RECNO_V||' unmatched...');\n       Put skip list (Translate(RECORD(1),TRANS_TABLE));\n       Put skip list (Translate(RECORD(2),TRANS_TABLE));\n       UNMATCHED = UNMATCHED + 1;\n     End;\n   End;\n\n End LOOP;\n\n Close file(INDD1), file(INDD2);\n\n Put skip(2) edit('Total records read........',RECNO)\n                 (A,P'ZZZZZ9');\n\n Put skip(1) edit('Total unmatched records...',UNMATCHED)\n                 (A,P'ZZZZZ9');\n\n /*******************************************************************/\n\n GET_RECORD: Proc (N);\n\n Dcl N fixed(15) bin,\n     L fixed(15) bin;\n\n If LOOKASIDE_MAX(N) ^= 0 then do;\n\n   RECORD(N) = LOOKASIDE(N,LOOKASIDE_INDEX(N));\n   LOOKASIDE_INDEX(N) = LOOKASIDE_INDEX(N) + 1;\n   If LOOKASIDE_INDEX(N) > LOOKASIDE_MAX(N) then do;\n     LOOKASIDE_INDEX(N) = 0;\n     LOOKASIDE_MAX(N) = 0;\n   End;\n\n End;\n\n Else do;\n\n   If ^ PHYSICAL_EOF(N) then Read file(INDD(N)) set(REC_PTR);\n\n   If PHYSICAL_EOF(N) then LOGICAL_EOF(N) = '1'B;\n   Else do;\n     LOGICAL_EOF(N) = '0'B;\n     If RECFM_V(N) then\n       L = Max(0,\n           Min(INDDDCB(N)->DCBLRECL-START_COLUMN+1-4,COMPARE_LENGTH));\n     Else\n       L = COMPARE_LENGTH;\n     RECORD(N) = Substr(INPUT_REC,START_COLUMN,L);\n   End;\n\n End;\n\n End GET_RECORD;\n\n End PLICOMP;\n./ ADD NAME=PLIXXC   0100-07332-07332-0900-00371-00371-00000-SEB\n*PROCESS OPT(TIME);\n /* PLIXXC: Program to do hex calculations */\n\n /* Note: E-level diagnostics will occur due to overlay defining. */\n\n PLIXXC:Proc(PARM) options(Main) reorder;\n\n Dcl\n   PARM                        char(100) var,\n   EXPRESSION           static char(100)    ,\n   (VALUE1,VALUE2)      static fixed(31) bin init( 0  ),\n   OPERATOR             static char  (3) var init(''  ) ,\n   RESULT               static fixed(31) bin init( 0  ),\n   CHAR_RESULT          static char (16) var init(''  ),\n   BAD                  static bit   (1)     init('0'B),\n   DECIMAL_INPUT        static bit   (1)     init('0'B),\n   SYSDVAL_MUST_BE_SET  static bit   (1)     init('0'B),\n   EFFBITS    (12)      static bit   (8)     init('11111010'B,\n                                                  '11111011'B,\n                                                  '11111100'B,\n                                                  '11111101'B,\n                                                  '11111110'B,\n                                                  '11111111'B,\n                                                  '11111010'B,\n                                                  '11111011'B,\n                                                  '11111100'B,\n                                                  '11111101'B,\n                                                  '11111110'B,\n                                                  '11111111'B),\n   EFFS         char(12) def EFFBITS,\n   FAFBFCFDFEFF char (6) def EFFBITS;\n\n Dcl\n   XGET        external entry(char(*), fixed(15) bin)\n                                                 options(Asm Inter),\n   XPUT        external entry(char(*) var)\n                                                 options(Asm Inter),\n   PLIXOPT     external char (2) var             init('NR');\n\n %INCLUDE XTSOVAR;\n\n Dcl\n    (Length,Substr,Translate,Char,Verify,\n     Mod,Unspec,Bool,Index,Null,Hbound)\n      builtin;\n\n\n On Size begin;\n   Call XPUT('Number is too large');\n   BAD = '1'B;\n End;\n\n On Fixedoverflow begin;\n   Call XPUT('Requested computation caused overflow');\n   BAD = '1'B;\n End;\n\n On Overflow begin;  /* For exponentiation - uses floating point */\n   Call XPUT('Requested computation caused overflow');\n   BAD = '1'B;\n End;\n\n On Underflow begin;  /* For exponentiation - uses floating point */\n   Call XPUT('Requested computation caused underflow');\n   BAD = '1'B;\n End;\n\n On Zerodivide begin;\n   Call XPUT('Division by zero is not possible');\n   BAD = '1'B;\n End;\n\n MAINLOOP:Do until (Length(PARM) > 0);\n  AN_INVOCATION_OF_MAINLOOP: Do;\n   BAD = '0'B;\n   If Length(PARM) > 0 then do;\n    If Substr(PARM,1,1) = '=' then do;\n     EXPRESSION = Substr(PARM,2);\n     SYSDVAL_MUST_BE_SET = '1'B;\n    End;\n    Else do;\n     EXPRESSION = PARM;\n     SYSDVAL_MUST_BE_SET = '0'B;\n    End;\n     If EXPRESSION = '?' then do;\n      Call HELP_FOR_XXC;\n     End;\n   End;\n   Else do;\n     Call XPUT('Enter hex expression (? for help)');\n     Call XGET(EXPRESSION,Length(EXPRESSION));\n     EXPRESSION = Translate(EXPRESSION,\n                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n                  'abcdefghijklmnopqrstuvwxyz');\n     If EXPRESSION = '?' then do;\n       Call HELP_FOR_XXC;\n       Leave AN_INVOCATION_OF_MAINLOOP;\n     End;\n     If EXPRESSION = '' | EXPRESSION = 'END' then do;\n       If ^ SYSDVAL_MUST_BE_SET then Call XPUT('End of program');\n       Leave MAINLOOP;\n     End;\n     Select (EXPRESSION);\n       When ('','END') do;\n         If ^ SYSDVAL_MUST_BE_SET then\n          Call XPUT('End of program');\n         Else Call XPUT('No operand specified');\n         Leave MAINLOOP;\n       End;\n       When ('N') do;\n         CHAR_RESULT = RESULT;\n         CHAR_RESULT = Substr(CHAR_RESULT,Verify(CHAR_RESULT,' '));\n         If ^ SYSDVAL_MUST_BE_SET then\n          Call XPUT('Decimal: '||CHAR_RESULT);\n         Else Call SET_SYSDVAL(CHAR_RESULT);\n         Leave AN_INVOCATION_OF_MAINLOOP;\n       End;\n       Otherwise;\n     End;\n   End;\n\n   VALUE1 = HEXIN(GETVALUE(' +-*/|&'));\n   If BAD then Leave AN_INVOCATION_OF_MAINLOOP;\n\n   OPERATOR = GETVALUE(' 0123456789ABCDEF');\n\n   If OPERATOR ^= '' then do;\n     VALUE2 = HEXIN(GETVALUE(' +-*/|&'));\n     If BAD then Leave AN_INVOCATION_OF_MAINLOOP;\n   End;\n\n   If GETVALUE(' ') ^= '' then do;\n     If OPERATOR = '' then\n       Call XPUT ('Missing operator');\n     Else\n       Call XPUT ('Too many operands');\n     If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');\n     Leave AN_INVOCATION_OF_MAINLOOP;\n   End;\n\n   Select (Char(OPERATOR,3));\n     When ('   ') do;\n       RESULT = VALUE1;\n       If DECIMAL_INPUT then do;\n         CHAR_RESULT = HEXOUT(RESULT);\n         If ^ SYSDVAL_MUST_BE_SET then\n          Call XPUT ('Hex: '||CHAR_RESULT);\n       End;\n       Else do;\n         CHAR_RESULT = RESULT;\n         CHAR_RESULT = Substr(CHAR_RESULT,Verify(CHAR_RESULT,' '));\n         If ^ SYSDVAL_MUST_BE_SET then\n          Call XPUT('Decimal: '||CHAR_RESULT);\n       End;\n       If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL(CHAR_RESULT);\n       Leave AN_INVOCATION_OF_MAINLOOP;\n     End;\n     When ('+  ') RESULT = VALUE1 + VALUE2;\n     When ('-  ') RESULT = VALUE1 - VALUE2;\n     When ('*  ') RESULT = VALUE1 * VALUE2;\n     When ('/  ') RESULT = VALUE1 / VALUE2;\n     When ('** ') RESULT = VALUE1 ** VALUE2;\n     When ('// ') RESULT = Mod(VALUE1,VALUE2);\n     When ('|  ') Unspec(RESULT) = Unspec(VALUE1) | Unspec(VALUE2);\n     When ('&  ') Unspec(RESULT) = Unspec(VALUE1) & Unspec(VALUE2);\n     When ('&& ') Unspec(RESULT) =\n      Bool(Unspec(VALUE1),Unspec(VALUE2),'0110'B); /* Exclusive OR */\n     Otherwise do;\n       Call XPUT ('Invalid expression');\n       If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');\n       Leave AN_INVOCATION_OF_MAINLOOP;\n     End;\n   End;\n\n   If BAD then do;\n    If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');\n    Leave AN_INVOCATION_OF_MAINLOOP;\n   End;\n\n   CHAR_RESULT = HEXOUT(RESULT);\n   If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL (CHAR_RESULT);\n   Else Call XPUT (HEXOUT(VALUE1)||' '||OPERATOR||' '||\n                   HEXOUT(VALUE2)||' = '|| CHAR_RESULT);\n\n  End AN_INVOCATION_OF_MAINLOOP;\n End MAINLOOP;\n\n Return;\n\n\n /********************************************************************/\n\n %PAGE;\n\n GETVALUE: Proc(DELIMS) returns(char(16) var) reorder;\n\n /* This subroutine extracts the next character value from the\n    input expression and removes it from the expression.    */\n /* Note: This function has side effects!!! */\n\n Dcl DELIMS  char(*) var,\n     I,J     fixed(15) bin,\n     NEWEXPR char(16) var;\n\n I = Verify(EXPRESSION,' '); /* point to first nonblank character */\n If I = 0 then\n   Return('');   /* return null string if no nonblanks */\n EXPRESSION = Substr(EXPRESSION,I);      /* delete leading blanks */\n If Length(DELIMS) = 1 then\n   J = Index(EXPRESSION||DELIMS,DELIMS); /* scan for delimiting char */\n Else\n   Do J = 1 to Length(EXPRESSION)        /* scan for delimiting char */\n      while (Index(DELIMS,Substr(EXPRESSION,J,1)) = 0);\n End;\n NEWEXPR = Substr(EXPRESSION,1,J-1); /* extract character string */\n If J > Length(EXPRESSION) then EXPRESSION = '';\n Else\n   EXPRESSION = Substr(EXPRESSION,J);  /* delete it from expression */\n\n Return(NEWEXPR);\n\n End GETVALUE;\n\n /********************************************************************/\n\n %PAGE;\n\n   SET_SYSDVAL: Proc (OUTPUT_VALUE);\n\n   Dcl OUTPUT_VALUE char(*) var;\n\n    Call XTSOVAR  ('W','SYSDVAL',OUTPUT_VALUE);\n\n   End SET_SYSDVAL;\n\n /********************************************************************/\n\n %PAGE;\n\n   HELP_FOR_XXC: Proc;\n\n    Dcl I fixed(15) bin static init(0);\n\n    Dcl\n        HELP_MESSAGES (30) char (72) var static init(\n ' ',\n ' XXC - Hex converter/calculator program',\n ' ',\n '       The following entries are valid:',\n ' ',\n '       (null entry) terminates this program',\n '       END     ...  terminates this program',\n '       ?       ...  produces this help display',\n '       hhh     ...  a hex number (1-8 characters) to be converted',\n '                    to decimal',\n '       dddN    ...  a decimal number (no sign permitted) to be',\n '                    converted to hex',\n '       N       ...  (the single letter N) converts the last',\n '                    result displayed to decimal',\n '       x op y  ...  a simple expression where:',\n '                      x is a number of the form hhh or dddN',\n '                      y is a number of the form hhh or dddN',\n '                      op is one of the following:',\n '                         +    ...  addition',\n '                         -    ...  subtraction',\n '                         *    ...  multiplication',\n '                         /    ...  division',\n '                         **   ...  exponentiation',\n '                         //   ...  remainder',\n '                         |    ...  bitwise OR',\n '                         &    ...  bitwise AND',\n '                         &&   ...  bitwise EXCLUSIVE OR',\n ' ',\n '       All operations take place on fixed-point fullword integers.',\n ' '\n                                                   );\n    Do I = 1 to Hbound(HELP_MESSAGES,1);\n\n     Call XPUT(HELP_MESSAGES(I));\n\n    End;\n\n   End HELP_FOR_XXC;\n\n /********************************************************************/\n\n %PAGE;\n\n HEXIN: Proc (EXPR) returns(fixed(31) bin) reorder;\n\n /* This subroutine takes a character string consisting of hex\n    character representations and returns a binary fullword\n    containing the hexadecimal data. */\n\n Dcl\n    EXPR                char(*) var,\n    CHAREXPR9    static pic '(9)9',\n    CHAREXPRX           char  (8)     def CHAREXPR9,\n    BITPACKED    static fixed (9) dec,\n    BITWORD      unal   fixed(31) bin def BITPACKED,\n    L            static fixed(15) bin;\n\n L = Length(EXPR);\n BAD, DECIMAL_INPUT = '0'B;\n\n If L = 0 then do;\n   Call XPUT('Missing value');\n   BAD = '1'B;\n   Return(0);\n End;\n\n If Substr(EXPR,L,1) = 'N' then do;\n   If L < 2 | L > 11 |\n    Verify(Substr(EXPR,1,L-1),'0123456789') ^= 0 then do;\n     Call XPUT('Invalid value');\n     BAD = '1'B;\n     Return(0);\n   End;\n   DECIMAL_INPUT = '1'B;\n   (Size):Return (Substr(EXPR,1,L-1));\n End;\n\n If L > 8 then do;\n   Call XPUT('Value too long');\n   BAD = '1'B;\n   Return(0);\n End;\n\n CHAREXPRX = '';\n Substr(CHAREXPRX,9-L,L) = EXPR;\n\n If Verify(CHAREXPRX,' 0123456789abcdefABCDEF') ^= 0 then do;\n   Call XPUT('Invalid hex characters entered');\n   BAD = '1'B;\n   Return(0);\n End;\n\n CHAREXPRX = Translate(CHAREXPRX,EFFS,'abcdefABCDEF');\n\n BITPACKED = CHAREXPR9;\n\n Return(BITWORD);\n\n End HEXIN;\n\n /********************************************************************/\n\n %PAGE;\n\n HEXOUT:Proc(NUMBER) returns(char(8) var) reorder;\n\n /* This subroutine takes a binary fullword and returns the\n    character representation of the hexadecimal data therein. */\n\n Dcl NUMBER               fixed(31) bin,\n     PACKED_DATA   static fixed(9) dec,\n     PACKED_FOUR_BYTES    fixed(31) bin unaligned def PACKED_DATA,\n     HEXUNPACKED9  static pic '(9)9',\n     HEXSTRING            char(8)   def HEXUNPACKED9;\n\n PACKED_FOUR_BYTES = NUMBER;\n HEXUNPACKED9 = PACKED_DATA;\n HEXSTRING = Translate(HEXSTRING,'ABCDEF',FAFBFCFDFEFF);\n\n Return(Substr(HEXSTRING,Verify(Substr(HEXSTRING,1,7)||' ','0')));\n\n End HEXOUT;\n\n /********************************************************************/\n\n End PLIXXC;\n./ ADD NAME=XDIS     0100-07332-07332-0900-03254-03254-00000-SEB\n*PROCESS OPT(TIME);\n XDIS: Proc (PARM) options(main) reorder; /* Disassembler for XA */\n\n /*******************************************************************/\n /*                                                                 */\n /* Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.    */\n /*                                                                 */\n /* This program is provided on an \"as is\" basis.  It may be freely */\n /* distributed as long as it is not offered for commercial sale,   */\n /* and as long as this copyright notice is included.               */\n /*                                                                 */\n /* Warning:  Use of this program on licensed object code from IBM  */\n /* or other software vendors may be subject to criminal or other   */\n /* penalties.  Consult your customer representative for the facts. */\n /*                                                                 */\n /*******************************************************************/\n\n\n /********************************************************************/\n /*                                                                  */\n /* Change activity:                                                 */\n /*                                                                  */\n /* 05/17/89 - Support for EXTRN + A(xxx+nnn) constant specs.        */\n /* 12/15/89 - Fixed bug with 0C4 with data at end of module.        */\n /* 12/19/89 - Handles complexly relocatable A(EXTRN2-EXTRN1) adcons.*/\n /* 12/26/89 - ESA support.                                          */\n /*                                                                  */\n /********************************************************************/\n\n Dcl\n     PARM                               char(100) var;\n\n Dcl\n     COPYRIGHT_NOTICE_AND_DISCLAIMER (9) char(64) static init(\n   'Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.',\n   '',\n   'This program is provided on an \"as is\" basis.  It may be freely',\n   'distributed as long as it is not offered for commercial sale,',\n   'and as long as this copyright notice is included.',\n   '',\n   'Warning:  Use of this program on licensed object code from IBM',\n   'or other software vendors may be subject to criminal or other',\n   'penalties.  Consult your customer representative for the facts.'\n                                              );\n\n Dcl\n     LOAD_PTR                    static ptr       init(Null),\n     CESD_PTR                    static ptr       init(Null),\n     CONTROL_PTR                 static ptr       init(Null),\n     RLD_PTR                     static ptr       init(Null),\n     RLD_SUB_PTR                 static ptr       init(Null),\n     TEXT_PTR                    static ptr       init(Null),\n     TEMP_PTR                    static ptr       init(Null),\n     END_PTR                     static ptr       init(Null),\n     OP_PTR                      static ptr       init(Null),\n     RETCODE                     static fixed(31) bin init(0),\n     CSECT_OFFSET                static fixed(31) bin init(0),\n     CSECT_LENGTH                static fixed(31) bin init(0),\n     TEXT_MOVE_OFFSET            static fixed(31) bin init(0),\n     TEXT_MOVE_SOURCE            static fixed(31) bin init(0),\n     TEXT_MOVE_LENGTH            static fixed(31) bin init(0),\n     BLOCK_LENGTH                static fixed(31) bin init(0),\n     IOFF                        static fixed(31) bin,\n     SAVE_IOFF                   static fixed(31) bin,\n     ILEN                        static fixed(31) bin,\n     I                           static fixed(31) bin,\n     J                           static fixed(31) bin,\n     K                           static fixed(31) bin,\n     L                           static fixed(31) bin,\n     PAGENUM                     static fixed(31) bin init(0),\n     CESD_ESDID                  static fixed(15) bin init(0),\n     ESDID                       static fixed(15) bin init(0),\n     OP_INDEX                    static fixed(15) bin,\n     OP_INDEX_LIMIT              static fixed(15) bin,\n     1 MISC_FLAGS      unaligned static,\n       2 DLOAD_EOF                      bit(1)    init('0'B),\n       2 PUNCH                          bit(1)    init('0'B),\n       2 TEXT                           bit(1)    init('0'B),\n       2 LAST_TEXT                      bit(1)    init('0'B),\n       2 MOVE_TEXT                      bit(1)    init('0'B),\n       2 GOT_SEGTAB                     bit(1)    init('0'B),\n       2 VALID_INST                     bit(1)    init('0'B),\n       2 VALID_CHAIN                    bit(1)    init('0'B),\n       2 RECOGNIZED_INST                bit(1)    init('0'B),\n       2 XA_MODULE                      bit(1)    init('0'B),\n       2 PRIVATE_CODE                   bit(1)    init('0'B),\n\n     ESD_ID                      static char(4),\n     ESD_ADDR                    static char(6),\n     ESD_LEN                     static char(6),\n     ESD_LDID                    static char(4),\n     ESD_FLAGS                   static char(2),\n\n     TYPE                        static char(1),\n     CONDITION_CODE              static char(1)   init(' '),\n     OPERATION                   static char(5),\n     MNEMONIC_OPER               static char(5) var,\n     MNEMONIC_STRING             static char(4)   init('    '),\n     AMODE                       static char(3)   init('   '),\n     RMODE                       static char(3)   init('   '),\n     CSECT_NAME                  static char(8)   init(' '),\n     CSECT_LABEL                 static char(8)   init(' '),\n     NAME9                       static char(9)   init(' '),\n     NAME                               char(8) def NAME9 pos(1),\n     OPERANDS                    static char(64) var,\n     IMAGE                       static char(64) var,\n     TRANS_ARRAY (16) static char(16)   init((15)(16)' ',\n                                             '0123456789ABCDEF'),\n     TRANS_TABLE             char(256)  def TRANS_ARRAY,\n\n     SYSDATE                     static char(6),\n     TODAY                       static char(8),\n\n /********************************************************************\n    The following are fields that may be modified by \"get data\"\n    style specifications on the DISPARM file.  Meanings are:\n\n     ESA = 'Y' / 'N'  ... whether to use the MVS/ESA instruction set\n     XA  = 'Y' / 'N'  ... whether to use the MVS/XA instruction set\n     SP1 = 'Y' / 'N'  ... whether to use the MVS/SP1.3 cross memory\n                          and other new instructions\n     VF  = 'Y' / 'N'  ... whether to use the 3090 Vector instructions\n     ESD = 'Y' / 'N'  ... whether to print a listing of the composite\n                          external symbol dictionary (CESD) entries\n                          for the load module\n     INCREMENT = number / 1000 ... sequence number increment for\n                                   generated source records\n     OPSCAN = number / 32 ... the maximum number of instructions to be\n                          scanned in a pass through a section of code\n                          to determine whether it consists of machine\n                          instructions or data (this represents a\n                          limit - scans are terminated by branch\n                          instructions, relocatable address constants\n                          or other known points in any case).\n\n    The default values are the second alternatives shown above.\n\n   *******************************************************************/\n\n     ESA                         static char(1) init('N'),\n     XA                          static char(1) init('N'),\n     SP1                         static char(1) init('N'),\n     VF                          static char(1) init('N'),\n     ESD                         static char(1) init('N'),\n     INCREMENT                   static fixed (7) dec init(1000),\n     OPSCAN                      static fixed(31) bin init(32),\n\n   /*Dummy based variables used as \"templates\" for data manipulation*/\n\n     N                           based  fixed(31) bin,\n     ADCON2                      based  fixed(15) bin,\n     ADCON3                      based  bit(24),\n     ADCON4                      based  fixed(31) bin,\n\n   /* Tables which define MVS operation codes and their attributes  */\n\n     OP_CODE_LOOKUP (0:255) static fixed(15) bin init(\n\n   999,180,999,999,  1,  2,  3,  4,  5,  6,  7,172,173,170,  8,  9,\n    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\n    58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,171, 71, 72,\n    73,181,999,999, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n    86,999,999,999,999,999,999, 87, 88, 89, 90, 91, 92, 93, 94, 95,\n    96,999,999,999,999,999,999,999, 97, 98, 99,100,101,102,103,104,\n   105,999,106,999,107,108,109,110,111,112,113,114,115,116,117,118,\n   119,120,121,122,123,124,125,126,127,174,182,183,128,129,130,131,\n   999,999,999,999,176,177,178,999,999,999,999,999,132,133,134,135,\n   999,136,137,999,999,999,138,139,999,999,140,141,999,142,143,144,\n   999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,\n   999,145,146,147,148,149,150,151,999,166,167,168,152,153,154,155,\n   999,999,999,999,179,169,999,999,175,999,999,999,999,999,999,999,\n   156,157,158,159,999,999,999,999,160,161,162,163,164,165,999,999),\n\n\n /********************************************************************/\n /*                                                                  */\n /* OP_TABLE format is as follows:                                   */\n /*                                                                  */\n /*  OP_NAME - 5 characters - the assembler mnemonic (opcode).       */\n /*                                                                  */\n /*  OP_FORMAT - 3 characters - the instruction format (RR,RS,etc).  */\n /*                                                                  */\n /*  OP_AUX - 1 character - an index into a table of op codes for    */\n /*                         the extended op codes (B2, etc.).        */\n /*                         Note that OP_AUX is mutually exclusive   */\n /*                         with all the other fields.               */\n /*                                                                  */\n /*  OP_TYPE - 1 character - if not blank, means the following:      */\n /*                                                                  */\n /*            \"B\" - this is a branch instruction with special       */\n /*                  mnemonics based on condition code (BC, BCR).    */\n /*                                                                  */\n /*            \"C\" - the immediate data in the instruction is        */\n /*                  probably character data and should be           */\n /*                  formatted as such (e.g. for MVI and CLI).       */\n /*                                                                  */\n /*            \"P\" - privileged instruction                          */\n /*                  or                                              */\n /*                  semiprivileged instruction                      */\n /*                                                                  */\n /*  OP_CC   - 1 character - what the instruction does to the        */\n /*                          condition code.  This is used to        */\n /*                          determine what mnemonic to use when     */\n /*                          disassembling a subsequent BC or BCR.   */\n /*                                                                  */\n /*           blank - no effect on condition code.                   */\n /*                                                                  */\n /*            \"A\" - arithmetic (BZ, BM, BP, BO)                     */\n /*                                                                  */\n /*            \"C\" - comparison (BE, BL, BH)                         */\n /*                                                                  */\n /*            \"D\" - affects the condition code but no mnemonics     */\n /*                  are defined.  Includes instructions like BAL    */\n /*                  which go off and cause random code to execute.  */\n /*                                                                  */\n /*            \"Z\" - zero/nonzero (BZ)                               */\n /*                                                                  */\n /*                                                                  */\n /*  OP_SPEC - 1 character - additional information determining if   */\n /*                          this is a valid op code.  If this is    */\n /*                          non-blank, certain fields of the        */\n /*                          instruction are checked for values      */\n /*                          which they must contain for it to be    */\n /*                          valid - otherwise it must be data.      */\n /*                                                                  */\n /* The following conventions apply herein for nibble descriptions:  */\n /*                                                                  */\n /* . - any value from 0-F is valid.                                 */\n /* 0 - the nibble must contain 0.                                   */\n /* E - the nibble must be even.                                     */\n /* D - the nibble must contain 0, 2, 4, or 6 (floating-point reg).  */\n /* Q - the nibble must contain 0 or 4 (extended-precision float).   */\n /*                                                                  */\n /*                                                                  */\n /*   \"C\" - ..0.....  MC                                             */\n /*   \"D\" - ..QQ      AXR, etc.                                      */\n /*   \"E\" - ..DD      ADR, etc.                                      */\n /*   \"F\" - ..D.....  AD, etc.                                       */\n /*   \"G\" - ..Q.....  MXD                                            */\n /*   \"H\" - ..QD      MXDR                                           */\n /*   \"L\" - ..EE....  MVCL, CLCL, CDS                                */\n /*   \"M\" - ..E.....  MR, DR, M, D                                   */\n /*   \"N\" - ....0000  IPK, PTLB, CSCH, HSCH, SAL, RSCH, RCHP, etc.   */\n /*   \"S\" - ..00....  SSM, LPSW, TS, TCH                             */\n /*   \"X\" - ....00.0  IAC, SSAR, EPAR, ESAR, MSTA                    */\n /*   \"Y\" - ....00..  IPTE, IPM, IVSK, PT, ISKE, RRBE, SSKE, etc.    */\n /*   \"1\" - ...0....  SPM, SRL, SLL, SRA, SLA                        */\n /*   \"2\" - ..E0....  SRDL, SLDL, SRDA, SLDA                         */\n /*                                                                  */\n /********************************************************************/\n\n   1 OP_TABLE      based(OP_PTR),\n     2 OP_NAME     char(5),\n     2 OP_FORMAT   char(3),\n     2 OP_AUX      char(1),\n     2 OP_TYPE     char(1),\n     2 OP_CC       char(1),\n     2 OP_SPEC     char(1),\n\n   1 OP_TABLE_ENTRIES static,\n     2 OP_TABLE001 char(12) init('SPM  SPM   1'),\n     2 OP_TABLE002 char(12) init('BALR RR   D '),\n     2 OP_TABLE003 char(12) init('BCTR RR     '),\n     2 OP_TABLE004 char(12) init('BCR  RR  B  '),\n     2 OP_TABLE005 char(12) init('SSK  RR  P  '),\n     2 OP_TABLE006 char(12) init('ISK  RR  P  '),\n     2 OP_TABLE007 char(12) init('SVC  I      '),\n     2 OP_TABLE008 char(12) init('MVCL RR   CL'),\n     2 OP_TABLE009 char(12) init('CLCL RR   CL'),\n     2 OP_TABLE010 char(12) init('LPR  RR   A '),\n     2 OP_TABLE011 char(12) init('LNR  RR   A '),\n     2 OP_TABLE012 char(12) init('LTR  RR   A '),\n     2 OP_TABLE013 char(12) init('LCR  RR   A '),\n     2 OP_TABLE014 char(12) init('NR   RR   Z '),\n     2 OP_TABLE015 char(12) init('CLR  RR   C '),\n     2 OP_TABLE016 char(12) init('OR   RR   Z '),\n     2 OP_TABLE017 char(12) init('XR   RR   Z '),\n     2 OP_TABLE018 char(12) init('LR   RR     '),\n     2 OP_TABLE019 char(12) init('CR   RR   C '),\n     2 OP_TABLE020 char(12) init('AR   RR   A '),\n     2 OP_TABLE021 char(12) init('SR   RR   A '),\n     2 OP_TABLE022 char(12) init('MR   RR    M'),\n     2 OP_TABLE023 char(12) init('DR   RR    M'),\n     2 OP_TABLE024 char(12) init('ALR  RR   D '),\n     2 OP_TABLE025 char(12) init('SLR  RR   D '),\n     2 OP_TABLE026 char(12) init('LPDR RR  FAE'),\n     2 OP_TABLE027 char(12) init('LNDR RR  FAE'),\n     2 OP_TABLE028 char(12) init('LTDR RR  FAE'),\n     2 OP_TABLE029 char(12) init('LCDR RR  FAE'),\n     2 OP_TABLE030 char(12) init('HDR  RR  F E'),\n     2 OP_TABLE031 char(12) init('LRDR RR  F E'),\n     2 OP_TABLE032 char(12) init('MXR  RR  F D'),\n     2 OP_TABLE033 char(12) init('MXDR RR  F H'),\n     2 OP_TABLE034 char(12) init('LDR  RR  F E'),\n     2 OP_TABLE035 char(12) init('CDR  RR  FCE'),\n     2 OP_TABLE036 char(12) init('ADR  RR  FAE'),\n     2 OP_TABLE037 char(12) init('SDR  RR  FAE'),\n     2 OP_TABLE038 char(12) init('MDR  RR  F E'),\n     2 OP_TABLE039 char(12) init('DDR  RR  F E'),\n     2 OP_TABLE040 char(12) init('AWR  RR  FAE'),\n     2 OP_TABLE041 char(12) init('SWR  RR  FAE'),\n     2 OP_TABLE042 char(12) init('LPER RR  FAE'),\n     2 OP_TABLE043 char(12) init('LNER RR  FAE'),\n     2 OP_TABLE044 char(12) init('LTER RR  FAE'),\n     2 OP_TABLE045 char(12) init('LCER RR  FAE'),\n     2 OP_TABLE046 char(12) init('HER  RR  F E'),\n     2 OP_TABLE047 char(12) init('LRER RR  F E'),\n     2 OP_TABLE048 char(12) init('AXR  RR  FAD'),\n     2 OP_TABLE049 char(12) init('SXR  RR  FAD'),\n     2 OP_TABLE050 char(12) init('LER  RR  F E'),\n     2 OP_TABLE051 char(12) init('CER  RR  FCE'),\n     2 OP_TABLE052 char(12) init('AER  RR  FAE'),\n     2 OP_TABLE053 char(12) init('SER  RR  FAE'),\n     2 OP_TABLE054 char(12) init('MER  RR  F E'),\n     2 OP_TABLE055 char(12) init('DER  RR  F E'),\n     2 OP_TABLE056 char(12) init('AUR  RR  FAE'),\n     2 OP_TABLE057 char(12) init('SUR  RR  FAE'),\n     2 OP_TABLE058 char(12) init('STH  RX     '),\n     2 OP_TABLE059 char(12) init('LA   RX     '),\n     2 OP_TABLE060 char(12) init('STC  RX     '),\n     2 OP_TABLE061 char(12) init('IC   RX     '),\n     2 OP_TABLE062 char(12) init('EX   RX   D '),\n     2 OP_TABLE063 char(12) init('BAL  RX   D '),\n     2 OP_TABLE064 char(12) init('BCT  RX     '),\n     2 OP_TABLE065 char(12) init('BC   RX  B  '),\n     2 OP_TABLE066 char(12) init('LH   RX     '),\n     2 OP_TABLE067 char(12) init('CH   RX   C '),\n     2 OP_TABLE068 char(12) init('AH   RX   A '),\n     2 OP_TABLE069 char(12) init('SH   RX   A '),\n     2 OP_TABLE070 char(12) init('MH   RX     '),\n     2 OP_TABLE071 char(12) init('CVD  RX     '),\n     2 OP_TABLE072 char(12) init('CVB  RX     '),\n     2 OP_TABLE073 char(12) init('ST   RX     '),\n     2 OP_TABLE074 char(12) init('N    RX   Z '),\n     2 OP_TABLE075 char(12) init('CL   RX   C '),\n     2 OP_TABLE076 char(12) init('O    RX   Z '),\n     2 OP_TABLE077 char(12) init('X    RX   Z '),\n     2 OP_TABLE078 char(12) init('L    RX     '),\n     2 OP_TABLE079 char(12) init('C    RX   C '),\n     2 OP_TABLE080 char(12) init('A    RX   A '),\n     2 OP_TABLE081 char(12) init('S    RX   A '),\n     2 OP_TABLE082 char(12) init('M    RX    M'),\n     2 OP_TABLE083 char(12) init('D    RX    M'),\n     2 OP_TABLE084 char(12) init('AL   RX   D '),\n     2 OP_TABLE085 char(12) init('SL   RX   D '),\n     2 OP_TABLE086 char(12) init('STD  RX  F F'),\n     2 OP_TABLE087 char(12) init('MXD  RX  F G'),\n     2 OP_TABLE088 char(12) init('LD   RX  F F'),\n     2 OP_TABLE089 char(12) init('CD   RX  FCF'),\n     2 OP_TABLE090 char(12) init('AD   RX  FAF'),\n     2 OP_TABLE091 char(12) init('SD   RX  FAF'),\n     2 OP_TABLE092 char(12) init('MD   RX  F F'),\n     2 OP_TABLE093 char(12) init('DD   RX  F F'),\n     2 OP_TABLE094 char(12) init('AW   RX  FAF'),\n     2 OP_TABLE095 char(12) init('SW   RX  FAF'),\n     2 OP_TABLE096 char(12) init('STE  RX  F F'),\n     2 OP_TABLE097 char(12) init('LE   RX  F F'),\n     2 OP_TABLE098 char(12) init('CE   RX  FCF'),\n     2 OP_TABLE099 char(12) init('AE   RX  FAF'),\n     2 OP_TABLE100 char(12) init('SE   RX  FAF'),\n     2 OP_TABLE101 char(12) init('ME   RX  F F'),\n     2 OP_TABLE102 char(12) init('DE   RX  F F'),\n     2 OP_TABLE103 char(12) init('AU   RX  FAF'),\n     2 OP_TABLE104 char(12) init('SU   RX  FAF'),\n     2 OP_TABLE105 char(12) init('SSM  S   P S'),\n     2 OP_TABLE106 char(12) init('LPSW S   PDS'),\n     2 OP_TABLE107 char(12) init('WRD  SI  P  '),\n     2 OP_TABLE108 char(12) init('RDD  SI  P  '),\n     2 OP_TABLE109 char(12) init('BXH  RS     '),\n     2 OP_TABLE110 char(12) init('BXLE RS     '),\n     2 OP_TABLE111 char(12) init('SRL  RSS  A1'),\n     2 OP_TABLE112 char(12) init('SLL  RSS  A1'),\n     2 OP_TABLE113 char(12) init('SRA  RSS  A1'),\n     2 OP_TABLE114 char(12) init('SLA  RSS  A1'),\n     2 OP_TABLE115 char(12) init('SRDL RSS  A2'),\n     2 OP_TABLE116 char(12) init('SLDL RSS  A2'),\n     2 OP_TABLE117 char(12) init('SRDA RSS  A2'),\n     2 OP_TABLE118 char(12) init('SLDA RSS  A2'),\n     2 OP_TABLE119 char(12) init('STM  RS     '),\n     2 OP_TABLE120 char(12) init('TM   SI   A '),\n     2 OP_TABLE121 char(12) init('MVI  SI  C  '),\n     2 OP_TABLE122 char(12) init('TS   S    DS'),\n     2 OP_TABLE123 char(12) init('NI   SI   Z '),\n     2 OP_TABLE124 char(12) init('CLI  SI  CC '),\n     2 OP_TABLE125 char(12) init('OI   SI   Z '),\n     2 OP_TABLE126 char(12) init('XI   SI   Z '),\n     2 OP_TABLE127 char(12) init('LM   RS     '),\n     2 OP_TABLE128 char(12) init('        1   '), /* 9Cxxxxxx */\n     2 OP_TABLE129 char(12) init('        2   '), /* 9Dxxxxxx */\n     2 OP_TABLE130 char(12) init('        3   '), /* 9Exxxxxx */\n     2 OP_TABLE131 char(12) init('TCH  S   PDS'),\n     2 OP_TABLE132 char(12) init('STNSMSI  P  '),\n     2 OP_TABLE133 char(12) init('STOSMSI  P  '),\n     2 OP_TABLE134 char(12) init('SIGP RS  PD '),\n     2 OP_TABLE135 char(12) init('MC   SI    C'),\n     2 OP_TABLE136 char(12) init('LRA  RX  PD '),\n     2 OP_TABLE137 char(12) init('        4   '), /* B2xxxxxx */\n     2 OP_TABLE138 char(12) init('STCTLRS  P  '),\n     2 OP_TABLE139 char(12) init('LCTL RS  P  '),\n     2 OP_TABLE140 char(12) init('CS   RS   D '),\n     2 OP_TABLE141 char(12) init('CDS  RS   DL'),\n     2 OP_TABLE142 char(12) init('CLM  RS   C '),\n     2 OP_TABLE143 char(12) init('STCM RS     '),\n     2 OP_TABLE144 char(12) init('ICM  RS   A '),\n     2 OP_TABLE145 char(12) init('MVN  SS1    '),\n     2 OP_TABLE146 char(12) init('MVC  SS1    '),\n     2 OP_TABLE147 char(12) init('MVZ  SS1    '),\n     2 OP_TABLE148 char(12) init('NC   SS1  Z '),\n     2 OP_TABLE149 char(12) init('CLC  SS1  C '),\n     2 OP_TABLE150 char(12) init('OC   SS1  Z '),\n     2 OP_TABLE151 char(12) init('XC   SS1  Z '),\n     2 OP_TABLE152 char(12) init('TR   SS1    '),\n     2 OP_TABLE153 char(12) init('TRT  SS1  D '),\n     2 OP_TABLE154 char(12) init('ED   SS1  A '),\n     2 OP_TABLE155 char(12) init('EDMK SS1  A '),\n     2 OP_TABLE156 char(12) init('SRP  SS3  A '),\n     2 OP_TABLE157 char(12) init('MVO  SS2    '),\n     2 OP_TABLE158 char(12) init('PACK SS2    '),\n     2 OP_TABLE159 char(12) init('UNPK SS2    '),\n     2 OP_TABLE160 char(12) init('ZAP  SS2  A '),\n     2 OP_TABLE161 char(12) init('CP   SS2  C '),\n     2 OP_TABLE162 char(12) init('AP   SS2  A '),\n     2 OP_TABLE163 char(12) init('SP   SS2  A '),\n     2 OP_TABLE164 char(12) init('MP   SS2    '),\n     2 OP_TABLE165 char(12) init('DP   SS2    '),\n     2 OP_TABLE166 char(12) init('MVCK SS4  D '),\n     2 OP_TABLE167 char(12) init('MVCP SS4  D '),\n     2 OP_TABLE168 char(12) init('MVCS SS4  D '),\n     2 OP_TABLE169 char(12) init('        5   '), /* E5xxxxxxxxxx */\n     2 OP_TABLE170 char(12) init('BASR RR     '),\n     2 OP_TABLE171 char(12) init('BAS  RX     '),\n     2 OP_TABLE172 char(12) init('BSM  RR   D '),\n     2 OP_TABLE173 char(12) init('BASSMRR   D '),\n     2 OP_TABLE174 char(12) init('TRACERS  P  '),\n     2 OP_TABLE175 char(12) init('MVCINSS1    '),\n     2 OP_TABLE176 char(12) init('        6   '), /* A4xxxxxx */\n     2 OP_TABLE177 char(12) init('        7   '), /* A5xxxxxx */\n     2 OP_TABLE178 char(12) init('        8   '), /* A6xxxxxx */\n     2 OP_TABLE179 char(12) init('        9   '), /* E4xxxxxxxxxx */\n     2 OP_TABLE180 char(12) init('        0   '), /* 01xx */\n     2 OP_TABLE181 char(12) init('LAE  RX     '),\n     2 OP_TABLE182 char(12) init('LAM  RS     '),\n     2 OP_TABLE183 char(12) init('STAM RS     '),\n\n   1 OP_TABLE0 (183) char(12) def OP_TABLE_ENTRIES,\n\n   1 AUX_OP_ARRAY (0:255) char(12) based,\n\n   1 AUX_OP_TABLE0_ENTRIES static, /* for op code 01 */\n     2 AUX_OP0_TABLE00 char(12) init('            '),\n     2 AUX_OP0_TABLE01 char(12) init('PR   N    D '),\n     2 AUX_OP0_TABLE02 char(12) init('UPT  N    D '),\n\n   1 AUX_OP_TABLE0 (0:2) char(12) def AUX_OP_TABLE0_ENTRIES,\n\n   1 AUX_OP_TABLE1_ENTRIES static, /* for op code 9C */\n     2 AUX_OP1_TABLE00  char(12) init('SIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('SIOF S   PD '),\n\n   1 AUX_OP_TABLE1 (0:1) char(12) def AUX_OP_TABLE1_ENTRIES,\n\n   1 AUX_OP_TABLE2_ENTRIES static, /* for op code 9D */\n     2 AUX_OP1_TABLE00  char(12) init('TIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('CLRIOS   PD '),\n\n   1 AUX_OP_TABLE2 (0:1) char(12) def AUX_OP_TABLE2_ENTRIES,\n\n   1 AUX_OP_TABLE3_ENTRIES static, /* for op code 9E */\n     2 AUX_OP1_TABLE00  char(12) init('HIO  S   PD '),\n     2 AUX_OP1_TABLE01  char(12) init('HDV  S   PD '),\n\n   1 AUX_OP_TABLE3 (0:1) char(12) def AUX_OP_TABLE3_ENTRIES,\n\n   1 AUX_OP_TABLE4_ENTRIES static, /* for op code B2 */\n     2 AUX_OP1_TABLE00  char(12) init('CONCSS   P  '),\n     2 AUX_OP1_TABLE01  char(12) init('DISCSS   P  '),\n     2 AUX_OP1_TABLE02  char(12) init('STIDPS   P  '),\n     2 AUX_OP1_TABLE03  char(12) init('STIDCS   PD '),\n     2 AUX_OP1_TABLE04  char(12) init('SCK  S   PD '),\n     2 AUX_OP1_TABLE05  char(12) init('STCK S      '),\n     2 AUX_OP1_TABLE06  char(12) init('SCKC S   P  '),\n     2 AUX_OP1_TABLE07  char(12) init('STCKCS   P  '),\n     2 AUX_OP1_TABLE08  char(12) init('SPT  S   P  '),\n     2 AUX_OP1_TABLE09  char(12) init('STPT S   P  '),\n     2 AUX_OP1_TABLE0A  char(12) init('SPKA S   P  '),\n     2 AUX_OP1_TABLE0B  char(12) init('IPK  N   P N'),\n     2 AUX_OP1_TABLE0C  char(12) init('            '),\n     2 AUX_OP1_TABLE0D  char(12) init('PTLB N   P N'),\n     2 AUX_OP1_TABLE0E  char(12) init('            '),\n     2 AUX_OP1_TABLE0F  char(12) init('            '),\n     2 AUX_OP1_TABLE10  char(12) init('SPX  S   P  '),\n     2 AUX_OP1_TABLE11  char(12) init('STPX S   P  '),\n     2 AUX_OP1_TABLE12  char(12) init('STAP S   P  '),\n     2 AUX_OP1_TABLE13  char(12) init('RRB  S   PD '),\n     2 AUX_OP1_TABLE14  char(12) init('            '),\n     2 AUX_OP1_TABLE15  char(12) init('            '),\n     2 AUX_OP1_TABLE16  char(12) init('            '),\n     2 AUX_OP1_TABLE17  char(12) init('            '),\n     2 AUX_OP1_TABLE18  char(12) init('PC   S      '),\n     2 AUX_OP1_TABLE19  char(12) init('SAC  S      '),\n     2 AUX_OP1_TABLE1A  char(12) init('CFC  S      '),\n     2 AUX_OP1_TABLE1B  char(12) init('            '),\n     2 AUX_OP1_TABLE1C  char(12) init('            '),\n     2 AUX_OP1_TABLE1D  char(12) init('            '),\n     2 AUX_OP1_TABLE1E  char(12) init('            '),\n     2 AUX_OP1_TABLE1F  char(12) init('            '),\n     2 AUX_OP1_TABLE20  char(12) init('            '),\n     2 AUX_OP1_TABLE21  char(12) init('IPTE RR2   Y'),\n     2 AUX_OP1_TABLE22  char(12) init('IPM  RR1   Y'),\n     2 AUX_OP1_TABLE23  char(12) init('IVSK RR2   Y'),\n     2 AUX_OP1_TABLE24  char(12) init('IAC  RR1  DX'),\n     2 AUX_OP1_TABLE25  char(12) init('SSAR RR1   X'),\n     2 AUX_OP1_TABLE26  char(12) init('EPAR RR1   X'),\n     2 AUX_OP1_TABLE27  char(12) init('ESAR RR1   X'),\n     2 AUX_OP1_TABLE28  char(12) init('PT   RR2   Y'),\n     2 AUX_OP1_TABLE29  char(12) init('ISKE RR2   Y'),\n     2 AUX_OP1_TABLE2A  char(12) init('RRBE RR2 PDY'),\n     2 AUX_OP1_TABLE2B  char(12) init('SSKE RR2 P Y'),\n     2 AUX_OP1_TABLE2C  char(12) init('TB   RR2 PDY'),\n     2 AUX_OP1_TABLE2D  char(12) init('DXR  RR2 F Y'),\n     2 AUX_OP1_TABLE2E  char(12) init('            '),\n     2 AUX_OP1_TABLE2F  char(12) init('            '),\n     2 AUX_OP1_TABLE30  char(12) init('CSCH N   PDN'),\n     2 AUX_OP1_TABLE31  char(12) init('HSCH N   PDN'),\n     2 AUX_OP1_TABLE32  char(12) init('MSCH S   PD '),\n     2 AUX_OP1_TABLE33  char(12) init('SSCH S   PD '),\n     2 AUX_OP1_TABLE34  char(12) init('STSCHS   PD '),\n     2 AUX_OP1_TABLE35  char(12) init('TSCH S   PD '),\n     2 AUX_OP1_TABLE36  char(12) init('TPI  S   PD '),\n     2 AUX_OP1_TABLE37  char(12) init('SAL  N   P N'),\n     2 AUX_OP1_TABLE38  char(12) init('RSCH N   PDN'),\n     2 AUX_OP1_TABLE39  char(12) init('STCRWS   PD '),\n     2 AUX_OP1_TABLE3A  char(12) init('STCPSS   P  '),\n     2 AUX_OP1_TABLE3B  char(12) init('RCHP N   PDN'),\n     2 AUX_OP1_TABLE3C  char(12) init('SCHM N   P N'),\n     2 AUX_OP1_TABLE3D  char(12) init('            '),\n     2 AUX_OP1_TABLE3E  char(12) init('            '),\n     2 AUX_OP1_TABLE3F  char(12) init('            '),\n     2 AUX_OP1_TABLE40  char(12) init('BAKR RR2  DY'),\n     2 AUX_OP1_TABLE41  char(12) init('            '),\n     2 AUX_OP1_TABLE42  char(12) init('            '),\n     2 AUX_OP1_TABLE43  char(12) init('            '),\n     2 AUX_OP1_TABLE44  char(12) init('            '),\n     2 AUX_OP1_TABLE45  char(12) init('            '),\n     2 AUX_OP1_TABLE46  char(12) init('STURARR2   Y'),\n     2 AUX_OP1_TABLE47  char(12) init('MSTA RR1   X'),\n     2 AUX_OP1_TABLE48  char(12) init('PALB N     N'),\n     2 AUX_OP1_TABLE49  char(12) init('EREG RR2   Y'),\n     2 AUX_OP1_TABLE4A  char(12) init('ESTA RR2  DY'),\n     2 AUX_OP1_TABLE4B  char(12) init('LURA RR2   Y'),\n     2 AUX_OP1_TABLE4C  char(12) init('TAR  RR2  DY'),\n     2 AUX_OP1_TABLE4D  char(12) init('CPYA RR2   Y'),\n     2 AUX_OP1_TABLE4E  char(12) init('SAR  RR2   Y'),\n     2 AUX_OP1_TABLE4F  char(12) init('EAR  RR2   Y'),\n\n   1 AUX_OP_TABLE4 (0:60) char(12) def AUX_OP_TABLE4_ENTRIES,\n\n   1 AUX_OP_TABLE5_ENTRIES static, /* for op code E5 */\n     2 AUX_OP5_TABLE00  char(12) init('LASP SSE PD '),\n     2 AUX_OP5_TABLE01  char(12) init('TPROTSSE PD '),\n     2 AUX_OP5_TABLE02  char(12) init('            '),\n     2 AUX_OP5_TABLE03  char(12) init('            '),\n     2 AUX_OP5_TABLE04  char(12) init('            '),\n     2 AUX_OP5_TABLE05  char(12) init('            '),\n     2 AUX_OP5_TABLE06  char(12) init('            '),\n     2 AUX_OP5_TABLE07  char(12) init('            '),\n     2 AUX_OP5_TABLE08  char(12) init('            '),\n     2 AUX_OP5_TABLE09  char(12) init('            '),\n     2 AUX_OP5_TABLE0A  char(12) init('            '),\n     2 AUX_OP5_TABLE0B  char(12) init('            '),\n     2 AUX_OP5_TABLE0C  char(12) init('            '),\n     2 AUX_OP5_TABLE0D  char(12) init('            '),\n     2 AUX_OP5_TABLE0E  char(12) init('MVCSKSSE    '),\n     2 AUX_OP5_TABLE0F  char(12) init('MVCDKSSE    '),\n\n   1 AUX_OP_TABLE5 (0:15) char(12) def AUX_OP_TABLE5_ENTRIES,\n\n   1 AUX_OP_TABLE6_ENTRIES static, /* for op code A4 */\n     2 AUX_OP6_TABLE00 char(12) init('VAE  VST    '),\n     2 AUX_OP6_TABLE01 char(12) init('VSE  VST    '),\n     2 AUX_OP6_TABLE02 char(12) init('VME  VST    '),\n     2 AUX_OP6_TABLE03 char(12) init('VDE  VST    '),\n     2 AUX_OP6_TABLE04 char(12) init('VMAE VST    '),\n     2 AUX_OP6_TABLE05 char(12) init('VMSE VST    '),\n     2 AUX_OP6_TABLE06 char(12) init('VMCE VST    '),\n     2 AUX_OP6_TABLE07 char(12) init('VACE VS3    '),\n     2 AUX_OP6_TABLE08 char(12) init('VCE  VST    '),\n     2 AUX_OP6_TABLE09 char(12) init('VL   VS3    '),\n     2 AUX_OP6_TABLE0A char(12) init('VLM  VS3    '), /* also VLME  */\n     2 AUX_OP6_TABLE0B char(12) init('VLY  VS3    '), /* also VLYE  */\n     2 AUX_OP6_TABLE0C char(12) init('            '),\n     2 AUX_OP6_TABLE0D char(12) init('VST  VS3    '), /* also VSTE  */\n     2 AUX_OP6_TABLE0E char(12) init('VSTM VS3    '), /* also VSTME */\n     2 AUX_OP6_TABLE0F char(12) init('VSTK VS3    '), /* also VSTKE */\n     2 AUX_OP6_TABLE10 char(12) init('VAD  VST    '),\n     2 AUX_OP6_TABLE11 char(12) init('VSD  VST    '),\n     2 AUX_OP6_TABLE12 char(12) init('VMD  VST    '),\n     2 AUX_OP6_TABLE13 char(12) init('VDD  VST    '),\n     2 AUX_OP6_TABLE14 char(12) init('VMAD VST    '),\n     2 AUX_OP6_TABLE15 char(12) init('VMSD VST    '),\n     2 AUX_OP6_TABLE16 char(12) init('VMCD VST    '),\n     2 AUX_OP6_TABLE17 char(12) init('VACD VS3    '),\n     2 AUX_OP6_TABLE18 char(12) init('VCD  VST    '),\n     2 AUX_OP6_TABLE19 char(12) init('VLD  VS3    '),\n     2 AUX_OP6_TABLE1A char(12) init('VLMD VS3    '),\n     2 AUX_OP6_TABLE1B char(12) init('VLYD VS3    '),\n     2 AUX_OP6_TABLE1C char(12) init('            '),\n     2 AUX_OP6_TABLE1D char(12) init('VSTD VS3    '),\n     2 AUX_OP6_TABLE1E char(12) init('VSTMDVS3    '),\n     2 AUX_OP6_TABLE1F char(12) init('VSTKDVS3    '),\n     2 AUX_OP6_TABLE20 char(12) init('VA   VST    '),\n     2 AUX_OP6_TABLE21 char(12) init('VS   VST    '),\n     2 AUX_OP6_TABLE22 char(12) init('VM   VST    '),\n     2 AUX_OP6_TABLE23 char(12) init('            '),\n     2 AUX_OP6_TABLE24 char(12) init('VN   VST    '),\n     2 AUX_OP6_TABLE25 char(12) init('VO   VST    '),\n     2 AUX_OP6_TABLE26 char(12) init('VX   VST    '),\n     2 AUX_OP6_TABLE27 char(12) init('            '),\n     2 AUX_OP6_TABLE28 char(12) init('VC   VST    '),\n     2 AUX_OP6_TABLE29 char(12) init('VLH  VS3    '),\n     2 AUX_OP6_TABLE2A char(12) init('VLINTVS3    '),\n     2 AUX_OP6_TABLE2B char(12) init('            '),\n     2 AUX_OP6_TABLE2C char(12) init('            '),\n     2 AUX_OP6_TABLE2D char(12) init('VSTH VS3    '),\n     2 AUX_OP6_TABLE2E char(12) init('            '),\n     2 AUX_OP6_TABLE2F char(12) init('            '),\n     2 AUX_OP6_TABLE30 char(12) init('            '),\n     2 AUX_OP6_TABLE31 char(12) init('            '),\n     2 AUX_OP6_TABLE32 char(12) init('            '),\n     2 AUX_OP6_TABLE33 char(12) init('            '),\n     2 AUX_OP6_TABLE34 char(12) init('            '),\n     2 AUX_OP6_TABLE35 char(12) init('            '),\n     2 AUX_OP6_TABLE36 char(12) init('            '),\n     2 AUX_OP6_TABLE37 char(12) init('            '),\n     2 AUX_OP6_TABLE38 char(12) init('            '),\n     2 AUX_OP6_TABLE39 char(12) init('            '),\n     2 AUX_OP6_TABLE3A char(12) init('            '),\n     2 AUX_OP6_TABLE3B char(12) init('            '),\n     2 AUX_OP6_TABLE3C char(12) init('            '),\n     2 AUX_OP6_TABLE3D char(12) init('            '),\n     2 AUX_OP6_TABLE3E char(12) init('            '),\n     2 AUX_OP6_TABLE3F char(12) init('            '),\n     2 AUX_OP6_TABLE40 char(12) init('            '),\n     2 AUX_OP6_TABLE41 char(12) init('            '),\n     2 AUX_OP6_TABLE42 char(12) init('            '),\n     2 AUX_OP6_TABLE43 char(12) init('            '),\n     2 AUX_OP6_TABLE44 char(12) init('            '),\n     2 AUX_OP6_TABLE45 char(12) init('            '),\n     2 AUX_OP6_TABLE46 char(12) init('            '),\n     2 AUX_OP6_TABLE47 char(12) init('            '),\n     2 AUX_OP6_TABLE48 char(12) init('            '),\n     2 AUX_OP6_TABLE49 char(12) init('            '),\n     2 AUX_OP6_TABLE4A char(12) init('            '),\n     2 AUX_OP6_TABLE4B char(12) init('            '),\n     2 AUX_OP6_TABLE4C char(12) init('            '),\n     2 AUX_OP6_TABLE4D char(12) init('            '),\n     2 AUX_OP6_TABLE4E char(12) init('            '),\n     2 AUX_OP6_TABLE4F char(12) init('            '),\n     2 AUX_OP6_TABLE50 char(12) init('            '),\n     2 AUX_OP6_TABLE51 char(12) init('            '),\n     2 AUX_OP6_TABLE52 char(12) init('            '),\n     2 AUX_OP6_TABLE53 char(12) init('            '),\n     2 AUX_OP6_TABLE54 char(12) init('            '),\n     2 AUX_OP6_TABLE55 char(12) init('            '),\n     2 AUX_OP6_TABLE56 char(12) init('            '),\n     2 AUX_OP6_TABLE57 char(12) init('            '),\n     2 AUX_OP6_TABLE58 char(12) init('            '),\n     2 AUX_OP6_TABLE59 char(12) init('            '),\n     2 AUX_OP6_TABLE5A char(12) init('            '),\n     2 AUX_OP6_TABLE5B char(12) init('            '),\n     2 AUX_OP6_TABLE5C char(12) init('            '),\n     2 AUX_OP6_TABLE5D char(12) init('            '),\n     2 AUX_OP6_TABLE5E char(12) init('            '),\n     2 AUX_OP6_TABLE5F char(12) init('            '),\n     2 AUX_OP6_TABLE60 char(12) init('            '),\n     2 AUX_OP6_TABLE61 char(12) init('            '),\n     2 AUX_OP6_TABLE62 char(12) init('            '),\n     2 AUX_OP6_TABLE63 char(12) init('            '),\n     2 AUX_OP6_TABLE64 char(12) init('            '),\n     2 AUX_OP6_TABLE65 char(12) init('            '),\n     2 AUX_OP6_TABLE66 char(12) init('            '),\n     2 AUX_OP6_TABLE67 char(12) init('            '),\n     2 AUX_OP6_TABLE68 char(12) init('            '),\n     2 AUX_OP6_TABLE69 char(12) init('            '),\n     2 AUX_OP6_TABLE6A char(12) init('            '),\n     2 AUX_OP6_TABLE6B char(12) init('            '),\n     2 AUX_OP6_TABLE6C char(12) init('            '),\n     2 AUX_OP6_TABLE6D char(12) init('            '),\n     2 AUX_OP6_TABLE6E char(12) init('            '),\n     2 AUX_OP6_TABLE6F char(12) init('            '),\n     2 AUX_OP6_TABLE70 char(12) init('            '),\n     2 AUX_OP6_TABLE71 char(12) init('            '),\n     2 AUX_OP6_TABLE72 char(12) init('            '),\n     2 AUX_OP6_TABLE73 char(12) init('            '),\n     2 AUX_OP6_TABLE74 char(12) init('            '),\n     2 AUX_OP6_TABLE75 char(12) init('            '),\n     2 AUX_OP6_TABLE76 char(12) init('            '),\n     2 AUX_OP6_TABLE77 char(12) init('            '),\n     2 AUX_OP6_TABLE78 char(12) init('            '),\n     2 AUX_OP6_TABLE79 char(12) init('            '),\n     2 AUX_OP6_TABLE7A char(12) init('            '),\n     2 AUX_OP6_TABLE7B char(12) init('            '),\n     2 AUX_OP6_TABLE7C char(12) init('            '),\n     2 AUX_OP6_TABLE7D char(12) init('            '),\n     2 AUX_OP6_TABLE7E char(12) init('            '),\n     2 AUX_OP6_TABLE7F char(12) init('            '),\n     2 AUX_OP6_TABLE80 char(12) init('VAES QST    '),\n     2 AUX_OP6_TABLE81 char(12) init('VSES QST    '),\n     2 AUX_OP6_TABLE82 char(12) init('VMES QST    '),\n     2 AUX_OP6_TABLE83 char(12) init('VDES QST    '),\n     2 AUX_OP6_TABLE84 char(12) init('VMAESQST    '),\n     2 AUX_OP6_TABLE85 char(12) init('VMSESQST    '),\n     2 AUX_OP6_TABLE86 char(12) init('            '),\n     2 AUX_OP6_TABLE87 char(12) init('            '),\n     2 AUX_OP6_TABLE88 char(12) init('VCES QST    '),\n     2 AUX_OP6_TABLE89 char(12) init('            '),\n     2 AUX_OP6_TABLE8A char(12) init('            '),\n     2 AUX_OP6_TABLE8B char(12) init('            '),\n     2 AUX_OP6_TABLE8C char(12) init('            '),\n     2 AUX_OP6_TABLE8D char(12) init('            '),\n     2 AUX_OP6_TABLE8E char(12) init('            '),\n     2 AUX_OP6_TABLE8F char(12) init('            '),\n     2 AUX_OP6_TABLE90 char(12) init('VADS QST    '),\n     2 AUX_OP6_TABLE91 char(12) init('VSDS QST    '),\n     2 AUX_OP6_TABLE92 char(12) init('VMDS QST    '),\n     2 AUX_OP6_TABLE93 char(12) init('VDDS QST    '),\n     2 AUX_OP6_TABLE94 char(12) init('VMADSQST    '),\n     2 AUX_OP6_TABLE95 char(12) init('VMSDSQST    '),\n     2 AUX_OP6_TABLE96 char(12) init('            '),\n     2 AUX_OP6_TABLE97 char(12) init('            '),\n     2 AUX_OP6_TABLE98 char(12) init('VCDS QST    '),\n     2 AUX_OP6_TABLE99 char(12) init('            '),\n     2 AUX_OP6_TABLE9A char(12) init('            '),\n     2 AUX_OP6_TABLE9B char(12) init('            '),\n     2 AUX_OP6_TABLE9C char(12) init('            '),\n     2 AUX_OP6_TABLE9D char(12) init('            '),\n     2 AUX_OP6_TABLE9E char(12) init('            '),\n     2 AUX_OP6_TABLE9F char(12) init('            '),\n     2 AUX_OP6_TABLEA0 char(12) init('VAS  QST    '),\n     2 AUX_OP6_TABLEA1 char(12) init('VSS  QST    '),\n     2 AUX_OP6_TABLEA2 char(12) init('VMS  QST    '),\n     2 AUX_OP6_TABLEA3 char(12) init('            '),\n     2 AUX_OP6_TABLEA4 char(12) init('VNS  QST    '),\n     2 AUX_OP6_TABLEA5 char(12) init('VOS  QST    '),\n     2 AUX_OP6_TABLEA6 char(12) init('VXS  QST    '),\n     2 AUX_OP6_TABLEA7 char(12) init('            '),\n     2 AUX_OP6_TABLEA8 char(12) init('VCS  QST    '),\n\n   1 AUX_OP_TABLE6 (0:168) char(12) def AUX_OP_TABLE6_ENTRIES,\n\n   1 AUX_OP_TABLE7_ENTRIES static, /* for op code A5 */\n     2 AUX_OP7_TABLE00 char(12) init('VAER VV     '),\n     2 AUX_OP7_TABLE01 char(12) init('VSER VV     '),\n     2 AUX_OP7_TABLE02 char(12) init('VMER VV     '),\n     2 AUX_OP7_TABLE03 char(12) init('VDER VV     '),\n     2 AUX_OP7_TABLE04 char(12) init('            '),\n     2 AUX_OP7_TABLE05 char(12) init('            '),\n     2 AUX_OP7_TABLE06 char(12) init('VMCERVV     '),\n     2 AUX_OP7_TABLE07 char(12) init('VACERVV2    '),\n     2 AUX_OP7_TABLE08 char(12) init('VCER VV     '),\n     2 AUX_OP7_TABLE09 char(12) init('VLR  VV2    '), /* also VLER  */\n     2 AUX_OP7_TABLE0A char(12) init('VLMR VV2    '), /* also VLMER */\n     2 AUX_OP7_TABLE0B char(12) init('VLZR VV1    '), /* also VLZER */\n     2 AUX_OP7_TABLE0C char(12) init('            '),\n     2 AUX_OP7_TABLE0D char(12) init('            '),\n     2 AUX_OP7_TABLE0E char(12) init('            '),\n     2 AUX_OP7_TABLE0F char(12) init('            '),\n     2 AUX_OP7_TABLE10 char(12) init('VADR VV     '),\n     2 AUX_OP7_TABLE11 char(12) init('VSDR VV     '),\n     2 AUX_OP7_TABLE12 char(12) init('VMDR VV     '),\n     2 AUX_OP7_TABLE13 char(12) init('VDDR VV     '),\n     2 AUX_OP7_TABLE14 char(12) init('            '),\n     2 AUX_OP7_TABLE15 char(12) init('            '),\n     2 AUX_OP7_TABLE16 char(12) init('VMCDRVV     '),\n     2 AUX_OP7_TABLE17 char(12) init('VACDRVV2    '),\n     2 AUX_OP7_TABLE18 char(12) init('VCDR VV     '),\n     2 AUX_OP7_TABLE19 char(12) init('VLDR VV2    '),\n     2 AUX_OP7_TABLE1A char(12) init('VLMDRVV2    '),\n     2 AUX_OP7_TABLE1B char(12) init('VLZDRVV1    '),\n     2 AUX_OP7_TABLE1C char(12) init('            '),\n     2 AUX_OP7_TABLE1D char(12) init('            '),\n     2 AUX_OP7_TABLE1E char(12) init('            '),\n     2 AUX_OP7_TABLE1F char(12) init('            '),\n     2 AUX_OP7_TABLE20 char(12) init('VAR  VV     '),\n     2 AUX_OP7_TABLE21 char(12) init('VSR  VV     '),\n     2 AUX_OP7_TABLE22 char(12) init('VMR  VV     '),\n     2 AUX_OP7_TABLE23 char(12) init('            '),\n     2 AUX_OP7_TABLE24 char(12) init('VNR  VV     '),\n     2 AUX_OP7_TABLE25 char(12) init('VOR  VV     '),\n     2 AUX_OP7_TABLE26 char(12) init('VXR  VV     '),\n     2 AUX_OP7_TABLE27 char(12) init('            '),\n     2 AUX_OP7_TABLE28 char(12) init('VCR  VV     '),\n     2 AUX_OP7_TABLE29 char(12) init('            '),\n     2 AUX_OP7_TABLE2A char(12) init('            '),\n     2 AUX_OP7_TABLE2B char(12) init('            '),\n     2 AUX_OP7_TABLE2C char(12) init('            '),\n     2 AUX_OP7_TABLE2D char(12) init('            '),\n     2 AUX_OP7_TABLE2E char(12) init('            '),\n     2 AUX_OP7_TABLE2F char(12) init('            '),\n     2 AUX_OP7_TABLE30 char(12) init('            '),\n     2 AUX_OP7_TABLE31 char(12) init('            '),\n     2 AUX_OP7_TABLE32 char(12) init('            '),\n     2 AUX_OP7_TABLE33 char(12) init('            '),\n     2 AUX_OP7_TABLE34 char(12) init('            '),\n     2 AUX_OP7_TABLE35 char(12) init('            '),\n     2 AUX_OP7_TABLE36 char(12) init('            '),\n     2 AUX_OP7_TABLE37 char(12) init('            '),\n     2 AUX_OP7_TABLE38 char(12) init('            '),\n     2 AUX_OP7_TABLE39 char(12) init('            '),\n     2 AUX_OP7_TABLE3A char(12) init('            '),\n     2 AUX_OP7_TABLE3B char(12) init('            '),\n     2 AUX_OP7_TABLE3C char(12) init('            '),\n     2 AUX_OP7_TABLE3D char(12) init('            '),\n     2 AUX_OP7_TABLE3E char(12) init('            '),\n     2 AUX_OP7_TABLE3F char(12) init('            '),\n     2 AUX_OP7_TABLE40 char(12) init('VLPERVV2    '),\n     2 AUX_OP7_TABLE41 char(12) init('VLNERVV2    '),\n     2 AUX_OP7_TABLE42 char(12) init('VLCERVV2    '),\n     2 AUX_OP7_TABLE43 char(12) init('            '),\n     2 AUX_OP7_TABLE44 char(12) init('            '),\n     2 AUX_OP7_TABLE45 char(12) init('            '),\n     2 AUX_OP7_TABLE46 char(12) init('            '),\n     2 AUX_OP7_TABLE47 char(12) init('            '),\n     2 AUX_OP7_TABLE48 char(12) init('            '),\n     2 AUX_OP7_TABLE49 char(12) init('            '),\n     2 AUX_OP7_TABLE4A char(12) init('            '),\n     2 AUX_OP7_TABLE4B char(12) init('            '),\n     2 AUX_OP7_TABLE4C char(12) init('            '),\n     2 AUX_OP7_TABLE4D char(12) init('            '),\n     2 AUX_OP7_TABLE4E char(12) init('            '),\n     2 AUX_OP7_TABLE4F char(12) init('            '),\n     2 AUX_OP7_TABLE50 char(12) init('VLPDRVV2    '),\n     2 AUX_OP7_TABLE51 char(12) init('VLNDRVV2    '),\n     2 AUX_OP7_TABLE52 char(12) init('VLCDRVV2    '),\n     2 AUX_OP7_TABLE53 char(12) init('            '),\n     2 AUX_OP7_TABLE54 char(12) init('            '),\n     2 AUX_OP7_TABLE55 char(12) init('            '),\n     2 AUX_OP7_TABLE56 char(12) init('            '),\n     2 AUX_OP7_TABLE57 char(12) init('            '),\n     2 AUX_OP7_TABLE58 char(12) init('            '),\n     2 AUX_OP7_TABLE59 char(12) init('            '),\n     2 AUX_OP7_TABLE5A char(12) init('            '),\n     2 AUX_OP7_TABLE5B char(12) init('            '),\n     2 AUX_OP7_TABLE5C char(12) init('            '),\n     2 AUX_OP7_TABLE5D char(12) init('            '),\n     2 AUX_OP7_TABLE5E char(12) init('            '),\n     2 AUX_OP7_TABLE5F char(12) init('            '),\n     2 AUX_OP7_TABLE60 char(12) init('VLPR VV2    '),\n     2 AUX_OP7_TABLE61 char(12) init('VLNR VV2    '),\n     2 AUX_OP7_TABLE62 char(12) init('VLCR VV2    '),\n     2 AUX_OP7_TABLE63 char(12) init('            '),\n     2 AUX_OP7_TABLE64 char(12) init('            '),\n     2 AUX_OP7_TABLE65 char(12) init('            '),\n     2 AUX_OP7_TABLE66 char(12) init('            '),\n     2 AUX_OP7_TABLE67 char(12) init('            '),\n     2 AUX_OP7_TABLE68 char(12) init('            '),\n     2 AUX_OP7_TABLE69 char(12) init('            '),\n     2 AUX_OP7_TABLE6A char(12) init('            '),\n     2 AUX_OP7_TABLE6B char(12) init('            '),\n     2 AUX_OP7_TABLE6C char(12) init('            '),\n     2 AUX_OP7_TABLE6D char(12) init('            '),\n     2 AUX_OP7_TABLE6E char(12) init('            '),\n     2 AUX_OP7_TABLE6F char(12) init('            '),\n     2 AUX_OP7_TABLE70 char(12) init('            '),\n     2 AUX_OP7_TABLE71 char(12) init('            '),\n     2 AUX_OP7_TABLE72 char(12) init('            '),\n     2 AUX_OP7_TABLE73 char(12) init('            '),\n     2 AUX_OP7_TABLE74 char(12) init('            '),\n     2 AUX_OP7_TABLE75 char(12) init('            '),\n     2 AUX_OP7_TABLE76 char(12) init('            '),\n     2 AUX_OP7_TABLE77 char(12) init('            '),\n     2 AUX_OP7_TABLE78 char(12) init('            '),\n     2 AUX_OP7_TABLE79 char(12) init('            '),\n     2 AUX_OP7_TABLE7A char(12) init('            '),\n     2 AUX_OP7_TABLE7B char(12) init('            '),\n     2 AUX_OP7_TABLE7C char(12) init('            '),\n     2 AUX_OP7_TABLE7D char(12) init('            '),\n     2 AUX_OP7_TABLE7E char(12) init('            '),\n     2 AUX_OP7_TABLE7F char(12) init('            '),\n     2 AUX_OP7_TABLE80 char(12) init('VAEQ QV     '),\n     2 AUX_OP7_TABLE81 char(12) init('VSEQ QV     '),\n     2 AUX_OP7_TABLE82 char(12) init('VMEQ QV     '),\n     2 AUX_OP7_TABLE83 char(12) init('VDEQ QV     '),\n     2 AUX_OP7_TABLE84 char(12) init('VMAEQQV     '),\n     2 AUX_OP7_TABLE85 char(12) init('VMSEQQV     '),\n     2 AUX_OP7_TABLE86 char(12) init('            '),\n     2 AUX_OP7_TABLE87 char(12) init('            '),\n     2 AUX_OP7_TABLE88 char(12) init('VCEQ QV     '),\n     2 AUX_OP7_TABLE89 char(12) init('VLEQ QV2    '),\n     2 AUX_OP7_TABLE8A char(12) init('VLMEQQV2    '),\n     2 AUX_OP7_TABLE8B char(12) init('            '),\n     2 AUX_OP7_TABLE8C char(12) init('            '),\n     2 AUX_OP7_TABLE8D char(12) init('            '),\n     2 AUX_OP7_TABLE8E char(12) init('            '),\n     2 AUX_OP7_TABLE8F char(12) init('            '),\n     2 AUX_OP7_TABLE90 char(12) init('VADQ QV     '),\n     2 AUX_OP7_TABLE91 char(12) init('VSDQ QV     '),\n     2 AUX_OP7_TABLE92 char(12) init('VMDQ QV     '),\n     2 AUX_OP7_TABLE93 char(12) init('VDDQ QV     '),\n     2 AUX_OP7_TABLE94 char(12) init('VMADQQV     '),\n     2 AUX_OP7_TABLE95 char(12) init('VMSDQQV     '),\n     2 AUX_OP7_TABLE96 char(12) init('            '),\n     2 AUX_OP7_TABLE97 char(12) init('            '),\n     2 AUX_OP7_TABLE98 char(12) init('VCDQ QV     '),\n     2 AUX_OP7_TABLE99 char(12) init('VLDQ QV2    '),\n     2 AUX_OP7_TABLE9A char(12) init('VLMDQQV2    '),\n     2 AUX_OP7_TABLE9B char(12) init('            '),\n     2 AUX_OP7_TABLE9C char(12) init('            '),\n     2 AUX_OP7_TABLE9D char(12) init('            '),\n     2 AUX_OP7_TABLE9E char(12) init('            '),\n     2 AUX_OP7_TABLE9F char(12) init('            '),\n     2 AUX_OP7_TABLEA0 char(12) init('VAQ  QV     '),\n     2 AUX_OP7_TABLEA1 char(12) init('VSQ  QV     '),\n     2 AUX_OP7_TABLEA2 char(12) init('VMQ  QV     '),\n     2 AUX_OP7_TABLEA3 char(12) init('            '),\n     2 AUX_OP7_TABLEA4 char(12) init('VNQ  QV     '),\n     2 AUX_OP7_TABLEA5 char(12) init('VOQ  QV     '),\n     2 AUX_OP7_TABLEA6 char(12) init('VXQ  QV     '),\n     2 AUX_OP7_TABLEA7 char(12) init('            '),\n     2 AUX_OP7_TABLEA8 char(12) init('VCQ  QV     '),\n     2 AUX_OP7_TABLEA9 char(12) init('VLQ  QV2    '),\n     2 AUX_OP7_TABLEAA char(12) init('VLMQ QV2    '),\n\n   1 AUX_OP_TABLE7 (0:170) char(12) def AUX_OP_TABLE7_ENTRIES,\n\n   1 AUX_OP_TABLE8_ENTRIES static, /* for op code A6 */\n     2 AUX_OP8_TABLE00 char(12) init('VMXSEVR     '),\n     2 AUX_OP8_TABLE01 char(12) init('VMNSEVR     '),\n     2 AUX_OP8_TABLE02 char(12) init('VMXAEVR     '),\n     2 AUX_OP8_TABLE03 char(12) init('            '),\n     2 AUX_OP8_TABLE04 char(12) init('            '),\n     2 AUX_OP8_TABLE05 char(12) init('            '),\n     2 AUX_OP8_TABLE06 char(12) init('            '),\n     2 AUX_OP8_TABLE07 char(12) init('            '),\n     2 AUX_OP8_TABLE08 char(12) init('VLELEVR     '),\n     2 AUX_OP8_TABLE09 char(12) init('VXELEVR     '),\n     2 AUX_OP8_TABLE0A char(12) init('            '),\n     2 AUX_OP8_TABLE0B char(12) init('            '),\n     2 AUX_OP8_TABLE0C char(12) init('            '),\n     2 AUX_OP8_TABLE0D char(12) init('            '),\n     2 AUX_OP8_TABLE0E char(12) init('            '),\n     2 AUX_OP8_TABLE0F char(12) init('            '),\n     2 AUX_OP8_TABLE10 char(12) init('VMXSDVR     '),\n     2 AUX_OP8_TABLE11 char(12) init('VMNSDVR     '),\n     2 AUX_OP8_TABLE12 char(12) init('VMXADVR     '),\n     2 AUX_OP8_TABLE13 char(12) init('            '),\n     2 AUX_OP8_TABLE14 char(12) init('            '),\n     2 AUX_OP8_TABLE15 char(12) init('            '),\n     2 AUX_OP8_TABLE16 char(12) init('            '),\n     2 AUX_OP8_TABLE17 char(12) init('            '),\n     2 AUX_OP8_TABLE18 char(12) init('VLELDVR     '),\n     2 AUX_OP8_TABLE19 char(12) init('VXELDVR     '),\n     2 AUX_OP8_TABLE1A char(12) init('VSPSDVR2    '),\n     2 AUX_OP8_TABLE1B char(12) init('VZPSDVR1    '),\n     2 AUX_OP8_TABLE1C char(12) init('            '),\n     2 AUX_OP8_TABLE1D char(12) init('            '),\n     2 AUX_OP8_TABLE1E char(12) init('            '),\n     2 AUX_OP8_TABLE1F char(12) init('            '),\n     2 AUX_OP8_TABLE20 char(12) init('            '),\n     2 AUX_OP8_TABLE21 char(12) init('            '),\n     2 AUX_OP8_TABLE22 char(12) init('            '),\n     2 AUX_OP8_TABLE23 char(12) init('            '),\n     2 AUX_OP8_TABLE24 char(12) init('            '),\n     2 AUX_OP8_TABLE25 char(12) init('            '),\n     2 AUX_OP8_TABLE26 char(12) init('            '),\n     2 AUX_OP8_TABLE27 char(12) init('            '),\n     2 AUX_OP8_TABLE28 char(12) init('VLEL VR     '),\n     2 AUX_OP8_TABLE29 char(12) init('VXEL VR     '),\n     2 AUX_OP8_TABLE2A char(12) init('            '),\n     2 AUX_OP8_TABLE2B char(12) init('            '),\n     2 AUX_OP8_TABLE2C char(12) init('            '),\n     2 AUX_OP8_TABLE2D char(12) init('            '),\n     2 AUX_OP8_TABLE2E char(12) init('            '),\n     2 AUX_OP8_TABLE2F char(12) init('            '),\n     2 AUX_OP8_TABLE30 char(12) init('            '),\n     2 AUX_OP8_TABLE31 char(12) init('            '),\n     2 AUX_OP8_TABLE32 char(12) init('            '),\n     2 AUX_OP8_TABLE33 char(12) init('            '),\n     2 AUX_OP8_TABLE34 char(12) init('            '),\n     2 AUX_OP8_TABLE35 char(12) init('            '),\n     2 AUX_OP8_TABLE36 char(12) init('            '),\n     2 AUX_OP8_TABLE37 char(12) init('            '),\n     2 AUX_OP8_TABLE38 char(12) init('            '),\n     2 AUX_OP8_TABLE39 char(12) init('            '),\n     2 AUX_OP8_TABLE3A char(12) init('            '),\n     2 AUX_OP8_TABLE3B char(12) init('            '),\n     2 AUX_OP8_TABLE3C char(12) init('            '),\n     2 AUX_OP8_TABLE3D char(12) init('            '),\n     2 AUX_OP8_TABLE3E char(12) init('            '),\n     2 AUX_OP8_TABLE3F char(12) init('            '),\n     2 AUX_OP8_TABLE40 char(12) init('VTVM RRZ    '),\n     2 AUX_OP8_TABLE41 char(12) init('VCVM RRZ    '),\n     2 AUX_OP8_TABLE42 char(12) init('VCZVMRRE    '),\n     2 AUX_OP8_TABLE43 char(12) init('VCOVMRRE    '),\n     2 AUX_OP8_TABLE44 char(12) init('VXVC RRE    '),\n     2 AUX_OP8_TABLE45 char(12) init('VLVCURRE    '),\n     2 AUX_OP8_TABLE46 char(12) init('VXVMMRRE    '),\n     2 AUX_OP8_TABLE47 char(12) init('            '),\n     2 AUX_OP8_TABLE48 char(12) init('VRRS RRE    '),\n     2 AUX_OP8_TABLE49 char(12) init('VRSVCRRE    '),\n     2 AUX_OP8_TABLE4A char(12) init('VRSV RRE    '),\n     2 AUX_OP8_TABLE4B char(12) init('            '),\n     2 AUX_OP8_TABLE4C char(12) init('            '),\n     2 AUX_OP8_TABLE4D char(12) init('            '),\n     2 AUX_OP8_TABLE4E char(12) init('            '),\n     2 AUX_OP8_TABLE4F char(12) init('            '),\n     2 AUX_OP8_TABLE50 char(12) init('            '),\n     2 AUX_OP8_TABLE51 char(12) init('            '),\n     2 AUX_OP8_TABLE52 char(12) init('            '),\n     2 AUX_OP8_TABLE53 char(12) init('            '),\n     2 AUX_OP8_TABLE54 char(12) init('            '),\n     2 AUX_OP8_TABLE55 char(12) init('            '),\n     2 AUX_OP8_TABLE56 char(12) init('            '),\n     2 AUX_OP8_TABLE57 char(12) init('            '),\n     2 AUX_OP8_TABLE58 char(12) init('            '),\n     2 AUX_OP8_TABLE59 char(12) init('            '),\n     2 AUX_OP8_TABLE5A char(12) init('            '),\n     2 AUX_OP8_TABLE5B char(12) init('            '),\n     2 AUX_OP8_TABLE5C char(12) init('            '),\n     2 AUX_OP8_TABLE5D char(12) init('            '),\n     2 AUX_OP8_TABLE5E char(12) init('            '),\n     2 AUX_OP8_TABLE5F char(12) init('            '),\n     2 AUX_OP8_TABLE60 char(12) init('            '),\n     2 AUX_OP8_TABLE61 char(12) init('            '),\n     2 AUX_OP8_TABLE62 char(12) init('            '),\n     2 AUX_OP8_TABLE63 char(12) init('            '),\n     2 AUX_OP8_TABLE64 char(12) init('            '),\n     2 AUX_OP8_TABLE65 char(12) init('            '),\n     2 AUX_OP8_TABLE66 char(12) init('            '),\n     2 AUX_OP8_TABLE67 char(12) init('            '),\n     2 AUX_OP8_TABLE68 char(12) init('            '),\n     2 AUX_OP8_TABLE69 char(12) init('            '),\n     2 AUX_OP8_TABLE6A char(12) init('            '),\n     2 AUX_OP8_TABLE6B char(12) init('            '),\n     2 AUX_OP8_TABLE6C char(12) init('            '),\n     2 AUX_OP8_TABLE6D char(12) init('            '),\n     2 AUX_OP8_TABLE6E char(12) init('            '),\n     2 AUX_OP8_TABLE6F char(12) init('            '),\n     2 AUX_OP8_TABLE70 char(12) init('            '),\n     2 AUX_OP8_TABLE71 char(12) init('            '),\n     2 AUX_OP8_TABLE72 char(12) init('            '),\n     2 AUX_OP8_TABLE73 char(12) init('            '),\n     2 AUX_OP8_TABLE74 char(12) init('            '),\n     2 AUX_OP8_TABLE75 char(12) init('            '),\n     2 AUX_OP8_TABLE76 char(12) init('            '),\n     2 AUX_OP8_TABLE77 char(12) init('            '),\n     2 AUX_OP8_TABLE78 char(12) init('            '),\n     2 AUX_OP8_TABLE79 char(12) init('            '),\n     2 AUX_OP8_TABLE7A char(12) init('            '),\n     2 AUX_OP8_TABLE7B char(12) init('            '),\n     2 AUX_OP8_TABLE7C char(12) init('            '),\n     2 AUX_OP8_TABLE7D char(12) init('            '),\n     2 AUX_OP8_TABLE7E char(12) init('            '),\n     2 AUX_OP8_TABLE7F char(12) init('            '),\n     2 AUX_OP8_TABLE80 char(12) init('VLVM VS     '),\n     2 AUX_OP8_TABLE81 char(12) init('VLCVMVS     '),\n     2 AUX_OP8_TABLE82 char(12) init('VSTVMVS     '),\n     2 AUX_OP8_TABLE83 char(12) init('            '),\n     2 AUX_OP8_TABLE84 char(12) init('VNVM VS     '),\n     2 AUX_OP8_TABLE85 char(12) init('VOVM VS     '),\n     2 AUX_OP8_TABLE86 char(12) init('VXVM VS     '),\n     2 AUX_OP8_TABLE87 char(12) init('            '),\n     2 AUX_OP8_TABLE88 char(12) init('            '),\n     2 AUX_OP8_TABLE89 char(12) init('            '),\n     2 AUX_OP8_TABLE8A char(12) init('            '),\n     2 AUX_OP8_TABLE8B char(12) init('            '),\n     2 AUX_OP8_TABLE8C char(12) init('            '),\n     2 AUX_OP8_TABLE8D char(12) init('            '),\n     2 AUX_OP8_TABLE8E char(12) init('            '),\n     2 AUX_OP8_TABLE8F char(12) init('            '),\n     2 AUX_OP8_TABLE90 char(12) init('            '),\n     2 AUX_OP8_TABLE91 char(12) init('            '),\n     2 AUX_OP8_TABLE92 char(12) init('            '),\n     2 AUX_OP8_TABLE93 char(12) init('            '),\n     2 AUX_OP8_TABLE94 char(12) init('            '),\n     2 AUX_OP8_TABLE95 char(12) init('            '),\n     2 AUX_OP8_TABLE96 char(12) init('            '),\n     2 AUX_OP8_TABLE97 char(12) init('            '),\n     2 AUX_OP8_TABLE98 char(12) init('            '),\n     2 AUX_OP8_TABLE99 char(12) init('            '),\n     2 AUX_OP8_TABLE9A char(12) init('            '),\n     2 AUX_OP8_TABLE9B char(12) init('            '),\n     2 AUX_OP8_TABLE9C char(12) init('            '),\n     2 AUX_OP8_TABLE9D char(12) init('            '),\n     2 AUX_OP8_TABLE9E char(12) init('            '),\n     2 AUX_OP8_TABLE9F char(12) init('            '),\n     2 AUX_OP8_TABLEA0 char(12) init('            '),\n     2 AUX_OP8_TABLEA1 char(12) init('            '),\n     2 AUX_OP8_TABLEA2 char(12) init('            '),\n     2 AUX_OP8_TABLEA3 char(12) init('            '),\n     2 AUX_OP8_TABLEA4 char(12) init('            '),\n     2 AUX_OP8_TABLEA5 char(12) init('            '),\n     2 AUX_OP8_TABLEA6 char(12) init('            '),\n     2 AUX_OP8_TABLEA7 char(12) init('            '),\n     2 AUX_OP8_TABLEA8 char(12) init('            '),\n     2 AUX_OP8_TABLEA9 char(12) init('            '),\n     2 AUX_OP8_TABLEAA char(12) init('            '),\n     2 AUX_OP8_TABLEAB char(12) init('            '),\n     2 AUX_OP8_TABLEAC char(12) init('            '),\n     2 AUX_OP8_TABLEAD char(12) init('            '),\n     2 AUX_OP8_TABLEAE char(12) init('            '),\n     2 AUX_OP8_TABLEAF char(12) init('            '),\n     2 AUX_OP8_TABLEB0 char(12) init('            '),\n     2 AUX_OP8_TABLEB1 char(12) init('            '),\n     2 AUX_OP8_TABLEB2 char(12) init('            '),\n     2 AUX_OP8_TABLEB3 char(12) init('            '),\n     2 AUX_OP8_TABLEB4 char(12) init('            '),\n     2 AUX_OP8_TABLEB5 char(12) init('            '),\n     2 AUX_OP8_TABLEB6 char(12) init('            '),\n     2 AUX_OP8_TABLEB7 char(12) init('            '),\n     2 AUX_OP8_TABLEB8 char(12) init('            '),\n     2 AUX_OP8_TABLEB9 char(12) init('            '),\n     2 AUX_OP8_TABLEBA char(12) init('            '),\n     2 AUX_OP8_TABLEBB char(12) init('            '),\n     2 AUX_OP8_TABLEBC char(12) init('            '),\n     2 AUX_OP8_TABLEBD char(12) init('            '),\n     2 AUX_OP8_TABLEBE char(12) init('            '),\n     2 AUX_OP8_TABLEBF char(12) init('            '),\n     2 AUX_OP8_TABLEC0 char(12) init('VSRSVSV     '),\n     2 AUX_OP8_TABLEC1 char(12) init('VMRSVSV     '),\n     2 AUX_OP8_TABLEC2 char(12) init('VSRRSSV     '),\n     2 AUX_OP8_TABLEC3 char(12) init('VMRRSSV     '),\n     2 AUX_OP8_TABLEC4 char(12) init('VLVCASV     '),\n     2 AUX_OP8_TABLEC5 char(12) init('VRCL SV     '),\n     2 AUX_OP8_TABLEC6 char(12) init('VSVMMSV     '),\n     2 AUX_OP8_TABLEC7 char(12) init('            '),\n     2 AUX_OP8_TABLEC8 char(12) init('VSTVPSV     '),\n     2 AUX_OP8_TABLEC9 char(12) init('            '),\n     2 AUX_OP8_TABLECA char(12) init('VACSVSV     '),\n     2 AUX_OP8_TABLECB char(12) init('VACRSSV     '),\n\n   1 AUX_OP_TABLE8 (0:203) char(12) def AUX_OP_TABLE8_ENTRIES,\n\n   1 AUX_OP_TABLE9_ENTRIES static, /* for op code E4 */\n     2 AUX_OP9_TABLE00 char(12) init('VLI  RSE    '), /* also VLIE  */\n     2 AUX_OP9_TABLE01 char(12) init('VSTI RSE    '), /* also VSTIE */\n     2 AUX_OP9_TABLE02 char(12) init('            '),\n     2 AUX_OP9_TABLE03 char(12) init('            '),\n     2 AUX_OP9_TABLE04 char(12) init('            '),\n     2 AUX_OP9_TABLE05 char(12) init('            '),\n     2 AUX_OP9_TABLE06 char(12) init('            '),\n     2 AUX_OP9_TABLE07 char(12) init('            '),\n     2 AUX_OP9_TABLE08 char(12) init('            '),\n     2 AUX_OP9_TABLE09 char(12) init('            '),\n     2 AUX_OP9_TABLE0A char(12) init('            '),\n     2 AUX_OP9_TABLE0B char(12) init('            '),\n     2 AUX_OP9_TABLE0C char(12) init('            '),\n     2 AUX_OP9_TABLE0D char(12) init('            '),\n     2 AUX_OP9_TABLE0E char(12) init('            '),\n     2 AUX_OP9_TABLE0F char(12) init('            '),\n     2 AUX_OP9_TABLE10 char(12) init('VLID RSE    '),\n     2 AUX_OP9_TABLE11 char(12) init('VSTIDRSE    '),\n     2 AUX_OP9_TABLE12 char(12) init('            '),\n     2 AUX_OP9_TABLE13 char(12) init('            '),\n     2 AUX_OP9_TABLE14 char(12) init('            '),\n     2 AUX_OP9_TABLE15 char(12) init('            '),\n     2 AUX_OP9_TABLE16 char(12) init('            '),\n     2 AUX_OP9_TABLE17 char(12) init('            '),\n     2 AUX_OP9_TABLE18 char(12) init('            '),\n     2 AUX_OP9_TABLE19 char(12) init('            '),\n     2 AUX_OP9_TABLE1A char(12) init('            '),\n     2 AUX_OP9_TABLE1B char(12) init('            '),\n     2 AUX_OP9_TABLE1C char(12) init('            '),\n     2 AUX_OP9_TABLE1D char(12) init('            '),\n     2 AUX_OP9_TABLE1E char(12) init('            '),\n     2 AUX_OP9_TABLE1F char(12) init('            '),\n     2 AUX_OP9_TABLE20 char(12) init('            '),\n     2 AUX_OP9_TABLE21 char(12) init('            '),\n     2 AUX_OP9_TABLE22 char(12) init('            '),\n     2 AUX_OP9_TABLE23 char(12) init('            '),\n     2 AUX_OP9_TABLE24 char(12) init('VSRL RSE    '),\n     2 AUX_OP9_TABLE25 char(12) init('VSLL RSE    '),\n     2 AUX_OP9_TABLE26 char(12) init('            '),\n     2 AUX_OP9_TABLE27 char(12) init('            '),\n     2 AUX_OP9_TABLE28 char(12) init('VLBIXRSE    '),\n\n   1 AUX_OP_TABLE9 (0:40) char(12) def AUX_OP_TABLE9_ENTRIES,\n\n\n     AUX_OP_TABLE_PTR (0:9)   static  ptr,\n     AUX_OP_TABLE_DIM (0:9)   static  fixed(15) bin,\n\n\n     DLOAD                       file   record input env(U),\n     DISPARM                     file   input,\n     DPRINT                      file   print,\n     DPUNCH                      file   record output env(F\n                                                      recsize(80)\n                                                      blksize(6160));\n\n Dcl\n     TEXT_BUFFER                        char(*) ctl;\n\n Dcl\n     1 LOAD_RECORD       aligned based(LOAD_PTR),\n       2 LOAD_TYPE       unaligned,\n         3 LOAD_IDR                     bit(1),\n         3 LOAD_SYM                     bit(1),\n         3 LOAD_CESD                    bit(1),\n         3 LOAD_SCATTER                 bit(1),\n         3 LOAD_END_OF_MODULE           bit(1),\n         3 LOAD_END_OF_SEGMENT          bit(1),\n         3 LOAD_RLD                     bit(1),\n         3 LOAD_CONTROL                 bit(1);\n Dcl\n     1 CESD_RECORD       aligned based(LOAD_PTR),\n       2 CESD_PREFIX,\n         3 CESD_IDENTIFICATION          bit(8),\n         3 CESD_FORMERLY_SPARE unaligned,\n           4 CESD_XA                    bit(1),\n           4 CESD_SPARE                 bit(23),\n         3 CESD_FIRST_ESDID             fixed(15) bin,\n         3 CESD_COUNT                   fixed(15) bin,\n       2 CESD_DATA                      char(16),\n\n     1 CESD_ENTRY        aligned based(CESD_PTR),\n       2 CESD_NAME                      char(8),\n       2 CESD_TYPE                      bit(8),\n       2 CESD_ADDRESS                   bit(24),\n       2 CESD_SEGMENT                   bit(8),\n       2 CESD_LENGTH                    bit(24), /* ID when labelref */\n\n     1 CESD_ENTRY2       aligned based(CESD_PTR),\n       2 CESD_NAME2                     char(8),\n       2 CESD_TYPE2    unaligned,\n         3 CESD_TYPE_BITS           (8) bit(1),\n       2 CESD_ADDRESS2                  bit(24),\n       2 CESD_SEGMENT2 unaligned,\n         3 CESD_XA_RESERVED             bit(4),\n         3 CESD_XA_RSECT                bit(1),\n         3 CESD_XA_RMODE                bit(1),\n         3 CESD_XA_AMODE                bit(2),\n       2 CESD_LENGTH2,\n         3 CESD_XA_LENGTH_FILLER        char(1),\n         3 CESD_XA_IDREF                fixed(15) bin,\n\n     1 CONTROL_RECORD    aligned based(LOAD_PTR),\n       2 CONTROL_PREFIX,\n         3 CONTROL_IDENTIFICATION       bit(8),\n         3 CONTROL_SPARE                bit(24),\n         3 CONTROL_CONTROL_COUNT        fixed(15) bin,\n         3 CONTROL_RLD_COUNT            fixed(15) bin,\n         3 CONTROL_CCW,\n           4 CONTROL_CCW_FLAGS1         bit(8),\n           4 CONTROL_CCW_ADDRESS        bit(24),\n           4 CONTROL_CCW_FLAGS2         bit(16),\n           4 CONTROL_CCW_LENGTH         fixed(15) bin,\n       2 CONTROL_DATA                   char(240),\n\n     1 CONTROL_ENTRY     aligned based(CONTROL_PTR),\n       2 CONTROL_ESDID                  fixed(15) bin,\n       2 CONTROL_LENGTH                 fixed(15) bin,\n\n     1 TEXT_RECORD        aligned based(LOAD_PTR),\n       2 TEXT_DATA                      char(32760),\n\n     1 RLD_RECORD        aligned based(LOAD_PTR),\n       2 RLD_PREFIX,\n         3 RLD_IDENTIFICATION           bit(8),\n         3 RLD_SPARE                    bit(24),\n         3 RLD_CONTROL_COUNT            fixed(15) bin,\n         3 RLD_RLD_COUNT                fixed(15) bin,\n         3 RLD_CCW                      char(8),\n       2 RLD_DATA                       char(240),\n\n     1 RLD_ENTRY         aligned based(RLD_PTR),\n       2 RLD_RELOCATION_POINTER         fixed(15) bin,\n       2 RLD_POSITION_POINTER           fixed(15) bin,\n       2 RLD_SUBDATA                    char(240),\n\n     1 RLD_SUBENTRY      aligned based(RLD_SUB_PTR),\n       2 RLD_FLAG      unaligned,\n         3 RLD_TYPE                     bit(4),\n         3 RLD_LENGTH                   bit(2),\n         3 RLD_NEGATIVE                 bit(1),\n         3 RLD_SAME_RP                  bit(1),\n       2 RLD_ADDRESS                    bit(24),\n\n     1 QUEUE             aligned static,\n       2 FIRST                          ptr init(Null),\n       2 LAST                           ptr init(Null),\n       2 MOST_RECENT                    ptr init(Null),\n\n     1 CEQ            like QUEUE static, /* ESD entry queue */\n     1 RAQ            like QUEUE static, /* RLD entry queue */\n     1 SPQ            like QUEUE static, /* start point queue */\n     1 LQ             like QUEUE static, /* label queue */\n     1 IQ             like QUEUE static, /* instruction queue */\n\n     CEQP                        static ptr,\n     RAQP                        static ptr,\n     SPQP                        static ptr,\n     LQP                         static ptr,\n     IQP                         static ptr,\n\n     1 CEQE                      based(CEQP),  /* ESD entry element */\n       2 CEQE_NEXT                      ptr,\n       2 CEQE_PREV                      ptr,\n       2 CEQE_ESDID                     fixed(31) bin, /* argument */\n       2 CEQE_NAME                      char(8),\n       2 CEQE_ADDRESS                   fixed(31) bin,\n       2 CEQE_LENGTH                    fixed(31) bin,\n       2 CEQE_IDREF                     fixed(31) bin, /* LR only */\n       2 CEQE_TYPE                      char(2),\n       2 CEQE_FLAGS                     bit(8),\n\n     1 RAQE                      based(RAQP),  /* RLD entry element */\n       2 RAQE_NEXT                      ptr,\n       2 RAQE_PREV                      ptr,\n       2 RAQE_ADDRESS                   fixed(31) bin, /* argument */\n       2 RAQE_LENGTH                    fixed(31) bin,\n       2 RAQE_RELOCATION                fixed(31) bin,\n       2 RAQE_NAME                      char(8),\n       2 RAQE_TYPE                      char(1),\n       2 RAQE_FLAGS,\n         3 RAQE_FLAGS_BITS unaligned,\n           4 RAQE_NEGATIVE              bit(1),\n           4 RAQE_UNRESOLVED            bit(1),\n           4 RAQE_FLAG3                 bit(1),\n           4 RAQE_FLAG4                 bit(1),\n           4 RAQE_FLAG5                 bit(1),\n           4 RAQE_FLAG6                 bit(1),\n           4 RAQE_FLAG7                 bit(1),\n           4 RAQE_FLAG8                 bit(1),\n\n     1 LQE                       based(LQP),   /* Label element */\n       2 LQE_NEXT                       ptr,\n       2 LQE_PREV                       ptr,\n       2 LQE_ADDRESS                    fixed(31) bin, /* argument */\n       2 LQE_NAME                       char(8),\n       2 LQE_FLAGS,\n         3 LQE_FLAGS_BITS unaligned,\n           4 LQE_ENTRY                  bit(1), /* entry (RLD LR)    */\n           4 LQE_CSECT                  bit(1), /* name of csect     */\n           4 LQE_GENERATED              bit(1), /* generated name    */\n           4 LQE_SYM                    bit(1), /* from symbol table */\n           4 LQE_FLAG5                  bit(1),\n           4 LQE_FLAG6                  bit(1),\n           4 LQE_FLAG7                  bit(1),\n           4 LQE_FLAG8                  bit(1),\n\n     1 SPQE                      based(SPQP),  /* Restart point */\n       2 SPQE_NEXT                      ptr,\n       2 SPQE_PREV                      ptr,\n       2 SPQE_ADDRESS                   fixed(31) bin, /* argument */\n       2 SPQE_LENGTH                    fixed(31) bin,\n       2 SPQE_RELOCATION                fixed(31) bin,\n       2 SPQE_LABEL                     char(8),\n       2 SPQE_NAME                      char(8),\n       2 SPQE_NAME2                     char(8),\n       2 SPQE_TYPE                      char(1),\n       2 SPQE_TYPE2                     char(1),\n       2 SPQE_FLAGS,\n         3 SPQE_FLAGS_BITS unaligned,\n           4 SPQE_EOM                   bit(1),/* end of csect       */\n           4 SPQE_COMPLEX               bit(1),/* complex relocation */\n           4 SPQE_ENTRY                 bit(1),/* external entry     */\n           4 SPQE_RLD                   bit(1),/* relocated address  */\n           4 SPQE_RLDEND                bit(1),/* end of reloc addr  */\n           4 SPQE_TOP                   bit(1),/* beginning of csect */\n           4 SPQE_FLOW                  bit(1),/* known good opcodes */\n           4 SPQE_RESERVED              bit(1),/* reserved           */\n\n     1 SP             static,\n       2 SP_NEXT                        ptr,\n       2 SP_PREV                        ptr,\n       2 SP_ADDRESS                     fixed(31) bin, /* argument */\n       2 SP_LENGTH                      fixed(31) bin,\n       2 SP_RELOCATION                  fixed(31) bin,\n       2 SP_LABEL                       char(8),\n       2 SP_NAME                        char(8),\n       2 SP_NAME2                       char(8),\n       2 SP_TYPE                        char(1),\n       2 SP_TYPE2                       char(1),\n       2 SP_FLAGS,\n         3 SP_FLAGS_BITS unaligned,\n           4 SP_EOM                     bit(1),/* end of csect       */\n           4 SP_COMPLEX                 bit(1),/* complex relocation */\n           4 SP_ENTRY                   bit(1),/* external entry     */\n           4 SP_RLD                     bit(1),/* relocated address  */\n           4 SP_RLDEND                  bit(1),/* end of reloc addr  */\n           4 SP_TOP                     bit(1),/* beginning of csect */\n           4 SP_FLOW                    bit(1),/* known good opcodes */\n           4 SP_RESERVED                bit(1),/* reserved           */\n\n     IPTR                        static ptr,\n     SAVE_IPTR                   static ptr,\n\n     1 INSTRUCTION_CHAR                 char(64) based(IPTR),\n     1 INSTRUCTION_BITS                 bit(48)  based(IPTR),\n\n     1 INSTRUCTION     unaligned based(IPTR),\n       2 OPCODE                         bit(8),\n       2 SUBOPCODE                      bit(8),\n\n     1 BRANCH_INST     unaligned based(IPTR),\n       2 BRANCH_OPCODE                  bit(8),\n       2 CONDMASK                       bit(4),\n\n /********************************************************************/\n /*                                                                  */\n /* The following operation code formats are defined:                */\n /*                                                                  */\n /*          _____________________________                           */\n /*  I      |           |                 |                          */\n /*         | Op Code   | Immediate Data  |                          */\n /*         |___________|_________________|                          */\n /*         0           8                16                          */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  N      |                             |                      |   */\n /*         | Op Code (2 bytes)           | //////////////////// |   */\n /*         |_____________________________|______________________|   */\n /*         0                            16                     32   */\n /*                                                                  */\n /*          _____________________________                           */\n /*  RR     |           |        |        |                          */\n /*         | Op Code   |   R1   |   R2   |                          */\n /*         |___________|________|________|                          */\n /*         0           8       12       16                          */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RR1    |           |                 |          |     |     |   */\n /*         | Op Code   | Sub-opcode      | //////// | R1  | /// |   */\n /*         |___________|_________________|__________|_____|_____|   */\n /*         0           8                16         24    28    32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RR2    |           |                 |          |     |     |   */\n /*         | Op Code   | Sub-opcode      | //////// | R1  | R2  |   */\n /*         |___________|_________________|__________|_____|_____|   */\n /*         0           8                16         24    28    32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RS     |           |        |        |      |               |   */\n /*         | Op Code   |   R1   |   R3   |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RSS    |           |        |        |      |               |   */\n /*         | Op Code   |   R1   | ////// |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  RX     |           |        |        |      |               |   */\n /*         | Op Code   |   R1   |  X2    |  B2  |  D2           |   */\n /*         |___________|________|________|______|_______________|   */\n /*         0           8       12       16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  S      |           |                 |      |               |   */\n /*         | Op Code   | /////////////// |  B1  |  D1           |   */\n /*         |___________|_________________|______|_______________|   */\n /*         0           8                16     20              32   */\n /*                                                                  */\n /*          ____________________________________________________    */\n /*  SI     |           |                 |      |               |   */\n /*         | Op Code   | Immediate Data  |  B1  |  D1           |   */\n /*         |___________|_________________|______|_______________|   */\n /*         0           8                16     20              32   */\n /*                                                                  */\n /*          _____________________________                           */\n /*  SPM    |           |        |        |                          */\n /*         | Op Code   |   R1   | ////// |                          */\n /*         |___________|________|________|                          */\n /*         0           8       12       16                          */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SSE    |        |         |    |            |    |            | */\n /*         | Opcode | Subop   | B1 |  D1        | B2 |  D2        | */\n /*         |________|_________|____|____________|____|____________| */\n /*         0        8       16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS1    |        |         |    |            |    |            | */\n /*         | Opcode |  L1     | B1 |  D1        | B2 |  D2        | */\n /*         |________|_________|____|____________|____|____________| */\n /*         0        8       16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS2    |        |    |    |    |            |    |            | */\n /*         | Opcode | L1 | L2 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS3    |        |    |    |    |            |    |            | */\n /*         | Opcode | L1 | I3 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  SS4    |        |    |    |    |            |    |            | */\n /*         | Opcode | R1 | I3 | B1 |  D1        | B2 |  D2        | */\n /*         |________|____|____|____|____________|____|____________| */\n /*         0        8   12  16   20           32   36           48  */\n /*                                                                  */\n /*                                                                  */\n /*                                                                  */\n /* ...and, for the new vector instructions:                         */\n /*                                                                  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QST    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QV     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | VR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  QV2    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR2  | //// | VR1  | //// |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VST    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | VR3  | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VS3    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | //// | RT2  | VR1  | RS2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | VR3  | //// | VR1  | VR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV1    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VV2    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | VR2  |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  RRE    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | GR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          ______________________________________________________  */\n /*  RSE    |        '         |    |    |    |    |    |          | */\n /*         | Opcode ' Sub-op. | R3 |////| VR1|////| B2 |    D2    | */\n /*         |________'_________|____|____|____|____|____|__________| */\n /*         0        8       16   20   24   28   32   36         48  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  SV     |           '             |      |                    |  */\n /*         | Op Code   ' Sub-opcode  |  B2  |        D2          |  */\n /*         |___________'_____________|______|____________________|  */\n /*         0           8            16     20                   32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR     |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | GR2  |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR1    |           '             |             |      |      |  */\n /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */\n /*         |___________'_____________|_____________|______|______|  */\n /*         0           8            16            24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VR2    |           '             |      |      |      |      |  */\n /*         | Op Code   ' Sub-opcode  | FR2  | //// | VR1  | //// |  */\n /*         |___________'_____________|______|______|______|______|  */\n /*         0           8            16     20     24     28     32  */\n /*                                                                  */\n /*          _____________________________________________________   */\n /*  VS     |           '             |                    |      |  */\n /*         | Op Code   ' Sub-opcode  |    ////////////    | RS2  |  */\n /*         |___________'_____________|____________________|______|  */\n /*         0           8            16                   28     32  */\n /*                                                                  */\n /*                                                                  */\n /********************************************************************/\n\n     1 RR_INSTRUCTION  aligned based(IPTR),\n       2 RR_OPCODE     bit(8),\n       2 RR_REGISTERS  unaligned,\n         3 RR_R1       bit(4),\n         3 RR_R2       bit(4),\n\n     1 RR_FLOAT_INST   aligned based(IPTR),\n       2 RR_FLOATCODE  bit(8),\n       2 RR_FLOATREGS  bit(8),\n\n     1 I_INSTRUCTION   aligned based(IPTR),\n       2 I_OPCODE      bit(8),\n       2 I_I           bit(8),\n\n     1 RX_INSTRUCTION  aligned based(IPTR),\n       2 RX_OPCODE     bit(8),\n       2 RX_REGISTERS  unaligned,\n         3 RX_R1       bit(4),\n         3 RX_X2       bit(4),\n       2 RX_B2D2       char(2),\n\n     1 S_INSTRUCTION   aligned based(IPTR),\n       2 S_OPCODE      bit(8),\n       2 S_ZEROES      bit(8),\n       2 S_B2D2        char(2),\n\n     1 N_INSTRUCTION   aligned based(IPTR),\n       2 N_OPCODE      bit(16),\n       2 N_ZEROES,\n         3 N_ZEROES1   bit(8),\n         3 N_ZEROES2   bit(8),\n\n     1 RS_INSTRUCTION  aligned based(IPTR),\n       2 RS_OPCODE     bit(8),\n       2 RS_REGISTERS  unaligned,\n         3 RS_R1       bit(4),\n         3 RS_R3       bit(4),\n       2 RS_B2D2       char(2),\n\n     1 SI_INSTRUCTION  aligned based(IPTR),\n       2 SI_OPCODE     bit(8),\n       2 SI_I2         char(1),\n       2 SI_B1D1       char(2),\n\n     1 SS1_INSTRUCTION aligned based(IPTR),\n       2 SS1_OPCODE    bit(8),\n       2 SS1_L1        bit(8),\n       2 SS1_B1D1      char(2),\n       2 SS1_B2D2      char(2),\n\n     1 SS2_INSTRUCTION aligned based(IPTR),\n       2 SS2_OPCODE    bit(8),\n       2 SS2_LENGTHS   unaligned,\n         3 SS2_L1      bit(4),\n         3 SS2_L2      bit(4),\n       2 SS2_B1D1      char(2),\n       2 SS2_B2D2      char(2),\n\n     1 SS3_INSTRUCTION aligned based(IPTR),\n       2 SS3_OPCODE    bit(8),\n       2 SS3_LENGTHS   unaligned,\n         3 SS3_L1      bit(4),\n         3 SS3_I3      bit(4),\n       2 SS3_B1D1      char(2),\n       2 SS3_B2D2      char(2),\n\n     1 SS4_INSTRUCTION aligned based(IPTR),\n       2 SS4_OPCODE    bit(8),\n       2 SS4_REGS      unaligned,\n         3 SS4_R1      bit(4),\n         3 SS4_I3      bit(4),\n       2 SS4_B1D1      char(2),\n       2 SS4_B2D2      char(2),\n\n     1 RR1_INSTRUCTION aligned based(IPTR),\n       2 RR1_OPCODE    bit(8),\n       2 RR1_SUBOP     bit(8),\n       2 RR1_ZEROES1   bit(8),\n       2 RR1_REGISTERS unaligned,\n         3 RR1_R1      bit(4),\n         3 RR1_ZEROES2 bit(4),\n\n     1 RR2_INSTRUCTION aligned based(IPTR),\n       2 RR2_OPCODE    bit(8),\n       2 RR2_SUBOP     bit(8),\n       2 RR2_ZEROES    bit(8),\n       2 RR2_REGISTERS unaligned,\n         3 RR2_R1      bit(4),\n         3 RR2_R2      bit(4),\n\n     1 SSE_INSTRUCTION aligned based(IPTR),\n       2 SSE_OPCODE    bit(8),\n       2 SSE_SUBOP     bit(8),\n       2 SSE_B1D1      char(2),\n       2 SSE_B2D2      char(2),\n\n     1 QST_INSTRUCTION aligned based(IPTR),\n       2 QST_OPCODE    bit(8),\n       2 QST_SUBOP     bit(8),\n       2 QST_REGISTERS unaligned,\n         3 QST_QR3     bit(4),\n         3 QST_RT2     bit(4),\n         3 QST_VR1     bit(4),\n         3 QST_RS2     bit(4),\n\n     1 QV_INSTRUCTION  aligned based(IPTR),\n       2 QV_OPCODE     bit(8),\n       2 QV_SUBOP      bit(8),\n       2 QV_REGISTERS  unaligned,\n         3 QV_QR3      bit(4),\n         3 QV_ZEROES   bit(4),\n         3 QV_VR1      bit(4),\n         3 QV_VR2      bit(4),\n\n     1 QV2_INSTRUCTION  aligned based(IPTR),\n       2 QV2_OPCODE     bit(8),\n       2 QV2_SUBOP      bit(8),\n       2 QV2_REGISTERS  unaligned,\n         3 QV2_QR2      bit(4),\n         3 QV2_ZEROES1  bit(4),\n         3 QV2_VR1      bit(4),\n         3 QV2_ZEROES2  bit(4),\n\n     1 VST_INSTRUCTION aligned based(IPTR),\n       2 VST_OPCODE    bit(8),\n       2 VST_SUBOP     bit(8),\n       2 VST_REGISTERS unaligned,\n         3 VST_VR3     bit(4),\n         3 VST_RT2     bit(4),\n         3 VST_VR1     bit(4),\n         3 VST_RS2     bit(4),\n\n     1 VS3_INSTRUCTION aligned based(IPTR),\n       2 VS3_OPCODE    bit(8),\n       2 VS3_SUBOP     bit(8),\n       2 VS3_REGISTERS unaligned,\n         3 VS3_ZEROES  bit(4),\n         3 VS3_RT2     bit(4),\n         3 VS3_VR1     bit(4),\n         3 VS3_RS2     bit(4),\n\n     1 VV_INSTRUCTION  aligned based(IPTR),\n       2 VV_OPCODE     bit(8),\n       2 VV_SUBOP      bit(8),\n       2 VV_REGISTERS  unaligned,\n         3 VV_VR3      bit(4),\n         3 VV_ZEROES   bit(4),\n         3 VV_VR1      bit(4),\n         3 VV_VR2      bit(4),\n\n     1 VV1_INSTRUCTION  aligned based(IPTR),\n       2 VV1_OPCODE     bit(8),\n       2 VV1_SUBOP      bit(8),\n       2 VV1_REGISTERS  unaligned,\n         3 VV1_ZEROES1  bit(8),\n         3 VV1_VR1      bit(4),\n         3 VV1_ZEROES2  bit(4),\n\n     1 VV2_INSTRUCTION  aligned based(IPTR),\n       2 VV2_OPCODE     bit(8),\n       2 VV2_SUBOP      bit(8),\n       2 VV2_REGISTERS  unaligned,\n         3 VV2_ZEROES   bit(8),\n         3 VV2_VR1      bit(4),\n         3 VV2_VR2      bit(4),\n\n     1 RRE_INSTRUCTION aligned based(IPTR),\n       2 RRE_OPCODE    bit(8),\n       2 RRE_SUBOP     bit(8),\n       2 RRE_REGISTERS unaligned,\n         3 RRE_ZEROES1 bit(8),\n         3 RRE_GR1     bit(4),\n         3 RRE_ZEROES2 bit(4),\n\n     1 RSE_INSTRUCTION aligned based(IPTR),\n       2 RSE_OPCODE    bit(8),\n       2 RSE_SUBOP     bit(8),\n       2 RSE_REGISTERS unaligned,\n         3 RSE_R3      bit(4),\n         3 RSE_ZEROES1 bit(4),\n         3 RSE_VR1     bit(4),\n         3 RSE_ZEROES2 bit(4),\n         3 RSE_B2D2    char(2),\n\n     1 SV_INSTRUCTION  aligned based(IPTR),\n       2 SV_OPCODE     bit(8),\n       2 SV_SUBOP      bit(8),\n       2 SV_B1D1       char(2),\n\n     1 VR_INSTRUCTION  aligned based(IPTR),\n       2 VR_OPCODE     bit(8),\n       2 VR_SUBOP      bit(8),\n       2 VR_REGISTERS  unaligned,\n         3 VR_QR3      bit(4),\n         3 VR_ZEROES   bit(4),\n         3 VR_VR1      bit(4),\n         3 VR_GR2      bit(4),\n\n     1 VR1_INSTRUCTION  aligned based(IPTR),\n       2 VR1_OPCODE     bit(8),\n       2 VR1_SUBOP      bit(8),\n       2 VR1_REGISTERS  unaligned,\n         3 VR1_ZEROES1  bit(8),\n         3 VR1_VR1      bit(4),\n         3 VR1_ZEROES2  bit(4),\n\n     1 VR2_INSTRUCTION  aligned based(IPTR),\n       2 VR2_OPCODE     bit(8),\n       2 VR2_SUBOP      bit(8),\n       2 VR2_REGISTERS  unaligned,\n         3 VR2_FR2      bit(4),\n         3 VR2_ZEROES1  bit(4),\n         3 VR2_VR1      bit(4),\n         3 VR2_ZEROES2  bit(4),\n\n     1 VS_INSTRUCTION  aligned based(IPTR),\n       2 VS_OPCODE     bit(8),\n       2 VS_SUBOP      bit(8),\n       2 VS_REGISTERS  unaligned,\n         3 VS_ZEROES   bit(12),\n         3 VS_RS1      bit(4),\n\n\n     INVLMOD                     condition,\n\n     (Date,Null,PLIDUMP,PLIRETC,Time,\n      Addr,Allocation,Dim,Hbound,High,Index,Lbound,Length,Low,\n      Max,Min,Mod,Repeat,String,Substr,Translate,Verify,Unspec)\n                                 builtin,\n     PLIXOPT            external static char(2) var init('NR');\n\n /*******************************************************************/\n1\n On Endfile(DLOAD)\n   DLOAD_EOF = '1'B;\n\n On Undefinedfile(DLOAD) begin;\n   Put file(DPRINT) edit('XDIS0002S File DISLOAD unavailable')\n                          (Skip(3),A);\n   Put file(DPRINT) edit('XDIS0003S Processing cannot continue')\n                          (Skip(1),A);\n   Call PLIRETC(16);\n   Stop;\n End;\n\n On Undefinedfile(DPUNCH) begin;\n   Put file(DPRINT) edit('XDIS0004W File DISPUNCH unavailable')\n                          (Skip(3),A);\n   Put file(DPRINT)\n      edit('XDIS0005W Processing continues without a PUNCH file')\n                          (Skip(1),A);\n   PUNCH = '0'B;\n End;\n\n On Undefinedfile(DISPARM)\n   Goto NO_DISPARM;\n\n On Name(DISPARM) begin;\n   Put file(DPRINT)\n      edit('XDIS0010W Unrecognized parameter ignored in DISPARM input')\n                          (Skip(3),A);\n End;\n\n On Condition(INVLMOD) begin;\n   Put file(DPRINT)\n   edit('XDIS0007S Invalid load module - processing terminated')\n                          (Skip(3),A);\n   Call PLIRETC(12);\n   Stop;\n\n End;\n\n /*******************************************************************/\n1\n AUX_OP_TABLE_PTR(0) = Addr(AUX_OP_TABLE0);\n AUX_OP_TABLE_PTR(1) = Addr(AUX_OP_TABLE1);\n AUX_OP_TABLE_PTR(2) = Addr(AUX_OP_TABLE2);\n AUX_OP_TABLE_PTR(3) = Addr(AUX_OP_TABLE3);\n AUX_OP_TABLE_PTR(4) = Addr(AUX_OP_TABLE4);\n AUX_OP_TABLE_PTR(5) = Addr(AUX_OP_TABLE5);\n AUX_OP_TABLE_PTR(6) = Addr(AUX_OP_TABLE6);\n AUX_OP_TABLE_PTR(7) = Addr(AUX_OP_TABLE7);\n AUX_OP_TABLE_PTR(8) = Addr(AUX_OP_TABLE8);\n AUX_OP_TABLE_PTR(9) = Addr(AUX_OP_TABLE9);\n AUX_OP_TABLE_DIM(0) = Hbound(AUX_OP_TABLE0,1);\n AUX_OP_TABLE_DIM(1) = Hbound(AUX_OP_TABLE1,1);\n AUX_OP_TABLE_DIM(2) = Hbound(AUX_OP_TABLE2,1);\n AUX_OP_TABLE_DIM(3) = Hbound(AUX_OP_TABLE3,1);\n AUX_OP_TABLE_DIM(4) = Hbound(AUX_OP_TABLE4,1);\n AUX_OP_TABLE_DIM(5) = Hbound(AUX_OP_TABLE5,1);\n AUX_OP_TABLE_DIM(6) = Hbound(AUX_OP_TABLE6,1);\n AUX_OP_TABLE_DIM(7) = Hbound(AUX_OP_TABLE7,1);\n AUX_OP_TABLE_DIM(8) = Hbound(AUX_OP_TABLE8,1);\n AUX_OP_TABLE_DIM(9) = Hbound(AUX_OP_TABLE9,1);\n\n /*******************************************************************/\n\n Open file(DPRINT) title('DISPRINT') linesize(150),\n      file(DLOAD)  title('DISLOAD');\n\n Put file(DPRINT) skip(2);\n Do I = 1 to Hbound(COPYRIGHT_NOTICE_AND_DISCLAIMER,1);\n  Put file(DPRINT) skip(1)\n      edit(COPYRIGHT_NOTICE_AND_DISCLAIMER(I)) (A);\n End;\n Put file(DPRINT) skip(3);\n\n CSECT_NAME = PARM;\n\n If CSECT_NAME = '' then do;\n   Put file(DPRINT)\n       edit(\n 'XDIS0006I No control section specified, CESD entries will be listed')\n           (Skip(2),A);\n   ESD = 'Y';\n End;\n\n Else do;\n  Get file(DISPARM) data(ESA,XA,SP1,VF,ESD,INCREMENT,OPSCAN);\n  Unspec(ESA) = Unspec(ESA) | '01000000'B;\n  Unspec(XA)  = Unspec(XA)  | '01000000'B;\n  Unspec(SP1) = Unspec(SP1) | '01000000'B;\n  Unspec(VF)  = Unspec(VF)  | '01000000'B;\n  Unspec(ESD) = Unspec(ESD) | '01000000'B;\n  If  ESA ^= 'Y' then ESA = 'N';\n  If  XA  ^= 'Y' then XA  = 'N';\n  If  SP1 ^= 'Y' then SP1 = 'N';\n  If  VF  ^= 'Y' then VF  = 'N';\n  If  ESD ^= 'Y' then ESD = 'N';\n\n  If ESA = 'Y' then XA  = 'Y';\n  If VF  = 'Y' then XA  = 'Y';\n  If XA  = 'Y' then SP1 = 'Y';\n\n End;\n\n NO_DISPARM:\n\n If ESA = 'Y' then do;\n                       OP_INDEX_LIMIT = 183; /* but what about VF? */\n                       AUX_OP_TABLE_DIM(4) = 79; /* B24F */\n                       AUX_OP_TABLE_DIM(5) = 15; /* E50F */\n End;\n Else if VF  = 'Y' then do;\n                       OP_INDEX_LIMIT = 179;\n                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else if XA  = 'Y' then do;\n                       OP_INDEX_LIMIT = 175;\n                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else if SP1 = 'Y' then do;\n                       OP_INDEX_LIMIT = 169;\n                       AUX_OP_TABLE_DIM(4) = 44; /* B22C */\n                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */\n End;\n Else do;\n                       OP_INDEX_LIMIT = 165;\n                       AUX_OP_TABLE_DIM(4) = 19; /* B213 */\n                    /* AUX_OP_TABLE_DIM(5) irrelevant    */\n End;\n\n If ESA ^= 'Y' then do;\n   AUX_OP1_TABLE1A = '';   /* no CFC unless ESA, just like UPT */\n End;\n Else If ESA = 'Y' & VF = 'N' then do;\n   OP_TABLE176 = '';\n   OP_TABLE177 = '';\n   OP_TABLE178 = '';\n   OP_TABLE179 = '';\n End;\n\n READ_LOAD: Do while (^ DLOAD_EOF);\n\n   Read file(DLOAD) set(LOAD_PTR);\n\n   If DLOAD_EOF then Leave READ_LOAD;\n\n   If TEXT then do;\n     Call PROCESS_TEXT;\n     TEXT = '0'B;\n     If LAST_TEXT then DLOAD_EOF = '1'B;\n   End;\n\n   Else do;\n\n     If LOAD_END_OF_MODULE then LAST_TEXT = '1'B;\n\n     If LOAD_CESD then do;\n       If LOAD_SYM | LOAD_CONTROL | LOAD_RLD then\n         Signal condition(INVLMOD);\n       Call PROCESS_CESD;\n     End;\n\n     If LOAD_SYM then do;\n       If LOAD_CONTROL | LOAD_RLD then\n         Signal condition(INVLMOD);\n     End;\n\n     If LOAD_CONTROL then do;\n       TEXT = '1'B;\n       Call PROCESS_CONTROL;\n     End;\n\n     If LOAD_RLD then do;\n       Call PROCESS_RLD;\n     End;\n\n   End;\n\n End READ_LOAD;\n\n Close file(DLOAD);\n\n /* Now...set up start point queue entries. */\n\n /* Add a start point entry for the physical end of the csect. */\n Call ADD_START_POINT (CSECT_LENGTH);\n SPQE_EOM = '1'B;\n\n /* Create a start point for the beginning of the module. */\n Call ADD_START_POINT (0);\n SPQE_LABEL = CSECT_NAME;\n SPQE_TOP = '1'B;\n\n Do CEQP = CEQ.FIRST repeat CEQE_NEXT while (CEQP ^= Null);\n   If CEQE_TYPE = 'LR' & CEQE_IDREF = ESDID then do;\n    /* For each label reference in our csect (i.e. entry point name) */\n    /* create a start point and a label element */\n     Call ADD_START_POINT (CEQE_ADDRESS - CSECT_OFFSET);\n     SPQE_LABEL = CEQE_NAME;\n     SPQE_ENTRY = '1'B;\n     If CEQE_NAME ^= CSECT_NAME then do;\n       Allocate LQE set(LQP);\n       LQE_ADDRESS = SPQE_ADDRESS;\n       LQE_NAME = CEQE_NAME;\n       String(LQE_FLAGS) = '00000000'B;\n       LQE_ENTRY = '1'B;\n       Call INSERT(LQP,Addr(LQ));\n     End;\n   End;\n End;\n\n Do RAQP = RAQ.FIRST repeat RAQE_NEXT while (RAQP ^= Null);\n   /* For each relocated addr in our csect, create a start point */\n   /* If already an entry, assume a label entry and modify it. */\n   Call ADD_START_POINT (RAQE_ADDRESS);\n   SPQE_RLD = '1'B;\n   /* If this is a negative value, this must be a complexly\n      relocatable address constant, and there must be 2 entries\n      with the same address (the existing one will be updated). */\n   If RAQE_NEGATIVE then do;\n    SPQE_NAME2 = RAQE_NAME;\n    SPQE_TYPE2 = RAQE_TYPE;\n    SPQE_RLD = '1'B;\n    SPQE_COMPLEX = '1'B;\n   End;\n   Else do;\n    SPQE_LENGTH = RAQE_LENGTH;\n    SPQE_RELOCATION = RAQE_RELOCATION;\n    SPQE_NAME = RAQE_NAME;\n    SPQE_TYPE = RAQE_TYPE;\n    SPQE_RLD = '1'B;\n   End;\n   /* Do the same to mark the end of each relocated address      */\n   /* If already an entry, assume a label entry and modify it. */\n   Call ADD_START_POINT (RAQE_ADDRESS + RAQE_LENGTH);\n   SPQE_RLDEND = '1'B;\n End;\n\n /* Free the ESD queue and display entries if requested */\n\n If ESD = 'Y' then do;\n   On ENDPAGE(DPRINT) begin;\n     PAGENUM = PAGENUM + 1;\n     Put file(DPRINT) page\n         edit(CSECT_NAME,' - COMPOSITE EXTERNAL SYMBOL DICTIONARY',\n              'PAGE ',NUMOUT(PAGENUM))\n             (X(18),A(8),A,X(40),A,A(5));\n     Put file(DPRINT) skip(3)\n         list('SYMBOL   TYPE  ID   ADDR  LENGTH LRID FLAGS');\n     Put file(DPRINT) skip(2);\n   End;\n   Signal ENDPAGE(DPRINT);\n End;\n Do CEQP = CEQ.FIRST repeat TEMP_PTR while (CEQP ^= Null);\n   If ESD = 'Y' then do;\n     ESD_ID   = Substr(HEXNUM(CEQE_ESDID),5,4);\n     ESD_LEN  = '';\n     Unspec(ESD_LDID) = Unspec('    ');\n     Unspec(ESD_FLAGS) = Unspec('  ');\n     If CEQE_TYPE = 'ER' |\n        CEQE_TYPE = 'NL' |\n        CEQE_TYPE = 'WX' then\n       ESD_ADDR = '';\n     Else do;\n       ESD_ADDR = Substr(HEXNUM(CEQE_ADDRESS),3,6);\n       If CEQE_TYPE = 'LR' then\n         ESD_LDID = Substr(HEXNUM(CEQE_IDREF),5,4);\n       Else\n         ESD_LEN  = Substr(HEXNUM(CEQE_LENGTH),3,6);\n     End;\n     If CEQE_TYPE = 'SD' |\n        CEQE_TYPE = 'PC' then\n       ESD_FLAGS = Substr(HEXNUM(CEQE_FLAGS),7,2);\n     Put file(DPRINT)\n         list(CEQE_NAME||'  '||CEQE_TYPE||'  '||ESD_ID  ||' '  ||\n              ESD_ADDR ||' ' ||ESD_LEN  ||' ' ||ESD_LDID||'   '||\n              ESD_FLAGS);\n     Put file(DPRINT) skip(1);\n   End;\n   TEMP_PTR = CEQE_NEXT;\n   Free CEQE;\n End;\n\n /* Free the RLD queue */\n\n Do RAQP = RAQ.FIRST repeat TEMP_PTR while (RAQP ^= Null);\n   TEMP_PTR = RAQE_NEXT;\n   Free RAQE;\n End;\n\n If CSECT_NAME = '' then do;\n   RETCODE = 4;\n   Goto FIN;\n End;\n\n If CSECT_LENGTH = 0 then do;\n   Put file(DPRINT) skip(2)\n       list('XDIS0008E Requested control section '||CSECT_NAME||\n       ' not found in load module');\n   RETCODE = 12;\n   Goto FIN;\n End;\n Else if CSECT_LENGTH < 0 then do;\n   Put file(DPRINT) skip(2)\n       list('XDIS0011E Requested control section '||CSECT_NAME||\n       ' unresolved in load module');\n   RETCODE = 12;\n   Goto FIN;\n End;\n\n PUNCH = '1'B; /* set to '0'B if undefined file occurs */\n\n Open file(DPUNCH) title('DISPUNCH');\n\n IOFF = 0;\n\n SYSDATE = Date;\n TODAY = Substr(SYSDATE,3,2)||'/'||Substr(SYSDATE,5,2)||'/'||\n         Substr(SYSDATE,1,2);\n\n Call OUTPUT('','TITLE',\n             ''''||CSECT_NAME||' - source generated by XDIS on '||\n             TODAY||'''');\n\n If PRIVATE_CODE then CSECT_LABEL = '';\n Else CSECT_LABEL = CSECT_NAME;\n\n Call OUTPUT(CSECT_LABEL,'CSECT','');\n\n If AMODE ^= '   ' then Call OUTPUT(CSECT_LABEL,'AMODE',AMODE);\n If RMODE ^= '   ' then Call OUTPUT(CSECT_LABEL,'RMODE',RMODE);\n\n DOIT_LOOP:Do while (SPQ.FIRST ^= Null);\n\n   SPQP = SPQ.FIRST;\n   SP = SPQE;\n   Call DELETE(SPQP,Addr(SPQ));\n   If SP_EOM then Leave DOIT_LOOP;\n\n   BLOCK_LENGTH = SP_NEXT->SPQE_ADDRESS - SP_ADDRESS;\n   IOFF = SP_ADDRESS;\n   Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n\n   Do LQP = Locate(Addr(LQ),IOFF) repeat LQE_NEXT\n            while (LQP ^= Null & LQE_ADDRESS = IOFF);\n     If LQE_ENTRY then\n       Call OUTPUT('        ','ENTRY',LQE_NAME);\n     Call OUTPUT (LQE_NAME,'EQU  ','*');\n     SP_LABEL = '';\n   End;\n\n   If SP_LABEL = CSECT_NAME then SP_LABEL = '';\n\n   If SP_RLD then do;\n     CONDITION_CODE = ' ';\n     VALID_INST = '0'B;\n     RECOGNIZED_INST = '0'B;\n     NAME = SP_NAME;\n     ILEN = SP_LENGTH;\n     IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n     Select (ILEN);\n       When (2) I = IPTR->ADCON2 - SP_RELOCATION;\n       When (3) I = IPTR->ADCON3 - SP_RELOCATION;\n       When (4) I = IPTR->ADCON4 - SP_RELOCATION;\n       Otherwise;\n     End;\n     If SP_TYPE = 'Q' then\n       Call OUTPUT(SP_LABEL,'DS   ','QL'||NUMOUT(ILEN));\n     Else do;\n       TYPE = SP_TYPE;\n       If TYPE = 'W' then do;\n        TYPE = 'A';\n        Call OUTPUT_XTRN ('WXTRN',SP_NAME);\n       End;\n       Else if TYPE = 'X' then do;\n        TYPE = 'A';\n        Call OUTPUT_XTRN ('EXTRN',SP_NAME);\n       End;\n       If SP_TYPE2 = 'W' then do;\n        Call OUTPUT_XTRN ('WXTRN',SP_NAME2);\n       End;\n       Else if SP_TYPE2 = 'X' then do;\n        Call OUTPUT_XTRN ('EXTRN',SP_NAME2);\n       End;\n\n       If ILEN = 4 & Mod(IOFF,4) = 0 then\n        OPERANDS = TYPE || '(' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       Else\n        OPERANDS = TYPE || 'L' || NUMOUT(ILEN) || '(' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       If SP_COMPLEX then do;\n        NAME = SP_NAME2;\n        OPERANDS = OPERANDS || '-' ||\n                   Substr(NAME9,1,Index(NAME9,' ')-1);\n       End;\n       If I = 0 then OPERANDS = OPERANDS || ')';\n       Else if I = -2147483648 then /* XA pointer-defined linkage */\n        OPERANDS = OPERANDS || '+X''80000000'')';\n       Else if I < 0 then do;\n        If I < -2130706432 then do; /* 80000000 thru 80ffffff */\n         Unspec(I) = Unspec(I) & '01111111111111111111111111111111'B;\n         OPERANDS = OPERANDS || '+' || NUMOUT(I) || '+X''80000000'')';\n        End;\n        Else do; /* 81000000 thru 8fffffff */\n         OPERANDS = OPERANDS || '-' || NUMOUT(-I) || ')';\n        End;\n       End;\n       Else OPERANDS = OPERANDS || '+' || NUMOUT(I) || ')';\n       Call OUTPUT(SP_LABEL,'DC   ',OPERANDS);\n     End;\n     SP_LABEL = '';\n   End;\n\n   Else\n   OTHER_THAN_RLD:Do;\n     If SP_FLOW then VALID_INST = '1'B;\n     Else\n     DETERMINE_IF_FLOW:Do;\n       SAVE_IOFF = IOFF;\n       SAVE_IPTR = IPTR;\n       VALID_CHAIN = '0'B;\n       FIND_GOOD_OPCODE_CHAIN:\n       Do I = 0 to BLOCK_LENGTH/2*2-1 by 2 until(VALID_CHAIN);\n         VALID_CHAIN = '1'B;\n         J = BLOCK_LENGTH - I;\n         IOFF = SAVE_IOFF + I;\n         RUN_OPCODE_CHAIN:\n         Do K = 1 to OPSCAN while (VALID_CHAIN);\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           If IOFF = SAVE_IOFF + BLOCK_LENGTH then do;\n             If SPQ.FIRST->SPQE_RLD |\n                SPQ.FIRST->SPQE_ENTRY /* added 12/19/89 */ |\n                SPQ.FIRST->SPQE_EOM then VALID_CHAIN = '0'B;\n             Leave RUN_OPCODE_CHAIN;\n           End;\n           Else if IOFF > SAVE_IOFF + BLOCK_LENGTH then\n             VALID_CHAIN = '0'B;\n           Else do;\n             TEMP_PTR = OP_CODE_LOCATOR(IPTR,J);\n             If TEMP_PTR = Null then do;\n               VALID_CHAIN = '0'B;\n               Leave RUN_OPCODE_CHAIN;\n             End;\n             L = OPLENGTH(IPTR);\n             If I ^= 0 & K = 1 & Verify(Substr(INSTRUCTION_CHAR,1,L),\n               'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$') = 0 then\n               VALID_CHAIN = '0'B;\n             Else if VALID_BRANCH_CODE(IPTR,J) then do;\n               IOFF = IOFF + L;\n               Leave RUN_OPCODE_CHAIN;\n             End;\n             Else do;\n               IOFF = IOFF + L;\n               J = J - L;\n             End;\n           End;\n         End RUN_OPCODE_CHAIN;\n       End FIND_GOOD_OPCODE_CHAIN;\n       If VALID_CHAIN then do;\n         Call ADD_START_POINT (IOFF);\n         If I ^= 0 then do;\n           VALID_INST = '0'B;\n           Call ADD_START_POINT (SAVE_IOFF + I);\n           SPQE_FLOW = '1'B;\n         End;\n         Else do;\n           VALID_INST = '1'B;\n           SP_FLOW = '1'B;\n         End;\n       End;\n       Else do;\n         VALID_INST = '0'B;\n         SP_FLOW = '0'B;\n       End;\n       IPTR = SAVE_IPTR;\n       IOFF = SAVE_IOFF;\n     End DETERMINE_IF_FLOW;\n\n     BLOCK_LENGTH = SPQ.FIRST->SPQE_ADDRESS - SP_ADDRESS;\n     DO_A_BUNCH:\n     Do while (BLOCK_LENGTH > 0);\n       Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n       If VALID_INST then do;\n         ILEN = OPLENGTH(IPTR);\n         If ILEN > BLOCK_LENGTH then do;\n           VALID_INST = '0'B;\n           ILEN = BLOCK_LENGTH;\n         End;\n         IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n         RECOGNIZED_INST = VALID_INST;\n           /*******************************************************/\n         OP_PTR = OP_CODE_LOCATOR(IPTR,(BLOCK_LENGTH));\n         If OP_PTR = Null then do;\n           Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n           CONDITION_CODE = ' ';\n         End;\n         Else GENERATE_INSTRUCTION:do;\n\n\n           OPERATION = OP_NAME;\n           Select (OP_FORMAT);\n             When ('RR ') do;\n               OPERANDS = NUMOUT((RR_R1))||','||NUMOUT((RR_R2));\n             End;\n             When ('I  ') do;\n               OPERANDS = NUMOUT((I_I));\n             End;\n             When ('SPM') do;\n               OPERANDS = NUMOUT((RR_R1));\n             End;\n             When ('RX ') do;\n               OPERANDS = NUMOUT((RX_R1)) || ',' ||\n                          GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');\n             End;\n             When ('S  ') do;\n               OPERANDS = GEN_EFF_ADDR(S_B2D2,0,' ');\n             End;\n             When ('N  ') do;\n               OPERANDS = '';\n             End;\n             When ('RS ') do;\n               OPERANDS = NUMOUT((RS_R1))||','||NUMOUT(RS_R3)||','||\n                          GEN_EFF_ADDR(RS_B2D2,0,' ');\n             End;\n             When ('RSS') do;\n               OPERANDS = NUMOUT((RS_R1)) || ',' ||\n                          GEN_EFF_ADDR(RS_B2D2,0,'S');\n             End;\n             When ('SI ') do;\n               If OP_TYPE = 'C' & Verify(SI_I2,\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./') = 0\n               then\n               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||\n                          'C'''||SI_I2 ||'''';\n               Else\n               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||\n                          'X'''||HEXOUT(SI_I2)||'''';\n             End;\n             When ('SS1') do;\n               OPERANDS = GEN_EFF_ADDR(SS1_B1D1,(SS1_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS1_B2D2,0,' ');\n             End;\n             When ('SS2') do;\n               OPERANDS = GEN_EFF_ADDR(SS2_B1D1,(SS2_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS2_B2D2,(SS2_L2),'L');\n             End;\n             When ('SS3') do;\n               OPERANDS = GEN_EFF_ADDR(SS3_B1D1,(SS3_L1),'L') || ',' ||\n                          GEN_EFF_ADDR(SS3_B2D2,0,'S')        || ',' ||\n                          NUMOUT((SS3_I3));\n             End;\n             When ('SS4') do;\n               OPERANDS = GEN_EFF_ADDR(SS4_B1D1,(SS4_R1),'M') || ',' ||\n                          GEN_EFF_ADDR(SS4_B2D2,0,'S')        || ',' ||\n                          NUMOUT((SS4_I3));\n             End;\n             When ('RR1') do;\n               OPERANDS = NUMOUT((RR1_R1));\n             End;\n             When ('RR2') do;\n               OPERANDS = NUMOUT((RR2_R1))||','||NUMOUT((RR2_R2));\n             End;\n             When ('SSE') do;\n               OPERANDS = GEN_EFF_ADDR(SSE_B1D1,0,' ') || ',' ||\n                          GEN_EFF_ADDR(SSE_B2D2,0,' ');\n             End;\n             When ('QST') do;\n               OPERANDS = NUMOUT((QST_VR1)) || ',' ||\n                          NUMOUT((QST_QR3)) || ',' ||\n                          NUMOUT((QST_RS2)) || '(' ||\n                          NUMOUT((QST_RT2)) || ')';\n             End;\n             When ('QV ') do;\n               OPERANDS = NUMOUT((QV_VR1)) || ',' ||\n                          NUMOUT((QV_QR3)) || ',' ||\n                          NUMOUT((QV_VR2));\n             End;\n             When ('QV2') do;\n               OPERANDS = NUMOUT((QV2_VR1)) || ',' ||\n                          NUMOUT((QV2_QR2));\n             End;\n             When ('VST') do;\n               OPERANDS = NUMOUT((VST_VR1)) || ',' ||\n                          NUMOUT((VST_VR3)) || ',' ||\n                          NUMOUT((VST_RS2)) || '(' ||\n                          NUMOUT((VST_RT2)) || ')';\n             End;\n             When ('VS3') do;\n               OPERANDS = NUMOUT((VS3_VR1)) || ',' ||\n                          NUMOUT((VS3_RS2)) || '(' ||\n                          NUMOUT((VS3_RT2)) || ')';\n             End;\n             When ('VV ') do;\n               OPERANDS = NUMOUT((VV_VR1)) || ',' ||\n                          NUMOUT((VV_VR3)) || ',' ||\n                          NUMOUT((VV_VR2));\n             End;\n             When ('VV1') do;\n               OPERANDS = NUMOUT((VV1_VR1));\n             End;\n             When ('VV2') do;\n               OPERANDS = NUMOUT((VV2_VR1)) || ',' ||\n                          NUMOUT((VV2_VR2));\n             End;\n             When ('RRE') do;\n               OPERANDS = NUMOUT((RRE_GR1));\n             End;\n             When ('RRZ') do;\n               OPERANDS = '';\n             End;\n             When ('RSE') do;\n               OPERANDS = NUMOUT((RSE_VR1)) || ',' ||\n                          NUMOUT((RSE_R3))  || ',' ||\n                          GEN_EFF_ADDR(RSE_B2D2,0,' ');\n             End;\n             When ('SV ') do;\n               OPERANDS = GEN_EFF_ADDR(SV_B1D1,0,' ');\n             End;\n             When ('VR ') do;\n               OPERANDS = NUMOUT((VR_VR1)) || ',' ||\n                          NUMOUT((VR_QR3)) || ',' ||\n                          NUMOUT((VR_GR2));\n             End;\n             When ('VR1') do;\n               OPERANDS = NUMOUT((VR1_VR1));\n             End;\n             When ('VR2') do;\n               OPERANDS = NUMOUT((VR2_VR1)) || ',' ||\n                          NUMOUT((VR2_FR2));\n             End;\n             When ('VS ') do;\n               OPERANDS = NUMOUT((VS_RS1));\n             End;\n             Otherwise\n               RECOGNIZED_INST = '0'B;\n           End;\n           If (RECOGNIZED_INST) & (OP_TYPE = 'B') then\n           PROCESS_MNEMONIC:do;\n             MNEMONIC_OPER = '?';\n             Select (CONDITION_CODE);\n               When ('A')\n                 MNEMONIC_STRING = 'ZMPO';\n               When ('C')\n                 MNEMONIC_STRING = 'ELH?';\n               When ('Z')\n                 MNEMONIC_STRING = 'Z???';\n               Otherwise\n                 MNEMONIC_STRING = '????';\n             End;\n             Select(CONDMASK);\n               When ('0000'B)\n                 MNEMONIC_OPER = 'NOP';\n               When ('1111'B)\n                 MNEMONIC_OPER = 'B';\n               When ('1000'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,1,1);\n               When ('0100'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,2,1);\n               When ('0010'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,3,1);\n               When ('0001'B)\n                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,4,1);\n               When ('0111'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,1,1);\n               When ('1011'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,2,1);\n               When ('1101'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,3,1);\n               When ('1110'B)\n                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,4,1);\n               Otherwise\n                 MNEMONIC_OPER = '?';\n             End;\n             If Index(MNEMONIC_OPER,'?') = 0 then do;\n               If OP_FORMAT = 'RR ' then do;\n                 MNEMONIC_OPER = MNEMONIC_OPER || 'R';\n                 OPERANDS = NUMOUT((RR_R2));\n               End;\n               Else do;\n                 OPERANDS = GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');\n               End;\n               OPERATION = MNEMONIC_OPER;\n             End;\n           End PROCESS_MNEMONIC;\n           If RECOGNIZED_INST then\n             Call OUTPUT(SP_LABEL,OPERATION,OPERANDS);\n           Else\n             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n           If OP_CC ^= ' ' then CONDITION_CODE = OP_CC;\n         End GENERATE_INSTRUCTION;\n         SP_LABEL = '';\n         BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n         IOFF = IOFF + ILEN;\n       End;\n       Else NOT_INSTRUCTIONS:do;\n         RECOGNIZED_INST = '0'B;\n         CONDITION_CODE = ' ';\n         PROCESS_DEECEES: Do while (BLOCK_LENGTH > 0);\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           K = Min(32,BLOCK_LENGTH);\n           ILEN = Verify(Substr(INSTRUCTION_CHAR,1,K),\n             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./');\n           If ILEN = 0 then ILEN = K;\n           Else ILEN = ILEN - 1;\n           If ILEN ^= 0 then do;\n             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n             Call OUTPUT(SP_LABEL,'DC   ','C'''||\n                         Substr(INSTRUCTION_CHAR,1,ILEN)||'''');\n             SP_LABEL = '';\n           End;\n           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n           IOFF = IOFF + ILEN;\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n           K = Min(8,BLOCK_LENGTH);\n           Do ILEN = 1 to K while (Index(\n             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./',\n              Substr(INSTRUCTION_CHAR,ILEN,1)) = 0);\n           End;\n           ILEN = ILEN - 1;\n           If ILEN ^= 0 then do;\n             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));\n             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');\n             SP_LABEL = '';\n           End;\n           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;\n           IOFF = IOFF + ILEN;\n           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;\n         End PROCESS_DEECEES;\n       End NOT_INSTRUCTIONS;\n     End DO_A_BUNCH;\n   End OTHER_THAN_RLD;\n\n End DOIT_LOOP;\n\n Call OUTPUT('        ','END  ','');\n\n FIN:\n\n If RETCODE ^= 0 then\n   Put file(DPRINT) skip(2)\n     list('XDIS0001I Processing terminated, highest return code is ' ||\n     NUMOUT(RETCODE));\n\n If PUNCH then Close file(DPUNCH);\n Close file(DPRINT);\n\n Call PLIRETC(RETCODE);\n\n Return;\n\n /*******************************************************************/\n1\n OUTPUT_XTRN: Proc(XTRN,NAME);\n\n  Dcl XTRN              char (5),\n      NAME              char (8);\n  Dcl (NP,NEWP)         ptr;\n  Dcl NAMELIST_PTR      static ptr init(Null());\n  Dcl 1 NAMELIST based,\n        2 NAMELIST_NEXT ptr,\n        2 NAMELIST_NAME char(8);\n\n  /* See if NAME is already on the list. */\n  Do NP = NAMELIST_PTR repeat (NP->NAMELIST_NEXT)\n                       while  (NP ^= Null());\n   If NP->NAMELIST_NAME = NAME then return; /* don't generate stmt */\n  End;\n  Allocate NAMELIST set(NEWP);\n  NEWP->NAMELIST_NEXT = NAMELIST_PTR;\n  NEWP->NAMELIST_NAME = NAME;\n  NAMELIST_PTR = NEWP;\n  Call OUTPUT ('        ',XTRN,NAME);\n\n End OUTPUT_XTRN;\n\n /*******************************************************************/\n1\n OUTPUT:Proc(LABEL,OPERATION,OPERANDS) reorder;\n\n Dcl LABEL              char  (8),\n     OPERATION          char  (5),\n     OPERANDS           char (56) var,\n     LOC8        static char(8),\n     LOC                char(6) def LOC8 pos(3),\n     RE_LOC8     static char(8),\n     RE_LOC             char(6) def RE_LOC8 pos(3),\n     LINE        static char (80),\n     OBJECT_DUMP static char (16),\n     IMAGE_TEMP  static char (12),\n     CURRENT_STATEMENT_NUMBER\n                 static fixed (5) dec init(0),\n     STMTNO             pic '99999',\n     SEQNUM      static fixed (8) dec init(0),\n     SEQUENCE           pic   '99999999' def LINE pos(73),\n     HEADING     static char(48) var init('');\n\n LOC8 = HEXNUM(IOFF);\n RE_LOC8 = HEXNUM(IOFF+CSECT_OFFSET);\n\n If OPERATION = 'END  '\n  | OPERATION = 'ENTRY'\n  | OPERATION = 'TITLE'\n  | OPERATION = 'WXTRN'\n  | OPERATION = 'EXTRN'\n  | OPERATION = 'AMODE'\n  | OPERATION = 'RMODE'\n                        then do;\n   LOC = '';\n   RE_LOC = '';\n   OBJECT_DUMP = '';\n End;\n Else if OPERATION = 'EQU  '\n       | OPERATION = 'CSECT'\n                             then do;\n   OBJECT_DUMP = '';\n End;\n Else if RECOGNIZED_INST then do;\n   IMAGE_TEMP = IMAGE;\n   OBJECT_DUMP = Substr(IMAGE_TEMP,1,4)||' '||Substr(IMAGE_TEMP,5,4)||\n                 ' '|| Substr(IMAGE_TEMP,9,4);\n End;\n Else do;\n   OBJECT_DUMP = Substr(IMAGE,1,Min(16,Length(IMAGE)));\n End;\n\n LINE = LABEL||' '||OPERATION||' '||OPERANDS;\n SEQNUM = SEQNUM + INCREMENT;\n SEQUENCE = SEQNUM;\n CURRENT_STATEMENT_NUMBER = CURRENT_STATEMENT_NUMBER + 1;\n STMTNO = CURRENT_STATEMENT_NUMBER;\n\n If PUNCH then\n   Write file(DPUNCH) from(LINE);\n\n On ENDPAGE(DPRINT) begin;\n   PAGENUM = PAGENUM + 1;\n   Put file(DPRINT) page edit(HEADING,'PAGE ',NUMOUT(PAGENUM))\n                             (X(18),A,X(47),A,A(5));\n   Put file(DPRINT) skip(3)\n   list('LM-LOC CS-LOC  OBJECT CODE         STMT   SOURCE STATEMENT');\n   Put file(DPRINT) skip(2);\n End;\n\n If OPERATION = 'TITLE' then do;\n   Get string(OPERANDS) list(HEADING);\n   Signal ENDPAGE(DPRINT);\n End;\n\n Else Put file(DPRINT) /* skip(1) */\n   list(RE_LOC||' '||LOC||'  '||OBJECT_DUMP||'   '||STMTNO||' '||LINE);\n\n End OUTPUT;\n\n /*******************************************************************/\n1\n OPLENGTH: Proc(IPTR) returns(fixed(15) bin) reorder;\n\n Dcl IPTR   ptr,\n     RETURN_VALUE static fixed(15) bin,\n     OPCODE_BITS bit(8) based(IPTR);\n\n Select (OPCODE_BITS & '11000000'B);\n   When ('00000000'B) RETURN_VALUE = 2;\n   When ('11000000'B) RETURN_VALUE = 6;\n   Otherwise          RETURN_VALUE = 4;\n End;\n\n Return(RETURN_VALUE);\n\n End OPLENGTH;\n\n /*******************************************************************/\n1\n OP_CODE_LOCATOR: Proc(IPTR,J) returns(ptr) reorder;\n\n Dcl IPTR              ptr,\n     J                 fixed(15) bin,\n     SAVE_AUX9  static pic '9',\n     SAVE_AUX          char(1) def SAVE_AUX9,\n     AUX        static fixed(15) bin,\n     RETURN_PTR static ptr,\n     1 OPCODE  aligned based(IPTR),\n       2 OPCODE1       bit(8),\n       2 OPCODE2       bit(8);\n\n If J < OPLENGTH(IPTR) then Return(Null);  /* bug fixed 12/15/89 */\n\n   OP_INDEX = OP_CODE_LOOKUP(OPCODE1);\n   If OP_INDEX > OP_INDEX_LIMIT then Return(Null);\n   OP_PTR = Addr(OP_TABLE0(OP_INDEX));\n   If OP_AUX ^= ' ' then do;\n     SAVE_AUX = OP_AUX;\n     AUX = SAVE_AUX9;\n     OP_INDEX = OPCODE2;\n     If OP_INDEX > AUX_OP_TABLE_DIM(AUX) then Return(Null);\n     OP_PTR = Addr(AUX_OP_TABLE_PTR(AUX)->AUX_OP_ARRAY(OP_INDEX));\n   End;\n   RETURN_PTR = OP_PTR;\n   Select (OP_SPEC);\n     When (' ') do;\n     End;\n     When ('E') do;\n       If ((RR_FLOATREGS & '10011001'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('D') do;\n       If ((RR_FLOATREGS & '10111011'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('F') do;\n       If ((RR_FLOATREGS & '10010000'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('G') do;\n       If ((RR_FLOATREGS & '10110000'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('H') do;\n       If ((RR_FLOATREGS & '10111001'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('M') do;\n       If (Substr(RR_R1,4,1)) then\n         RETURN_PTR = Null;\n     End;\n     When ('L') do;\n       If (Substr(RR_R1,4,1) | Substr(RR_R2,4,1)) then\n         RETURN_PTR = Null;\n     End;\n     When ('S') do;\n       If ((S_ZEROES) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('N') do;\n       If ((N_ZEROES1) ^= '00000000'B) |\n          ((N_ZEROES2) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('1') do;\n       If ((RS_R3) ^= '0000'B) then RETURN_PTR = Null;\n     End;\n     When ('2') do;\n       If ((RR_FLOATREGS & '00011111'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('C') do;\n       If ((Unspec(SI_I2) & '11110000'B) ^= '00000000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('X') do;\n       If ((RR1_ZEROES1) ^= '00000000'B) |\n          ((RR1_ZEROES2) ^= '0000'B) then\n         RETURN_PTR = Null;\n     End;\n     When ('Y') do;\n       If ((RR2_ZEROES) ^= '00000000'B) then RETURN_PTR = Null;\n     End;\n     Otherwise do;\n       RETURN_PTR = Null;\n     End;\n   End;\n\n Return (RETURN_PTR);\n\n End OP_CODE_LOCATOR;\n\n /*******************************************************************/\n1\n VALID_BRANCH_CODE: Proc(IPTR,REMAINING_LENGTH) returns(bit(1)) reorder;\n\n Dcl IPTR                 ptr,\n     REMAINING_LENGTH     fixed(15) bin,\n     RETURN_VALUE  static bit(1),\n     OPDATA               char(6) based(IPTR),\n     DOUBLEOPCODE         bit(16) based(IPTR),\n     1 OPCODE            aligned  based(IPTR),\n       2 OPCODE1          bit(8),\n       2 OPCODE2          bit(8),\n     1 BRANCHOPCODES     aligned  based(IPTR),\n       2 BRANCHOPCODE     bit(8),\n       2 BRANCHSTUFF   unaligned,\n         3 BRANCHMASK     bit(4),\n         3 BRANCHREG      bit(4);\n\n If REMAINING_LENGTH < OPLENGTH(IPTR) then RETURN_VALUE = '0'B;\n\n Else if (\n    ((OPCODE1) = '01000101'B)           /* 45 - BAL                */ |\n    ((OPCODE1) = '01001101'B)           /* 4D - BAS                */ |\n    ((OPCODE1) = '00001011'B)           /* 0B - BSM                */ |\n    ((OPCODE1) = '00001100'B)           /* 0C - BASSM              */ |\n    (((OPCODE1)='00000101'B) & ((BRANCHREG) ^='0000'B)) /* 05 BALR */ |\n    (((OPCODE1)='00001101'B) & ((BRANCHREG) ^='0000'B)) /* 0D BASR */ |\n    (((OPCODE1)='00000111'B) & ((BRANCHMASK)^='0000'B)) /* 07 BCR  */ |\n    (((OPCODE1)='01000111'B) & ((BRANCHMASK)^='0000'B)) /* 47 BC   */ |\n    ((DOUBLEOPCODE) = '0000101000000011'B)   /*  0A03 - EXIT       */ |\n    ((DOUBLEOPCODE) = '0000101000000111'B)   /*  0A07 - XCTL       */ |\n    ((DOUBLEOPCODE) = '0000101000001101'B)   /*  0A0D - ABEND      */ |\n    ((DOUBLEOPCODE) = '1000001000000000'B)   /*  8200 - LPSW       */ |\n    ((DOUBLEOPCODE) = '0000000100000001'B)   /*  0101 - PR         */ |\n    (((DOUBLEOPCODE)='1011001001000000'B) & ((BRANCHREG)^='0000'B))\n                                             /*  B240 - BAKR       */\n                  ) then RETURN_VALUE = '1'B;\n Else RETURN_VALUE = '0'B;\n\n Return (RETURN_VALUE);\n\n End VALID_BRANCH_CODE;\n\n /*******************************************************************/\n1\n GEN_EFF_ADDR: Proc (SCON,R3,FLAG) returns(char(32) var) reorder;\n\n Dcl SCON              char(2),\n     R3                fixed(31) bin,\n     FLAG              char(1),\n     SYMBOL     static char(32) var,\n     BASEANDDISPLACEMENT static bit(16),\n     1 B2D2            def BASEANDDISPLACEMENT,\n       2 B2D2UN unaligned,\n         3 B2          bit(4),\n         3 D2          bit(12),\n     BASEREG    static fixed(31) bin,\n     BASE       static char(16) var,\n     DISPL      static char(16) var,\n     DISPL_TEMP static fixed(15) bin;\n\n BASEANDDISPLACEMENT = Unspec(SCON);\n BASEREG  = (B2);\n BASE     = NUMOUT((BASEREG));\n Unspec(DISPL_TEMP) = BASEANDDISPLACEMENT & '0000111111111111'B;\n DISPL    = NUMOUT((DISPL_TEMP));\n\n Select (FLAG);\n   When ('I') do;\n     If BASEREG = 0 & R3 = 0 then SYMBOL = DISPL;\n     Else if BASEREG = 0 then SYMBOL = DISPL || '(' ||NUMOUT(R3)|| ')';\n     Else if R3 = 0      then SYMBOL = DISPL || '(,'|| BASE     || ')';\n     Else SYMBOL = DISPL || '(' ||NUMOUT(R3) || ',' || BASE     || ')';\n   End;\n   When ('L') do;\n     SYMBOL = DISPL || '(' || NUMOUT(R3+1) || ',' || BASE || ')' ;\n   End;\n   When ('M') do;\n     SYMBOL = DISPL || '(' || NUMOUT(R3) || ',' || BASE || ')' ;\n   End;\n   When ('S') do;\n     If BASEREG = 0 then SYMBOL = DISPL;\n     Else SYMBOL = DISPL || '(' || BASE || ')' ;\n   End;\n   Otherwise do;\n     SYMBOL = DISPL || '(' || BASE || ')' ;\n   End;\n End;\n\n Return (SYMBOL);\n\n End GEN_EFF_ADDR;\n\n /*******************************************************************/\n1\n ADD_START_POINT: Proc (ADDRESS) reorder;\n\n Dcl ADDRESS fixed(31) bin;\n\n SPQP = LOCATE (Addr(SPQ),ADDRESS);\n If SPQP = Null then do;\n   Allocate SPQE set(SPQP);\n   SPQE_ADDRESS     = ADDRESS;\n   SPQE_LENGTH      = 0;\n   SPQE_RELOCATION  = 0;\n   SPQE_LABEL       = '';\n   SPQE_NAME        = '';\n   SPQE_NAME2       = '';\n   SPQE_TYPE        = '';\n   SPQE_TYPE2       = '';\n   String(SPQE_FLAGS) = '00000000'B;\n   Call INSERT (SPQP,Addr(SPQ));\n End;\n\n SPQ.MOST_RECENT = SPQP;\n\n Return;\n\n End ADD_START_POINT;\n\n /*******************************************************************/\n1\n PROCESS_CESD: Proc;\n\n CESD_ESDID = CESD_FIRST_ESDID;\n\n XA_MODULE = (CESD_XA);\n\n Addr(CESD_PTR)->N = Addr(LOAD_PTR)->N + 8; /* Bump past CESD_PREFIX */\n Addr(END_PTR)->N = Addr(CESD_PTR)->N + CESD_COUNT;\n\n LOOP_CESD: Do while (Addr(CESD_PTR)->N < Addr(END_PTR)->N);\n\n   Allocate CEQE set(CEQP);  /* Create a CESD queue entry */\n   CEQE_ESDID = CESD_ESDID;\n   CEQE_NAME = CESD_NAME;\n   CEQE_ADDRESS = CESD_ADDRESS;\n   CEQE_LENGTH = CESD_LENGTH;\n   CEQE_IDREF = 0;\n   CEQE_FLAGS = CESD_SEGMENT;\n\n   Select (CESD_TYPE & '00001111'B);\n\n     When ('00000000'B) do;  /* Section definition */\n       CEQE_TYPE = 'SD';\n     End;\n\n     When ('00000011'B) do;  /* Label reference */\n       CEQE_TYPE = 'LR';\n       CEQE_IDREF = CESD_XA_IDREF;\n     End;\n\n     When ('00000100'B) do;  /* Private code    */\n       If ^ CESD_TYPE_BITS(4) then do;\n         CEQE_NAME = '$PRIVATE';\n         PRIVATE_CODE = '1'B;\n       End;\n       CEQE_TYPE = 'PC';\n     End;\n\n     When ('00000101'B) do;  /* Common          */\n       CEQE_TYPE = 'CM';\n     End;\n\n     When ('00000110'B) do;  /* Pseudo register */\n       CEQE_TYPE = 'PR';\n     End;\n\n     When ('00000111'B) do;  /* Null            */\n       CEQE_TYPE = 'NL';\n     End;\n\n     When ('00000010'B) do;  /* External reference      */\n       CEQE_TYPE = 'ER';\n     End;\n\n     When ('00001010'B) do;  /* Weak external reference */\n       CEQE_TYPE = 'WX';\n     End;\n\n     Otherwise do;\n       CEQE_TYPE = '??';\n       Put file(DPRINT) skip(1)\n             list('XDIS0009S Invalid CESD entry type '|| CESD_TYPE);\n     End;\n\n   End;\n\n   If CSECT_NAME = CEQE_NAME & Index('SD PC ER WX',CEQE_TYPE) ^= 0\n      then do; /* Establish our csect */\n     ESDID = CESD_ESDID;\n     If CEQE_TYPE = 'ER' | CEQE_TYPE = 'WX' then do;\n       CSECT_LENGTH = -1;\n     End;\n     Else do;\n       CSECT_LENGTH = CESD_LENGTH;\n       CSECT_OFFSET = CESD_ADDRESS;\n       If ((XA_MODULE) & (CESD_SEGMENT ^= '00000000'B)) then do;\n         If CESD_XA_RMODE then RMODE = 'ANY';\n         Else                  RMODE = '24 ';\n         Select ((CESD_SEGMENT & '00000011'B));\n           When ('00000010'B)  AMODE = '31 ';\n           When ('00000011'B)  AMODE = 'ANY';\n           Otherwise           AMODE = '24 ';\n         End;\n       End;\n     End;\n   End;\n\n   Call INSERT(CEQP,Addr(CEQ));  /*  Add CESD entry to queue */\n\n   CESD_ESDID = CESD_ESDID + 1;\n   Addr(CESD_PTR)->N = Addr(CESD_PTR)->N + Length(CESD_DATA);\n\n End LOOP_CESD;\n\n End PROCESS_CESD;\n\n /*******************************************************************/\n1\n PROCESS_CONTROL: Proc;\n\n MOVE_TEXT = '0'B;\n Addr(CONTROL_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of prefix */\n                        + CONTROL_RLD_COUNT;  /* in case combo rec */\n Addr(END_PTR)->N = Addr(CONTROL_PTR)->N + CONTROL_CONTROL_COUNT;\n CONTROL_FIND_CSECT:\n Do while(Addr(CONTROL_PTR)->N < Addr(END_PTR)->N);\n   If CONTROL_ESDID = ESDID then do;\n     If TEXT_PTR = Null then do;\n       Allocate TEXT_BUFFER char(((CSECT_LENGTH+7)/8)*8);\n       TEXT_PTR = Addr(TEXT_BUFFER);\n     End;\n     TEXT_MOVE_OFFSET = Max(0, CONTROL_CCW_ADDRESS - CSECT_OFFSET);\n     TEXT_MOVE_SOURCE = Max(0, CSECT_OFFSET - CONTROL_CCW_ADDRESS);\n     TEXT_MOVE_LENGTH = CONTROL_LENGTH;\n     MOVE_TEXT = '1'B;\n     Leave CONTROL_FIND_CSECT;\n   End;\n  Addr(CONTROL_PTR)->N = Addr(CONTROL_PTR)->N + 4;\n End CONTROL_FIND_CSECT;\n\n End PROCESS_CONTROL;\n\n /*******************************************************************/\n1\n PROCESS_TEXT: Proc;\n\n If MOVE_TEXT then do;\n\n   Substr(TEXT_BUFFER,TEXT_MOVE_OFFSET+1,TEXT_MOVE_LENGTH) =\n     Substr(TEXT_DATA,TEXT_MOVE_SOURCE+1,TEXT_MOVE_LENGTH);\n\n End;\n\n End PROCESS_TEXT;\n\n /*******************************************************************/\n1\n PROCESS_RLD: Proc;\n\n Addr(RLD_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of RLD_PREFIX */;\n Addr(END_PTR)->N = Addr(RLD_PTR)->N + RLD_RLD_COUNT;\n LOOP_RLD: Do while (Addr(RLD_PTR)->N < Addr(END_PTR)->N);\n\n   PROCESS_RLD_SUBENTRIES:\n   Do Addr(RLD_SUB_PTR)->N = Addr(RLD_PTR)->N + 4\n                             repeat Addr(RLD_SUB_PTR)->N + 4;\n     If RLD_POSITION_POINTER = ESDID then do;\n       Allocate RAQE set(RAQP);\n       RAQE_ADDRESS = RLD_ADDRESS - CSECT_OFFSET;\n       RAQE_LENGTH = RLD_LENGTH+1;\n       TEMP_PTR = LOCATE(Addr(CEQ),RLD_RELOCATION_POINTER);\n       If TEMP_PTR = Null then do;\n         RAQE_NAME = '';\n         RAQE_RELOCATION = 0;\n       End;\n       Else do;\n         RAQE_NAME = TEMP_PTR->CEQE_NAME;\n         RAQE_RELOCATION = TEMP_PTR->CEQE_ADDRESS;\n       End;\n       String(RAQE_FLAGS) = '00000000'B;\n       If RLD_NEGATIVE then RAQE_NEGATIVE = '1'B;\n       RAQE_UNRESOLVED = (Substr(RLD_TYPE,1,1));\n       RAQE_TYPE = Substr('AVPQ    AV      ',RLD_TYPE+1,1);\n       If RAQE_TYPE = 'A' then do;\n        If TEMP_PTR->CEQE_TYPE = 'WX' then RAQE_TYPE = 'W';\n        Else if TEMP_PTR->CEQE_TYPE = 'ER' then RAQE_TYPE = 'X';\n       End;\n       Call INSERT(RAQP,Addr(RAQ));\n     End;\n     If ^ RLD_SAME_RP then Leave PROCESS_RLD_SUBENTRIES;\n   End PROCESS_RLD_SUBENTRIES;\n\n   Addr(RLD_PTR)->N = Addr(RLD_SUB_PTR)->N + 4;\n\n End LOOP_RLD;\n\n End PROCESS_RLD;\n\n /*******************************************************************/\n1\n INSERT: Proc(E_PTR,Q_PTR) reorder;\n\n /* This subroutine inserts an element into a queue. */\n\n Dcl (E_PTR, Q_PTR) ptr,\n     P                    static ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(E_PTR),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr,\n       2 E_ARG                   fixed(31) bin;\n\n P = Q.MOST_RECENT;\n If P ^= Null &\n    E_ARG >= P->E_ARG &\n    (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)\n   then;\n Else do P = Q.LAST repeat P->E_PREV while (P ^= Null);\n   If E_ARG >= P->E_ARG &\n      (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)\n     then Leave;\n End;\n E_PREV = P;\n If P ^= Null then do;  /* not at top of queue */\n   E_NEXT = P->E_NEXT;\n   P->E_NEXT = E_PTR;\n End;\n Else do;               /* top of queue */\n   E_NEXT = Q.FIRST;\n   Q.FIRST = E_PTR;\n End;\n If E_NEXT = Null then Q.LAST = E_PTR;\n Else E_NEXT->E_PREV = E_PTR;\n\n End INSERT;\n\n /*******************************************************************/\n1\n DELETE: Proc(E_PTR,Q_PTR) reorder;\n\n /* This subroutine deletes an element from a queue. */\n\n Dcl (E_PTR, Q_PTR) ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(E_PTR),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr;\n\n If E_PREV = Null then Q.FIRST = E_NEXT;\n Else E_PREV->E_NEXT = E_NEXT;\n\n If E_NEXT = Null then Q.LAST = E_PREV;\n Else E_NEXT->E_PREV = E_PREV;\n\n Free E;\n\n End DELETE;\n\n /*******************************************************************/\n1\n LOCATE: Proc(Q_PTR,ARG) returns(ptr) reorder;\n\n /* This subroutine locates an element in a queue. */\n\n Dcl (Q_PTR) ptr,\n     ARG    fixed(31) bin,\n     P                    static ptr,\n     1 Q     like QUEUE          based(Q_PTR),\n     1 E                         based(P),\n       2 E_NEXT                  ptr,\n       2 E_PREV                  ptr,\n       2 E_ARG                   fixed(31) bin;\n\n Do P = Q.FIRST repeat E_NEXT while (P ^= Null);\n   If E_ARG = ARG then Leave;\n End;\n\n Q.MOST_RECENT = P;  /* Set ptr for easy access to element */\n\n Return(P);\n\n End LOCATE;\n\n /*******************************************************************/\n1\n NUMOUT: Proc(N) returns(char(14) var) reorder;\n\n Dcl N              fixed(31) bin,\n     N_CHAR  static char(14),\n     N_CHAR_VAR     char(14) var;\n\n N_CHAR = N;\n\n N_CHAR_VAR = Substr(N_CHAR,Verify(N_CHAR,' '));\n\n Return (N_CHAR_VAR);\n\n End NUMOUT;\n\n /*******************************************************************/\n1\n HEXNUM:Proc(NUMBER) returns(char(8)) reorder;\n\n /* This subroutine takes a binary fullword and returns the\n    character representation of the hexadecimal data therein. */\n\n Dcl NUMBER               fixed(31) bin,\n     PACKED_DATA   static fixed(9) dec,\n     PACKED_FOUR_BYTES    fixed(31) bin unaligned based,\n     HEXUNPACKED9  static pic '(9)9',\n     HEXSTRING            char(8)   def HEXUNPACKED9;\n\n Addr(PACKED_DATA)->PACKED_FOUR_BYTES = NUMBER;\n HEXUNPACKED9 = PACKED_DATA;\n HEXSTRING = Translate(HEXSTRING,TRANS_TABLE);\n\n Return(HEXSTRING);\n\n End HEXNUM;\n\n /*******************************************************************/\n1\n HEXOUT:Proc(INPUT) returns(char(1024) var) reorder;\n\n /* This subroutine takes a character string and returns the\n    character representation of the hexadecimal data therein. */\n\n Dcl INPUT                   char(*)    var,\n     PACKEDVALUE      static fixed (9)  dec unaligned,\n     HEXVALUE         based  char  (4)      unaligned,\n     HEXUNPACKED9     static pic '(9)9',\n     HEXDATA                 char(9)    def HEXUNPACKED9,\n     I                static fixed(15)  bin,\n     HEXSTRING               char(2*Length(INPUT)+4) var init('');\n\n Do I = 1 to Length(INPUT) by 4;\n\n   Addr(PACKEDVALUE)->HEXVALUE = Substr(INPUT,I);\n   HEXUNPACKED9 = PACKEDVALUE;\n   HEXSTRING = HEXSTRING || Translate(Substr(HEXDATA,1,8),TRANS_TABLE);\n\n End;\n\n Return(Substr(HEXSTRING,1,2*Length(INPUT)));\n\n End HEXOUT;\n\n /*******************************************************************/\n\n\n End XDIS;\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT772/FILE772.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT772", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}