./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00170-00170-00000-SEB
------------------------------------------------------------------------
Name:     BREAKUP
Type:     C
Purpose:  Break up a data set into a bunch of smaller data sets
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     CHEX
Type:     C
Purpose:  Interactive hex calculator
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     FLDATA
Type:     C
Purpose:  Demonstrate C fldata() function
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     FLENGTH
Type:     C
Purpose:  Show number of bytes in a data set using C fseek()
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     FTPCLI
Type:     C
Purpose:  FTP client
Requires:
Used by:
Comments: TCP/IP For MVS
------------------------------------------------------------------------
Name:     GFTP
Type:     C
Purpose:  Get a file via FTP
Requires:
Used by:
Comments: TCP/IP For MVS
------------------------------------------------------------------------
Name:     GSVCTEST
Type:     C
Purpose:  Example of using the generalized SVC routine in C
Requires: GSVC H
          XGSVC C
Used by:
Comments:
------------------------------------------------------------------------
Name:     HEXDUMP
Type:     C
Purpose:  Dump contents of a file in hex dump format
Requires:
Used by:
Comments: Not sure what the difference is between this and HEXDUMP2
------------------------------------------------------------------------
Name:     HEXDUMP2
Type:     C
Purpose:  Dump contents of a file in hex dump format
Requires:
Used by:
Comments: Not sure what the difference is between this and HEXDUMP
------------------------------------------------------------------------
Name:     HEXIN
Type:     C
Purpose:  Subroutine to convert a hex string to binary data
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     HTTPDO
Type:     C
Purpose:  Line-mode Web (HTTP) client
Requires:
Used by:
Comments: Requires TCP/IP for MVS
------------------------------------------------------------------------
Name:     JAY
Type:     C
Purpose:  Convert date between Julian and Gregorian
Requires:
Used by:
Comments: Like CLIST J but doesn't know how to get current date
------------------------------------------------------------------------
Name:     MAKENULL
Type:     C
Purpose:  Demonstrate creation of null records by a C program
Requires:
Used by:
Comments: Because C used to not make null records properly (does it now?
------------------------------------------------------------------------
Name:     MAKEUP
Type:     C
Purpose:  Create an IEBUPDTE stream from a PDS
Requires:
Used by:
Comments: Compare BREAKUP
------------------------------------------------------------------------
Name:     MATCH
Type:     C
Purpose:  Pattern matcher, sort of like grep
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     NUSERS
Type:     C
Purpose:  Display ASVT entries and number of TSO users logged on
Requires:
Used by:
Comments: (Did I write this?)
------------------------------------------------------------------------
Name:     REXXIT
Type:     C
Purpose:  Demonstrate REXX interface from C, I guess
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     REXXJCL
Type:     C
Purpose:  Demonstrate REXX interface from C, I guess
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     SIGFAIL
Type:     C
Purpose:  Demonstrate that MVS does not handle SIGINT properly
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     SMTPDOG
Type:     C
Purpose:  Send mail messages via SMTP
Requires:
Used by:  CLIST MAILDSN,MAILFILE
Comments: Requires TCP/IP for MVS
------------------------------------------------------------------------
Name:     TSOPREF
Type:     C
Purpose:  Show TSO userid and prefix
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XGALLOC
Type:     C
Purpose:  Perform allocation from a non-TSO environment
Requires:
Used by:
Comments: Used by MVS Gopher server
------------------------------------------------------------------------
Name:     XPASTE
Type:     C
Purpose:  Perform X Window System "paste" operation
Requires: TCP/IP X11
Used by:
Comments: You can "paste" data from a remote workstation onto a 3270...
------------------------------------------------------------------------
Name:     X800
Type:     C
Purpose:  Show all possible "words" that spell out a 7-digit pbone #
Requires:
Used by:
Comments:
------------------------------------------------------------------------
./ ADD NAME=BREAKUP  0100-07332-07332-0900-00102-00102-00000-SEB
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int
main(argc,argv)
int    argc;
char **argv;
{
 char *infile;
 char *cp;
 int   rc;
 int   size;
 int   count;
 int   filenum;
 FILE *ifp;
 FILE *ofp;
 char  outfile[128];
 char  inline[2048];

 if (argc != 3) {
   fprintf(stderr,"Usage: %s filename lines\n",argv[0]);
   return 12;
 }
 infile = argv[1];
 size   = atoi(argv[2]);
 if (size == 0) {
   fprintf(stderr,"Usage: %s filename lines (nonzero)\n",argv[0]);
   return 12;
 }
 ofp = NULL;
 rc = 0;
 count = 0;
 filenum = 0;
 ifp = fopen(infile,"r");
 if (!ifp) {
   perror(infile);
   return 12;
 }
 for (;;) {
   fgets(inline,sizeof(inline),ifp);
   if (ferror(ifp)) {
     fprintf(stderr,"Error reading %s\n",infile);
     rc++;
     break;
   }
   if (feof(ifp)) break;
   /*
   if ((cp=strchr(inline,'\n'))) *cp = '\0';
   */
   count++;
   if (count > size) count = 1;
   if (count == 1) {
     if (ofp) {
       if (fclose(ofp) < 0) {
         fprintf(stderr,"Error closing %s\n",outfile);
         rc++;
       }
       else {
         fprintf(stderr,"%s created (%d lines)\n",outfile,size);
       }
       ofp = NULL;
     }
     filenum++;
     sprintf(outfile,"%s.PART%d",infile,filenum);
     for (cp=outfile;*cp;cp++) *cp=toupper(*cp);
     fprintf(stderr,"Creating file %s\n",outfile);
     ofp = fopen(outfile,"w,recfm=vb,lrecl=255,blksize=6233");
     if (!ofp) {
       perror(outfile);
       fprintf(stderr,"Processing aborted.\n");
       rc++;
       break;
     }
   }
   fputs(inline,ofp);
   if (ferror(ofp)) {
     fprintf(stderr,"Error writing to %s\n",outfile);
     fprintf(stderr,"Processing aborted.\n");
     rc++;
     break;
   }
 }

 if (ofp) {
   if (fclose(ofp) < 0) {
     fprintf(stderr,"Error closing %s\n",outfile);
     rc++;
   }
   else {
     fprintf(stderr,"%s created (%d lines)\n",outfile,count);
   }
   ofp = NULL;
 }

 if (fclose(ifp) < 0) {
   fprintf(stderr,"Error closing %s\n",infile);
 }

 return 0;

}
./ ADD NAME=CHEX     0100-07332-07332-0900-00170-00170-00000-SEB
/* HEXCOMP: Program to do hex calculations */
#pragma runopts(execops)
#include <stdio.h>
#include <signal.h>
#include <string.h>

#define BOOL  char
#define FALSE ((BOOL)0)
#define TRUE  ((BOOL)1)
#define STRING_EQUAL(a,b)  (strcmp((a),(b)) == 0)

static BOOL bad = FALSE;

static void handler();
static void getvalue();
static int  hexin();

main(argc,argv)
int argc;
char **argv;
{
 char *ep;
 char expression [100];
 char operand1   [100];
 char operand2   [100];
 char operation  [100];
 int  value1, value2;
 char operator;
 int  result;

signal(SIGFPE,handler);
while(TRUE) {
 bad = FALSE;
 printf("Enter hex expression: xxx + yyy or xxx - yyy\n");
 if (gets(expression) == NULL) {
  printf("End of program signalled by EOF\n");
  break;
 }
 if (STRING_EQUAL(expression,"")) {
  printf("End of program signalled by null expression\n");
  break;
 }

 ep = expression;

 getvalue(&ep," +-*/",operand1); /* scan for operand */

 value1 = hexin(operand1);   /* convert it to hex */

 getvalue(&ep," 0123456789abcdefABCDEF",operation); /* scan for op */

 if (strlen(operation) != 1) {
  printf("Invalid expression\n");
  bad = TRUE;
 }
 else {
  getvalue(&ep," +-*/",operand2); /* scan for operand */
  value2 = hexin(operand2);   /* convert it to hex */
  operator = operation[0];
  if (!bad) {
   switch (operator) {
    case '+': result = value1 + value2; break;
    case '-': result = value1 - value2; break;
    case '*': result = value1 * value2; break;
    case '/': result = value1 / value2; break;
    default:
              printf("Invalid operator\n");
              bad = TRUE;
              break;
   }; /* end switch */
  }; /* end if (!bad) */
 }; /* end else */

 if (!bad) {
  printf("%X %c %X = %X\n",value1,operator,value2,result);
 }

 }; /* end while(TRUE) */

 return;

}; /* end main() */


 /********************************************************************/

#pragma page()

 void getvalue(ep,delims,newexpr)

 /* This subroutine extracts the next character value from the
    input expression and removes it from the expression.    */

  char **ep;
  char *delims;
  char *newexpr;

 {
  register int i;

  *ep += strspn(*ep," "); /* bump past leading blanks */

  if (**ep == '\0') {
   if (!bad) printf("Incomplete expression\n");
   bad = TRUE;
   strcpy(newexpr,"");  /* return null string if no nonblanks */
   return;
  }

  memcpy(newexpr,*ep,i=strcspn(*ep,delims));
  newexpr[i] = '\0';

  *ep += i;

 return;

 }; /* end getvalue */


 /********************************************************************/

#pragma page()

 int hexin(expr)

 /* This subroutine takes a character string consisting of hex
    character representations and returns a binary fullword
    containing the hexadecimal data. */

  char *expr;
{
 int thing;
 int l;

 l = strlen(expr);
 if (l==0) {
  printf("Missing value\n");
  bad = TRUE;
  return(0);
 }
 if (l>8) {
  printf("Hex value too long\n");
  bad = TRUE;
  return(0);
 }

 if (strspn(expr," 0123456789abcdefABCDEF")<l) {
  printf("Invalid hex characters entered\n");
  bad = TRUE;
  return(0);
 }

 sscanf(expr,"%x",&thing);

 return(thing);

}; /* end hexin */

 /********************************************************************/

#pragma page()


void handler()
{

 perror("Overflow or division by zero (can't tell which)");
 bad = TRUE;

};
./ ADD NAME=FLDATA   0100-07332-07332-0900-00184-00184-00000-SEB
#pragma runopts(trap(off))
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/*-------------------------------------------------------------------*/

static int option_a = 0;
static int option_b = 0;

/*-------------------------------------------------------------------*/

static void
option_error(n,o)
 char *n;
 char  o;
{
 fprintf(stderr,"%s: invalid option %c\n",n,o);
 abort();
}

/*-------------------------------------------------------------------*/

static void
do_fldata(filetag,fp)
 char *filetag;
 FILE *fp;
{
 int       flret;
 char      filename[256];
 fldata_t *F;
 fldata_t  fstruct;

 F = &fstruct;

 memset(F, 0, sizeof fstruct);

 flret = fldata(fp, filename, F);
 printf("%s: fldata rc=%d,filename=%s\n", filetag, flret, filename);

 printf("\n");
 printf("__recfmF ........... %d\n", F->__recfmF   );
 printf("__recfmV ........... %d\n", F->__recfmV   );
 printf("__recfmU ........... %d\n", F->__recfmU   );
 printf("__recfmS ........... %d\n", F->__recfmS   );
 printf("__recfmBlk ......... %d\n", F->__recfmBlk );
 printf("__recfmASA ......... %d\n", F->__recfmASA );
 printf("__recfmM ........... %d\n", F->__recfmM       );
 printf("__dsorgPO .......... %d\n", F->__dsorgPO      );
 printf("__dsorgPDSmem ...... %d\n", F->__dsorgPDSmem  );
 printf("__dsorgPDSdir ...... %d\n", F->__dsorgPDSdir  );
 printf("__dsorgPS .......... %d\n", F->__dsorgPS      );
 printf("__dsorgConcat ...... %d\n", F->__dsorgConcat  );
 printf("__dsorgMem ......... %d\n", F->__dsorgMem     );
 printf("__dsorgHiper ....... %d\n", F->__dsorgHiper   );
 printf("__dsorgTemp ........ %d\n", F->__dsorgTemp    );
 printf("__dsorgVSAM ........ %d\n", F->__dsorgVSAM    );
 printf("__dsorgHFS ......... %d\n", F->__dsorgHFS     );
 printf("__openmode ......... ");
 switch (F->__openmode) {
   case __TEXT:    printf("__TEXT");                         break;
   case __BINARY:  printf("__BINARY");                       break;
   case __RECORD:  printf("__RECORD");                       break;
   default:        printf("%d",F->__openmode);
 }
 printf("\n");
 printf("__modeflag ......... ");
 switch (F->__modeflag) {
   case __READ:    printf("__READ");                         break;
   case __WRITE:   printf("__WRITE");                        break;
   case __APPEND:  printf("__APPEND");                       break;
   case __UPDATE:  printf("__UPDATE");                       break;
   default:        printf("%d",F->__modeflag);
 }
 printf("\n");
 printf("__reserve2 ......... %d\n", F->__reserve2     );
 printf("__device ........... ");
 switch (F->__device) {
   case __DISK:       printf("__DISK");                      break;
   case __TERMINAL:   printf("__TERMINAL");                  break;
   case __PRINTER:    printf("__PRINTER");                   break;
   case __TAPE:       printf("__TAPE");                      break;
   case __TDQ:        printf("__TDQ");                       break;
   case __DUMMY:      printf("__DUMMY");                     break;
   case __MSGFILE:    printf("__MSGFILE");                   break;
   case __MEMORY:     printf("__MEMORY");                    break;
   case __HFS:        printf("__HFS");                       break;
   case __HIPERSPACE: printf("__HIPERSPACE");                break;
   case __OTHER:      printf("__OTHER");                     break;
   default:           printf("%d",F->__device);
 }
 printf("\n");
 printf("__blksize .......... %l\n", F->__blksize      );
 printf("__maxreclen ........ %l\n", F->__maxreclen    );
 printf("__vsamtype ......... ");
 switch (F->__vsamtype) {
   case __NOTVSAM:    printf("__NOTVSAM");                   break;
   case __ESDS:       printf("__ESDS");                      break;
   case __KSDS:       printf("__KSDS");                      break;
   case __RRDS:       printf("__RRDS");                      break;
   case __ESDS_PATH:  printf("__ESDS_PATH");                 break;
   case __KSDS_PATH:  printf("__KSDS_PATH");                 break;
   default:           printf("%d",F->__vsamtype);
 }
 printf("\n");
 printf("__vsamkeylen ....... %l\n", F->__vsamkeylen   );
 printf("__vsamRKP .......... %l\n", F->__vsamRKP      );
 if (F->__dsname)
   printf("__dsname ........... %s\n", F->__dsname       );
 else
   printf("__dsname is null\n");
 printf("__reserve4 ......... %d\n", F->__reserve4     );
 printf("\n");

 return;

}

/*-------------------------------------------------------------------*/

static void
doit(filenamep)
 char *filenamep;
{
 char *filetag;
 FILE *fp;

 if (!filenamep) {
   fp = stdin;
   filetag = "standard input";
 }
 else {
   fp = fopen(filenamep,option_b ? "rb" : "r");
   filetag = filenamep;
 }
 if (!fp) {
   perror(filetag);
 }
 else {
   do_fldata(filetag,fp);
   printf("\nFLDATA output complete for %s\n",filetag);
   if (filenamep) {
     if (fclose(fp) != 0) {
       perror(filetag);
       fprintf(stderr,"Error closing %s\n",filetag);
     }
     else {
       printf("Closed %s\n", filetag);
     }
   }
 }
 return;

}

/*-------------------------------------------------------------------*/

main(argc,argv)
 int argc;
 char **argv;
{
 int i;
 int arg_index;
 char *x;

 arg_index = 0;
 while ((arg_index++)<argc && *(x = argv[arg_index]+0) == '-') {
  for (x++;*x;x++) {
    switch (*x) {
       case 'a': option_a = 1; break;
       case 'b': option_b = 1; break;
       default : option_error(argv[0],*x);
    };
  };
 }
 if (arg_index >= argc) doit(NULL);
 else {
   for (i=arg_index; i<argc; i++) {
     doit(argv[i]);
   }
 }
 return 0;
}

./ ADD NAME=FLENGTH  0100-07332-07332-0900-00035-00035-00000-SEB
#include <stdio.h>

int
main(argc,argv)
int     argc;
char  **argv;
{
 char  *filename;
 FILE  *fp;
 long   position;
 long   len;

 if (argc != 2) {
   fprintf(stderr,"Usage: flength filename\n");
   return 12;
 }
 filename = argv[1];
 if (!(fp = fopen(filename,"r"))) {
   perror(filename);
   return 12;
 }

 position = ftell(fp);

 fseek(fp, 0, SEEK_END);

 len = ftell(fp);

 printf("File length of %s: %d\n", filename, len);

 fclose(fp);

 return 0;

}
./ ADD NAME=FTPCLI   0100-07332-07332-0900-00670-00670-00000-SEB
/* PORT 21 (FTP) client - similar to "TELNET hostname 21" */

/* usage: ftpcli remotehost user password getfile putfile */

#ifdef MVS
#include <manifest.h>
#include <tcperrno.h>
#include <ctest.h>
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define  Bool                 int

#ifndef  TRUE
#define  TRUE                 ((Bool)1)
#endif
#ifndef  FALSE
#define  FALSE                ((Bool)0)
#endif

#define  CARRIAGE_RETURN      ('\r')
#define  READ_BYTES           512
#define  MYBUF_INITIAL_SIZE   512
#define  MYBUF_INCREMENT      256
#define  IBUF_MSGSIZE         512
#define  OBUF_MSGSIZE         512
#define  SOCKET_GETCHAR_ERROR (-1)
#define  SOCKET_NO_MORE       (-2)
#define  IPPORT_FTPD          20                /* FTP data port */
#define  IPPORT_FTP           21                /* FTP control port */

#ifdef MVS

#define  LINE_FEED            (0x25)
#define  TCPERROR             tcperror
#define  etoa(x)              ebcdictoascii[x]
#define  atoe(x)              asciitoebcdic[x]
#define  ebcdictoascii        ebcdicto
#define  asciitoebcdic        asciitoe
extern   char                 ebcdictoascii[];
extern   char                 asciitoebcdic[];

#else

#define  LINE_FEED            (0x0a)
#define  TCPERROR             perror
#define  etoa(x)              (x)
#define  atoe(x)              (x)

#endif

typedef unsigned int IPADDRESS;
typedef          int SOCKETNO;

enum server_retval {
                    SERVER_OK,
                    SERVER_READ_ERROR,
                    SERVER_BUFFER_ERROR,
                    SERVER_NO_MORE
                   };

struct Ftp         {
 char              *text;
 char              *mybufp;
 int                msgid;
 int                mybufl;
 int                nbytes;
 int                ibuflen;
 int                bytes_returned;
 int                g_buf_index;
 IPADDRESS          hostaddress;
 struct hostent    *server_hostent;
 struct hostent    *client_hostent;
 struct sockaddr_in bindsock;
 struct sockaddr_in consock;
 SOCKETNO           controlns;
 SOCKETNO           datans;
 int                backlog;
 int                readrc;
 int                writrc;
 Bool               time_to_go_home;
 Bool               server_has_something_pending;
 Bool               server_finished_replying;
 Bool               sending_text;
 Bool               dont_read;
 char               client_hostname [257];
 char               server_hostname [257];
 char               ibuf [IBUF_MSGSIZE];
 char               obuf [OBUF_MSGSIZE];
 char               g_buf [READ_BYTES];
};

/* ---- Dump some data. ------------------------------------------- */

static void
dump_it(p,r)
char *p;
int   r;
{
 int i;

 for (i=0;i<77;i++) fprintf(stderr,"-"); fprintf(stderr,"\n");
 for (i=0;i<r;i++) {
   char c = *(p+i);
   if (isprint(c))  fprintf(stderr,"%c",c);
   else             fprintf(stderr,"<0x%2.2x>",c);
 }
 fprintf(stderr,"\n");
 for (i=0;i<77;i++) fprintf(stderr,"-"); fprintf(stderr,"\n");
}

/* --- show stuff returned by FTP server --------------------------- */

static void
show(c)
char *c;
{

#ifdef MVS
     /* Last character of output buffer is a CR. No \n needed. */
     fprintf(stderr,"%s",c);
#else
     /* Last character of output buffer is a CR w/o LF.  LF needed. */
     fprintf(stderr,"%s\n",c);
#endif

 return;
}

/* ---- Get a character from the server. -------------------------- */

static int
socket_getchar(F,ns)
struct Ftp *F;
SOCKETNO    ns;
{
 int        readrc;

 if (F->g_buf_index == -1
  || F->g_buf_index >= F->bytes_returned - 1) {
   F->g_buf_index = -1;
   if (F->dont_read) return SOCKET_NO_MORE;
   readrc = read(ns, F->g_buf, READ_BYTES);
   if (readrc == -1) return SOCKET_GETCHAR_ERROR;
   if (readrc == 0)  return SOCKET_NO_MORE;
   F->bytes_returned = readrc;
#ifdef MVS
   {int i;
    for (i=0;i<F->bytes_returned;i++) F->g_buf[i]=atoe(F->g_buf[i]);
   }
#endif
   /* dump_it(F->g_buf,readrc); */
 }
 return F->g_buf[++F->g_buf_index];
}

/* ---- Get a line of data from the server. ----------------------- */

static enum server_retval
socket_read(F,ns)
struct Ftp  *F;
SOCKETNO     ns;
{
 char       *i_buf;
 int         n_bytes;
 char        delimiter;
 Bool        dont_read;
 int         i_buf_index;
 int         i;
 int         character;

 i_buf     = F->obuf;
 n_bytes   = OBUF_MSGSIZE;
 delimiter = LINE_FEED;
 dont_read = F->dont_read;

 /* Get characters from the server until delimiter is reached. */

 i_buf_index = 0;
 while ((character = socket_getchar(F,ns)) != delimiter) {
   if (character == SOCKET_GETCHAR_ERROR)  return SERVER_READ_ERROR;
   if (character == SOCKET_NO_MORE)        return SERVER_NO_MORE;
   if (i_buf_index >= n_bytes) {
     fprintf(stderr,
             "Warning: The buffer passed to socket_in overflowed.\n");
     fprintf(stderr,
             " More than %d bytes collected without %2.2x seen.\n",
             n_bytes,delimiter);
     fprintf(stderr,
             " Returning what we have so far.\n");
     break;
   }
   i_buf[i_buf_index++] = (unsigned char)character;
 }
 i_buf[i_buf_index] = '\0';
 return SERVER_OK;
}

/* ---- Get a chunk of data from the server. ---------------------- */

static Bool
socket_in(F,ns)
struct Ftp  *F;
SOCKETNO     ns;
{

 switch (socket_read(F,ns)) {
   case SERVER_OK:
                  return TRUE;
   case SERVER_READ_ERROR:
                  fprintf(stderr,"Read error, lost connection\n");
                  F->time_to_go_home = TRUE;
                  return FALSE;
   case SERVER_BUFFER_ERROR:
                  fprintf(stderr,"Server buffer error\n\n");
                  F->time_to_go_home = TRUE;
                  return FALSE;
   case SERVER_NO_MORE:
                  F->server_has_something_pending = FALSE;
                  return TRUE;
 }
 return TRUE;
}

/* ---- Send a line of data to the server. ------------------------ */

static Bool
socket_out(F, ns, o_buf, n_bytes)
struct Ftp      *F;
SOCKETNO         ns;
char            *o_buf;
int              n_bytes;
{
 int             writrc;
 int             needed_bytes   = n_bytes + 2;

 if (F->mybufp == NULL) {
   F->mybufl = MYBUF_INITIAL_SIZE;
   F->mybufp = (char *)malloc(F->mybufl);
   fprintf(stderr,
           "Allocated %d bytes for output buffer\n",F->mybufl);
 }

 if (F->mybufl < needed_bytes) {
   F->mybufl = needed_bytes + MYBUF_INCREMENT;
   free(F->mybufp);
   F->mybufp = (char *)malloc(F->mybufl);
   fprintf(stderr,
           "Allocated %d bytes for output buffer\n",F->mybufl);
 }

 if (F->mybufp == NULL) {
   fprintf(stderr,"\nOops, failed to allocate output buffer!\n");
   return FALSE;
 }

 memcpy(F->mybufp,o_buf,n_bytes);

 F->mybufp[n_bytes  ] = CARRIAGE_RETURN;
 F->mybufp[n_bytes+1] = LINE_FEED;

#ifdef MVS
 {int i;
  for (i=0;i<=n_bytes+1;++i) F->mybufp[i] = etoa(F->mybufp[i]);
 }
#endif

 writrc = write(ns, F->mybufp, n_bytes+2);
 if (writrc < 0) {
   TCPERROR("write");
   return FALSE;
 }

 return TRUE;
}

/* ---- Format an Internet address. -------------------------------- */

static void
ip_address(n,c)
IPADDRESS n;
char     *c;
{
 char *cp = (char *)&n;

 sprintf(c,"%d.%d.%d.%d", (unsigned char)*cp,
                          (unsigned char)*(cp+1),
                          (unsigned char)*(cp+2),
                          (unsigned char)*(cp+3));
 return;
}

/* ---- Format an FTP port address. -------------------------------- */

static void
port_address(addrnum,portnum,c)
IPADDRESS addrnum;
int       portnum;
char     *c;
{
 char *ap = (char *)&addrnum;
 char *pp = (char *)&portnum;

 fprintf(stderr,"port_address: addrnum=%8.8X, portnum=%8.8x\n",
        addrnum,portnum);

 sprintf(c,"%d,%d,%d,%d,%d,%d", (unsigned char)*(ap+0),
                                (unsigned char)*(ap+1),
                                (unsigned char)*(ap+2),
                                (unsigned char)*(ap+3),
                                (unsigned char)*(pp+2),
                                (unsigned char)*(pp+3));

 return;
}

/* ---- Close socket. ---------------------------------------------- */

static Bool
ftp_close(F,ns)
struct Ftp   *F;
SOCKETNO      ns;
{

 fprintf(stderr,"Closing socket %d\n",ns);

 if (close(ns) < 0) {
   TCPERROR("close");
   return FALSE;
 }

 return TRUE;

}

/* ---- Connect to the FTP server host. ---------------------------- */

static SOCKETNO
ftp_connect(F,ftphost)
struct Ftp *F;
char       *ftphost;
{
 SOCKETNO           ftpsock;
 int                bindrc;
 int                listrc;
 int                connrc;
 char               ipstring[65];

 ftpsock = -1;
 gethostname(F->client_hostname,sizeof(F->client_hostname));
 F->client_hostent = gethostbyname(F->client_hostname);
 if (!F->client_hostent) {
   TCPERROR("gethostbyname for client hostname");
   return -1;
 }
 F->hostaddress = *(IPADDRESS *)F->client_hostent->h_addr_list[0];

 ip_address(F->hostaddress,ipstring);
 fprintf(stderr,"client %s [%s]\n",F->client_hostname,ipstring);

 ftpsock = socket(AF_INET, SOCK_STREAM, 0);
 if (ftpsock < 0) {
   TCPERROR("socket");
   return -1;
 }

 F->bindsock.sin_family      = AF_INET;
 F->bindsock.sin_port        = 0;
 F->bindsock.sin_addr.s_addr = F->hostaddress;

 bindrc = bind(ftpsock,&F->bindsock,sizeof(F->bindsock));
 if (bindrc < 0) {
   TCPERROR("bind for client");
   return -1;
 }

 F->server_hostent = gethostbyname(ftphost);
 if (!F->server_hostent) {
   fprintf(stderr,"gethostbyname: unknown host %s\n",ftphost);
   return -1;
 }
 F->hostaddress = *(IPADDRESS *)F->server_hostent->h_addr;

 ip_address(F->hostaddress,ipstring);
 fprintf(stderr,"server %s [%s]\n",ftphost,ipstring);

 F->consock.sin_family      = AF_INET;
 F->consock.sin_port        = htons(IPPORT_FTP);
 F->consock.sin_addr.s_addr = F->hostaddress;

 connrc = connect(ftpsock,&F->consock,sizeof(F->consock));
 if (connrc < 0) {
   TCPERROR(ftphost);
   return -1;
 }

 return ftpsock;
}

/* --- Get a response from the FTP server. ------------------ */

static Bool
frecv(F,ns)
struct Ftp    *F;
SOCKETNO       ns;
{
 int           n;

 F->server_has_something_pending = TRUE;
 F->server_finished_replying     = FALSE;
 F->sending_text                 = FALSE;
 F->dont_read                    = FALSE;
 F->text                         = NULL;
 F->msgid                        = -1;

 while (F->server_has_something_pending) {

   if (F->server_finished_replying) F->dont_read = TRUE;
   if (!socket_in(F, ns)) break;
   if (F->time_to_go_home) break;
   if (F->dont_read && !F->server_has_something_pending) break;
   show(F->obuf);
   F->msgid = -1;
   F->text  = NULL;
   n        = 0;
   sscanf(F->obuf,"%d %n", &F->msgid, &n);
   F->text = F->obuf + n;

   switch (F->msgid) {
     case 221: /* Goodbye */
               F->server_finished_replying = TRUE;
               F->server_has_something_pending = FALSE;
            /* F->time_to_go_home          = TRUE; */
               break;
     default:
               F->server_finished_replying = TRUE;
               F->server_has_something_pending = FALSE;
               break;
   }

 } /* end while F->server_has_something_pending */

 if (F->time_to_go_home) {
   fprintf(stderr,"Time to go home\n");
   return FALSE;
 }

 return TRUE;

}

/* --- Send a request to the FTP server. ----------------------- */

static Bool
fsend(F,ns,text,arg)
struct Ftp    *F;
SOCKETNO      ns;
char          *text;
char          *arg;
{

 /* first check if there is anything pending from the server */

 while (F->server_has_something_pending) {
   if (F->server_finished_replying) F->dont_read = TRUE;
   if (!socket_in(F, ns)) break;
   if (F->time_to_go_home) break;
   if (F->dont_read && !F->server_has_something_pending) break;
   show(F->obuf);
 }

 if (F->time_to_go_home) return FALSE;

 /* now send */

 sprintf(F->ibuf,text,arg);

 show(F->ibuf);

 return socket_out(F,ns,F->ibuf,strlen(F->ibuf));
}

/* --- Main routine. ------------------------------------------- */

main(argc,argv)
int                   argc;
char                **argv;
{
 char                *cp;
 char                *ftphost;
 char                *ftpuser;
 char                *ftppass;
 char                *ftpgetf;
 char                *ftpputf;
 char                *ftptext;
 int                  ftpmsgid;
 int                  n;
 int                  socksize;
 int                  accept_count;
 int                  bytes_to_write;
 int                  fwriterc;
 int                  bytes_written;
 FILE                *ofp;
 struct Ftp          *F;
 struct Ftp           ftp;
 struct sockaddr_in   datasocket;
 struct sockaddr_in   controlsocket;
 char                 port[81];

#define  FSEND(A,B)     if (!fsend(F,F->controlns,(A),(B))) {exit(1);}
#define  FRECV()        if (!frecv(F,F->controlns))         {exit(1);}
#define  FEXPECT(A)     switch (F->msgid) {\
                          case (A): break;\
                          default:  FLOSE();\
                        }
#define  FLOSE()        fprintf(stderr,"Unexpected response: %d\n",\
                                       F->msgid);\
                        fprintf(stderr,"Full response follows:\n");\
                        fprintf(stderr,"%s\n",F->obuf);\
                        exit(1);

 if (argc != 6) {
   fprintf(stderr,
           "Usage: %s remotehost user password getfile putfile\n",
           argv[0]);
   exit(1);
 }

 ftphost = argv[1];
 ftpuser = argv[2];
 ftppass = argv[3];
 ftpgetf = argv[4];
 ftpputf = argv[5];

 ofp = fopen(ftpputf,"r");
 if (ofp) {
   fprintf(stderr,"%s: File exists.\n",ftpputf);
   fprintf(stderr,"File transfer not done.\n");
   exit(1);
 }
 (void)fclose(ofp);

 ofp = fopen(ftpputf,"w");
 if (!ofp) {
   perror(ftpputf);
   fprintf(stderr,"File transfer not done.\n");
   exit(1);
 }

 F = &ftp;
 memset(F,0,sizeof(struct Ftp));
 F->g_buf_index = -1;

 F->controlns = ftp_connect(F,ftphost);
 if (F->controlns < 0) exit(1);

 fprintf(stderr,"Connected to %s (socket %d).\n",
                ftphost, F->controlns);

 FRECV();
 FEXPECT(220);  /* server ready */

 FSEND("USER %s",ftpuser);
 FRECV();
 FEXPECT(331);  /* password required */

 FSEND("PASS %s",ftppass);
 FRECV();
 FEXPECT(230);  /* user logged in */

 /* not done yet */

 /* for ftpgetf, must issue RETR command but open data connection first */

 F->datans = socket(AF_INET, SOCK_STREAM, 0);
 if (F->datans < 0) {
   TCPERROR("data socket");
   exit(1);
 }

 listen(F->datans,0);   /* accept only one connection */

 /* get port number of data connection */

 socksize = sizeof(struct sockaddr);
 getsockname(F->datans,(char *)&datasocket,&socksize);
 socksize = sizeof(struct sockaddr);
 getsockname(F->controlns,(char *)&controlsocket,&socksize);
 datasocket.sin_addr.s_addr = controlsocket.sin_addr.s_addr;

 port_address(datasocket.sin_addr.s_addr,datasocket.sin_port,port);

 FSEND("PORT %s", port);
 FRECV();
 FEXPECT(200);  /* command successful */

 FSEND("TYPE %s","A");          /* ascii type */
 FRECV();
 FEXPECT(200);  /* type set to ... */

 FSEND("RETR %s", ftpgetf);
 FRECV();
 FEXPECT(150);  /* data connection for... */

 accept_count = 0;
 F->datans = accept(F->datans,NULL,&accept_count);
 if (F->datans < 0) {
   TCPERROR("accept");
   exit(1);
 }

 /* get data from data connection */

 F->time_to_go_home = FALSE;
 F->server_has_something_pending = TRUE;

 bytes_to_write = 0;
 bytes_written = 0;
 fprintf(stderr,"Writing to %s\n",ftpputf);
 for (;;) {
   if (!socket_in(F, F->datans)) exit(1);
   if (F->time_to_go_home) break;
   if (!F->server_has_something_pending) break;
   /* show(F->obuf); */
   bytes_to_write = strlen(F->obuf)-1;
   fwriterc = fwrite(F->obuf,1,bytes_to_write,ofp);
   bytes_written += fwriterc;
   if (fwriterc < bytes_to_write) {
     fprintf(stderr,"Error writing to %s\n",ftpputf);
     break;
   }
   bytes_to_write = 1;
   fwriterc = fwrite("\n",1,bytes_to_write,ofp);
   bytes_written += fwriterc;
   if (fwriterc < bytes_to_write) {
     fprintf(stderr,"Error writing to %s\n",ftpputf);
     break;
   }
 }

 if (fclose(ofp) < 0) {
   fprintf(stderr,"Error closing %s\n",ftpputf);
 }
 else fprintf(stderr,"%d bytes written to %s\n",
                     bytes_written,ftpputf);

 FRECV();
 FEXPECT(226);  /* transfer complete */

 (void)ftp_close(F,F->datans);

 FSEND("QUIT",NULL);
 FRECV();
 FEXPECT(221);  /* goodbye */

 (void)ftp_close(F,F->controlns);

 exit(0);

}

./ ADD NAME=GFTP     0100-07332-07332-0900-00786-00786-00000-SEB
/* usage: gftp remotehost user password getfile putfile */

#define _TCP31_PROTOS
#define MVS

#ifdef MVS
#include <manifest.h>
#include <tcperrno.h>
#include <ctest.h>
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define  Bool                 int

#ifndef  TRUE
#define  TRUE                 ((Bool)1)
#endif
#ifndef  FALSE
#define  FALSE                ((Bool)0)
#endif

#define  CARRIAGE_RETURN      ('\r')
#define  READ_BYTES           512
#define  MYBUF_INITIAL_SIZE   512
#define  MYBUF_INCREMENT      256
#define  IBUF_MSGSIZE         512
#define  OBUF_MSGSIZE         512
#define  SOCKET_GETCHAR_ERROR (-1)
#define  SOCKET_NO_MORE       (-2)
#define  IPPORT_FTPD          20                /* FTP data port */
#define  IPPORT_FTP           21                /* FTP control port */

#define  SHOW(A)        fprintf(stderr,"%s\n",(A))
#define  BLATHER        if (F->verboseflag) fprintf
#define  FLOSE          fexit(F,1)
#define  FWIN           fexit(F,0)
#define  FSEND(A,B)     if (!fsend(F,CS,(A),(B))) {FLOSE;}
#define  FRECV()        if (!frecv(F,CS,TRUE))    {FLOSE;}
#define  FEXPECT(A)     if (!fexpect(F,A))        {FLOSE;}

#ifdef MVS

#define  LINE_FEED            (0x25)
#define  TCPERROR             tcperror
#define  DELETE_FILE          remove
#define  etoa(x)              ebcdictoascii[x]
#define  atoe(x)              asciitoebcdic[x]
#define  ebcdictoascii        ebcdicto
#define  asciitoebcdic        asciitoe
extern   char                 ebcdictoascii[];
extern   char                 asciitoebcdic[];

#else

#define  LINE_FEED            (0x0a)
#define  TCPERROR             perror
#define  DELETE_FILE          unlink
#define  etoa(x)              (x)
#define  atoe(x)              (x)

#endif

typedef unsigned int IPADDRESS;
typedef          int SOCKETNO;

enum server_retval {
                    SERVER_OK,
                    SERVER_READ_ERROR,
                    SERVER_BUFFER_ERROR,
                    SERVER_NO_MORE
                   };

struct connection  {
 char              *mybufp;
 int                mybufl;
 int                nbytes;
 int                ibuflen;
 int                bytes_returned;
 int                g_buf_index;
 SOCKETNO           ns;
 Bool               time_to_go_home;
 Bool               server_has_nothing;
 Bool               dont_read;
 char               ibuf [IBUF_MSGSIZE];
 char               obuf [OBUF_MSGSIZE];
 char               g_buf [READ_BYTES];
                   };

struct Ftp         {
 struct connection  control_connection;
 struct connection  data_connection;
 IPADDRESS          hostaddress;
 struct hostent    *server_hostent;
 struct hostent    *client_hostent;
 struct sockaddr_in bindsock;
 struct sockaddr_in consock;
 int                backlog;
 SOCKETNO           listensocket;
 Bool               verboseflag;
 Bool               replaceflag;
 Bool               listflag;
 Bool               nlstflag;
 Bool               cmsflag;
 Bool               file_existed;
 Bool               file_created;
 Bool               file_opened;
 Bool               control_socket_opened;
 Bool               listen_socket_opened;
 Bool               accept_socket_opened;
 FILE              *ofp;
 char               client_hostname [257];
 char               server_hostname [257];
 char               putfile [257];
};

/* --- display usage message and exit ------------------------------ */

static void
usage(progname)
char *progname;
{

  fprintf(stderr,
    "Usage: %s [-vrlcn] remotehost user password getfile [putfile]\n",
          progname);
  fprintf(stderr, "   -v  - verbose mode\n");
  fprintf(stderr, "   -r  - replace existing file\n");
  fprintf(stderr, "   -l  - send LIST request instead of RETR\n");
  fprintf(stderr, "   -n  - send NLST request instead of RETR\n");
  fprintf(stderr, "   -c  - CMS server compatibility mode\n");
  exit(1);
}


/* ---- Get a character from the server. -------------------------- */

static int
socket_getchar(F,S)
struct Ftp        *F;
struct connection *S;
{
 int        readrc;

 if (S->g_buf_index == -1
  || S->g_buf_index >= S->bytes_returned - 1) {
   S->g_buf_index = -1;
   if (S->dont_read) return SOCKET_NO_MORE;
   readrc = read(S->ns, S->g_buf, READ_BYTES);
   if (readrc == -1) return SOCKET_GETCHAR_ERROR;
   if (readrc == 0)  return SOCKET_NO_MORE;
   S->bytes_returned = readrc;
#ifdef MVS
   {int i;
    for (i=0;i<S->bytes_returned;i++) S->g_buf[i]=atoe(S->g_buf[i]);
   }
#endif
 }
 return S->g_buf[++S->g_buf_index];
}

/* ---- Get a line of data from the server. ----------------------- */

static enum server_retval
socket_read(F,S)
struct Ftp        *F;
struct connection *S;
{
 char       *i_buf;
 int         n_bytes;
 char        delimiter;
 int         i_buf_index;
 int         i;
 int         character;

 i_buf     = S->obuf;
 n_bytes   = OBUF_MSGSIZE;
 delimiter = LINE_FEED;

 /* Get characters from the server until delimiter is reached. */

 i_buf_index = 0;
 while ((character = socket_getchar(F,S)) != delimiter) {
   if (character == SOCKET_GETCHAR_ERROR)  return SERVER_READ_ERROR;
   if (character == SOCKET_NO_MORE)        return SERVER_NO_MORE;
   if (i_buf_index >= n_bytes) {
     fprintf(stderr,
             "Warning: The buffer passed to socket_in overflowed.\n");
     BLATHER(stderr,
             " More than %d bytes collected without %2.2x seen.\n",
             n_bytes,delimiter);
     BLATHER(stderr,
             " Returning what we have so far.\n");
     break;
   }
   i_buf[i_buf_index++] = (unsigned char)character;
 }
 i_buf[i_buf_index] = '\0';
 return SERVER_OK;
}

/* ---- Get a chunk of data from the server. ---------------------- */

static Bool
socket_in(F,S)
struct Ftp        *F;
struct connection *S;
{

 S->time_to_go_home = FALSE;
 S->server_has_nothing = FALSE;

 switch (socket_read(F,S)) {
   case SERVER_OK:
                  return TRUE;
   case SERVER_READ_ERROR:
                  fprintf(stderr,"Read error, lost connection\n");
                  S->time_to_go_home = TRUE;
                  return FALSE;
   case SERVER_BUFFER_ERROR:
                  fprintf(stderr,"Server buffer error\n\n");
                  S->time_to_go_home = TRUE;
                  return FALSE;
   case SERVER_NO_MORE:
                  BLATHER(stderr,"Server returned no more data\n");
                  S->server_has_nothing = TRUE;
                  return TRUE;
 }
 return TRUE;
}

/* ---- Send a line of data to the server. ------------------------ */

static Bool
socket_out(F,S,o_buf,n_bytes)
struct Ftp        *F;
struct connection *S;
char              *o_buf;
int                n_bytes;
{
 int               writrc;
 int               needed_bytes = n_bytes + 2;

 if (S->mybufp == NULL) {
   S->mybufl = MYBUF_INITIAL_SIZE;
   S->mybufp = (char *)malloc(S->mybufl);
   BLATHER(stderr,
           "Allocated %d bytes for output buffer\n",S->mybufl);
 }

 if (S->mybufl < needed_bytes) {
   S->mybufl = needed_bytes + MYBUF_INCREMENT;
   free(S->mybufp);
   S->mybufp = (char *)malloc(S->mybufl);
   BLATHER(stderr,
           "Allocated %d bytes for output buffer\n",S->mybufl);
 }

 if (S->mybufp == NULL) {
   fprintf(stderr,"\nOops, failed to allocate output buffer!\n");
   return FALSE;
 }

 memcpy(S->mybufp,o_buf,n_bytes);

 S->mybufp[n_bytes  ] = CARRIAGE_RETURN;
 S->mybufp[n_bytes+1] = LINE_FEED;

#ifdef MVS
 {int i;
  for (i=0;i<=n_bytes+1;++i) S->mybufp[i] = etoa(S->mybufp[i]);
 }
#endif

 writrc = write(S->ns, S->mybufp, needed_bytes);
 if (writrc < 0) {
   TCPERROR("write");
   return FALSE;
 }

 return TRUE;
}

/* ---- Format an Internet address. -------------------------------- */

static void
ip_address(n,c)
IPADDRESS n;
char     *c;
{
 char *cp = (char *)&n;

 sprintf(c,"%d.%d.%d.%d", (unsigned char)*cp,
                          (unsigned char)*(cp+1),
                          (unsigned char)*(cp+2),
                          (unsigned char)*(cp+3));
 return;
}

/* ---- Format an FTP port address. -------------------------------- */

static void
port_address(F,addrnum,portnum,c)
struct Ftp *F;   /* needed by BLATHER macro */
IPADDRESS   addrnum;
int         portnum;
char       *c;
{
 char *ap = (char *)&addrnum;
 char *pp = (char *)&portnum;

 BLATHER(stderr,"port_address: addrnum=%8.8X, portnum=%8.8X\n",
                addrnum,portnum);

 sprintf(c,"%d,%d,%d,%d,%d,%d", (unsigned char)*(ap+0),
                                (unsigned char)*(ap+1),
                                (unsigned char)*(ap+2),
                                (unsigned char)*(ap+3),
                                (unsigned char)*(pp+2),
                                (unsigned char)*(pp+3));

 return;
}

/* ---- Close socket. ---------------------------------------------- */

static Bool
ftp_close(F,s)
struct Ftp        *F;
SOCKETNO           s;
{

 BLATHER(stderr,"Closing socket %d\n",s);

 if (close(s) < 0) {
   TCPERROR("close");
   return FALSE;
 }

 return TRUE;

}

/* ---- Connect to the FTP server host. ---------------------------- */

static SOCKETNO
ftp_connect(F,ftphost)
struct Ftp *F;
char       *ftphost;
{
 SOCKETNO           ftpsock;
 int                bindrc;
 int                listrc;
 int                connrc;
 char               ipstring[65];

 ftpsock = -1;
 gethostname(F->client_hostname,sizeof(F->client_hostname));
 F->client_hostent = gethostbyname(F->client_hostname);
 if (!F->client_hostent) {
   TCPERROR("gethostbyname for client hostname");
   return -1;
 }
 F->hostaddress = *(IPADDRESS *)F->client_hostent->h_addr_list[0];

 ip_address(F->hostaddress,ipstring);
 BLATHER(stderr,"client %s [%s]\n",F->client_hostname,ipstring);

 ftpsock = socket(AF_INET, SOCK_STREAM, 0);
 if (ftpsock < 0) {
   TCPERROR("socket");
   return -1;
 }

 F->bindsock.sin_family      = AF_INET;
 F->bindsock.sin_port        = 0;
 F->bindsock.sin_addr.s_addr = F->hostaddress;

 bindrc = bind(ftpsock,&F->bindsock,sizeof(F->bindsock));
 if (bindrc < 0) {
   TCPERROR("bind for client");
   return -1;
 }

 F->server_hostent = gethostbyname(ftphost);
 if (!F->server_hostent) {
   fprintf(stderr,"gethostbyname: unknown host %s\n",ftphost);
   return -1;
 }
 F->hostaddress = *(IPADDRESS *)F->server_hostent->h_addr;
 strcpy(F->server_hostname,ftphost);
 ip_address(F->hostaddress,ipstring);
 BLATHER(stderr,"server %s [%s]\n",F->server_hostname,ipstring);

 F->consock.sin_family      = AF_INET;
 F->consock.sin_port        = htons(IPPORT_FTP);
 F->consock.sin_addr.s_addr = F->hostaddress;

 connrc = connect(ftpsock,&F->consock,sizeof(F->consock));
 if (connrc < 0) {
   TCPERROR(ftphost);
   return -1;
 }

 return ftpsock;
}

/* --- Exit in success or failure. -------------------------- */

static void
fexit(F,rc)
struct Ftp *F;
int         rc;
{
 struct connection      *CS;
 struct connection      *DS;

 CS = &F->control_connection;
 DS = &F->data_connection;

 if (rc != 0) {
   if (F->file_opened) {
     if (fclose(F->ofp) < 0) {
       fprintf(stderr,"Error closing %s\n",F->putfile);
     }
   }
   if (F->file_created
     && !F->file_existed
#ifdef MVS
     && !strchr(F->putfile,':') /* don't remove dd:foo */
#endif
      ) {
     if (DELETE_FILE(F->putfile) < 0) {
       fprintf(stderr,"Error deleting %s\n",F->putfile);
     }
     else {
       BLATHER(stderr,"File %s deleted.\n",F->putfile);
     }
   }
 }

 if (F->listen_socket_opened) {
   (void) ftp_close(F,F->listensocket);
   F->listen_socket_opened = FALSE;
 }

 if (F->accept_socket_opened) {
   (void) ftp_close(F,DS->ns);
   F->accept_socket_opened = FALSE;
 }

 if (F->control_socket_opened) {
   (void) ftp_close(F,CS->ns);
   F->control_socket_opened = FALSE;
 }

 exit(rc);

}

/* --- Get a response from the FTP server. ------------------ */

static Bool
frecv(F,S,doread)
struct Ftp        *F;
struct connection *S;
Bool               doread;
{

 S->dont_read = !doread;
 if (!socket_in(F,S)) return FALSE;
 if (S->time_to_go_home) return FALSE;
 if (S->server_has_nothing) return TRUE;
 if (F->verboseflag) SHOW(S->obuf);
 return TRUE;

}

/* --- Send a request to the FTP server. ----------------------- */

static Bool
fsend(F,S,text,arg)
struct Ftp        *F;
struct connection *S;
char              *text;
char              *arg;
{

 /* first check if there is anything pending from the server */

 (void)frecv(F,S,FALSE);

 /* now send */

 sprintf(S->ibuf,text,arg);

 if (F->verboseflag) {
   if (!memcmp(S->ibuf,"PASS ",5)) {
     SHOW("PASS ********");
   }
   else {
     SHOW(S->ibuf);
   }
 }

 return socket_out(F,S,S->ibuf,strlen(S->ibuf));
}

/* --- Retrieve a response and insure it was the expected one. -- */

static Bool
fexpect(F,mesid)
struct Ftp         *F;
char               *mesid;
{
 struct connection *S = &F->control_connection;

 for (;;) {
   if (!frecv(F,S,TRUE)) FLOSE;
   if (S->obuf[0] == '\0')  continue;
   if (S->obuf[0] == ' ')   continue;
   if (strlen(S->obuf) > 3) {
     if (!memcmp(mesid,S->obuf,3)) {
       if (S->obuf[3] == '-')  continue;
       if (S->obuf[3] == '\0') break;
       if (S->obuf[3] == ' ')  break;
     }
   }
   fprintf(stderr,"Unexpected FTP response from %s (not %s):\n%s\n",
                  F->server_hostname,mesid,S->obuf);
   FLOSE;
 }

 return TRUE;
}
/* --- Main routine. ------------------------------------------- */

main(argc,argv)
int                   argc;
char                **argv;
{
 char                *cp;
 char                *ftphost = NULL;
 char                *ftpuser = NULL;
 char                *ftppass = NULL;
 char                *ftpgetf = NULL;
 char                *ftpputf = NULL;
 char                *ftptext = NULL;
 int                  n;
 int                  i;
 int                  socksize;
 int                  accept_count;
 int                  bytes_to_write;
 int                  fwriterc;
 int                  bytes_written;
 struct connection   *CS;
 struct connection   *DS;
 struct Ftp          *F;
 struct Ftp           ftp;
 struct sockaddr_in   datasocket;
 struct sockaddr_in   controlsocket;
 char                 port[81];

 F = &ftp;
 memset(F,0,sizeof(struct Ftp));
 CS = &F->control_connection;
 DS = &F->data_connection;
 CS->g_buf_index = -1;
 DS->g_buf_index = -1;

 for (i=1;i<argc;i++) {
   if (argv[i][0] != '-') break;
     /* process flags here */
   for (cp=&argv[i][1]; *cp; cp++) {
     switch (tolower(*cp)) {
       case 'v':  F->verboseflag = TRUE;  break;
       case 'r':  F->replaceflag = TRUE;  break;
       case 'l':  F->listflag    = TRUE;  break;
       case 'n':  F->nlstflag    = TRUE;  break;
       case 'c':  F->cmsflag     = TRUE;  break;
       default:   fprintf(stderr,"Unknown flag: %c\n",*cp);
                  usage(argv[0]);
                  break;
     }
   }
 }

 if (F->listflag && F->nlstflag) {
   fprintf(stderr,"-l and -n flags are mutually exclusive\n");
   usage(argv[0]);
 }

 if (i < argc) ftphost = argv[i++]; else usage(argv[0]);
 if (i < argc) ftpuser = argv[i++]; else usage(argv[0]);
 if (i < argc) ftppass = argv[i++]; else usage(argv[0]);
 if (i < argc) ftpgetf = argv[i++]; else ftpgetf = NULL;
 if (i < argc) ftpputf = argv[i++]; else ftpputf = NULL;
 if (i < argc)                           usage(argv[0]);

 if (!ftpgetf && !F->listflag && !F->nlstflag) usage(argv[0]);

 if (ftpputf && !strcmp(ftpputf,"-")) ftpputf = NULL;

 if (ftpputf) strcpy(F->putfile,ftpputf);
 else         strcpy(F->putfile,"standard output");

 if (ftpputf
#ifdef MVS
     && !strchr(ftpputf,':') /* don't check if dd:foo is readable */
#endif
    ) {
   F->ofp = fopen(ftpputf,"r");
   if (F->ofp) {
     F->file_existed = TRUE;
     if (F->replaceflag) {
       BLATHER(stderr,"%s: File is being replaced.\n",ftpputf);
     }
     else {
       fprintf(stderr,"%s: File exists.  Use -r to replace.\n",
                      ftpputf);
       fprintf(stderr,"File transfer not done.\n");
       FLOSE;
     }
   }
   (void)fclose(F->ofp);
 }

 if (ftpputf) {
   F->ofp = fopen(ftpputf,
#ifdef MVS
               "w,recfm=vb,lrecl=259,blksize=6233"
#else
               "w"
#endif
              );
   if (!F->ofp) {
     perror(ftpputf);
     fprintf(stderr,"File transfer not done.\n");
     FLOSE;
   }
   F->file_created = TRUE;
   F->file_opened  = TRUE;
 }
 else {
   F->ofp = stdout;
 }

 CS->ns = ftp_connect(F,ftphost);
 if (CS->ns < 0) FLOSE;
 F->control_socket_opened = TRUE;

 BLATHER(stderr,"Connected to %s (socket %d).\n", ftphost, CS->ns);

 FEXPECT("220");  /* server ready */

 FSEND("USER %s",ftpuser);
 FEXPECT("331");  /* password required */

 FSEND("PASS %s",ftppass);
 FEXPECT("230");  /* user logged in */

 /* for ftpgetf, must issue RETR command but open data connection first */

 F->listensocket = socket(AF_INET, SOCK_STREAM, 0);
 if (F->listensocket < 0) {
   TCPERROR("data socket");
   FLOSE;
 }
 F->listen_socket_opened = TRUE;

 listen(F->listensocket,1); /* accept only one connection */

 /* get port number of data connection */

 socksize = sizeof(struct sockaddr);
 getsockname(F->listensocket,(char *)&datasocket,&socksize);
 socksize = sizeof(struct sockaddr);
 getsockname(CS->ns,(char *)&controlsocket,&socksize);
 datasocket.sin_addr.s_addr = controlsocket.sin_addr.s_addr;

 port_address(F,datasocket.sin_addr.s_addr,datasocket.sin_port,port);

 FSEND("PORT %s", port);
 FEXPECT("200");  /* command successful */

 FSEND("TYPE %s","A");          /* ascii type */
 FEXPECT("200");  /* type set to ... */

 if (F->cmsflag && (F->listflag || F->nlstflag)) {
   FSEND("CWD %s", ftpgetf);
   FEXPECT("250");  /* current working dir set to ... */
   ftpgetf = NULL;
 }

 if (F->listflag) {
   if (!ftpgetf) {FSEND("LIST", NULL);}
   else          {FSEND("LIST %s", ftpgetf);}
 }
 else if (F->nlstflag) {
   if (!ftpgetf) {FSEND("NLST", NULL);}
   else          {FSEND("NLST %s", ftpgetf);}
 }
 else {
   FSEND("RETR %s", ftpgetf);
 }

 if (F->cmsflag && (F->listflag || F->nlstflag)) {
   FEXPECT("125");  /* List started OK */
 }
 else {
   FEXPECT("150");  /* data connection for... */
 }

 accept_count = 0;
 DS->ns = accept(F->listensocket,NULL,&accept_count);
 if (DS->ns < 0) {
   TCPERROR("accept");
   FLOSE;
 }
 F->accept_socket_opened = TRUE;

 /* get data from data connection */

 bytes_to_write = 0;
 bytes_written = 0;
 BLATHER(stderr,"Writing to %s\n",F->putfile);
 for (;;) {
   DS->time_to_go_home = FALSE;
   DS->server_has_nothing = FALSE;
   if (!socket_in(F, DS)) FLOSE;
   if (DS->time_to_go_home) break;
   if (DS->server_has_nothing) break;
   bytes_to_write = strlen(DS->obuf)-1;
   fwriterc = fwrite(DS->obuf,1,bytes_to_write,F->ofp);
   bytes_written += fwriterc;
   if (fwriterc < bytes_to_write) {
     fprintf(stderr,"Error writing to %s\n",F->putfile);
     break;
   }
   bytes_to_write = 1;
   fwriterc = fwrite("\n",1,bytes_to_write,F->ofp);
   bytes_written += fwriterc;
   if (fwriterc < bytes_to_write) {
     fprintf(stderr,"Error writing to %s\n",F->putfile);
     break;
   }
 }

 /* Close the data socket before waiting for the server to return
  * connection acknowledgement.  The VM server enforces this.
  */

 (void) ftp_close(F,DS->ns);
 F->accept_socket_opened = FALSE;

 if (F->cmsflag) {
   FEXPECT("250");  /* ... completed successfully */
 }
 else {
   FEXPECT("226");  /* transfer complete */
 }

 if (ftpputf) {
   if (fclose(F->ofp) < 0) {
     fprintf(stderr,"Error closing %s\n",F->putfile);
   }
   else BLATHER(stderr,"%d bytes written to %s\n",
                       bytes_written,F->putfile);
   F->file_opened = FALSE;
 }

 FSEND("QUIT",NULL);
 FEXPECT("221");  /* goodbye */

 FWIN;

}

./ ADD NAME=GSVCTEST 0100-07332-07332-0900-00043-00043-00000-SEB
#include <stdio.h>
#include <string.h>
#include "gsvc.h"
main()
{
 SVC_REGISTER reg15,reg0,reg1;
 char         data[] = "This is a test of GSVCTEST.";
 struct       {
               short   wtolen;
               short   wtodum;
               char    wtotext[257];
              } wto;

 reg15 = (SVC_REGISTER_CONTENTS) 0;
 reg0  = (SVC_REGISTER_CONTENTS) strlen(data);
 reg1  = (SVC_REGISTER_CONTENTS) data;
 reg1 |= 0x01000000;  /* specify "ASIS" option */

 printf("On entry to SVC 93: R15=%8.8X R0=%8.8X R1=%8.8X\n",
        reg15,reg0,reg1);

 SVC(93,&reg15,&reg0,&reg1);

 printf("Return from SVC 93: R15=%8.8X R0=%8.8X R1=%8.8X\n",
        reg15,reg0,reg1);

 wto.wtolen = strlen(data) + 4;
 wto.wtodum = 0;
 strcpy(wto.wtotext,data);

 reg15 = (SVC_REGISTER_CONTENTS) 0;
 reg0  = (SVC_REGISTER_CONTENTS) 0;
 reg1  = (SVC_REGISTER_CONTENTS) &wto;

 printf("On entry to SVC 35: R15=%8.8X R0=%8.8X R1=%8.8X\n",
        reg15,reg0,reg1);

 SVC(35,&reg15,&reg0,&reg1);

 printf("Return from SVC 35: R15=%8.8X R0=%8.8X R1=%8.8X\n",
        reg15,reg0,reg1);

}
./ ADD NAME=HEXDUMP  0100-07332-07332-0900-00071-00071-00000-SEB
#include <stdio.h>
#include <ctype.h>

int isascii(char c) {return 1;}

main(argc,argv)
 int argc;
 char **argv;
{
 int i;
 void doit();
 if (argc == 1) doit(NULL);
 else for (i=1;i<argc;i++) doit(argv[i]);
 exit(0);
}
void doit(filenamep)
 char *filenamep;
{
 FILE *fp;
 char c;
 int i;
 int off;
 int got_something;
 char *lp;
 char error_string[150];
 char xline[39];
 char cline[16];
 if (filenamep == NULL) fp = stdin;
 else fp = fopen(filenamep,"r");
 if (fp == NULL)
   {
    sprintf(error_string,"%s open failed",filenamep);
    perror(error_string);
    exit(4);
   }
 else {
    if (filenamep) printf("\n%s\n\n",filenamep);
    off = 0;
    do {
         char *xlinep;
         for (i=0;i<36;i++) xline[i] = ' ';
         for (i=0;i<16;i++) cline[i] = ' ';
         xlinep = &xline[0];
         got_something = 0;
         for (i=0;i<16;i++) {
          c=getc(fp);
          /* if (c==EOF) break; */
          if (feof(fp)) break;
          got_something = 1;
          sprintf(xlinep,"%2.2X",(c & 0x000000ff));
          *(xlinep+2) = ' ';
          if (isascii(c) && isprint(c)) cline[i] = c;
          else cline[i] = '.';
          if (c=='\n') break;
          xlinep += ((i%4==3) ? 3 : 2);
         }
         if (got_something) {
            printf("%6.6X  %36.36s  *%16.16s*\n",off,xline,cline);
            if (c=='\n') {
               printf("\n");
               off = 0;
            }
            else off += i;
         }
       } /* while (c != EOF); */
         while (!(feof(fp)));
  }
  if (filenamep) fclose(fp);
  return;
 }

./ ADD NAME=HEXDUMP2 0100-07332-07332-0900-00135-00135-00000-SEB
#include <stdio.h>
#include <ctype.h>

#define BOOL int
#ifndef FALSE
#define FALSE ((BOOL)0)
#endif
#ifndef TRUE
#define TRUE  ((BOOL)1)
#endif

#ifdef MVS
#define isascii(A) TRUE
#endif

static BOOL blockmode;
static BOOL lreclmode;
static int  lrecl;

/* ================================================================== */

static void
doit (char *filenamep)
{
 FILE *fp;
 char  c;
 int   i;
 int   off;
 int   l;
 BOOL  got_something;
 char *lp;
 char  error_string[150];
 char  xline[39];
 char  cline[16];

 if (filenamep == NULL) fp = stdin;
 else fp = fopen(filenamep,"r");
 if (fp == NULL)
   {
    sprintf(error_string,"%s open failed",filenamep);
    perror(error_string);
    exit(4);
   }
 else {
    if (filenamep) printf("\n%s\n\n",filenamep);
    off = 0;
    l   = 0;
    do {
         char *xlinep;
         for (i=0;i<36;i++) xline[i] = ' ';
         for (i=0;i<16;i++) cline[i] = ' ';
         xlinep = &xline[0];
         got_something = FALSE;
         for (i=0;i<16;i++) {
          if (lrecl > 0 && l >= lrecl) {
            break;
          }
          c=getc(fp);
          /* if (c==EOF) break; */
          if (feof(fp)) break;
          l++;
          got_something = TRUE;
          sprintf(xlinep,"%2.2X",(c & 0x000000ff));
          *(xlinep+2) = ' ';
          if (isascii(c) && isprint(c)) cline[i] = c;
          else cline[i] = '.';
          if (!blockmode && c=='\n') {
            break;
          }
          xlinep += ((i%4==3) ? 3 : 2);
         }
         if (got_something) {
            printf("%6.6X  %36.36s  *%16.16s*\n",off,xline,cline);
            if (!blockmode && c=='\n') {
              printf("\n");
              off = 0;
            }
            else off += i;
            if (lrecl > 0 && l >= lrecl) {
              printf("\n");
              l = 0;
            }
         }
       } /* while (c != EOF); */
         while (!(feof(fp)));
  }
  if (filenamep) fclose(fp);
  return;
}

/* ================================================================== */

main(argc,argv)
 int argc;
 char **argv;
{
 int  i;
 int  j;
 BOOL got_a_file;
 BOOL expecting_lrecl;

 blockmode       = FALSE;
 lreclmode       = FALSE;
 got_a_file      = FALSE;
 expecting_lrecl = FALSE;
 for (i=1;i<argc;i++) {
   if (argv[i][0] == '-') {
	    j=1;
	    while (argv[i][j]) {
	       switch (argv[i][j]) {
          case 'b': blockmode = TRUE;
                    break;
          case 'l': lreclmode = TRUE;
                    expecting_lrecl = TRUE;
                    break;
		        default:  fprintf(stderr,"Usage: hexdump -bl file . . .\n");
				                exit(12);
				                break;
	       }
	       j++;
     }
   }
   else if (expecting_lrecl) {
     expecting_lrecl = FALSE;
     lrecl = atoi(argv[i]);
   }
   else {
     got_a_file = TRUE;
     doit(argv[i]);
   }
 }
 if (!got_a_file) doit(NULL);
 exit(0);
}

./ ADD NAME=HEXIN    0100-07332-07332-0900-00040-00040-00000-SEB
 /********************************************************************/

#pragma page()

 int hexin(expr)

 /* This subroutine takes a character string consisting of hex
    character representations and returns a binary fullword
    containing the hexadecimal data. */

  char *expr;
{
 int thing;
 int l;

 l = strlen(expr);
 if (l==0) {
  printf("Missing value\n");
  bad = TRUE;
  return(0);
 }
 if (l>8) {
  printf("Hex value too long\n");
  bad = TRUE;
  return(0);
 }

 if (strspn(expr," 0123456789abcdefABCDEF")<l) {
  printf("Invalid hex characters entered\n");
  bad = TRUE;
  return(0);
 }

 sscanf(expr,"%x",&thing);

 return(thing);

}; /* end hexin */

 /********************************************************************/
./ ADD NAME=HTTPDO   0100-07332-07332-0900-00356-00356-00000-SEB
/* PORT 80 (WEB) client - similar to "TELNET hostname 80" */

#define MVS

#ifdef MVS
#include <manifest.h>
#include <tcperrno.h>
#include <ctest.h>
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define  Bool                 int
#ifndef  TRUE
#define  TRUE                 (Bool)1
#endif
#ifndef  FALSE
#define  FALSE                (Bool)0
#endif
#define  CARRIAGE_RETURN      ('\r')
#define  NULL_CHARACTER       ('\0')
#define  READ_BYTES           1024
#define  MYBUF_INITIAL_SIZE   1024
#define  MYBUF_INCREMENT      512
#define  IBUF_MSGSIZE         1024
#define  OBUF_MSGSIZE         1024
#define  SOCKET_GETCHAR_ERROR (-1)
#define  SOCKET_NO_MORE       (-2)
#define  SOCKET_READ_NOTHING  (-3)

#ifdef MVS
#define  LINE_FEED            (0x25)
#define  etoa(x)              ebcdictoascii[x]
#define  atoe(x)              asciitoebcdic[x]
#define  ebcdictoascii        ebcdicto
#define  asciitoebcdic        asciitoe
#else
#define  LINE_FEED            (0x0a)
#define  etoa(x)              (x)
#define  atoe(x)              (x)
#endif

enum server_retval {
                    SERVER_OK,
                    SERVER_READ_ERROR,
                    SERVER_BUFFER_ERROR,
                    SERVER_NO_MORE,
                    SERVER_READ_NOTHING
                   };

#ifdef MVS
extern   char                 ebcdictoascii[];
extern   char                 asciitoebcdic[];
#endif

 /********************************************************************/
 /*                                                                  */
 /* Error handler.                                                   */
 /*                                                                  */
 /********************************************************************/

static void
errhand(whats,whatn)
char            *whats;
int              whatn;
{
 fprintf(stderr,"\nError: %s returned %d\n",whats,whatn);
 return;
}

 /********************************************************************/
 /*                                                                  */
 /* Input one character from the server.                             */
 /*                                                                  */
 /********************************************************************/

static int
socket_getchar(ns,dont_read)
 int                   ns;
 Bool                  dont_read;
 {
  static int           bytes_returned = 0;
  static char          g_buf[READ_BYTES];
  static int           g_buf_index = -1;
         int           readrc;

  if (g_buf_index == -1 || g_buf_index >= bytes_returned-1) {
    g_buf_index = -1;
    if (dont_read) return(SOCKET_NO_MORE);
    else {
      readrc = read(ns, g_buf, READ_BYTES);
      if (readrc == -1)     return SOCKET_GETCHAR_ERROR;
      else if (readrc == 0) return SOCKET_READ_NOTHING;
      else {
#ifdef MVS
            int i;
            for (i=0;i<readrc;i++) g_buf[i] = atoe(g_buf[i]);
#endif
            bytes_returned = readrc;
           }
    }
  }
  return g_buf[++g_buf_index];
 }

 /********************************************************************/
 /*                                                                  */
 /* Input one line of data from the server.                          */
 /*                                                                  */
 /********************************************************************/

static enum server_retval
socket_in(ns,i_buf,n_bytes,delimiter,dont_read)
 int                   ns;
 char                 *i_buf;
 int                   n_bytes;
 char                  delimiter;
 Bool                  dont_read;
 {
  int                  i_buf_index;
  int                  i;
  int                  character;

  /* Get characters from the server until delimiter is reached. */

  i_buf_index = 0;
  while ((character = socket_getchar(ns,dont_read)) != delimiter) {
    if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);
    if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);
    if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_NOTHING);
    if (i_buf_index >= n_bytes) {
      fprintf(stderr,"Warning: The buffer passed to socket_in overflowed.\n");
      fprintf(stderr," More than %d bytes collected without %2.2x seen.\n",
             n_bytes,delimiter);
      fprintf(stderr," Returning what we have so far.\n");
      break;
    }
    i_buf[i_buf_index++] = (unsigned char)character;
  }
  i_buf[i_buf_index] = NULL_CHARACTER;

  return(SERVER_OK);
 }

 /********************************************************************/
 /*                                                                  */
 /* Output one line of data to the server.                           */
 /*                                                                  */
 /********************************************************************/

static void
socket_out(ns,o_buf,n_bytes)
 int                   ns;
 char                 *o_buf;
 int                   n_bytes;
 {
  int                  writrc;
  int                  j;
  int                  needed_bytes;
  static char         *mybufp = NULL;
  static int           mybufl = 0;

  needed_bytes = n_bytes+2;

  if (mybufp == NULL) {
    mybufl = MYBUF_INITIAL_SIZE;
    mybufp = (char *)malloc(mybufl);
  }

  if (mybufl < needed_bytes) {
    mybufl = needed_bytes + MYBUF_INCREMENT;
    free(mybufp);
    mybufp = (char *)malloc(mybufl);
  }

  if (mybufp == NULL) {
    fprintf(stderr,"\nWhoops, failed to allocate output buffer!\n");
    abort();
  }

  memcpy(mybufp,o_buf,n_bytes);
  mybufp[n_bytes  ] = CARRIAGE_RETURN;
  mybufp[n_bytes+1] = LINE_FEED;

#ifdef MVS
  for (j=0;j<=n_bytes+1;++j) mybufp[j] = etoa(mybufp[j]);
#endif

  writrc = write(ns, mybufp, n_bytes+2);
  if (writrc < 0) errhand("write",writrc);

  return;
 }

 /********************************************************************/
 /*                                                                  */
 /* Client routine.                                                  */
 /*                                                                  */
 /********************************************************************/

main(argc,argv)
int               argc;
char            **argv;
{

 int                port = 80;      /* port for the HTTP protocol  */
 char              *hostname;
 char              *hostfile;
 char              *cp;
 int                nbytes;         /* size of message buffer        */
 char               ibuf[IBUF_MSGSIZE];    /* the input buffer       */
 char               obuf[OBUF_MSGSIZE];    /* the output buffer      */
 char              *obufp;
 int                ibuflen;
 int                hostaddress;
 char               client_hostname[80];
 struct hostent    *hp;
 struct hostent    *server_hostent;
 struct sockaddr_in consock;        /* used by connect               */
 int                consocklen;     /* used by connect               */
 int                s;              /* the socket descriptor         */
 int                backlog;        /* queue length                  */
 int                listrc;         /* the return code from listen   */
 int                connrc;         /* the return code from connect  */
 int                readrc;         /* the return code from read     */
 int                writrc;         /* the return code from write    */
 enum server_retval socket_in_rc;

 Bool               first_time_thru;
 Bool               time_to_go_home;
 Bool               server_has_something_pending;
 Bool               sending_text;
 Bool               something_to_print;
 Bool               dont_read;

 if (argc != 3) {
   fprintf(stderr,"Usage: %s hostname[:portnumber] url\n",argv[0])      ;
   exit(12);
 }

 hostname = argv[1];
 hostfile = argv[2];

 cp = strchr(hostname,':');
 if (cp) {
   *cp = '\0';
   port = atoi(cp+1);
 }
 else port = 80;

 server_hostent = gethostbyname(hostname);
 if (!server_hostent) {
    fprintf(stderr,"Error:  gethostbyname doesn't know host %s\n",hostname);
    exit(12);
 }
 if (!server_hostent) errhand("gethostbyname for server hostname",0);

 consock.sin_family = AF_INET;
 consock.sin_port = htons(port);
 consock.sin_addr.s_addr = *((int *)server_hostent->h_addr);

 gethostname(client_hostname,sizeof(client_hostname));
 hp = gethostbyname(client_hostname);
 if (!hp) errhand("gethostbyname for client hostname",0);
 hostaddress = *((int *)(hp->h_addr_list[0]));

 s = socket(AF_INET, SOCK_STREAM, 0);
 if (s < 0) errhand("socket creation",s);

 consocklen = sizeof(consock);
 connrc = connect(s, &consock, consocklen);

 if (connrc < 0) {
   errhand("connect",connrc);
   exit(connrc);
 }

 /**********************************************************************
 *                                                                     *
 * Send the server some input.  For HTTP, this is a URL.               *
 *                                                                     *
 **********************************************************************/

 strcpy(ibuf, "GET ");
 strncpy(ibuf+4,hostfile,sizeof(ibuf)-5);

 socket_out(s,ibuf,strlen(ibuf));

 server_has_something_pending = TRUE;
 sending_text                 = FALSE;
 something_to_print           = FALSE;
 dont_read                    = FALSE;

 while (server_has_something_pending) {

  something_to_print = FALSE;

  socket_in_rc = socket_in(s,obuf,OBUF_MSGSIZE, LINE_FEED, dont_read);

  switch (socket_in_rc) {
    case SERVER_OK:
            something_to_print = TRUE;
            break;
    case SERVER_READ_NOTHING:
            server_has_something_pending = FALSE;
            break;
    case SERVER_NO_MORE:
            server_has_something_pending = FALSE;
            break;
    case SERVER_READ_ERROR:
            fprintf(stderr,"\n\nRead error, lost connection.\n\n");
            time_to_go_home = TRUE;
            break;
    case SERVER_BUFFER_ERROR:
            fprintf(stderr,"\n\nServer buffer error\n\n");
            time_to_go_home = TRUE;
            break;
  };

  if (time_to_go_home) break;
  if (dont_read && !server_has_something_pending) break;

  obufp = obuf;

  if (something_to_print) {
    cp = obufp + strlen(obufp) - 1;
    if (cp >= obufp) {
      if (*cp == CARRIAGE_RETURN) *cp = '\0';
    }
    printf("%s\n",obufp);
  }

  if (time_to_go_home) break;

 } /* end while server_has_something_pending */

 /********************************************************************/
 /*                                                                  */
 /* Close the original socket.                                       */
 /*                                                                  */
 /********************************************************************/

 close(s);

 exit(0);

}

./ ADD NAME=JAY      0100-07332-07332-0900-00092-00092-00000-SEB
/* # pragma runopts(test) */
# include <stdio.h>

static void j_process_julian_date();
static void j_process_some_kind_of_date();
static void j_process_gregorian_date();
static void j_syntax_error();

main(argc,argv)
        int argc;
        char **argv;
{

 if (argc == 1)         /* no date argument specified */
        j_process_julian_date("Sorry, can't get current date, too stupid");
 else
 if (argc == 2)         /* one date argument specified */
        j_process_some_kind_of_date(argv[1]);
 else {
        fprintf(stderr,"Usage: j [julian_or_gregorian_date]\n");
        exit(1);
 }
}

 void j_process_some_kind_of_date(datep)
        char *datep;
{

 if (strchr(datep,'/'))         /* date contains a slash */
        j_process_gregorian_date(datep);
 else
        j_process_julian_date(datep);
}

void j_process_gregorian_date(datep)
        char *datep;
{
        int     mm,
                dd,
                yy;
        int     j;

 static int     days_so_far[12] = {0,31,60,91,121,152,182,213,244,274,305,335};

 if (sscanf(datep,"%d/%d/%d",&mm,&dd,&yy) != 3)
        j_syntax_error(datep,"bad mm or dd or yy");

 if (mm < 1 || mm > 12 || dd < 1 || yy < 1)
        j_syntax_error(datep,"mm or dd or yy out of range");
 j = days_so_far[mm-1] + dd;
 if (yy%4 != 0 && j > 59) j--;
 /* printf("Julian date for \"%s\" is:  %2.2d%3.3d\n",datep,yy,j); */
 printf("%2.2d%3.3d\n",yy,j);
 exit(0);
}

void j_process_julian_date(datep)
        char *datep;
{
        int     n,
                jjj,
                nextjjj,
                yy,
                sscanf_rc;

 static int     days_month[12] = {31,29,31,30,31,30,31,31,30,31,30,31};

 if (strchr(datep,'.'))  sscanf_rc = sscanf(datep,"%d.%d",&yy,&jjj);
 else                    sscanf_rc = sscanf(datep,"%2d%d",&yy,&jjj);
 if (sscanf_rc != 2)
        j_syntax_error(datep,"bad yy or jjj");

 if (yy%4 != 0 && jjj > 59) jjj++;
 nextjjj = jjj;
 for (n=0;n<12 && nextjjj>0;n++) {
        jjj = nextjjj;
        nextjjj -= days_month[n];
 }


 /* printf("Gregorian date for \"%s\" is:  %2.2d/%2.2d/%2.2d\n",datep,n,jjj,yy);
 printf("%2.2d/%2.2d/%2.2d\n",n,jjj,yy);
 exit(0);
}

void j_syntax_error(datep,error_code)
        char *datep;
        char *error_code;
{
 fprintf(stderr,"Invalid date, %s - %s\n",datep,error_code);
 exit(1);
}
./ ADD NAME=MAKENULL 0100-07332-07332-0900-00064-00064-00000-SEB
/* makenull.c - this program demonstrates the creation and reading of
                null records in a C program */

#include <stdio.h>

main() {
 FILE   *fp;
 char   *cp;
 int     i;
 char   *filename = "makenull.txt";
 char    line[512];
 char   *textlines[7] = {"This is line 1.",
            "This line should be followed by a null line.",
            "",
            "This line should be preceded by a null line.",
            "You should see blank space (one line's worth) between",
            "the previous 2 lines.  If you don't, the program has ",
            "handled null records correctly."};

 /* First, create the file that contains a null record */

 remove(filename);

 fp = fopen(filename,"wb,recfm=vb,lrecl=255,blksize=6233");
 if (!fp) {
  perror(filename);
  exit(1);
 }

 printf("\nWriting file %s...\n\n",filename);

 for (i=0; i<7; i++) {
  printf("%s\n",textlines[i]);
  for (cp = textlines[i]; *cp; cp++) {
   fwrite(cp,1,1,fp);
  }
  fflush(fp);  /* apparently this makes new records in binary mode */
 }

 fclose(fp);

 /* Now, read back the file we just created. */

 fp = fopen(filename,"r");
 if (!fp) {
  perror(filename);
  exit(1);
 }

 printf("\nReading file %s...\n\n",filename);

 while (1) {
  cp = fgets(line, sizeof line, fp);
  if (cp == NULL) break;
  while (*cp) {
   putchar(*cp);
   cp++;
  }
 }

 fclose(fp);

}

./ ADD NAME=MAKEUP   0100-07332-07332-0900-00203-00203-00000-SEB
/*
 ***********************************************************************
 *                                                                     *
 * This program takes a PDS and creates an IEBUPDTE stream on stdout.  *
 *                                                                     *
 * The PDS may be FB or VB.                                            *
 *                                                                     *
 * Usage:   makeup pdsname > iebupdte_stream_file                      *
 *                                                                     *
 * or                                                                  *
 *                                                                     *
 * Usage:   makeup pdsname membernamelistfile > iebupdte_stream_file   *
 *                                                                     *
 ***********************************************************************
 */

#include <stdio.h>
#include <string.h>

#define  Bool       char
#define  FALSE      (Bool)0
#define  TRUE       (Bool)1
#define  EQUAL(X,Y)         (strcmp(X,Y)   == 0)
#define  UNEQUAL(X,Y)       (strcmp(X,Y)   != 0)
#define  LESS(X,Y)          (strcmp(X,Y)   <  0)
#define  GREATER(X,Y)       (strcmp(X,Y)   >  0)
#define  EQUALM(X,Y,Z)      (memcmp(X,Y,Z) == 0)
#define  UNEQUALM(X,Y,Z)    (memcmp(X,Y,Z) != 0)
#define  LESSM(X,Y,Z)       (memcmp(X,Y,Z) <  0)
#define  GREATERM(X,Y,Z)    (memcmp(X,Y,Z) >  0)

typedef struct memlink MEMLINK;

struct memlink {
                struct memlink *next;
                char            member[9];
               };

int
main(argc,argv)
int          argc;
char       **argv;
{
 short       i;
 short       block_count;
 short       bump_amount;
 Bool        no_more;
 Bool        reject;
 char       *cp;
 FILE       *dirfp;
 FILE       *ifp;
 FILE       *mfp;
 char       *pgm;
 char       *pds;
 char       *memlistdsn;
 MEMLINK    *ml;
 MEMLINK    *newml;
 int         linecount;
 char        fulldsn [128];
 char        dirblk  [256];
 char        eline   [256];

 /* code to get members and process each one */

 switch (argc) {
   case 2: pgm = argv[0];
           pds = argv[1];
           memlistdsn = NULL;
           break;
   case 3: pgm = argv[0];
           pds = argv[1];
           memlistdsn = argv[2];
           break;
   default:
            fprintf(stderr,
   "Usage: %s <pdsname> <optional_file_containing_names_of_members>\n",
                    argv[0]);
            exit(16);
 }

 ml = NULL;

 if (memlistdsn) {
   if (!(mfp = fopen(memlistdsn,"r"))) {
     perror(memlistdsn);
     exit(12);
   }
   while (!feof(mfp)) {
     *eline = '\0';
     fscanf(mfp,"%s",eline);
     if (ferror(mfp)) {
       fprintf(stderr,"%s: error reading %s\n",pgm,memlistdsn);
       exit(20);
     }
     if (!*eline) continue;
     if (strlen(eline) > 8) {
       fprintf(stderr,"%s: Member name too long, ignored: %s\n",
                      pgm,eline);
       continue;
     }
     newml = (MEMLINK *)malloc(sizeof(MEMLINK));
     if (!newml) {
       fprintf(stderr,"%s: not enough memory for member name list\n",
                      pgm);
       exit(20);
     }
     newml->next = ml;
     strcpy(newml->member,"        ");
     strcpy(newml->member,eline);
     for (cp = newml->member; *cp; cp++) *cp = toupper(*cp);
     *cp = ' ';
     ml = newml;
   }
   fclose(mfp);
 }

 /* debugging only */

 for (newml = ml; newml; newml = newml->next) {
   fprintf(stderr,"Selecting member name: <%s>\n", newml->member);
 }

 if (!(dirfp = fopen(pds,"rb,recfm=u,lrecl=256"))) {
   perror(pds);
   exit(12);
 }

 no_more = FALSE;

 do {
   memset(dirblk,0x00,256);
   fread(dirblk,256,1,dirfp);
   if (feof(dirfp)) break;
   if (ferror(dirfp)) {
     fprintf(stderr, "%s: Error reading directory of %s\n",
                     pgm,pds);
     fclose(dirfp);
     exit(20);
   }
   cp = dirblk;
   block_count = *(short *)cp - 2;   /* # bytes in dir block */
   cp += 2;                        /* addr of dir block data */
   while (block_count > 0) {
     if (EQUALM(cp,"\xff\xff\xff\xff\xff\xff\xff\xff",8)) {
       /*
       no_more = TRUE;
       */
       break;
     }
     reject = FALSE;
     if ((cp[11] & 0x80) != 0) { /* skip aliases */
       fprintf(stderr,"Skipping alias:  %-8.8s\n",cp);
       reject = TRUE;
     }
     else if (memlistdsn) {
       for (newml = ml; newml; newml = newml->next) {
         if (EQUALM(newml->member,cp,8)) break;
       }
       if (!newml) {
         fprintf(stderr,"Unwanted member: %-8.8s\n",cp);
         reject = TRUE;
       }
     }
     if (!reject) {
       if (*pds == '\'')
            sprintf(fulldsn,"'%.*s(%-8.8s)'", strlen(pds)-2,pds+1,cp);
       else sprintf(fulldsn,"%s(%-8.8s)",pds,cp);
       if (!(ifp = fopen(fulldsn,"r"))) {
         perror(fulldsn);
         break;
       }
       fprintf(stdout,"./ ADD NAME=%s\n",cp);
       linecount = 0;
       while(!feof(ifp)) {
         memset(eline,'\0',4);
         (void)fgets(eline,sizeof eline,ifp);
         if (feof(ifp)) break;
         if (ferror(ifp)) {
           fprintf(stderr,"%s: Error reading %s",pgm,fulldsn);
           break;
         }
         linecount++;
         if (EQUALM(eline,"./",2)) {
           fprintf(stderr,"Warning: ./ found in %-8.8s - line %d\n",
                   cp,linecount);
         }
         fputs(eline,stdout);
       }
       fclose(ifp);
     }
     bump_amount = 12 + ((cp[11] & 0x1f) * 2);
     cp += bump_amount;
     block_count -= bump_amount;
   }
 } while(!no_more);

 fprintf(stdout,"./ ENDUP\n");

 fclose(dirfp);

 exit(0);
}

./ ADD NAME=MATCH    0100-07332-07332-0900-00336-00336-00000-SEB
#include <ctest.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define  BOOL      int
#define  FALSE     (BOOL)0
#define  TRUE      (BOOL)1
#define  FAILURE   (-1)
#define  NULLCHAR  '\0'

typedef struct _matcher   MATCHER;
typedef struct _matchap   MATCHAP;
typedef int             (*OPERATION)();

struct _matchap {
                 OPERATION   operation;
                 int         operi;
                 char       *operj;
                };

struct _matcher {
                 int         used;
                 MATCHAP     matchap[1];
                };

/*-------------------------------------------------------------------*/

static BOOL
same(s1,s2,len)
register  char    *s1;
register  char    *s2;
register  int      len;
{
 register char    *p1;
 register char    *p2;

 for (p1=s1,p2=s2; len>0 ; p1++,p2++,len--) {
   if (*p2 != '?' && *p1 != *p2) return FALSE;
 }
 return TRUE;
}

/*-------------------------------------------------------------------*/

static int
do_min(wordp,wordlen,argi,argj,pointer)
register char     *wordp;
register int       wordlen;
register int       argi;
register char     *argj;
register int       pointer;
{

 if (argi > wordlen) return FAILURE;
 else return pointer;
}

/*-------------------------------------------------------------------*/

static int
do_bump(wordp,wordlen,argi,argj,pointer)
register char     *wordp;
register int       wordlen;
register int       argi;
register char     *argj;
register int       pointer;
{

 pointer += argi;
 if (pointer > wordlen) return FAILURE;
 else return pointer;
}

/*-------------------------------------------------------------------*/

static int
do_match(wordp,wordlen,argi,argj,pointer)
register  char     *wordp;
register  int       wordlen;
register  int       argi;
register  char     *argj;
register  int       pointer;
{
 register int       matchptr = wordlen + 1 - argi;

 if (pointer > matchptr) return FAILURE;
 else if (!memcmp(wordp+pointer,argj,argi)) return pointer + argi;
 else return FAILURE;
}

/*-------------------------------------------------------------------*/

static int
do_scan(wordp,wordlen,argi,argj,pointer)
register  char     *wordp;
register  int       wordlen;
register  int       argi;
register  char     *argj;
register  int       pointer;
{
 register int       matchptr = wordlen + 1 - argi;

 for (;pointer <= matchptr; pointer++) {
   if (!memcmp(wordp+pointer,argj,argi)) return pointer + argi;
 }
 return FAILURE;
}

/*-------------------------------------------------------------------*/

static int
do_wildmatch(wordp,wordlen,argi,argj,pointer)
register  char     *wordp;
register  int       wordlen;
register  int       argi;
register  char     *argj;
register  int       pointer;
{
 register int      matchptr = wordlen + 1 - argi;

 if (pointer > matchptr) return FAILURE;
 else if (same(wordp+pointer,argj,argi)) return pointer + argi;
 else return FAILURE;
}

/*-------------------------------------------------------------------*/

static int
do_wildscan(wordp,wordlen,argi,argj,pointer)
register  char     *wordp;
register  int       wordlen;
register  int       argi;
register  char     *argj;
register  int       pointer;
{
 register int      matchptr = wordlen + 1 - argi;

 for (;pointer <= matchptr; pointer++) {
   if (same(wordp+pointer,argj,argi)) return pointer + argi;
 }
 return FAILURE;
}

/*-------------------------------------------------------------------*/

static BOOL
apply(matcher,wordp,wordlen)
MATCHER  *matcher;
char     *wordp;
int       wordlen;
{
 short    pointer = 0;
 int      m;
 int    (*function)();
 int      argument;

 for (m=0; m<matcher->used; m++) {

   pointer = (matcher->matchap[m].operation)
                                          (wordp,
                                           wordlen,
                                           matcher->matchap[m].operi,
                                           matcher->matchap[m].operj,
                                           pointer);
   if (pointer == FAILURE)  return FALSE;
 }

 return TRUE;
}

/*-------------------------------------------------------------------*/

static void
hack(pattern,matcher)
char     *pattern;
MATCHER  *matcher;
{
 int      min       = 0;
 int      bump      = 0;
 int      matchlen  = 0;
 BOOL     starmode  = FALSE;
 BOOL     matchmode = TRUE;
 BOOL     wildmode  = FALSE;
 BOOL     dataless  = TRUE;
 char    *matchp    = NULL;
 char    *cp        = NULL;

 matcher->matchap[0].operation = do_min;
 matcher->matchap[0].operi     = 0;    /* to be filled in later */
 matcher->matchap[0].operj     = NULL; /* to be filled in later */
 matcher->used = 1;

 for (cp=pattern;*cp;cp++) {
   switch (*cp) {
     case '*':
              if (matchp) {
                matcher->matchap[matcher->used].operation =
                   (matchmode ? (wildmode ? do_wildmatch : do_match)
                              : (wildmode ? do_wildscan  : do_scan));
                matcher->matchap[matcher->used].operi    =  matchlen;
                matcher->matchap[matcher->used].operj    =  matchp;
                matcher->used++;
                matchp = NULL;
                matchlen = 0;
              }
              starmode = TRUE;
              break;
     case '?':
              min++;
              if (starmode || dataless) {
                bump++;
              }
              else {
                wildmode = TRUE;
                if (!matchp) matchp = cp;
                matchlen++;
              }
              break;
     default:
              dataless = FALSE;
              min++;
              if (bump > 0) {
                matcher->matchap[matcher->used].operation = do_bump;
                matcher->matchap[matcher->used].operi      = bump;
                matcher->matchap[matcher->used].operj      = NULL;
                matcher->used++;
                bump = 0;
              }
              if (starmode) {
                matchmode = FALSE;
                wildmode = FALSE;
              }
              if (!matchp) matchp = cp;
              matchlen++;
              starmode = FALSE;
              break;
   }
 }

 if (bump > 0) {
   matcher->matchap[matcher->used].operation = do_bump;
   matcher->matchap[matcher->used].operi     = bump;
   matcher->matchap[matcher->used].operj     = NULL;
   matcher->used++;
   bump = 0;
 }
 if (starmode) {
   matchmode = FALSE;
   wildmode = FALSE;
 }
 if (!matchp) matchp = cp;
 matchlen++;
 if (matchp) {
   matcher->matchap[matcher->used].operation =
      (matchmode ? (wildmode ? do_wildmatch : do_match)
                 : (wildmode ? do_wildscan  : do_scan));
   matcher->matchap[matcher->used].operi    =  matchlen;
   matcher->matchap[matcher->used].operj    =  matchp;
   matcher->used++;
   matchp = NULL;
   matchlen = 0;
 }

 matcher->matchap[0].operi  = min;

 return;
}

/*-------------------------------------------------------------------*/

int
main(argc,argv)
int       argc;
char    **argv;
{
 char    *pattern;
 char    *filename;
 int      matchersize;
 MATCHER *matcher;
 FILE    *fp;
 int      i;
 char    *wordp;
 int      wordlen;
 char     line[256];

 if (argc < 3) {
   fprintf(stderr,"Usage: match pattern filename\n");
   exit(12);
 }

 if (argc > 3 && (!strcmp(argv[3],"test") ||
                  !strcmp(argv[3],"TEST"))) __ctest(NULL);

 pattern  = argv[1];
 filename = argv[2];

 matchersize = strlen(pattern) * sizeof(MATCHAP) + sizeof(MATCHER);
 matcher = (MATCHER *)malloc(matchersize);
 if (!matcher) {
   fprintf(stderr,"match: cannot get %d bytes for matcher\n",
                  matchersize);
   exit(16);
 }
 hack(pattern,matcher);
 if (!(fp=fopen(filename,"r"))) {
   perror(filename);
   exit(12);
 }

 while (!feof(fp)) {
   (void)fgets(line,sizeof line,fp);
   if (feof(fp)) break;
   if (ferror(fp)) {
     perror(filename);
     break;
   }
   if (wordp = strchr(line,'\n')) *wordp = '\0';
   wordp = line;
   for (;;) {
     wordp += strspn(wordp," ");
     if (*wordp == '\0') break;
     wordlen = strcspn(wordp," ");
     *(wordp+wordlen) = '\0';
     if (apply(matcher,wordp,wordlen)) {
       printf("%s\n",wordp);
     }
     else {
     }
     wordp += wordlen+1;
   }
 }
 fclose(fp);
 free(matcher);
 return 0;
}
./ ADD NAME=NUSERS   0100-07332-07332-0900-00070-00070-00000-SEB
#pragma runopts(nospie,nostae)
#include <stdio.h>

static unsigned long * nuser();

main()
{printf("\n%d TSO users\n",*nuser());}

unsigned long * nuser()
{

 static unsigned long tsoctr;

 struct cvt {
         char            CVT_FILLER1 [556];       /* 0-22C  */
         struct asvt *   CVTASVT;                 /* 22C    */
        };

 struct ascb {
         char             ASCB_FILLER1 [36];       /* 0-24  */
         short            ASCBASID;                /* 24-26 */
         char             ASCB_FILLER2 [22];       /* 26-3C */
         struct tsb *     ASCBTSB;                 /* 3C    */
         char             ASCB_FILLER3 [112];      /* 40-B0 */
         char *           ASCBJBNS;                /* B0    */
        };

 struct tsb {
         char NOTHING_MUCH;  /* who cares */
        };

 struct asvtentry {
         int             asvteword;
        };

 struct asvt {
         char               ASVT_FILLER1 [516];      /* 0-204 */
         int                ASVTMAXU;                /* 204   */
         int                ASVT_FILLER2;            /* 208   */
         struct asvtentry   ASVTENTY[1];             /* 20C   */
        };

 struct cvt      ** cvtpp = (struct cvt **) 0x10;
 struct cvt       * cvtp;
 struct ascb      * ascbp;
 struct asvtentry   asvte;
 int asid, asid_start, asid_end;

 tsoctr = 0;
 cvtp = *cvtpp;
 asid_start = 1;
 asid_end   = cvtp->CVTASVT->ASVTMAXU;

 for (asid=asid_start; asid<=asid_end; asid++) {
    /* get ASVT entry for this ASID */
    asvte = cvtp->CVTASVT->ASVTENTY[asid-1];
    if (!(asvte.asvteword & 0x80000000)) { /* this asid is assigned */
       ascbp = (struct ascb *)(asvte.asvteword & 0x00ffffff);
       printf("ASID %d (%4.4X) TSB %8.8X Name %8.8s\n",asid,asid,
              (ascbp->ASCBTSB),
              (ascbp->ASCBJBNS) ? ascbp->ASCBJBNS : "--------");

       if (ascbp->ASCBTSB != NULL && ascbp->ASCBJBNS != NULL)
          tsoctr++;
    }
    else printf("ASID %d (%4.4X) not in use: %8.8X\n",
                asid,asid, (asvte.asvteword));
 }
 return(&tsoctr);
}
./ ADD NAME=REXXIT   0100-07332-07332-0900-00479-00479-00000-SEB
/*
#pragma linkage(IRXEXCOM,OS)
#pragma linkage(IRXEXEC,OS)
#pragma linkage(IRXINIT,OS)
#pragma linkage(IRXLOAD,OS)
#pragma linkage(IRXSTK,OS)
#pragma linkage(IRXTERM,OS)
*/
#pragma runopts(noargparse,noredir)
#include <stdio.h>
#include "rexx.h"

#define Bool        int
#ifndef FALSE
#define FALSE       (Bool)0
#endif
#ifndef TRUE
#define TRUE        (Bool)1
#endif

static Rexxfun    irxexcom;
static Rexxfun    irxexec;
static Rexxfun    irxinit;
static Rexxfun    irxload;
static Rexxfun    irxstk;
static Rexxfun    irxterm;

static struct envblock  *envblockptr;
static struct instblock *instblockptr;
static char             *commandargs;
static struct execblock  execblk;

/* ================================================================ */

static void
dump_envblock(struct envblock *E)
{
 fprintf(stdout,"Dump of ENVBLOCK at %8.8X follows...\n\n",E);
 fprintf(stdout,"ID.....................%8.8s\n", E->id              );
 fprintf(stdout,"Version................%4.4s\n", E->version         );
 fprintf(stdout,"Length.................%d\n",    E->length          );
 fprintf(stdout,"Parmblock..............%8.8X\n", E->parmblock       );
 fprintf(stdout,"Userfield..............%8.8X\n", E->userfield       );
 fprintf(stdout,"Workblock extension....%8.8X\n", E->workblok_ext    );
 fprintf(stdout,"External entry vector..%8.8X\n", E->irxexte         );
 fprintf(stdout,"Error call address.....%8.8X\n", E->error_call_addr );
 fprintf(stdout,"Error message ID.......%8.8s\n", E->error_msgid     );
 fprintf(stdout,"Primary error message:\n%80.80s\n",
                E->primary_error_message);
 fprintf(stdout,"Alternate error message:\n%160.160s\n",
                E->alternate_error_message);
 fprintf(stdout,"compgmtb...............%8.8X\n", E->compgmtb        );
 fprintf(stdout,"attnrout_parmptr.......%8.8X\n", E->attnrout_parmptr);
 fprintf(stdout,"\n\nEnd of ENVBLOCK dump.\n\n");
}

/* ================================================================ */

static Bool
call_irxinit(char *command)
{
 unsigned int       bitflags;
 int                rexxrc;
 int                irxinitrc;
 int                i;
 void              *parmlist; /* dunno */
 Bool               rc;
 PARAMETER          parameter[11];

 /* Set up parameters for IRXINIT:
  *
  * Param 1  -  "INITENVB"  - could be "FINDENVB" to find env block
  * Param 2  -  "        "  - name of parameters module
  * Param 3  -  address of in-storage parameter list
  * Param 4  -  address of a user field
  * Param 5  -  zero
  * Param 6  -  set to address of environment block
  * Param 7  -  set to reason code
  * Param 8  -  zero (default storage allocation)
  * Param 9  -  set to return code
  *
  */

 rexxrc = 0;

 parameter[ 3] =   (PARAMETER) NULL;       /* no instor param list */
 parameter[ 4] =   (PARAMETER) NULL;       /* no user field */
 parameter[ 5] =   (PARAMETER) 0;
 parameter[ 6] =   (PARAMETER) NULL;
 parameter[ 7] =   (PARAMETER) 0;
 parameter[ 8] =   (PARAMETER) 0;
 parameter[ 9] =   (PARAMETER) 0;

 irxinitrc = (*irxinit) (
                         "INITENVB",
                         "        ",
                         &parameter[3],
                         &parameter[4],
                         &parameter[5],
                         &parameter[6],
                         LASTPARM(&parameter[7]),   /* old REXX */
                         &parameter[8],
                         LASTPARM(&parameter[9])    /* new REXX */
                        );

 if (irxinitrc != 0) rc = FALSE;
 else rc = TRUE;
 envblockptr = (struct envblock *)parameter[6];
 rexxrc = parameter[7];
 fprintf(stderr,"Return code from IRXINIT is %d\n", irxinitrc);
 fprintf(stderr,"Reason code from IRXINIT is %d\n", rexxrc   );
 fprintf(stderr,"IRXINIT returned envblock at %8.8X\n", envblockptr);
 if (!memcmp((char *)envblockptr,"ENVBLOCK",8)) {
   fprintf(stderr,"This is a good environment block address\n");
 }
 else {
   fprintf(stderr,"This is a BAD environment block address\n");
 }
 return TRUE;

}

/* ================================================================ */

static Bool
call_irxterm(char *command)
{
 int irxtermrc;

 irxtermrc = (*irxterm) ();

 if (irxtermrc != 0) {
   fprintf(stderr,"Return code from IRXTERM is %d\n", irxtermrc);
   return FALSE;
 }
 else {
   fprintf(stderr,"Return code from IRXTERM is %d\n", irxtermrc);
   return TRUE;
 }
}

/* ================================================================ */

static Bool
call_irxload(char *command)
{
 char              *function;
 unsigned int       bitflags;
 int                rexxrc;
 int                irxloadrc;
 int                cmdlen;
 int                scan_count;
 int                i;
 Bool               rc;
 char               exectest[1024];
 PARAMETER          parameter[11];

 function = (command ? "LOAD    " : "FREE    ");
 rc = TRUE;
 scan_count = 0;
 cmdlen = strlen(command);

 *exectest = '\0';
 sscanf(command, "%s %n", exectest, &scan_count);
 if (strlen(exectest) > 8) {
   fprintf(stderr,"Sorry, name of exec is too long: %s\n",exectest);
   return FALSE;
 }
 commandargs = command + scan_count;

 if (!rc) return rc;

 /* set up exec block */

 if (command) {
   memset(&execblk,0,sizeof(execblk));
   execblk.length = sizeof(execblk);
   memcpy (execblk.acryn, "IRXEXECB", 8);
   strncpy(execblk.member,exectest,8);
   for (i=0;i<8;i++) {
     if (execblk.member[i] == '\0') execblk.member[i] = ' ';
   }
   /* We may have just clobbered this, so do this after... */
   memcpy (execblk.ddname, "GGEXEC  ", 8);
   memcpy (execblk.subcom, "        ", 8);
   parameter[ 2] =   (PARAMETER)&execblk;
   parameter[ 3] =   (PARAMETER)NULL;   /* set to INSTBLK */
   fprintf(stderr,"Loading:%s\n", exectest);
 }
 else {
   parameter[ 2] =   (PARAMETER)NULL;
   parameter[ 3] =   (PARAMETER)instblockptr;
 }
 parameter[ 4] =   (PARAMETER)envblockptr;
 parameter[ 5] =   (PARAMETER)0;      /* set to return code */

 irxloadrc = (*irxload) (
                         function,
                         &parameter[2],
                         LASTPARM(&parameter[3]), /* old REXX */
                         &parameter[4],
                         LASTPARM(&parameter[5])  /* new REXX */
                        );

 fprintf(stderr,"Return code from IRXLOAD is %d\n", irxloadrc);
 instblockptr = (struct instblock *)parameter[3];
 return (irxloadrc == 0 ? TRUE : FALSE);

}

/* ================================================================ */

static Bool
call_irxexec(char *command)
{
 unsigned int       bitflags;
 int                rexxrc;
 int                irxexecrc;
 int                cmdlen;
 int                i;
 Bool               rc;
 char              *arg2 = "Argument number two";
 char              *arg3 = "This, too, shall pass to the REXX exec.";
 char               exectest[1024];
 PARAMETER          parameter[11];
 struct {
         struct {
                 char   *argstring_ptr;
                 int     argstring_length;
                }        argstring[3];
         int             argstring_end;
        }                arguments;

 rc = TRUE;

 /* Set up parameters for IRXEXEC:
  *
  * Param 1  -  address of EXECBLK
  * Param 2  -  address of arguments
  * Param 3  -  bitflags
  * Param 4  -  address of INSTBLK
  * Param 5  -  address of CPPL
  * Param 6  -  address of EVALBLOCK
  * Param 7  -  address of 8-byte work area
  * Param 8  -  address of user field
  * Param 9  -  address of environment block
  * Param 10 -  return code
  *
  */

 if (rc) {

   /* set up arguments  */

   arguments.argstring[0].argstring_ptr    = commandargs;
   arguments.argstring[0].argstring_length = strlen(commandargs);
   arguments.argstring[1].argstring_ptr    = arg2;
   arguments.argstring[1].argstring_length = strlen(arg2);
   arguments.argstring[2].argstring_ptr    = arg3;
   arguments.argstring[2].argstring_length = strlen(arg3);
   arguments.argstring_end    = 0xffffffff;

   /* Invoke the rexx exec */

   fprintf(stderr,"Executing:%s\n", command);

   rexxrc = 0;
   bitflags = (unsigned int)(INVOKE_EXEC_AS_COMMAND +
                             RETURN_EXTENDED_RETURN_CODES);

   parameter[ 1] =   (PARAMETER)&execblk;
   parameter[ 2] =   (PARAMETER)&arguments;
   parameter[ 3] =   (PARAMETER)bitflags;
   parameter[ 4] =   (PARAMETER)NULL;  /* no INSTBLK */
   parameter[ 5] =   (PARAMETER)NULL;  /* no CPPL    */
   parameter[ 6] =   (PARAMETER)NULL;  /* no eval block */
   parameter[ 7] =   (PARAMETER)NULL;  /* no work area */
   parameter[ 8] =   (PARAMETER)NULL;  /* no user field, last parm */
   parameter[ 9] =   (PARAMETER)NULL;  /* no environment block */
   parameter[10] =   (PARAMETER)0;     /* return code */

   irxexecrc = (*irxexec) (
                           &parameter[1],
                           &parameter[2],
                           &parameter[3],
                           &parameter[4],
                           &parameter[5],
                           &parameter[6],
                           &parameter[7],
                           LASTPARM(&parameter[8]), /* old REXX */
                           &parameter[9],
                           LASTPARM(&parameter[10]) /* new REXX */
                          );

   if (irxexecrc != 0) {
     fprintf(stderr,"Return code from IRXEXEC is %d\n", irxexecrc);
     rc = FALSE;
   }
   else {
     rexxrc = parameter[10];
     fprintf(stderr,"Return code from %s is %d\n", exectest, rexxrc);
   }
 }

 else fprintf(stderr,"Some kind of problem with exec %s\n",exectest);

 return rc;

}

/* ================================================================ */

static Bool
call_irxexcom(char *stuff)
{
 int              irxexcomrc = 0;
 int              retcode    = 0;
 int              zero       = 0;
 char            *variable_name  = "FOOVARIABLE";
 char            *variable_value = "Value of the FOOVARIABLE variable";
 struct shvblock  shvblk;

 memset(&shvblk,0,sizeof(shvblk));

 shvblk.shvcode = 'S';    /* Set variable from given value */
 shvblk.shvnama = variable_name;
 shvblk.shvnaml = strlen(variable_name);
 shvblk.shvvala = variable_value;
 shvblk.shvvall = strlen(variable_value);

 irxexcomrc = (*irxexcom) (
                           "IRXEXCOM",
                           &zero,
                           &zero,
                           LASTPARM(&shvblk),
                           &envblockptr,
                           LASTPARM(&retcode)
                          );

 fprintf(stderr,"Return code from IRXEXCOM is %d (%d)\n",
                 irxexcomrc, retcode);

 return (irxexcomrc == 0 ? TRUE : FALSE);

}

/* ================================================================ */

static void
rexx_queue(char *qline)
{
 int retcode  = 0;
 int qlen     = strlen(qline);

 retcode = (*irxstk)(
                     "QUEUE   ",
                     &qline,
                     &qlen,
                     LASTPARM(&retcode)
                    );

 fprintf(stderr,"IRXSTK returned code %d\n",retcode);

 return;
}

/* ================================================================ */

static char *
rexx_pull()
{
 int   retcode  = 0;
 char *string   = NULL;
 char *qline    = NULL;
 int   qlen     = 0;

 retcode = (*irxstk)(
                     "PULL    ",
                     &qline,
                     &qlen,
                     LASTPARM(&retcode)
                    );

 fprintf(stderr,"IRXSTK returned code %d\n",retcode);

 if (qline) {
   string = (char *)malloc(qlen+1);
   if (!string) {
     fprintf(stderr,"Could not malloc %d bytes for pulled string\n",
       qlen+1);
     return NULL;
   }
   memcpy(string,qline,qlen);
   string[qlen] = '\0';
 }
 return string;
}


/* ================================================================ */

static int
rexx_queued()
{
 int   queued   = 0;
 int  retcode   = 0;

 queued = (*irxstk)(
                    "QUEUED  ",
                    0,
                    0,
                    LASTPARM(&retcode)
                   );

 return retcode;
}


/* ================================================================ */

static Rexxfun
load_it(char *module)
{
 int (*funcp)();

 funcp = (Rexxfun)fetch(module);
 if (!funcp) fprintf(stderr,"Cannot fetch %s\n",module);
 return funcp;

}

/* ================================================================ */

int
main(int argc, char **argv) {
 char              *command;
 char              *line;

   command = argv[1];

   fprintf(stderr,"Command:'%s'\n",command);

   envblockptr = (PARAMETER)NULL;
   irxexcom = load_it("IRXEXCOM");
   irxexec  = load_it("IRXEXEC");
   irxinit  = load_it("IRXINIT");
   irxload  = load_it("IRXLOAD");
   irxstk   = load_it("IRXSTK");
   irxterm  = load_it("IRXTERM");

   if (!(irxexcom&&irxexec&&irxinit&&irxload&&irxstk&&irxterm))
      return 16;

   call_irxinit  (NULL);
   call_irxload  (command);
   dump_envblock (envblockptr);
   call_irxexcom (NULL);
   rexx_queue    ("Stacked line number one");
   rexx_queue    ("Stacked line number two");
   rexx_queue    ("Stacked line number three");
   dump_envblock (envblockptr);
   call_irxexec  (command);
   dump_envblock (envblockptr);
   call_irxload  (NULL);
   fprintf(stderr,"There are %d lines queued.\n",rexx_queued());
   while ((line = rexx_pull()) != NULL)
         fprintf(stderr,"Pulled line:'%s'\n",line);
   call_irxterm  (NULL);

   release("IRXEXCOM");
   release("IRXEXEC");
   release("IRXINIT");
   release("IRXLOAD");
   release("IRXSTK");
   release("IRXTERM");

   return 0;

}
./ ADD NAME=REXXJCL  0100-07332-07332-0900-00030-00030-00000-SEB
#pragma linkage(IRXJCL,OS)
#pragma runopts(noargparse,noredir)
#include <stdio.h>

int
main(int argc, char **argv) {
 int                rexxrc;
 int              (*irxjcl)();
 char               parm[257];

   printf("Command:'%s'\n",argv[1]);

   irxjcl = (int(*)())fetch("IRXJCL");
   if (!irxjcl) {
     printf("Cannot fetch IRXJCL\n");
     return 16;
   }

   *(short *)parm = strlen(argv[1]);
   memcpy(parm+2,argv[1],strlen(argv[1]));

   rexxrc = (*irxjcl)(parm);

   printf("Return code from exec is %d\n", rexxrc);

   release("IRXJCL");

   return rexxrc;

}
./ ADD NAME=SIGFAIL  0100-07332-07332-0900-00081-00081-00000-SEB

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

static void
handler() {
 printf("SIGINT handler has been called.\n");
 exit(8);
}

static int
ask(question)
char *question;
{
 char ans[81];

 for (;;) {
   printf("%s",question);
   fgets(ans,79,stdin);
   switch (ans[0]) {
     case 'y':
     case 'Y': return 1;
     case 'n':
     case 'N': return 0;
     default: printf("Bad answer, %s\n",ans);
              continue;
   }
 }
}

main(argc,argv)
int argc;
char **argv;
{
 int sigp;
 int loopp;
 int i;

 printf(
  "This program demonstrates that SIGINT is not handled on MVS.\n");
 printf(
  "It does NOT prove or disprove anything about attention handling\n");
 printf(
  "in C/370 in general, except possibly for how output to stdout\n");
 printf(
  "and stderr are affected by an attention interruption.\n\n");
 printf(
  "At the end of the program, a line of output is written to each\n");
 printf(
  "of the two output files.  If you see either one, that means that\n");
 printf(
  "C/370 has intercepted the attention, but you will observe that\n");
 printf(
  "it has not been handled by a SIGINT routine and it also has not\n");
 printf(
  "allowed the program to be terminated by the operating system.\n\n");

 sigp  = ask("Do you want to signal abort on interrupts? (y or n)");
 loopp = ask("Do you want to loop forever without output? (y or n)");

 if (sigp) {
   printf("Doing signal(SIGINT,handler)\n");
   if (signal(SIGINT,handler) == SIG_ERR)
       perror("Could not set SIGINT");
 }

 printf("OK, hit PA1 now\n");

 if (loopp) {
   for (;;) ;
 }
 else {
   for (i=0;i<5000;i++) {
    printf("I=%d\n",i);
   }
 }
 printf("I'm finished (on stdout)\n");
 fprintf(stderr,"I'm finished (on stderr)\n");
}

./ ADD NAME=SMTPDOG  0100-07332-07332-0900-00564-00564-00000-SEB
/* SMTPDOG = "SMTP do good" = "SMTPDO" with checking responses */
/* PORT 25 (SMTP) client - similar to "TELNET hostname 25" */

/*

 SMTP commands and expected responses:

HELP       214
HELO       250
MAIL FROM  250
RCPT TO    250
DATA       354
.          250
QUIT       221

*/

#define _TCP31_PROTOS

#include <bsdtypes.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include <manifest.h>
#include <socket.h>
#include <in.h>
#include <netdb.h>

#define  Bool                 int
#ifndef  TRUE
#define  TRUE                 (Bool)1
#endif
#ifndef  FALSE
#define  FALSE                (Bool)0
#endif
#define  NULL_CHARACTER       ('\0')
#define  READ_BYTES           1024
#define  MYBUF_INITIAL_SIZE   1024
#define  MYBUF_INCREMENT      512
#define  IBUF_MSGSIZE         1024
#define  OBUF_MSGSIZE         1024
#define  SOCKET_GETCHAR_ERROR (-1)
#define  SOCKET_NO_MORE       (-2)
#define  SOCKET_READ_NOTHING  (-3)

#define  ASCII_CR             (0x0d)
#define  ASCII_LF             (0x0a)
#define  EBCDIC_CR            ('\r')
#define  EBCDIC_LF            (0x25)

#ifdef MVS
#define  etoa(x)              ebcdictoascii[x]
#define  atoe(x)              asciitoebcdic[x]
#define  ebcdictoascii        ebcdicto
#define  asciitoebcdic        asciitoe
extern   char                 ebcdictoascii[];
extern   char                 asciitoebcdic[];
#endif

#ifdef MVSOE
#define  etoa(x)              __etoa(x)
#define  atoe(x)              __atoe(x)
#endif

enum server_retval {
                    SERVER_OK,
                    SERVER_READ_ERROR,
                    SERVER_BUFFER_ERROR,
                    SERVER_NO_MORE,
                    SERVER_READ_NOTHING
                   };

 /********************************************************************/
 /*                                                                  */
 /* Error handler.                                                   */
 /*                                                                  */
 /********************************************************************/

static void
errhand(whats,whatn)
char            *whats;
int              whatn;
{
 fprintf(stderr,"\nError: %s returned %d\n",whats,whatn);
 return;
}

 /********************************************************************/
 /*                                                                  */
 /* Input one character from the server.                             */
 /*                                                                  */
 /********************************************************************/

static int
socket_getchar(ns,dont_read)
 int                   ns;
 Bool                  dont_read;
 {
  static int           bytes_returned = 0;
  static char          g_buf[READ_BYTES];
  static int           g_buf_index = -1;
         int           readrc;

  if (g_buf_index == -1 || g_buf_index >= bytes_returned-1) {
    g_buf_index = -1;
    if (dont_read) return(SOCKET_NO_MORE);
    else {
      readrc = read(ns, g_buf, READ_BYTES);
      if (readrc == -1)     return SOCKET_GETCHAR_ERROR;
      else if (readrc == 0) return SOCKET_READ_NOTHING;
      else {
            g_buf[readrc] = NULL_CHARACTER;
            bytes_returned = readrc;
           }
    }
  }
  return g_buf[++g_buf_index];
 }

 /********************************************************************/
 /*                                                                  */
 /* Input one line of data from the server.                          */
 /*                                                                  */
 /********************************************************************/

static enum server_retval
socket_in(ns,i_buf,n_bytes,delimiter,dont_read)
 int                   ns;
 char                 *i_buf;
 int                   n_bytes;
 char                  delimiter;
 Bool                  dont_read;
 {
  int                  i_buf_index;
  int                  character;

  /* Get characters from the server until delimiter is reached. */

  i_buf_index = 0;
  while ((character = socket_getchar(ns,dont_read)) != delimiter) {
    if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);
    if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);
    if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_NOTHING);
    if (i_buf_index >= n_bytes) {
      fprintf(stderr,"Warning: The buffer passed to socket_in overflowed.\n");
      fprintf(stderr," More than %d bytes collected without %2.2x seen.\n",
             n_bytes,delimiter);
      fprintf(stderr," Returning what we have so far.\n");
      break;
    }
    i_buf[i_buf_index++] = (unsigned char)character;
  }
  i_buf[i_buf_index] = NULL_CHARACTER;

#ifdef MVS
  {
   int i;
   for (i=0;i<i_buf_index;i++) i_buf[i] = atoe(i_buf[i]);
  }
#endif

#ifdef MVSOE
  __atoe(i_buf);  /* translate from ASCII to EBCDIC */
#endif

  return(SERVER_OK);
 }

 /********************************************************************/
 /*                                                                  */
 /* Output one line of data to the server.                           */
 /*                                                                  */
 /********************************************************************/

static void
socket_out(ns,o_buf,n_bytes)
 int                   ns;
 char                 *o_buf;
 int                   n_bytes;
 {
  int                  writrc;
  int                  needed_bytes;
  static char         *mybufp = NULL;
  static int           mybufl = 0;

  needed_bytes = n_bytes+2;

  if (mybufp == NULL) {
    mybufl = MYBUF_INITIAL_SIZE;
    mybufp = (char *)malloc(mybufl);
  }

  if (mybufl < needed_bytes) {
    mybufl = needed_bytes + MYBUF_INCREMENT;
    free(mybufp);
    mybufp = (char *)malloc(mybufl);
  }

  if (mybufp == NULL) {
    fprintf(stderr,"\nWhoops, failed to allocate output buffer!\n");
    abort();
  }

  memcpy(mybufp,o_buf,n_bytes);

  mybufp[n_bytes] = NULL_CHARACTER;

#ifdef MVS
  {
   int i;
   for (i=0;i<=n_bytes+1;++i) mybufp[i] = etoa(mybufp[i]);
  }
#endif

#ifdef MVSOE
  __etoa(mybufp);
#endif

  mybufp[n_bytes  ] = ASCII_CR;
  mybufp[n_bytes+1] = ASCII_LF;

  writrc = write(ns, mybufp, n_bytes+2);
  if (writrc < 0) errhand("write",writrc);

  return;
 }

 /********************************************************************/
 /*                                                                  */
 /* Send something to the server.                                    */
 /*                                                                  */
 /********************************************************************/

static void
send_it(s,string,variable,echo)
int   s;
char *string;
char *variable;
Bool  echo;
{
 char               ibuf[IBUF_MSGSIZE];    /* the input buffer       */

 if (string) {

  sprintf(ibuf,string,variable);
  if (echo) {
    fprintf(stderr,"Sending:'%s'\n",ibuf);
  }
  socket_out(s,ibuf,strlen(ibuf));

 }

}

 /********************************************************************/
 /*                                                                  */
 /* Receive something from the server.                               */
 /*                                                                  */
 /********************************************************************/

static Bool
receive_it(s,obuf,verbose)
int   s;
char *obuf;
Bool  verbose;
{
 enum server_retval socket_in_rc;
 char              *cp;
 Bool               got_something_from_server;

 socket_in_rc = socket_in(s,obuf,OBUF_MSGSIZE, ASCII_LF, FALSE);

 switch (socket_in_rc) {
  case SERVER_OK:
            got_something_from_server = TRUE;
            break;
  case SERVER_READ_NOTHING:
            got_something_from_server = FALSE;
            break;
  case SERVER_NO_MORE:
            got_something_from_server = FALSE;
            break;
  case SERVER_READ_ERROR:
            fprintf(stderr,"\n\nRead error, lost connection.\n\n");
            got_something_from_server = FALSE;
            break;
  case SERVER_BUFFER_ERROR:
            fprintf(stderr,"\n\nServer buffer error\n\n");
            got_something_from_server = FALSE;
            break;
 };

 if (!got_something_from_server) return FALSE;

 cp = obuf + strlen(obuf) - 1;
 if (cp >= obuf) {
   if (*cp == EBCDIC_CR) *cp = NULL_CHARACTER;
 }
 if (verbose) {
  printf("%s\n",obuf);
 }

 return TRUE;

}

 /********************************************************************/
 /*                                                                  */
 /* Tell server.                                                     */
 /*                                                                  */
 /********************************************************************/

static void
tell_server(s,obuf,textmode,verbose,string,variable)
int   s;
char *obuf;
Bool  textmode;
Bool  verbose;
char *string;
char *variable;
{

 send_it(s,string,variable,(!textmode && verbose));

 if (!textmode) {
  while (1) {
   receive_it(s,obuf,verbose);
   if (strlen(obuf) > 3) {
     if (obuf[3] == '-') continue;
   }
   break;
  }
 }

}

 /********************************************************************/
 /*                                                                  */
 /* Send file.                                                       */
 /*                                                                  */
 /********************************************************************/

static int
send_file(s,obuf,filename,hostname,verbose,quickquit)
int   s;
char *obuf;
char *filename;
char *hostname;
Bool  verbose;
Bool  quickquit;
{
 int   exitrc = 0;
 FILE *fp;
 char *bp;
 char *cp;
 Bool  textmode = FALSE;
 Bool  piped    = FALSE;
 Bool  errors   = FALSE;
 Bool  needtext = FALSE;
 char *er;
 char  buf[2048];

 if (!filename) {
  filename = "<standard input>";
  piped = TRUE;
  fp = stdin;
 }
 else {
  fp = fopen(filename,"r");
 }
 if (!fp) {
   perror(filename);
   return 12;
 }

 tell_server (s,obuf,FALSE,verbose,NULL,"");

 textmode = FALSE;

 for (;;) {
   errors = FALSE;
   needtext = FALSE;
   memset(buf,0,2048);
   bp = buf;
   if (!fgets(bp, sizeof(buf), fp)) break;
   if (feof(fp)) bp = "QUIT";
   if (ferror(fp)) {
     fprintf(stderr,"*** Error - read error on file: %s", filename);
     break;
   }
   if ((cp = strchr(bp,'\n'))) *cp = NULL_CHARACTER;
   if (!strcmp(bp,".")) textmode = FALSE;
   tell_server (s,obuf,textmode,verbose,"%s",bp);
   if (textmode) {
     /* */
   }
   else {
    if      (!memcmp(bp,"HELO",4))  er = "250";
    else if (!memcmp(bp,"HELP",4))  er = "214";
    else if (!memcmp(bp,"HELO",4))  er = "250";
    else if (!memcmp(bp,"MAIL",4))  er = "250";
    else if (!memcmp(bp,"RCPT",4))  er = "250";
    else if (!memcmp(bp,"DATA",4)) {er = "354"; needtext = TRUE;}
    else if (!memcmp(bp,"QUIT",4))  er = "221";
    else er = NULL;
   }
   if (!memcmp(obuf,"354",3))       textmode = TRUE;
   if (!memcmp(obuf,"250",3))       textmode = FALSE;
   if (!memcmp(obuf,"221",3))       break;
   if (!textmode) {
    if (*obuf != '2')               errors = TRUE;
    if (er && memcmp(obuf,er,3))    errors = TRUE;
   }

   if (errors) {
     exitrc = 1;
     fprintf(stderr,"An error occurred while communicating with the\n");
     fprintf(stderr,"SMTP server.  The command was:\n");
     fprintf(stderr,"\n%s\n\n", bp);
     fprintf(stderr,"And the response from the server was:\n");
     fprintf(stderr,"\n%s\n\n", obuf);
     if (quickquit || needtext) {
      tell_server (s,obuf,FALSE,verbose,"QUIT","");
      break;
     }
   }

 }

 if (!piped) (void)fclose(fp);

 return exitrc;

}
static void
usage(x)
char *x;
{

 fprintf(stderr,"Usage: %s [-v] [-q] [-m mailhostname] [file]\n",x);

}

 /********************************************************************/
 /*                                                                  */
 /* Client routine.                                                  */
 /*                                                                  */
 /********************************************************************/

int
main(argc,argv)
int               argc;
char            **argv;
{
 int                exitrc = 0;
 int                port = 25;      /* port for the SMTP protocol  */
 int                i;
 int                j;
 char              *hostname  = "mailhost";
 char              *mailfrom  = NULL;
 char              *mailto    = NULL;
 char              *filename  = NULL;
 char              *cp;
 int                nbytes;         /* size of message buffer        */
 int                hostaddress;
 char               client_hostname[80];
 struct hostent    *hp;
 struct hostent    *server_hostent;
 struct sockaddr_in consock;        /* used by connect               */
 char               obuf[OBUF_MSGSIZE];    /* the output buffer      */
 int                consocklen;     /* used by connect               */
 int                s;              /* the socket descriptor         */
 int                backlog;        /* queue length                  */
 int                listrc;         /* the return code from listen   */
 int                connrc;         /* the return code from connect  */
 int                readrc;         /* the return code from read     */
 int                writrc;         /* the return code from write    */
 Bool               argerror = FALSE;
 Bool               verbose = FALSE;
 Bool               quickquit = FALSE;
 Bool               expecting_mailhost = FALSE;

 setenv("_EDC_ZERO_RECLEN","Y",1); /* allow zero-length input records*/

 hostname = "mailhost";

 for (i=1; i<argc; i++) {
  if (expecting_mailhost) {
   expecting_mailhost = FALSE;
   hostname = argv[i];
  }
  else if (argv[i][0] == '-') {
   for (j=1; argv[i][j]; j++) {
    switch (argv[i][j]) {
     case 'q':   quickquit = TRUE; break;
     case 'v':   verbose   = TRUE; break;
     case 'm':   expecting_mailhost = TRUE; break;
     default:
                 fprintf(stderr,"%s: invalid option %c\n",
                                argv[0], argv[i][j]);
                 argerror = TRUE;
    }
   }
  }
  else {
   if (filename) {
    fprintf(stderr,"%s: too many filenames specified\n",argv[0]);
    argerror = TRUE;
   }
   else {
    filename = argv[i];
   }
  }
 }

 if (expecting_mailhost) {
  fprintf(stderr,"%s: the -m flag must be followed by a mail host name.\n",
                 argv[0]);
  argerror = TRUE;
 }

 if (argerror) {
  usage(argv[0]);
  exit(1);
 }

 port = 25;

 server_hostent = gethostbyname(hostname);
 if (!server_hostent) {
    fprintf(stderr,"Error:  gethostbyname doesn't know host %s\n",hostname);
    exit(12);
 }
 if (!server_hostent) errhand("gethostbyname for server hostname",0);

 consock.sin_family = AF_INET;
 consock.sin_port = port;
 consock.sin_addr.s_addr = *((int *)server_hostent->h_addr);

 gethostname(client_hostname,sizeof(client_hostname));
 hp = gethostbyname(client_hostname);
 if (!hp) errhand("gethostbyname for client hostname",0);
 hostaddress = *((int *)(hp->h_addr_list[0]));

 s = socket(AF_INET, SOCK_STREAM, 0);
 if (s < 0) errhand("socket creation",s);

 consocklen = sizeof(consock);
 connrc = connect(s, &consock, consocklen);

 if (connrc < 0) {
   errhand("connect",connrc);
   exit(connrc);
 }

 exitrc = send_file (s,obuf,filename,hostname,verbose,quickquit);

 close(s);

 exit(exitrc);

}

./ ADD NAME=TSOPREF  0100-07332-07332-0900-00059-00059-00000-SEB
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

 struct tcb  {
              char           filler1[180];
              struct jscb   *tcbjscb;
             };

 struct jscb {
              char           filler1[264];
              struct pscb   *jscbpscb;
              char           filler2[ 80];
              struct jscb   *jscbact;
             };

 struct pscb {
              char           pscbuser [7];
              char           pscbusrl;
              char           filler1 [44];
              struct upt    *pscbupt;
             };

 struct upt  {
              char           filler1 [16];
              char           uptprefx [7];
              char           uptprefl;
             };

main() {
 char         userid[8];
 char         prefix[8];
 struct tcb  *tcbptr;
 struct pscb *pscbptr;
 struct upt  *uptptr;

 tcbptr  = *(struct tcb **)0x21c;
 pscbptr = tcbptr->tcbjscb->jscbact->jscbpscb;

 if (pscbptr == NULL) {
   printf("TSO is not active.\n");
   return;
 }

 uptptr  = pscbptr->pscbupt;

 memset(userid,0,8);
 memset(prefix,0,8);

 memcpy(userid,pscbptr->pscbuser,pscbptr->pscbusrl);

 memcpy(prefix,uptptr->uptprefx,uptptr->uptprefl);


 printf("TSO userid is '%s'\n",userid);
 printf("TSO prefix is '%s'\n",prefix);


}
./ ADD NAME=XGALLOC  0100-07332-07332-0900-00487-00487-00000-SEB

 /********************************************************************/
 /*                                                                  */
 /* Copyright (c) The Charles Stark Draper Laboratory, 1992, 1993    */
 /*                                                                  */
 /* This software is provided on an "AS IS" basis.  All warranties,  */
 /* including the implied warranties of merchantability and fitness, */
 /* are expressly denied.                                            */
 /*                                                                  */
 /* Provided this copyright notice is included, this software may    */
 /* be freely distributed and not offered for sale.                  */
 /*                                                                  */
 /* Changes or modifications may be made and used only by the maker  */
 /* of same, and not further distributed.  Such modifications should */
 /* be mailed to the author for consideration for addition to the    */
 /* software and incorporation in subsequent releases.               */
 /*                                                                  */
 /********************************************************************/

/*
 ***********************************************************************
 *                                                                     *
 * This is not a main program, nor a subroutine to be linked into an   *
 * existing program, but a routine which is to be called from a        *
 * REXX exec as follows:                                               *
 *                                                                     *
 *  dsn = "name.of.data.set"  -- or null to create a temporary         *
 *  dnn = "ddname"            -- or null to generate a unique one      *
 *  disp = "SHR"              -- or "OLD", "NEW", "FREE" or "DELETE"   *
 *  msg1 = ""                 -- to be set with an error message       *
 *  msg2 = ""                 -- to be set with an error message       *
 *                                                                     *
 *  address LINKMVS "XGALLOC DSN DDN DISP MSG1 MSG2"                   *
 *                                                                     *
 *  In addition to possibly updating the indicated variables, this     *
 *  routine returns a return code, which becomes the value of "RC".    *
 *                                                                     *
 *  The purpose of this routine is to provide a way for REXX execs     *
 *  to perform allocation and unallocation of data sets from a non-TSO *
 *  environment.  The LINKMVS (or ATTCHMVS) interface allows it to     *
 *  update the specified REXX variables by setting values for the      *
 *  passed parameters without calling REXX routines directly.          *
 *                                                                     *
 *  Use of this routine requires TSO/REXX 3.46 or higher.              *
 *                                                                     *
 ***********************************************************************
 */

#pragma environment(XGALLOC)
#pragma linkage(ikjeff18,OS)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <spc.h>

/* #define FETCH  */
#undef  FETCH

#define  Bool                 char
#ifndef  TRUE
#define  TRUE                 1
#endif
#ifndef  FALSE
#define  FALSE                0
#endif

#define  S99VRBAL  0x01             /* ALLOCATION                    */
#define  S99VRBUN  0x02             /* UNALLOCATION                  */
#define  S99VRBCC  0x03             /* CONCATENATION                 */
#define  S99VRBDC  0x04             /* DECONCATENATION               */
#define  S99VRBRI  0x05             /* REMOVE IN-USE                 */
#define  S99VRBDN  0x06             /* DDNAME ALLOCATION             */
#define  S99VRBIN  0x07             /* INFORMATION RETRIEVAL         */
#define  S99NOCNV  0x40             /* ALLOC FUNCTION-DO NOT USE AN  */
                                    /* EXISTING ALLOCATION TO SATISFY*/
                                    /* THE REQUEST                   */
#define  DALDDNAM   0x0001          /* DDNAME                        */
#define  DALDSNAM   0x0002          /* DSNAME                        */
#define  DALMEMBR   0x0003          /* MEMBER NAME                   */
#define  DALSTATS   0x0004          /* DATA SET STATUS               */
#define  DALNDISP   0x0005          /* DATA SET DISPOSITION          */
#define  DALTRK     0x0007          /* TRACK SPACE TYPE              */
#define  DALBLKLN   0x0009          /* BLOCK LENGTH                  */
#define  DALPRIME   0x000a          /* PRIMARY SPACE ALLOCATION      */
#define  DALSECND   0x000b          /* SECONDARY SPACE ALLOCATION    */
#define  DALDIR     0x000c          /* DIRECTORY BLOCK ALLOCATION    */
#define  DALSYSOU   0x0018          /* SYSOUT                        */
#define  DALSFMNO   0x001a          /* SYSOUT FORMS NUMBER           */
#define  DALCOPYS   0x001d          /* SYSOUT COPIES                 */
#define  DALUCS     0x0029          /* UNIVERSAL CHARACTER SET       */
#define  DALBLKSZ   0x0030          /* DCB BLOCKSIZE                 */
#define  DALDSORG   0x003c          /* DATA SET ORGANIZATION         */
#define  DALLRECL   0x0042          /* DCB LOGICAL RECORD LENGTH     */
#define  DALRECFM   0x0049          /* DCB RECORD FORMAT             */
#define  DALPERMA   0x0052          /* PERMANENTLY ALLOCATED ATTRIB  */
#define  DALRTDDN   0x0055          /* RETURN DDNAME                 */
#define  DALRTDSN   0x0056          /* RETURN DSNAME                 */
#define  DALRTORG   0x0057          /* RETURN D.S. ORGANIZATION      */
#define  DALSUSER   0x0058          /* SYSOUT REMOTE WORKSTATION     */
#define  DUNDDNAM   0x0001          /* DDNAME                        */
#define  DUNDSNAM   0x0002          /* DSNAME                        */
#define  DUNUNALC   0x0007          /* UNALLOC OPTION                */
#define  SHR        0x08
#define  NEW        0x04
#define  MOD        0x02
#define  OLD        0x01
#define  KEEP       0x08
#define  DELETE     0x04
#define  CATLG      0x02
#define  UNCATLG    0x01
#define  RECFM_F    0x80
#define  RECFM_V    0x40
#define  RECFM_U    0xc0
#define  RECFM_D    0x20
#define  RECFM_T    0x20
#define  RECFM_B    0x10
#define  RECFM_S    0x08
#define  RECFM_A    0x04
#define  RECFM_M    0x02
#define  RECFM_FB   (RECFM_F | RECFM_B)
#define  RECFM_VB   (RECFM_V | RECFM_B)
#define  DSORG_PS   0x4000
#define  DSORG_PO   0x0200

enum disposition {DISP_SHR,DISP_OLD,DISP_MOD,
                  DISP_NEW,DISP_KEEP,DISP_DELETE};

#define uppercase_in_place(C) {char *__cp;\
                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);}

#define copy_uppercase(A,B) {char *__cA,*__cB;\
                     for (__cA=A,__cB=B; *__cB;__cA++,__cB++)\
                         *__cA = toupper(*__cB);\
                     *__cA='\0';}

#define set2(A,B)   *(short *)(A) = B
#define set3(A,B)   memset(A,0,3); *(short *)(A+1) = B

struct _textunit {
                  unsigned short         key;
                  unsigned short         num;
                  struct {
                          unsigned short len;
                          char           prm[80];
                         }               ent;
                 };

struct varstring {
                  short   len;
                  char    text[1];
                 };

typedef struct _textunit TEXTUNIT;
typedef struct varstring VARSTRING;

/*--------------------------------------------------------------------*/

static void
allocfail(rc,p99,msg1,msg2)
int            rc;
__S99parms    *p99;
char          *msg1;
char          *msg2;
{
 int           zero = 0;
 unsigned int  dfid = 0x40320000;
 struct {
         short first_level_msg_len;
         short first_level_msg_offset;
         char  first_level_msg[251];
         short second_level_msg_len;
         short second_level_msg_offset;
         char  second_level_msg[251];
        }      dfbuffer;

 static int (*ikjeff18_pointer)() = NULL;

#ifndef FETCH
 extern int *ikjeff18();
#endif

 strcpy(msg1,"");
 strcpy(msg2,"");

 if (!ikjeff18_pointer) {
#ifdef FETCH
   ikjeff18_pointer = (int (*)())fetch("IKJEFF18");
#else
   ikjeff18_pointer = (int (*)())ikjeff18;
#endif
 }

 dfbuffer.first_level_msg_len = 4;
 dfbuffer.second_level_msg_len = 4;

 if (ikjeff18_pointer) {
   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {
     strcpy(msg1,"IKJEFF18 returned a nonzero return code");
   }
   if (dfbuffer.first_level_msg_len > 0) {
     strncpy(msg1, dfbuffer.first_level_msg,
                   dfbuffer.first_level_msg_len-4);
   }
   if (dfbuffer.second_level_msg_len > 0) {
     strncpy(msg2, dfbuffer.second_level_msg,
                   dfbuffer.second_level_msg_len-4);
   }
 }
 else {
#ifdef FETCH
   strcpy(msg1,"xgalloc cannot fetch IKJEFF18");
#else
   strcpy(msg1,"IKJEFF18 was not linked with xgalloc");
#endif
 }
 return;
}

/*--------------------------------------------------------------------*/

static void
setmsg(msgvar,string)
VARSTRING *msgvar;
char  *string;
{

 msgvar->len = strlen(string);
 memcpy(msgvar->text,string,msgvar->len);
 return;
}

/*--------------------------------------------------------------------*/

int
XGALLOC()
{
 VARSTRING      **reg1;
 VARSTRING       *dsnvar;
 VARSTRING       *ddnvar;
 VARSTRING       *dispvar;
 VARSTRING       *msg1var;
 VARSTRING       *msg2var;
 int              i;
 int              rc;
 int              disp99_1;
 int              disp99_2;
 Bool             unal;
 enum disposition disp;
 short            primary_allocation    = 0;
 short            secondary_allocation  = 0;
 short            directory_blocks      = 0;
 short            dsorg                 = 0;
 char             recfm                 = 0;
 short            lrecl                 = 0;
 short            blocksize             = 0;
 __S99parms       stuff99; /* No "struct", despite manual */
 TEXTUNIT        *return_dsname_tup = NULL;
 TEXTUNIT        *return_ddname_tup = NULL;
 TEXTUNIT        *tup [32];
 TEXTUNIT         tu  [32];
 char            *lparp;
 char            *rparp;
 char             dsname  [81];
 char             ddname   [9];
 char             dispname [9];
 char             member  [81];
 char             msg1   [256];
 char             msg2   [256];

 reg1 = (VARSTRING **)edcxregs(1);

 dsnvar  = reg1[0];
 ddnvar  = reg1[1];
 dispvar = reg1[2];
 msg1var = reg1[3];
 msg2var = reg1[4];

 memset((char *)&stuff99,0,sizeof(__S99parms));
 strcpy(msg1,"");
 strcpy(msg2,"");

 if (dsnvar->len > 56) {
   setmsg(msg1var,"DSNAME argument cannot be longer than 56");
   return 16;
 }
 if (ddnvar->len > 8) {
   setmsg(msg1var,"DDNAME argument cannot be longer than 8");
   return 16;
 }
 if (dispvar->len > 8) {
   setmsg(msg1var,"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE");
   return 16;
 }

 strncpy(dsname,dsnvar->text,dsnvar->len);
 strncpy(ddname,ddnvar->text,ddnvar->len);
 strncpy(dispname,dispvar->text,dispvar->len);
 uppercase_in_place(dsname);
 uppercase_in_place(ddname);
 uppercase_in_place(dispname);

 if      (!strcmp(dispname,"SHR"))    disp = DISP_SHR;
 else if (!strcmp(dispname,"OLD"))    disp = DISP_OLD;
 else if (!strcmp(dispname,"MOD"))    disp = DISP_MOD;
 else if (!strcmp(dispname,"NEW"))    disp = DISP_NEW;
 else if (!strcmp(dispname,"FREE"))   disp = DISP_KEEP;
 else if (!strcmp(dispname,"KEEP"))   disp = DISP_KEEP;
 else if (!strcmp(dispname,"DELETE")) disp = DISP_DELETE;
 else {
   setmsg(msg1var,"DISP must be SHR/OLD/MOD/NEW/FREE/KEEP/DELETE");
   return 16;
 }

 switch (disp) {
   case DISP_SHR:     unal=FALSE; disp99_1=SHR; disp99_2=KEEP; break;
   case DISP_OLD:     unal=FALSE; disp99_1=OLD; disp99_2=KEEP; break;
   case DISP_MOD:     unal=FALSE; disp99_1=MOD; disp99_2=CATLG; break;
   case DISP_NEW:     unal=FALSE; disp99_1=NEW; disp99_2=CATLG; break;
   case DISP_KEEP:    unal=TRUE; disp99_2=KEEP; break;
   case DISP_DELETE:  unal=TRUE; disp99_2=DELETE; break;
 }

 switch (disp) {
   case DISP_MOD:
   case DISP_NEW:
                 primary_allocation   = 100;
                 secondary_allocation = primary_allocation;
                 dsorg                = DSORG_PS;
                 recfm                = RECFM_VB;
                 lrecl                = 256;
                 blocksize            = 23440;
                 break;
 }

 strcpy(member,"");
 lparp = strchr(dsname,'(');
 rparp = strchr(dsname,')');
 if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\0')) {
   *lparp = '\0';            /* makes dsname the seq part only */
   *rparp = '\0';            /* turns member into a string     */
   strcpy(member, lparp+1);
 }

 stuff99.__S99RBLN   = 20;
 stuff99.__S99VERB   = unal ? S99VRBUN : S99VRBAL;
 stuff99.__S99FLAG1  = S99NOCNV << 8;
 stuff99.__S99ERROR  = 0;
 stuff99.__S99INFO   = 0;
 stuff99.__S99TXTPP  = tup;
 stuff99.__S99FLAG2  = 0;

 for (i=0; i<32; i++) tup[i] = &tu[i];

 i = 0;

 if (*dsname) {
   tu[i].key        = unal ? DUNDSNAM : DALDSNAM;
   tu[i].num        = 1;
   tu[i].ent.len    = strlen(dsname);
   copy_uppercase(tu[i].ent.prm,dsname);
   i++;
 }
 else if (!unal) {
   tu[i].key        = DALRTDSN;
   tu[i].num        = 1;
   tu[i].ent.len    = 44;
   memset(tu[i].ent.prm,' ',44);
   return_dsname_tup = &tu[i];
   i++;
 }
 if (*member) {
   tu[i].key        = DALMEMBR;
   tu[i].num        = 1;
   tu[i].ent.len    = strlen(member);
   copy_uppercase(tu[i].ent.prm,member);
   i++;
 }
 if (*ddname) {
   tu[i].key        = unal ? DUNDDNAM : DALDDNAM;
   tu[i].num        = 1;
   tu[i].ent.len    = strlen(ddname);
   copy_uppercase(tu[i].ent.prm,ddname);
   i++;
   if (!unal) {
     tu[i].key      = DALPERMA;
     tu[i].num      = 0;
     i++;
   }
 }
 else if (!unal) {
   tu[i].key        = DALRTDDN;
   tu[i].num        = 1;
   tu[i].ent.len    = 8;
   memset(tu[i].ent.prm,' ',8);
   return_ddname_tup = &tu[i];
   i++;
 }
 if (unal) {
   tu[i].key        = DUNUNALC;
   tu[i].num        = 0;
   i++;
 }
 else {
   tu[i].key        = DALSTATS;
   tu[i].num        = 1;
   tu[i].ent.len    = 1;
   tu[i].ent.prm[0] = disp99_1;
   i++;
   tu[i].key        = DALNDISP;
   tu[i].num        = 1;
   tu[i].ent.len    = 1;
   tu[i].ent.prm[0] = disp99_2;
   i++;
 }
 if (recfm) {
   tu[i].key        = DALRECFM;
   tu[i].num        = 1;
   tu[i].ent.len    = 1;
   tu[i].ent.prm[0] = recfm;
   i++;
 }
 if (lrecl) {
   tu[i].key        = DALLRECL;
   tu[i].num        = 1;
   tu[i].ent.len    = 2;
   set2(tu[i].ent.prm,lrecl);
   i++;
 }
 if (blocksize) {
   tu[i].key        = DALBLKSZ;
   tu[i].num        = 1;
   tu[i].ent.len    = 2;
   set2(tu[i].ent.prm,blocksize);
   i++;
 }
 if (blocksize) {
   tu[i].key        = DALBLKLN;
   tu[i].num        = 1;
   tu[i].ent.len    = 3;
   set3(tu[i].ent.prm,blocksize);
   i++;
 }
 if (primary_allocation) {
   tu[i].key        = DALPRIME;
   tu[i].num        = 1;
   tu[i].ent.len    = 3;
   set3(tu[i].ent.prm,primary_allocation);
   i++;
 }
 if (secondary_allocation) {
   tu[i].key        = DALSECND;
   tu[i].num        = 1;
   tu[i].ent.len    = 3;
   set3(tu[i].ent.prm,secondary_allocation);
   i++;
 }
 if (dsorg) {
   tu[i].key        = DALDSORG;
   tu[i].num        = 1;
   tu[i].ent.len    = 2;
   set2(tu[i].ent.prm,dsorg);
   i++;
 }

 tup[i] = (void *)0x80000000;

 rc = svc99(&stuff99);

 if (rc == 0) {
   if (return_dsname_tup) {
     memcpy(dsnvar->text,(char *)return_dsname_tup->ent.prm,64);
     dsnvar->len = return_dsname_tup->ent.len;
   }
   if (return_ddname_tup) {
     memcpy(ddnvar->text,(char *)return_ddname_tup->ent.prm,8);
     ddnvar->len = return_ddname_tup->ent.len;
   }
 }
 else {
   allocfail(rc,&stuff99,msg1,msg2);
 }
 setmsg(msg1var,msg1);
 setmsg(msg2var,msg2);
 return rc;
}

./ ADD NAME=XPASTE   0100-07332-07332-0900-00087-00087-00000-SEB

#include <stdio.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>


#ifdef MVS
#define  LF           0x25
#else
#define  LF           0x0a
#endif

int
main(argc, argv)
int  argc;
char **argv;
{
    Display       *mydisplay;
    int            nbytes_return;
    char          *bytes_return;
    short          b;
    char          *server;
    int            buffer;

 /* if (argc <= 1) {
  *  fprintf(stderr,"%s: A display host must be specified.\n",
  *                 argv[0]);
  *  exit(1);
  * }
  */
 /* If no display given, use the display in XWINDOWS.DISPLAY. */

    server = (argc > 1) ? argv[1] : NULL;

    mydisplay = XOpenDisplay(server);

    if (mydisplay == NULL) {
        fprintf(stderr, "%s: unable to open display '%s'\n",
                        argv[0], XDisplayName(server));
        exit(1);
    }

    bytes_return = XFetchBytes(mydisplay, &nbytes_return);

    if (bytes_return) {
      for (b = 0; b < nbytes_return; b++) {
        char bp = bytes_return[b];
        switch (bp) {
          case LF:   putchar('\n');
                     break;
          default:
                     putchar(bp);
                     break;
        }
      }
    }
    else
         fprintf(stderr,"%s: Nothing in %s's cut buffer.\n",
                        argv[0],XDisplayName(server));

    if (bytes_return) XFree(bytes_return);

 /*
  * for (buffer = 0; buffer < 8; buffer++) {
  *   bytes_return = XFetchBuffer(mydisplay, &nbytes_return, buffer);
  *   if (bytes_return) {
  *     printf("\nContents of cut buffer %d:\n\n",buffer);
  *     for (b = 0; b < nbytes_return; b++) {
  *       switch (bytes_return[b]) {
  *         case 0x25: printf("\n");
  *                    break;
  *         default:
  *                    printf("%c",bytes_return[b]);
  *                    break;
  *       }
  *     }
  *   }
  *   else
  *        fprintf(stderr,"\nNothing in cut buffer %d.\n",buffer);
  *   if (bytes_return) XFree(bytes_return);
  * }
  */

    XCloseDisplay(mydisplay);

    return 0;
}
./ ADD NAME=X800     0100-07332-07332-0900-00083-00083-00000-SEB
#define LOOPFOR(i) for(i=0;i<3;i++)
#include <stdio.h>
char choices[10][3];
main(argc,argv)
 int argc;
 char **argv;
{
 char number[10];
 int i;
 int j;
 char *letters();
 void prtword();

 if (argc != 2) {
   fprintf(stderr,"Exactly 1 argument required.\n");
   return;
 }
 else strcpy(number,argv[1]);
 printf("For number: %s\n",number);
 for (i=0; i<strlen(number); i++) {
  strcpy(choices[i],letters(number[i]));
 }
{int i1,i2,i3,i4,i5,i6,i7;
 int output_count = 0;
 LOOPFOR(i1)
 LOOPFOR(i2)
 LOOPFOR(i3)
 LOOPFOR(i4)
 LOOPFOR(i5)
 LOOPFOR(i6)
 LOOPFOR(i7)
     prtword(i1,i2,i3,i4,i5,i6,i7,&output_count);
 }
 printf("\n");
}

void prtword(one, two, three, four,
             five, six, seven, count)
     int one,two,three,four,five,six,seven;
     int *count;
{
 printf("%c%c%c%c%c%c%c ",choices[0][one],choices[1][two],
        choices[2][three],choices[3][four],choices[4][five],
        choices[5][six], choices[6][seven]);
 if ((*count += 8) > 79) {
     printf("\n");
     *count = 0;
   }
 }

 char *letters(n) int n; {
  char result[3];
  switch(n) {
     case '2':
      strcpy(result,"ABC");
      break;
     case '3':
      strcpy(result,"DEF");
      break;
     case '4':
      strcpy(result,"GHI");
      break;
     case '5':
      strcpy(result,"JKL");
      break;
     case '6':
      strcpy(result,"MNO");
      break;
     case '7':
      strcpy(result,"PRS");
      break;
     case '8':
      strcpy(result,"TUV");
      break;
     case '9':
      strcpy(result,"WXY");
      break;
     default:
      strcpy(result,"?!>");
    }
  return result;
}

