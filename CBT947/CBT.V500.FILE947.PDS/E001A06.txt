Automating the VSE to PC download process

We needed a way to move VSE-generated data from the 4381
to a PC application without operator intervention.  The data is
generated seven days a week, so data from Saturday and
Sunday must be available to the user on Monday.  The steps
outlined below were taken.


STEP ONE

A VSE COBOL program was written to create the data
required for the user.  Three ESDS VSAM files are deleted and
defined every day, then the COBOL program writes the data to
these files.  Later in the JCL job stream another COBOL
program punches a one-line file to the VSE punch queue.  The
VSE punch queue has been defined, at VSE IPL time, to spool
the specific punch class to the VM punch queue.


STAGE TWO

Create the punch member.

/*
*  STEP 56.5 -- PUNCHJOB - PUNCH
* $$ PUN CLASS=O,DISP=D
// ASSGN SYS007,SYSPCH
// EXEC PUNCHJOB,SIZE=150K
/*


STAGE THREE

Use the VSE command to set up punch spooling to VM.

START PUN,00D,0,,VM


STAGE FOUR

In order to move data to CMS, a service machine, SMACH, is
autologged every morning using VMUTIL.  The service
machine has a series of EXECs that search for the VM punch
member, move the ESDS VSAM data to CMS, and delete the
oldest CMS members.  The service machine then logs itself
off.


STAGE FIVE

Use the EXEC to check for punch member and to move data to
CMS.

/* EXEC TO CHECK FOR PUNCH RECORD EVERY 1/2 HOUR AFTER START */
SIGNAL FIRSTRD
RESTART:
CP SLEEP 30 MIN
FIRSTRD:
CP SPOOL CON CLOSE
PUR PRT ALL
CP SPOOL CON START
CP Q PUN ALL
CP SPOOL CON CLOSE
EXECIO 2 CP '( MARGINS 1 80 LIFO STRING QUERY PRT ALL * '
PULL REC
  SPOOLID1 = SUBSTR(REC,10,4)
TRANSFER PRT SPOOLID1 TO SMACH RDR
'RECEIVE' SPOOLID1 'CON LIST (NOLOG REPLACE'
DROPBUF
COUNT = 1
/* PROCESS CON LIST FILE                              */
AGAIN:
COUNT = COUNT + 1
EXECIO 1 DISKR CON LIST A COUNT
IF RC¬= 0 THEN SIGNAL OUT
  PULL REC
  NOFILES = SUBSTR(REC,1,2)
  SYSNAME = SUBSTR(REC,1,7)
  SPOOLID = SUBSTR(REC,10,4)
  FNAME   = SUBSTR(REC,54,5)
  FTYPE   = SUBSTR(REC,64,8)
  DIST    = SUBSTR(REC,73,8)
/* CHECK TO SEE IF PUN HAS ANY FILES */
  IF NOFILES = 'NO'
     THEN SIGNAL RESTART
  IF SPOOLID = 'FILE'
     THEN SIGNAL AGAIN
/* CHECK TO SEE IF CORRECT SYSTEM NAME  */
  IF SYSNAME ¬= 'DOSMACH '
     THEN SIGNAL AGAIN
/* CHECK TO SEE IF FILE NAME IS XXO28 */
  IF FNAME ¬= 'XXO28'
     THEN SIGNAL AGAIN
/* RECEIVE THE FILE AND CHECK THE 4TH RECORD FOR XXO28*/
PROCESS:
DROPBUF
TRANSFER SYSNAME PUN  SPOOLID TO SMACH RDR
'RECEIVE' SPOOLID 'XXO28 CARD (NOLOG'
EXECIO 1 DISKR XXO28 CARD A 4
PULL CREC
GOOD_NAME = SUBSTR(CREC,1,5)
IF GOOD_NAME ¬= 'XXO28'
   THEN SIGNAL AGAIN
ERASE XXO28 CARD
DROPBUF
EXEC XX82DOWN
SET DOS OFF
EXEC XX82B
EXEC XX82C
EXEC XX82S
LOGOFF
EXIT
OUT:
DROPBUF
SIGNAL RESTART


STAGE SIX

Use the EXEC to move data from an ESDS VSAM file to a
CMS file.

/* XX82DOWN LINKS EXEC             *
 * ACCESS THE VSAM MASTER CATALOG  */
GLOBAL TXTLIB COBLIBVS CMSLIB SYNCSORT
GLOBAL MACLIB OSVSAM OSMACRO OSMACRO1 CMSLIB
SET EMSG ON;
CP LINK MACH 128 128 RR MACH-PASSWORD
CP LINK MACH 424 424 RR MACH-PASSWORD
ACC 128 W
ACC 424 N
DLBL IJSYSCL W DSN PROD.CORE.IMAGE.LIBRARY.A
DLBL IJSYSCT W DSN VSAM.MASTER.CATALOG
DLBL VSAMCAT N DSN VSAM.CATALOG
DLBL INFILE1 N DSN FILE1.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT
DLBL INFILE2 N DSN FILE2.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT
DLBL INFILE3 N DSN FILE3.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT
FILEDEF OUTFILE1 DISK OUTFILE1 DATA A '(' RECFM F
FILEDEF OUTFILE2 DISK OUTFILE2 DATA A '(' RECFM F
FILEDEF OUTFILE3 DISK OUTFILE3 DATA A '(' RECFM F
LOAD XX82DOWN
START
REL W
DET 128
REL N
DET 424
EXIT


STAGE SEVEN

COBOL program used to create CMS files from ESDS VSAM
files.

  IDENTIFICATION DIVISION.
  PROGRAM-ID. 'XX82DOWN'.
  AUTHOR. D. KOSKIE.
  REMARKS.  PROGRAM TO READ VSAM ESDS FILE AND WRITE IT OUT
            AS A CMS FILE IN YOUR LIBRARY.
  DATE-WRITTEN.
  DATE-COMPILED.
  ENVIRONMENT DIVISION.
  CONFIGURATION SECTION.
  SOURCE-COMPUTER. IBM-370
  OBJECT-COMPUTER. IBM-370.
  SPECIAL-NAMES.
  INPUT-OUTPUT SECTION.
  FILE-CONTROL.
      SELECT   INFILE1 ASSIGN TO SYS007-AS-INFILE1
               FILE STATUS IS STAT-COND.
      SELECT   INFILE2 ASSIGN TO SYS008-AS-INFILE2
               FILE STATUS IS STAT-COND.
      SELECT   INFILE3 ASSIGN TO SYS009-AS-INFILE3
               FILE STATUS IS STAT-COND.
      SELECT   OUTFILE1 ASSIGN TO SYS010-3340-DA-OUTFILE1.
      SELECT   OUTFILE2 ASSIGN TO SYS011-3340-DA-OUTFILE2.
      SELECT   OUTFILE3 ASSIGN TO SYS012-3340-DA-OUTFILE3.
  DATA DIVISION.
  FILE SECTION.
  FD  INFILE1
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS INREC1
      RECORD CONTAINS 199 CHARACTERS.
***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.
  01  INREC1 PIC X(199).
  FD  INFILE2
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS INREC2
      RECORD CONTAINS 199 CHARACTERS.
***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.
  01  INREC2 PIC X(199).
  FD  INFILE3
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS INREC3
      RECORD CONTAINS 199 CHARACTERS.
***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.
  01  INREC3 PIC X(199).
  FD  OUTFILE1
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS OUTREC1
      RECORD CONTAINS 131 CHARACTERS.
  01  OUTREC1.
      05 FDATA1  PIC X(131).
  FD  OUTFILE2
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS OUTREC2
      RECORD CONTAINS 131 CHARACTERS.
  01  OUTREC2.
      05 FDATA2  PIC X(131).
  FD  OUTFILE3
      LABEL RECORDS ARE STANDARD
      DATA RECORD IS OUTREC3
      RECORD CONTAINS 131 CHARACTERS.
  01  OUTREC3.
      05 FDATA3  PIC X(131).
  WORKING-STORAGE SECTION.
  77  RLENGTH                   PIC S9(4) COMP VALUE ZERO.
  77  REC-COUNT                 PIC 9999999    VALUE ZERO.
  01  STAT-COND.
      05  STAT-COND1            PIC X VALUE SPACES.
      05  STAT-COND2            PIC X VALUE SPACES.
  01  WORKREC.
      05  FILLER                PIC X(68).
      05  MOVEREC               PIC X(131).
  PROCEDURE DIVISION.
      OPEN INPUT INFILE1, INFILE2, INFILE3
                         OUTPUT OUTFILE1, OUTFILE2,OUTFILE3.
      IF STAT-COND = '00' THEN NEXT SENTENCE
       ELSE DISPLAY 'BAD OPEN INPUT ' STAT-COND UPON CONSOLE
              GO TO BAD-PROG.
  READ-ANOTHER1.
      READ INFILE1 AT END
           DISPLAY 'RECORD COUNT '  REC-COUNT
           MOVE ZERO TO REC-COUNT
           GO TO READ-ANOTHER2.
      MOVE INREC1 TO WORKREC.
      MOVE MOVEREC TO OUTREC1.
      WRITE OUTREC1  INVALID KEY
      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE
              GO TO END-PROG.
      ADD 1 TO REC-COUNT.
***   IF REC-COUNT > 100
***        GO TO END-PROG.
      GO TO READ-ANOTHER1.
  READ-ANOTHER2.
      READ INFILE2 AT END
           DISPLAY 'RECORD COUNT '  REC-COUNT
           MOVE ZERO TO REC-COUNT
           GO TO READ-ANOTHER3.
      MOVE INREC2 TO WORKREC.
      MOVE MOVEREC TO OUTREC2.
      WRITE OUTREC2  INVALID KEY
      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE
              GO TO END-PROG.
      ADD 1 TO REC-COUNT.
***   IF REC-COUNT > 100
***        GO TO END-PROG.
      GO TO READ-ANOTHER2.
  READ-ANOTHER3.
      READ INFILE3 AT END
           DISPLAY 'RECORD COUNT '  REC-COUNT
           GO TO END-PROG.
      MOVE INREC3 TO WORKREC.
      MOVE MOVEREC TO OUTREC3.
      WRITE OUTREC3  INVALID KEY
      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE
              GO TO END-PROG.
      ADD 1 TO REC-COUNT.
***   IF REC-COUNT > 100
***        GO TO END-PROG.
      GO TO READ-ANOTHER3.
  END-PROG.
   CLOSE INFILE1 INFILE2 INFILE3 OUTFILE1 OUTFILE2 OUTFILE3.
  BAD-PROG.
      STOP RUN.


STAGE EIGHT

XX82B EXEC creates the correct CMS file and deletes the
oldest.  XX82C and XX82S are copies of XX82B.

/* XX82B LINKS EXEC                */
/* GET THE CURRENT DATE AND RENAME THE INPUT FILE */
DAY = DATE(U)
M1 = SUBSTR(DAY,1,2)
D1 = SUBSTR(DAY,4,2)
Y1 = SUBSTR(DAY,7,2)
FTYPE = M1||'-'||D1||'-'||Y1
COPY OUTFILE1 DATA A OUTFILE1 DATA A '(' REP PACK
RENAME OUTFILE1 DATA A XX82BLX FTYPE A
/* ERASE THE OLDEST XX82BLX FILE - LEAVE 7 VERSIONS */
AO = '(EXEC'
B1 = 'XX82BLX'
B2 = '*'
LISTFILE B1 B2 A1 AO
OPT = ' ( FINIS '
'EXECIO * DISKR' CMS EXEC A OPT
RECOUNT = QUEUED()
DROPBUF
IF RECOUNT < 8 THEN SIGNAL OUT
QUEUE 23 2 CH A 17 2 CH A 20 2 CH A
SSORT CMS EXEC A
DROPBUF
EXECIO 1 DISKR CMS EXEC A 1
PULL REC
 NAME = SUBSTR(REC,8,9)
 TYPE = SUBSTR(REC,17,8)
 CLASS = SUBSTR(REC,26,2)
ERASE NAME TYPE CLASS
OUT:
ERASE CMS EXEC A
TELL OPERATOR 'XX82BLX PROCESSING COMPLETE'
RETURN


STAGE NINE

The users must move the CMS data to the PC using a series of
EXECs.  The first EXEC creates a link to the data disk, then
creates a TDISK to move the data in unpacked format, and
does an automatic FLIST of the data disk.

/* DO THE LINKS TO SMACH SYSTEM */
REL Z
DET 500
CP DEFINE T3370 AS 500 BLK 10000
CLRSCRN
QUEUE "YES"
QUEUE "TDISK"
FORMAT 500 Z
CLRSCRN
SET MSG OFF
SET EMSG OFF
SET IMSG OFF
GETFMADR
SET MSG OFF
SET EMSG OFF
SET IMSG OFF
PULL . FMODE VADDR
CP LINK SMACH 191 VADDR RR MACH-PASSWORD
ACC VADDR FMODE
SET MSG ON
SET EMSG ON
SET IMSG ON
CLRSCRN
FLIST '*' '*' FMODE
SET MSG OFF
SET EMSG OFF
SET IMSG OFF
REL FMODE
CP DET VADDR
SET MSG ON
SET EMSG ON
SET IMSG ON


STAGE TEN

This EXEC moves the chosen CMS member to the TDISK in
unpacked format.  After the file is created on the TDISK, the
user switches over to the PC and executes the correct BAT file
for the actual data movement between CMS and PC.

/* COPY FROM SMACH DISK TO THE USERS TDISK */
PARSE UPPER ARG PNAME PMODE PTYPE STUFF
IF PNAME = XX82CARE THEN
    COPY PNAME PMODE PTYPE XX82CARE DATA Z '(' UNPACK REPLACE
IF PNAME = XX82CAID THEN
    COPY PNAME PMODE PTYPE XX82CAID DATA Z '(' UNPACK REPLACE
IF PNAME = XX82BLX THEN
    COPY PNAME PMODE PTYPE XX82BLX DATA Z '(' UNPACK REPLACE


STAGE ELEVEN

BAT file to move data from CMS to PC.

RECEIVE UTRAP.DAT XX82BLX DATA Z (ASCII CRLF


Donald Koskie
Systems Analyst (USA)


