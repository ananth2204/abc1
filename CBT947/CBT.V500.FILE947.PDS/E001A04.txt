Enhanced POWER queue display

I wrote the article Display the VSE/POWER queues that was
published in the VSE Yearbook 1990.  Since then I have made
many changes to the code.  These changes result in:

o      The ability to browse entries (and to copy the entries to a
      CMS disk).

o      Faster retrieval of the entries.

o      Displaying entries from shared and non-shared POWER.

o      It works with POWER 2.3 and 4.1.

POWER maintains a copy of the IJQFILE in storage when
running non-shared.  The program is slightly slower when
displaying entries from a non-shared POWER.  This is because
it has to read the IJQFILE sequentially and sort the entries
afterwards.  The sorting is done in storage.

The program does not use any disk space when running.  The
program must know where the IJQFILE and IJDFILE starts.
The VSE-id must own the mini-disks on which the IJQFILE
and IJDFILE resides.

The program runs under VM/SP HPO Version 5, and the
POWER files are on 3380s.


PWRQ EXEC

/** PWRQ - Display VSE/POWER queues.                                 **/
 Address COMMAND
 Arg Input
 Parse Value Diag(8,'QUERY TERM') With 'BRKKEY' Brkkey ','
 Parse Value Diag(8,'QUERY SET') With,
      'MSG' Msg ',' 'EMSG' Emsg ',' 'IMSG' Imsg ','
 Dosflag = Cmsflag('DOS')
'CP SET  MSG OFF'
'CP SET IMSG OFF'
'CP SET EMSG OFF'
'CP TERM BRKKEY NONE'
'SET DOS OFF'
 Push Input
'XEDIT PWRDUMMY' Userid() 'A (PROFILE PWRQPROF'
 Rx = Rc
'CP SET  MSG' Msg
'CP SET IMSG' Imsg
'CP SET EMSG' Emsg
'CP TERM BRKKEY' Brkkey
 If Dosflag = 1 Then 'SET DOS ON'
 Exit Rx


PWRQPROF XEDIT

/** PWRQPROF  - Profile for the VM VSE/POWER queue display program.  **/
      Trace Off
      Signal On Syntax
      Pull Vseid Command
      Parse Value Command With Queue ',' Rest
     'SET MSGLINE ON -2 1 OVERLAY'
     'SET MSGMODE ON'
     'SET CMDLINE OFF'
     'SET TOFEOF  OFF'
     'SET PREFIX  OFF'
     'SET SCALE   OFF'
     'SET LINEND  OFF'
     'SET REMOTE  ON'
     'SET ENTER   ONLY'
     'SET CTLCHAR -   ESCAPE'
     'SET CTLCHAR "   PROTECT RED   BLI    HIGH'
     'SET CTLCHAR #   PROTECT RED   NONE   HIGH'
     'SET CTLCHAR %   PROTECT WHI   NONE   HIGH'
     'SET CTLCHAR <   PROTECT BLU   NONE NOHIGH'
     'SET CTLCHAR ¬   PROTECT GREEN NONE NOHIGH'
     'SET CTLCHAR >   PROTECT YEL   NONE NOHIGH'
     'SET CTLCHAR &   PROTECT BLU   REV  NOHIGH'
     'SET CTLCHAR \ NOPROTECT GREEN NONE NOHIGH'
     'SET CTLCHAR / NOPROTECT WHITE NONE   HIGH'
     'SET CTLCHAR ! NOPROTECT GREEN NONE   HIGH'
     'EXTRACT /LSCREEN/NONDISP/'
     'SET NONDISP'
/**          D e f i n e   t h e   V S E   s y s t e m s             **/
/** Format of the 'Vse.' variable is:                                **/
/** Vse.VSENAME = 'VSEOWN QPASS QCUU QSTARTCC QSTARTHH               **/
/**                       DPASS DCUU DSTARTCC DSTARTHH'              **/
/**                                                                  **/
/** VSEOWN   -  VM-userid of mini-disk owner.                        **/
/** VSENAME  -  VM-userid of your VSE-system.                        **/
/** xPASS    -  Minidisk read-password to the VSE-system.            **/
/** QCUU     -  The minidisk CUU. (IJQFILE)                          **/
/** DCUU     -  The minidisk CUU. (IJDFILE)                          **/
/** QSTARTCC -  Start CYLINDER of the IJQFILE.                       **/
/** QSTARTHH -  Start  HEAD    of the IJQFILE.                       **/
/** DSTARTCC -  Start CYLINDER of the IJDFILE.                       **/
/** DSTARTHH -  Start  HEAD    of the IJDFILE.                       **/
      Vse. = ' '
      Vse.VSEIPO   = 'VSEPROD  VSEIPO   144  79  0 VSEIPO   146  60  0'
      Vse.VSETEST  = 'VSETEST  VSETEST  24E  63  0 VSETEST  24F 453  0'
      Vse.VSESERVB = 'VSESERVB VSESERVB 141   0  2 VSESERVB 140  67  0'
/**                     E n d  o f  d e f i n e                      **/
      Scale = '*!...+....'
      Scale = Scale''Space('1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 +',4,'.')
      Scale = Scale'...'Space('10 .+ 11 .+ 12 .+ 13 .+ 14 .+ 15 .+ 16',
                                                ' .+ 17 .+ 18 .+',3,'.')
      Nums = '0123456789'
      Alfa = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      Disp1 = 'DK*'
      Disp2 = 'HLAXY'
      Q_Head. =
      Q_Head.RDR = ' Reader Queue   P D C S Cards Rdr From     Date',
                                              ' Time  User-information'
      Q_Head.LST = ' List Queue     P D C S Pages CC Prt Form To-User',
                                        ' Date  Time  User-information'
      Q_Head.PUN = ' Punch Queue    P D C S Cards CC Pun Form To-User',
                                        ' Date  Time  User-information'
      Q_Head.XMT = ' Transmit Queue P D C I Lines To-Node  To-User',
                                        ' Date  Time  User-information'
      Q_Scroll = Lscreen.1 - 5
      D_Scroll = Lscreen.1 - 4
      ExitRc   = 0
      QCount   = 0
      Cursor.1 = 1
      Call Req_Init
      If Vseid = '?' | Queue = '?' Then Signal Help
New_Q:
      Chg_Q    = 'NO'
      Rec.     = '-¬'
      Call Some_Init
      If VseId = OldVse Then Signal Vse_Ok
      OldVse   = Vseid
/** Check if it's a valid VSE-id.                                    **/
      If Vse.Vseid = ' ' Then Do
         If Vseid <> ' ' Then Header = '-#Invalid VSE-id.'
                         Else Header = ' Enter VSE-id or ? for help.'
         Cursor.2 = 10
         OldVse = 'INVALID'
         Signal QScroll
         End
      CC_QStart = Right(Word(Vse.Vseid,4),4,0)
      HH_QStart = Right(Word(Vse.Vseid,5),4,0)
      CC_DStart = Right(Word(Vse.Vseid,8),4,0)
      HH_DStart = Right(Word(Vse.Vseid,9),4,0)
      Address COMMAND 'CP DETACH 140'
      Address COMMAND 'CP DETACH 141'
      Parse Value Diagrc(8,'LINK' Word(Vse.Vseid,1) Word(Vse.Vseid,3),
                         '140 RR' Word(Vse.Vseid,2)) With Rc . LinkText
      If Rc <> 0 Then Signal Link_Err
      Parse Value Diagrc(8,'LINK' Word(Vse.Vseid,1) Word(Vse.Vseid,7),
                         '141 RR' Word(Vse.Vseid,6)) With Rc . LinkText
      If Rc <> 0 Then Signal Link_Err
/** Check if it's a valid queue.                                     **/
Vse_Ok:
      Cursor.2 =  28
      Queue = Strip(Queue)
      Header = Q_Head.Queue
      If Header = ' ' Then Do
         Chg_Q = 'YES'
         If Queue <> ' '  Then Header = '-#Invalid queue - Must be',
                                                ' RDR, LST, PUN or XMT.'
                          Else Header = ' Enter queue or ? for help.'
         Signal QScroll
         End
      Call Some_Init
      QCount   =  0
      If Rest <> ' ' Then Do
         Call CmdCheck
         ReqJname = S.2
         ReqJnum  = S.3
         ReqDisp  = S.4
         ReqSysid = S.5
         End
/** Read the VSE/POWER queue and check the result.                   **/
Refresh:
      Cursor.1 =  1
      Rec.     = '-¬'
      R_Time = Time()
      Call Some_Init
      Address COMMAND 'PWRQREAD' Queue CC_Qstart HH_Qstart ReqClass,
                                      ReqDisp ReqSysid ReqJnum ReqJname
      If Rc = 99 Then Do
         Header = ' The' Queue'-queue is empty.'
         Signal QScroll
         End
      If Rec.0  = 0 Then Do
         Header = '-#No match.'
         Signal QScroll
         End
      If Rc = 99999 Then Do
         Call Non_Shared_Power
         Rc = 0
         End
      If Rc <> 0 Then Do
         Rx = rc
         Rc25_Action = 'Signal QScroll'
         Signal Rc_Check
         End
      Parse Value (Rec.0/Q_Scroll) with TotPage '.' Decimal
      If Decimal <> ' ' Then TotPage = TotPage + 1
      Page   = 1
      QCount = 0
      Header = Q_Head.Queue
     'SET NONDISP'
/** Display the final result and wait for new command.               **/
QScroll:
      PreQCount = QCount
      Do Line=4 To (Lscreen.1-2) By 1
         QCount = QCount + 1
        'SET RESERVED' Line 'NOHIGH' Rec.QCount
         End
Read:
      Command = Strip(Command)
      Pf5   = '        '
      Pf7   = '     '
      Pf8   = '     '
      Enter =
      If Command <> '?' & Vseid <> '?' Then Do
         If Chg_Q = 'NO' & OldVse <> 'INVALID' Then Enter =,
             'Enter=Refresh -& Last refresh:' R_Time
         If Page <> 0      Then Pf5 = '5=Browse'
         If Page >  1      Then Pf7 = '7=Bwd'
         If Page < TotPage Then Pf8 = '8=Fwd'
         End
     'SET RESERVED  1 GRE NON NOHIGH' 'VSE-Id:0/
'Left(Vseid,8)'-¬Display:-/'Left(Command,30)'-¬'Right(Date(),12) Time()
     'SET RESERVED  2 GRE NON NOHIGH' ' 'Right(' Page' Page 'of',
                                                        TotPage,78,'-')
     'SET RESERVED  3 WHI NON   HIGH' Header
     'SET RESERVED -2 GRE NON NOHIGH  'Copies('-',79)
     'SET RESERVED -1 WHI NON   HIGH  Pf:  3=Quit  'Pf5'  'Pf7'  ',
                                                         Pf8'    'Enter
     'CURSOR SCREEN' Cursor.1 Cursor.2
      Cursor.1 = 1
      Cursor.2 = 28
      Do Externals()
         Parse External
         End
     'READ NO TAG'
      Do Queued()
         Pull Key Num Pos Input
         Select
            When Key = 'PFK' Then Do
                 If Num > 12 Then Num = Num - 12
                 Address COMMAND 'DROPBUF'
                 Select
                    When Num=3  Then Signal Exit
                    When Num=5  & Pf5 <> ' ' Then Do
                        'EXTRACT /CURSOR/'
                         If Cursor.1 < 4 | Cursor.1 > Lscreen.1-2
                                                  Then Signal Inval_Cur
                         Lnum = PreQCount + (Cursor.1-3)
                         Reqname = Substr(Rec.Lnum,3,8)
                         Reqnum  = Substr(Rec.Lnum,12,5)
                         SeekOffset = Substr(Rec.Lnum,81,11)
                         If Reqname <> ' ' Then Signal Browse
Inval_Cur:              'EMSG  Invalid cursor position'
                         Signal Read
                         End
                    When Num=7  Then Do
                         If Page <= 1 Then Signal Read
                         Page = Page - 1
                         QCount = PreQCount - Q_Scroll
                         If QCount < 0 Then QCount = 0
                         Signal QScroll
                         End
                    When Num = 8  Then Do
                         If Page = TotPage Then Signal Read
                         Page = Page + 1
                         Signal QScroll
                         End
                    Otherwise Nop
                    End
                 End
            When Key = 'RES' & Pos = 10 Then Vseid = Strip(Input)
            When Key = 'RES' & Pos = 28 Then Do
                 Command = Input
                 Parse Value Input With Queue ',' Rest
                 Call Req_Init
                 Chg_Q = 'YES'
                 End
            When Key = 'CMD' Then Do
                 If Vseid   = '?'      Then Signal Help
                 If Queue   = '?'      Then Signal Help
                 If Vseid   = ' '      Then Signal New_Q
                 If Queue   = ' '      Then Signal New_Q
                 If OldVse <>  Vseid   Then Signal New_Q
                 If Chg_Q   = 'YES'    Then Signal New_Q
                 Signal Refresh
                 End
            Otherwise Nop
            End
         End
      Signal Read
/**                           B R O W S E                            **/
/** Read the VSE/POWER data file and check the result.               **/
Browse:
      Data.  =
      Color. = '-<'
      Address COMMAND 'PWRDREAD' SeekOffset CC_DStart HH_DStart Reqname
      MaxSize = Rc
      If Maxsize > 90000 Then Do
         Rx = Maxsize - 90000
         Rc25_Action = 'Signal Read'
         Signal Rc_Check
         End
      Data.0 = Abs(Data.0)
      If Data.0 = 0 Then Do
         Qcount = PreQcount
        'EMSG  Entry is empty.'
         Signal Qscroll
         End
      B = Data.0 + 1
      Data.B  = Copies('*',Maxsize+78)
      Color.B = '-%'
      Maxscroll = B
      DataL = Length(Data.0)
      B = 0
     'SET RESERVED  1 WHI NON   HIGH' Strip(Header,L)
     'SET RESERVED -2 YEL NON NOHIGH  'Copies('-',78)
      LR = 'L'
     'SET NONDISP' Nondisp.1
      Start = 1
      Stop  = 78
      OrigCur = 76 - (2 * DataL)
      SearchL = 22 - (2 * DataL)
      ScrollCur = Origcur
      B_Header = 'Queue:-%'Queue'-<  Job:-%'Reqname Reqnum,
                                                        '  -<Search:-!'
S_CLear:
      Search =
BScroll:
      PreB = B
      Do Line=3 To (Lscreen.1-2) By 1
         B = B + 1
        'SET RESERVED' Line 'GRE NON NOHIGH',
                                     Color.B''Substr(Data.B,Start,Stop)
         End
Bread:
     'SET RESERVED 1 BLU NON NOHIGH' B_Header''Left(Search,SearchL,'_'),
                          ||'-<  Line-!'Left(PreB+1,DataL)'-<of' Data.0
      If Stop  < Maxsize Then Pf11 = '11=Right'
                         Else Pf11 = '        '
      If Start > 1       Then Pf10 = '10=Left'
                         Else Pf10 = '       '
     'SET RESERVED  2 YEL NON NOHIGH  'Substr(Scale,Start,Stop)
      Pf2 = '     '
      Pf7 = '     '
      Pf8 = '     '
      If B < Data.0  Then Do
         Pf8 = '8=Fwd'
         Pf2 = '2=Bot'
         End
      If Preb > 0 Then Do
         Pf7 = '7=Bwd'
         Pf2 = '2=Top'
         End
     'SET RESERVED -1 WHI NON   HIGH  Pf:  'Pf2'  3=Return  'Pf7,
                                      ' 'Pf8'  'Pf10'  'Pf11'  12=Copy'
     'CURSOR SCREEN 1' ScrollCur
     'READ NO TAG'
      Do Queued()
         Pull Key Num Pos Input
         Select
            When Key = 'PFK' Then Do
                 If Num > 12 Then Num = Num - 12
                 Select
                    When Num = 2  & PreB > 0 Then Do
                         B = 0
                         Signal S_Clear
                         End
                    When Num = 2 Then Do
                         B = Data.0 - 1
                         Signal S_Clear
                         End
                    When Num = 3  Then Do
                         QCount = PreQCount
                        'SET NONDISP'
                         Signal QScroll
                         End
                    When Num = 7  Then Do
                         B = PreB - D_Scroll
                         If B < 0 Then B = 0
                         Signal S_Clear
                         End
                    When Num = 8  Then Do
                         If B >= Data.0 Then B = PreB
                         Signal S_Clear
                         End
                    When Num = 10 Then Do
                         B = PreB
                         If Start > 1 Then Do
                            Start = Start - 40
                            Stop  = Stop  - 40
                            End
                         Signal BScroll
                         End
                    When Num = 11 Then Do
                         B = PreB
                         If Stop < Maxsize Then Do
                            Start = Start + 40
                            Stop  = Stop  + 40
                            End
                         Signal BScroll
                         End
                    When Num = 12 Then Call MakeCopy
                    Otherwise Nop
                    End
                 End
            When Key = 'RES' & Pos < 55 Then Do
                 ScrollCur = Pos
                 Search = Strip(Translate(Input,' ','_'))
                 If Search <> ' ' Then Do
                    B = PreB
                    Lastmatch = Data.0 + 1
                    Signal Search
                    End
                 End
            When Key = 'RES' & Pos > 55 Then Do
                 SCROLLCUR = ORIGCUR
                 If Datatype(Input,'W') = 1 & Input > 0 Then Do
                    B = Input - 1
                    If B >= Data.0 Then B = Data.0 - 1
                    Signal BScroll
                    End
                 End
            When Key = 'CMD' & Search <> ' ' Then Do
                 B = PreB + 1
                 Signal Search
                 End
            Otherwise Nop
            End
         End
      Signal Bread
Search:
      If B > Lastmatch Then Do
         B = PreB
         Signal S_Clear
         End
      Address COMMAND 'DROPBUF'
      Do Forever
         B = B + 1
         If B > Data.0 Then Do
            B = PreB + 1
           'EMSG  Target not found.'
            EOS = 'YES'
            Lastmatch = 0
            Leave
            End
         If Pos(Search,Data.B) <> 0 Then Do
            Lastmatch = B
            Leave
            End
         End
      B = B - 1
      Signal BScroll
/**                      S U B R O U T I N E S                       **/
MakeCopy:
      Address COMMAND 'DESBUF'
      Fileid = Reqname Reqnum 'A'
      TestNum = 0
      Do Forever
         Address COMMAND 'STATE' Fileid
         If Rc <> 0 Then Leave
         Testnum = Testnum + 1
         Fileid = Reqname Strip(Reqnum)'-'Testnum 'A'
         End
      Address COMMAND 'EXECIO' Data.0 'DISKW' Fileid '(FINIS STEM DATA.'
      If Rc  = 0 Then 'EMSG  Entry copied to disk - Fileid:' Fileid
                 Else Do
                     'EMSG  Rc' Rc 'from EXECIO DISKW.'
                      Address COMMAND 'ERASE' Fileid
                      End
      Return
/** Initialize some of the variables.                                **/
Some_Init:
      Rec. = '-¬'
      Page    = 0
      Totpage = 0
      Return
Req_Init:
      ReqClass = '-'
      ReqDisp  = '-'
      ReqSysid = '-'
      ReqJnum  = '-'
      ReqJname = '-'
      Return
/** Check the options that was entered with the requested queue.     **/
Cmdcheck:
      Rest = Translate(Rest,' ',',')
      Y    = 1
      S.  = '-'
      If Length(Word(Rest,1)) = 1 Then Do
         If (Queue='RDR' | Queue='XMT') Then Accept_type = 'A'
                                        Else Accept_type = 'U'
         If Datatype(Word(Rest,1),Accept_Type) = 1 Then Do
            ReqClass = Word(Rest,1)
            Y=2
            End
         If Words(Rest) = 1 Then Return
         End
      Do QCount=Y To Words(Rest) By 1
         Find = Word(Rest,QCount)
         Select
            When S.5 = '-' & Substr(Find,1,6) = 'SYSID=' Then Do
                 S.5 = Substr(Find,7)
                 If Queue =  'XMT' & (S.5 <> 'R' & S.5 <> 'L')
                                                      Then Signal S_Err
                 If Queue <> 'XMT' Then;
                    If S.5 <> ' ' & (S.5 < 1 | S.5 > 9)
                                                      Then Signal S_Err
                 If S.5 = ' ' Then S.5 = '00'X
                 End
            When S.4 = '-' & Find = 'HOLD'   Then S.4 = 'HL'
            When S.4 = '-' & Find = 'FREE'   Then S.4 = '*DK'
            When S.4 = '-' & Substr(Find,1,5) = 'DISP='
                                              Then S.4 = Substr(Find,6)
            When S.2 = '-' & Datatype(Find) = 'CHAR' Then Do
                 If Find             = 'HOLD'    Then Signal S_Err
                 If Find             = 'FREE'    Then Signal S_Err
                 If Substr(Find,1,5) = 'DISP='   Then Signal S_Err
                 If Substr(Find,1,6) = 'SYSID='  Then Signal S_Err
                 S.2 = Find
                 If Substr(S.2,1,1) = '*'
                                     Then S.2 = Strip(Substr(S.2,2))'*'
                 End
            When S.3 = '-' & Datatype(Find) = 'NUM'
                                             Then S.3 = Right(Find,5,0)
            Otherwise Signal S_Err
            End
         End
      Rest     = ' '
      Return
S_Err:
      Header = '-#Error in search criteria.'
      Chg_Q  = 'YES'
      Signal QScroll
/** Sort the entries. Only if it's a non shared POWER.               **/
Non_Shared_Power:
      New.  =
      NewDate. =
      Select
         When Queue = 'RDR' Then Offset = 45
         When Queue = 'LST' Then Offset = 53
         When Queue = 'PUN' Then Offset = 53
         When Queue = 'XMT' Then Offset = 50
         Otherwise nop
         End
      Do A=1 To Rec.0 By 1
         Parse Value Substr(Rec.A,Offset,11) ,
                                   With DD '/' +1 MM +2 . +1 HH ':' Min
         Date.A = MM || DD || HH || Min
         End
      A = 1
      New.1     = Rec.1
      Newdate.1 = Date.1
Again:
      A = A + 1
      If A > Rec.0 Then Signal Non_Shared_Exit
      Moved = 'N'
      Do B=1 To A By 1
        If Date.A  < NewDate.B Then Signal Move
        If Date.A  = NewDate.B & Substr(Rec.A,12,5) < Substr(New.B,12,5)
                                                       Then Signal Move
         End
      If Moved = 'N' Then Do
         New.A = Rec.A
         NewDate.A = Date.A
         End
      Signal Again
Move:
      Moved = 'Y'
      Do X=A+1 To B+1 By -1
         Y = X-1
         New.X = New.Y
         NewDate.X = NewDate.Y
         End
      New.B = Rec.A
      NewDate.B = Date.A
      Signal Again
Non_Shared_Exit:
      Dnum = 0
      If Queue = 'RDR' | Queue = 'XMT' Then Do A=1 To Length(Nums) By 1
         Q_Letter = Substr(Nums,A,1)
         Call Get Disp1
         Call Get Disp2
         End
      Do A=1 To Length(Alfa) By 1
         Q_Letter = Substr(Alfa,A,1)
         Call Get Disp1
         Call Get Disp2
         End
      Drop New.
      Return
Get:
      Arg Disps
      Do X=1 To Rec.0 By 1
         If New.X = '' Then Iterate
         If Substr(New.X,22,1) = Q_Letter Then Do
            If Pos(Substr(New.X,20,1),Disps) <> 0 Then Do
               Dnum = Dnum + 1
               Rec.Dnum = New.X
               New.X = ''
               End
            End
         End
      Return
/** Check returncodes                                                **/
Rc_Check:
      Address COMMAND 'DROPBUF'
      Select
         When Rx =   25 Then Do
             'EMSG ' Errortext(5)
              Interpret(Rc25_Action)
              End
         When Rx = 1111 Then Do
             'EMSG  Job' Strip(Reqname) Strip(Reqnum) 'is executing.'
              Signal Read
              End
         When Rx = 1112 Then Do
             'EMSG  Pointer mismatch - Refresh display and retry.'
              Signal Read
              End
         When Rx =    1 Then Say 'Minidisk not linked.'
         When Rx =    2 Then Say 'Unit exeption.'
         When Rx =    3 Then Say 'Wrong length record detected.'
         When Rx =    5 Then Say 'Device busy or interrupt pending.'
         When Rx =   13 Then Say 'Permanent I/O error.'
         Otherwise Say 'Unexpected returncode received.'
         End
      ExitRc = Rx
      Signal Exit
/** Display the help picture.                                        **/
Help:
      Text. = ' '
      If Queue  = ' ' | Queue = '?' Then Do
         Text.1 = ' Enter command'
         Cursor.2 = 28
         End
      If Vseid  = ' ' | Vseid = '?' Then Do
         OldVse = '?'
         Text.2 = 'Enter VSE-id'
         Cursor.2 = 10
         End
      If Text.1 <> ' ' & Text.2 <> ' '
                              Then Header = ' Enter VSE-id and command.'
                                       Else Header = Text.1''Text.2
      Page    = 1
      TotPage = 1
     'SET RESERVED  4 BLU NON NOHIGH'
     'SET RESERVED  5 BLU NON NOHIGH  Format: Queue (,class)',
                           '(,jobname) (,jobnumber) (,SYSID= ) (,FREE)'
     'SET RESERVED  6 BLU NON NOHIGH                        ',
                            '(,*jobname)                        (,HOLD)'
     'SET RESERVED  7 BLU NON NOHIGH' Copies(' ',58),
                                                  '(,DISP=dispositions)'
     'SET RESERVED  8 BLU NON NOHIGH'
     'SET RESERVED  9 BLU NON NOHIGH  Valid queues: RDR, LST, PUN',
                                                              'or XMT.'
     'SET RESERVED 10 BLU NON NOHIGH'
     'SET RESERVED 11 BLU NON NOHIGH'
     'SET RESERVED 12 BLU NON NOHIGH  SYSID= must be R or L for',
                   'XMT-queue and 1-9 (or blank) for the other queues.'
     'SET RESERVED 13 BLU NON NOHIGH  If you specify class it must',
                          'be entered before any of the other options.'
     'SET RESERVED 14 BLU NON NOHIGH'
     'SET RESERVED 15 BLU NON NOHIGH' ' 'Center('-%Examples-<',80,'*')
     'SET RESERVED 16 BLU NON NOHIGH  * RDR,A,FREE          ',
               'The free RDR-entries in class A.                      *'
     'SET RESERVED 17 BLU NON NOHIGH  * PUN,FREE            ',
               'All free PUN-entries.                                 *'
     'SET RESERVED 18 BLU NON NOHIGH  * LST,*CICS,HOLD      ',
               'All held LST-entries starting with CICS.              *'
     'SET RESERVED 19 BLU NON NOHIGH  * LST,H,FREE,*CICS    ',
               'The free LST-entries starting with CICS in class H.   *'
     'SET RESERVED 20 BLU NON NOHIGH  * LST,DISP=DL         ',
               'All LST-entries with disposition D or L.              *'
     'SET RESERVED 21 BLU NON NOHIGH  * RDR,SYSID=,FREE     ',
               'All free RDR-entries with SYSID=blank.                *'
     'SET RESERVED 22 BLU NON NOHIGH' ' 'Left('*',78,'*')
      Do X=23 To Lscreen.1 By 1
        'SET RESERVED' x 'BLU NON NOHIGH'
         End
      Signal Read
/** A CP LINK error occured.                                         **/
Link_Err:
      ExitRc = Rc
      Say Strip(Linktext)
      Signal Exit
Syntax:
      Signal Off Syntax
      Say Errortext(Rc) '- Error detected in line' Sigl
      Signal Exit
/**                     P R O G R A M   E X I T                      **/
Exit:
     'SET NONDISP' Nondisp.1
      Address COMMAND
     'CP DETACH 140'
     'CP DETACH 141'
     'DROPBUF'
      Address XEDIT 'COMMAND QUIT' ExitRc
      Exit


PWRQREAD ASSEMBLE

** PWRQREAD - Read the POWER queue file ** POWER Version 2 Release 3 **
**                                      ** POWER Version 4 Release 1 **
** Return codes: 1 - MINIDISK NOT LINKED.                            **
**               2 - UNIT EXCEPTION.                                 **
**               3 - WRONG LENGTH RECORD DETECTED.                   **
**               5 - DEVICE BUSY OR INTERRUPT PENDING.               **
**              13 - PERMANENT I/O ERROR.                            **
**              25 - NO MORE STORAGE.                                **
**              88 - PROGRAM ERROR DETECTED.                         **
**              99 - QUEUE IS EMPTY.                                 **
**           99999 - NON SHARED POWER.                               **
PWRQREAD CSECT
R0       EQU     0                     PARAMETER LIST
R1       EQU     1                     PARAMETER LIST
R2       EQU     2                     OFFSET POINTER
R3       EQU     3                     ADDRESS OF READCCW
R4       EQU     4                     WORK
R5       EQU     5                     WORK
R6       EQU     6                     CUU OF DISK TO READ
R7       EQU     7                     WORK
R8       EQU     8                     WORK
R9       EQU     9                     WORK
R10      EQU     10                    BASE FOR RDR-, LST- ,XMTDISPL
R11      EQU     11                    BASE FOR SHVBLOCK
R12      EQU     12                    BASE
R13      EQU     13                   *NOT USED
R14      EQU     14                    BAL / RETURN
R15      EQU     15                    RETURN CODE
         USING   PWRQREAD,R12
         ST      R14,SAVERET
         MVC     QUEUE(1),8(R1)        THE REQUESTED QUEUE
         MVC     REQCLASS(1),32(R1)                  CLASS
         MVC     REQDISP(8),40(R1)                   DISPOSITION(S)
         MVC     REQSYSID(1),48(R1)                  SYSID
         MVC     REQJNUM(5),56(R1)                   JOBNUMBER
         MVC     REQJNAME(8),64(R1)                  JOBNAME
         MVC     WORKD(4),16(R1)       IJQFILE START CYLINDER
         BAL     R14,PACK              PACK CYLINDER NUMBER
         STH     R7,INITCC             SAVE IT
         STCM    R7,B'0011',ICC
         MVC     WORKD(4),24(R1)       IJQFILE START HEAD
         BAL     R14,PACK              PACK HEAD NUMBER
         STH     R7,INITHH             SAVE IT
         STCM    R7,B'0011',IHH
         LA      R3,READCCW            R3 = ADDRESS OF CCWLIST
         LH      R6,CUU                R6 = LINKED CUU
         BAL     R14,DIAG0018          READ INTERNAL RECORD
         LH      R5,IREC+2             GET OFFSET OF MASTER-RECORD
         BAL     R14,DISKPOS           CALCULATE CCHHR
         LA      R4,QCRM
         STCM    R4,B'0111',READADDR
         LA      R4,1062
         STCM    R4,B'0111',READSIZE
         BAL     R14,DIAG0018          READ MASTER RECORD
         LA      R4,QBLOCK
         STCM    R4,B'0111',READADDR
         L       R4,ONEPAGE
         STCM    R4,B'0111',READSIZE
         CLI     REQJNUM,C'-'          ALL JOBNUMBERS WANTED ?
         BE      PRGSTART              YES, GO START PROGRAM
         PACK    WORKD,REQJNUM(5)
         CVB     R7,WORKD
         STCM    R7,B'0011',REQJNUM
PRGSTART EQU     *
         LA      R11,SHVBUFF           ADDRESSABILITY FOR SHVBLOCK
         USING   SHVBLOCK,R11
         MVI     SHVCODE,SHVSTORE      WE WANT TO SET VARIABLES
         XC      SHVNEXT,SHVNEXT       ONE BY ONE
         LA      R1,SHVBLOCK
         ST      R1,SHVADDR
         MVC     SHVNAMA,=A(VARNAME)   ADDRESS OF VARIABLE NAME
         MVC     SHVVALA,=A(DISPLAY)   ADDRESS OF VALUE BUFFER
         LA      R1,91                 LENGTH OF VALUE
         ST      R1,SHVVALL
         LA      R1,QTABLE
QGETLOOP EQU     *
         CLC     QUEUE(1),12(R1)       CHECK FOR THE REQUESTED QUEUE
         BE      QFOUND                FOUND, BRANCH
         LA      R1,16(,R1)            MOVE POINTER
         B       QGETLOOP              AND TRY AGAIN
QFOUND   EQU     *
         XR      R15,R15               SET RETURN CODE TO 0
         L       R8,0(,R1)
         MVC     ENTRIES,0(R8)         MOVE THE POINTERS
         L       R8,4(,R1)
         MVC     NENTRIES,0(R8)
         L       R2,8(,R1)             SET OFFSET POINTER
         TM      SSF1,B'10000000'      SHARED POWER
         BNO     NSHRPOWR
         BAL     R14,EMPTYCHK
**          THIS LOOP GETS THE ENTRIES FROM A SHARED POWER           **
SHRLOOP  EQU     *
         BAL     R14,FINDENT           FIND AN ENTRY
         BAL     R14,CHECKREC
         B       SHRLOOP               AND DO IT ALL AGAIN
**        THIS LOOP GETS THE ENTRIES FROM A NON-SHARED POWER         **
NSHRPOWR EQU     *
         MVI     SHAREPOW,C'N'         A NON-SHARED POWER
         XC      SAVER9,SAVER9         CLEAR SAVER9 (=0)
         B       FIRSTREC              AND BRANCH
NSHRLOOP EQU     *
         L       R9,SAVER9             GET SAVED VALUE OF R9
         CH      R9,MRQRRCN            LOWER THAN RECS IN A REC
         BL      NOSHARE               YES, BRANCH
FIRSTREC EQU     *
         L       R5,RECCOUNT           GET RECORD COUNTER
         LA      R5,1(,R5)             ADD 1
         CH      R5,MRQRBLK            R5 >= NUMBER OF RECORDS
         BNL     NSHREXIT              YES, GO EXIT PROGRAM
         ST      R5,RECCOUNT           AND STORE VALUE
         BAL     R14,DISKPOS           CALCULATE CC HH R
         BAL     R14,DIAG0018          READ QUEUE RECORD
         LTR     R15,R15               CHECK THE RETURN CODE
         BNZ     ERREXIT               IF NOT ZERO; GET OUT
         XC      SAVER9,SAVER9         CLEAR SAVER9 (=0)
NOSHARE  EQU     *
         L       R9,SAVER9             GET SAVED VALUE OF R9
         LR      R5,R9                 R5 = R9
         MH      R5,MRQRCSZ            MULTIPLY WITH RECORD-SIZE
         STCM    R5,B'1111',OFFSET     STORE R5 - OFFSET IN BYTES
         LA      R9,1(,R9)             ADD 1 TO R9
         ST      R9,SAVER9             AND SAVE THE NEW VALUE
         CH      R9,MRQRRCN            LOWER THAN RECS IN A REC
         BH      NSHRLOOP              NO, BRANCH
         BAL     R14,CHECKREC          CHECK THE RECORD
         B       NOSHARE               AND DO IT AGAIN
NSHREXIT EQU     *
         CLC     VARCOUNT(4),DOBBZERO
         BNE     EXIT
         LA      R15,99
         B       ERREXIT
**                     P R O G R A M   E X I T                       **
EXIT     EQU     *
         LA      R1,16                 LENGTH OF VARIABLE CONTENTS
         ST      R1,SHVVALL            STORE IT
         L       R9,VARCOUNT           GET HIGHEST VARIABLE NUMBER
         BAL     R14,CONVERT           CONVERT TO DECIMAL
         MVC     DISPLAY(16),DECIMAL   AND MOVE IT
         LA      R9,0
         BAL     R14,SETVAR0           SET DATA.0
         CLI     SHAREPOW,C'Y'         SHARED POWER
         BE      ERREXIT               YES, BRANCH
         L       R15,NOSHRRC           ELSE SET RC = 99999
ERREXIT  EQU     *
         L       R14,SAVERET           RESTORE RETURN ADDRESS
         BR      R14                   RETURN TO CMS
**                       S U B R O U T I N E S                       **
**  READ QUEUE FILE - DIAG X'18' WILL CONVERT TO ECKD WHEN POSSIBLE  **
DIAG0018 EQU     *
         LA      R15,1                 NUMBER OF READS IN CCW-LIST
         DIAG    R6,R3,X'0018'         READ FIRST REC IN IJQFILE
         BR      R14
**        CHECK IF THE RECORD SHOULD BE RETURNED TO THE XEDIT        **
CHECKREC EQU     *
         ICM     R4,B'1111',OFFSET     GET OFFSET IN BYTES
         LA      R5,QBLOCK(R4)         ADDRESS OF QBLOCK + OFFSET
         CLI     42(R5),C'F'           CHECK QIDENT BEFORE MOVE
         BER     R14                   WAS IT FREE - JUST RETURN
         MVC     QRECORD(256),0(R5)    MOVE THE RECORD
         TM      QRS1,B'01000000'      ABENDED QUEUE SET ?
         BOR     R14                   YES, RETURN
         CLI     QUEUE,C'X'            THE XMT QUEUE WANTED
         BNE     CHKQUEUE              NO, SKIP NEXT CHECK
         TM      QRS1,B'10000000'      QUEUE SET IN XMT QUEUE
         BNOR    R14                   NO, RETURN
         MVC     QSYSID,QIDENT         LET SYSID BE = QIDENT (L,R,P)
         B       CHKSHARE              AND SKIP THE NEXT CHECK
CHKQUEUE EQU     *
         TM      QRS1,B'10000000'      QUEUE SET IN XMT QUEUE
         BOR     R14                   YES, RETURN
         CLC     QUEUE(1),QIDENT       QIDENT = R, L, P
         BNER    R14                   NO, RETURN
CHKSHARE EQU     *
         CLI     SHAREPOW,C'Y'         IS IT A SHARED POWER
         BE      CHKCLASS              YES, SKIP NEXT CHECK
         CLC     QRADD,DOBBZERO        ADD-DATE = 0
         BER     R14                   YES, IGNORE ENTRY
CHKCLASS EQU     *
         CLI     REQCLASS,C'-'         ALL CLASSES WANTED
         BE      CHKJNUM               YES, GO CHECK JOBNUMBER
         CLC     REQCLASS,QCLASS       IS THIS THE CLASS
         BNER    R14                   NO, RETURN
CHKJNUM  EQU     *
         CLI     REQJNUM,C'-'          SPECIFIC JOBNUBER WANTED ?
         BE      CHKSYSID              NO, BRANCH
         CLC     REQJNUM(2),QNUMBER    IS THIS THE NUMBER
         BNER    R14                   NO, RETURN
CHKSYSID EQU     *
         CLI     REQSYSID,C'-'         ALL SYSIDS  WANTED ?
         BE      CHKDISP               YES, BRANCH
CHKSID   EQU     *
         CLC     REQSYSID,QSYSID       THIS SYSID WANTED ?
         BNER    R14                   NO, RETURN
CHKDISP  EQU     *
         CLI     REQDISP,C'-'          ALL DISPOSITIONS WANTED ?
         BE      ALLDISP
         LA      R9,REQDISP
DISPLOOP EQU     *
         CLI     0(R9),X'40'           END OF CHECK
         BER     R14                   YES, JUST RETURN
         CLC     0(1,R9),QDISP         IS THIS THE DISPOSITION
         BE      ALLDISP               YES, ACCEPT THE ENTRY
         LA      R9,1(,R9)
         B       DISPLOOP
ALLDISP  EQU     *
         CLI     REQJNAME,C'-'         ALL JOBNAMES WANTED ?
         BE      ALLNAMES              YES, BRANCH
         LA      R9,REQJNAME           GET READY TO CHECK NAME
         LA      R8,QNAME
NAMELOOP EQU     *
         CLI     0(R9),C'*'            END OF NAME
         BE      ALLNAMES              YES, BRANCH
         CLC     0(1,R9),0(R8)         DOES THIS LETTER MATCH
         BNER    R14                   NO, JUST RETURN
         LA      R9,1(,R9)             ADD 1 TO COUNTERS
         LA      R8,1(,R8)
         B       NAMELOOP              AND CHECK NEXT
ALLNAMES EQU     *
         ST      R14,CHKSAVE           SAVE RETURN ADDRESS
         XR      R9,R9                 CLEAR R9
         ICM     R9,B'0011',QNUMBER    READY TO CONVERT Q-NUMBER
         BAL     R14,CONVERT           CONVERT ...
         MVC     NUMBER,DECIMAL+10     AND MOVE IT
         L       R9,QSTIME             TIME ENTRY WAS PUT IN QUEUE
         MVC     TIME,TIMEMASK         SETUP FOR EDIT
         ED      TIME,QSTIME           EDIT Q-TIME
         MVC     NAME,QNAME            MOVE THE RELEVANT DATA
         MVC     PRI,QPRI
         MVC     CLASS,QCLASS
         MVC     SYSID,QSYSID
         MVC     DATE,QDATE
         MVC     USER,QUSER
         MVC     DISP,QDISP
         CLI     QRUN,C'X'             IS THE JOB EXECUTING
         BNE     CONVQ
         MVI     DISP,C'*'             YES, SET DISPOSITION = '*'
CONVQ    EQU     *
         CLI     QUEUE,C'X'            XMT QUEUE WANTED
         BNE     CHKRDR                NO, BRANCH
         BAL     R14,XMTCONV           CONVERT
         B       CHKEND                AND BRANCH
CHKRDR   EQU     *
         CLI     QUEUE,C'R'            RDR QUEUE WANTED
         BNE     CHKLST                NO, BRANCH
         BAL     R14,RDRCONV           CONVERT
         B       CHKEND                AND BRANCH
CHKLST   EQU     *
         CLI     QUEUE,C'L'            LST QUEUE WANTED
         BE      CONVIT                YES, BRANCH
         CLI     QUEUE,C'P'            PUN QUEUE WANTED
         BE      CONVIT                YES, SHOULD BE
         LA      R15,88                ELSE SET RC = 88
         B       ERREXIT               AND GO END PROGRAM
CONVIT   EQU     *
         BAL     R14,LSTCONV           CONVERT
         B       CHKEND                AND BRANCH
CHKEND   EQU     *
         BAL     R14,SETVAR            GO SET THE VARIABLE
         L       R14,CHKSAVE           GET RETURN ADDRESS
         BR      R14                   AND RETURN
**  FIND ENTRIES IN THE POWER QUEUE - ONLY USED FOR A SHARED POWER   **
FINDENT  EQU     *
         ICM     R4,B'1111',QNEXT
         LTR     R4,R4                 MORE ENTRIES IN THE CLASS (¬=0)
         BNZ     NEXTINQ               YES, GET NEXT IN QUEUE
         CLI     NDQCHECK,C'N'         NON-DISPATCHABLE QUEUE CHECKED
         BE      QNLOOP                NO, CHECK IT
QLOOP    EQU     *
         MVI     NDQCHECK,C'N'         SET CHECK SWITCH
         LA      R2,4(,R2)             ADD 4 TO OFFSET
         C       R2,MAXENTRY           ALL ENTRIES PROCESSED ?
         BNL     EXIT                  YES - GET OUT
         LH      R4,ENTRIES+0(R2)      FIRST ENTRY IN A CLASS
         CH      R4,=H'0'              ANY ENTRIES IN THE CLASS ?
         BNE     NEXTINQ               YES, GET IT
QNLOOP   EQU     *
         MVI     NDQCHECK,C'Y'         SET CHECK SWITCH
         LH      R4,NENTRIES+0(R2)     FIRST ENTRY IN A CLASS
         CH      R4,=H'0'              ANY ENTRIES IN THE CLASS ?
         BE      QLOOP                 NO, GET NEXT CLASS.
NEXTINQ  EQU     *
         XR      R5,R5                 CLEAR R5
RECLOOP  EQU     *
         CH      R4,MRQRRCN            IS THE RECORD IN THIS BLOCK
         BL      RECFOUND              YES, BRANCH
         LA      R5,1(,R5)             ADD 1 TO BLOCK
         SH      R4,MRQRRCN            SUBTRACT MRQRRCN
         CH      R4,MRQRRCN            IS RECORD IN BLOCK AT OFFSET 0
         BE      BLKADD                YES, BRANCH
         B       RECLOOP               ELSE TRY AGAIN
BLKADD   EQU     *                     RECORD IS AT OFFSET 0 IN BLOCK
         SH      R4,MRQRRCN            SUBTRACT MRQRRCN
         LA      R5,1(,R5)             ADD 1 TO BLOCK
RECFOUND EQU     *
         LR      R7,R4                 COPY R4 (R4=RECORD# IN BLOCK)
         MH      R7,MRQRCSZ            MULTIPLY WITH RECORD-SIZE
         STCM    R7,B'1111',OFFSET     STORE R7 - OFFSET IN BYTES
         CL      R5,PREBLOCK           RECORD IN LAST READ BLOCK
         BER     R14                   YES, DON'T READ AGAIN
         ST      R5,PREBLOCK           ELSE SAVE BLOCK NUMBER
         ST      R14,FINDSAVE
         BAL     R14,DISKPOS           AND CALCULATE CCHHR
         LA      R15,1
         DIAG    R6,R3,X'0018'         READ THE QUEUE FILE
         LTR     R15,R15               CHECK THE RETURN CODE
         BNZ     ERREXIT               IF NOT ZERO; GET OUT
         L       R14,FINDSAVE
         BR      R14                   RETURN
**               SET THE REXX VARIABLE FOR THE XEDIT                 **
SETVAR   EQU     *
         L       R9,VARCOUNT           NUMBER OF VARIABLE
         LA      R9,1(,R9)             ADD 1
         ST      R9,VARCOUNT           AND STORE NEW VALUE
SETVAR0  EQU     *
         ST      R14,SAVER14           REMEMBER RETURN ADDRESS
         LA      R4,DECIMAL+15         READY TO CONVERT
         BAL     R14,CONVERT           CONVERT
         L       R14,SAVER14           RESTORE RETURN ADDRESS
         SR      R4,R1                 CALCULATE LENGTH OF NUMBER
         LA      R5,5(,R4)             SET R5 = R4 + 5
         ST      R5,SHVNAML            THIS GIVES LENGTH OF VARIABLE
         EX      R4,MOVEMASK           MOVE THE NUMBER
         LA      R1,XCOMM              SET UP FOR EXECCOMM
         LA      R0,EPLIST
         ICM     R1,B'1000',=X'02'
         SVC     202
         DC      AL4(1)                I CHECK FOR ERROR
         LTR     R15,R15               ANY ERROR
         BZR     R14                   NO, RETURN
         LA      R15,25                SET RC = 25
         B       ERREXIT               AND BRANCH
MOVEMASK MVC     VARNAME+4(0),0(R1)
**      PACK AND CVB CONTENTS OF WORKD AND RETURN RESULT IN R7       **
PACK     EQU     *
         PACK    WORKD,WORKD(4)
         CVB     R7,WORKD
         BR      R14
**               CALCULATE DISK POSITION OF THE RECORD               **
DISKPOS  EQU     *
         XR      R4,R4                 CLEAR R4
         LH      R7,INITCC             LOAD INITIAL CYLINDER NUMBER
         LH      R8,INITHH             LOAD INITIAL HEAD     NUMBER
         D       R4,TEN                DIVIDE WITH BLOCKS PR. CYL. (10)
         CL      R5,TRACKS             PASSED CYLINDER BOUNDARY
         BL      NOTPCB                NO, BRANCH
CYLDIFF  EQU     *                     ELSE ...
         LA      R7,1(,R7)             ADD 1 TO CYLINDER
         S       R5,TRACKS             SUBTRACT NUMBER OF TRACKS
         CL      R5,TRACKS             STILL NOT THE RIGTH CYLINDER
         BNL     CYLDIFF               NO, BRANCH
         XR      R8,R8                 SET INIT HEAD = 0
NOTPCB   EQU     *
         AR      R5,R8                 CALCULATE HEAD NUMBER
         STCM    R5,B'0011',IHH        AND STORE IT
         LA      R4,1(,R4)             ADD 1 TO RECORD NUMBER
         STCM    R4,B'0001',IRR        AND STORE IT
         XR      R4,R4                 CLEAR R4
         D       R4,TRACKS             DIVIDE WITH TRACKS PER CYL.
         AR      R5,R7                 CALCULATE CYLINDER NUMBER
         STCM    R5,B'0011',ICC        AND STORE IT
         BR      R14                   RETURN
**              CONVERT A BINARY NUMBER TO DISPLAYABLE               **
CONVERT  EQU     *
         LA      R1,DECIMAL+15
         CVD     R9,WORKD              CONVERT R9
         MVC     DECIMAL,NUMMASK       SETUP FOR EDIT
         EDMK    DECIMAL,WORKD         EDIT
         BR      R14                   RETURN
**               CHECK IF THE REQUESTED QUEUE IS EMPTY               **
EMPTYCHK EQU     *
         CLI     QUEUE,C'X'            IS IT THE XMT QUEUE
         BE      ALLQS                 YES, FORGET THE CLASS CHECK
         CLI     REQCLASS,C'-'         ALL CLASSES WANTED
         BE      ALLQS                 YES, BRANCH
         LA      R2,0
         LA      R9,VALIDQS
QTABLOOP EQU     *
         CLC     0(1,R9),REQCLASS      IS THIS THE CLASS
         BE      SETMAXQ               YES, BRANCH
         LA      R9,1(,R9)             MOVE POINTERS
         LA      R2,4(,R2)
         B       QTABLOOP              AND TRY AGAIN
SETMAXQ  EQU     *
         LA      R9,8(,R2)             MAXENTRY = R2 + 8
         ST      R9,MAXENTRY
ALLQS    EQU     *
         CLC     ENTRIES,ENTRYCHK      ANY ENTRIES IN DISP Q
         BNER    R14                   YES, RETURN
         CLC     NENTRIES,ENTRYCHK     ANY ENTRIES IN NONDISP Q
         BNER    R14                   YES, RETURN
         LA      R15,99
         B       ERREXIT               AND GO EXIT PROGRAM
LSTCONV  EQU     *
         ST      R14,CONVSAVE
         LA      R10,DREST
         USING   LSTDISPL,R10
         XR      R9,R9                 CLEAR R9
         ICM     R9,B'0001',QCOPY      NUMBER OF COPIES
         BAL     R14,CONVERT           CONVERT COPY-NUMBER
         MVC     LSTCOPY,DECIMAL+14    AND MOVE IT
         LH      R9,QPAGES             NUMBER OF PAGES (LST)
         CLI     QUEUE,C'L'            LST QUEUE REQUESTED
         BE      BALCONV               YES, SKIP NEXT LINE
         L       R9,QRECORDS           NUMBER OF RECORDS (PUN)
BALCONV  EQU     *
         BAL     R14,CONVERT           CONVERT NUMBER OF PAGES/RECORDS
         MVC     LSTPAGE,DECIMAL+10    MOVE NUMBER
         MVC     LSTCUU,QCUU           AND OTHER DATA
         MVC     LSTFORM,QFORM
         MVC     LSTDTU,DTU
         MVC     LSTUSER,TARGID
         L       R14,CONVSAVE
         BR      R14
XMTCONV  EQU     *
         ST      R14,CONVSAVE
         LA      R10,DREST
         USING   XMTDISPL,R10
         L       R9,QCOUNT
         CLI     QIDENT,C'L'           IS IT A TRANSMIT LST
         BE      XLST                  YES, BRANCH
         L       R9,QRECORDS
XLST     EQU     *
         BAL     R14,CONVERT           CONVERT NUMBER OF RECORDS
         MVC     XMTRECS,DECIMAL+10    MOVE RECORD NUMBER
         MVC     SYSID,QIDENT          ... AND OTHER DATA
         MVC     XMTDTU,DTU
         MVC     XMTTARG,TARGNAM
         MVC     XMTORIG,TARGID
         L       R14,CONVSAVE
         BR      R14
RDRCONV  EQU     *
         ST      R14,CONVSAVE
         LA      R10,DREST
         USING   RDRDISPL,R10
         L       R9,QRECORDS           LOAD NUMBER OF RECORDS
         BAL     R14,CONVERT           CONVERT NUMBER
         MVC     RDRRECS,DECIMAL+10    MOVE IT
         MVC     RDRCUU,QCUU           AND SOME OTHER DATA
         MVC     RDRORIG,ORIGID
         MVC     RDRDTU,DTU
         L       R14,CONVSAVE
         BR      R14
WORKD    DS      D
DOBBZERO DC      D'0'
TEN      DC      F'10'                 BLOCKS/TRACK    (3380)
TRACKS   DC      F'15'                 TRACKS/CYLINDER (3380)
MAXENTRY DC      F'148'
ONEPAGE  DC      F'4096'
NOSHRRC  DC      F'99999'
VARCOUNT DC      F'0'
RECCOUNT DC      F'-1'
IREC     DS      F
SAVERET  DS      F
SAVER9   DS      F
SAVER14  DS      F
CHKSAVE  DS      F
CONVSAVE DS      F
FINDSAVE DS      F
*
EPLIST   DC      A(XCOMM)
         DC      A(0)
         DC      A(0)
SHVADDR  DC      A(0)
*
PREBLOCK DC      XL4'FF'
INITHH   DS      H
INITCC   DS      H
CUU      DC      X'0140'               ADDRESS THAT THE EXEC LINKS
NUMMASK  DC      X'40202020202020202020202020202120'
TIMEMASK DC      X'2120207A2020'
VALIDQS  DC      C'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
SHVBUFF  DS      CL32
DECIMAL  DS      CL16
VARNAME  DC      CL12'REC.'
XCOMM    DC      CL8'EXECCOMM'
QUEUE    DS      CL1
SHAREPOW DC      C'Y'                  ASSUME IT'S A SHARED POWER
NDQCHECK DC      C'Y'
ENTRIES  DC      XL148'00'
NENTRIES DC      XL148'00'
ENTRYCHK DC      XL148'00'
REQCLASS DS      CL1
REQSYSID DS      CL1
REQDISP  DC      CL9' '
REQJNUM  DC      CL5' '
REQJNAME DC      CL8' '
         DC      CL1'*'
QTABLE   DS      0F
         DC      A(RDRCLASS),A(RDRNDISP),F'00',CL4'R'
         DC      A(LSTCLASS),A(LSTNDISP),F'40',CL4'L'
         DC      A(PUNCLASS),A(PUNNDISP),F'40',CL4'P'
         DC      A(XMTCLASS-140),A(XMTNDISP-140),F'136',CL4'X'
QTABEND  EQU     *
QCRM     DS      0XL1062               THE MASTER RECORD.
         DS      XL32
MRQRBLK  DS      XL2                   NUMBER OF QUEUE RECORD BLOCKS
         DS      XL2
MRQRRCN  DS      XL2                   NUMBER OF Q-RECS PER Q-REC BLOCK
MRQRCSZ  DS      XL2                   Q-RECORD COMPARTMENT SIZE
         DS      XL116
RDRCLASS DS      XL148                 DISPATCHABLE RDR CLASS AREA.
LSTCLASS DS      XL148                              LST
PUNCLASS DS      XL148                              PUN
XMTCLASS DS      XL8                                XMT
RDRNDISP DS      XL148             NON-DISPATCHABLE RDR CLASS AREA.
LSTNDISP DS      XL148                              LST
PUNNDISP DS      XL148                              PUN
XMTNDISP DS      XL8                                XMT
         DS      X
SSF1     DS      X
         DS      0F                    MUST BE ON FULLWORD BOUNDARY
QRECORD  DS      0XL256                THE QUEUE RECORD.
QDATE    DS      CL5
         DS      CL3
QSTIME   DS      XL4
QETIME   DS      XL4
QUSER    DS      CL16
QNAME    DS      CL8
QNUMBER  DS      BL2
QIDENT   DS      CL1
         DS      CL2
QCUU     DS      CL3
         DS      CL2
QCLASS   DS      CL1
QPRI     DS      CL1
QRECORDS DS      BL4
         DS      CL3
QCOPY    DS      BL1
QFORM    DS      CL4
         DS      CL4
QPAGES   DS      BL2
         DS      CL2
QCOUNT   DS      BL4
         DS      CL6
QDISP    DS      CL1
         DS      CL47
QSYSID   DS      CL1
         DS      CL5
QRUN     DS      CL1
         DS      CL3
QRS1     DS      X
         DS      CL15
QRADD    DS      CL8
         DS      CL4
QNEXT    DC      X'00000000'           POINTER TO NEXT IN QUEUE.
         DS      CL12
TARGNAM  DS      CL8
TARGID   DS      CL8
ORIGNAM  DS      CL8
ORIGID   DS      CL8
         DS      CL40
DISPLAY  DC      CL2'-\'               VALUE OF REC. VARIABLE
NAME     DS      CL8
NUMBER   DS      CL6
         DC      CL1' '
PRI      DS      CL1
         DC      CL1' '
DISP     DS      CL1
         DC      CL1' '
CLASS    DS      CL1
         DC      CL1' '
SYSID    DS      CL1
DREST    DC      CL56' '
SEEK     DC      X'0000'               SEEK ADDRESS.
ICHR     DS      0CL5
ICC      DS      X'0000'               CYLINDER NUMBER.
IHH      DS      X'0000'               HEAD     NUMBER.
IRR      DC      X'01'                 RECORD   NUMBER.
OFFSET   DS      CL4
DTU      DS      0CL29                 DTU = DATE/TIME/USER
         DC      CL1' '                EQUAL FOR ALL QUEUES
DATE     DS      CL5
TIME     DS      CL6
         DC      CL1' '
USER     DS      CL16
READCCW  CCW     X'07',SEEK,X'40',6    SEEK
         CCW     X'23',IRR,X'40',1     SET SECTOR
         CCW     X'31',ICHR,X'40',5    SEARCH
         CCW     X'08',*-8,X'00',0     TIC
         CCW     X'06',IREC,X'00',4    READ
READADDR EQU     READCCW+33
READSIZE EQU     READCCW+37
**                            D S E C T S                            **
         DSECT
RDRDISPL DS      0CL56                 ONLY FOR RDR
RDRRECS  DS      CL6
         DS      CL1
RDRCUU   DS      CL3
         DS      CL1
RDRORIG  DS      CL8
RDRDTU   DS      CL29
         DS      CL8
LSTDISPL DS      0CL56                 FOR LST AND PUN
LSTPAGE  DS      CL6
         DS      CL1
LSTCOPY  DS      CL2
         DS      CL1
LSTCUU   DS      CL3
         DS      CL1
LSTFORM  DS      CL4
         DS      CL1
LSTUSER  DS      CL8
LSTDTU   DS      CL29
XMTDISPL DS      0CL56                 ONLY FOR XMT
XMTRECS  DS      CL6
         DS      CL1
XMTTARG  DS      CL8
         DS      CL1
XMTORIG  DS      CL8
XMTDTU   DS      CL29
         DS      CL3
         SHVBLOCK DSECT
PWRQREAD CSECT
         LTORG
QBLOCK   DS      CL4096                QUEUE RECORD BLOCK
         END


PWRDREAD ASSEMBLE

** PWRDREAD - Read the POWER data file  ** POWER Version 2 Release 3 **
**                                      ** POWER Version 4 Release 1 **
** Return codes: 90001 - MINIDISK NOT LINKED.                        **
**               90002 - UNIT EXCEPTION.                             **
**               90003 - WRONG LENGTH RECORD DETECTED.               **
**               90005 - DEVICE BUSY OR INTERRUPT PENDING.           **
**               90013 - PERMANENT I/O ERROR.                        **
**               90025 - NO MORE STORAGE.                            **
**               91111 - JOB IS EXECUTING.                           **
**               91112 - POINTER MISMATCH.                           **
PWRDREAD CSECT
R0       EQU     0                     CMS EXTENDED PLIST POINTER
R1       EQU     1                     PARAMETER LIST
R2       EQU     2                     OFFSET POINTER
R3       EQU     3                     LINK ADDRESS
R4       EQU     4                     WORK
R5       EQU     5                     WORK
R7       EQU     7                     WORK
R8       EQU     8                     WORK
R9       EQU     9                     WORK
R10      EQU     10                    BASE FOR SHVBLOCK
R11      EQU     11                    CCW ADDRESS POINTER
R12      EQU     12                    BASE
R13      EQU     13                   *NOT USED
R14      EQU     14                    RETURN / BAL
R15      EQU     15                    RETURN CODE
         USING   PWRDREAD,R12
         ST      R14,SAVERET
         LR      R2,R0
         L       R3,4(,R2)
         MVC     SEEK(11),0(R3)        SEEK ADDRESS (AND OFFSET)
         MVC     WORKD(4),16(R1)       IJDFILE START CYLINDER
         BAL     R14,PACK              PACK CYLINDER NUMBER
         STH     R7,INITCC             SAVE IT
         MVC     WORKD(4),24(R1)       IJDFILE START HEAD
         BAL     R14,PACK              PACK HEAD NUMBER
         STH     R7,INITHH             SAVE IT
         MVC     REQNAME(8),32(R1)
         LH      R3,QCUU               LOAD R3 WITH THE LINK ADDR
         BAL     R14,DIAG0018
         ICM     R4,B'1111',OFFSET     GET OFFSET IN BYTES
         LA      R5,PWRBLOCK(R4)       ADDRESS OF PWRBLOCK + OFFSET
         MVC     QRECORD(256),0(R5)    MOVE THE RECORD
         LA      R15,1112              IF JOB IS NOT FOUND. RC=1112
         CLC     QNAME(8),REQNAME      IS IT THE RIGHT NAME
         BNE     ERREXIT               NO, DO NOT BROWSE
         LA      R15,1111              IF JOB IS EXECUTING. RC=1111
         CLI     QRUN,C'X'             IS THE JOB EXECUTING
         BE      ERREXIT               YES, DO NOT BROWSE
         TM      QRS1,B'10000000'      PART OF XMT QUEUE
         BNO     VARSETUP              NO, GO SETUP REXX
         MVI     QIDENT,C'X'           INSERT X IN QIDENT (X=XMT)
VARSETUP EQU     *
         LA      R10,REXXVAR           ADDRESSABILITY FOR SHVBLOCK
         USING   SHVBLOCK,R10
         MVI     SHVCODE,C'S'          VARIABLES ARE TO BE SET
         XC      SHVNEXT,SHVNEXT       ONE BY ONE
         LA      R7,SHVBLOCK
         ST      R7,SHVADDR
         MVC     SHVNAMA,=A(VARNAME)   ADDRESS OF VARIABLE NAME
         XR      R15,R15               CLEAR R15
         CLI     QIDENT,C'R'           READER QUEUE ENTRY
         BNE     NEWBLOCK              NO, BRANCH
         MVI     FIRSTIME,C'N'
NEWBLOCK EQU     *
         L       R5,DBLK
         LH      R7,INITCC             LOAD INITIAL D-CYLINDER NUMBER
         LH      R8,INITHH             LOAD INITIAL D-HEAD     NUMBER
         BAL     R14,DISKPOS           CALCULATE CCHHR
         LH      R3,DCUU
         BAL     R14,DIAG0018
         LA      R5,PWRBLOCK
         LH      R4,PWRBLOCK           LENGTH OF FIRST RECORD IN BLOCK
         CLC     PWRBLOCK+4(4),=C'SER:' SER RECORD ?
         BNE     NOTSER                NO, BRANCH
         MVC     DBLK,PWRBLOCK+8       MOVE DBLK NUMBER
         MVI     4(R5),X'20'
         B       ADD
NOTSER   EQU     *
         L       R3,DBLK
         LA      R3,1(,R3)             ADD 1 TO DBLK NUMBER
         ST      R3,DBLK
ADD      EQU     *
         TM      2(R5),B'00000100'     END OF DATA
         BO      EXIT                  YES, GET OUT
         TM      4(R5),B'10100000'     JOB- OR DATA SET- HEADER RECORD
         BZ      NOADD                 NO, BRANCH
         AR      R5,R4                 ELSE MOVE POINTERS
         LH      R4,0(R5)
         B       ADD                   AND CHECK AGAIN
NOADD    EQU     *
         ICM     R4,B'0011',0(R5)      GET LENGTH OF RECORD + PREFIX
         TM      2(R5),B'00000100'     END OF DATA
         BO      EXIT                  YES, GET OUT
         MVC     PRECCW,CCWCODE        REMEMBER PREVIOUS CCW-CODE
         CLI     3(R5),X'73'           IGNORE X'73'
         BE      NOSTACK
         CLI     3(R5),X'FE'           IGNORE X'FE'
         BE      NOSTACK
         CLI     3(R5),X'FF'           IGNORE X'FF'
         BE      NOSTACK
         BAL     R14,CCWCHECK          FIND NEXT CCW-CODE
         CLI     FIRSTIME,C'Y'
         BE      NOSTACK
         MVC     7(1,R5),PRECCW        INSERT PREVIOUS CCW-CODE
         LA      R8,7(,R5)             SET R8 = R5 + 7
         LR      R7,R4                 SET R7 = R4 ...
         SH      R7,=H'8'              SUBTRACT 8 (1 IS FOR EXECUTE)
         EX      R7,EXCOMP             CHECK FOR A "+         " LINE
         BE      NOSTACK               WAS IT ONE; SKIP IT
         LA      R7,1(,R7)             ADD 1 TO R7 (FOR THE EXECUTE)
         ST      R7,SHVVALL            R7 = LENGTH OF RECORD
         ST      R8,SHVVALA            R8 = START  OF RECORD IN BLOCK
         BAL     R14,SETVAR
         MVC     HIGHNUM,DECIMAL
NOSTACK  EQU     *
         MVI     FIRSTIME,C'N'
         TM      2(R5),B'00010000'     END OF BLOCK
         BO      NEWBLOCK              YES, GO GET NEW BLOCK
         AR      R5,R4                 MOVE LDA POINTER
         B       NOADD
EXCOMP   CLC     0(0,R8),EMPTYLIN
**                     P R O G R A M   E X I T                       **
ERREXIT  EQU     *                     AN ERROR HAS OCCURED
         A       R15,NINETI            SET RC = R15 + 90000
         ST      R15,SAVERC            STORE IT
         B       NOSETVAR              AND DO NOT SET DATA.0
EXIT     EQU     *
         XC      SAVERC,SAVERC         CLEAR SAVERC
         MVC     SAVERC+2(2),QRRL      INSERT MAX LENGTH
         LA      R7,16                 LENGTH OF DATA
         ST      R7,SHVVALL            STORE IT
         LA      R7,HIGHNUM            HIGHEST DATA. VALUE
         ST      R7,SHVVALA            STORE IT
         XR      R7,R7                 SET R7 = 0
         BAL     R14,SETVAR0           AND SET DATA.0
NOSETVAR EQU     *
         L       R14,SAVERET
         L       R15,SAVERC            SET RC
         BR      R14                   RETURN TO CMS
**                       S U B R O U T I N E S                       **
PACK     EQU     *
         PACK    WORKD,WORKD(4)
         CVB     R7,WORKD
         BR      R14
CCWCHECK EQU     *
         TM      4(R5),B'00000010'     ASA CONTROL CHARACTERS
         BZ      NOASA                 NO, BRANCH
         MVC     PRECCW,3(R5)          INSERT ASA CC
         BR      R14                   RETURN
NOASA    EQU     *
         MVC     CCWCODE,PRECCW
         LA      R7,MCCTABLE
         LA      R8,ASATABLE
MCCLOOP  EQU     *
         CLC     0(1,R7),3(R5)         IS THIS THE CCW CODE
         BE      MCCFOUND              YES, MOVE THE ASA CODE
         CLI     0(R7),X'FF'           END OF MCCTABLE
         BE      MCCFOUND              YES, INSERT ? AS ASA CODE
         LA      R7,1(,R7)             ADD 1 TO MCC POINTER
         LA      R8,1(,R8)             ADD 1 TO ASA POINTER
         B       MCCLOOP               AND GO CHECK THE NEXT
MCCFOUND EQU     *
         MVC     CCWCODE,0(R8)
         BR      R14
DISKPOS  EQU     *
         XR      R4,R4                 CLEAR R4
         D       R4,TEN                DIVIDE WITH BLOCKS PR. CYL. (10)
         CL      R5,TRACKS             PASSED CYLINDER BOUNDARY
         BL      NOTPCB                NO, BRANCH
XCYLDIFF EQU     *                     ELSE ...
         LA      R7,1(,R7)             ADD 1 TO CYLINDER
         S       R5,TRACKS             SUBTRACT NUMBER OF TRACKS
         CL      R5,TRACKS             STILL NOT THE RIGTH CYLINDER
         BNL     XCYLDIFF              NO, BRANCH TO XCYLDIFF
         SR      R8,R8                 SET INIT HEAD = 0
NOTPCB   EQU     *
         AR      R5,R8                 CALCULATE HEAD NUMBER
         STH     R5,IHH                AND STORE IT
         LA      R4,1(,R4)             ADD 1 TO RECORD NUMBER
         STC     R4,IRR                AND STORE IT
         XR      R4,R4                 CLEAR R4
         D       R4,TRACKS             DIVIDE WITH 15 (TRACKS PR. CYL)
         AR      R5,R7                 CALCULATE CYLINDER NUMBER
         STH     R5,ICC                AND STORE IT
         BR      R14                   RETURN
DIAG0018 EQU     *
         LA      R15,1                 NUMBER OF READS IN CCW-LIST
         LA      R11,READCCW
         DIAG    R3,R11,X'0018'        READ THE QUEUE FILE
         LTR     R15,R15               CHECK THE RETURN CODE
         BZR     R14                   RC = 0, RETURN
         B       ERREXIT               IF NOT ZERO; GET OUT
SETVAR   EQU     *
         L       R7,VARCOUNT           GET NUMBER OF VARIABLES SO FAR
         LA      R7,1(,R7)             ADD 1
         ST      R7,VARCOUNT           AND REMEMBER THE NEW VALUE
SETVAR0  EQU     *
         LA      R1,DECIMAL+15         SET R1 = DECIMAL+15
         LR      R8,R1                 SET R8 = R1
         CVD     R7,WORKD              CONVERT R7
         MVC     DECIMAL,NUMMASK       SETUP FOR EDIT
         EDMK    DECIMAL,WORKD         EDIT (MAY CHANGE VALUE OF R1)
         SR      R8,R1                 R8 = R8 - R1
         LA      R7,6(,R8)             R7 = R8 + 6
         ST      R7,SHVNAML            LENGTH OF VARIABLE NAME
         EX      R8,MOVEMASK           MOVE THE NUMBER
         LA      R1,XCOMM              SETUP FOR EXECCOMM
         LA      R0,EPLIST               ...
         ICM     R1,B'1000',=X'02'       ...
         SVC     202                   INVOKE EXECCOMM
         DC      AL4(1)                I CHECK FOR ERROR
         LTR     R15,R15               RC = 0
         BZR     R14                   YES, RETURN
         MVI     SHVCODE,C'D'          READY TO DROP VARIABLES
         LA      R7,5                  LENGTH OF NAME (DATA.)
         ST      R7,SHVNAML
         SVC     202                   DROP THE DATA. VARIABLES
         DC      AL4(1)                IGNORE ANY ERROR
         LA      R15,25                SET RC = 25
         B       ERREXIT               AND GO EXIT THE PROGRAM
MOVEMASK MVC     VARNAME+5(0),0(R1)
**           C O N S T A N T S   A N D   V A R I A B L E S           **
WORKD    DS      D
SAVERET  DS      F
TRACKS   DC      F'15'                 TRACKS/CYLINDER (3380)
TEN      DC      F'10'                 BLOCKS/TRACK    (3380)
SAVERC   DC      F'0'
VARCOUNT DC      F'0'
NINETI   DC      F'90000'
INITHH   DS      H
INITCC   DS      H
QCUU     DC      X'0140'               Q-ADDRESS (LINKED BY PWRQPROF)
DCUU     DC      X'0141'               D-ADDRESS (LINKED BY PWRQPROF)
CCWCODE  DC      X'40'
PRECCW   DC      X'40'
AUTH     DS      X
MCCTABLE DC      X'000B098B11131B01191BFF'
ASATABLE DC      X'404040F1F0F0604E60606F'
NUMMASK  DC      X'40202020202020202020202020202120'
REXXVAR  DS      CL32
DECIMAL  DS      CL16
HIGHNUM  DC      CL16'0'
VARNAME  DC      CL15'DATA.'           NAME OF REXX VARIABLE
XCOMM    DC      CL8'EXECCOMM'
REQNAME  DS      CL8
FIRSTIME DC      C'Y'
EMPTYLIN DC      C'+',CL250' '
*
         DS      0F
QRECORD  DS      0XL256                THE QUEUE RECORD.
         DS      CL32
QNAME    DS      CL8
         DS      CL2
QIDENT   DS      CL1
         DS      CL89
QRRL     DS      CL2
         DS      CL2
QRUN     DS      CL1
         DS      CL3
QRS1     DS      CL1
         DS      CL27
QNEXT    DC      F'0'                  POINTER TO NEXT IN QUEUE.
DBLK     DS      F
         DS      CL80
*
SEEK     DC      H'0'
ICHR     DS      0CL5
ICC      DS      H'0'                  CYLINDER NUMBER.
IHH      DS      H'0'                  HEAD     NUMBER.
IRR      DC      X'01'                 RECORD   NUMBER.
OFFSET   DS      CL4
*
EPLIST   DS      0D
         DC      A(XCOMM)
         DC      A(0)
         DC      A(0)
SHVADDR  DC      A(0)
*
READCCW  CCW     X'07',SEEK,X'40',6    SEEK
         CCW     X'23',IRR,X'40',1     SET SECTOR
         CCW     X'31',ICHR,X'40',5    SEARCH
         CCW     X'08',*-8,X'00',0     TIC
         CCW     X'06',PWRBLOCK,X'00',4096   READ
*
         LTORG
         SHVBLOCK
PWRDREAD CSECT
         DS      0H
PWRBLOCK DS      CL4096                QUEUE OR DATA RECORD BLOCK
         END     PWRDREAD


Michael Plannthin
Systems Programmer (Denmark)

