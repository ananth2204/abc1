Reading VSE/SP3 libraries from CMS

The programs to read the VSE/SP3 libraries from CMS are:

o      LIBRCMS ASSEMBLE - this is the program that reads the
      VSE/SP3 library and puts the information in REXX
      variables.

o      LIBREXX EXEC, LIBXEDIT XEDIT and LIBREXX
      XEDIT  -  these programs run LIBRCMS and display the
      information returned in XEDIT files.

The command format is:

      LIBRCMS  (sublib  (member  (type )))

where sublib is the name of the target sublibrary.  Member and
type is the name and type of the target member.  If no
parameters are entered then all the sublibraries in the library are
listed.  If sublib and member are entered, all members with that
name in that sublibrary are listed.  If sublib, member and type
are specified, the lines in that member are listed.

The requirements on entry are:

o      All disks on which the library resides must be ASSGNed to
      SYS100 onwards. The first SYStem logical unit not used
      after SYS100 should be ASSGNed IGN to avoid the
      OVTOC macro cancelling the program.

o      The following REXX variables should be set to give
      information regarding the type of library to be read :

      o      LibrKEY - This is the library's file-id (ie
            VSE.PRD2.LIBRARY).

      o      LibrVSM - Indicates if the library is VSAM and is
            set to Y or N.

      o      LibrSYS - Indicates if the library is IJSYSRS and
            again is set to Y or N.

o      If the library is VSAM then a DLBL for IJSYSUC must
      point to the catalog holding it.  Ensure also that you have
      the MASTER catalog accessed.

Because VSAM libraries are NONCIFORMAT VSAM
managed SAM files, they cannot be accessed using an ACB or
DTFSD.  DTFPH can be used to access such a file but this isn't
supported by CMS.  Therefore to read the library, this program
examines the catalog (or the VTOCs for a non-VSAM library)
and builds a table describing the location of all the library's
extents and then issues its own CCWs to retrieve the
information.

In order to speed up runtimes this program assumes that it has
been NUCXLOADed and sets a flag inside the CSECT once
the extent table has been built.  On subsequent executions to
read the same library it won't bother rebuilding the table.

To read a different library make sure you NUCXLOAD a new
copy to reset the flag and cause the table to be rebuilt.  After
the table has been prepared the library directory records
describing each sublibrary, the sublibrary directory records
describing its members, and the member records are read
according to the input parameters.

The limitations on use are:

o      This program only supports libraries on 3380s.

o      The maximum number of disks on which a library may
      reside is sixteen.  (This may be increased by adding extra

      entries to the VOL1TAB and XTNTTAB tables, but make sure
      VOL1TAB doesn't have more entries than
      XTNTTAB.)

o      If the library is not VSAM, the number of extents on any
      one disk is limited to three (although you can have up to
      sixteen extents spread over several disks).  This is because
      a FORMAT1 VTOC label only details up to three extents;
      the rest are detailed on a FORMAT3 continuation label
      which this program does not read.

o      This program can't read a member whose record length is
      not 80 bytes (this only includes PHASEs and DUMPs and
      maybe a few other obscure member types).


LIBRCMS ASSEMBLE

*  Function:     To read VSE/SP3 libraries from CMS and place         *
*                contents of directories or members in REXX           *
*                variables for use by the calling EXEC.               *
*  Conditions on exit:                                                *
*     R15 is set as follows -                                         *
*         0     Execution successful and variables set as described   *
*               below.                                                *
*         1     One of the library's records couldn't be found        *
*               (probably because of a missing disk if non-VSAM).     *
*         2     EXECCOMM returned a non-zero return code.             *
*         3     A VSAM error occurred processing the catalog.         *
*         4     A disk required to build the extent table could not   *
*               be found for a VSAM library.                          *
*         5     The library has more extents than entries in the      *
*               extent table.                                         *
*         6     The library has more than three extents on one of     *
*               its disks (non-VSAM libraries only).                  *
*         7     The sublibrary specified on input could not be found. *
*         8     The member specified on input could not be found.     *
*                                                                     *
*     If the return code is zero then the REXX variables LIBR.0 to    *
*     LIBR.nnn are setup as follows:                                  *
*         LIBR.0     =    nnn   where nnn is the highest LIBR.        *
*                               variable set.                         *
*         For a list of sublibraries (CMSLIBR                   )     *
*         LIBR.1 to LIBR.nnn is as follows -                          *
*              chars  1 for  8  =  sublibrary name                    *
*              chars 10 for  6  =  creation date in YYMMDD format     *
*              chars 17 for  6  =  number of members in sublibrary    *
*         For a list of members (CMSLIBR sublib            )          *
*         LIBR.1 to LIBR.nnn is as follows -                          *
*              chars  1 for  8  =  member name                        *
*              chars 10 for  8  =  member type                        *
*              chars 19 for  6  =  creation date in YYMMDD format     *
*              chars 26 for  6  =  replacement date in YYMMDD format  *
*         For a display of a member (CMSLIBR sublib member type)      *
*         LIBR.1 to LIBR.nnn is as follows -                          *
*              chars  1 for 80  =  corresponding line in member       *
*                                                                     *
*  Generation:                                                        *
*     1) In order to assemble this program make sure the following    *
*        VSE macros have been ESERVed and MACLIBed down to CMS:       *
*          i) ACB,RPL,OPEN,GET,MODCB and CLOSE to process VSAM        *
*         ii) OVTOC and PVTOC to read VTOCs                           *
*        iii) CCB and EXCP to issue I/Os                              *
*     2) Use the RLDSAVE option of the LOAD command to make it        *
*        acceptable for NUCXLOAD.                                     *
*     3) Use the ALL option of the GENMOD command to allow this       *
*        program to be run with CMS/DOS set on.                       *
*  Software levels:                                                   *
*     i)    VM/XA SP 2.0    (but should work on any VM system)        *
*    ii)    VSE/SP VERSION 3.1.0 - VSE/SYSTEM PACKAGE VER 3.1.0       *
*   iii)    VSE/SP VERSION 2.1.0 - VSE/VSAM VERSION 1.3.0             *
         REGEQU
SHVBLOCK SHVBLOCK                      * REXX variable DSECT
         USING SHVBLOCK,R14            *
         DMSCCB                        * CCB DSECT
         USING DMSCCB,R5
         IJJHDLST                      * Volume descriptor list DSECT
         USING IJJHDLST,R2
LIBRCMS  CSECT
         USING LIBRCMS,R12             * establish base register
         STM   R14,R12,12(R13)         * save caller's registers
         LR    R12,R15                 * and load my base register
         LA    R3,SAVE                 * new save area
         ST    R3,8(R13)               * chain new s/a in old s/a
         ST    R13,4(R3)               * chain old s/a in new s/a
         LR    R13,R3                  * point to new s/a
*    Transfer the parameters pointed to by R1 to my parameter         *
*    table PARAMS and blank out unused entries in case a previous     *
*    run left old parameters due to NUCXLOAD.                         *
         LA    R4,NPARAMS              * max num of params to get
         LA    R3,PARAMS               * start of parameter table
         LA    R1,8(R1)                * start of parameters entered
GETPARM1 EQU   *
         MVI   0(R3),C' '              * blank out entry (NUCXLOAD)
         CLI   0(R1),X'FF'             * end of parameters ?
         BE    NXTPARAM                * branch if yes
         MVC   0(L'PARAMS,R3),0(R1)    * move parameter to table
         LA    R1,8(R1)                * address next parameter
NXTPARAM EQU   *
         LA    R3,8(R3)                * address next table entry
         BCT   R4,GETPARM1             * get next parameter
         CLI   BUILTFLG,C'Y'           * extent table already built ?
         BE    TABBUILT                * branch if yes
         MVI   BUILTFLG,C'Y'           * set "table built" flag
*    Read the REXX variables LibrKEY,LibrVSM and LibrSYS to get       *
*    the type of library to be read.                                  *
         LA    R14,REXBLOCK            * address my SHVBLOCK
         LA    R2,VARNUM               * number of variables to get
         LA    R3,VARTAB               * start of variable table
GETVARS  EQU   *
         MVC   SHVBUFL(L'VARTAB),0(R3) * move params to SHVBLOCK
         BAL   R10,GETVAR              * get the variable
         LA    R3,L'VARTAB(R3)         * address next table entry
         BCT   R2,GETVARS              * get next variable
         LA    R10,TABBUILT            * set return address
         CLI   VSMVARB,C'Y'            * is it a VSAM library
         BE    VSAMLIB                 * branch if yes to build table
         B     SDLIB                   * else branch for a non-VSAM one
*    Read the library directory records until the specified sublib    *
*    has been found or, if one hasn't been specified, set REXX        *
*    variables LIBR. to provide info about each sublibrary.           *
*    The first record in the library is the first of the library      *
*    directory records and the sublibrary entries start at offset     *
*    X'D8' in that record. The last fullword in the record points to  *
*    the next record or is F'-1' if there are no more records. The    *
*    sublibrary entries start at offset 0 in these subsequent records.*
*    Each sublibrary entry is 72 bytes in length. The name is 8 bytes *
*    at offset 0, the creation date is 6 bytes at offset 8 (YYMMDD)   *
*    and the number of entries is 4 bytes at offset X'28'. The 4 bytes*
*    at offset X'1C' point to the first record describing the members *
*    in the sublibrary (the sublibrary directory records).            *
TABBUILT EQU   *
         MVI   LIBRB,C' '              * blank out REXX variable buffer
         MVC   LIBRB+1(L'LIBRB-1),LIBRB
         LA    R14,REXBLOCK            * address my SHVBLOCK
         MVC   SHVNAMA,=A(LIBRVARN)    * start of variable name LIBR.nn
         MVC   SHVVALA,=A(LIBRB)       * address of buffer to SHVBLOCK
         MVC   SHVVALL,=A(L'LIBRB)     * length of buffer to SHVBLOCK
         LA    R7,VBUF+X'D8'           * start of data in record
         LA    R0,0                    * want first record
         LA    R11,0                   * set stem number
GETSLIBS EQU   *
         BAL   R10,GETREC              * read the record
LOOP     EQU   *
         CLC   0(4,R7),=F'0'           * any more data on record ?
         BNE   SLIBINFO                * branch if yes
         LA    R1,VBUF
         L     R0,RECLEN-4(R1)         * last fword points to next rec
         C     R0,=F'-1'               * is there another record ?
         BE    ENDREAD                 * branch if no
         LA    R7,VBUF                 * start of data in next record
         B     GETSLIBS                * read and process the record
SLIBINFO EQU   *
         CLC   SUB2GET,0(R7)           * this sublib in entry params ?
         BE    ALLSLIBS                * branch if yes
         CLI   SUB2GET,C' '            * was a sublib name specified ?
         BNE   NOSHOW                  * branch if yes
         MVC   SUBLIB,0(R7)            * put sublib name in REXX buffer
         MVC   SUBLIBCD,8(R7)          * and create date as well
         L     R1,X'28'(R7)            * get number of members
         CVD   R1,CVDWORK              * and convert to decimal
         MVC   EDPATRN(8),=X'4020202020202120'
         ED    EDPATRN(8),CVDWORK+4
         MVC   SUBLIBNO,EDPATRN+2      * now move to REXX buffer
         LA    R11,1(R11)              * increment stem number
         BAL   R10,SETVAR              * go and set the variable
NOSHOW   EQU   *
         LA    R7,72(R7)               * point to next sublibrary entry
         B     LOOP                    * process it
ENDREAD  EQU   *
         CLI   SUB2GET,C' '            * was a sublibrary specified ?
         BE    FINISH                  * branch if no
         B     SUBNTFND                * branch to set bad RC.
*    Read the sublibrary directory records until the specified member *
*    has been found or, if one hasn't been specified, set REXX        *
*    variables LIBR. to give information about the members.           *
*    The entries start at offset 0 in the first and subsequent        *
*    records.                                                         *
*    There are three types of entries - TYPE entries which describes  *
*    the type of all subsequent members, MEMBER entries which         *
*    describes members for the previous type, and DUMMY entries which *
*    appear to be deleted entries.    The 2 bytes at offset 8 are     *
*    X'0080' for a TYPE entry, X'0020' for a MEMBER entry, and any    *
*    thing else is classed as a DUMMY entry.                          *
*    A TYPE entry is 10 bytes in length and the type is 8 bytes at    *
*    offset 0.                                                        *
*    A MEMBER entry is X'48' bytes in length, the name is 8 bytes at  *
*    offset 0, the creation date (YYMMDD) 6 bytes at offset X'26' and *
*    the replacement date (YYMMDD) 6 bytes at offset X'30'. The 4     *
*    bytes at offset X'0C' point to the first record describing the   *
*    member's contents.                                               *
*    A DUMMY entry's length is given by the 2 bytes at offset 0.      *
ALLSLIBS EQU   *                       * read a sublibrary's directory
         L     R0,X'1C'(R7)            * get recno of its directory
SUBDIAG  EQU   *
         LA    R4,VBUF                 * start of data in record
         BAL   R10,GETREC              * read the record
NEXTMEM  EQU   *
         CLC   0(8,R4),=XL8'00'        * end of data on record ?
         BE    ENDLOOP                 * branch if yes
         CLC   8(2,R4),=X'0020'        * is entry a member name ?
         BE    ISMEMBER                * branch if yes
         CLC   8(2,R4),=X'0080'        * is entry a member type ?
         BE    ISTYPE                  * branch if yes
         AH    R4,0(R4)                * dummy entry so skip over it
         B     NEXTMEM                 * and process next entry
ISTYPE   EQU   *
         MVC   TYPE(8),0(R4)           * set type of following members
         LA    R4,10(R4)               * point to first of this type
ISMEMBER EQU   *
         CLI   MEM2GET,C' '            * was member specified on entry?
         BE    SHOWMEM                 * branch if no
         CLC   MEM2GET,0(R4)           * is this the member ?
         BNE   NOTMEM                  * branch if no
         CLI   TYP2GET,C' '            * was type specified on entry?
         BE    SHOWMEM                 * branch if no
         CLC   TYP2GET,TYPE            * is the type the same ?
         BE    COPYMEM                 * branch if yes
         B     NOTMEM                  * skip listing member
SHOWMEM  EQU   *
         MVC   MEMBER,0(R4)            * move member name to REXX buff
         MVC   MEMBERCD,X'26'(R4)      * and the create date
         MVC   MEMBERRD,X'30'(R4)      * and the replace date
         LA    R11,1(R11)              * increment the stem number
         BAL   R10,SETVAR              * and set the variable
NOTMEM   EQU   *
         LA    R4,X'48'(R4)            * point to next member entry
         B     NEXTMEM                 * go and process it
ENDLOOP  EQU   *
         LA    R1,VBUF
         L     R0,RECLEN-4(R1)         * last fword is next rec number
         C     R0,=F'-1'               * is there another record
         BNE   SUBDIAG                 * branch if yes
         CLI   TYP2GET,C' '            * were we looking for a member ?
         BE    FINISH                  * branch if no
         B     MEMNTFND                * go and set a bad RC
*    Read the member records describing its contents and set REXX     *
*    variables LIBR. to correspond to each line in the member.        *
*    The data starts at offset 0 and is compressed to removed spaces. *
*    The first byte of the data is a compression control byte. Bits   *
*    0 to 3 describe the number of characters following it and bits   *
*    4 to 7 describe the number of spaces that should be added after  *
*    the characters. Another control byte and characters follow the   *
*    previous set and continues in this manner describing the complete*
*    contents of the member. A X'00' control byte ends the data.      *
*    A member line is put into LIBR. each time 80 bytes of data have  *
*    been decompressed which is why PHASEs and DUMPs aren't supported.*
COPYMEM  EQU   *
         LA    R11,0                   * set stem number
         L     R0,X'0C'(R4)            * get member record number
COPYMEM0 EQU   *
         BAL   R10,GETREC              * read the record
         MVI   LIBRB,C' '              * blank out the REXX buffer
         MVC   LIBRB+1(L'LIBRB-1),LIBRB
         LA    R7,VBUF                 * start of data in record
         LA    R8,LIBRB                * address REXX buffer
         LA    R9,L'LIBRB              * length of REXX buffer
COPYMEM1 EQU   *
         LTR   R9,R9                   * reached end of REXX buffer?
         BE    EOLINE                  * branch if yes
         LA    R5,0
         ICM   R5,B'0001',0(R7)        * get number of chars and spaces
*                                      * bits 0-3=chars  4-7=spaces
         BE    EOREC                   * branch if both zero
         LR    R4,R5                   * copy into R4
         SRL   R4,4                    * and shift to get num of chars
         N     R5,=X'0000000F'         * turn R5 into num of spaces
         SR    R9,R4                   * take chars away from REXX buff
         SR    R9,R5                   * take spaces away as well
         LTR   R4,R4                   * are there any characters ?
         BE    MOV4SPCS                * branch if no
         BCTR  R4,R0                   * decrement length for MVC
         EX    R4,MVCMEMBF             * and move chars to REXX buffer
         LA    R8,1(R4,R8)             * move up posn in REXX buffer
         LA    R4,1(R4)                * increment length after MVC
MOV4SPCS EQU   *
         LA    R7,1(R4,R7)             * move up posn in record
         AR    R8,R5                   * move up posn in REXX buffer
         B     COPYMEM1                * goback and process next entry
EOLINE   EQU   *
         LA    R11,1(R11)              * increment stem number
         BAL   R10,SETVAR              * go and set the variable
         MVI   LIBRB,C' '              * blank out the REXX buffer
         MVC   LIBRB+1(L'LIBRB-1),LIBRB
         LA    R8,LIBRB                * readdress REXX buffer
         LA    R9,L'LIBRB              * and reset length
         B     COPYMEM1                * read next line in member
EOREC    EQU   *
         LA    R7,VBUF                 * start of data in next record
         L     R0,RECLEN-4(R7)         * last fword is next record num
         C     R0,=F'-1'               * are there any more records ?
         BNE   COPYMEM0                * branch if yes
         B     FINISH                  * getout
*    Write error messages and set RC if something wrong.              *
RECERROR EQU   *                       * GETREC couldn't get record
         LINEDIT TEXT='RECORD ERROR FOR RECNO ........',SUB=(HEX,(R5))
         LA    R15,1
         B     GETOUT
REXERR   EQU   *                       * EXECCOMM gave bad return code
         LINEDIT TEXT='REXX ERROR ........',SUB=(DEC,(R15))
         LA    R15,2
         B     GETOUT
VSAMERR  EQU   *                       * VSAM should write error msg
         LA    R15,3
         B     GETOUT
VOL1MISS EQU   *                       * VSAM library disk not ASSGN'd
         LINEDIT TEXT='MISSING VOLID ......',SUB=(CHARA,(R5))
         LA    R15,4
         B     GETOUT
TOOHIERR EQU   *                       * Not enough XTNTTAB entries
         LINEDIT TEXT='LIBRARY HAS TOO MANY EXTENTS'
         LA    R15,5
         B     GETOUT
OVER3    EQU   *                       * More than 3 extents on a disk
         LINEDIT TEXT='LIBRARY HAS MORE THAN THREE EXTENTS ON ONE DISK'
         LA    R15,6
         B     GETOUT
SUBNTFND EQU   *                       * Obvious
         LINEDIT TEXT='SPECIFIED SUBLIBRARY NOT FOUND'
         LA    R15,7
         B     GETOUT
MEMNTFND EQU   *                       * Obvious
         LINEDIT TEXT='SPECIFIED MEMBER NOT FOUND'
         LA    R15,8
         B     GETOUT
*    Exit after everything worked ok.                                 *
FINISH   EQU   *
         BAL   R10,SETSTEM             * set LIBR.0 to number of lines
         LA    R15,0                   * give a nice return code
GETOUT   EQU   *
         L     R13,4(R13)              * get old s/a
         L     R14,12(R13)             * restore caller's registers
         LM    R0,R12,20(R13)          * except for R15
         BR    R14                     * and return to caller
*    Read the library record whose number is in R0.                   *
*    (0 is the first record).                                         *
GETRECSV DS    5F                      * where to save regs
GETREC   EQU   *
         STM   R3,R7,GETRECSV          * save regs about to change
         LR    R5,R0                   * transfer wanted record number
         LA    R3,XTNTTAB              * address the extent table
         LA    R4,0
XTNTLOOP EQU   *
         CLC   XTNTLO(4,R3),=F'-1'     * reached end of table ?
         BE    RECERROR                * branch if yes
         C     R0,XTNTRECS(R3)         * is the record in this extent
         BL    GOTXTNT                 * branch if yes
         L     R4,XTNTRECS(R3)         * transfer highest rec num here
         LA    R3,XTNTLEN(R3)          * address next table entry
         B     XTNTLOOP                * process next entry
GOTXTNT  EQU   *
         SR    R5,R4                   * record num relative to extent
         LA    R4,0
         D     R4,=F'31'               * relative trk=rec/(recs/trk)
         LA    R4,1(R4)                * remainder+1 = rec for SEID
         STC   R4,SEIDDATA+4           * store it for SEID
         LA    R4,0
         D     R4,=F'15'               * relative cyl=trk/(trks/cyl)
         AH    R4,XTNTLO+2(R3)         * + start of extent for abs trk
         LR    R7,R4                   * recalculate trk in case above
         LA    R6,0                    * addition caused spill into
         D     R6,=F'15'               * next cyl.
         AR    R5,R7                   * add to rel cyl if spilled
         STH   R6,SEEKDATA+4           * store trk for SEEK
         STH   R6,SEIDDATA+2           * and for SEID
         AH    R5,XTNTLO(R3)           * abs cyl = rel_cyl+extent_start
         STH   R5,SEEKDATA+2           * store cyl for SEEK
         STH   R5,SEIDDATA             * and for SEID
         LA    R5,CCBBLOCK             * address the CCB block
         MVC   CCBSUNUM,XTNTADDR+3(R3) * transfer SYS unit extent is on
         EXCP  CCBBLOCK                * issue i/o
         LM    R3,R7,GETRECSV          * restore regs
         BR    R10                     * return
*    Retrieve the value of a REXX variable (SHVBLOCK already set).    *
GETVAR   EQU   *
         LA    R14,REXBLOCK            * address my SHVBLOCK
         MVI   SHVCODE,SHVSYFET        * want to fetch
         LA    R1,EXECCOMM             * address "EXECCOMM" string
         ICM   R1,B'1000',=X'02'       * insert "subcommand call" flag
         LA    R0,EPLIST               * address the extended plist
         SVC   202                     * retrieve the variable
         DC    AL4(REXERR)             * branch off if error
         BR    R10                     * return
*    Set LIBR.0 to highest LIBR. variable set (R11).                  *
SETSTEM  EQU   *
         LA    R14,REXBLOCK            * address my SHVBLOCK
         MVC   SHVVALA(4),=A(EDPATRN+2) * move address of value
         MVC   SHVVALL(4),=A(6)        * move length of value
         CVD   R11,CVDWORK             * convert no of lines to decimal
         MVC   EDPATRN(8),=X'4021202020202020'
         ED    EDPATRN(8),CVDWORK+4
         MVC   SHVNAML,=A(6)           * move length of name
         MVI   LIBRVARN+5,C'0'         * make it LIBR.0
         B     SETSVC                  * branch to set variable
*    Set LIBR.xxx where xxx is in R11.                               *
SETVAR   EQU   *
         LA    R14,REXBLOCK            * address my SHVBLOCK
         MVI   SHVCODE,SHVSTORE        * tell EXECCOMM want to store
         CVD   R11,CVDWORK             * turn stem number into decimal
         MVC   EDPATRN(8),=X'4020202020202120'
         ED    EDPATRN(8),CVDWORK+4
         LA    R15,0                   * zeroise decimal number length
         LA    R1,EDPATRN+7            * address end of decimal number
SCAN     EQU   *                       * scan for space to calc length
         CLI   0(R1),C' '              * found start of R11 number ?
         BE    GOTSPC1                 * branch if yes
         LA    R15,1(R15)              * increment length count
         BCT   R1,SCAN                 * decrement posn and look again
GOTSPC1  EQU   *
         EX    R15,SCANMVC             * move number to LIBR.xxx
         LA    R15,5(R15)              * add length of LIBR.
         ST    R15,SHVNAML             * store in name length
SETSVC   EQU   *
         LA    R1,EXECCOMM             * address "EXECCOMM"
         ICM   R1,B'1000',=X'02'       * insert "subcommand call flag"
         LA    R0,EPLIST               * address extended plist
         SVC   202                     * call EXECCOMM
         DC    AL4(REXERR)             * branch if get an error
         BR    R10                     * return
*    Build the extent table (XTNTTAB) for a non-VSAM library.         *
*    Read VTOCs of all disks ASSGNed to SYS100 onwards and put any    *
*    library extents in sequence order into the extent table, then    *
*    read table and calculate highest record number held in each      *
*    extent.                                                          *
SDLIB    EQU   *                       * build non-VSAM extent table
         LA    R3,XTNTNUM              * number of table entries
         LA    R4,SYSADDR              * start of SYStem logical units
SDLOOP1  EQU   *
         STC   R4,SYSNUM+1             * set SYS number to check
         OVTOC SYSNO=SYSNUM,DLIST=DLISTADR * open the vtoc
         LTR   R15,R15                 * errors ?
         BNE   SDLOOP2                 * branch if yes
*                                      * now read FORMAT1 label
         PVTOC READ,DLIST=DLISTADR,IOA=VBUF,TYPE=F1,NAME=KEYVARB
         LTR   R15,R15                 * errors ?
         BNE   LEAVE                   * branch if yes
         LA    R2,0
         IC    R2,VBUF+X'3B'+7         * get num of extents on disk
         CH    R2,=H'3'                * more than three extents ?
         BH    OVER3                   * branch if yes
         LA    R7,VBUF+X'69'+7         * start of extent information
LOOPIT   EQU   *
         LA    R6,0
         IC    R6,1(R7)                * get extent sequence number
         CH    R6,=AL2(XTNTNUM)        * can it fit in the extent table
         BNL   TOOHIERR                * branch if no
         MH    R6,=AL2(XTNTLEN)        * calculate offset into table
         LA    R6,XTNTTAB(R6)          * and add to start of table
         MVC   XTNTLO(4,R6),2(R7)      * move lo extent into table
         MVC   XTNTHI(4,R6),6(R7)      * and move hi extent
         ST    R4,XTNTADDR(R6)         * and store its SYS number
         LA    R7,10(R7)               * move onto next FORMAT1 entry
         BCT   R2,LOOPIT               * process next extent
LEAVE    EQU   *
         LA    R4,1(R4)                * go onto the next SYS unit
         BCT   R3,SDLOOP1              * go and process it
SDLOOP2  EQU   *
         CLI   SYSVARB,C'Y'            * is it IJSYSRS
         BNE   NOTSYS                  * branch if no
         LA    R6,XTNTTAB              * address the extent table and
         LH    R1,XTNTLO+2(R6)         * increment the start of the
         LA    R1,1(R1)                * first extent by one track cos
         STH   R1,XTNTLO+2(R6)         * the first track is ipl stuff.
NOTSYS   EQU   *
         LA    R6,XTNTTAB              * address extent table
         LA    R7,0                    * zero accumulative record count
LOOPIT2  EQU   *
         CLC   XTNTLO(4,R6),=F'-1'     * any more extents ?
         BE    0(R10)                  * return if no
         LH    R9,XTNTHI(R6)           * get hi cyl
         SH    R9,XTNTLO(R6)           * subtract lo cyl for num cyls
         MH    R9,=H'15'               * calculate number of tracks
         SH    R9,XTNTLO+2(R6)         * subtract the lo track and add
         AH    R9,XTNTHI+2(R6)         * hi trk for num trks in extent
         LA    R9,1(R9)                * add one to make it work
         MH    R9,=H'31'               * num recs=trks*(recs/trk)
         AR    R7,R9                   * add to accumulative record cnt
         ST    R7,XTNTRECS(R6)         * store in table entry
         LA    R6,XTNTLEN(R6)          * address next table entry
         B     LOOPIT2                 * and process it
*    Build the extent table (XTNTTAB) for a VSAM library.             *
*    Open IJSYSUC as a KSDS file and GET a record using the library   *
*    file-id (ie VSE.PRD2.LIBRARY) as the key. The 2 bytes at offset  *
*    45 in this record are used to make a key to GET the cluster      *
*    record. The format of this key is:                               *
*            X'0000',(the 2 bytes),X'01',XL39'00'.                    *
*    The 2 bytes at offset X'80' in the cluster record form another   *
*    key as above to GET the data record. The 2 bytes at offset X'96' *
*    in the data record form the key of record describing the extents.*
*    The extent info starts at offset 60 in this record, however if   *
*    the 2 bytes at offset X'96' in the data record are X'0000' then  *
*    the extent info is found in the data record at the offset calc'd *
*    by the following equation:   X'FD'+(5*(byte at X'94')).          *
*    The extent info comes in blocks with each block describing the   *
*    extents on a single disk. The volser of the disk is at offset 6  *
*    for 6 bytes in the block and the number of extents on this disk  *
*    is held in the 1 byte at offset 15. The lo address of the first  *
*    extent is at offset 47 for 4 bytes (CCCCHHHH) and the hi address *
*    is at offset 51 for 4 bytes. The description of each extent in   *
*    the block is 20 bytes in length and so the displacement to the   *
*    next extent is 20 bytes and so on. The length of the block and   *
*    so the displacement to the next block is (20*(num extents))+X'2D'*
VSAMLIB  EQU   *
         LA    R2,DLISTADR             * address the descriptor list
         LA    R3,VOL1NUM              * number of volser table entries
         LA    R4,SYSADDR              * start at SYS100
         LA    R6,VOL1TAB              * address the volser table
VOL1LOOP EQU   *
         STC   R4,SYSNUM+1             * set the SYS unit to process
         OVTOC SYSNO=SYSNUM,DLIST=DLISTADR * open the vtoc
         LTR   R15,R15                 * errors ?
         BNE   GETXTNTS                * branch if yes
         MVC   VOL1VOL(,R6),DLVOLID    * move volser into table
         LA    R4,1(R4)                * move onto next SYS unit
         LA    R6,VOL1LEN(R6)          * address next table entry
         BCT   R3,VOL1LOOP             * process next entry
GETXTNTS EQU   *
         OPEN  IJSYSUC                 * open the catalogue
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         GET   RPL=MYRPL               * get file record
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         MVC   THEKEY2+2(2),VBUF+45    * set key to get cluster record
         MODCB RPL=MYRPL,ARG=THEKEY2   * mod rpl to reflect new key
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         GET   RPL=MYRPL               * get cluster record
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         MVC   THEKEY2+2(2),VBUF+X'80' * set key to get data record
         GET   RPL=MYRPL               * get data record
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         LA    R3,XTNTTAB              * address the extent table
         LA    R4,XTNTNUM              * number of table entries
         ICM   R5,B'0011',VBUF+X'96'   * are extents on different rec ?
         BE    ONTHISRC                * branch if no
         STH   R5,THEKEY2+2            * set key for this other rec
         GET   RPL=MYRPL               * get the record
         LTR   R15,R15                 * errors ?
         BNE   VSAMERR                 * branch if yes
         LA    R5,VBUF+60              * start of extent info on rec
         B     READEM                  * branch to read info
ONTHISRC EQU   *
         LA    R5,0
         IC    R5,VBUF+X'94'           * take byte at offset X'94'
         MH    R5,=H'5'                * multiply by five and
         LA    R5,VBUF+X'FD'(R5)       * add X'FD' for start of info
READEM   EQU   *
         LA    R7,0                    * zero accumulative record count
XLOOP    EQU   *
         CLC   47(4,R5),=F'0'          * end of extent info ?
         BE    DONEXTNT                * branch if yes
         LA    R8,VOL1TAB              * address the volser table
         LA    R9,SYSADDR              * start at SYS100
GETVOL1  EQU   *
         CLI   VOL1VOL(R8),C' '        * end of volser table ?
         BE    VOL1MISS                * branch if yes
         CLC   VOL1VOL(,R8),6(R5)      * got the right disk ?
         BE    VOL1HIT                 * branch if yes
         LA    R8,VOL1LEN(R8)          * goto next volser table entry
         LA    R9,1(R9)                * and next SYS unit
         B     GETVOL1                 * branch to check next SYS unit
VOL1HIT  EQU   *
         LA    R8,0
         ICM   R8,B'0001',15(R5)       * get num of extents for disk
         BE    NEXTBLK                 * branch if zero
XLOOP2   EQU   *
         ST    R9,XTNTADDR(R3)         * store SYS unit in extent table
         MVC   XTNTLO(4,R3),47(R5)     * and lo extent
         MVC   XTNTHI(4,R3),51(R5)     * and hi extent
         LH    R6,XTNTHI(R3)           * get hi cyl
         SH    R6,XTNTLO(R3)           * subtract lo cyl
         MH    R6,=H'15'               * and multiply by 15 for trks
         SH    R6,XTNTLO+2(R3)         * minus lo trk
         AH    R6,XTNTHI+2(R3)         * plus hi trk
         LA    R6,1(R6)                * and add one for total trks
         MH    R6,=H'31'               * multiply for total records
         AR    R7,R6                   * add to accumulative rec count
         ST    R7,XTNTRECS(R3)         * and store in extent table
         LA    R5,20(R5)               * address next extent info
         LA    R3,XTNTLEN(R3)          * address next table entry
         SH    R4,=H'1'                * decrement XTNTTAB entries left
         BC    4,TOOHIERR              * branch if none left.
         BCT   R8,XLOOP2               * process next extent
NEXTBLK  EQU   *
         LA    R5,X'2D'(R5)            * address next disk with extents
         B     XLOOP                   * go and find it
DONEXTNT EQU   *
         CLOSE IJSYSUC                 * close the catalog
         BR    R10                     * return
*                         Storage areas.                              *
*      Parameter table to record entry parameters.                    *
PARAMS   EQU   *,8                     * table for input parameters
SUB2GET  DC    CL(L'PARAMS)' '         * specified sublibrary
MEM2GET  DC    CL(L'PARAMS)' '         * specified member name
TYP2GET  DC    CL(L'PARAMS)' '         * specified member type
NPARAMS  EQU   (*-PARAMS)/L'PARAMS     * number of entries
*    Table describing REXX variables to retrieve and their buffers    *
VARTAB   EQU   *,16                    * table of REXX vars to read
         DC    A(L'KEYVARB,KEYVARN,L'KEYVARN,KEYVARB) * library file-id
         DC    A(L'SYSVARB,SYSVARN,L'SYSVARN,SYSVARB) * is it IJSYSRS
         DC    A(L'VSMVARB,VSMVARN,L'VSMVARN,VSMVARB) * is it VSAM
VARNUM   EQU   (*-VARTAB)/L'VARTAB
*    The variable names and buffers described above.                  *
KEYVARN  DC    C'LibrKEY'              * REXX var with library file-id
KEYVARB  DC    CL44' '                 * buffer to put its value in
SYSVARN  DC    C'LibrSYS'              * REXX var to say if its IJSYSRS
SYSVARB  DC    CL8' '                  * buffer to put value in (Y/N)
VSMVARN  DC    C'LibrVSM'              * REXX var to say if its VSAM
VSMVARB  DC    CL8' '                  * buffer to put value in (Y/N)
*    Extended plist, "EXECCOMM" string and SHVBLOCK used by EXECCOMM. *
EXECCOMM DC    C'EXECCOMM'             * required for EXECCOMM
EPLIST   DC    A(EXECCOMM)             * extended plist for EXECCOMM
         DC    A(0)
         DC    A(0)
         DC    A(REXBLOCK)
REXBLOCK DC    XL(SHVBLEN)'0'          * my SHVBLOCK for REXX variables
*    Couple of instructions to EXecute.                               *
         DS    0F
SCANMVC  MVC   LIBRVARN+5(0),1(R1)     * EX inst to move LIBR. stem num
         DS    0F
MVCMEMBF MVC   0(0,R8),1(R7)           * EX inst to move member data
*    The REXX LIBR. output buffer and variable and associated equates.*
LIBRVARN DC    CL30'LIBR.'             * REXX var name for output
LIBRB    DC    CL80' '                 * output buffer for REXX LIBR.n
SUBLIB   EQU   LIBRB+0,8               * posn of sublib name in LIBR.n
SUBLIBCD EQU   LIBRB+9,6               * posn of sublib create date
SUBLIBNO EQU   LIBRB+16,6              * posn of number of entries
MEMBER   EQU   LIBRB+0,8               * posn of member name
TYPE     EQU   LIBRB+9,8               * posn of member type
MEMBERCD EQU   LIBRB+18,6              * posn of member create date
MEMBERRD EQU   LIBRB+25,6              * posn of member replace date
*    VSE macros and associated data.                                  *
IJSYSUC  ACB   AM=VSAM,                * ACB to open the catalogue     X
               MACRF=(IN,KEY)
MYRPL    RPL   ACB=IJSYSUC,            * RPL to access the catalogue   X
               AM=VSAM,                                                X
               AREA=VBUF,                                              X
               AREALEN=L'VBUF,                                         X
               ARG=KEYVARB,                                            X
               OPTCD=(KEY,MVE,DIR)
CCBBLOCK CCB   SYS100,CCWADDR          * CCB for EXCP to issue CCWs
*
SYSADDR  EQU   100                     * disks ASSGN'd to SYS100 on
RECLEN   EQU   1024                    * library blocksize
SYSNUM   DC    X'0100'                 * SYS number for O/PVTOC macros
THEKEY2  DC    X'0000000001'           * 2nd KEY for VSAM GET
         DC    XL39'00'
DLISTADR DS    XL(DLLEN)               * space for vol descriptor list
*    Table describing the location of the library's extents.          *
XTNTTAB  DS    0F                      * table describing extents
XTNTLO   EQU   *-XTNTTAB               * lo extent  (CCHH)
         DC    F'-1'
XTNTHI   EQU   *-XTNTTAB               * hi extent  (CCHH)
         DC    F'0'
XTNTRECS EQU   *-XTNTTAB               * highest rec num held in it
         DC    F'0'
XTNTADDR EQU   *-XTNTTAB               * SYStem logical unit its on
         DC    F'0'
XTNTLEN  EQU   *-XTNTTAB               * length of table entry
         DC    15F'-1,0,0,0'                    * a few more entries
XTNTNUM  EQU   (*-XTNTTAB)/XTNTLEN     * number of entries
         DC    F'-1',F'0',F'0',F'0'    * dummy entry to mark end of tab
*    Table describing the volsers of all ASSGNed disks.               *
VOL1TAB  EQU   *                       * table of volids assgn'd
VOL1VOL  EQU   *-VOL1TAB,6             * the volser
         DC    CL6' '
VOL1LEN  EQU   *-VOL1TAB               * length of entry
         DC    15CL6' '                * space for entries
VOL1NUM  EQU   (*-VOL1TAB)/VOL1LEN     * number of entries
         DC    CL6' '                  * dummy entry to mark end of tab
*    CCWs and data.                                                   *
SEEKDATA DC    X'000000000000'         * used by SEEK command
SEIDDATA DC    X'0000000000'           * used by SEID command
CCWADDR  CCW   X'07',SEEKDATA,X'40',6  * seek extent
SEIDADDR CCW   X'31',SEIDDATA,X'40',5  * search for record
TIC      CCW   X'08',SEIDADDR,X'40',5  * loop till find it
CCWCMD   CCW   X'06',VBUF,X'00',RECLEN * read it
*    Bits n bobs.                                                     *
BUILTFLG DC    C'N'                    * indicates if extent tab built
CVDWORK  DS    1D                      * work area for decimal convert
EDPATRN  DC    X'4020202020202120'     * same again
SAVE     DS    18F                     * save area
*    The LITERAL POOL because can't address if after VBUF.            *
         LTORG                         * make LITERAL POOL addressable
*    Buffer to read records into.                               *
VBUF     DS    XL(RECLEN)              * my i/o buffer
         END


LIBREXX EXEC

/* Function:   To view the contents of VSE/SP3 (Version 2) libraries  */
/*              from CMS.                                             */
/* Operation:  After the required library has been selected from the  */
/*             menu, the CMSDOS environment is set and all disks that */
/*             the library resides on are ASSGNed to SYS100 onwards.  */
/*             The LIBRCMS module is called to set REXX variables     */
/*             LIBR.0 to LIBR.nnn where nnn is the number of          */
/*             sublibraries (LIBR.0 = nnn), with information relating */
/*             to each sublibrary (name, creation date, and number of */
/*             members).  This information is then displayed in an    */
/*             XEDIT file in which the contents of a sublibrary can   */
/*             be displayed by typing LX beside it in the prefix area.*/
/*             Once a sublibrary's members have been listed, the      */
/*             contents of a member can also be put in a XEDIT file by*/
/*             typing LX beside it.                                   */
/*             Please note that although the LIBRCMS module reads the */
/*             library quite quickly, the process of queuing the      */
/*             entries and using XEDIT to display them can be slow by */
/*             comparison if the number is large.  Therefore you might*/
/*             wish to use some other method of displaying them.      */
/*             However, this would of course lose the flexibillity    */
/*             that XEDIT provides.                                   */
/* Other programs  :                                                  */
/*    LIBREXX  XEDIT  - Profile used when XEDITing.                   */
/*    LIBXEDIT XEDIT  - The LX prefix macro used to list members and  */
/*                      the contents of members.                      */
/*    LIBRCMS  MODULE - Called by LIBREXX EXEC and LIBXEDIT XEDIT to  */
/*                      read the library and place the information in */
/*                      rexx variable LIBR.0 to LIBR.nnn where nnn =  */
/*                      LIBR.0.                                       */
/*    Refer to the LIBRCMS source for detailed information on calling */
/*    the LIBRCMS MODULE.                                             */
/* Display the available libraries and get a selection */
"VMFCLEAR"
ndisks = 0
queue "IJSYSRS     VSE.SYSRES.LIBRARY                        DOSRES N Y"
queue "PRD1        VSE.PRD1.LIBRARY                          DOSRES N N"
queue "PRD2        VSE.PRD2.LIBRARY                          MCAT   Y N"
queue "MGMPROD     LIVE.PROD.LIBRARY                         SPUCT  Y N"
queue "MGMTEST     MGM.TEST.LIBRARY                          UCAT1  Y N"
queue "SASLIB      SAS.TEST.LIBRARY                          UCAT1  Y N"
say
say "                       =====>>>  LIBRCMS  <<<===="
say
say "                     Enter number of the library......"
say
num_libs = queued()
do i = 1 to num_libs
  pull libname.i libid.i libcat.i libvsm.i libsys.i .
  say "        "i")    "left(libname.i,8)"    "left(libid.i,44),
                                                         "    "libcat.i
end
pull lib_wanted .
if lib_wanted < 0 | lib_wanted > num_libs | datatype(lib_wanted) ¬=
                                         "NUM" then signal exit_program
/* Setup the enviroment to run LIBRCMS MODULE */
/* LIBRCMS MODULE reads these variables to get library characteristics*/
LibrKEY = libid.lib_wanted             /* filename        */
LibrVSM = libvsm.lib_wanted            /* VSAM (Y/N)      */
LibrSYS = libsys.lib_wanted            /* IJSYSRS (Y/N)   */
/* Make NUCXLOADable to save above info across successive executions */
"SET CMSTYPE HT"
"NUCXLOAD LIBRCMS (PUSH"
"DLBL * CLEAR"
/* Setup the MASTER catalogue if needed */
if LibrVSM = "Y" then call setup_MCAT
/* Setup the USER catalogue or disks */
interpret "CALL setup_"libcat.lib_wanted
"SET DOS ON (VSAM"
if LibrVSM = "Y" then do
  "ASSGN SYSCAT "mcat_mode
  "DLBL IJSYSCT  "mcat_mode" (VSAM SYSCAT"
end
/* ASSGN all disks to SYS100 onwards */
do i = 1 to ndisks
  "ASSGN SYS"99+i free_mode.i
end
/* ASSGN IGN last one to stop OVTOC falling over */
"ASSGN SYS"100+ndisks" IGN"
"SET CMSTYPE RT"
/* Read the library */
"LIBRCMS"
if rc ¬= 0 then signal exit_program
if libr.0 = 0 then do
  say
  say "NO SUBLIBRARIES AVAILABLE"
  say
  signal exit_program
end
/* Queue up data and XEDIT file */
do i = 1 to libr.0
 sublib = substr(libr.i,1,8)
 num_members = substr(libr.i,17,6)
 create_date = substr(libr.i,14,2)"/"substr(libr.i,12,2)"/"substr(libr.i,10,2)
queue "INPUT          "sublib"           "create_date"              "num_members
end
queue "SET RESERVE 24 GREEN  REVV HIGH",
                    "***Put LX in the prefix area to view a sublib*** "
queue "SET RESERVE 2  GREEN  REVV HIGH               ",
                      "Sublibrary         Create date        No members"
/* This avoids XEDITing an existing file on disk */
push "FN "libname.lib_wanted
push "FT $$SLIB$$"
"XEDIT $LIBREXX LIBREXX$ A (PROF LIBREXX"
exit_program:
"SET DOS OFF"
"NUCXDROP LIBRCMS"
do i = 1 to ndisks
  "RELEASE "free_mode.i" (DET"
end
exit
setup_UCAT1:
call getadisk
"CP LINK SP3TEST 242 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
"DLBL IJSYSUC  "free_mode.ndisks" DSN MGM001.USER.CATALOG   (VSAM"
call getadisk
"CP LINK SP3TEST 244 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
return
setup_DOSRES:
call getadisk
"CP LINK SP3TEST 240 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
return
setup_SPUCT:
call getadisk
"CP LINK SP3TEST 241 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
"DLBL IJSYSUC  "free_mode.ndisks" DSN VSESP.USER.CATALOG   (VSAM"
call getadisk
"CP LINK SP3TEST 240 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
return
setup_MCAT:
call getadisk
mcat_mode = free_mode.ndisks
"CP LINK SP3TEST 240 "free_addr.ndisks" RR VSEIPO"
"ACCESS "free_addr.ndisks free_mode.ndisks
"DLBL IJSYSUC  "free_mode.ndisks" DSN VSAM.MASTER.CATALOG  (VSAM "
return
getadisk:
ndisks = ndisks + 1
"GETFMADR"
pull . free_mode.ndisks free_addr.ndisks .
return


LIBXEDIT XEDIT

/* This macro processes the LX prefix macro requests to list members  */
/* in a sublibrary or the contents of a member.                       */
/* If the filetype of the file in which it is issued is $$SLIB$$ then */
/* LIBXEDIT assumes it is a list of sublibraries created by LIBREXX   */
/* EXEC and sets about listing the members in that sublibrary,        */
/* otherwise it displays the contents of the member.                  */
/* Note that LIBRCMS only supports the XEDITing of members with an 80 */
/* byte record format (this includes most types except PHASEs and     */
/* DUMPs).                                                            */
arg . . lineno .
"EXTRACT /FN/FT/LINE"
":"lineno
"STACK 1"
":"line.1
/* Should I list a sublibrary or a member */
if ftype.1 ¬= "$$SLIB$$" then signal xedit_member
pull slib_name .
/* Read the sublibrary directory */
"SET LINEND OFF"     /* set control chars off in case in sublib name */
"SET ESCAPE OFF"
"SET ARB OFF"
"CMS LIBRCMS "slib_name
libr_rc = rc
"SET LINEND ON"     /* set control chars back on again */
"SET ESCAPE ON"
"SET ARB ON"
if libr_rc ¬= 0 then do
  "EMSG Error code "rc" from LIBR MODULE."
  exit
end
/* Queue and XEDIT it */
"DESBUF"
queue "XEDIT $$LIBR$$ $$LIBR$$ A (PROF LIBREXX"
queue "SET RESERVE 24 GREEN  REVV HIGH                ",
                 "***Put LX in the prefix area to look at a member*** "
queue "SET RESERVE 2 GREEN REVV HIGH           ",
        "Member name     Member type      Create date     Replace date"
queue "FN "fname.1
queue "FT "slib_name
do i = 1 to libr.0
 cdate = substr(libr.i,23,2)"/"substr(libr.i,21,2)"/"substr(libr.i,19,2)
 if substr(libr.i,26,6) = "      " then rdate = "        "
    else rdate = substr(libr.i,30,2)"/"substr(libr.i,28,2)"/"substr(libr.i,26,2)
 queue "INPUT      "substr(libr.i,1,8)"         "substr(libr.i,10,8)"       ,
"cdate"        "rdate
end
exit
xedit_member:
pull member_name member_type .
/* Don't allow non-80 byte record format members to be XEDIT'd */
if member_type = "PHASE" | member_type = "DUMP" then do
  "EMSG XEDIT not supported for this type of member."
  exit
end
/* Read a member */
"SET LINEND OFF"     /* set control chars off in case in member name */
"SET ESCAPE OFF"
"SET ARB OFF"
"CMS LIBRCMS "ftype.1 member_name member_type
libr_rc = rc
"SET LINEND ON"     /* set control chars back on again */
"SET ESCAPE ON"
"SET ARB ON"
if libr_rc ¬= 0 then do
  "EMSG Error code "rc" from LIBR MODULE."
  exit
end

/* Queue and XEDIT it */
"DESBUF"
queue "XEDIT $$LIBR$$ $$LIBR$$ A (PROF LIBREXX"
queue "FN "member_name
queue "FT "member_type
queue "PREFIX OFF"
queue "SCALE ON 2"
do i = 1 to libr.0
  queue "INPUT "libr.i
end
exit


LIBREXX XEDIT

/* Profile for XEDIT files created by LIBREXX EXEC and LIBXEDIT XEDIT.*/

/* You may change these colours to suit yourself */
"SET COLOR FILEAREA BLUE"
"SET COLOR PREFIX BLUE REVV"
"SET CTLCHAR 1 PROTECT GREEN REVV HIGH"

/* Please leave the following commands alone */
"SET CTLCHAR % ESCAPE"
"CASE M I"
"SCALE OFF"
"CURL ON 3"
"NUM ON"
"VER 1 79"
"SET MSGLINE ON 23 OVERLAY"
"SET PREFIX SYNONYM LX LIBXEDIT"
queue "TOP"
/* Make sure control characters aren't processed on INPUT */
"SET IMAG OFF"
"SET LINEND OFF"
"SET ESCAPE OFF"
"SET ARB OFF"
/* Set them back after all data has been input. */
queue "SET LINEND ON"
queue "SET ESCAPE ON"
queue "SET ARB ON"
queue "SET IMAG ON"
exit

Jeremy Carter
Systems Administrator
MGM Assurance (UK)                              c MGM Assurance 1991

