{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013546000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2704156, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 18, "INMDSNAM": "CBT.V500.FILE947.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE947.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00,\\x02'", "DS1TRBAL": "b'\\xd3,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'P\\xf4\\xfd\\xd0\\x00\\x00\\t\\xcf\\x00\\x00\\t\\xd1\\x00\\x0e\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x006\\x01\\x16\\x18\\x7f\\x01\\x16\\x18\\x7f\\x007\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-07-05T00:00:00", "modifydate": "2016-07-05T00:37:36", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  947\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE947\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 74 MEMBERS COUNTED; CUMULATIVE SIZE IS 25,044 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/05/16    00:37:36    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE947": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00(\\x01\\x16\\x18\\x7f\\x01\\x16\\x18\\x7f\\x007\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-07-05T00:00:00", "modifydate": "2016-07-05T00:37:28", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 947 contains articles downloaded from Xephon archives,    *   FILE 947\n//*           from VSE Update magazines, which are now supported    *   FILE 947\n//*           by www.cbttape.org, bu way of permission from Thomas  *   FILE 947\n//*           Publishing and Bob Thomas.  The Xephon company is     *   FILE 947\n//*           now defunct, the rights were given over to Thomas     *   FILE 947\n//*           publishing, who gave the support rights to us.  So    *   FILE 947\n//*           you can now use all this information and code, in     *   FILE 947\n//*           good conscience.                                      *   FILE 947\n//*                                                                 *   FILE 947\n//*           Articles in this file are from March 1991 thru        *   FILE 947\n//*           December 1992.                                        *   FILE 947\n//*                                                                 *   FILE 947\n//*           email:  sbgolob@cbttape.org                           *   FILE 947\n//*                   sbgolob@attglobal.net                         *   FILE 947\n//*                                                                 *   FILE 947\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A00I": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "VSEUPDT"}, "text": "E001 - VSE Update Issue #1  March 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE001A01   Non-volatile cross-job VSE parameters\nE001A02   CPU-ids for VSE\nE001A03   On-line VSE messages under VM\nE001A04   Enhanced POWER queue display\nE001A05   Running CSP batch\nE001A06   Automating the VSE to PC download process\nE001A07   Security when starting VSE\nE001A08   Quick display of devices\nE001A09   VSE/ESA - the way to the future\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x16\\x05O\\x01\\x16\\x05O\\x13\\x16\\x01\\x19\\x01\\x19\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T13:16:04", "lines": 281, "newlines": 281, "modlines": 0, "user": "VSEUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "E001A02": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xa2\\x00\\xa2\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 162, "newlines": 162, "modlines": 0, "user": "VSEUPDT"}, "text": "CPU-ids for VSE\n\nWe run several VSE virtual machines in our VM/VSE\nenvironment, each with its own purpose and CPU-id.  Among\nthese are virtual machines running test CICS, development\nbatch, production CICS, production batch, and VSE pre-\nupgrade test.  The start-up IPL parameters for the different\nvirtual machines are in a VSE procedure called the ASIPROC\n(automatic system initialization procedure).\n\nSince we run VM on two mainframe systems, each logical\nVSE system has a virtual machine defined in both VM\ndirectories.  The logical systems are known to the users in the\ninstallation by their user-ids, which are linked to the use of the\nvirtual machine.  The correct ASIPROC entry for each machine\nis decided by the CPU-id of the machine performing the IPL.\n\nThe CPU-id is composed of four fields:\n\no      Version code (always 'FF' under VM)\n\no      Serial number (can be set by directory option or CP SET command)\n\no      Model number (under VM, same as the base hardware)\n\no      Channel logout (under VM, always 0).\n\nAt start-up, a VSE machine does a store CPU-id operation to\nget its CPU-id, and locate its entry in the ASIPROC.\nUnfortunately, when the virtual machine runs on a different\nphysical system, its CPU-id will not be the same in the 'CPU\nmodel' field, if the base hardware is a different model.  This\nresults in two major and one minor problem:\n\n1      VSAM files defined with a file-id in the format\n      %%SOMENAME are used to provide partition and CPU\n      independence of file-id.  (The same user name\n      SOMENAME can be used by jobs in different partitions\n      and CPUs.)  The file-id built by VSAM consists of the\n      user-supplied name (SOMENAME) with the CPU serial\n      and model numbers appended to it.  A problem arises if a\n      file is built in a particular CPU and partition, by a logical\n      VSE which then moves to a different VM system.  For\n      example, if a job builds file %%MYFIL while in F5 of\n      PRODBAT, it gets a real file-id of\n      MYFIL.F5.C222222.M3033.  If PRODBAT is stopped,\n      and restarted on the other VM system, on a real 4341, the\n      F5 job looking for file %%MYFIL will fail, as it needs to\n      find MYFIL.F5.C222222.M4341.\n\n2      VSE does not recognize the label area previously created,\n      if the current CPU-id has a model number different from\n      that in the original CPU-id.  This requires the label area to\n      be reformatted at IPL when restarting the same logical\n      VSE system on the other real CPU.\n\n3      A minor annoyance is the need to build multiple ASIPROC\n      entries for each logical VSE, with the same CPU serial\n      number but different model numbers.  One entry for each\n      model in the installation is needed for each CPU serial\n      number used.  Entries must also be added if hardware is\n      acquired with a model number not yet in use.\n\nTo solve these problems, and to ensure that logical VSE\nmachines will have a fixed CPU-id, without being affected by\nthe hardware model the virtual machine is running on, I\ninstalled the following mod to CP.\n\nA virtual machine can get its CPU-id in two ways, either by a\nCP query (as a CMS user would do), or with the STIDP (store\nCPU-id) machine instruction (which is what a VSE machine\ndoes).  Since STIDP is a privileged instruction, it is caught and\nsimulated by VM.  The mod, in DMKPRV simply says: all\nusers performing a STIDP instruction will be given the same\nCPU model number, regardless of the real hardware model.\n(The CP QUERY CPUID command is unaffected by this mod.)\nIn this way, each of our VSE machines gets its standard\n\nCPU-id, without being affected by the real machine in use.\nThe CPU model is always 4341, since that was one of the\nmodels in use here when I wrote the mod, but this can be\nwhatever CPU model type you want.\n\n\nDMKPRV POLCPUID\n\n./ * ALWAYS GIVE '4341' AS MODEL, ON 'ST CPUID'\n./ I 17720000          $ 17720100 100                 11/17/88 20:15:04\n*     LOCAL MOD TO FORCE ALL VSE VIRTUAL MACHINES              %PLCPUID\n*     (AND ANY OTHERS THAT ISSUE 'ST CPUID')                   %PLCPUID\n*     TO MODEL '4341'                                          %PLCPUID\nCHGMODEL MVC   CPUMODEL(2),=XL2'4341'   FORCE MODEL TO '4341'  %PLCPUID\n\nThe lines are inserted following 'MVC\nCPUMODEL(2),CPUMODEL-PSA(R6)' which is 2 lines after\nlabel MAINMODL in the IBM source.\n\nAfter the first part of this article was written we installed a new\nCPU of the 3081 class, which for the first time required an\nIOCP generation.  After setting up a basic IOCP definition\nthrough the hardware frames, and IPLing VM, I attempted to\nstore the full IOCP which I had built in a CMS file.  Even\nthough Q CPUID displayed FFnnnnnn30810000 (nnnnnn being\nthe CPU serial number), I received the error message: ICP400I\nREAD/WRITE OF IOCDS IS INVALID ON THIS\nPROCESSOR.\n\nI immediately guessed that the IOCP program was checking the\nCPU-id with STIDP, and verified this by running IOCP with\nCP PER (PER I B202 R 20000-30000).  When PER caught the\nSTIDP operation (twice) I replaced the model number using CP\nSTORE.  This temporary measure at least allowed the IOCP to\nfinish normally.\n\nWe now decided that all references to 4341 in the CP mod\nwould be changed to 3081, to prevent this IOCP problem in the\nfuture.  This entailed the following steps:\n\n1      One VSE machine was started (still using the old CP mod,\n      with 4341 as the CPU model).\n\n2      The ASIPROC entries were recatalogued with 3081 in the\n\n      CPU-id of the test batch VSE machine.\n\n3      The CP mod was edited, DMKPRV reassembled, and the\n      CP nucleus was rebuilt.\n\n4      On start-up of the VSE test batch system, the lock file had\n      to be reformatted, to remove all the old CPUs (with 4341)\n      already recorded in it.\n\n5      The label area got an 'OVERLAP ON UNEXPIRED FILE'\n      message, and needed to be given a DELETE, since the file\n      was under the name of a CPU of type 4341.\n\n6      Other software, which recognized systems by CPU-id, had\n      to be given the new CPU-ids to use.  These included\n      ZEKE (scheduling system) and DYNAM/T (tape\n      management system).\n\n7      Now that at least one system was up and running with\n      3081, all ASIPROC entries were changed and the other\n      VSE systems could be started.  Each system required a\n      DELETE of the old label area at the first VSE IPL.\n\nThe new version of the mod is given below.\n\n\nDMKPRV POLCPUID\n\n./ * ALWAYS GIVE '3081' AS MODEL, ON 'ST CPUID'\n./ I 17720000          $ 17720100 100                01/01/90 20:11:58\n*     LOCAL MOD TO FORCE ALL VSE VIRTUAL MACHINES             %PLCPUID\n*     (AND ANY OTHERS THAT ISSUE 'ST CPUID')                  %PLCPUID\n*     TO MODEL '3081'                                         %PLCPUID\nCHGMODEL MVC   CPUMODEL(2),=XL2'3081'   FORCE MODEL TO '3081' %PLCPUID\n\nShimon Lebowitz\nVM System Programmer\nIsrael Police National HQ (Israel)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A03": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01\\x15\\x01\\x15\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 277, "newlines": 277, "modlines": 0, "user": "VSEUPDT"}, "text": "On-line VSE messages under VM\n\nWhen working in a VM/VSE environment it is sometimes\nreally frustrating not to be able to display VSE error messages\non-line.  In order to facilitate this we copied the\nVSE.MESSAGES.ONLINE file from VSE to VM.  We named\nit VSEMESG ONLINE, and built the following program,\nwhich is able to read, format and display the requested help\ninformation.  A parameter value of '?' displays a one-line help\ntext.  Make sure that the C'n' (line 95) really is a lower case\n(non-capital) 'n'.\n\n         MACRO\n&LBL     CLS\n&LBL     CNOP   0,8\n         STM    R1,R2,*+52\n         BAL    R1,*+12\n         DC     CL8'CONWAIT'\n         SVC    202\n         DC     AL4(1)\n         LA     R2,009\n         BCR    0,0\n         BAL    R1,*+12\n         DC     X'1900000020FF0001'\n         DIAG   R1,R2,X'0058'\n         LM     R1,R2,*+8\n         B      *+12\n         DS     2F\n         MEND\nVSEHELP  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         BALR  R12,0                   * REGISTER 12 IS BASE REGISTER\n         USING *,R12                   * NOTIFY ASSEMBLER\n         STM   R14,R13,0(R13)          * SAVE OLD REGISTERS\n         ST    R13,SAVEAREA            * SAVE REGISTER STORE PLACE\n         B     VSEHSTRT                * BRANCH TO THE START\n         DC    C'NAME: VSEHELP FACILITY, ASSEMBLED: '\n         DC    C'&SYSDATE '\n         DC    C'&SYSTIME'\n         DC    C', AUTHOR: R.T. HEEMSKERK'\n         TITLE 'BUILD UP WORD TABLES'\nVSEHSTRT CLI   8(R1),X'FF'\n         BE    NOMESG\n         CLI   8(R1),C'?'\n         BE    HELP\n         MVC   ERRMESG(8),8(R1)        * ERROR MESG NUMBER IS PARAMETER\n         FSSTATE FSCB=INFILE,ERROR=NOFILE  * FIND FIRST VSEMESG ONLINE\n         FSOPEN FSCB=INFILE            * OPEN IT\n         FSREAD FSCB=INFILE            * READ FIRST LINE\n         LR    R2,R0                   * SAVE LENGTH IN REGISTER 2\n         L     R7,=A(SPECTAB)          * TABLE FOR OFTEN USED WORDS\n         MVC   TRANSTAB(256),BUFFER+16 * TRANSLATION TABLE IN 1ST LINE\n         LA    R5,BUFFER               * REGISTER 5\n         LA    R5,272(R5)              *   BEING POINTER INTO 1ST LINE\n         S     R2,=F'272'              * 272 CHAR'S = TRANSTAB + HEADER\n         XR    R3,R3                   * REGISTER 3 WILL CONTAIN CHAR'S\nSPECFILL IC    R3,0(R5)                * INPUT CHARACTER FROM LINE\n         STC   R3,SPECMOVE+1           *   = LENGTH OF WORD - 1\n         STC   R3,0(R7)                *   INTO SPECIALS TABLE\nSPECMOVE MVC   1(1,R7),1(R5)           * LENGTH MODIFIED BY R3\n         LA    R7,32(R7)               * R7 POINT TO NEXT IN SPECTABLE\n         LA    R3,1(R3)                * R3 = LENGTH OF WORD\n         AR    R5,R3                   * UPDATE LINE POINTER REGISTER 5\n         LA    R5,1(R5)                *   PAST LENGTH BYTE + WORD\n         SR    R2,R3                   * UPDATE RESTING LINE LENGTH\n         BCT   R2,SPECFILL             * IF NOT ZERO GET NEXT SPECIAL\n         L     R7,=A(WOORDTAB)         * TABLE FOR LESS COMMON WORDS\n         LA    R6,8                    * COUNTER FOR NUMBER OF LINES\nLOOP1    FSREAD FSCB=INFILE            * READ A LINE\n         LR    R2,R0                   * STORE LENGTH INTO REGISTER 2\n         S     R2,=F'12'               * 1ST 12 BYTES NOT OF INTEREST\n         LA    R5,BUFFER               * REGISTER 5 POINTER INTO LINE\n         LA    R5,12(R5)               * PAST 1ST 12 BYTES\nREPEAT   IC    R3,0(R5)                * INSERT CHARACTER FROM LINE\n         STC   R3,MOVE+1               *   = LENGTH OF WORD - 1\n         STC   R3,0(R7)                *   INTO WORDS TABLE\nMOVE     MVC   1(1,R7),1(R5)           * LENGTH MODIFIED BY R3\n         LA    R7,16(R7)               * NEXT ENTRY IN WORDS TABLE\n         LA    R3,1(R3)                * = LENGTH OF WORD\n         AR    R5,R3                   * UPDATE LINE POINTER\n         LA    R5,1(R5)                *   PAST LENGTH BYTE + WORD\n         SR    R2,R3                   * UPDATE RESTING LINE LENGTH\n         BCT   R2,REPEAT               * IF NOT ZERO NEXT WORD\n         BCT   R6,LOOP1                * NEXT LINE, IF NOT ZERO\n         TITLE 'FIND THE LINE CONTAINING THE ERROR CODE'\nFINDCODE FSREAD FSCB=INFILE,ERROR=NOTFOUND * READ NEXT LINE\n         LR    R2,R0                   * REMEMBER LENGTH IN REGISTER 2\n         A     R2,=A(BUFFER)           * + BUFFER ADDRESS = END OF DATA\n         LA    R6,8                    * LENGTH OF ERROR CODE\nLOOPJE   L     R5,=A(BUFFER)           * ADDRESS OF MESG FILE LINE\n         AR    R5,R6                   * OFFSET INTO ERROR CODE\n         CLI   3(R5),C'n'              * 'n' IS ANY NUMBER\n         BE    ISSMALLN                * IF EQUAL, REPLACE THAT N\n         BCT   R6,LOOPJE               * NEXT CHARACTER IN ERROR CODE\n         B     XLATE                   * LAST DONE, GO COMPARE\nISSMALLN LA    R4,ERRMESG              * ADDRESS OF REQUESTED MESG-ID\n         AR    R4,R6                   *   + OFFSET INTO ERROR CODE\n         MVC   3(1,R5),0(R4)           * MOVE INTO MESG FILE LINE\n         BCT   R6,LOOPJE               * GO FOR NEXT CHARACTER\nXLATE    TR    BUFFER+3(8),TRANSUPP    * TRANSLATE MSGCODE TO UPPERCASE\n         CLC   BUFFER+3(8),ERRMESG     * IS IT THE REQUESTED ONE?\n         BL    FINDCODE                * NOT YET, GO TO NEXT LINE\n         BH    NOTFOUND                * PAST CODE => IT DOESN'T EXIST\n         TITLE 'PROCESS THE ERROR MESSAGE'\n         CLS                           * CLEAR THE SCREEN\n         WRTERM ERRMESG,8              * FIRST SCREEN LINE = ERRORCODE\n         WRTERM ' '                    * EMPTY LINE\n         LA    R5,BUFFER               * REGISTER 5 POINTER INTO LINE\n         LA    R5,12(R5)               * 1ST 12 BYTES NOT OF INTEREST\nLOOPMESG IC    R3,0(R5)                * LENGTH OF INPUT-LINE-PART\n         LA    R5,1(R5)                * POINT PAST LENGTH BYTE\n         LA    R4,OUTBUF               * REG 4 POINTER IN SCREEN OUTPUT\nNEXTCHAR MVC   LETTER(1),0(R5)         * GET NEXT CHARACTER IN INPUT\n         TR    LETTER(1),TRANSTAB      * TRANSLATE WITH MESG-TRANSL-TAB\n         CLI   LETTER,X'9C'            * OUTCOME A X'9C' CHARACTER?\n         BE    SPECIAL                 * THEN SPECIAL PROCESSING\n         CLI   LETTER,X'B1'            * X'B1' MEANT TO BE BOLDFACE\n         BE    IGNORE                  * NOT IMPLEMENTED\n         CLI   LETTER,X'B2'            * X'B2' MEANT END BOLDFACE\n         BE    IGNORE                  * NOT IMPLEMENTED\n         B     UPDATER4                * SKIP NEXT\nJUSTSPCE MVI   LETTER,C' '             * LET LETTER IS A SPACE\nUPDATER4 MVC   0(1,R4),LETTER          * PUT CHARACTER IN SCREEN OUTPUT\n         LA    R4,1(R4)                * UPDATE SCREEN OUTPUT POINTER\nIGNORE   LA    R5,1(R5)                * POINT TO NEXT INPUT CHARACTER\nDONE     BCT   R3,NEXTCHAR             * NOT LAST OF INPUT PART? NEXT!\n         S     R4,=A(OUTBUF)           * POINTER OUTPUT - STARTOUTPUT\n         WRTERM OUTBUF,(R4)            *   = LENGTH; OUTPUT TO SCREEN\n         CLR   R5,R2                   * END OF LINE?\n         BNL   ENDMESG                 * THEN GO CLOSE ETC.\n         CLI   0(R5),X'00'             * NEXT CHARACTER IS X'00' ?\n         BNE   LOOPMESG                * NO, GO PROCESS NEXT INPUT PART\n         WRTERM ' '                    * YES, WRITE BLANK LINE\n         LA    R5,1(R5)                * POINT PAST X'00' CHARACTER\n         B     LOOPMESG                * GO PROCESS NEXT INPUT PART\n         TITLE 'PROCESSING OF SPECIAL CHARACTERS'\nSPECIAL  CLI   0(R5),X'20'             * IF CHARACTER'S X-VALUE < 20\n         BL    ISSPEC                  * THEN FIND IT IN OFTEN USED TAB\n         BE    JUSTSPCE                * IF = 20 THEN MAKE IT A SPACE\n         CLI   0(R5),X'30'             * IF CHARACTER'S X-VALUE < 30\n         BL    NEWLINE                 * THEN DO TAB PROCESSING\n         BE    TIMES3                  * IF = 30 THEN NEXT CHAR 3 TIMES\n         LH    R6,0(R5)                * ELSE IN COMMON WORD TABLE\n         N     R6,=X'000003FF'         * LAST 10 BYTES = WORD NUMBER\n         SLL   R6,4                    * TIMES 16 = OFFSET IN TABLE\n         A     R6,=A(WOORDTAB)         * + ADDRESS TABLE = ABSOLUTE ADD\n         TM    0(R5),X'08'             * IF '08' BIT NOT SET\n         BZ    NOSPACE                 * SKIP FOLLOWING 2 LINES\n         MVI   0(R4),C' '              * IF SET, MOVE A SPACE BEFORE\n         LA    R4,1(R4)                * UPDATE SCREEN OUTPUT POINTER\nNOSPACE  XR    R7,R7                   * MAKE REGISTER 7 ZERO\n         IC    R7,0(R6)                * GET LENGTH OF THE WORD - 1\n         STC   R7,MOVE2+1              * TO BE MOVED\n         STC   R7,TRANSL+1             * AND PERHAPS TO BE UPPERCASE'D\nMOVE2    MVC   0(1,R4),1(R6)           * LENGTH MODIFIED BY R7\n         LR    R8,R4                   * SAVE SCREEN OUTPUT POINTER\n         AR    R4,R7                   * UPDATE SCREEN OUTPUT POINTER\n         LA    R4,1(R4)                *   WITH WORDLENGTH\n         TM    0(R5),X'10'             * IF '10' BIT NOT SET\n         BZ    CHCK1ST                 * SKIP THE FOLLOWING LINE\nTRANSL   TR    0(1,R8),TRANSUPP        * MAKE WORD UPCASE, LENGTH MODIF\nCKCK1ST  TM    0(R5),X'20'             * IF '20' BIT NOT SET\n         BZ    CHCKENDS                * SKIP THE FOLLOWING LINE\n         TR    0(1,R8),TRANSUPP        * MAKE FIRST CHARACTER UPPERCASE\nCHCKENDS TM    0(R5),X'04'             * IF '04' BIT NOT SET\n         BZ    NOENDSP                 * SKIP THE FOLLOWING 2 LINES\n         MVI   0(R4),C' '              * PUT SPACE AFTER THE WORD\n         LA    R4,1(R4)                * UPDATE SCREEN OUTPUT POINTER\nNOENDSP  LA    R5,2(R5)                * 2 INPUT BYTES DONE\n         BCTR  R3,0                    * UPDATE INPUT PART POINTER\n         B     DONE                    * RETURN\nNEWLINE  L     R9,=A(OUTBUF)           * ADDRESS OF SCREEN OUPUT BUFFER\n         LA    R9,5(R9)                * PLUS 5 INTO REGISTER 9\n         CLR   R4,R9                   * CURRENT POINTER </= REGISTER 9\n         BNH   MAKETAB                 * THEN DON'T OUTPUT YET\n         S     R4,=A(OUTBUF)           * OUTPUT POINTER - STARTOUTPUT\n         WRTERM OUTBUF,(R4)            * IS OUTPUT LENGTH; OUTPUT\n         L     R4,=A(OUTBUF)           * RESET OUTPUT SCREEN POINTER\nMAKETAB  MVI   0(R4),C' '              * INPUT A SERIES OF 5 SPACES\n         MVC   1(5,R4),0(R4)           * INTO SCREEN OUTPUT BUFFER\n         L     R4,=A(OUTBUF)           * RESET OUTPUT SCREEN POINTER\n         LA    R4,5(R4)                * TO TAB-POSITION\n         LA    R5,1(R5)                * UPDATE INPUT POINTER\n         B     DONE                    * RETURN\nTIMES3   MVC   0(1,R4),1(R5)           * INPUT A SERIES OF 3 CHARACTERS\n         MVC   1(2,R4),0(R4)           * INTO SCREEN OUTPUT BUFFER\n         LA    R4,3(R4)                * UPDATE SCREEN OUTPUT POINTER\n         LA    R5,2(R5)                * UPDATE INPUT POINTER\n         BCTR  R3,0                    * UPDATE INPUT PART POINTER\n         B     DONE                    * RETURN\nISSPEC   XR    R6,R6                   * MAKE REGISTER 6 ZERO\n         IC    R6,0(R5)                * INPUT WORD NUMBER\n         SLL   R6,5                    * TIMES 32 = OFFSET IN TABLE\n         A     R6,=A(SPECTAB)          * + ADDRESS TABLE = ABSOLUTE ADD\n         XR    R7,R7                   * MAKE REGISTER 7 ZERO\n         IC    R7,0(R6)                * GET LENGTH OF WORD - 1\n         LA    R7,1(R7)                * + 1 = LENGTH OF WORD\n         LA    R6,1(R6)                * POINT TO WORD ITSELF\nLOOP2    CLI   0(R6),X'B1'             * X'B1' MEANT TO BE BOLDFACE\n         BE    NXTLOOP2                * NOT IMPLEMENTED\n         CLI   0(R6),X'B2'             * X'B2' MEANT END BOLDFACE\n         BE    SPACEIT                 * IMPLEMENTED AS A SPACE\n         MVC   0(1,R4),0(R6)           * PUT CHAR INTO SCREEN OUTPUT\n         B     UPR4                    * GO UPDATE OUTPUT POINTER\nSPACEIT  MVI   0(R4),C' '              * INSERT SPACE IN SCREEN OUTPUT\nUPR4     LA    R4,1(R4)                * UPDATE SCREEN OUTPUT POINTER\nNXTLOOP2 LA    R6,1(R6)                * UPDATE WORD POINTER\n         BCT   R7,LOOP2                * ALL CHARACTERS OF WORD DONE?\n         LA    R5,1(R5)                * THEN UPDATE INPUT POINTER\n         B     DONE                    * RETURN\n         TITLE 'ERROR MESSAGES AND ENDING LINKAGE'\nNOFILE   WRTERM 'FILE VSEMESG ONLINE * NOT FOUND'\n         MVC   RC,=F'24'               * SET RETURNCODE 24\n         B     EINDE                   * END OF PROGRAM\nNOTFOUND WRTERM 'ERROR CODE NOT FOUND' *\n         MVC   RC,=F'28'               * SET RETURNCODE 28\nENDMESG  FSCLOSE FSCB=INFILE           * CLOSE INPUT FILE\nEINDE    L     R13,SAVEAREA            * GET REGISTER SAVE ADDRESS\n         LM    R14,R11,0(R13)          * RESTORE OLD REGISTERS\n         L     R15,RC                  * GET RETURNCODE\n         BR    R14                     * RETURN TO CMS\nNOMESG   WRTERM 'NO ERROR CODE SPECIFIED'\n         MVC   RC,=F'24'               * SET RETURNCODE 24\n         B     EINDE\nHELP     WRTERM 'FORMAT: VSEHELP MSG-ID'\n         B     EINDE\n         TITLE 'VARIABLES, CONSTANTS AND TABLES'\nSAVEAREA DS    F                       * STORE FOR REGISTER 13\nRC       DC    F'0'                    * STORE FOR RETURNCODE INIT 0\nERRMESG  DS    CL8                     * STORE FOR ERRORMESG CODE\nLETTER   DS    C                       * STORE FOR INPUT CHARACTER\nOUTBUF   DS    CL80                    * STORE FOR SCREEN OUTPUT\nINFILE   FSCB  'VSEMESG ONLINE *',BUFFER=BUFFER,BSIZE=16384\nTRANSTAB DS    128CL2                  * STORE FOR TRANSLATION TABLE\nTRANSUPP DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         LTORG                         * LITERAL POOL INSERTED HERE\n         DS    0D                      * ALIGN\nBUFFER   EQU   *                       *\nBUFDUM   CSECT                         *\n         DS    32CL128                 * 4K INPUT BUFFER\nWOORDTAB DC    128CL128' '             * COMMON WORD TABLE\nSPECTAB  DC    32CL32' '               * FAST OFTEN USED WORD TABLE\n         END\n\nR T Heemskerk\nSystems Programmer (The Netherlands)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A04": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\x08\\x06W\\x06V\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:08:44", "lines": 1623, "newlines": 1622, "modlines": 0, "user": "VSEUPDT"}, "text": "Enhanced POWER queue display\n\nI wrote the article Display the VSE/POWER queues that was\npublished in the VSE Yearbook 1990.  Since then I have made\nmany changes to the code.  These changes result in:\n\no      The ability to browse entries (and to copy the entries to a\n      CMS disk).\n\no      Faster retrieval of the entries.\n\no      Displaying entries from shared and non-shared POWER.\n\no      It works with POWER 2.3 and 4.1.\n\nPOWER maintains a copy of the IJQFILE in storage when\nrunning non-shared.  The program is slightly slower when\ndisplaying entries from a non-shared POWER.  This is because\nit has to read the IJQFILE sequentially and sort the entries\nafterwards.  The sorting is done in storage.\n\nThe program does not use any disk space when running.  The\nprogram must know where the IJQFILE and IJDFILE starts.\nThe VSE-id must own the mini-disks on which the IJQFILE\nand IJDFILE resides.\n\nThe program runs under VM/SP HPO Version 5, and the\nPOWER files are on 3380s.\n\n\nPWRQ EXEC\n\n/** PWRQ - Display VSE/POWER queues.                                 **/\n Address COMMAND\n Arg Input\n Parse Value Diag(8,'QUERY TERM') With 'BRKKEY' Brkkey ','\n Parse Value Diag(8,'QUERY SET') With,\n      'MSG' Msg ',' 'EMSG' Emsg ',' 'IMSG' Imsg ','\n Dosflag = Cmsflag('DOS')\n'CP SET  MSG OFF'\n'CP SET IMSG OFF'\n'CP SET EMSG OFF'\n'CP TERM BRKKEY NONE'\n'SET DOS OFF'\n Push Input\n'XEDIT PWRDUMMY' Userid() 'A (PROFILE PWRQPROF'\n Rx = Rc\n'CP SET  MSG' Msg\n'CP SET IMSG' Imsg\n'CP SET EMSG' Emsg\n'CP TERM BRKKEY' Brkkey\n If Dosflag = 1 Then 'SET DOS ON'\n Exit Rx\n\n\nPWRQPROF XEDIT\n\n/** PWRQPROF  - Profile for the VM VSE/POWER queue display program.  **/\n      Trace Off\n      Signal On Syntax\n      Pull Vseid Command\n      Parse Value Command With Queue ',' Rest\n     'SET MSGLINE ON -2 1 OVERLAY'\n     'SET MSGMODE ON'\n     'SET CMDLINE OFF'\n     'SET TOFEOF  OFF'\n     'SET PREFIX  OFF'\n     'SET SCALE   OFF'\n     'SET LINEND  OFF'\n     'SET REMOTE  ON'\n     'SET ENTER   ONLY'\n     'SET CTLCHAR -   ESCAPE'\n     'SET CTLCHAR \"   PROTECT RED   BLI    HIGH'\n     'SET CTLCHAR #   PROTECT RED   NONE   HIGH'\n     'SET CTLCHAR %   PROTECT WHI   NONE   HIGH'\n     'SET CTLCHAR <   PROTECT BLU   NONE NOHIGH'\n     'SET CTLCHAR \u00ac   PROTECT GREEN NONE NOHIGH'\n     'SET CTLCHAR >   PROTECT YEL   NONE NOHIGH'\n     'SET CTLCHAR &   PROTECT BLU   REV  NOHIGH'\n     'SET CTLCHAR \\ NOPROTECT GREEN NONE NOHIGH'\n     'SET CTLCHAR / NOPROTECT WHITE NONE   HIGH'\n     'SET CTLCHAR ! NOPROTECT GREEN NONE   HIGH'\n     'EXTRACT /LSCREEN/NONDISP/'\n     'SET NONDISP'\n/**          D e f i n e   t h e   V S E   s y s t e m s             **/\n/** Format of the 'Vse.' variable is:                                **/\n/** Vse.VSENAME = 'VSEOWN QPASS QCUU QSTARTCC QSTARTHH               **/\n/**                       DPASS DCUU DSTARTCC DSTARTHH'              **/\n/**                                                                  **/\n/** VSEOWN   -  VM-userid of mini-disk owner.                        **/\n/** VSENAME  -  VM-userid of your VSE-system.                        **/\n/** xPASS    -  Minidisk read-password to the VSE-system.            **/\n/** QCUU     -  The minidisk CUU. (IJQFILE)                          **/\n/** DCUU     -  The minidisk CUU. (IJDFILE)                          **/\n/** QSTARTCC -  Start CYLINDER of the IJQFILE.                       **/\n/** QSTARTHH -  Start  HEAD    of the IJQFILE.                       **/\n/** DSTARTCC -  Start CYLINDER of the IJDFILE.                       **/\n/** DSTARTHH -  Start  HEAD    of the IJDFILE.                       **/\n      Vse. = ' '\n      Vse.VSEIPO   = 'VSEPROD  VSEIPO   144  79  0 VSEIPO   146  60  0'\n      Vse.VSETEST  = 'VSETEST  VSETEST  24E  63  0 VSETEST  24F 453  0'\n      Vse.VSESERVB = 'VSESERVB VSESERVB 141   0  2 VSESERVB 140  67  0'\n/**                     E n d  o f  d e f i n e                      **/\n      Scale = '*!...+....'\n      Scale = Scale''Space('1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 +',4,'.')\n      Scale = Scale'...'Space('10 .+ 11 .+ 12 .+ 13 .+ 14 .+ 15 .+ 16',\n                                                ' .+ 17 .+ 18 .+',3,'.')\n      Nums = '0123456789'\n      Alfa = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n      Disp1 = 'DK*'\n      Disp2 = 'HLAXY'\n      Q_Head. =\n      Q_Head.RDR = ' Reader Queue   P D C S Cards Rdr From     Date',\n                                              ' Time  User-information'\n      Q_Head.LST = ' List Queue     P D C S Pages CC Prt Form To-User',\n                                        ' Date  Time  User-information'\n      Q_Head.PUN = ' Punch Queue    P D C S Cards CC Pun Form To-User',\n                                        ' Date  Time  User-information'\n      Q_Head.XMT = ' Transmit Queue P D C I Lines To-Node  To-User',\n                                        ' Date  Time  User-information'\n      Q_Scroll = Lscreen.1 - 5\n      D_Scroll = Lscreen.1 - 4\n      ExitRc   = 0\n      QCount   = 0\n      Cursor.1 = 1\n      Call Req_Init\n      If Vseid = '?' | Queue = '?' Then Signal Help\nNew_Q:\n      Chg_Q    = 'NO'\n      Rec.     = '-\u00ac'\n      Call Some_Init\n      If VseId = OldVse Then Signal Vse_Ok\n      OldVse   = Vseid\n/** Check if it's a valid VSE-id.                                    **/\n      If Vse.Vseid = ' ' Then Do\n         If Vseid <> ' ' Then Header = '-#Invalid VSE-id.'\n                         Else Header = ' Enter VSE-id or ? for help.'\n         Cursor.2 = 10\n         OldVse = 'INVALID'\n         Signal QScroll\n         End\n      CC_QStart = Right(Word(Vse.Vseid,4),4,0)\n      HH_QStart = Right(Word(Vse.Vseid,5),4,0)\n      CC_DStart = Right(Word(Vse.Vseid,8),4,0)\n      HH_DStart = Right(Word(Vse.Vseid,9),4,0)\n      Address COMMAND 'CP DETACH 140'\n      Address COMMAND 'CP DETACH 141'\n      Parse Value Diagrc(8,'LINK' Word(Vse.Vseid,1) Word(Vse.Vseid,3),\n                         '140 RR' Word(Vse.Vseid,2)) With Rc . LinkText\n      If Rc <> 0 Then Signal Link_Err\n      Parse Value Diagrc(8,'LINK' Word(Vse.Vseid,1) Word(Vse.Vseid,7),\n                         '141 RR' Word(Vse.Vseid,6)) With Rc . LinkText\n      If Rc <> 0 Then Signal Link_Err\n/** Check if it's a valid queue.                                     **/\nVse_Ok:\n      Cursor.2 =  28\n      Queue = Strip(Queue)\n      Header = Q_Head.Queue\n      If Header = ' ' Then Do\n         Chg_Q = 'YES'\n         If Queue <> ' '  Then Header = '-#Invalid queue - Must be',\n                                                ' RDR, LST, PUN or XMT.'\n                          Else Header = ' Enter queue or ? for help.'\n         Signal QScroll\n         End\n      Call Some_Init\n      QCount   =  0\n      If Rest <> ' ' Then Do\n         Call CmdCheck\n         ReqJname = S.2\n         ReqJnum  = S.3\n         ReqDisp  = S.4\n         ReqSysid = S.5\n         End\n/** Read the VSE/POWER queue and check the result.                   **/\nRefresh:\n      Cursor.1 =  1\n      Rec.     = '-\u00ac'\n      R_Time = Time()\n      Call Some_Init\n      Address COMMAND 'PWRQREAD' Queue CC_Qstart HH_Qstart ReqClass,\n                                      ReqDisp ReqSysid ReqJnum ReqJname\n      If Rc = 99 Then Do\n         Header = ' The' Queue'-queue is empty.'\n         Signal QScroll\n         End\n      If Rec.0  = 0 Then Do\n         Header = '-#No match.'\n         Signal QScroll\n         End\n      If Rc = 99999 Then Do\n         Call Non_Shared_Power\n         Rc = 0\n         End\n      If Rc <> 0 Then Do\n         Rx = rc\n         Rc25_Action = 'Signal QScroll'\n         Signal Rc_Check\n         End\n      Parse Value (Rec.0/Q_Scroll) with TotPage '.' Decimal\n      If Decimal <> ' ' Then TotPage = TotPage + 1\n      Page   = 1\n      QCount = 0\n      Header = Q_Head.Queue\n     'SET NONDISP'\n/** Display the final result and wait for new command.               **/\nQScroll:\n      PreQCount = QCount\n      Do Line=4 To (Lscreen.1-2) By 1\n         QCount = QCount + 1\n        'SET RESERVED' Line 'NOHIGH' Rec.QCount\n         End\nRead:\n      Command = Strip(Command)\n      Pf5   = '        '\n      Pf7   = '     '\n      Pf8   = '     '\n      Enter =\n      If Command <> '?' & Vseid <> '?' Then Do\n         If Chg_Q = 'NO' & OldVse <> 'INVALID' Then Enter =,\n             'Enter=Refresh -& Last refresh:' R_Time\n         If Page <> 0      Then Pf5 = '5=Browse'\n         If Page >  1      Then Pf7 = '7=Bwd'\n         If Page < TotPage Then Pf8 = '8=Fwd'\n         End\n     'SET RESERVED  1 GRE NON NOHIGH' 'VSE-Id:0/\n'Left(Vseid,8)'-\u00acDisplay:-/'Left(Command,30)'-\u00ac'Right(Date(),12) Time()\n     'SET RESERVED  2 GRE NON NOHIGH' ' 'Right(' Page' Page 'of',\n                                                        TotPage,78,'-')\n     'SET RESERVED  3 WHI NON   HIGH' Header\n     'SET RESERVED -2 GRE NON NOHIGH  'Copies('-',79)\n     'SET RESERVED -1 WHI NON   HIGH  Pf:  3=Quit  'Pf5'  'Pf7'  ',\n                                                         Pf8'    'Enter\n     'CURSOR SCREEN' Cursor.1 Cursor.2\n      Cursor.1 = 1\n      Cursor.2 = 28\n      Do Externals()\n         Parse External\n         End\n     'READ NO TAG'\n      Do Queued()\n         Pull Key Num Pos Input\n         Select\n            When Key = 'PFK' Then Do\n                 If Num > 12 Then Num = Num - 12\n                 Address COMMAND 'DROPBUF'\n                 Select\n                    When Num=3  Then Signal Exit\n                    When Num=5  & Pf5 <> ' ' Then Do\n                        'EXTRACT /CURSOR/'\n                         If Cursor.1 < 4 | Cursor.1 > Lscreen.1-2\n                                                  Then Signal Inval_Cur\n                         Lnum = PreQCount + (Cursor.1-3)\n                         Reqname = Substr(Rec.Lnum,3,8)\n                         Reqnum  = Substr(Rec.Lnum,12,5)\n                         SeekOffset = Substr(Rec.Lnum,81,11)\n                         If Reqname <> ' ' Then Signal Browse\nInval_Cur:              'EMSG  Invalid cursor position'\n                         Signal Read\n                         End\n                    When Num=7  Then Do\n                         If Page <= 1 Then Signal Read\n                         Page = Page - 1\n                         QCount = PreQCount - Q_Scroll\n                         If QCount < 0 Then QCount = 0\n                         Signal QScroll\n                         End\n                    When Num = 8  Then Do\n                         If Page = TotPage Then Signal Read\n                         Page = Page + 1\n                         Signal QScroll\n                         End\n                    Otherwise Nop\n                    End\n                 End\n            When Key = 'RES' & Pos = 10 Then Vseid = Strip(Input)\n            When Key = 'RES' & Pos = 28 Then Do\n                 Command = Input\n                 Parse Value Input With Queue ',' Rest\n                 Call Req_Init\n                 Chg_Q = 'YES'\n                 End\n            When Key = 'CMD' Then Do\n                 If Vseid   = '?'      Then Signal Help\n                 If Queue   = '?'      Then Signal Help\n                 If Vseid   = ' '      Then Signal New_Q\n                 If Queue   = ' '      Then Signal New_Q\n                 If OldVse <>  Vseid   Then Signal New_Q\n                 If Chg_Q   = 'YES'    Then Signal New_Q\n                 Signal Refresh\n                 End\n            Otherwise Nop\n            End\n         End\n      Signal Read\n/**                           B R O W S E                            **/\n/** Read the VSE/POWER data file and check the result.               **/\nBrowse:\n      Data.  =\n      Color. = '-<'\n      Address COMMAND 'PWRDREAD' SeekOffset CC_DStart HH_DStart Reqname\n      MaxSize = Rc\n      If Maxsize > 90000 Then Do\n         Rx = Maxsize - 90000\n         Rc25_Action = 'Signal Read'\n         Signal Rc_Check\n         End\n      Data.0 = Abs(Data.0)\n      If Data.0 = 0 Then Do\n         Qcount = PreQcount\n        'EMSG  Entry is empty.'\n         Signal Qscroll\n         End\n      B = Data.0 + 1\n      Data.B  = Copies('*',Maxsize+78)\n      Color.B = '-%'\n      Maxscroll = B\n      DataL = Length(Data.0)\n      B = 0\n     'SET RESERVED  1 WHI NON   HIGH' Strip(Header,L)\n     'SET RESERVED -2 YEL NON NOHIGH  'Copies('-',78)\n      LR = 'L'\n     'SET NONDISP' Nondisp.1\n      Start = 1\n      Stop  = 78\n      OrigCur = 76 - (2 * DataL)\n      SearchL = 22 - (2 * DataL)\n      ScrollCur = Origcur\n      B_Header = 'Queue:-%'Queue'-<  Job:-%'Reqname Reqnum,\n                                                        '  -<Search:-!'\nS_CLear:\n      Search =\nBScroll:\n      PreB = B\n      Do Line=3 To (Lscreen.1-2) By 1\n         B = B + 1\n        'SET RESERVED' Line 'GRE NON NOHIGH',\n                                     Color.B''Substr(Data.B,Start,Stop)\n         End\nBread:\n     'SET RESERVED 1 BLU NON NOHIGH' B_Header''Left(Search,SearchL,'_'),\n                          ||'-<  Line-!'Left(PreB+1,DataL)'-<of' Data.0\n      If Stop  < Maxsize Then Pf11 = '11=Right'\n                         Else Pf11 = '        '\n      If Start > 1       Then Pf10 = '10=Left'\n                         Else Pf10 = '       '\n     'SET RESERVED  2 YEL NON NOHIGH  'Substr(Scale,Start,Stop)\n      Pf2 = '     '\n      Pf7 = '     '\n      Pf8 = '     '\n      If B < Data.0  Then Do\n         Pf8 = '8=Fwd'\n         Pf2 = '2=Bot'\n         End\n      If Preb > 0 Then Do\n         Pf7 = '7=Bwd'\n         Pf2 = '2=Top'\n         End\n     'SET RESERVED -1 WHI NON   HIGH  Pf:  'Pf2'  3=Return  'Pf7,\n                                      ' 'Pf8'  'Pf10'  'Pf11'  12=Copy'\n     'CURSOR SCREEN 1' ScrollCur\n     'READ NO TAG'\n      Do Queued()\n         Pull Key Num Pos Input\n         Select\n            When Key = 'PFK' Then Do\n                 If Num > 12 Then Num = Num - 12\n                 Select\n                    When Num = 2  & PreB > 0 Then Do\n                         B = 0\n                         Signal S_Clear\n                         End\n                    When Num = 2 Then Do\n                         B = Data.0 - 1\n                         Signal S_Clear\n                         End\n                    When Num = 3  Then Do\n                         QCount = PreQCount\n                        'SET NONDISP'\n                         Signal QScroll\n                         End\n                    When Num = 7  Then Do\n                         B = PreB - D_Scroll\n                         If B < 0 Then B = 0\n                         Signal S_Clear\n                         End\n                    When Num = 8  Then Do\n                         If B >= Data.0 Then B = PreB\n                         Signal S_Clear\n                         End\n                    When Num = 10 Then Do\n                         B = PreB\n                         If Start > 1 Then Do\n                            Start = Start - 40\n                            Stop  = Stop  - 40\n                            End\n                         Signal BScroll\n                         End\n                    When Num = 11 Then Do\n                         B = PreB\n                         If Stop < Maxsize Then Do\n                            Start = Start + 40\n                            Stop  = Stop  + 40\n                            End\n                         Signal BScroll\n                         End\n                    When Num = 12 Then Call MakeCopy\n                    Otherwise Nop\n                    End\n                 End\n            When Key = 'RES' & Pos < 55 Then Do\n                 ScrollCur = Pos\n                 Search = Strip(Translate(Input,' ','_'))\n                 If Search <> ' ' Then Do\n                    B = PreB\n                    Lastmatch = Data.0 + 1\n                    Signal Search\n                    End\n                 End\n            When Key = 'RES' & Pos > 55 Then Do\n                 SCROLLCUR = ORIGCUR\n                 If Datatype(Input,'W') = 1 & Input > 0 Then Do\n                    B = Input - 1\n                    If B >= Data.0 Then B = Data.0 - 1\n                    Signal BScroll\n                    End\n                 End\n            When Key = 'CMD' & Search <> ' ' Then Do\n                 B = PreB + 1\n                 Signal Search\n                 End\n            Otherwise Nop\n            End\n         End\n      Signal Bread\nSearch:\n      If B > Lastmatch Then Do\n         B = PreB\n         Signal S_Clear\n         End\n      Address COMMAND 'DROPBUF'\n      Do Forever\n         B = B + 1\n         If B > Data.0 Then Do\n            B = PreB + 1\n           'EMSG  Target not found.'\n            EOS = 'YES'\n            Lastmatch = 0\n            Leave\n            End\n         If Pos(Search,Data.B) <> 0 Then Do\n            Lastmatch = B\n            Leave\n            End\n         End\n      B = B - 1\n      Signal BScroll\n/**                      S U B R O U T I N E S                       **/\nMakeCopy:\n      Address COMMAND 'DESBUF'\n      Fileid = Reqname Reqnum 'A'\n      TestNum = 0\n      Do Forever\n         Address COMMAND 'STATE' Fileid\n         If Rc <> 0 Then Leave\n         Testnum = Testnum + 1\n         Fileid = Reqname Strip(Reqnum)'-'Testnum 'A'\n         End\n      Address COMMAND 'EXECIO' Data.0 'DISKW' Fileid '(FINIS STEM DATA.'\n      If Rc  = 0 Then 'EMSG  Entry copied to disk - Fileid:' Fileid\n                 Else Do\n                     'EMSG  Rc' Rc 'from EXECIO DISKW.'\n                      Address COMMAND 'ERASE' Fileid\n                      End\n      Return\n/** Initialize some of the variables.                                **/\nSome_Init:\n      Rec. = '-\u00ac'\n      Page    = 0\n      Totpage = 0\n      Return\nReq_Init:\n      ReqClass = '-'\n      ReqDisp  = '-'\n      ReqSysid = '-'\n      ReqJnum  = '-'\n      ReqJname = '-'\n      Return\n/** Check the options that was entered with the requested queue.     **/\nCmdcheck:\n      Rest = Translate(Rest,' ',',')\n      Y    = 1\n      S.  = '-'\n      If Length(Word(Rest,1)) = 1 Then Do\n         If (Queue='RDR' | Queue='XMT') Then Accept_type = 'A'\n                                        Else Accept_type = 'U'\n         If Datatype(Word(Rest,1),Accept_Type) = 1 Then Do\n            ReqClass = Word(Rest,1)\n            Y=2\n            End\n         If Words(Rest) = 1 Then Return\n         End\n      Do QCount=Y To Words(Rest) By 1\n         Find = Word(Rest,QCount)\n         Select\n            When S.5 = '-' & Substr(Find,1,6) = 'SYSID=' Then Do\n                 S.5 = Substr(Find,7)\n                 If Queue =  'XMT' & (S.5 <> 'R' & S.5 <> 'L')\n                                                      Then Signal S_Err\n                 If Queue <> 'XMT' Then;\n                    If S.5 <> ' ' & (S.5 < 1 | S.5 > 9)\n                                                      Then Signal S_Err\n                 If S.5 = ' ' Then S.5 = '00'X\n                 End\n            When S.4 = '-' & Find = 'HOLD'   Then S.4 = 'HL'\n            When S.4 = '-' & Find = 'FREE'   Then S.4 = '*DK'\n            When S.4 = '-' & Substr(Find,1,5) = 'DISP='\n                                              Then S.4 = Substr(Find,6)\n            When S.2 = '-' & Datatype(Find) = 'CHAR' Then Do\n                 If Find             = 'HOLD'    Then Signal S_Err\n                 If Find             = 'FREE'    Then Signal S_Err\n                 If Substr(Find,1,5) = 'DISP='   Then Signal S_Err\n                 If Substr(Find,1,6) = 'SYSID='  Then Signal S_Err\n                 S.2 = Find\n                 If Substr(S.2,1,1) = '*'\n                                     Then S.2 = Strip(Substr(S.2,2))'*'\n                 End\n            When S.3 = '-' & Datatype(Find) = 'NUM'\n                                             Then S.3 = Right(Find,5,0)\n            Otherwise Signal S_Err\n            End\n         End\n      Rest     = ' '\n      Return\nS_Err:\n      Header = '-#Error in search criteria.'\n      Chg_Q  = 'YES'\n      Signal QScroll\n/** Sort the entries. Only if it's a non shared POWER.               **/\nNon_Shared_Power:\n      New.  =\n      NewDate. =\n      Select\n         When Queue = 'RDR' Then Offset = 45\n         When Queue = 'LST' Then Offset = 53\n         When Queue = 'PUN' Then Offset = 53\n         When Queue = 'XMT' Then Offset = 50\n         Otherwise nop\n         End\n      Do A=1 To Rec.0 By 1\n         Parse Value Substr(Rec.A,Offset,11) ,\n                                   With DD '/' +1 MM +2 . +1 HH ':' Min\n         Date.A = MM || DD || HH || Min\n         End\n      A = 1\n      New.1     = Rec.1\n      Newdate.1 = Date.1\nAgain:\n      A = A + 1\n      If A > Rec.0 Then Signal Non_Shared_Exit\n      Moved = 'N'\n      Do B=1 To A By 1\n        If Date.A  < NewDate.B Then Signal Move\n        If Date.A  = NewDate.B & Substr(Rec.A,12,5) < Substr(New.B,12,5)\n                                                       Then Signal Move\n         End\n      If Moved = 'N' Then Do\n         New.A = Rec.A\n         NewDate.A = Date.A\n         End\n      Signal Again\nMove:\n      Moved = 'Y'\n      Do X=A+1 To B+1 By -1\n         Y = X-1\n         New.X = New.Y\n         NewDate.X = NewDate.Y\n         End\n      New.B = Rec.A\n      NewDate.B = Date.A\n      Signal Again\nNon_Shared_Exit:\n      Dnum = 0\n      If Queue = 'RDR' | Queue = 'XMT' Then Do A=1 To Length(Nums) By 1\n         Q_Letter = Substr(Nums,A,1)\n         Call Get Disp1\n         Call Get Disp2\n         End\n      Do A=1 To Length(Alfa) By 1\n         Q_Letter = Substr(Alfa,A,1)\n         Call Get Disp1\n         Call Get Disp2\n         End\n      Drop New.\n      Return\nGet:\n      Arg Disps\n      Do X=1 To Rec.0 By 1\n         If New.X = '' Then Iterate\n         If Substr(New.X,22,1) = Q_Letter Then Do\n            If Pos(Substr(New.X,20,1),Disps) <> 0 Then Do\n               Dnum = Dnum + 1\n               Rec.Dnum = New.X\n               New.X = ''\n               End\n            End\n         End\n      Return\n/** Check returncodes                                                **/\nRc_Check:\n      Address COMMAND 'DROPBUF'\n      Select\n         When Rx =   25 Then Do\n             'EMSG ' Errortext(5)\n              Interpret(Rc25_Action)\n              End\n         When Rx = 1111 Then Do\n             'EMSG  Job' Strip(Reqname) Strip(Reqnum) 'is executing.'\n              Signal Read\n              End\n         When Rx = 1112 Then Do\n             'EMSG  Pointer mismatch - Refresh display and retry.'\n              Signal Read\n              End\n         When Rx =    1 Then Say 'Minidisk not linked.'\n         When Rx =    2 Then Say 'Unit exeption.'\n         When Rx =    3 Then Say 'Wrong length record detected.'\n         When Rx =    5 Then Say 'Device busy or interrupt pending.'\n         When Rx =   13 Then Say 'Permanent I/O error.'\n         Otherwise Say 'Unexpected returncode received.'\n         End\n      ExitRc = Rx\n      Signal Exit\n/** Display the help picture.                                        **/\nHelp:\n      Text. = ' '\n      If Queue  = ' ' | Queue = '?' Then Do\n         Text.1 = ' Enter command'\n         Cursor.2 = 28\n         End\n      If Vseid  = ' ' | Vseid = '?' Then Do\n         OldVse = '?'\n         Text.2 = 'Enter VSE-id'\n         Cursor.2 = 10\n         End\n      If Text.1 <> ' ' & Text.2 <> ' '\n                              Then Header = ' Enter VSE-id and command.'\n                                       Else Header = Text.1''Text.2\n      Page    = 1\n      TotPage = 1\n     'SET RESERVED  4 BLU NON NOHIGH'\n     'SET RESERVED  5 BLU NON NOHIGH  Format: Queue (,class)',\n                           '(,jobname) (,jobnumber) (,SYSID= ) (,FREE)'\n     'SET RESERVED  6 BLU NON NOHIGH                        ',\n                            '(,*jobname)                        (,HOLD)'\n     'SET RESERVED  7 BLU NON NOHIGH' Copies(' ',58),\n                                                  '(,DISP=dispositions)'\n     'SET RESERVED  8 BLU NON NOHIGH'\n     'SET RESERVED  9 BLU NON NOHIGH  Valid queues: RDR, LST, PUN',\n                                                              'or XMT.'\n     'SET RESERVED 10 BLU NON NOHIGH'\n     'SET RESERVED 11 BLU NON NOHIGH'\n     'SET RESERVED 12 BLU NON NOHIGH  SYSID= must be R or L for',\n                   'XMT-queue and 1-9 (or blank) for the other queues.'\n     'SET RESERVED 13 BLU NON NOHIGH  If you specify class it must',\n                          'be entered before any of the other options.'\n     'SET RESERVED 14 BLU NON NOHIGH'\n     'SET RESERVED 15 BLU NON NOHIGH' ' 'Center('-%Examples-<',80,'*')\n     'SET RESERVED 16 BLU NON NOHIGH  * RDR,A,FREE          ',\n               'The free RDR-entries in class A.                      *'\n     'SET RESERVED 17 BLU NON NOHIGH  * PUN,FREE            ',\n               'All free PUN-entries.                                 *'\n     'SET RESERVED 18 BLU NON NOHIGH  * LST,*CICS,HOLD      ',\n               'All held LST-entries starting with CICS.              *'\n     'SET RESERVED 19 BLU NON NOHIGH  * LST,H,FREE,*CICS    ',\n               'The free LST-entries starting with CICS in class H.   *'\n     'SET RESERVED 20 BLU NON NOHIGH  * LST,DISP=DL         ',\n               'All LST-entries with disposition D or L.              *'\n     'SET RESERVED 21 BLU NON NOHIGH  * RDR,SYSID=,FREE     ',\n               'All free RDR-entries with SYSID=blank.                *'\n     'SET RESERVED 22 BLU NON NOHIGH' ' 'Left('*',78,'*')\n      Do X=23 To Lscreen.1 By 1\n        'SET RESERVED' x 'BLU NON NOHIGH'\n         End\n      Signal Read\n/** A CP LINK error occured.                                         **/\nLink_Err:\n      ExitRc = Rc\n      Say Strip(Linktext)\n      Signal Exit\nSyntax:\n      Signal Off Syntax\n      Say Errortext(Rc) '- Error detected in line' Sigl\n      Signal Exit\n/**                     P R O G R A M   E X I T                      **/\nExit:\n     'SET NONDISP' Nondisp.1\n      Address COMMAND\n     'CP DETACH 140'\n     'CP DETACH 141'\n     'DROPBUF'\n      Address XEDIT 'COMMAND QUIT' ExitRc\n      Exit\n\n\nPWRQREAD ASSEMBLE\n\n** PWRQREAD - Read the POWER queue file ** POWER Version 2 Release 3 **\n**                                      ** POWER Version 4 Release 1 **\n** Return codes: 1 - MINIDISK NOT LINKED.                            **\n**               2 - UNIT EXCEPTION.                                 **\n**               3 - WRONG LENGTH RECORD DETECTED.                   **\n**               5 - DEVICE BUSY OR INTERRUPT PENDING.               **\n**              13 - PERMANENT I/O ERROR.                            **\n**              25 - NO MORE STORAGE.                                **\n**              88 - PROGRAM ERROR DETECTED.                         **\n**              99 - QUEUE IS EMPTY.                                 **\n**           99999 - NON SHARED POWER.                               **\nPWRQREAD CSECT\nR0       EQU     0                     PARAMETER LIST\nR1       EQU     1                     PARAMETER LIST\nR2       EQU     2                     OFFSET POINTER\nR3       EQU     3                     ADDRESS OF READCCW\nR4       EQU     4                     WORK\nR5       EQU     5                     WORK\nR6       EQU     6                     CUU OF DISK TO READ\nR7       EQU     7                     WORK\nR8       EQU     8                     WORK\nR9       EQU     9                     WORK\nR10      EQU     10                    BASE FOR RDR-, LST- ,XMTDISPL\nR11      EQU     11                    BASE FOR SHVBLOCK\nR12      EQU     12                    BASE\nR13      EQU     13                   *NOT USED\nR14      EQU     14                    BAL / RETURN\nR15      EQU     15                    RETURN CODE\n         USING   PWRQREAD,R12\n         ST      R14,SAVERET\n         MVC     QUEUE(1),8(R1)        THE REQUESTED QUEUE\n         MVC     REQCLASS(1),32(R1)                  CLASS\n         MVC     REQDISP(8),40(R1)                   DISPOSITION(S)\n         MVC     REQSYSID(1),48(R1)                  SYSID\n         MVC     REQJNUM(5),56(R1)                   JOBNUMBER\n         MVC     REQJNAME(8),64(R1)                  JOBNAME\n         MVC     WORKD(4),16(R1)       IJQFILE START CYLINDER\n         BAL     R14,PACK              PACK CYLINDER NUMBER\n         STH     R7,INITCC             SAVE IT\n         STCM    R7,B'0011',ICC\n         MVC     WORKD(4),24(R1)       IJQFILE START HEAD\n         BAL     R14,PACK              PACK HEAD NUMBER\n         STH     R7,INITHH             SAVE IT\n         STCM    R7,B'0011',IHH\n         LA      R3,READCCW            R3 = ADDRESS OF CCWLIST\n         LH      R6,CUU                R6 = LINKED CUU\n         BAL     R14,DIAG0018          READ INTERNAL RECORD\n         LH      R5,IREC+2             GET OFFSET OF MASTER-RECORD\n         BAL     R14,DISKPOS           CALCULATE CCHHR\n         LA      R4,QCRM\n         STCM    R4,B'0111',READADDR\n         LA      R4,1062\n         STCM    R4,B'0111',READSIZE\n         BAL     R14,DIAG0018          READ MASTER RECORD\n         LA      R4,QBLOCK\n         STCM    R4,B'0111',READADDR\n         L       R4,ONEPAGE\n         STCM    R4,B'0111',READSIZE\n         CLI     REQJNUM,C'-'          ALL JOBNUMBERS WANTED ?\n         BE      PRGSTART              YES, GO START PROGRAM\n         PACK    WORKD,REQJNUM(5)\n         CVB     R7,WORKD\n         STCM    R7,B'0011',REQJNUM\nPRGSTART EQU     *\n         LA      R11,SHVBUFF           ADDRESSABILITY FOR SHVBLOCK\n         USING   SHVBLOCK,R11\n         MVI     SHVCODE,SHVSTORE      WE WANT TO SET VARIABLES\n         XC      SHVNEXT,SHVNEXT       ONE BY ONE\n         LA      R1,SHVBLOCK\n         ST      R1,SHVADDR\n         MVC     SHVNAMA,=A(VARNAME)   ADDRESS OF VARIABLE NAME\n         MVC     SHVVALA,=A(DISPLAY)   ADDRESS OF VALUE BUFFER\n         LA      R1,91                 LENGTH OF VALUE\n         ST      R1,SHVVALL\n         LA      R1,QTABLE\nQGETLOOP EQU     *\n         CLC     QUEUE(1),12(R1)       CHECK FOR THE REQUESTED QUEUE\n         BE      QFOUND                FOUND, BRANCH\n         LA      R1,16(,R1)            MOVE POINTER\n         B       QGETLOOP              AND TRY AGAIN\nQFOUND   EQU     *\n         XR      R15,R15               SET RETURN CODE TO 0\n         L       R8,0(,R1)\n         MVC     ENTRIES,0(R8)         MOVE THE POINTERS\n         L       R8,4(,R1)\n         MVC     NENTRIES,0(R8)\n         L       R2,8(,R1)             SET OFFSET POINTER\n         TM      SSF1,B'10000000'      SHARED POWER\n         BNO     NSHRPOWR\n         BAL     R14,EMPTYCHK\n**          THIS LOOP GETS THE ENTRIES FROM A SHARED POWER           **\nSHRLOOP  EQU     *\n         BAL     R14,FINDENT           FIND AN ENTRY\n         BAL     R14,CHECKREC\n         B       SHRLOOP               AND DO IT ALL AGAIN\n**        THIS LOOP GETS THE ENTRIES FROM A NON-SHARED POWER         **\nNSHRPOWR EQU     *\n         MVI     SHAREPOW,C'N'         A NON-SHARED POWER\n         XC      SAVER9,SAVER9         CLEAR SAVER9 (=0)\n         B       FIRSTREC              AND BRANCH\nNSHRLOOP EQU     *\n         L       R9,SAVER9             GET SAVED VALUE OF R9\n         CH      R9,MRQRRCN            LOWER THAN RECS IN A REC\n         BL      NOSHARE               YES, BRANCH\nFIRSTREC EQU     *\n         L       R5,RECCOUNT           GET RECORD COUNTER\n         LA      R5,1(,R5)             ADD 1\n         CH      R5,MRQRBLK            R5 >= NUMBER OF RECORDS\n         BNL     NSHREXIT              YES, GO EXIT PROGRAM\n         ST      R5,RECCOUNT           AND STORE VALUE\n         BAL     R14,DISKPOS           CALCULATE CC HH R\n         BAL     R14,DIAG0018          READ QUEUE RECORD\n         LTR     R15,R15               CHECK THE RETURN CODE\n         BNZ     ERREXIT               IF NOT ZERO; GET OUT\n         XC      SAVER9,SAVER9         CLEAR SAVER9 (=0)\nNOSHARE  EQU     *\n         L       R9,SAVER9             GET SAVED VALUE OF R9\n         LR      R5,R9                 R5 = R9\n         MH      R5,MRQRCSZ            MULTIPLY WITH RECORD-SIZE\n         STCM    R5,B'1111',OFFSET     STORE R5 - OFFSET IN BYTES\n         LA      R9,1(,R9)             ADD 1 TO R9\n         ST      R9,SAVER9             AND SAVE THE NEW VALUE\n         CH      R9,MRQRRCN            LOWER THAN RECS IN A REC\n         BH      NSHRLOOP              NO, BRANCH\n         BAL     R14,CHECKREC          CHECK THE RECORD\n         B       NOSHARE               AND DO IT AGAIN\nNSHREXIT EQU     *\n         CLC     VARCOUNT(4),DOBBZERO\n         BNE     EXIT\n         LA      R15,99\n         B       ERREXIT\n**                     P R O G R A M   E X I T                       **\nEXIT     EQU     *\n         LA      R1,16                 LENGTH OF VARIABLE CONTENTS\n         ST      R1,SHVVALL            STORE IT\n         L       R9,VARCOUNT           GET HIGHEST VARIABLE NUMBER\n         BAL     R14,CONVERT           CONVERT TO DECIMAL\n         MVC     DISPLAY(16),DECIMAL   AND MOVE IT\n         LA      R9,0\n         BAL     R14,SETVAR0           SET DATA.0\n         CLI     SHAREPOW,C'Y'         SHARED POWER\n         BE      ERREXIT               YES, BRANCH\n         L       R15,NOSHRRC           ELSE SET RC = 99999\nERREXIT  EQU     *\n         L       R14,SAVERET           RESTORE RETURN ADDRESS\n         BR      R14                   RETURN TO CMS\n**                       S U B R O U T I N E S                       **\n**  READ QUEUE FILE - DIAG X'18' WILL CONVERT TO ECKD WHEN POSSIBLE  **\nDIAG0018 EQU     *\n         LA      R15,1                 NUMBER OF READS IN CCW-LIST\n         DIAG    R6,R3,X'0018'         READ FIRST REC IN IJQFILE\n         BR      R14\n**        CHECK IF THE RECORD SHOULD BE RETURNED TO THE XEDIT        **\nCHECKREC EQU     *\n         ICM     R4,B'1111',OFFSET     GET OFFSET IN BYTES\n         LA      R5,QBLOCK(R4)         ADDRESS OF QBLOCK + OFFSET\n         CLI     42(R5),C'F'           CHECK QIDENT BEFORE MOVE\n         BER     R14                   WAS IT FREE - JUST RETURN\n         MVC     QRECORD(256),0(R5)    MOVE THE RECORD\n         TM      QRS1,B'01000000'      ABENDED QUEUE SET ?\n         BOR     R14                   YES, RETURN\n         CLI     QUEUE,C'X'            THE XMT QUEUE WANTED\n         BNE     CHKQUEUE              NO, SKIP NEXT CHECK\n         TM      QRS1,B'10000000'      QUEUE SET IN XMT QUEUE\n         BNOR    R14                   NO, RETURN\n         MVC     QSYSID,QIDENT         LET SYSID BE = QIDENT (L,R,P)\n         B       CHKSHARE              AND SKIP THE NEXT CHECK\nCHKQUEUE EQU     *\n         TM      QRS1,B'10000000'      QUEUE SET IN XMT QUEUE\n         BOR     R14                   YES, RETURN\n         CLC     QUEUE(1),QIDENT       QIDENT = R, L, P\n         BNER    R14                   NO, RETURN\nCHKSHARE EQU     *\n         CLI     SHAREPOW,C'Y'         IS IT A SHARED POWER\n         BE      CHKCLASS              YES, SKIP NEXT CHECK\n         CLC     QRADD,DOBBZERO        ADD-DATE = 0\n         BER     R14                   YES, IGNORE ENTRY\nCHKCLASS EQU     *\n         CLI     REQCLASS,C'-'         ALL CLASSES WANTED\n         BE      CHKJNUM               YES, GO CHECK JOBNUMBER\n         CLC     REQCLASS,QCLASS       IS THIS THE CLASS\n         BNER    R14                   NO, RETURN\nCHKJNUM  EQU     *\n         CLI     REQJNUM,C'-'          SPECIFIC JOBNUBER WANTED ?\n         BE      CHKSYSID              NO, BRANCH\n         CLC     REQJNUM(2),QNUMBER    IS THIS THE NUMBER\n         BNER    R14                   NO, RETURN\nCHKSYSID EQU     *\n         CLI     REQSYSID,C'-'         ALL SYSIDS  WANTED ?\n         BE      CHKDISP               YES, BRANCH\nCHKSID   EQU     *\n         CLC     REQSYSID,QSYSID       THIS SYSID WANTED ?\n         BNER    R14                   NO, RETURN\nCHKDISP  EQU     *\n         CLI     REQDISP,C'-'          ALL DISPOSITIONS WANTED ?\n         BE      ALLDISP\n         LA      R9,REQDISP\nDISPLOOP EQU     *\n         CLI     0(R9),X'40'           END OF CHECK\n         BER     R14                   YES, JUST RETURN\n         CLC     0(1,R9),QDISP         IS THIS THE DISPOSITION\n         BE      ALLDISP               YES, ACCEPT THE ENTRY\n         LA      R9,1(,R9)\n         B       DISPLOOP\nALLDISP  EQU     *\n         CLI     REQJNAME,C'-'         ALL JOBNAMES WANTED ?\n         BE      ALLNAMES              YES, BRANCH\n         LA      R9,REQJNAME           GET READY TO CHECK NAME\n         LA      R8,QNAME\nNAMELOOP EQU     *\n         CLI     0(R9),C'*'            END OF NAME\n         BE      ALLNAMES              YES, BRANCH\n         CLC     0(1,R9),0(R8)         DOES THIS LETTER MATCH\n         BNER    R14                   NO, JUST RETURN\n         LA      R9,1(,R9)             ADD 1 TO COUNTERS\n         LA      R8,1(,R8)\n         B       NAMELOOP              AND CHECK NEXT\nALLNAMES EQU     *\n         ST      R14,CHKSAVE           SAVE RETURN ADDRESS\n         XR      R9,R9                 CLEAR R9\n         ICM     R9,B'0011',QNUMBER    READY TO CONVERT Q-NUMBER\n         BAL     R14,CONVERT           CONVERT ...\n         MVC     NUMBER,DECIMAL+10     AND MOVE IT\n         L       R9,QSTIME             TIME ENTRY WAS PUT IN QUEUE\n         MVC     TIME,TIMEMASK         SETUP FOR EDIT\n         ED      TIME,QSTIME           EDIT Q-TIME\n         MVC     NAME,QNAME            MOVE THE RELEVANT DATA\n         MVC     PRI,QPRI\n         MVC     CLASS,QCLASS\n         MVC     SYSID,QSYSID\n         MVC     DATE,QDATE\n         MVC     USER,QUSER\n         MVC     DISP,QDISP\n         CLI     QRUN,C'X'             IS THE JOB EXECUTING\n         BNE     CONVQ\n         MVI     DISP,C'*'             YES, SET DISPOSITION = '*'\nCONVQ    EQU     *\n         CLI     QUEUE,C'X'            XMT QUEUE WANTED\n         BNE     CHKRDR                NO, BRANCH\n         BAL     R14,XMTCONV           CONVERT\n         B       CHKEND                AND BRANCH\nCHKRDR   EQU     *\n         CLI     QUEUE,C'R'            RDR QUEUE WANTED\n         BNE     CHKLST                NO, BRANCH\n         BAL     R14,RDRCONV           CONVERT\n         B       CHKEND                AND BRANCH\nCHKLST   EQU     *\n         CLI     QUEUE,C'L'            LST QUEUE WANTED\n         BE      CONVIT                YES, BRANCH\n         CLI     QUEUE,C'P'            PUN QUEUE WANTED\n         BE      CONVIT                YES, SHOULD BE\n         LA      R15,88                ELSE SET RC = 88\n         B       ERREXIT               AND GO END PROGRAM\nCONVIT   EQU     *\n         BAL     R14,LSTCONV           CONVERT\n         B       CHKEND                AND BRANCH\nCHKEND   EQU     *\n         BAL     R14,SETVAR            GO SET THE VARIABLE\n         L       R14,CHKSAVE           GET RETURN ADDRESS\n         BR      R14                   AND RETURN\n**  FIND ENTRIES IN THE POWER QUEUE - ONLY USED FOR A SHARED POWER   **\nFINDENT  EQU     *\n         ICM     R4,B'1111',QNEXT\n         LTR     R4,R4                 MORE ENTRIES IN THE CLASS (\u00ac=0)\n         BNZ     NEXTINQ               YES, GET NEXT IN QUEUE\n         CLI     NDQCHECK,C'N'         NON-DISPATCHABLE QUEUE CHECKED\n         BE      QNLOOP                NO, CHECK IT\nQLOOP    EQU     *\n         MVI     NDQCHECK,C'N'         SET CHECK SWITCH\n         LA      R2,4(,R2)             ADD 4 TO OFFSET\n         C       R2,MAXENTRY           ALL ENTRIES PROCESSED ?\n         BNL     EXIT                  YES - GET OUT\n         LH      R4,ENTRIES+0(R2)      FIRST ENTRY IN A CLASS\n         CH      R4,=H'0'              ANY ENTRIES IN THE CLASS ?\n         BNE     NEXTINQ               YES, GET IT\nQNLOOP   EQU     *\n         MVI     NDQCHECK,C'Y'         SET CHECK SWITCH\n         LH      R4,NENTRIES+0(R2)     FIRST ENTRY IN A CLASS\n         CH      R4,=H'0'              ANY ENTRIES IN THE CLASS ?\n         BE      QLOOP                 NO, GET NEXT CLASS.\nNEXTINQ  EQU     *\n         XR      R5,R5                 CLEAR R5\nRECLOOP  EQU     *\n         CH      R4,MRQRRCN            IS THE RECORD IN THIS BLOCK\n         BL      RECFOUND              YES, BRANCH\n         LA      R5,1(,R5)             ADD 1 TO BLOCK\n         SH      R4,MRQRRCN            SUBTRACT MRQRRCN\n         CH      R4,MRQRRCN            IS RECORD IN BLOCK AT OFFSET 0\n         BE      BLKADD                YES, BRANCH\n         B       RECLOOP               ELSE TRY AGAIN\nBLKADD   EQU     *                     RECORD IS AT OFFSET 0 IN BLOCK\n         SH      R4,MRQRRCN            SUBTRACT MRQRRCN\n         LA      R5,1(,R5)             ADD 1 TO BLOCK\nRECFOUND EQU     *\n         LR      R7,R4                 COPY R4 (R4=RECORD# IN BLOCK)\n         MH      R7,MRQRCSZ            MULTIPLY WITH RECORD-SIZE\n         STCM    R7,B'1111',OFFSET     STORE R7 - OFFSET IN BYTES\n         CL      R5,PREBLOCK           RECORD IN LAST READ BLOCK\n         BER     R14                   YES, DON'T READ AGAIN\n         ST      R5,PREBLOCK           ELSE SAVE BLOCK NUMBER\n         ST      R14,FINDSAVE\n         BAL     R14,DISKPOS           AND CALCULATE CCHHR\n         LA      R15,1\n         DIAG    R6,R3,X'0018'         READ THE QUEUE FILE\n         LTR     R15,R15               CHECK THE RETURN CODE\n         BNZ     ERREXIT               IF NOT ZERO; GET OUT\n         L       R14,FINDSAVE\n         BR      R14                   RETURN\n**               SET THE REXX VARIABLE FOR THE XEDIT                 **\nSETVAR   EQU     *\n         L       R9,VARCOUNT           NUMBER OF VARIABLE\n         LA      R9,1(,R9)             ADD 1\n         ST      R9,VARCOUNT           AND STORE NEW VALUE\nSETVAR0  EQU     *\n         ST      R14,SAVER14           REMEMBER RETURN ADDRESS\n         LA      R4,DECIMAL+15         READY TO CONVERT\n         BAL     R14,CONVERT           CONVERT\n         L       R14,SAVER14           RESTORE RETURN ADDRESS\n         SR      R4,R1                 CALCULATE LENGTH OF NUMBER\n         LA      R5,5(,R4)             SET R5 = R4 + 5\n         ST      R5,SHVNAML            THIS GIVES LENGTH OF VARIABLE\n         EX      R4,MOVEMASK           MOVE THE NUMBER\n         LA      R1,XCOMM              SET UP FOR EXECCOMM\n         LA      R0,EPLIST\n         ICM     R1,B'1000',=X'02'\n         SVC     202\n         DC      AL4(1)                I CHECK FOR ERROR\n         LTR     R15,R15               ANY ERROR\n         BZR     R14                   NO, RETURN\n         LA      R15,25                SET RC = 25\n         B       ERREXIT               AND BRANCH\nMOVEMASK MVC     VARNAME+4(0),0(R1)\n**      PACK AND CVB CONTENTS OF WORKD AND RETURN RESULT IN R7       **\nPACK     EQU     *\n         PACK    WORKD,WORKD(4)\n         CVB     R7,WORKD\n         BR      R14\n**               CALCULATE DISK POSITION OF THE RECORD               **\nDISKPOS  EQU     *\n         XR      R4,R4                 CLEAR R4\n         LH      R7,INITCC             LOAD INITIAL CYLINDER NUMBER\n         LH      R8,INITHH             LOAD INITIAL HEAD     NUMBER\n         D       R4,TEN                DIVIDE WITH BLOCKS PR. CYL. (10)\n         CL      R5,TRACKS             PASSED CYLINDER BOUNDARY\n         BL      NOTPCB                NO, BRANCH\nCYLDIFF  EQU     *                     ELSE ...\n         LA      R7,1(,R7)             ADD 1 TO CYLINDER\n         S       R5,TRACKS             SUBTRACT NUMBER OF TRACKS\n         CL      R5,TRACKS             STILL NOT THE RIGTH CYLINDER\n         BNL     CYLDIFF               NO, BRANCH\n         XR      R8,R8                 SET INIT HEAD = 0\nNOTPCB   EQU     *\n         AR      R5,R8                 CALCULATE HEAD NUMBER\n         STCM    R5,B'0011',IHH        AND STORE IT\n         LA      R4,1(,R4)             ADD 1 TO RECORD NUMBER\n         STCM    R4,B'0001',IRR        AND STORE IT\n         XR      R4,R4                 CLEAR R4\n         D       R4,TRACKS             DIVIDE WITH TRACKS PER CYL.\n         AR      R5,R7                 CALCULATE CYLINDER NUMBER\n         STCM    R5,B'0011',ICC        AND STORE IT\n         BR      R14                   RETURN\n**              CONVERT A BINARY NUMBER TO DISPLAYABLE               **\nCONVERT  EQU     *\n         LA      R1,DECIMAL+15\n         CVD     R9,WORKD              CONVERT R9\n         MVC     DECIMAL,NUMMASK       SETUP FOR EDIT\n         EDMK    DECIMAL,WORKD         EDIT\n         BR      R14                   RETURN\n**               CHECK IF THE REQUESTED QUEUE IS EMPTY               **\nEMPTYCHK EQU     *\n         CLI     QUEUE,C'X'            IS IT THE XMT QUEUE\n         BE      ALLQS                 YES, FORGET THE CLASS CHECK\n         CLI     REQCLASS,C'-'         ALL CLASSES WANTED\n         BE      ALLQS                 YES, BRANCH\n         LA      R2,0\n         LA      R9,VALIDQS\nQTABLOOP EQU     *\n         CLC     0(1,R9),REQCLASS      IS THIS THE CLASS\n         BE      SETMAXQ               YES, BRANCH\n         LA      R9,1(,R9)             MOVE POINTERS\n         LA      R2,4(,R2)\n         B       QTABLOOP              AND TRY AGAIN\nSETMAXQ  EQU     *\n         LA      R9,8(,R2)             MAXENTRY = R2 + 8\n         ST      R9,MAXENTRY\nALLQS    EQU     *\n         CLC     ENTRIES,ENTRYCHK      ANY ENTRIES IN DISP Q\n         BNER    R14                   YES, RETURN\n         CLC     NENTRIES,ENTRYCHK     ANY ENTRIES IN NONDISP Q\n         BNER    R14                   YES, RETURN\n         LA      R15,99\n         B       ERREXIT               AND GO EXIT PROGRAM\nLSTCONV  EQU     *\n         ST      R14,CONVSAVE\n         LA      R10,DREST\n         USING   LSTDISPL,R10\n         XR      R9,R9                 CLEAR R9\n         ICM     R9,B'0001',QCOPY      NUMBER OF COPIES\n         BAL     R14,CONVERT           CONVERT COPY-NUMBER\n         MVC     LSTCOPY,DECIMAL+14    AND MOVE IT\n         LH      R9,QPAGES             NUMBER OF PAGES (LST)\n         CLI     QUEUE,C'L'            LST QUEUE REQUESTED\n         BE      BALCONV               YES, SKIP NEXT LINE\n         L       R9,QRECORDS           NUMBER OF RECORDS (PUN)\nBALCONV  EQU     *\n         BAL     R14,CONVERT           CONVERT NUMBER OF PAGES/RECORDS\n         MVC     LSTPAGE,DECIMAL+10    MOVE NUMBER\n         MVC     LSTCUU,QCUU           AND OTHER DATA\n         MVC     LSTFORM,QFORM\n         MVC     LSTDTU,DTU\n         MVC     LSTUSER,TARGID\n         L       R14,CONVSAVE\n         BR      R14\nXMTCONV  EQU     *\n         ST      R14,CONVSAVE\n         LA      R10,DREST\n         USING   XMTDISPL,R10\n         L       R9,QCOUNT\n         CLI     QIDENT,C'L'           IS IT A TRANSMIT LST\n         BE      XLST                  YES, BRANCH\n         L       R9,QRECORDS\nXLST     EQU     *\n         BAL     R14,CONVERT           CONVERT NUMBER OF RECORDS\n         MVC     XMTRECS,DECIMAL+10    MOVE RECORD NUMBER\n         MVC     SYSID,QIDENT          ... AND OTHER DATA\n         MVC     XMTDTU,DTU\n         MVC     XMTTARG,TARGNAM\n         MVC     XMTORIG,TARGID\n         L       R14,CONVSAVE\n         BR      R14\nRDRCONV  EQU     *\n         ST      R14,CONVSAVE\n         LA      R10,DREST\n         USING   RDRDISPL,R10\n         L       R9,QRECORDS           LOAD NUMBER OF RECORDS\n         BAL     R14,CONVERT           CONVERT NUMBER\n         MVC     RDRRECS,DECIMAL+10    MOVE IT\n         MVC     RDRCUU,QCUU           AND SOME OTHER DATA\n         MVC     RDRORIG,ORIGID\n         MVC     RDRDTU,DTU\n         L       R14,CONVSAVE\n         BR      R14\nWORKD    DS      D\nDOBBZERO DC      D'0'\nTEN      DC      F'10'                 BLOCKS/TRACK    (3380)\nTRACKS   DC      F'15'                 TRACKS/CYLINDER (3380)\nMAXENTRY DC      F'148'\nONEPAGE  DC      F'4096'\nNOSHRRC  DC      F'99999'\nVARCOUNT DC      F'0'\nRECCOUNT DC      F'-1'\nIREC     DS      F\nSAVERET  DS      F\nSAVER9   DS      F\nSAVER14  DS      F\nCHKSAVE  DS      F\nCONVSAVE DS      F\nFINDSAVE DS      F\n*\nEPLIST   DC      A(XCOMM)\n         DC      A(0)\n         DC      A(0)\nSHVADDR  DC      A(0)\n*\nPREBLOCK DC      XL4'FF'\nINITHH   DS      H\nINITCC   DS      H\nCUU      DC      X'0140'               ADDRESS THAT THE EXEC LINKS\nNUMMASK  DC      X'40202020202020202020202020202120'\nTIMEMASK DC      X'2120207A2020'\nVALIDQS  DC      C'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nSHVBUFF  DS      CL32\nDECIMAL  DS      CL16\nVARNAME  DC      CL12'REC.'\nXCOMM    DC      CL8'EXECCOMM'\nQUEUE    DS      CL1\nSHAREPOW DC      C'Y'                  ASSUME IT'S A SHARED POWER\nNDQCHECK DC      C'Y'\nENTRIES  DC      XL148'00'\nNENTRIES DC      XL148'00'\nENTRYCHK DC      XL148'00'\nREQCLASS DS      CL1\nREQSYSID DS      CL1\nREQDISP  DC      CL9' '\nREQJNUM  DC      CL5' '\nREQJNAME DC      CL8' '\n         DC      CL1'*'\nQTABLE   DS      0F\n         DC      A(RDRCLASS),A(RDRNDISP),F'00',CL4'R'\n         DC      A(LSTCLASS),A(LSTNDISP),F'40',CL4'L'\n         DC      A(PUNCLASS),A(PUNNDISP),F'40',CL4'P'\n         DC      A(XMTCLASS-140),A(XMTNDISP-140),F'136',CL4'X'\nQTABEND  EQU     *\nQCRM     DS      0XL1062               THE MASTER RECORD.\n         DS      XL32\nMRQRBLK  DS      XL2                   NUMBER OF QUEUE RECORD BLOCKS\n         DS      XL2\nMRQRRCN  DS      XL2                   NUMBER OF Q-RECS PER Q-REC BLOCK\nMRQRCSZ  DS      XL2                   Q-RECORD COMPARTMENT SIZE\n         DS      XL116\nRDRCLASS DS      XL148                 DISPATCHABLE RDR CLASS AREA.\nLSTCLASS DS      XL148                              LST\nPUNCLASS DS      XL148                              PUN\nXMTCLASS DS      XL8                                XMT\nRDRNDISP DS      XL148             NON-DISPATCHABLE RDR CLASS AREA.\nLSTNDISP DS      XL148                              LST\nPUNNDISP DS      XL148                              PUN\nXMTNDISP DS      XL8                                XMT\n         DS      X\nSSF1     DS      X\n         DS      0F                    MUST BE ON FULLWORD BOUNDARY\nQRECORD  DS      0XL256                THE QUEUE RECORD.\nQDATE    DS      CL5\n         DS      CL3\nQSTIME   DS      XL4\nQETIME   DS      XL4\nQUSER    DS      CL16\nQNAME    DS      CL8\nQNUMBER  DS      BL2\nQIDENT   DS      CL1\n         DS      CL2\nQCUU     DS      CL3\n         DS      CL2\nQCLASS   DS      CL1\nQPRI     DS      CL1\nQRECORDS DS      BL4\n         DS      CL3\nQCOPY    DS      BL1\nQFORM    DS      CL4\n         DS      CL4\nQPAGES   DS      BL2\n         DS      CL2\nQCOUNT   DS      BL4\n         DS      CL6\nQDISP    DS      CL1\n         DS      CL47\nQSYSID   DS      CL1\n         DS      CL5\nQRUN     DS      CL1\n         DS      CL3\nQRS1     DS      X\n         DS      CL15\nQRADD    DS      CL8\n         DS      CL4\nQNEXT    DC      X'00000000'           POINTER TO NEXT IN QUEUE.\n         DS      CL12\nTARGNAM  DS      CL8\nTARGID   DS      CL8\nORIGNAM  DS      CL8\nORIGID   DS      CL8\n         DS      CL40\nDISPLAY  DC      CL2'-\\'               VALUE OF REC. VARIABLE\nNAME     DS      CL8\nNUMBER   DS      CL6\n         DC      CL1' '\nPRI      DS      CL1\n         DC      CL1' '\nDISP     DS      CL1\n         DC      CL1' '\nCLASS    DS      CL1\n         DC      CL1' '\nSYSID    DS      CL1\nDREST    DC      CL56' '\nSEEK     DC      X'0000'               SEEK ADDRESS.\nICHR     DS      0CL5\nICC      DS      X'0000'               CYLINDER NUMBER.\nIHH      DS      X'0000'               HEAD     NUMBER.\nIRR      DC      X'01'                 RECORD   NUMBER.\nOFFSET   DS      CL4\nDTU      DS      0CL29                 DTU = DATE/TIME/USER\n         DC      CL1' '                EQUAL FOR ALL QUEUES\nDATE     DS      CL5\nTIME     DS      CL6\n         DC      CL1' '\nUSER     DS      CL16\nREADCCW  CCW     X'07',SEEK,X'40',6    SEEK\n         CCW     X'23',IRR,X'40',1     SET SECTOR\n         CCW     X'31',ICHR,X'40',5    SEARCH\n         CCW     X'08',*-8,X'00',0     TIC\n         CCW     X'06',IREC,X'00',4    READ\nREADADDR EQU     READCCW+33\nREADSIZE EQU     READCCW+37\n**                            D S E C T S                            **\n         DSECT\nRDRDISPL DS      0CL56                 ONLY FOR RDR\nRDRRECS  DS      CL6\n         DS      CL1\nRDRCUU   DS      CL3\n         DS      CL1\nRDRORIG  DS      CL8\nRDRDTU   DS      CL29\n         DS      CL8\nLSTDISPL DS      0CL56                 FOR LST AND PUN\nLSTPAGE  DS      CL6\n         DS      CL1\nLSTCOPY  DS      CL2\n         DS      CL1\nLSTCUU   DS      CL3\n         DS      CL1\nLSTFORM  DS      CL4\n         DS      CL1\nLSTUSER  DS      CL8\nLSTDTU   DS      CL29\nXMTDISPL DS      0CL56                 ONLY FOR XMT\nXMTRECS  DS      CL6\n         DS      CL1\nXMTTARG  DS      CL8\n         DS      CL1\nXMTORIG  DS      CL8\nXMTDTU   DS      CL29\n         DS      CL3\n         SHVBLOCK DSECT\nPWRQREAD CSECT\n         LTORG\nQBLOCK   DS      CL4096                QUEUE RECORD BLOCK\n         END\n\n\nPWRDREAD ASSEMBLE\n\n** PWRDREAD - Read the POWER data file  ** POWER Version 2 Release 3 **\n**                                      ** POWER Version 4 Release 1 **\n** Return codes: 90001 - MINIDISK NOT LINKED.                        **\n**               90002 - UNIT EXCEPTION.                             **\n**               90003 - WRONG LENGTH RECORD DETECTED.               **\n**               90005 - DEVICE BUSY OR INTERRUPT PENDING.           **\n**               90013 - PERMANENT I/O ERROR.                        **\n**               90025 - NO MORE STORAGE.                            **\n**               91111 - JOB IS EXECUTING.                           **\n**               91112 - POINTER MISMATCH.                           **\nPWRDREAD CSECT\nR0       EQU     0                     CMS EXTENDED PLIST POINTER\nR1       EQU     1                     PARAMETER LIST\nR2       EQU     2                     OFFSET POINTER\nR3       EQU     3                     LINK ADDRESS\nR4       EQU     4                     WORK\nR5       EQU     5                     WORK\nR7       EQU     7                     WORK\nR8       EQU     8                     WORK\nR9       EQU     9                     WORK\nR10      EQU     10                    BASE FOR SHVBLOCK\nR11      EQU     11                    CCW ADDRESS POINTER\nR12      EQU     12                    BASE\nR13      EQU     13                   *NOT USED\nR14      EQU     14                    RETURN / BAL\nR15      EQU     15                    RETURN CODE\n         USING   PWRDREAD,R12\n         ST      R14,SAVERET\n         LR      R2,R0\n         L       R3,4(,R2)\n         MVC     SEEK(11),0(R3)        SEEK ADDRESS (AND OFFSET)\n         MVC     WORKD(4),16(R1)       IJDFILE START CYLINDER\n         BAL     R14,PACK              PACK CYLINDER NUMBER\n         STH     R7,INITCC             SAVE IT\n         MVC     WORKD(4),24(R1)       IJDFILE START HEAD\n         BAL     R14,PACK              PACK HEAD NUMBER\n         STH     R7,INITHH             SAVE IT\n         MVC     REQNAME(8),32(R1)\n         LH      R3,QCUU               LOAD R3 WITH THE LINK ADDR\n         BAL     R14,DIAG0018\n         ICM     R4,B'1111',OFFSET     GET OFFSET IN BYTES\n         LA      R5,PWRBLOCK(R4)       ADDRESS OF PWRBLOCK + OFFSET\n         MVC     QRECORD(256),0(R5)    MOVE THE RECORD\n         LA      R15,1112              IF JOB IS NOT FOUND. RC=1112\n         CLC     QNAME(8),REQNAME      IS IT THE RIGHT NAME\n         BNE     ERREXIT               NO, DO NOT BROWSE\n         LA      R15,1111              IF JOB IS EXECUTING. RC=1111\n         CLI     QRUN,C'X'             IS THE JOB EXECUTING\n         BE      ERREXIT               YES, DO NOT BROWSE\n         TM      QRS1,B'10000000'      PART OF XMT QUEUE\n         BNO     VARSETUP              NO, GO SETUP REXX\n         MVI     QIDENT,C'X'           INSERT X IN QIDENT (X=XMT)\nVARSETUP EQU     *\n         LA      R10,REXXVAR           ADDRESSABILITY FOR SHVBLOCK\n         USING   SHVBLOCK,R10\n         MVI     SHVCODE,C'S'          VARIABLES ARE TO BE SET\n         XC      SHVNEXT,SHVNEXT       ONE BY ONE\n         LA      R7,SHVBLOCK\n         ST      R7,SHVADDR\n         MVC     SHVNAMA,=A(VARNAME)   ADDRESS OF VARIABLE NAME\n         XR      R15,R15               CLEAR R15\n         CLI     QIDENT,C'R'           READER QUEUE ENTRY\n         BNE     NEWBLOCK              NO, BRANCH\n         MVI     FIRSTIME,C'N'\nNEWBLOCK EQU     *\n         L       R5,DBLK\n         LH      R7,INITCC             LOAD INITIAL D-CYLINDER NUMBER\n         LH      R8,INITHH             LOAD INITIAL D-HEAD     NUMBER\n         BAL     R14,DISKPOS           CALCULATE CCHHR\n         LH      R3,DCUU\n         BAL     R14,DIAG0018\n         LA      R5,PWRBLOCK\n         LH      R4,PWRBLOCK           LENGTH OF FIRST RECORD IN BLOCK\n         CLC     PWRBLOCK+4(4),=C'SER:' SER RECORD ?\n         BNE     NOTSER                NO, BRANCH\n         MVC     DBLK,PWRBLOCK+8       MOVE DBLK NUMBER\n         MVI     4(R5),X'20'\n         B       ADD\nNOTSER   EQU     *\n         L       R3,DBLK\n         LA      R3,1(,R3)             ADD 1 TO DBLK NUMBER\n         ST      R3,DBLK\nADD      EQU     *\n         TM      2(R5),B'00000100'     END OF DATA\n         BO      EXIT                  YES, GET OUT\n         TM      4(R5),B'10100000'     JOB- OR DATA SET- HEADER RECORD\n         BZ      NOADD                 NO, BRANCH\n         AR      R5,R4                 ELSE MOVE POINTERS\n         LH      R4,0(R5)\n         B       ADD                   AND CHECK AGAIN\nNOADD    EQU     *\n         ICM     R4,B'0011',0(R5)      GET LENGTH OF RECORD + PREFIX\n         TM      2(R5),B'00000100'     END OF DATA\n         BO      EXIT                  YES, GET OUT\n         MVC     PRECCW,CCWCODE        REMEMBER PREVIOUS CCW-CODE\n         CLI     3(R5),X'73'           IGNORE X'73'\n         BE      NOSTACK\n         CLI     3(R5),X'FE'           IGNORE X'FE'\n         BE      NOSTACK\n         CLI     3(R5),X'FF'           IGNORE X'FF'\n         BE      NOSTACK\n         BAL     R14,CCWCHECK          FIND NEXT CCW-CODE\n         CLI     FIRSTIME,C'Y'\n         BE      NOSTACK\n         MVC     7(1,R5),PRECCW        INSERT PREVIOUS CCW-CODE\n         LA      R8,7(,R5)             SET R8 = R5 + 7\n         LR      R7,R4                 SET R7 = R4 ...\n         SH      R7,=H'8'              SUBTRACT 8 (1 IS FOR EXECUTE)\n         EX      R7,EXCOMP             CHECK FOR A \"+         \" LINE\n         BE      NOSTACK               WAS IT ONE; SKIP IT\n         LA      R7,1(,R7)             ADD 1 TO R7 (FOR THE EXECUTE)\n         ST      R7,SHVVALL            R7 = LENGTH OF RECORD\n         ST      R8,SHVVALA            R8 = START  OF RECORD IN BLOCK\n         BAL     R14,SETVAR\n         MVC     HIGHNUM,DECIMAL\nNOSTACK  EQU     *\n         MVI     FIRSTIME,C'N'\n         TM      2(R5),B'00010000'     END OF BLOCK\n         BO      NEWBLOCK              YES, GO GET NEW BLOCK\n         AR      R5,R4                 MOVE LDA POINTER\n         B       NOADD\nEXCOMP   CLC     0(0,R8),EMPTYLIN\n**                     P R O G R A M   E X I T                       **\nERREXIT  EQU     *                     AN ERROR HAS OCCURED\n         A       R15,NINETI            SET RC = R15 + 90000\n         ST      R15,SAVERC            STORE IT\n         B       NOSETVAR              AND DO NOT SET DATA.0\nEXIT     EQU     *\n         XC      SAVERC,SAVERC         CLEAR SAVERC\n         MVC     SAVERC+2(2),QRRL      INSERT MAX LENGTH\n         LA      R7,16                 LENGTH OF DATA\n         ST      R7,SHVVALL            STORE IT\n         LA      R7,HIGHNUM            HIGHEST DATA. VALUE\n         ST      R7,SHVVALA            STORE IT\n         XR      R7,R7                 SET R7 = 0\n         BAL     R14,SETVAR0           AND SET DATA.0\nNOSETVAR EQU     *\n         L       R14,SAVERET\n         L       R15,SAVERC            SET RC\n         BR      R14                   RETURN TO CMS\n**                       S U B R O U T I N E S                       **\nPACK     EQU     *\n         PACK    WORKD,WORKD(4)\n         CVB     R7,WORKD\n         BR      R14\nCCWCHECK EQU     *\n         TM      4(R5),B'00000010'     ASA CONTROL CHARACTERS\n         BZ      NOASA                 NO, BRANCH\n         MVC     PRECCW,3(R5)          INSERT ASA CC\n         BR      R14                   RETURN\nNOASA    EQU     *\n         MVC     CCWCODE,PRECCW\n         LA      R7,MCCTABLE\n         LA      R8,ASATABLE\nMCCLOOP  EQU     *\n         CLC     0(1,R7),3(R5)         IS THIS THE CCW CODE\n         BE      MCCFOUND              YES, MOVE THE ASA CODE\n         CLI     0(R7),X'FF'           END OF MCCTABLE\n         BE      MCCFOUND              YES, INSERT ? AS ASA CODE\n         LA      R7,1(,R7)             ADD 1 TO MCC POINTER\n         LA      R8,1(,R8)             ADD 1 TO ASA POINTER\n         B       MCCLOOP               AND GO CHECK THE NEXT\nMCCFOUND EQU     *\n         MVC     CCWCODE,0(R8)\n         BR      R14\nDISKPOS  EQU     *\n         XR      R4,R4                 CLEAR R4\n         D       R4,TEN                DIVIDE WITH BLOCKS PR. CYL. (10)\n         CL      R5,TRACKS             PASSED CYLINDER BOUNDARY\n         BL      NOTPCB                NO, BRANCH\nXCYLDIFF EQU     *                     ELSE ...\n         LA      R7,1(,R7)             ADD 1 TO CYLINDER\n         S       R5,TRACKS             SUBTRACT NUMBER OF TRACKS\n         CL      R5,TRACKS             STILL NOT THE RIGTH CYLINDER\n         BNL     XCYLDIFF              NO, BRANCH TO XCYLDIFF\n         SR      R8,R8                 SET INIT HEAD = 0\nNOTPCB   EQU     *\n         AR      R5,R8                 CALCULATE HEAD NUMBER\n         STH     R5,IHH                AND STORE IT\n         LA      R4,1(,R4)             ADD 1 TO RECORD NUMBER\n         STC     R4,IRR                AND STORE IT\n         XR      R4,R4                 CLEAR R4\n         D       R4,TRACKS             DIVIDE WITH 15 (TRACKS PR. CYL)\n         AR      R5,R7                 CALCULATE CYLINDER NUMBER\n         STH     R5,ICC                AND STORE IT\n         BR      R14                   RETURN\nDIAG0018 EQU     *\n         LA      R15,1                 NUMBER OF READS IN CCW-LIST\n         LA      R11,READCCW\n         DIAG    R3,R11,X'0018'        READ THE QUEUE FILE\n         LTR     R15,R15               CHECK THE RETURN CODE\n         BZR     R14                   RC = 0, RETURN\n         B       ERREXIT               IF NOT ZERO; GET OUT\nSETVAR   EQU     *\n         L       R7,VARCOUNT           GET NUMBER OF VARIABLES SO FAR\n         LA      R7,1(,R7)             ADD 1\n         ST      R7,VARCOUNT           AND REMEMBER THE NEW VALUE\nSETVAR0  EQU     *\n         LA      R1,DECIMAL+15         SET R1 = DECIMAL+15\n         LR      R8,R1                 SET R8 = R1\n         CVD     R7,WORKD              CONVERT R7\n         MVC     DECIMAL,NUMMASK       SETUP FOR EDIT\n         EDMK    DECIMAL,WORKD         EDIT (MAY CHANGE VALUE OF R1)\n         SR      R8,R1                 R8 = R8 - R1\n         LA      R7,6(,R8)             R7 = R8 + 6\n         ST      R7,SHVNAML            LENGTH OF VARIABLE NAME\n         EX      R8,MOVEMASK           MOVE THE NUMBER\n         LA      R1,XCOMM              SETUP FOR EXECCOMM\n         LA      R0,EPLIST               ...\n         ICM     R1,B'1000',=X'02'       ...\n         SVC     202                   INVOKE EXECCOMM\n         DC      AL4(1)                I CHECK FOR ERROR\n         LTR     R15,R15               RC = 0\n         BZR     R14                   YES, RETURN\n         MVI     SHVCODE,C'D'          READY TO DROP VARIABLES\n         LA      R7,5                  LENGTH OF NAME (DATA.)\n         ST      R7,SHVNAML\n         SVC     202                   DROP THE DATA. VARIABLES\n         DC      AL4(1)                IGNORE ANY ERROR\n         LA      R15,25                SET RC = 25\n         B       ERREXIT               AND GO EXIT THE PROGRAM\nMOVEMASK MVC     VARNAME+5(0),0(R1)\n**           C O N S T A N T S   A N D   V A R I A B L E S           **\nWORKD    DS      D\nSAVERET  DS      F\nTRACKS   DC      F'15'                 TRACKS/CYLINDER (3380)\nTEN      DC      F'10'                 BLOCKS/TRACK    (3380)\nSAVERC   DC      F'0'\nVARCOUNT DC      F'0'\nNINETI   DC      F'90000'\nINITHH   DS      H\nINITCC   DS      H\nQCUU     DC      X'0140'               Q-ADDRESS (LINKED BY PWRQPROF)\nDCUU     DC      X'0141'               D-ADDRESS (LINKED BY PWRQPROF)\nCCWCODE  DC      X'40'\nPRECCW   DC      X'40'\nAUTH     DS      X\nMCCTABLE DC      X'000B098B11131B01191BFF'\nASATABLE DC      X'404040F1F0F0604E60606F'\nNUMMASK  DC      X'40202020202020202020202020202120'\nREXXVAR  DS      CL32\nDECIMAL  DS      CL16\nHIGHNUM  DC      CL16'0'\nVARNAME  DC      CL15'DATA.'           NAME OF REXX VARIABLE\nXCOMM    DC      CL8'EXECCOMM'\nREQNAME  DS      CL8\nFIRSTIME DC      C'Y'\nEMPTYLIN DC      C'+',CL250' '\n*\n         DS      0F\nQRECORD  DS      0XL256                THE QUEUE RECORD.\n         DS      CL32\nQNAME    DS      CL8\n         DS      CL2\nQIDENT   DS      CL1\n         DS      CL89\nQRRL     DS      CL2\n         DS      CL2\nQRUN     DS      CL1\n         DS      CL3\nQRS1     DS      CL1\n         DS      CL27\nQNEXT    DC      F'0'                  POINTER TO NEXT IN QUEUE.\nDBLK     DS      F\n         DS      CL80\n*\nSEEK     DC      H'0'\nICHR     DS      0CL5\nICC      DS      H'0'                  CYLINDER NUMBER.\nIHH      DS      H'0'                  HEAD     NUMBER.\nIRR      DC      X'01'                 RECORD   NUMBER.\nOFFSET   DS      CL4\n*\nEPLIST   DS      0D\n         DC      A(XCOMM)\n         DC      A(0)\n         DC      A(0)\nSHVADDR  DC      A(0)\n*\nREADCCW  CCW     X'07',SEEK,X'40',6    SEEK\n         CCW     X'23',IRR,X'40',1     SET SECTOR\n         CCW     X'31',ICHR,X'40',5    SEARCH\n         CCW     X'08',*-8,X'00',0     TIC\n         CCW     X'06',PWRBLOCK,X'00',4096   READ\n*\n         LTORG\n         SHVBLOCK\nPWRDREAD CSECT\n         DS      0H\nPWRBLOCK DS      CL4096                QUEUE OR DATA RECORD BLOCK\n         END     PWRDREAD\n\n\nMichael Plannthin\nSystems Programmer (Denmark)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E001A05": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00F\\x00F\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 70, "newlines": 70, "modlines": 0, "user": "VSEUPDT"}, "text": "Running CSP batch\n\nWe are a VSE/SP 3.2 shop using CSP/AD and CSP/AE for\ndeveloping on-line applications.  While we were satisfied with\nCSP as an on-line development tool under CICS, we wanted to\nexplore the possibility of running CSP applications in VSE\nbatch partitions.  The ability to share record definitions and\ncode among on-line and batch applications eliminates\nredundancy.  In addition, the batch applications can be\ndeveloped and tested on-line, using CSP/AD MSL and tracing\nfacilities.  Since most of our developers were already\nconversant with CSP, using this language for batch applications\nwas attractive.\n\nA CSP batch application is invoked by executing program\nDCBYINIT.  The Application Load File (ALF) and application\nname are specified in a control card (SYSIPT).  Applications\nare fetched and executed from the ALF.  This is similar to the\nway CSP/AE works under CICS.  Although no run statistics\nare available, the performance of these batch programs has\nbeen good.\n\nThe JCL might be challenging to some programmers because\nof CSP's rather arcane control card syntax.  Here is an example\nof a batch application using SQL/DS tables and VSAM\ndatasets.  The following points are noted:\n\no      Under CSP/AD, the application is defined as main batch.\n\no      This application was tested on-line under CSP/AD and then\n      generated to an ALF.\n\no      Make sure that all VSAM datasets are shareable if the files\n      are also used under CICS.\n\no      We use the standard label area for // DLBL definitions.\n      This saves redundant JCL coding.\no      Follow the control statement syntax carefully (see CSP/AD\n      and CSP/AE System Administration manual).\n\no      All naming conventions for on-line CSP apply.\n\no      An 8 byte field may be passed to the application\n      (U=userparm).\n\no      All control statements must have ;; starting in column 71 if\n      they are to be continued on the next card.\n\no      Note ';; END OF CSP PARAMETER DATA'.\n\n\n* $$ JOB JNM=UT29A,CLASS=0,DISP=D\n// JOB CSPBATCH FOR APPLICATION: UT29A\n* STANDARD LABEL DEFINITIONS AND LIBDEFs ARE USED\n* PRINT MAPS ARE ASSIGNED TO SYS005 AND GO TO SYSLST\n// ASSGN SYS005,SYSLST\n* MODIFY THE FOLLOWING STATEMENT TO REFLECT YOUR CONFIGURATION\n// DLBL DCADZGD,'CSP.V3R2M1.DZGMSG',,VSAM,CAT=VSESPUC\n// EXEC PGM=DCBYINIT,SIZE=256K\nA=AAUALF.UT29A U=19900207 SID=SQLDBA/SQLDBAPW SMODE=D                 ;;\nF=EZEPRINT S=005\n;; END OF CSP PARAMETERS DATA\n/*\n.&\n* $$ EOJ\n\nEric Bombe\nTechnical Manager\nAssociated Aviation Underwriters (USA)        c Eric Bombe 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A06": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01\\x82\\x01\\x82\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 386, "newlines": 386, "modlines": 0, "user": "VSEUPDT"}, "text": "Automating the VSE to PC download process\n\nWe needed a way to move VSE-generated data from the 4381\nto a PC application without operator intervention.  The data is\ngenerated seven days a week, so data from Saturday and\nSunday must be available to the user on Monday.  The steps\noutlined below were taken.\n\n\nSTEP ONE\n\nA VSE COBOL program was written to create the data\nrequired for the user.  Three ESDS VSAM files are deleted and\ndefined every day, then the COBOL program writes the data to\nthese files.  Later in the JCL job stream another COBOL\nprogram punches a one-line file to the VSE punch queue.  The\nVSE punch queue has been defined, at VSE IPL time, to spool\nthe specific punch class to the VM punch queue.\n\n\nSTAGE TWO\n\nCreate the punch member.\n\n/*\n*  STEP 56.5 -- PUNCHJOB - PUNCH\n* $$ PUN CLASS=O,DISP=D\n// ASSGN SYS007,SYSPCH\n// EXEC PUNCHJOB,SIZE=150K\n/*\n\n\nSTAGE THREE\n\nUse the VSE command to set up punch spooling to VM.\n\nSTART PUN,00D,0,,VM\n\n\nSTAGE FOUR\n\nIn order to move data to CMS, a service machine, SMACH, is\nautologged every morning using VMUTIL.  The service\nmachine has a series of EXECs that search for the VM punch\nmember, move the ESDS VSAM data to CMS, and delete the\noldest CMS members.  The service machine then logs itself\noff.\n\n\nSTAGE FIVE\n\nUse the EXEC to check for punch member and to move data to\nCMS.\n\n/* EXEC TO CHECK FOR PUNCH RECORD EVERY 1/2 HOUR AFTER START */\nSIGNAL FIRSTRD\nRESTART:\nCP SLEEP 30 MIN\nFIRSTRD:\nCP SPOOL CON CLOSE\nPUR PRT ALL\nCP SPOOL CON START\nCP Q PUN ALL\nCP SPOOL CON CLOSE\nEXECIO 2 CP '( MARGINS 1 80 LIFO STRING QUERY PRT ALL * '\nPULL REC\n  SPOOLID1 = SUBSTR(REC,10,4)\nTRANSFER PRT SPOOLID1 TO SMACH RDR\n'RECEIVE' SPOOLID1 'CON LIST (NOLOG REPLACE'\nDROPBUF\nCOUNT = 1\n/* PROCESS CON LIST FILE                              */\nAGAIN:\nCOUNT = COUNT + 1\nEXECIO 1 DISKR CON LIST A COUNT\nIF RC\u00ac= 0 THEN SIGNAL OUT\n  PULL REC\n  NOFILES = SUBSTR(REC,1,2)\n  SYSNAME = SUBSTR(REC,1,7)\n  SPOOLID = SUBSTR(REC,10,4)\n  FNAME   = SUBSTR(REC,54,5)\n  FTYPE   = SUBSTR(REC,64,8)\n  DIST    = SUBSTR(REC,73,8)\n/* CHECK TO SEE IF PUN HAS ANY FILES */\n  IF NOFILES = 'NO'\n     THEN SIGNAL RESTART\n  IF SPOOLID = 'FILE'\n     THEN SIGNAL AGAIN\n/* CHECK TO SEE IF CORRECT SYSTEM NAME  */\n  IF SYSNAME \u00ac= 'DOSMACH '\n     THEN SIGNAL AGAIN\n/* CHECK TO SEE IF FILE NAME IS XXO28 */\n  IF FNAME \u00ac= 'XXO28'\n     THEN SIGNAL AGAIN\n/* RECEIVE THE FILE AND CHECK THE 4TH RECORD FOR XXO28*/\nPROCESS:\nDROPBUF\nTRANSFER SYSNAME PUN  SPOOLID TO SMACH RDR\n'RECEIVE' SPOOLID 'XXO28 CARD (NOLOG'\nEXECIO 1 DISKR XXO28 CARD A 4\nPULL CREC\nGOOD_NAME = SUBSTR(CREC,1,5)\nIF GOOD_NAME \u00ac= 'XXO28'\n   THEN SIGNAL AGAIN\nERASE XXO28 CARD\nDROPBUF\nEXEC XX82DOWN\nSET DOS OFF\nEXEC XX82B\nEXEC XX82C\nEXEC XX82S\nLOGOFF\nEXIT\nOUT:\nDROPBUF\nSIGNAL RESTART\n\n\nSTAGE SIX\n\nUse the EXEC to move data from an ESDS VSAM file to a\nCMS file.\n\n/* XX82DOWN LINKS EXEC             *\n * ACCESS THE VSAM MASTER CATALOG  */\nGLOBAL TXTLIB COBLIBVS CMSLIB SYNCSORT\nGLOBAL MACLIB OSVSAM OSMACRO OSMACRO1 CMSLIB\nSET EMSG ON;\nCP LINK MACH 128 128 RR MACH-PASSWORD\nCP LINK MACH 424 424 RR MACH-PASSWORD\nACC 128 W\nACC 424 N\nDLBL IJSYSCL W DSN PROD.CORE.IMAGE.LIBRARY.A\nDLBL IJSYSCT W DSN VSAM.MASTER.CATALOG\nDLBL VSAMCAT N DSN VSAM.CATALOG\nDLBL INFILE1 N DSN FILE1.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT\nDLBL INFILE2 N DSN FILE2.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT\nDLBL INFILE3 N DSN FILE3.VSAM.DOWNLOAD '('VSAM CAT VSAMCAT\nFILEDEF OUTFILE1 DISK OUTFILE1 DATA A '(' RECFM F\nFILEDEF OUTFILE2 DISK OUTFILE2 DATA A '(' RECFM F\nFILEDEF OUTFILE3 DISK OUTFILE3 DATA A '(' RECFM F\nLOAD XX82DOWN\nSTART\nREL W\nDET 128\nREL N\nDET 424\nEXIT\n\n\nSTAGE SEVEN\n\nCOBOL program used to create CMS files from ESDS VSAM\nfiles.\n\n  IDENTIFICATION DIVISION.\n  PROGRAM-ID. 'XX82DOWN'.\n  AUTHOR. D. KOSKIE.\n  REMARKS.  PROGRAM TO READ VSAM ESDS FILE AND WRITE IT OUT\n            AS A CMS FILE IN YOUR LIBRARY.\n  DATE-WRITTEN.\n  DATE-COMPILED.\n  ENVIRONMENT DIVISION.\n  CONFIGURATION SECTION.\n  SOURCE-COMPUTER. IBM-370\n  OBJECT-COMPUTER. IBM-370.\n  SPECIAL-NAMES.\n  INPUT-OUTPUT SECTION.\n  FILE-CONTROL.\n      SELECT   INFILE1 ASSIGN TO SYS007-AS-INFILE1\n               FILE STATUS IS STAT-COND.\n      SELECT   INFILE2 ASSIGN TO SYS008-AS-INFILE2\n               FILE STATUS IS STAT-COND.\n      SELECT   INFILE3 ASSIGN TO SYS009-AS-INFILE3\n               FILE STATUS IS STAT-COND.\n      SELECT   OUTFILE1 ASSIGN TO SYS010-3340-DA-OUTFILE1.\n      SELECT   OUTFILE2 ASSIGN TO SYS011-3340-DA-OUTFILE2.\n      SELECT   OUTFILE3 ASSIGN TO SYS012-3340-DA-OUTFILE3.\n  DATA DIVISION.\n  FILE SECTION.\n  FD  INFILE1\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS INREC1\n      RECORD CONTAINS 199 CHARACTERS.\n***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.\n  01  INREC1 PIC X(199).\n  FD  INFILE2\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS INREC2\n      RECORD CONTAINS 199 CHARACTERS.\n***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.\n  01  INREC2 PIC X(199).\n  FD  INFILE3\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS INREC3\n      RECORD CONTAINS 199 CHARACTERS.\n***  CHANGE RECORD LENGTH TO CORRECT SIZE TO AVOID PROBLEMS.\n  01  INREC3 PIC X(199).\n  FD  OUTFILE1\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS OUTREC1\n      RECORD CONTAINS 131 CHARACTERS.\n  01  OUTREC1.\n      05 FDATA1  PIC X(131).\n  FD  OUTFILE2\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS OUTREC2\n      RECORD CONTAINS 131 CHARACTERS.\n  01  OUTREC2.\n      05 FDATA2  PIC X(131).\n  FD  OUTFILE3\n      LABEL RECORDS ARE STANDARD\n      DATA RECORD IS OUTREC3\n      RECORD CONTAINS 131 CHARACTERS.\n  01  OUTREC3.\n      05 FDATA3  PIC X(131).\n  WORKING-STORAGE SECTION.\n  77  RLENGTH                   PIC S9(4) COMP VALUE ZERO.\n  77  REC-COUNT                 PIC 9999999    VALUE ZERO.\n  01  STAT-COND.\n      05  STAT-COND1            PIC X VALUE SPACES.\n      05  STAT-COND2            PIC X VALUE SPACES.\n  01  WORKREC.\n      05  FILLER                PIC X(68).\n      05  MOVEREC               PIC X(131).\n  PROCEDURE DIVISION.\n      OPEN INPUT INFILE1, INFILE2, INFILE3\n                         OUTPUT OUTFILE1, OUTFILE2,OUTFILE3.\n      IF STAT-COND = '00' THEN NEXT SENTENCE\n       ELSE DISPLAY 'BAD OPEN INPUT ' STAT-COND UPON CONSOLE\n              GO TO BAD-PROG.\n  READ-ANOTHER1.\n      READ INFILE1 AT END\n           DISPLAY 'RECORD COUNT '  REC-COUNT\n           MOVE ZERO TO REC-COUNT\n           GO TO READ-ANOTHER2.\n      MOVE INREC1 TO WORKREC.\n      MOVE MOVEREC TO OUTREC1.\n      WRITE OUTREC1  INVALID KEY\n      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE\n              GO TO END-PROG.\n      ADD 1 TO REC-COUNT.\n***   IF REC-COUNT > 100\n***        GO TO END-PROG.\n      GO TO READ-ANOTHER1.\n  READ-ANOTHER2.\n      READ INFILE2 AT END\n           DISPLAY 'RECORD COUNT '  REC-COUNT\n           MOVE ZERO TO REC-COUNT\n           GO TO READ-ANOTHER3.\n      MOVE INREC2 TO WORKREC.\n      MOVE MOVEREC TO OUTREC2.\n      WRITE OUTREC2  INVALID KEY\n      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE\n              GO TO END-PROG.\n      ADD 1 TO REC-COUNT.\n***   IF REC-COUNT > 100\n***        GO TO END-PROG.\n      GO TO READ-ANOTHER2.\n  READ-ANOTHER3.\n      READ INFILE3 AT END\n           DISPLAY 'RECORD COUNT '  REC-COUNT\n           GO TO END-PROG.\n      MOVE INREC3 TO WORKREC.\n      MOVE MOVEREC TO OUTREC3.\n      WRITE OUTREC3  INVALID KEY\n      THEN DISPLAY 'WRITE OUTFILE ERROR'        UPON CONSOLE\n              GO TO END-PROG.\n      ADD 1 TO REC-COUNT.\n***   IF REC-COUNT > 100\n***        GO TO END-PROG.\n      GO TO READ-ANOTHER3.\n  END-PROG.\n   CLOSE INFILE1 INFILE2 INFILE3 OUTFILE1 OUTFILE2 OUTFILE3.\n  BAD-PROG.\n      STOP RUN.\n\n\nSTAGE EIGHT\n\nXX82B EXEC creates the correct CMS file and deletes the\noldest.  XX82C and XX82S are copies of XX82B.\n\n/* XX82B LINKS EXEC                */\n/* GET THE CURRENT DATE AND RENAME THE INPUT FILE */\nDAY = DATE(U)\nM1 = SUBSTR(DAY,1,2)\nD1 = SUBSTR(DAY,4,2)\nY1 = SUBSTR(DAY,7,2)\nFTYPE = M1||'-'||D1||'-'||Y1\nCOPY OUTFILE1 DATA A OUTFILE1 DATA A '(' REP PACK\nRENAME OUTFILE1 DATA A XX82BLX FTYPE A\n/* ERASE THE OLDEST XX82BLX FILE - LEAVE 7 VERSIONS */\nAO = '(EXEC'\nB1 = 'XX82BLX'\nB2 = '*'\nLISTFILE B1 B2 A1 AO\nOPT = ' ( FINIS '\n'EXECIO * DISKR' CMS EXEC A OPT\nRECOUNT = QUEUED()\nDROPBUF\nIF RECOUNT < 8 THEN SIGNAL OUT\nQUEUE 23 2 CH A 17 2 CH A 20 2 CH A\nSSORT CMS EXEC A\nDROPBUF\nEXECIO 1 DISKR CMS EXEC A 1\nPULL REC\n NAME = SUBSTR(REC,8,9)\n TYPE = SUBSTR(REC,17,8)\n CLASS = SUBSTR(REC,26,2)\nERASE NAME TYPE CLASS\nOUT:\nERASE CMS EXEC A\nTELL OPERATOR 'XX82BLX PROCESSING COMPLETE'\nRETURN\n\n\nSTAGE NINE\n\nThe users must move the CMS data to the PC using a series of\nEXECs.  The first EXEC creates a link to the data disk, then\ncreates a TDISK to move the data in unpacked format, and\ndoes an automatic FLIST of the data disk.\n\n/* DO THE LINKS TO SMACH SYSTEM */\nREL Z\nDET 500\nCP DEFINE T3370 AS 500 BLK 10000\nCLRSCRN\nQUEUE \"YES\"\nQUEUE \"TDISK\"\nFORMAT 500 Z\nCLRSCRN\nSET MSG OFF\nSET EMSG OFF\nSET IMSG OFF\nGETFMADR\nSET MSG OFF\nSET EMSG OFF\nSET IMSG OFF\nPULL . FMODE VADDR\nCP LINK SMACH 191 VADDR RR MACH-PASSWORD\nACC VADDR FMODE\nSET MSG ON\nSET EMSG ON\nSET IMSG ON\nCLRSCRN\nFLIST '*' '*' FMODE\nSET MSG OFF\nSET EMSG OFF\nSET IMSG OFF\nREL FMODE\nCP DET VADDR\nSET MSG ON\nSET EMSG ON\nSET IMSG ON\n\n\nSTAGE TEN\n\nThis EXEC moves the chosen CMS member to the TDISK in\nunpacked format.  After the file is created on the TDISK, the\nuser switches over to the PC and executes the correct BAT file\nfor the actual data movement between CMS and PC.\n\n/* COPY FROM SMACH DISK TO THE USERS TDISK */\nPARSE UPPER ARG PNAME PMODE PTYPE STUFF\nIF PNAME = XX82CARE THEN\n    COPY PNAME PMODE PTYPE XX82CARE DATA Z '(' UNPACK REPLACE\nIF PNAME = XX82CAID THEN\n    COPY PNAME PMODE PTYPE XX82CAID DATA Z '(' UNPACK REPLACE\nIF PNAME = XX82BLX THEN\n    COPY PNAME PMODE PTYPE XX82BLX DATA Z '(' UNPACK REPLACE\n\n\nSTAGE ELEVEN\n\nBAT file to move data from CMS to PC.\n\nRECEIVE UTRAP.DAT XX82BLX DATA Z (ASCII CRLF\n\n\nDonald Koskie\nSystems Analyst (USA)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E001A07": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00[\\x00[\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 91, "newlines": 91, "modlines": 0, "user": "VSEUPDT"}, "text": "Security when starting VSE\n\nWe have two systems from two different firms in the same\ncomputer room.  I made $SYSOPEN for our computer, so that\noperators and system programmers who don't know the correct\npassword cannot IPL a processor.\n\nFor VM users, it is simple to test $SYSOPEN, but for the\nnative VSE users it is not.  We run VSE/SP 2.1 .\n\nProbably the best way to implement it is to make it a procedure\non SYSWK1.  This can be done when you install an IBM PTF.\nIn this case IJSYSR1.SYSLIB1 becomes IJSYSRS.SYSLIB\nafter an IPL.  Therefore, it is necessary to use the full\ndescription (DLBL and extent) when you catalogue it in the\nsource library.\n\nBe careful if you do not have VM installed.\n\n* $$ JOB JNM=NEKO\n// JOB NEKO\n// LIBDEF *,CATALOG=IJSYSRS.SYSLIB\n// OPTION CATAL,ALIGN,XREF,NODUMP,NOSYSDMP\n    PHASE $SYSOPEN,*\n// EXEC ASSEMBLY,SIZE=200K\nOPEN2    START 0\n         USING *,R15\nBEGIN    ST R14,RETURN\n* CONSOLE OPERATOR MUST ENTER PASSWORD : WORK    ( CAPITAL LETTERS !)\n* HE CAN TRY THIS TWICE\n* IF HE DOES NOT ENTER CORRECT PASSWORD CURRENT IPL STOPPED WITH\n* HARD WAIT CODE NOPW AND MUST START NEW IPL\n         LA R1,LOGCCB1            SEND MESSAGE ON THE CONSOLE\n         EXCP (1)\n         WAIT (1)\n         LA R1,LOGCCB2            ENTER PASSWORD\n         EXCP (1)\n         WAIT (1)\n         CLC LOGINP,=C'WORK'    IS IT PASSWORD CORRECT ?\n         BE LEND                 YES GO TO LEND\n*                                 NO, TRY AGAIN\n         LA R1,LOGCCB1\n         EXCP (1)\n         WAIT (1)\n         LA R1,LOGCCB2\n         EXCP (1)\n         WAIT (1)\n         CLC LOGINP,=C'WORK'\n         BE LEND\n*                                     PASSWORD NOT OK,HARD WAIT CODE\n         MVC LOGMSG,=C'NEED NEW IPL'\n         L R11,HWCODE\n         ST R11,0\n         OI SVCNPSW+1,X'02'\n* WAIT\n         SVC 7\n* POVRATAK\nLEND     BZR R14\nSVCNPSW  EQU 96\nLOGCCB1  CCB SYSLOG,LOGCCW1\nLOGCCB2  CCB SYSLOG,LOGCCW2\nLOGCCW1  CCW X'09',LOGMSG,X'20',L'LOGMSG\nLOGCCW2  CCW X'0A',LOGINP,X'20',L'LOGINP\nLOGMSG   DC C'PASSWORD : ?'\nLOGINP   DC C'    '\nRETURN   DC F'0'\nHWCODE   DC C'NOPW'\nR0       EQU 0\nR1       EQU 1\nR2       EQU 2\nR11      EQU 11\nR12      EQU 12\nR13      EQU 13\nR14      EQU 14\nR15      EQU 15\n         END  OPEN2\n/*\n// IF $RC GT 2 THEN\n// GOTO KRAJ\n*  LNKEDT\n// EXEC LNKEDT,PARM='MSHP'\n/*\n* SYCATAL END\n/. KRAJ\n/&\n* $$ EOJ\n\n\nNenad Kuzmanovic\nArenaturist (Yugoslavia)                         c Nenad Kuzmanovic 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A08": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01B\\x01B\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 322, "newlines": 322, "modlines": 0, "user": "VSEUPDT"}, "text": "Quick display of devices\n\nWhen maintaining numerous VSE systems, each with plenty of\nADD statements, occasionally the Physical Unit Block (PUB)\ntable fills up.  One must check the IPL procedure carefully\nbefore adding a new device so as not to exceed the limit\nimposed by VSE.  This can be extremely awkward if the\ndevices are specified in ranges such as 'ADD 468:46F,3277'.\nTherefore, I decided to write this small program to go straight\ninto COMREG+X'40 and read through the PUB table before\ncoming to rest when it detects X'FF.  I have written this\nprogram for CICS 1.7 running under VSE/SP 3.2.  I have hard-\ncoded the address of the PUB table, therefore VSE/SP 4 users\nwill have to add an extra few bytes.  I have called the\ntransaction SYS2, the program SYSPUBP and the mapset\nSYSPUBM (the copybook for the map is SYSPUBA).  Note:\nthere is, included in the program, a useful routine for\nconverting hex into character; it is called CONVERT.  Figure 1\nshows an example of the output as it appears on the screen.\n\n\nSYSPUBM\n\n* | MAP SYSPUBM  - PROGRAM SYSPUBP  displays VSE PUB table          | *\nMAPSET   DFHMSD TYPE=&SYSPARM,                                         C\n               MODE=INOUT,                                             C\n               CTRL=(FREEKB,FRSET),                                    C\n               TIOAPFX=YES,                                            C\n               STORAGE=AUTO\n         SPACE 2\n* SET UP SCREEN                                 *\nSYSPUBM  DFHMDI SIZE=(24,80)\n         SPACE 2\n* AND HEADING                                   *\nLINE     DFHMDF POS=(1,1),                                             C\n               LENGTH=7,                                               C\n               INITIAL='SYSPUBM',                                      C\n               ATTRB=(ASKIP,FSET)\n         SPACE 2\n         DFHMDF POS=(1,10),                                            C\n               ATTRB=(ASKIP,BRT),                                      C\n               LENGTH=52,                                              C\n               INITIAL='               V S E    P U B    T A B L E     C\n               '\n         SPACE 2\n* SHOW EACH ADDRESS IN PUB TABLE -LEFT TO RIGHT *\nLINE1    DFHMDF POS=(1,63),LENGTH=16,                                  C\n               ATTRB=(FSET,PROT)\n         SPACE 2\n* SHOW EACH ADDRESS IN PUB TABLE -LEFT TO RIGHT *\nLINE3    DFHMDF POS=(3,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE4    DFHMDF POS=(4,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE5    DFHMDF POS=(5,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE6    DFHMDF POS=(6,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE7    DFHMDF POS=(7,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE8    DFHMDF POS=(8,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE9    DFHMDF POS=(9,3),                                             C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE10   DFHMDF POS=(10,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE11   DFHMDF POS=(11,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE12   DFHMDF POS=(12,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE13   DFHMDF POS=(13,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE14   DFHMDF POS=(14,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE15   DFHMDF POS=(15,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE16   DFHMDF POS=(16,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE17   DFHMDF POS=(17,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE18   DFHMDF POS=(18,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE19   DFHMDF POS=(19,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\nLINE20   DFHMDF POS=(20,3),                                            C\n               LENGTH=75,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' '\n         SPACE 2\n* SHOW NUMBER OF ENTRIES IN PUB TABLE           *\nLINE22   DFHMDF POS=(22,9),                                            C\n               LENGTH=33,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL=' NUMBER OF ENTRIES IN PUB TABLE :'\n         SPACE 2\nL22      DFHMDF POS=(22,44),                                           C\n               LENGTH=3,                                               C\n               ATTRB=(FSET,PROT,BRT)\n         SPACE 2\n* RETURN TO CICS INFORMATION                    *\nLINE23   DFHMDF POS=(23,9),                                            C\n               LENGTH=70,                                              C\n               ATTRB=(PROT,ASKIP),                                     C\n               INITIAL='        PRESS PF3,PF12 - TO EXIT'\n         SPACE 2\n* ERROR MESSAGE AREA                            *\nERRMSG   DFHMDF POS=(24,1),                                            C\n               LENGTH=79,                                              C\n               ATTRB=(PROT,BRT),                                       C\n               INITIAL=' '\n         SPACE 2\n         DFHMSD TYPE=FINAL\n         END\n\n\nSYSPUBP\n\n * ASSEMBLER PROGRAM TO FIND NUMBER OF       *\n * DEVICES IN PUB TABLE AND DISPLAY WITHIN CICS                       *\n DFHEISTG DSECT\n          COPY  SYSPUBA\n          COPY  DFHBMSCA\n          COPY  DFHCSADS\n          EJECT\n PROGRAM  CSECT\n          EXEC  CICS ADDRESS CSA(11) NOEDF\n          USING DFHCSADS,11\n          EXEC  CICS HANDLE AID PF12(CICS)PF3(CICS) ANYKEY(BUFFOON)     *\n                 ENTER(MAINRTN)\n          EXEC  CICS HANDLE CONDITION ERROR(ERRORS)\n          EJECT\n FINDPUB  EQU   *\n R0       EQU   0\n R1       EQU   1\n R2       EQU   2\n R3       EQU   3\n R4       EQU   4\n R5       EQU   5\n R6       EQU   6\n R7       EQU   7\n R8       EQU   8\n R9       EQU   9\n R10      EQU   10\n R11      EQU   11\n R12      EQU   12\n R13      EQU   13\n R14      EQU   14\n R15      EQU   15\n          EJECT\n * PLEASE NOTE - SP3 USE 538+40-SP4 USE 550+40                        *\n          LH    R10,X'578'            ADDRESS OF PUB MOVED IN\n          LA    R9,LINES              ADDRESS OF LINES\n          ZAP   COUNT,=PL1'0'         RESET STORAGE FIRST TIME THROUGH\n          SPACE 3\n LOOP     EQU   *\n          CLI   0(R10),X'FF'          ARE WE AT THE END OF THE PUB\n          BE    FINISH                YES - WE BETTER CALL IT A DAY THEN\n          LA    R5,2                  NUMBER OF BYTES TO CONVERT\n          LA    R6,CHARDEV            ADDRESS OF DISPLAY CHAR FIELD\n          LR    R4,R10                ADDRESS OF FIELD IN REG 4\n          XR    R2,R2                 CLEAR REGISTER 2\n          BAL   R8,CONVERT            ITS IN HEX FORMAT SO LETS CONVERT\n          MVC   0(4,R9),CHARDEV       MOVE IN CHARS TO APPROP. POSITION\n          LA    R9,5(,R9)             ADVANCE SCREEN POSITION\n          AP    COUNT,=PL1'1'         INCREMENT COUNTER\n          LA    R10,8(,R10)           INDEX TO THE NEXT PUB ENTRY\n          B     LOOP                  GO AND DO NEXT PUB ENTRY\n          SPACE 3\n FINISH   EQU   *\n          MVC   FOURBYTE,PATTRN       MOVE IN THE EDIT PATTERN\n          ED    FOURBYTE,COUNT        AND EDIT COUNT\n          SPACE 3\n MAINRTN  EQU   *\n          MVC   LINE3O,DATA3          FIRST FIFTEEN DEVICES\n          MVC   LINE4O,DATA4          AND NEXT FIFTEEN\n          MVC   LINE5O,DATA5          AND SO ON....\n          MVC   LINE6O,DATA6\n          MVC   LINE7O,DATA7\n          MVC   LINE8O,DATA8\n          MVC   LINE9O,DATA9\n          MVC   LINE10O,DATA10\n          MVC   LINE11O,DATA11\n          MVC   LINE12O,DATA12\n          MVC   LINE13O,DATA13\n          MVC   LINE14O,DATA14\n          MVC   LINE15O,DATA15\n          MVC   LINE16O,DATA16\n          MVC   LINE17O,DATA17\n          MVC   LINE18O,DATA18\n          MVC   LINE19O,DATA19\n          MVC   LINE20O,DATA20\n          MVC   L22O,FOURBYTE+1       AND MOVE FIELD TO SCREEN\n          B     SNDMAP\n          SPACE 2\n ERRORS   EQU   *\n          MVC   ERRMSGO,=CL79' ERRORS  CALL YOUR FRIENDLY SYSPROG'\n          B     SNDMAP\n          SPACE 2\n BUFFOON  EQU   *\n          MVC   ERRMSGO,=CL79'     YOU HAVE HIT A WRONG KEY      '\n          B     MAINRTN               SET UP MAP AGAIN\n          SPACE 2\n SNDMAP   EQU   *\n          EXEC  CICS SEND MAP('SYSPUBM') ERASE\n          EXEC  CICS RECEIVE MAP('SYSPUBM')\n          SPACE 2\n CICS     EQU   *\n          MVC   MSGAREA,=CL19'NORMAL END OF TASK'\n          EXEC  CICS SEND FROM(MSGAREA) ERASE\n          EXEC  CICS RETURN\n          SPACE 2\n          EJECT\n * WE NEED THE FOLLOWING ROUTINE TO CONVERT HEX DEVICE INTO CHARACTER *\n * THIS ROUTINE REQUIRES R5 ... NUMBER OF BYTES TO CONVERT            *\n *                       R4 ... ADDRESS OF START OF CONVERSION        *\n *                       R6 ... ADDRESS OF PRINT FIELD                *\n *                       R2 ... CLEAR THIS REG BY XR                  *\n CONVERT  EQU   *\n          IC    R2,0(R4)\n          SRL   R2,4\n          STC   R2,0(R6)\n          TR    0(1,R6),TABLE\n          IC    R2,0(R4)\n          N     R2,NUM\n          STC   R2,1(R6)\n          TR    1(1,R6),TABLE\n          LA    R4,1(R4)\n          LA    R6,2(R6)\n          BCT   R5,CONVERT\n          BR    R8\n          EJECT\n * ALL STORAGE FOLLOWS BELOW.....                                     *\n          LTORG\n          EJECT\n          CNOP  0,4\n MSGAREA  DS    CL19\n TABLE    DS    0CL256\n          DC    CL16'0123456789ABCDEF'\n          DC    240CL1'?'\n FULLWORD DS    F\n NUM      DC    X'0000000F'\n CUUDEV   DC    XL2'00'               ADDRESS IN HEX\n CHARDEV  DC    XL4'F0'               ADDRESS IN CHARACTER\n COUNT    DC    PL2'0'                COUNT NUMBER OF DEVICES\n PATTRN   DC    X'40212020'           PACKED COUNT FIELD PATTERN\n FOURBYTE DS    CL4                   FOUR BYTE WORK FIELD\n LINES    DS    0CL1275\n DATA3    DC    CL75' '\n DATA4    DC    CL75' '\n DATA5    DC    CL75' '\n DATA6    DC    CL75' '\n DATA7    DC    CL75' '\n DATA8    DC    CL75' '\n DATA9    DC    CL75' '\n DATA10   DC    CL75' '\n DATA11   DC    CL75' '\n DATA12   DC    CL75' '\n DATA13   DC    CL75' '\n DATA14   DC    CL75' '\n DATA15   DC    CL75' '\n DATA16   DC    CL75' '\n DATA17   DC    CL75' '\n DATA18   DC    CL75' '\n DATA19   DC    CL75' '\n DATA20   DC    CL75' '\n          END\n\n\nSimon Connelly\nSystems Programmer\nE R Squibb (UK)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E001A09": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00Y\\x00Y\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 89, "newlines": 89, "modlines": 0, "user": "VSEUPDT"}, "text": "VSE/ESA - the way to the future\n\nThe announcement of VSE/ESA has brought great relief for\nmany VSE users.  IBM has finally recognized the value of its\n22,000+ VSE licence holders, and there now seems no doubt\nthat VSE is going to be vigorously supported for some years\nyet, possibly into the next century, both as a mid-range\noperating system in its own right and as the entry system to\nIBM's mainframe line.\n\nVSE Release 5 - VSE/ESA - indicates a sea change in IBM's\nattitude to VSE.  Previous releases have represented grudging\nconcessions by IBM to pressures from users, but VSE/ESA is\naltogether different and lifts many key restraints of previous\nversions as well as introducing several new elements to VSE:\n\no      The number of address spaces that VSE can handle has\n      been increased dramatically with the introduction of\n      dynamic partitions.  Dynamic partitions are a new type of\n      partition which exist only for as long as they are needed,\n      and up to 200 of them can be used in addition to the\n      existing 12 static partitions.  The 12 static partitions still\n      reside in their 9 address spaces, and each of the new\n      dynamic partitions exists in its own address space; thus\n\n      VSE/ESA can now support 209 address spaces and 212\n      partitions.\n\no      Real memory support has been increased to 384MB (from\n      16MB in VSE/SP), which implies 31-bit addressing within\n      the VSE supervisor.\n\no      I/O support has been improved, and VSE/ESA can handle\n      up to 256 channels, including the new ESCON channels,\n      on the appropriate processors.\n\no      Native support for 3390/3990 devices has been introduced;\n      this includes dynamic path select/reconnect and four-\n      channel pathing.\n\no      All uniprocessor ES/9000s are supported directly, although\n      on the water-cooled 9021 models support is available only\n      under VM, or in logical partitioning mode under PR/SM.\n      On multiprocessor models (air-cooled and water cooled),\n      VM or  PR/SM is needed.\n\no      POWER (on ESA-capable processors) and VTAM (on all\n      processors) can be moved from shared storage into their\n      own private partitions.  Potentially this frees up 2-4MB per\n       address space, and with up to 209 address spaces available,\n      can yield a very substantial increase in the amount of space\n      available to users' applications.  However, note that it's\n      already possible to hold VTAM in a private area using\n      CICS MRO and further savings would not be available to\n      users already employing this technique.\n\nRelease 5 has not raised the constraint of 16MB per address\nspace, although there's a Statement of Direction for support of\nup to 2GB per address space.\n\nAlongside these improvements within VSE itself, there have\nbeen substantial enhancements to other software commonly\nused in the VSE environment, notably VM and CICS.  VM is\nwidely used as a means of working round VSE constraints, and\nthe new unified version of VM, VM/ESA, can still be used for\nthis purpose with the new VSE.  However, the greater capacity\nand performance of VSE/ESA and the availability of PR/SM\nthroughout the ES/9000 range will make VM unnecessary for\nmany users, and there's likely to be a reduction in the number\nof VM licences as the base of VSE/ESA and ES/9000 users\ngrows.\n\nIn contrast to the impact of VM/ESA, the latest CICS\nannouncements are likely to play a key role in VSE sites.  The\nnew release of CICS - CICS/VSE 2.1 - offers improved LU6.2\nand cooperative processing support, availability of CICS/XRF\n(eXtended Recovery Facility), COBOL II (the SAA version of\nthe language), and the C language (C will be available at a so-\nfar unspecified later date).  MRO performance is also claimed\nto be better.  CICS/XRF (which originated right at the top end\nof the IBM range as part of IMS) is a particularly welcome\naddition to the VSE environment; it creates a 'mirror' CICS\nsystem synchronized with the main system which can take over\nimmediately in the event of a failure in the primary system.  It\ncan also be used for planned hardware and/or software\nmaintenance by allowing the back-up CICS system to be used\nwhile the main system is being maintained.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A00I": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "VSEUPDT"}, "text": "E002 - VSE Update Issue #02  June 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE002A01   VSE/ESA - an early user experience\nE002A02   Checking correct date via IPL exit $SYSOPEN\nE002A03   COBOL program interface to VSE/POWER\nE002A04   Reading VSE/SP3 libraries from CMS\nE002A05   Stacking the VSE console\nE002A06   VSE batch operator\nE002A07   Using a virtual CTCA\nE002A08   Internal sort routine\nE002A09   Partition wait for a specified time\nE002A10   Secret' POWER parameters\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A01": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xc6\\x00\\xc6\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 198, "newlines": 198, "modlines": 0, "user": "VSEUPDT"}, "text": "VSE/ESA - an early user experience\n\nMy company's decision to install VSE/ESA was driven by the\nneed for more virtual storage.  With over 600 terminals and\nprinters, using two production CICS systems, VTAM was\npushing its VPBUF pool limits.  There was talk of putting\nVTAM in a private address space on our existing VSE.  Since\nwe currently run on VSE/SP 3.1.2, this meant that we would\nhave to apply some PTFs and set up a CICS AOR and TOR.\nThere were concerns whether we could still process over 350\n000 transactions per day and keep our current response times\nwithout a CPU upgrade.  Luckily, VSE/ESA was announced\nand made it unnecessary to use a CICS TOR.\n\nWe run on a 32MB 3090 with PR/SM using three LPARs.\nLPAR A  is used for our production jobs and most of our\nremote terminals and printers.  LPAR B is used for production\nand by our programming staff.  LPAR C is used exclusively for\nthe system programming staff, consisting of two people.  There\nare five 3480 tape drives attached to all three LPARs and one\n3420 tape drive attached to LPARs A and B.\n\nOur ESA tapes arrived in mid-January and we began installing\nthe tapes immediately.  After restoring DOSRES and\nSYSWK1, we tried to IPL in ESA mode.  We found out that\nyou cannot IPL VSE/ESA in ESA mode in only 3MB of\nmemory as shipped by IBM.  There is a new parameter on the\nSVA IPL statement: SHARED=LOW/HIGH.  This allows you\nto put the SVA area right after the supervisor\n(SHARED=LOW), or put it at the high end of storage\n(SHARED=HIGH, which is where the SVA resides in pre-ESA\nVSEs).  IBM ships VSE/ESA with SHARED=LOW.  We\ncould not IPL in ESA mode with less than 7MB of memory.\nThis meant we had to wait for the weekend, steal 4MB of\nmemory from another LPAR, IPL and get CICS up so we\ncould change the SVA statement to SHARED=HIGH, then\ngive the 4MB back to the LPAR we stole it from and re-IPL.\nThe minimum in which VSE/ESA in ESA mode could run is\n3MB.  As you would expect, it does not run very fast, but\nspeed is not our main concern in our test environment.\n\nThe installation of VSE/ESA is the same as installing VSE/SP,\nso I will not go into detail here.  The file layouts for DOSRES\nand SYSWK1 have changed somewhat.  If you have used any\nof the free space on the volumes for other files, you will need\nto review those locations.\n\nWe decided to let our OEM packages test VSE/ESA for us.\nDuring our testing, we found a couple of the VSE internal\nchanges that were made to make the new features work.  The\nmost widespread change was done to the partition's COMREG\narea.  To support and run in the new dynamic partitions, new\nfull-word fields were added to the COMREG.  This means that\nany program that uses half-word fields in the COMREG must\nbe changed to use the full-word field if running in a dynamic\npartition.  If the program is only going to be run in a static\npartition, no changes are needed to access the COMREG\nfields.  Another change was made to some POWER control\nblocks.  If you have a program that accesses POWER control\nblocks, or bypasses POWER and reads the queue and data files\ndirectly, these must be changed.\n\nWith the changes, any OEM products that use VSE or POWER\ncontrol blocks will need new versions.  This includes DASD\nand tape management packages, schedulers, VSE monitors,\nPOWER queue files to CICS printer packages, VSAM dynamic\nbuffering packages, and SORT packages.  You should call the\nvendor and make sure that their product will work under ESA\nand with what kind of restrictions, if any.  The reason I\nmentioned the restrictions is explained below.\n\nThe following is a list of packages that we are testing/running\nunder ESA:\n\no      Computer Associates      -      DYNAM\no      Computer Associates      -      SORT\no      Computer Associates      -      SCHEDULER\no      Computer Associates      -      VOLLIE\no      Computer Associates      -      LIBRARIAN\no      Computer Associates      -      RAPS\no      Pansophic      -       CORPORATE TIE\no      Pansophic      -       EASYTRIEVE PLUS\no      Goal      -      EXPLORE/VSE\no      SDS      -       POWERTOOLS.\n\nCA-DYNAM - Version 5.5 of the DYNAM family is needed.\nMost of the serious problems that we encountered were caused\nby IBM code.  All were fixed by existing PTFs.  DYNAM has\nno problems running in a dynamic partition.\n\nCA-SORT - Version 7.4 is needed to run under ESA.  CA-\nSORT will run in a dynamic partition.  There were no new\nfeatures besides the capability to run under ESA.\n\nCA-SCHEDULER - Version 7.2 is needed to run under ESA.\nThere are some new features for coordinating job runs on other\nCPUs.  You must make sure you re-link the phases that access\nJCL from other library types (ie VOLLIE, LIBRARIAN,\nICCF, CONDOR).  These other packages have new ESA\nmodules that need to be included when link-editing CA-\nSCHEDULER.  So make sure these packages are already\ninstalled.\n\nCA-VOLLIE - VOLLIE is still at Version 4.3.  However, you\nneed to order an ESA option tape that will allow VOLLIE to\nwork under ESA.  This tape contains the object code and\nphases needed for ESA.\n\nCA-LIBRARIAN - LIBRARIAN is still at 3.8.  It also needs\nan ESA option tape to function under VSE/ESA.\n\nCA-RAPS - Version 4.2 of RAPS is needed.  It needs the ESA\noption tape to run under VSE/ESA.\n\nPansophic's Easytrieve Plus - Version 6.0.D will run under\nESA in static partitions only.  It will not run in a dynamic\npartition.  I asked Pansophic about their plans for enhancing\nEasytrieve Plus to run in a dynamic partition.  They said there\nwere no immediate plans for providing this capability.  Also,\nEasytrieve Plus cannot run under ESA if the SVA is set up as\nSHARED=LOW.  Easytrieve checks some addresses to\ndetermine whether it may be run in the SVA.  If the SVA is set\nup as SHARED=LOW, Easytrieve will display a message then\ncancel.  The SVA must be set up as SHARED=HIGH in order\nfor Easytrieve Plus to run.\n\nPansophic's CORPORATE TIE - Version 2 was tested, and we\nfound no problems running under ESA with CICS 2.1.\n\nGoal's EXPLORE/VSE - We are new to using\nEXPLORE/VSE.  Under VSE/SP, we ran IBM Performance\nTool to monitor our VSEs.  IBM has announced that PT will\nnot run under ESA and has no plans to make it run under ESA.\nIBM advised that we try EXPLORE/VSE.  So we installed\nEXPLORE/VSE and gave it a try.  We were pleased with what\nEXPLORE could do.  I have been told by Goal that the disk\nXA I/O reporting was new.  They can take the actual timings\nfrom the hardware and not depend on sampling to get their\nnumbers.  If you are looking for a VSE monitor, make sure\nyou take a look at EXPLORE/VSE.\n\nSDS POWERTOOLS - The most current version available will\nwork under ESA.\n\nDuring the testing of these products, we did encounter some\nbugs.  Some were the vendor's code, some were ESA code.\nSome of the problems went away after we applied the PTFs\nfrom the PSP PUT buckets.  It is very important to apply the\nPTFs from the bucket list.  These solved some of the serious\nerrors between the OEM packages and ESA.  I would also\nrecheck the buckets every few weeks.  ESA is new, and new\nPTFs appear in the buckets.\n\nOne area our OEM products could not test was in the\ncommunications area.  We have a 3745 running NCP Version\n5.3.  VTAM 3.3 had no problems communicating with the\n3745.  We tested remote SNA terminals and printers, POWER\nRJE, POWER PNET, VTAM cross domains, and the dial-up\nconnection to an EDI network.\n\nOne IBM product that is a disappointment is FCOBOL, which\nwill not compile in a dynamic partition.  We were planning to\nset up a dynamic class for compiles and testing.  Since neither\nFCOBOL nor EASYTRIEVE PLUS will compile in a dynamic\npartition, dynamic partitions do not give us any benefits.\n\nPricing of VSE/ESA depends on what type of CPU it is\nrunning on.  Generally speaking, there is a big increase in the\nmonthly cost going from VSE/SP 3.1.2 to VSE/ESA.  I am\ntold that going from VSE/SP 4.1 to VSE/ESA is not as big an\nincrease.  Computer Associates is using ESA as an excuse for\nincreasing prices.  You now have to pay extra for an ESA\nfeature (for every product of theirs you have) that lets the\nproduct work on VSE/ESA.  This is true even if you are\nalready leasing the product.  This ESA feature charge is costing\nmy company thousands of dollars.  Computer Associates is the\nonly company I know of that is doing this.  We are considering\nthe possibility of dropping Computer Associates' products and\nreplacing them with products from companies who do not\ncharge extra for VSE/ESA.\n\nOur target date for moving VSE/ESA into production is the\nmiddle of March.  All of our OEM ESA versions can run in\nVSE/SP.  So we are moving each product into production\nunder VSE/SP before we convert to VSE/ESA.  This will serve\ntwo purposes.  One, it will make converting to ESA easier.\nTwo, it will give us a chance to stress test the new versions and\nfind any problems before we move to VSE/ESA.\n\nVSE/ESA has given us room for growth by putting VTAM in\nits own address space.  This should last us for about 2 years.\nBy that time, IBM should have announced the availability of\n31-bit virtual addressing.\n\nKeith Nush\nTechnical Consultant\nDTA Technical Services (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A02": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xda\\x00\\xda\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 218, "newlines": 218, "modlines": 0, "user": "VSEUPDT"}, "text": "Checking correct date via IPL exit $SYSOPEN\n\nWe have encountered problems with operators not knowing the\ncorrect date or miskeying it etc when IPLing.  This can cause\nhavoc with accounting.  The following IPL exit routine was\ndeveloped to prevent this problem.  Operators tend to know\nwhat day of the week it is so the exit asks for it and validates\nweekday against the system date.  You can still have a problem\nif the transposition of day and month number produces the\nsame weekday.  If this bothers you then add a few instructions\nto ask for the month in letters as well.\n\nIPLE     TITLE 'IPL EXIT ROUTINE TO CHECK DAY ENTERED WITH DATE'\n*********************************************************************\n*       IPL EXIT                                                    *\n*       PHASE NAME MUST BE $SYSOPEN AND MUST BE ON SYSRES TO BE     *\n*       USED DURING IPL. ANY LIBRARY MAY BE USED FOR TESTING        *\n*       THE ROUTINE BY EXECING IT FROM JCL.                         *\n*       THE OPERATOR IS ASKED WHAT DAY OF THE WEEK HE THINKS IT IS. *\n*       IF THIS DOES NOT TALLY WITH THE SYSTEM DATE WE KEEP ASKING. *\n*       IF WE ARE RUNNING UNDER VM AND ARE DISCONNECTED THEN        *\n*       OP. IS NOT ASKED, THE ASSUMPTION BEING THAT THE VIRTUAL     *\n*       MACHINE CONSOLE IS THE VSE CONSOLE.                         *\n*       THE ONLY NON-IBM VSE MACROS REQUIRED ARE ESUP, DIAG & REGEQU*\n*       THE LOGICAL TRANSIENT $$BPSWFX IS CALLED BY ESUP.           *\n*********************************************************************\n$SYSOPEN CSECT\n         USING *,R12                ADDRESSABILITY\n         LR    R12,R15\n         ST    R14,FRETURN         SAVE RETURN ADDR\n         COMRG\n         MVC   FSYSDATE,83(R1)     SAVE SYSTEM DATE  (YYDDD)\n         ASYSCOM R1                GET SYSCOM ADDRESS\n         L     R1,IJBRASLN-SYSCOM(R1)  GET ADDRESS OF CPUID\n         CLI   0(R1),X'FF'         BRANCH IF\n         BNE   FENTWEEK             NOT UNDER VM\n*          IF THIS IS A DISCONNECTED MACHINE UNDER VM *\n*          WE DO NOT WANT TO ASK FOR DAY OF WEEK      *\n         ESUP IN                   GET INTO SUPV. MODE FOR DIAG.\n         LA    R1,R1\n         LNR   R1,R1               MINUS 1 MEANS FIND CONSOLE\n         DIAG  R1,R2,X'24'         GET CONSOLE ADDRESS\n         BC   12,WCONNECT          BRANCH IF THERE IS ONE (CONNECTED)\n         ESUP OUT                  GET OUT OF SUPV. MODE\n         B    EXIT                 UNDER VM AND DISCONNECTED SO\n*                                  SKIP DAY OF WEEK ROUTINE\n\nWCONNECT EQU  *\n         ESUP OUT                  GET OUT OF SUPV. MODE\n*                      * NATIVE OR CONNECTED UNDER VM SO *\n*                      *  DO DAY OF WEEK ROUTINE         *\nFENTWEEK EQU   *\n         MVC   CONWK,FENTWKMS      DISPLAY 'ENTER WEEKDAY'\n         LA    R1,L'FENTWKMS       MESSAGE\n         BAL   R10,FPUT\n         BAL   R10,FGET            AND READ REPLY\n         LA    R1,FDAYTAB          USING TABLE OF 'DAYS'\nFLOOKAGN EQU   *\n         CLI   0(R1),X'FF'         CHECK\n         BE    FENTWEEK            FOR\n         CLC   0(3,R1),CONWK       VALID REPLY\n         BE    FOUND               ELSE\n         LA    R1,3(R1)            DISPLAY\n         B     FLOOKAGN            'ENTER WEEKDAY' AGAIN\nFOUND    EQU   *\n         PACK  DWORD,FSYSDATE(2)   CONVERT YEARS\n         CVB   R2,DWORD            TO BINARY\n         PACK  DWORD,FSYSDATE+2(3) CONVERT DAYS\n         CVB   R3,DWORD            TO BINARY\n         LR    R5,R2\n         BCTR  R2,R0               FIND NO. OF LEAP YEARS\n         SRL   R2,2                  (YY-1)/4\n         LA    R1,365              FIND DAYS EQUIVALENT OF YY\n         MR    R4,R1                 (AS A MULTIPLE OF 365)\n         AR    R5,R2               ADD TOGETHER\n         AR    R5,R3               YY IN DAYS, DAYS AND LEAPS\n         LA    R1,7                TAKE OUT ALL MULTIPLES\n         DR    R4,R1               OF 7 TO FIND VALUE  0-6\n         MH    R4,THREE            CALC DISPLACEMENT ON DAY TABLE\n         LA    R1,FDAYTAB(R4)      FIND DAY CALCULATED AND\n         CLC   0(3,R1),CONWK       COMPARE TO ONE ENTERED\n         BNE   FWRONG\n         MVC   CONWK,FDAYAGRE      IF EQUAL, DISPLAY\n         LA    R1,L'FDAYAGRE        MESSAGE TO\n         BAL   R10,FPUT              THAT EFFECT\nEXIT     EQU   *\n         SR    R15,R15             RETURN CODE IF BATCH TEST\n         L     R14,FRETURN         EXIT\n         BR    R14\nFWRONG   EQU   *                   IF DAYS NOT EQUAL,\n         MVC   CONWK,FDAYWRNG      DISPLAY MESSAGE\n         LA    R1,L'FDAYWRNG        TO THIS EFFECT\n         BAL   R10,FPUT              AND THEN ...\n         B     FENTWEEK            ... KEEP ASKING\nFPUT     DS    0H     CONSOLE OUTPUT ROUTINE,\n         ST    R1,WRITCCW+4        PUT LENGTH IN CCW\n         LA    R1,WRITCCW          SET UP WRITE COMMAND L\n         ST    R1,FCCB+8            IN CCB\n         LA    R1,FCCB               AND WRITE\n         EXCP  (1)\n         WAIT  (1)\n         BR    R10                 RETURN\nFGET     DS    0H     CONSOLE INPUT ROUTINE\n         XC    CONWK,CONWK         CLEAR CONSOLE INPUT\n         LA    R1,READCCW          SET UP READ COMMAND\n         ST    R1,FCCB+8            IN CCB\n         LA    R1,FCCB               AND READ\n         EXCP  (1)\n         WAIT  (1)\n         TM    4(R1),X'01'         TEST IF CANCEL\n         BNZ   FGET                YES, READ AGAIN\n         OC    CONWK(L'FBLANKS),FBLANKS NO, SET REPLY TO UPPER\n         BR    R10                       CASE AND RETURN\n         DS    0D\nFCCB     CCB   SYSLOG,WRITCCW\nREADCCW  CCW   X'0A',CONWK,X'20',3\nWRITCCW  CCW   9,CONWK,X'20',L'CONWK\nDWORD    DC    D'0'                     CONVERT TO BINARY FIELD\nFRETURN  DC    F'0'                     RETURN ADDR SAVE AREA\nFSYSDATE DS    CL5                      SYSTEM DATE SAVE AREA\nFBLANKS  DC    CL10' '\nCONWK    DC    CL50' '                  CONSOLE MESSAGE AREA\nFENTWKMS DC    C'ENTER WEEKDAY - THREE LETTERS'\nFDAYAGRE DC    C'WEEKDAY AGREES WITH TODAY''S DATE'\nFDAYWRNG DC    C'WEEKDAY AND DATE DON''T AGREE'\nFDAYTAB  DC    C'SUNMONTUEWEDTHUFRISAT'\n         DC    X'FF'\nTHREE    DC    H'3'\n         REGEQU\nSYSCOM   SYSCOM\n         END\n\nThe required logical transient is shown below.\n\nPSWF     TITLE 'ALTER A PARTITION''S PSW TO SUPERVISOR TYPE'\n******************************************************\n*          USED BY ESUP MACRO.                       *\n*          PHASE NAME MUST BE $$BPSWFX.              *\n*          MUST BE ON SYSRES TO BE USED BY IPL EXIT. *\n******************************************************\n$$BPSWFX CSECT\n         USING *,R15\n         USING COMREG,R1\n         USING SYSCOM,R3\n         DC    CL8'$$BPSWFX'\n         LR    R14,R0              SAVE ADDR. OF AREA PASSED BY USER\n         COMRG\n         ASYSCOM 3\n         LH    R9,PIBPT            PIBTAB\n         L     R9,8(R9)            PARTN. SAVE AREA (WHEN IN LTA)\n         MVC   0(2,R14),8(R9)      SAVE START OF ORIGINAL PSW FOR USER\n         MVC   8(2,R9),=X'040C'    MODIFY SAVED PSW, EC MODE\n                                    DISABLED, PROT. KEY ZERO, SUP.STATE\n         TM    IJBFLG06,IJBEMODE   IF MODE=E IN SUPVR.\n         BZ    QEXIT                NO DAT IS DONE\n         NI    8(R9),X'FF'-X'04'     SO TURN OFF TRANSLATION BIT\nQEXIT    EQU   *\n         SVC   11\n         REGEQU\n         MAPCOMR\nSYSCOM   SYSCOM\n         END\n\nThe following are the required macros:\n\n         MACRO\n&LBL     DIAG  &R1,&R2,&CODE\n&LBL     DC    0H'0',X'83',AL.4(&R1,&R2),Y(&CODE)\n         MEND\n\n         MACRO\n         REGEQU\n* GENERAL PURPOSE REGISTERS\nR0       EQU   0\n\nEditor's note: registers 1 to 14 go here.\n\nR15      EQU   15\n         MEND\n\n         MACRO\n&NAME    ESUP  &IO\n         GBLC  &ESPX\n         GBLB  &ESPNFST\n*    ESUP MACRO - GET INTO OR OUT OF SUPVR. MODE, KEY ZERO, DISABLED  *\n&NAME    DS    0H\n         AIF   (&ESPNFST).ESPNFST\n&ESPX    SETC  '&SYSNDX'           FIRST TIME THIS ASSEMBLY\n.ESPNFST ANOP\n         AIF   ('&IO' EQ 'OUT').ESPOUT\n         AIF   ('&IO' EQ 'IN').ESPIN\n         MNOTE 9,'OPERAND INVALID'\n         MEXIT\n.ESPIN   ANOP\n         AIF   (&ESPNFST).ESPA\n         CNOP  4,8\n         BAL   0,*+12\nESPS&ESPX DC   D'0'                SAVE PROBLEM PROGRAM PSW\n         AGO   .ESPB\n.ESPA    LA    0,ESPS&ESPX         POINT TO SAVE AREA FOR P.P. PSW\n.ESPB    LA    1,=CL8'$$BPSWFX'    CALL TRANSIENT TO GET INTO\n         SVC   2                    SUPVR MODE & PROT. KEY ZERO\n         AGO   .ESPEXIT\n.ESPOUT  ANOP\n         AIF   (&ESPNFST).ESPC\n         CNOP  4,8\n         B     *+12\nESPS&ESPX DC   D'0'                SAVE PROBLEM PROGRAM PSW\n.ESPC    LA    0,*+12\n         ST    0,ESPS&ESPX+4\n         LPSW  ESPS&ESPX           RETURN TO P.P. MODE & CORRECT KEY\n.ESPEXIT ANOP\n&ESPNFST SETB  1                   NO LONGER FIRST TIME\n         MEND\n\nJohn Illingworth\nChief Systems Programmer\nEmpire Stores Ltd (UK)                         c Empire Stores Ltd 1991\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A03": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x91\\x00\\x91\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 145, "newlines": 145, "modlines": 0, "user": "VSEUPDT"}, "text": "COBOL program interface to VSE/POWER\n\nThis routine offers the following facilities for COBOL\nprograms running under VSE:\n\no      Issue a VSE/POWER command\no      Submit a VSE/POWER job.\n\nThe routine accepts a complete VSE/POWER job stream, and\nis therefore more flexible than using the DISP=I parameter on\nthe '* $$ PUN' statement.\n\nThe routine is called as follows:\n\nCALL 'VSEPWR' USING record-name.\n\nWhere record-name must have the following structure:\n\n01  RECORD-NAME.\n    03  CODE                    PIC X.\n    03  NUMBER                  PIC S9(4) COMP SYNC.\n    03  CARD-1                  PIC X(80).\n    .\n    .\n    .\n    03  CARD-N                  PIC X(80).\n\nWhere:\n\no      CODE is 'C' if CARD-1 contains a VSE/POWER\n      command or 'J' if CARD-1 to CARD-N contains a\n      VSE/POWER job.\n\no      NUMBER is the number of cards in the job if CODE is 'J',\n      NUMBER is not used if CODE is 'C'.\n\no      CARD-1 is the VSE/POWER command if CODE is 'C', or\n      the first card of the VSE/POWER job if CODE is 'J'.  The\n      second and subsequent cards of the VSE/POWER job must\n      follow CARD-1.  Each card must be 80 characters.  The\n      maximum number of cards in the VSE/POWER jobstream\n      is 75.\n\nAssemble the source code and catalogue the relocatable module\ninto a relocatable library.  The relocatable library should be in\nthe standard relocatable library searchlist, so that the module\nmay be included in the calling program at link edit time.\n\nVSEPWR\n\n         TITLE 'VSEPWR - POWER INTERFACE FOR BATCH PROGRAMS'\nVSEPWR   CSECT\nR0       EQU   0\n\nEditor's note: registers 1 to 14 go here.\n\nR15      EQU   15\nVSEPWR   CSECT\n         USING VSEPWR,R15              ESTABLISH ADDRESSABILITY\n         SAVE  (14,12)\n         LR    R3,R15                  R3 IS PROGRAM BASE\n         DROP  R15\n         USING VSEPWR,R3\n         L     R4,0(0,R1)              R4 IS MESSAGE CONTROL BLOCK\n         L     R4,0(R4)                FOR USE BY PL/I PROGRAMMERS\n         USING COBREC,R4                    BASE\n         CLI   COBCODE,C'C'            IS IT A COMMAND ?\n         BE    PWRCMD1                 YES\n         CLI   COBCODE,C'J'            IS IT A JOB ?\n         BE    PWRJOB1                 YES\n         B     PWREXIT\nPWRCMD1  LA    10,PWRCMD1+4\n         LA    R12,CTLSPL              POINT TO CONTROL SPL CTRL BLK\n         USING SPLMAP,R12\n         STCM  R12,7,SPMXECB+5         SAVE ADDRESS IN XECB\n         XECBTAB TYPE=DEFINE,XECB=SPMXECB,ACCESS=XWAIT\n         LTR   R15,R15                 ANY ERRORS\n         BNZ   PWRWAIT                 YES - ASSUME BUSY\n         MVC   FEEDBACK(80),COBCMD     MOVE COMMAND TO BUFFER\n         CTLSPOOL SPL=(R12)            ISSUE COMMAND\n         XECBTAB TYPE=DELETE,XECB=SPMXECB\n         CLI   SPER,X'42'              ANY ERRORS\n         BNE   PWRERR                  YES GO HANDLE IT\n         B     PWREXIT\nPWRJOB1  LH    R10,COBCRDS             GET NUMBER OF CARDS\n         CH    R10,=H'75'              MORE THAN 75 ?\n         BH    PWREXIT                 IGNORE\n         CH    R10,=H'1'               LESS THAN 1 ?\n         BL    PWREXIT                 IGNORE\n         LA    R12,COBCMD              R12 = A(FIRST CARD)\n         LA    R1,PWRJCL               R1 = A(FIRST POWER CARD)\nPWRJOB2  LR    R15,R1                  R15 = A(CURRENT CARD)\n         LA    R15,88(R15)             POINT TO NEXT CARD\n         ST    R15,0(R1)               STORE IN PREVIOUS CARD\n         MVC   8(80,R1),0(R12)         MOVE IN CARD\n         LA    R12,80(R12)             POINT TO NEXT INPUT CARD\n         LA    R1,88(R1)               POINT TO NEXT OUTPUT CARD\n         BCT   R10,PWRJOB2             ANY MORE CARDS ?\n         LA    R15,88\n         SR    R1,R15                  POINT TO LAST CARD\n         SLR   R15,R15\n         ST    R15,0(R1)               SET LAST CARD\nPWRJOB9  LA    10,PWRJOB9+4\n         LA    R9,PWRJCL               R9 = A(JCL)\n         LA    R12,PUTSPL              POINT TO PUTSPOOL SPL CONTROL\n         USING SPLMAP,R12\n         STCM  R12,7,ICRXECB+5         SAVE ADDRESS IN XECB\n         XECBTAB TYPE=DEFINE,XECB=ICRXECB,ACCESS=XWAIT\n         LTR   R15,R15                 ANY ERRORS\n         BNZ   PWRWAIT                 YES = GO ASSUME BUSY\n         PUTSPOOL SPL=(R12),CBUF=(R9)  STUFF JOB INTO READER\n         XECBTAB TYPE=DELETE,XECB=ICRXECB\n         CLI   SPER,0                  ANY ERRORS\n         BNE   PWRERR                  YES - GO HANDLE\n         B     PWREXIT                 NO - GO RETURN\nPWRERR   DS    0H                      ADD ANY ERROR HANDLING HERE\n         B     PWREXIT\nPWRWAIT  DS    0H\n         SETIME 5,TECB                 WAIT 5 SECONDS AND TRY AGAIN\n         WAIT  TECB\n         BR    R10\nPWREXIT  EQU   *\n         RETURN (14,12)\n         SPACE 2\n         LTORG\nICRXECB  DC    A(0,0)\nSPMXECB  DC    A(0,0)\nTECB     TECB\nCTLSPL   SPL   TYPE=DEFINE,PBUF=FEEDBACK,PBUFL=320,REQ=COMMAND\nPUTSPL   SPL   TYPE=DEFINE,PBUF=FEEDBACK,PBUFL=88\nFEEDBACK DC    4CL88' '\n         SPACE 2\nPWRJCL   DC    75XL88'00'\n         SPACE 2\nCOBREC   DSECT\nCOBCODE  DS    C\nCOBCRDS  DS    H\nCOBCMD   DC    CL80' '\n         SPACE 2\nSPLMAP   SPL   TYPE=MAP\n         END\n\nMichael Nunan\nSystems Programmer\nSage Computing (South Africa)                   c Sage Computing 1991\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A04": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\t\\x04\\n\\x04\\t\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:09:47", "lines": 1034, "newlines": 1033, "modlines": 0, "user": "VSEUPDT"}, "text": "Reading VSE/SP3 libraries from CMS\n\nThe programs to read the VSE/SP3 libraries from CMS are:\n\no      LIBRCMS ASSEMBLE - this is the program that reads the\n      VSE/SP3 library and puts the information in REXX\n      variables.\n\no      LIBREXX EXEC, LIBXEDIT XEDIT and LIBREXX\n      XEDIT  -  these programs run LIBRCMS and display the\n      information returned in XEDIT files.\n\nThe command format is:\n\n      LIBRCMS  (sublib  (member  (type )))\n\nwhere sublib is the name of the target sublibrary.  Member and\ntype is the name and type of the target member.  If no\nparameters are entered then all the sublibraries in the library are\nlisted.  If sublib and member are entered, all members with that\nname in that sublibrary are listed.  If sublib, member and type\nare specified, the lines in that member are listed.\n\nThe requirements on entry are:\n\no      All disks on which the library resides must be ASSGNed to\n      SYS100 onwards. The first SYStem logical unit not used\n      after SYS100 should be ASSGNed IGN to avoid the\n      OVTOC macro cancelling the program.\n\no      The following REXX variables should be set to give\n      information regarding the type of library to be read :\n\n      o      LibrKEY - This is the library's file-id (ie\n            VSE.PRD2.LIBRARY).\n\n      o      LibrVSM - Indicates if the library is VSAM and is\n            set to Y or N.\n\n      o      LibrSYS - Indicates if the library is IJSYSRS and\n            again is set to Y or N.\n\no      If the library is VSAM then a DLBL for IJSYSUC must\n      point to the catalog holding it.  Ensure also that you have\n      the MASTER catalog accessed.\n\nBecause VSAM libraries are NONCIFORMAT VSAM\nmanaged SAM files, they cannot be accessed using an ACB or\nDTFSD.  DTFPH can be used to access such a file but this isn't\nsupported by CMS.  Therefore to read the library, this program\nexamines the catalog (or the VTOCs for a non-VSAM library)\nand builds a table describing the location of all the library's\nextents and then issues its own CCWs to retrieve the\ninformation.\n\nIn order to speed up runtimes this program assumes that it has\nbeen NUCXLOADed and sets a flag inside the CSECT once\nthe extent table has been built.  On subsequent executions to\nread the same library it won't bother rebuilding the table.\n\nTo read a different library make sure you NUCXLOAD a new\ncopy to reset the flag and cause the table to be rebuilt.  After\nthe table has been prepared the library directory records\ndescribing each sublibrary, the sublibrary directory records\ndescribing its members, and the member records are read\naccording to the input parameters.\n\nThe limitations on use are:\n\no      This program only supports libraries on 3380s.\n\no      The maximum number of disks on which a library may\n      reside is sixteen.  (This may be increased by adding extra\n\n      entries to the VOL1TAB and XTNTTAB tables, but make sure\n      VOL1TAB doesn't have more entries than\n      XTNTTAB.)\n\no      If the library is not VSAM, the number of extents on any\n      one disk is limited to three (although you can have up to\n      sixteen extents spread over several disks).  This is because\n      a FORMAT1 VTOC label only details up to three extents;\n      the rest are detailed on a FORMAT3 continuation label\n      which this program does not read.\n\no      This program can't read a member whose record length is\n      not 80 bytes (this only includes PHASEs and DUMPs and\n      maybe a few other obscure member types).\n\n\nLIBRCMS ASSEMBLE\n\n*  Function:     To read VSE/SP3 libraries from CMS and place         *\n*                contents of directories or members in REXX           *\n*                variables for use by the calling EXEC.               *\n*  Conditions on exit:                                                *\n*     R15 is set as follows -                                         *\n*         0     Execution successful and variables set as described   *\n*               below.                                                *\n*         1     One of the library's records couldn't be found        *\n*               (probably because of a missing disk if non-VSAM).     *\n*         2     EXECCOMM returned a non-zero return code.             *\n*         3     A VSAM error occurred processing the catalog.         *\n*         4     A disk required to build the extent table could not   *\n*               be found for a VSAM library.                          *\n*         5     The library has more extents than entries in the      *\n*               extent table.                                         *\n*         6     The library has more than three extents on one of     *\n*               its disks (non-VSAM libraries only).                  *\n*         7     The sublibrary specified on input could not be found. *\n*         8     The member specified on input could not be found.     *\n*                                                                     *\n*     If the return code is zero then the REXX variables LIBR.0 to    *\n*     LIBR.nnn are setup as follows:                                  *\n*         LIBR.0     =    nnn   where nnn is the highest LIBR.        *\n*                               variable set.                         *\n*         For a list of sublibraries (CMSLIBR                   )     *\n*         LIBR.1 to LIBR.nnn is as follows -                          *\n*              chars  1 for  8  =  sublibrary name                    *\n*              chars 10 for  6  =  creation date in YYMMDD format     *\n*              chars 17 for  6  =  number of members in sublibrary    *\n*         For a list of members (CMSLIBR sublib            )          *\n*         LIBR.1 to LIBR.nnn is as follows -                          *\n*              chars  1 for  8  =  member name                        *\n*              chars 10 for  8  =  member type                        *\n*              chars 19 for  6  =  creation date in YYMMDD format     *\n*              chars 26 for  6  =  replacement date in YYMMDD format  *\n*         For a display of a member (CMSLIBR sublib member type)      *\n*         LIBR.1 to LIBR.nnn is as follows -                          *\n*              chars  1 for 80  =  corresponding line in member       *\n*                                                                     *\n*  Generation:                                                        *\n*     1) In order to assemble this program make sure the following    *\n*        VSE macros have been ESERVed and MACLIBed down to CMS:       *\n*          i) ACB,RPL,OPEN,GET,MODCB and CLOSE to process VSAM        *\n*         ii) OVTOC and PVTOC to read VTOCs                           *\n*        iii) CCB and EXCP to issue I/Os                              *\n*     2) Use the RLDSAVE option of the LOAD command to make it        *\n*        acceptable for NUCXLOAD.                                     *\n*     3) Use the ALL option of the GENMOD command to allow this       *\n*        program to be run with CMS/DOS set on.                       *\n*  Software levels:                                                   *\n*     i)    VM/XA SP 2.0    (but should work on any VM system)        *\n*    ii)    VSE/SP VERSION 3.1.0 - VSE/SYSTEM PACKAGE VER 3.1.0       *\n*   iii)    VSE/SP VERSION 2.1.0 - VSE/VSAM VERSION 1.3.0             *\n         REGEQU\nSHVBLOCK SHVBLOCK                      * REXX variable DSECT\n         USING SHVBLOCK,R14            *\n         DMSCCB                        * CCB DSECT\n         USING DMSCCB,R5\n         IJJHDLST                      * Volume descriptor list DSECT\n         USING IJJHDLST,R2\nLIBRCMS  CSECT\n         USING LIBRCMS,R12             * establish base register\n         STM   R14,R12,12(R13)         * save caller's registers\n         LR    R12,R15                 * and load my base register\n         LA    R3,SAVE                 * new save area\n         ST    R3,8(R13)               * chain new s/a in old s/a\n         ST    R13,4(R3)               * chain old s/a in new s/a\n         LR    R13,R3                  * point to new s/a\n*    Transfer the parameters pointed to by R1 to my parameter         *\n*    table PARAMS and blank out unused entries in case a previous     *\n*    run left old parameters due to NUCXLOAD.                         *\n         LA    R4,NPARAMS              * max num of params to get\n         LA    R3,PARAMS               * start of parameter table\n         LA    R1,8(R1)                * start of parameters entered\nGETPARM1 EQU   *\n         MVI   0(R3),C' '              * blank out entry (NUCXLOAD)\n         CLI   0(R1),X'FF'             * end of parameters ?\n         BE    NXTPARAM                * branch if yes\n         MVC   0(L'PARAMS,R3),0(R1)    * move parameter to table\n         LA    R1,8(R1)                * address next parameter\nNXTPARAM EQU   *\n         LA    R3,8(R3)                * address next table entry\n         BCT   R4,GETPARM1             * get next parameter\n         CLI   BUILTFLG,C'Y'           * extent table already built ?\n         BE    TABBUILT                * branch if yes\n         MVI   BUILTFLG,C'Y'           * set \"table built\" flag\n*    Read the REXX variables LibrKEY,LibrVSM and LibrSYS to get       *\n*    the type of library to be read.                                  *\n         LA    R14,REXBLOCK            * address my SHVBLOCK\n         LA    R2,VARNUM               * number of variables to get\n         LA    R3,VARTAB               * start of variable table\nGETVARS  EQU   *\n         MVC   SHVBUFL(L'VARTAB),0(R3) * move params to SHVBLOCK\n         BAL   R10,GETVAR              * get the variable\n         LA    R3,L'VARTAB(R3)         * address next table entry\n         BCT   R2,GETVARS              * get next variable\n         LA    R10,TABBUILT            * set return address\n         CLI   VSMVARB,C'Y'            * is it a VSAM library\n         BE    VSAMLIB                 * branch if yes to build table\n         B     SDLIB                   * else branch for a non-VSAM one\n*    Read the library directory records until the specified sublib    *\n*    has been found or, if one hasn't been specified, set REXX        *\n*    variables LIBR. to provide info about each sublibrary.           *\n*    The first record in the library is the first of the library      *\n*    directory records and the sublibrary entries start at offset     *\n*    X'D8' in that record. The last fullword in the record points to  *\n*    the next record or is F'-1' if there are no more records. The    *\n*    sublibrary entries start at offset 0 in these subsequent records.*\n*    Each sublibrary entry is 72 bytes in length. The name is 8 bytes *\n*    at offset 0, the creation date is 6 bytes at offset 8 (YYMMDD)   *\n*    and the number of entries is 4 bytes at offset X'28'. The 4 bytes*\n*    at offset X'1C' point to the first record describing the members *\n*    in the sublibrary (the sublibrary directory records).            *\nTABBUILT EQU   *\n         MVI   LIBRB,C' '              * blank out REXX variable buffer\n         MVC   LIBRB+1(L'LIBRB-1),LIBRB\n         LA    R14,REXBLOCK            * address my SHVBLOCK\n         MVC   SHVNAMA,=A(LIBRVARN)    * start of variable name LIBR.nn\n         MVC   SHVVALA,=A(LIBRB)       * address of buffer to SHVBLOCK\n         MVC   SHVVALL,=A(L'LIBRB)     * length of buffer to SHVBLOCK\n         LA    R7,VBUF+X'D8'           * start of data in record\n         LA    R0,0                    * want first record\n         LA    R11,0                   * set stem number\nGETSLIBS EQU   *\n         BAL   R10,GETREC              * read the record\nLOOP     EQU   *\n         CLC   0(4,R7),=F'0'           * any more data on record ?\n         BNE   SLIBINFO                * branch if yes\n         LA    R1,VBUF\n         L     R0,RECLEN-4(R1)         * last fword points to next rec\n         C     R0,=F'-1'               * is there another record ?\n         BE    ENDREAD                 * branch if no\n         LA    R7,VBUF                 * start of data in next record\n         B     GETSLIBS                * read and process the record\nSLIBINFO EQU   *\n         CLC   SUB2GET,0(R7)           * this sublib in entry params ?\n         BE    ALLSLIBS                * branch if yes\n         CLI   SUB2GET,C' '            * was a sublib name specified ?\n         BNE   NOSHOW                  * branch if yes\n         MVC   SUBLIB,0(R7)            * put sublib name in REXX buffer\n         MVC   SUBLIBCD,8(R7)          * and create date as well\n         L     R1,X'28'(R7)            * get number of members\n         CVD   R1,CVDWORK              * and convert to decimal\n         MVC   EDPATRN(8),=X'4020202020202120'\n         ED    EDPATRN(8),CVDWORK+4\n         MVC   SUBLIBNO,EDPATRN+2      * now move to REXX buffer\n         LA    R11,1(R11)              * increment stem number\n         BAL   R10,SETVAR              * go and set the variable\nNOSHOW   EQU   *\n         LA    R7,72(R7)               * point to next sublibrary entry\n         B     LOOP                    * process it\nENDREAD  EQU   *\n         CLI   SUB2GET,C' '            * was a sublibrary specified ?\n         BE    FINISH                  * branch if no\n         B     SUBNTFND                * branch to set bad RC.\n*    Read the sublibrary directory records until the specified member *\n*    has been found or, if one hasn't been specified, set REXX        *\n*    variables LIBR. to give information about the members.           *\n*    The entries start at offset 0 in the first and subsequent        *\n*    records.                                                         *\n*    There are three types of entries - TYPE entries which describes  *\n*    the type of all subsequent members, MEMBER entries which         *\n*    describes members for the previous type, and DUMMY entries which *\n*    appear to be deleted entries.    The 2 bytes at offset 8 are     *\n*    X'0080' for a TYPE entry, X'0020' for a MEMBER entry, and any    *\n*    thing else is classed as a DUMMY entry.                          *\n*    A TYPE entry is 10 bytes in length and the type is 8 bytes at    *\n*    offset 0.                                                        *\n*    A MEMBER entry is X'48' bytes in length, the name is 8 bytes at  *\n*    offset 0, the creation date (YYMMDD) 6 bytes at offset X'26' and *\n*    the replacement date (YYMMDD) 6 bytes at offset X'30'. The 4     *\n*    bytes at offset X'0C' point to the first record describing the   *\n*    member's contents.                                               *\n*    A DUMMY entry's length is given by the 2 bytes at offset 0.      *\nALLSLIBS EQU   *                       * read a sublibrary's directory\n         L     R0,X'1C'(R7)            * get recno of its directory\nSUBDIAG  EQU   *\n         LA    R4,VBUF                 * start of data in record\n         BAL   R10,GETREC              * read the record\nNEXTMEM  EQU   *\n         CLC   0(8,R4),=XL8'00'        * end of data on record ?\n         BE    ENDLOOP                 * branch if yes\n         CLC   8(2,R4),=X'0020'        * is entry a member name ?\n         BE    ISMEMBER                * branch if yes\n         CLC   8(2,R4),=X'0080'        * is entry a member type ?\n         BE    ISTYPE                  * branch if yes\n         AH    R4,0(R4)                * dummy entry so skip over it\n         B     NEXTMEM                 * and process next entry\nISTYPE   EQU   *\n         MVC   TYPE(8),0(R4)           * set type of following members\n         LA    R4,10(R4)               * point to first of this type\nISMEMBER EQU   *\n         CLI   MEM2GET,C' '            * was member specified on entry?\n         BE    SHOWMEM                 * branch if no\n         CLC   MEM2GET,0(R4)           * is this the member ?\n         BNE   NOTMEM                  * branch if no\n         CLI   TYP2GET,C' '            * was type specified on entry?\n         BE    SHOWMEM                 * branch if no\n         CLC   TYP2GET,TYPE            * is the type the same ?\n         BE    COPYMEM                 * branch if yes\n         B     NOTMEM                  * skip listing member\nSHOWMEM  EQU   *\n         MVC   MEMBER,0(R4)            * move member name to REXX buff\n         MVC   MEMBERCD,X'26'(R4)      * and the create date\n         MVC   MEMBERRD,X'30'(R4)      * and the replace date\n         LA    R11,1(R11)              * increment the stem number\n         BAL   R10,SETVAR              * and set the variable\nNOTMEM   EQU   *\n         LA    R4,X'48'(R4)            * point to next member entry\n         B     NEXTMEM                 * go and process it\nENDLOOP  EQU   *\n         LA    R1,VBUF\n         L     R0,RECLEN-4(R1)         * last fword is next rec number\n         C     R0,=F'-1'               * is there another record\n         BNE   SUBDIAG                 * branch if yes\n         CLI   TYP2GET,C' '            * were we looking for a member ?\n         BE    FINISH                  * branch if no\n         B     MEMNTFND                * go and set a bad RC\n*    Read the member records describing its contents and set REXX     *\n*    variables LIBR. to correspond to each line in the member.        *\n*    The data starts at offset 0 and is compressed to removed spaces. *\n*    The first byte of the data is a compression control byte. Bits   *\n*    0 to 3 describe the number of characters following it and bits   *\n*    4 to 7 describe the number of spaces that should be added after  *\n*    the characters. Another control byte and characters follow the   *\n*    previous set and continues in this manner describing the complete*\n*    contents of the member. A X'00' control byte ends the data.      *\n*    A member line is put into LIBR. each time 80 bytes of data have  *\n*    been decompressed which is why PHASEs and DUMPs aren't supported.*\nCOPYMEM  EQU   *\n         LA    R11,0                   * set stem number\n         L     R0,X'0C'(R4)            * get member record number\nCOPYMEM0 EQU   *\n         BAL   R10,GETREC              * read the record\n         MVI   LIBRB,C' '              * blank out the REXX buffer\n         MVC   LIBRB+1(L'LIBRB-1),LIBRB\n         LA    R7,VBUF                 * start of data in record\n         LA    R8,LIBRB                * address REXX buffer\n         LA    R9,L'LIBRB              * length of REXX buffer\nCOPYMEM1 EQU   *\n         LTR   R9,R9                   * reached end of REXX buffer?\n         BE    EOLINE                  * branch if yes\n         LA    R5,0\n         ICM   R5,B'0001',0(R7)        * get number of chars and spaces\n*                                      * bits 0-3=chars  4-7=spaces\n         BE    EOREC                   * branch if both zero\n         LR    R4,R5                   * copy into R4\n         SRL   R4,4                    * and shift to get num of chars\n         N     R5,=X'0000000F'         * turn R5 into num of spaces\n         SR    R9,R4                   * take chars away from REXX buff\n         SR    R9,R5                   * take spaces away as well\n         LTR   R4,R4                   * are there any characters ?\n         BE    MOV4SPCS                * branch if no\n         BCTR  R4,R0                   * decrement length for MVC\n         EX    R4,MVCMEMBF             * and move chars to REXX buffer\n         LA    R8,1(R4,R8)             * move up posn in REXX buffer\n         LA    R4,1(R4)                * increment length after MVC\nMOV4SPCS EQU   *\n         LA    R7,1(R4,R7)             * move up posn in record\n         AR    R8,R5                   * move up posn in REXX buffer\n         B     COPYMEM1                * goback and process next entry\nEOLINE   EQU   *\n         LA    R11,1(R11)              * increment stem number\n         BAL   R10,SETVAR              * go and set the variable\n         MVI   LIBRB,C' '              * blank out the REXX buffer\n         MVC   LIBRB+1(L'LIBRB-1),LIBRB\n         LA    R8,LIBRB                * readdress REXX buffer\n         LA    R9,L'LIBRB              * and reset length\n         B     COPYMEM1                * read next line in member\nEOREC    EQU   *\n         LA    R7,VBUF                 * start of data in next record\n         L     R0,RECLEN-4(R7)         * last fword is next record num\n         C     R0,=F'-1'               * are there any more records ?\n         BNE   COPYMEM0                * branch if yes\n         B     FINISH                  * getout\n*    Write error messages and set RC if something wrong.              *\nRECERROR EQU   *                       * GETREC couldn't get record\n         LINEDIT TEXT='RECORD ERROR FOR RECNO ........',SUB=(HEX,(R5))\n         LA    R15,1\n         B     GETOUT\nREXERR   EQU   *                       * EXECCOMM gave bad return code\n         LINEDIT TEXT='REXX ERROR ........',SUB=(DEC,(R15))\n         LA    R15,2\n         B     GETOUT\nVSAMERR  EQU   *                       * VSAM should write error msg\n         LA    R15,3\n         B     GETOUT\nVOL1MISS EQU   *                       * VSAM library disk not ASSGN'd\n         LINEDIT TEXT='MISSING VOLID ......',SUB=(CHARA,(R5))\n         LA    R15,4\n         B     GETOUT\nTOOHIERR EQU   *                       * Not enough XTNTTAB entries\n         LINEDIT TEXT='LIBRARY HAS TOO MANY EXTENTS'\n         LA    R15,5\n         B     GETOUT\nOVER3    EQU   *                       * More than 3 extents on a disk\n         LINEDIT TEXT='LIBRARY HAS MORE THAN THREE EXTENTS ON ONE DISK'\n         LA    R15,6\n         B     GETOUT\nSUBNTFND EQU   *                       * Obvious\n         LINEDIT TEXT='SPECIFIED SUBLIBRARY NOT FOUND'\n         LA    R15,7\n         B     GETOUT\nMEMNTFND EQU   *                       * Obvious\n         LINEDIT TEXT='SPECIFIED MEMBER NOT FOUND'\n         LA    R15,8\n         B     GETOUT\n*    Exit after everything worked ok.                                 *\nFINISH   EQU   *\n         BAL   R10,SETSTEM             * set LIBR.0 to number of lines\n         LA    R15,0                   * give a nice return code\nGETOUT   EQU   *\n         L     R13,4(R13)              * get old s/a\n         L     R14,12(R13)             * restore caller's registers\n         LM    R0,R12,20(R13)          * except for R15\n         BR    R14                     * and return to caller\n*    Read the library record whose number is in R0.                   *\n*    (0 is the first record).                                         *\nGETRECSV DS    5F                      * where to save regs\nGETREC   EQU   *\n         STM   R3,R7,GETRECSV          * save regs about to change\n         LR    R5,R0                   * transfer wanted record number\n         LA    R3,XTNTTAB              * address the extent table\n         LA    R4,0\nXTNTLOOP EQU   *\n         CLC   XTNTLO(4,R3),=F'-1'     * reached end of table ?\n         BE    RECERROR                * branch if yes\n         C     R0,XTNTRECS(R3)         * is the record in this extent\n         BL    GOTXTNT                 * branch if yes\n         L     R4,XTNTRECS(R3)         * transfer highest rec num here\n         LA    R3,XTNTLEN(R3)          * address next table entry\n         B     XTNTLOOP                * process next entry\nGOTXTNT  EQU   *\n         SR    R5,R4                   * record num relative to extent\n         LA    R4,0\n         D     R4,=F'31'               * relative trk=rec/(recs/trk)\n         LA    R4,1(R4)                * remainder+1 = rec for SEID\n         STC   R4,SEIDDATA+4           * store it for SEID\n         LA    R4,0\n         D     R4,=F'15'               * relative cyl=trk/(trks/cyl)\n         AH    R4,XTNTLO+2(R3)         * + start of extent for abs trk\n         LR    R7,R4                   * recalculate trk in case above\n         LA    R6,0                    * addition caused spill into\n         D     R6,=F'15'               * next cyl.\n         AR    R5,R7                   * add to rel cyl if spilled\n         STH   R6,SEEKDATA+4           * store trk for SEEK\n         STH   R6,SEIDDATA+2           * and for SEID\n         AH    R5,XTNTLO(R3)           * abs cyl = rel_cyl+extent_start\n         STH   R5,SEEKDATA+2           * store cyl for SEEK\n         STH   R5,SEIDDATA             * and for SEID\n         LA    R5,CCBBLOCK             * address the CCB block\n         MVC   CCBSUNUM,XTNTADDR+3(R3) * transfer SYS unit extent is on\n         EXCP  CCBBLOCK                * issue i/o\n         LM    R3,R7,GETRECSV          * restore regs\n         BR    R10                     * return\n*    Retrieve the value of a REXX variable (SHVBLOCK already set).    *\nGETVAR   EQU   *\n         LA    R14,REXBLOCK            * address my SHVBLOCK\n         MVI   SHVCODE,SHVSYFET        * want to fetch\n         LA    R1,EXECCOMM             * address \"EXECCOMM\" string\n         ICM   R1,B'1000',=X'02'       * insert \"subcommand call\" flag\n         LA    R0,EPLIST               * address the extended plist\n         SVC   202                     * retrieve the variable\n         DC    AL4(REXERR)             * branch off if error\n         BR    R10                     * return\n*    Set LIBR.0 to highest LIBR. variable set (R11).                  *\nSETSTEM  EQU   *\n         LA    R14,REXBLOCK            * address my SHVBLOCK\n         MVC   SHVVALA(4),=A(EDPATRN+2) * move address of value\n         MVC   SHVVALL(4),=A(6)        * move length of value\n         CVD   R11,CVDWORK             * convert no of lines to decimal\n         MVC   EDPATRN(8),=X'4021202020202020'\n         ED    EDPATRN(8),CVDWORK+4\n         MVC   SHVNAML,=A(6)           * move length of name\n         MVI   LIBRVARN+5,C'0'         * make it LIBR.0\n         B     SETSVC                  * branch to set variable\n*    Set LIBR.xxx where xxx is in R11.                               *\nSETVAR   EQU   *\n         LA    R14,REXBLOCK            * address my SHVBLOCK\n         MVI   SHVCODE,SHVSTORE        * tell EXECCOMM want to store\n         CVD   R11,CVDWORK             * turn stem number into decimal\n         MVC   EDPATRN(8),=X'4020202020202120'\n         ED    EDPATRN(8),CVDWORK+4\n         LA    R15,0                   * zeroise decimal number length\n         LA    R1,EDPATRN+7            * address end of decimal number\nSCAN     EQU   *                       * scan for space to calc length\n         CLI   0(R1),C' '              * found start of R11 number ?\n         BE    GOTSPC1                 * branch if yes\n         LA    R15,1(R15)              * increment length count\n         BCT   R1,SCAN                 * decrement posn and look again\nGOTSPC1  EQU   *\n         EX    R15,SCANMVC             * move number to LIBR.xxx\n         LA    R15,5(R15)              * add length of LIBR.\n         ST    R15,SHVNAML             * store in name length\nSETSVC   EQU   *\n         LA    R1,EXECCOMM             * address \"EXECCOMM\"\n         ICM   R1,B'1000',=X'02'       * insert \"subcommand call flag\"\n         LA    R0,EPLIST               * address extended plist\n         SVC   202                     * call EXECCOMM\n         DC    AL4(REXERR)             * branch if get an error\n         BR    R10                     * return\n*    Build the extent table (XTNTTAB) for a non-VSAM library.         *\n*    Read VTOCs of all disks ASSGNed to SYS100 onwards and put any    *\n*    library extents in sequence order into the extent table, then    *\n*    read table and calculate highest record number held in each      *\n*    extent.                                                          *\nSDLIB    EQU   *                       * build non-VSAM extent table\n         LA    R3,XTNTNUM              * number of table entries\n         LA    R4,SYSADDR              * start of SYStem logical units\nSDLOOP1  EQU   *\n         STC   R4,SYSNUM+1             * set SYS number to check\n         OVTOC SYSNO=SYSNUM,DLIST=DLISTADR * open the vtoc\n         LTR   R15,R15                 * errors ?\n         BNE   SDLOOP2                 * branch if yes\n*                                      * now read FORMAT1 label\n         PVTOC READ,DLIST=DLISTADR,IOA=VBUF,TYPE=F1,NAME=KEYVARB\n         LTR   R15,R15                 * errors ?\n         BNE   LEAVE                   * branch if yes\n         LA    R2,0\n         IC    R2,VBUF+X'3B'+7         * get num of extents on disk\n         CH    R2,=H'3'                * more than three extents ?\n         BH    OVER3                   * branch if yes\n         LA    R7,VBUF+X'69'+7         * start of extent information\nLOOPIT   EQU   *\n         LA    R6,0\n         IC    R6,1(R7)                * get extent sequence number\n         CH    R6,=AL2(XTNTNUM)        * can it fit in the extent table\n         BNL   TOOHIERR                * branch if no\n         MH    R6,=AL2(XTNTLEN)        * calculate offset into table\n         LA    R6,XTNTTAB(R6)          * and add to start of table\n         MVC   XTNTLO(4,R6),2(R7)      * move lo extent into table\n         MVC   XTNTHI(4,R6),6(R7)      * and move hi extent\n         ST    R4,XTNTADDR(R6)         * and store its SYS number\n         LA    R7,10(R7)               * move onto next FORMAT1 entry\n         BCT   R2,LOOPIT               * process next extent\nLEAVE    EQU   *\n         LA    R4,1(R4)                * go onto the next SYS unit\n         BCT   R3,SDLOOP1              * go and process it\nSDLOOP2  EQU   *\n         CLI   SYSVARB,C'Y'            * is it IJSYSRS\n         BNE   NOTSYS                  * branch if no\n         LA    R6,XTNTTAB              * address the extent table and\n         LH    R1,XTNTLO+2(R6)         * increment the start of the\n         LA    R1,1(R1)                * first extent by one track cos\n         STH   R1,XTNTLO+2(R6)         * the first track is ipl stuff.\nNOTSYS   EQU   *\n         LA    R6,XTNTTAB              * address extent table\n         LA    R7,0                    * zero accumulative record count\nLOOPIT2  EQU   *\n         CLC   XTNTLO(4,R6),=F'-1'     * any more extents ?\n         BE    0(R10)                  * return if no\n         LH    R9,XTNTHI(R6)           * get hi cyl\n         SH    R9,XTNTLO(R6)           * subtract lo cyl for num cyls\n         MH    R9,=H'15'               * calculate number of tracks\n         SH    R9,XTNTLO+2(R6)         * subtract the lo track and add\n         AH    R9,XTNTHI+2(R6)         * hi trk for num trks in extent\n         LA    R9,1(R9)                * add one to make it work\n         MH    R9,=H'31'               * num recs=trks*(recs/trk)\n         AR    R7,R9                   * add to accumulative record cnt\n         ST    R7,XTNTRECS(R6)         * store in table entry\n         LA    R6,XTNTLEN(R6)          * address next table entry\n         B     LOOPIT2                 * and process it\n*    Build the extent table (XTNTTAB) for a VSAM library.             *\n*    Open IJSYSUC as a KSDS file and GET a record using the library   *\n*    file-id (ie VSE.PRD2.LIBRARY) as the key. The 2 bytes at offset  *\n*    45 in this record are used to make a key to GET the cluster      *\n*    record. The format of this key is:                               *\n*            X'0000',(the 2 bytes),X'01',XL39'00'.                    *\n*    The 2 bytes at offset X'80' in the cluster record form another   *\n*    key as above to GET the data record. The 2 bytes at offset X'96' *\n*    in the data record form the key of record describing the extents.*\n*    The extent info starts at offset 60 in this record, however if   *\n*    the 2 bytes at offset X'96' in the data record are X'0000' then  *\n*    the extent info is found in the data record at the offset calc'd *\n*    by the following equation:   X'FD'+(5*(byte at X'94')).          *\n*    The extent info comes in blocks with each block describing the   *\n*    extents on a single disk. The volser of the disk is at offset 6  *\n*    for 6 bytes in the block and the number of extents on this disk  *\n*    is held in the 1 byte at offset 15. The lo address of the first  *\n*    extent is at offset 47 for 4 bytes (CCCCHHHH) and the hi address *\n*    is at offset 51 for 4 bytes. The description of each extent in   *\n*    the block is 20 bytes in length and so the displacement to the   *\n*    next extent is 20 bytes and so on. The length of the block and   *\n*    so the displacement to the next block is (20*(num extents))+X'2D'*\nVSAMLIB  EQU   *\n         LA    R2,DLISTADR             * address the descriptor list\n         LA    R3,VOL1NUM              * number of volser table entries\n         LA    R4,SYSADDR              * start at SYS100\n         LA    R6,VOL1TAB              * address the volser table\nVOL1LOOP EQU   *\n         STC   R4,SYSNUM+1             * set the SYS unit to process\n         OVTOC SYSNO=SYSNUM,DLIST=DLISTADR * open the vtoc\n         LTR   R15,R15                 * errors ?\n         BNE   GETXTNTS                * branch if yes\n         MVC   VOL1VOL(,R6),DLVOLID    * move volser into table\n         LA    R4,1(R4)                * move onto next SYS unit\n         LA    R6,VOL1LEN(R6)          * address next table entry\n         BCT   R3,VOL1LOOP             * process next entry\nGETXTNTS EQU   *\n         OPEN  IJSYSUC                 * open the catalogue\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         GET   RPL=MYRPL               * get file record\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         MVC   THEKEY2+2(2),VBUF+45    * set key to get cluster record\n         MODCB RPL=MYRPL,ARG=THEKEY2   * mod rpl to reflect new key\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         GET   RPL=MYRPL               * get cluster record\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         MVC   THEKEY2+2(2),VBUF+X'80' * set key to get data record\n         GET   RPL=MYRPL               * get data record\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         LA    R3,XTNTTAB              * address the extent table\n         LA    R4,XTNTNUM              * number of table entries\n         ICM   R5,B'0011',VBUF+X'96'   * are extents on different rec ?\n         BE    ONTHISRC                * branch if no\n         STH   R5,THEKEY2+2            * set key for this other rec\n         GET   RPL=MYRPL               * get the record\n         LTR   R15,R15                 * errors ?\n         BNE   VSAMERR                 * branch if yes\n         LA    R5,VBUF+60              * start of extent info on rec\n         B     READEM                  * branch to read info\nONTHISRC EQU   *\n         LA    R5,0\n         IC    R5,VBUF+X'94'           * take byte at offset X'94'\n         MH    R5,=H'5'                * multiply by five and\n         LA    R5,VBUF+X'FD'(R5)       * add X'FD' for start of info\nREADEM   EQU   *\n         LA    R7,0                    * zero accumulative record count\nXLOOP    EQU   *\n         CLC   47(4,R5),=F'0'          * end of extent info ?\n         BE    DONEXTNT                * branch if yes\n         LA    R8,VOL1TAB              * address the volser table\n         LA    R9,SYSADDR              * start at SYS100\nGETVOL1  EQU   *\n         CLI   VOL1VOL(R8),C' '        * end of volser table ?\n         BE    VOL1MISS                * branch if yes\n         CLC   VOL1VOL(,R8),6(R5)      * got the right disk ?\n         BE    VOL1HIT                 * branch if yes\n         LA    R8,VOL1LEN(R8)          * goto next volser table entry\n         LA    R9,1(R9)                * and next SYS unit\n         B     GETVOL1                 * branch to check next SYS unit\nVOL1HIT  EQU   *\n         LA    R8,0\n         ICM   R8,B'0001',15(R5)       * get num of extents for disk\n         BE    NEXTBLK                 * branch if zero\nXLOOP2   EQU   *\n         ST    R9,XTNTADDR(R3)         * store SYS unit in extent table\n         MVC   XTNTLO(4,R3),47(R5)     * and lo extent\n         MVC   XTNTHI(4,R3),51(R5)     * and hi extent\n         LH    R6,XTNTHI(R3)           * get hi cyl\n         SH    R6,XTNTLO(R3)           * subtract lo cyl\n         MH    R6,=H'15'               * and multiply by 15 for trks\n         SH    R6,XTNTLO+2(R3)         * minus lo trk\n         AH    R6,XTNTHI+2(R3)         * plus hi trk\n         LA    R6,1(R6)                * and add one for total trks\n         MH    R6,=H'31'               * multiply for total records\n         AR    R7,R6                   * add to accumulative rec count\n         ST    R7,XTNTRECS(R3)         * and store in extent table\n         LA    R5,20(R5)               * address next extent info\n         LA    R3,XTNTLEN(R3)          * address next table entry\n         SH    R4,=H'1'                * decrement XTNTTAB entries left\n         BC    4,TOOHIERR              * branch if none left.\n         BCT   R8,XLOOP2               * process next extent\nNEXTBLK  EQU   *\n         LA    R5,X'2D'(R5)            * address next disk with extents\n         B     XLOOP                   * go and find it\nDONEXTNT EQU   *\n         CLOSE IJSYSUC                 * close the catalog\n         BR    R10                     * return\n*                         Storage areas.                              *\n*      Parameter table to record entry parameters.                    *\nPARAMS   EQU   *,8                     * table for input parameters\nSUB2GET  DC    CL(L'PARAMS)' '         * specified sublibrary\nMEM2GET  DC    CL(L'PARAMS)' '         * specified member name\nTYP2GET  DC    CL(L'PARAMS)' '         * specified member type\nNPARAMS  EQU   (*-PARAMS)/L'PARAMS     * number of entries\n*    Table describing REXX variables to retrieve and their buffers    *\nVARTAB   EQU   *,16                    * table of REXX vars to read\n         DC    A(L'KEYVARB,KEYVARN,L'KEYVARN,KEYVARB) * library file-id\n         DC    A(L'SYSVARB,SYSVARN,L'SYSVARN,SYSVARB) * is it IJSYSRS\n         DC    A(L'VSMVARB,VSMVARN,L'VSMVARN,VSMVARB) * is it VSAM\nVARNUM   EQU   (*-VARTAB)/L'VARTAB\n*    The variable names and buffers described above.                  *\nKEYVARN  DC    C'LibrKEY'              * REXX var with library file-id\nKEYVARB  DC    CL44' '                 * buffer to put its value in\nSYSVARN  DC    C'LibrSYS'              * REXX var to say if its IJSYSRS\nSYSVARB  DC    CL8' '                  * buffer to put value in (Y/N)\nVSMVARN  DC    C'LibrVSM'              * REXX var to say if its VSAM\nVSMVARB  DC    CL8' '                  * buffer to put value in (Y/N)\n*    Extended plist, \"EXECCOMM\" string and SHVBLOCK used by EXECCOMM. *\nEXECCOMM DC    C'EXECCOMM'             * required for EXECCOMM\nEPLIST   DC    A(EXECCOMM)             * extended plist for EXECCOMM\n         DC    A(0)\n         DC    A(0)\n         DC    A(REXBLOCK)\nREXBLOCK DC    XL(SHVBLEN)'0'          * my SHVBLOCK for REXX variables\n*    Couple of instructions to EXecute.                               *\n         DS    0F\nSCANMVC  MVC   LIBRVARN+5(0),1(R1)     * EX inst to move LIBR. stem num\n         DS    0F\nMVCMEMBF MVC   0(0,R8),1(R7)           * EX inst to move member data\n*    The REXX LIBR. output buffer and variable and associated equates.*\nLIBRVARN DC    CL30'LIBR.'             * REXX var name for output\nLIBRB    DC    CL80' '                 * output buffer for REXX LIBR.n\nSUBLIB   EQU   LIBRB+0,8               * posn of sublib name in LIBR.n\nSUBLIBCD EQU   LIBRB+9,6               * posn of sublib create date\nSUBLIBNO EQU   LIBRB+16,6              * posn of number of entries\nMEMBER   EQU   LIBRB+0,8               * posn of member name\nTYPE     EQU   LIBRB+9,8               * posn of member type\nMEMBERCD EQU   LIBRB+18,6              * posn of member create date\nMEMBERRD EQU   LIBRB+25,6              * posn of member replace date\n*    VSE macros and associated data.                                  *\nIJSYSUC  ACB   AM=VSAM,                * ACB to open the catalogue     X\n               MACRF=(IN,KEY)\nMYRPL    RPL   ACB=IJSYSUC,            * RPL to access the catalogue   X\n               AM=VSAM,                                                X\n               AREA=VBUF,                                              X\n               AREALEN=L'VBUF,                                         X\n               ARG=KEYVARB,                                            X\n               OPTCD=(KEY,MVE,DIR)\nCCBBLOCK CCB   SYS100,CCWADDR          * CCB for EXCP to issue CCWs\n*\nSYSADDR  EQU   100                     * disks ASSGN'd to SYS100 on\nRECLEN   EQU   1024                    * library blocksize\nSYSNUM   DC    X'0100'                 * SYS number for O/PVTOC macros\nTHEKEY2  DC    X'0000000001'           * 2nd KEY for VSAM GET\n         DC    XL39'00'\nDLISTADR DS    XL(DLLEN)               * space for vol descriptor list\n*    Table describing the location of the library's extents.          *\nXTNTTAB  DS    0F                      * table describing extents\nXTNTLO   EQU   *-XTNTTAB               * lo extent  (CCHH)\n         DC    F'-1'\nXTNTHI   EQU   *-XTNTTAB               * hi extent  (CCHH)\n         DC    F'0'\nXTNTRECS EQU   *-XTNTTAB               * highest rec num held in it\n         DC    F'0'\nXTNTADDR EQU   *-XTNTTAB               * SYStem logical unit its on\n         DC    F'0'\nXTNTLEN  EQU   *-XTNTTAB               * length of table entry\n         DC    15F'-1,0,0,0'                    * a few more entries\nXTNTNUM  EQU   (*-XTNTTAB)/XTNTLEN     * number of entries\n         DC    F'-1',F'0',F'0',F'0'    * dummy entry to mark end of tab\n*    Table describing the volsers of all ASSGNed disks.               *\nVOL1TAB  EQU   *                       * table of volids assgn'd\nVOL1VOL  EQU   *-VOL1TAB,6             * the volser\n         DC    CL6' '\nVOL1LEN  EQU   *-VOL1TAB               * length of entry\n         DC    15CL6' '                * space for entries\nVOL1NUM  EQU   (*-VOL1TAB)/VOL1LEN     * number of entries\n         DC    CL6' '                  * dummy entry to mark end of tab\n*    CCWs and data.                                                   *\nSEEKDATA DC    X'000000000000'         * used by SEEK command\nSEIDDATA DC    X'0000000000'           * used by SEID command\nCCWADDR  CCW   X'07',SEEKDATA,X'40',6  * seek extent\nSEIDADDR CCW   X'31',SEIDDATA,X'40',5  * search for record\nTIC      CCW   X'08',SEIDADDR,X'40',5  * loop till find it\nCCWCMD   CCW   X'06',VBUF,X'00',RECLEN * read it\n*    Bits n bobs.                                                     *\nBUILTFLG DC    C'N'                    * indicates if extent tab built\nCVDWORK  DS    1D                      * work area for decimal convert\nEDPATRN  DC    X'4020202020202120'     * same again\nSAVE     DS    18F                     * save area\n*    The LITERAL POOL because can't address if after VBUF.            *\n         LTORG                         * make LITERAL POOL addressable\n*    Buffer to read records into.                               *\nVBUF     DS    XL(RECLEN)              * my i/o buffer\n         END\n\n\nLIBREXX EXEC\n\n/* Function:   To view the contents of VSE/SP3 (Version 2) libraries  */\n/*              from CMS.                                             */\n/* Operation:  After the required library has been selected from the  */\n/*             menu, the CMSDOS environment is set and all disks that */\n/*             the library resides on are ASSGNed to SYS100 onwards.  */\n/*             The LIBRCMS module is called to set REXX variables     */\n/*             LIBR.0 to LIBR.nnn where nnn is the number of          */\n/*             sublibraries (LIBR.0 = nnn), with information relating */\n/*             to each sublibrary (name, creation date, and number of */\n/*             members).  This information is then displayed in an    */\n/*             XEDIT file in which the contents of a sublibrary can   */\n/*             be displayed by typing LX beside it in the prefix area.*/\n/*             Once a sublibrary's members have been listed, the      */\n/*             contents of a member can also be put in a XEDIT file by*/\n/*             typing LX beside it.                                   */\n/*             Please note that although the LIBRCMS module reads the */\n/*             library quite quickly, the process of queuing the      */\n/*             entries and using XEDIT to display them can be slow by */\n/*             comparison if the number is large.  Therefore you might*/\n/*             wish to use some other method of displaying them.      */\n/*             However, this would of course lose the flexibillity    */\n/*             that XEDIT provides.                                   */\n/* Other programs  :                                                  */\n/*    LIBREXX  XEDIT  - Profile used when XEDITing.                   */\n/*    LIBXEDIT XEDIT  - The LX prefix macro used to list members and  */\n/*                      the contents of members.                      */\n/*    LIBRCMS  MODULE - Called by LIBREXX EXEC and LIBXEDIT XEDIT to  */\n/*                      read the library and place the information in */\n/*                      rexx variable LIBR.0 to LIBR.nnn where nnn =  */\n/*                      LIBR.0.                                       */\n/*    Refer to the LIBRCMS source for detailed information on calling */\n/*    the LIBRCMS MODULE.                                             */\n/* Display the available libraries and get a selection */\n\"VMFCLEAR\"\nndisks = 0\nqueue \"IJSYSRS     VSE.SYSRES.LIBRARY                        DOSRES N Y\"\nqueue \"PRD1        VSE.PRD1.LIBRARY                          DOSRES N N\"\nqueue \"PRD2        VSE.PRD2.LIBRARY                          MCAT   Y N\"\nqueue \"MGMPROD     LIVE.PROD.LIBRARY                         SPUCT  Y N\"\nqueue \"MGMTEST     MGM.TEST.LIBRARY                          UCAT1  Y N\"\nqueue \"SASLIB      SAS.TEST.LIBRARY                          UCAT1  Y N\"\nsay\nsay \"                       =====>>>  LIBRCMS  <<<====\"\nsay\nsay \"                     Enter number of the library......\"\nsay\nnum_libs = queued()\ndo i = 1 to num_libs\n  pull libname.i libid.i libcat.i libvsm.i libsys.i .\n  say \"        \"i\")    \"left(libname.i,8)\"    \"left(libid.i,44),\n                                                         \"    \"libcat.i\nend\npull lib_wanted .\nif lib_wanted < 0 | lib_wanted > num_libs | datatype(lib_wanted) \u00ac=\n                                         \"NUM\" then signal exit_program\n/* Setup the enviroment to run LIBRCMS MODULE */\n/* LIBRCMS MODULE reads these variables to get library characteristics*/\nLibrKEY = libid.lib_wanted             /* filename        */\nLibrVSM = libvsm.lib_wanted            /* VSAM (Y/N)      */\nLibrSYS = libsys.lib_wanted            /* IJSYSRS (Y/N)   */\n/* Make NUCXLOADable to save above info across successive executions */\n\"SET CMSTYPE HT\"\n\"NUCXLOAD LIBRCMS (PUSH\"\n\"DLBL * CLEAR\"\n/* Setup the MASTER catalogue if needed */\nif LibrVSM = \"Y\" then call setup_MCAT\n/* Setup the USER catalogue or disks */\ninterpret \"CALL setup_\"libcat.lib_wanted\n\"SET DOS ON (VSAM\"\nif LibrVSM = \"Y\" then do\n  \"ASSGN SYSCAT \"mcat_mode\n  \"DLBL IJSYSCT  \"mcat_mode\" (VSAM SYSCAT\"\nend\n/* ASSGN all disks to SYS100 onwards */\ndo i = 1 to ndisks\n  \"ASSGN SYS\"99+i free_mode.i\nend\n/* ASSGN IGN last one to stop OVTOC falling over */\n\"ASSGN SYS\"100+ndisks\" IGN\"\n\"SET CMSTYPE RT\"\n/* Read the library */\n\"LIBRCMS\"\nif rc \u00ac= 0 then signal exit_program\nif libr.0 = 0 then do\n  say\n  say \"NO SUBLIBRARIES AVAILABLE\"\n  say\n  signal exit_program\nend\n/* Queue up data and XEDIT file */\ndo i = 1 to libr.0\n sublib = substr(libr.i,1,8)\n num_members = substr(libr.i,17,6)\n create_date = substr(libr.i,14,2)\"/\"substr(libr.i,12,2)\"/\"substr(libr.i,10,2)\nqueue \"INPUT          \"sublib\"           \"create_date\"              \"num_members\nend\nqueue \"SET RESERVE 24 GREEN  REVV HIGH\",\n                    \"***Put LX in the prefix area to view a sublib*** \"\nqueue \"SET RESERVE 2  GREEN  REVV HIGH               \",\n                      \"Sublibrary         Create date        No members\"\n/* This avoids XEDITing an existing file on disk */\npush \"FN \"libname.lib_wanted\npush \"FT $$SLIB$$\"\n\"XEDIT $LIBREXX LIBREXX$ A (PROF LIBREXX\"\nexit_program:\n\"SET DOS OFF\"\n\"NUCXDROP LIBRCMS\"\ndo i = 1 to ndisks\n  \"RELEASE \"free_mode.i\" (DET\"\nend\nexit\nsetup_UCAT1:\ncall getadisk\n\"CP LINK SP3TEST 242 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\n\"DLBL IJSYSUC  \"free_mode.ndisks\" DSN MGM001.USER.CATALOG   (VSAM\"\ncall getadisk\n\"CP LINK SP3TEST 244 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\nreturn\nsetup_DOSRES:\ncall getadisk\n\"CP LINK SP3TEST 240 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\nreturn\nsetup_SPUCT:\ncall getadisk\n\"CP LINK SP3TEST 241 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\n\"DLBL IJSYSUC  \"free_mode.ndisks\" DSN VSESP.USER.CATALOG   (VSAM\"\ncall getadisk\n\"CP LINK SP3TEST 240 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\nreturn\nsetup_MCAT:\ncall getadisk\nmcat_mode = free_mode.ndisks\n\"CP LINK SP3TEST 240 \"free_addr.ndisks\" RR VSEIPO\"\n\"ACCESS \"free_addr.ndisks free_mode.ndisks\n\"DLBL IJSYSUC  \"free_mode.ndisks\" DSN VSAM.MASTER.CATALOG  (VSAM \"\nreturn\ngetadisk:\nndisks = ndisks + 1\n\"GETFMADR\"\npull . free_mode.ndisks free_addr.ndisks .\nreturn\n\n\nLIBXEDIT XEDIT\n\n/* This macro processes the LX prefix macro requests to list members  */\n/* in a sublibrary or the contents of a member.                       */\n/* If the filetype of the file in which it is issued is $$SLIB$$ then */\n/* LIBXEDIT assumes it is a list of sublibraries created by LIBREXX   */\n/* EXEC and sets about listing the members in that sublibrary,        */\n/* otherwise it displays the contents of the member.                  */\n/* Note that LIBRCMS only supports the XEDITing of members with an 80 */\n/* byte record format (this includes most types except PHASEs and     */\n/* DUMPs).                                                            */\narg . . lineno .\n\"EXTRACT /FN/FT/LINE\"\n\":\"lineno\n\"STACK 1\"\n\":\"line.1\n/* Should I list a sublibrary or a member */\nif ftype.1 \u00ac= \"$$SLIB$$\" then signal xedit_member\npull slib_name .\n/* Read the sublibrary directory */\n\"SET LINEND OFF\"     /* set control chars off in case in sublib name */\n\"SET ESCAPE OFF\"\n\"SET ARB OFF\"\n\"CMS LIBRCMS \"slib_name\nlibr_rc = rc\n\"SET LINEND ON\"     /* set control chars back on again */\n\"SET ESCAPE ON\"\n\"SET ARB ON\"\nif libr_rc \u00ac= 0 then do\n  \"EMSG Error code \"rc\" from LIBR MODULE.\"\n  exit\nend\n/* Queue and XEDIT it */\n\"DESBUF\"\nqueue \"XEDIT $$LIBR$$ $$LIBR$$ A (PROF LIBREXX\"\nqueue \"SET RESERVE 24 GREEN  REVV HIGH                \",\n                 \"***Put LX in the prefix area to look at a member*** \"\nqueue \"SET RESERVE 2 GREEN REVV HIGH           \",\n        \"Member name     Member type      Create date     Replace date\"\nqueue \"FN \"fname.1\nqueue \"FT \"slib_name\ndo i = 1 to libr.0\n cdate = substr(libr.i,23,2)\"/\"substr(libr.i,21,2)\"/\"substr(libr.i,19,2)\n if substr(libr.i,26,6) = \"      \" then rdate = \"        \"\n    else rdate = substr(libr.i,30,2)\"/\"substr(libr.i,28,2)\"/\"substr(libr.i,26,2)\n queue \"INPUT      \"substr(libr.i,1,8)\"         \"substr(libr.i,10,8)\"       ,\n\"cdate\"        \"rdate\nend\nexit\nxedit_member:\npull member_name member_type .\n/* Don't allow non-80 byte record format members to be XEDIT'd */\nif member_type = \"PHASE\" | member_type = \"DUMP\" then do\n  \"EMSG XEDIT not supported for this type of member.\"\n  exit\nend\n/* Read a member */\n\"SET LINEND OFF\"     /* set control chars off in case in member name */\n\"SET ESCAPE OFF\"\n\"SET ARB OFF\"\n\"CMS LIBRCMS \"ftype.1 member_name member_type\nlibr_rc = rc\n\"SET LINEND ON\"     /* set control chars back on again */\n\"SET ESCAPE ON\"\n\"SET ARB ON\"\nif libr_rc \u00ac= 0 then do\n  \"EMSG Error code \"rc\" from LIBR MODULE.\"\n  exit\nend\n\n/* Queue and XEDIT it */\n\"DESBUF\"\nqueue \"XEDIT $$LIBR$$ $$LIBR$$ A (PROF LIBREXX\"\nqueue \"FN \"member_name\nqueue \"FT \"member_type\nqueue \"PREFIX OFF\"\nqueue \"SCALE ON 2\"\ndo i = 1 to libr.0\n  queue \"INPUT \"libr.i\nend\nexit\n\n\nLIBREXX XEDIT\n\n/* Profile for XEDIT files created by LIBREXX EXEC and LIBXEDIT XEDIT.*/\n\n/* You may change these colours to suit yourself */\n\"SET COLOR FILEAREA BLUE\"\n\"SET COLOR PREFIX BLUE REVV\"\n\"SET CTLCHAR 1 PROTECT GREEN REVV HIGH\"\n\n/* Please leave the following commands alone */\n\"SET CTLCHAR % ESCAPE\"\n\"CASE M I\"\n\"SCALE OFF\"\n\"CURL ON 3\"\n\"NUM ON\"\n\"VER 1 79\"\n\"SET MSGLINE ON 23 OVERLAY\"\n\"SET PREFIX SYNONYM LX LIBXEDIT\"\nqueue \"TOP\"\n/* Make sure control characters aren't processed on INPUT */\n\"SET IMAG OFF\"\n\"SET LINEND OFF\"\n\"SET ESCAPE OFF\"\n\"SET ARB OFF\"\n/* Set them back after all data has been input. */\nqueue \"SET LINEND ON\"\nqueue \"SET ESCAPE ON\"\nqueue \"SET ARB ON\"\nqueue \"SET IMAG ON\"\nexit\n\nJeremy Carter\nSystems Administrator\nMGM Assurance (UK)                              c MGM Assurance 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E002A05": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01a\\x01a\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 353, "newlines": 353, "modlines": 0, "user": "VSEUPDT"}, "text": "Stacking the VSE console\n\nIn a VM/VSE environment a few VM/VSE interface routines exist:\n\no      VSECMD passes a VSE command from CMS to the VSE\n      virtual machine\n\no      VSEMSG displays the VSE console\n\no      VSEREP passes a reply to a partition in which a program\n      waits for it.\n\nThese programs are supplied by IBM, but for EXEC\nprogramming there is no way to read the VSE console and use\nthis information in a program.  So, we made the VSESTACK\nmodule, based on VSEMSG, which, as the name indicates,\nstacks the output from the VSEMSG command, FIFO.  The\nstacked lines can be read and used.\n\n         MACRO\n&LBL     STACK &LINE,&LENGTH,&ORDER\n         LCLC  &ORD\n         AIF   ('&LINE'(1,1) EQ '(').R1FORM\n&LBL     CNOP  0,8\n         AGO   .TWO\n.R1FORM  ANOP\n&LBL     CNOP  4,8\n         STCM  &LINE(1),7,*+25\n.TWO     AIF   ('&LENGTH'(1,1) EQ '(').R2FORM\n         MVI   *+20,&LENGTH\n         AGO   .THREE\n.R2FORM  ANOP\n         STC   &LENGTH(1),*+20\n.THREE   BAL   R1,*+20\n         DC    CL8'ATTN'\n&ORD     SETC  '&ORDER'.'FIFO'\n&ORD     SETC  '&ORD'(1,4)\n         DC    CL4'&ORD'\n         DC    AL1(0)\n         AIF   ('&LINE'(1,1) EQ '(').ZERO\n         DC    AL3(&LINE)\n         AGO   .SVC\n.ZERO    DC    AL3(0)\n.SVC     SVC   202\n         DC    AL4(1)\n         MEND\n         MACRO\n&LBL     CLS\n&LBL     CNOP  0,8\n         STM   R1,R2,*+52              * SAVE REGISTERS 1 AND 2\n         BAL   R1,*+12\n         DC    CL8'CONWAIT'            * FINIS PENDING CONSOLE MSGS\n         SVC   202                     * HANDLE BY CMS\n         DC    AL4(1)\n         LA    R2,009                  * CONSOLE ADDRESS\n         BCR   0,0                     * NOP FOR ALIGNMENT\n         BAL   R1,*+12\n         DC    X'1900000020FF0001'     * CLEAR SCREEN CCW\n         DIAG  R1,R2,X'0058'           * BY CP VIA DIAG 58\n         LM    R1,R2,*+8               * RESTORE REGISTERS 1 AND 2\n         B     *+12                    * CONTINUE AFTER SAVE PLACE\n         DS    2F                      * SAVE PLACE FOR REGS 1 AND 2\n         MEND\nVSESTACK CSECT\n         REGEQU\n         STM   R14,R12,0(R13)\n         BALR  R12,0\n         USING *,R12\n         B     START\n         DC    C'NAME: STACK VSE CONSOLE, ASSEMBLED: '\n         DC    C'&SYSDATE '\n         DC    C'&SYSTIME'\n         DC    C', AUTHOR: R.T. HEEMSKERK'\nSTART    CLI   8(R1),X'FF'             * NO PARMS SUPPLIED ?\n         BE    HELPINFO                * DISPLAY HELP INFORMATION\n         CLI   8(R1),C'?'              * PARM '?'\n         BE    HELPINFO\n         CLC   8(4,R1),=C'HELP'        * PARM 'HELP' ?\n         BE    HELPINFO\n         LR    R6,R1                   * R6 IS PARAMETER POINTER\n         MVC   AUTHPARM+8(8),8(R6)     * MOVE USERID INTO SPECIFIC\n         MVC   AU2PARM+8(8),8(R6)\n         MVI   AU2PARM+36,X'30'\n         STCK  CLOCK                   * GET TOD CLOCK\n         MVC   AU2PARM+4(4),CLOCK+3    * FOR SPECIAL IDENTIFICATION\n         HNDEXT SET,EXTFLIH            * HANDLE EXTERNAL INTERR.\n         LA    R2,AUTHPARM\n         SR    R3,R3\n         DIAG  R2,R3,X'0068'\n         LTR   R3,R3\n         BNZ   ERROR\nAGAIN    LA    R2,AU2PARM\n         SR    R3,R3\n         STCTL R0,R0,CNTRL0\n         OI    CNTRL0+3,1\n         LCTL  R0,R0,CNTRL0\n         DIAG  R2,R3,X'0068'\n         LTR   R3,R3\n         BNZ   ERROR2\n         LPSW  PSWAIT\nEXTFLIH  EQU   *\n         USING *,R15\n         MVC   PSWOLD+2(2),26(R0)\n         MVC   96(4,R1),PSWOLD\n         BR    R14\n         DROP  R15\nPSWOLD   DC    X'00040000'\nPSWAIT   DS    0D\n         DC    X'01060000'\n         DC    A(CONTINUE)\nCONTINUE CLC   PSWOLD+2(2),=X'4001'\n         BNE   WRONGEXT\n         TM    BUFFER,X'40'\n         BNO   SUCCES\n         SR    R11,R11\n         IC    R11,BUFFER+35\n         EX    R0,*(R11)\n         B     ERRBUSY\n         B     ERRLOGIC\n         B     ERRLOGIC\n         B     ERRLOGIC\n         B     ERRLOGIC\n         B     ERRLOGIC\n         B     ERRLOGIC\n         B     ERRINCPT\nERRBUSY  LINEDIT TEXT='DMSVSE004I TASK BUSY, PLEASE RESUBMIT'\n         LA    R3,4\n         B     UNAUTH\nERRINCPT LINEDIT TEXT='DMSVSE056E INCOMPATIBLE VERSIONS OF VMCF'\n         LA    R3,56\n         B     UNAUTH\nWRONGEXT LINEDIT TEXT='DMSVSE060I PROCESSING SUSPENDED BY USER'\n         LH    R3,PSWOLD+2\n         B     UNAUTH\nERRLOGIC LINEDIT TEXT='DMSVSE020E PROGRAM LOGIC ERROR ..',             +\n               SUB=(DEC,(R11))\n         LA    R3,20\n         B     UNAUTH\nSUCCES   CLI   16(R6),X'FF'            * ONLY USERID SUPPLIED\n         BE    ALL\n         CLC   16(5,R6),=C'LAST '      *\n         BE    DOLAST\n         LA    R8,DATA                 * PARTITION SUPPLIED\n         L     R9,=A(DATAEND)          * ELSE PARTITION SUPPLIED\nLOOP2    CLC   383(2,R8),16(R6)\n         BE    PARTFND\n         CLC   17(2,R8),16(R6)\n         BE    PARTFND\n         CLC   200(2,R8),16(R6)\n         BE    PARTFND\n         LA    R8,732(R8)\n         CLR   R8,R9\n         BL    LOOP2\n         WRTERM INVLINE,INVLENGT\n         LA    R3,20\n         B     UNAUTH\nDOLAST   LA    R10,ANSWER\n         SL    R10,ANSWER+4\n         L     R6,ANSWER\n         LA    R6,0(R6)\n         ALR   R6,R10\n         LR    R3,R6\nNEXTENTR TM    0(R6),X'C0'\n         BZ    NOENTRY\n         LA    R4,118\n         TM    0(R6),X'80'\n         BO    LONG\n         LA    R4,48\nLONG     LA    R4,4(R6)\n         STACK (R5),(R4)\nNOENTRY  L     R6,0(R6)\n         LA    R6,0(R6)\n         ALR   R6,R10\n         CLR   R6,R3\n         BNE   NEXTENTR\n         SR    R3,R3\n         B     UNAUTH\nPARTFND  LR    R6,R8\n         BAL   R11,DISPLAY\n         SR    R3,R3\n         B     UNAUTH\nALL      LA    R10,17\n         LA    R6,DATA\nLOOP     BAL   R11,DISPLAY\n         LA    R6,732(R6)\n         BCT   R10,LOOP\n         SR    R3,R3\nUNAUTH   LA    R4,UNAUPARM\n         XR    R5,R5\n         DIAG  R4,R5,X'0068'\n         STCTL R0,R0,CNTRL0\n         NI    CNTRL0+3,254\n         LCTL  R0,R0,CNTRL0\n         HNDEXT CLR\nTHEEND   LR    R15,R3\n         L     R14,0(R13)\n         LM    R0,R12,8(R13)\n         BR    R14\nDISPLAY  TM    366(R6),X'40'\n         BOR   R11\n         ST    R6,REG6\n         MVC   OWNER(8),=C'**NONE**'\n         MVC   OWNER+9(11),SPACES\n         CLC   374(8,R6),SPACES\n         BE    DISPLINE\n         MVC   OWNER(8),374(R6)\n         MVC   OWNER+9(11),=C'ECHO='\n         TM    366(R6),X'10'\n         BO    DISPLINE\n         MVC   ECHOTYPE(5),=C'REPLY'\n         TM    366(R6),X'08'\n         BO    DISPLINE\n         MVC   ECHOTYPE(5),=CL5'YES'\n         TM    366(R6),X'20'\n         BO    DISPLINE\n         MVC   ECHOTYPE(5),=CL5'NO'\nDISPLINE STACK OWNLINE,OWNLENGT\n         LA    R9,3\n         LR    R5,R6\nLOOP3    BAL   R6,DISPCONS\n         LA    R5,183(R5)\n         BCT   R9,LOOP3\n         L     R6,REG6\n         CLI   385(R6),C'-'\n         BE    DISPWAIT\n         CLI   385(R6),C'+'\n         BNE   RETURN\nDISPWAIT STACK WAITLINE,WAITLENG\nRETURN   BR    R11\nDISPCONS TM    0(R5),X'40'\n         BOR   R6\n         LA    R4,134(R5)\n         LA    R7,111\nREADSPAC CLI   O(R4),C' '\n         BNE   NOSPACE\n         BCTR  R4,R0\n         BCT   R7,READSPAC\nNOSPACE  LA    R4,1(R7)\n         SR    R8,R8\n         LA    R7,BUFFER+7\n         LA    R3,24(R5)\n         MVC   BUFFER(7),17(R5)\nMORE     CLI   0(R3),X'15'\n         BNE   NOEOL\n         LA    R3,1(R3)\n         B     EOL\nNOEOL    MVC   0(1,R7),0(R3)\n         LA    R7,1(R7)\n         LA    R8,1(R8)\n         LA    R3,1(R3)\n         CH    R8,=H'111'\n         BE    EOL\n         BCT   R4,MORE\nEOL      LA    R8,7(R8)\n         STACK BUFFER,(R8)\n         MVC   BUFFER(80),SPACES\n         SR    R8,R8\n         LA    R7,BUFFER+7\n         BCTR  R4,R0\n         LTR   R4,R4\n         BH    MORE\n         BR    R6\nHELPINFO CLS\n         WRTERM HELP,HELPLENG,EDIT=LONG\n         SR    R3,R3\n         B     THEEND\nHELP     DC    C'VSESTACK HELPINFO'\n         DC    X'15'\n         DC    C'-----------------'\n         DC    X'1515'\n         DC    C'This module will stack requested console information '\n         DC    C'from a VSE machine.'\n         DC    X'1515'\n         DC    C'Format of the call:'\n         DC    X'1515'\n         DC    C'    VSESTACK vseid \u00ddLAST|BG|Fn\u00a8'\n         DC    X'1515'\n         DC    C'Where:',X'15'\n         DC    C'vseid is the id of the VSE machine,',X'15'\n         DC    C'LAST  will stack the last 20 console messages,',X'15'\n         DC    C'BG    the last 3 messages for the BG-partition,',X'15'\n         DC    C'Fn    the last 3 messages for the Fn-partition.',X'15'\n         DC    X'15'\n         DC    C'Omitting the optional operands will result in '\n         DC    C'stacking the last 3 messages',X'15'\n         DC    C'for BG, Fn, and AR.',X'15'\n         DC    C'One line info about the partition owner and '\n         DC    C'ECHO-information will preceed',X'15'\n         DC    C'partition messages (operand BG, Fn or no operands).'\n         DC    X'1515'\nHELPLENG EQU   *-HELP\nERROR    LINEDIT TEXT='VSE VMCF ERROR .... WHILE AUTHORIZING THIS USERI+\n               D',SUB=(DEC,(R3))\n         LA    R3,24\n         B     UNAUTH\nERROR2   CH    R3,=H'5'\n         BNE   CHCK8\n         LINEDIT TEXT='VSE MACHINE NOT AVAILABLE FOR VMCF'\n         LA    R3,44\n         B     UNAUTH\nCHCK8    CH    R3,=H'8'\n         BNE   CHCK10\n         STCK  CLOCK\n         MVC   4(4,R7),CLOCK+3\n         B     AGAIN\nCHCK10   CH    R3,=H'10'\n         BNZ   VCMFERR\n         LINEDIT TEXT='DMSVSE048E VMCF MESSAGE LIMIT EXCEEDED, RETRY'\n         LA    R3,48\n         B     UNAUTH\nVMCFERR  LINEDIT TEXT='DMSVSE052E VMCF ERROR ....',                    +\n               SUB=(DEC,(R3))\n         LA    R3,52\n         B     UNAUTH\nCLOCK    DS    D\nBUFFER   DC    80C' '\nCNTRL0   DS    F\nREG6     DS    F\nOWNLINE  DC    C'PARTITION OWNERID: '\nOWNER    DC    9C' ',5C' '\nECHOTYPE DC    5C' '\nOWNLENGT EQU   *-OWNLINE\nWAITLINE DC    C'PARTITION WAITING REPLY'\nWAITLENG EQU   *-WAITLINE\nINVLINE  DC    C'PARTITION IS INVALID OR NO MESSAGES ARE BUFFERED'\nINVLENGT EQU   *-INVLINE\nSPACES   DC    CL80' '\n         DS    0D\nAUTHPARM DC    X'80000000'\n         DC    4X'00',8C' '\n         DC    A(BUFFER)\n         DC    X'00000028'\n         DC    16X'00'\nUNAUPARM DC    X'00000001'\n         DC    4X'00',8C' '\n         DC    24X'00'\nAU2PARM  DC    X'00000003'\n         DC    4X'00',8C' '\n         DC    A(AU2PARM)\n         DC    X'00000028'\n         DC    A(ANSWER)\n         DC    X'0000'\n         DC    H'12800',C'MSG     '\n         LTORG\nANSWER   DC    A(0)\n         DC    A(ANSWER)\nDATA     DC    100CL128' '\nDATAEND  EQU   *\n         END\n\nR T Heemskerk\nSystems Programmer (The Netherlands)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A06": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01\\xe1\\x01\\xe1\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 481, "newlines": 481, "modlines": 0, "user": "VSEUPDT"}, "text": "VSE batch operator\n\nThe following program was developed to allow VSE operator\ncommands to be issued from a batch jobstream.  Our\nenvironment is VSE/SP 3.2 with CICS 1.7 running under\nVM/SP HPO 5. The VSEMCDS program takes advantage of\nSVC 30 which was introduced with VSE/SP 3.x.x.  An article\nin CICS Update provided some information on enabling SVC\n30 in a VSE/SP 2.1.x environment.\n\nVSECMDS allows most VSE console commands to be issued\nfrom a batch job.  In addition, two pseudo commands have also\nbeen implemented to provide some control over when and\nwhere commands are issued.  Although SVC 30 allows\ncommands to be issued there are no provisions for obtaining\nthe response that may have resulted from the command.  For\ninstance, if you were to issue a PRTY command via SVC 30\nyou have no way of determining or retrieving the output from\nthe command for further analysis.  This tends to restrict the\nusefulness of being able to issue commands via SVC 30 but\nthere are still some functions which can be successfully\nhandled.  In addition, SVC 30 does issue a return code to\nindicate whether the command was successfully processed or\nrejected.  If this return code is greater than 4 the remaining\nVSECMDS statements will be flushed and the VSE return code\nwill be set to the value returned by SVC 30.  An SVC 30 return\ncode of 4 means the command processor was busy.\nVSECMDS  will try to re-issue the command for several\nminutes and if unsuccessful will flush the remaining\nVSECMDS statements and set the VSE return code to a non-\nzero value.\n\nThe two psuedo commands implemented are a CPU command\nand a WAIT command.  The CPU command is used to make\nsure the commands are issued on the right CPU.  In a multi-\nCPU environment this can be very important.  The format for\nthe command is:\n\n      CPU nnnnnn\n\nWhere nnnnnn is the 6 digit CPU-id of the CPU you wish to\nrun on.  The command must begin in column 1, be followed by\nexactly 1 space, and then the 6 digit CPU-id.  If the specified\nCPU-id does not match that of the CPU running the batch job,\nthe remaining VSECMDS control statements are flushed and\nthe VSE return code is set to a non-zero value.\n\nThe 'WAIT' command has two formats.  The first format is\nused to wait for a specified number of seconds.\n\n      WAIT nnn\n\nWhere nnn is a 1-3 digit number specifying the number of\nseconds to wait.  After the specified time expires the next\nVSECMDS control statement will be processed.\n\nThe second format is used to wait until a specified partition\nbecomes free.\n\n      WAIT partid\n\nwhere partid is a 2 character partition id, eg F1, BG, etc.\nWhen the specified partition becomes free, ie it has a jobname\nof 'NO NAME', the next VSECMDS control statement is\nprocessed.  If the specified partition does not free up after\nseveral minutes the remaining VSECMDS statements are\nflushed and the VSE return code is set to a non-zero value.\n\nIn addition to the two pseudo commands there is a slight\nmodification to the normal syntax of commands which are\npreceded by a repl-id.  Normally if you were to issue a\ncommand at the console such as 'MSG F2' you would be\nprompted with the repl-id which you should use for your\nresponse.  This repl-id cannot always be predicted ahead of\ntime and may vary depending on the tasks running in the\npartition.  To handle this situation and allow VSECMDS to\nissue the MSG command and properly handle responses to it,\nthe repl-id is not actually coded on the VSECMDS statement.\nInstead the two character partition id is substituted for it and\nthe actual repl-id will be determined from the VSE Operator\nReply Element table for the specified partition.  If a repl-id\ncannot be determined after several minutes, the remaining\nVSECMDS statements are flushed and the VSE return code is\nset to a non-zero value.  Also if you attempt to issue a MSG to\nan inactive partition the remaining VSECMDS statements are\nflushed and the VSE return code is set to a non-zero value.\nThe following examples may help illustrate the various\ncommands and formats.\n\n\nEXAMPLE 1\n\n// EXEC VSECMDS\nMSG F2\nF2 CEMT I TAS          notice that F2 is substituted for the repl-id\nF2                     EOB to clear the outstanding reply\n/*\n\n\nEXAMPLE 2\n\n// EXEC VSECMDS\nCPU 123456             make sure we are running on the right CPU\nMSG F2                 MSG to CICS\nF2 CSMT SHUT,Y         shut it down immediately\nWAIT F2                wait for the partition to become free\nZ NET,QUICK            terminate VTAM\nWAIT F3                wait for the partition to become free\nPEND                   shut down POWER\n/*\n\n\nEXAMPLE 3\n\n// EXEC VSECMDS\n/LLOG STOP            stop CA-LOOK logging\nWAIT 60               wait 60 seconds for command to complete\n/SERV Q SHUT          shutdown CA-LOOK\nWAIT 60               wait 60 seconds for command to complete\nMSG F2                msg to CICS\nF2 CJSI STOP,OFF      stop JARS\nF2                    EOB\nMSG F6                msg to CICS\nF6 CJSI STOP,OFF      stop JARS\nF6                    EOB\n/*\n\nAs mentioned earlier, if you were to try and issue a MSG to an\ninactive partition VSECMDS would flush the remaining\nstatements, possibly discarding statements which you would\nlike to go ahead and issue.  It is useful sometimes to not issue\nall commands via the same execution of VSECMDS. See\nExamples 4 and 5.\n\n\nEXAMPLE 4\n\n// EXEC VSECMDS\nMSG F2\nF2 CJSI STOP,OFF\nF2\nMSG F6\nF6 CJSI STOP,OFF\nF6\n/*\n\nThis would fail to issue the commands in F6 if F2 was not\nactive. Instead you might do the following so that the F6\ncommands are issued regardless of whether F2 is active or not.\n\n\nEXAMPLE 5\n\n// EXEC VSECMDS\nMSG F2\nF2 CJSI STOP,OFF\nF2\n// EXEC VSECMDS\nMSG F6\nF6 CJSI STOP,OFF\nF6\n/*\n\n\nVSECMDS\n\n*                           V S E C M D S                             *\n*  A PROGRAM WHICH ALLOWS BATCH JOBSTREAMS TO ISSUE VSE CONSOLE CMDS  *\n         PRINT NOGEN\nCOMREG   MAPCOMR\nSYSCOM   SYSCOM\nASDSECT  DSECT\nASCCB    DS    2D\nASUSCCB  DS    F\nASUCCW   DS    F\nASCUT    DS    F\nASOCTID  DS    H\nASREPLY  DS    CL3\nASCCHQP  DS    X\nASFLAG   DS    X\nASRSTAT  EQU   X'40'\nASPT     DS    CL3\n         DS    CL2\nASDLEN   EQU   *-ASDSECT\nVSECMDS  CSECT\n         BALR  R12,0\n         USING *,R12\n         B     BEGIN\n         DC    CL16'VSECMDS 02/20/89'\nBEGIN    EQU   *\n         LA    R9,0                         RETURN CODE\n         MVC   MESSAGE(L'MSGVSE),MSGVSE\n         EXCP  CONSOLE\n         WAIT  CONSOLE\n         OPEN  IJSYSIN                      OPEN SYSIPT\nREAD     EQU   *\n*  READ NEXT RECORD FROM SYSIPT                                       *\n         GET   IJSYSIN                     GET A COMMAND\n         MVC   MESSAGE(50),IO              ECHO TO SYSLST\n         EXCP  SYSLST\n         WAIT  SYSLST\nCHKCMD   EQU   *\n         LA    R3,IO                       POINT TO IT\n         MVI   REPLY,C'N'                  RESET REPLY SWT\n         LA    R4,3(,R3)                   POINT PAST KEYWORD\n         CLC   0(4,R3),=C'MSG '            IS IT MSG PARTID?\n         BE    LOOKPP\n         CLC   0(4,R3),=C'CPU '            IS IT CPUID?\n         BE    CPUID\n         CLC   0(5,R3),=C'WAIT '           IS IT A WAIT\n         BNE   PROCESS                     NO, MUST BE A REAL COMMAND\n*  WAIT AND MSG STMTS ARE PROCESSED HERE                              *\n*  WAIT FORMAT IS 'WAIT NNN' OR 'WAIT PARTID', WHERE NNN IS A TIME    *\n*  INTERVAL AND PARTID IS PARTITION ID.                               *\n         EXCP  CONSOLE                     ECHO WAIT TO CONSOLE\n         WAIT  CONSOLE\n         LA    R4,4(,R3)                   POINT PAST KEYWORD\nLOOKPP   EQU   *\n         MVC   TIME,=C'000000'             INIT WORK AREA\n         LA    R10,20                      MAX SPACES TO SCAN\nSCANT    EQU   *                           SCAN PAST SPACES\n         LA    R4,1(,R4)                   LOOK AT NEXT CHAR\n         CLI   0(R4),C' '                  IS IT A SPACE\n         BNE   GETSECS                     NO, FINISHED WITH SCAN\n         BCT   R10,SCANT                   GO SCAN SOME MORE\n         B     NOTNUM\nGETSECS  EQU   *\n         LA    R10,3                       MAX DIGITS\n         LA    R8,TIME+2                   WORK AREA\nSCANG    EQU   *                           SCAN NUMERIC WAIT INTERVAL\n         CLI   0(R4),C'0'                  IS IT NUMERIC?\n         BL    CHKPRTN                     NO\n         CLI   0(R4),C'9'                  IS IT NUMERIC\n         BH    CHKPRTN                     NO\n         MVC   0(1,R8),0(R4)               MOVE A DIGIT\n         LA    R4,1(,R4)                   LOOK AT NEXT CHAR\n         CLI   0(R4),C' '                  IS IT A SPACE\n         BE    CNVRT                       YES, FINISIHED\n         LA    R8,1(,R8)                   NO, BUMP TARGET BY 1\n         BCT   R10,SCANG                   BACK FOR MORE\n         LA    R10,1(,R10)                 ADJUST FOR 3 DIGIT INTERVAL\nCNVRT    EQU   *\n         LA    R4,TIME+3                  POINT TO WORK AREA\n         SR    R4,R10                     ADJUST START OF NUMERIC FIELD\n         PACK  DWORD,0(3,R4)              CONVERT INTERVAL\n         CVB   R15,DWORD                  PUT IT INTO R15\n         SETIME (R15),TECBLK              AND WAIT\n         WAIT  TECBLK\n         B     READ                       GET NEXT COMMAND\n* COME HERE TO DETERMINE PARTID ON WAIT AND MSG STMTS                 *\n* THERE IS AN ASSUMPTION HERE THAT 12 PARTITIONS ARE GENNED           *\nCHKPRTN  EQU   *\n         LA    R5,12                        NUMBER OF PARTITIONS\n         SR    R6,R6                        CLEAR R6-DISPL INTO PIB2TAB\n         LA    R7,PTAB                      ADDR OF PARTID TABLE\nLOOPP    EQU   *\n         LA    R6,16(,R6)                   DISPL INTO PIB2TAB\n         CLC   0(3,R4),0(R7)                IS IT THE RIGHT PARTID?\n         BE    PARTN                        YES,R6 HAS DISPL NOW\n         LA    R7,3(,R7)                    NEXT PARTID\n         BCT   R5,LOOPP                     BACK AGAIN\n         B     NOTPID                       SOMETHING WRONG\nPARTN    EQU   *\n         L     R5,X'14'                     GET ACTIVE PARTITION\n         USING COMREG,R5\n         LH    R5,BGCOMPT                   GET BG COMREG\n         LH    R2,PIB2PTR                   GET PIB2TAB\n         LA    R2,0(R6,R2)                  GET PARTN COMREG\n         LH    R5,0(R2)\n         LA    R10,10                       LOOP COUNT\nPLOOP    EQU   *\n         CLC   0(5,R3),=C'WAIT '            IS IT A WAIT STMT\n         BE    PWAIT                        YES, PROCESS IT\n         CLC   0(4,R3),=C'MSG '             IS IT A MSG STMT\n         BNE   PROCESS\n         LA    R9,12                        SET RETURN CODE\n         CLC   COMNAME(8),=CL8'NO NAME '    MSG FOR INACTIVE PARTITION?\n         BE    QUITERR\n         MVC   PTN+5(2),0(R4)               PUT PARTID IN RESOURCE ID\n* WE CREATE A LOCK FOR THE PARTITION WE WILL BE DOING A 'MSG' TO.     *\n* WE DO NOT WANT MULTIPLE COPIES OF 'VSECMDS' TRYING TO COMMUNICATE   *\n* WITH THE SAME PARTITION AT THE SAME TIME. HOWEVER, LOCKING THE      *\n* RESOURCE AND WAITING CREATES THE POSSIBILITY OF A 'DEADLY EMBRACE'  *\n* IF WE HAVE MULTIPLE 'VSECMDS' RUNNING AND TRYING TO DO MSG'S TO     *\n* MULTIPLE PARTITIONS.                                                *\n         LOCK  PTN,FAIL=WAIT\n         LA    R9,0                         SET RETURN CODE\n         B     PROCESS\n*  COME HERE TO WAIT FOR A SPECIFIC PARTITION TO BECOME FREE          *\nPWAIT    EQU   *\n         CLC   COMNAME(8),=CL8'NO NAME '    IS IT FREE?\n         BE    READ\n         SETIME 30,TECBLK                   WAIT AROUND\n         WAIT  TECBLK\n         BCT   R10,PWAIT                    GO BACK AND CHK AGAIN\n         MVC   MESSAGE(L'MSGPTN),MSGPTN     PARTITION NEVER FREED UP\n         LA    R9,12                        SET RETURN CODE\n         B     QUITERR\n*  COME HERE TO PROCESS COMMANDS OTHER THAN WAIT AND CPU              *\nPROCESS  EQU   *\n         ST    R3,CMDADDR                 SAVE ADDRESS OF COMMAND\n         LA    R10,79                     LENGTH OF SCAN\nSCANS    EQU   *\n         LA    R4,0(R10,R3)               POINT R4 TO NEXT CHAR\n         CLI   0(R4),C' '                 IS IT A SPACE\n         BNE   SAVELEN                    NO, FINISHED WITH SCAN\n         BCT   R10,SCANS                  GO SCAN SOME MORE\n         MVC   MESSAGE(L'MSGERR),MSGERR\n         LA    R9,12                      SET RETURN CODE\n         B     QUITERR\nSAVELEN  EQU   *\n         LA    R10,1(,R10)                ADJUST LENGTH UP BY 1\n         STH   R10,CMDLEN                 SAVE IT FOR SVC30\n         CLC   0(3,R3),=C'F2 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F3 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F4 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F5 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F6 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F7 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F8 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'F9 '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'FA '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'FB '            CHK FOR REPLID\n         BE    REPLYID\n         CLC   0(3,R3),=C'BG '            CHK FOR REPLID\n         BE    REPLYID\n         B     CMD\n* COME HERE TO DETERMINE WHAT A SPECIFIC PARTITIONS REPLID IS         *\nREPLYID  EQU   *\n         LA    R7,24                      NUMBER OF 5 SEC WAITS\nLOOPM    EQU   *\n         ASYSCOM R5\n         USING SYSCOM,R5\n         ICM   R5,7,IJBASYAD                ASYNCH OP CMD TAB\n         DROP  R5\n         L     R5,0(R5)                     POINT TO ORE\n         USING ASDSECT,R5\n         LA    R6,16                        LOOP COUNTER\nLOOPM01  EQU   *\n         TM    ASFLAG,ASRSTAT               CHK FOR REPLID\n         BZ    LOOPM02\n         CLC   0(2,R3),ASPT                 IS IT THE ONE WE WANT\n         BE    FIXRID                       YES, GO INSERT REPLID\nLOOPM02  EQU   *\n         LA    R5,ASDLEN(R5)                NEXT ONE\n         BCT   R6,LOOPM01                   LOOP BACK\n         SETIME 05,TECBLK                   WAIT AWHILE\n         WAIT  TECBLK\n         BCT   R7,LOOPM                     GO SCAN AGAIN\n         MVC   MESSAGE(L'MSGFAIL),MSGFAIL   DID NOT FIND REPLID\n         EXCP  CONSOLE\n         WAIT  CONSOLE\n         EXCP  SYSLST\n         WAIT  SYSLST\n         MVC   MESSAGE(L'MSGBYP),MSGBYP\n         MVC   MESSAGE+18(30),IO\n         LA    R9,12                       SET RETURN CODE\n         B     QUITERR\nFIXRID   EQU   *\n         MVC   0(2,R3),ASREPLY+1            ONLY USE LAST 2 OF REPLYID\n         MVI   REPLY,C'Y'                   INDICATE WE WANT TO REPLY\nCMD      EQU   *\n         LA    R10,5                        RETRY COUNT FOR BUSY\n*  COME HERE TO ISSUE SVC 30 TO PERFORM THE COMMAND                   *\nSVC30    EQU   *\n         LA    R1,CMDLEN                    SETUP PARMLIST FOR SVC30\n         SLR   0,0\n         SVC   30\n         LTR   R15,R15                      ERRORS?\n         BZ    OK\n         LR    R9,R15                       PUT INTO RETURN CODE\n         C     R15,=F'4'                    BUSY, RETRY COMMAND\n         BE    BUSY\n         C     R15,=F'8'                    COMMAND TOO LONG\n         BE    TRUNC\n         MVC   MESSAGE(L'MSGERR),MSGERR\n         B     QUITERR\n*  COME HERE TO PROCESS CPU STMT                                      *\n*  WE WANT TO MAKE SURE WE ARE RUNNING ON THE RIGHT CPU               *\nCPUID    EQU   *\n         LA    R10,10\n         EXTRACT ID=CPUID,AREA=CPUSTOR,LEN=(10)\n         MVC   DWORD(3),CPUSTOR+1\n         UNPK  CPUSTOR(8),DWORD(4)\n         CLC   4(6,R3),CPUSTOR+1            IS IT THE RIGHT CPU?\n         BE    READ\n         MVC   MESSAGE(L'MSGCPU),MSGCPU\n         LA    R9,12                        SET RETURN CODE\n         B     QUITERR\n*  COMMAND PROCESSOR WAS BUSY, WE WILL WAIT AND RETRY                 *\nBUSY     EQU   *\n         SETIME 02,TECBLK                   WAIT 2 SECONDS\n         WAIT  TECBLK\n         BCT   R10,SVC30                    TRY IT AGAIN\n         MVC   MESSAGE(L'MSGBUSY),MSGBUSY\n         B     QUITERR                      GIVE UP\nNOTNUM   EQU   *\n         MVC   MESSAGE(L'MSGWAIT),MSGWAIT\n         LA    R9,12                        SET RETURN CODE\n         B     QUITERR\nNOTPID   EQU   *\n         MVC   MESSAGE(L'MSGPID),MSGPID\n         LA    R9,12                        SET RETURN CODE\n         B     QUITERR\nTRUNC    EQU   *\n         MVC   MESSAGE(L'MSGTRN),MSGTRN\n         B     QUITERR\n* COMMAND PROCESSED OK. MAY NEED TO WAIT IF PROCESSING REPLIDS        *\nOK       EQU   *\n         CLI   REPLY,C'Y'                   PROCESSING REPLYS\n         BNE   READ\n         SETIME 05,TECBLK                   GIVE MORE TIME TO UPDATE\n         WAIT  TECBLK\n         B     READ                         YES, GO BACK FOR MORE\n* WRITE ERROR MESSAGES TO CONSOLE AND SYSLST                          *\nQUITERR  EQU   *\n         EXCP  CONSOLE                      ERR MSG TO CONSOLE\n         WAIT  CONSOLE\n         EXCP  SYSLST                       ERR MSG TO SYSLST ALSO\n         WAIT  SYSLST\n*  FLUSH REST OF CONTROL CARDS IF ERRORS ENCOUNTERED                  *\nREADE    EQU   *                            BYPASS REST OF COMMANDS\n         GET   IJSYSIN\n         MVC   MESSAGE(L'MSGBYP),MSGBYP\n         MVC   MESSAGE+18(30),IO\n         EXCP  CONSOLE\n         WAIT  CONSOLE\n         EXCP  SYSLST\n         WAIT  SYSLST\n         B     READE\nEOJ      EQU   *\n         CLOSE IJSYSIN\n*  END WITH A RETURN CODE AND UNLOCK ANY RESOURCES                    *\nEOJRC    EQU   *\n         UNLOCK ALL\n         EOJ   RC=(R9)\n         CNOP  2,4\nCMDLEN   DC    H'0'\nCMDADDR  DC    A(0)\nCONSOLE  CCB   SYSLOG,WRITECCW\nSYSLST   CCB   SYSLST,LSTCCW\nWRITECCW CCW   1,MESSAGE,0,L'MESSAGE\nLSTCCW   CCW   9,MESSAGE,0,L'MESSAGE\nTECBLK   TECB\nREPLY    DC    C'N'\nDWORD    DC    D'0'\nCPUSTOR  DC    CL10' '\nTIME     DC    C'000000'\nMESSAGE  DC    CL50' '\nPTAB     DC    C'BG FB FA F9 F8 F7 F6 F5 F4 F3 F2 F1 '\nMSGPID   DC    C'VSE002:  INVALID PARTITION ID              '\nMSGVSE   DC    C'VSE003:  BATCH VSE AR COMMAND PROCESSOR    '\nMSGERR   DC    C'VSE004:  INVALID COMMAND                   '\nMSGTRN   DC    C'VSE005:  COMMAND TRUNCATED                 '\nMSGWAIT  DC    C'VSE006:  INVALID INTERVAL ON WAIT STATEMENT'\nMSGBYP   DC    C'VSE007:  BYPASSED-                         '\nMSGBUSY  DC    C'VSE008:  COMMAND PROCESSOR BUSY            '\nMSGFAIL  DC    C'VSE009:  FAILED TO FIND ACTIVE REPLY ID    '\nMSGPTN   DC    C'VSE010:  PARTITION NOT AVAILABLE           '\nMSGCPU   DC    C'VSE011:  CPU-ID DID NOT MATCH              '\nIO       DC    CL80' '\nIJSYSIN  DTFDI DEVADDR=SYSIPT,IOAREA1=IO,EOFADDR=EOJ,RECSIZE=80\n         PRINT GEN\n* PARTITION RESOURCE ID TO ENQUEUE ON, PP WILL BE REPLACED WITH PARTID*\nPTN      DTL   NAME=$PPVSECMD\n         EQUREGS\n         END\n\nStanley A Stewart\nTechnical Services Manager\nSt John Medical Center (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A07": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x91\\x00\\x91\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 145, "newlines": 145, "modlines": 0, "user": "VSEUPDT"}, "text": "Using a virtual CTCA\n\nWe are a VSE/SP 3.2 shop running two guest machines under\nVM/SP.  All of our production CICS terminals are dedicated,\nwhile all test terminals are defined as special under VM/SP.\nWe needed some way to run test demos on production\nterminals or to run production on test terminals.  We could\nhave used the CP DIAL command, but I didn't like giving that\nto the users.\n\nWe decided instead to take advantage of the CTCA.  This\nvirtual device allows me to connect my VTAM test subarea\nwith my VTAM production subarea.  The only pre-requisite is\nto be running on Release 3 of VSE/SP.\n\n1      The CTCA must be defined in the ASI procs.\n\n      ADD 500,CTCA,EML\n\n2      In your VMUSERS directory add this statement to your\n      VSE guest machines.\n\n      SPECIAL 500 CTCA\n\n3      The following B.Book is needed in VTAM.\n\n      CATALOG CTCA500.B       REPLACE=YES\n      CTCA     VBUILD TYPE=CA\n      VTCA     GROUP  LNCTL=CTCA,\n                DELAY=.100,\n                REPLTO=3.0,\n                      ISTATUS=ACTIVE,\n                      MAXFRU=(6,6),\n      CPULINE  LINE   ADDRESS=500\n      CPUPU4   PU     PUTYPE=4\n\n      You will also need to define the paths to connect the\n      subareas, CDRMs and CDRSCs.\n\n4      You will need to issue a CP COUPLE command.  I\n      placed mine in the VTAMTEST start-up.\n\n     // EXEC CPCMD,SIZE=CPCMD\n     CP COUPLE 500 VSEPROD 500\n     /*\n     // EXEC ISTINCVT,SIZE=1300K\n\n5      The final step was to create my own USSTAB.  With the\n      USSTAB, you can create your own menu and reduce the\n      log-on application-id command to a couple of keystrokes.\n\n              PUNCH ' PHASE VTAMMENU,*'\n              TITLE 'VTAM MENU FOR ALL LOCAL TERMINALS'\n              PRINT NOGEN\n     VTAMMENU USSTAB TABLES=STDTRANS\n     A        USSCMD  CMD=A,REP=LOGON,FORMAT=BAL\n              USSPARM PARM=P1,REP=APPLID,DEFAULT=DBDCCICS\n              USSPARM PARM=P2,REP=DATA\n     B        USSCMD  CMD=B,REP=LOGON,FORMAT=BAL\n              USSPARM PARM=P1,REP=APPLID,DEFAULTS=DBDCTEST\n              USSPARM PARM=P2,REP=DATA\n     TEST     USSCMD  CMD=TEST,REP=IBMTEST,FORMAT=BAL\n              USSPARM PARM=P1,DEFAULT=10\n              USSPARM PARM=P2,DEFAULT=OK\n     MESSAGES USSMSG  MSG=0,TEXT='COMMAND ACCEPTED'\n              USSMSG  MSG=1,BUFFER=M1\n              USSMSG  MSG=2,BUFFER=M1\n              USSMSG  MSG=3,TEXT='ERROR IN VTAMMENU. PRESS ENTER'\n              USSMSG  MSG=4,TEXT='APPL NOT ACTIVATED. PRESS ENTER'\n              USSMSG  MSG=5,BUFFER=M1\n              USSMSG  MSG=6,TEXT='LOGON ALREADY PENDING'\n              USSMSG  MSG=7,TEXT='LOGON FAILED. PRESS ENTER'\n              USSMSG  MSG=8,TEXT='INSUFFICIENT STORAGE'\n              USSMSG  MSG=9,TEXT='MAGNETIC CARD DATA ERROR'\n              USSMSG  MSG=10,BUFFER=M1\n              USSMSG  MSG=12,TEXT='REQUIRED PARAMETER OMITTED'\n              USSMSG  MSG=13,TEXT='IBMECHO%'\n     STDTRANS DC      128AL1(*-STDTRANS)\n              DC      X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n              DC      X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n              DC      X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n              DC      X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n              DC      X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n              DC      X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n              DC      X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n              DC      X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n     END      USSEND\n     M1       DC      AL2(M1E-M1S)\n     M1S      DC      X'F5'            ERASE WRITE ALARM\n              DC      X'C7'            WCC ALARM\n     *  VTAMMENU    VTAM APPLICATION SELECTION MENU\n              DC      X'11'            SET BUFFER ADDRESS ORDER\n              DC      X'40C1'          ROW 1 COLUMN 2\n              DC      X'1D'            START FIELD\n              DC      X'F0'            PROTECT SKIP NORMAL\n              DC      CL8'VTAMMENU'\n              DC      X'11'            SET BUFFER ADDRESS ORDER\n              DC      X'40D7'          ROW 1 COLUMN 24\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F8'            PROT SKIP INT ATTR\n              DC      C'VTAM APPLICATION SELECTION MENU'\n              DC      X'11'            SET BUFFER ADDRESS ORDER\n              DC      X'C2E3'          ROW 3 COLUMN 4\n              DC      X'1D'            START FIELD\n              DC      X'F0'            PROTECT SKIP NORMAL\n              DC      C'Enter the character of your selection '\n              DC      C'and press the ENTER key:'\n     *  THE FOLLOWING MENU WILL BE DISPLAYED ON NON-SNA TERMINALS ONLY\n     *  LABEL A1 CORRESPONDS TO LABEL A\n     A1       DC      X'11'            START FIELD\n              DC      X'C5C9'          ROW 5 COLUMN 10\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F8'            PROT SKIP INT ATTR\n              DC      CL2'A '\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F0'            PROTECT SKIP NORMAL\n              DC      CL50'Production CICS'\n     B1       DC      X'11'            SET BUFFER ADDRESS ORDER\n              DC      X'C6D9'          ROW 6 COLUMN 10\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F8'            PROT SKIP INT ATTR\n              DC      CL2'B '\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F0'            PROTECT SKIP NORMAL\n              DC      CL50'Test CICS'\n              DC      X'11'            SET BUFFER ADDRESS ORDER\n              DC      X'D661'          ROW 19 COLUMN 2\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F8'            PROT SKIP INT ATTR\n              DC      C'==> '\n              DC      X'1D'            START FIELD ORDER\n              DC      X'4D'            UNPROTECT DARK\n              DC      X'13'            INSERT CURSOR POSITION\n              DC      X'3C'            REPEAT TO ADDRESS ORDER\n              DC      X'D66B'          ROW 20 COLUMN 1\n              DC      C'   '\n              DC      X'1D'            START FIELD ORDER\n              DC      X'F0'            UNPROTECTED NORMAL ATTR\n     M1E      EQU     *\n              END\n\n6      Your VTAMMENU should look like Figure 1.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E002A08": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00}\\x00}\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 125, "newlines": 125, "modlines": 0, "user": "VSEUPDT"}, "text": "Internal sort routine\n\nThis subroutine may be called to perform an internal sort of a\ntable of fixed entries.  The entries may be up to 256 bytes in\nlength.  This module will perform the sort and return control to\nthe calling program.\n\nCOBOL calling procedure:\n\n    CALL 'INTRSORT' USING TABLE1. SORT-PARMS.\n01  TABLE1.\n    05  ENTRIES  -----------\n    05  ENTRIES  -----------\n    05  ENTRIES  -----------\n    05  ENTRIES  -----------\n    05  ENTRIES  -----------\n    05  ENTRIES  -----------\n01  SORT-PARMS.\n    05  NUMENTRIES        PIC S9(4) COMP VALUE +100.\n    05  ENTRYLENGTH       PIC S9(4) COMP VALUE +20.\n    05  KEYLENGTH         PIC S9(4) COMP VALUE +5.\n    05  KEYDISP           PIC S9(4) COMP VALUE +9.\n    05  SORTYPE           PIC X VALUE 'A' OR 'D'.\n\nThe SORT-PARMS definitions are: NUMENTRIES, the\nnumber of entries in the table (binary value) - maximum value\n256; ENTRYLENGTH, the length of the entries (binary value)\n- maximum value 256; KEYLENGTH, the length of the sort\nkey (binary value) - maximum value 256; KEYDISP, the\ndisplacement of the sort key (binary value) - first byte of table\nis relative to 0; SORTYPE, one character - either A for\nascending, or D for descending.\n\nNote: no edit is performed on any of the fields.\n\n\nINTRSORT CSECT\n\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR12      EQU   12\n         SAVE  (14,12)\n         BALR  R12,0\n         USING *,R12\n         USING PARMSIN,R1\n         USING PARMFLDS,R2\n         L     R2,SORTCTLS         LOAD SORT CONTROL FIELDS\n         L     R2,0(R2)            FOR PL/I USERS\n         L     R7,TABADDR          POINT R7 TO START OF TABLE\n         L     R7,0(R7)            FOR PL/I USERS\n         SR    R6,R6               ZERO R6\n         LH    R6,NBRENTRS         LOAD NR OF TABLE ENTRIES\n         SR    R9,R9               ZERO R9\n         LH    R9,ENTRYLNG         LOAD LENGTH OF ENTRY\n         MR    R8,R6               ENTRY LENGTH X NR. ENTRIES\n         LH    R8,ENTRYLNG         LOAD ENTRY LENGTH\n         AR    R9,R7               POINT R9 TO THE LAST\n         SR    R9,R8                  ENTRY IN TABLE\nSETXCLNG EQU   *   ...SET LENGTH FOR XC...\n         BCTR  R8,0                SUBTRACT 1\n         STC   R8,XC1+1            STORE THE LENGTH CODE IN EACH OF\n         STC   R8,XC2+1               THE 3 \"XC\"\n         STC   R8,XC3+1               INSTRUCTIONS\n         LA    R8,1(0,R8)          BUMP ENTRY LENGTH BACK UP BY 1.\nSETCLCLN EQU   *   ...SET LENGTH FOR CLC...\n         SR    R3,R3               ZERO R3\n         LH    R3,KEYLENGH         LOAD SORT KEY LENGTH\n         BCTR  R3,0                SUBTRACT 1\n         STC   R3,COMPARE+1        STORE LENGTH CODE IN CLC INSTR.\n         MVC   COMPARE+3(1),KEYDISP+1  MOVE SORT KEY DISP.\n         MVC   COMPARE+5(1),KEYDISP+1   INTO COMPARE INSTR.\nSETBRNCH EQU   *   ...CHECK FOR ASCENDING OR DESCENDING...\n         CLI   SORTYPE,C'A'        ASCENDING\n         BNE   DESCEND               NO--BRANCH\n         MVI   BRANCH+1,X'DO'      SET FOR ASCENDING\n         B     STARTPT               GO SORT\nDESCEND  EQU   *   ...SET DESCENDING SEQUENCE...\n         MVI   BRANCH+1,X'BO'      SET FOR DESCENDING\n         B     STARTPT               GO SORT\nCOMPARE  CLC   0(0,R5),0(R7)       COMPARE HI/LO TO NEXT ENTRY\nBRANCH   BC    0,BUMPONE           BRANCH IF CURRENT IS STILL LO/HI\nNEWONE   EQU   *   ...FOUND NEW ENTRY...\n         LR    R5,R7               POINT R5 TO NEW LO/HI\nBUMPONE  EQU   *   ...BUMP TO NEXT ENTRY...\n         BXLE  R7,R8,COMPARE\n         L     R7,SAVESTRT         RESTORE R7 TO NEXT ENTRY\n         CR    R7,R5               WAS STARTING ENTRY LO/HI\n         BE    NOMOVE                YES--BRANCH\nXC1      XC    0(0,R5),0(R7)       SWITCH THE STARTING ENTRY\nXC2      XC    0(0,R7),0(R5)        WITH THE LO/HI\nXC3      XC    0(0,R5),0(R7)        FOUND IN THIS PASS\nNOMOVE   EQU   *   ...DON'T MOVE ENTRY...\n         LA    R7,0(R8,R7)         BUMP R7 TO NEXT STARTING POINT\nSTARTPT  EQU   *   ...SWITCH THE STARTING POINT...\n         ST    R7,SAVESTRT         SAVE START ADDR OF THIS PASS\n         BCT   R6,NEWONE           BRANCH IF MORE PASSES\nTHRU     EQU   *   ...ALL THRU. GO WEST ON 121...\n         RETURN (14,12)\n         EJECT\nSAVESTRT DC    F'0'\nPARMSIN  DSECT\nTABADDR  DS    F                   ADDRESS OF TABLE TO BE SORTED\nSORTCTLS DS    F                   ADDRESS OF SORT CONTROL PARMS\nPARMFLDS DSECT\nNBRENTRS DS    H\nENTRYLNG DS    H\nKEYLENGH DS    H\nKEYDISP  DS    H\nSORTYPE  DS    CL1\n         END\n\nJesse Joyner\nSystems Programmer\nBank of Mississippi (USA)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E002A09": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xa8\\x00\\xa8\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 168, "newlines": 168, "modlines": 0, "user": "VSEUPDT"}, "text": "Partition wait for a specified time\n\nThis program is designed to do nothing more than wait for a\nspecified time.  It can be used for any purpose.  It was written\nas a result of the requirement for the production CICS system\nto be started at 6:00 in the morning, when only a day and\nevening shift are in operation.  This would allow operators to\nleave jobs which used CICS files running, when leaving at\nmidnight, and set CICS to start in the early morning.\n\nBecause it may be necessary to start CICS at other times, for\nexample after a power failure, this program should be run as a\nseparate job step, thereby allowing the job step running this\nprogram to be cancelled if required.\n\nThe program will wait, holding up the partition in which it is\nrunning, until the time specified is reached for the first time.\nIn other words, if a time is specified which has already passed\ntoday, it will stop the partition until that time tomorrow.  To\nrun the program, only the following JCL is required:\n\n// EXEC M051,PARM='hh:mm'\n\nwhere 'hh:mm' is the required time in hours and minutes.\n(Note: use the 24 hour clock.)\n\n\nMESSAGES\n\nNormally, the following message will be displayed:\n\n      M051*0* THIS PARTITION WILL RESTART AT HH:MM\n\nIn case of errors, a message prefixed by 'M051*n*' will be\nissued, 'n' will indicate one of the following errors:\n\n      1 - no 'PARM=' on the EXEC card\n      2 - the parameter passed does not consist of five characters\n      3 - missing \":\"\n      4 - hours invalid\n      5 - minutes invalid.\n\n\nTECHNICAL NOTES\n\nThe program is written in Assembler language, so should be\nassembled and linked with the IJSYS01, IJSYS02, IJSYS03\nand IJSYSLN work files available (these should be in your\npartition standard labels), and SYS001, SYS002, SYS003 and\nSYSLNK assigned.  A LIBDEF with a catalog destination\nshould be provided, along with an OPTION CATAL, followed\nby a ' PHASE M051,*' card.\n\nAll macros used in the program are standard VSE macros.\n\nThe program uses physical I/O for communication with the\noperator console, so the use of a simple CCB and CCW chain\nfor I/O can be examined.  Note that the EXCP macro writes the\nmessage, and the following WAIT causes the program to wait\nuntil the I/O is complete.\n\nThe simple use of Event Control Blocks (ECBs) can also be\nexamined; in this case the program uses a timer ECB (TECB).\nThe program calculates the number of seconds to go until the\ntime at which the program is to allow the partition to restart.\nThe SETIME macro is then passed this number of seconds in\nregister 3, associating the TECB with that time, and placing the\nTECB address in register 1.  The WAIT macro issues an SVC\n7, which will pause the program until the TECB is posted by\nthe system, ie after the number of seconds specified have\nelapsed.\n\nR1      EQU   1\nR3      EQU   3\nR7      EQU   7\nR9      EQU   9\nR11     EQU   11\nR15     EQU   15\n        EJECT\n        PRINT NOGEN\nM051    CSECT\n        BALR  R11,0\n        USING *,R11\n        MVI   MSG+5,C'1'\n        CR    R1,R15                  IF R1 = R15, THEN WE DONT HAVE\n        BNE   A200                       A PARM CARD\n        SPACE 4\nA100    EQU   *\n        LA    R1,LOGCCB               THERE IS SOME KIND OF ERROR\n        EXCP  (1)\n        WAIT  (1)\n        CANCEL\n        SPACE 4\nA200    EQU   *\n        L     R1,0(R1)\n        MVI   MSG+5,C'2'\n        CLC   0(2,R1),=H'5'           IS PARM LENGTH 5 ?\n        BNE   A100\n        MVI   MSG+5,C'3'\n        CLI   4(R1),C':'\n        BNE   A100\n        MVI   MSG+5,C'4'\n        MVC   OKMSG+39(5),2(R1)\n        MVC   TWOCHAR,2(R1)           CONVERT HOURS TO BINARY\n        CLI   TWOCHAR,C'0'\n        BL    A100\n        CLI   TWOCHAR,C'2'\n        BH    A100\n        CLI   TWOCHAR+1,C'0'\n        BL    A100\n        CLI   TWOCHAR+1,C'9'\n        BH    A100\n        BAL   R7,CONVERT\n        CH    R9,=H'0'                CHECK VALID HOURS\n        BL    A100\n        CH    R9,=H'23'\n        BH    A100\n        MH    R9,=H'3600'             CONVERT HOURS TO SECONDS\n        LR    R3,R9                   STORE TIME IN R3\n        MVI   MSG+5,C'5'\n        MVC   TWOCHAR,5(R1)           CONVERT MINUTES TO BINARY\n        CLI   TWOCHAR,C'0'\n        BL    A100\n        CLI   TWOCHAR,C'5'\n        BH    A100\n        CLI   TWOCHAR+1,C'0'\n        BL    A100\n        CLI   TWOCHAR+1,C'9'\n        BH    A100\n        BAL   R7,CONVERT\n        CH    R9,=H'0'                CHECK VALID MINUTES\n        BL    A100\n        CH    R9,=H'59'\n        BH    A100\n        MH    R9,=H'60'               CONVERT MINUTES TO SECONDS\n        AR    R3,R9                      AND ADD TO HOURS\n        GETIME BINARY\n        CR    R3,R1                   NOW SEE IF TIME IS TOMORROW\n        BH    *+8\n        A     R3,=F'86400'            IT IS, SO ADD 24 HOURS\n        SR    R3,R1                   NOW SET R3 TO REMAINING SECONDS\n        LA    R1,OKCCB                MESSAGE TO OP - TIME OF RESTART\n        EXCP  (1)\n        WAIT  (1)\n        SETIME (3),TECB\n        WAIT  (1)\n        EOJ\n        SPACE 4\nCONVERT EQU   *\n        PACK  TWODEC,TWOCHAR\n        CVB   R9,TWODEC\n        BR    R7\n        SPACE 4\nTWODEC  DS    D\nTWOCHAR DS    CL2\nLOGCCB  CCB   SYSLOG,LOGCCW\nLOGCCW  CCW   9,MSG,32,52\nMSG     DC    C'M051*** A PARM= MUST BE PRESENT TIME IN HH:MM FORMAT'\nOKCCB   CCB   SYSLOG,OKCCW\nOKCCW   CCW   9,OKMSG,32,48\nOKMSG   DC    C'M051*0* THIS PARTITION WILL RESTART AT HH:MM   '\nTECB    TECB\n        LTORG\n        END\n\nRobin Lynch\nSoftware Support Manager (UK)                   c Robin Lynch 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E002A10": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00X\\x00X\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 88, "newlines": 88, "modlines": 0, "user": "VSEUPDT"}, "text": "'Secret' POWER parameters\n\nWe recently upgraded our VSE software from 2.1.5 to 4.1.2\n(via 4.1.0 and 4.1.1).  During the course of generating a job\nstream through the Interactive Interface, we noticed a question\nfor 'time event scheduling'.  For the sake of experimentation,\nwe replaced the default 2 with a 1 and were shown several\nother screens and options.  After the system generated the JCL,\nwe were surprised to find some previously unseen parameters\non the * $$ JOB card.  Next we checked our new 4.1 POWER\nInstallation and Operations guide.  These new parameters were\nunlisted.  After several more trips through the Interactive\nInterface, we were able to piece together a fairly accurate list\nof these undocumented parameters.\n\nAlthough we haven't tried them all, we have used quite a few\nand found them very handy for certain types of job.  We use\nthem to start batch PRINTLOG jobs automatically at the end of\neach shift, to run a weekly EREP print and file offload, and to\nrun periodic reports for our CICS monitoring facility.\n\nOne interesting anomaly we have found is that the job must\nreside in the RDR queue with DISP=K.  The RDR queue\nscreen on the Interactive Interface will show the start dates and\ntimes for these jobs.  They will also show in the 'wait for run\nsubqueue' (option 5) on the manage batch queues screen.  If,\nfor some reason, the disposition is changed to an L, the start\ndates and times are removed from the screen.  (A subsequent\nPALTER command back to K will restore them to pending\nstart status.)\n\nAs far as we know, these parameters work in Releases 4.1.1\nand 4.1.2, but beyond that we are uncertain.  If only we could\nnow figure out what the 'RESTART=' parameter on the * $$\nJOB card does!\n\nThe following is a list of the parameters and their uses as we\nhave found them and some examples.\n\nDUETIME=hhmm      to release the job at a specific time\n\n      hh   = the hour (24 hour clock)\n      mm = the minute.\n\nFor example:\n\n      DUETIME=2330  -  to release a job at 11:30pm\n\nDUEDATE=mmddyy       to release a job on a specific day (for\n      a onetime run for instance)\n      mm = month\n      dd   = day\n      yy   = year.\n\nFor example:\n\n      DUEDATE=040591 -  to release a job on 5 April 1991.\n\nDUEDAY=DAILY -  to release a job every day at a specific time.\n\nDUEDAY=(SUN, MON, TUE, WED, THU, FRI, SAT)\n\n      to release a job on a specific day or several specific days of the week.\n\nDUEDAY=(1,2,3,4,5,6....29,30,31)\n\n            to release a job on a specific day of the month or\n            several specific days of the month.\n\nDUEMONTH=(1,2,3,4,5,6,7,8,9,10,11,12)\n\n            use this parameter in combination with the numeric\n            DUEDAY to release a job on a specific day (or days)\n            of a specific month (or months).\n\nFor example:\n\n      DUEDAY=(1,15),DUEMONTH(1-12)\n\n            will release the job every month on the 1st and the 15th.\n\nNote: DUETIME is used in conjunction with the other\nparameters (DUEDAY, DUEDATE, DUEMONTH).\n\nKevin E Crandall\nManager of Technical Services\nVictory Markets Inc (USA)                   c Victory Markets Inc 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A00I": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "VSEUPDT"}, "text": "E003 - VSE Update Issue #003 September 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE003A01   SQL/DS guest sharing with VM/VSE\nE003A02   Effectively handling packed-unsigned decimals\nE003A03   Interface to use PL/I with conditional JCL\nE003A04   Tape utility program\nE003A05   POWER commands from a program\nE003A06   Slimming down VSE's printlog\nE003A07   VSE/ESA - an early user experience - revisited\nE003A08   PF key support for VSE console\nE003A09   DL/I HDAM database management\nE003A10   Storage dump utility\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A01": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02.\\x02.\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 558, "newlines": 558, "modlines": 0, "user": "VSEUPDT"}, "text": "SQL/DS guest sharing with VM/VSE\n\n\nINTRODUCTION\n\nIn late 1989 IBM announced the VM/VSE SQL/DS guest\nsharing facility.  The guest sharing facility allows a VSE/SP (or\nVSE/AF) system running as a guest under VM to share, with\nCMS users, access to a VM SQL/DS database.\n\nThe mechanism employed for guest sharing is a special XPCC\n(Cross Partition Communication Control) request in VSE that is\ntranslated into an APPC (Advanced Program to Program\nCommunication) to VM.  Guest sharing is activated for batch\nprograms through a SET XPCC command when VSE is IPLd.\nGuest sharing is activated for CICS programs through a\nparameter in the CIRB transaction, which starts the on-line\nresource manager for SQL/DS.\n\nIBM provides an excellent guest sharing guide (GG24-3462-\n00) that details all the possible combinations of VM and VSE\ndatabases as well as providing tuning and installation planning\ninformation.\n\nMy experience with guest sharing is as a consultant working\nfor a large scale, direct mail, fund raising organization.  My\nclient has an on-going commitment to implement relational\ntechnology in an IBM mainframe environment.  Starting in the\nspring of 1990 we planned for, installed, and implemented\nguest sharing.  Our CPU is a 4381-P21.  We have about 32\non-line users (mix of CMS and CICS).  Our software is VM/IS\n5.1, VSE/SP 4.1.2, and SQL/DS 2.2.0.  Our CMS users make\nextensive use of ECF for query management and data transfer\nfrom SQL/DS to PC, for use in software such as Lotus and\nQuattro.\n\nThis article will cover three topics; our reasons for\nimplementing guest sharing, the process of installation and\nimplementation, and hints and tips on installation and use of\nguest sharing.\n\n\nWHY IMPLEMENT GUEST SHARING?\n\nUntil guest sharing, we had been maintaining our production\ndata in VSE/VSAM with a copy of the production data in\nVM/SQL/DS.  We refreshed the SQL/DS tables nightly or at\nweekends (depending on necessity of fresh data and the size of\nthe table) from the production VSAM files.  Periodic refresh\nwas an adequate solution since the first phase of our\nimplementation of relational technology was to supply decision\nsupport capability.  Further, we had decided we must run\nSQL/DS in VM because of greater vendor support, both from\nIBM (eg ECF) and third parties.\n\nWe wanted to transfer 'ownership' of production data from\nVSE/CICS/VSAM to VM/SQL/DS.  With VM/SQL/DS\nowning the production data, we could eliminate the headaches\nof maintaining redundant data, and save DASD resources.\nImplementing guest sharing made this possible.\n\nWe also wanted to preserve our investment in application\nsoftware.  We have a highly customized data entry/file\nmaintenance system that we have developed over the last eight\nyears.  By implementing guest sharing and converting our\napplication programs to use SQL instead of VSAM, we have\ntaken another step towards full relational technology without\nthe expense of rewriting our entire system!\n\nIBM made the decision to go to guest sharing easier by not\ncharging for both the VM and VSE databases.  The product\nnumbers are the same - are they trying to tell us something?\n\nAdvantages to us:\n\no      'Up-to-the-minute' data in SQL/DS.\n\no      Another step towards 'full' relational technology.\n\no      Simplified operation because maintenance of redundant\n      data is no longer needed.\n\no      Reduction in DASD use because VSAM files are no longer needed.\n\no      The SQL/DS utility products available from both IBM and\n      third parties are more robust for VM/SQL/DS.\n\nAdvantages to a VSE/SQL installation:\n\no      All of the above.\n\no      Reduction in virtual storage use with the elimination of one\n      or more SQL/DS partitions.\n\no      Centralization of DBA functions under VM.\n\no      Better use of multiple CPUs.\n\nDisadvantages.\n\no      VSE batch (including the SQL/DS preprocessor) can only\n      access one VM database at a time.  This makes the test\n      environment clumsy.\n\no      If SQL/DS is running in VSE and is accessed by CICS,\n      batch can only access the VSE database.\n\no      Additional resource overhead of approximately 10% (IBM's number).\n\no      VSE cannot access a database running under VM/XA.\n\no      VSE running under VM/XA cannot access a VM/SP database.\n\nTechnical requirements\n\nLevel of VSE - 4.1.0 or higher.\n\nLevel of VM - VM/SP 5 (or 6 if you need to access a remote database).\n\nLevel of SQL/DS - 2.2.\n\n\nOptions for combinations of VSE and VM databases\n\nMany combinations of VM and VSE databases are possible in a\nguest sharing environment, with the following restrictions:\n\n1      All batch programs running in a VSE guest have access to\n      only one database (VM, through SET XPCC, or VSE, by default).\n\n2      Each CICS partition can access only one SQL/DS database\n      (VM or VSE) based on a parameter in CIRB (the\n      transaction used to start the on-line resource manager).\n\n3      If CICS is accessing a VSE database, batch can access\n      only that database.\n\nTo change the database to which batch has access, VSE must\nbe IPLd with a different SET XPCC command.  To change the\ndatabase to which CICS has access, a CIRT transaction\n(terminate on-line resource manager) must be issued, followed\nby a CIRB with a different database name.\n\nThe approach we selected was to keep all databases centralized\nunder VM, thus providing us with all the advantages listed\nabove.  Moreover, since we never ran any VSE databases,\nthere was no migration concern.\n\nI believe that any shop running multiple VSE guests with\nseveral databases will find that by implementing guest sharing,\ncentralizing DBA in VM, and adding some of the powerful\nafter-market tools, they will realize significant reduction in\nresource use and gains in productivity.\n\n\nHOW INSTALLATION/IMPLEMENTATION WAS ACCOMPLISHED\n\nComponents of VM SQL/DS that were or weren't installed\n\nPrior to implementing guest sharing, as part of our customary\nsystem software upgrade policy, we had installed a fully\nfunctional SQL/DS 2.2.0 in VM.\n\nComponents of VSE SQL/DS that were or weren't installed\n\nWe installed the database services utility, all the language\npreprocessors (although we only use COBOL), ISQL, batch\nresource manager, and the on-line resource manager.  We did\nnot install the database management modules and National\nLanguage Support modules.  Installation and testing were done\nin a test VSE/SP 4.1.2 guest so as not to interfere with\nproduction.  The documentation we used was a combination of\nthe guest sharing guide, the SQL/DS Installation for VSE\nmanual, the Program Directory for use with SQL/DS and the\nIBM SQL/DS Newsletter (Fall 1989).\n\nHow components were installed\n\nFirst, we put this SET XPCC command in our IPL procedure:\n\nDPD VOLID=DOSRES,CYL=423,TYPE=N,DSF=N\nDLA NAME=AREA1,VOLID=DOSRES,CYL=60,NCYL=3,DSF=N\nSET XPCC TARGET SYSARI TO APPCVM TARGET SQLDBA\nSVA PSIZE=534K,SDL=250,GETVIS=64K\n\nWe used the TAILOR IPL PROCEDURE: VSE APPC/VM\nSPECIFICATION panel of the VSE Interactive Interface to do this.\n\nAlthough there was already an IUCV ALLOW statement in\nSQLDBA's VM directory, we added the following IUCV\nSQLDBA statement to VSE412's VM directory both to\ndocument VSE412's guest sharing access and to ensure access\nin the event of a change to SQLDBA:\n\nUSER VSE412  VSE412   8M 16M BG\nIUCV SQLDBA\nOPTION ECMODE BMX REALTIMER 370E MAXCONN 10\nIPL CMS\nCONSOLE 009 3215 T OPERATOR\n\nThen we re-IPLd VSE.\n\nNext, we performed the following steps as shown in the VSE\nSQL/DS installation manual.\n\nPrepare your VSE system\n\nWe installed our VSE/SP 4.1.2 system with configuration\nnumber 3 (40M VAE, 12 partitions) so we already had\npartition FA as the partition designated for SQL/DS with 4M of\nvirtual storage.  Further, the standard labels that come with the\n3380 version of VSE/SP provide the SYS001 work space\nrequired by this step.\n\nUpdate the CICS tables for SQL/DS\n\nWe took the PCT and PPT entries straight out of the\ninstallation manual.  Again, our SIT and TCT as installed had\nall the required parameters (DBP=YES|xx, EXEC=YES,\nEXITS=YES, TSP=YES|xx).\n\nDefine the library to be installed.\n\nAs noted in the installation manual this step is not needed for\nVSE/SP users because the PRD2 library already exists.\nHowever, we did define the PRD2.SQL220 sub-library (see\nnote under hints and tips).\n\nInstall (restore) the libraries via MSHP\n\nThe installation manual provides a sample job for doing this.\nWe used the INSTALL PROGRAM - STACKED V2\nFORMAT panel of the VSE Interactive Interface to do this.\nThe Interactive Interface creates a large job-manager job stream\nthe critical step of which is this:\n\n// ASSGN SYS006,1B0\n// EXEC LIBR\nCHANGE S=PRD2.SQL220 REUSE=IMMEDIATE\n/*\n// EXEC MSHP\nINSTALL PRODUCT FROMT ID='SQL/DS.....2.2.0' PROD IN=PRD2.SQL220\n/*\n// EXEC LIBR\nCHANGE S=PRD2.SQL220 REUSE=AUTOMATIC\n/*\n\nAfter installing SQL/DS in PRD2.SQL220, we added\nPRD2.SQL220 to our ICCF/CICS start-up LIBDEF so we\ncould use LIBRx commands in ICCF to view/retrieve its\ncontents.  We then re-cycled ICCF/CICS.\n\nCatalogue the base procedures\n\nWe catalogued the base procedures for VSE/SP using the\nARIS223D.Z and ARIS22AD.Z jobs provided in\nPRD2.SQL220.\n\nPerform SQL/DS system installation link edits\n\nWe ran the link edit using the ARIS22BD.Z job provided in\nPRD2.SQL220.\nSince we were not installing a VSE database, steps 7 through\n10 (Optionally define the VSAM master catalog, define VSAM\ndatasets for the database, generate the initial database, install\noptional database components) were not done.\n\nOptionally GRANT SCHEDULE authority\n\nWe performed the GRANT SCHEDULE using the\nARIS22FD.Z job provided in PRD2.SQL220.  We changed the\nCICS appl-id and the SQLDBA password as needed.\n\nStart SQL/DS in multi-user mode\n\nIt was unnecessary to start SQL/DS in multi-user mode because\nSQL/DS was already running in VM.  We then ran the CIRB\nand ISQL transactions in CICS to test the installation, and\neverything worked fine.  We also wrote a quick batch COBOL\nprogram to query one of our tables, preprocessed it, compiled\nit, and ran it.  The batch COBOL also worked fine.  Since our\ntests ran well, we didn't bother with steps 13 and 14 of the\ninstallation (running ISQL against some system tables and\nrunning the sample COBOL program ARISCBLD).\n\nAfter the installation we began converting our programs from\nVSAM to use SQL.  This is proving to be a straightforward\nproject although this is our first experience with the\ncombination of SQL and COBOL.\n\n\nHINTS AND TIPS\n\nThe initial installation went well and was accomplished,\nincluding preparatory work, in one day.  However, because the\nVSE/SQL/DS installation manual is meant for a VSE/AF shop\n(as opposed to VSE/SP), some interpretation was required.  In\nfact, the installation guide would be very confusing to a novice\nVSE/SP system programmer.  For example, it provides JCL to\ndefine a VSAM master catalog in step 7, yet discusses defining\na VSAM managed library in step 3!  Further, the installation\nmanual offers only cursory advice as to which steps to skip or\nmodify if one is installing under VSE/SP.  I feel very strongly\nthat IBM should provide specific VSE/SP instructions for\ninstalling both SQL/DS and guest sharing.\n\nOne problem we encountered early on was choosing the sub-\nlibrary to install SQL/DS in.  The VSE/SP manuals all\nreference PRD2.DBASE as the database sub-library.\nHowever, the VSE/SQL/DS installation manual exclusively\nreferences PRD2.SQL220 as the database sub-library.  As\nmentioned before, we elected to define the PRD2.SQL220 sub-\nlibrary.  Also, using the PRD2.SQL220 sub-library instead of\nPRD2.DBASE allows one the flexibility to up-level SQL/DS\nusing a different sub-library (eg PRD2.SQL310).\n\nAnother problem we encountered almost right away was a\nshortage of real memory allocated to our partitions.  The\ndefault configuration (see above) we used when installing\nVSE/SP called for 0K of real memory in our batch partitions.\nThe guest sharing guide briefly mentions real memory,\nrecommending 32K per path into SQL/DS per partition\naccessing SQL/DS.  We found that a minimum of 64K per\nbatch partition and an additional 96K in our CICS partitions\nwas needed for reliable guest sharing access.  So, we\nconfigured our partitions as follows:\n\nALLOC S,F1=768K,F3=3072K,F5=256K\nALLOC 1,BG=1536K,F7=1024K,F8=4608K,F4=1024K\nALLOC 2,F2=7878K,F6=348K\nALLOC 3,F9=2048K,FA=5120K,FB=2048K\nALLOC R,BG=64K,F1=64K,F2=256K,F3=424K\nALLOC R,F4=64K,F5=128K,F6=64K,F7=64K\nALLOC R,F8=256K,F9=64K,FA=128K,FB=64K\n\nStill another problem that plagued us for several days was the\ninability to establish more than 4 paths into the database\nmachine from VSE.  The solution to this problem was to\nincrease the MAXCONN parameter of the OPTION statement\nin VSE412's VM directory to 10 from the default of 4 (see\ndirectory extract above).  The potential need to increase this\nparameter is not mentioned anywhere in the guest sharing\nguide, installation manual, or the newsletters.\n\nYet another problem we soon encountered was preprocessing\nand compiling a COBOL program that uses the EXEC SQL\ninterface.  The SQL/DS Application Programming for VSE\nmanual supplies simple models for doing this for both batch\nand CICS.  However, the models use sequential disk extents\nfor the output of the SQL/DS preprocessor (input to the\nCOBOL compiler or CICS preprocessor).  We don't like\nsequential disk extents for utility functions like compiles\nbecause it means we must have a different set of extents or\neven a different JCL for each partition.  Further, the CICS\nmodel is unclear as to whether the INCLUDE statements for\nthe SQL/DS modules ARIRRTED and ARIPADR belong after\nthe execute of FCOBOL or before the execute of LNKEDT.\n\nAfter some experimentation we came up with the following\nbatch SQL/COBOL compile skeleton.  This skeleton uses the\nPOWER DISP=I punch capability to punch the output of the\nSQL/DS preprocessor behind some compile JCL thus allowing\nus to run SQL/COBOL compiles in any and all partitions.  By\nplacing this compile skeleton in member C$$COBAT of the\nICCF library in which our batch SQL/COBOL is kept, we can\nuse option 8 (compile) of the Interactive Interface PRIMARY\nLIBRARY panel for our batch SQL/COBOL compiles.\n\n* $$ JOB JNM=&JOBNAME,DISP=D,CLASS=A,NTFY=YES\n* $$ LST DISP=D,CLASS=Q,PRI=3\n* $$ PUN DISP=I,PRI=9,CLASS=A\n// JOB &JOBNAME SQL PREP PROGRAM &PROGNAME\n// ASSGN SYS005,SYSRDR\n// EXEC IESINSRT\n$ $$ LST DISP=D,CLASS=Q,PRI=3\n// JOB &JOBNAME COMPILE PROGRAM &PROGNAME\n// SETPARM CATALOG=&CATALOG\n// IF CATALOG = 1 THEN\n// GOTO CAT\n// OPTION ERRS,SXREF,SYM,LIST,NODECK\n// GOTO ENDCAT\n/.  CAT\n// LIBDEF PHASE,CATALOG=FRISPRD.LOADLIB\n// OPTION ERRS,SXREF,SYM,CATAL,NODECK\n   PHASE &PROGNAME,*\n   INCLUDE ARIPRDID\n   INCLUDE ARIPADR\n/.  ENDCAT\n// EXEC FCOBOL,SIZE=256K\n CBL LIB,FLOW,STATE,VERB,LANGLVL(1),APOST,NOTRUNC,NOADV,BUF=2048\n* $$ END\n// ON $CANCEL OR $ABEND GOTO ENDJ2\n// EXEC\nARIPRPC,SIZE=AUTO,PARM='USERID=VSEBATCH/VSEBATCH,KEEP,ISOL(CS),*\n               PREPNAME=&PROGNAME,BLOCK'\n* $$ SLI ICCF=(&PROGNAME,&PASSWORD),LIB=&LIBNO\n/*\n/.  ENDJ2\n// EXEC IESINSRT\n/*\n// IF CATALOG NE 1 OR $MRC GT 4 THEN\n// GOTO NOLNK\n// EXEC LNKEDT,SIZE=256K\n/.  NOLNK\n#&\n$ $$ EOJ\n* $$ END\n/&\n* $$ EOJ\n\nAfter some experimentation we came up with the following\nCICS SQL/COBOL compile skeleton.  As with the batch\ncompile, this skeleton uses the POWER DISP=I punch\ncapability to punch the output of the SQL/DS preprocessor\nbehind some CICS preprocessor which in turn punches its\noutput behind some compile JCL.  This skeleton also uses a\nquick COBOL program (KDKINSRT) we wrote to read JCL\nfrom the job stream and punch it out.  We wrote KDKINSRT\nbecause we couldn't get IESINSRT (the similar function\nsupplied with VSE) to do what we wanted in this case.  By\nplacing this compile skeleton in member C$$COONL of the\nICCF library in which our CICS SQL/COBOL is kept, we can\nuse option 8 (compile) of the Interactive Interface PRIMARY\nLIBRARY panel for our CICS SQL/COBOL compiles.\n\n* $$ JOB JNM=&JOBNAME,DISP=D,CLASS=A,NTFY=YES\n* $$ LST DISP=D,CLASS=Q,PRI=3\n* $$ PUN DISP=I,PRI=9,CLASS=A\n// JOB &JOBNAME SQL PREP PROGRAM &PROGNAME\n// ASSGN SYS006,FED\n// EXEC KDKINSRT\n$ $$ LST DISP=D,CLASS=Q,PRI=3\n$ $$ PUN DISP=I,PRI=9,CLASS=A\n// JOB &JOBNAME TRANSLATE PROGRAM &PROGNAME\n// ASSGN SYS005,SYSRDR\n// EXEC IESINSRT\n@ $$ LST DISP=D,CLASS=Q,PRI=3\n// JOB &JOBNAME COMPILE PROGRAM &PROGNAME\n// SETPARM CATALOG=1\n// IF CATALOG = 1 THEN\n// GOTO CAT\n// OPTION ERRS,SXREF,SYM,LIST,NODECK\n// GOTO ENDCAT\n/.  CAT\n// LIBDEF PHASE,CATALOG=FRISPRD.LOADLIB\n// OPTION ERRS,SXREF,SYM,CATAL,NODECK\n   PHASE &PROGNAME,*\n   INCLUDE DFHECI\n/.  ENDCAT\n// EXEC FCOBOL,SIZE=256K\n CBL LIB,LANGLVL(1),APOST,NOADV,BUF=2048\n$ $$ END\n// ON $CANCEL OR $ABEND GOTO ENDJ2\n// OPTION NOLIST,NODUMP,DECK\n// EXEC DFHECP1$,SIZE=512K\n CBL XOPTS(CICS DEBUG LANGLVL(1))\n@ $$ END\n// ON $CANCEL OR $ABEND GOTO ENDJ2\n// EXEC\nARIPRPC,SIZE=AUTO,PARM='USERID=CICSUSER/CICSUSER,KEEP,ISOL(CS),*\n              PREPNAME=&PROGNAME,BLOCK'\n* $$ SLI ICCF=(&PROGNAME),LIB=0029\n/*\n/.  ENDJ2\n// ASSGN SYS006,FED\n// EXEC KDKINSRT\n#*\n/.  ENDJ2\n// EXEC IESINSRT\n+*\n// IF CATALOG NE 1 OR $MRC GT 4 THEN\n// GOTO NOLNK\n  INCLUDE ARIRRTED\n  INCLUDE ARIPADR\n// EXEC LNKEDT,SIZE=256K\n/.  NOLNK\n+&\n@ $$ EOJ\n$ $$ END\n#&\n$ $$ EOJ\n@ $$ END\n/&\n* $$ EOJ\n\n\nKDKINSRT\n\nCBL APOST,LIB,NOSYM,SXREF,CLIST\n      IDENTIFICATION DIVISION.\n      PROGRAM-ID.    KDKINSRT.\n      REMARKS.  CARD-TO-CARD CONVERT @ TO $ AND + TO # IN COL 1.\n                          CAN'T FIND DOCS ON IBM'S IESINSRT TO SEE IF IT\n                          CAN DO THIS.\n                 ENVIRONMENT DIVISION.\n                 INPUT-OUTPUT SECTION.\n                 FILE-CONTROL.\n                     SELECT CARD-OUT  ASSIGN TO SYS006-UR-2540P-S.\n                 DATA DIVISION.\n                 FILE SECTION.\n                 FD  CARD-OUT\n                        RECORDING MODE IS F\n                        LABEL RECORDS ARE OMITTED\n                        RECORD CONTAINS 080 CHARACTERS\n                        DATA RECORD IS OP-REC.\n                 01  OP-REC                      PIC X(080).\n                 WORKING-STORAGE SECTION.\n                 01  WORK-AREA.\n                     02  FILLER   PIC X(16)  VALUE 'WORKING STORAGE '.\n                     02  W2-IP-CNT          PIC S9(7) COMP-3 VALUE +0.\n                     02  W2-OP-CNT          PIC S9(7) COMP-3 VALUE +0.\n                 01  IP-REC.\n                     05  IP-END.\n                       10  IP-CONVERT5\n                         15  IP-CONVERT3         PIC XXX.\n                         15  FILLER              PIC XX.\n                       10  FILLER                PIC XXX.\n                     05  FILLER                  PIC X(72).\n                 PROCEDURE DIVISION.\n                 HSK.  OPEN OUTPUT CARD-OUT.\n                 P1-READ.\n                     ACCEPT IP-REC.\n                     ADD 1 TO W2-IP-CNT.\n                     IF IP-END EQUAL '@ $$ END'\n                        GO TO P99-EOF.\n                     IF IP-CONVERT5 EQUAL '@ $$ '\n                        MOVE '$ $$ ' TO IP-CONVERT5\n                     ELSE\n                     IF IP-CONVERT5 EQUAL '$ $$ '\n                        MOVE '* $$ ' TO IP-CONVERT5\n                     ELSE\n                     IF IP-CONVERT3 EQUAL '+* '\n                        MOVE '#* ' TO IP-CONVERT3\n                     ELSE\n                     IF IP-CONVERT3 EQUAL '#* '\n                        MOVE '/* ' TO IP-CONVERT3\n                     ELSE\n                     IF IP-CONVERT3 EQUAL '+& '\n                        MOVE '#& ' TO IP-CONVERT3\n                     ELSE\n                     IF IP-CONVERT3 EQUAL '#& '\n                        MOVE '/& ' TO IP-CONVERT3.\n                     MOVE IP-REC TO OP-REC.\n                     WRITE OP-REC.\n                     ADD 1 TO W2-OP-CNT.\n                     GO TO P1-READ.\n                 P99-EOF.\n                     CLOSE CARD-OUT.\n                     STOP RUN.\n\nIn conclusion, we have found guest sharing to be a good match\nfor our requirements, we have had no insurmountable problems\nwith its installation and use and it moves us forward in our\neffort to implement a full relational environment.\n\nKevin Kitowski\nBrickhouse Associates (USA)                  cBrickhouse Associates 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A02": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x90\\x00\\x90\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 144, "newlines": 144, "modlines": 0, "user": "VSEUPDT"}, "text": "Effectively handling packed-unsigned decimals\n\n\nPACKED AND UNPACKED DATA FIELDS\n\nOur system uses a lot of packed-unsigned decimals to capture\naccount numbers, codes, dates, and many other items in order\nto save storage.  All the savings are made at the cost of longer\nprocessing time.  However, if we can handle them effectively,\nthe processing time can still be reduced.\n\nMany programs may have their own way to pack or unpack a\nfield.  Some of them may have used Assembler subroutines to\ndo the job, but the easiest and fastest way is to define two\nfields in working storage and redefine them in the required\nway.\n\nIf you have a maximum of 10 bytes to pack or unpack, define a\n10-digit signed decimal with an implied decimal place field -\nPIC S9(10)V9 - and a similar field which is in packed format -\nPIC S9(10)V9 COMP-3.  Both must have an initial value of\nzero, and must be redefined in order to truncate the last bytes.\n\n  WORKING-STORAGE SECTION.\n  01  PACKED-UNSIGN-WORK-AREA.\n      05    PACK-10                 PIC  S9(10)V9    COMP-3  VALUE +0.\n      05    FILLER  REDEFINES  PACK-10.\n            10   PACK-5-BYTES       PIC  X(5).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  PACK-10.\n            10   FILLER             PIC  X(1).\n            10   PACK-4-BYTES       PIC  X(4).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  PACK-10.\n            10   FILLER             PIC  X(2).\n            10   PACK-3-BYTES       PIC  X(3).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  PACK-10.\n            10   FILLER             PIC  X(3).\n            10   PACK-2-BYTES       PIC  X(2).\n            10   FILLER             PIC  X.\n******************************\n      05    UNPK-10                 PIC  S9(10)V9            VALUE +0.\n      05    FILLER  REDEFINES  UNPK-10.\n            10   UNPACK-10-BYTES    PIC  X(10).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  UNPK-10.\n            10   FILLER             PIC  X(2).\n            10   UNPACK-8-BYTES     PIC  X(8).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  UNPK-10.\n            10   FILLER             PIC  X(4).\n            10   UNPACK-6-BYTES     PIC  X(6).\n            10   FILLER             PIC  X.\n      05    FILLER  REDEFINES  UNPK-10.\n            10   FILLER             PIC  X(6).\n            10   UNPACK-4-BYTES     PIC  X(4).\n            10   FILLER             PIC  X.\n  PROCEDURE DIVISION.\n  TO-UNPACK-10-DIGIT-ACNO.\n       MOVE  PACKED-ACNO            TO   PACK-5-BYTES.\n       MOVE  PACK-10                TO   UNPK-10.\n       MOVE  UNPACK-10-BYTES        TO   UNPACKED-ACNO.\n  TO-UNPACK-6-DIGIT-DATE.\n       MOVE  PACKED-DATE            TO   PACK-3-BYTES.\n       MOVE  PACK-10                TO   UNPK-10.\n       MOVE  UNPACK-6-BYTES         TO   UNPACKED-DATE.\n  TO-UNPACK-4-DIGIT-CODE.\n       MOVE  PACKED-CODE            TO   PACK-2-BYTES.\n       MOVE  PACK-10                TO   UNPK-10.\n       MOVE  UNPACK-4-BYTES         TO   UNPACKED-CODE.\n *SIMILAR FOR OTHER NUMBER OF DIGITS.\n  TO-PACK-10-DIGIT-ACNO.\n       MOVE  UNPACKED-ACNO          TO   UNPACK-10-BYTES.\n       MOVE  UNPK-10                TO   PACK-10.\n       MOVE  PACK-5-BYTES           TO   PACKED-ACNO.\n  TO-PACK-6-DIGIT-DATE.\n       MOVE  UNPACKED-DATE          TO   UNPACK-6-BYTES.\n       MOVE  UNPK-10                TO   PACK-10.\n       MOVE  PACK-3-BYTES           TO   PACKED-DATE.\n  TO-PACK-4-DIGIT-CODE.\n       MOVE  UNPACKED-CODE          TO   UNPACK-4-BYTES.\n       MOVE  UNPK-10                TO   PACK-10.\n       MOVE  PACK-2-BYTES           TO   PACKED-CODE.\n *SIMILAR FOR OTHER NUMBER OF DIGITS.\n\nNOTES\n\no      The implied decimal must be specified for PACK-10.\n\no      When you follow the same method to define the fields,\n      MOVE PACK-10 TO UNPK-10 generates only an UNPK\n      instruction; and MOVE UNPK-10 TO PACK-10 generates\n      PACK and ZAP instructions.\n\no      If the receiving fields are defined without a sign then each\n      MOVE statement generates one more 0I instruction.\n\no      If the implied decimal is not specified for UNPK-10 then\n      each MOVE statement generates one more MVO instruction.\n\n\nCHECKING AND MOVING OF PACKED-UNSIGNED DATA FIELDS\n\nWhen packed-unsigned decimals are used in the system, you\nmay need to check their content or move some specific data\ninto them.  In this case you may define the specific data in\nworking storage as follows.\n\n WORKING-STORAGE SECTION.\n 01  PACKED-UNSIGN-WORK-AREA.\n     05    PACKED-DATA             PIC  S9(10)V9   COMP-3   VALUE +1234567890.0.\n     05    FILLER  REDEFINES  PACKED-DATA.\n           10   PACK-1234          PIC  X(2).\n           10   PACK-567890        PIC  X(3).\n           10   FILLER             PIC  X.\n     05    PACKED-FIELD-1          PIC  X(2).\n     05    PACKED-FIELD-2          PIC  X(3).\n PROCEDURE DIVISION.\n**************************************************************\n*    Both the following procedures perform the same task     *\n*    ie       If PACKED-FIELD-1 contains x'1234' then        *\n*                move X'567890' to PACKED-FIELD-2.           *\n**************************************************************\n NORMAL-WAY-TO-CHECK-AND-MOVE.\n      MOVE  PACKED-FIELD-1         TO   PACK-2-BYTES.\n      MOVE  PACK-10 TO             UNPK-10.\n      IF  UNPACK-4-BYTES           =   '1234'\n           MOVE  '567890'          TO   UNPACK-6-BYTES\n           MOVE  UNPK-10           TO   PACK-10\n           MOVE  PACK-3-BYTES      TO   PACKED-FIELD-2.\n SHORTER-WAY-TO-CHECK-AND-MOVE.\n      MOVE  1234                   TO   PACK-10.\n      IF  PACKED-FIELD-1           =   PACK-2-BYTES\n           MOVE  567890            TO   PACK-10\n           MOVE  PACK-3-BYTES      TO   PACKED-FIELD-2.\n SHORTEST-WAY-TO-CHECK-AND-MOVE.\n      IF  PACKED-FIELD-1           =    PACK-1234\n           MOVE  PACK-567890       TO   PACKED-FIELD-2.\n\nChwee Tee Ng\nProject Analyst\nBank of China (Singapore)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A03": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xd6\\x00\\xd6\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 214, "newlines": 214, "modlines": 0, "user": "VSEUPDT"}, "text": "Interface to use PL/I with conditional JCL\n\nConditional JCL is a very useful tool.  However, return codes\ncan be set only in Assembler programs.  To get round this\nrestriction I made this interface to use conditional JCL with\nPL/I, and PL/I and DL/I programs.\n\nAll the code has been tested on VSE/SP 2.1, DL/I 1.7.0 and\nPL/I 1.6.\n\nThe Assembler subroutine is called from a program and puts a\nreturn code in the partition communication region.\n\n* $$ JOB JNM=NEKR6\n// JOB NEKR6\nLIBDEF *,CATALOG=LIBTEST.SY       PUT YOUR LIBRARY\n// OPTION CATAL,ALIGN,XREF,NODUMP,NOSYSDMP\n PHASE NEKRC2,*\n// EXEC ASSEMBLY,SIZE=200K\n         PRINT NOGEN\nNEKRC2   CSECT\n         ENTRY RCOD\n         DC    C' RCOD'\n         DC    AL1(5)\nRCOD     DS    0H\n         STM   14,11,12(13)\n         BALR  10,0\n         USING *,10\n         LA    4,SAVEAREA\n         ST    13,4(4)\n         ST    4,8(13)\n         LR    13,4\n*                          ADDRESS OF PL/I PARAMETER LIST IS\n         USING ARGLIST,1             IN THE REGISTER 1\n         MVC  ADRX,ADDR1\n         MVI  AAA,X'00'\n         L R7,ADR          IN THE R7 IS NOW ADDRESS OF THE RETURN CODE\n         USING DUM,R7\n         MVC RETCOD,RCDUM  MVC DUE TO JOBCOM\n*        DUMP\n         JOBCOM FUNCT=PUTCOM,AREA=RETCOD,LENGTH=4\n         L   13,4(13)\n         LM  14,11,12(13)\n         BR  14\nLAA      CANCEL ALL\nSAVEAREA DC  20F'0'\nRETCOD   DS  F\nR7             EQU 7\n         CNOP 0,8\nADR      DS 0CL4\nAAA      DS CL1\nADRX     DS CL3\nARGLIST  DSECT\nXXX      DS CL1       X'80' LAST FULL WORD IN PARAMETER LIST\nADDR1    DS CL3                       ADDRESS OF RCOD\nDUM      DSECT\nRCDUM    DS F                 HERE WILL BE ADDRESS OF RCOD\n         END\n/*\n// EXEC LNKEDT\n/*\n/&\n* $$ EOJ\n\nPL/I programs must be catalogued in the following way.\n\n* $$JOB JNM=NEKJRC1,CLASS=O,DISP=D,USER=SYSYT\n* $$PRT CLASS=S\n// JOB NEKJRC1\nLIBDEF *,CATALOG=LIBTEST.SY,SEARCH=LIBTEST.SY\n// DLBL IJSYSPH,'PL OD PROD',0\n// EXTENT SYSPCH,SYS472,1,0,513000,1000     PUT YOUR EXTENTS\nASSGN SYSPCH,DISK,VOL=SYS472,SHR\n* INSTEAD SYPL2 DOWN PUT NAME OF YOUR PHASE |\n// EXEC PLIOPT,SIZE=256K\n* PROCESS CATALOG('SYPL2'),DECK,NOLINK;\n\n MAIN:PROC OPTIONS(MAIN) ;\n   DCL   RCOD    ENTRY OPTIONS (ASSEMBLER INTER);\n   DCL (R_COD)FIXED BIN (31);  /* DECLARATION OF RETURN CODE */\n   ......\n   R_COD=116;                  /* SETTING OF RETURN CODE*/\n   .......\n   CALL RCOD (R_COD);          /* CALL ASSEMBLER SUBROUTINE */\n END;\n/*\nCLOSE SYSPCH,PUNCH\n// DLBL IJSYSIN,'PL OD PROD',0\n// EXTENT SYSIPT,SYS472,1,0,513000,1000\nASSGN SYSIPT,DISK,VOL=SYS472,SHR\n// EXEC LIBR,PARM='ACCESS SUBLIB=LIBTEST.SY '  PODBIBLIOTEKA OK ? +++\n/*\nLIBDEF *,CATALOG=LIBTEST.SY,SEARCH=LIBTEST.SY\n// OPTION CATAL,ALIGN,XREF,NODUMP,NOSYSDMP\n   PHASE SYPL2,*                           PUT YOUR NAME  #######\n   INCLUDE SYPL2                           PUT YOUR NAME  #######\n   INCLUDE NEKRC2\n   INCLUDE IBMBPJRA\n/*\n// EXEC LNKEDT\n/*\nCLOSE SYSIPT,READER\n/*\n/&\n* $$EOJ\n\nThe JCL to be used is given below.\n\n* $$ JOB JNM=NEKR3\n// JOB NEKR3\nLIBDEF *,SEARCH=LIBTEST.SY\n// EXEC SYPL2,SIZE=300K\n/*\n// EXEC NEKRCOD,SIZE=300K\n/*\n/&\n* $$ EOJ\n\nNEKRCOD is the program that gets the return code from the\npartition region.  It must be catalogued as a phase.\n\n         PRINT NOGEN\nGETRC    START X'78'\n         BALR R12,0\n         USING *,R12\n         LA 13,SAVEAREA\n         JOBCOM FUNCT=GETCOM,AREA=RCOD,LENGTH=4\n         L   R7,RCOD\n         EOJ RC=(R7)\n               SPACE\nSAVEAREA       DS 9D\nRCOD     DS F\n*\nR7             EQU 7\nR12            EQU 12\nR14            EQU 14\nR15            EQU 15\n         END GETRC\n\nThe part of the partition that is used cannot be used for any\nthing else.\n\nUsers of DL/I and PL/I  must use different JCL.  This is shown\nbelow.\n\n* $$JOB JNM=NEKJRC2\n// JOB NEKJRC2\n// ASSGN SYSPCH,UA\n// ASSGN SYSPCH,FED\n// ASSGN SYSIPT,UA\n// ASSGN SYSIPT,FEC\nLIBDEF *,CATALOG=LIBTEST.SY,SEARCH=LIBTEST.SY\n// DLBL IJSYSPH,'PL SY TEST',0\n// EXTENT SYSPCH,SYS472,1,0,536000,1000\nASSGN SYSPCH,DISK,VOL=SYS472,SHR\n// EXEC DFHEPP1$,SIZE=256K\n* PROCESS INCLUDE,XOPTS(DLI);\n SYARC1: PROC(PCB1) OPTIONS(MAIN);\n\n /* DECLARATION OF SUBROUTINE */\n     DCL RCOD ENTRY OPTIONS ( ASSEMBLER INTER ) ;\n /* DECLARATION OF RETURN CODE */\n     DCL (R_COD) FIXED BIN (31) ;\n   /* USUAL DL/I PROGRAM */\n   ..............\n   ..............\n   R_COD=17 ;   /* SETTING OF RETURN CODE */\n   ..............\n   R_COD=18 ;   /* SETTING OF RETURN CODE */\n   .............\n   .............\n   CALL RCOD ( R_COD ) ;   /* AFTHER THIS ANY CHANGE OF RETURN CODE\n                              HAS NO MEANING                  */\n   .............\n END SYARC1;\n/*\nCLOSE SYSPCH,PUNCH\n// DLBL IJSYSIN,'PL SY TEST',0\n// EXTENT SYSIPT,SYS472,1,0,536000,1000\nASSGN SYSIPT,DISK,VOL=SYS472,SHR\n// OPTION CATAL,ALIGN,NOXREF,NOSYM\n   PHASE SYARC1,*               PUT YOUR PHASE NAME |\n// EXEC PLIOPT,SIZE=100K\n   INCLUDE NEKRC2                ASSEMBLY MODULE\n   INCLUDE DLZLIPLI\n   INCLUDE IBMBPJRA\n   ENTRY DLZLIPLI\n// EXEC LNKEDT\n/*\n/&\n// JOB RESET\nCLOSE SYSIPT,READER\n/*\n/&\n* $$EOJ\n\nThe execution JCL is standard except that the execution of the\nNEKRCOD phase must be at the end.\n\n* $$ JOB JNM=NEKR4\n// JOB NEKR4\n// DLBL ...                  JCL FOR DATABASES ...\nLIBDEF *,SEARCH=LIBTEST.SY\n// EXEC DLZRRC00,SIZE=300K\nDLI,SYARC1,SYAPSB1\n/*\n// EXEC NEKRCOD,SIZE=300K\n/*\n/&\n* $$ EOJ\n\nNenad Kuzmanovic\nArenaturist (Yugoslavia)                        c Nenad Kuzmanovic 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A04": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01/\\x01/\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 303, "newlines": 303, "modlines": 0, "user": "VSEUPDT"}, "text": "Tape utility program\n\nI wrote the following program primarily to enable me to check\nthe status of tape drives and the volumes mounted on them\nfrom a terminal at my desk.  In addition, it allows commands\nto (F) forward space one file, (B) back space one file, (R)\nrewind to load point, and (U) unload a tape.  Executed\nprimarily from ICCF ($TM), it has saved many trips into the\ncomputer room.  The program can also be executed from the\nconsole via a pause, or by assigning it to an unused attention\nroutine command.  The program is currently running under\nVSE/SP 2.1 with 3420-6 tape drives, but should work with any\nmodel 3420 drive.  The only changes required for other tape\ndevices should be the channel program command codes, if any.\nThe program is currently capable of checking 16 tape drives,\nbut could accommodate more by expanding the assign release\ntable (RELTAB).\n\nFigure 1 shows the possible responses from executing the\nprogram.  One line is displayed per tape drive.  The device\nCUU is listed first, and is obtained from the PUB table.  The\nstatus of the drive, which is either available or owned, is\nshown next.  If there is an assign made to a drive, that drive is\nowned and no further checking is done for that unit.  The tape\nstatus is then listed (ready/notrd).  If a tape is mounted and is\nnot currently assigned, the status will be ready.  The next field\nin the display is the protect/unprotect indicator (ring in/out).\nThe density of the tape mounted is displayed next, followed by\nload point status (load point/not load point).  The volume and\nheader records are read for those tapes at load point (LPT) that\nare available to show the volume serial number, the file-id, and\nfile creation and expiration dates.  If the header and volume\nrecords are read, the tape is rewound to load point so as not to\ninterfere with the tape being assigned.\n\nTo position a tape that is not currently owned enter the\ncommand code (F,B,R, and U) followed by a space and the\nCUU.  For example: B 380 would backspace the tape on 380\none file; or R 380 would rewind it to load point.  A response\nwith no data re-executes the program and provides a fresh\ndisplay.  To end the program, simply enter Q.\n\n* $$ JOB JNM=TM,DISP=D,CLASS=0,PRI=5,USER='*WILL*'\n* $$ LST CLASS=O,DISP=D,PRI=5\n// JOB TM SE\n// LIBDEF PHASE,CATALOG=USR1.PROD\n// OPTION CATAL,ALIGN\n PHASE TM,*\n// EXEC ASSEMBLY,SIZE=500K *\n         PRINT   ON,NOGEN,DATA\n*        PRINT   ON,GEN,DATA\n*\n*       THIS PROGRAM WILL:\n*       1. LIST ALL TAPE DRIVES AND THEIR STATUS.\n*       2. LIST THE HEADER INFORMATION FROM ANY TAPES AT LOAD POINT.\n*       3. ACCEPT COMMANDS TO:  REWIND             (R)\n*                               UNLOAD             (U)\n*                               FORWARD SPACE FILE (F)\n*                               BACK SPACE FILE    (B).\nASSIGN   ASPL  DSECT=YES\nTM       START 0\n         BALR  R12,0\n         USING *,R12                LOAD BASE REGISTER\n         XC    ASPL1,ASPL1          CLEAR PARAMETER LIST\n         XC    TAPEINFO,TAPEINFO    CLEAR SENSE INFO\n         XC    REPLY,REPLY          CLEAR REPLY INFO\n         LA    R10,ASPL1            ESTABLISH ADDRESSABILITY\n         USING ASSIGN,R10           TO PARM LIST\n         LA    R11,RELTAB           POINT TO RELEASE TABLE\n         ASYSCOM ,                  POINT TO SYSCOM\n         L     R8,120(R1)           SET PUBOWN ADDRESS\n         ST    R8,PUBOWN            SAVE PUBOWN ADDRESS\n         COMRG ,                    GET COMREG ADDRESS\n         LH    R9,64(R1)            SET ADDRESS OF PUB TABLE\n         ST    R9,PUBTAB            SAVE PUB TABLE ADDRES\nPUBCHECK EQU   *\n         MVI   LOGMSG1,C' '         CLEAR MESSAGE LINE\n         MVC   LOGMSG1+1(L'LOGMSG1),LOGMSG1\n         MVC   WORK1(1),4(R9)       GET THE DEVICE TYPE\n         NI    WORK1,X'F0'          REMOVE OTHER BITS\n         CLI   WORK1,X'50'          IS DEVICE A TAPE UNIT\n         BNE   BUMPUB               NO, GET ANOTHER\nCHECKUP  EQU   *\n         MVC   WORK2(2),0(R9)       GET CUU\n         MVC   CUU(1),0(R9)         MOVE CHANNEL\n         MVI   WORK2,X'00'          REMOVE CHANNEL\n         LH    R4,WORK2\n         SRL   R4,4                 REMOVE RIGHT NIBS\n         STC   R4,CUU+1             MOVE UU\n         NI    WORK2+1,X'0F'        REMOVE LEFT NIBS\n         MVC   CUU+2(1),WORK2+1     AND MOVE\n         TR    CUU(3),TABLE         TRANSLATE FOR DISPLAY\n         TM    7(R9),X'F8'          IS TAPE UNIT?\n         BM    TAPEUP               YES, PROCEED\n         MVC   STATUS,=C'DOWN '     NO\n         LA    R1,LOGCCB1           PUT LINE TO CONSOLE\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         B     BUMPUB\nTAPEUP   EQU   *\n         LH    R5,0(R8)             SET PUBOWN FLAGS\n         SLL   R5,20                STRIP OFF FIRST 4 BITS\n         LTR   R5,R5                IS TAPE UNIT OWNED?\n         BNZ   OWNED                YES GO DO MESSAGE\n         MVC   STATUS,=C'AVAIL'     NO\n         MVI   ASGFUNCT,ASGTPT      ASSGN TAPE TEMP\n         LA    R10,ASPL1            ENSURE ADDRESSABILITY\n         ASSIGN ASPL=(R10),SAVE=SAVEAREA\n         LTR   R15,R15              ASSIGN OK\n         BNZ   BADASG               NO\n         MVC   TAPECCB1+7(1),ASGLUNDX    PUT SYSNO IN CCB\n         MVC   HWORD,ASGLUNO        GET SYSNO\n         NI    HWORD,B'00000000'    FOR RELEASE\n         LH    R7,HWORD             MACRO\n         CVD   R7,DWORD\n         UNPK  DWORD,DWORD+6(2)\n         MVC   0(3,R11),DWORD+5     MOVE SYSNO TO RELEASE TABLE\n         LA    R11,3(R11)           BUMP RELEASE TABLE POINTER\n* THIS IS WHERE TO CHECK FOR TAPE POSITIONING COMMANDS\n         CLC   CUU,ICUU             DO WE WANT TO SPIN THIS TAPE\n         BNE   SENSE                NOPE, GO AROUND\n         CLI   ICOM,C'R'            DO WE WANT TO REWIND THIS TAPE\n         BNE   NOREWIND             NOPE, GO AROUND\n         MVI   TAPECCW1,X'07'       INDICATE REWIND\n         LA    R1,TAPECCB1          GET READY TO REWIND\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         B     SENSE                CONTINUE\nNOREWIND EQU   *\n         CLI   ICOM,C'U'            DO WE WANT TO UNLOAD THIS TAPE\n         BNE   NOUNLD               NOPE, GO AROUND\n         MVI   TAPECCW1,X'0F'       INDICATE UNLOAD\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         B     SENSE                GO AROUND\nNOUNLD   EQU   *\n         CLI   ICOM,C'F'            DO WE WANT TO F-S-F\n         BNE   NOFSF                NOPE, GO AROUND\n         MVI   TAPECCW1,X'3F'       FORWARD SPACE FILE\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         B     SENSE                GO AROUND\nNOFSF    EQU   *\n         CLI   ICOM,C'B'            DO WE WANT TO B-S-F\n         BNE   SENSE                NOPE, GO AROUND\n         MVI   TAPECCW1,X'2F'       BACK SPACE FILE\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\nSENSE    EQU   *\n         MVI   TAPECCW1,X'04'       SENSE\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         TM    TAPEINFO+1,B'00001000'\n         BO    LPT\n         MVC   LPOINT,=C'NLP'\n         B     MODECHEK\nLPT      EQU   *\n         MVC   LPOINT,=C'LPT'\nMODECHEK EQU   *\n         TM    TAPEINFO+6,B'00010000' CHECK TAPE MODE\n         BO    HIDEN\n         MVC   DENSITY,=C'1600'\n         B     PROTCHEK\nHIDEN    EQU   *\n         MVC   DENSITY,=C'6250'\nPROTCHEK EQU   *\n         TM    TAPEINFO+1,B'00000010' CHECK FOR FILE PROTECT\n         BO    PROT                 IT IS PROTECTED\n         MVC   PROTECT,=C'UNP '\n         B     RDYCHECK\nPROT     EQU   *\n         MVC   PROTECT,=C'PROT'\nRDYCHECK EQU   *\n         TM    TAPEINFO+1,B'01000000' IS TAPE READY\n         BO    TAPERDY              YES\n         MVC   READY,=C'NOTRD'\n         B     LINEOUT\nTAPERDY  EQU   *\n         MVC   READY,=C'READY'\n         TM    TAPEINFO+1,B'01001000'  CAN LABEL BE READ?\n         BNO   LINEOUT              NO DONT TRY\n         MVI   TAPECCW1,X'02'       READ FORWARD (VOL1)\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         MVC   VOLSAVE,TAPEINFO     SAVE VOLUME 1 RECORD\n         MVI   TAPECCW1,X'04'       SENSE\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         TM    TAPEINFO+6,B'00010000' CHECK TAPE MODE\n         BO    HIDEN2\n         MVC   DENSITY,=C'1600'\n         B     VOLCHECK\nCP       EQU   *\n         EXCP  (1)                  DO IT\n         WAIT  (1)                  AND BE PATIENT\n         BR    R6                   RETURN FROM WHERE YOU CAME\nHIDEN2   EQU   *\n         MVC   DENSITY,=C'6250'\nVOLCHECK EQU   *\n         CLC   VOLSAVE(3),=C'VOL'   CHECK FOR VOLUME LABEL\n         BE    HASVOL               YEP GET IT\n         MVC   VOLNO,=C'NO VOL'     NOPE\n         B     REWIND\nHASVOL   EQU   *\n         MVC   VOLNO,VOLSAVE+4      GET VOLUME NO\n         MVI   TAPECCW1,X'02'       READ FORWARD (HDR1)\n         LA    R1,TAPECCB1          GET READY TO EXCP\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         MVC   LBL,TAPEINFO+4       GET HDR LABEL\n         MVC   CREDATE,TAPEINFO+42  GET CREATE DATE\n         MVC   EXPDATE,TAPEINFO+48  GET EXP DATE\nREWIND   EQU   *\n         MVI   TAPECCW1,X'07'       INDICATE REWIND\n         LA    R1,TAPECCB1          GET READY TO REWIND\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\nLINEOUT  EQU   *\n         XC    TAPEINFO,TAPEINFO    CLEAR SENSE INFO\n         XC    ASPL1,ASPL1          CLEAR PARM LIST\n         LA    R1,LOGCCB1           PUT LINE TO CONSOLE\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         B     BUMPUB\nOWNDED   EQU   *\n         MVC   STATUS,=C'OWNED'\n         LA    R1,LOGCCB1           PUT LINE TO CONSOLE\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\nBUMPUB   EQU   *\n         LA    R9,8(R9)             POINT TO NEXT ENTRY IN PUB TABLE\n         LA    R8,2(R8)             POINT TO NEXT ENTRY IN PUBOWN TABLE\n         CLI   0(R9),X'FF'          END OF PUB TABLE?\n         BNZ   PUBCHECK\n         MVC   REPLY,SPACES         CLEAR INPUT AREA\n*        RELEASE (SYS099,SYS099)\n         LA    1,=C'$$BRELSE'\n         BAL   0,IJBZ0021\nRELTAB   DC    C'099099099099099099099099099099099099099099099099'\nIJBZ0021 SVC   2\n         LA    R1,ASKCCB1           GET REPLY FROM CONSOLE\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\n         CLI   REPLY,C'Q'           SEE IF THEY WANT TO QUIT\n         BE    END                  YEP THEY'RE QUITTERS\n         LA    R11,RELTAB           SET RELEASE TABLE ADDRESS\n         L     R8,PUBOWN            SET PUBOWN ADDRESS\n         L     R9,PUBTAB            SET ADDRESS OF PUB TABLE\n         B     PUBCHECK\nBADASG   EQU   *\n         MVC   LOGMSG1,=C'BAD ASSIGN       '\n         LA    R1,LOGCCB1           PUT LINE TO CONSOLE\n         BAL   R6,CP                GO EXECUTE CHANNEL PROGRAM\nEND      EQU   *\n         EOJ   RC=0                 TERMINATE PROGRAM\n*\n         REGS\nASPL1    DS    CL(ASGLNG)\nSAVEAREA DS    18F                  SAVE AREA FOR ASSGN MACRO\nLOGCCB1  CCB   SYSLOG,LOGCCW1\nLOGCCW1  CCW   X'09',LOGMSG1,X'20',L'LOGMSG1\nLOGMSG1  DS    0CL74\nCUU      DS    CL3\n         DC    C'  '\nSTATUS   DS    CL5\n         DC    C'  '\nREADY    DS    CL5\n         DC    C'  '\nPROTECT  DS    CL4\n         DC    C'  '\nDENSITY  DS    CL4\n         DC    C'  '\nLPOINT   DS    CL3\n         DC    C'  '\nVOLNO    DS    CL6\n         DC    C'  '\nLBL      DS    CL17\n         DC    C'  '\nCREDATE  DS    CL5\n         DC    C' '\nEXPDATE  DS    CL5\nSPACES   DC    CL80' '\nASKCCB1  CCB   SYSLOG,ASKCCW1\nASKCCW1  CCW   X'0A',REPLY,X'20',L'REPLY\nTAPECCB1 CCB   SYS010,TAPECCW1\nTAPECCW1 CCW   X'04',TAPEINFO,X'20',L'TAPEINFO\nTAPEINFO DS    CL80\nVOLSAVE  DS    CL80\nREPLY    DS    0CL5\nICOM     DS    CL1\nFILL     DS    CL1\nICUU     DS    CL3\nPUBTAB   DS    F\nPUBOWN   DS    F\nWORK1    DS    C\nWORK2    DS    H\nHWORD    DS    H\nDWORD    DS    D\nTABLE    DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         LTORG\n         END   TM\n/*\n// EXEC LNKEDT\n/&\n* $$ EOJ\n\nWill Townsley\nSystems Programmer\nBCISD (USA)                               c BCISD 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A05": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00[\\x00[\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 91, "newlines": 91, "modlines": 0, "user": "VSEUPDT"}, "text": "POWER commands from a program\n\nThe following program was originally developed to serve one\nparticular need, but is now widely used in our organization.\nOur Data Centre's method for handling system usage\naccounting of the batch VSE machine consists of collecting\ndata from the POWER job accounting file, merging it onto a\nhistory tape, and then periodically (usually monthly) running a\nreport sorted by the USER field available in the POWER\naccounting record.  (The EXEC we use for submitting a job\nfrom VM ensures that the VM user-id is placed into the\nPOWER JOB card.)\n\nThe use of the POWER \"PACCOUNT\" (\"J\") command allowed\nus to place the data onto tape, and the accounting information\nwas later deleted.  If, however, an unnoticed tape error\noccurred, the operator could mistakenly erase the accounting\nfile, thus completely losing all of the data.\n\nThe COMMAND program allows the use of the EXEC card\nPARM operand to pass an actual AR or POWER command to\nthe program, which in turn causes VSE to execute the\ncommand just as if it had been entered at the console.  We\noriginally used the COMMAND program to automate the\ndeletion of the POWER accounting data based on the return\ncode from the previous job step.  Thus, no operator\nintervention was needed and we prevented the possibility of\ndata loss.\n\nProvision has been made in the program to accept commands\nup to 50 characters in length.  If this is not sufficient for your\nneeds, simply increase the length of fields CMD and\nPARMAREA equally.\n\nNote that the PARM operand of the JCL EXEC statement\nplaces the actual data at offset 2 from the address found in the\nparameter list pointed to by register 1.  Thus, you will notice\nthat I incremented the register being used for the DSECT by 2.\n\n         TITLE 'COMMAND - EXECUTE ANY AR OR POWER COMMAND'\n         PRINT NOGEN\nCOMMAND  CSECT\n         SPACE 2\n*       THIS PROGRAM WILL EXECUTE ANY AR OR POWER COMMAND           *\n         SPACE 3\n         XR    R15,R15                 CLEAR OUT ERROR CODE\n         STM   R14,R12,12(R13)         DO STANDARD SAVES\n         BALR  R12,0\n         USING *,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(R13)\n         LR    R13,R15\n         SPACE 2\n         USING PARMS,R3                USE R3 FOR PASSED PARAMETERS\n         L     R3,0(R1)                LOAD IN ADDRESS OF POINTER\n         LA    R3,2(R3)                INCREMENT TO DATA\n         MVC   CMD,PARMAREA            MOVE IN THE COMMAND\n         SLR   0,0                     CLEAR R0\n         LA    R1,CMDPTR               POINT TO POINTER\n         SVC   30                      DO THE COMMAND\n         L     R13,SAVEAREA+4          NOW PREPARE TO LEAVE\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 2\nSAVEAREA DC    18F'0'\nCMDPTR   DC    AL2(L'CMD)\n         DC    AL4(CMD)\nCMD      DC    CL50' '\n         SPACE 2\n*                  R E G I S T E R   E Q U A T E S\n         SPACE 3\nPARMS    DSECT\nPARMAREA DS    CL50\n         END\n\nJCL to execute the COMMAND program.\n\n* $$ JOB JNM=TESTIT,CLASS=0\n* $$ LST CLASS=Q\n// JOB TESTIT  TEST THE USE OF THE COMMAND PROGRAM\n// EXEC COMMAND,SIZE=AUTO,                                             X\n               PARM='J DISK,MYFILE                                    '\n/*\n/&\n* $$ EOJ\n\nDavid M Wakser\nDirector MIS\nNational League for Nursing (USA)       c National League for Nursing 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E003A06": {"ttr": 3842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02\\x8e\\x02\\x8e\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 654, "newlines": 654, "modlines": 0, "user": "VSEUPDT"}, "text": "Slimming down VSE's printlog\n\nHave you ever wandered through a VSE printlog and decided\nthere were more messages than necessary?  This is what\nhappened in our shop.  Since I am a VM/VSE systems\nprogrammer, constantly looking for a more efficient way of\ndoing things, I decided to write an EXEC.\n\nBefore presenting the EXEC, let me describe the general flow:\n\no      A printlog is run in VSE and routed to a VM server\n      machine.\no      The server machine detects a reader file, determines that it\n      is a VSE printlog and invokes this EXEC with the\n      printlog's spool-id.\n\nThere are several points to keep in mind when looking at this EXEC:\n\no      A CMS file of SQL statistics is being created from SQL\n      SHOW commands recorded on the printlog.\n\no      The printlog is filtered and condensed by eliminating such\n      messages as 1Q34I \"task WAITING FOR WORK ON cuu\".\n\no      In addition, two extra pages are appended to the end -\n      these pages contain 'helpful' information that has been\n      extracted while processing the printlog.  The first page\n      contains an index of POWER jobname, time job began,\n      page number in the printlog, partition in which the job ran,\n      and a cancel flag if the job was cancelled.  The second\n      page contains a tape error summary for all the 4E10I \"\n      volume-id TR = nnn TW = nnn SIO = nnnnn\" messages.\n      Other 'helpful' information could be extracted and\n      formatted according to the needs of your shop.\n\nExamples of the reformatted printlog and the two extra pages\nare included as Figures 1, 2, and 3 respectively.\n\nNote that three other EXECs are called from the main EXEC.\nA listing of these EXECs is provided.\n\nOne final word - our environment is VM/SP Release 4 with\nVSE/SP 2.1.3 as the guest.  We are getting ready to upgrade to\nVM Release 6 and VSE/SP 4.1.2, and I feel confident that this\nEXEC will work just as well under the new software.\n\n\nARCH:VSC EXEC\n\n/********************************************************************/\n/**  EXEC MODE : INVOKED BY SUPRARCH EXEC IN THE ARCHIVE MACHINE   **/\n/**  FUNCTION  : FILTERS, CONDENSES, AND PRINTS THE VSE PRINTLOG.  **/\n/**              ALSO THE SQL STATS ARE EXTRACTED AND WRITTEN TO   **/\n/**              THE SQL STATS FILE.                               **/\n/**  FORMAT    : ARCH:VSC (SPOOLID)                                **/\n/**  USERS     : ARCHIVE                                           **/\n/**  FILE/TABLE: THE VSE PRINTLOG                                  **/\n/**  PARMLIST  : SPOOL-ID OF THE VSE PRINTLOG FILE                 **/\n/********************************************************************/\n/**  ERASE SOME OLD SQL STATS FILES  **/\nPARSE VALUE DATE(O) WITH YY '/' MM '/' .\nPARSE VALUE DATECALC(YY'/'MM'/01','O','70','-'),\n        WITH OLDYY '/' OLDMM '/' .\nRC = QUIET('ERASE SQL'OLDYY||OLDMM' STATS A')\nAA = TIME(R)\n/**  SET UP SOME VARIABLES                                         **/\nLINE_CNT   = '0'                 /* LINE COUNT ON A PAGE            */\nPAGE_CNT   = '1'                 /* PAGE COUNT                      */\nNEW_TIME   = '1'                 /* TIME FOR A TIME BREAK           */\nNEW_USER   = '0'                 /* TIME TO PRINT THE USERID        */\nOLD_PARTID = ''                  /* SAVE THE PREVIOUS PARTITION ID  */\nLOG_TIME   = '00:00:00'          /* SET UP THE INITIAL TIME         */\nLOG_DATE   = '00/00/00'          /* SET UP THE INITIAL DATE         */\nCHECK_PAGE = '1'                 /* CHECK FOR THE PAGE BREAK        */\nSQL_STATS  = '0'                 /* START WRITING SQL STATISTICS    */\nHEADER1    = SPREAD('VSE PRINTLOG',' ',1,' ',3)\nHEADER1    = CENTER(HEADER1,132)\n/**  ACCEPT THE SPOOLID OF THE PRINTLOG FILE                       **/\nARG SPOOLID\n/**  PUT THE READER ON HOLD IN CASE SOMETHING GOES AWRY  **/\nPARSE VALUE DIAG(8,'SPOOL READER HOLD') WITH DATA\n/**  ORDER THE PRINTLOG ENTRY IN THE READER QUEUE  **/\nPARSE VALUE DIAG(8,'ORDER * R 'SPOOLID) WITH DATA\n/**  LOCATE THE FIRST HEADER IN THE PRINTLOG LISTING               **/\n'EXECIO * CARD (LOC /OPTIONS SPECIFIED/ STEM HEADER.'\nIF RC > '0'\n   THEN DO\n           SAY 'ERROR: COULD NOT FIND THE HEADERS IN THE VSE PRINTLOG'\n           SAY 'ERROR: RC = 'RC\n           SIGNAL EXIT\n        END\n/**  SET UP THE HEADERS FOR THE PRINT FILE  **/\nCALL HEADERS                           /* PRINT THE FIRST HEADERS   */\n/**  DEFINE THOSE MESSAGES WHICH CAN BE SUPPRESSED                 **/\nMSG_TABLE = '1Q20I 1R75I 1Q34I 1I40I 1C39I 0D16D',\n            '1T20I K002I K004I K006I K481I K001I K008I',\n            'K029I K103I K088I 1S78I'\n/**  DEFINE THE VALID PARTITION IDS  **/\nPARTID_TABLE = 'AR BG F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB'\n/**  LOOP THROUGH THE PRINTLOG FILTERING AND REFORMATTING          **/\nJOB_INDEX = ''                         /* TABLE OF JOBS AND TIMES   */\nERRORS    = '0'                        /* COUNT OF TAPE ERROR MSGS  */\nDO FOREVER\n   CARD_REC = 'CARD_REC'               /* RESET PRINTLOG RECORD     */\n   CNTL     = 'CNTL'                   /* RESET CARRIAGE CONTROL    */\n   /**  READ THE NEXT RECORD IN THE FILE  **/\n   'EXECIO 1 CARD (VAR 'CARD_REC\n   IF RC > '0'\n      THEN LEAVE\n   /**  IS THIS THE END OF THE PRINTLOG?  **/\n   IF FIND(CARD_REC,'END OF UTILITY') > '0'\n      THEN DO\n              LOG_REC = COPIES(' ',10) /* WRITE A BLANK LINE        */\n              CALL WRITE_DETAIL\n              LOG_REC = COPIES(' ',10) /* WRITE A BLANK LINE        */\n              CALL WRITE_DETAIL\n              LOG_REC = CARD_REC       /* WRITE THE EOF MSG         */\n              CALL WRITE_DETAIL\n              CALL PRINT_INDEX         /* WRITE INDEX PAGE          */\n              CALL PRINT_TAPE_ERRORS   /* WRITE THE TAPE ERROR PAGE */\n              LEAVE                    /* GO TO THE EXIT            */\n           END\n   /**  LAYOUT THE PRINTLOG RECORD WITH DIFFERENT VIEWS  **/\n   PARSE VAR CARD_REC . 8  CON_LINE 85 .\n   PARSE VAR CARD_REC . 16 JOB_MSG 85 .\n   PARSE VAR CARD_REC . 16 DOS_CARD 23 .\n   PARSE VAR CARD_REC . 16 SUBSYS_MSG 24 SUBSYS_TEXT 85 .\n   PARSE VAR CARD_REC .  2 COUNT     7 .  8 REPLY   9 PART_ID  11 .,\n                        12 REPLY_ID 15 . 16 MSG_ID 21 MSG_TEXT 85 .\n   /**  NOW START ANALYZING THE VSE CONSOLE ENTRY  **/\n   SELECT\n     /**  IS THIS A PRINTLOG PAGE HEADER?  **/\n     WHEN FIND(CARD_REC,'OPTIONS SPECIFIED:') > '0'\n       THEN ITERATE\n     /**  IS THIS ANOTHER PRINTLOG PAGE HEADER?  **/\n     WHEN FIND(CARD_REC,'MESSAGE TEXT') > '0'\n       THEN ITERATE\n     /**  IS THIS A BLANK LINE?  **/\n     WHEN COUNT = ' ' & CON_LINE = ' '\n       THEN ITERATE\n     /**  IS THIS MESSAGE ID IN THE TABLE OF MESSAGES TO SKIP?  **/\n     WHEN FIND(MSG_TABLE,MSG_ID) > '0'\n        THEN ITERATE\n     /**   IS THIS A COMMENT? **/\n     WHEN SUBSTR(DOS_CARD,1,2) = '* '\n       THEN DO\n               LOG_REC = LOG_DATE COPIES(' ',9) PART_ID COPIES(' ',3),\n                         MSG_ID||MSG_TEXT\n               CALL WRITE_DETAIL\n               ITERATE\n            END\n     /**  IS THIS A NULL MESSAGE FROM A PARTITION?  **/\n     WHEN (SUBSTR(PART_ID,1,1) = 'F' | SUBSTR(PART_ID,1,1) = 'B') &,\n          MSG_ID = '*' & MSG_TEXT = ''\n       THEN ITERATE\n     /**  IS THIS A DITTO PROMPT?  **/\n     WHEN FIND(JOB_MSG,'DITTO FUNCTION ?') > '0'\n       THEN ITERATE\n     /**  IS CICS FINISHED INITIALIZING?  **/\n     WHEN SUBSYS_MSG = 'DFH1500' &,\n          FIND(SUBSYS_TEXT,'CONTROL IS BEING GIVEN TO CICS') = '0'\n       THEN ITERATE\n     /**  IS THIS A MESSAGE TELLING A JOB WAS RECEIVED IN READER?  **/\n     WHEN MSG_ID = '1Q47I'\n       THEN DO\n               PARSE VAR CARD_REC . '1Q47I' NEW_PARTID NEW_JOB .,\n                              'FROM LOCAL' USERID ', TIME=' LOG_TIME .\n               NEW_PARTID = STRIP(NEW_PARTID,B,' ')\n               PART_JOB.NEW_PARTID = NEW_JOB\n               USERID     = STRIP(USERID,B,' ')\n               IF USERID = ''          /* NO USERID ON MSG          */\n                  THEN USERID = 'LCL'  /* USE LOCAL AS USERID       */\n               NEW_TIME   = '1'\n               NEW_USER   = '1'\n               LOG_TIME   = RIGHT(LOG_TIME,8,'0')\n               NEW_JOB    = LEFT(NEW_JOB,8,'.')\n               JOB_INDEX  = JOB_INDEX NEW_JOB'='||LEFT(LOG_TIME,5)'.P',\n                            ||RIGHT((PAGE_CNT - 1),2,'0')'.'NEW_PARTID\n               ITERATE\n            END\n     /**  IS THIS A HIGHLIGHTED MESSAGE?  **/\n     WHEN REPLY = '*'\n       THEN DO\n               CHECK_PAGE = '1'        /* CHECK FOR PAGE OVERFLOW   */\n               LOG_REC    = COPIES(' ',18) PART_ID'     'JOB_MSG\n               CALL WRITE_DETAIL\n               CHECK_PAGE = '0'        /* DON'T CHECK               */\n               CNTL       = '+'        /* OVERLAY PREVIOUS LINE     */\n               CALL WRITE_DETAIL       /* WRITE SAME LINE AGAIN     */\n               CHECK_PAGE = '1'        /* START CHECKING AGAIN      */\n               ITERATE\n            END\n     /**  IS THIS A DATE AND TIME LINE?  **/\n     WHEN REPLY_ID = 'DAT'\n       THEN DO\n               PARSE VAR CARD_REC . 'DATE ' LOG_DATE ',CLOCK ' LOG_TIME,\n                                  ',DURATION' DURATION .\n               NEW_TIME = '1'\n               LOG_TIME = LEFT(LOG_TIME,8)\n               LOG_TIME = REPLACE(LOG_TIME,'/',':')\n               IF DURATION \u00ac= ''\n                  THEN DO\n                          DURATION = REPLACE(DURATION,'/',':')\n                          LOG_REC  = LOG_DATE LOG_TIME COPIES(' ',7),\n                                     'DURATION = 'DURATION\n                          CALL WRITE_DETAIL\n                          NEW_TIME = '0'\n                       END\n               ITERATE\n            END\n     /**  IS A JOB CANCELLING?  **/\n     WHEN INDEX(MSG_TEXT,'CANCELED.') > '0' &,\n          MSG_ID \u00ac= '0S12I'                   /* CICS CANCELLING?    */\n          THEN DO\n                 PARSE VAR MSG_TEXT . 'JOB, J_NAME 'CANCELED. ',\n                                    CANCEL_MSG\n                 IF J_NAME = 'NO NAME' /* NO JOB NAME ASSIGNED      */\n                    THEN DO\n                           LOG_REC = LOG_DATE COPIES(' ',9) PART_ID,\n                                     COPIES(' ',3) 'CAUSE =' CANCEL_MSG\n                           POINTER = CENTER('CANCEL->',10)\n                           LOG_REC = OVERLAY(POINTER,LOG_REC,10)\n                           CALL WRITE_DETAIL\n                           ITERATE\n                         END\n                 BB = LASTPOS('.'||PART_ID,JOB_INDEX)\n                 IF BB = '0'           /* NO ENTRY IN TABLE FOR JOB */\n                    THEN DO\n                           LOG_REC = LOG_DATE COPIES(' ',9) PART_ID,\n                                     COPIES(' ',3) 'CAUSE =' CANCEL_MSG\n                           POINTER = CENTER('CANCEL->',10)\n                           LOG_REC = OVERLAY(POINTER,LOG_REC,10)\n                           CALL WRITE_DETAIL\n                           ITERATE\n                         END\n                 CC = INDEX(JOB_INDEX,' ',BB)\n                 IF CC = '0'           /* ENTRY LAST IN TABLE       */\n                    THEN CC = LENGTH(JOB_INDEX) + 1\n                 DD = LASTPOS(' ',JOB_INDEX,BB) + 1\n                 /**  HAS THIS JOB CANCELLED ALREADY?  **/\n                 IF INDEX(SUBSTR(JOB_INDEX,DD,(CC - DD)),'-C') = '0'\n                    THEN JOB_INDEX = INSERT('-C',JOB_INDEX,(CC - 1))\n                 LOG_REC = LOG_DATE COPIES(' ',9) PART_ID,\n                           COPIES(' ',3) 'CAUSE =' CANCEL_MSG\n                 POINTER = CENTER('CANCEL->',10)\n                 LOG_REC = OVERLAY(POINTER,LOG_REC,10)\n                 CALL WRITE_DETAIL\n                 ITERATE\n               END\n     /**  IS THIS A VSE IPL MESSAGE?  **/\n     WHEN PART_ID = '**'\n       THEN DO\n               LOG_REC = COPIES(' ',8) CON_LINE\n               CALL WRITE_DETAIL\n               ITERATE\n            END\n     /**  IS THIS A TAPE ERROR MESSAGE?   **/\n     WHEN MSG_ID = '4E10I'\n       THEN DO\n               PARSE VAR CARD_REC . PART_ID . '4E10I' VOLSER DRIVE,\n                              'TR=' READ 'TW=' WRITE 'SIO=' SIO .\n               PART_ID = STRIP(PART_ID,B,' ')\n               ERRORS  = ERRORS + 1\n               IF DRIVE = ''           /* NO VOLSER PRESENT?       */\n                  THEN DO\n                          DRIVE  = CENTER(STRIP(VOLSER,B,' '),5)\n                          VOLSER = COPIES(' ',6)\n                       END\n                  ELSE DO\n                          DRIVE  = CENTER(STRIP(DRIVE,B,' '),5)\n                          VOLSER = STRIP(VOLSER,B,' ')\n                       END\n               READ  = STRIP(READ,L,'0')\n               WRITE = STRIP(WRITE,L,'0')\n               SIO   = STRIP(SIO,L,'0')\n               IF INDEX(PART_JOB.PART_ID,'PART_JOB') > '0' /* NO NAME*/\n                  THEN PART_JOB.PART_ID = LEFT(PART_ID,8,' ')\n               TAPE.ERRORS = PART_JOB.PART_ID'  'VOLSER'   'DRIVE' ',\n                             RIGHT(READ,6)'  'RIGHT(WRITE,6),\n                             RIGHT(SIO,5)\n            END\n     /**  IS THIS AN SQL MESSAGE?  **/\n     WHEN FIND(JOB_MSG,'COUNTERS RESET AT') > '0' |,\n          FIND(JOB_MSG,'COUNTER VALUES AT') > '0'\n       THEN DO\n               PARSE VAR CARD_REC . 'TIME=' LOG_TIME\n               NEW_TIME = '1'\n               LOG_TIME = LEFT(STRIP(LOG_TIME,B,\"'\"),8)\n               LOG_TIME = RIGHT(LOG_TIME,8,'0')\n            END\n     /**  IS THIS A CICS RESPONSE?  **/\n     WHEN FIND(JOB_MSG,'RESPONSE:') > '0'\n       THEN DO\n               PARSE VAR CARD_REC . 'TIME:' LOG_TIME 'DATE:' .\n               NEW_TIME = '1'\n               LOG_TIME = LEFT(STRIP(LOG_TIME,B,' '),8)\n               LOG_TIME = RIGHT(LOG_TIME,8,'0')\n               LOG_TIME = REPLACE(LOG_TIME,'.',':')\n            END\n     /**  IS THE LINE NONE OF THE ABOVE?  **/\n     OTHERWISE\n       NOP\n   END\n   /**  IS IT TIME TO WRITE SQL STATS TO THE SQL FILE?  **/\n   IF SQL_STATS\n      THEN DO\n             /**  IS THIS THE END OF SQL COMMAND RESPONSE?  **/\n             IF SUBSYS_MSG = 'ARI0065I'\n                THEN SQL_STATS = '0'   /* YES, TURN OFF FLAG        */\n                ELSE DO                /* NO, PROCESS COUNTERS      */\n                       PARSE VAR CARD_REC  . 47 LABEL 56 VALUE .\n                       VALUE   = STRIP(VALUE,B,' ')\n                       SQL_REC = ' 'LOG_DATE LOG_TIME LABEL,\n                                 RIGHT(VALUE,8,' ')\n                       'EXECIO 1 DISKW SQL'YY||MM' STATS A',\n                                  '(STRING 'SQL_REC\n                       IF RC > '0'\n                          THEN DO\n                                 SAY 'ERROR: COULD NOT WRITE TO THE',\n                                     'SQL STATS FILE.'\n                                 SAY 'ERROR: RC = 'RC\n                                 SIGNAL EXIT\n                               END\n                     END\n           END\n   /**  ARE THE SQL STATISTICS COMING UP?  **/\n   IF FIND(JOB_MSG,'COUNTER VALUES AT') > '0'\n      THEN SQL_STATS = '1'\n   /**  HAS THE USER CHANGED?  **/\n   IF NEW_USER & PART_ID = NEW_PARTID & DOS_CARD = '// JOB '\n      THEN DO\n              CON_LINE     = OVERLAY(USERID,CON_LINE,5,4)\n              USER_ON_LINE = '1'\n              NEW_USER     = '0'\n           END\n      ELSE USER_ON_LINE = '0'\n   /**  IS THE REPLY ID TO BE OVERLAID?  **/\n   IF FIND(PARTID_TABLE,PART_ID) > '0' & \u00ac USER_ON_LINE\n      THEN CON_LINE = OVERLAY('    ',CON_LINE,5,4)\n   /**  HAS TIME CHANGED?  **/\n   IF NEW_TIME\n      THEN DO\n              LOG_REC  = LOG_DATE LOG_TIME CON_LINE\n              NEW_TIME = '0'\n           END\n      ELSE LOG_REC = LOG_DATE COPIES(' ',8) CON_LINE\n   /**  IS THIS A USER ENTERED COMMAND?  **/\n   IF PART_ID \u00ac= '' & FIND(PARTID_TABLE,PART_ID) = '0'\n      THEN DO\n              ARROW   = CENTER('===>',10)\n              LOG_REC = OVERLAY(ARROW,LOG_REC,10)\n           END\n   /**  WRITE THE DETAIL RECORD  **/\n   CALL WRITE_DETAIL\n   CHECK_PAGE = '1'                    /* RESET PAGE OVERFLOW CHECK */\nEND\n/**  EXIT THIS EXEC                                               **/\nSYNTAX:\nEXIT:\n/**  CLOSE THE READER  **/\nPARSE VALUE DIAG(8,'CLOSE RDR') WITH DATA\n/**  TAKE THE READER OFF HOLD  **/\nPARSE VALUE DIAG(8,'SPOOL READER NOHOLD') WITH DATA\n/**  CLOSE THE PRINT FILE TO SEND IT ON ITS WAY  **/\nPARSE VALUE DIAG(8,'CLOSE PRT') WITH DATA\n/**  CLOSE THE SQL STATS FILE  **/\n'FINIS SQL 'YY||MM' STATS A'\n/**  PURGE THE PRINTLOG FILE  **/\nPARSE VALUE DIAG(8,'PURGE READER 'SPOOLID) WITH DATA\nBB = FORMAT(TIME(E),3,0)\nSAY 'It took 'BB' seconds to finish.'\n'DROPBUF'\nEXIT\n/**  PRINT THE DETAIL RECORD                                      **/\nWRITE_DETAIL:\nIF LINE_CNT >= '60' & CHECK_PAGE       /* TIME FOR A PAGE BREAK?    */\n   THEN CALL HEADERS\n/**  DETERMINE THE PROPER CARRIAGE CONTROL  **/\nSELECT\n  WHEN PART_ID = '  '                  /* A CONTINUATION LINE?      */\n    THEN CNTL = ' '                    /* YES, SINGLE SPACE         */\n  /**  IS THIS AN OPERATOR RESPONSE TO THE IMMEDIATE PREV PARTITION?**/\n  WHEN OLD_PARTID = 'F'||SUBSTR(PART_ID,1,1)           |, /* F1-F9  */\n       (SUBSTR(OLD_PARTID,2,1) = 'A' & PART_ID = '10') |, /* FA?    */\n       (SUBSTR(OLD_PARTID,2,1) = 'B' & PART_ID = '11') |, /* FB?    */\n       (OLD_PARTID = 'BG'            & PART_ID = '0')     /* BG?    */\n    THEN CNTL = ' '                    /* YES, SINGLE SPACE         */\n  WHEN OLD_PARTID \u00ac= PART_ID           /* PARTITION HAS CHANGED?    */\n    THEN DO\n            OLD_PARTID = PART_ID\n            IF CNTL = 'CNTL'           /* NO VALUE ASSIGNED YET?    */\n               THEN CNTL = '0'         /* NO, DOUBLE SPACE LINE     */\n         END\n  OTHERWISE\n    IF CNTL = 'CNTL'                   /* NO VALUE ASSIGNED YET?    */\n       THEN CNTL = ' '                 /* NO, SINGLE SPACE LINE     */\nEND\n/**  WRITE THE DETAIL RECORD  **/\n'EXECIO 1 PRINT (CC DATA STRING 'CNTL||LOG_REC\nIF RC > '0'\n   THEN DO\n           SAY 'ERROR: COULD NOT ROUTE THE PRINT LINE TO FILE.'\n           SAY 'ERROR: RC = 'RC\n           SIGNAL EXIT\n        END\n/**  DETERMINE HOW MANY LINES TO INCREMENT THE LINE COUNT  **/\nSELECT\n  WHEN CNTL = ' '                      /* LINE WAS SINGLE SPACED    */\n    THEN LINE_CNT = LINE_CNT + 1\n  WHEN CNTL = '0'                      /* LINE WAS DOUBLE SPACED    */\n    THEN LINE_CNT = LINE_CNT + 2\n  WHEN CNTL = '+'                      /* LINE WAS OVERLAID         */\n    THEN NOP\n  OTHERWISE\n    LINE_CNT = LINE_CNT + 1\nEND\nRETURN\n/**  PRINT THE PAGE HEADERS                                       **/\nHEADERS:\n'EXECIO 1 PRINT (CC DATA STRING 1'HEADER1\nIF RC > '0'\n   THEN DO\n           SAY 'ERROR: COULD NOT ROUTE THE FIRST HEADER TO THE FILE.'\n           SAY 'ERROR: RC = 'RC\n           SIGNAL EXIT\n        END\n'EXECIO 1 PRINT (CC DATA STRING 'COPIES(' ',120) 'PAGE = 'PAGE_CNT\nIF RC > '0'\n   THEN DO\n           SAY 'ERROR: COULD NOT ROUTE THE SECOND HEADER TO THE FILE.'\n           SAY 'ERROR: RC = 'RC\n           SIGNAL EXIT\n        END\n'EXECIO 1 PRINT (CC DATA STRING 'COPIES(' ',10)\nIF RC > '0'\n   THEN DO\n           SAY 'ERROR: COULD NOT ROUTE THE THIRD HEADER TO THE FILE.'\n           SAY 'ERROR: RC = 'RC\n           SIGNAL EXIT\n        END\n\nLINE_CNT = '3'\nPAGE_CNT = PAGE_CNT + 1\nRETURN\n/**  PRINT THE JOB NAME / START TIME / PAGE NUMBER INDEX          **/\nPRINT_INDEX:\nLINE_CNT = '1'                         /* RESET THE LINE COUNT      */\nPARSE VALUE 'FF' '00' WITH OLD_PARTID PART_ID\nLOG_REC = HEADER1                      /* WRITE THE HEADER          */\nCNTL    = '1'\nCALL WRITE_DETAIL\nLIT1 = 'JOB NAME ALPHABETICAL CROSS-REFERENCE'\nLOG_REC = CENTER(LIT1,132)\nCNTL    = ' '\nCALL WRITE_DETAIL\nLIT1 = 'JOB NAME / START TIME / PAGE NUMBER / PARTITION - CANCEL FLAG'\nLOG_REC = CENTER(LIT1,132)\nCNTL    = ' '\nCALL WRITE_DETAIL\nLOG_REC = COPIES('=',132)\nCNTL    = '0'\nCALL WRITE_DETAIL\nJOB_INDEX = REXXSORT(JOB_INDEX,'1','11','A')\nCHECK_PAGE = '0'                       /* DON'T CHECK FOR PAGE BREAK*/\nDO JI = 1 TO 55 UNTIL WORD(JOB_INDEX,JI) = ''\n   COL1 = LEFT(WORD(JOB_INDEX,JI),25,' ')\n   COL1 = REPLACE(COL1,'=',' ')\n   COL1 = REPLACE(COL1,'.',' ')\n   C2   = JI + 55                      /* POINT TO 2ND COLUMN      */\n   COL2 = LEFT(WORD(JOB_INDEX,C2),25,' ')\n   COL2 = REPLACE(COL2,'=',' ')\n   COL2 = REPLACE(COL2,'.',' ')\n   C3   = JI + 110                     /* POINT TO 3RD COLUMN      */\n   COL3 = LEFT(WORD(JOB_INDEX,C3),25,' ')\n   COL3 = REPLACE(COL3,'=',' ')\n   COL3 = REPLACE(COL3,'.',' ')\n   C4   = JI + 165                     /* POINT TO 4TH COLUMN      */\n   COL4 = LEFT(WORD(JOB_INDEX,C4),25,' ')\n   COL4 = REPLACE(COL4,'=',' ')\n   COL4 = REPLACE(COL4,'.',' ')\n   C5   = JI + 220                     /* POINT TO 5TH COLUMN      */\n   COL5 = LEFT(WORD(JOB_INDEX,C5),25,' ')\n   COL5 = REPLACE(COL5,'=',' ')\n   COL5 = REPLACE(COL5,'.',' ')\n   LOG_REC = COL1||COL2||COL3||COL4||COL5\n   CNTL    = ' '\n   CALL WRITE_DETAIL\nEND\nRETURN\n/**  PRINT THE TAPE ERROR SUMMARY                                 **/\nPRINT_TAPE_ERRORS:\nLINE_CNT = '1'                         /* RESET THE LINE COUNT      */\nLOG_REC = HEADER1                      /* WRITE THE HEADER          */\nCNTL    = '1'\nCALL WRITE_DETAIL\nLOG_REC = CENTER('TAPE ERROR SUMMARY',132)\nCNTL    = ' '\nCALL WRITE_DETAIL\nLOG_REC = COPIES(' ',10)               /* WRITE A BLANK LINE        */\nCNTL    = ' '\nCALL WRITE_DETAIL\nLOG_REC = '  JOB     VOLSER  TAPE    READ   WRITE   SIO'\nCNTL    = ' '\nCALL WRITE_DETAIL\nLOG_REC = '  NAME            DRIVE  ERRORS  ERRORS  COUNT'\nCNTL    = ' '\nCALL WRITE_DETAIL\nLOG_REC = '--------  ------  -----  ------  ------  -----'\nCNTL    = ' '\nCALL WRITE_DETAIL\n/**  LOOP THROUGH TAPE ERROR MESSAGES  **/\nIF ERRORS = '0'                        /* NO TAPE ERRORS            */\n   THEN DO\n           LOG_REC = 'THERE WERE NO TAPE ERRORS DURING THIS PERIOD.'\n           CNTL    = ' '\n           CALL WRITE_DETAIL\n        END\n   ELSE DO TE = 1 TO ERRORS            /* DISPLAY THE ERRORS        */\n           LOG_REC = TAPE.TE\n           CNTL    = ' '\n           CALL WRITE_DETAIL\n        END\n\nRETURN\n\n\nQUIET EXEC\n\n/**  EXEC MODE : INVOKED AS A REXX BUILT-IN FUNCTION               **/\n/**  FUNCTION  : IT ISSUES A COMMAND WHILE SUPPRESSING ALL         **/\n/**              GENERATED MESSAGES                                **/\n/**  PARMLIST  : A COMMAND TO EXECUTE                              **/\n/**  RETURNS   : THE RETURN CODE FROM THE COMMAND                  **/\nARG COMMAND                       /* ACCEPT THE PARAMETERS    */\nRESULT = '0'                      /* INIT THE RESULT          */\n/**  GET THE CP MSG SETTINGS  **/\nPARSE VALUE DIAG(8,'QUERY SET'),\n       WITH . 'MSG' MSG_SETTING ',' . 'EMSG' EMSG_SETTING ',' ,\n            . 'IMSG' IMSG_SETTING ',' .\nMSG_SETTING  = STRIP(MSG_SETTING,B,' ')\nEMSG_SETTING = STRIP(EMSG_SETTING,B,' ')\nIMSG_SETTING = STRIP(IMSG_SETTING,B,' ')\n/**  GET THE CMS MSG SETTING  **/\n'QUERY CMSTYPE (STACK LIFO'\nPULL . '= ' CMSTYPE_SETTING\n/**  TURN ALL MSG MODES OFF  **/\nPARSE VALUE DIAG(8,'SET MSG OFF') WITH DATA\nPARSE VALUE DIAG(8,'SET EMSG OFF') WITH DATA\nPARSE VALUE DIAG(8,'SET IMSG OFF') WITH DATA\nADDRESS CMS 'SET CMSTYPE HT'\n/**  GET THE XEDIT MSG SETTING  **/\n/**  AND SET IT OFF             **/\nADDRESS XEDIT 'COMMAND EXTRACT /MSGMODE'\nIF RC = '0'\n   THEN DO\n           ADDRESS XEDIT 'SET MSGMODE OFF'\n           IN_XEDIT = '1'\n        END\n    ELSE IN_XEDIT = '0'\n/**  EXECUTE THE COMMAND     **/\nIF IN_XEDIT\n   THEN ADDRESS XEDIT COMMAND\n   ELSE COMMAND\nCOMMAND_RC = RC\n/**  RESET THE CP MSG SETTINGS  **/\nPARSE VALUE DIAG(8,'SET MSG 'MSG_SETTING) WITH DATA\nPARSE VALUE DIAG(8,'SET EMSG 'EMSG_SETTING) WITH DATA\nPARSE VALUE DIAG(8,'SET IMSG 'IMSG_SETTING) WITH DATA\nIF IN_XEDIT\n   THEN ADDRESS XEDIT 'SET MSGMODE 'MSGMODE.1 MSGMODE.2\nADDRESS CMS 'SET CMSTYPE 'CMSTYPE_SETTING\nEXIT COMMAND_RC\n\n\nREPLACE EXEC\n\n/**  EXEC MODE : REXX BUILT-IN FUNCTION                            **/\n/**  FUNCTION  : REPLACE A SUBSTRING WITH ANOTHER SUBSTRING        **/\n/**              THIS IS SIMILIAR TO THE TRANSLATE FUNCTION        **/\n/**              EXCEPT THAT REPLACE WILL TRANSLATE ONE FOR MANY   **/\n/**              OR MANY FOR ONE.                                  **/\n/**  PARMLIST  : STRING TO BE EXAMINED;                            **/\n/**              SUBSTRING TO BE LOCATED ON;                       **/\n/**              SUBSTRING TO SUBSTITUTE                           **/\n/**  RETURNS   : EITHER -                                          **/\n/**               THE ORIGINAL STRING, BECAUSE THE SUBSTRING TO    **/\n/**                                    LOCATE WAS NOT FOUND        **/\n/**                OR                                              **/\n/**               THE ORIGINAL STRING WITH THE SUBSTITUTED         **/\n/**               SUBSTRING                                        **/\n/**  RECEIVE THE ARGUMENTS  **/\nPARSE ARG STRING,L_SUBSTR,S_SUBSTR\n/**  LOOP THROUGH THE STRING LOOKING FOR THE EACH OCCURRENCE  **/\n/**  OF THE FIRST SUBSTRING AND THEN REPLACE IT WITH THE      **/\n/**  SECOND SUBSTRING                                         **/\nSTRING_POS = '1'        /* LOCATION OF SUBSTRING TO BE REPLACED */\nDO FOREVER\n   STRING_POS = INDEX(STRING,L_SUBSTR,STRING_POS)\n   IF STRING_POS = '0'\n      THEN LEAVE\n   STRING     = DELSTR(STRING,STRING_POS,LENGTH(L,_SUBSTR))\n   INSERT_POS = STRING_POS - 1\n   STRING     = INSERT(S_SUBSTR,STRING,INSERT_POS,LENGTH(S_SUBSTR))\n   STRING_POS = STRING_POS + LENGTH(S_SUBSTR)\nEND\nEXIT:\nEXIT STRING\n\n\nREXXSORT EXEC\n\n/**  EXEC MODE : REXX BUILT-IN FUNCTION                            **/\n/**  FUNCTION  : BIF SORTS A VARIABLE PASSED.                      **/\n/**  PARMLIST  : VARIABLE NAME                                     **/\n/**              BEGINNING POSITION OF THE SORT FIELD              **/\n/**              LENGTH OF THE SORT FIELD                          **/\n/**              SORT SEQUENCE                                     **/\n/**  RETURNS   : THE SORTED VARIABLE                               **/\n/**  ACCEPT THE PARAMETERS  **/\nARG INPUT,BEG,LEN,ORDER\n/**  SET UP THE DEFAULTS  **/\nIF BEG = ''                        /* DEFAULT BEGINNING COLUMN IS 1 */\n   THEN BEG = '1'\nIF ORDER = ''                      /* DEFAULT ORDER IS ASCENDING    */\n   THEN ORDER = 'A'\nIF LEN = ''                        /* DEFAULT ENDING COLUMN IS *    */\n   THEN END = LENGTH(WORD(INPUT,1))\n   ELSE END = BEG + LEN\n/**  CREATE A TEMPORARY XEDIT FILE WITH INPUT  **/\nDO II = 1 TO WORDS(INPUT)\n   'EXECIO 1 DISKW $$TEMP SORT A (STRING 'WORD(INPUT,II)\nEND\n/**  NOW SORT THE FILE  **/\nQUEUE 'COMMAND DOWN 1'\nQUEUE 'MACRO SORT * 'ORDER BEG END\nQUEUE 'FILE'\n'XEDIT $$TEMP SORT A'\n/**  NOW READ THE FILE BACK IN  **/\n'EXECIO * DISKR $$TEMP SORT A (STEM SORT_LINE.'\n/**  REBUILD THE OUTPUT  **/\nRESULT = ''\nDO N = 1 TO SORT_LINE.0\n   RESULT = RESULT SORT_LINE.N\nEND\n/**  GET RID OF THE TEMP FILE  **/\nRC = QUIET('ERASE $$TEMP SORT A')\n/**  EXIT THE EXEC  **/\nEXIT:\nEXIT RESULT\n\nRandy Epperson\nSystems Programmer\nRay Co Inc (USA)                               c Ray Co Inc 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E003A07": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x12\\x00\\x12\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 18, "newlines": 18, "modlines": 0, "user": "VSEUPDT"}, "text": "VSE/ESA - an early user experience - revisited\n\nIn issue 2 of VSE Update we published an article by Keith\nNush describing his experiences when installing VSE/ESA.  In\nthat article Keith said \"Computer Associates is using ESA as an\nexcuse for increasing prices.  You now have to pay extra for an\nESA feature (for every product of theirs you have) that lets the\nproduct work on VSE/ESA.  This is true even if you are\nalready leasing the product.  This ESA feature charge is costing\nmy company thousands of dollars.  Computer Associates is the\nonly company I know of that is doing this\".\n\nComputer Associates in the UK have written to say \"all our\nVSE products already support VSE/ESA.  All our VSE\nproducts can run under VSE/ESA without payment of any\nadditional licence or maintenance fee.  We have developed for\ncertain of our VSE products chargeable, but optional, ESA\nproduct modules that exploit the ESA extension of VSE\".\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E003A08": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xb9\\x00\\xb9\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 185, "newlines": 185, "modlines": 0, "user": "VSEUPDT"}, "text": "PF key support for VSE console\n\nWe are running VSE/SP 3.2.2 and I have noticed that IBM has\nsome undocumented supervisor commands, which may be\ninteresting for every VSE system programmer, but take care\nwhen using these commands for the first time!  I have found\nthese commands and the parameters by trial and error and they\nmight not be complete.\n\nThese commands are: DEBUG, GETVIS, LOCATE, PFKEY,\nPRTYIO, SHOW, STACK, STATUS and TAPE.\n\nPFKEY and STACK are very nice, because now you have the\nfeatures you always wanted: ie retrieve key on VSE, and create\nshort names for long commands.  It is an IBM solution which\ndoes not require changes in object code.\n\n\nPFKEY\n\nFormat of command:\n\n      PFKEY (ON PF10)\n\nIt is not standard to have a retrieve key for the VSE console.  If\na long command has been entered at the console and it contains\nan error, the whole command must be rekeyed.  With this\ncommand you can activate PF key support for VSE on PF10,\nalthough you could use any key you wanted.\n\nTo activate this support you have to reassemble your supervisor\nwith the following undocumented options:\n\no      FOPT  - PARAMETER: DEBUG=YES\no      IOTAB -PARAMETER: DEBUG=4K\n\nExample supervisor generation\n\nSUPRV ID=T,                     SUPERVISOR $$A$SUPT                C\n      MODE=370,                 MODE 370                           C\n      NPARTS=9                  9 PARTITIONS\nFOPT  DASDSHR=NO,               NO DASD SHARING                    C\n      DEBUG=YES,        <---    DEBUG ON FOR PF-KEYS               C\n      FASTTR=YES,               FAST CCW TRANSLATION               C\n      RPS=YES,                  ROT. POS. SENS. ON                 C\n      USERID='SUPRV.WITH.PFKEY' SUPERVISOR IDENTIFIER MESSAGE\nIOTAB NPGR=2295,                255 X 9 PROG. LOG. UNITS           C\n      DEBUG=4K,         <---    4K DEBUGGING AREA FOR PF-KEYS      C\n      IODEV=254                 MAX I/O DEV.\n\nIf you do not have the debug option on, message \"1I01I\nINVALID COMMAND\" will appear.\n\nThe major disadvantage of these definitions is a little\nperformance degradation (I think about 1 percent).\n\nYou must change and catalogue the IPL procedure to use the\nnew supervisor.\n\n      01F,$$A$SUPT,VSIZE=40M,VIO=512K,VPOOL=64K,N,NOLOG\n\nNext a VSE IPL must be performed.  Once the system is up the\nfollowing commands must be entered:\n\n      DEBUG\n      PFKEY ON PF10\n\nThis will ensure that the debug option is on and set the retrieve\nkey on PF10.\n\nTo test the retrieve key function you can adopt the following\nprocedure.  Type in MAP; MAP output is shown.  Press PF10;\nMAP command is shown again.  Press the enter key and the\nMAP output is reshown.\n\nThe set up works with VSE/SP 3.3.2.\n\n\nSTACK\n\nFormat of command:\n\n      STACK short!command\n\nWith this command you can shorten every command for\nPOWER, VTAM or OCCF!  Your operator will be astonished\nif you type in 'VB' and on the VSE console comes the VTAM\nbuffer statistic or you display the POWER queue by typing in\n'PD'.  For example:\n\n      VB!D NET,BFRUSE\n\nCommand 'VB' will show you VTAM buffer statistic.\n\nNote: no blank characters should be between the short name\nand the command; the separator should be an exclamation mark.\n\n\nDEBUG\n\nFormat of command:\n\n      DEBUG (on | off)\n\nDEBUG without parameter shows actual debug status.\nDEBUG ON activates IBM internal supervisor debug mode.\nDEBUG OFF deactivates IBM internal supervisor debug mode.\n\n\nGETVIS\n\nFormat of command:\n\n      GETVIS (PARTITION)\n\nDisplays GETVIS statistic of an active partition\n\n\nLOCATE\n\nFormat of command:\n\n      LOCATE ' SEARCH-STRING '\n\nThis will locate a string in storage from 00000 to FFFFFF.\n\nEvery occurrence is shown with AR+15, and you must answer\nwith '15'.  '15 END' stops locating.  For example:\n\n      LOCATE 'POWER'\n\n\nPRTYIO\n\nFormat of command:\n\n      PRTYIO (OFF|PARTITION)\n\nThis works like the PRTY command.\n\nWith this command you can favour I/Os for special partitions.\nFor example:\n\n      PRTYIO F2,F3\n\n\nSHOW\n\nFormat of command:\n\n      SHOW ADR.LEN\n\nShows storage on address 'ADR' in length of 'LEN'.  For\nexample:\n\n      SHOW 000001.0F\n\n\nSTATUS\n\nFormat of command:\n\n      STATUS (iodev)\n\nDisplays status of all subtasks in a partition or for an I/O\ndevice.  For example:\n\n      STATUS 00E\n\n\nTAPE\n\nFormat of command:\n\n      TAPE (run=off,unl=unl)\n'\nTAPE ' without operands shows tape status.\n'TAPE ' with operands changes tape's status.  For example:\n\n      TAPE RUN=ON\n\nWalter Fuchs\nSystems Programmer (Germany)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E003A09": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02\\x1c\\x02\\x1c\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 540, "newlines": 540, "modlines": 0, "user": "VSEUPDT"}, "text": "DL/I HDAM database management\n\nDL/I HDAM database management is a set of two COBOL\nprograms that are used to evaluate any DL/I HDAM database.\nThis is very useful when you need to calculate the size of the\ndatabase.\n\nThe first program, DLIRAPS, will read all the Control\nIntervals (blocks) in a DL/I HDAM database and calculate the\nnumber of root anchor points.  This value is specified in the\nDBD control statement as the second parameter in\nRMNAME=.  The input control card specifies the database\nname and the new value that you want to specify for the root\nanchor points.  This program will produce both a report and\ncard-image output showing each root anchor point and the total\nnumber of records for each one.  The card output can be used\nin a graphics program such as Lotus.\n\nThe second program, DLIRLEN, will read any DL/I HDAM\ndatabase and calculate the maximum number of bytes for a\ndatabase record. This value is specified in the DBD control\nstatement as the fourth parameter in RMNAME=.  The input\ncontrol card specifies the database segment name and the\nlength of each segment.  One control card is needed for each\nsegment on the database.  This program will produce both a\nreport and card-image output showing the maximum number of\nbytes per HDAM database segment.  The card output can be\nused in a graphics program such as Lotus.\n\n\nDLIRAPS\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.   DLIRAPS.\n       REMARKS.  THE PURPOSE OF THIS PROGRAM IS TO EVALUATE A DL/I\n                HDAM DATABASE.  THIS PROGRAM WILL READ ALL THE CONTROL\n                INTERVALS (BLOCKS) IN A DL/I HDAM DATABASE AND CALCULATE\n                THE NUMBER OF ROOT ANCHOR POINTS.  THE DATABASE IS\n                DEFINED AS A VSAM ENTRY SEQUENTIAL DATASET (ESDS).\n                 FIRST, THE PROGRAM WILL READ A CONTROL CARD SPECIFYING\n                THE MAXIMUM NUMBER OF ROOT ANCHOR POINTS IN THE DBDGEN\n                RMNAME= PARAMETER.\n                 NEXT, THE DL/I HDAM DATABASE IS READ AND THE TOTAL\n                NUMBER OF ROOT ANCHOR POINTS PER CONTROL INTERVAL IS\n                CALCULATED.  A COUNT OF THE TOTAL NUMBER OF ROOT ANCHOR\n                POINTS IN EACH CONTROL INTERVAL IS ACCUMULATED AND IS\n                DISPLAYED AT THE END OF THE PROGRAM.  IF A CONTROL\n                INTERVAL DOES NOT HAVE ANY ROOT ANCHOR POINTS, THEN A\n                COUNT IS ALSO ACCUMULATED AND DISPLAYED.\n                 THE PUNCHED CARDS HAVE THE SAME INFORMATION AS THE\n                PRINTOUT.  THESE CARDS CAN BE USED TO DOWNLOAD IT INTO\n                A GRAPHICS PROGRAM SUCH AS LOTUS.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT CARD-FILE   ASSIGN SYS016-UR-2540R-S.\n           SELECT DLIRAPS     ASSIGN SYS050-AS-DLIRAPS\n               FILE STATUS IS FILE-STATUS1.\n           SELECT PUNCH-FILE  ASSIGN SYS017-UR-2540P-S.\n           SELECT PRINT-FILE  ASSIGN SYS018-UR-1403-S.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  CARD-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 80 CHARACTERS\n               LABEL RECORDS ARE OMITTED.\n       01  CARD-REC                         PIC X(80).\n       FD  DLIRAPS\n           LABEL RECORDS ARE STANDARD.\n       01                  FILLER           PIC X(4096).\n       FD  PUNCH-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 80 CHARACTERS\n               LABEL RECORDS ARE OMITTED.\n       01  PUN-REC                          PIC X(80).\n       FD  PRINT-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 133 CHARACTERS\n               LABEL RECORDS ARE OMITTED\n               DATA RECORD IS PRINT-REC.\n       01  PRT-REC.\n           03  PRT-CC                       PIC X.\n           03              FILLER           PIC X(132).\n       WORKING-STORAGE SECTION.\n       77  PGM-ID                           PIC X(10)   VALUE 'DLIRAPS'.\n       77  TIME-COMPILED                    PIC X(16)   VALUE      ' '.\n       77  PAGE-CNT              COMP-3     PIC 999     VALUE        0.\n       77  LINE-CNT              COMP-3     PIC S99     VALUE       +0.\n       77  FILE-STATUS1                     PIC XX      VALUE      ' '.\n       77  X                     COMP SYNC  PIC S9(4)   VALUE       +0.\n       77  I                     COMP SYNC  PIC S9(4)   VALUE       +0.\n       77  ID-Y                             PIC S9(4)   VALUE       +0.\n       77  ZORRO                 COMP SYNC  PIC S9(4)   VALUE       +0.\n       77  NUM-RAPS              COMP-3     PIC S9(9)   VALUE       +0.\n       77  REC-IN                COMP-3     PIC S9(9)   VALUE       +0.\n      *    DLI HDAM DATA BASE LAYOUT\n       01  WORK-AREA.\n           03  WA-FSAP.\n               05  WA-FSAP1       COMP      PIC S9(4).\n               05  WA-FSAP2       COMP      PIC S9(4).\n           03  WA-RAPS OCCURS 200 TIMES DEPENDING ON X.\n               05  WA-RAPS-ELE    COMP      PIC S9(8).\n      *    CONTROL CARD SPECIFIES TOTAL NUMBER OF ROOT ANCHOR POINTS\n       01  CONTROL-CARDS.\n           03  CC-DB-NAME                   PIC X(9).\n           03  CC-DB-RAPS                   PIC 999.\n           03              FILLER           PIC X(68).\n      *    TOTAL NUMBER OF ROOT ANCHOR POINTS PER CONTROL INTERVAL\n      *    TABLE WILL HANDLE MAXIMUM OF 200 ROOT ANCHOR POINTS\n       01  TABLE-RAPS-COUNT.\n           03  TBL-COUNT OCCURS 200 TIMES INDEXED BY Y\n                                            PIC S9(9) COMP-3.\n       01  REPORT-TITLES.\n           03  REPORT-TITLE-1               PIC X(44)    VALUE\n                         '                        DLI HDAM RAPS COUNT '.\n       01  HEAD-LINE-1.\n           03              FILLER           PIC X(9) VALUE\n                                                            '1DLIRAPS '.\n           03              FILLER           PIC X(17) VALUE         ' '.\n           03  HD-1-REPORT-TITLE            PIC X(44) VALUE         ' '.\n           03              FILLER           PIC X(26) VALUE         ' '.\n           03  HD-1-RUN-DATE                PIC X(8)  VALUE         ' '.\n           03              FILLER           PIC X(8)  VALUE         ' '.\n           03  HD-1-RUN-TIME                PIC X(8)  VALUE         ' '.\n           03              FILLER           PIC X(5)  VALUE         ' '.\n           03              FILLER           PIC X(5)  VALUE     'PAGE '.\n           03  HD-1-PAGE-NO                 PIC ZZZ.\n       01  HEAD-LINE-2.\n           03              FILLER           PIC X(56)  VALUE\n             '0  RAPS PER              NUMBER                         '.\n           03              FILLER           PIC X(77)  VALUE        ' '.\n       01  HEAD-LINE-3.\n           03              FILLER           PIC X(56)  VALUE\n             '      CI                 OF C/I                         '.\n           03              FILLER           PIC X(77)  VALUE        ' '.\n       01  DETL-LINE-1.\n           03              FILLER           PIC XXX.\n           03  DETL-SUB                     PIC Z(8).\n           03              FILLER           PIC X(12).\n           03  DETL-COUNT                   PIC Z(8).\n           03              FILLER           PIC X(102).\n       PROCEDURE DIVISION.\n           MOVE WHEN-COMPILED TO TIME-COMPILED.\n           DISPLAY 'BEGIN PROGRAM ' PGM-ID TIME-COMPILED UPON CONSOLE.\n           MOVE SPACES          TO  WORK-AREA.\n           SET Y                TO  ZORRO.\n           MOVE CURRENT-DATE    TO  HD-1-RUN-DATE.\n           MOVE TIME-OF-DAY     TO  HD-1-RUN-TIME.\n       100-OPEN-FILES.\n           OPEN INPUT  DLIRAPS.\n           IF FILE-STATUS1 NOT = '00'\n               DISPLAY 'OPEN ERROR ON DLIRAPS ' FILE-STATUS1\n                                   GO TO 999-END-PROGRAM.\n           OPEN INPUT CARD-FILE.\n           OPEN OUTPUT PRINT-FILE.\n           OPEN OUTPUT PUNCH-FILE.\n       10-READ-CARDS.\n           READ CARD-FILE INTO CONTROL-CARDS AT END\n               DISPLAY 'MISSING OR INVALID CONTROL CARD' UPON CONSOLE\n               DISPLAY 'MISSING OR INVALID CONTROL CARD'\n               STOP RUN.\n           MOVE CC-DB-RAPS  TO  X.\n       20-INITIALIZE-TABLE.\n           SET Y UP BY +1.\n           IF Y > 201\n                                   GO TO 100-READ-DLIRAPS.\n           MOVE ZEROS  TO  TBL-COUNT (Y).\n           GO TO 20-INITIALIZE-TABLE.\n       100-READ-DLIRAPS.\n           READ DLIRAPS INTO WORK-AREA AT END\n                                   GO TO 999-END-PROGRAM.\n      *    BYPASS DLI CONTROL RECORD\n           ON 1\n                                   GO TO 100-READ-DLIRAPS.\n      *    BYPASS DLI BIT MAP\n           IF WA-FSAP2  =  1\n                                   GO TO 100-READ-DLIRAPS.\n           ADD 1       TO  REC-IN.\n           MOVE ZEROS  TO  NUM-RAPS.\n           PERFORM 200-CALCULATE-RAPS  THRU  250-CALCULATE-EXIT\n                                      VARYING I FROM 1 BY 1 UNTIL I > X.\n           IF NUM-RAPS = ZEROS\n               SET Y  TO  X\n               SET Y  UP BY +1\n               ADD 1  TO  TBL-COUNT (Y)\n           ELSE\n               SET Y  TO  NUM-RAPS\n               ADD 1  TO  TBL-COUNT (Y).\n           GO TO 100-READ-DLIRAPS.\n       200-CALCULATE-RAPS.\n      *    IF WA-RAPS-ELE IS NOT ZEROS, THEN IT'S A RAP\n           IF WA-RAPS-ELE (I) NOT EQUAL ZEROS\n               ADD 1 TO NUM-RAPS.\n       250-CALCULATE-EXIT.\n           EXIT.\n       999-END-PROGRAM.\n           PERFORM 1000-PRINT-HEADINGS THRU 1100-RETURN-EXIT.\n           CLOSE DLIRAPS.\n           CLOSE PRINT-FILE.\n           CLOSE CARD-FILE.\n           CLOSE PUNCH-FILE.\n           DISPLAY 'TOTAL CI READ ' REC-IN UPON CONSOLE.\n           DISPLAY 'END - DLIRAPS'         UPON CONSOLE.\n           STOP RUN.\n       1000-PRINT-HEADINGS.\n           MOVE REPORT-TITLE-1  TO  HD-1-REPORT-TITLE.\n           PERFORM 8010-PRINT-HEAD-1.\n           PERFORM 8020-PRINT-HEAD-2.\n           PERFORM 8030-PRINT-HEAD-3.\n           MOVE SPACES TO DETL-LINE-1.\n           PERFORM 8100-PRINT-DETAIL-LINE.\n       1050-RETURN-ROUTINE.\n           ADD 1 TO X.\n           PERFORM 1200-PRINT-DETAIL THRU 1250-PRINT-DETAIL-EXIT\n               VARYING Y FROM 1 BY 1 UNTIL Y > X.\n       1100-RETURN-EXIT.\n           EXIT.\n       1200-PRINT-DETAIL.\n           IF LINE-CNT > 52\n               PERFORM 1000-PRINT-HEADINGS.\n           MOVE ' '            TO  DETL-LINE-1.\n           SET  ID-Y           TO  Y.\n           MOVE ID-Y           TO  DETL-SUB.\n           MOVE TBL-COUNT (Y)  TO  DETL-COUNT.\n           ADD 1               TO  LINE-CNT.\n           PERFORM 8100-PUNCH-DETAIL-LINE.\n           PERFORM 8100-PRINT-DETAIL-LINE.\n       1250-PRINT-DETAIL-EXIT.\n           EXIT.\n       MISC-RTNS SECTION.\n       8010-PRINT-HEAD-1 SECTION.\n           MOVE CURRENT-DATE  TO  HD-1-RUN-DATE.\n           MOVE TIME-OF-DAY   TO  HD-1-RUN-TIME.\n           ADD 1              TO  PAGE-CNT.\n           MOVE PAGE-CNT      TO  HD-1-PAGE-NO.\n           WRITE PRT-REC FROM HEAD-LINE-1  AFTER POSITIONING PRT-CC.\n       8020-PRINT-HEAD-2 SECTION.\n           WRITE PRT-REC FROM HEAD-LINE-2 AFTER POSITIONING PRT-CC.\n       8030-PRINT-HEAD-3 SECTION.\n           WRITE PRT-REC FROM HEAD-LINE-3 AFTER POSITIONING PRT-CC.\n       8100-PRINT-DETAIL-LINE SECTION.\n           WRITE PRT-REC FROM DETL-LINE-1 AFTER POSITIONING PRT-CC.\n           MOVE SPACES   TO  DETL-LINE-1.\n       8100-PUNCH-DETAIL-LINE SECTION.\n           WRITE PUN-REC FROM DETL-LINE-1.\n\n\nDLIRLEN\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.   DLIRLEN.\n       REMARKS.  THE PURPOSE OF THIS PROGRAM IS TO EVALUATE A DL/I\n                HDAM DATABASE.  THIS PROGRAM WILL READ ANY DL/I HDAM\n                DATABASE AND CALCULATE THE MAXIMUM NUMBER OF BYTES IN A\n                DATABASE SEGMENT.  THIS INFORMATION IS USEFUL IN\n                DETERMINING THE VALUE TO USE FOR THE FOURTH PARAMETER\n                OF RMNAME= IN THE DBD STATEMENT FOR AN HDAM DATABASE.\n                  THIS PARAMETER SPECIFIES THE MAXIMUM NUMBER OF BYTES\n               OF A DATABASE SEGMENT THAT CAN BE STORED IN THE ROOT\n               ADDRESSABLE AREA IN A SERIES OF INSERTS UNBROKEN BY A\n               CALL TO ANOTHER DATABASE RECORD.\n                 FIRST, THE PROGRAM WILL READ CONTROL CARDS SPECIFYING\n                THE SEGMENT NAME AND THE MAXIMUM NUMBER OF BYTES FOR\n                THIS SEGMENT.\n                 NEXT, THE DL/I HDAM DATABASE IS READ AND THE MAXIMUM\n                NUMBER OF BYTES PER HDAM DATABASE SEGMENT IS CALCULATED\n                AND A COUNT OF THE TOTAL NUMBER IS ACCUMULATED AND IS\n                DISPLAYED AT THE END OF THE PROGRAM.\n                 THE PUNCHED CARDS HAVE THE SAME INFORMATION AS THE\n                PRINTOUT.  THESE CARDS CAN BE USED TO DOWNLOAD INTO\n                A GRAPHICS PROGRAM SUCH AS LOTUS.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT  CARD-FILE  ASSIGN SYS016-UR-2540R-S.\n           SELECT  PUNCH-FILE ASSIGN SYS017-UR-2540P-S.\n           SELECT  PRINT-FILE ASSIGN SYS018-UR-1403-S.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  CARD-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 80 CHARACTERS\n               LABEL RECORDS ARE OMITTED.\n       01  CARD-REC                         PIC X(80).\n       FD  PUNCH-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 80 CHARACTERS\n               LABEL RECORDS ARE OMITTED.\n       01  PUN-REC                          PIC X(80).\n       FD  PRINT-FILE\n               RECORDING MODE F\n               RECORD CONTAINS 133 CHARACTERS\n               LABEL RECORDS ARE OMITTED.\n       01  PRT-REC.\n           03  PRT-CC                       PIC X.\n           03              FILLER           PIC X(132).\n           EJECT\n       WORKING-STORAGE SECTION.\n       77  PGM-ID                           PIC X(10)   VALUE 'DLIRLEN'.\n       77  TIME-COMPILED                    PIC X(16)   VALUE      ' '.\n       77  LINE-CNT            COMP-3       PIC S99     VALUE      +99.\n       77  PAGE-CNT            COMP-3       PIC 999     VALUE        0.\n       77  SEGMENT-LENGTH-A    COMP-3       PIC S9(5)   VALUE       +0.\n       77  SEGMENT-LENGTH-B    COMP-3       PIC S9(5)   VALUE       +0.\n       77  HOLD-KEY                         PIC X(19)   VALUE      ' '.\n       77  ZORRO               COMP SYNC    PIC S9(4)   VALUE       +0.\n       77  ID-Y                             PIC S9(4)   VALUE       +0.\n      *    CONTROL CARD SPECIFIES MAXIMUM LENGTH OF EACH SEGMENT\n       01  CONTROL-CARDS.\n           03  CC-SEGMENT-NAME              PIC X(9).\n           03  CC-SEGMENT-LENGTH            PIC 999.\n           03              FILLER           PIC X(68).\n       01  TABLE-CARDS.\n           03  TBL-SEGMENTS OCCURS 20 TIMES INDEXED BY X.\n               05  TBL-SEG-NAME             PIC X(8).\n               05  TBL-SEG-LENGTH    COMP-3 PIC S9(3).\n      *    MAXIMUM NUMBER OF BYTES PER HDAM DATA BASE RECORD\n      *    TABLE WILL HANDLE MAXIMUM OF 20 SEGMENTS PER DATA BASE\n       01  TABLE-LENGTH.\n           03  TBL-COUNT OCCURS 1001 TIMES INDEXED BY Y\n                                            PIC S9(9) COMP-3.\n       01  REPORT-TITLES.\n           03  REPORT-TITLE-1               PIC X(50)    VALUE\n                   ' COPICS DATA BASE MEDIUM RECORD LENGTH REPORT FOR '.\n           03  REPORT-TITLE-2               PIC X(50)    VALUE\n                   '                                                  '.\n           03  REPORT-TITLE-3               PIC X(50)    VALUE\n                   '                                                  '.\n       01  HEAD-LINE-1.\n           03              FILLER           PIC X(11) VALUE\n                                                          '1  DLIRLEN-'.\n           03  HD-1-RPT-NO                  PIC X     VALUE         ' '.\n           03              FILLER           PIC X(10) VALUE         ' '.\n           03  HD-1-REPORT-TITLE            PIC X(50) VALUE         ' '.\n           03  HD-1-DBD-NAME                PIC X(18) VALUE         ' '.\n           03              FILLER           PIC X(5)  VALUE     'DATE '.\n           03  HD-1-RUN-DATE                PIC X(8)  VALUE         ' '.\n           03              FILLER           PIC X(8)  VALUE\n                                                             '   TIME '.\n           03  HD-1-RUN-TIME                PIC XXBXXBXX.\n           03              FILLER           PIC X(11) VALUE\n                                                          '      PAGE '.\n           03  HD-1-PAGE-NO                 PIC ZZZ.\n       01  HEAD-LINE-2.\n           03              FILLER           PIC X(55)  VALUE\n              '0   MAXIMUM              NUMBER                        '.\n           03              FILLER           PIC X(78)  VALUE\n                              '                                       '.\n       01  HEAD-LINE-3.\n           03              FILLER           PIC X(55)  VALUE\n              '    REC LEN              PER DB                        '.\n           03              FILLER           PIC X(78)  VALUE\n                              '                                       '.\n       01  DETL-LINE-1.\n           03              FILLER           PIC XXX.\n           03  DETL-SUB                     PIC Z(8).\n           03              FILLER           PIC X(12).\n           03  DETL-COUNT                   PIC Z(8).\n           03              FILLER           PIC X(102).\n       01  FUNCTIONS       COPY FUNCTINS.\n       01  SEGMENT-AREA                     PIC X(1000).\n\n       LINKAGE SECTION.\n       01  PCB1            COPY PCB1.\n           EJECT\n       PROCEDURE DIVISION.\n           ENTRY 'DLITCBL' USING PCB1.\n           MOVE WHEN-COMPILED TO TIME-COMPILED.\n           DISPLAY 'BEGIN PROGRAM ' PGM-ID TIME-COMPILED UPON CONSOLE.\n           MOVE HIGH-VALUES TO  TABLE-CARDS.\n           MOVE ZEROS       TO  TABLE-LENGTH.\n           SET X            TO  ZORRO.\n           SET Y            TO  ZORRO.\n           OPEN INPUT CARD-FILE OUTPUT PRINT-FILE PUNCH-FILE.\n       10-READ-CARDS.\n           READ CARD-FILE INTO CONTROL-CARDS AT END\n                                   GO TO 20-INITIALIZE-TABLE.\n           SET X UP BY +1.\n           IF X > 20\n               DISPLAY 'SEGMENT INPUT CARDS EXCEED 20' UPON CONSOLE\n               DISPLAY 'SEGMENT INPUT CARDS EXCEED 20'\n               DISPLAY 'INCREASE TABLE OCCURS        ' UPON CONSOLE\n               DISPLAY 'INCREASE TABLE OCCURS        '\n               GOBACK.\n           MOVE CC-SEGMENT-NAME    TO  TBL-SEG-NAME   (X).\n           MOVE CC-SEGMENT-LENGTH  TO  TBL-SEG-LENGTH (X).\n           GO TO 10-READ-CARDS.\n       20-INITIALIZE-TABLE.\n           SET Y UP BY +1.\n           IF Y > 1001\n                                   GO TO 100-READ-SEGMENTS.\n           MOVE ZEROS  TO  TBL-COUNT (Y).\n           GO TO 20-INITIALIZE-TABLE.\n       100-READ-SEGMENTS.\n           CALL 'CBLTDLI' USING FUNC-GN  PCB1 SEGMENT-AREA.\n           IF STATUS1 NOT EQUAL '  '\n               IF STATUS1 = 'GB'\n                                   GO TO 500-CALCULATE-LENGTH\n               ELSE\n                   IF STATUS1 = 'GA' OR 'GK'\n                       NEXT SENTENCE\n               ELSE\n                   DISPLAY PCB1 ' - ' SEGMENT-AREA\n                                   GO TO 500-CALCULATE-LENGTH.\n      *    SEG-LEVEL1 SPECIFIES A NEW DATA BASE RECORD OR ROOT SEGMENT\n           IF SEG-LEVEL1 = '01'\n               PERFORM 500-CALCULATE-LENGTH THRU 550-CALCULATE-EXIT\n               MOVE SEGMENT-AREA  TO  HOLD-KEY.\n           PERFORM 200-SEARCH-SEGMENT  THRU  250-SEARCH-EXIT.\n           GO TO 100-READ-SEGMENTS.\n       200-SEARCH-SEGMENT.\n      *    SEARCH TABLE IN ORDER TO FIND THE SEGMENT LENGTH\n           SET X TO +1.\n           SEARCH TBL-SEGMENTS AT END\n                                   GO TO 250-SEARCH-EXIT\n           WHEN TBL-SEGMENTS (X) = HIGH-VALUES\n                                   GO TO 250-SEARCH-EXIT\n           WHEN TBL-SEG-NAME (X) = SEG-NAME1\n               ADD TBL-SEG-LENGTH (X)  TO  SEGMENT-LENGTH-A.\n       250-SEARCH-EXIT.\n           EXIT.\n       500-CALCULATE-LENGTH.\n      *    THE FOLLOWING COMPUTE STATEMENT IS USED TO SHOW THE TOTAL\n      *    RECORD LENGTH ON ANY DATABASE UP TO 10000 BYTES. THE TOTAL\n      *    NUMBER OF BYTES IS DIVIDED BY 10 IN ORDER TO KEEP THE OCCURS\n      *    AT 1000 INSTEAD OF 10000.  IF THE TOTAL NUMBER OF BYTES IS\n      *    GREATER THAN 10000, THEN 1 IS ADDED TO THE 1001 OCCURS.\n           ON 1\n                                   GO TO 550-CALCULATE-EXIT.\n           COMPUTE SEGMENT-LENGTH-B = SEGMENT-LENGTH-A / 10.\n           IF SEGMENT-LENGTH-B > 1000\n               ADD 1 TO TBL-COUNT (1001)\n               DISPLAY 'TOTAL RECORD LENGTH > 10000 KEY=' HOLD-KEY\n                                  ' - SEGMENT LENGTH=' SEGMENT-LENGTH-A\n           ELSE\n               ADD 1 TO TBL-COUNT (SEGMENT-LENGTH-B).\n           MOVE ZEROS  TO  SEGMENT-LENGTH-A.\n       550-CALCULATE-EXIT.\n           EXIT.\n       999-END-PROGRAM.\n           PERFORM 1000-PRINT-HEADINGS THRU 1100-RETURN-EXIT.\n           CLOSE CARD-FILE PRINT-FILE PUNCH-FILE.\n           DISPLAY 'END - DLIRLEN' UPON CONSOLE.\n           GOBACK.\n           STOP RUN.\n       1000-PRINT-HEADINGS.\n           MOVE REPORT-TITLE-1  TO  HD-1-REPORT-TITLE.\n           MOVE DBD-NAME1       TO  HD-1-DBD-NAME.\n           MOVE '1'             TO  HD-1-RPT-NO.\n           PERFORM 8010-PRINT-HEAD-1.\n           PERFORM 8020-PRINT-HEAD-2.\n           PERFORM 8030-PRINT-HEAD-3.\n           MOVE SPACES TO DETL-LINE-1.\n           PERFORM 8100-PRINT-DETAIL-LINE.\n       1050-RETURN-ROUTINE.\n           PERFORM 1200-PRINT-DETAIL THRU 1250-PRINT-DETAIL-EXIT\n               VARYING Y FROM 1 BY 1 UNTIL Y > 1001.\n       1100-RETURN-EXIT.\n           EXIT.\n       1200-PRINT-DETAIL.\n           IF LINE-CNT > 52\n               PERFORM 1000-PRINT-HEADINGS.\n           MOVE ' '            TO  DETL-LINE-1.\n           SET ID-Y            TO  Y.\n           MOVE ID-Y           TO  DETL-SUB.\n           MOVE TBL-COUNT (Y)  TO  DETL-COUNT.\n           ADD 1               TO  LINE-CNT.\n           PERFORM 8100-PUNCH-DETAIL-LINE.\n           PERFORM 8100-PRINT-DETAIL-LINE.\n       1250-PRINT-DETAIL-EXIT.\n           EXIT.\n       MISC-RTNS SECTION.\n       8010-PRINT-HEAD-1 SECTION.\n           MOVE CURRENT-DATE  TO  HD-1-RUN-DATE.\n           MOVE TIME-OF-DAY   TO  HD-1-RUN-TIME.\n           EXAMINE HD-1-RUN-TIME REPLACING ALL ' ' BY '.'.\n           ADD 1              TO  PAGE-CNT.\n           MOVE PAGE-CNT      TO  HD-1-PAGE-NO.\n           WRITE PRT-REC FROM HEAD-LINE-1  AFTER POSITIONING PRT-CC.\n           MOVE ZEROS         TO  LINE-CNT.\n       8020-PRINT-HEAD-2 SECTION.\n           WRITE PRT-REC FROM HEAD-LINE-2 AFTER POSITIONING PRT-CC.\n       8030-PRINT-HEAD-3 SECTION.\n           WRITE PRT-REC FROM HEAD-LINE-3 AFTER POSITIONING PRT-CC.\n       8100-PRINT-DETAIL-LINE SECTION.\n           WRITE PRT-REC FROM DETL-LINE-1 AFTER POSITIONING PRT-CC.\n           MOVE SPACES TO DETL-LINE-1.\n       8100-PUNCH-DETAIL-LINE SECTION.\n           WRITE PUN-REC FROM DETL-LINE-1.\n\n\nDLIRAPS JCL\n\n* $$ JOB JNM=DLIRAPS,CLASS=0,PRI=3,DISP=D\n* $$ PUN PUN=02D,CLASS=T,DEST=(,1-8777),JSEP=0\n* $$ LST LST=02E,CLASS=T,DEST=(,1-8777)\n* $$ LST LST=02F,CLASS=T,DEST=(,1-8777)\n// JOB DLIRAPS - CALCULATE DL/I HDAM DATABASE RAPS PER CI\n// ASSGN SYSLST,02E\n// ASSGN SYS018,02F\n// LIBDEF *,SEARCH=(SHRLIB.DLI,SH1LIB.MFG)\n// DLBL SYS4UC,'SYSWK4.USER.CAT',,VSAM\n// DLBL DLIRAPS,'DLI.PLNGDB.HDAM.DATA',,VSAM,CAT=SYS4UC\n// EXEC DLIRAPS,SIZE=200K\nPLNGDB   020\n/*\n/&\n* $$ EOJ\n\n\nDLIRLEN JCL\n\n* $$ JOB JNM=DLIRLEN,CLASS=0,PRI=3,DISP=D\n* $$ PUN PUN=02D,CLASS=T,DEST=(,1-8777),JSEP=0\n* $$ LST LST=02E,CLASS=T,DEST=(,1-8777)\n* $$ LST LST=02F,CLASS=T,DEST=(,1-8777)\n// JOB DLIRLEN - CALCULATE AVERAGE DL/I HDAM DATABASE RECORD LENGTH\n// UPSI 00000010\n// ASSGN SYSLST,02E\n// ASSGN SYS018,02F\n// LIBDEF *,SEARCH=(SHRLIB.DLI,SH1LIB.MFG)\n// DLBL SYS4UC,'SYSWK4.USER.CAT',,VSAM\n// DLBL DLIRAPS,'DLI.PLNGDB.HDAM.DATA',,VSAM,CAT=SYS4UC\n// EXEC DLZRRC00,SIZE=400K\nDLI,DLIRLEN,PLANPSB\nPLNGID   025\nGROSRQ   055\nPLNORD   055\nGROPTR   043\n/*\n/&\n* $$ EOJ\n\nRobert Ferro\nSystems Programmer\nProgress Lighting (USA)\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E003A10": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x017\\x017\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 311, "newlines": 311, "modlines": 0, "user": "VSEUPDT"}, "text": "Storage dump utility\n\nWhen I started programming in COBOL, after having been an\nAssembly language programmer, I quickly noticed that there\nwas no equivalent of the PDUMP macro.  To address this\ndeficiency I created a subroutine to provide a facility for\nproducing a DITTO DDD (hexadecimal and character) format\nstorage dump from within a COBOL program.\n\nThis subroutine, which I called HEXPRINT, contains its own\nDTFPR so that the dump is not mixed in with any other reports\nbeing produced.  This DTF writes to SYS055, which suits our\ninstallation because that programmer logical unit is not used by\nany other task.  This, of course, may be changed to suit\nparticular installation requirements.\n\nTo set up HEXPRINT the following line must be inserted in\nyour JCL.\n\n      // ASSGN SYS055.SYSLST\n\nTwo arguments are required for the subroutine call: ARG-1,\nwhich is a 2-byte packed-signed field containing the length of\nthe field to be dumped (up to 600 bytes can be dumped); and\nARG-2, which is the name (label) of the start of the field to be\ndumped.\n\nTo dump 200 bytes from the start of WS-WORK-FIELD, in\nCOBOL.\n\nWORKING-STORAGE SECTION.\n01  WS-HEXPRT-LENGTH            PIC S9(3) COMP-3 VALUE 200.\n01  WS-WORK-FIELD               PIC X(450).\nPROCEDURE DIVISION.\n    CALL 'HEXPRINT' USING WS-HEXPRT-LNTH\n                          WS-WORK-FIELD.\n\nTo dump 200 bytes from the address pointed to by the label\nWORKFLD, in Assembler.\n\n   HXPRLGTH DC    P'200'\n   WORKFLD  DS    CL'450'\n            CALL  HEXPRINT,(HXPRLGTH,WORKFLD)\n* PROGRAM-       HEXPRINT                                             *\n* DEFINITION-    THIS SUBROUTINE IS USED TO PRINT A RECORD IN BOTH    *\n*                CHARACTER AND HEXADECIMAL FORMAT.                    *\n* INPUT-         (1) ADDRESS OF A 2 BYTE FIELD CONTAINING THE LENGTH  *\n*                    OF THE RECORD TO BE PRINTED IN PACKED SIGNED     *\n*                    FORMAT. THIS LENGTH MAY NOT EXCEED 600 BYTES.    *\n*                (2) ADDRESS OF RECORD TO BE PRINTED.                 *\n* OUTPUT-        THIS PROGRAM CONTAINS ITS OWN PRINT DTF SO NO DATA   *\n*                IS PASSED BACK TO THE CALLING PROGRAM.               *\n*                THE PRINT DTF USES SYS055.                           *\n* CALL SEQUENCE- TO PRINT RECORD       CALL 'HEXPRINT' USING LENGTH   *\n*                                                            RECORD.  *\n* NOTE -       THE FIRST CALL WILL AUTOMATICALLY OPEN THE PRINT FILE. *\n         TITLE 'HEXPRINT - RECORD DUMP'\nHEXPRINT START 0\n         PRINT NOGEN\n*        *** INITIALISATION ***                                       *\nINITIAL  EQU   *\n         SAVE  (14,12)                 SAVE REGS OF CALLING PROGRAM\n         USING *,R15                   REG 15 BASE REG\n         LR    R12,R15                 LOAD REG 12 - WILL BE BASE REG\n         DROP  R15                     REG 15 NO LONGER BASE REG\n         USING HEXPRINT,R12            REG 12 NOW BASE REGISTER\n         ST    R13,SAVR13              SAVE CALLING PROG SAVE AREA ADDR\n         L     R2,0(R1)                ADDRESS OF LENGTH PARAMETER\n         L     R3,4(R1)                ADDRESS OF RECORD TO PRINT\n         CLI   SW1ST,X'00'             1ST TIME\n         BNE   PAGECHK                 NO- BYPASS\n         SPACE 3\nOPEN     EQU   *\n         OPEN  HEXPR1A\n         MVI   SW1ST,X'FF'             FILE NOW OPEN\n         SPACE 3\nPAGECHK  EQU   *\n         CLI   HEADDATE,C' '           DO WE HAVE DATE\n         BNE   PC0010                  YES- BYPASS\n         LA    R13,SAVEAREA            LOAD SAVE AREA ADDRESS\n         CALL  DAYDATE,(DATE,HEADDATE,FN)\nPC0010   EQU   *\n         CP    LINECTR,KP54            DO WE HAVE A FULL PAGE\n         BL    CHKPARMS                NO- BYPASS\n         BAL   R14,HEAD                PRINT HEADING\n         EJECT\n*        *** CHECK INPUT PARAMETERS ***                               *\nCHKPARMS EQU   *\n         MVC   LENGTH(2),=2X'00'       ZERO HIGH ORDER 2 BYTES\n         MVC   LENGTH+2(2),0(R2)       MOVE LENGTH PARAMETER\n         UNPCK LEN(3),0(2,R2)\n         NC    LEN(3),=X'0F0F0F'       ZERO ZONES\n         TRT   LEN(3),TSTTBLE1\n         BZ    CK0010                  NO NUMERIC ERRORS\n         LA    R8,ERRORS               ERROR MESSAGE\n         B     ERROR\nCK0010   EQU   *\n         UNPK  LEN(3),0(2,R2)\n         NI    LEN+2,X'F0'             ZERO NUMERIC OF LAST BYTE\n         CLI   LEN+2,X'C0'             SIGN C\n         BE    CK0020                  YES - OK\n         CLI   LEN+2,X'F0'             SIGN F\n         BE    CK0020                  YES - OK\n         LA    R8,ERRORS               ERROR MESSAGE\n         B     ERROR\nCK0020   EQU   *\n         CP    LENGTH,KP0              IS IT ZERO\n         BNE   CK0030                  NO- BYPASS\n         LA    R8,ERROR+35             ERROR MESSAGE\n         B     ERROR\nCK0030   EQU   *\n         CP    LENGTH,KP600            LONGER THAN 600 BYTES\n         BNH   WRITE                   NO- BYPASS\n         LA    R8,ERRORS+70            ERROR MESSAGE\n         B     ERROR\n         EJECT\n*        *** FORMAT PRINT LINE ***                                    *\nWRITE    EQU   *\n         AP    RECCTR,KP1              COUNT RECORDS\n         MVC   POUT1+1(3),=C'REC'\n         MVC   POUT1+4(8),EDREC        EDIT RECORD COUNT\n         ED    POUT1+4(8),RECCTR\n         DP    LENGTH,KP100            DIVIDE BY 100\n         MVC   DWORD,HEXZEROS          ZERO FILL DOUBLE WORD\n         MVC   DWORD+6(2),NUMLINES     MOVE NUMBER OF 100 BYTE SEGMENTS\n         CVB   R4,DWORD                SET UP LOOP COUNTER\n         LA    R13,REFNUM              ADDRESS OF REFERENCE NUMBERS\n         CP    NUMLINES,KP0            ANY FULL 100 BYTE SEGMENTS\n         BE    WR0030                  NO- BYPASS\nWR0020   EQU   *\n         LA    R5,100                  YES- LENGTH LOOP COUNTER = 100\n         B     WR0040\nWR0030   EQU   *\n         MVC   DWORD,HEXZEROS          ZERO FILL DOUBLE WORD\n         MVC   DWORD+6(2),LENREM       MOVE LENGTH OF PART SEGMENT\n         CVB   R5,DWORD                SET UP LOOP COUNTER\nWR0040   EQU   *\n         LA    R8,CHARLINE             ADDRESS OF CHARACTER LINE\n         LA    R9,HEXLINE1             ADDRESS OF HEX CHAR LINE 1\n         LA    R10,HEXLINE2            ADDRESS OF HEX CHAR LINE 2\n         LA    R11,REFLINE             ADDRESS OF REFERENCE LINE\n         MVC   0(2,R11),0(R13)         MOVE 1ST TWO REFERENCE NUMBERS\n         LA    R11,2(R11)              BUMP REGISTER\n         LA    R13,2(R13)              BUMP REGISTER\nWR0050   EQU   *\n         MVC   0(1,R8),0(R3)           MOVE CHARACTER TO O/P\n         SR    R6,R6                   ZERO REGISTER\n         IC    R6,0(R3)                MOVE IN BYTE OF DATA\n         SRL   R6,4                    LOOK AT HIGH ORDER HALF BYTE\n         LA    R7,TABLE                ADDRESS OF CONVERSION TABLE\n         AR    R7,R6                   DISPLACE ALONG TABLE\n         MVC   0(1,R9),0(R7)           MOVE HEX CHARACTER TO O/P\n         SR    R6,R6                   ZERO REGISTER\n         IC    R6,0(R3)                MOVE IN SAME BYTE OF DATA\n         N     R6,=X'0000000F'         ZERO HIGH ORDER HALF BYTE\n         LA    R7,TABLE                ADDRESS OF CONVERSION TABLE\n         AR    R7,R6                   DISPLACE ALONG TABLE\n         MVC   0(1,R10),0(R7)          MOVE HEX CHARACTER TO O/P\n         MVC   0(1,R11),0(R13)         MOVE REFERENCE TO O/P\n         LA    R3,1(R3)                BUMP REGISTER\n         LA    R8,1(R8)                BUMP REGISTER\n         LA    R9,1(R9)                BUMP REGISTER\n         LA    R10,1(R10)              BUMP REGISTER\n         LA    R11,1(R11)              BUMP REGISTER\n         LA    R13,1(R13)              BUMP REGISTER\n         BCT   R5,WR0050               LOOP IF NOT ZERO\n         BAL   R14,PRINT               GO FINISH FORMATTING PRINT LINES\n         MVI   CHARLINE,X'40'          CLEAR ALL OUTPUT WORK AREAS\n         MVC   CHARLINE+1(99),CHARLINE\n         MVC   HEXLINE1,X'40'\n         MVC   HEXLINE1+1(99),HEXLINE1\n         MVI   HEXLINE2,X'40'\n         MVC   HEXLINE2+1(99),HEXLINE2\n         MVI   REFLINE,X'40'\n         MVC   REFLINE+1(101),REFLINE\n         CH    R4,=H'0'                LAST SEGMENT PRINTED\n         BE    RETURN                  YES- BYPAS\n         BCT   R4,WR0020               LOOP IF NOT ZERO\n         CP    LENREM,KP0              ANY PART SEGMENTS TO PRINT\n         BNE   WR0030                  YES\n         SPACE 3\nRETURN   EQU   *\n         L     R13,SAVR13              LOAD CALLING PROG SAVE AREA ADDR\n         RETURN (14,12)\n         SPACE 3\nERROR    EQU   *\n         MVI   POUT1,C'0'              DOUBLE SPACE\n         AP    RECCTR,KP1              COUNT RECORDS\n         MVC   POUT1+1(3),=C'REC'\n         MVC   POUT1+4(8),EDREC        EDIT RECORD COUNT\n         ED    POUT1+4(8),RECCTR\n         MVC   POUT1+16(35),0(R8)      MOVE ERROR MESSAGE\n         BAL   R14,WRITER              PRINT IT\n         B     RETURN\n         EJECT\n*        *** HEADER ROUTINE ***                                       *\nHEAD     EQU   *\n         ST    R14,HDSAVR14           SAVE BAL REGISTER\n         AP    PAGECTR,KP1             ADD 1 TO PAGE COUNTER\n         ZAP   LINECTR,KP0             ZERO LINE COUNTER\n         MVI   POUT1,C'1'              SKIP TO NEW PAGE\n         MVC   HEADPAGE,EDPAGE         MOVE IN PAGE NUMBER\n         ED    HEADPAGE,PAGECTR\n         MVC   POUT1+1(132),HEADLINE   MOVE HEADER\n         BAL   R14,WRITER              GO PRINT IT\n         L     R14,HDSAVR14            RESTORE BAL REGISTER\n         BR    R14                     BRANCH BACK\nHDSAVR14 DS    F\n         EJECT\n*        *** MOVE PRINT LINES TO OUTPUT AREA ***                      *\nPRINT    EQU   *\n         ST    R14,PRSAVR14            SAVE BAL REGISTER\n         CP    LINECTR,KP54\n         BL    PR0010\n         BAL   R14,HEAD\nPR0010   EQU   *\n         MVI   POUT1,C'0'              SKIP 1 LINE BEFORE PRINTING\n         MVC   POUT1+18(100),CHARLINE  MOVE CHARACTER LINE\n         BAL   R14,WRITER              GO PRINT IT\n         MVC   POUT1+18(100),HEXLINE1  MOVE 1ST HEX LINE\n         BAL   R14,WRITER              GO PRINT IT\n         MVC   POUT1+18(100),HEXLINE2  MOVE 2ND HEX LINE\n         BAL   R14,WRITER              GO PRINT IT\n         MVC   POUT1+16(102),REFLINE   MOVE REFERENCE LINE\n         BAL   R14,WRITER              GO PRINT IT\n         L     R14,PRSAVR14            RESTORE BAL REGISTER\n         BR    R14                     BRANCH BACK\nPRSAVR14 DS    F\n         EJECT\n*        *** PRINT THE LINE ***                                       *\nWRITER   EQU   *\n         ST    R14,WTSAVR14            SAVE BAL REGISTER\n         CLI   POUT1,C'0'             IS IT DOUBLE SPACE\n         BNE   WT0010                  NO- BYPASS\n         AP    LINECTR,KP2             YES- ADD 2 TO LINE COUNTER\n         B     WT0020\nWT0010   EQU   *\n         AP    LINECTR,KP1             ADD 1 TO LINE COUNTER\nWT0020   EQU   *\n         PUT   HEXPR1A                 PRINT LINE\n         MVC   POUT1,POUT1-1           CLEAR PRINT AREA\n         L     R14,WTSAVR14            RESTORE BAL REGISTER\n         BR    R14                     BRANCH BACK\nWTSAVR14 DS    F\n         SPACE 3\nHEXPR1A  DTFPR                                                         C\n               DEVADDR=SYS055,                                         C\n               BLKSIZE=133,                                            C\n               CTLCHR=ASA,                                             C\n               IOAREA1=POUT1\n         EJECT\n*        *** WORK AREAS AND CONSTANTS ***                             *\nSAVR13   DS    F\nSAVEAREA DS    9D\nSW1ST    DC    X'00'\nHEXZEROS DC    8X'0'\nKP0      DC    P'0'\nKP1      DC    P'1'\nKP2      DC    P'2'\nKP54     DC    P'54'\nKP100    DC    P'100'\nKP600    DC    P'600'\nTSTTBLE1 DC    X'000000000000000000000A0B0C0D0E0F'\nTABLE    DC    C'0123456789ABCDEF'\nDWORD    DS    D\nLEN      DS    CL3\nLENGTH   DS    PL4'0'\n         ORG   LENGTH\nNUMLINES DS    PL2\nLENREM   DS    PL2\nPAGECTR  DC    PL3'0'\nLINECTR  DC    P'99'\nRECCTR   DC    PL4'0'\nEDPAGE   DC    X'402020202120'\nEDREC    DC    X'4020202020202120'\nDATE     DC    6C' '\nFN       DC    C'0'\nHEADLINE DS    0CL132\n         DC    CL70'HEXPRINT - RECORD DUMP'\nHEADDATE DC    29C' '\n         DC    23C' '\n         DC    C'PAGE'\nHEADPAGE DS    CL6\nCHARLINE DC    100C' '\nHEXLINE1 DC    100C' '\nHEXLINE2 DC    100C' '\nREFLINE  DC    102C' '\nREFNUM   DC    C'  1.......10........20........30........40........50'\n         DC    C'........60........70........80........90.......100'\n         DC    C'101......110.......120.......130.......140.......150'\n         DC    C'.......160.......170.......180.......190.......200'\n         DC    C'201......210.......220.......230.......240.......250'\n         DC    C'.......260.......270.......280.......290.......300'\n         DC    C'301......310.......320.......330.......340.......350'\n         DC    C'.......360.......370.......380.......390.......400'\n         DC    C'401......410.......420.......430.......440.......450'\n         DC    C'.......460.......470.......480.......490.......500'\n         DC    C'501......510.......520.......530.......540.......550'\n         DC    C'.......560.......570.......580.......590.......600'\nERRORS   DC    C'*** INVALID LENGTH PARAMETER       '\n         DC    C'*** ZERO LENGTH SPECIFED           '\n         DC    C'*** LENGTH TOO GREAT - 600 BYTE MAX'\n         DC    CL1' '\nPOUT1    DS    CL133\n         LTORG\n         NED   HEXPRINT\n\nAndrew Gardiner\nSystems  Programmer\nSt George Building Society Ltd (Australia)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A00I": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\r\\x00\\r\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 13, "newlines": 13, "modlines": 0, "user": "VSEUPDT"}, "text": "E004 - VSE Update Issue #4  December 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE004A01   A scheduling program\nE004A02   Automated operations\nE004A03   PR/SM versus VM for VSE users\nE004A04   How to share ICCF in several VSE/SP4 systems\nE004A05   Print file segmentation for COBOL programs\nE004A06   Loading tables in VSE batch\nE004A07   File block sizes and performance\nE004A08   How to obtain volume characteristics information\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A01": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xc9\\x00\\xc9\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 201, "newlines": 201, "modlines": 0, "user": "VSEUPDT"}, "text": "A scheduling program\n\nIf your shop has a one-shift operation and does not have an\nautomatic job scheduler, it is difficult to schedule resource-\nintensive batch jobs.  If the operator releases such a job before\nleaving, users working late can experience problems.  The\nproblem is exacerbated if the job needs to close CICS files for\nupdate.\n\nThe following short program entitled 'Waiter', gets around this\nproblem in an effective, if inelegant manner.  The first step of\nthe resource-hungry job executes 'Waiter', which issues a VSE\nwait for the number of minutes specified in SYSIPT (see job\nexample below).  Thus if the operator releases the job at 17:00\nand sets a wait period of 4 hours, the resource intensive part of\nthe job will not start until 21:00.  Hopefully, at this time all\nusers will have gone home.\n\n        PRINT NOGEN\n        TITLE 'WAIT - WAITS ''N'' SECONDS AS SPECIFIED IN SYSIPT'\n*   REGISTER USAGE\n*   R1    -  WORK, TECB ADDRESS FOR SETIMER\n*   R2-R6 -  WORK REGISTERS\n*   R7    -  SETIMER VALUE\n*   R9    -  ERROR FLAG\n*   R11   -  PROGRAM BASE\n*   R15   -  VSE/SP RETURN CODE\n* SYNTAX:\n* WAIT PERIOD IN MINUTES MUST BE SPECIFIED STARTING IN COLUMN 1,\n* ACCEPTABLE RANGE 1-9999. LEADING ZEROES ARE ACCEPTABLE, EG 0010\n* (IE WAIT 10 MINUTES). THE PROGRAM ONLY READS THE FIRST 4 DIGITS,\n* ADDITIONAL DIGITS ARE IGNORED.\n*\n* EXAMPLE OF USE :\n* // JOB WAIT FOUR HOURS, THEN EXECUTE MYPROGRAM\n* /*\n* /. STEP1\n* // LIBDEF *,SEARCH=LIB.SUBLIB\n* // EXEC WAITER\n* 240         (WAIT 240 MINUTES/4 HRS)\n* /*\n* // IF $RC GT 0 THEN     EXIT JOB IF PROBLEM OCCURRED\n* // GOTO $EOJ\n* /*\n* /. STEP2\n* // EXEC MYPROGRAM  (CAN'T RUN THIS DURING PRIME SHIFT)\n* /*\n* /&\n*\n* PLS NOTE: BECAUSE OF PROGRAM OVERHEADS ETC, THE ELAPSED TIME MAY VARY\n* FROM THAT SPECIFIED BY A FEW SECONDS. THIS UTILITY IS NOT INTENDED\n* TO BE A STOPWATCH.\nWAITER   CSECT\n         BALR  R11,0\n         USING *,R11\n         XR    R9,R9               INITIALIZE ERROR FLAG\n         XR    R7,R7               INITIALIZE MINUTES\n* M A I N L I N E\n* OPEN FILES\n         OPEN  PRINTFL             OPEN PRINT FILE\n         OPEN  CARDFL              OPEN CARD FILE\n* EDIT INPUT CARD - ONLY THE FIRST CARD IS READ.\n         GET   CARDFL\n         B     CARDEDIT             EDIT 1 CARD ONLY\nCARDEOF  EQU   *\n* EXIT IF BAD CARD\n         LTR   R7,R7                  IF BAD VALUE\n         BZ    BADEXIT\n         BM    BADEXIT                GIVE UP\n* WAIT SPECIFIED PERIOD\n         LR    R1,R7\n         SETIME (1),TIMEBLK           SET THE TIMER\n         WAIT (1)                     WAIT FOR THE POST\n* TELL USER HOW LONG WE'VE WAITED FOR\n         B     TELL\n         B     WAITEXIT               GO AROUND ERROR HANDLER\n* ERROR HANDLER\nBADEXIT  DS    0H\n         MVC PRTBUF+1(26),=CL26'** INVALID CONTROL CARD **'\n         PUT   PRINTFL\n         LA    R9,8                   SET RETCODE\n* NORMAL EXIT POINT\nWAITEXIT DS    0H\n         CLOSE CARDFL              CLOSE CARD FILE\n         CLOSE PRINTFL             CLOSE PRINT FILE\n         LR    R15,R9              GET RETCODE\n         EOJ   RC=(15)\n         DS    0F\nTIMEBLK  TECB                          TIMER EVENT CONTROL BLOCK\n         EJECT\n* TELL - PRINT WAIT TIME ON SYSLST\n* INPUT  - WORK4 = RIGHT-ADJUSTED WAIT TIME\n* OUTPUT - PRTBUF\nTELL     DS    0H\n         LA    R2,4                   CHAR COUNT\n         LA    R1,WORK4               R1 => WAIT PERIOD FLD\n         LA    R3,PRTBUF+1            R3 => PRINT BUFFER\n         XR    R4,R4                  SET LEADING ZERO FLAG\nLOOPT    DS    0H                     DO UNTIL END OF FLD\n         LTR   R4,R4                  TEST LEADING ZERO FLAG\n         BNZ   MOVEIT                 BYPASS IF PAST LEADING ZEROES\n         CLI   0(R1),C'0'             TEST FOR ZERO\n         BE    ZERO                   BYPASS LEADING ZEROES\n         LA    R4,1                   SET LEADING FLAG\nMOVEIT   DS    0H\n         MVC   0(1,R3),0(R1)          MOVE TO PRINT BUFFER\n         LA    R3,1(R3)               BUMP PRINT BUFFER PTR\nZERO     DS    0H\n         LA    R1,1(R1)               BUMP WAIT FLD PTR\n         BCT   R2,LOOPT               AROUND WE GO\n         C     R7,=F'58'              IF 1 MINUTE (ADJUSTED)\n         BH    MULT\n         MVC   1(16,R3),=CL16'MINUTE IS UP ***'\n         B     NEXT\nMULT     DS    0H                     ELSE\n         MVC   1(18,R3),=CL18'MINUTES ARE UP ***'\nNEXT     DS    0H\n         PUT   PRINTFL\n         B     WAITEXIT               NORMAL EXIT, ALL'S WELL\n         EJECT\n* CARDEDIT - EDIT INPUT CARD\n* INPUT  - CARDBUF\n* OUTPUT - R7 = REQUIRED TIME PERIOD IN MINUTES\nCARDEDIT DS    0H\n* IF BAD FORMAT CARD, NOTIFY & BAIL OUT\n         CLC   CARDBUF(4),=CL4'    '        IF BAD CARD\n         BE    BADEXIT                      NOTIFY & GIVE UP\n* CHECK WAIT PERIOD (MINUTES)\n         LA    R1,CARDBUF+3           R1 => END CHAR OF INPUT\n         LA    R2,4                   R2 = NO. OF CHARS ALLOWED\n         LA    R3,WORK4+3             R3 => END OF WORK AREA\nLOOP1    DS    0H                     DO UNTIL ALL CHARS PROCESSED\n         CLI   0(R1),C' '             IF BLANK\n         BE    BLANK                  BYPASS\n         CLI   0(R1),C'0'             IF BAD CHAR\n         BL    BADEXIT                GIVE UP\n         CLI   0(R1),C'9'             IF BAD CHAR\n         BH    BADEXIT                GIVE UP\n         MVC   0(1,R3),0(R1)          SAVE CHAR\n         BCTR  R3,0                   DECR BUFFER PTR\nBLANK    DS    0H\n         BCTR  R1,0                   DECR BUFFER PTR\n         BCT   R2,LOOP1               PLAY IT AGAIN, SAM !\n* CONVERT INPUT TO BINARY\n         LA    R1,WORK4+3              POINT TO END OF WORKAREA\n         LA    R2,4                    R2 = NO. OF CHARS ALLOWED\n         XR    R5,R5                   CLEAR WORK REGISTER\n         LA    R3,1\nLOOP2    DS    0H                      DO UNTIL ALL CHARS PROCESSED\n         IC    R5,0(R1)                GET DIGIT\n         SLL   R5,4                    CLEAR OUT 'CHAR' PART\n         ICM   R5,B'0010',X'00'        CLEAR OUT 'CHAR' PART\n         O     R5,=XL4'0C'             PLUG IN SIGN\n         ST    R5,DWORD+4              PUT IN DOUBLE WORD\n         CVB   R5,DWORD                CONVERT TO BINARY\n         MR    R4,R3                   TIMES POSITIONAL VALUE\n         AR    R7,R5                   ADD TO RESULT\n         MH    R3,=H'10'               BUMP POSITIONAL VALUE\n         BCTR  R1,0                    DECR BUFFER PTR\n         BCT   R2,LOOP2                FINISHED YET ?\n* CONVERT INPUT TO MINUTES\n         M     R6,=F'60'               TIMES 60\n         BCTR  R7,0                    LESS 2 SECS FOR PROGRAM OVERHEAD\n         BCTR  R7,0                    (GUESSTIMATE)\n         B     CARDEOF                 ONLY READ 1 CARD\nWORK4    DC    CL4'0000'\nDWORD    DC    D'0'\nCARDBUF  DC    CL80' '\n         EJECT\nDATAAREA DS    0F\n         LTORG\n* REGISTER EQUATES\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR9       EQU   9\nR11      EQU   11\nR15      EQU   15\nPRTBUF   DC    CL132' '              PRINT BUFFER\n* DTF'S, ACB'S ETC.\n         DS    0F\nPRINTFL  DTFPR DEVADDR=SYSLST,     PRINT FILE DTF                      C\n               DEVICE=1403,                                            C\n               BLKSIZE=132,                                            C\n               CTLCHR=ASA,                                             C\n               IOAREA1=PRTBUF,                                         C\n               RECFORM=FIXUNB\n         DS    0F\nCARDFL   DTFCD DEVADDR=SYSIPT,     CARD FILE DTF                       C\n               BLKSIZE=80,                                             C\n               EOFADDR=CARDEOF,                                        C\n               IOAREA1=CARDBUF\n         END\n/*\n\nDavid Roth (Australia)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A02": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\tE\\tE\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 2373, "newlines": 2373, "modlines": 0, "user": "VSEUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "E004A03": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\t\\x004\\x004\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:09:56", "lines": 52, "newlines": 52, "modlines": 0, "user": "VSEUPDT"}, "text": "PR/SM versus VM for VSE users\n\nFor sites that have a 3090 or ES/9000 processor the PR/SM\nfeature is available.  By using PR/SM, VSE sites can run VSE\nnative on the hardware without needing  VM to run as a\nhypervisor.  Many VSE sites are in the position of having to\nchoose whether or not to keep VM.\n\nThere are a number of benefits from removing VM completely\nand using the PR/SM feature.  Savings in costs can be made\nbecause payments for VM and related software licence fees no\nlonger have to be made.  However, sites with processors that\nrequire PR/SM to be paid for as an optional extra will have to\ncompare the two costs carefully.  There are performance\nimprovements in VSE from using PR/SM rather than VM.\nPR/SM allows VSE to achieve near native performance levels,\nwhereas with VM, VSE's performance is at best in the 90%\nregion of native performance.  PR/SM has much less of an\noverhead than VM.  The PR/SM overhead has been measured\nat around 2%, while the VM overhead has been measured at\nanything between 8% and 25%.  PR/SM offers improved\nreliability over VM.  Although VM is very stable it does\nsometimes crash, whereas PR/SM is not known to crash.\n\nOn the downside, the loss of VM has associated drawbacks.\nVM allows a great deal of flexibility when it comes to sharing\ndevices between several guest VSE systems.  This is achieved\nwith the ATTACH command.  VM can even allocate the\nindividual device address on the same control unit to separate\nguest systems.  PR/SM does not offer anywhere near this\ndegree of flexibility, requiring a separate control unit per guest.\nIf a device does not have multiple channel connections it can\nbe attached to only one PR/SM guest.  With VM, guest\nsystems can communicate with each other easily using a virtual\nCTCA.  With PR/SM it is much more complicated.  PR/SM\nguests can communicate, but need real CTCAs or\ncommunication hardware, eg 3745 with multiple channel\nadapters.  VM is much better at allocating memory to guests\nthan PR/SM.  Guests under VM get memory from a common\npool which results in optimum real storage utilization.  With\nPR/SM, the memory is allocated to a guest on a once and for\nall basis.  Unused memory from one PR/SM guest cannot be\nused by another PR/SM guest.  Perhaps the biggest negative\naspect of losing VM is the loss of CMS.  Neither VSE nor\nPR/SM offer such a multifunctional user-friendly facility.\n\nWhen deciding one way or another, VSE sites will have to give\ntheir own weighting to each of the plus and minus points for\nPR/SM and VM and see which of the two choices comes out\ntop.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A04": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00f\\x00f\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:53", "lines": 102, "newlines": 102, "modlines": 0, "user": "VSEUPDT"}, "text": "How to share ICCF in several VSE/SP4 systems\n\n\nSITUATION\n\nWe run VM/XA on a 3090.  We had VSE/SP4 running under\nVM/XA, installed as intended by IBM.  We needed eight more\nVSE systems; five in VAE-mode and three in VM-mode.  All\neight systems had to share the two system mini-disks DOSRES\nand SYSWK1.\n\nOur users needed a CICS with ICCF in each machine, and to\nsave as much DASD space as possible, I had to share the CICS\nand ICCF system generated in the installation, automatically,\nbetween all machines.\n\n\nWHAT I DID\n\nUsing the main system, I defined a new VSAM user catalog on\nan extra mini-disk for the first system.  (Main system means\nthe original generated system; first system means the first extra\ngenerated system.  The remaining seven systems are not\nmentioned, because I simply repeated the method.)\n\nThis mini-disk was created especially for this purpose with a\nsize of 50 cylinders, including catalog and space.  (This size\nwas an assumption; I was unfortunately unable to find out the\nminimum VSAM-size a shared CICS needs.)\n\nI changed the standard label procedure of the first system so\nthat the following files came under the control of this new user\ncatalog:\n\nIJSYSLN, IESCNTL, IESTRFL, IESTRWF, IESMSGS,\nIESPRB, IESROUT, DFHSTM, DFHSTN, DFHNTRA,\nDFHTEMP, DFHRSD, IJSYS01-04, SORTWK1, and\nIKSYS11-54.\n\nDFHDMPA, DFHDMPB, and DFHAUXT stayed in\nVSESPUC with separate names.\n\nI duplicated the procedure DTRCICST and called it\nDTRCICS2 and catalogued DTRCICS2.PROC in SYSLIB.\n(This procedure is called in the CICS start-up, therefore I had\nto change the start-up procedure for the first CICS system so\nthat DTRCICS2.PROC was called.)\n\nI duplicated the % sign for all the workfiles.\n\nI IPLed the first system and then worked in this system and:\n\no      Defined and initialized the RSD file,\n\no      Defined and initialized the TEXT - REPSTORY file,\n\no      Defined the TD - INTRA file,\n\no      Defined the DFHTEMP file,\n\no      Defined the MESSAGE - ROUTING file,\n\no      Defined the ONLINE - PROB - DET file,\n\no      Defined the AUTO - STATS - A file,\n\no      Defined the AUTO - STATS - B file,\n\no      Defined the SYSTEM - LOG - A file,\n\no      Defined the SYSTEM - LOG - B file,\n\no      Defined the USER - JOURNAL - A file,\n\no      Defined the USER - JOURNAL - B file.\n\nI backed up the DTSFILE from the ICCF-library of the main\nsystem and restored it to the ICCF-library of the first system.\n\nI backed up the VSE CONTROL file from VSESPUC and\nrestored it to the new user catalog.\n\nI backed up the TEXT REPSTORY file from VSESPUC and\nrestored it to the new user catalog.\n\nI defined DEFAULT - MODEL - ESDS - SAM in the new user\ncatalog.\n\nI initialized the DUMP MANAGEMENT FILE in the first\nsystem.\n\nI started CICS-ICCF in the first system and logged on.\n\nI changed the name of the standard-label procedure in the\nmember ADM$DTAB in library '50' in the newly-created\nCICS-ICCF to the name used by the first system.\n\n\nWolf-Jurgen M\nlzer\nSystem Programmer\nSoftware AG (Germany)                         c Software AG 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A05": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xc4\\x00\\xc4\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 196, "newlines": 196, "modlines": 0, "user": "VSEUPDT"}, "text": "Print file segmentation for COBOL programs\n\nThis routine allows a user to alter the VSE/POWER spool file\noptions while the file is currently open. This routine is\nextremely useful for splitting reports for various departments\nand dispatching branch reports to remote locations.\n\nThe calling sequence for a COBOL program is:\n\nCALL 'PWRSEG' USING record-name.\n\nwhere record-name must have the following structure:\n\n01  RECORD-NAME.\n    03  LOGICAL-UNIT            PIC X(6).\n    03  CLASS                   PIC X.\n    03  COPIES                  PIC 99.\n    03  FORM                    PIC X(4).\n    03  FCB                     PIC X(8).\n    03  DISPOSITION             PIC X.\n    03  REMOTE-STATION          PIC 999.\n\nLOGICAL-UNIT       is the programmer logical unit as\nassigned at run time.  This field is mandatory.\n\nCLASS      is the new class of the print file.\n\nCOPIES      is the number of copies to be printed.\n\nFORM      is the new form number for the print file.\n\nFCB      is the new FCB for the print file.\n\nDISPOSITION       is the new disposition of the print file.\n\nREMOTE-STATION      is the new remote station identifier for\nthe print file.\n\nIf any parameter value is not to be changed from the original\nLST card, or from a previous call of this routine, then the field\n\nmust be set to spaces or zeros as appropriate.\n\nThe new LST card is displayed at the console.  The word\nERROR appears in columns 66 to 70 of the displayed LST card\nif any errors were detected.\n\nAssemble the source code for PWRSEG and catalogue the\nrelocatable module into a relocatable library.  The relocatable\nlibrary should be in the standard relocatable library searchlist,\nso that the module may be included in the calling program at\nlink edit time.\n\n         TITLE 'PWRSEG - POWER SEGMENTATION MODULE'\nPWRSEG   CSECT\n         USING PWRSEG,15\n         SAVE  (14,12)\n         LR    2,15                    R2 = BASE REGISTER\n         USING PWRSEG,2\n         DROP  15\n         SPACE 2\n*              SET UP ADDRESSABILITY\n         SPACE 2\n         L     3,0(0,1)                R3 = A(PARAMS)\n         USING PWRPARMS,3              SET UP DSECT ADDRESS\n         LA    4,PWRJECL               R4 = A(JECL STATEMENT)\n         LA    4,13(4)                 POINT TO FIRST AVAILABLE BYTE\n         MVI   0(4),64                 CLEAR LST CARD\n         MVC   1(71-14,4),0(4)\n         SPACE 2\n*              VET AND SET UP LOGICAL UNIT\n         SPACE 2\n         CLC   PWRLST(3),=CL3'SYS'     PROGRAMMER LOGICAL UNIT ?\n         BNE   PWR890                  NO\n         CLC   PWRLST+3(3),=CL3'001'   LESS THAN 1 ?\n         BL    PWR890                  YES\n         CLC   PWRLST+3(3),=CL3'254'   GREATER THAN 254 ?\n         BH    PWR890                  YES\n         MVC   0(6,4),PWRLST           MOVE LOGICAL UNIT TO JECL\n         LA    4,6(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP CLASS\n         SPACE 2\n         CLI   PWRCLS,64               CLASS EQUAL TO SPACE ?\n         BE    PWR300                  YES\n         CLI   PWRCLS,C'A'             LESS THAN A ?\n         BL    PWR300                  YES\n         CLI   PWRCLS,C'Z'             GREATER THAN Z ?\n         BH    PWR300                  YES\n         MVC   0(7,4),=CL7',CLASS='    MOVE KEYWORD TO JECL\n         LA    4,7(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(1,4),PWRCLS           MOVE CLASS TO JECL\n         LA    4,1(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP COPIES\n         SPACE 2\nPWR300   EQU   *\n         CLC   PWRCPY,=CL2'01'         LESS THAN 1 ?\n         BL    PWR400                  YES\n         CLC   PWRCPY,=CL2'99'         GREATER THAN 99 ?\n         BH    PWR400                  YES\n         MVC   0(6,4),=CL6',COPY='     MOVE KEYWORD TO JECL\n         LA    4,6(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(2,4),PWRCPY           MOVE COPIES TO JECL\n         LA    4,2(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP FORM NUMBER\n         SPACE 2\nPWR400   EQU   *\n         CLC   PWRFNO,=CL4' '          FNO EQUAL TO SPACES ?\n         BE    PWR500                  YES\n         MVC   0(5,4),=CL5',FNO='      MOVE KEYWORD TO JECL\n         LA    4,5(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(4,4),PWRFNO           MOVE FORM NUMBER TO JECL\n         LA    4,4(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP FCB\n         SPACE 2\nPWR500   EQU   *\n         CLC   PWRFCB,=CL8' '          FCB EQUAL TO SPACES ?\n         BE    PWR600                  YES\n         MVC   0(5,4),=CL5',FCB='      MOVE KEYWORD TO JECL\n         LA    4,5(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(8,4),PWRFCB           MOVE FCB TO JECL\n         LA    4,8(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP DISPOSITION\n         SPACE 2\nPWR600   EQU   *\n         CLI   PWRDSP,64               DISP EQUAL TO SPACE ?\n         BE    PWR700                  YES\n         CLI   PWRDSP,C'D'             DISP EQUAL TO D ?\n         BE    PWR610                  YES\n         CLI   PWRDSP,C'H'             DISP EQUAL TO H ?\n         BE    PWR610                  YES\n         CLI   PWRDSP,C'K'             DISP EQUAL TO K ?\n         BE    PWR610                  YES\n         CLI   PWRDSP,C'L'             DISP EQUAL TO L ?\n         BNE   PWR700                  NO\nPWR610   EQU   *\n         MVC   0(6,4),=CL6',DISP='     MOVE KEYWORD TO JECL\n         LA    4,6(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(1,4),PWRDSP\n         LA    4,1(4)                  POINT TO NEXT AVAILABLE BYTE\n         SPACE 2\n*              VET AND SET UP REMOTE STATION IDENTIFIER\n         SPACE 2\nPWR700   EQU   *\n         CLC   PWRREM,=CL3'000'        IS PARAMETER PRESENT ?\n         BE    PWR800                  NO\n         MVC   0(8,4),=CL8',REMOTE='   MOVE KEYWORD TO JECL\n         LA    4,8(4)                  POINT TO NEXT AVAILABLE BYTE\n         MVC   0(3,4),PWRREM\n         SPACE 2\n*              ISSUE POWER SEGMENT\n         SPACE 2\nPWR800   EQU   *\n         LA    5,1                     R5 = DEVICE CLASS\n         STC   5,PWR810+4              STORE IN MACRO\n         PACK  PWRWRK,PWRLST+3(3)      GET LOGICAL UNIT NUMBER\n         CVB   5,PWRWRK\n         STC   5,PWR810+5              STORE IN MACRO\nPWR810   EQU   *\n         SEGMENT DEVADDR=SYSLST,JECL=PWRJECL\n         LTR   15,15                   ANY ERRORS ?\n         BE    PWR900                  NO\nPWR890   EQU   *\n         MVC   PWRJECL+70-5(5),=CL5'ERROR' INFORM USER\n         SPACE 2\n*              RETURN TO CALLING ROUTINE\n         SPACE 2\nPWR900   EQU   *\n         PUT   CONSOLE\n         RETURN (14,12)\n         SPACE 2\nPWRWRK   DS    D\n         SPACE 2\nPWRJECL  DC    CL71'* $$ LST LST='\n         SPACE 2\n         LTORG\n         SPACE 2\nCONSOLE  DTFCN BLKSIZE=71,DEVADDR=SYSLOG,IOAREA1=PWRJECL,TYPEFLE=OUTPUT\nPWRPARMS DSECT\nPWRLST   DS    CL6                     LOGICAL UNIT\nPWRCLS   DS    C                       CLASS\nPWRCPY   DS    CL2                     COPY\nPWRFNO   DS    CL4                     FORM NUMBER\nPWRFCB   DS    CL8                     FCB\nPWRDSP   DS    C                       DISPOSITION\nPWRREM   DS    CL3                     REMOTE STATION IDENTIFIER\n         END\n\nM Nunan\nSystems Programmer\nSage Computing  (South Africa)                         c Sage Computing 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A06": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00_\\x00_\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 95, "newlines": 95, "modlines": 0, "user": "VSEUPDT"}, "text": "Loading tables in VSE batch\n\nThough CICS allows the dynamic loading of a phase into\nstorage from a high-level language program, batch VSE has\nnever offered this capability.\n\nIn our installation, numerous tables - eg postage and foreign\ncountry and zip code tables - are used in programs.  To ensure\nthat changes made to these tables are always reflected in the\nprograms which access them, without the need for re-\ncompilation and without 'hard-coding' them, we developed the\nTABLOADR program.\n\nTABLOADR is designed to be called from a high-level\nlanguage (such as COBOL or PL/I), and issues a VSE LOAD\nmacro to accomplish the actual function.\n\nWhen invoked from a COBOL program, for instance, the\nCALL statement must pass two parameters: the data name of\nwhere the phase is to be loaded into storage, and a data name\ncontaining a value corresponding to the phase name which is to\nbe loaded, as in the following sample code:\n\n01  W06-POSTAGE-AREA.\n    03      W06-PHASE-NAME           PIC  X(08) VALUE 'POSTAGE '.\n    03      W06-POSTAGE-TABLE.\n        ---   actual layout of data   ---\n    SKIP3\n01  W07-FOREIGN-COUNTRY-AREA.\n    03      W07-PHASE-NAME           PIC X(08)  VALUE 'FOREIGNS'.\n    SKIP1\n    03      W07-FOREIGN-COUNTRY-TABLE.\n        ---   actual layout of data   ---\n        SKIP3\n        ---    PROCEDURE DIVISION statements   ---\n\n    CALL 'LOADIT' USING W06-PHASE-NAME W06-POSTAGE-TABLE.\n    CALL 'LOADIT' USING W07-PHASE-NAME W07-FOREIGN-COUNTRY-TABLE.\n\nWhen invoked from a BAL program, standard linkage\nconvention is used.  Register 1 points to a parameter list\ncontaining the address where the data is to be loaded and the\naddress of the field containing the phase name to be loaded.\n\nThe tables themselves are created by placing the values desired\nin DCs in a BAL program.  The BAL program is then\nassembled and link-edited.\n\n         TITLE 'AUTOMATIC TABLE LOADER PROGRAM'\n         PRINT NOGEN\nTABLOADR CSECT\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*     THIS PROGRAM TAKES THE LOAD ADDRESS & PHASE NAME FROM THE     *\n*     \"CALLING\" PROGRAM (FOR BAL PROGRAMS, R1 POINTS TO A PARA-     *\n*     METER LIST) AND \"LOADS\" THE SPECIFIED PHASE INTO THE          *\n*     ADDRESS SPECIFIED.                                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\n         STM   R14,R12,12(R13)\n         BALR  R12,0\n         USING *,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(R13)                  S A V E S   &  L I N K A G E\n         LR    R13,R15\n         LM    R0,R1,0(R1)             GET THE PARAMETERS INTO THE REGS\n         LOAD  (1),(0)                 ISSUE THE VSE LOAD\n         L     R13,SAVEAREA+4          NOW GET BACK OUT\n         LM    R14,R12,12(R13)\n         BR    R14\nSAVEAREA DC    18F'0'\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n\nDavid M Wakser\nDirector  MIS\nNational League for Nursing (USA)            c National League for Nursing 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E004A07": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00R\\x00R\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 82, "newlines": 82, "modlines": 0, "user": "VSEUPDT"}, "text": "File block sizes and performance\n\nToday's faster computers have more memory than ever before,\nyet many of the programs that are running on them were\ndesigned many years ago for slower computers with restrictions\non the amount of virtual storage that could be used.  However,\nminor changes to these older systems can produce eye-catching\nresults.  In today's environment, using VM and VSE, virtual\nstorage constraint for batch can almost be erased, and programs\nneed to be altered to take advantage of this new unrestricted\nuse of virtual storage.  VSE works much better when it has to\ndo very little I/O.  For these two reasons, block sequential files\nare critical for best resource utilization.\n\nInefficient blocking leads to wasted disk space.  An unblocked\nfile may use only 20% of a disk.  This means that if you buy a\nsingle density 3380 with 2.5GB of storage only 0.5GB would\nbe used.  Placing 2.5GB of characters using an unblocked\nformat means buying five times the disk storage; paying five\ntimes the amount needed for hardware maintenance; buying an\nair conditioner capable of cooling five disks; and finally\nenlarging your computer room to hold all five disks.  This\nquickly adds up to real dollars.  Using a block size of under 4K\n- a common block size in the early 1980s - may use only 55%\nof the available disk space.  While this is better than not\nblocking, it still means buying more than twice as much\nhardware as is really needed.\n\nWasted disk space is not the only problem however, tapes are\nalso impacted by poor block sizes.  Between each block is an\ninter-record gap.  If the block sizes are small, this gap may be\nlarger than the blocked data and the tape is under-utilized in the\nsame way that disks are.  This cannot be justified by the\nargument that tapes are cheap; think of the time the operator\nmust take to mount and care for the many extra tapes generated\nas a result of poor block sizes.\n\nWasted space is not the worst part of poorly blocked files.\nRun-time may be impacted over tenfold.  If you find this hard\nto believe, try a simple test.  Take a sequential file on disk with\nabout 10 000 records.  Use IDCAMS REPRO to copy it to a\ntape, setting the block length equal to the file length for both\nfiles.  Then redo the REPRO, but block the files as close to\n32K as possible.  Assuming no other contention, the blocked\nfiles should have been done much faster.  (Results are most\ndramatic when the sequential file has a small record size.)  By\nre-blocking files, jobs that ran in hours now run in minutes;\nfewer disks and tapes are used; and finally, less total CPU time\nis used because the CPU is not busy doing I/Os.\n\nPerhaps the easiest place to start is with back-up tapes.  If your\nshop is like most, file back-ups are run either before or after\nthe files are updated.  Since back-up tapes are usually created\nfrom only one jobstream and read in by only one restore\njobstream, only these two jobstreams and/or programs need to\nbe changed to re-block this file that is probably used daily.\nAfter back-up tapes, large disk files should then be blocked\nhigher.  This is much more involved since these files are likely\nto be used in many jobstreams and programs.  However,\nbecause they are used in many jobstreams the payback is much\ngreater in terms of less run-time and less disk space used.\n\nA forgotten file is the POWER data file.  Recent enhancements\nallow for better access to the POWER spool files by buffering\nthem and putting the buffers in memory.  By re-blocking the\nPOWER data file, significant gains in run time may be seen.\nTapes can be blocked up to 32 760 bytes (VSE systems could\nreally go seven bytes higher, but then the tapes could not be\nread by MVS systems).  On disk, if a track is less than 32K in\nsize, try to use a block size as close to full track blocking as\npossible.  If the track size is more than 32K try to pick a block\nsize that is close, but not over, one half the size of a track.\nHowever, there is one word of caution: if your shop decides to\nre-block the POWER files, too large a block size may actually\nwaste more disk space because the blocks would not be full.\nAlso check with all vendors that read POWER tapes, offloads,\nsuch as micro-fiche vendors; some have restrictions on how\nlarge the block size may be.\n\nKelvin J Menzel\nSystems Programmer (USA)                         c K J Menzel 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E004A08": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00]\\x00]\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 93, "newlines": 93, "modlines": 0, "user": "VSEUPDT"}, "text": "How to obtain volume characteristics information\n\nIt may often be useful for a program to provide information\nabout DASD characteristics or actual DASD status.  For\nexample, it may be useful to know a DASD device type;\nwhether it is shareable; the VTOC start address; the track\nbalance information (number of remaining data bytes on a\ntrack); and so on.  This, and other useful information related to\nDASD (and also tape) devices, can easily be obtained by\ncalling the macro GETVCE (SVC99, X'63') from an Assembler\nroutine.\n\nA simple application might consist of a test from a batch\nprogram to check whether a specific DASD VOLSER exists\nand is operational.  (This is similar to the information obtained\nwith AR command VOLUME.)  For example, it is possible, at\nan unattended site, to verify from a batch program whether a\nspecific VOLSER is used and operational, and to set a return\ncode to be tested with conditional JCL for a possible skip of a\n//ASSGN STMT, that would otherwise get the message 1A67D\nUNIT CURRENTLY UNASSIGNABLE.\n\nThe return codes from this macro are well explained in the\nVSE Messages manual (page VSE-13 of SC33-6310 for\nVSE/SP 3.1), but only in the Supervisor Program Logic\nManual is it possible to find out how to code it.  The simple\nroutine shown here shows only how to code the macro with the\nVOLID parameter, and the possible return code that GETVCE\nreturns in register 15.  It is not a complete program.  A detailed\nexplanation of all the parameters may be found in the\nSupervisor Logic Manual.  A DSECT of the information\nreturned from GETVCE in the program area addressed by the\nAREA parameter may be found in the Supervisor assembly\nlisting (AVRADR DSECT).\n\n* $$ JOB JNM=GETVCE,CLASS=0\n* $$ LST CLASS=Q,DISP=JL\n// JOB GETVCE\n*   CHECK THE STATUS OF A PARTICULAR DASD\n// LIBDEF *,SEARCH=(IJSYSRS.SYSLIB)\n// OPTION LINK,NOSYSDMP,PARTDUMP\n// LIBDEF PHASE,CATALOG=IJSYSRS.SYSLIB\n// EXEC ASSEMBLY,SIZE=256K\nGETVCE   CSECT\nVIA      BALR 2,0\n         USING *,2\n         GETVCE AREA=AREA1.VOLID=DEVNAME\n         STC   15,RETCODE\n         CLI   RETCODE,X'00'\n         BE    OKDASD  OK\n         CLI   RETCODE,X'04'\n         BE    OKNVAL    OK, BUT SOME DATA NON VALID (SEE AVRFLAG)\n         CLI   RETCODE,X'08'\n         BE    NOTMOUNT  VOLUME NOT MOUNTED,OR LOGICAL UNIT NOT ASSIGN\n         CLI   RETCODE,X'0C'\n         BE    LUIGN           LOGICAL UNIT ASSIGNED IGNORE\n         CLI   RETCODE,X'10'\n         BE    NOTOP           DEV NOT OPERATIONAL\n         CLI   RETCODE,X'14'\n         BE    INVPARM         PARM LIST INVALID\n         CLI   RETCODE,X'18'\n         BE    NODASD          LOGICAL UNIT OR DEVICE NOT A DASD\n         CLI   RETCODE,X'1C'\n         BE    NOREADY         DEVICE NOT READY\n         CLI   RETCODE,X'24'\n         BE    TRK             FOR TRKBAL OR TRKAP REQUEST ONLY\n*\nOKDASD   EQU   *\nOKNVAL   EQU   * (AVRFLAG) SOME DATA NOT VALID\nNOTMOUNT EQU   * VOL NOT MOUNTED\nLUIGN    EQU   * LU ASSGN IGNORE\nNOTOP    EQU   * DEV NOT OPERATIONAL\nINVPARM  EQU   * PARM LIST INVALID\nNODASD   EQU   * LU OR DEV NOT DASD\nNOREADY  EQU   * DEV NOT READY\nTRK      EQU   * FOR TRKBAL OR TRKAP REQUEST ONLY\n*\n         EOJ   RC=(15)\nAREA1    DC    XL60'00'\nDEVNAME  DC    C'XXXRES'   <---   VOLID   TO  CHECK   *******\nRETCODE  DC    X'00'\n         END\n/*\n// EXEC LNKEDT\n// EXEC ,SIZE=AUTO\n/*\n/&\n* $$ EOJ\n\nGianni Orione\nSystems Engineer\nOlivetti Systems & Networks (Italy)        c Olivetti Systems & Networks 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E005A00I": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 11, "newlines": 11, "modlines": 0, "user": "VSEUPDT"}, "text": "E005 - VSE Update issue #5  March 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE005A01   Coding SVA eligible programs\nE005A02   Operator communication interrupt\nE005A03   RSCS to POWER\nE005A04   Setting return codes from within COBOL\nE005A05   Unload magnetic tape drives for reuse\nE005A06   POWER time event scheduling exposed\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E005A01": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x03k\\x03k\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 875, "newlines": 875, "modlines": 0, "user": "VSEUPDT"}, "text": "Coding SVA eligible programs\n\nThis article is designed to introduce the coding requirements\nfor writing a Shared Virtual Area (SVA) resident phase. I will\nfirst give an overview of the SVA, its contents, and the SVA\nprogramming requirements. Next, I will discuss the two\nprograms provided and the SVA coding necessary to meet the\nSVA programming requirements.\n\nThe Shared Virtual Area (SVA) is used to contain frequently\nused programs. It is built by IPL in the high end of virtual\nstorage on VSE/SP systems and either the high end of virtual\nstorage or immediately following the supervisor on VSE/ESA\nsystems. The SVA contains:\n\no      A System Directory List (SDL) of either descriptors of\n      SVA resident programs (phases) or in-storage directory\n      entries of highly used programs (phases). An SDL entry\n      contains all the information required to satisfy the\n      fetch/load services of VSE. Entries in the SDL are copies\n      of specific library directory entries. An entry is built for\n      each phase that IPL will load into the SVA.\n\no      Highly used programs (phases) located in the SVA can be\n      shared between partitions (virtual library). These programs\n      run with the PSW of the requesting task. SVA resident\n      programs must be relocatable and re-enterable.\n\nIf a program is not in the virtual library it is loaded into the\nrequesting partition. A phase loaded into the SVA is loaded at\nthe next available double word boundary.\n\nThe SVA command is used at system IPL to reserve space for\nadditional SVA entries. The SVA command is used to increase\nthe SVA size beyond that set by the VSE system at IPL. The\nIPL program automatically allocates space in the SVA using\nloadlist found in the system sublibrary. Many IBM licenced\nproducts are shipped with loadlist. The phases the system loads\ninto the SVA during start-up are prefixed with the characters\n$SVA. To obtain the names of phases in the loadlist use the\nLIBR access command ACCESS IJSYSRS.SYSLIB followed\nby the list command LIST $SVA*.PHASE.\n\nThe SVALIST macro is used to create a private SVA loadlist.\nFor example, to assemble a loadlist with the name $SVAUSER\ncode the following job stream:\n\n      // J0B LOADLIST\n      // LIBDEF PHASE,CATALOG=IJSYSRS.SYSLIB\n      // OPTION CATAL\n      // EXEC ASSEMBLY\n         SVALIST $SVAUSER,(phase1),(phase2),(phasen)\n         END\n      /*\n      // EXEC LNKEDT\n      /&\n\nThe first operand of the SVALIST macro is the phase name for\nthe new loadlist. The second through nth operands are the\nnames of the phases that you want to be loaded into the SVA\nautomatically during start-up.\n\nThe LIST=loadlist command may be issued following the SET\nSDL command for a user loadlist. The phase names in the list\nare located by VSE using the LIBDEF search string that is\nactive and loads the phases into the SVA. This additional space\nallocation is for SDL entries, phases, and system GETVIS.\n\nThe SET SDL command is issued to cause SDL entries to be\nbuilt and phases to be loaded into the SVA. As shipped with\nVSE, user SVA programs are added to a VSE background\nprocedure whose name is USERBG. The user phase names are\nadded between the SET SDL command and the /* statement. A\nphase catalogued as SVA eligible (SVA operand in the linkage\neditor PHASE statement) is loaded into the SVA, if it is\ncatalogued in the system sublibrary IJSYSRS.SYSLIB and a\nphase of the same name is already in the SVA, or if a phase of\nthat name had been specified in the SET SDL command. If the\nphase has an entry in the SDL, that entry is updated.\n\nThe SET SDL must be issued from the background (BG)\npartition and may be given any time after IPL. It may be issued\nany number of times. Following the SET SDL command are\none or more statements in the format 'name,SVA', where name\nis any valid phase name and SVA indicates whether or not the\nphase is to be loaded into the SVA. If SVA was specified and\nthe phase is SVA eligible, the job control program will cause\nthe phase to be loaded into the SVA. If the phase is not found a\nmessage is issued and a dummy entry is made in the SDL.\n\nThe two programs presented below demonstrate the coding\nnecessary to execute a program from the SVA. Program one\n(HCLSTSVA) is a driver program whose only function is to\nfetch the SVA resident program (HCPRTSVA). HCPRTSVA is\nan Assembler program that demonstrates a coding technique for\nrunning in the SVA. HCPRTSVA must be added to your SET\nSDL procedure to be loaded into the SVA. HCPRTSVA prints\nthe formatted contents of all SVA table entries, the formatted\ncontents of each SDL entry, an interpreted dump of the\noccupied SVA, and an interpreted dump of system GETVIS.\nThe interpreted dumps are optional. They are used for\ndebugging SVA phases or data areas. The interpreted hex\ndump of occupied SVA and system GETVIS is requested by\nsubmitting a // UPSI 1 with the HCLSTSVA job stream. A //\nUPSI 01 will cause a PDUMP of the SVA to verify directory\nformat, locations contents, and data areas when the program\nthinks there is not an SVA or when changes in VSE cause\nincorrect output. The // UPSI 01 is helpful in making changes\nto HCPRTSVA and verifying SVA contents and format.\n\nSince SVA resident programs must be relocatable and re-\nenterable these SVA programs cannot use data areas within the\nprogram to store data. To satisfy this requirement HCPRTSVA\nissues the GETVIS macro to request the storage for the work\narea. This work area is referenced via a dummy section\n(DSECT) that is pointed to by register 8. The macros issued by\nthe HCPRTSVA program are documented at the beginning\nalong with the register usage. The macros that generate a\nDSECT to map the SVA data areas, system communications\nregion, and communication region are hard-coded. These\nDSECTs can be compared to the macros in your VSE system\nlibrary for any changes between VSE releases. Having these\nmacros hard-coded in the program helps you to determine if\nchanges have been made between releases that will affect the\nexecution output of the program as well as making the program\neasier to read.\n\nHCPRTSVA first prints a heading containing the date and the\nCPU-id. If you ever need access to the CPU-id, this code can\nbe used. The second heading line prints the information shown\nin Figure 1 followed by a heading line that shows the start of\nthe SDL.\n\nEach data line in the body of the report contains information\nabout an entry in the SDL. This information includes the areas\nshown in Figure 2.\n\nNote that the CCB and CCW used in the HCPRTSVA are\nmade relocatable in the GETVIS obtained work area. Also, the\nPDUMP used to print the SVA area is hard-coded to make it\nre-entrant.\n\n\nHCLSTSVA\n\n     PRINT NOGEN\n     TITLE 'HCLSTSVA. DRIVER FOR HCPRTSVA PROGRAM'\n     PUNCH  ' PHASE HCLSTSVA,* '\nMAINLINE START 0\n*/*DOC*+------------------------------------------------------------+*/\n*/*DOC*| PROCEDURE: FETCH PROGRAM TO      | SECTION:                |*/\n*/*DOC*|  PRINT CONTENTS OF VSE/SP SVA    | CONTROLLING CSECT       |*/\n*/*DOC*|------------------------------------------------------------|*/\n*/*DOC*|                                                            |*/\n*/*DOC*+------------------------------------------------------------+*/\nR0       EQU   0 .                 EQUATE                            */\nR1       EQU   1 .                 ALL                               */\nR2       EQU   2 .                 THE                               */\nR3       EQU   3 .                 REGISTERS                         */\nR4       EQU   4 .                 TO                                */\nR5       EQU   5 .                 SYMBOLS                           */\nR6       EQU   6 .                 SO                                */\nR7       EQU   7 .                 THAT                              */\nR8       EQU   8 .                 REGISTER                          */\nR9       EQU   9 .                 USAGE                             */\nR10      EQU   10 .                MAY                               */\nR11      EQU   11 .                BE                                */\nR12      EQU   12 .                TRACED                            */\nR13      EQU   13 .                IN THE                            */\nR14      EQU   14 .                CROSS REFERENCE                   */\nR15      EQU   15 .                LISTING                           */\n*/*------------------------------------------------------------------*/\n         BALR  R11,0                 /* ESTABLISH ADDRESSABILITY.    */\n         USING *,R11                 /* IDENTIFY BASE REGISTER.      */\n         LA    R13,SAVEAREA          /* POINT TO SAVE-AREA.          */\n         LA    R14,RETURN            /* SET UP RETURN REGISTER.      */\n         FETCH HCPRTSVA              /* LOAD AND EXECUTE PHASE.      */\nRETURN   EQU   *                     /* EXIT TO VSE                  */\n         EOJ                         /* END OF JOB                   */\n*------------------------------------/*                              */\nSAVEAREA DS    18F                   /* REGISTER SAVEAREA            */\n*/*------------------------------------------------------------------*/\n         END\n\n\nHCPRTSVA\n\n         TITLE '      <<<<   S V A    D U M P    U T I L I T Y   >>>>  .\n                 P R O D U C T I V I T Y    A I D'\n         PUNCH   '  PHASE HCPRTSVA,*,SVA  '\n         PRINT NOGEN\nHCPRTSVA START 0\n*/*DOC*+------------------------------------------------------------+*/\n*/*DOC*| PROCEDURE:                            | SECTION:           |*/\n*/*DOC*|   PRINT CONTENTS OF VSE/SP  SVA       |  CONTROLLING CSECT |*/\n*/*DOC*|------------------------------------------------------------|*/\n*/*DOC*|                                                            |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|HCPRTSVA IS RE-ENTRANT, SELF-RELOCATING AND SVA-ELIGIBLE.   |*/\n*/*DOC*|THIS PROGRAM DISPLAYS THE FOLLOWING INFORMATION ON 'SYSLST':|*/\n*/*DOC*|                                                            |*/\n*/*DOC*|      1.  FORMATTED CONTENTS OF ALL SVA TABLE ENTRIES.      |*/\n*/*DOC*|      2.  FORMATTED CONTENTS OF EACH SDL ENTRY.             |*/\n*/*DOC*|      3.  INTERPRETED DUMP OF OCCUPIED SVA.                 |*/\n*/*DOC*|      4.  INTERPRETED DUMP OF SYSTEM GETVIS AREA, IF PRESENT|*/\n*/*DOC*|                                                            |*/\n*/*DOC*| IF A // UPSI 1 STATEMENT IS SUBMITTED WITH THE JCL THE     |*/\n*/*DOC*| OCCUPIED PART OF THE SVA IS PRINTED. LOTS OF PAPER!        |*/\n*/*DOC*|                                                            |*/\n*/*DOC*| IF A // UPSI 01 STATEMENT IS SUBMITTED WITH THE JCL A      |*/\n*/*DOC*| PDUMP IS REQUESTED. THIS IS FOR TESTING TO GET A DUMP OF   |*/\n*/*DOC*| SVA TO VERIFY DIRECTORY AND LOCATION CONTENTS WHEN THE     |*/\n*/*DOC*| PROGRAM THINKS THERE IS NOT AN SVA.                        |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|************************************************************|*/\n*/*DOC*|                                                            |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|       R E G I S T E R    U S A G E                         |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|       0                   WORK.                            |*/\n*/*DOC*|       1                   WORK.                            |*/\n*/*DOC*|       2                   WORK.                            |*/\n*/*DOC*|       3                   SVA BASE REGISTER.               |*/\n*/*DOC*|       4                   ADDRESS POINTER FOR DUMP.        |*/\n*/*DOC*|       5                   END OF DUMP, OR OCCUPIED SVA.    |*/\n*/*DOC*|       6                   START OF SYSTEM GETVIS AREA.     |*/\n*/*DOC*|       7                   END OF VIRTUAL STORAGE.          |*/\n*/*DOC*|       8                   PARTITION GETVIS BASE REGISTER.  |*/\n*/*DOC*|       9                   INTERNAL RETURN.                 |*/\n*/*DOC*|       10                  WORK.                            |*/\n*/*DOC*|       11                  WORK.                            |*/\n*/*DOC*|       12                  PROGRAM BASE REGISTER.           |*/\n*/*DOC*|       13                  SAVE AREA.                       |*/\n*/*DOC*|       14                  INTERNAL RETURN.                 |*/\n*/*DOC*|       15                  WORK.                            |*/\n*/*DOC*|                                                            |*/\n*/*DOC*| MACROS USED: MACROS ARE IN IJSYSRS.SYSLIB                  |*/\n*/*DOC*| ------------                                               |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|        GETVIS                                              |*/\n*/*DOC*|        COMRG                                               |*/\n*/*DOC*|        EOJ                                                 |*/\n*/*DOC*|        EXCP                                                |*/\n*/*DOC*|        WAIT                                                |*/\n*/*DOC*|        CCB                                                 |*/\n*/*DOC*|        MAPDNTRY                                            |*/\n*/*DOC*|        MAPCOMR                                             |*/\n*/*DOC*|        SYSCOM                                              |*/\n*/*DOC*|        MAPSVAHD                                            |*/\n*/*DOC*|                                                            |*/\n*/*DOC*|------------------------------------------------------------|*/\n*/*DOC*| MAINTENANCE HISTORY.                                       |*/\n*/*DOC*|                                                            |*/\n*/*DOC*+------------------------------------------------------------+*/\n         SPACE 1                                                     */\n**********************************************************************/\n*                                                                    */\n**********     R E G I S T E R    E Q U A T E S     ******************/\n*                                                                    */\n**********************************************************************/\n         SPACE 1                                                     */\nR0       EQU   0 .                 EQUATE                            */\nR1       EQU   1 .                 ALL                               */\nR2       EQU   2 .                 THE                               */\nR3       EQU   3 .                 REGISTERS                         */\nR4       EQU   4 .                 TO                                */\nR5       EQU   5 .                 SYMBOLS                           */\nR6       EQU   6 .                 SO                                */\nR7       EQU   7 .                 THAT                              */\nR8       EQU   8 .                 REGISTER                          */\nR9       EQU   9 .                 USAGE                             */\nRA       EQU   10 .                MAY                               */\nR10      EQU   10                                                    */\nRB       EQU   11 .                BE                                */\nR11      EQU   11                                                    */\nRC       EQU   12 .                TRACED                            */\nR12      EQU   12                                                    */\nRD       EQU   13 .                IN THE                            */\nR13      EQU   13                                                    */\nRE       EQU   14 .                CROSS-REFERENCE                   */\nR14      EQU   14                                                    */\nRF       EQU   15 .                LISTING                           */\nR15      EQU   15                                                    */\n         TITLE 'HCPRTSVA INITIALIZATION '\n         BALR  R12,0                 /*ESTABLISH BASE REGISTER.      */\n         USING *,R12                 /*                              */\n         USING WORKAREA,R8           /*POINTER FOR GETVIS DATA AREA. */\n*/*------------------------------------------------------------------*/\n*        HCLIC &TYPE=DM,             /* DOS MONITORS SYSTEM          */\n*              &RETURN=EOJ,          /*                              */\n*              &RELO=,               /*                              */\n*              &PRODUCT=9576-DM3,    /* PRODUCT ID                   */\n*              &DATE=03/01/84,       /*                              */\n*              &VM=01.00,            /* VERSION MOD                  */\n*              &PHASE=HCPRTSVA       /* PHASE NAME                   */\n*/*------------------------------------------------------------------*/\n*/*                                  /*                              */\n*/*------------------------------------------------------------------*/\n*/*   H O U S E K E E P I N G                                        */\n*/*------------------------------------------------------------------*/\n         GETVIS ADDRESS=(R8),        /*       GET PARTITION WORK-AREA*/C\n               LENGTH=WORKSIZE       /*                              */\n         LTR   R15,R15               /*WAS THE GETVIS SUCCESSFUL ?   */\n         BZ    GOTVIS                /*IF YES, USE THE SUPPLIED ADDR */\n         LA    R8,WORKSIZE+4         /*OTHERWISE-ASSUME NO SIZE USED.*/\nGOTVIS   EQU   *                     /*                              */\n         XC    LINES,LINES           /*CLEAR LINE COUNTERS           */\n         XC    LINECT,LINECT         /*                              */\n         MVI   BLANK,C' '            /*INITIALIZE BLANK CONSTANT.    */\n         MVC   PRINTO,PRINTO-1       /*BLANK OUT PRINT LINE.         */\n         MVI   Z0,X'00'              /*INITIALIZE ZONE CONSTANT.     */\n         MVC   CCB(16),PRCCB         /*COPY CCB INTO GETVIS AREA.    */\n         LA    R1,CCW                /*POINT TO WORKING COPY OF CCW  */\n         STCM  R1,X'07',CCB+9        /*POINT THE CCB TO WORKING CCW  */\n         MVC   CCW,PRCCW             /*COPY CCW INTO GETVIS AREA.    */\n         LA    R1,PRINTO             /*GET I/O AREA ADDRESS.         */\n         STCM  R1,X'07',CCW+1        /*PUT I/O AREA ADDRESS IN CCW.  */\n         MVI   CCW,X'89'             /*SKIP TO TOP OF PAGE           */\n*------------------------------------/*                              */\n         SR    R3,R3                 /*CLEAR WORK REGISTER           */\n         USING COMREG,R1             /*                              */\n         COMRG                       /*                              */\n         MVC   HOLDDATE,JOBDATE      /*MM/DD/YY                      */\n         MVC   HOLDUPSI,UPSI         /*SAVE UPSI BYTE                */\n         IC    R3,SYSLINE            /*GET SYSLST LINE COUNT         */\n         BCTR  R3,R0                 /*MINUS 1 FOR HEADING           */\n         STC   R3,LINES+1            /*SAVE SYSLST LINE COUNT        */\n         STC   R3,LINECT+1           /*                              */\n         L     R7,EOCADR             /*GET ADDR OF END OF VIRT STOR  */\n         DROP  R1                    /*                              */\n         L     R1,X'80'              /*GET SYSCOM START ADDRESS.     */\n         USING SYSCOM,R1             /*SYSTEM COMMUNICATION AREA     */\n         L     R3,IJBRASLN           /*A(RAS LINKAGE)  IJBRASLN      */\n         MVC   HOLDCPU,1(R3)         /*                              */\n         L     R3,IJBSVA             /*GET SVA START ADDRESS.        */\n         USING DSVA,R3               /* SVA AREA                     */\n         LA    R3,0(R3)              /*CLEAR HIGH ORDER BITS         */\n         ST    R3,SAVESTRT           /*SAVE START ADDRESS            */\n         L     R5,DSVAEND            /*POINTER FOR END   OF SVA DUMP.*/\n         L     R6,IJBSVIS            /*GET GETVIS START ADDRESS.     */\n*------------------------------------/*                              */\n         DROP R1                     /*                              */\n*------------------------------------/*                              */\n         BCTR  R7,0                  /*DECREMENT BY 1.               */\n         CLC   ZEROES,DSVATIME       /*NOTHING IN SVA ?              */\n         BNE   SVAPRES               /*                              */\n         MVC   PRINTO(14),=C'NO SVA ACTIVE.'                         */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(13),TITLE      /*                              */\n         BAL   R14,PRINT             /*                              */\n         B     EXIT                  /*NOTHING TO PRINT, SO EXIT.    */\n*------------------------------------/*                              */\n         TITLE 'HCPRTSVA  PRINT TABLE ENTIRES'\n*/*------------------------------------------------------------------*/\n*        P R I N T    S V A    T A B L E    E N T R I E S            */\n*/*------------------------------------------------------------------*/\nSVAPRES  EQU   *                     /*                              */\n         TM    HOLDUPSI,X'01'        /*USE  PDUMP TO VERIFY OUTPUT ? */\n         BO    PDUMPIT               /*YES PRINT SVA VIA PDUMP       */\n         B     BYPASS                /*    PRINT SVA HEADER          */\n*------------------------------------/*                              */\nPDUMPIT  EQU   *                     /*                              */\n*                                    /*                              */\n*        REENTRANT 'PDUMP' ROUTINE * /*                              */\n*                                    /*                              */\n         ST    R3,STARTEND           /*SET UP ADDRESSES              */\n         ST    R7,STARTEND+4         /*TO MAKE 'PDUMP' REENTRANT.    */\n         LA    R1,=CL8'$$BPDUMP'     /*IDENTIFY TRANSIENT TO BE FETCH*/\n         LA    R0,STARTEND           /*POINT TO START / END ADDRESSES*/\n         SVC   2                     /*CALL 'PDUMP.                  */\n*------------------------------------/*                              */\nBYPASS   EQU   *                     /*                              */\n         TITLE 'HCSVAPRT  PRINT SVA HEADER INFORMATION'\n*/*------------------------------------------------------------------*/\n*        P R I N T    S V A    H E A D E R                           */\n*/*------------------------------------------------------------------*/\n         BAL   R14,PRINT             /*SPACE.                        */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(L'HDR1),HDR1   /*MOVE IN HEADER                */\n         USING COMREG,R1             /*                              */\n         MVC   PRINTO+61(8),HOLDDATE /*GET THE DATE                  */\n         MVC   UNPKA(5),HOLDCPU      /*PRINT CPU ID                  */\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO+75(9),=C'CPU ID = '                            */\n         MVC   PRINTO+84(10),UNPKO   /*CPUID                         */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO+45(11),TITLE   /*UNDERLINE TITLE.              */\n         BAL   R14,PRINT             /*PRINT UNDERLINE               */\n         BAL   R14,PRINT             /*SPACE AFTER HEADING           */\n         MVC   PRINTO(105),SVATITLE  /*                              */\n         BAL   R14,PRINT             /* PRINT SVA HEADING ONE        */\n         MVC   PRINTO(105),TITLE     /*UNDERLINE TITLE               */\n         BAL   R14,PRINT             /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n         ST    R3,UNPKA              /*SVA START ADDRESS.            */\n*------------------------------------/*                              */\n         LR    R1,R3                 /*SVA START ADDRESS             */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO(8),PRINTWRK    /* MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         L     R1,DSVATIME           /*LAST UPDATE TIME/DATE         */\n         ST    R1,UNPKA              /*                              */\n         BAL   R14,UNPK              /* CONVERT TO PRINTABLE         */\n         MVC   PRINTO+12(16),UNPKO   /* MOVE TO PRINT LINE           */\n*------------------------------------/*                              */\n         L     R1,DSVAVL             /*START OF VIRTUAL LIBRARY      */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+33(8),PRINTWRK /* MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         L     R1,DSVAFPTR           /* PNTR TO NEXT FREE SVA ENTRY  */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+44(8),PRINTWRK /* MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         L     R1,DSVAEND            /* END OF SVA PROGRAM AREA      */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+55(8),PRINTWRK /* MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         L     R1,DSVASDL            /*GET ADDRESS OF SDL FROM SVA.  */\n         LA    R1,4(R1)              /*ADJUST TO CORRECT VALUE.      */\n         BAL   R14,ADDRSUB           /* CONVERT TO PRINTABLE         */\n         MVC   PRINTO+65(8),PRINTWRK /* MOVE TO PRINT LINE           */\n*------------------------------------/*                              */\n         L     R1,DSVAFSDL           /* ADDR OF NEXT SDL ENTRY       */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+76(8),PRINTWRK /* MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         LH    R1,DSVAENT            /* NUMBER OF SDL ENTRIES        */\n         BCTR  R1,0                  /* DECREMENT BY ONE             */\n         CVD   R1,UNPKA              /*CREATE PACKED FORMAT.         */\n         MVC   PRINTO+86(4),=X'4020202021'         SET UP EDIT FIELD.*/\n         ED    PRINTO+86(4),UNPKA+6  /*PUT NUMBER ENTIRES  IN LINE.  */\n*------------------------------------/*                              */\n         LH    R1,DSVALENT           /* LENGTH OF A SDL ENTRY        */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+97(4),PRINTWRK+4  MOVE TO OUTPUT LINE          */\n*------------------------------------/*                              */\n         BAL   R14,PRINT             /*                              */\n*------------------------------------/*                              */\n         TITLE 'HCPRTSVA  PRINT THE SDL LIST'\n*--------------------------------------------------------------------*/\n*        P R I N T    S Y S T E M    D I R E C T O R Y    L I S T    */\n*--------------------------------------------------------------------*/\n         BAL   R14,PRINT             /*SPACE.                        */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(25),=C'SYSTEM DIRECTORY DISPLAY:'              */\n         MVC   PRINTO+39(14),=C'START OF SDL ='                      */\n         L     R4,DSVASDL            /*GET ADDRESS OF SDL FROM SVA.  */\n         LA    R4,4(R4)              /*ADJUST TO CORRECT VALUE.      */\n         ST    R4,UNPKA              /*                              */\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO+54(8),UNPKO    /*                              */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(25),TITLE      /*UNDERLINE TITLE.              */\n         BAL   R14,PRINT             /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(94),SDLTITLE   /*                              */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(94),TITLE      /*                              */\n         BAL   R14,PRINT             /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n*/*----------------------------------/*                              */\nPRINTSDL EQU   *                     /*                              */\n         CR    R4,R5                 /* NO END OF SDL FOUND IN SVA ? */\n         BH    ENDIT                 /*GIVE UP IF END NOT FOUND.     */\n         ST    R4,UNPKA              /*SDL ENTRY ADDRESS.            */\n         USING SDLENTRY,R4           /* SVA SDL DSECT ADDRESSIBILITY */\n         LR    R1,R4                 /*SDL ENTRY ADDR INTO REG 1     */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO(8),PRINTWRK    /* MOVE TO OUTPUT LINE          */\n         MVC   PRINTO+11(8),SDLENAM  /*PHASE-NAME.                   */\n*                                    /*                              */\n         MVC   PRINTO+22(3),=C'YES'  /*DEFAULT TO IN THE SVA         */\n         TM    SDLEPFL,SDLEBSD       /*IN SVA                        */\n         BO    CKSYSLIB              /*                              */\n         MVC   PRINTO+22(3),=C' NO'  /*NOT IN THE SVA                */\n*                                    /*                              */\nCKSYSLIB EQU   *                     /*                              */\n         MVC   PRINTO+31(3),=C'YES'  /*DEFAULT TO IN IJSYSRS.SYSLIB  */\n         TM    SDLEPFL,SDLEBPC       /*IN PRIVATE LIBRARY            */\n         BNO   CKLOAD                /*NO, MUST BE IN SYSLIB         */\n*                                    /*YES, SET NOT IN SYSLIB FLAG   */\n         MVC   PRINTO+31(3),=C' NO'  /*PHASE NOT  IN IJSYSRS.SYSLIB  */\n*                                    /*                              */\nCKLOAD   EQU   *                     /*                              */\n         MVC   PRINTO+40(3),=C'YES'  /*DEFAULT TO PHASE LOADABLE     */\n         TM    SDLEPFL,SDLEBSE       /*SVA ELIGIBLE                  */\n         BO    GETLNK                /*YES                           */\n*                                    /*NO                            */\n         MVC   PRINTO+40(3),=C' NO'  /*PHASE NOT LOADABLE            */\n*                                    /*                              */\nGETLDSET EQU   *                     /*                              */\n         MVC   PRINTO+40(3),=C'YES'  /*DEFAULT TO PHASE ELIGIBLE     */\n         TM    SDLESWT,SDLECLS       /*SVA ELIGIBLE FROM SET SDL SVA */\n         BO    GETLNK                /*YES,                          */\n*                                    /*NO, RESET FLAG                */\n         MVC   PRINTO+40(3),=C' NO'  /*PHASE NOT LOADABLE            */\n*                                    /*                              */\nGETLDMVE EQU   *                     /*                              */\n         MVC   PRINTO+40(3),=C'YES'  /*DEFAULT TO PHASE LOADABLE     */\n         TM    SDLESWT,SDLECLM       /*SVA ELIGIBLE FROM SET SDL MOVE*/\n         BO    GETLNK                /*YES, ALREADY SET TO YES       */\n*                                    /*NO, RESET FLAG                */\n         MVC   PRINTO+40(3),=C' NO'  /*PHASE NOT LOADABLE            */\n*                                    /*                              */\nGETLNK   EQU   *                     /*                              */\n         L     R1,SDLELPT            /*LOAD POINT AT LNKEDT TIME     */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+50(8),PRINTWRK /*LOAD  POINT AT LNKEDT TIME.   */\n*                                    /*                              */\n         L     R1,SDLEENP            /*ENTRY POINT AT LNKEDT TIME.   */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+59(8),PRINTWRK /*LOAD  POINT AT LNKEDT TIME.   */\n*                                    /*                              */\n         L     R2,SDLEPLN            /*LENGTH OF PHASE IN BYTES      */\n         CVD   R2,UNPKA              /*CREATE PACKED FORMAT.         */\n         MVC   PRINTO+67(7),=X'402020202021D2'     SET UP EDIT FIELD.*/\n         ED    PRINTO+67(6),UNPKA+5  /*PUT STORAGE ADDRESS IN LINE.  */\n*                                    /*                              */\n         L     R1,SDLESTR            /*PARTN START AT LNKEDT TIME.   */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+76(8),PRINTWRK /*PARTITION START ADDR AT LNKEDT*/\n*                                    /*                              */\n         L     R1,SDLESVAP           /*ENTRY POINT OF PHASE IN SVA.  */\n         BAL   R14,ADDRSUB           /*CONVERT TO PRINTABLE HEX      */\n         MVC   PRINTO+85(8),PRINTWRK /*ENTRY POINT OF PHASE IN SVA.  */\n*                                    /*                              */\n         BAL   R14,PRINT             /*                              */\n*------------------------------------/*                              */\n         AH    R4,DSVALENT           /*POINT TO NEXT SDL TABLE ENTRY.*/\n         CLC   X8FS,SDLENAM          /*LAST ENTRY IN SDL ?           */\n         BNE   PRINTSDL              /*REPEAT FOR EACH SDL ENTRY.    */\n*------------------------------------/*                              */\n         DROP  R4                    /*THROUGH WITH SDL DSECT        */\n         TM    HOLDUPSI,X'80'        /*PRINT OCCUPIED SVA AREA ?     */\n         BNO   CKGETVIS              /*NO, CHECK FOR GETVIS PRINT    */\n*--------------------------------------------------------------------*/\n*        P R I N T    S V A    H E A D E R                           */\n*--------------------------------------------------------------------*/\n         MVI   LINES+1,X'01'         /*FORCE SKIP TO TOP OF PAGE     */\n         BAL   R14,PRINT             /* SPACE.                       */\n         MVC   PRINTO(19),=C'DUMP OF SVA PHASES:'                    */\n         MVC   PRINTO+26(27),=C'START OF SVA PROGRAM AREA ='         */\n         L     R4,SAVESTRT           /*                              */\n         ST    R4,UNPKA              /*START ADDR FOR SVA-RES PHASES */\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO+54(8),UNPKO    /*                              */\n         MVC   PRINTO+98(34),=C'(LINES WITH ALL ZEROS NOT PRINTED)'  */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(18),TITLE      /*UNDERLINE TITLE.              */\n         BAL   R14,PRINT             /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n*--------------------------------------------------------------------*/\n*        D U M P    S H A R E D    V I R T U A L    A R E A          */\n*--------------------------------------------------------------------*/\n         SRL   R4,5                  /*ROUND DOWN TO NEAREST         */\n         SLL   R4,5                  /*32 BYTE BOUNDARY.             */\n*                                    /*R5 POINTS TO END OF USED SVA  */\n         BAL   R9,DUMP               /*DUMP ALL OF OCCUPIED SVA.     */\n*                                    /*                              */\nCKGETVIS LTR   R6,R6                 /*WAS SYS GETVIS AREA DEFINED?  */\n         BZ    EXIT                  /*IF NOT, DUMP IS COMPLETE.     */\n         TM    HOLDUPSI,X'80'        /*PRINT OCCUPIED GETVIS AREA ?  */\n         BNO   EXIT                  /*NO, DUMP IS COMPLETE PRINT    */\n*------------------------------------/*                              */\n*--------------------------------------------------------------------*/\n*        P R I N T    G E T V I S    H E A D E R                     */\n*--------------------------------------------------------------------*/\n         MVI   LINES+1,X'01'         /*FORCE SKIP TO TOP OF PAGE     */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(27),=C'DUMP OF SYSTEM GETVIS AREA:'            */\n         MVC   PRINTO+31(22),=C'START OF GETVIS AREA ='              */\n         ST    R6,UNPKA              /*SYSTEM GETVIS START ADDRESS.  */\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO+54(8),UNPKO    /*                              */\n         LR    R2,R6                 /*GET START OF GETVIS ADDRESS.  */\n         BAL   R14,EDITSIZE          /*PLACE IN OUTPUT IN FORM -----K*/\n         MVC   PRINTO+63(8),=X'7E402020202021D2'   SET UP EDIT FIELD.*/\n         ED    PRINTO+64(6),UNPKA+5  /*PUT STORAGE ADDRESS IN LINE.  */\n         MVC   PRINTO+98(34),=C'(LINES WITH ALL ZEROS NOT PRINTED)'  */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(26),TITLE      /*UNDERLINE TITLE.              */\n         BAL   R14,PRINT             /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n*--------------------------------------------------------------------*/\n*        D U M P    O F    S Y S T E M    G E T V I S    A R E A     */\n*--------------------------------------------------------------------*/\n         LR    R4,R6                 /*JUMP TO START OF GETVIS.      */\n         LR    R5,R7                 /*POINT TO END OF VIRTUAL STOR  */\n         BAL   R9,DUMP               /*DUMP SYSTEM GETVIS AREA.      */\n         B     EXIT                  /*DUMP COMPLETED.               */\n*------------------------------------/*                              */\n*--------------------------------------------------------------------*/\n*        E O J                                                       */\n*--------------------------------------------------------------------*/\nENDIT    EQU   *                     /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(28),=C'END OF SVA BEFORE END OF SDL'           */\n         BAL   R14,PRINT             /*                              */\n*                                    /*GO RETURN TO MAINLINE         */\n*                                    /*                              */\nEXIT     EQU   *                     /*                              */\n         BAL   R14,PRINT             /*SPACE.                        */\n         MVC   PRINTO(25),=C'END OF SVA / GETVIS DUMP.'              */\n         MVC   PRINTO+29(24),=C'END OF VIRTUAL STORAGE ='            */\n         ST    R7,UNPKA              /*END OF VIRTUAL STORAGE ADDRESS*/\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO+54(8),UNPKO    /*                              */\n         LA    R2,1(R7)              /*GET END OF VITUAL STORAGE     */\n         BAL   R14,EDITSIZE          /*PLACE IN OUTPUT IN FORM -----K*/\n         MVC   PRINTO+63(8),=X'7E402020202021D2'   SET UP EDIT FIELD.*/\n         ED    PRINTO+64(6),UNPKA+5  /*PUT STORAGE ADDRESS IN LINE.  */\n         BAL   R14,PRINT             /*                              */\n         MVC   PRINTO(24),TITLE      /*                              */\n         BAL   R14,PRINT             /*                              */\n         EOJ                         /*                              */\n         TITLE 'HCPRTSVA INTERNAL SUBROUTINES'\n*--------------------------------------------------------------------*/\n*                                                                    */\n*                                                                    */\n*        I N T E R N A L    S U B R O U T I N E S                    */\n*                                                                    */\n*--------------------------------------------------------------------*/\nDUMP     EQU   *                     /*                              */\n         CR    R4,R5                 /*ALL OF REQUESTED AREA DUMPED? */\n         BCR   2,R9                  /*IF YES, RETURN NOW.           */\n*                                    /*IF NOT, KEEP PRINTING.        */\n         CLI   0(R4),X'00'           /*IS THE 1ST CHARACTER ZERO ?   */\n         BNE   DUMPLINE              /*IF NOT PRINT THIS NONZERO LINE*/\n         CLC   1(31,R4),0(R4)        /*CHECK IF ALL OTHERS ARE ZERO  */\n         BE    SKIPLINE              /*IF YES, DON'T PRINT THIS LINE.*/\nDUMPLINE EQU   *                     /*                              */\n         ST    R4,UNPKA              /*ADDR OF DATA BEING PRINTED.   */\n         MVC   PRINTO+98(16),0(R4)   /*PLACE PRINTABLE CHARS IN LINE.*/\n         MVC   PRINTO+116(16),16(R4) /*                              */\n         TR    PRINTO+98(34),PRNTABLE *REMOVE UNPRINTABLE CHARACTERS.*/\n         MVC   UNPKA+4(32),0(R4)     /*                              */\n         BAL   R14,UNPK              /*                              */\n         MVC   PRINTO(8),UNPKO       /*                              */\n*--------------------------------------------------------------------*/\n*                                                                    */\n*        FOLLOWING ROUTINE SPACES OUT THE 64 HEX CHARACTERS ON A LINE*/\n*        IN GROUPS OF 'SEG' CHARACTERS EACH.                         */\n*                                                                    */\n*--------------------------------------------------------------------*/\nSEG      EQU   8                 LINE SEGMENT CONSTANT = 8 CHAR / SEG*/\n*--------------------------------------------------------------------*/\n         LA    R10,SEG               /*SET BYTES / SEGMENT CONSTANT. */\n         LA    R2,PRINTO+14          /*POINT TO OUTPUT LINE POSITION.*/\n         LA    R15,UNPKO+8           /*POINT TO INPUT CHAR LOCATION. */\n         LA    R11,63(R15)           /*POINT TO END OF INPUT DATA.   */\nLINELOOP EQU   *                     /*                              */\n         MVC   0(SEG,R2),0(R15)      /*MOVE A SEGMENT TO OUTPUT LINE.*/\n         LA    R2,SEG+2(R2)          /*POINT TO NEXT OUTPUT POSITION.*/\n         BXLE  R15,R10,LINELOOP      /*REPEAT FOR ENTIRE LINE.       */\n         MVC   PRINTO+12(32/SEG*(SEG+2)),PRINTO+14  SPLIT DUMP IN TWO*/\n*                                    /*                              */\n         BAL   R14,PRINT             /*                              */\nSKIPLINE EQU   *                     /*                              */\n         LA    R4,32(R4)         POINT TO NEXT 32 BYTES FOR NEXT LINE*/\n         B     DUMP                  /*KEEP PRINTING SVA/GETVIS AREA */\n*------------------------------------/*                              */\nPRINT    EQU   *                     /*                              */\n         LA    R1,CCB                /*POINT TO WORKING COPY OF CCB  */\n         EXCP  (1)                   /*EXECUTE CHANNEL PROGRAM       */\n         LA    R1,CCB                /*POINT TO WORKING COPY OF CCB  */\n         WAIT  (1)                   /*WAIT FOR COMPLETION.          */\n         MVI   CCW,X'09'             /*RESET TO SPACE 1 LINE         */\n         MVC   PRINTO,PRINTO-1       /*BLANK OUT PRINT LINE.         */\n         LH    R2,LINES              /*GET LINE COUNTER.             */\n         BCT   R2,NEXTLINE           /*DECREMENT BY 1, */\n*/*                                  /* TEST IF IT WENT ZERO         */\n         MVI   CCW,X'89'             /*IF END OF PAGE-SKIP NEXT TIME */\n         LH    R2,LINECT             /*  THEN RESET COUNT.           */\nNEXTLINE EQU   *                     /*                              */\n         STH   R2,LINES              /*SAVE NEW VALUE FOR LINE COUN  */\n         BR    R14                   /*RETURN.                       */\n*------------------------------------/*                              */\nEDITSIZE EQU   *                     /*                              */\n         SLL   R2,8                  /*CLEAR HIGH BYTE.              */\n         SRL   R2,18                 /*DIVIDE BY 1 5.                */\n         CVD   R2,UNPKA              /*CREATE PACKED FORMAT.         */\n         BR    R14                   /*RETURN.                       */\n*------------------------------------/*                              */\nUNPK     EQU   *                     /*                              */\n         UNPK  UNPK1(15),UNPKA(8)    /*                              */\n         UNPK  UNPK1+15(1),UNPK1+14(1)                               */\n         UNPK  UNPK2(15),UNPKA+8(8)  /*                              */\n         UNPK  UNPK2+15(1),UNPK2+14(1)                               */\n         UNPK  UNPK3(15),UNPKA+16(8) /*                              */\n         UNPK  UNPK3+15(1),UNPK3+14(1)                               */\n         UNPK  UNPK4(15),UNPKA+24(8) /*                              */\n         UNPK  UNPK4+15(1),UNPK4+14(1)                               */\n         UNPK  UNPK5(15),UNPKA+32(8)  *                              */\n         UNPK  UNPK5+15(1),UNPK5+14(1)                               */\n         UNPK  UNPK6(15),UNPKA+40(8)  *                              */\n         UNPK  UNPK6+15(1),UNPK6+14(1)                               */\n         MVZ   UNPK1(96),Z0          /*STRIP OFF ANY ZONE BITS.      */\n         TR    UNPK1(96),HEXTABLE    /*REPLACE WITH CORRESP. CHAR    */\n         MVC   UNPKO(96),UNPK1       /*MOVE PRINTABLE CHARS TO OUTPUT*/\n         MVC   UNPK1(96),Z0          /*INITIALIZE INPUT AREA.        */\n         BR    R14                   /*RETURN.                       */\n*------------------------------------/*                              */\n*/*                                  /*                              */\n*/*------------------------------------------------------------------*/\n*/*    THIS ROUTINE IS USED TO CONVERT ADDRESSES FOR PRINTING        */\n*/*    R1  USED AS BAL COUNT REG                                     */\n*/*    R4  USED AS WORK REG                                          */\n*/*    R5  USED AS WORK REG (SAVED AND RESTORED.)                    */\n*/*    R7  POINTS TO OUTPUT                                          */\n*/*    R14 RETURN REGISTER                                           */\n*/*    R15 CONTAINS ADDRESS TO PRINT                                 */\n*/*------------------------------------------------------------------*/\nADDRSUB  EQU   *                     /*                              */\n         ST    R14,RETURN14          /*SAVE RETURN ADDRESS           */\n         LA    14,PRNTWRK            /*BUILD PRINT AREA              */\n         LR    R10,R1                /*VALUE TO CONVERT IN R1 AND R10*/\n         LR    R11,R10               /*VALUE TO CONVERT IN R10 & R11 */\n         SRL   R10,4                 /*MOVE THE ZONES TO NUMERIC BITS*/\n         N     R11,=X'0F0F0F0F'      /*MASK OFF 1ST 4 BITS OF        */\n*                                    /* EACH BYTE.                   */\n         N     R10,=X'0F0F0F0F'      /*IN BOTH THE ZONE & NUMERIC REG*/\n         LA    R1,8                  /*NUMBER OF BYTES * 2           */\nADDRSUB2 EQU   *                     /*                              */\n         STC   R11,0(R14,R1)         /*STORE THE NUMERIC BYTE        */\n         BCTR  R1,0                  /*DECREMENT R1  BY 1            */\n         STC   R10,0(R14,R1)         /*STORE THE ZONE BYTE           */\n         SRDL  R10,8                 /*SHIFT TO THE NEXT BYTE        */\n         BCT   R1,ADDRSUB2           /*GO DO THE NEXT BYTE           */\n         TR    1(8,R14),TRANTABA     /*TRANSLATE IT                  */\n         L     R14,RETURN14          /*LOAD RETURN ADDRESS           */\n         BR    R14                   /*RETURN WHEN THROUGH           */\n*/*------------------------------------------------------------------*/\nTRANTABA DC    C'0123456789ABCDEF'\n*/*------------------------------------------------------------------*/\n*                                    /*                              */\n         LTORG                       /* ALL LITERALS BEFORE WORKAREA */\n         TITLE 'HCPRTSVA - CONSTANTS AREA'\n*---------------------------------------------------------------------/\n*                                                                    */\n*                                                                    */\n*        D A T A    A R E A                                          */\n*                                                                    */\n*--------------------------------------------------------------------*/\nPRCCB    CCB   SYSLST,PRCCW\nPRCCW    CCW   9,*-*,X'20',132\n*\nX8FS     DC    8X'FF'\nZEROES   DC    8X'00'\nHEXTABLE DC    C'0123456789ABCDEF'\nPRNTABLE EQU   *\n         DC    CL16'                '  0X\n         DC    CL16'                '  1X\n         DC    CL16'                '  2X\n         DC    CL16'                '  3X\n         DC    CL16'           .<(+.'  4X\n         DC    CL16'           $*); '  5X\n         DC    CL16'-/         ,%_>?'  6X\n         DC    CL16'          :#@''=\"' 7X\n         DC    CL16'                '  8X\n         DC    CL16'                '  9X\n         DC    CL16'                '  AX\n         DC    CL16'                '  BX\n         DC    CL16' ABCDEFGHI      '  CX\n         DC    CL16' JKLMNOPQR      '  DX\n         DC    CL16'  STUVWXYZ      '  EX\n         DC    CL16'0123456789      '  FX\n*\nSVATITLE DC    CL105'SVA ADDR    SVA LAST UPDATED    SVA START   NEXT SX\n               VA   SVA END   SDL START  NEXT SDL  # IN SDL  ENTRY LEN'\n*\nSDLTITLE DC    CL94'SDL ADDR  PHASENAME  IN SVA  IN SYSLIB  LOADABLE  LX\n               D POINT  ENTRY    SIZE   SVA ADDR SVA ENTRY'\nTITLE    DC    105C'-'             UNDERLINE FOR TITLES.\nHDR1     DC    C'HANNA && ASSOCIATES, INC. EDMOND OKLAHOMA     SVA LISTX\n               ING'\nWORKSIZE DC    A(WORKEND-WORKAREA) REQUIRED GETVIS AREA LENGTH.\n         TITLE 'HCPRTSVA DSECTS'\nWORKAREA DSECT                     WORK AREA LOCATED IN GETVIS\nWORKSTRT DS    0D                  START OF WORK AREA\nDBLWRDWK DS    D\nCCB      DS    2D                  DUMMY CCB FOR GETVIS AREA\nCCW      DS    D                   DUMMY CCW FOR GETVIS AREA\n*/* N O T E --->                 /* UNPKA MUST BEGIN ON DBLWRD BNDRY */\nUNPKA    DS    CL48                INPUT  AREA FOR 'UNPK' - HEX BYTES.\nUNPKO    DS    CL96                OUTPUT AREA FOR 'UNPK' - CHARACTERS.\nSAVESTRT DS    F\nSTARTEND DS    2F                  BEGINNING / END OF SVA.\nRETURN14 DS    F                     /* ADDRESS OF CALLER RETURN     */\nLINES    DS    H                   LINE COUNTER FOR 'PRINT'.\nLINECT   DS    H                   SYSLST LINE COUNT FROM COMREG\nPRNTWRK  DS    0CL9                  /*                              */\n         DS    C\nPRINTWRK DS    CL8\nHOLDUPSI DS    X                   UPSI BYTE FROM COMREG\nHOLDDATE DS    CL8                 MM/DD/YY FROM COMREG\nHOLDCPU  DS    XL5                 CPU ID HOLD\nBLANK    DS    C                   BLANK CONSTANT MUST PRECEED 'PRINTO'\nPRINTO   DS    CL132               'PRINT' OUTPUT LINE.\nZ0       DS    X                   ZONE CONSTANT, MUST PRECEED 'UNPK1'.\nUNPK1    DS    CL16                OUTPUT\nUNPK2    DS    CL16                       WORK\nUNPK3    DS    CL16                            SPACE\nUNPK4    DS    CL16                                  FOR\nUNPK5    DS    CL16                                      'UNPK'\nUNPK6    DS    CL16                                             ROUTINE\nWORKEND  EQU   *\n         SPACE 2\n*        PRINT GEN\n         SPACE 2\n*        MAPSVAHD\n         MAPSVAHD\n         SPACE 2\n*SYSCOM  SYSCOM\nSYSCOM   SYSCOM\n         SPACE 2\n*        MAPCOMR\n         MAPCOMR\n         SPACE 2\n*        MAPDNTRY\n         MAPDNTRY\n         SPACE 2\n*-------------------------------------------------------------*\n*------- SDL       DUMMY CONTROL SECTION  --------------------*\n*-------------------------------------------------------------*\n         SPACE 1\nSDLENTRY DSECT .                  DIRECTORY ENTRY\nSDLENAM  DS    CL8             0  DIRECTORY NAME FIELD\n         DS    XL1             8  RESERVED\nSLDEDEF1 DS    XL1             9  ATTTRIBUTES FOR DE\nSDLDDTYP EQU   X'80'              TYPE OF ENTRY = TYPE\nSDLDDHLX EQU   X'40'              TYPE OF ENTRY = HIGH LEVEL INDEX\nSDLDDDIR EQU   X'20'              TYPE OF ENTRY = DIRECTORY\n*              X'10' - X'01'      RESERVED\n*\nSDLEPRBA DS    XL6             A  PRBA OF MEMBER\nSDLECONT DS    XL2            10  NUMBER OF CONTIGUOUS LBS\n         DS    XL2            12  RESERVED\nSDLEPFL  DS    XL1            14  FLAGS\n*--------------------------------------------------------------\nSDLEBSR  EQU   X'80'              SELF RELOCATING PHASE\nSDLEBRL  EQU   X'40'              RELOCATING PHASE\nSDLEBSE  EQU   X'20'              SVA ELIGIBLE\nSDLEBSD  EQU   X'10'              PHASE IN SVA\nSDLEBPC  EQU   X'08'              PCIL FLAG FOR INCORE DIRECTORY\nSDLEBNF  EQU   X'04'              NOT FOUND FLAG (INCORE DIRECTORY)\nSDLEBAC  EQU   X'02'              ENTRY ACTIVE (INCORE DIRECTORY)\n*        EQU   X'01'              RESERVED\n*--------------------------------------------------------------\nSDLESWT  DS    XL1            15  SWITCHES\n*--------------------------------------------------------------\nSDLECLM  EQU   X'80'              MOVE MODE FLAG  FROM SET SDL\nSDLECLS  EQU   X'40'              SVA ELIG. FLAG  FROM SET SDL\n*--------------------------------------------------------------\n         DS    XL2            16  RESERVED\nSDLEPLN  DS    XL4            18  LENGTH OF PHASE(TXT) IN BYTES\nSDLELPT  DS    XL4            1C  LOAD POINT AT LINKEDIT TIME\nSDLEENP  DS    XL4            20  ENTRY POINT AT LINKEDIT TIME\nSDLESTR  DS    XL4            24  PARTITION START AT LINKEDIT\nSDLERLD  DS    XL2            28  NUMBER OF RLD ITEMS\nSDLERLDA DS    XL6            2A  PRBA OF FIRST RLD ITEM, IF ANY\n         DS    XL8            30  RESERVED\nSDLESVAP DS    XL4            38  ENTRY POINT OF PHASE IN SVA\nSDLEIDEN DS    XL4            3C  LIBRARY BLOCK ID\nSDLEALIB DS    XL4            40  ADDRESS OF LIB-DEF-TAB\nSDLEASLB DS    XL4            44  ADDRESS OF SUBLIB-DEF-TAB\n*--------------------------------------------------------------\nSDLENGTH EQU   *-SDLENTRY         LENGTH OF ENTRY (X'72' DEC 48)\n         SPACE 2\n         END   HCPRTSVA\n\n\nMark Hanna\nPresident\nHanna & Associates Inc (USA)                      c Hanna & Associates Inc 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E005A02": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\x10\\x00v\\x00v\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:10:06", "lines": 118, "newlines": 118, "modlines": 0, "user": "VSEUPDT"}, "text": "Operator communication interrupt\n\nIt may sometimes be desirable to interrupt an executing\nprogram in order to talk to it. For example, it might be useful\nto be able to ask a long-running program \"what record are you\ncurrently working on?\" or \"how many pages have you printed\nso far?\". It might be useful to be able to tell the program to\nissue a POWER SEGMENT command so that you can see\nwhat has been printed so far. Or it might be useful to be able to\ntell the program \"please stop running after you save enough\ninformation to allow restart later\". The program might finish\nprinting the current page, save information necessary to restart,\nand then end. Later, the program could be executed again with\na restart option which causes the program to read the save file\nand continue from where it left off. It is easy enough for a\nprogram to communicate with the operator by writing messages\nto and reading messages from the system console; the trick is\nknowing when the operator wants to communicate.\n\nThe Assembly language macro STXIT facilitates Operator\nCommunication Interrupts. An application program executes a\nSTXIT OC macro instruction which specifies the address of a\nuser routine in the program and a register save area. When the\nconsole operator issues the command MSG Fx (where Fx is the\nprogram's partition), normal instruction processing is\ninterrupted and control is given to the user routine specified by\nthe STXIT OC command. This routine does whatever it is\nprogrammed to do and ends by executing an EXIT OC macro\ninstruction causing processing to continue from where the\nprogram was interrupted.\n\nIt is seldom convenient for a program to begin communicating\nwith the operator at the instant the MSG Fx command is\nissued. It is not uncommon, therefore, for STXIT OC routines\nsimply to set a switch indicating that an OC interrupt has\noccurred and then exit. The application program periodically\nchecks the value in the switch. When the value changes, it\nknows that it must communicate with the console operator. The\nrelocatable subroutine JHROCI shown below facilitates\noperator communication interrupts in this way.\n\nAn application program CALLs JHROCI once, specifying a\none-byte field. JHROCI saves the address of the field, issues\nthe STCIT OC command naming OCI as the OC interrupt\nroutine and then RETURNs to the caller. Now, any time the\nconsole operator issues the MSG Fx command, control is given\nto the routine OCI which moves the character 'I' into the\ncaller's one-byte field and then exits. It is the application\nprogram's responsibility to check the field occasionally to see\nif an 'I' has been placed in it, and to act accordingly. After\nhandling the OC interrupt, the program can reset the value in\nthe field and continue processing. If the operator again issues\nthe MSG Fx command, the field will once again be changed to\nthe character 'I'. It is not necessary to CALL JHROCI a second\ntime because the STXIT OC remains in effect until the program\nterminates. The following example shows how JHROCI might\nbe used by a COBOL program.\n\n    77  OC-SWITCH               PIC X     VALUE SPACE.\n    77  RESPONSE                PIC X(40) VALUE SPACES.\n                  :\n    PROCEDURE DIVISION.\n         CALL 'JHROCI' USING OC-SWITCH.\n                  :\n    LOOP.\n        IF OC-SWITCH IS EQUAL TO 'I'\n           GO TO OC-INTERRUPT-ROUTINE.\n        READ file\n           AT END GO TO end-of-file-routine.\n                  :\n        do some processing\n                  :\n        GO TO LOOP.\n                  :\n    OC-INTERRUPT-ROUTINE.\n        DISPLAY 'WHAT DO YOU WANT' UPON CONSOLE.\n        ACCEPT RESPONSE FROM CONSOLE.\n                  :\n        handle communication with operator\n        doing whatever is requested\n                  :\n        MOVE SPACE TO OC-SWITCH.\n        GO TO LOOP.\n\n\nJHROCI\n\n         TITLE 'JHROCI - OPERATOR COMMUNICATION INTERRUPT'\n         PUNCH '  CATALR JHROCI '\nJHROCI   START 0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR12      EQU   12\nR14      EQU   14\nR15      EQU   15\n         USING JHROCI,R15\n         SAVE  (R14,R12)\n         L     R2,0(,R1)     LOAD ADDRESS OF CALLER'S OC SWITCH\n         ST    R2,SWADDR     SAVE OC SWITCH ADDRESS\n         LA    R3,SAVEAREA   GET ADDR OF SAVE AREA FOR USE BY STXIT OC\n         LA    R4,OCI        GET ADDR OF OC INTERRUPT ROUTINE\n         STXIT OC,(R4),(R3)  SET OC STXIT\n         RETURN (R14,R12)    RETURN TO CALLER\n         DROP  R15\nOCI      BALR  R2,0          ENTER HERE WHEN MSG FX OCCURS\n         USING *,R2\n         L     R3,SWADDR     GET ADDRESS OF OC SWITCH\n         MVI   0(R3),C'I'    INDICATE MSG FX HAS OCCURED\n         EXIT  OC\nSWADDR   DC    F'0'          SAVE AREA FOR OC SWITCH ADDRESS\nSAVEAREA DS    18F           SAVE AREA FOR OC INTERRUPT\n         END\n\n\nJames E Holler\nLittle Blue Systems (USA)              c Little Blue Systems 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E005A03": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x07\\x85\\x07\\x85\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 1925, "newlines": 1925, "modlines": 0, "user": "VSEUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "E005A04": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00J\\x00J\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 74, "newlines": 74, "modlines": 0, "user": "VSEUPDT"}, "text": "Setting return codes from within COBOL\n\nWith the advent of conditional JCL, control of job execution is\nnow a reality. The return code may be tested and appropriate\nremedial action taken. However, there is no standard way to set\na return code from within a COBOL program. The following\nAssembler program may be CALLed from a COBOL program\nto set the return code.\n\n* $$ JOB JNM=RCPOST,CLASS=0,DISP=D\n* $$ PUN DISP=I\n// JOB RCPOST  -  ASSEMBLE AND CATALOG RC SUBROUTINE\n// OPTION LIST,DECK\n// EXEC ASSEMBLY,SIZE=128K\n         PUNCH '// JOB LIBRCAT'\n         PUNCH '// EXEC LIBR,PARM=''ACCESS SUBLIB=PRD1.BASE'''\n         PUNCH '   CATALOG RCPOST.OBJ REPLACE=YES'\nRCPOST   START 0\n*         NOTE:  REGISTER NOT SAVED - NO RETURN TO CALLER        *\n         LR    3,15                LOAD BASE REGISTER\n         USING RCPOST,3\n         L     5,0(0,1)            SAVE ADDRESS OF PASSED RC\n         L     15,0(0,5)           LOAD RC INTO REGISTER 15\n         EOJ   RC=(15)\n         END\n/*\n// EXEC ASSEMBLY,SIZE=128K\n         PUNCH '/*'\n         PUNCH '/&&'\n         END\n/*\n/&\n* $$ EOJ\n\nThe following is an example of the coding needed to set the\nreturn code from a COBOL program and use of it to control job\nflow.\n\nIn the WORKING-STORAGE section code:\n\n 01  RCODE                   PIC 9(8) COMP VALUE 0.\n\nIn the PROCEDURE DIVISION code:\n\n*  SET RETURN CODE FOR CONDITIONAL JCL\n*     100 = QUARTERLY RUN, ANYTHING ELSE IS NOT QUARTERLY RUN\n     MOVE 100 TO RCODE.\n     CALL 'RCPOST' USING RCODE.\n\n\nJCL EXAMPLE\n\nPlace the following three lines at the start of a job to override\nthe default handling of return codes:\n\n// ON $ABEND GOTO ABORT\n// ON $RC GE 16 CONTINUE\n// ON $RC GT 4 AND $RC LT 16 GOTO ABORT\n\nThe following tests the maximum return code, and takes\nappropriate action:\n\n// IF $MRC=0100 THEN\n// GOTO QTRLY\n// whatever steps you want\n .\n .\n .\n/. QTRLY\n\nFrank A Braman\nSystems Programmer\nSt Johnsbury Trucking Co  (USA)      c St Johnsbury Trucking Co 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E005A05": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00*\\x00*\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 42, "newlines": 42, "modlines": 0, "user": "VSEUPDT"}, "text": "Unload magnetic tape drive for reuse\n\nThis routine allows a COBOL program to close a magnetic tape\nfile such that the tape is unloaded. This will allow the tape\ndrive to be used to read a number of tapes with the same\nfilename.\n\nThe routine must be called prior to the tape file being closed, eg:\n\nCALL 'UNLOADTP' USING filename.\nCLOSE filename.\n\nAssemble the source code and catalogue the relocatable module\ninto a relocatable library. The relocatable library should be in\nthe standard relocatable library searchlist, so that the module\nmay be included in the calling program at link-edit time.\n\n         TITLE 'ULOADTP - CHANGE FILE DISPOSITION TO UNLOAD AT CLOSE'\nUNLOADTP CSECT\n         USING UNLOADTP,15\n         SAVE  (14,12)\n         LR    2,15                    R2 = BASE REGISTER\n         USING UNLOADTP,2\n         DROP  15\n         SPACE 2\n*              SET UP ADDRESSABILITY\n         SPACE 2\n         L     3,0(0,1)                R3 = A(DTF)\n         SPACE 2\n*              ALTER CLOSE OPTION TO UNLOAD\n         SPACE 2\n         OI    32(3),32                SET UNLOAD IN DTF\n         SPACE 2\n*              RETURN TO CALLING ROUTINE\n         SPACE 2\n         RETURN (14,12)\n         END\n\nMichael Nunan\nSystems Programmer\nSage Computing (South Africa)                   c Sage Computing 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E005A06": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x9c\\x00\\x9c\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 156, "newlines": 156, "modlines": 0, "user": "VSEUPDT"}, "text": "POWER time event scheduling exposed\n\nIn the June 1991 issue of VSE Update, Kevin Crandall noted\nsome new POWER operands concerning time event scheduling\nwhich were previously undocumented. We are currently\nupgrading to VSE/ESA 1.1, and I am happy to say that the\nfeature is now fully documented in POWER Version 5 Release\n1's Administration and Operation manual, as well as in the\nnew, hand-sized VSE/ESA Quick Reference booklet (which,\nby the way, includes command syntax summaries for\nAdvanced Functions, POWER, VSAM, and ICCF).\n\nKevin is correct; time event scheduling is supported starting at\nVSE/SP 4.1.1, as stated on page 104 of the above manual. As\nfar as the remark about wishing to know what the\n'RESTART=' parameter was, I can only assume that he meant\nthe new 'RERUN=' parameter instead, which is also a part of\ntime event scheduling, as I could find no documentation for a\n'RESTART=' operand of the '* $$ JOB' card.\n\nThe following highlights the information available in the\nAdministration and Operation manual.\n\nTime event scheduling operands are not required, but if any are\nused, at least DUETIME is required.\n\nThe operands are: DUETIME; DUEDATE or DUEDAY\n(mutually exclusive); DUEMONTH; and RERUN.\n\nDUETIME=hhmm specifies time in military (24-hour)\nnotation. Leading zeros are required.\n\nDUEDATE=mmddyy or DUEDATE=ddmmyy, depending on\nhow your system date format is set up (in your IPL procedure).\nNote that there are no delimiters (such as slashes or dashes),\nand leading zeros are required. If you need to specify a format\ndifferent from the originating system (perhaps the job is going\nto be transmitted to a system with a differing date format, or\nyou're not sure), then use either 'extended' format\nDUEDATE=(mmddyy,M) or DUEDATE=(ddmmyy,D) to\nexplicitly state the format, where D means day-first, and M\nmeans month-first.\n\nYears with values 89 to 99 are considered 1989 to 1999 (20th\ncentury), and year values 00 to 88 are treated as 2000 to 2088\n(21st century).\n\nDUEDAY=DAILY for every-day use, or DUEDAY=(name-\nlist), or DUEDAY=(number-list) for specific days. Name-list\ncontains 3-character abbreviations of the days of the week;\nSUN, MON, TUE, WED, THU, FRI, SAT. Alternatively,\nnumber-list contains one or more day-of-the-month numbers,\nsuch as 31 for the 31st day. Either form of the list can be\ndelimited by commas and/or dashes. For example,\nDUEDAY=(MON-WED,FRI) means Monday to Wednesday,\nthen not again until Friday.\n\nDUEDAY is mutually exclusive with DUEDATE. Also,\nDUEDAY can be used in conjunction with DUEMONTH, but\nDUEDATE cannot be used with DUEMONTH, according to\nthe documented syntax.\n\nAn interesting and helpful point: if a day number is specified\nfor a month without that many days, it is assumed to mean the\nlast day of the month. Thus, DUEMONTH=(1-12),\nDUEDAY=(31) would assure the time event to expire on the\nlast day of every month, regardless of leap years.\n\nDUEMONTH=(number-list) is very similar to\nDUEDAY=(number-list), except, of course, that it specifies the\nmonth(s)-of-the-year: 1 for January to 12 for December. Again,\ncommas and/or dashes may be included.\nDUEMONTH=(1,3,5,10-12) means January, March, May,\nthen October to December.\n\nRERUN, which defaults to RERUN=YES, tells POWER what\nto do in case a time event job that was put in the queue prior to\nPOWER coming down (intentionally or not) 'expires'\n(becomes eligible to be run) during the outage time period. If\nPOWER comes back up the same day as it came down,\nRERUN is ignored, to prevent undue complications arising\nfrom very short outages (perhaps only a few minutes).\nOtherwise, RERUN=YES causes the job to become\nimmediately eligible as soon as POWER regains control, as if\nthe expiry has just occurred. With RERUN= NO, you inform\nPOWER that the expired run is to be ignored.\n\nThe default original disposition and the final disposition of a\ntime event job depends on whether it is a 'one-time shot' or a\nmultiple-release job. For the one-timers, the default is\nDISP=D, and the job is deleted after running. If the JOB card\nspecifies DISP=K, it becomes DISP=L after execution, just as\nyou would expect for a non-timed job.\n\nFor multiple-event jobs, however, the default is DISP=K, to\nagree with the multiple-run intent. Unlike one-timers, however,\na DISP=K returns to DISP=K, not DISP=L, after running, so\nthat the operator does not manually have to make it\ndispatchable again. The reason is that a non-dispatchable job\n(DISP=H or DISP=L) is not eligible to run even if its time of\nexpiry goes by. Only DISP=D and DISP=K jobs are processed\nby the feature.\n\nIf a job is submitted with a time/date that has already passed,\nthe event immediately expires and the job is eligible to run\n(assuming it is dispatchable). Note, however, that if you\nsubmit a job with DUETIME=1700,DUEDAY=(FRIDAY) and\nyou submit it at 5:01pm on a Friday, the job will not\n'immediately expire', but will instead wait until the following\nFriday.\n\nIn regard to error detection: the year value of the DUEDATE\noperand must be greater than or equal to 10 years prior to the\ncurrent year, and less than or equal to 3 years past the current\nyear, or else POWER assumes a mistake and puts the job in a\nHOLD status and issues message number 1R37I. However, if\nthe operator places the job back into a status of DISP=D or\nDISP=K, POWER honours the parameters.\n\nAdditionally, if error(s) are detected in any of the time event\noperands, all of the operands are ignored and the job is placed\nin a HOLD status, and message number 1R36I is issued.\n\nFor a display of expiry time/dates, the usual D RDR command\nincludes the field 'RUN=hh:mm mm/dd' for non-expired jobs,\nand 'EXP=hh:mm mm/dd' for expired (but not yet running)\njobs in the queue. Time event jobs that are not eligible to run\n(such as those in DISP=H) show 'RUN=--', where the dashes\nindicate 'not applicable'. To also see the original time event\noperands coded on the job card at submission, the fuller\ncommand D RDR,FULL=YES displays an additional 1 or 2\nlines per job entry. For jobs in the XMT queue, the D\nXMT,FULL=YES shows the additional 1 or 2 lines, but not\nRUN= or EXP=, since the latter only applies to RDR queue\nentries.\n\nAnother command, D WRUN, will display those time event\njobs 'waiting to run' (eligible but not yet expired).\n\nAfter a time-event job is run, if it is put back in the job queue\nfor another timed release (because of DISP=K), the POWER\njob number changes.\n\nI hope that this information helps those VSE shops that are at\n4.1.1 and simply don't have access to the ESA documentation.\nI would assume that all points mentioned here are usable, but\nyou may want to try some of the commands, such as D WRUN\nand D RDR,FULL=YES, to be sure. I am certain that this\nfeature of POWER will be a tremendous help to many shops,\nas it will be to ours as we begin to incorporate it into our\noperations strategy.\n\nLawrence Holder\nSenior Programmer/Analyst\nThe University of Tennessee at Martin (USA)                 c UTMCC 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A00I": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\r\\x00\\r\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 13, "newlines": 13, "modlines": 0, "user": "VSEUPDT"}, "text": "E006 - VSE Update Issue #6  June 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE006A01   Issue a POWER command from batch\nE006A02   Automated console\nE006A03   Preventing automatic restart of in-flight jobs\nE006A04   Get CPU-id for several applications\nE006A05   CICS commands from batch\nE006A06   File generation datasets under VSE\nE006A07   Reader's letter\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A01": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02\\x0e\\x02\\x0e\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 526, "newlines": 526, "modlines": 0, "user": "VSEUPDT"}, "text": "Issue a POWER command from batch\n\nThe program source which follows allows a POWER command\nto be issued either from a batch job stream or from a calling\nprogram. Don't try calling it from a CICS program because the\nECBs will put CICS into a wait state.\n\nFrom a batch job you would supply the power command to be\nissued on the PARM operand of the EXEC statement, ie:\n\n      // EXEC PWRCMD,PARM='A LST,MYJOB,CLASS=X'\n\nIf the POWER command is a PDISPLAY command, any\nmessages that would appear on the console, assuming the\ncommand was issued at the console, will be printed on\nSYSLST. If problems occur, a return code of 16 is set.\n\nPWRCMD may also be called from another program;\nremember that PWRCMD does write to SYSLST, though. An\nexample of how it may be called from another Assembler\nprogram is shown below. I am sure you could work out how to\ncall it from PL/I or COBOL.\n\nHere is an example of how to call PWRCMD from another\nAssembler program:\n\n         CDLOAD PWRCMD             LOAD PWRCMD INTO GETVIS\n         LTR   R15,R15             LOAD WORK OK ?\n         BNZ   ERRCDLOD            ...NO\n         LR    R15,R1              SET UP ENTRY ADDRESS TO PWRCMD\n         LA    R1,PSEUDOPP         LOAD ADDRESS OF PSEUDO PARM POINTER\n         LA    R13,SAVEAREA        LOAD ADDRESS OF SAVEAREA\n         BALR  R14,R15             GO CALL PWRCMD\n         LTR   R15,R15             POWER COMMAND WORK OK ?\n         BNZ   ERRPCMD             ...NO\n*\n         OTHER PROGRAM CODE  ETC\n*\nSAVEAREA DS    9D\nPSEUDOPP DC    A(PSEUDOP)           PSEUDO PARM POINTER\nPSEUDOP  EQU   *                    PSEUDO PARM\n         DC    Y(PSEUDOPL)           LENGTH\n         DC    C'D LST,FREE'        YOUR POWER COMMAND\nPSEUDOPL EQU   *-PSEUDOP-2          LENGTH OF PSEUDO PARM\n\nPWRCMD has been tested and works on both VSE/SP 3.1.2\nand VSE/ESA 1.2.0. Saving registers on entry, restoring them\nat EOJ and then branching on R14 with a return code in R15\ndoes work for a VSE main program from about VSE/SP 2.\nPWRCMD has unlimited access to all queue entries, like the\nVSE central operator, and any valid POWER command can be\nissued and will be processed. You might like to add some code\nto screen out certain commands. For audit purposes the VSE\njobname and the command to be issued are written to SYSLOG\nand SYSLST. Values for PXPRETCD and PXPFBKCD may\nbe found in the PWRSPL DSECT, and values for IJBXFCT,\nIJBXRETC, and IJBXREAS in the MAPXPCCB DSECT. The\nabove fields appear in the error messages should anything fail.\n\nThere are three in-line macros:\n\no      MESSAGE - issue messages to SYSLST/SYSLOG or both.\n\no      SAVEWORK - save and restore work registers for nesting.\n\no      B2X - convert return codes to printable hex.\n\n\nPWRCMD\n\n*% PWRCMD   - DESCRIPTION                                             %\n*% ISSUE A POWER COMMAND FROM BATCH VIA PARM                          %\n         EJECT\n*% MACRO - MESSAGE                                                    %\n*%         ERROR MESSAGE TO SYSLOG ETC                                %\n         MACRO\n&LABEL   MESSAGE &LINE,&ADDR=,&LENGTH=,&TYPE=CONS\n         LCLA &LEN,&LOC,&X,&SCHAR\n         AIF  ('&LABEL' EQ '').NOLABEL\n&LABEL   DS    0H\n.NOLABEL ANOP\n         AIF  ('&TYPE' NE 'BOTH').BYPBOTH\n         OI    FLAGCTL,FLGCONS+FLGPRT\n.BYPBOTH ANOP\n         AIF  ('&TYPE' NE 'CONS').BYPCONS\n         OI    FLAGCTL,FLGCONS\n.BYPCONS ANOP\n         AIF  ('&TYPE' NE 'PRT').BYPPRT\n         OI    FLAGCTL,FLGPRT\n.BYPPRT  ANOP\n         AIF  ('&ADDR' EQ '').LITERAL\n         AIF  ('&LENGTH' NE '').LENOK\n         LA    R1,&ADDR                  ADDRESS OF LINE TO BE PUNCHED\n         LH    R0,&ADDR.L                LENGTH OF LINE ASSUMED\n         BAL   BALREG,SHOWIT\n         MEXIT\n.*                                       ADDRESS OF LINE SUPPLIED\n.LENOK   ANOP\n         AIF  (T'&LENGTH NE 'A').LEN2\n         LA    R1,&ADDR                  ADDRESS OF LINE TO BE PUNCHED\n         LH    R0,&LENGTH                LENGTH OF LINE\n         BAL   BALREG,SHOWIT\n         MEXIT\n.*                                       LITERAL LENGTH SUPPLIED\n.LEN2    ANOP\n         LA    R1,&ADDR                  ADDRESS OF LINE TO BE PUNCHED\n         LH    R0,=Y(&LENGTH-1)          LENGTH OF LINE\n         BAL   BALREG,SHOWIT\n         MEXIT\n.*                                    LINE SUPPLIED AS A LITERAL\n.*                                    THE NEXT BIT CHECKS FOR SPECIAL\n.*                                    CHARACTERS IN &LINE SO WE CAN\n.*                                    CALCULATE A CORRECT LENGTH VALUE\n.LITERAL ANOP\n&SCHAR   SETA 0\n&LOC     SETA 2\n&X       SETA K'&LINE-2\n.*\n.LOOP    ANOP\n         AIF   ('&LINE'(&LOC,1) EQ '''').UPSCHAR\n         AIF   ('&LINE'(&LOC,1) EQ '&&'(1,1)).UPSCHAR\n         AGO .BYPUPS\n.UPSCHAR ANOP\n&SCHAR   SETA &SCHAR+1\n.BYPUPS  ANOP\n&X       SETA &X-1\n         AIF   ('&X' EQ '0').CONT01\n&LOC     SETA &LOC+1\n         AGO .LOOP\n.CONT01  ANOP\n         AIF   ('&SCHAR' EQ '0').CONT02\n&SCHAR   SETA &SCHAR/2\n.CONT02  ANOP\n&LEN     SETA K'&LINE-3-&SCHAR           ASSEMBLER LENGTH OF LINE\n         LA    R1,=C&LINE                ADDRESS OF MESSAGE\n         LH    R0,=Y(&LEN)               LENGTH OF MESSAGE\n         BAL   BALREG,SHOWIT\n         MEND\n*% END                                                                %\n         EJECT\n*% MACRO - SAVEWORK                                                   %\n*%         SAVE WORK REGISTERS ( R2,R3,R4,R5 ) AND BALREG, AND ALLOW  %\n*% RESTORE OF SAME REGISTERS. THE MACRO HAS 4 DIFFERENT FORMATS :     %\n*%                                                                    %\n*% TYPE = SAVE   - SAVE REGISTERS, LEVEL= MUST BE SPECIFIED           %\n*%        REST   - RESTORE REGISTERS, LEVEL= MUST BE SPECIFIED AND    %\n*%                 MATCH LEVEL= WHEN SAVE WAS DONE SO THE SAME SET    %\n*%                 OF REGISTERS IS RESTORED.                          %\n*%        SET    - SPECIFY HOW MANY SAVEAREAS VIA NUMLEVS=            %\n*%        DEFINE - DEFINE THE BLOCK OF SAVE AREA'S                    %\n         MACRO\n&LABEL   SAVEWORK &TYPE=,&NUMLEVS=,&LEVEL=\n         GBLA &CURLEV,&MAXLEV\n         LCLA &OFFSET\n.*                                      CHECK TYPE OK\n         AIF  ('&TYPE' EQ 'SAVE').TYPEOK\n         AIF  ('&TYPE' EQ 'REST').TYPEOK\n         AIF  ('&TYPE' EQ 'SET').TYPEOK\n         AIF  ('&TYPE' EQ 'DEFINE').TYPEOK\n         MNOTE 16,'INVALID TYPE SPECIFIED'\n         MEXIT\n.TYPEOK  ANOP\n         AIF  ('&LABEL' EQ '').NOLABEL\n.*                                      KICK OUT LABEL IF REQUIRED\n         AIF  ('&LABEL' EQ '').NOLABEL\n&LABEL   DS    0H\n.NOLABEL ANOP\n.*                                      SELECT ON TYPE\n         AIF  ('&TYPE' EQ 'SAVE').SAVE\n         AIF  ('&TYPE' EQ 'REST').REST\n         AIF  ('&TYPE' EQ 'DEFINE').DEFINE\n.*                                      DEFAULT TO TYPE=SET\n         AIF  ('&NUMLEVS' EQ '').NLEVERR\n&MAXLEV  SETA  &NUMLEVS                 SET GLOBAL CONSTANT\n         MEXIT\n.NLEVERR ANOP\n         MNOTE 16,'NUMLEVS MUST BE SPECIFIED ON SET COMMAND'\n         MEXIT\n.*                                      DEFINE SAVEAREA BLOCK\n.DEFINE  ANOP\n         DS    0D\nSAVEWORK DC    CL20'SAVEWORK  EYECATCHER'\n         DC    (&MAXLEV*5)F'0'\n         MEXIT\n.*                                      SAVE REGISTERS\n.SAVE    ANOP\n         AIF  ('&LEVEL' EQ '').SLEVERR\n&CURLEV  SETA  &CURLEV+1\n         AIF  ('&CURLEV' GT '&MAXLEV').MAXLERR\n&OFFSET  SETA  &CURLEV*20\n&LEVEL   EQU   &OFFSET                  EQU SO REST HAS SAME OFFSET\n         STM   R2,R5,SAVEWORK+&LEVEL\n         ST    BALREG,SAVEWORK+&LEVEL+16\n         MEXIT\n.SLEVERR ANOP\n         MNOTE 16,'LEVEL MUST BE SPECIFIED ON SAVE COMMAND'\n         MEXIT\n.MAXLERR ANOP\n         MNOTE 16,'MAXIMUM NUMBER OF SAVEAREAS EXCEEDED'\n         MEXIT\n.*                                      RESTORE REGISTERS\n.REST    ANOP\n         AIF  ('&LEVEL' EQ '').RLEVERR\n         LM    R2,R5,SAVEWORK+&LEVEL\n         L     BALREG,SAVEWORK+&LEVEL+16\n         MEXIT\n.RLEVERR  ANOP\n         MNOTE 16,'LEVEL MUST BE SPECIFIED ON REST COMMAND'\n         MEXIT\n         MEND\n*% END                                                                %\n         EJECT\n*% MACRO - B2X                                                        %\n*%         CONVERT A BINARY TO PRINTABLE HEX AND MOVE                 %\n         MACRO\n&LABEL   B2X &OUTPUT,&INPUT\n         UNPK  #UNPKWRK(L'&INPUT*2+1),&INPUT.(L'&INPUT+1)\n         TR    #UNPKWRK(L'&INPUT*2),PRINTHEX\n         MVC   &OUTPUT,#UNPKWRK\n         MEND\n*% END                                                                %\n         EJECT\n*% DSECTS                                                             %\n         PRINT ON,GEN\n         MAPCOMR                       DSECT OF COMREG\n         MAPXPCCB                      DSECT OF XPCC BLOCK ETC\n         PWRSPL TYPE=MAP               DSECT OF SPOOL PARAM LIST\n*% END                                                                %\n         EJECT\n*% START OF MODULE                                                    %\n         PRINT ON,GEN\nMODSTART CSECT\n         DC    CL8'PWRCMD  '       MODULE NAME STORAGE MARKER\n*% REGISTER EQUATES                                                   %\nR0       EQU   0             -  MACROS LINKAGE ETC\nR1       EQU   1             -  MACROS LINKAGE ETC\nR2       EQU   2             WORK REG\nR3       EQU   3             WORK REG\nR4       EQU   4             WORK REG\nR5       EQU   5             WORK REG\nXPCCBREG EQU   6             XPCCB CONTROL BLOCK\nR7       EQU   7             REPLY BUFFER\nR8       EQU   8             PXPUSER & PXUUSER DSECTS\nBALREG   EQU   9             BRANCH AND LINK REGISTER\nBASE1    EQU   10            BASE REG 1\nBASE2    EQU   11            BASE REG 2\nBASE3    EQU   12            BASE REG 3\nR12      EQU   12\nR13      EQU   13            -  SAVEAREA\nR14      EQU   14            -  MACROS LINKAGE ETC\nR15      EQU   15            -  MACROS LINKAGE ETC\n*% OTHER EQUATES                                                      %\nPOSTBIT  EQU   X'80'               MASK FOR A POSTED ECB\nRBUFSIZE EQU   4*1024              REPLY BUFFER SIZE IN K\n*% END EQUATES                                                        %\n         EJECT\n*% START OF CODE                                                      %\nPWRCMD   CSECT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         BALR  BASE1,0             LOAD BASE REG ONE\n         USING *,BASE1,BASE2,BASE3 ESTABLISH ADDRESABILITY\n         LA    BASE2,4095(BASE1)   LOAD BASE REG TWO\n         LA    BASE2,1(BASE2)\n         LA    BASE3,4095(BASE2)   LOAD BASE REG THREE\n         LA    BASE3,1(BASE3)\n         ST    R13,SAVEAREA+4      SAVE R13 FOR GOING BACK\n         LA    R13,SAVEAREA        POINT TO SAVE AREA\n         SAVEWORK TYPE=SET,NUMLEVS=20\n         CR    R1,R15              WAS A PARM SUPPLIED\n         BE    NOPARM              NO !!\n         XR    R2,R2               CLEAR R2\n         ICM   R2,B'0111',1(R1)    LOAD ADDR OF PARM\n         XR    R3,R3               CLEAR R3\n         ICM   R3,B'0011',0(R2)    LOAD LENGTH BYTES OF PARM\n         C     R3,=F'71'           CHECK LENGTH\n         BL    *+8                 OK SO DO EXECUTE\n         L     R3,=F'71'           REP AS TOO LONG\n         BCTR  R3,R0               MAKE A MACHINE LENGTH\n         LA    R2,2(R2)            UP R2 TO POINT TO PARM DATA\n         EX    R3,MOVEPOWC         MOVE POWER COMMAND INTO SPL LIST\n         OPEN  PRINTER\n         COMRG                     GET COMREG ADDRESS\n         USING COMREG,R1           ADDRESSING\n         MVC   JOBNAME,COMNAME     MOVE JOB NAME FOR MSG\n         MVC   ISSCMD,CMDCFLD      MOVE THE COMMAND FOR MSG\n         MESSAGE ADDR=MSGICMD,TYPE=BOTH\n         B     BYPMVCX1\nMOVEPOWC MVC   CMDCFLD(*-*),0(R2)  VARIABLE MOVE FOR POWER COMMAND\nBYPMVCX1 DS    0H\n         LA    XPCCBREG,XPCCBLK          LOAD ADDRESS OF XPCCB BLOCK\n         USING IJBXPCCB,XPCCBREG         DUMMY SECTION FOR XPCCB BLOCK\n         LA    R7,REPLBUF          LOAD THE ADDR OF BUFFER\n         USING RECPRFIX,R7         DSECT FOR POWER RECORD REFIX\n         XPCC XPCCB=(XPCCBREG),FUNC=IDENT      IDENTIFY MYSELF\n         B     *+4(R15)            BRANCH ON RETURN CODE\n         B     IDENTOK             RC = 0      ALL     OK\n         B     IDENTOK             RC = 4      THIS IS OK\n         B     ERRXPCC             RC = 8\n         B     ERRXPCC             RC = 12     SHOULD BE N/A\n         B     ERRXPCC             RC = 16     SHOULD BE N/A\nIDENTOK  DS    0H\n         XPCC XPCCB=(XPCCBREG),FUNC=CONNECT    CONNECT TO POWER\n         LTR   R15,R15             ZERO RETURN CODE ?\n         BNZ   ERRXPCC             ...NO\n         SETIME 120,INTECB         INSTALL WAIT INTERVAL OF TWO MINS\n         LA    R3,IJBXCECB         LOAD ADDRESS OF CONNECTION ECB\n         ST    R3,LISTCECB         COMPLETE WAITLIST\n         WAITM WAITLIST            WAIT FOR CONNECTION OR 2 MINS\n         TM    IJBXCECB+2,POSTBIT  CONNECTION COMPLETE?\n         BNO   ERRTOUT             ...NO, SO ISSUE TIMEOUT MESSAGE\n         LA    R8,IJBXSUSR         GET ADDR OF USER DATA TO BE SENT\n         USING PXUUSER,R8          ADDRESSABILITY FOR DSECT\n         MVI   PXUBTYP,PXUBTSPL    IND BUFFER TYPE IS SPOOL\n         XC    PXUACT1,PXUACT1     CLEAR ACTION BYTE\n         XC    CMDGPW,CMDGPW       CLEAR PASSWORD FOR NO CHECKS\nDOSENDR  DS    0H\n         XPCC XPCCB=(XPCCBREG),FUNC=SENDR\n         LTR   R15,R15             ZERO RETURN CODE ?\n         BNZ   ERRXPCC             ...NO\n         LA    R3,IJBXSECB         LOAD ADDRESS OF SENDR ECB\n         WAIT  (R3)                WAIT FOR SENDER ECB TO BE POSTED\n         CLI   IJBXREAS,X'00'      REASON CODE OK ?\n         BNE   ERRREAS             ...NO\n         LA    R8,IJBXRUSR         GET ADDR OF RECEIVED USER DATA\n         USING PXPUSER,R8          ADDRESSABILITY FOR DSECT\n         CLI   PXPRETCD,PXP00OK    POWER RETURN CODE OK ?\n         BNE   ERRPOW              ...NO\n         BAL   BALREG,PRNTREP      PRINT THE REPLY BUFFER\n         CLI   PXPFBKCD,PXP00EOD   WAS LAST BUFFER END OF DATA ?\n         BE    DODISC              ...YES\n         XC    IJBXBLN,IJBXBLN     ZERO LENGTH BUFFER TO BE SENT\n         LA    R8,IJBXSUSR         GET ADDR OF USER DATA TO BE SENT\n         USING PXUUSER,R8          ADDRESSABILITY FOR DSECT\n         XC    PXUBTYP,PXUBTYP     CLEAR BUFFER TYPE\n         MVI   PXUACT1,PXUATRMR    INDICATE SEND MORE MESSAGES\n         B     DOSENDR\nDODISC   DS    0H\n         XPCC XPCCB=(XPCCBREG),FUNC=DISCONN    DISCONNECT FROM POWER\n         LTR   R15,R15             ZERO RETURN CODE ?\n         BNZ   ERRXPCC             ...NO\n         XPCC XPCCB=(XPCCBREG),FUNC=TERMIN     TERMINATE XPCC\n         LTR   R15,R15             ZERO RETURN CODE ?\n         BNZ   ERRXPCC             ...NO\n         B     RETURN\n*% END                                                                %\n         EJECT\n*% RETURN                                                             %\nRETURN   DS    0H                  EOJ ROUTINE\n         CLOSE PRINTER\n         L     R15,RETCODE         LOAD THE RETURN CODE\n         L     R13,SAVEAREA+4      RESTORE SAVE AREA ADDRESS\n         L     R14,12(R13)         RESTORE REGISTERS APART FROM R15\n         LM    R0,R12,20(R13)      WHICH HAS THE RETURN CODE\n         BR    R14                 BACK WE GO\n*% END                                                                %\n         EJECT\n*% SUB ROUTINE PRINT THE REPLY BUFFER                                 %\nPRNTREP  DS    0H\n         SAVEWORK TYPE=SAVE,LEVEL=SWRKPRP\n         LA    R7,REPLBUF         LOAD ADDR OF BUFFER\n         USING RECPRFIX,R7        DSECT FOR POWER RECORD PREFIX\nBUFLEFT  EQU   R3\n         XR    BUFLEFT,BUFLEFT    CLEAR REG\n         ICM   BUFLEFT,B'0111',IJBXSLN  LENGTH OF BUFFER TO PROCESS\n         BZ    PREPRET            NOTHING TO PRINT\nPREPLOOP DS    0H\n         LH    R2,RECLNGTH         LOAD LENGTH BYTES\n         LA    R7,RECPRFXL(R7)     UP R7 TO POINT TO DATA\n         LR    R1,R7               ADDRESS OF DATA\n         AR    R7,R2               UP BY LENGTH OF RECORD FOR NEXT\n         BCTR  R2,0                MAKE A MACHINE LENGTH\n         LR    R0,R2               LOAD REG FOR CALL\n         OI    FLAGCTL,FLGPRT      TO THE PRINTER\n         BAL   BALREG,SHOWIT       GO PRINT ROUTINE\n         LA    R2,RECPRFXL+1(R2)   TOTAL LENGTH DATA + HEADER\n         SR    BUFLEFT,R2          CALC LENGTH OF BUFFER STILL TO DO\n         LTR   BUFLEFT,BUFLEFT     ALL DONE ?\n         BZ    PREPRET             ...YES\n         B     PREPLOOP            LOOP ROUND\nPREPRET  DS    0H\n         SAVEWORK TYPE=REST,LEVEL=SWRKPRP\n         BR    BALREG\n*% END                                                                %\n         EJECT\n*% EXTENDED ERROR HANDLING                                            %\nNOPARM   DS    0H\n         MESSAGE 'NO PARM SUPPLIED ON // EXEC'\n         MVC   RETCODE,=F'16'      RETURN CODE 16\n         B     RETURN\nERRTOUT  MESSAGE 'TIMEOUT HAS OCCURRED'\n         MVC   RETCODE,=F'16'      RETURN CODE 16\n         B     RETURN\nERRPOW   DS    0H\n         USING PXPUSER,R8          ADDRESSABILITY FOR DSECT\n         MVC   RETCODE,=F'16'      RETURN CODE 16\n         B2X   CODE1,PXPRETCD      POWER RETURN CODE\n         B2X   CODE2,PXPFBKCD      POWER FEEDBACK CODE\n         MESSAGE ADDR=MSGRETS,TYPE=BOTH\n         B     RETURN\nERRXPCC  DS    0H\n         ST    R15,RETCODE         SAVE RETURN CODE FOR EOJ\n         STCM  R15,B'0001',XPCCRC  SAVE RC FOR MSG\n         B2X   XPCODE1,IJBXFCT     FUNCTION BYTE\n         B2X   XPCODE2,IJBXRETC    XPCC RETURN CODE\n         B2X   XPRCR15,XPCCRC      XPCC RETURN CODE R15\n         MESSAGE ADDR=MSGXPRC,TYPE=BOTH\n         B     RETURN\nERRREAS  DS    0H\n         MVC   RETCODE,=F'16'      SET RETURN CODE 16\n         B2X   XPREAS,IJBXREAS     RAESON CODE\n         MESSAGE ADDR=MSGREAS,TYPE=BOTH\n         B     RETURN\n*% END                                                                %\n         EJECT\n*% SUB ROUTINE TO DISPLAY MESSAGES                                    %\n*%                                                                    %\n*%    A 'BAL' IS MADE TO THIS ROUTINE WHEN THE IN-LINE MACRO MESSAGE  %\n*% IS USED, R0 = MACHINE LENGTH OF MESSAGE & R1 = ADDRESS OF THE      %\n*% MESSAGE                                                            %\n*%                                                                    %\nSHOWIT   DS    0H\n         SAVEWORK TYPE=SAVE,LEVEL=SWRKPRT       SAVE BALREG ETC\n         MVI   MESSAREA,X'40'      BLANK FOR ASA CTL CHAR + ROLL MOVE\n         MVC   MESSAREA+1(L'MESSAREA-1),MESSAREA   CLEAR IT\n         MVC   MESSAREA+1(L'MESSHEAD),MESSHEAD     MESSAGE PREFIX\n         LR    R2,R0\n         CH    R2,=Y(132-L'MESSHEAD)  LOGIC CHK MAX MSG LENGTH ?\n         BNH   SHWLENOK               ...NO\n         LH    R2,=Y(132-L'MESSHEAD)  ...YES  SO FIRST 72 BYTES ONLY\nSHWLENOK DS    0H\n         EX    R2,MOVEMESS\n         TM    FLAGCTL,FLGCONS     CONSOLE ?\n         BZ    SHWPRT              ...NO\n         PUT   CONSOLE,MESSAREA    OUTPUT TO SYSLOG\nSHWPRT   DS    0H\n         TM    FLAGCTL,FLGPRT      PRINTER ?\n         BZ    SHWRET              ...NO\n         PUT   PRINTER,MESSAREA    OUTPUT TO SYSLST\nSHWRET   DS    0H\n         NI    FLAGCTL,X'FF'-FLGCONS-FLGPRT     RESET FLAGS\n         SAVEWORK TYPE=REST,LEVEL=SWRKPRT       RESTORE BALREG ETC\n         BR    BALREG              RETURN\nMOVEMESS MVC   MESSAREA+L'MESSHEAD+1(*-*),0(R1)   MOVE THE MESSAGE\n*% END                                                                %\n         EJECT\n*% CONSTANTS                                                          %\nSAVEAREA DS    9D                   SAVEAREA\nRETCODE  DC    F'0'                 RETURN CODE\nXPCCRC   DS    X                    XPCC R15 RETURN CODE ERROR PROC\n         SAVEWORK TYPE=DEFINE\nWAITLIST DC    A(INTECB)           INTECB = 1ST ELEMENT OF WAITLIST\nLISTCECB DC    A(0)                IJBXCECB = 2ND ELEM. OF WAITLIST\nLISTEND  DC    X'FF'               INDICATE END OF WAITLIST\nINTECB   DS    F                   ECB USED TO WAIT FOR TIMER INTERVALS\nMESSHEAD DC    C'PWRCMD : '         HEADER FOR ALL MESSAGES\nMESSAREA DC    CL133' '\nFLAGCTL  DC    X'00'                CONTROL FLAG\nFLGCONS  EQU   B'00000001'          CONSOLE MESSAGE\nFLGPRT   EQU   B'00000010'          PRINTER MESSAGE\n#UNPKWRK DS    CL32                 UNPK WORK AREA\nPRINTHEX EQU   *-240                START ADDRESS FOR TRANTAB\n         DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nPWRREQ   PWRSPL TYPE=GEN,FUNC=COMMAND,USERID=SYSCMD,REQ=CTL,PRFX=CMD\nXPCCBLK  XPCCB  APPL=SYSCMD,TOAPPL=SYSPWR,BUFFER=(PWRREQ,CMDGLEN),     C\n               REPAREA=(REPLBUF,RBUFSIZE)\n*% END                                                                %\n         EJECT\n*% MESSAGE CONSTANTS                                                  %\nMSGICMD  DS    0H\n         DC    C' JOB = '\nJOBNAME  DC    CL8' '\n         DC    C' CMD = '\nISSCMD   DC    CL71' '\nMSGICMDE EQU   *\nMSGICMDL DC    Y((MSGICMDE-MSGICMD)-1)\nMSGRETS  DS    0H\n         DC    C' REQUEST TO POWER FAILED   PXPRETCD = '\nCODE1    DC    C'  '\n         DC    C' PXPFBKCD = '\nCODE2    DC    C'  '\nMSGRETSE EQU   *\nMSGRETSL DC    Y((MSGRETSE-MSGRETS)-1)\nMSGXPRC  DS    0H\n         DC    C' XPCC REQUEST FAILED  R15 = '\nXPRCR15  DC    C'  '\n         DC    C' IJBXFCT  = '\nXPCODE1  DC    C'  '\n         DC    C' IJBXRETC = '\nXPCODE2  DC    C'  '\nMSGXPRCE EQU   *\nMSGXPRCL DC    Y((MSGXPRCE-MSGXPRC)-1)\nMSGREAS  DS    0H\n         DC    C' BAD REASON CODE '\n         DC    C' IJBXREAS = '\nXPREAS   DC    C'  '\nMSGREASE EQU   *\nMSGREASL DC    Y((MSGREASE-MSGREAS)-1)\n*% END                                                                %\n         EJECT\n*% START OF LTORG POOL                                                %\n         LTORG\n*% END                                                                %\n         EJECT\n*% DTF FOR FILES                                                      %\n         PRINT ON,NOGEN\nCONSOLE  DTFCN DEVADDR=SYSLOG,                                         C\n               IOAREA1=CONSWORK,                                       C\n               TYPEFLE=CMBND,                                          C\n               BLKSIZE=65,                                             C\n               INPSIZE=65,                                             C\n               WORKA=YES\nCONSWORK DS     CL144\nPRINTER  DTFPR DEVADDR=SYSLST,                                         C\n               IOAREA1=REPORT1,IOAREA2=REPORT2,                        C\n               BLKSIZE=133,                                            C\n               CTLCHR=ASA,                                             C\n               WORKA=YES\nREPORT1  DS     CL133\nREPORT2  DS     CL133\nREPLBUF  DC     (RBUFSIZE)X'00'         DEFINE REPLY BUFFER AREA\n*% END                                                                %\n         END   PWRCMD\nJohn Brunton\nSystem Programmer\nCannon Lincoln Assurance (UK)      c J Brunton & Cannon Lincoln Assurance 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A02": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02\\xae\\x02\\xae\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 686, "newlines": 686, "modlines": 0, "user": "VSEUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "E006A03": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x95\\x00\\x95\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 149, "newlines": 149, "modlines": 0, "user": "VSEUPDT"}, "text": "Preventing automatic restart of in-flight jobs\n\nAfter a system crash, all in-flight jobs are automatically\nrestarted by POWER. This may not be desired! To allow some\nmeasure of control, the XMODExx parameter can be tested and\nappropriate action taken. This parameter is available in VSE/SP\n4, and may be available in earlier releases. The DTRSETP\nutility program used to interrogate and/or modify this and other\nparameters is described in the VSE/SP Administration Manual,\nSC33-6405.\n\nThe following procedures may be catalogued, and then\nexecuted by inserting the following statement in each job:\n\n      // EXEC PROC=$$MODE\n\nThese procedures will interrogate the system parameter\nXMODEFx, and pause if the value of the parameter is\nRECOV. The operator may then CANCEL the job (nn\nCANCEL), or allow the job to continue by responding with\nENTER. If the job is allowed to continue, the XMODEFx\nparameter is set to 'WARM' so subsequent jobs running in that\npartition will not pause.\n\n* $$ JOB JNM=CATALOG,DISP=D,CLASS=0\n// JOB CATALOG\n// EXEC LIBR,PARM='MSHP'\n  ACCESS S=IJSYSRS.SYSLIB\nCATALOG $0MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEBG=''\n// EXEC PROC=CPUVAR1,XMODEBG\n// IF XMODEBG NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEBG=WARM'\n/*\n/. GOGO\n/+\nCATALOG $2MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF2=''\n// EXEC PROC=CPUVAR1,XMODEF2\n// IF XMODEF2 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF2=WARM'\n/*\n/. GOGO\n/+\nCATALOG $3MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF3=''\n// EXEC PROC=CPUVAR1,XMODEF3\n// IF XMODEF3 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF3=WARM'\n/*\n/. GOGO\n/+\nCATALOG $4MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF4=''\n// EXEC PROC=CPUVAR1,XMODEF4\n// IF XMODEF4 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF4=WARM'\n/*\n/. GOGO\n/+\nCATALOG $5MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF5=''\n// EXEC PROC=CPUVAR1,XMODEF5\n// IF XMODEF5 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF5=WARM'\n/*\n/. GOGO\n/+\nCATALOG $6MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF6=''\n// EXEC PROC=CPUVAR1,XMODEF6\n// IF XMODEF6 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF6=WARM'\n/*\n/. GOGO\n/+\nCATALOG $7MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF7=''\n// EXEC PROC=CPUVAR1,XMODEF7\n// IF XMODEF7 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF7=WARM'\n/*\n/. GOGO\n/+\nCATALOG $8MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF8=''\n// EXEC PROC=CPUVAR1,XMODEF8\n// IF XMODEF8 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF8=WARM'\n/*\n/. GOGO\n/+\nCATALOG $9MODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEF9=''\n// EXEC PROC=CPUVAR1,XMODEF9\n// IF XMODEF9 NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEF9=WARM'\n/*\n/. GOGO\n/+\nCATALOG $AMODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEFA=''\n// EXEC PROC=CPUVAR1,XMODEFA\n// IF XMODEFA NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEFA=WARM'\n/*\n/. GOGO\n/+\nCATALOG $BMODE.PROC  DATA=YES REPLACE=YES\n// SETPARM XMODEFB=''\n// EXEC PROC=CPUVAR1,XMODEFB\n// IF XMODEFB NE RECOV THEN\n// GOTO GOGO\n// PAUSE RECOVERY MODE - CANCEL NOW, OR ENTER TO CONTINUE\n// EXEC DTRSETP,PARM='CPUVAR1;;SET XMODEFB=WARM'\n/*\n/. GOGO\n/+\nLIST $0MODE.PROC $2MODE.PROC $3MODE.PROC $4MODE.PROC $5MODE.PROC -\n     $6MODE.PROC $7MODE.PROC $8MODE.PROC $9MODE.PROC $AMODE.PROC -\n     $BMODE.PROC\n/*\n/&\n* $$ EOJ\n\nFrank A Braman\nSystems Programmer\nSt Johnsbury Trucking Co (USA)      c St Johnsbury Trucking Co 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A04": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00k\\x00k\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 107, "newlines": 107, "modlines": 0, "user": "VSEUPDT"}, "text": "Get CPU-id for several applications\n\nThe following macro and B-transient is very useful to get the\nCPU identification for applications that need this information to\nsign a report or to determine the system they are running on.\n\nIt will help in situations where multiple guests run under VM,\nor where multiple real processors may be in a network.\n\n       MACRO\n&NAME  GETCPUID &UNPK,&PACK,&LIST=\n       LCLB  &POS\n* WJK - GET CPU ID - V.1.0\n       CNOP  0,4\n       AIF   ('&NAME' EQ '').NONAME\n&NAME  DC    0F'0'\n.NONAME  ANOP\n       BAL   0,WJK1&SYSNDX\n       AIF   ('&UNPK' EQ '').NOUNPK\n       DC    A(&UNPK)\n       AGO   .PARM2\n.NOUNPK  ANOP\n       DC    A(0)\n.PARM2  ANOP\n       AIF   ('&PACK' EQ '').NOPACK\n       DC    A(&PACK)\n       AGO   .FETCH\n.NOPACK  ANOP\n       DC    A(0)\n.FETCH  ANOP\nWJK1&SYSNDX DS   0H\n       LA    1,=C'$$BCPUID'\n       SVC   2  FETCH TRANSIENT\n.EXIT  ANOP\n       MEXIT\n.PARMERR ANOP\n       MNOTE 8,'WRONG PARAMETER'\n       MEND\n$CPU  TITLE '$$BCPUID  -  TRANSIENT TO GET THE CPU-ID'\n       PUNCH '   PHASE $$BCPUID,+0 '\n       SPACE 3\n$$BCPUID START 0\n       USING *,R15\n       DC    CL8'$$BCPUID'\n       B     BEGIN\nVERSION  DC    C' V.1.0 '\n       DC    C'&UDATE '\n       DC    C'&UTIME '\n       DC    C'author: willi j. kuhn '\n       SPACE 3\n\nEditor's note: register equates go here.\n\n     EJECT\nBEGIN DS    0H\n       LR    R2,R0                  SAVE PARAMETER ADDR\n* GO TO SUPERVISOR-STATE BY FORCED PROGRAM CHECK INTERRUPT\n       SR    R0,R0\n       SVC   22    SEIZE THE SYSTEM\n* NO INTERRUPT ARE ALLOWED\n       MVC   PSWSV,X'68'         SAVE PROG NEW PSW\n       BAL   R1,NEWADR\n* ROUTINE EXECUTED IN SUPERVISOR-STATE\n       MVC   X'68'(8,0),PSWSV    RESTORE PROG NEW PSW\n       STIDP CPUID               FETCH CPU-ID\n       SPACE\nENDSVST  MVI   FORCECHK,X'07'\n       LPSW  X'28'(0)            RETURN TO PROBLEM-STATE\nNEWADR  ST    R1,ADR             )MOVE USER ROUTINE ADR TO\n       MVC   X'6D'(3,0),ADR+1    )NEW PROG PSW\nFORCECHK DC    H'0'              )AND FORCE PROG.CHECK\n* RELEASE SEIZURE\nREL    LA    R0,X'FF'\n       SVC   22                  RELEASE THE SYSTEM\n* INTERRUPT ARE ALLOWED\n       SPACE\n       L     R1,0(R2)            GET 1ST PARAM ADDR\n       LTR   R1,R1               TEST FOR ZERO\n       BZ    PARM2               NOT REQUESTED\n       SPACE\n       UNPK  CPUIDU1,CPUID(5)   UNPACK CPU ID PART 1\n       UNPK  CPUIDU2,CPUID+4(5)  AND PART 2\n       MVC   0(8,R1),CPUIDU1     MOVE UNPACKED CPU ID PART1\n       MVC   8(8,R1),CPUIDU2       AND PART2\n       TR    0(16,R1),HEXTAB     TRANSLATE FOR PRINTABLE\n       SPACE 2\nPARM2  DS    0H\n       L     R1,4(R2)            GET 2ND PARAM ADDR\n       LTR   R1,R1               TEST FOR ZERO\n       BZ    RETURN              NOT REQUESTED\n       SPACE\n       MVC   0(L'CPUID,R1),CPUID    MOVE UNCHANGED\n       SPACE 3\n* RETURN TO CALLING PROGRAM\nRETURN  SVC   11\nCPUIDU1  DS    CL9\nCPUIDU2  DS    CL9\nCPUID    DC    D'0'\nPSWSV    DS    D\nADR      DS    A\nHEXTAB   DC    240X'00'\n       DC    C'0123456789ABCDEF'\n       END\n\nWilli Kuhn\nFreelance Systems Programmer (Germany)            c Willi Kuhn 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A05": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00@\\x00@\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 64, "newlines": 64, "modlines": 0, "user": "VSEUPDT"}, "text": "CICS commands from batch\n\nThe following Assembler source code allows any program to\nfeed a character string to the system console as if it were keyed\nto the DOC handler in VSE/SP 2.1.7. I suspect it will function\non any Version 2 VSE supervisor.\n\nI wrote this for a client installation so they could CLOSE and\nOPEN CICS datasets from a batch partition during update runs\nunder the control of the batch program.\n\nThe client leaves a Terminal Control read outstanding at the\nsystem console all the time, and this routine and the batch\nprogram are able to issue a CEMT CLOSE or OPEN when\nnecessary.\n\nOne address, the system PSS, must be obtained from a\nsupervisor Assembly listing.\n\n*  START OF ROUTINE\n     SR    R1,R1           GET INTO PROTECT KEY 0\n     ICM   R1,8,=X'FF'\n     SVC   13\n     ST    R1,SAVR1\n     COMRG ,\n     USING COMREG,R1\n     LH    R1,PIB2PTR      GET PIB EXTENSION\n     DROP  R1\n     USING PIBADR,R1\n     L     R1,PIBPCB       GET PCB ADDRESS\n     DROP  R1\n     USING PCBADR,R1\n     ASYSCOM (R2)          GET SYSCOM ADDRESS\n     USING IJBERBLC,R2\n     TM    IJBASYFL,ASYBUSY    Q.ASYNC OPER BUSY\n     BO    BUSYRUTN              YES\n     L     R3,IJBASY      GET ASYNCH AREA ADDRESS\n     USING ASYTAB,R3\n     MVC   ASYBUFF,ASYBUFF-1      CLEAR BUFFER\n     MVC   ASYBUFF(72),CEMTCMND   MOVE CEMT COMMAND TO BUFFER\n     MVC   ASYLENG(2),=H'72'      AND COMMAND LENGTH\n     01    IJBASYFL,ASYREQRD+ASYREPAV MARK ASYNCH READY\n     01    X'258',X'80'    SET SYS PSS ACTIVE (FROM SUPV LIST)\n     01    TSS+1,X'80'            MARK ASYNCH READY\n     DROP  R1,R2,R3\n     L     R1,SAVR1         SET REGULAR PROTECT KEY\n     ICM   R1,8,=X'FF'\n     ICM   R1,1,=X'FF'\n     SVC   12\n     COMRG ,                FORCE TASK SELECTION\n*  END OF ROUTINE\nSAVR1 DS   F\n     PRINT GEN\n     SYSCOM                 GET DSECTS\n     MAPCOMR\n     MAPPIB\n     MAPPCB\n     ASYTAB\n     END\n\nOrville A Wiseman\nConsultant\nWiseman Computer Group (USA)       c Wiseman Computer Group 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A06": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\x10\\x06\\xbc\\x06\\xba\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:10:59", "lines": 1724, "newlines": 1722, "modlines": 0, "user": "VSEUPDT"}, "text": "File generation datasets under VSE\n\nMVS contains a feature that to my knowledge is not available\nin VSE. That feature is Generation DataSets (GDS). For those\nnot familiar with the term a GDS enables multiple versions of a\nfile to be maintained, each being updated in succession. Any\nversion of the GDS can be read at the user's option.\n\nTo get a similar function to work on VSE I wrote a program\nthat makes use of VSE JCL symbolic parameters. The program\naccesses a VSAM file containing information relating to each\nGDS, updates the GDS control file if necessary, and passes the\nGDS version to be accessed as a return code. The JCL takes\nthe return code, sets it up as a PARM, and modifies the VSAM\nDLBL via symbolic parameters.\n\nIt should be noted that even though I use the GDS function for\nVSAM files, there is no reason why it couldn't be used for\nnon-VSAM disk files or even tape files.\n\n\nRESTRICTIONS\n\nThe number of versions maintained for a GDS is limited to 10.\nVSE can handle return codes up to 4095 but return codes equal\nto 16 or more are usually considered to be a serious problem by\nsome IBM system programs. A limit of 10 seems to be a\nreasonable limitation, but if you feel otherwise it is a simple\nprogram change.\n\nThe file name for each version of a GDS must be identical\nexcept for the version number. The version number will be a V\nfollowed by a 4-digit number. For example:\n\n      SAMPLE.VSAM.GDS.FILE.V0001\n      SAMPLE.VSAM.GDS.FILE.V0002\n\nAll versions of the GDS must be defined to VSAM prior to\nuse. Information will be passed back to the user via return\ncodes. The user can use the return codes in conditional JCL to\nmake the GDS work. It should be pointed out that only the last\nreturn code can be returned so you should have only one 'read'\nor one 'write' command in the JCL and it must be the last one.\nYou can use other commands preceding the read or write. The\nreturn codes used are listed in Figure 1.\n\nThe GDS name used as input to the GDS program is 8-\ncharacters long and uniquely identifies the GDS. I use a\nstandard name in the following format (the standards can be\naltered):\n\n      XSSGDSNN\n\nwhere NN is the sequential number; GDS remains constant as\nGDS; SS is the system code (eg 'AR' for accounts receivable,\n'AP' for accounts payable, etc.); X is either 'P' for production\nor 'T' for test.\n\nFor example, if I were setting up the first GDS for an accounts\nreceivable system in a production environment I would give it a\nname of PARGDS01.\n\nProgram input is free form, but the fields must be input in the\nsequence shown in Figure 2 with at least one blank between\neach field, except between the sign and the version in which\ncase there is no space.\n\nA log is written to the console so all activity can be traced\neasily as the job progresses.  There are four types of data\nlogged:\n\nThe following line always shows:\n\n         REQUEST=> X------DUPLICATES THE INPUT YOU SUPPLIED--->\n\nThe following is returned if an error occurs:\n\n         ERROR  => X--ERROR MESSAGE--X\n\nThe following line displays informational messages:\n\n         X------INFO------X\n\nThe following line displays the return information after\nprocessing GDS:\n\n      RETURN => XX OF YY MM/DD/YY HH/MM RC=NN <----DESCRIPT---->\n\nwhere XX is the current version of the GDS; YY is the\nmaximum number of versions of this GDS; MM/DD/YY is the\ndate and time of the last update; NN is the return code; and\nDESCRIPT is a description of the GDS.\n\nI'm running on VSE/SP 3.1 and CICS 1.7 but other releases\nthat allow conditional JCL and symbolic parameters should not\nbe a problem.\n\nFigure 3 shows a summary of field usage by command.\n\n\nSAMPLE INPUTS\n\nSample inputs to the program (phase name=ZZGDS) are as\nfollows:\n\no      Create a production GDS with 5 versions:\n      PMSGDS01 CREATE 5 RECYCLED.ERRORS\n\no      Write to a GDS:\n      PMSGDS01 WRITE\n\no      Read current version:\n      PMSGDS01 READ\n\no      Read previous version:\n      PMSGDS01 READ -1\n\no      Read previous 3:\n      PMSGDS01 READ V3\n\no      Delete 1 version of GDS:\n      PMSGDS01 DELETE 1\n\no      Delete entire GDS from control:\n      PMSGDS01 DELETE 99\n\n\nSAMPLE JCL USING GDS CONTROL PROGRAM\n\n   01 * $$ JOB JNM=ZZTSTGDS,CLASS=P,DISP=D,USER=ANGELO\n   02 * $$ LST FNO=1PTW,DISP=D,CLASS=Z\n   03 // JOB ZZ0001 SAMPLE GDS JCL\n   04 // OPTION LOG,NODUMP\n   05 // ON $ABEND OR $CANCEL GOTO PROBLEM\n   06 // ASSGN SYS007,SYSIPT\n   07 // EXEC ZZGDS,SIZE=ZZGDS\n   08 PZZGDS01 DELETE 99\n   09 PZZGDS01 CREATE 5 TRANSACTION.RECYCLE\n   10 PZZGDS01 WRITE\n   11 /*\n   12 // IF $RC = 0 OR $RC > 10 THEN\n   13 // PAUSE PROBLEM WITH GDS RETURN CODE\n   14 // SETPARM ZZA=$RC\n   15 // ASSGN SYS007,SYSIPT\n   16 // EXEC ZZGDS,SIZE=ZZGDS\n   17 PZZGDS01 WRITE\n   18 /*\n   19 // IF $RC = 0 OR $RC > 10 THEN\n   20 // PAUSE PROBLEM WITH GDS RETURN CODE\n   21 // SETPARM ZZB=$RC\n   22 * PROCESS FIRST GDS\n   23 // DLBL SORTOUT,'SAMPLE.VSAM.GDS.FILE.V&ZZA',,VSAM,CAT=YOURCAT\n   24 // EXEC SORT,SIZE=96K\n   25  SORT FIELDS=(1,13,A),FORMAT=BI,WORK=1\n   26  RECORD TYPE=F,LENGTH=80\n   27  INPFIL SYSIPT\n   28  OUTFIL TOL,BLKSIZE=80\n   29  SUM FIELDS=NONE\n   30  END\n   31  ZZA INPUT 001\n   32  ZZA INPUT 002\n   33 /*\n   34 // DLBL FILE,'SAMPLE.VSAM.GDS.FILE.V&ZZA',,VSAM,CAT=YOURCAT\n   35 // EXEC IDCAMS,SIZE=AUTO\n   36    PRINT INFILE(FILE) SKIP(0) COUNT(10)\n   37 /*\n   38 * PROCESS SECOND GDS\n   39 // DLBL SORTOUT,'SAMPLE.VSAM.GDS.FILE.V&ZZB',,VSAM,CAT=YOURCAT\n   40 // EXEC SORT,SIZE=96K\n   41  SORT FIELDS=(1,13,A),FORMAT=BI,WORK=1\n   42  RECORD TYPE=F,LENGTH=80\n   43  INPFIL SYSIPT\n   44  OUTFIL TOL,BLKSIZE=80\n   45  SUM FIELDS=NONE\n   46  END\n   47 ZZB INPUT 001\n   48 ZZB INPUT 002\n   49 /*\n   50 // DLBL FILE,'SAMPLE.VSAM.GDS.FILE.V&ZZB',,VSAM,CAT=YOURCAT\n   51 // EXEC IDCAMS,SIZE=AUTO\n   52    PRINT INFILE(FILE) SKIP(0) COUNT(10)\n   53 /*\n   54 // GOTO LISTLOG\n   55 /. PROBLEM\n   56 * PROBLEM ENCOUNTERED\n   57 /. LISTLOG\n   58 // EXEC LISTLOG\n   59 /&\n   60 * $$ EOJ\n\n\n      Explanation of JCL (using the line numbers).\n\n05      If any programs abend or operator cancels job go to\n      'problem' at line 55.\n\n08      Delete entire GDS.\n\n09      Create a GDS with 5 versions.\n\n10      I want to write to next version of the GDS.\n\n12      If return code is not in the range of 1-10 a version was not\n      returned in which case the pause at line 13 will print on the\n      console.\n\nNote: I know pauses should not be used in a production\nenvironment but this is for illustration only.\n\n14      Set PARM ZZA (you pick this name) equal to the return\n      code (the next GDS version to be written). Note: the name\n      you pick does not have to be 3 positions long, however by\n      doing this you will be replacing the 4 symbolic characters\n      in the label (the symbolic name as used in the label will be\n      preceded by &) with the 4-digit return code; therefore there\n      will be no shifting  of the name in the label.\n\n17      I want to write the next version of the GDS.\n\n21      Set PARM ZZB (you pick this name) equal to the return\n      code  (the next GDS version to be written).\n\n23      This is the label for the GDS you are going to write. Note\n      the use of &ZZA. The & indicates that what follows is a\n      parameter and it points to the ZZA defined by line 14.\n      ZZA is a 4-position field containing the version number of\n      the GDS. For example, if the version number is 2 then\n      ZZA = 0002 and the label as processed will be changed\n      from V&ZZA to V0002. The actual file would have\n      previously been defined with V0001 to V0005 as the suffix\n      (assuming a 5 version GDS).\n\n34      See explanation for line 23 above for details on the\n      meaning of &ZZA for this DLBL. &ZZA will be replaced\n      with exactly the same version as in line 23.\n\n39       See explanation for line 23 above for details on the\n      meaning of &ZZB for this DLBL. &ZZB will be replaced\n      with the version determined at line 21.\n\n\nSAMPLE VSAM FILE DEFINITIONS\n\nThe following is a sample VSAM file definition for a GDS that\nwill have a maximum of three versions:\n\n          DEFINE CLUSTER( -\n                 NAME(SAMPLE.VSAM.GDS.FILE.V0001) -\n                   VOLUMES(123456) REUSE -\n                   NONINDEXED TRACKS(15 15) RECORDFORMAT(UNDEF) -\n                   RECORDSIZE(200 12000) SPEED FOR(0) NOALLOCATION) -\n                 CATALOG(YOUR.USER.CATALOG)\n          DEFINE CLUSTER( -\n                 NAME(SAMPLE.VSAM.GDS.FILE.V0002) -\n                   VOLUMES(123456) REUSE -\n                   NONINDEXED TRACKS(15 15) RECORDFORMAT(UNDEF) -\n                   RECORDSIZE(200 12000) SPEED FOR(0) NOALLOCATION) -\n                 CATALOG(YOUR.USER.CATALOG)\n          DEFINE CLUSTER( -\n                 NAME(SAMPLE.VSAM.GDS.FILE.V0003) -\n                   VOLUMES(123456) REUSE -\n                   NONINDEXED TRACKS(15 15) RECORDFORMAT(UNDEF) -\n                   RECORDSIZE(200 12000) SPEED FOR(0) NOALLOCATION) -\n                 CATALOG(YOUR.USER.CATALOG)\n\n\nTO INSTALL THE BATCH PROGRAM\n\nDefine the GDS control file to VSAM. Naturally you should\nchange the data to meet your shop standards. The sample\nbelow was set up for 3380 DASD.\n\n          DEFINE CLUSTER( -\n                   NAME(GDS.CONTROL.FILE) VOLUMES(123456) -\n                     INDEXED SHR(4 3) RECORDS(50 25) -\n                     RECORDSIZE(60 60) KEYS(8 0) FREESPACE(0 0) SPEED -\n                     TO(99365)) -\n                 DATA( -\n                   NAME(GDS.CONTROL.FILE.DATA) CISZ(4096)) -\n                 INDEX( -\n                   NAME(GDS.CONTROL.FILE.INDEX) CISZ(1024)) -\n                 CATALOG(YOUR.USER.CATALOG)\n\nPut a DLBL in the standard label area.\n\n         // DLBL ZZGDSK,'GDS.CONTROL.FILE',,VSAM,CAT=YOURCAT\n\nCompile the batch program. I used phase name ZZGDS. Note:\nthe program contains several macros. They are used to\nmaintain consistency, eliminate redundancy, and simplify\ncoding. You can put the coding in-line if you like.\n\nInitialize the GDS.CONTROL.FILE. The control file must be\ninitialized before using it. This is done by executing phase\nZZGDS with an input card containing INITIALIZE in column\n1, for example:\n\n         // ASSGN SYS007,SYSIPT\n         // EXEC ZZGDS,SIZE=ZZGDS\n         INITIALIZE\n         /*\n\nUse JCL similar to the sample JCL described above to test the\nsystem.\n\n\nON-LINE ACCESS TO GDS CONTROL FILE\n\nThe GDS control file can be accessed on-line using a CICS\ncommand level program. The on-line program is not essential\nto the processing of the GDS files but it does enable you to\nbrowse the GDS control file. It also enables you to change the\nfile description, the current version (especially useful when\ntesting, however this can also be done in batch), and the\nmaximum number of versions.\n\nTo use this program, you must do the following:\n\no      Add the following to your CICS tables (or use RDO):\n\nPCT table:\n\n             ZZGD     DFHPCT TYPE=ENTRY,TRANSID=ZZGD,PROGRAM=ZZGD01,  X\n                            SPURGE=YES\n\n                   *** PPT TABLE   ***\n\n             ZZGD01   DFHPPT TYPE=ENTRY,PROGRAM=ZZGD01,               X\n                            PGMLANG=ASSEMBLER\n             ZZGDS01  DFHPPT TYPE=ENTRY,MAPSET=ZZGDS01\n\nFCT table:\n\n             ZZGDSK   DFHFCT TYPE=DATASET,DATASET=ZZGDSK,             X\n                            ACCMETH=VSAM,FILSTAT=(ENABLED,CLOSED),    X\n                            RECFORM=(FIXED,BLOCKED),                  X\n                            SERVREQ=(BROWSE,READ,UPDATE),STRNO=2\n\no      Insert your company name in the BMS MAP macros and\n      compile  the MAP and DSECT.\n\no      Compile the program (use Assembler option NOPROLOG\n      for the command level preprocessor). For example:\n\n                // EXEC DFHEAP1$,SIZE=300K\n                *ASM XOPTS(LINECOUNT(78) NOPROLOG)\n                <--- SOURCE CODE HERE --->\n\no      Use trans ZZGD to access the transaction. The use of the\n      program is self-explanatory but be aware of the following:\n\n      o      You can use a generic prefix when entering the GDS-\n            id. The program will display the record that is equal to\n            or greater than this value. You can use the PF keys to\n            browse from there.\n\n      o      For updating, simply display the record you want,\n            make the change, and press PF9.\n\nThe GDS control file display/update screen looks like Figure 4.\n\nMost fields are self-explanatory, but note the following:\n\no      You can display or update an existing record, but you can't\n      add or delete a record.\n\no      The 'job that last updated GDS' is the batch job name that\n      established the GDS or the one that wrote to the GDS.\n      'Reads' do not update this field. If the GDS record is\n      updated on-line then this field will contain 'CICS'\n      followed by the 3-position DFHSNT operator-id.\n\n\nZZGDS\n\nGDS      TITLE 'JOB ZZGDS PSEUDO GENERATION DATASET PROCESSING'\n* THE PURPOSE OF THIS PROGRAM IS TO PROVIDE THE VSE USER WITH THE\n* ABILITY TO USE GENERATION DATASETS (GDS).\n*        * * * * * * * * *   N O T E   * * * * * * * * *\n*\n* BEFORE THE FILE IS USED FOR THE FIRST TIME, IT MUST BE INITIALIZED.\n* THIS IS DONE BY SIMPLY RUNNING THIS JOB WITH AN INPUT CARD CONTAINING\n* 'INITIALIZE' STARTING IN COLUMN 1.\n* THERE WILL BE A MAX OF 10 VERSIONS OF A DATASET.\n* RETURN CODES WILL BE AS FOLLOWS:\n*     00  SUCCESSFUL COMPLETION FOR OPTIONS CREATE, DELETE, USED\n*  01-10  VERSION OF GDS REQUESTED\n*     12  I/O ERROR\n*     13  INPUT REQUEST IS IN ERROR\n*     15  GDS RECORD NOT FOUND\n*     20-24 PROBLEM INITIALIZING FILE\n*         IF YOU ENCOUNTER A PROBLEM WHEN INITIALIZING THE FILE THE\n*         FOLLOWING MESSAGE WILL APPEAR ON THE CONSOLE:\n*               'ERROR  => FILE INIT PROB. RC=XX,R15=YY,FDBK=ZZ'\n*         . WHERE 'XX' = VALUE IN FIELD 'RETNCODE'.\n*            BY LOOKING AT ROUTINE 'INITFILE' YOU CAN DETERMINE WHICH\n*            VSAM MACRO HAD THE PROBLEM.\n*         . WHERE 'YY' = HEX VALUE IN REGISTER 15.\n*            CHECK 'VSE/VSAM COMMANDS AND MACROS' FOR THE MEANING OF\n*            THIS CODE. THEY ARE LISTED UNDER THE TOPIC 'RETURN CODES\n*            FOR REQUEST MACROS'.\n*         . WHERE 'ZZ' = HEX VALUE IN 'FDBK' FROM THE REQUEST MACRO.\n*            CHECK 'VSE/VSAM MESSAGES AND CODES' FOR THE MEANING OF\n*            THIS CODE. THEY ARE LISTED UNDER THE TOPIC 'RETURN CODES\n*            FROM REQUEST MACROS'.\n*   ----------------------------------------------------------------\n* INPUT REQUEST CARD IS FREEFORM WITH AT LEAST 1 SPACE BETWEEN EACH\n* FIELD:\n*         MAX <-- INPUT FIELD REQUIREMENTS BY COMMAND (X=REQUIRED)\n*         LTH CREATE DELETE STATUS READ WRITE                    .\n* PDSID     8   X      X      X     X     X                      .\n* COMMAND   8   X      X      X     X     X                      .\n* SIGN      1                       0                            .\n* VERSION   2   X      O            O                            .\n* DESCR    30   X                                                .\n*\n*  NOTE: SIGN CAN BE 'V' (FOR ACTUAL VERSION) OR '-' FOR RELATIVE\n*    VERSION IF NOT CURRENT VERSION. THERE MUST BE NO BLANKS BETWEEN\n*    SIGN AND VERSION #. IF YOU WANT THE CURRENT VERSION SIMPLY LEAVE\n*    SIGN & VERSION BLANK.\n*    USING VERSION '99' FOR DELETE WILL PURGE THE GDS RECORD FROM THE\n*    FILE.\n         EJECT\n* MACRO DEFINITIONS\n         MACRO\n         REGIS\n* MACRO        ==> REGIS\n* PARAMETERS   ==> NONE\n* PURPOSE      ==> ASSIGN TAGS TO REGISTERS\n\nEditor's note: register equates go here.\n\n         MACRO\n&NAME    BEGIN &SUB\n* MACRO        ==> BEGIN &SUB\n* PARAMETERS   ==>  &SUB = NONE - NORMAL PHASE\n*                   &SUB = SUB  - CALLED SUBROUTINE\n* PURPOSE      ==> USED BY ASSEMBLER PHASES TO ESTABLISH REGISTER SAVE\n*                  AREAS AND BY CALLED SUBROUTINES TO ESTABLISH RETURN\n*                  LINKAGE AS WELL.\n         DS    0H\n&NAME    EQU   *\n         AIF   ('&SUB' EQ 'SUB').ITSSUB\n         BALR  R15,R0              LOAD R15\n         USING *,R15               ADDRESSABILITY\n         CNOP  0,4\n         BAL   R13,*+4+(18*4)      NO CALLING PROG, FAKE IT\nSAV$$RGP DC    18F'0'\n         DROP  R15\n         BALR  R15,R0              IT'S A PHASE, LOAD R15\n.ITSSUB  ANOP\n         USING *,R15               ADDRESSABILITY\n         SAVE  (14,12)             STORE REG 14 THRU 12 IN CALLING PROG\n         ST    R13,SAV$$REG+4      STORE R13 IN MY SAVE AREA\n         MVC   8(4,R13),SAVADCON   PASS BACK ADDRESS OF MY SAVE AREA\n         L     R13,SAVADCON        PUT ADDR OF MY SAVE AREA IN R13\n         B     CONTIN$$\nSAV$$REG DC    18F'0'\nMAX$$RET DC    F'0'                USED TO STORE MAX RETURN CODE\nSAVADCON DC    A(SAV$$REG)\n         DS    0H\nCONTIN$$ EQU   *\n         DROP  R15\n         MEND\nZZGDS    START 0\n         EJECT\n         PRINT NOGEN\n         REGIS\nZZGDSK   ACB   MACRF=(SEQ,DIR,OUT),EXLST=GDSEXLST\nGDSEXLST EXLST AM=VSAM,EODAD=GDSEND\nGDSRPL   RPL   ACB=ZZGDSK,AREA=GDSDATA,AREALEN=060,OPTCD=(DIR),        C\n               ARG=WGDSID,RECLEN=60\nGDSRPLS  RPL   ACB=ZZGDSK,AREA=GDSDATA,AREALEN=060,OPTCD=(SEQ,NUP),    C\n               ARG=WGDSID,RECLEN=60\nCONSOLE  DTFCN DEVADDR=SYSLOG,IOAREA1=CONSIO,TYPEFLE=CMBND,WORKA=YES,  C\n               BLKSIZE=70,INPSIZE=10\nCONSIO   DS    CL70\nCARDS    DTFCD DEVADDR=SYS007,IOAREA1=CARDIN,BLKSIZE=80,TYPEFLE=INPUT, C\n               DEVICE=2540,EOFADDR=LASTCD,RECFORM=FIXUNB\n         EJECT\nSTART    BEGIN\n         BALR  R3,R0\n         USING *,R3\n         OPEN  CARDS,CONSOLE,ZZGDSK\n         COMRG\n         MVC   CURDATE(2),0(R1)\n         MVC   CURDATE+2(2),3(R1)\n         MVC   CURDATE+4(2),6(R1)\n         MVC   CURJOB,24(R1)\n         GETIME STANDARD\n         ST    R1,FULL\n         UNPK  WORK,FULL\n         MVC   CURTIME,WORK\n* GET OPTION REQUEST\nGETOPT   EQU   *\n         GET   CARDS\n* DISPLAY REQUEST ON CONSOLE\n         MVC   MESSAGE,MESSAGE-1\n         MVC   MESSAGE(9),=C'REQUEST=>'\n         MVC   MESSAGE+10(60),CARDIN\n         BAL   R9,PUTCON\n* IS USER REQUESTING FILE TO BE INITIALIZED?\n         CLC   =C'INITIALIZE',CARDIN\n         BE    INITFILE            GO INITIALIZE THE FILE\n* FORMAT INPUT DATA\n         MVC   WAREA,WAREA-1\n         ZAP   WVERSION,ZERO\n         L     R8,=A(CARDIN)\n* GDSID\n         TRT   0(80,R8),FIELDDLM\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    INPERROR             .. YES\n         ST    R1,DLMLOC           STORE FIELD-DELIM LOCATION\n         SR    R1,R8               LENGTH OF FIELD\n         CH    R1,=H'8'            LENGTH VALID?\n         BH    INPERROR             .. NO\n         BCTR  R1,R0               DECREMENT LENGTH\n         STC   R1,*+5\n         MVC   WGDSID(0),0(R8)\n* COMMAND\n         L     R8,DLMLOC\n         TRT   0(80,R8),FIELDSTR\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    INPERROR             .. YES\n         LR    R8,R1               R8 POINTS TO NEXT FIELD\n         TRT   0(80,R8),FIELDDLM\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    INPERROR             .. YES\n         ST    R1,DLMLOC           STORE FIELD-DELIM LOCATION\n         SR    R1,R8               LENGTH OF FIELD\n         CH    R1,=H'8'            LENGTH VALID?\n         BH    INPERROR             .. NO\n         BCTR  R1,R0               DECREMENT LENGTH\n         STC   R1,*+5              OVERLAY LENGTH IN NEXT INSTRUCTION\n         MVC   WCOMMAND(0),0(R8)\n* SIGN (- OR V) AND VERSION #\n         L     R8,DLMLOC\n         TRT   0(80,R8),FIELDSTR\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    COMPLETE             .. YES\n         LR    R8,R1               R8 POINTS TO NEXT FIELD\n         TRT   0(80,R8),FIELDDLM\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    COMPLETE             .. YES\n         ST    R1,DLMLOC           STORE FIELD-DELIM LOCATION\n         SR    R1,R8               LENGTH OF FIELD\n         CLI   0(R8),MINUS\n         BE    VALSIGN\n         CLI   0(R8),VER\n         BE    VALSIGN\n         B     VERSION             IT'S THE VERSION #\nVALSIGN  MVC   WSIGN,0(R8)\n         LA    R8,1(R8)            STEP BY SIGN\n         BCTR  R1,R0               DECREMENT LENGTH\n         B     VERSION\n* VERSION\nVERSION  CH    R1,=H'2'            LENGTH VALID?\n         BH    INPERROR             .. NO\n         BCTR  R1,R0               DECREMENT LENGTH\n         STC   R1,*+11             LENGTH OF SENDING FIELD\n         MVZ   *+7(1),=X'10'       LENGTH OF RECEIVING FIELD\n         PACK  WVERSION(0),0(0,R8)\n         MVN   WVERSION+1(1),SIGN\n* WAS VERSION NUMERIC\n         CLI   0(R8),C'0'\n         BL    INPERROR\n         CLI   0(R8),C'9'\n         BH    INPERROR\n         CLI   1(R8),BLANK         1 POSITION VERSION?\n         BE    DESCRIPT             .. YES\n         CLI   1(R8),C'0'\n         BL    INPERROR\n         CLI   1(R8),C'9'\n         BH    INPERROR\n* DESCRIPTION\nDESCRIPT L     R8,DLMLOC\n         TRT   0(80,R8),FIELDSTR\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    COMPLETE             .. YES\n         LR    R8,R1               R8 POINTS TO NEXT FIELD\n         TRT   0(80,R8),FIELDDLM\n         CLI   0(R1),EOR           END OF RECORD?\n         BE    COMPLETE             .. YES\n         ST    R1,DLMLOC           STORE FIELD-DELIM LOCATION\n         SR    R1,R8               LENGTH OF FIELD\n         CH    R1,=H'30'           LENGTH OK?\n         BNH   *+8                  .. YES\n         L     R1,=A(30)            .. NO, MAKE IT 30\n         BCTR  R1,R0               DECREMENT LENGTH\n         STC   R1,*+5\n         MVC   WDESCR(0),0(R8)\n         B     COMPLETE\n         EJECT\n* OPTION REQUEST HAS BEEN REFORMATTED\nCOMPLETE EQU   *\n         CLC   CREATE,WCOMMAND\n         BE    OPCREATE\n         CLC   DELETE,WCOMMAND\n         BE    OPDELETE\n         CLC   READ,WCOMMAND\n         BE    OPREAD\n         CLC   WRITE,WCOMMAND\n         BE    OPWRITE\n         CLC   STATUS,WCOMMAND\n         BE    OPSTATUS\n         B     INPERROR            INVALID COMMAND\n* CREATE NEW GDS\nOPCREATE EQU   *\n         CP    WVERSION,MAXVERSN\n         BNH   OPCVOK\n         MVC   MESSAGE,MESSAGE-1   VERSION > MAX\n         MVC   MESSAGE(L'MESSOVM),MESSOVM\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPCVOK   L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPL,OPTCD=NUP\n         BAL   R9,GETGDS\n         CLC   WGDSID,GGDSID\n         BNE   OPCOKAY\n         MVC   MESSAGE,MESSAGE-1   ATTEMPTING TO DUP GDS\n         MVC   MESSAGE(L'MESSDUP),MESSDUP\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPCOKAY  MVC   GDSDATA,GDSDATA-1\n         MVC   GGDSID,WGDSID\n         ZAP   GCURVER,ZERO\n         ZAP   GMAXVER,WVERSION\n         MVC   GDATE,CURDATE\n         MVC   GTIME,CURTIME\n         MVC   GJOB,CURJOB\n         MVC   GDESCR,WDESCR\n         BAL   R9,PUTGDS\n         ZAP   RETNCODE,ZERO\n         BAL   R9,DISPLAY\n         B     GETOPT\n* DELETE GDS\nOPDELETE EQU   *\n         L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPL,OPTCD=UPD\n         BAL   R9,GETGDS\n         CLC   WGDSID,GGDSID\n         BE    OPDOKAY\n         MVC   MESSAGE,MESSAGE-1   NO RECORD FOUND\n         MVC   MESSAGE(L'MESSNRF),MESSNRF\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'15'\n         B     GETOPT\nOPDOKAY  EQU   *\n         CP    WVERSION,=P'99'\n         BE    OPDALL              DELETE ENTIRE GDS\n         CP    WVERSION,GMAXVER\n         BL    OPDVOK\n         MVC   MESSAGE,MESSAGE-1   VERSION TOO HIGH\n         MVC   MESSAGE(L'MESSVER),MESSVER\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\n* DELETE VERSIONS OF GDS\nOPDVOK   ZAP   REQVER,WVERSION\n         ZAP   WORKVER,GCURVER\n         CP    GCURVER,ZERO\n         BNE   OPDLOOP             GDS NEVER USED\n         MVC   MESSAGE,MESSAGE-1   1ST GDS NEVER WRITTEN\n         MVC   MESSAGE(L'MESSNFL),MESSNFL\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPDLOOP  CP    REQVER,ZERO\n         BE    OPDVRSET            VERSION SET\n         SP    REQVER,ONE\n         SP    WORKVER,ONE\n         CP    WORKVER,ZERO\n         BNE   OPDLOOP\n         ZAP   WORKVER,GMAXVER     RESET TO MAX\n         B     OPDLOOP\nOPDVRSET MVC   GDATE,CURDATE       ADJUST GDS RECORD\n         MVC   GTIME,CURTIME\n         MVC   GJOB,CURJOB\n         ZAP   GCURVER,WORKVER\n         BAL   R9,PUTGDS\n         ZAP   RETNCODE,ZERO\n         BAL   R9,DISPLAY\n         B     GETOPT\n* DELETE ENTIRE GDS\nOPDALL   L     R13,=A(SAV$$REG)\n         ERASE RPL=GDSRPL\n         MVC   GDSDATA,GDSDATA-1\n         MVC   MESSAGE,MESSAGE-1   RECORD DELETED\n         MVC   MESSAGE(L'MESSDEL),MESSDEL\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,ZERO\n         B     GETOPT\n* READ GDS\nOPREAD   EQU   *\n         L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPL,OPTCD=NUP\n         BAL   R9,GETGDS\n         CLC   WGDSID,GGDSID\n         BE    OPROKAY\n         MVC   MESSAGE,MESSAGE-1   NO RECORD FOUND\n         MVC   MESSAGE(L'MESSNRF),MESSNRF\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'15'\n         B     GETOPT\nOPROKAY  CP    GCURVER,ZERO\n         BNE   OPRNOT1\n         MVC   MESSAGE,MESSAGE-1   1ST GDS NEVER WRITTEN\n         MVC   MESSAGE(L'MESSNFL),MESSNFL\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPRNOT1  CP    WVERSION,GMAXVER\n         BL    OPRVOK\n         MVC   MESSAGE,MESSAGE-1   VERSION TOO HIGH\n         MVC   MESSAGE(L'MESSVER),MESSVER\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPRVOK   CLI   WSIGN,VER\n         BNE   OPRNOSP             NOT SPECIFIC\n         ZAP   RETNCODE,WVERSION   WANTS SPECIFIC VERSION\n         BAL   R9,DISPLAY\n         B     GETOPT\nOPRNOSP  CP    WVERSION,ZERO\n         BE    OPRMINUS            WANTS CURRENT VERSION\n         CLI   WSIGN,MINUS\n         BE    OPRMINUS\n         MVC   MESSAGE,MESSAGE-1   NO SIGN BEFORE VERSION\n         MVC   MESSAGE(L'MESSNSGN),MESSNSGN\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\nOPRMINUS ZAP   REQVER,WVERSION\n         ZAP   WORKVER,GCURVER\nOPRLOOP  CP    REQVER,ZERO\n         BE    OPRVRSET            VERSION SET\n         SP    REQVER,ONE\n         SP    WORKVER,ONE\n         CP    WORKVER,ZERO\n         BNE   OPRLOOP\n         ZAP   WORKVER,GMAXVER     RESET TO MAX\n         B     OPRLOOP\nOPRVRSET ZAP   RETNCODE,WORKVER\n         BAL   R9,DISPLAY\n         B     GETOPT\n* WRITE GDS\nOPWRITE  EQU   *\n         L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPL,OPTCD=UPD\n         BAL   R9,GETGDS\n         CLC   WGDSID,GGDSID\n         BE    OPWOKAY\n         MVC   MESSAGE,MESSAGE-1   NO RECORD FOUND\n         MVC   MESSAGE(L'MESSNRF),MESSNRF\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'15'\n         B     GETOPT\nOPWOKAY  EQU   *\n         CP    GCURVER,GMAXVER     AT MAX VERSION?\n         BL    *+10\n         ZAP   GCURVER,ZERO        RESET FOR VER 1\n         AP    GCURVER,ONE\n         MVC   GDATE,CURDATE\n         MVC   GTIME,CURTIME\n         MVC   GJOB,CURJOB\n         BAL   R9,PUTGDS\n         ZAP   RETNCODE,GCURVER    SET RETURN CODE\n         BAL   R9,DISPLAY\n         B     GETOPT\n* STATUS OF GDS\nOPSTATUS EQU   *\n         L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPL,OPTCD=NUP\n         BAL   R9,GETGDS\n         CLC   WGDSID,GGDSID\n         BE    OPSOKAY\n         MVC   MESSAGE,MESSAGE-1   NO RECORD FOUND\n         MVC   MESSAGE(L'MESSNRF),MESSNRF\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'15'\n         B     GETOPT\nOPSOKAY  ZAP   RETNCODE,ZERO\n         BAL   R9,DISPLAY\n         B     GETOPT\n         EJECT\n* PROCESS GDS MASTER\nGETGDS   EQU   *\n         L     R13,=A(SAV$$REG)\n         GET   RPL=GDSRPL\n         BR    R9\nPUTGDS   EQU   *\n         L     R13,=A(SAV$$REG)\n         PUT   RPL=GDSRPL\n         LTR   R15,R15\n         BZR   R9\n         ZAP   RETNCODE,=P'12'     I/O ERROR\n         BR    R9\n* DISPLAY GDS RECORD\nDISPLAY  ST    R9,HOLDR9\n         MVC   MESSAGE,MESSAGE-1\n         MVC   MESSAGE(L'MESSRTN),MESSRTN\n         UNPK  MESSAGE+10(2),GCURVER\n         OI    MESSAGE+11,FSIGN\n         UNPK  MESSAGE+16(2),GMAXVER\n         OI    MESSAGE+17,FSIGN\n         MVC   MESSAGE+19(2),GDATE\n         MVC   MESSAGE+22(2),GDATE+2\n         MVC   MESSAGE+25(2),GDATE+4\n         MVC   MESSAGE+28(2),GTIME\n         MVC   MESSAGE+31(2),GTIME+2\n         UNPK  MESSAGE+37(2),RETNCODE\n         OI    MESSAGE+38,FSIGN\n         MVC   MESSAGE+40(30),GDESCR\n         BAL   R9,PUTCON\n         L     R9,HOLDR9\n         BR    R9\n* PUT CONSOLE MESSAGES\n* RESPONSE EXPECTED\nPUTCONR  MVC   RESPONSE,BLANKS\n         PUTR  CONSOLE,MESSAGE,RESPONSE\n         OC    RESPONSE,BLANKS    FORCE UPPER CASE\n         BR    R9\n* NO RESPONSE EXPECTED\nPUTCON   PUT   CONSOLE,MESSAGE\n         BR    R9\n* INPUT REQUEST IS IN ERROR\nINPERROR EQU   *\n         MVC   MESSAGE,MESSAGE-1\n         MVC   MESSAGE(L'MESSINP),MESSINP\n         BAL   R9,PUTCON\n         ZAP   RETNCODE,=P'13'\n         B     GETOPT\n* END OF JOB PROCESSING\nLASTCD   EQU   *\nENDJOB   EQU   *\n         CLOSE CARDS,CONSOLE,ZZGDSK\n         ZAP   DOUBLE,RETNCODE\n         CVB   R15,DOUBLE\n         EOJ   RC=(15)\n         EJECT\n* INITIALIZE THE FILE\nINITFILE EQU   *\n         MVC   GDSDATA,GDSDATA-1  BLANK THE RECORD AREA\n* WRITE A BLANK RECORD\n         ZAP   RETNCODE,=P'20'\n         L     R13,=A(SAV$$REG)\n         PUT   RPL=GDSRPLS\n         LTR   R15,R15\n         BNZ   INITPROB\n* CLOSE & OPEN FILE TO BREAK AWAY FROM INITIAL LOAD\n         CLOSE ZZGDSK\n         OPEN  ZZGDSK\n* MODIFY RPL - FOR UPDATE\n         ZAP   RETNCODE,=P'21'\n         L     R13,=A(SAV$$REG)\n         MODCB RPL=GDSRPLS,OPTCD=(UPD)\n         LTR   R15,R15\n         BNZ   INITPROB\n* RETRIEVE RECORD FOR UPDATE\n         ZAP   RETNCODE,=P'22'\n         L     R13,=A(SAV$$REG)\n         GET   RPL=GDSRPLS\n         LTR   R15,R15\n         BNZ   INITPROB\n* ERASE RECORD\n         ZAP   RETNCODE,=P'23'\n         L     R13,=A(SAV$$REG)\n         ERASE RPL=GDSRPLS\n         LTR   R15,R15\n         BNZ   INITPROB\n* RELEASE RPL\n         ZAP   RETNCODE,=P'24'\n         L     R13,=A(SAV$$REG)\n         ENDREQ RPL=GDSRPLS\n         LTR   R15,R15\n         BNZ   INITPROB\n* FILE INITIALIZED SUCESSFULLY\n         ZAP   RETNCODE,ZERO\n         MVC   MESSAGE,MESSAGE-1\n         MVC   MESSAGE(L'MESSINOK),MESSINOK\n         BAL   R9,PUTCON\n         B     GETOPT\n* PROBLEM OCCURRED WHILE INITIALIZING THE FILE\nGDSEND   EQU   *\nINITPROB EQU   *\n         MVC   MESSAGE,MESSAGE-1\n         MVC   MESSAGE(L'MESSINIT),MESSINIT\n         UNPK  MESSAGE+29(2),RETNCODE DISPLAY RETURN CODE\n         MVZ   MESSAGE+30(1),SIGN\n         STC   R15,FULL\n         UNPK  DOUBLE(3),FULL(2)\n         MVC   MESSAGE+36(2),DOUBLE   R15 VALUE\n         L     R13,=A(SAV$$REG)\n         SHOWCB RPL=GDSRPLS,AREA=FULL,LENGTH=4,FIELDS=FDBK\n         LTR   R15,R15\n         BNZ   *+16\n         UNPK  DOUBLE(3),FULL+3(2)\n         MVC   MESSAGE+44(2),DOUBLE   FEEDBACK VALUE\n         BAL   R9,PUTCON\n         B     ENDJOB\n         EJECT\n* CONSTANTS AND WORK AREAS\n         LTORG\nHIVALUE  EQU   X'FF'\nEOR      EQU   X'FF'\nMINUS    EQU   C'-'\nVER      EQU   C'V'\nBLANK    EQU   C' '\nFSIGN    EQU   X'F0'\nCREATE   DC    C'CREATE'\nDELETE   DC    C'DELETE'\nREAD     DC    C'READ'\nWRITE    DC    C'WRITE'\nSTATUS   DC    C'STATUS'\nBLANKS   DC    CL10' '\nZERO     DC    P'0'\nONE      DC    P'1'\nSIGN     DC    X'FC'\nDOUBLE   DS    D\nFULL     DS    F\nDLMLOC   DS    F\nHOLDR9   DS    F\nRPLUSED  DS    F\nMAXVERSN DC    P'10'\nRETNCODE DC    PL2'0'\nCURDATE  DS    CL6 MMDDYY\nCURTIME  DS    CL4 HHMM\nCURJOB   DS    CL8 CURRENT JOB EXECUTING\nWORK     DS    CL6\nREQVER   DS    PL2\nWORKVER  DS    PL2\nCARDIN   DS    CL80\n         DC    X'FF' <== MUST FOLLOW CARDIN\n* REFORMATTED REQUEST OPTION\n         DC    C' '\nWAREA    DS    0CL49\nWGDSID   DS    CL8\nWCOMMAND DS    CL8   CREATE, DELETE, USED, SELECT, STATUS\nWSIGN    DS    CL1   +/- (+ ASSUMED), OR 'V' FOR EXACT VERSION\nWVERSION DS    PL2\nWDESCR   DS    CL30\n* GDS MASTER RECORD\n         DC    C' '\nGDSDATA  DS    0CL60\nGGDSID   DS    CL8\nGCURVER  DS    PL2   CURRENT VERSION\nGMAXVER  DS    PL2   MAX # OF VERSIONS (MAX 10)\nGDATE    DS    CL6   DATE LAST VERSION CREATED\nGTIME    DS    CL4   TIME LAST VERSION CREATED (HHMM)\nGJOB     DS    CL8   JOB THAT LAST UPDATED GDS\nGDESCR   DS    CL30\n         ORG   GDSDATA+60\n         DC    C' '\nMESSAGE  DS    CL70\n*                ....5...10...15...20...25...30...35...40...45...50\nMESSINIT DC    C'ERROR  => FILE INIT PROB. RC=  ,R15=  ,FDBK=  '\nMESSINOK DC    C'FILE INITIALIZED SUCESSFULLY'\nMESSRTN  DC    C'RETURN => XX OF XX MM/DD/YY HH:MM RC=XX'\nMESSDUP  DC    C'ERROR  => ATTEMPTING TO DUPLICATE GDS.'\nMESSNRF  DC    C'ERROR  => NO GDS RECORD FOUND.'\nMESSOVM  DC    C'ERROR  => VERSIONS > 10.'\nMESSINP  DC    C'ERROR  => INPUT REJECTED.'\nMESSVER  DC    C'ERROR  => VERSION TOO HIGH.'\nMESSNFL  DC    C'ERROR  => 1ST GDS NEVER WRITTEN.'\nMESSNSGN DC    C'ERROR  => NO SIGN BEFORE VERSION.'\nMESSDEL  DC    C'ABOVE GDS DELETED.'\nRESPONSE DS    CL10\n         EJECT\n* * * * * USED TO LOCATE FIELD DELIMETERS\nFIELDDLM EQU   *     0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'00000000000000000000000000000000' 0\n         DC    XL16'00000000000000000000000000000000' 1\n         DC    XL16'00000000000000000000000000000000' 2\n         DC    XL16'00000000000000000000000000000000' 3\n         DC    XL16'40000000000000000000000000000000' 4\n         DC    XL16'00000000000000000000000000000000' 5\n         DC    XL16'00000000000000000000000000000000' 6\n         DC    XL16'00000000000000000000000000000000' 7\n         DC    XL16'00000000000000000000000000000000' 8\n         DC    XL16'00000000000000000000000000000000' 9\n         DC    XL16'00000000000000000000000000000000' A\n         DC    XL16'00000000000000000000000000000000' B\n         DC    XL16'00000000000000000000000000000000' C\n         DC    XL16'00000000000000000000000000000000' D\n         DC    XL16'00000000000000000000000000000000' E\n         DC    XL16'000000000000000000000000000000FF' F\n* * * * * USED TO LOCATE FIELD STARTS\nFIELDSTR EQU   *     0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'11111111111111111111111111111111' 0\n         DC    XL16'11111111111111111111111111111111' 1\n         DC    XL16'11111111111111111111111111111111' 2\n         DC    XL16'11111111111111111111111111111111' 3\n         DC    XL16'00111111111111111111111111111111' 4\n         DC    XL16'11111111111111111111111111111111' 5\n         DC    XL16'11111111111111111111111111111111' 6\n         DC    XL16'11111111111111111111111111111111' 7\n         DC    XL16'11111111111111111111111111111111' 8\n         DC    XL16'11111111111111111111111111111111' 9\n         DC    XL16'11111111111111111111111111111111' A\n         DC    XL16'11111111111111111111111111111111' B\n         DC    XL16'11111111111111111111111111111111' C\n         DC    XL16'11111111111111111111111111111111' D\n         DC    XL16'11111111111111111111111111111111' E\n         DC    XL16'111111111111111111111111111111FF' F\n         END   START\n\n\nZZGD01\n\nZZGD     TITLE 'CICS ZZGD01 - ACCESS GENERATION DATASET CONTROL FILE'\n* THE PURPOSE OF THIS PROGRAM IS TO READ AND UPDATE THE GDS CONTROL\n* FILE.  YOU CAN'T ADD OR DELETE, ONLY READ OR UPDATE.\n*     CALLING TRANSACTION: ZZGD\n*     INPUT:\n*        USER: GDS-NAME OR USER CAN START AT BEGINNING OF FILE\n*        FILE: ZZGDSK\n*     MAPSET: ZZGDS01\n*        MAPS: MAP01\n*     NOTE:    COMPILED WITH OPTION 'NOPROLOG'\n         PRINT NOGEN\n         EJECT\n* MACRO DEFINITIONS\n         MACRO\n&NAME    BLANK &TO,&COUNT\n* MACRO      ==> BLANK\n* PARAMETERS ==> &TO     = AREA TO BE BLANKED\n*                &COUNT  = SIZE OF AREA TO BE BLANKED\n* PURPOSE    ==> USED BY ASSEMBLER PROGRAMS TO BLANK AREAS\n         LCLA  &B\n&B       SETA  &COUNT-1\n&NAME    MVI   &TO,C' '      BLANK FIRST POSITION\n         MOVL  &TO+1,&TO,&B\n* MACRO END BLANK\n         MEND\n         MACRO\n&NAME    MOVL  &TO,&FROM,&COUNT\n* MACRO      ==> MOVL\n* PARAMETERS ==> &TO     = AREA TO BE MOVED TO\n*                &FROM   = AREA TO BE MOVED FROM\n*                &COUNT  = LENGTH OF MOVE\n* PURPOSE    ==> USED BY ASSEMBLER PROGRAMS FOR MOVES > 256 BYTES\n         GBLA  &A\n         LCLA  &B\n&B       SETA  &COUNT\n.PN      ANOP\n         AIF   (&B LE 256).DO\n&NAME    MVC   &TO+&A.(256),&FROM+&A   256 BYTE MOVE\n&A       SETA  &A+256\n&B       SETA  &B-256\n         MOVL  &TO,&FROM,&B\n         MEXIT\n.DO      ANOP\n&NAME    MVC   &TO+&A.(&B),&FROM+&A    LESS THAN 256 BYTE MOVE\n&A       SETA  0\n* MACRO END MOVL\n         MEND\n         MACRO\n         REGIS\n* MACRO        ==> REGIS\n* PARAMETERS   ==> NONE\n* PURPOSE      ==> ASSIGN TAGS TO REGISTERS\n\nEditor's note: register equates go here.\n\n         MEND\n         MACRO\n&NAME    MOVLR &FLDS,&FLDE,&REGFROM,&REGTO\n* MACRO      ==> MOVLR\n* PARAMETERS ==> &FLDS    = START OF RECEIVING FIELD\n*                &FLDE    = END OF RECEIVING FIELD\n*                &REGFROM = REGISTER CONTAINING ADDRESS OF 'FROM' FIELD\n*                &REGTO   = WORK REGISTER\n* PURPOSE    ==> USED BY ASSEMBLER PROGRAMS TO MOVE AN AREA OF UNKNOWN\n*                LENGTH TO A RECEIVING AREA. FROM AREA ADDRESS IS IN\n*                A REGISTER\n         LA    R1,&FLDE       END OF FIELD\n         LA    &REGTO,&FLDS   START OF FIELD\n         SR    R1,&REGTO\n         LA    R1,1(R1)       R1 CONTAINS LENGTH OF FIELD\n         B     *+22           BYPASS NEXT 4 INSTRUCTIONS\n         SH    R1,=H'256'     DECREMENT R1 BY MAX MOVE LENGTH\n         MVC   0(256,&REGTO),0(&REGFROM) MOVE MAX LENGTH\n         LA    &REGTO,256(&REGTO)     INCREMENT POINTER\n         LA    &REGFROM,256(&REGFROM) INCREMENT POINTER\n         CH    R1,=H'256'     CHECK REMAINING LENGTH\n         BNL   *-22           DO MAX MOVE\n         CH    R1,=H'1'       CHECK REMAINING LENGTH\n         BL    *+16           NO MORE LEFT\n         BCTR  R1,0           DECREMENT LENGTH BY 1\n         STC   R1,*+5         DO SHORT MOVE\n         MVC   0(0,&REGTO),0(&REGFROM) LENGTH < 256\n* MACRO END MOVLR\n         MEND\n         MACRO\n&NAME    NULLS &FLDS,&FLDE,&REG\n* MACRO      ==> NULLS\n* PARAMETERS ==> &FLDS   = START OF FIELD TO RECEIVE NULLS\n*                &FLDE   = END OF FIELD TO RECEIVE NULLS\n*                &REG    = WORK REGISTER\n* PURPOSE    ==> USED BY ASSEMBLER PROGRAMS TO MOVE NULLS (X'00')\n*                TO AN AREA (USEFULL FOR CICS SCREENS)\n         LA    R1,&FLDE       END OF FIELD\n         LA    &REG,&FLDS     START OF FIELD\n         SR    R1,&REG\n         LA    R1,1(R1)       R1 CONTAINS LENGTH OF FIELD\n         B     *+18           BYPASS NEXT 3 INSTRUCTIONS\n         SH    R1,=H'256'     DECREMENT R1 BY MAX MOVE LENGTH\n         XC    0(256,&REG),0(&REG) SET TO NULLS (LENGTH = 256)\n         LA    &REG,256(&REG) INCREMENT POINTER\n         CH    R1,=H'256'     CHECK REMAINING LENGTH\n         BNL   *-18           DO MAX MOVE\n         CH    R1,=H'1'       CHECK REMAINING LENGTH\n         BL    *+16           NO MORE LEFT\n         BCTR  R1,0           DECREMENT LENGTH BY 1\n         STC   R1,*+5         DO SHORT MOVE\n         XC    0(0,&REG),0(&REG) SET TO NULLS (LENGTH < 256)\n* MACRO END NULLS\n         MEND\n         EJECT\n* DEFINE DYNAMIC STORAGE\nDFHEISTG DSECT\n         DFHEISTG             NEEDED BECAUSE OF OPTION 'NOPROLOG'\n* C O M M A R E A\nCOMAREAS DS    0H       START OF COMMAREA\n* GDS MASTER RECORD\nGDSDATA  DS    0CL60\nGGDSID   DS    CL8\nGCURVER  DS    PL2   CURRENT VERSION\nGMAXVER  DS    PL2   MAX # OF VERSIONS (MAX 10)\nGDATE    DS    CL6   DATE LAST VERSION CREATED\nGTIME    DS    CL4   TIME LAST VERSION CREATED (HHMM)\nGJOB     DS    CL8   JOB THAT LAST UPDATED GDS\nGDESCR   DS    CL30\n         ORG   GDSDATA+60\nGDSID    DS    CL8      REQUESTED GDS-ID\nPREVKEY  DS    CL8      PREVIOUS KEY (FOR FILE BROWSING)\nCOMAREAE DS    0H       END OF COMMAREA\nOPERID   DS    CL3\nTIME     DS    PL8      ABSOLUTE TIME\nCURDATE  DS    CL10\nCURTIME  DS    CL8\nUPDATE   DS    CL1      IF 'ON' A FIELD HAS BEEN UPDATED\n* CHANGE INFO\nWCURVER  DS    CL2   CURRENT VERSION\nWMAXVER  DS    CL2   MAX # OF VERSIONS (MAX 10)\nWDESCR   DS    CL30\nWDESCHG  DS    CL1   IF 'ON' DESCRIPTION WAS CHANGED\nWCURCHG  DS    CL1   IF 'ON' CURRENT VER WAS CHANGED\nWMAXCHG  DS    CL1   IF 'ON' MAX VER WAS CHANGED\nHOLD10   DS    F\nHOLD10A  DS    F\nHOLD10B  DS    F\nHOLD10C  DS    F\nYEAR     DS    F\nCOMLEN   DS    H        COMMAREA LENGTH\n         EJECT\n         COPY  ZZGDS01             MAP COPYBOOK\n         DFHEIEND\n         EJECT\n***           MAINLINE        ***\n         REGIS\nZZGD01   DFHEIENT CODEREG=(3,5),DATAREG=(11,12),EIBREG=(6)\n         CLC   EIBCALEN,=H'0'     CHECK FOR 1ST TIME ENTRY\n         BH    COMRETND            ... RETURN TRANSID\n         SPACE 3\n* 1ST TIME IN PROGRAM\n         BAL   R10,CLEARMAP\n         BAL   R10,SETTIME\n         BLANK GDSID,8\n         BLANK GGDSID,8\n         BLANK PREVKEY,8\n         MVC   SM1DATEO,CURDATE\n         MVC   SM1TIMEO,CURTIME\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') ERASE FREEKB\n         B     RETURN              RETURN WITH COMMAREA\n         SPACE 3\n* NOT THE FIRST TIME IN PROGRAM\nCOMRETND EQU   *\n         L     R10,DFHEICAP    ADDRESSABILITY TO COMMAREA\n         ST    R13,DFHEIR13\n         MOVLR COMAREAS,COMAREAE,R10,R13\n         L     R13,DFHEIR13\n         SPACE 2\n* CHECK FOR INITIAL FILE INPUT DATA\n         MVC   GDSID,GGDSID    THIS IS THE KEY CURRENTLY DISPLAYED\n         EXEC  CICS HANDLE CONDITION MAPFAIL(ERMAPFL) ERROR(ERMISC)    X\n               LENGERR(ERLENTH)\n         EXEC  CICS HANDLE AID PF2(RECFIRST) PF4(EXIT)                 X\n               PF7(RECPREV) PF8(RECNEXT) PF9(RECUPDAT)\n         EXEC  CICS RECEIVE MAP('MAP01') MAPSET('ZZGDS01')\n         SPACE 2\n* ASKING FOR SPECIFIC GDS?\n         OC    SGDSIDI,SGDSIDI    WAS GDSID ENTERED?\n         BZ    *+10                 ... NO  - RETAIN PREVIOUS REQUEST\n         MVC   GDSID,SGDSIDI        ... YES - POST NEW REQUEST\n         B     GETNEXT\n         SPACE 2\n* WANT FIRST GDS RECORD\nRECFIRST EQU   *\n         MVC   GDSID,LOVALUES\n         B     GETNEXT\n         SPACE 2\n* WANT NEXT GDS RECORD\nRECNEXT  EQU   *\n         MVC   GDSID,GGDSID       ID OF CURRENT RECORD\n         EXEC  CICS HANDLE CONDITION NOTFND(RNENDBR) NOTOPEN(ERNOTOPN) X\n               ENDFILE(ENDNEXT)\n         EXEC  CICS STARTBR DATASET('ZZGDSK') RIDFLD(GDSID)\n         EXEC  CICS READNEXT DATASET('ZZGDSK') INTO(GDSDATA)           X\n               RIDFLD(GDSID) LENGTH(RECLENTH)\n         CLC   GGDSID,PREVKEY  SAME KEY AS PREVIOUS ONE?\n         BNE   RNENDBR         ... NO\n         EXEC  CICS READNEXT DATASET('ZZGDSK') INTO(GDSDATA)           X\n               RIDFLD(GDSID) LENGTH(RECLENTH)\nRNENDBR  EXEC  CICS ENDBR DATASET('ZZGDSK')\n         MVC   PREVKEY,GGDSID\n         BAL   R10,MAPBUILD\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') ERASE FREEKB\n         MVC   SMESSAGO,BLANKS\n         B     RETURN\nENDNEXT  EXEC  CICS ENDBR DATASET('ZZGDSK')\n         MVI   PREVKEY,HIVALUE\n         BAL   R10,CLEARMAP\n         MVC   MESSAGS(L'MESS07),MESS07\n         B     DISPERR\n         SPACE 2\n* WANT PREVIOUS GDS RECORD\nRECPREV  EQU   *\n         MVC   GDSID,GGDSID       GET CURRENT KEY\n         EXEC  CICS HANDLE CONDITION NOTFND(RPENDBR) NOTOPEN(ERNOTOPN) X\n               ENDFILE(ENDPREV)\n         EXEC  CICS STARTBR DATASET('ZZGDSK') RIDFLD(GDSID)\n         EXEC  CICS READPREV DATASET('ZZGDSK') INTO(GDSDATA)           X\n               RIDFLD(GDSID) LENGTH(RECLENTH)\n         CLC   GGDSID,PREVKEY  SAME KEY AS PREVIOUS ONE?\n         BNE   RPENDBR         ... NO\n         EXEC  CICS READPREV DATASET('ZZGDSK') INTO(GDSDATA)           X\n               RIDFLD(GDSID) LENGTH(RECLENTH)\nRPENDBR  EXEC  CICS ENDBR DATASET('ZZGDSK')\n         MVC   PREVKEY,GGDSID\n         BAL   R10,MAPBUILD\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') ERASE FREEKB\n         MVC   SMESSAGO,BLANKS\n         B     RETURN\nENDPREV  EXEC  CICS ENDBR DATASET('ZZGDSK')\n         MVI   PREVKEY,HIVALUE\n         BAL   R10,CLEARMAP\n         MVC   MESSAGS(L'MESS08),MESS08\n         B     DISPERR\n         SPACE 2\n* WANT TO UPDATE THE GDS\nRECUPDAT EQU   *\n         MVI   UPDATE,OFF         OFF UNTIL A VALID CHANGE\n         MVI   WDESCHG,OFF\n         MVI   WCURCHG,OFF\n         MVI   WMAXCHG,OFF\n         MVC   GDSID,GGDSID\n         MVC   WDESCR,GDESCR      INITIALLY ASSUME THAT NONE OF THE\n         UNPK  WMAXVER,GMAXVER     .. FIELDS WILL BE UPDATED AND\n         MVZ   WMAXVER+1(1),SIGN   .. USE DATA FROM MASTER RECORD\n         UNPK  WCURVER,GCURVER     .. FOR DISPLAY.\n         MVZ   WCURVER+1(1),SIGN\n         SPACE 1\n* SAVE DESCRIPTION CHANGE IF ANY\n         OC    SDESCRI,SDESCRI    WAS FIELD ENTERED?\n         BZ    *+14                 ... NO\n         MVC   WDESCR,SDESCRI       ... YES, MAKE CHANGE\n         MVI   WDESCHG,ON\n         CLI   SDESCRF,DFHBMEOF   WAS FIELD ERASED?\n         BNE   *+14                 ... NO\n         MVC   WDESCR,BLANKS        ... YES, THEN BLANK IT\n         MVI   WDESCHG,ON\n         SPACE 1\n* SAVE MAX VERSION CHANGE IF ANY\n         OC    SMAXVERI,SMAXVERI  WAS FIELD ENTERED?\n         BZ    *+14                 ... NO\n         MVC   WMAXVER,SMAXVERI\n         MVI   WMAXCHG,ON\n         SPACE 1\n* SAVE CURRENT VERSION CHANGE IF ANY\n         OC    SCURVERI,SCURVERI  WAS FIELD ENTERED?\n         BZ    *+14                 ... NO\n         MVC   WCURVER,SCURVERI\n         MVI   WCURCHG,ON\n         SPACE 1\n* GET RECORD\n         EXEC  CICS HANDLE CONDITION NOTFND(ERNOTFND) NOTOPEN(ERNOTOPN)\n         EXEC  CICS READ DATASET('ZZGDSK') INTO(GDSDATA) RIDFLD(GDSID) X\n               LENGTH(RECLENTH) EQUAL UPDATE\n         MVC   PREVKEY,GGDSID\n         BAL   R10,CLEARMAP\n         BAL   R10,SETTIME\n* APPLY CHANGES\n         SPACE 1\n* DESCRIPTION\n         CLI   WDESCHG,ON         WAS THERE A CHANGE?\n         BNE   RECUBDES            ... NO\n         MVC   GDESCR,WDESCR      APPLY CHANGE TO RECORD\n         MVI   UPDATE,ON\nRECUBDES EQU   *\n         SPACE 1\n* MAXIMUM VERSION\n         CLI   WMAXCHG,ON         WAS THERE A CHANGE?\n         BE    *+20                ... YES\n         UNPK  WMAXVER,GMAXVER     ... NO, POST ORIGINAL DATA\n         MVZ   WMAXVER+1(1),SIGN\n         B     RECUBMAX\n         MVZ   TWOZEROS,WMAXVER\n         CLC   TWOZEROS,C00\n         BE    *+14               IT'S NUMERIC\n         MVC   SERRMAXO,MESS20\n         B     RECUBMAX\n         CLC   WMAXVER,=C'10'\n         BNH   *+14\n         MVC   SERRMAXO,MESS22\n         B     RECUBMAX\n         PACK  GMAXVER,WMAXVER    APPLY CHANGE TO RECORD\n         MVN   GMAXVER+1(1),SIGN\n         MVI   UPDATE,ON\nRECUBMAX EQU   *\n         SPACE 1\n* CURRENT VERSION\n         CLI   WCURCHG,ON         WAS THERE A CHANGE?\n         BNE   RECUBCUR            ... NO\n         MVZ   TWOZEROS,WCURVER\n         CLC   TWOZEROS,C00\n         BE    *+14               IT'S NUMERIC\n         MVC   SERRCURO,MESS20\n         B     RECUBCUR\n         PACK  WORKA,WCURVER\n         MVN   WORKA+3(1),SIGN\n         CP    WORKA,GMAXVER       CURRENT VERSION CAN'T EXCEED MAX\n         BNH   *+14\n         MVC   SERRCURO,MESS21\n         B     RECUBCUR\n         ZAP   GCURVER,WORKA      APPLY CHANGE TO RECORD\n         MVI   UPDATE,ON\nRECUBCUR EQU   *\n         SPACE 1\n         CLI   UPDATE,ON\n         BNE   NOUPDATE           NOTHING VALIDLY UPDATED\n         MVC   GDATE(2),CURDATE\n         MVC   GDATE+2(2),CURDATE+3\n         MVC   GDATE+4(2),CURDATE+8\n         MVC   GTIME(2),CURTIME\n         MVC   GTIME+2(2),CURTIME+3\n         MVC   GJOB,BLANKS\n         EXEC  CICS ASSIGN OPID(OPERID)\n         MVC   GJOB(4),=C'CICS'\n         MVC   GJOB+4(3),OPERID\n         BAL   R10,MAPBUILD  GO BUILD MAP\n         MVC   SDESCRO,WDESCR     PUT CHANGES (IF ANY) TO SCREEN\n         MVC   SMAXVERO,WMAXVER\n         MVC   SCURVERO,WCURVER\n         BLANK MESSAGS,50\n         MVC   MESSAGS(L'MESS06),MESS06\n         MVC   SMESSAGO,MESSAGS\n         EXEC  CICS REWRITE DATASET('ZZGDSK') FROM(GDSDATA)\n         B     PUTUPSCR\n* NO UPDATING IS TAKING PLACE. RELEASE HOLD ON RECORD.\nNOUPDATE EQU   *\n         BAL   R10,MAPBUILD  GO BUILD MAP\n         MVC   SDESCRO,WDESCR     PUT CHANGES (IF ANY) TO SCREEN\n         MVC   SMAXVERO,WMAXVER\n         MVC   SCURVERO,WCURVER\n         EXEC  CICS UNLOCK DATASET('ZZGDSK')\n         B     PUTUPSCR\nPUTUPSCR BAL   R10,SETTIME\n         MVC   SM1DATEO,CURDATE\n         MVC   SM1TIMEO,CURTIME\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') ERASE FREEKB\n         B     RETURN\n         SPACE 2\n* READ THE GDS FILE\n         SPACE 2\n* NO UPDATE, ACCEPT GT OR EQ\nGETNEXT  EQU   *\n         EXEC  CICS HANDLE CONDITION NOTFND(ERNOTFND) NOTOPEN(ERNOTOPN)\n         EXEC  CICS READ DATASET('ZZGDSK') INTO(GDSDATA) RIDFLD(GDSID) X\n               LENGTH(RECLENTH) GTEQ\n         MVC   PREVKEY,GGDSID\n         BAL   R10,MAPBUILD  GO BUILD MAP\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') ERASE FREEKB\n         B     RETURN\n         SPACE 2\n* SET TIME AND POST TO MAP\nSETTIME  EQU   *\n         ST    R10,HOLD10A\n         EXEC  CICS ASKTIME ABSTIME(TIME)\n         EXEC  CICS FORMATTIME ABSTIME(TIME)                           X\n               MMDDYY(CURDATE) YEAR(YEAR) DATESEP('/')                 X\n               TIME(CURTIME) TIMESEP(':')\n         L     R10,YEAR\n         CVD   R10,DOUBLE\n         UNPK  CURDATE+6(4),DOUBLE\n         MVZ   CURDATE+9(1),SIGN\n         L     R10,HOLD10A\n         BR    R10\n         SPACE 2\n* CLEAR MESSAGE AREA\nCLEARMSG EQU   *\n         ST    R10,HOLD10B\n         MVI   SMESSAGO,BLANK      CLEAR ERROR FIELD\n         MVC   SMESSAGO+1(L'SMESSAGO-1),SMESSAGO\n         L     R10,HOLD10B\n         BR    R10\n         SPACE 2\n* CLEAR MAP\nCLEARMAP EQU   *\n         ST    R10,HOLD10C\n         NULLS MAP01O,ZZGDS01T,R10\n         L     R10,HOLD10C\n         BR    R10\n         SPACE 2\n* SET UP DISPLAY\nMAPBUILD EQU   *\n         ST    R10,HOLD10\n         BAL   R10,CLEARMSG\n         BAL   R10,SETTIME        RESET AND POST DATE/TIME\n         MVC   SM1DATEO,CURDATE\n         MVC   SM1TIMEO,CURTIME\n         MVC   SGDSIDO,GGDSID\n         MVC   SDESCRO,GDESCR\n         UNPK  SCURVERO,GCURVER\n         MVZ   SCURVERO+1,SCURVERO\n         UNPK  SMAXVERO,GMAXVER\n         MVZ   SMAXVERO+1,SMAXVERO\n         MVC   SDATLSTO+2(4),=C'/  /'\n         MVC   SDATLSTO(2),GDATE\n         MVC   SDATLSTO+3(2),GDATE+2\n         MVC   SDATLSTO+6(2),GDATE+4\n         MVI   STIMUPDO+2,C':'\n         MVC   STIMUPDO(2),GTIME\n         MVC   STIMUPDO+3(2),GTIME+2\n         MVC   SLSTJOBO,GJOB\n         L     R10,HOLD10\n         BR    R10\n         EJECT\n* EXIT PROGRAM\n         SPACE 2\n* EXPECT TO COME BACK\nRETURN   EQU   *\n         MVC   COMLEN,=AL2(COMAREAE-COMAREAS) LENGTH OF COMMAREA\n         EXEC  CICS RETURN TRANSID('ZZGD') COMMAREA(COMAREAS)          X\n               LENGTH(COMLEN)\n         SPACE 3\n* EXIT TRANSACTION (RETURN TO CICS)\nEXIT     EQU   *\n         EXEC  CICS SEND CONTROL ERASE FREEKB\n         EXEC  CICS RETURN\n         SPACE 3\n         EJECT\n* ERROR HANDLING ROUTINES\n         SPACE 2\n* NO RECORD FOUND\nERNOTFND EQU   *\n         MVC   MESSAGS(L'MESS01),MESS01\n         B     DISPERR\n         SPACE 2\n* FILE 'ZZGDSK' NOT OPEN\nERNOTOPN EQU   *\n         MVC   MESSAGS(L'MESS02),MESS02\n         B     DISPERR\n         SPACE 2\n* MAP FAIL\nERMAPFL  EQU   *\n         BAL   R10,CLEARMSG       CLEAR MESSAGE AREA\n         MVC   MESSAGS(L'MESS03),MESS03\n         MVC   SMESSAGO,MESSAGS\n         BAL   R10,SETTIME\n         MVC   SM1DATEO,CURDATE\n         MVC   SM1TIMEO,CURTIME\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') FREEKB FRSET\n         B     RETURN             COME BACK TO INITIAL SCREEN\n         SPACE 2\n* MISCELLANEOUS ERROR\nERMISC   EQU   *\n         EXEC  CICS HANDLE CONDITION ERROR\n         MVC   MESSAGS(L'MESS04),MESS04\n         B     DISPERR\n         SPACE 2\n* FILE LENGTH ERROR\nERLENTH  EQU   *\n         MVC   MESSAGS(L'MESS05),MESS05\n         B     DISPERR\n         SPACE 2\n* AN ERROR HAS OCCURRED. DISPLAY APPROPRIATE MESSAGE.\nDISPERR  EQU   *\n         BAL   R10,CLEARMAP       CLEAR MAP\n         MVC   SGDSIDO,GDSID\n         MVC   SMESSAGO,MESSAGS    MOVE MESSAGE TO OUTPUT\n         BLANK MESSAGS,50\n         BAL   R10,SETTIME\n         MVC   SM1DATEO,CURDATE\n         MVC   SM1TIMEO,CURTIME\n         EXEC  CICS SEND MAP('MAP01') MAPSET('ZZGDS01') FREEKB\n         B     RETURN\n         EJECT\n* CONSTANTS AND WORK AREAS\n         LTORG\nTWOZEROS DC    C'00'\nC00      DC    C'00'\nC99      DC    C'99'\nLOVALUES DC    8X'00'\nHIVALUES DC    2X'FF'\nRECLENTH DC    H'60'\nDOUBLE   DS    D\nSIGN     DC    X'FC'\nZERO     DC    P'0'\nONE      DC    P'1'\nWORKA    DS    CL4\nBLANKS   DC    CL30' '\nBLANK    EQU   C' '\nHIVALUE  EQU   X'FF'\nON       EQU   X'FF'\nOFF      EQU   X'00'\n* ERROR MESSAGES\nMESS01   DC    C'NO RECORD FOUND FOR THIS KEY'\nMESS02   DC    C'ZZGDSK FILE NOT OPEN'\nMESS03   DC    C'MAP FAIL, PRESS CLEAR THEN REENTER DATA'\nMESS04   DC    C'MISCELLANEOUS ERROR'\nMESS05   DC    C'FILE LENGTH ERROR'\nMESS06   DC    C'RECORD HAS BEEN UPDATED'\nMESS07   DC    C'READING > LAST RECORD, PRESS PF7 TO GET LAST'\nMESS08   DC    C'READING < FIRST RECORD, PRESS PF8 TO GET FIRST'\nMESS20   DC    CL20'ERROR - NOT NUMERIC'\nMESS21   DC    CL20'ERROR - > MAX'\nMESS22   DC    CL20'ERROR - > 10'\nMESSAGS  DS    CL50\n         EJECT\n         PRINT GEN\n         COPY  DFHBMSCA\n         COPY  DFHAID\n         END   ZZGD01\n\n\nZZGDS01\n\n* MAPSET=ZZGDS01  MAP=MAP01    NAME=VSAM GENERATION DATA SETS\nZZGDS01  DFHMSD TYPE=&SYSPARM,MODE=INOUT,CTRL=(FREEKB,FRSET),          X\n               TIOAPFX=YES,STORAGE=AUTO,LANG=ASM\nMAP01    DFHMDI SIZE=(24,80),LINE=1,COLUMN=1,MAPATTS=(COLOR,HILIGHT),  X\n               DSATTS=(COLOR,HILIGHT),EXTATT=YES\nSPROGID  DFHMDF LENGTH=006,POS=(01,01),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='ZZGD01'\n         DFHMDF LENGTH=040,POS=(01,17),                                X\n               COLOR=NEUTRAL,HILIGHT=REVERSE,                          X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL=' Y O U R    C O M P A N Y    N A M E    '\n         DFHMDF LENGTH=001,POS=(01,59),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=005,POS=(01,64),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='DATE:'\nSM1DATE  DFHMDF LENGTH=010,POS=(01,70),                                X\n               COLOR=NEUTRAL,HILIGHT=REVERSE,                          X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='MM/DD/YYYY'\n         DFHMDF LENGTH=011,POS=(02,01),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(FSET,ASKIP),                                     X\n               INITIAL='ZZGDS01(01)'\n         DFHMDF LENGTH=008,POS=(02,31),                                X\n               COLOR=YELLOW,HILIGHT=REVERSE,                           X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL=' V S A M'\n         DFHMDF LENGTH=001,POS=(02,41),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=005,POS=(02,64),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='TIME:'\nSM1TIME  DFHMDF LENGTH=008,POS=(02,70),                                X\n               COLOR=NEUTRAL,HILIGHT=REVERSE,                          X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='HH:MM:SS'\n         DFHMDF LENGTH=001,POS=(02,79),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=042,POS=(03,16),                                X\n               COLOR=YELLOW,HILIGHT=REVERSE,                           X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL=' G E N E R A T I O N    D A T A    S E T S'\n         DFHMDF LENGTH=001,POS=(03,60),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(06,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='GDS-NAME.....................'\n         DFHMDF LENGTH=001,POS=(06,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSGDSID   DFHMDF LENGTH=008,POS=(06,38),                                X\n               COLOR=GREEN,HILIGHT=UNDERLINE,                          X\n               ATTRB=(BRT,UNPROT,IC),                                  X\n               INITIAL='        '\n         DFHMDF LENGTH=001,POS=(06,47),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(08,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='DESCRIPTION..................'\n         DFHMDF LENGTH=001,POS=(08,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSDESCR   DFHMDF LENGTH=030,POS=(08,38),                                X\n               COLOR=GREEN,HILIGHT=UNDERLINE,                          X\n               ATTRB=(BRT,UNPROT),                                     X\n               INITIAL='                              '\n         DFHMDF LENGTH=001,POS=(08,69),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(10,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='CURRENT VERSION..............'\n         DFHMDF LENGTH=001,POS=(10,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSCURVER  DFHMDF LENGTH=002,POS=(10,38),                                X\n               COLOR=GREEN,HILIGHT=UNDERLINE,                          X\n               ATTRB=(BRT,NUM)\n         DFHMDF LENGTH=001,POS=(10,41),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSERRCUR  DFHMDF LENGTH=020,POS=(10,47),                                X\n               COLOR=RED,HILIGHT=BLINK,                                X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='                    '\n         DFHMDF LENGTH=001,POS=(10,68),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(12,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='MAXIMUM NUMBER OF VERSIONS...'\n         DFHMDF LENGTH=001,POS=(12,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSMAXVER  DFHMDF LENGTH=002,POS=(12,38),                                X\n               COLOR=GREEN,HILIGHT=UNDERLINE,                          X\n               ATTRB=(BRT,NUM)\n         DFHMDF LENGTH=001,POS=(12,41),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSERRMAX  DFHMDF LENGTH=020,POS=(12,47),                                X\n               COLOR=RED,HILIGHT=BLINK,                                X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='                    '\n         DFHMDF LENGTH=001,POS=(12,68),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(14,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='DATE LAST VERSION CREATED....'\n         DFHMDF LENGTH=001,POS=(14,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSDATLST  DFHMDF LENGTH=008,POS=(14,38),                                X\n               COLOR=NEUTRAL,HILIGHT=OFF,                              X\n               ATTRB=(BRT,ASKIP)\n         DFHMDF LENGTH=001,POS=(14,47),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(16,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='TIME LAST VERSION UPDATED....'\n         DFHMDF LENGTH=001,POS=(16,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSTIMUPD  DFHMDF LENGTH=005,POS=(16,38),                                X\n               COLOR=NEUTRAL,HILIGHT=OFF,                              X\n               ATTRB=(BRT,ASKIP)\n         DFHMDF LENGTH=001,POS=(16,44),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\n         DFHMDF LENGTH=029,POS=(18,05),                                X\n               COLOR=BLUE,HILIGHT=REVERSE,                             X\n               ATTRB=(ASKIP),                                          X\n               INITIAL='JOB THAT LAST UPDATED GDS....'\n         DFHMDF LENGTH=001,POS=(18,35),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSLSTJOB  DFHMDF LENGTH=008,POS=(18,38),                                X\n               COLOR=NEUTRAL,HILIGHT=OFF,                              X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='        '\n         DFHMDF LENGTH=001,POS=(18,47),                                X\n               COLOR=BLUE,HILIGHT=OFF,                                 X\n               ATTRB=(ASKIP)\nSMESSAG  DFHMDF LENGTH=050,POS=(22,01),                                X\n               COLOR=RED,HILIGHT=BLINK,                                X\n               ATTRB=(BRT,ASKIP)\n         DFHMDF LENGTH=054,POS=(23,01),                                X\n               COLOR=PINK,HILIGHT=OFF,                                 X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL='ENTER GDS-ID AND PRESS ENTER OR USE APPROPRIATE*\n                PF KEY'\n         DFHMDF LENGTH=001,POS=(23,56),                                X\n               COLOR=PINK,HILIGHT=OFF,                                 X\n               ATTRB=(BRT,ASKIP)\n         DFHMDF LENGTH=074,POS=(24,01),                                X\n               COLOR=PINK,HILIGHT=REVERSE,                             X\n               ATTRB=(BRT,ASKIP),                                      X\n               INITIAL=' PF2=1ST-RECORD   4=EXIT   7=PREVIOUS-RECORD   X\n               8=NEXT-RECORD   9=UPDATE   '\n         DFHMDI TYPE=FINAL\n         END\n\nAngelo Sileo\nManager Technical Services\nPatrick Media Group (USA)                         c Angelo Sileo 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E006A07": {"ttr": 8458, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x16\\x00\\x16\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 22, "newlines": 22, "modlines": 0, "user": "VSEUPDT"}, "text": "Reader's letter\n\nWe recently used a combination of two articles in the June\n1991 issue of VSE Update. The articles were VSE batch\noperator and Partition wait for a specified time. These two\narticles saved our company a lot of time and money.\n\nUsing the two articles, we programmed an automatic operator\nto bounce our system from night-production CICS to day-\nproduction CICS every morning at 5:30am before the day\noperators reported at 6:00am.\n\nOther systems programmers with the same limited experience\nmay benefit from an additional note being added to the\nPartition wait for a specified time article. The SETIME macro\nwill only allow a maximum wait time of 55924 seconds (15\nhours 32 minutes and 4 seconds). This caused us several\nheadaches until we determined the problem.\n\nSteven P Moore\nSenior Systems Analyst\nAmerex Corporation (USA)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A00I": {"ttr": 8460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 11, "newlines": 11, "modlines": 0, "user": "VSEUPDT"}, "text": "E007 - VSE Update issue 7 September 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE007A01   Subroutine to set return codes from COBOL\nE007A02   A routine to intercept and analyse data exceptions\nE007A03   Using IOCP with VSE\nE007A04   POWER accounting system\nE007A05   System unit record file reset\nE007A06   Processing EXEC PARM values with COBOL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A01": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 247, "newlines": 247, "modlines": 0, "user": "VSEUPDT"}, "text": "Subroutine to set return codes from COBOL\n\nThere are times when the need arises to use conditional JCL.\nThis requires programs, at end of processing, to set and pass\nconditions through the use of return codes. Unfortunately, IBM\ndoes not currently support this with higher level languages such\nas COBOL. However, IBM Assembler does support the setting\nof return codes with its EOJ macro.\n\nAn Assembler subroutine called ADC034 is now available to\nCOBOL for setting return codes. This passes eleven bytes of\ndata to a special register, COM-REG, and calls subroutine\nADC034. (COM-REG is a special register like CURRENT-\nDATE and does not need to be defined in Working-Storage.)\n\nThe following is an example that will set the return code to\n0015.\n\n      MOVE '00000000015' to COM-REG.\n      CALL 'ADC034'.\n\nNote: this subroutine allows the use of code values 0000-0032.\nBecause IBM uses codes 4, 8, 12, and 16 for processing, these\nshould be avoided.\n\n\nSAMPLE COBOL PROGRAM\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. RCTEST.\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\nDATA DIVISION.\nFILE SECTION.\nWORKING-STORAGE SECTION.\n01  FILLER                       PIC X(42)\n    VALUE '*** RCTEST WORKING STORAGE BEGINS HERE ***'.\n01  RC                           PIC X(11) VALUE '00000000015'.\n01  FILLER                       PIC X(40)\n    VALUE '*** RCTEST WORKING STORAGE ENDS HERE ***'.\nPROCEDURE DIVISION.\nSTP-RUN.\n    DISPLAY 'ENTER RC:' UPON CONSOLE.\n    ACCEPT RC FROM CONSOLE.\n    MOVE RC TO COM-REG.\n    CALL 'ADC034'.\n    STOP RUN.\n\n\nSAMPLE JCL\n\n* $$ JOB JNM=RCTEST,CLASS=8,DISP=D\n* $$ LST CLASS=Q,DISP=H\n// JOB RCTEST\n// OPTION NODUMP\n// LIBDEF *,SEARCH=USRLIBS.USERTEST\nON $RC = 0015 GOTO NOEMS\n// EXEC RCTEST,SIZE=256K\n/*\n// EXEC EMS001,SIZE=(AUTO,256K)    This will be bypassed if $RC=0015\n/*                       This statement will be bypassed if $RC=0015\n/. NOEMS\n/*\n/&\n* $$ EOJ\n\n\nZ14.ADC034\n\n*      PROGRAM-ID. ADC034 SET RETURN CODE FROM COBOL PROGRAM.\n*      REMARKS.\n*               *********************PROJECT 01047*********************\n*               * THIS SUBROUTINE WILL SET THE RETURN CODE TO A VALUE *\n*               * (FROM 0 TO 32) PASSED TO IT FROM A COBOL PROGRAM.   *\n*               * THIS RETURN CODE CAN THEN BE TESTED IN JCL WITH     *\n*               * CONDITIONAL STATEMENTS.                             *\nADC034   CSECT\nR1       EQU    1\nR11      EQU   11\nR13      EQU   13\nR15      EQU   15\n         USING *,R11\n         LR    R11,R15\n         COMRG                     ACCESS COMMUNICATIONS REGION\n         MVC   JOBNAME,24(R1)        GET JOBNAME\n         MVC   USCR,12(R1)           GET DATA PASSED F/CALLING PGM\n         OPEN  CONSOLE             OPEN CONSOLE FOR DISPLAY\n         PUT   CONSOLE               DISPLAY APPROPRIATE MSG\n         CLC   USCR,N0010          START COMPARING FOR PASSED RTN CDES\n         BH    C0011\n         BL    C0000\n         BE    EOJ0010\nC0000    CLC   USCR,N0001\n         BH    C0001\nEOJ0000  EOJ   RC=0000\nC0001    CLC   USCR,N0001\n         BH    C0002\nEOJ0001  EOJ   RC=0002\nCOOO2    CLC   USCR,N0002\n         BH    C0003\nEOJ0002  EOJ   RC=0002\nC0003    CLC   USCR,N0003\n         BH    C0004\nEOJ0003  EOJ   RC=0003\nC0004    CLC   USCR,N0004\n         BH    C0005\nEOJ0004  EOJ   RC=0004\nCOOO5    CLC   USCR,N0005\n         BH    C0006\nEOJ0005  EOJ   RC=0005\nCOOO6    CLC   USCR,N0006\n         BH    C0007\nEOJ0006  EOJ   RC=0006\nCOOO7    CLC   USCR,NOOO7\n         BH    C0008\nEOJ0007  EOJ   RC=0007\nC0008    CLC   USCR,N0008\n         BH    C0009\nEOJ0008  EOJ   RC=0008\nC0000    CLC   USCR,N0009\n         BH    C0010\nEOJ0009  EOJ   RC=0009\nC0010    CLC   USCR,N0010\n         BH    C0011\nEOJ0010  EOJ   RC=0010\nC0011    CLC   USCR,N0020\n         BH    C0021\n         BE    EOJ0020\n         CLC   USCR,N0011\n         BH    C0012\nEOJ0011  EOJ   RC=0011\nCOO12    CLC   USCR,N0012\n         BH    C0013\nEOJ0012  EOJ   RC=0012\nCOO13    CLC   USCR,N0013\n         BH    C0014\nEOJ0013  EOJ   RC=0013\nC0014    CLC   USCR,N0014\n         BH    C0015\nEOJ0014  EOJ   RC=0014\nC0015    CLC   USCR,N0015\n         BH    C0016\nEOJ0015  EOJ   RC=0015\nC0016    CLC   USCR,N0016\n         BH    C0017\nEOJ0016  EOJ   RC=0016\nC0017    CLC   USCR,N0017\n         BH    C0018\nEOJ0017  EOJ   RC=0017\nC0018    CLC   USCR,N0018\n         BH    C0019\nEOJ0018  EOJ   RC=0018\nC0019    CLC   USCR,N0019\n         BH    C0020\nEOJ0019  EOJ   RC=0019\nC0020    CLC   USCR,N0020\n         BH    C0021\nEOJ0020  EOJ   RC=0020\nC0021    CLC   USCR,N0030\n         BH    C0031\n         BE    EOJ0030\n         CLC   USCR,N0021\n         BH    C0022\nEOJ0021  EOJ   RC=0021\nC0022    CLC   USCR,N0022\n         BH    C0023\nEOJ0022  EOJ   RC=0022\nCOO23    CLC   USCR,N0023\n         BH    C0024\nEOJ0023  EOJ   RC=0023\nC0024    CLC   USCR,N0024\n         BH    C0025\nEOJ0024  EOJ   RC=0024\nCOO25    CLC   USCR,N0025\n         BH    C0026\nEOJ0025  EOJ   RC=0025\nC0026    CLC   USCR,N0026\n         BH    C0027\nEOJ0026  EOJ   RC=0026\nC0027    CLC   USCR,N0027\n         BH    C0028\nEOJ0027  EOJ   RC=0027\nC0028    CLC   USCR,N0028\n         BH    C0029\nEOJ0028  EOJ   RC=0028\nC0029    CLC   USCR,N0029\n         BH    C0030\nEOJ0029  EOJ   RC=0029\nC0030    CLC   USCR,N0030\n         BH    C0031\nEOJ0030  EOJ   RC=0030\nC0031    EQU   *\n         CLC   USCR,N0031\n         BH    EOJ0032\nEOJ0031  EOJ   RC=0031\nEOJ0032  EOJ   RC=0032\nMSG      DS    0CL45\n         DC    C'JOB= '\nJOBNAME  DS    CL8\n         DC    C' '\n         DC    C'HAS SET RC TO.....: '\nUSCR     DS    CL11\nN0001    DC    C'00000000001'\nN0002    DC    C'00000000002'\nN0003    DC    C'00000000003'\nN0004    DC    C'00000000004'\nN0005    DC    C'00000000005'\nN0006    DC    C'00000000006'\nN0007    DC    C'00000000007'\nN0008    DC    C'00000000008'\nN0009    DC    C'00000000009'\nN0010    DC    C'00000000010'\nN0011    DC    C'00000000011'\nN0012    DC    C'00000000012'\nN0013    DC    C'00000000013'\nN0014    DC    C'00000000014'\nN0015    DC    C'00000000015'\nN0016    DC    C'00000000016'\nN0017    DC    C'00000000017'\nN0018    DC    C'00000000018'\nN0019    DC    C'00000000019'\nN0020    DC    C'00000000020'\nN0021    DC    C'00000000021'\nN0022    DC    C'00000000022'\nN0023    DC    C'00000000023'\nN0024    DC    C'00000000024'\nN0025    DC    C'00000000025'\nN0026    DC    C'00000000026'\nN0027    DC    C'00000000027'\nN0028    DC    C'00000000028'\nN0029    DC    C'00000000029'\nN0030    DC    C'00000000030'\nN0031    DC    C'00000000031'\nN0032    DC    C'00000000032'\n         LTORG\nCONSOLE  DTFCN BLKSIZE=45,                                             C\n               DEVADDR=SYSLOG,                                         C\n               IOAREA1=MSG,                                            C\n               TYPEFLE=OUTPUT\n         END\n\n\nFred Schubert\nManager of Development\nCounty of Albemarle (USA)                   c County of Albemarle 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A02": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 251, "newlines": 251, "modlines": 0, "user": "VSEUPDT"}, "text": "A routine to intercept and analyse data exceptions\n\nWhen data exceptions occur and a job is terminated, one\nrealizes that it would be very useful if more occurrences of data\nexceptions could be found in a single test run. DIAGRTN will\nallow up to 100 data exceptions to occur before terminating the\njob. This can be extremely useful when doing conversions from\nnon-IBM to IBM systems.\n\nThe routine should be called as early as possible in the COBOL\nprogram, so that trapping of data exceptions can occur.\nDIAGRTN will produce a partition dump on the first\noccurrence of a data exception, and an analysis of up to 100\ndata exceptions. If an error - other than a data exception -\noccurs, the program is terminated with a dump and an\nappropriate message. The dump may be suppressed by\nincluding a //UPSI 01 card in the JCL for the job.\n\nNote: the COBOL options STATE and FLOW must not be\nspecified if DIAGRTN is called.\n\nThe routine is called by including the following statement in\nthe COBOL program:\n\n      CALL 'DIAGRTN'.\n\nThe source code for DIAGRTN follows. Assemble the source\ncode and catalogue the relocatable module into a relocatable\nlibrary. The relocatable library should be in the standard\nrelocatable library searchlist, so that the module may be\nincluded in the calling program at link edit time.\n\n         TITLE 'DIAGRTN - DIAGNOSTICS ROUTINE'\nDIAGRTN  START\n         USING DIAGRTN,15\n         SAVE  (14,12)                 STORE REGISTERS\n         STXIT PC,AAA,SAVE             ENTRY ADDRESS\n         OPEN  LISTER\n         RETURN (14,12)                RETURN\n         DROP  15\n         SPACE 2\n*              DATA ERROR RECOVERY ROUTINE\n         SPACE 2\nAAA      BALR  10,0\n         USING *,10\n         LA    11,SAVE\n         SPACE 2\n*        R10   BASE REGISTER\n*        R11   ADDRESS OF WEIGHT\n         SPACE 2\n         EXTRACT ID=BDY,AREA=PARTMAP,LEN=20\n         CLI   3(11),X'07'             RECOVERABLE ERROR?\n         BE    P110                    YES\nP050     EQU   *\nP100     PUT   LISTER,UNKNOWN          UNKNOWN ERROR\n         B     P260\nP110     EQU   *\n         CP    COUNT,PZERO             FIRST ERROR\n         BNE   P130                    NO\nP120     PUT   LISTER,STARTD\n         L     2,PBEGIN\n         L     3,PENDLOG\n         PDUMP (2),(3)                 TAKE A DUMP\nP130     AP    COUNT,PONE              AUGMENT ERROR COUNT\n         SLR   2,2\n         IC    2,4(11)                 EXTRACT P-CNTR\n         SRL   2,6                     GET INSTRUCTION LENGTH BITS\n         SLL   2,1                     MULTIPLY BY 2\n         ST    2,SAVEA\n         L     2,4(11)                 EXTRACT P-CNTR\n         S     2,SAVEA                 BACKDATE\n         ST    2,SAVEA                 STORE P-CNTR\n         USING NSTR,2\nP151     EQU   *\n         LA    3,3                     LENGTH OF PC\n         LA    4,SAVEA                 ADDRESS OF P-CNTR\n         BAL   12,CONVERT              CONVERT PC\n         MVC   PC(6),UAREA+5           SET UP P-CNTR\n         SLR   3,3                     LENGTH OF WEIGHT\n         LA    4,3(11)                 A(WEIGHT)\n         BAL   12,CONVERT              CONVERT WEIGHT\n         MVC   WT(2),UAREA+9           SET UP WEIGHT\n         LH    5,ADDR                  (A) ADDRESS\n         BAL   12,RESOLVE              RESOLVE (A) ADDRESS\n         ST    4,SAVEA\n         LA    4,SAVEA                 ADDR OF (A) ADDRESS\n         LA    3,3                     LENGTH OF ADDRESS\n         BAL   12,CONVERT              CONVERT (A) ADDRESS\n         MVC   AA(6),UAREA+5           SET UP AA\n         SLR   4,4                     GET (A) LENGTH\n         LA    3,240                   FO\n         IC    4,LNGTH\n         NR    3,4\n         SRL   3,4                     (A) LNGTH IN R3\n         LA    3,1(3)\n         STH   3,LNGA\n         BCTR  3,0\n         L     4,SAVEA                 AD ADDRESS\n         BAL   12,CONVERT              CONVERT AD TO DISPLAY\n         MVC   AD(10),UAREA+1          SET UP ADATA\n         LH    5,BDDR                  (B) ADDRESS\n         BAL   12,RESOLVE              RESOLVE (B) ADDRESS\n         ST    4,SAVEB\n         LA    4,SAVEB                 ADDR OF (B) ADDRESS\n         LA    3,3                     LENGTH OF ADDRESS\n         BAL   12,CONVERT              CONVERT (B) ADDRESS\n         MVC   BA(6),UAREA+5           SET UP BA\n         SLR   4,4                     GET (B) LENGTH\n         LA    3,15                    OF\n         IC    4,LNGTH\n         NR    3,4                     (B) LNGTH IN R3\n         LA    3,1(3)\n         STH   3,LNGB\n         BCTR  3,0\n         L     4,SAVEB                 BD ADDRESS\n         BAL   12,CONVERT              CONVERT BD TO DISPLAY\n         MVC   BD(10),UAREA+1          SET UP BDATA\n         MVC   PSVE(6),PC              GET P-CNTR\n         CLC   PSVE(6),LSTP            SAME AS LAST?\n         BNE   P158                    NO\n         AP    SCOUNT,PONE             AUGMENT SAME COUNT\n         B     P165\nP158     CP    SCOUNT,PZERO            ANY DUPLICATES?\n         BE    P159                    NO\n         UNPK  DISCNT(9),SCOUNT        DISPLAY DUPLICATE COUNT\n         OI    DISCNT+8,240\n         PUT   LISTER,OCCURS\n         ZAP   SCOUNT,PZERO\nP159     MVC   LSTP(6),PSVE            STORE THIS ERROR\nP160     PUT   LISTER,DIAG\nP165     EQU   *\nP250     CP    COUNT,PHUN              MORE THAN 100 ERRORS?\n         BNH   P270                    NO\n         CP    SCOUNT,PZERO            ANY DUPLICATES?\n         BE    P260\n         UNPK  DISCNT(9),SCOUNT        DISPLAY DUPLICATE COUNT\n         OI    DISCNT+8,240\n         PUT   LISTER,OCCURS\nP260     EQU   *\n         COMRG REG=1                   GET COMREG ADDRESS\n         TM    23(1),64                IS DUMP REQUIRED ?\n         BO    P265                    NO\n         L     2,PBEGIN\n         L     3,PENDLOG\n         PDUMP (2),(3)                 TAKE A DUMP\nP265     EQU   *\n         PUT   LISTER,ENDMSG\n         EOJ\nP270     EQU   *\n         EXIT  PC\n         SPACE 2\n*              ROUTINE TO CONVERT TO DISPLAY\n         SPACE 2\nCONVERT  EX    3,MOVE                  MOVE DATA TO WAREA\n         LA    3,1(3)                  AUGMENT LNGTH FOR UNPK\n         EX    3,UNPK\n         TR    UAREA(11),TABLE-240     TRANSLATE FOR DISPLAY\n         BR    12                      RETURN\n         SPACE 2\n*              ROUTINE TO RESOLVE ADDRESS IN BDDD FORMAT\n         SPACE 2\nRESOLVE  LA    4,240                   FO\n         SLL   4,8                     FOOO\n         NR    4,5\n         SRL   4,10                    BASE * 4\n         L     4,SAVE+8(4)\n         LA    6,4095                  0FFF\n         NR    6,5                     DISPL IN R6\n         AR    4,6                     FINAL ADDR IN R4\n         BR    12\n         SPACE 2\n*              GENERAL WORKING STORAGE\n         SPACE 2\nCOUNT    DC    PL5'0'                  ERROR COUNT\nSCOUNT   DC    PL5'0'                  DUPLICATE COUNT\nUNKNOWN  DC    CL80'0 ERROR - R11 = ADDRESS OF P-COUNTER'\nSTARTD   DC    CL80'0 DIAGRTN - DIAGNOSTICS'\nENDMSG   DC    CL80'0 TERMINATED BY DIAGRTN'\nOCCURS   DC    CL27'0 THE ABOVE ERROR OCCURRED '\nDISCNT   DC    CL9' '                  DISPLAY COUNT\n         DC    CL44' TIMES'\nPONE     DC    PL1'1'                  CONSTANT 1\nPSVE     DC    CL6' '                  THIS P-CNTR\nLSTP     DC    CL6' '                  LAST P-CNTR\nWAREA    DC    CL16' '                 DATA STORAGE\nUAREA    DC    CL12' '                 UNPACK AREA\nTABLE    DC    C'0123456789ABCDEF'\nDIAG     DS    0CL80\n         DC    C'O ERROR = '\nWT       DC    CL2' '                  INTERRUPT WEIGHT\n         DC    C' - '\n         DC    C'PC='\nPC       DC    CL6' '\n         DC    C','\n         DC    C'AA='\nAA       DC    CL6' '\n         DC    C','\n         DC    C'AD='\nAD       DC    CL10' '                 A DATA\n         DC    C','\n         DC    C'BA='\nBA       DC    CL6' '\n         DC    C','\n         DC    C'BD='\nBD       DC    CL10' '                  B DATA\n         DC    CL8' '\nPZERO    DC    PL1'0'\nPHUN     DC    PL2'100'\n         SPACE 2\n*              ALIGNED WORKING STORAGE\n         SPACE 2\nSAVE     DS    0D                      SAVE AREA\n         DS    D                       PSW\n         DS    16F                     REGISTER STORAGE\nSAVEA    DS    F                       RESOLVED (A) ADDRESS\nSAVEB    DS    F                       RESOLVED (B) ADDRESS\nLNGA     DS    H                       (A) DATA LENGTH\nLNGB     DS    H                       (B) DATA LENGTH\nDWORK    DS    D                       DOUBLE WORK AREA\nPARTMAP  MAPBDY DSECT=NO\n         SPACE 2\nNSTR     DSECT\nOPCODE   DS    C\nLNGTH    DS    C\nADDR     DS    CL2\nBDDR     DS    CL2\nDIAGRTN  CSECT\n         SPACE 2\n*              INSTRUCTION WORKING STORAGE\n         SPACE 2\n         USING AAA+2,10\nMOVE     MVC   WAREA(1),0(4)\nUNPK     UNPK  UAREA(12),WAREA(1)\n         SPACE 2\nLISTER   DTFPR DEVADDR=SYSLST,                                        X\n               BLKSIZE=80,                                            X\n               CTLCHR=ASA,                                            X\n               DEVICE=1403,                                           X\n               RECFORM=FIXUNB,                                        X\n               IOAREA1=OUTAREA,                                       X\n               MODNAME=IJDFAZZW\nOUTAREA  DS    CL80\n         SPACE 2\n         LTORG\n         END\n\n\nM Nunan\nSystems Programmer\nSage Computing (South Africa)             c Sage Computing 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A03": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01$\\x01$\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 292, "newlines": 292, "modlines": 0, "user": "VSEUPDT"}, "text": "Using IOCP with VSE\n\nAlthough it may be new to many VSE environments, running\nthe IBM I/O Configuration Program (IOCP) is mandatory for\nall ES/9000 processors. IBM dedicated most of a Field\nNetwork Television (FNT) satellite broadcast to the subject on\n2 April 1992. Video tapes of the broadcast are available\nthrough IBM for North American customers.\n\nIOCP defines the I/O configuration to the Dynamic Channel\nSubsystem. Perhaps best envisioned as a processor, the\nDynamic Channel Subsystem controls all channel activity,\ndefines resource distribution in LPAR (PR/SM logical\npartition) mode, and associates a unique device number to all\nI/O devices. To provide these functions, it requires specific\ndata about the I/O configuration attached to the system\n(channel speed, type of control unit, and type of I/O device).\n\nAn IOCP is required for any processor running in LPAR mode\nor running in XA or ESA mode. It is also required to run in\nS/370 mode on a 3090 and 308x. All ES/9000 processors\nrequire an IOCP because all ES/9000s run in LPAR mode.\nIOCP is a customer responsibility, unlike the equivalent setting\nof UCWs taken care of by an IBM Customer Engineer on\nsystems such as the 4381.\n\nDespite the work involved, an IOCP does provide some\nbenefits. The Dynamic Channel Subsystem supports Dynamic\nPath Selection (DPS), Dynamic Path Reconnection (DPR), 256\nchannels, and up to four paths from a uniprocessor to each\ndevice (twice that number on a dyadic). VSE supports only\nuniprocessors at the present time. DPS means the channel\nsubsystem figures out the optimum path to a device, while\nDPR means that an I/O can be initiated on one path and return\non another. The exception to all this is the integrated I/O\nsubsystem of the 9221 processors, which supports only one\npath to a device.\n\nWhat does it all cost? The Dynamic Channel Subsystem\nrequires a Hardware Systems Area (HSA) of 2MB to 5MB of\nreal storage. HSA contains the information defining the I/O\nsubsystem.\n\nWhen I/O becomes the bottleneck, the use of multiple paths\nreally pays off in performance. Therefore, it makes sense to\nplan configurations that provide the maximum number of paths\npossible. A physical diagram is the best method; this can be\ndone by hand or with a computer-based tool. One PC-based\ntool, designed specifically for working with IOCPs, will read\nan IOCP and draw the diagram.\n\n\nCHPID\n\nTo the newcomer, the most incomprehensible thing about\nIOCPs is the CHPID. Pronounced chipid, the CHannel Path\nIDentifier is an IBM-predetermined fixed number that indicates\nwhich slot and the position within that slot where a channel\ncard is physically installed. In a 9221 rack-mounted ES/9000,\nlooking from the back, the card slots are numbered, left to\nright, 10 to 18. Slot 10 is where the power card must be\ninstalled, and each remaining slot can have a single or triple\nchannel card installed to support parallel or ESCON channels.\nOne to three I/O bus link cards are supported by the 9221 and\nare installed working backwards from slot 18. If present, the\nSysplex Timer separates the I/O bus link and parallel/ESCON\nchannel cards.\n\nCHPIDs for I/O bus link cards begin at X'00' at the top of slot\n18, with a maximum of X'FF' indicating the bottom of slot 16.\nFor parallel and ESCON channel cards, CHPIDs begin at X'20'\nat the top of slot 11. X'21' and X'22' are assigned to the lower\ntwo channels in slot 11 if a triple channel card is installed in\nthat location; X'21' and X'22' are never used if a single channel\ncard is installed in slot 11. In either case slot 12 begins at\nX'23', meaning the maximum CHPID would be X'37' at the\nbottom of slot 18.\n\nAir-cooled frame ES/9000 models, the 9121, have an even\nmore confusing CHPID configuration. In the base frame of a\nuniprocessor, both LOC 1 and LOC 2 can contain a maximum\nof 12 parallel and four ESCON channels. The parallel channels\nin LOC 1 have CHPIDs of X'00' to X'0B', and LOC 2 X'0C' to\nX'17'. ESCON channels reverse the process. In LOC 2,\nCHPIDs begin at X'18' and continue to X'1B'. LOC 1 has X'1C'\nto X'1F'.\n\nIn summary, the CHPID is a fixed two-digit hexadecimal\nnumber, determined by a channel's location within the cabinet\nand is unaffected by the presence, absence, or size of any other\ncard in the cabinet. Hard-coding a number like CHPID in the\nIOCP makes some sense given the relative permanence of a\nchannel's location in the cabinet. In practice, new cards get\nadded, but rarely are existing cards moved.\n\n\nIOCP DEFINITION\n\nThe IOCP takes channel path definitions, control unit\ndefinitions, and I/O device definitions as input and produces an\nI/O Configuration DataSet (IOCDS), creates subchannel\nnumbers, and provides configuration reports as output. As\nmight be expected, input looks very much like Assembler\nmacro calls, and must follow the rules of Assembler: ie labels\nin column 1, no spaces after commas, single quotes around\nstrings with spaces or special characters, unlabelled statements\nmay not start in column 1, continuation is in column 72, and\ncontinued statements must start in column 16. In certain\nsituations, the number of parentheses indicated in the IBM\ndocumentation may look superfluous, but is usually required.\n\nAn IOCP must be done before the first IML. The obvious\nquestion is how? There are five methods of IOCP generation\navailable, the first two of which are stand-alone. Since the\nprocessor controller is really a PS/2 microcomputer, IOCP\nparameters can be specified by a series of screens in a manner\nsimilar to the setup of UCWs done on some\n\nS/370 processors. The associated software is shipped with the\nprocessor complex on diskettes associated with the processor\ncontroller.\n\nGiven a card reader or another computer with a compatible tape\ndrive, IOCP input in 80-byte card image fixed format can be\nassembled stand-alone by microcode and stored in the specified\nIOCDS. Unless the tape method is used on a processor where\nIOCP syntax checking is possible, this approach can be\ntedious.\n\nIf an operational VSE, MVS, or VM system is available, the\ntypical batch process used by installations modifying IOCPs\ncan be used. Although the syntax checking and logical\nconsistency process does not guarantee it will work on the new\nprocessor, the IOCDS can be generated. Processor support is\nprovided for downloading the IOCDS to the new processor.\nWith a tight time schedule for installation, the IOCDS could be\ngenerated before the processor is installed. An exact hardware\nconfiguration for the new processor would be required. It\nwould have to include locations of all channel cards, since this\ndetermines CHPIDs.\n\nIf an operational processor with VSE/ESA 1.2 is available,\nassistance is provided by two skeletons in VSE/ICCF library\n59. SKIOCPIN is used to install the IOCP program in sub-\nlibrary PRD2.IOCP. SKIOCPCN is a sample IOCP job that\ncan form a base for configuration changes.\n\nAutoGen IOCP is a tool on the 9221 service processor that\ncreates an input source deck for integrated I/O subsystem\nchannels only. By using templates of macros and the editor,\nadditional configuration information is added to the source file.\n\n\nIOCP STATEMENTS\n\nThe three main statements in an IOCP are CHPID,\nCNTLUNIT, and IODEVICE. They describe the characteristics\nand connections between channels, control units, and I/O\ndevices respectively. Although each channel can have multiple\ncontrol units attached to it, and each control unit multiple I/O\ndevices attached to it, it is generally impractical to code the\nhierarchy in this way. For example, a DASD control unit is\nusually connected to more than one channel, but the\nCNTLUNIT statement can only be coded once for each control\nunit, not once under the CHPID statement of each channel to\nwhich it is attached.\n\nFor this reason, and because each CHPID statement must\nprecede all CNTLUNIT statements that reference it, and each\nCNTLUNIT statement must precede all IODEVICE statements\nthat reference it, CHPID statements are generally grouped\ntogether first, then all CNTLUNIT statements, followed by all\nIODEVICE statements.\n\nAll three statements, CHPID, CNTLUNIT, and IODEVICE,\ncan be specified with an optional label beginning in column 1.\nAlthough they impart no meaning to IOCP, when used as\ndocumentation they can be used to quickly identify the relevant\nstatement for a particular device.\n\nAn ID statement begins each IOCP. It names the resulting\nIOCDS, allowing more than one IOCDS to be kept. The most\nobvious use of this is for simplified back-out of a newly created\nfailing IOCDS. After all, if it is too wrong, an IPL may not be\npossible. A SYSTEM= parameter allows an IOCP to generate\nan IOCDS on a system other than the one where the IOCDS\nwill be used.\n\nCHPID\n\nCHPID statements are coded for each channel, with the CHPID\ncoded as the first parameter of the PATH=Jkeyword. Although\nnot needed for ES/9000, the S/370 channel number can be\ncoded as the second parameter for PATH= and is recommended\nfor documentation, especially during conversion from S/370.\n\nTYPE= indicates the type of channel being defined. BL is for\nparallel block multiplexor channels, while BY is for byte\nmultiplexors. CVC (formerly FX) is for ESCON routed\nthrough an ESCON converter. CNC (formerly S) is for true\nESCON. CTC is an ESCON path used for channel-to-channel\ncommunications to another CPU on another system, to another\nLPAR, or to the other CPU of a dyadic processor. IOC is an\nintegrated I/O subsystem channel path. In this case, byte or\nblock multiplexor is determined from the I/O controller control\ninformation.\n\nThe first parameter of PARTITION=Jindicates the name of the\nLPAR that will use the channel. An optional second parameter,\nREC, indicates dynamic configuration support for the channel,\nallowing it to be configured to another partition. In S/370\nmode, REC is required and the channel will not work without\nit.\n\nCNTLUNIT\n\nCNTLUNIT has several keywords with missing letters, so care\nis required to get it right. A system of numbering controllers\nmust be invented and specified with the\nCUNUMBR= keyword. Each controller must be given a\nunique one to five digit hexadecimal number (0000-0FFF for\nVSE/ESA). For parallel (non-ESCON) control units,\nPROTOCL= specifies D for directly coupled, S for 3MBps,\nand S4 for 4.5 MBps. SHARED=N is the default for shared\nsubchannels - it means yes! Y means no and there is also a YB\nspecification. An appendix to the appropriate (they vary by\nCPU type) IOCP User's Guide indicates the correct values of\nthese parameters for each control unit type.\n\nPATH=Jindicates the CHPIDs of the channels to which the\ncontrol unit is attached. UNIT=Jis not checked by VSE, but is\nrequired by VM and MVS. It indicates the control unit type; eg\nUNIT=3880.\n\nUNITADD=Jindicates the two hexadecimal digit unit addresses\nof those I/O devices attached to this control unit. Because\ndevices are generally in clumps of sequentially numbered unit\naddresses, a short cut is provided to eliminate the need to list\neach device's unit address separately. A second parameter\nindicates the (decimal) number of sequentially numbered unit\naddresses. To accommodate this short cut, double parentheses\nare always required. The following are equivalent:\n\n      UNITADD=((10,4))\n      UNITADD=((10),(11),(12),(13))\n\nIODEVICE\n\nThe IODEVICE statement defines all of the I/O devices. The\nADDRESS=Jkeyword provides the same short cut that\nUNITADD=Jdoes. A single IODEVICE statement can be\ncoded for multiple identical devices having sequentially\nnumbered addresses. Only one set of parentheses is required,\nhowever, because only one set of addresses is permitted; eg\nADDRESS=(01F0,16)\n\nCUNUMBR= must match the CUNUMBR= specification on\nthe CNTLUNIT statement defining the controller to which this\ndevice is attached. This is a parenthesized list, usually of more\nthan one number because most I/O devices are attached to more\nthan one control unit for contingency purposes.\nUNIT=Jspecifies the device type. STADET=Jis ignored in\nS/370 mode, but used to specify whether the device is ESCON\n(Y) or parallel (N). The option PATH=Jspecification indicates\nthe CHPID of the preferred path; this performance option is\nused when a particular path is known to have lower usage.\n\n\nVSE/ESA DEVICE SPECIFICATION\n\nBringing all of this to the VSE/ESA environment, device\nnumbers are four hexadecimal digits in the range 0000 to 0FFF\nand are defined in the IOCP process. Running VSE/ESA in\nESA mode, ADD statements will be rejected if they contain the\nS parameter to indicate channel switching. Instead, channel\nswitching is defined through the IOCP statements described\nabove.\n\nTo ease migration, IBM strongly recommends that the device\nnumber defined in the IOCP match the current cuu address.\n\nRemember, IODEVICE is only specified once per device in an\nIOCP definition. This contrasts with previous versions of VSE\nwhere I/O devices were specified once for each path through\nwhich they could be accessed.\n\nFinally, it pays to overdefine. Devices not installed will be\nignored at IPL time. When new devices are added, if they can\nbe accommodated through previous over-definition, the outages\nrelated to installing and testing a new IOCP can be avoided.\n\nJon E Pearkins (Canada)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A04": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x07G\\x07G\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 1863, "newlines": 1863, "modlines": 0, "user": "VSEUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "E007A05": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xe1\\x00\\xe1\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 225, "newlines": 225, "modlines": 0, "user": "VSEUPDT"}, "text": "System unit record file reset\n\nThis program offers a solution to the problem that occurs when\na system unit record file, SYSRDR, SYSIPT, SYSPCH, or\nSYSLST, is reassigned to disk (or tape) and the job cancels\nleaving the system file opened to the wrong device or possibly\nunassigned.\n\nThis program uses a $JOBACCT exit program to scan the\nassignments for the first four LUBTAB positions and, when\nnecessary, reset the assignment using the MSAT macro.\n\nThe first time the program is executed in a partition it stores the\ncurrent assignments in the standard job accounting user save\narea. Subsequent executions compare the stored values with the\ncurrent assignment values. If an assignment (PUBTAB index)\nis not equal to the value stored during the first execution, the\nprogram uses the MSAT macro to set a new permanent\nassignment equal to the original assignment.\n\nThe program uses the 1K user save area provided when VSE is\nIPLed with job accounting support turned on. A minimal check\nis done to make sure we can use this area. The initial value of\nthe area is all X'00'. If the program finds a value other than hex\nzero or a flag value set by a previous execution of itself, it will\nexit back to job control.\n\nThe program works on a VSE/SP Release 3 system. I don't\nknow if it will work on any other versions/releases of VSE.\n\nThe supervisor must be IPLed with job accounting support.\n\nBe aware of any other job accounting exit programs. This\nprogram may cause problems for them. If you are using a\nspecialized $JOBACCT program already, be very careful when\nmerging this code with your existing program.\n\nThis program must be link edited into IJSYSRS.SYSLIB to\nreplace the IBM supplied $JOBACCT.\n\n\n\n         TITLE '$JOBACCT PROGRAM TO RESET SYS LUB ASSIGNMANTS AT EOJ'\n         PUNCH ' PHASE $JOBACCT,S,NOAUTO,SVA'\nJOBACCT CSECT\n         USING *,R12\n         B     JA0000                  JUMP AROUND EYECATCHER STUFF\n         DC    C'$JOBACCT - RESET UNIT RECORD PERM ASSIGNMENTS '\n         DC    C'MKOSANKE '\n         DC    C'02/22/92 '\n* +---------------------------------------------------------------+\n* | ADDRESS DATA AREAS USED BY THE PROGRAM                        |\n* | CHECK USER SAVE AREA, MAKE SURE WE CAN USE IT...              |\n* +---------------------------------------------------------------+\nJA0000   LR    R2,R15                  POINT R2 TO JOBACCT TABLE\n         USING JATABLE,R2              ADDRESS JOBACCT TABLE\n         USING JASAVEA,R13             ADDRESS JOBACCT SAVE AREA\n         CLC   JASFLAG,=D'0'           CHECK FLAG AREA FOR ZEROS\n         BE    JA0005                  CONTINUE PROCESSING\n         CLC   JASFLAG,SYSAFLAG        CHECK FOR OUR CODE\n         BNE   JA0099            EXIT, SOMEONE ELSE IS IN HERE???\n* +---------------------------------------------------------------+\n* | GETVIS FOR THE CCB USED LATER IN THE PROGRAM                  |\n* | ADDRESS PARTITION COMM REG                                    |\n* +---------------------------------------------------------------+\nJA0005   LA    R0,GSIZE                LOAD SIZE OF GETVIS\n         GETVIS LENGTH=(0)             GET SOME STORAGE\n         LR    R11,R15                 SAVE RETURN CODE, CHECK LATER\n         ST    R1,SAVEVIS              SAVE ADDRESS OF STORAGE\n         COMRG ,                       MAKE COMM REG ADDRESABLE\n         USING COMREG,R1               ADDRESS COMM REG\n         ST    R1,SAVER1               SAVE R1 VALUE FOR RESTORE\n* +---------------------------------------------------------------+\n* | MAKE SURE WE ARE AT THE END OF THE VSE JOB                    |\n* +---------------------------------------------------------------+\n         TM    CCODE,X'EF'             CODE = 10 (NORMAL EOJ)\n         BNZ   JA0010                  YES, GO CHECK STUFF\n         CLI   RECTYPE,C'L'            CHECK FOR LAST STEP\n         BNE   JA0095                  RETURN TO VSE\n* +---------------------------------------------------------------+\n* | GET INTO THE LUBTAB FOR THIS PARTITION                        |\n* | R3 USED AS WORK REGISTER                                      |\n* | R4 POINTS TO FIRST ENTRY IN SAVED VALUE TABLE                 |\n* | R5 POINTS TO FIRST SYS LUB (SYSRDR)                           |\n* | R7 USED AS A LOOP COUNTER AND WORK REGISTER                   |\n* | R8 HOLDS LOGUNIT VALUE FOR MSAT MACRO                         |\n* | R10 USED AS WORK REGISTER                                     |\n* +---------------------------------------------------------------+\nJA0010   LH    R7,PID                  PUT PIK IN R7\n         SRL   R7,4                    SHIFT HI ORDER TO LOW ORDER\n         LH    R3,FICLPT               FIRST IN CLASS POINTER\n         AR    R3,R7                   GET INDEX TO PROGRAMMER LUB\n         SR    R10,R10                 CLEAR R10 FOR NEW VALUE\n         IC    R10,0(R3)               GET INDEX FROM FICL\n         LH    R5,LUBPT                POINT TO LUBTAB\n         AR    R5,R10                  TWO BYTES PER LUB\n         AR    R5,R10                  NOW POINTS TO PROGRAMMER LUB\n         LH    R6,NICLPT               GET NEXT IN CLASS LIST POINTER\n         SR    R10,R10                 CLEAR WORK REG\n         IC    R10,0(R6)               POINT TO SYSLUBS\n         SR    R5,R10                  TWO BYTES PER LUB\n         SR    R5,R10                  POINTING TO SYSLUBS\n         LA    R8,0                    SET LOGUNIT IN MSAT MACRO\n         LA    R7,4                    SET LOOP COUNTER\n         LA    R4,STABLE               POINT TO CURRENT VALUES\nJA0020   STH   R8,0(R4)                SAVE LOGUNIT NUMBER\n         SR    R10,R10                 CLEAR WORK REG\n         IC    R10,0(R5)               GET SYSIPT OFFSET\n         STH   R10,2(R4)               SAVE INDEX TO PUB TAB\n         SLL   R10,3                   EACH ENTRY HAS 8 BYTES\n         LH    R15,PUBPT               POINT TO PUBTAB\n         AR    R15,R10                 ADD OFFSET INTO PUB\n         MVC   HALFWORD(2),0(R15)      SAVE CUU FOR CONVERT\n         UNPK  PRINTHEX(5),HALFWORD(3) SET 4 BYTES.\n         NC    PRINTHEX(4),=X'0F0F0F0F' KILL ZONE BITS\n         TR    PRINTHEX(4),HEXTRT      TRANSLATE TO CHAR.\n         MVC   4(4,R4),PRINTHEX        MOVE TO TABLE POSITION\n         LA    R5,2(R5)                POINT TO NEXT LUB ENTRY\n         LA    R4,8(R4)                POINT TO NEXT STABLE ENTRY\n         LA    R8,1(R8)                POINT TO NEXT LOGUNIT\n         BCT   R7,JA0020               LOOK AT NEXT LUB\n* +---------------------------------------------------------------+\n* | IF WE HAVE BEEN HERE BEFORE, CONTINUE AT JA0030               |\n* | OTHERWISE STORE THE CURRENT VALUES AND SET OUR FLAG           |\n* +---------------------------------------------------------------+\n         CLC   JASFLAG(8),SYSAFLAG     CHECK FOR OUR CODE\n         BE    JA0030                  GOOD STUFF, GO PROCESS\n         MVC   JASFLAG(8),SYSAFLAG     INSERT OUR CODE\n         MVC   JASASGN(32),STABLE      SAVE OUR PERM VALUES\n         B     JA0095                  WAIT FOR NEXT PASS\n* +---------------------------------------------------------------+\n* | RESET INDEXES TO CURRENT AND STORED VALUE TABLES..            |\n* +---------------------------------------------------------------+\nJA0030   LA    R7,4                    LOAD LOOP COUNTER\n         LA    R3,JASASGN              POINT TO STORED VALUES\n         LA    R4,STABLE               POINT TO CURRENT VALUES\n         LA    R9,SYSTABL              POINT TO SYS UNITS TABLE\n* +---------------------------------------------------------------+\n* | IF THIS ENTRY IS EQUAL TO STORED, CONTINUE AT JA0050          |\n* | OTHERWISE, ASSIGN LOGUNIT TO ORIGINAL PHYUNIT...              |\n* |            SET UP AND PRINT A MESSAGE                         |\n* +---------------------------------------------------------------+\nJA0040   CLC   2(2,R3),2(R4)           COMPARED STORED TO CURRENT\n         BE    JA0050                  GO LOOK AT NEXT ENTRY\n         MSAT  ID=NPM,LOGUNIT=(S,0(R3)),PHYUNIT=(S,2(R3))\n         LTR   R11,R11                 CHECK RETURN CODE FROM GETVIS\n         BNZ   JA0050                  GO EXIT ON NON-ZERO R11\n         MVC   AMSG+3(3),0(R9)         MOVE SYS NUM RDR IPT PCH LST\n         MVC   BMSG+3(3),0(R9)         MOVE SYS NUM RDR IPT PCH LST\n         MVC   AMSG+25(3),5(R4)        MOVE CURRENT CUU\n         MVC   AMSG+35(3),5(R3)        MOVE PERM CUU\n         MVC   BMSG+21(3),5(R3)        MOVE PERM CUU\n         LA    R2,LSTCCWA              GET REASSIGN MESSAGE ADDRESS\n         CLI   3(R4),X'FE'             CHECK FOR NA OR IGN IN LUBTAB\n         BL    JA0045                  GO USE REASSIGN MESSAGE\n         LA    R2,LSTCCWB              GET ASSIGN MESSAGE ADDRESS\nJA0045   L     R1,SAVEVIS              POINT R1 TO OUR STORAGE\n         MVC   0(GSIZE,R1),LSTCCB      PUT CCB IN VIS\n         STCM  R2,7,9(R1)              STICK MESSAGE ADDRESS INTO CCB\n         EXCP  (1)                     PRINT REASSIGN INFO LINE\n         WAIT  (1)\n* +---------------------------------------------------------------+\n* | POINT TO NEXT ENTRY AND LOOP BACK FOR ANOTHER CHECK           |\n* +---------------------------------------------------------------+\nJA0050   L     R1,SAVER1               RESET R1 TO COM REG\n         LA    R3,8(R3)                POINT TO NEXT STORED ENTRY\n         LA    R4,8(R4)                POINT TO NEXT CURRENT ENTRY\n         LA    R9,3(R9)                POINT TO NEXT SYS NUM\n         BCT   R7,JA0040               LOOK AT NEXT LUB\n* +---------------------------------------------------------------+\n* | FREE THE STORAGE WE REQUESTED EARLIER - AND EXIT TO JOB CTL   |\n* +---------------------------------------------------------------+\nJA0095   LTR   R11,R11                 CHECK RETURN CODE FROM GETVIS\n         BNZ   JA0099                  GO EXIT ON NON-ZERO R11\n         LA    R0,GSIZE                LOAD SIZE OF GETVIS\n         L     R1,SAVEVIS              LOAD VIS ADDRESS\n         FREEVIS LENGTH=(0)            RELEASE THE STORAGE\nJA0099   SR    R15,R15                 CLEAR RETURN CODE REGISTER\n         BR    R14                     RETURN TO CALLER\n* +---------------------------------------------------------------+\n* | CONSTANT AND VARIABLE STORAGE USED BY THIS PROGRAM            |\n* +---------------------------------------------------------------+\n         LTORG ,\n         DS    0D\nLSTCCB   CCB   SYSLST,*-*\nGSIZE    EQU   *-LSTCCB\nLSTCCWA  CCW   X'0B',*-*,X'40',1\n         CCW   X'01',AMSG,X'00',L'AMSG\nAMSG     DC    C'SYSXXX REASSIGNED FROM X''CUU'' TO X''CUU'''\nLSTCCWB  CCW   X'0B',*-*,X'40',1\n         CCW   X'01',BMSG,X'00',L'BMSG\nBMSG     DC    C'SYSXXX ASSIGNED TO X''CUU'''\nSAVEVIS  DS    F                  STORE ADDRESS FROM GETVIS\nSAVER1   DS    F                  STORE ADDRESS OF PART COMM REG\nHALFWORD DS    H                  USED TO CONVERT TO READABLE HEX\nPRINTHEX DS    CL5                USED TO CONVERT TO READABLE HEX\nHEXTRT   DC    C'0123456789ABCDEF' USED TO CONVERT TO READABLE HEX\nSYSTABL  DC    C'RDRIPTPCHLST'    LIST OF VALUES FOR DISPLAY\nSYSAFLAG DC    CL8'SYSASSGN'      FLAG OUR USER SAVE AREA\n* +---------------------------------------------------------------+\n* | JOB ACCOUNT TABLE                                             |\n* +---------------------------------------------------------------+\nJATABLE  CSECT\nJOBNAME  DS    D       JOB NAME\nUSERINFO DS    2D      JOB USER INFORMATION\nPARTID   DS    H       PARTITION ID\nCCODE    DS    X       STEP CANCEL CODE\nRECTYPE  DS    C       JA TABLE RECORD TYPE S OR L\n* +---------------------------------------------------------------+\n* | USER SAVE AREA                                                |\n* +---------------------------------------------------------------+\nJASAVEA  CSECT\nJASFLAG  DS    D       SAVE AREA FLAG\nJASASGN  DS    4D      NORMAL PERM ASSIGNS FOR RDR, IPT, PCH AND LST\nSTABLE   DS    4D      CURRENT PERM ASSIGNS FOR RDR, IPT, PCH AND LST\n* +---------------------------------------------------------------+\n* | COPY MEMBERS AND MACROS                                       |\n* +---------------------------------------------------------------+\n         MAPCOMR         MAPS COM REG\n         DFHREGS         REGISTER EQUATE <FROM CICS>\n         END JOBACCT\n\nMonte L Kosanke\nConsultant (USA)                        c Monte L Kosanke 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E007A06": {"ttr": 9739, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xa5\\x00\\xa5\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 165, "newlines": 165, "modlines": 0, "user": "VSEUPDT"}, "text": "Processing EXEC PARM values with COBOL\n\nOur application development group works with three different\noperating systems: MVS, VSE, and PC-DOS. In MVS and PC-\nDOS environments it is very simple in a COBOL program to\nhave access to the information passed in an EXEC PARM or in\nthe command line. You must only code a structure in the\nLINKAGE SECTION with a halfword length field and a field\nfor the character string. After entry to the PROCEDURE\nDIVISION the values are available.\n\nIn VSE it is not possible to get this information in COBOL.\nThe normal mainline routine in COBOL does not establish the\naddressability to the parameter present from VSE.\n\nThen I found an example Assembler program in the Calling\nand Called Programs chapter of the IBM DOS/VS COBOL\nCompiler and Library Programmers Guide (SC28-6478). Based\non this example I wrote the interface which is explained in this\narticle. This interface must be linked as an entry point for all\nCOBOL mainlines that will have access to EXEC parameter\nvalues in VSE. The COBOL LINKAGE SECTION is the same\nas in the other environments. In the PROCEDURE DIVISION\nwe must code a fixed named entry point before the first\nstatement (see sample program).\n\nAssembler interface routine\n\n// JOB UPXEPARC  COMPILE SUBROUTINE\n// OPTION DECK,SXREF\n// EXEC ASSEMBLY,SIZE=256K\nEPAR       TITLE 'UPXEPARC  -  CALL COBOL MAIN AS A SUBPROG'\n       SPACE 3\nUPXEPARC CSECT\n       SPACE 3\n*  REGISTER-USAGE\nR0        EQU   0\nR1        EQU   1      PARMLIST\nR2        EQU   2      WORKREG\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12      BASEREG\nR13       EQU   13      ADDRESS OF OWN SAVE AREA\nR14       EQU   14      RETURN ADDR / BALREG\nR15       EQU   15      ENTRY ADDR\n       EJECT\n       SAVE  (14,12)                  SAVE REGS IN CALLERS AREA\n       LR    R12,R15                  LOAD BASE ADDR\n       USING UPXEPARC,R12\n       B     BEGIN\n       DC    CL8'UPXEPARC'                 PROGRAM NAME\n* **       DC    C'&SYSDATE '              DATE OF ASSEMBLY\n* **       DC    C'&SYSTIME '              TIME OF ASSEMBLY\n       DC    C'AUTHOR: WILLI J. KUHN'\nBEGIN  DS    0H\n       ST    R13,SAVEAREA+4           SAVE PREVIOUS SAVEAREA ADDR\n       LR    R2,R13                   SAVE REG 13\n       LA    R13,SAVEAREA             LOAD OWN SAVEAREA ADDR\n       ST    R13,8(R2)                CHAIN IT TO PREVIOUS AREA\n       SPACE\n*  IF R1 = R15 - THERE IS NO EXEC PARAMETER\n*  IN THIS CASE LOAD A DUMMY FOR COBOL\n       CR    R1,R15                   COMPARE REGISTER\n       BNE   ILBDSET                  PARAMETER PRESENT\n       LA    R1,DUMMYP                ELSE LOAD DUMMY\n       SPACE\n*  CALL ILBDSET0 TO SET A SWITCH X'FF' IN ILBDMNS0\n*  THIS IS NECESSARY TO TELL COBOL TO ACT IN STANDARD LINKAGE\nILBDSET  L     R15,=V(ILBDSET0)       LOAD V-CONST\n       BALR  R14,R15                  AND CALL\n       SPACE\n*  NOW CALL THE COBOL MAIN ROUTINE\n*  THE COBOL PROGRAM MUST USE AN ENTRY NAMED IN THE FOLLOWING\n*  V-CONST AND A USING PARAMETER OR LIST.\n*  REG1 WILL BE UNCHANGED FROM THE INITIAL ENTRY OR POINT TO DUMMY\n       L     R15,=V(CBLEPAR)          LOAD V-CONST\n       BALR  R14,R15                  AND CALL\n       SPACE\nEXIT   DS    0H\n       L     R13,SAVEAREA+4\n       L     R14,12(R13)              LOAD RETURN ADDR\n       SPACE\n       RETURN (0,12)                  LEAVE RC IN R15 UNCHANGED\n       EJECT\n*  CONSTANTS/AREAS/LITERALS                                    *\nSAVEAREA DS    18F                    MAIN SAVE AREA\nDUMMYP DC    X'80'                    HIGH ORDER BIT ON\n       DC    AL3(NULLPARM)            ADDR NULL STRING\nNULLPARM DC    F'0'                   NULL STRING\n       SPACE 2\n       LTORG\n       SPACE 3\n       END\n/*\n/&\n\nSample COBOL program\n\n// JOB UPXCTMBP    COMPILE\n// OPTION CATAL\n   PHASE UPXCTMBP,*\n// EXEC FCOBOL\n CBL LIB,LANGLVL(2),APOST,NOADV,BUF=2048\n CBL CLIST,NOSEQ,SUPMAP,NOTRUNC,SXREF,DMAP\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. UPXCTMBP.\n       EJECT\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER. IBM-4381.\n       OBJECT-COMPUTER. IBM-4381.\n      *\n       SPECIAL-NAMES.\n         DECIMAL-POINT IS COMMA.\n      *\n       INPUT-OUTPUT SECTION.\n      *\n       FILE-CONTROL.\n      *\n       EJECT\n       DATA DIVISION.\n      *\n       FILE SECTION.\n      *\n       EJECT\n       WORKING-STORAGE SECTION.\n       77  PGRMID                 PIC X(8)       VALUE 'UPXCTMBP'.\n       EJECT\n       LINKAGE SECTION.\n       01  EXEC-PARM.\n         02 EXEC-PARM-LENGTH            PIC S9(4)  COMP.\n         02 EXEC-PARM-STRING.\n            03 EXEC-PARM-CHAR       PIC X\n                 OCCURS 0 TO 100 DEPENDING ON EXEC-PARM-LENGTH.\n       EJECT\n       PROCEDURE DIVISION.\n         ENTRY 'CBLEPAR' USING EXEC-PARM.\n         MOVE EXEC-PARM-LENGTH TO EXEC-PARM-LENGTH.\n         DISPLAY EXEC-PARM-LENGTH.\n         IF EXEC-PARM-LENGTH NOT = ZERO\n            DISPLAY EXEC-PARM-STRING.\n      *\n         STOP RUN.\n/*\n   INCLUDE UPXEPARC\n   ENTRY UPXEPARC\n// EXEC LNKEDT\n/&\n\nSample JCL for testing\n\n// JOB UPXCTMBP    TEST\n// EXEC UPXCTMBP,PARM='TEST-PARAMETER'\n/&\n\nWilli Kuhn\nFreelance Systems Programmer (Germany)            c Willi Kuhn 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A00I": {"ttr": 9988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\r\\x00\\r\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 13, "newlines": 13, "modlines": 0, "user": "VSEUPDT"}, "text": "E008 - VSE Update issue 8 December 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nE008A01   Displaying the VSE lock file\nE008A02   Using PDUMP from a high-level language program\nE008A03   'Super' directory of members in VSE libraries\nE008A04   POWER queue rotation and management\nE008A05   Which CPU?\nE008A06   POWER queue manipulation\nE008A07   Unique dynamic partition tables\nE008A08   Hardcopy job completion summary\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A01": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x02:\\x02:\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 570, "newlines": 570, "modlines": 0, "user": "VSEUPDT"}, "text": "Displaying the VSE lock file\n\nIn order to find out what is holding up a VSE machine, it is\nsometimes useful to know which machine is locking a\nresource. The following EXEC and module will present this\ninformation in a readable form.\n\nI had originally intended to convert the whole thing to\nAssembler after the logic was working correctly, but the\nperformance of the mixed REXX and Assembler seems to be\nacceptable. Because full tracks are read, we find that a three-\ncylinder lock file can be read in under half a minute.\n\nTo set up VSELOCK:\n\n1      Assemble FLOCK\n\n2      LOAD FLOCK\n\n3      GENMOD FLOCK (DOS\n\n4      Modify LINK machine and address in VSELOCK EXEC\n\n5      Add your virtual machine CPU-ids to VSELOCK in vmid\n\n6      Enter 'VSELOCK'.\n\n\nVSELOCK EXEC\n\n/*********************************\n* Read and display VSE lock file *\n*********************************/\n               ... change 2 lines for your installation ...\nowner = 'MAINT'      /* owner of Lock File in directory */\ncuu =  'F41'         /* virtual address   ,,     ,,     */\naddress COMMAND\n'ERASE VSE LOCK A'\n'EXECIO * CP (SKIP STRING DET 100'\n'EXECIO * CP (SKIP STRING LINK' owner cuu '100 RR READ'\n'AC 100 Z'\n'SET DOS ON'\n'ASSGN SYS000 Z'\n'DLBL LOCKFLE Z DSN DOS LOCK FILE (SYS000'\ncall 'FLOCK' 'LSTART','EXTENT'\nlcc = c2d(left(lstart,2))\nlhh = c2d(substr(lstart,3,2))\nfirstrec = 1         /* first record not yet read */\nlr = 0\neof = 0\ncall 'FLOCK' 'LREC.',lcc,lhh,'1' /* read Lock File descriptor */\nrec1 = lrec.1\ntrct = 1             /* count of tracks read */\nncpus = c2d(substr(rec1,3,2))    /* sharing machines  */\nnblk  = c2d(substr(rec1,7,2))    /* no of data blocks */\nnent  = c2d(substr(rec1,9,2))    /* entries per block */\nlent  = c2d(substr(rec1,11,2))   /* entry length      */\nrec#  = c2d(substr(rec1,15,2))   /* blocks per track  */\nreclim = rec#                    /* remember it       */\ntrck# = c2d(substr(rec1,17,2))   /* tracks per cyl.   */\nntracks = (nblk+1)/rec#          /* number of tracks  */\nrec# = lrec.0  /* no. of useful blocks on first track */\ncpulist = substr(rec1,12,ncpus*8)   /* all sharing CPU-ids */\nk = 0\ndo j=1 to ncpus*8 by 8        /* remember all ids */\n   cpuid.k = substr(cpulist,j+2,6)\n   cpuid.k = vmid(cpuid.k)    /* convert to virtual machine id */\n   k = k+1\nend\n         /**********************************\n         * Look at all blocks in lock file *\n         **********************************/\nlrec = readnext()    /* already seen first block (descriptor) */\ndo forever\n   lrec = readnext()\n   if eof then leave\n   bents = c2d(substr(lrec,3,2))     /* entries in this block */\n   if bents>0 then\n   do p=5 to 5+(bents-1)*lent by lent\n      rname = substr(lrec,p,12)     /* resource name */\n      do k=0 to ncpus-1\n         cpulock.k = '00'\n      end\n      do k=0 to ncpus-1\n         lflag = c2x(substr(lrec,p+12+k,1))\n         if lflag\u00ac='00'x then cpulock.k = lflag    /* some locking */\n         else cpulock.k = '00'\n      end\n      do k=0 to ncpus-1\n         if cpulock.k\u00ac='00' then 'EXECIO 1 DISKW VSE LOCK A0 (STRING' ,\n            left(rname,12) c2x(rname) left(cpuid.k,8) '  'opt(cpulock.k)\n      end\n   end\nend\n'SET DOS OFF'\n'EXECIO 0 DISKW VSE LOCK A0 (FINIS'\n'XEDIT VSE LOCK A (PROF XLOCK'\nexit rc\n/*********************\n* Return next record *\n*********************/\nreadnext:\nlr = lr+1            /* next record */\nif lr>rec# | firstrec then\ndo until lr\u00ac>rec# | eof      /* next track  */\n   if firstrec then\n   do\n      call 'FLOCK' 'LREC.',lcc,lhh,reclim\n      rec# = lrec.0\n   end\n   else\n   do\n      lr = 1\n      lhh = lhh+1\n      if lhh>trck#-1 then\n      do                /* next cylinder */\n         lhh = 0\n         lcc = lcc+1\n      end\n      trct = trct+1\n      if trct>ntracks then eof = 1  /* last track has been passed */\n      else call 'FLOCK' 'LREC.',lcc,lhh,reclim\n      rec# = lrec.0     /* number of blocks with anything useful  */\n   end\n   firstrec = 0\nend\nreturn lrec.lr\n/*********************************************************\n* Return lock options separated into LOCKOPT and CONTROL *\n*********************************************************/\nopt:\narg lopt .\nif left(lopt,1)='1' then control = 'E'\nelse control = 'S'\nreturn right(lopt,1)'     'control\n/***************************************************\n* Work out virtual machine name from serial number *\n***************************************************/\nvmid:\nparse arg id .\nif id='FFB100025890'x then return 'CICSA   '\nif id='FFA100025890'x then return 'CICSB   '\nif id='FFD100025890'x then return 'DOSTEST '\n         ... put all your machines' cpu ids here ...\nif id='FF1800925890'x then return 'DYNAMCMS'\nreturn c2x(left(id,4))    /* can't find this one, use cpu-id */\n\n\nXLOCK XEDIT\n\n/********************************************\n* Profile for editing VSE lock file display *\n********************************************/\naddress XEDIT\n'SET SCALE OFF'\n'SET PREFIX OFF'\n'SET TOFEOF OFF'\n'SET PREFIX NULLS'\n'SET RESERVED 3 H' ,\n'      <---------- Resource name ----------> Machine  Lock  Control'\n'SET RESERVED 4 H' ,\n'      <-- char --> <---- hexadecimal ----->  name   Option'\n'SET CURLINE ON 5'\n'SET LINEND OFF'\n'SET PF1 HELP RESNAMES'\n'SET PF4 TOP#SORT * A 1 12 39 46'       /* sort by resource name */\n'SET PF5 TOP#SORT * A 39 46 1 12'       /* sort by machine name  */\n'SET LINEND ON;\n'SET RESERVED -3 H' ,\n'PF1: Help    PF4: Sort by resource    PF5: Sort by machine'\n'SORT * A 1 12 39 46'                   /* sort by resource name */\n\n\nRESNAMES HELPCMS\n\n            +-----------------------+\n            |                       |\n            | Common resource names |\n            | on VSE lock file      |\n            |                       |\n            +-----------------------+\n\nResource name      Meaning\n-------------      -------\nAvvvvvv...\n         The VTOC on volume \"vvvvvv\" is locked, probably\n         during an OPEN. One machine waiting for a reply to\n         an overlap message will lock out other OPENs to the\n         same volume. This is a good reason not to have\n         duplicate vol-ids on mini-disks used by VSE machines\n         sharing a lock file if they are defined as SHR in\n         the IPL procedure.\nCvvvvvv...\n         LIBR has locked a library on volume \"vvvvvv\" during\n         an update.\nIJQFLEvvvvvv..\n         The POWER Q file on volume \"vvvvvv\" is locked,\n         normally for only a couple of seconds, whilst one\n         sharing system is updating or scanning it.\nVvvvvvv....\n         VSAM has locked something on volume \"vvvvvv\". These\n         resource names will usually take up 99% of the lock\n         file.\n\n         ****************************************************\n         * For full information on the rest of the resource *\n         * name see the appropriate logic manuals.          *\n         ****************************************************\n\n            +--------------+\n            |              |\n            | Lock Options |\n            |              |\n            +--------------+\n\n+----------------------------------------------------------------+\n| LOCKOPT|CONTROL  |      Meaning                                |\n|--------+---------+---------------------------------------------|\n|    1   |   E     |   No other user is allowed concurrent use   |\n|        |---------+---------------------------------------------|\n|        |   S     |   Other 'S' users allowed concurrent use,   |\n|        |         |   but no concurrent 'E' user allowed        |\n|--------+---------+---------------------------------------------|\n|    2   |   E     |   No other 'E' user gets concurrent use,    |\n|        |         |   but other 'S' users allowed               |\n|        |---------+---------------------------------------------|\n|        |   S     |   Other 'S' users allowed and, in addition, |\n|        |         |   one 'E' user is allowed                   |\n|--------+---------+---------------------------------------------|\n|    4   |   E     |   No other 'E' user from another system is  |\n|        |         |   allowed. However, other 'S' users from    |\n|        |         |   other systems may have concurrent use.    |\n|        |---------+---------------------------------------------|\n|        |   S     |   Other 'S' users and, in addition, one 'E' |\n|        |         |   user from another system is allowed.      |\n+----------------------------------------------------------------+\n\n\nFLOCK ASSEMBLE\n\nFLOCK    TITLE 'READ FROM VSE LOCK FILE ON 100 AND RETURN RECORDS'\n**********************************************************************\n* FLOCK is called in the following ways from REXX:                   *\n*      1.  CALL FLOCK VAR,EXTENT                                     *\n*                returns the start extent for lock file as cccc hh r *\n*                                                                    *\n*                          'EXTENT' is literal                       *\n*                                                                    *\n*      2.  CALL FLOCK VAR,CCCC,HH,BLOCKS                             *\n*                returns a track at disk address CCC HH on           *\n*                device address 100 and puts all records with lock   *\n*                information into stem variable VAR.                 *\n*                BLOCKS is how many blocks to read.                  *\n*                                                                    *\n*        NB   'VAR' is a REXX variable name and must be in quotes.   *\n*             to be more efficient 'FLOCK' should be in quotes.      *\n*             these pairs of quotes must be separate:                *\n*             eg 'FLOCK' 'LREC',cc,hh,nrec                           *\n*                                                                    *\n* Macros used are DIAG and REGEQU    (in DMSGPI and DMSOM if VM/XA)  *\n**********************************************************************\n                                                  SPACE\nFLOCK    CSECT\n         USING *,R12\n         LR    R12,R15             SET UP BASE REGISTER\n         ST    R14,SAVRET\n         LR    R13,R0              BASE FOR EXTENDED FUNCTION PLIST\n         USING EFPLIST,R13\n                                                  SPACE\n         L     R1,EARGLIST\n                                                  SPACE\n*           GET VARIABLE NAME\n         LM    R5,R6,0(R1)         VARIABLE NAME & LENGTH\n         BCTR  R6,R0               EXECUTE LENGTH\n         EX    R6,MVVAR            MOVE VARIABLE TO OUR AREA\n         LA    R6,VNAME+1(R6)      BYTE AFTER VARIABLE NAME\n         ST    R6,AVEND            SAVE ADDRESS\n         MVC   SHVNAML,4(R1)       MOVE LENGTH\n         MVC   SAVNAML,4(R1)       SAVE ELSEWHERE\n                                                  SPACE\n*           CHECK FOR EXTENT REQUEST\n         LM    R5,R6,8(R1)         CYL. NO & LENGTH\n         CLC   EXTENT,0(R5)        BRANCH IF\n         BE    QEXTENT              EXTENT REQUESTED\n                                                  SPACE\n*           GET CYLINDER NUMBER\n         BCTR  R6,R0               EXECUTE LENGTH\n         EX    R6,PACKW            PACKED CYL.\n         CVB   R6,DWORK            HEX CYL.\n         STCM  R6,B'0011',CC       PUT INTO DISK ADDRESS\n                                                  SPACE\n*           GET HEAD NUMBER\n         LM    R5,R6,16(R1)        HEAD NO & LENGTH\n         BCTR  R6,R0               EXECUTE LENGTH\n         EX    R6,PACKW            PACKED HEAD\n         CVB   R6,DWORK            HEX HEAD\n         STCM  R6,B'0011',HH        PUT INTO DISK ADDRESS\n                                                  SPACE\n*           GET NO OF RECORDS TO READ\n         LM    R5,R6,24(R1)        RECORD COUNT & LENGTH\n         BCTR  R6,R0               EXECUTE LENGTH\n         EX    R6,PACKW            PACKED COUNT\n         CVB   R6,DWORK            HEX COUNT\n         STH   R6,RLIMIT           PUT INTO REC. COUNTER\n                                                  SPACE\n                                                  EJECT\n*        **************************************************\n*        * READ THE REQUESTED NUMBER OF RECORDS ON A TRACK*\n*        * THE RECORDS WILL BE RETURNED IN STEM VARIABLES *\n*        **************************************************\n                                                  SPACE\n         LA    R2,DEVADDR          DEVICE ADDRESS\n         LA    R3,CCWS             READ CCW CHAIN\n         SLA   R6,3                MULTIPLY NO. OF BLOCKS\n         LA    R7,READCCWS-8(R6)    BY LENGTH OF CCW\n         NI    4(R7),X'FF'-X'40'   UNCHAIN NTH READ CCW\n         DIAG  R2,R3,X'20'         DO GENERAL I/O\n         BNZ   QERROR              SOMETHING WRONG\n                                                  SPACE\n         LA    R7,BUFFER1          FIRST RECORD\n         LH    R8,RLIMIT           RECORDS PER TRACK\nQRECOUT  EQU   *\n         NC    2,(2,R7),2(R7)      IF THESE BYTES ARE ZERO THEN\n         BZ    QNORET               THERE IS NOTHING IN THE BLOCK\n                                                  SPACE\n         L     R9,CURSTEM          ADDRESS OF CURRENT STEM NO.\n         L     R3,AVEND            WHERE TO PUT IT\n         MVC   0(R3,3),0(R9)       MOVE \".NN\" TO VARIABLE NAME\n         L     R2,SAVNAML          GET VARIABLE LENGTH\n         SR    R0,R0\n         IC    R0,2(R9)            LENGTH OF N OR NN\n         AR    R2,R0               ADD THIS TO ORIGINAL LENGTH\n         LA    R1,L'BUFFER1        RECORD LENGTH\n         BAL   R10,QRETVAR         RETURN VARIABLE\n                                                  SPACE\n         LA    R9,3(R9)           NEXT STEM NO.\n         ST    R9,CURSTEM          REMEMBER IT\nQNORET   EQU   *\n         LA    R7,L'BUFFER1(R7)    NEXT RECORD\n         BCT   R8,QRECOUT          LOOK AT ALL RECORDS\n                                                  SPACE\n*        ***************************************\n*        * RETURN NUMBER OF VARIABLES IN VAR.0 *\n*        ***************************************\n         L     R7,CURSTEM          NEXT STEM NUMBER ADDRESS\n         BCTR  R7,R0               LESS 3 FOR\n         BCTR  R7,R0                HIGHEST ONE\n         BCTR  R7,R0                 RETURNED\n         AR    R2,R0               ADD THIS TO ORIGINAL LENGTH\n         SR    R1,R1\n         IC    R1,2(R7)            LENGTH OF N OR NN\n         L     R2,SAVNAML          LENGTH OF VAR.\n         LA    R2,1(R2)            LENGTH OF VAR.0\n         L     R3,AVEND            WHERE TO PUT \"0\"\n         MVI   0(R3),C'0'          SET UP VAR.0\n         BAL   R10,QRETVAR         HOW MANY VARIABLES RETURNED\n                                                  SPACE 2\n*               ******************\n*               * EXIT TO CALLER *\n*               ******************\n         L     R14,SAVRET          RETURN\n         BR    R14\n                                                  EJECT\n***************************************************\n*        RETURN DATA INTO REXX VARIABLE           *\n*                                                 *\n*          R7  = ADDRESS OF DATA                  *\n*          R1  = LENGTH OF DATA                   *\n*          R10 = RETURN ADDRESS                   *\n*          R2  = LENGTH OF VARIABLE NAME IN VNAME *\n***************************************************\n                                                  SPACE\nQRETVAR  DS    0H\n         ST    R7,SHVVALA          ADDRESS OF VALUE\n         ST    R1,SHVVALL          LENGTH OF VALUE\n         ST    R2,SHVNAML          LENGTH OF VARIABLE NAME\n         LA    R0,RFPLIST          PARAMETER LIST\n         L     R1,ADNAME           SET UP TO CALL 'EXECCOM'\n         SVC   202\n         DC    AL4(1)\n         LTR   R15,R15\n         BM    QERROR\n         BR    R10                 RETURN\n                                                  SPACE\nAVEND    DC    A(0)    ADDRESS OF END OF VARIABLE NAME\nMVVAR    MVC   VNAME(0),0(R5)\nVNAME    DC    CL16' '\nCOMMNAME DC    CL8'EXECCOMM'\nADNAME   DC    0A(0),X'02',AL3(COMMNAME)\n                                                  SPACE\n*        EXTENDED PLIST TO CALL EXECCOMM\nRFPLIST  DS    0D\nRCOMVERB DC    A(COMMNAME)\nRBEGARGS DC    F'0'\nRENDARGS DC    F'0'\nRFBLOCK  DC    A(SHVBLOK)\nRARGLIST DC    F'0'\nRFUNRET  DC    F'0'\n                                                  SPACE\nSHVBLOK  DS    0D     SHARED VARIABLE PLIST ELEMENT\nSHVNEXT  DC    A(0)          CHAIN POINTER\nSHVUSER  DC    F'0'          PRIVATE USE\nSHVCODE  DC    C'S'          FUNCTION CODE (SET VARIABLE)\nSHVRET   DC    X'00'         RETURN CODE\n         DC    H'0'\nSHVBUFL  DC    F'0'          LENGTH OF'FETCH' VALUE BUFFER\nSHVNAMA  DC    A(VNAME)      ADDRESS OF VARIABLE NAME\nSHVNAML  DC    F'0'          LENGTH OF VARIABLE NAME\nSHVVALA  DC    A(0)          ADDRESS OF VALUE BUFFER\nSHVVALL  DC    F'0'          LENGTH OF VALUE BUFFER\nSHVBLEN  EQU   *-SHVBLOK     LENGTH OF BLOCK\nSAVNAML  DC    F'0'          LENGTH OF VARIABLE NAME AS SUPPLIED\n                                                  SPACE\n******************************************************\n* A TABLE OF NUMBERS IS USED RATHER THAN WORKING     *\n* THEM OUT BECAUSE THE STORAGE USED IS IRRELEVANT    *\n* AND FEWER INSTRUCTIONS ARE NEEDED                  *\n*----------------------------------------------------*\n* INCREASE STEMNOS TABLE FOR LARGER TRACKS THAN 3380 *\n******************************************************\nCURSTEM  DC    A(STEMNOS)\n         DC    C'0 ',X'1'\nSTEMNOS  DC    C'1 ',X'1',C'2 ',X'1',C'3 ',X'1',C'4 ',X'1',C'5 ',X'1'\n         DC    C'6 ',X'1',C'7 ',X'1',C'8 ',X'1',C'9 ',X'1',C'10',X'2'\n         DC    C'11',X'2',C'12',X'2',C'13',X'2',C'14',X'2',C'15',X'2'\n         DC    C'16',X'2',C'17',X'2',C'18',X'2',C'19',X'2',C'20',X'2'\n         DC    C'21',X'2',C'22',X'2',C'23',X'2',C'24',X'2',C'25',X'2'\n         DC    C'26',X'2',C'27',X'2',C'28',X'2',C'29',X'2',C'30',X'2'\n         DC    C'31',X'2',C'32',X'2',C'33',X'2',C'34',X'2',C'35',X'2'\n         DC    C'36',X'2',C'37',X'2',C'38',X'2',C'39',X'2',C'40',X'2'\n         DC    C'41',X'2',C'42',X'2',C'43',X'2',C'44',X'2',C'45',X'2'\n         DC    C'46',X'2'\n                                                  EJECT\n************************************************\n*          OPEN FILE TO GET EXTENT INFORMATION *\n************************************************\n                                                  SPACE\nQEXTENT  DS    0H\n         CNOP  0,4\n         LA    R1,=C'$$BOPEN '     OPEN LOCKFLE\n         BAL   R0,SVC02\n         DC    A(LOCKFLE)\nSVC02    SVC   2                   'SET DOS ON' FOR THIS\n                                                  SPACE\n         MVC   STEXTENT,LOCKFLES+2 GET START OF EXTENT FROM DTF\n         LA    R7,STEXTENT\n         LA    R1,L'STEXTENT\n         L     R2,SAVNAML          LENGTH OF VARIABLE NAME\n         BAL   R10,QRETVAR         RETURN EXTENT INFO\n         L     R14,SAVRET          RETURN TO CMS\n         BR    R14\n                                                  SPACE 3\nLOCKFLE  DC    0D'0'               BASIC DTFSD\n         DC    5F'0'               CCB ETC.\n         DC    X'20'               DTF TYPE\n         DC    X'02'               INPUT FILE\n         DC    CL7'LOCKFLE'\n         DC    XL107'00'           PADDING\nLOCKFLES EQU   LOCKFLE+58   SEEK ADDRESS OF START OF EXTENT\n                                                  SPACE 3\nSTEXTENT DS    XL5\nEXTENT   DC    C'EXTENT'\n                                                  EJECT\n***********************************************************\n*          ERROR ROUTINE                                  *\n*   ALL ERRORS WILL CAUSE A NULL VALUE TO BE RETURNED     *\n*                                                         *\n*   R15 IS NEGATIVE FOR ERRORS FROM EXECCOM               *\n*   R15 = 3 FOR WRONG LENGTH RECORD                       *\n*   SEE MANUAL FOR OTHER I/O ERRORS FROM DIAG X'20'       *\n***********************************************************\n         SPACE\nQERROR   DS    0H\n         SR    R1,R1               ENSURE NULL VALUE RETURNED\n         L     R2,SAVNAML          LENGTH OF VARIABLE NAME\n         BAL   R10,QRETVAR          TO EXEC\n         L     R14,SAVRET          RETURN TO CMS\n         BR    R14\n                                                  EJECT\nDWORK    DS    D\nSAVRET   DC    F'0'       R14 ON ENTRY\nRLIMIT   DC    Y((CCWSEND-READCCWS)/8)\nPACKW    PACK  DWORK,0(0,R5)\nDEVADDR  EQU   X'0100'             DEVICE ADDRESS\n                                                  SPACE\nBBCCHHR  DS    0XL7                DISK ADDRESS\n         DC    X'0000'\nCC       DS    XL2\nHH       DS    XL2\nR        DC    X'01'\n                                                  SPACE\n**********************************************************\n* CHANGE NUMBER OF READ CCWS FOR LARGER TRACKS THAN 3380 *\n**********************************************************\nCCWS     CCW   7,BBCCHHR,X'40',6\n         CCW   X'31',CC,X'40',5\n         CCW   8,*-8,0,0\nREADCCWS CCW   6,BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+1*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+2*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+3*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+4*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+5*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+6*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+7*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+8*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+9*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+10*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+11*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+12*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+13*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+14*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+15*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+16*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+17*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+18*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+19*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+20*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+21*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+22*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+23*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+24*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+25*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+26*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+27*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+28*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+29*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+30*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+31*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+32*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+33*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+34*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+35*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+36*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+37*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+38*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+39*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+40*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+41*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+42*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+43*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+44*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+45*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+46*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+47*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+48*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+49*L'BUFFER1,X'40',L'BUFFER1\n         CCW   6,BUFFER1+50*L'BUFFER1,X'40',L'BUFFER1\nCCWSEND  EQU   *\n                                                  SPACE\n         LTORG\n         REGEQU\n                                                  SPACE 5\n*        ENSURE I/O BUFFERS START ON A 1K BOUNDARY\n*        SO THAT NONE CROSSES A PAGE BOUNDARY\n         ORG   FLOCK+1024*((*+1023-FLOCK)/1024)\nBUFFER1  DS    0CL512   STORAGE PASSED THIS IS USED FOR MORE BUFFERS\n                                                  SPACE 3\nEFPLIST  DSECT\nECOMVERB DS    F\nEBEGARGS DS    F\nEENDARGS DS    F\nEFBLOCK  DS    F\nEARGLIST DS    F\nEFUNRET  DS    F\n         END\n\nJohn Illingworth\nEmpire Stores (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E008A02": {"ttr": 10244, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00=\\x00=\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 61, "newlines": 61, "modlines": 0, "user": "VSEUPDT"}, "text": "Using PDUMP from a high-level language program\n\nThe Assembly language macro PDUMP allows a program to\ndisplay current register contents and a range of storage on\nSYSLST without cancelling the program, and can be a very\nhelpful tool during program development and testing. For\nexample, when a certain condition occurs, a program could use\nPDUMP to display a record or an area of working storage, and\ncontinue processing. The programmer needs to provide only\nthe start and end address of the area of storage to be displayed.\nPDUMP prints that area on SYSLST in dump format. In an\nAssembly language program, a 20-byte storage area could be\nPDUMPed by coding the instruction:\n\n      PDUMP  FIELD.FIELD+19\n\nSince programs written in a high-level language such as\nCOBOL or RPG cannot call Assembly language macros\ndirectly, a relocatable subroutine such as the following can be used.\n\n         TITLE 'JHRPDUMP - ISSUE DOS PDUMP MACRO'\n         PUNCH ' CATALR JHRPDUMP'\nJHRPDUMP START  0\n         USING  JHRPDUMP.15\n         SAVE   (14,12)\n         LM     1,2,0(1)\n         PDUMP  (1),(2)\n         RETURN (14,12)\n         END\n\nIn a COBOL program, a portion of WORKING-STORAGE\nmight be dumped as illustrated below. The area displayed is\nfrom the first byte of FIRST-FIELD to the first byte of LAST-FIELD.\n\nWORKING-STORAGE SECTION.\n\n77  FIRST-FIELD      PIC X(9).\n77  COMP-3-DATA      PIC S9(5) COMP-3.\n77  MORE-DATA        PIC X(20).\n77  LAST-FIELD       PIC X(5).\n\nPROCEDURE DIVISION.\n\n    CALL 'JHRPDUMP' USING FIRST-FIELD LAST-FIELD.\n\nPDUMP displays its output on SYSLST. If it is not desirable to\nhave a dump appear in the middle of the program's report\noutput, the program's printer file should be assigned to a\nprogrammer logical unit other than SYSLST, for example\nSYS005. SYS005 can then be assigned to a virtual printer\nspooled by POWER, but not the printer SYSLST is assigned\nto, and a separate POWER LST card can be coded for each\nprinter. For example:\n\n* $$ LST CLASS=A,DISP=H\n* $$ LST CLASS=A,DISP=H,LST=FFE\n// ASSGN SYS005,FFE\n\nJames E Holler\nLittle Blue Systems (USA)                         c Little Blue Systems 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A03": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\x11\\x01H\\x01H\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:11:21", "lines": 328, "newlines": 328, "modlines": 0, "user": "VSEUPDT"}, "text": "'Super' directory of members in VSE libraries\n\nMany times there is a need to determine in which library a\nspecific member resides, or how many copies of a member\nexist in multiple libraries, or whether, in fact, there are\nmultiple copies of a member. The Librarian (LIBR) provided\nwith VSE is partially helpful in answering these questions, but\nprovides no comprehensive listing of all members in all\nlibraries. You must do individual LISTDIR commands on each\nlibrary, then scan each listing for the desired member.\n\nThe following two programs will provide a single\ncomprehensive, alphabetical '3-up' listing of all members in\nmultiple libraries with an indication of any duplications.\n\nThe first program is an Assembler program that CALLs the\nLibrarian through the Librarian call interface, which is\ndocumented in the Diagnosis Reference: Librarian manual. The\nprogram contains a list of LD commands at label\nCOMMANDS. This list should be modified as needed to\nprovide a list of libraries to be processed. This program will\nexecute an 'LD L=lib O=SH' command for each library in the\nlist in turn, and write the output print line to a sequential disk\nfile.\n\nThe second program is a COBOL program that reads the file\ncreated by the first program, sorts the members into global\nalphabetical sequence, and prints a report listing all members in\nall libraries scanned.\n\nAn example of the output is shown in Figure 1.\n\n\nLIBGET PROGRAM\n\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* PROGRAM: LIBGET                                                     *\n*                                                                     *\n* PURPOSE: INVOKES LIBR AND ISSUES SUCCESSIVE LISTDIRS, DIRECTING     *\n*          THE OUTPUT TO A SEQUENTIAL FILE FOR PROCESSING BY SUPDIR.  *\n*                                                                     *\n* INPUT:   ADDRESS OF PARAMETER LIST IS PASSED TO LIBR.  CONTENT      *\n*          OF THIS LIST IS EXPLAINED BELOW.                           *\n*                                                                     *\n* SPECIAL: WE LOAD LIBR INTO THE END OF THE PARTITION. THIS WILL      *\n*          ALLOW GETVIS AND CDLOAD REQUESTS TO BE ISSUED WITHOUT      *\n*          OVERLAYING THE LIBR CODE. 32K SHOULD BE ENOUGH FOR         *\n*          THIS. IF YOUR PARTITION DEFAULT GETVIS IS KEPT SMALL,      *\n*          YOU MAY NEED TO USE \"EXEC TESTLIBR,SIZE=(TESTLIBR,32K)\".   *\n*                                                                     *\n* INFO:    MACRO \"REGEQU\" GENERATES R0-R15 REGISTER EQUATES.          *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         PRINT NOGEN\nLIBGET   START 0                   START OF PROGRAM\n         BALR  R11,0               SETUP THE BASE\n         USING *,R11               ADDRESS PROGRAM\n         OPEN  SDISK\n         COMRG ,                   GET COMREG ADDRESS\n         L     R2,32(R1)           GET END OF PROGRAM STORAGE\n         LA    R2,1(R2)            GET JUST PAST THIS\n         S     R2,OFFSET           LIBR SHOULD BE AT THE TAIL END\n         LOAD  LIBR,(R2)           NOW LOAD IT\n         LR    R15,R1              SAVE ENTRY ADDRESS\n         LA    R1,PARM             POINT TO PARMS\n         BALR  R14,R15             CALL LIBR\n         LR    R3,R15              SAVE THE RETURN CODE\n         CLOSE SDISK\n         EOJ   RC=(R3)             AND TERMINATE\n* LIBR SYSLST EXIT ROUTINE\nLSTEXIT  SAVE  (14,12)             SAVE INCOMING REGS\n         BALR  R11,0               SETUP A NEW BASE\n         USING *,R11               AND TELL THE ASSEMBLER\n         ST    R13,SAVEAREA+4      SAVE SAVEAREA\n         LA    R2,SAVEAREA         POINT TO SAVEAREA\n         ST    R2,8(R13)           SAVE THE BACKPOINTER\n         LR    R13,R2              AND USE THIS SAVEAREA\n         PUT   SDISK,ALSTAREA\nEXITLST  L     R13,SAVEAREA+4      REGAIN POINTER\n         LM    R14,R12,12(R13)     REGAIN REGISTERS\n         BR    R14                 RETURN TO LIBR\n         DROP  R11\n* OTHER EXIT ROUTINES\nIPTEXIT  BR    R14                 RETURN TO LIBR\nCONEXIT  BR    R14                 RETURN TO LIBR\nPCHEXIT  BR    R14                 RETURN TO LIBR\n* -------------------- DATA AREA ---------------------------*\n         LTORG ,                   LITERAL POOL\n         REGEQU\nSAVEAREA DS    9D                  USER EXIT REGISTER SAVEAREA\nOFFSET   DC    F'307200'           AREA FOR LIBR INSERTION\nCOMMANDS DC    AL2(CMDEND-*),XL6'00'  HEADER FIELD FOLLOWED BY DATA\n         DC    CL80'LD L=PRD2 O=SH'\n         DC    CL80'LD L=PRD1 O=SH'\n         DC    CL80'LD L=IJSYSRS O=SH'\n* NOTE: Add as many libraries as needed - use same format\n*       as preceding lines.\n         DC    CL80'/*'            THIS ENTRY IS *REQUIRED*\nCMDEND   EQU   *                   USED FOR LENGTH CALCULATION\nPARM     DC    X'80',AL3(LIBRPARM) LIBR PARM ADDRESS\n         DS    0F                  ALIGNMENT\nLIBRPARM DC    AL2(PARMEND-*)      LENGTH OF CONTROL BLOCK\n         DC    XL6'00'             CALLER INFO WITH IBM FILE\n         DC    AL4(IPTEXIT)        SYSIPT EXIT ROUTINE\n         DC    AL4(COMMANDS)       ADDRESS OF COMMANDS\n         DC    AL4(CONEXIT)        SYSLOG EXIT\n         DC    AL4(LOGAREA)        ADDRESS OF SYSLOG DATA AREA\n         DC    AL4(LSTEXIT)        SYSLST EXIT\nALSTOUT  DC    AL4(ALSTAREA)       ADDRESS OF SYSLST DATA AREA\n         DC    AL4(PCHEXIT)        SYSPCH EXIT\n         DC    AL4(PCHAREA)        ADDRESS OF SYSPCH DATA AREA\n         DC    XL24'00'            FIELDS NOT USEFUL TO US\nPARMEND  EQU   *                   USED FOR LENGTH CALCULATION\nSDISK    DTFSD BLKSIZE=2428,                                           C\n               DEVADDR=SYS020,                                         C\n               IOAREA1=DSKAREA1,                                       C\n               RECFORM=FIXBLK,                                         C\n               RECSIZE=121,                                            C\n               WORKA=YES,                                              C\n               TYPEFLE=OUTPUT\nDSKAREA1 DS    CL2428\nALSTAREA DS    CL133               WORK AREA FOR SYSLST EXIT\nLOGAREA  DC    CL80' '             CONSOLE I/O AREA\nPCHAREA  DC    CL80' '             SYSPCH I/O AREA\n         END\n\n\nSUPDIR PROGRAM\n\n IDENTIFICATION DIVISION.\n PROGRAM-ID.    SUPDIR\n ENVIRONMENT DIVISION.\n CONFIGURATION SECTION.\n SOURCE-COMPUTER.  IBM-4381.\n OBJECT-COMPUTER.  IBM-4381.\n INPUT-OUTPUT SECTION.\n FILE-CONTROL.\n     SELECT IN-FILE ASSIGN TO SYS020-UT-3420-S-SDISK.\n     SELECT SORT-FILE ASSIGN TO SYS001-UT-FBA1-S-SORTWK1.\n     SELECT PRINT-FILE ASSIGN TO SYS012-UR-3203-S.\n     EJECT\n DATA DIVISION.\n FILE SECTION.\n FD  IN-FILE\n         BLOCK CONTAINS 20 RECORDS\n         LABEL RECORDS STANDARD\n         RECORDING MODE F.\n 01  IN-REC.\n     05 FILLER           PIC X(9).\n     05 IDENT            PIC X(17).\n     05 FILLER           PIC X(8).\n     05 IDENT2           PIC X(11).\n     05 LIBID            PIC X(16).\n     05 FILLER           PIC X(60).\n 01  DTL-REC.\n     05 FILLER           PIC X(9).\n     05 FILLER           OCCURS 3 INDEXED BY IN-FILE-IX.\n         10 MN           PIC X(8).\n         10 FILLER       PIC X.\n         10 MT           PIC X(8).\n         10 FILLER       PIC X(8).\n     05 FILLER           PIC X(37).\n SD  SORT-FILE\n         LABEL RECORDS STANDARD\n         RECORDING MODE F\n         RECORD CONTAINS 32 CHARACTERS.\n 01  SORT-REC.\n     05 SORT-KEY.\n         10 SORT-MN      PIC X(8).\n         10 SORT-MT      PIC X(8).\n         10 SORT-LIB     PIC X(16).\n FD  PRINT-FILE\n         LABEL RECORDS OMITTED\n         RECORDING MODE F.\n 01  PRINT-REC.\n     05 FIELD1       PIC X(37).\n     05 FILLER       PIC X(6).\n     05 FIELD2       PIC X(37).\n     05 FILLER       PIC X(6).\n     05 FIELD3       PIC X(37).\n WORKING-STORAGE SECTION.\n 01  MATRIX.\n     05 PAGE-LAYOUT      OCCURS 50 INDEXED BY LINE-IX.\n         10 FILLER           PIC X.\n         10 DATA-FIELD       OCCURS 3 INDEXED BY COL-IX.\n             15 MEMBER       PIC X(8).\n             15 POINT        PIC X.\n             15 MTYPE        PIC X(8).\n             15 FILLER       PIC X.\n             15 LIB          PIC X(16).\n             15 FILLER       PIC X.\n             15 DUPE         PIC X.\n             15 FILLER       PIC X(7).\n 01  FIELD-HDR       PIC X(37) VALUE\n     '----MEMBER----    LIB.SUBLIB      DUP'.\n 01  PAGE-HDR.\n     05 FILLER       PIC X(54) VALUE SPACES.\n     05 FILLER       PIC X(15) VALUE 'SUPER DIRECTORY'.\n     05 FILLER       PIC X(11) VALUE SPACES.\n     05 THIS-DATE    PIC X(8).\n     05 FILLER       PIC XX.\n     05 THIS-TIME    PIC 99B99B99.\n     05 COLONS REDEFINES THIS-TIME PIC X OCCURS 8.\n     05 FILLER       PIC X(16) VALUE SPACES.\n     05 FILLER       PIC X(5) VALUE 'PAGE '.\n     05 PG-COUNT     PIC Z(3)9.\n 01  PG-COUNTER      PIC 9(4) COMP VALUE 1.\n 01  DIR-FLAG        PIC X   VALUE 'Y'.\n     88 DIR-REQ      VALUE 'Y'.\n 01  EOF-FLAG        PIC X   VALUE 'N'.\n     88 EOF      VALUE 'Y'.\n 01  HOLD-LIB        PIC X(16).\n 01  OLD-KEY.\n     10 OLD-MN      PIC X(8).\n     10 OLD-MT      PIC X(8).\n     10 OLD-LIB     PIC X(16).\n PROCEDURE DIVISION.\n SORTING SECTION.\n 001-START.\n     SORT SORT-FILE ON ASCENDING KEY SORT-KEY\n         INPUT PROCEDURE IS SORT-INPUT\n         OUTPUT PROCEDURE IS PRINT-PROC.\n     STOP RUN.\n SORT-INPUT SECTION.\n 010-START.\n     OPEN INPUT IN-FILE.\n     PERFORM 015-GET-DATA UNTIL EOF.\n     CLOSE IN-FILE.\n     GO TO 099-EXIT.\n 015-GET-DATA.\n     IF DIR-REQ\n         PERFORM 080-READ UNTIL EOF\n             OR IDENT = 'DIRECTORY DISPLAY'.\n     IF IDENT = 'DIRECTORY DISPLAY'\n         PERFORM 050-PROCESS-DIR.\n     IF EOF\n         OR IDENT = SPACES\n         OR IDENT = ALL '-'\n         OR IDENT = 'L113I RETURN CODE'\n         MOVE 'Y' TO DIR-FLAG\n     ELSE\n         PERFORM 030-PROCESS-DATA.\n 030-PROCESS-DATA.\n     PERFORM 035-BUILD-SORT-REC\n         VARYING IN-FILE-IX FROM 1 BY 1\n           UNTIL IN-FILE-IX = 4.\n     PERFORM 080-READ.\n 035-BUILD-SORT-REC.\n     IF MN (IN-FILE-IX) NOT = SPACES\n         MOVE MN (IN-FILE-IX) TO SORT-MN\n         MOVE MT (IN-FILE-IX) TO SORT-MT\n         MOVE HOLD-LIB TO SORT-LIB\n         RELEASE SORT-REC.\n 050-PROCESS-DIR.\n     MOVE LIBID TO HOLD-LIB.\n     PERFORM 080-READ 6 TIMES.\n     MOVE 'N' TO DIR-FLAG.\n 080-READ.\n     READ IN-FILE AT END MOVE 'Y' TO EOF-FLAG.\n     IF IDENT = '1S55I  LAST RETUR'\n         MOVE 'Y' TO EOF-FLAG.\n 099-EXIT. EXIT.\n PRINT-PROC SECTION.\n 100-START.\n     OPEN OUTPUT PRINT-FILE.\n     MOVE 'N' TO EOF-FLAG.\n     MOVE CURRENT-DATE TO THIS-DATE.\n     MOVE TIME-OF-DAY TO THIS-TIME.\n     MOVE ':' TO COLONS (3) COLONS (6).\n     PERFORM 105-PRINT-REPORT UNTIL EOF.\n     CLOSE PRINT-FILE.\n     GO TO 199-EXIT.\n 105-PRINT-REPORT.\n     PERFORM 110-BUILD-PAGE VARYING COL-IX FROM 1 BY 1\n         UNTIL COL-IX = 4 OR EOF.\n     PERFORM 150-PRINT-PAGE.\n 110-BUILD-PAGE.\n     PERFORM 120-BUILD-LINE VARYING LINE-IX FROM 1 BY 1\n         UNTIL LINE-IX = 51 OR EOF.\n 120-BUILD-LINE.\n     PERFORM 180-RETURN.\n     IF NOT EOF\n         PERFORM 130-MOVE-TO-PAGE.\n 130-MOVE-TO-PAGE.\n     MOVE SORT-MN TO MEMBER (COL-IX LINE-IX).\n     MOVE SORT-MT TO MTYPE (COL-IX LINE-IX).\n     MOVE SORT-LIB TO LIB (COL-IX LINE-IX).\n     IF SORT-MN = OLD-MN AND SORT-MT = OLD-MT\n         MOVE '*' TO DUPE (COL-IX LINE-IX).\n     MOVE SORT-KEY TO OLD-KEY.\n 150-PRINT-PAGE.\n     MOVE PG-COUNTER TO PG-COUNT.\n     ADD 1 TO PG-COUNTER.\n     WRITE PRINT-REC FROM PAGE-HDR AFTER ADVANCING PAGE.\n     MOVE SPACES TO PRINT-REC.\n     MOVE FIELD-HDR TO FIELD1 FIELD2 FIELD3.\n     WRITE PRINT-REC AFTER ADVANCING 2.\n     MOVE SPACES TO PRINT-REC.\n     WRITE PRINT-REC AFTER 1.\n     PERFORM 160-PRINT-LINE VARYING LINE-IX FROM 1 BY 1\n         UNTIL LINE-IX = 51.\n     MOVE SPACES TO MATRIX.\n 160-PRINT-LINE.\n     WRITE PRINT-REC FROM PAGE-LAYOUT (LINE-IX) AFTER 1.\n 180-RETURN.\n     RETURN SORT-FILE AT END MOVE 'Y' TO EOF-FLAG.\n 199-EXIT. EXIT.\n\n\nSAMPLE JCL\n\n* $$ JOB JNM=SUPERDIR,CLASS=c,DISP=D,PRI=3,LDEST=*\n* $$ LST CLASS=c,DISP=D\n// JOB SUPERDIR\n// DLBL SDISK,'file.ident'\n// EXTENT SYS020, as needed\n// EXEC LIBGET\n// ASSGN SYS012,SYSLST\n* $$ LST LST=SYS012,CLASS=c\n// DLBL SDISK,'file.ident'\n// EXTENT SYS020, as needed\n// EXEC SUPDIR\n/&\n* $$ EOJ\n\nFrank A Braman\nSenior Software Specialist\nSt Johnsbury Trucking Company (USA)    c St Johnsbury Trucking Company 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E008A04": {"ttr": 10252, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\x87\\x00\\x87\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 135, "newlines": 135, "modlines": 0, "user": "VSEUPDT"}, "text": "POWER queue rotation and management\n\nThis program illustrates the use of the CTLSPOOL interface\nfor issuing POWER/VS commands from a batch program. The\nprogram can be used to alter and delete POWER LST, PUN,\nand RDR queues. Put this program in JCL that is executed\nevery day, for example back-ups.  A queue management\nroutine can be put into effect that will keep the POWER data\nfile from becoming full with old reports. The following JCL\nillustrates how to implement a one day rotation of POWER\nqueue class A.\n\n// JOB DAILYBK EXECUTED ONCE EVERYDAY\n.\n.\n// EXEC POWERCMD\nL LST,D                 DELETE ALL ENTRIES IN CLASS D\nA LST,A,CLASS=D         ALTER ALL CLASS A TO CLASS D\n/*\n.\n.\n\nAny valid POWER/VS RELEASE command will be accepted.\nA message is issued on the console when the command is\npassed to POWER/VS, and again when the command has been\nexecuted.\n\nPrerequisites:  the DOS/VS supervisor must specify support for\ncross partition event control blocks, ie 'XECB=YES', and\nPOWER must specify support for the CTLSPOOL interface, ie\n'SPOOL=YES'.\n\nPOWERCMD TITLE 'POWER COMMANDS / SYSIPT'\n         PUNCH '   PHASE   POWERCMD,S,NOAUTO      '\n         PUNCH '  INCLUDE  ,(POWERCMD)            '\n         PUNCH '  INCLUDE  ,(IJSYSLOG)            '\n         PUNCH '  INCLUDE  IJJFCIZD               '\n         PRINT NOGEN\nPOWERCMD START X'78'\nR5       EQU   5               BASE\nR8       EQU   8               BASE FOR SPLMAP\nR9       EQU   9               POWERCMD BASE REGISTER\nR10      EQU   10\nR7       EQU   7\nR0       EQU   0               POINTER\nR1       EQU   1               POINTER\n SPACE 2 TITLE 'POWERCMD - AUTOMATIC QUEUE MANAGEMENT FACILITY'\n         BALR  R9,0\n         BCTR  R9,0\n         BCTR  R9,0\n         USING POWERCMD,R9\n         B     START\n         DC    C'POWERCMD 1.0'\n         EJECT ,\nSTART    DS    0H\n* DEFINE THE XECB FOR POWER/VS COMMUNICATION\n         XECBTAB TYPE=DEFINE,XECB=SPMXECB,ACCESS=XWAIT\n* REGISTER 15 WILL CONTAIN THE RETURN CODE - SHOULD BE ZERO\n* REGISTER  1 WILL CONTAIN THE ADDRESS OF THE XECB\n* REGISTER 14 WILL CONTAIN THE ADDRESS OF THE TABLE ENTRY\n         LTR   15,15               DID XECB DEFINE OKAY ?\n         BNZ   XECBERR             IF NOT, ISSUE ERROR MSG\n*\n         OPENR CARD,CONS        OPEN DTF\nGETCARD  MVI   IOAREA1,C' '    CLEAR INPUT AREA\n         MVC   IOAREA1+1(L'IOAREA1-1),IOAREA1\n         GET   CARD                READ A CARD INTO IOAREA1\n* REVIEW THE TESTS BELOW TO EDIT THE COMMANDS YOU WISH TO ACCEPT\n         CLI   IOAREA1,C'L'             IS IT A DELETE COMMAND ?\n         BE    OK                       BRANCH IF YES\n         CLI   IOAREA1,C'R'             IS IT A RELEASE COMMAND ?\n         BE    OK                       BRANCH IF YES\n         CLI   IOAREA1,C'A'             IS IT AN 'ALTER' COMMAND ?\n         BNE   INVCMD                   NO, REJECT COMMAND\nOK       LA    R7,72                    SET LENGTH OF MESSAGE\n         MVC   PWRMSG1(71),IOAREA1      MOVE CARD TO OUTPUT AREA\n*=====>> PUT   CONS,PWRMSG              DISPLAY CARD READ ON CONSOLE\n         LA    R5,SPL1                  LOAD ADDRESS OF SPL\n         USING SPLMAP,R5\n         XC    SPPW,SPPW                SET PASSWORD TO 'MASTER'\nISSUE    CTLSPOOL SPL=(5),PBUF=IOAREA1,REQ=COMMAND   ISSUE COMMAND\n         CLI   SPMERROR,X'00'           TEST RETURN CODE FROM CTLSPOOL\n         BE    CONSOLE                  ACCEPT 00 RETURN CODE\n         CLI   SPMERROR,X'42'          TEST FOR 42 RETURN CODE AND\n         BE    CONSOLE                 ACCEPT IT\n         SPACE ,\n         LA    R7,64                   NOT VALID RETURN CODE, SO\n         MVC   PWRMSG1(71),IOAREA1      MOVE RESULT OF COMMAND\n         MVC   PWRMSG1+35(L'CMDERR),CMDERR\n         PUT   CONS,PWRMSG             SEND MESSAGE TO CONSOLE\n         B     GETCARD                 GO TRY NEXT CARD\n         SPACE ,\nCONSOLE  LA    R7,64                   LOAD LENGTH OF MESSAGE\n         MVC   PWRMSG1(71),IOAREA1      MOVE RESULT OF COMMAND\n         PUT   CONS,PWRMSG             DISPLAY RESULT ON CONSOLE\n         B     GETCARD                 GO READY ANOTHER COMMAND CARD\n         SPACE ,\nINVCMD   LA    R7,64                   ISSUE ERROR MESSAGE TO\n         MVC   PWRMSG1(71),IOAREA1      MOVE RESULT OF COMMAND\n         MVC   PWRMSG1+35(L'INVMSG),INVMSG\n         PUT   CONS,PWRMSG             CONSOLE, AND GET THE NEXT\n         B     GETCARD                 COMMAND CARD\n         SPACE ,\nXECBERR  DS    0H'0'                   XECB DID NOT DEFINE PROPERLY\n         LA    R7,38                   SO ISSUE ERROR MESSAGE TO\n         PUT   CONS,XERRMSG            CONSOLE AND EXIT PROGRAM\nEOJ      EOJ   ,\n         SPACE ,\nSPL1     SPL   TYPE=DEFINE,REQ=COMMAND,PBUF=IOAREA1   DEFINE SPL\n         PRINT NOGEN\nCONS     DTFCN  TYPEFLE=INPUT,DEVADDR=SYSLOG,IOAREA1=CONSWORK,         C\n               RECFORM=UNDEF,RECSIZE=(7),MODNAME=IJSYSLOG,             C\n               BLKSIZE=80,WORKA=YES\nCARD     DTFDI DEVADDR=SYSIPT,IOAREA1=IOAREA1,EOFADDR=EOJ,RECSIZE=80\nPWRMSG   DC    CL09'POWERCMD-'\nPWRMSG1  DC    CL71' '\nCONSWORK DC    CL80' '    CONSOLE WORK AREA\nIOAREA1  DC    CL80' '\n         DC    CL08' '     POWER/VS BUFFER MUST BE 88 BYTES\nXERRMSG  DC    CL38'POWERCMD FAILED DURING XECB DEFINITION'\nCMDERR   DC    C'ERROR DURING CTLSPOOL'\nINVMSG   DC    C'INVALID PARAMETER CARD FOUND'\nSPMXECB  DC    F'0'       XECB\nSPMERROR DC    XL1'00'    ERROR RETURN CODE\nSPMSPLP  DC    AL3(SPL1)  POINTER TO SPL\nLTORG    LTORG ,\nPOWERCMD CSECT ,\n         PRINT GEN\nSPLMAP   SPL   TYPE=MAP,SPMXECB=SPMXECB  SPL DSECT REQUIRED\n         END   ,\n\nRay Lightcap\nLead Systems Programmer\nCyCare Systems Inc (USA)                            c CyCare Systems Inc 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A05": {"ttr": 10498, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x00\\xbe\\x00\\xbe\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 190, "newlines": 190, "modlines": 0, "user": "VSEUPDT"}, "text": "Which CPU?\n\nWe have two real CPUs that have been termed production and\ntest, although there is not literally a true separation of test and\nproduction jobs. There are some jobs that must not run on a\ncertain machine. This program checks the CPU serial number\nand cancels a job if it is not running on the correct CPU. It will\nalso display the CPU-id if the PARM is incorrect.\n\nThis program was intended for use in prodution JCL at our\nshop to prevent operators from causing us more headaches!\n\nOur hardware is made up of two IBM 4381-2 CPUs, and IBM\n3380        DASD shared between the two processors.\n\n* $$ JOB JNM=RPDPSMNT,CLASS=P,PROGR=BUBBA,USER=SYSTEMS,SYSID=2\n* $$ LST DISP=H,CLASS=Z,JSEP=1,RBS=0,FNO=Z02D\n// JOB RPDPSMNT\n// OPTION JCANCEL,NODUMP                         CHKCPUID(ICCF31)\nLIBDEF PHASE,CATALOG=USR1.SYS\n// OPTION CATAL,SXREF,NORLD\n PHASE CHKCPUID,*\nEXEC PGM=ASSEMBLY,SIZE=512K\n         TITLE ' CHECK CPU-ID FOR TEST OR PRODUCTION'\nCHKCPUID CSECT\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n         BALR  R2,R0\n         BCTR  R2,R0\n         BCTR  R2,R0\n         USING CHKCPUID,R2\n         SPACE\n         TM    0(R1),X'80'         NULL PARM STRING ?\n         BZ    DISPLAY             YES, SKIP\n         L     R5,0(R1)            POINT TO PARM DATA\n         SLL   R5,8                CLEAR HIGH\n         SRL   R5,8                 ORDER BYTE\n         MVC   PARM,2(R5)          SAVE PARM DATA\n         BAL   R8,GETCPUID\n         CLC   PARM,=C'PROD'\n         BNE   *+4+6+4+4\n         CLC   PROD,CPUID+1\n         BNE   CANCEL\n         B     EOJ\n         CLC   PARM,=C'TEST'\n         BNE   PARMERR\n         CLC   TEST,CPUID+1\n         BNE   CANCEL\n         B     EOJ\n         EJECT\nGETCPUID LA    R10,10                  LENGTH\n         EXTRACT ID=CPUID,AREA=CPUSTOR,LEN=(R10)\n         MVC   CPUID(8),CPUSTOR\n         BR    R8\n         SPACE\nPARMERR  MVC   ERR+6(4),PARM\n         MVC   MSG,ERR\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         MVC   MSG,MSG-1\n         MVC   MSG(7),=C'CPU ID='\n         BAL   R8,GETCPUID\n         UNPK  MSG+7(9),CPUID(5)\n         UNPK  MSG+15(9),CPUID+4(5)\n         MVI   MSG+23,X'40'\n         TR    MSG+7(16),TBL\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         B     EOJ\n         SPACE\nDISPLAY  MVC   MSG,MSG-1\n         MVC   MSG(11),=C'CPU ID''S   '\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         MVC   MSG(11),PROD+3\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         MVC   MSG(11),TEST+3\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         B     EOJ\n         EJECT\nEXCP     SVC   0\n         TM    2(R1),X'80'\n         BO    0(R8)\n         SVC   7\n         SPACE 2\nCANCEL   MVC   MSG+33(4),PARM\n         LA    R1,CONSOLE\n         BAL   R8,EXCP\n         LA    R1,PRINTER\n         BAL   R8,EXCP\n         SR    R0,R0\n         SVC   6\n         SPACE\nEOJ      SVC   14\n         EJECT\n         LTORG\n         SPACE 2\n         DS    D\nCPUSTOR  DS    CL10\nCPUID    DS    D\n         SPACE\nCONSOLE  CCB   SYSLOG,CCW1\n         SPACE\nPRINTER  CCB   SYSLST,CCW1\n         SPACE\nCCW1     CCW   X'09',MSG,X'00',45\n         DC    X'40'\nMSG      DC    CL45'WRONG CPU!   RUN THIS JOB ON THE XXXX MACHINE'\nERR      DC    CL45'PARM=''NULL'' IS INVALID                       '\n         SPACE\nTEST     DC    XL3'013273',CL11'TEST=013273'\nPROD     DC    XL3'010713',CL11'PROD=010713'\nPARM     DC    CL4'    '          PROD OR TEST\n         SPACE\n         DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nTBL      EQU   *-256\n         SPACE\n         END\n/*\nEXEC PGM=LNKEDT,SIZE=256K\nEXEC PGM=CHKCPUID,SIZE=2K,PARM='OOPS'\n/&\n\n\nEXAMPLES\n\nThe first example shows the program's use with an invalid\nPARM.  This will display the full CPU-id of the CPU that\nexecuted CHKCPUID.\n\n// JOB RPDPSMNT\n// OPTION NODUMP,JCANCEL\nEXEC PGM=CHKCPUID,SIZE=2K,PARM='OOPS'\nPARM='OOPS' IS INVALID\nCPU ID=0001327343810000\n\nThe second example shows the use of CHKCPUID without any\nPARM.  This will display the serial number of each CPU.\n\nEXEC PGM=CHKCPUID,SIZE=2K\nCPU ID'S\nPROD=010713\nTEST=013273\n\nThe third example shows the use of the program to check the\nCPU-id.\n\n* $$ JOB JNM=RPDPSMNT,PRI=3,CLASS=P,PROGR=BUBBA,USER=SYSTEMS,SYSID=2\n* $$ LST DISP=H,CLASS=Z,JSEP=1,FNO=Z02D,RBS=0,RBM=0\n// JOB RPDPSMNT\n// OPTION NODUMP,JCANCEL                         DPS090R(ICCF11)\n/. STEP1     CATALOG DPS090R.J TO PWR.JCL AS OF 11-21-90\nEXEC PGM=LIBR,SIZE=512K,PARM='MSHP'\nACCESS SUBLIB=PWR.JCL\nCATALOG DPS090R.J                    REPLACE=YES\n// OPTION NODUMP,JCANCEL                         DPS090R.J(PWR.JCL)\nEXEC PGM=CHKCPUID,SIZE=2K,PARM='TEST'\n*          NO BATCH JOBS SHOULD BE RUNNING ON EITHER CPU WHILE THIS\n*          JOB IS PROCESSING !   THIS JOB IS NOT RESTARTABLE !\n// PAUSE   IF THIS JOB CANCELS FOR ANY REASON, CALL SYSTEMS !!!!!!!\nEXEC PGM=DATETIME,SIZE=AUTO,PARM='SYSLST'\n/. STEP0   SCRATCH AND DELETE WORK FILES\nEXEC PGM=TSIDMNT,SIZE=512K\nCLOSE   'BGP.DPS.SORT.WORK.1'\nSCRATCH 'BGP.DPS.SORT.WORK.1',VER=1\nCLOSE   'BGP.DPS.SORT.WORK.2'\nSCRATCH 'BGP.DPS.SORT.WORK.2',VER=1\n\nRobert Payne\nSystems Programmer\nMillers Insurance Group (USA)                 c Millers Insurance Group 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A06": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x16\\x05O\\x01\\x16\\x06/\\x13\\x11\\x03c\\x03b\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T13:11:48", "lines": 867, "newlines": 866, "modlines": 0, "user": "VSEUPDT"}, "text": "POWER queue manipulation\n\nThe purpose of this program is to create an output file from a\nlist in the POWER queue file, using cross-partition\ncommunication with POWER/VSE. The input cards are:\n\n      LSTIN=LISTNAME,NNNNN,CLASS=Q\n      LINENO=NNNNNNNN\n      STRING=/STRING/\n      ESTRNG=/STRING/\n      COUNT=NNNNNNNN\nFILEOUT=DDNAME,BLKSIZE=NNNNN,LRECL=NNNNN,SYSNO=SYSNNN\n\nLISTNAME is the input list name (required). NNNNN is the\njobnumber; the default is the first list with jobname. CLASS is\nthe list queue class; the default is 'Q'. LINENO is the line\nnumber at which to start; the default is 1. STRING means start\nwriting when a line contains a specified string; the default is\nnone, and it must be enclosed in the same non-blank\ncharacters. ESTRNG means stop writing when a line contains a\nspecified string; the default is none, and it must be enclosed in\nthe same non-blank characters. COUNT is the number of lines\nto write. DDNAME is the output DDNAME on the DLBL\nSTMT (required). BLKSIZE=NNNNN specifies the blocksize\n(default=80). LRECL=NNNNN specifies the record length\n(default=80). SYSNO=SYSNNN is the SYS number assigned\nin the extent and ASSGN statements; 'SYS' and leading zeroes\nmay be omitted; the default is SYS006. Specify 'fileout=print'\nto print the output file.\n\n\n\nNOTES\n\nAll keywords must begin in column 1, and the first keyword\nmust be LSTIN. If LINENO and STRING are specified, the\nstring searching starts from the line specified by LINENO. If\nCOUNT and ESTRNG are specified, writing stops when the\ncount is reached or ESTRNG is found, whichever comes first.\nIf this program is cancelled while processing, rerun the job\nwith LINENO=1 and COUNT=0 to reset everything. SYS004\nmust be assigned to a reader and SYS005 (messages) should be\nassigned to a printer or ignored.\n\n\nEXAMPLE\n\nThis job scans a listing containing CICS transaction dumps and\nprints the dump for transaction P18A.\n\n// JOB   SCANDUMP\n// ASSGN SYS005,E\n// ASSGN SYS004,00C\n// EXEC SCANLIST\nLSTIN=CICSDUMP,CLASS=Q\nINFOMSG=N\nLINENO=1\nSTRING=*TASK=P18A*\nESTRNG=/END OF CICS TRANSACTION DUMP/\n/*\n/&\n\n\nPOWQREAD\n\nPOWQREAD CSECT\n         PRINT NOGEN\n* PROGRAM NAME: POWQREAD                                              *\n         LR    12,15                   BASE REGS ARE 12 & 10\n         LA    10,4095(12)\n         LA    10,1(10)\n         USING POWQREAD,12,10\n         OPEN  PRT                     OPEN PRINTER\n         OPEN  CARD                    OPEN CARD INPUT\n         LA    11,SPLEX                POWER SPOOL PARAMETER LIST\n         USING SPL,11                  ADDRESSABILITY\n         ST    11,SPMXECB+4            STORE ADDR IN CROSS PART ECB\n*  DEFINE CROSS PARTITION ECB IN SUPERVISOR TABLE\n         LA    9,DEFXECBM              ADDRESS OF ERROR MESSAGE\n         SR    2,2                     R2 = RETRY COUNTER\nDEFXECB  XECBTAB TYPE=DEFINE,XECB=SPMXECB,ACCESS=XWAIT  CONNECT XECB\n         LTR   15,15                   OK ?\n         BZ    GETCARD                 GET GET CARD INPUT\n         LA    2,1(2)                  NO - BUMP RETRY COUNTER\n         SETIME 1,TIMERECB             WAIT 1 SEC\n         WAIT  TIMERECB\n         C     2,RETRYLIM              > RETRY LIMIT (5) ?\n         BH    ERROR                   YES WRITE ERROR & EXIT\n         B     DEFXECB                 RETRY CONNECTION\n*  PROCESS LSTIN= CARDS\nGETCARD  GET   CARD                    GET INPUT CARD\n         CLI   LINEIN,C'*'             CHECK IF CARD IS A COMMENT\n         BE    GETCARD                 YES, IGNORE\n         CLC   LINEIN(6),=CL6'LSTIN='  IS THE LSTIN CARD\n         BE    PROCLSTC                YES PROCESS\n         MVC   LINEO(L'NOTLSTM),NOTLSTM  NO WRITE ERROR MESSAGE\n         BAL   7,SAYERROR             DISPLAY ON CONSOLE\n         BAL   7,PUTLINE              WRITE TO LIST\n         B     EOJ                    EXIT\nPROCLSTC LA    2,LINEIN+6             POINT TO JOBNAME\n         LA    3,JOBNAME              JOBNAME SAVE AREA\n         LA    4,8                    MAX LEN\nGETJNAME MVC   0(1,3),0(2)            MOVE IN ONE CHAR\n         LA    2,1(,2)                BUMP POINTERS\n         LA    3,1(,3)\n         CLI   0(2),C' '              END OF CARD ?\n         BE    GOTJNAME\n         CLI   0(2),C','              END OF DDNAME ?\n         BE    GOTJNAME\n         BCT   4,GETJNAME             GET NEXT CHAR\nGOTJNAME LA    2,1(,2)                POINT TO JOB NUMBER IF THERE\n         LA    4,5                    MAX LEN\n         LR    5,2                    SAVE START ADDR\n         TM    0(2),X'F0'             IS IT NUMERIC ?\n         BO    GETJNUM                YES\n         LA    2,LINEIN+6             NO POINT TO START OF JOBNAME\n         SR    5,2                    R5=LENGTH OF JOBNAME\n         BCTR  5,0                    LESS ONE FOR EXECUTE\n         B     NOJOBNO\nGETJNUM  TM    0(2),X'F0'             CHECK NUMERIC\n         BNO   GOTJNUM                NO GO TO END\n         LA    2,1(2)                 BUMP\n         BCT   4,GETJNUM\nGOTJNUM  OI    SWITCH2,NUMGIVEN       INDICATE JOB NUM PROVIDED\n         SR    2,5                    LENGTH OF JOBNUM\n         LA    3,JOBNUM+5             END OF JOBNUM SAVE AREA\n         SR    3,2                    GO BACK LENGTH\n         BCTR  2,0                    LESS ONE FOR EXECUTE\n         EX    2,MVCJNUM              MOVE IN JOB NUM\n         LA    3,LINEIN+6             START OF DDNAME\n         LA    2,1(,2)                PLUS ONE WE SUBTRACTED\n         AR    5,2                    R5=END OF JOBNAME + JOBNUM\n         SR    5,3                    R5=LENGTH    \"      \"\nNOJOBNO  BCTR  5,0                    LESS ONE FOR EX\n         EX    5,MVCJNJN              MOVE IN JOBNAME & NUMBER\n         EX    5,MVCALT1              INTO POWER ALTER COMMAND 1\n         EX    5,MVCALT2               & 2\n         LA    2,ALTCM1+6             POINT TO END OF 'A LST,'\n         AR    2,5                    POINT PAST JOBNAME + NUM\n         TM    SWITCH2,NUMGIVEN       WAS JOB NUMBER SPECIFIED ?\n         BO    *+12                   YES - SKIP NEXT TWO LINES\n         ST    2,SAVENUMB             SAVE NUMBER FIELD IN ALT CMD ADDR\n         LA    2,6(2)                 LEAVE A GAP FOR NUMBER\n         MVC   1(7,2),=CL7',DISP=K'   MOVE IN DISP\n         LA    2,7(,2)                POINT TO 'K'\n         ST    2,ALTDISPB             SAVE ADDRESS FOR LATER\n         LA    2,ALTCM2+6             SAME\n         AR    2,5                         AGAIN\n         TM    SWITCH2,NUMGIVEN       WAS JOB NUMBER SPECIFIED ?\n         BO    *+12                   YES - SKIP NEXT TWO LINES\n         ST    2,SAVENUMA             SAVE NUMBER FIELD IN ALT CMD ADDR\n         LA    2,6(2)                 LEAVE A GAP FOR NUMBER\n         MVC   1(7,2),=CL7',DISP=K'\n         LA    2,7(,2)                POINT TO 'K'\n         ST    2,ALTDISPA             SAVE ADDRESS FOR LATER\n         LA    2,LINEIN+6             POINT TO START OD DDNAME\n         LA    3,66                   MAX LEN\nGETCLASS CLC   0(6,2),=CL6'CLASS='    SEARCH FOR A CLASS= STMT\n         BE    GOTCLASS\n         LA    2,1(2)\n         BCT   3,GETCLASS\n         B     *+10                   NOT FOUND, BRANCH PAST NEXT STMT\nGOTCLASS MVC   JOBCLASS(1),6(2)       MOVE IN GIVEN JOBCLASS\n         MVC   PBUF(6),=CL6'D LST,'   COMMAND INTO BUFFER\n         BAL   6,POWCMD               EXEC COMMAND(ERRORS CHECKED THERE\n         CLC   JOBCLASS(1),PBUF+54    CHECK POWCLASS=GIVEN CLASS\n         BNE   WRGCLASS\n         TM    SWITCH2,NUMGIVEN       WAS JOB NUMBER GIVEN ?\n         BO    CHKUSER\n         L     6,SAVENUMA             NO, HAVE TO GET IT OURSELVES\n         MVI   1(6),C','              R6=ADDR OF NUM FIELD IN ALTER CMD\n         MVC   2(5,6),PBUF+44         MOVE IN JOB NUM\n         L     6,SAVENUMB             NO, HAVE TO GET IT OURSELVES\n         MVI   1(6),C','              R6=ADDR OF NUM FIELD IN ALTER CMD\n         MVC   2(5,6),PBUF+44         MOVE IN JOB NUM\nCHKUSER  MVC   JOBNUM(5),PBUF+44      MOVE IN JOB NUM\n         CLC   PBUF+78(4),=CL4' '     CHECK NO USER-ID ASSIGNED\n         BE    CHKSTATS\n         L     6,ALTDISPB                 ADDR OF K IN DISP=K FIELD\n         MVC   1(11,6),=CL11',USER=LOCAL' ADD USER=LOCAL\n         L     6,ALTDISPA                 DO SAME FOR SECOND ALTER\n         MVC   1(6,6),=CL11',USER='       TO CHANGE BACK AT EOJ\n         MVC   7(4,6),PBUF+78             INSERT CURRENT USER-ID\n         OI    SWITCH,USERIDFN            SHOW USER-ID CHANGED TEMP\nCHKSTATS BAL   6,STATUS                   CHECK STATUS OF LIST\n         CLI   SPSQ,C'N'                  NOT THERE ?\n         BNE   CHKALIST\nWRGCLASS MVC   REQCLASS(1),JOBCLASS       MOVE IN GIVEN CLASS TO ERRMSG\n         MVC   LINEO(L'NOTHERE+1),NOTHERE MOVE IN ERROR MSG\n         BAL   7,SAYERROR                 DISPLAY ON CONSOLE\n         BAL   7,PUTLINE                  WRITE TO LIST\n         B     EOJ                        EXIT\nCHKALIST CLI   SPSQ,C'L'                  IS ENTRY A LISTING ?\n         BE    CHKDISP\n         MVC   LINEO(L'NOTLIST),NOTLIST   TELL USER\n         BAL   7,SAYERROR                         NOT A\n         BAL   7,PUTLINE                                LISTING\n         B     EOJ\nCHKDISP  L     2,ALTDISPA             POINT TO DISP FIELD IN ALTER CMD\n         MVC   0(1,2),SPQD            MOVE IN CURRENT DISP FOR LATER\n         CLI   SPQD,C'L'              CURRENT DISP=L ?\n         BNE   *+8\n         OI    SWITCH2,DISPWASL       YES, NO NEED TO RESET AT EOJ\n         CLI   SPQD,C'K'              ALREADY IN DISP=K ?\n         BNE   ALTDISP\n         TM    SWITCH,USERIDFN        DO WE WANT TO CHANGE USER-ID ?\n         BNO   OPTIONS\nALTDISP  MVI   PBUF,C' '              CLEAR\n         MVC   PBUF+1(131),PBUF             BUFFER\n         MVC   PBUF(50),ALTCM1        MOVE IN ALTER COMMAND\n         BAL   6,POWCMD               CHANGE TO DISP=K\n         CLC   PBUF+35(2),=CL2'OK'    CHECK FOR POWER'S OK MESSAGE\n         BE    OPTIONS\n         MVC   LINEO(L'POWERRME),POWERRME  POWER DIDN'T APPROVE\n         BAL   7,SAYERROR                  INFORM AND GO\n         BAL   7,PUTLINE\n         B     EOJ\n*  PROCESS OTHER CARDS\nOPTIONS  GET   CARD                     GET INPUT CARDS\n         CLI   LINEIN,C'*'              CHECK IF CARD IS A COMMENT\n         BE    OPTIONS                  YES, IGNORE\n         CLC   LINEIN(7),=CL7'LINENO='\n         BE    SETLINEN                 PROCESS LINENO CARD\n         CLC   LINEIN(7),=CL7'STRING='\n         BE    SETSTRNG                 PROCESS START STRING SEARCH\n         CLC   LINEIN(7),=CL7'ESTRNG='\n         BE    SETSTRNG                 PROCESS END STRING SEARCH\n         CLC   LINEIN(6),=CL6'COUNT='\n         BE    SETCOUNT                 PROCESS COUNT CARD\n         CLC   LINEIN(8),=CL8'FILEOUT='\n         BE    SETOUT                   PROCESS FILEOUT CARD\n         MVC   LINEIN+30(29),=CL29'** CARD INVALID - RUN END **'\n         MVC   LINEO(59),LINEIN         CARD NOT RECOGNIZED\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\n*  GET A LISTING RECORD\nGET      LA    2,JOBNAME                    JOB NAME IN R2\n         PACK  DWORD(8),JOBNUM(5)\n         CVB   3,DWORD                      JOB NUM IN R3\n         SR    4,4\n         ICM   4,B'0001',JOBCLASS           JOB CLASS IN R4\n         MVI   PBUF,C' '                    CLEAR BUFFER\n         MVC   PBUF+1(131),PBUF\n         LA    9,GETM                       ERROR MSG JUST IN CASE\n         TM    SWITCH,RESTART               WAS A RESTART REQUESTED ?\n         BO    SETSTLIN                     YES - POSITION\n         GETSPOOL SPL=(11),JOBN=(2),JNUM=(3),CLASS=(4),CC=YES\n         LTR   15,15\n         BNZ   ERROR\n         LA    9,TESTSTAM                   ERROR MSG JUST IN CASE\nTESTSTA  LA    4,SPMXECB                    ADDRESS OD RETURNED ECB\n         TM    4(4),SPIA+SPPP+SPUE+SPPI     CHECK FOR ERROR\n         BNZ   ERROR\n         AP    LINESRD(5),=PL5'1'           BUMP LINES READ COUNTER\n         TM    SWITCH,SEARCH                SEARCHING FOR A STRING ?\n         BNO   *+8\n         BAL   7,SCANBUF                    YES, SCAN LINE FOR STRING\n         L     7,RECLEN                     LOAD OUTPUT RECLEN\n         EX    7,PUTREC                     MOVE LINE TO OUTPUT AREA\n         BAL   7,PUTOUT                     WRITE RECORD\n         TM    SWITCH,ESEARCH               LOOKING FOR END STRING ?\n         BNO   *+8\n         BAL   7,SCANBUFE                   YES, SCAN LINE\n         AP    LINECNT(5),=PL5'1'           BUMP LINES WRITTEN COUNTER\n         TM    SWITCH,LIMIT                 WAS A COUNT LIMIT SET ?\n         BNO   *+8\n         BAL   7,CHKCOUNT                   CHECK COUNT NOT EXEEDED\nTESTEOF  TM    SPER,SPLR                    END OF LIST ?\n         BNO   GET                          NO - GET NEXT REC\n*  EOJ ROUTINE\nENDLIST  TM   SWITCH,LIMIT                  EOJ DUE TO COUNT ?\n         BNO  END\nRESETDIS BAL  6,STATUS                      YES, RESET DISP=*\nEND      ED    LINESRDE(12),LINESRD         NUMBER OF LINES READ\n         MVC   LINEO(LLINESRD),LINESRDM\n         BAL   7,PUTLINE\n         ED    LINESWTE(12),LINECNT         NUMBER OF LINES WRITTEN\n         MVC   LINEO(LLINESWT),LINESWT\n         BAL   7,PUTLINE\n         TM    SWITCH,USERIDFN              WAS USER-ID CHANGED ?\n         BO    RESTDISP                     YES - RESET IT\n         TM    SWITCH2,DISPWASL             WAS INPUT DISP=L ?\n         BO    EOJ                          YES, NO NEED TO RESET\nRESTDISP MVI   PBUF,C' '                    CLEAR\n         MVC   PBUF+1(131),PBUF                   BUFFER\n         MVC   PBUF(50),ALTCM2              RESET DISP TO WHAT IT WAS\n         BAL   6,POWCMD                     EXEC POWER ALTER COMMAND\nEOJ      XECBTAB TYPE=DELETE,XECB=SPMXECB   DELETE CONNECTION\n         TM   SWITCH,SEARCH                 DID WE FIND STRING ?\n         BNO  TESTLINE\n         MVC  LINEO(L'NOTFOUND),NOTFOUND    MENTION IT\n         BAL   7,SAYERROR                   ON CONSOLE\n         BAL  7,PUTLINE                     ON PAPER\nTESTLINE TM   SWITCH,RESTART                EOF WHILE DOING A RESTART?\n         BNO  READXTRA\n         MVC  LINEO(L'TOOHIGH),TOOHIGH      YES RESTART > LINECOUNT\n         BAL   7,SAYERROR\n         BAL  7,PUTLINE\nREADXTRA TM   SWITCH,EOFENTRD\n         BO   CLOSE\nGOTOEOF  GET  CARD                          READ ANY EXCESS CARDS\n         B    GOTOEOF                       CLOSE ENTERED BY EOF\nCLOSE    CLOSE PRT\n         CLOSE CARD\n         TM    SWITCH,OUT2LIST\n         BO    CHECKERR\n         CLOSE OUT\nCHECKERR TM    SWITCH,ERRFOUND              WAS AN ERROR ENCOUNTERED ?\n         BNO   NORMEOJ                      NO, EXIT RC=0\n         L     15,BADRC                     YES, LOAD RC\n         EOJ   RC=(15)                      EXIT\nNORMEOJ  EOJ   RC=0\n*  LINE COUNTER CHECKER - ENTERED BY KEYWORD COUNT=\nCHKCOUNT CP    LINECNT(5),PLIM(5)      LINE COUNT EXCEEDED ?\n         BLR   7                       NO\n         B     ENDLIST                 YES, CLOSE LIST\n*  DETERMINE STATUS OF LIST\nSTATUS   LA    2,JOBNAME               LIST NAME\n         PACK  DWORD(8),JOBNUM(5)      LIST NO.\n         CVB   3,DWORD                 CONVERT TO BINARY\n         LA    9,DISPSTAM              ADDRESS OF ERROR MESSAGE\n         CTLSPOOL SPL=(11),REQ=STATUS,PBUF=PBUF,JOBN=(2),JNUM=(3)\n         LTR   15,15                   OK ?\n         BNZ   ERROR                   NO, LIST NOT AVAILABLE\n         BR    6                       YES, RETURN\n*  RESTART LIST AT LINE NUMBER - ENTERED BY KEYWORD LINENO=\nSETSTLIN L     5,SLINE                 OTHER REGS SET AT LABEL GET\n         GETSPOOL SPL=(11),JOBN=(2),JNUM=(3),CLASS=(4),LINENO=(5)\n         LTR   15,15\n         BNZ   ERROR\n         NI    SWITCH,NRESTART         TURN OFF RESTART\n         BCTR  5,0                     SUBTRACT 1 FROM R5\n         CVD   5,DWORD                 CONVERT TO PRINTABLE\n         MVC   LINESRD(5),DWORD+3      UPDATE LINES READ COUNTER\n         LA    9,TESTSTAM              PREPARE AN ERROR MESSAGE\n         B     TESTSTA\n*  SCAN BUFFER FOR START STRING - ENTERED BY KEYWORD STRING=\nSCANBUF  LA    2,SEARCHST              ADDRESS OF STRING\n         LA    3,133                   MAX LENGTH\n         L     4,STRNGLEN              LENGTH OF STRING\n         LA    5,PBUF                  ADDRESS OF INPUT BUFFER\n         SR    3,4                     MAX LEN-STRING LEN\nSCAN     CLC   0(1,5),0(2)             DO FIRST CHARS MATCH ?\n         BNE   SCANBUMP\n         EX    4,COMPARE               YES, CHECK WHOLE STRING\n         BE    GOTSTRNG\nSCANBUMP LA    5,1(5)                  BUMP POINTER\n         BCT   3,SCAN                  DO TILL BEYOND MATCH\n         B     TESTEOF                 NO MATCH - CHECK EOF\nGOTSTRNG NI    SWITCH,NSEARCH          GOT MATCH, TURN OFF INDICATOR\n         ED    HITLINE(12),LINESRD     TELL USER\n         MVC   LINEO(HITMSG),HITMES              IN\n         MVC   HITLINE(12),HITLINES                 WHICH\n         PUT   PRT                                        LINE\n         MVI   LINEO,C' '              TIDY\n         MVC   LINEO+1(131),LINEO           UP\n         BR    7\n*  SCAN BUFFER FOR END STRING - ENTERED BY KEYWORD ESTRNG=\nSCANBUFE LA    2,SEARCHSE               STRING HERE\n         LA    3,133                    MAX SEARCH LENGTH\n         L     4,ESTRNGLN               LENGTH OF STRING\n         LA    5,PBUF                   CURRENT LINE\n         SR    3,4                      SEARCH LEN=133-STRING LEN\nSCANE    CLC   0(1,5),0(2)              FIRST CHARACTER EQUAL ?\n         BNE   SCANBUME                 NO, BUMP\n         EX    4,COMPARE                YES, COMPARE WHOLE STRING\n         BE    GOTSTRNE                 EQUAL ?\nSCANBUME LA    5,1(5)                   NO NEXT CHARACTER\n         BCT   3,SCANE                  CONTINUE SCAN\n         BR    7                        END OF SCAN, RETURN\nGOTSTRNE BAL   7,PUTLINE                GOT STRING, WRITE LINE\n         NI    SWITCH,NSEARCHE          GOT STRING, TURN OF SEARCH\n         ED    HITLINE(12),LINESRD      CURRENT LINE NUMBER IN LIST\n         MVC   LINEO(HITMSG),HITMES     SAY WHERE WE FOUND THE STRING\n         MVC   HITLINE(12),HITLINES\n         BAL   7,PUTLINE                PRINT INFO MESSAGE\n         B     RESETDIS                 CLOSE UP\n*  PREPARE RESTART LINE NUMBER - ENTERED BY KEYWORD LINENO=\nSETLINEN LA    2,LINEIN+7              POINT TO FIRST DIGIT\n         XC    DWORD(8),DWORD          CLEAR WORK DWORD\n         TM    0(2),X'F0'              CHECK NUMERIC\n         BO    SETL2\n         MVC   LINEO(L'NOTNUM),NOTNUM\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\nSETL2    LR    3,2                     START OF LINENO\n         LA    4,8                     MAX LENGTH\nSETL3    LA    3,1(3)                  FIND END\n         TM    0(3),X'F0'\n         BNO   SETL4\n         BCT   4,SETL3\nSETL4    SR    3,2                     END - START =LENGTH\n         LA    4,DWORD+8               END OF WORK DWORD\n         SR    4,3                     BACK UP LENGTH\n         BCTR  3,0                     LESS ONE FOR EXECUTE\n         EX    3,MVCNUM                MOVE NUMBER TO DOUBLE WORD\n         PACK  DWORD(8),DWORD(8)       CONVERT TO BINARY\n         CVB   3,DWORD\n         ST    3,SLINE                 STORE IT SAFE\n         ED    RSLINE(12),DWORD+3      WRITE AN INFO MESSAGE\n         MVC   LINEO(RESMSG),RESMES\n         BAL   7,PUTLINE\n         OI    SWITCH,RESTART\n         B     OPTIONS\n*  SET SCAN STRINGS - ENTERED BY KEYWORDS STRING= & ESTRNG=\nSETSTRNG LA    2,LINEIN+7              POINT TO FIRST CHAR\n         CLI   0(2),C' '               MAY NOT BE A BLANK\n         BNE   SETS2\n         MVC   LINEO(L'NOTUNIQ),NOTUNIQ\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\nSETS2    CLC   LINEIN(5),=CL5'ESTRNG'  DOING ESTRNG OR STRING ?\n         BNE   LOADSTRG                NO SET POINTER FOR STRING=\n         LA    5,SEARCHSE              YES SET FOR ESTRNG=\n         LA    6,ESTRNGLN              LENGTH\n         OI    SWITCH,ESEARCH          TAKE A NOTE\n         B     SETS2B\nLOADSTRG LA    5,SEARCHST              ADDRESS OF STRING\n         LA    6,STRNGLEN              LENGTH OF STRING\n         OI    SWITCH,SEARCH           INDICATE WE'LL BE SEARCHING\nSETS2B   MVC   UNIQ(1),0(2)            SAVE FIRST CHAR (DELIMITER)\n         LA    2,1(2)                  FIRST CHAR OF STRING\n         LR    3,2                     SAVE ADDR\n         LA    4,62                    MAX LENGTH\nSETS3    CLC   0(1,3),UNIQ             FOUND SECOND DELIMITER ?\n         BE    SETS4\n         MVC   0(1,5),0(3)             NO MOVE IN ONE CHAR\n         LA    5,1(5)                  BUMP POINTERS\n         LA    3,1(3)\n         BCT   4,SETS3                 DO TO MAX\n         MVC   LINEO(L'NOTUNIQ),NOTUNIQ NO DELIMITER FOUND\n         BAL   7,SAYERROR              TELL THE MAN\n         BAL   7,PUTLINE\n         B     EOJ\nSETS4    SR    3,2                     GOT DELIMITER\n         BCTR  3,0                     LESS ONE FOR EXECUTE (LATER)\n         ST    3,0(6)                  SAVE LENGTH\n         MVC   LINEO(13),=CL13'SCAN STRING:/'  PREPARE MESSAGE\n         SR    5,3                     POINT TO BEGIN OF STRING\n         SH    5,=H'1'                 LESS ONE\n         MVC   LINEO+13(60),0(5)       MOVE STRING TO INFO LINE\n         LA    4,LINEO+13              POINT TO FIRST '/'\n         AR    4,3                     ADD LENGTH\n         LA    4,1(4)                  POINT 1 BEYOND END\n         MVI   0(4),C'/'               MOVE IN A '/'\n         BAL   7,PUTLINE               WRITE INFO MESSAGE\n         B     OPTIONS\n*  SET COUNT ROUTINE - ENTERED BY KEYWORD COUNT=\nSETCOUNT LA    2,LINEIN+6              POINT TO FIRST DIGIT\n         XC    DWORD(8),DWORD          CLEAR WORK DWORD\n         TM    0(2),X'F0'              CHECK NUMERIC\n         BO    SETC2\n         MVC   NOTNUM(5),=CL5'COUNT'\n         MVC   LINEO(L'NOTNUM),NOTNUM\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\nSETC2    LR    3,2                     SAVE ADDR OF FIRST DIGIT\n         LA    4,8                     MAX LENGTH\nSETC3    LA    3,1(3)                  POINT TO NEXT DIGIT\n         TM    0(3),X'F0'\n         BNO   SETC4\n         BCT   4,SETC3\nSETC4    SR    3,2                     R3=LENGTH\n         LA    4,DWORD+8               END OF DWORD\n         SR    4,3                     BACK UP LENGTH\n         BCTR  3,0                     LESS ONE FOR EXECUTE\n         EX    3,MVCNUM                MOVE IN NUMBER\n         PACK  PLIM(5),DWORD+3(5)      SET COUNT FIELD\n         ED    LMLINE(12),PLIM         WRITE AN INFO MESSAGE\n         MVC   LINEO(LIMMSG),LIMMES\n         BAL   7,PUTLINE\n         OI    SWITCH,LIMIT            TAKE A NOTE\n         B     OPTIONS\n*  ISSUE POWER COMMAND - COMMAND IS IN PBUF\nPOWCMD   LA    9,DISPLSTM              SET UP AN ERROR MESSAGE\n         MVC   LINEO(15),=CL15'COMMAND ISSUED:' INFO MESSAGE\n         BAL   7,PUTLINE\n         MVC   LINEO(50),PBUF          PRINT COMMAND TEXT\n         BAL   7,PUTLINE\n         CTLSPOOL SPL=(11),REQ=COMMAND,PBUF=PBUF,QUEUE=LST\n         LTR   15,15\n         BNZ   ERROR\n         MVC   LINEO(88),PBUF+28       PRINT POWER REPLY\n         BAL   7,PUTLINE\n         BR    6                       RETURN\n*  ERROR ROUTINE\nERROR    LR    2,15                    SAVE R15 RC\n         SLL   2,24                    GET RID OF LOW ORDER BITS\n         SRL   2,24\n         LA    4,RETCDE                ADDRESS TO PLACE PRINTABLE RC\n         BAL   7,CONV                  CONVERT TO PRINTABLE\n         SR    2,2                     CLEAR R2\n         IC    2,SPMXECB+4             INSERT FEEDBACK CODES FROM ECB\n         LA    4,ERCODE                ADDRESS TO PLACE IT\n         BAL   7,CONV                  CONVERT TO PRINTABLE\n         MVC   ERRORMSG(30),0(9)       WRITE ERROR MESSAGE\n         MVC   LINEO(60),ERRORMSG\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         OI    SWITCH,ERRFOUND         INDICATE ERROR\n         B     EOJ\n*  WRITE MESSAGE ON CONSOLE ROUTINE\nSAYERROR TM    SWITCH,ERRFOUND         TEST IF ONE ERROR ALREADY DONE\n         BOR   7                       YES, DON'T DEPRESS THE OPERATOR\n         LA    1,CCB                   WRITE TO CONSOLE\n         EXCP  (1)\n         WAIT  (1)\n         OI    SWITCH,ERRFOUND\n         BR    7\nCCB      CCB   SYSLOG,CCW\nCCW      CCW   X'09',LINEO,X'20',50\n*  CONVERT TO PRINTABLE - R4 = OUTPUT ADDRESS R2 CONTAINS CODE\nCONV     SLDL  2,28                    R2=000000NN R3=NN000000\n         STC   2,0(4)\n         SRL   3,28                    R3=000000NN\n         STC   3,1(4)\n         TR    0(2,4),TRTAB            CONVERT TO PRINTABLE\n         BR    7\n*  EOF ROUTINE - CARDS\nNOCARDS  TM    SWITCH,ERRFOUND         ENDING DUE TO AN ERROR?\n         BO    CLOSE                   YES - NO MORE MESSAGES\n         OI    SWITCH,EOFENTRD         INDICATE EOF ON CARD INPUT\n         CLI   JOBNAME,X'40'           DID WE GET A JOBNAME CARD?\n         BNE   CHKFILOD\n         MVC   LINEO(L'NOCARDSM),NOCARDSM   NO TELL USER\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\nCHKFILOD TM    SWITCH,FILEODUN         DID WE PROCESS A FILEOUT CARD?\n         BO    GET\n         MVC   LINEO(L'NOFILECD),NOFILECD  NO TELL USER\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         B     EOJ\n*  WRITE A MESSAGE ROUTINE\nPUTLINE  PUT   PRT                     WRITE MESSAGE\n         MVI   LINEO,C' '              CLEAR\n         MVC   LINEO+1(131),LINEO           BUFFER\n         MVI   CC,X'09'                WRITE 1 LINE CC\n         BR    7\n*  WRITE A RECORD ROUTINE\nPUTOUT   TM    SWITCH2,OUT2LIST        IS OUTPUT FILE TO BE PRINTED ?\n         BNO   PUTOUT2                 NO\n         MVC   LINEO(132),PBUF         YES, COPY RECORD TO PRINT AREA\n         MVC   CC(1),SPCC              COPY CARRIAGE CONTROL CHAR\n         B     PUTLINE\nPUTOUT2  PUT   OUT                     WRITE RECORD\n         MVI   0(8),C' '               CLEAR BUFFER\n         L     6,RECLEN                LENGTH OF BUFFER\n         BCTR  6,0                     LESS ONE FOR EXECUTE\n         EX    6,CLRBUF                CLEAR IT\n         BR    7\nCLRBUF   MVC   1(*-*,8),0(8)           DUMMY FOR EXECUTE\n*  UPDATE OUTPUT DCB TO GIVEN VALUES AND OPEN IT - ENTERED BY FILEOUT=\nSETOUT   CLC   LINEIN+8(5),=CL5'PRINT'  FILEOUT=PRINT ?\n         BNE   SETOUT2                 NO\n         OI    SWITCH2,OUT2LIST        YES, TAKE A NOTE\n         OI    SWITCH,FILEODUN         INDICATE WE'VE DONE IT\n         LA    8,LINEO\n         B     OPTIONS\nSETOUT2  LA    2,LINEIN+8              FIRST CHARACTER OF DDNAME\n         CLI   0(2),C' '               CHECK NOT BLANK\n         BE    INVALID\n         TM    0(2),X'F0'              OR NUMERIC\n         BO    INVALID\nCREDCB1  LA    3,OUTDCB+X'1E'          POINT TO DDNAME IN DCB\n         LA    4,7                     MAX LEN\nCREDCB2  MVC   0(1,3),0(2)             MOVE IN GIVEN DDNAME\n         LA    2,1(,2)\n         LA    3,1(,3)\n         CLI   0(2),C' '               UNTIL END OF CARD\n         BE    CREDCBE\n         CLI   0(2),C','               OR A COMMA\n         BE    CREDCB4\n         BCT   4,CREDCB2\nCREDCB4  LA    2,1(,2)                 POINT TO NEXT OPERAND\n         MVC   FERRMSG(7),=CL7'FILEOUT' PREPARE ERROR MESSAGE\n         CLC   0(8,2),=CL8'BLKSIZE='    WHAT\n         BE    PROCBSIZ\n         CLC   0(6,2),=CL6'LRECL='          OPERAND\n         BE    PROCLREC\n         CLC   0(6,2),=CL6'SYSNO='                  ?\n         BE    PROCSYSN\n         B     INVALID                  NONE OF THE ABOVE - ERROR\n*  PROCESS SYSNO= OPERAND OF FILEOUT= KEYWORD\nPROCSYSN MVC   FERRMSG(7),=CL7'SYSNO'  INIT ERROR MESSAGE\n         LA    2,6(,2)                 POINT PAST SYSNO=\n         CLI   0(2),C' '               A BLANK ?\n         BE    INVALID                 ERROR\n         CLC   0(3,2),=CL3'SYS'        PRECEEDED BY 'SYS' ?\n         BNE   *+8\n         LA    2,3(2)                  YES - SKIP OVER\nPROCSYS1 TM    0(2),X'F0'              CHECK NUMERIC\n         BNO   INVALID\n         XC    DWORD(8),DWORD          NULL WORK DWORD\n         LR    5,2                     SAVE ADDRESS OF FIRST DIGIT\n         LA    4,3                     MAX LEN\nPROCSYS2 LA    2,1(2)                  POINT TO NEXT DIGIT\n         TM    0(2),X'F0'\n         BNO   PROCSYS3\n         BCT   4,PROCSYS2\nPROCSYS3 LR    3,2                     END ADDR IN R3\n         SR    3,5                     R3 = LENGTH\n         LA    4,DWORD+8               END OF DWORD\n         SR    4,3                     BACK UP LENGTH\n         BCTR  3,0                     LESS ONE FOR EXECUTE\n         EX    3,MVCNUMB               MOVE SYS NUMBER\n         PACK  DWORD(8),DWORD(8)       CONVERT TO BINARY\n         CVB   5,DWORD\n         STCM  5,1,OUTDCB+X'0F'        STORE IN OUT DCB\n         CLI   0(2),C' '               END OF CARD ?\n         BE    CREDCBE\n         B     CREDCB4                 NO GET NEXT OPERAND\n*  PROCESS BLKSIZE= OPERAND OF FILEOUT= KEYWORD\nPROCBSIZ MVC   FERRMSG(7),=CL7'BLKSIZE' INIT ERROR MESSAGE\n         LA    2,8(,2)                 POINT PAST 'BLKSIZE='\n         CLI   0(2),C' '               CHECK NOT BLANK\n         BE    INVALID\nPROCBSI1 TM    0(2),X'F0'              CHECK NUMERIC\n         BNO   INVALID\n         XC    DWORD(8),DWORD          CLEAR DWORD\n         LR    5,2                     SAVE ADDR\n         LA    4,5                     MAX LEN\nPROCBSI2 LA    2,1(2)                  NEXT DIGIT\n         TM    0(2),X'F0'\n         BNO   PROCBSI3\n         BCT   4,PROCBSI2              DO TILL BE GET END\nPROCBSI3 LR    3,2                     END IN R3\n         SR    3,5                     R3=LENGTH\n         LA    4,DWORD+8               END OF DWORD\n         SR    4,3                     BACK UP LENGTH\n         BCTR  3,0                     LESS ONE FOR EXECUTE\n         EX    3,MVCNUMB\n         PACK  DWORD(8),DWORD(8)\n         CVB   5,DWORD\n         ST    5,BLOKSIZE              SAVE FOR LATER\n         BCTR  5,0                     LESS ONE IN DCB\n         STH   5,OUTDCB+X'52'          STORE IN DCB\n         LA    5,8(5)                  PLUS 8 BYTES FOR LIOCS\n         LA    4,OUTDCB+X'68'          DCB NEEDS A FWORD WITH OUT DCB\n         AR    5,4                     + LENGTH BLOKSIZE A(*+BLOKSIZE)\n         ST    5,OUTDCB+X'68'          JUST ABOUT HERE\n         CLI   0(2),C' '               END OF CARD  ?\n         BE    CREDCBE\n         B     CREDCB4                 NO - GO GET NEXT OPERAND\n*  PROCESS LRECL= OPERAND OF FILEOUT= KEYWORD\nPROCLREC MVC   FERRMSG(7),=CL7'LRECL'  INIT ERROR MESSAGE\n         LA    2,6(,2)                 POINT PAST LRECL=\n         CLI   0(2),C' '               CHECK NOT BLANK\n         BE    INVALID\nPROCLRE1 TM    0(2),X'F0'              CHECK NUMERIC\n         BNO   INVALID\n         XC    DWORD(8),DWORD          CLEAR DWORD\n         LR    5,2                     SAVE START ADDR\n         LA    4,5                     MAX LEN\nPROCLRE2 LA    2,1(2)                  NEXT DIGIT\n         TM    0(2),X'F0'              NUMERIC ?\n         BNO   PROCLRE3                NO\n         BCT   4,PROCLRE2\nPROCLRE3 LR    3,2                     R3 = END ADDR\n         SR    3,5                     R3 = LENGTH\n         LA    4,DWORD+8               END OF DWORD\n         SR    4,3                     BACK UP LENGTH\n         BCTR  3,0                     LESS 1 FOR EX\n         EX    3,MVCNUMB               NUM IN DWORD\n         PACK  DWORD(8),DWORD(8)       CONVERT TO BINARY\n         CVB   5,DWORD\n         ST    5,RECLEN                SAVE FOR LATER\n         STH   5,OUTDCB+X'4A'          STORE IN DCB\n         ST    5,OUTDCB+X'64'          HERE TOO\n         CLI   0(2),C' '               END OF CARD ?\n         BE    CREDCBE\n         B     CREDCB4\n*  CHECK ALL WAS VAILD AND OPEN OUTPUT FILE\nCREDCBE  L     2,BLOKSIZE            BLOCK SIZE\n         L     3,BLOKSIZE\n         L     5,RECLEN              RECORD LENGTH\n         SRDA  2,32                  DIVIDE BLOKSIZE BY LRECL\n         DR    2,5\n         LTR   2,2                   ANY REMAINDER ?\n         BZ    OPENOUT               NO - OK LRECL IS MULTIPLE OF BSIZE\n         ST    2,BADRC               REMAINDER AS RC\n         OI    SWITCH,ERRFOUND       INDICATE ERROR ENCOUNTERED\n         LA   2,4                    LENGTH OF DATA TO CONVERT\n         LA   8,RECLEN               ADDRESS   \"     \"     \"\n         BAL  6,CONVERT              CONVERT TO PRINTABLE\n         MVC  LINEO+1(8),CONDATA     MOVE TO MESSAGE\n         MVC  LINEO+10(8),=CL8'RECSIZE'\n         BAL  7,PUTLINE              PRINT MESSAGE\n         LA   2,4                    LENGTH\n         LA   8,BLOKSIZE             ADDRESS\n         BAL  6,CONVERT              CONVERT TO PRINTABLE\n         MVC  LINEO+1(8),CONDATA\n         MVC  LINEO+10(8),=CL8'BLKSIZE'\n         BAL  7,PUTLINE                     PRINT\n         MVC   LINEO(L'NOTMULT),NOTMULT     NO MULTIPLE MESSAGE\n         BAL   7,SAYERROR               TELL OPERATOR\n         BAL   7,PUTLINE                PRINT ERROR MESSAGE\n         B     EOJ                      END\nOPENOUT  OPEN  OUT                      OPEN FILEOUT\n         OI    SWITCH,FILEODUN          INDICATE WE'VE DONE IT\n         B     OPTIONS\nCONVERT  MVI   CONDATA,C' '             CLEAR\n         MVC   CONDATA+1(69),CONDATA          BUFFER\n         LA    9,CONDATA                BUFFER ADDRESS\nCONV1    SR    3,3                      CLEAR R3\n         IC    3,0(8)                   INSERT 1 HEX CHAR\n         AR    3,3                      DOUBLE FOR CHAR\n         LA    4,CHARTAB                PRINTABLE HEX TAB\n         AR    4,3                      +R3 = OFFSET IN TAB\n         MVC   0(2,9),0(4)              MOVE INTO BUFFER\n         LA    9,2(9)                   BUMP BUFFER\n         LA    8,1(8)                   POINT TO NEX CHAR\n         BCT   2,CONV1                  DO TO END\n         BR    6                        RETURN\nCONDATA  DC    CL80' '                  USED BY CONVERT ROUTINE\nCHARTAB DC  C'000102030405060708090A0B0C0D0E0F'  HEX TO CHAR TRANSLATE\n        DC  C'101112131415161718191A1B1C1D1E1F'  TABLE\n        DC  C'202122232425262728292A2B2C2D2E2F'\n        DC  C'303132333435363738393A3B3C3D3E3F'\n        DC  C'404142434445464748494A4B4C4D4E4F'\n        DC  C'505152535455565758595A5B5C5D5E5F'\n        DC  C'606162636465666768696A6B6C6D6E6F'\n        DC  C'707172737475767778797A7B7C7D7E7F'\n        DC  C'808182838485868788898A8B8C8D8E8F'\n        DC  C'909192939495969798999A9B9C9D9E9F'\n        DC  C'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n        DC  C'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n        DC  C'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n        DC  C'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n        DC  C'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n        DC  C'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*  ERROR PROCESSING FILEOUT= CARD\nINVALID  MVC   LINEO(L'FERRMSG),FERRMSG       WRITE ERROR MESSAGE\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         NI    SWITCH,NERRFOND             RESET FLAG SET BY SAYERROR\n         MVC   LINEO(L'LINEIN),LINEIN         WRITE INPUT CARD\n         BAL   7,SAYERROR\n         BAL   7,PUTLINE\n         NI    SWITCH,NERRFOND             RESET FLAG SET BY SAYERROR\n         LA    3,LINEIN                       START OF INPUT CARD\n         SR    2,3                            R2 = WHERE ERROR WAS\n         LA    3,LINEO                        R2 = OFFSET IN INPUT CARD\n         AR    2,3\n         MVI   0(2),C'*'                      UNDERLINE ERROR\n         BAL   7,SAYERROR                     WRITE IT\n         BAL   7,PUTLINE\n         B     ENDLIST\n*  CONSTANTS\nTRTAB    EQU   *-240                          TRANSLATE TABLE\n         DC    C'0123456789ABCDEF'\nMVCJNUM  MVC   0(*-*,3),0(5)                  DUMMY FOR EXECUTE\nMVCJNJN  MVC   PBUF+6(*-*),LINEIN+6             \"         \"\nMVCALT1  MVC   ALTCM1+6(*-*),LINEIN+6           \"         \"\nMVCALT2  MVC   ALTCM2+6(*-*),LINEIN+6           \"         \"\nMVCNUMB  MVC   0(*-*,4),0(5)                    \"         \"\nCOMPARE  CLC   0(*-*,5),0(2)                    \"         \"\nMVCNUM   MVC   0(*-*,4),0(2)                    \"         \"\nPUTREC   MVC   0(*-*,8),PBUF                    \"         \"\nSWITCH   DC    X'00'\nSEARCH   EQU   X'01'                   SEARCH FOR A START STRING\nRESTART  EQU   X'02'                   RESTART REQUESTED\nESEARCH  EQU   X'08'                   SEARCH FOR END STRING\nLIMIT    EQU   X'04'                   COUNT WAS SPECIFIED\nFILEODUN EQU   X'10'                   FILEOUT CARD HAS BEEN PROCESSED\nERRFOUND EQU   X'20'                   ERROR DETECTED\nEOFENTRD EQU   X'40'                   EOF ROUTINE HAS BEEN ENTERED\nUSERIDFN EQU   X'80'                   USER-ID WAS SPECIFIED IN LISTING\nNRESTART EQU   X'FD'                   TURN OFF RESTART REQUEST\nNSEARCH  EQU   X'FE'                   TURN OFF START STRING SEARCH\nNSEARCHE EQU   X'F7'                   TURN OFF END STRING SEARCH\nNERRFOND EQU   X'DF'                   TURN OFF ERROR FOUND\nSWITCH2  DC    X'00'\nDISPWASL EQU   X'01'                   INPUT DISP WAS L\nNUMGIVEN EQU   X'02'                   JOB NUMBER WAS GIVEN\nOUT2LIST EQU   X'02'                   OUTPUT FILE TO BE PRINTER\nDWORD    DC    D'0'                    WORK DWORD\nRECLEN   DC    1F'80'                  RECLENGTH DEFAULT 80\nBLOKSIZE DC    1F'80'                  BLOKLEN\nSYSNUM   DC    1F'6'                   DEFAULT SYSNO SYS006\nFWORD    DC    1F'0'                   WORK FWORD\nSAVENUMA DC    1F'0'                   ADDR OF NUM IN ALTER COMMAND\nSAVENUMB DC    1F'0'                   ADDR OF NUM IN ALTER COMMAND\nSPMXECB  DC    A(0,*-*)                ECBS\nTIMERECB DC    A(0)\n         DC    X'FF'                   END LIST\nRETRYLIM DC    1F'5'                   RETRY LIMIT FOR DEFINE XECB\nALTDISPA DC    1F'0'                   ADDRESS OF NEW DISPOSITION\nALTDISPB DC    1F'0'                   ADDRESS OF OLD DISPOSITION\nSTRNGLEN DC    1F'0'                   LEN OF START STRING\nESTRNGLN DC   1F'0'                    LEN OF END STRING\nSLINE    DC   1F'0'                    RESTART LINE NUMBER\nBADRC    DC   1F'8'                    RESTART LINE NUMBER\nLINECNT  DC   PL5'0'                   LINES WRITTEN COUNTER\nLINESRD  DC   PL5'0'                   LINES READ COUNTER\nPLIM     DC   PL5'0'                   LIMIT SET BY COUNT=\nJOBNAME  DC   CL8' '                   JOB NAME\nJOBNUM   DC   CL5'00000'               NUMBER\n         DC   CL3' '\nJOBCLASS DC   C'Q'                     CLASS\nRC       DC   C' '                     RETURN CODE\nUNIQ     DC   C' '                     SCAN STRING DELIMITER\nSEARCHST DC   CL60' '                  STRINGS\nSEARCHSE DC   CL60' '\nALTCM1   DC   CL50'A LST,'             POWER COMMANDS\nALTCM2   DC   CL50'A LST,'\nPBUF     DC   CL132' '                 POWER - POWQREAD BUFFER\nCC       DC   X'8B'                    CARRIAGE CONTROL CHARACTER\nLINEO    DC   CL132' '                 OUTPUT LINE BUFFER\nLINEIN   DC   CL80' '                  INPUT LINE BUFFER\nERRORMSG DC   CL30' '                  FILLED BY ERROR ROUTINE\n         DC   C'XECB BYTES='\nERCODE   DC   CL5' '\n         DC   CL4'R15='\nRETCDE   DC   CL16' '\nDEFXECBM DC   CL30'FUNCTION: DEFINE XECB '\nDISPLSTM DC   CL30'FUNCTION: DISPLAY LIST '\nDISPSTAM DC   CL30'FUNCTION: DISPLAY STATUS '\nGETM     DC   CL30'FUNCTION: GET SPOOL ENTRY '\nTESTSTAM DC   CL30'FUNCTION: VSE RETURN CODE '\nNOTHERE  DC   C'SPECIFIED LIST NOT FOUND IN POWER LST CLASS '\nREQCLASS DC   CL1' '\nNOTLIST  DC   C'SPECIFIED NAME IS NOT A LISTING'\nNOTLSTM  DC   C'FIRST CARD NOT ''LSTIN='''\nNOFILECD DC   C'NO ''FILEOUT='' CARD READ'\nNOCARDSM DC   C'CONTROL CARDS MISSING'\nPOWERRME DC   C'RUN ABORTED DUE TO POWER MESSAGE'\nNOTUNIQ  DC   C'STRING DOES NOT START AND END WITH SAME NONBLANK CHAR'\nNOTNUM   DC   C'START LINE NO. NOT NUMERIC'\nNOTFOUND DC   C'STRING NOT FOUND'\nTOOHIGH  DC   C'START LINE EXCEEDS RECORD COUNT'\nLINESRDM DC   C'TOTAL NUMBER OF LINES READ '\nLINESRDE DC   X'402020206B2020206B202120'\nLLINESRD EQU  *-LINESRDM\nLINESWT  DC   C'TOTAL NUMBER OF OUTPUT RECS'\nLINESWTE DC   X'402020206B2020206B202120'\nLLINESWT EQU  *-LINESWT\nHITMES   DC   C'STRING FOUND IN RECORD NO. '\nHITLINE  DC   X'402020206B2020206B202120'\nHITMSG   EQU  *-HITMES\nHITLINES DC   X'402020206B2020206B202120'\nRESMES   DC   C'RESTART AT LINE NUMBER     '\nRSLINE   DC   X'402020206B2020206B202120'\nRESMSG   EQU  *-RESMES\nLIMMES   DC   C'NUMBER OF LINES TO PRINT   '\nLMLINE   DC   X'402020206B2020206B202120'\nLIMMSG   EQU  *-LIMMES\nFERRMSG  DC     C'FILEOUT  PARAMETER INVALID'\nNOTMULT  DC     C'BLOCKSIZE IS NOT A MULTIPLE OF LRECL'\nCARD     DTFCD DEVADDR=SYS004,BLKSIZE=80,                              C\n               TYPEFLE=INPUT,IOAREA1=LINEIN,EOFADDR=NOCARDS\nPRT      DTFPR DEVADDR=SYS005,IOAREA1=CC,BLKSIZE=133,CTLCHR=YES\nOUT      DTFSD DEVADDR=SYS006,RECSIZE=80,BLKSIZE=88,                   C\n               TYPEFLE=OUTPUT,RECFORM=FIXBLK,IOREG=(8)\nOUTDCB   EQU   OUT-8\nSPLEX    SPL  TYPE=DEFINE,PBUF=PBUF,PBUFL=132\nSPL      SPL  TYPE=MAP\n         END\n\nR Keane\nSystems Programmer (Germany)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E008A07": {"ttr": 10761, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01\\xcc\\x01\\xcc\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 460, "newlines": 460, "modlines": 0, "user": "VSEUPDT"}, "text": "Unique dynamic partition tables\n\nOne of the enhancements introduced with VSE/ESA is the\nability to generate more than 12 partitions by using dynamic\npartitions. Although the definition and use of dynamic\npartitions is relatively straightforward, there are some less than\ndesirable aspects.\n\n\nDTR$DYNC SHORTCOMINGS\n\nOne of the biggest shortcomings is that the dynamic class table\ncannot be renamed or moved from IJSYSRS.SYSLIB. For\nsingle VSE shops this may not present a problem. However, in\nmulti-VSE shops, such as ours, where IJSYSRS is shared\nbetween all systems, it means that each VSE system must use\nthe same dynamic class table This may not always be desirable.\nFor one thing, you're limited to a total of 10 dynamic classes to\nbe allocated to the entire shared VSE network. In many cases\n10 is sufficient since you can assign two or more classes to\neach VSE and then define multiple partitions within those\nclasses. However, if, for operational reasons, you need to\ndefine a single partition within each dynamic class, the limit\ncan be reached very quickly.\n\nFurthermore, suppose you wanted certain partitions, such as\nCICS or a system monitor, to use the same dynamic partition in\neach VSE system. Each partition would probably require\nunique partition labels and/or assignments. This could not be\neasily achieved because dynamic class start-up would invoke\nthe same start-up JCL PROC regardless of the system in which\nit was running. Although you could code the start-up JCL\nPROC to execute $COMVAR or some other routine to check\nCPU-id and then invoke a specific PROC based on the results,\nthat could prove to be cumbersome and less efficient.\n\n\nSOLUTION\n\nTo overcome these problems I've developed a fully automated\nmethod that allows each VSE system to have a unique dynamic\nclass table while sharing a common IJSYSRS.SYSLIB. Using\nthis method, you can define for each system the maximum of\n10 classes, using the same or different classes and partition\nattributes within each system.\n\nMy method is really quite simple. It involves each system\ncataloguing and activating its own dynamic class table during\nIPL. Since the table name and SUBLIB must remain the same\nfor each VSE system, I was faced only with the problem of\nserializing the cataloguing process to prevent the table for one\nsystem from being prematurely overlaid by the table for\nanother system. This situation later proved to be very likely in\nour environment since IPLs for multiple VSE systems are\ninitiated at nearly the same time from an operator screen in VM.\n\nTo handle the serialization problem I coded the DYNMGR\nprogram shown below. DYNMGR works in conjunction with\nconditional JCL and a single-record VSAM file defined on a\nshared VSAM user catalog to act as a lock file. When one\nsystem is ready to catalog its table, DYNMGR is invoked to\nsee if another table is already being catalogued. If not, the file\nis enqueued, marked as update-in-progress, and DYNMGR sets\na return code, indicating that the catalog and table load can\ntake place. The file is then closed and control returns to the\nJCL member where the dynamic partition table is loaded and\nactivated. After the load and activation, DYNMGR is again\ninvoked to dequeue the file and make it available to other\nsystems.\n\nIf an update is already in progress when an enqueue is\nrequested by another system, DYNMGR issues an\ninformational message then waits a short time and retries the\nenqueue. After three attempts, a return code is set, indicating\nthat the file is permanently enqueued, and the operator is\nnotified. If the enqueue is obtained, the requesting system\ncontinues. The dequeue process is also designed to wait for file\naccess in the event of the file being open to another system\nwhile that system checks the status. The entire\nenqueue/catalog/load/dequeue process takes only about 15\nseconds and operators are kept informed by informational\nmessages.\n\nWith a little effort, this method can be implemented using a\nmember on a shared VSE SUBLIB instead of a shared VSAM\nfile. I chose VSAM since I already had a shared VSAM user\ncatalog defined to my VSE systems.\n\n\nEXAMPLES\n\nShown below is the SYSTEM2 JCL member that drives the\ndynamic partition process along with the source code for the\nDYNMGR program, related PROCs, and the IDCAMS\nDEFINE for the DYNLOCK file. Note that the SYSTEM2 JCL\nmember invokes a PROC instead of having the start-up steps\ncoded directly within the JCL member. This was done to allow\nthe start-up member to be dynamically changed without having\nto remember to delete the old POWER queue entry and re-\nsubmit a new one. CPCMD and ARCMD are programs that\ngenerate commands and pass them to VM and VSE,\nrespectively, for execution. ARCMD also builds commands\nbased on passed parameters. In the example, the IPL2 PARM\ncauses ARCMD to generate queue-delete commands with a 15-\nday-old date to delete obsolete POWER queue entries. Other,\nsimilar programs are available to issue console commands.\nSome have been presented in earlier issues of VSE Update.\n\n\nTAIL-END OF BG ASI PROC\n\n  .\n  .\n  .\nASSGN SYS063,DISK,PERM,VOL=VOL253,SHR\nASSGN SYS066,DISK,PERM,VOL=VOL009,SHR\n// PWR PRELEASE RDR,SYSTEM2\n/(\n/&\n\n\nSTARTUP MEMBER THAT STAYS IN THE READER\n\n// JOB SYSTEM2 INITIALIZATION\n// OPTION LOG\n// EXEC PROC=SYSTEM2\n/*\n/&\n**********************************************************************\n***  Startup proc...                                               ***\n**********************************************************************\n// EXEC LIBR\nACCESS SUBLIB=IJSYSRS.SYSLIB\nCATALOG SYSTEM2.PROC DATA=YES REPLACE=YES EOD=/(\n// ON $RC GT 0 CONTINUE\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Issue CP commands...                                    ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n// EXEC CPCMD,PARM='SET RUN ON'\n// EXEC CPCMD,PARM='SET WNG OFF'\n// EXEC CPCMD,PARM='SET MSG OFF'\n// EXEC CPCMD,PARM='SP RDR CONT'\n// EXEC CPCMD,PARM='COUPLE 0C2 VTAM320 0C2'\n// EXEC CPCMD,PARM='COUPLE 0C6 VSE1 OC6'\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Set VSE options, perform IPL routine...                 ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n// EXEC ARCMD,PARM='PRTY BG=F9=F8,FB,F7,F6,F4,F5,G,FA,F3,F2,F1'\n// EXEC ARCMD,PARM='PRTYIO F1,F2 F3 FA,DYNC,F5,F4,F6,F7,FB,F8=F9=BG'\n// EXEC ARCMD,PARM='STACK MAPX|MAP|MAP CLASS=ALL|'\n// EXEC ARCMD,PARM='IPL2'\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Load/activate dynamic partitions...                     ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n// ON $RC GT 0 GOTO ERROR\n// EXEC DYNMGR,PARM='ENQUEUE,VSE2    '    ENQUEUE FILE\n// EXEC PROC=DYNVSE2                      RE-CATALOG DYNPART TABLE\n// EXEC ARCMD,PARM='PLOAD DYNC,FORCE'     ACTIVATE DYNPART TABLE\n// EXEC DYNMGR,PARM='DEQUEUE,VSE2    '    DEQUEUE FILE\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Release VTAM and system monitor...                      ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n// PWR PRELEASE RDR,VTAM\n// PWR PRELEASE RDR,EXPLORE\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Start virtual reader to allow job submits from VM...    ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n// EXEC ARCMD,PARM='PSTART RDR,OFC,X,2'\n// GOTO EXIT\nNOLOG ****************************************************************\nNOLOG ***                                                          ***\nNOLOG ***  Error occurred, notify operator...                      ***\nNOLOG ***                                                          ***\nNOLOG ****************************************************************\n/. ERROR\n// PAUSE Error during system start-up.  Notify Tech Support...\n/. EXIT\n/(\n\n\nDTR$DYNC PARTITION TABLE FOR VSE2\n\n// EXEC LIBR\nA S=IJSYSRS.SYSLIB\nCATALOG DYNVSE2.PROC REPLACE=YES DATA=YES EOD=/%\n// EXEC LIBR\nA S=IJSYSRS.SYSLIB\nCATALOG DTR$DYNC.Z REPLACE=YES EOD=/\u00ac\n----------v------vvvv----vvvvv--vvvvv---vvv--vvvvvvvv-vv------v---------\n          CLASS  ALLOC   SIZE   SP-GETV LUBS PROFILE  MAX-P   ENABLED\n\nCLASS=    G        10      500     64   155  $GJCL2   01      Y\n\nREADER=   00C\nPRINTERS= 00E,01E\nPUNCHES=  00D\n\nCLASS=    H         6      512     64   100  $HJCL2   01      Y\n\nREADER=   00C\nPRINTERS= 00E\nPUNCHES=  00D\n/\u00ac\n/%\n/*\n\n\nSOURCE FOR DYNMGR\n\n         PUNCH ' PHASE DYNMGR,*'\n         TITLE 'DYNMGR - DYNAMIC PARTITION LOCK MANAGER'\n**********************************************************************\n***                                                                ***\n***  Program Name  - DYNMGR - Dynamic Partition Lock File Handler  ***\n***      Function  - Works as a lock file handler to serialize     ***\n***                  updates to DTR$DYNC on IJSYSRS.SYSLIB.        ***\n***                                                                ***\n***                  When a VSE system is ready to update, this    ***\n***                  program enqueues the lock file (if not al-    ***\n***                  ready in use) and sets a return code          ***\n***                  indicating that the catalog and activation    ***\n***                  process can take place.  Other systems        ***\n***                  requesting an enqueue during this time will   ***\n***                  wait and retry up to 3 times.  After the      ***\n***                  catalog, this program dequeues the lock       ***\n***                  file making it available to other systems.    ***\n***                                                                ***\n***     JCL Parms  - ENQUEUE   This causes the lock file to be     ***\n***                            enqueued for this system until      ***\n***                            the dynamic partition table has     ***\n***                            been catalogued.                    ***\n***                                                                ***\n***                - DEQUEUE   This causes the lock file to be     ***\n***                            dequeued and made available to      ***\n***                            other systems.                      ***\n***                                                                ***\n***                - VSEID     Name of VSE system or other         ***\n***                            descriptive information.            ***\n***                                                                ***\n***                                                                ***\n***    Invocation  - From start-up JCL member which is released    ***\n***                  for execution during IPL.  For example:       ***\n***                                                                ***\n***    // JOB STARTUP\n***    // EXEC DYNMGR,PARM='ENQUEUE,VSE2'     <== enqueue file     ***\n***    // EXEC PROC=CATLOG1                   <== catalogue table  ***\n***    // EXEC ARPGM,PARM='PLOAD DYNC,FORCE'  <== user pgm or      ***\n***       (OR // PAUSE...)                        manual load      ***\n***    // EXEC DYNMGR,PARM='DEQUEUE,VSE2'     <== dequeue file     ***\n***    /*                                                          ***\n***    /&                                                          ***\n***                                                                ***\n**********************************************************************\n         PRINT GEN\nBEGIN    START 0\n         BALR  R3,0\n         USING *,R3,R4\n         LA    R3,0(R3)\n         LA    R4,2048(R3)\n         LA    R4,2048(R4)\n***  Edit & save JCL parms...                                      ***\n         CR    R1,R15                  Parm present?\n         BE    NOPARM                  No\n         L     R6,0(1)                 Load addr of parm len/data\n         MVC   JCLPARM,2(R6)           Save type-of-request\n         CLC   =C'ENQUEUE',2(R6)       Enqueue?\n         BE    DYNOPEN\n         CLC   =C'DEQUEUE',2(R6)       Dequeue?\n         BNE   NOPARM\n         ZAP   UPIPCT,=P'0'            Clear retry counter\n***  Open file...                                                  ***\nDYNOPEN  LA    R7,3                    Max number of open retries\nDYNO1    LA    R1,DYNLOCK\n         LA    R13,VSAVERG             VSAM save area\n         OPEN  (R1)\n         LTR   R15,R15                 Open OK?\n         BZ    DYNCONT\n         MVC   CDATA(55),=C'DYN0033  Waiting for enqueue. File=DYNLOCK.C\n               ..          '\n         BAL   R2,CONPUT               Display message\n         SETIME 20,TECB2               Set WAIT ECB\n         WAIT  TECB2\n         BCT   R7,DYNO1                Decr number of open retries\n         MVC   CDATA(55),=C'DYN0001  Error during OPEN of DYNLOCK.     C\n                           '\n         B     ERROR\n**********************************************************************\n***  Process jclparm...                                            ***\n**********************************************************************\nDYNCONT  BAL   R2,DYNGET               Read control record\n         CLC   =C'ENQUEUE',JCLPARM     Enqueue?\n         BE    CKUPIP\n*** MUST BE DEQUEUE REQUEST...\n         MVC   DYNSTAT,=CL4' '         Turn off upip flag\n         MVC   DYNVSEID,=CL8' '        CLear VSE name\n         BAL   R2,DYNPUT               Update control rec\n         BAL   R2,DYNCLOSE             Close file\n         MVC   CDATA(55),=C,'DYN0037  Enqueue released. File=DYNLOCK...C\n                           '\n         BAL   R2,CONPUT               Display message\n         B     FINISH\nCKUPIP   CLC   =C'UPIP',DYNSTAT        Another update in progress?\n         BNE   SETUPIP                 No\n         BAL   R2,DYNCLOSE             Close file\n         CP    UPIPCT,=P'3'            Reached max tries?\n         BNL   UPIPFAIL                Yes\n         MVC   CDATA(55),=C'DYN0033  Waiting for enqueue. File=DYNLOCK.X\n               ..          '\n         BAL   R2,CONPUT               Display message\n         SETIME 20,TECB2               Set WAIT ECB\n         WAIT  TECB2\n         AP    UPIPCT,=P'1'            Add 1 to attempts\n         B     DYNOPEN\nSETUPIP  MVC   CDATA(55),=C'DYN0035  Enqueue obtained. File=DYNLOCK... C\n                           '\n         BAL   R2,CONPUT               Display message\n         MVC   DYNSTAT,=C'UPIP'        Turn on upip flag\n         MVC   DYNVSEID,JCLVSEID       Name of enqueuing VSE system\n         BAL   R2,DYNPUT               Update control rec\n         BAL   R2,DYNCLOSE             Close file\n         B     FINISH\nUPIPFAIL MVC   CDATA(55),=C'DYN0009  DYNLOCK permanently enqueued.     C\n                           '\n         B     ERROR\n***  Error handler & return...                                     ***\nNOPARM   MVC   CDATA(55),=C'DYN0011  Missing or invalid parm on EXEC stC\n               atement.    '\nERROR    DS    0H\n         BAL   R2,CONPUT               Display message\n         MVC   CDATA(55),=C'DYN0111  Contact Technical Support.        C\n                           '\n         BAL   R2,CONPUT               Display message\n         ICM   R15,B'1111',RC08        Set return code of 8\n         B     RETURN\n***\nFINISH   ICM   R15,B'1111',RC00        Set return code of zero\nRETURN   EOJ   RC=(R15)\n***  Close lock file...                                            ***\nDYNCLOSE LA    R1,DYNLOCK              Control file\n         LA    R13,VSAVERG             VSAM save area\n         CLOSE (R1)\n         LTR   R15,R15                 Good return code?\n         BZR   R2\n         MVC   CDATA(55),=C'DYN0007  Error during CLOSE of DYNLOCK.    C\n                           '\n         B     ERROR\n***  Update lock file...                                           ***\nDYNPUT   LA    R1,DYNLOCK1             Point to sequential RPL\n         LA    R13,VSAVERG             VSAM save area\n         PUT   RPL=(R1)\n         LTR   R15,R15                 Good return code?\n         BZR   R2\n         MVC   CDATA(55),=C'DYN0005  Error writing to DYNLOCK.         C\n                           '\n         B     ERROR\n***  Process jclparm...                                            ***\nDYNGET   LA    R1,DYNLOCK1             Point to sequential RPL\n         LA    R13,VSAVERG             VSAM save area\n         GET   RPL=(R1)\n         LTR   R15,R15                 Good return code?\n         BZR   R2\n         MVC   CDATA(55),=C'DYN0003  Error during read from DYNLOCK.   C\n                           '\n         B     ERROR\n***  DISPLAY ON CONSOLE                                            ***\nCONPUT   MVC   CCW+6(2),=AL2(L'CDATA)\n         LA    R1,CCB\n         EXCP  (R1)\n         WAIT  (R1)\n         BR    R2\n***           S T O R A G E    D E F I N I T I O N S               ***\n         DC    C'STORAGE DEFINITIONS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n***\nJCLPARM  DS    0CL16                   Parm passed on EXEC stmt\nJCLRQST  DS    CL7                     ENQUEUE or DEQUEUE\n         DS    C                       Delimiter\nJCLVSEID DS    CL8                     VSE-ID\n***\nUPIPCT   DC    PL2'0'                  Retries because of UPIP\nRC00     DC    X'00000000'             RC=0\nRC08     DC    X'00000008'             RC=8\nTECB2    TECB                          Timer ECB\nVSAVERG  DS    9D                      VSAM RSA\n***  Lock file record layout                                       ***\nDYNREC   DS    0CL20\nDYNKEY   DS    CL8                     Always $$SYSTEM\nDYNSTAT  DS    CL4                     UPIP or blank\nDYNVSEID DS    CL8                     Name of enqueuing VSE system\n         LTORG\n***  Dynamic partition lock file                                   ***\nDYNLOCK  ACB   AM=VSAM,                                                C\n               MACRF=(KEY,SEQ,OUT),                                    C\n               STRNO=2\n***\nDYNLOCK1 RPL   AM=VSAM,                                                C\n               ACB=DYNLOCK,                                            C\n               AREA=DYNREC,                                            C\n               AREALEN=20,                                             C\n               OPTCD=(KEY,SEQ,UPD,MVE),                                C\n               ARG=DYNKEY\n***  Console                                                       ***\nCCB      CCB   SYSLOG,CCW\nCCW      CCW   9,CDATA,0,1\nCDATA    DS    CL60\n***\n         END   BEGIN\n***  Define for DYNLOCK...                                         ***\n***                                                                ***\n***  Note:  The following 20-byte header record should be added    ***\n***         after the file is defined.                             ***\n***                                                                ***\n***         $$SYSTEM************                                   ***\n***                                                                ***\n**********************************************************************\n   DELETE (DYNAMIC.PTN.LOCK.FILE) PURGE                                -\n           CATALOG (UCS01.UC.USERCAT.SHARED)\n   DEFINE CLUSTER                                                      -\n           (NAME(DYNAMIC.PTN.LOCK.FILE)                                -\n            INDEXED                                                    -\n            RECORDSIZE(20 20)                                          -\n            CYL(1 1)                                                   -\n            KEYS(8 0)                                                  -\n            FREESPACE(5 5)                                             -\n            SHAREOPTIONS(4))                                           -\n          DATA                                                         -\n           (NAME(DYNAMIC.PTN.LOCK.FILE.DATA) CISZ(4096))               -\n          INDEX                                                        -\n           (NAME(DYNAMIC.PTN.LOCK.FILE.INDEX))                         -\n          CATALOG (UCS01.UC.USERCAT.SHARED)\n\nSteve Bernard\nSenior Systems Programmer\nArkansas Farm Bureau Insurance (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "E008A08": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12R\\x01A\\x01A\\x00\\x00\\xe5\\xe2\\xc5\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:52:54", "lines": 321, "newlines": 321, "modlines": 0, "user": "VSEUPDT"}, "text": "Hardcopy job completion summary\n\nTo assist operations to quickly check job completions after a\ngiven starting point, HARDSUMM was written. By running\nthe program, which reads the VSE hardcopy file, one can\nquickly determine the final outcome of jobs without having to\nmanually scan the console backwards, with all of its many\nmessages.\n\nThe program prompts the operator for a starting date and time,\nsuch as 11/20/92,00:00. It will then scan all hardcopy records\nsince midnight on that date until the current time (end-of-file).\n\nEach time a '// JOB' message is read, an entry in an in-core\ntable is created. When the corresponding 'EOJ' and\n'DURATION' messages are read, the entry is completed,\nprinted, and reset. Thus, the summary is in order by job\ncompletion time, not starting time.\n\nIf a job is cancelled or abends, the message '1S78I' is read,\nand the first four characters of the reason are printed instead of\na maximum return code. For example, 'PROGRAM ABEND'\nwould print as 'PROG', and 'CANCELLED BY OPERATOR'\nwould print as 'CANC'.\n\nWhen end-of-file is reached, the in-core table is checked for\nany non-blank entries left. These indicate jobs which started\nwithin our record scan, but are still running. This can be\nhelpful, for example, if HARDSUMM is printed at change-of-\nshift, so that the next operator can see, not only what has been\nrun, but also what is pending completion when they take over.\n\nThe hardcopy file system macros used should be self-\nexplanatory: the HCF is opened, backed up to the beginning,\nand then read forward until the end. If you wish to look at the\nmacro source, punch their E-books (using ESERV) from the\nIJSYSRS.SYSLIB sublibrary.\n\nPlease note that the layout for the HCF is for VSE/ESA 1.1.\nMy copy of VSE/AF (2.1) Diagnosis Reference: System\nUtilities (LY33-9114-0), in the PRINTLOG chapter on page\nJ.02, shows a version of the file prior to adding the system date\nto each record. By using DITTO to dump a few records, I was\nable to determine the newest layout. Since our shop skipped\nfrom VSE/SP 3.1.2 directly to VSE/ESA, it is possible that\nVSE/SP Version 4 might use the newer format. The program\nwould still work, without the time information, with minor\nchanges for pre-ESA shops.\n\nAn example of the output is shown in Figure 1.\n\n\nHARDSUMM PROGRAM\n\n         PRINT NOGEN\n* PROGRAM NAME: HARDSUMM                                             *\n* SYSTEM:       VSE/ESA 1.1                                          *\n* PURPOSE:      HARCOPY FILE SUMMARY OF JOB COMPLETIONS              *\n* INPUT:        CONSOLE PROMPT FOR STARTING DATE AND TIME            *\n*\nR0       EQU   0                       WORK\nR1       EQU   1                       WORK\nR2       EQU   2                       WORK\nR11      EQU   11                      JOB TABLE POINTER\nR12      EQU   12                      PROGRAM BASE\nR13      EQU   13                      STANDARD\nR14      EQU   14                      STANDARD\nR15      EQU   15                      STANDARD\nJTABD    DSECT ,                       JOB TABLE LAYOUT\nJNAME    DS    CL8\n         DS    CL2\nJPARTN   DS    CL2\n         DS    CL2\nJBDATE   DS    CL8\n         DS    CL2\nJBTIME   DS    CL5\n         DS    CL2\nJEDATE   DS    CL8\n         DS    CL2\nJETIME   DS    CL5\n         DS    CL2\nJDUR     DS    CL8\n         DS    CL2\nJMAXRC   DS    CL4\nJTABLEN  EQU   *-JTABD                 LENGTH OF AN ENTRY\nHARDSUMM CSECT ,\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         LR    R12,R15                 ESTABLISH BASE\n         USING HARDSUMM,R12            (NOTIFY ASSEMBLER)\n         USING JTABD,R11               (NOTIFY ASSEMBLER)\n         ST    R13,SAVER13             HOLD CALLER'S SAVEAREA ADDR\n         B     ASKSTART                ==> SKIP AHEAD\n         DC    CL8'HARDSUMM'\n         DC    CL8'07/16/92'\nASKSTART DS    0H\n         MVI   CONCCW1,X'09'           MOD CCW OPERATION TO WRITE\n         MVC   CONCCW1+6(2),=Y(PROLEN)         LENGTH\n         MVC   CONCCW1+1(3),=AL3(PROMPT)       BUFFER ADDR\n         EXCP  CONSOLE                 WRITE PROMPT TO CONSOLE\n         WAIT  CONSOLE                 WAIT FOR I/O\nGETREPLY DS    0H\n         MVI   REPLY,C' '              INITIALIZE REPLY\n         MVC   REPLY+1(REPLYLEN-1),REPLY    AREA TO BLANKS\n         MVI   CONCCW1,X'0A'           MOD CCW OPERATION TO READ\n         MVC   CONCCW1+6(2),=Y(REPLYLEN)       LENGTH\n         MVC   CONCCW1+1(3),=AL3(REPLY)        BUFFER ADDR\n         EXCP  CONSOLE                 READ REPLY FROM CONSOLE\n         WAIT  CONSOLE                 WAIT FOR I/O\n         MVC   PARMDATE,REPLY          PARM DATE MM/DD/YY\n         MVC   PARMTIME,REPLY+9        PARM TIME HH:MM\nPRTTITLE DS    0H\n         MVC   PRTLINE(L'TITLE),TITLE  PRINT TITLE...\n         EXCP  PRINTER\n         WAIT  PRINTER\n         MVC   PRTLINE(L'HDR),HDR      PRINT HEADER...\n         EXCP  PRINTER\n         WAIT  PRINTER\nOPEN     DS    0H\n         L     R1,=X'FF000000'         ENTER SUPERVISOR STATE...\n         SVC   13\n         POINTHCF READ,PRINTLOG,ALL,SAVE=SAVEAREA\n         LTR   R15,R15                 CHECK OPEN\n         BZ    BACKWARD\n         MVC   RC,=H'1'                BAD OPEN, RC = 1\n         B     EOJ                     ==> END\nBACKWARD DS    0H\n         ST    R1,HCFCB                SAVE THE FCB\n         MODHCF (R1),BW                BACKWARD DIRECTION\n         LTR   R15,R15                 OK ?\n         BZ    TO@TOP                  ==> YES..CONTINUE\n         MVC   RC,=H'2'                BAD MOD, RC = 2\n         B     CLOSE                   ==> CLOSE AND END\nTO@TOP   DS    0H\n         L     R1,HCFCB                RESTORE POINTER\n         SKIPHCF (R1),EOF              BACK UP TO BEGINNING OF FILE\n         LTR   R15,R15                 OK ?\n         BZ    FORWARD                 ==> YES..CONTINUE\n         MVC   RC,=H'3'                BAD SKIP, RC = 3\n         B     CLOSE                   ==> CLOSE AND END\nFORWARD  DS    0H\n         L     R1,HCFCB                RESTORE POINTER\n         MODHCF (R1),FW                FORWARD DIRECTION\n         LTR   R15,R15                 OK ?\n         BZ    READ                    ==> YES..CONTINUE\n         MVC   RC,=H'4'                BAD MOD, RC = 4\n         B     CLOSE                   ==> CLOSE AND END\nREAD     DS    0H\n         L     R1,HCFCB                POINT TO FCB\n         LA    R0,HCFREC               POINT TO OUTPUT AREA\n         READHCF (R1),(R0)             READ A RECORD\n         LTR   R15,R15                 OK ?\n         BZ    READOK                  ==> YES..CONTINUE\n         CH    R15,=H'24'              EOF ?\n         BE    ENDOFHCF                ==> YES..GO CLEAN UP\n         MVC   RC,=H'5'                BAD READ, RC = 5\n         B     CLOSE                   ==> CLOSE AND END\nREADOK   DS    0H\n         MVC   PACKDATE(3),HCDATE      CONVERT DATE TO MM/DD/YY...\n         MVI   PACKDATE+3,X'0F'\n         UNPK  UNPKDATE,PACKDATE\n         MVC   ZDATE+0(2),UNPKMON\n         MVC   ZDATE+3(2),UNPKDAY\n         MVC   ZDATE+6(2),UNPKYEAR\n         LM    R0,R1,HCTIME            CONVERT TIME TO HH:MM...\n         GETIME CLOCK=YES\n         ST    R1,PACKTIME\n         UNPK  UNPKTIME,PACKTIME\n         MVC   ZTIME+0(2),UNPKHOUR\n         MVC   ZTIME+3(2),UNPKMIN\n         CLI   FNDSTRT,X'FF'           ALREADY FOUND STARTING POINT ?\n         BE    CONT                    ==> YES..\n         CLC   ZDATE,PARMDATE          FOUND BEGINNING DATE ?\n         BNE   READ                    ==> NOT YET..\n         CLC   ZTIME,PARMTIME          ON/AFTER BEGINNING TIME ?\n         BL    READ                    ==> NOT YET..\n         MVI   FNDSTRT,X'FF'           INDICATE WE'VE FOUND START\nCONT     DS    0H\n         CLC   HCTEXT+8(6),=C'// JOB'  JOB CARD ?\n         BNE   CONT1                   ==> NO...\n         LA    R11,JOBTAB              POINT TO JOB TABLE\nSEEKMPTY DS    0H\n         CLI   JNAME,C' '              EMPTY TABLE ENTRY ?\n         BE    FNDEMPTY                ==> YES..USE IT\n         LA    R11,JTABLEN(,R11)       NEXT TABLE ENTRY\n         CLI   JNAME,X'FF'             END OF TABLE ?\n         BNE   SEEKMPTY                ==> NO...LOOP\n         MVC   RC,=H'6'                TABLE FULL, RC = 6\n         B     CLOSE                   ==> CLOSE AND END\nFNDEMPTY DS    0H\n         LA    R1,HCTEXT+15            POINT TO JOBNAME IN HCF\n         LA    R2,JNAME                POINT TO JOBNAME IN TABLE\nBLDJNAME DS    0H\n         CLI   0(R1),C' '              BLANK ?\n         BE    BLDNMOK                 ==> DONE WITH NAME BUILD\n         MVC   0(1,R2),0(R1)           MOVE ONE CHARACTER\n         LA    R1,1(,R1)               NEXT INPUT CHARACTER\n         LA    R2,1(,R2)               NEXT OUTPUT CHARACTER\n         B     BLDJNAME                ==> AND LOOP\nBLDNMOK  DS    0H\n         MVC   JPARTN,HCTEXT+1         MOVE PARTITION TO TABLE\n         MVC   JBDATE,ZDATE            MOVE START DATE TO TABLE\n         MVC   JBTIME,ZTIME            MOVE START TIME TO TABLE\n         B     READ                    ==> READ NEXT\nCONT1    DS    0H\n         CLC   HCTEXT+8(3),=C'EOJ'     EOJ ?\n         BNE   CONT2                   ==> NO...\n         LA    R11,JOBTAB              POINT TO JOB TABLE\nSEEKJOB  DS    0H\n         CLC   HCTEXT+12(8),JNAME      FOUND JOBNAME IN TABLE ?\n         BE    FNDJOB                  ==> YES..USE IT\n         LA    R11,JTABLEN(,R11)       NEXT TABLE ENTRY\n         CLI   JNAME,X'FF'             END OF TABLE ?\n         BNE   SEEKJOB                 ==> NO...LOOP\n         LA    R11,EXTRA               USE EXTRA ENTRY INSTEAD\n         MVC   JNAME,HCTEXT+12         MOVE JOBNAME\n         MVC   JPARTN,HCTEXT+1         MOVE PARTITION\nFNDJOB   DS    0H\n         MVC   JEDATE,ZDATE            MOVE END DATE TO TABLE\n         MVC   JETIME,ZTIME            MOVE END TIME TO TABLE\n         MVC   JMAXRC,HCTEXT+38        MOVE MAX RETCODE TO TABLE\n         CLC   JPARTN,TERMPART         WAS JOB TERMINATED ?\n         BNE   READ                    ==> NO...DONE HERE\n         MVC   JMAXRC,TERMTYPE         USE TYPE OF EVENT FOR MAXRC\n         MVI   TERMPART,X'FF'          RESET TERMINATION FIELD\n         B     READ                    ==> READ NEXT\nCONT2    DS    0H\n         CLC   HCTEXT+33(8),=C'DURATION'   EOJ CONTINUATION ?\n         BNE   CONT3                   ==> NO...\n         MVC   JDUR,HCTEXT+44          MOVE DURATION TO TABLE\n         MVC   PRTLINE(JTABLEN),JTABD  MOVE ENTRY TO PRINT LINE\n         EXCP  PRINTER                 WRITE TO SYSLST\n         WAIT  PRINTER                 WAIT FOR I/O\n         MVI   JTABD,C' '              MOVE BLANKS TO ENTRY...\n         MVC   JTABD+1(JTABLEN-1),JTABD\n         B     READ                    ==> READ ANOTHER\nCONT3    DS    0H\n         CLC   HCTEXT+8(5),=C'1S78I'   ABNORMAL TERMINATION ?\n         BNE   READ                    ==> NO...SKIP IT\n         MVC   TERMPART,HCTEXT+1       HOLD PARTITION\n         MVC   TERMTYPE,HCTEXT+38      HOLD TYPE OF TERMINATION\n         B     READ                    ==> READ NEXT\nENDOFHCF DS    0H\n         LA    R11,JOBTAB              POINT TO JOB TABLE\nCLRTABLE DS    0H\n         CLI   JNAME,C' '              JOBNAME STILL IN TABLE ?\n         BE    CLRNEXT                 ==> NO...LEAVE ALONE\n         MVC   PRTLINE(JTABLEN),JTABD  MOVE ENTRY TO PRINT LINE\n         EXCP  PRINTER                 WRITE TO SYSLST\n         WAIT  PRINTER                 WAIT FOR I/O\nCLRNEXT  DS    0H\n         LA    R11,JTABLEN(,R11)       NEXT TABLE ENTRY\n         CLI   JNAME,X'FF'             END OF TABLE ?\n         BNE   CLRTABLE                ==> NO...CHECK NEXT ENTRY\nCLOSE    DS    0H\n         L     R1,HCFCB                CLOSE...\n         CLOSEHCF (R1)\nEOJ      DS    0H\n         LH    R15,RC                  SET RETURN CODE.\n         L     R13,SAVER13             POINT TO CALLER'S SAVEAREA\n         L     R14,12(R13)             RESTORE CALLER'S REGISTERS\n         LM    R0,R12,20(R13)            EXCEPT 13 AND 15\n         BR    R14                     RETURN FROM WHENCE WE CAME\nSAVEAREA DS   9D                       REQUIRED BY POINTHCF MACRO\nSAVER13  DS    F                       SAVE ORIGINAL R13\nHCFCB    DS    F                       FCB USED BY HCF MACROS\nRC       DC    H'0'                    RETURN CODE\nFNDSTRT  DC    X'00'                   STARTING POINT INDICATOR\nPACKDATE DS    F\nPACKTIME DS    F\nUNPKDATE DS   0CL7\nUNPKMON  DS    CL2\nUNPKDAY  DS    CL2\nUNPKYEAR DS    CL2\n         DS    CL1\nUNPKTIME DS   0CL6\nUNPKHOUR DS    CL2\nUNPKMIN  DS    CL2\n         DS    CL2\nZDATE    DC    CL8'**/**/**'\nZTIME    DC    CL5'**:**'\n         DS   0D                       FORCE ALIGNMENT FOR HCTIME\nHCFREC   DS   0CL93\nHCMTYPE  DS    X                       MSG TYPE\nHCCTYPE  DS    X                       CONSOLE TYPE\nHCORIG   DS    CL2                     ORIGIN \"BG\", \"AR\", ETC\n         DS    X\nHCDATE   DS    XL3                     DATE MMDDYY PACKED NO SIGN\nHCTIME   DS    D                       TIME FROM STORE CLOCK\nHCTEXT   DS    CL76                    TEXT\n         DS    X\nPRINTER  CCB   SYSLST,PRTCCW\nPRTCCW   CCW   9,PRTLINE,X'00',L'PRTLINE\nPRTLINE  DS    CL62\nTITLE    DS   0CL62\n         DC    CL25'JOBS BY COMPLETION SINCE '\nPARMDATE DS    CL8\n         DC    CL1' '\nPARMTIME DS    CL5\n         DC    CL23' '\nHDR      DS   0CL62\n         DC    CL31'JOBNAME   PN  START DATE/TIME  '\n         DC    CL31'END DATE/TIME    DURATION  MXRC'\nJOBTAB   DC  20CL62' '\n         DC    X'FF'\nEXTRA    DC    CL62' '\nTERMPART DC    CL2' '\nTERMTYPE DC    CL4' '\nPROMPT   DC    C'ENTER START AS:  MM/DD/YY,HH:MM'\nPROLEN   EQU   *-PROMPT\nREPLY    DS    CL80\nREPLYLEN EQU   *-REPLY\nCONSOLE  CCB   SYSLOG,CONCCW1\nCONCCW1  CCW   9,*,X'00',60\n         LTORG ,\n         END   HARDSUMM\n\nLawrence Holder\nSenior Programmer/Analyst\nUniversity of Tennessee (USA)                              c UTMCC 1992\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT947/FILE947.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT947", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}