{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012919000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE834.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE834.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x08'", "DS1TRBAL": "b'\\x86\\xce'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xcb\\x00\\x08\\x05\\xcc\\x00\\x00\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x10\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x16P\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T16:50:10", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  834\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE834\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,109 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/14/12    16:50:09    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x10\"O\\x01\\x10\"O\\x11\\x04\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-08-12T00:00:00", "modifydate": "2010-08-12T11:04:33", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Migrate macro\nFrom:    \"EXI-Vasilenko, Alexander I\" <Alexander.I.Vasilenko@boeing.com>\nDate:    Sun, 18 Jul 2010 22:48:16 -0700\nTo:      \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi, Sam again!\n\nI could propose one more macro. It was written about year ago to\nfacilitate migration of data sets to another system. It is another\nalternative way to allocate data sets.\n\nIdea of this macro is very simple. When I run MIGRATE with REQ\noption then allocation attributes are asked and stored in the\nfile. Now I can send this file to other system and perform\nMIGRATE ALLOC, it doesn't matter with the same names or new.\n\nIn archive:\n\nMIGRATE   - macro.\n\nDSLIST    - list of data sets before MIGRATE REQ.\n\nDSLIST2   - the same list after MIGRATE REQ. This list is ready\n            to allocate with MIGRATE ALLOC.\n\nWith best wishes,\nAlexander I. Vasilenko,\n\nWIRS Sustaining,\nProgrammer, Luxoft\nPhone: (495) 967-80-30 (ext. 3367)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x16I\\x00$\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T16:49:33", "lines": 36, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Migrate Tool Upgrade\nFrom:     \"EXI-Vasilenko, Alexander I\"\n          <Alexander.I.Vasilenko@boeing.com>\nDate:     9/14/2012 7:01 AM\nTo:       \"Sam Golob (sbgolob@cbttape.org)\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nI've never thought that my MIGRATE macro became so useful. We\nhave more than 2000 of PO/PS Data Sets and about 2000 GDGs. It\nwould difficult to allocate all of this manually. But as we have\nDS for different regions of ENDEVOR, we use variables in our JCL.\nSo I have redesign my old macro and create some more to train\nthis tool to understand variables in DSN.\n\nNow I have full package to prepare DSN list from existing JCL and\nallocate all PO/PS and GDG. And I'd like to propose it to you.\nMay be it will useful for somebody else.\n\nWe use this Tool for migration from one ENDEVOR region to\nanother, to reallocate DS in case it allocation parameters were\nchanged and so on.\n\nAlso I send some of my other commands and macros.\n\nKind regards,\nAlexander Vasilenko\nLeading programmer\nLuxoft Moscow\n\nTel: +7 (495) 967 8030\nTel (ext.): (85) 3367\nMobile: +7 926 962 3854\n\nwww.luxoft.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DOC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x03 \\x00\\x17\\x00\\x17\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T03:20:34", "lines": 23, "newlines": 23, "modlines": 0, "user": "IS0485"}, "text": "  This PDS contains some REXX procedures.\n\n  Migrate Toll.\n  1. DELDUP   - macro to delete duplicate lines.\n  2. EXTRDISP - macro to extract DSN and DISP from SRCHFOR file.\n  3. GDGALLOC - requests and defines GDG.\n  4. MIGRATE  - requests and allocated PDS/PDSE and PS.\n  5. QDS      - determines DS type.\n  6. LIST#UG  - desribes how to prepare DSN list from JCL.\n  7. MIRG#UG  - describes how to use migrate macros.\n\n  Some other macros and commands.\n     COMMENT  - this EDIT macro allow comment and uncomment.\n     MARK     - convenient EDIT macro to mark edited lines with\n                certain label in 73-80 positions.\n     MARKC    - similar as MARK but performs marking base on COMPARE\n                result.\n     SETREPL  - CLIST procedure to change ZMCREP ISPF variable,\n                responsible to replacement of member in COPY/MOVE\n                operation. You may perform it from ISRUDSM panel.\n     VIEWPOOL - simple REXX to view variable pools.\n     WHATCHA  - EDIT macro to see which lines were changed and how.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#TST": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x02\\x11\\x00\\x05\\x00\\x05\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T02:11:39", "lines": 5, "newlines": 5, "modlines": 0, "user": "IS0485"}, "text": "//SETSTMT  SET AMSSUF=WIR8\n//SETSTMT  SET DBDSNM1=WIRSIT18\n//SETSTMT  SET DBDSNM2=IT18\n//SETSTMT  SET DDOTQ=D.WIRL\n// AND SO ON\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE834": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x02\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x16P\\x00H\\x00H\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T16:50:02", "lines": 72, "newlines": 72, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 834 is from Alexander I. Vasilenko and contains an edit   *   FILE 834\n//*           macro which helps you allocate datasets from one      *   FILE 834\n//*           system to another system, and it preserves all the    *   FILE 834\n//*           allocation attributes.  You supply a list of datasets *   FILE 834\n//*           to the macro and edit them on the sending system.     *   FILE 834\n//*           The macro then runs LISTDSI and fills in all the      *   FILE 834\n//*           dataset attributes on the right side of the file.     *   FILE 834\n//*           (The file has to be at least LRECL=131.)  On the      *   FILE 834\n//*           sending system, you invoke the macro as:              *   FILE 834\n//*                                                                 *   FILE 834\n//*                MIGRATE REQ       (This puts attributes into     *   FILE 834\n//*                                   the file list of datasets.)   *   FILE 834\n//*                                                                 *   FILE 834\n//*           On the receiving system, you edit the same (modified) *   FILE 834\n//*           file that was produced by the MIGRATE REQ command     *   FILE 834\n//*           on the sending system.  This time, you invoke:        *   FILE 834\n//*                                                                 *   FILE 834\n//*                MIGRATE ALLOC                                    *   FILE 834\n//*                                                                 *   FILE 834\n//*           and the macro will allocate all the datasets, with    *   FILE 834\n//*           their proper attributes, on the receiving system.     *   FILE 834\n//*                                                                 *   FILE 834\n//*           Sample \"before\" and \"after\" dataset lists are         *   FILE 834\n//*           provided in XMIT format as member SAMPLES.  After     *   FILE 834\n//*                TSO RECEIVE INDS(this.pds(SAMPLES))              *   FILE 834\n//*           you will get a pds with LRECL=133 that shows the      *   FILE 834\n//*           \"before REQ\" and \"after REQ\" dataset lists.           *   FILE 834\n//*                                                                 *   FILE 834\n//*           email: Alexander.I.Vasilenko@boeing.com               *   FILE 834\n//*                  Ali_vas@mail.ru                                *   FILE 834\n//*                                                                 *   FILE 834\n//*           --------------------------------------------------    *   FILE 834\n//*                                                                 *   FILE 834\n//*    >>>    This file now contains some other edit macros from    *   FILE 834\n//*    >>>    Alexander Vasilenko.  Alex has made a new shipment    *   FILE 834\n//*    >>>    of his MIGRATE macro, but I have preserved the old    *   FILE 834\n//*    >>>    version of this file in IEBUPDTE SYSIN format (or     *   FILE 834\n//*    >>>    actually PDSLOAD format) as member OLD834, just in    *   FILE 834\n//*    >>>    case somebody would like to refer to Alex's older     *   FILE 834\n//*    >>>    work.                                                 *   FILE 834\n//*                                                                 *   FILE 834\n//*    This PDS now contains some more REXX procedures.             *   FILE 834\n//*                                                                 *   FILE 834\n//*    Needed for MIGRATE:                                          *   FILE 834\n//*                                                                 *   FILE 834\n//*    1. DELDUP   - macro to delete duplicate lines.               *   FILE 834\n//*    2. EXTRDISP - macro to extract DSN and DISP from             *   FILE 834\n//*                  SRCHFOR file.                                  *   FILE 834\n//*    3. GDGALLOC - requests and defines GDG.                      *   FILE 834\n//*    4. MIGRATE  - requests and allocated PDS/PDSE and PS.        *   FILE 834\n//*    5. QDS      - determines DS type.                            *   FILE 834\n//*    6. LIST#UG  - desribes how to prepare DSN list from          *   FILE 834\n//*                  JCL.                                           *   FILE 834\n//*    7. MIRG#UG  - describes how to use migrate macros.           *   FILE 834\n//*                                                                 *   FILE 834\n//*    Some other macros and commands.                              *   FILE 834\n//*                                                                 *   FILE 834\n//*       COMMENT  - this EDIT macro allows comment and             *   FILE 834\n//*                  uncomment.                                     *   FILE 834\n//*       MARK     - convenient EDIT macro to mark edited           *   FILE 834\n//*                  lines with certain label in 73-80              *   FILE 834\n//*                  positions.                                     *   FILE 834\n//*       MARKC    - similar as MARK but performs marking           *   FILE 834\n//*                  base on COMPARE result.                        *   FILE 834\n//*       SETREPL  - CLIST procedure to change ZMCREP ISPF          *   FILE 834\n//*                  variable, responsible to replacement of        *   FILE 834\n//*                  member in COPY/MOVE operation. You may         *   FILE 834\n//*                  perform it from ISRUDSM panel.                 *   FILE 834\n//*       VIEWPOOL - simple REXX to view variable pools.            *   FILE 834\n//*       WHATCHA  - EDIT macro to see which lines were             *   FILE 834\n//*                  changed and how.                               *   FILE 834\n//*                                                                 *   FILE 834\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMMENT": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x00(\\x00\\xd2\\x00\\xa9\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:28:46", "lines": 210, "newlines": 169, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n   This macro comments or uncomments certain strings in edited member.\n   You must define MASK in your profile before using this macro.\n   Also BOUNDS from your profile will be used.\n\n   Call format:\n\n   COMMENT (comment_string) (FORCE)\n\n   comment_string.\n           Commonly mask value from EDIT profile will be used as\n           comment string.\n           You may issue desired string as option.\n\n   FORCE.\n           Use this option to force macro to comment selected lines\n           regardless of contents. (See change history 14.12.2011).\n\n   Also use line command 'S' and 'O' in conjuction with the makro.\n           Use 'S' to shift commented line.\n           Use 'O' to ovwrwrite it.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n/*   Change history.\n     14.12.2011 - macro determins if comments will be removed or\n                  inserted depending of first line of range.\n                  If first line is commented out, then comments will\n                  be removed. If first line is not ommented out, then\n                  this line will be commented.\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\n/*                                                                   */\nif substr(parms,1,1) = '?' then\n  call Show_help\n\n/*       Main line                                                   */\nupper parms\ntrace o\n/*                 */\nBlank = '          '\nParmGiven = 1\nshift = 1   /* it is default value */\nCmask    = ''\nOverCond = 0\nForce    = 0\nAddress ISREDIT\n\"(MYSTATE) = USER_STATE\"\n\"(MASK)  = MASKLINE\"\n\"(LB,RB) = BOUNDS\"\nRB = RB + 1\n\"(LREC)  = LRECL\"\nSlen     = RB - LB  /* text length within bounds */\n/*\nif Cmask = ' ' then do\n  ZEDSMSG = 'MASK not defined.'\n  ZEDLMSG = 'You must define MASK in your profile.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  exit 4\nend */\nif Parms \\= '' then do\n  If wordpos('FORCE',Parms) > 0 then do\n    Force = 1\n    parse var Parms Cmask 'FORCE'\n    Cmask = strip(Cmask)\n  end\n  else do\n    Force = 0\n  end\nend\nIf Cmask = '' then\n  Cmask = Mask     /* mask from profile */\n'process range O S'\nif RCode = 4 then do\n  ZEDSMSG = 'Range Error.'\n  ZEDLMSG = 'You must use O or S line command to define range.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  exit 4\nend\n'(FIRSTLN) = LINENUM .ZFRANGE'\n'(LASTLN)  = LINENUM .ZLRANGE'\n'(CMD)     = RANGE_CMD'\nselect\n  when CMD = 'S' then\n    shift = 1\n  when CMD = 'O' then\n    shift = 0\n  otherwise\n    ZEDSMSG = 'Range Error.'\n    ZEDLMSG = 'You must use O or S line command to define range.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    exit 4\nend\nCmask = strip(Cmask)\nML = length(Cmask)     /* length of mask */\ndo l = FirstLn to LastLn\n  '(TEXT) = LINE ' l\n  Rest = substr(Text,RB)\n  Text = substr(Text,LB,Slen)\n  Text = strip(Text,T)\n  If Force then do\n    Remove = 0\n    Insert = 1\n  end\n  else do\n/*if l = FirstLn then do */ /* this line determine rem/ins oper */\n    if substr(Text,1,ML) = Cmask then do\n      Remove = 1\n      Insert = 0\n    end\n    else do\n      Remove = 0\n      Insert = 1\n    end\n  end\n/*end */ /* this line determine rem/ins oper according first line */\n  if Remove then do\n    if substr(Text,1,ML) = Cmask then\n      call Remove_Comment\n  end\n  else do\n    call Ins_Comment\n  end\nend\n\"USER_STATE = (MYSTATE)\"\nexit 0\n/*                    */\nIns_comment:\n  if \\ParmGiven then do\n    if substr(Text,1,ML) = ''  then\n      shift = 0\n    else\n      shift = 1\n  end\n  if shift then do\n    if length(Cmask) + length(Text) >= RB then do\n      ZEDSMSG = 'BOUNDS.'\n      ZEDLMSG = 'Some data may be lost after shifting in line 'L'.',\n      'You may reformat this string or change bounds.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n/*    exit 4 */\n    end\n    Text = Cmask||Text\n    Text = overlay(Rest,Text,RB)\n    \"LINE \"l\" = (TEXT)\"\n  end\n  else do\n    if (substr(Text,1,ML) \u00ac= '') then\n      OverCond = 1\n    Text = overlay(Cmask,Text,1,ML)\n    Text = overlay(Rest,Text,RB)\n    \"LINE \"l\" = (TEXT)\"\n    if OverCond then do\n      ZEDSMSG = 'Overwrite.'\n      ZEDLMSG = \"Text in commented lines has been overwritten.\",\n      \"If you want to recover this text, undo the last action\",\n      \"and reformat the string or use SHIFT option.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n/*    exit 4 */\n    end\n  end\nReturn\n\nRemove_comment:\n  if \\ParmGiven then do\n    if substr(Text,ML + 1,ML) = ''  then\n      shift = 0\n    else\n      shift = 1\n  end\n  if shift then do\n    Text = Substr(Text,ML+1)\n    Text = overlay(Rest,Text,RB)\n    \"LINE \"l\" = (TEXT)\"\n  end\n  else do\n    Blank = substr(Blank,1,ML)\n    Text = overlay(Blank,Text,1,ML)\n    Text = overlay(Rest,Text,RB)\n    \"LINE \"l\" = (TEXT)\"\n  end\nReturn\n\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\nexit 0\n\nERROR:\nif RC = 4 then do\n  RCode = 4\n  return RCode\nend\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDUP": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00(\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x000\\x00a\\x00Z\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:30:28", "lines": 97, "newlines": 90, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n   This macro deletes equal strings.\n   File must be sorted before this command execution.\n   It is possible to enter first and last positions for compare.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nupper parms\nif word(parms,1) = '?' |,\n   word(parms,1) = 'HELP'\n  then do\n  Show_help:\n  eoh = 0\n  do line = 3 until eoh\n    if substr(sourceline(line + 1),1,2) = '*/' then\n      eoh = 1\n    say sourceline(line)\n  end\nend\n/*                                */\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\ntrace o\n/*                 */\nAddress ISREDIT\nFend    = 0\nl       = 1\nc       = 0\nsubstring = 0\nif parms \u00ac= '' then do\n  parse var parms fpos lpos .\n  substring = 1\n  lpos = word(parms,2)\n  if verify(fpos,'1234567890') > 0 |,\n     verify(lpos,'1234567890') > 0 then do\n    say '  Positions must be numerical.'\n    exit 4\n  end\nend\n'(LNUM)    = LINENUM .ZLAST'\n'(TEXTO) = LINE ' l\nl = l + 1\n\ndo until Fend\n  '(TEXT) = LINE ' l\n  if l >= Lnum then\n    Fend = 1\n  if substring then do\n    T1 = substr(Text,fpos,lpos-fpos+1)\n    T2 = substr(TextO,fpos,lpos-fpos+1)\n  end\n  else do\n    T1 = Text\n    T2 = TextO\n  end\n  if T1 = T2 then do\n    delete l\n    c = c + 1\n    Lnum = Lnum - 1\n  end\n  else do\n    TextO = Text\n    l = l + 1\n  end\nend\nif c > 0 then do\n  ZEDSMSG = \"Deleted \"c\" lines.\"\n  ZEDLMSG = \"Some lines have been deleted from edited file.\"\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nend\nexit\n/*                    */\nERROR:\nif RC = 4 then do\n  Range_RC = RC\n  firstln  = 1\n  '(LNUM)    = LINENUM .ZLAST'\n  return\nend\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\n  say 'Curr line = ' l 'Total lines = ' Lnum\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXTRDISP": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x00&\\x00\\x9c\\x00\\xa7\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:26:16", "lines": 156, "newlines": 167, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n   This macro allows build differents lists according to search\n   argument.\n   It must be used after SuperC is done.\n   Find both DISP= and DSN= before use.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nupper parms\nif word(parms,1) = '?' |,\n   word(parms,1) = 'HELP'\n  then do\n  Show_help:\n  eoh = 0\n  do line = 3 until eoh\n    if substr(sourceline(line + 1),1,2) = '*/' then\n      eoh = 1\n    say sourceline(line)\n  end\n  exit 0\nend\n/* Check if output data set exist */\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\ntrace o\nblanks = ' '\nblank_line = '                                      '\nend_text   = 0\nDSN_found  = 0\n/*                 */\nAddress ISREDIT\n'(LNUM)    = LINENUM .ZLAST'\n'(TEXT) = LINE ' 1\nif word(Text,2) \\= 'ISRSUPC' then call Warn_exit\ntrace o\n/* find search argument */\na = 0 /* number of arguments */\ndo l = 1 by 1 for Lnum\n  if l = lnum then do\n    say 'SRCHFOR not found.'\n    exit 1008\n  end\n  '(TEXT) = LINE ' lnum - l\n  Text = translate(Text,' ',\"'\")\n  select\n    when pos('SRCHFOR   DISP=',Text) > 0 then do\n      StAr_disp = 'DISP='\n    end\n    when pos('SRCHFOR   DSN=',Text) > 0 then do\n      StAr_dsn = 'DSN='\n    end\n    when word(Text,1) = 'SELECT' then\n      iterate l\n    when substr(Text,2,13) = 'THE FOLLOWING' then do\n      leave l\n      end\n  otherwise\n      iterate l\n  end\nend\ntrace o\ndo l = 1 to lnum\n  '(TEXT) = LINE ' l\n  if pos('SEARCH-FOR SUMMARY SECTION',Text) > 0 then do\n    end_text = 1\n  end\n  if word(Text,3) = 'STRING(S)' then do\n    Member = word(Text,1)\n    Text   = delword(Text,1)\n/*  Text   = overlay('***',text,1)\n    Text   = overlay(member,text,5) */\n    'LINE' l ' = (TEXT)'\n  end\n  else do\n    if end_text then do\n      Text = delstr(Text,1)\n      'LINE' l ' = (TEXT)'\n    end\n    else do\n      if (pos(' DD ',Text) > 0)&(DSN_found) then do\n        TextL = delstr(TextL,1)\n/*      TextL = overlay(memberL,textL,1)*/\n        TextL = overlay(DSN_Arg,textL,3)\n        TextL = overlay(DISP_Arg,textL,48)\n        'LINE' l-1 ' = (TEXTL)'\n        DSN_found = 0\n      end\n      Text = translate(Text,' ',',')\n      APos_dsn = pos(StAr_dsn,Text)\n      APos_disp = pos(StAr_disp,Text)\n      select\n        when (APos_dsn > 0)&(APos_disp > 0) then do\n/*        DSN_found = 1*/\n          Temp = Substr(Text,APos_dsn+length(StAr_dsn))\n          DSN_Arg = word(Temp,1)\n          parse var DSN_Arg DSN_Arg '(' .\n          Temp = Substr(Text,APos_disp+length(StAr_disp))\n          DISP_Arg = word(Temp,1)\n          Text = delstr(Text,1)\n/*        Text = overlay(member,text,1)*/\n          Text = overlay(DSN_Arg,text,3)\n          Text = overlay(DISP_Arg,text,48)\n          'LINE' l ' = (TEXT)'\n        end\n        when (APos_dsn > 0)&(APos_disp = 0) then do\n          DSN_found = 1; MemberL = Member\n          Temp = Substr(Text,APos_dsn+length(StAr_dsn))\n          DSN_Arg = word(Temp,1)\n          parse var DSN_Arg DSN_Arg '(' .\n          DISP_Arg = '---'\n          Text = delstr(Text,1)\n          'LINE' l ' = (TEXT)'\n        end\n        when (APos_dsn = 0)&(APos_disp > 0) then do\n          Temp = Substr(Text,APos_disp+length(StAr_disp))\n          DISP_Arg = word(Temp,1)\n          Text = delstr(Text,1)\n          'LINE' l ' = (TEXT)'\n        end\n        otherwise do\n          Text = delword(Text,1)\n          'LINE' l ' = (TEXT)'\n        end\n      end\n    end\n  end\nend\n\"EXCLUDE '\"blank_line\"' ALL 3 40\"\n'DEL X ALL'\n'RES'\nreturn\n/*                    */\nERROR:\nif RC = 4 then do\n  Range_RC = RC\n  firstln  = 1\n  '(LNUM)    = LINENUM .ZLAST'\n  return\nend\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\n  say 'String - ' l\nexit 1004\n/*                    */\nWarn_exit:\nsay '   This macro is allowed only in SuperC contents.'\nexit 1000\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGALLOC": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x005\\x01y\\x01y\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:35:54", "lines": 377, "newlines": 377, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n       Version 2. 03.02.2011\n       This macro was created from MIGRATE one. It uses for allocation\n   of GDG.\n   You must have PS or PDS/PDSE data set 133 LRECL for data set\n   attributes list. Perform 'NUM OFF' edit command!!!\n   Insert DSNs in columns 12-55. After macro is run, allocation\n   attributes appear in the right columns. This information will be\n   used as input for new DS allocation.\n\n          Call format:\n\n          GDGALLOC (REQ|ALLOC (DEL)|?) {FOR Region}\n\n          REQ   - for request allocation attributes.\n          ALLOC - for new DS allocation using retrieved attributes.\n          DEL   - use this option to delete existing GDG. This\n                  option is  optional. It may be issued only with\n                  ALLOC option.\n                  If GDG already exist, it will be deleted and allocated\n                  again with options from file.\n          FOR   - it is reserved word. If you use it, you must issue\n                  Region too.\n          Region- ENDEVOR region. In common case it is member name\n                  with variavles for substitution into DSN.\n                  You will issue this name without '#' but real\n                  member name is started with '#'.\n                  See Dict parameter of interface to define library\n                  where this member resides.\n          ?     - this help text.\n\n   First position of every string is used for status.\n   * - means comment.\n   A - DS was allocated.\n   D - DS was allocated after deletion.\n   X - DS already exist.\n   E - error during allocation.\n   V - variable in DSN does not exist in dictionary.\n   N - GDG does not exist or error in parameters.\n\n   You also may use range commands according common ISPF rules:\n     Z - for single string;\n     ZZ or Zn - for range of strings.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n/* Change log.\n   12/24 New functionality. Added 'FOR Region' capability.\n   12/28 New format of DS list.\n               - DS name\n               - DISP from JOB/PROC\n               - DS type from IDCAMS\n               - allocation parameters list in the same order.\n   03/18/2011  - New status added. N - DS does not exist.\n   03/21/2011  - history capability is activated.\n   04/15/2011  - print errors in log line.\n   04/20/2011  - blank out param columns before fill attributes.\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nAddress ISPEXEC CONTROL ERRORS RETURN\nS = outtrap(tso_mes.,,noconcat)\nupper parms\n/*                                                                   */\nif substr(parms,1,1) = '?' |,\n   substr(parms,1,1) = ' ' then\n  call Show_help\n/*        Interface  and variavles */    /* 12/24 */\nDict = 'DATALIB.WIRS.SERVBLKP.DICT' /* dictionary */\n/* Dict = 'DATALIB.WIRS.PRDP.SERVPROD.DICT' */\n/*Dict = 'IS0485.TEST.REXX'           test only */\nNewValue. = ''\nRegion  = ' '              /* 03/21/2011 */\nError.  = 0                /* 04/15/2011 */\nOK      = 0                /* 04/20/2011 for OK process */\nEx      = 0                /* 04/20/2011 for already exist */\nForMode = 0\nStPos   = 3 /* 12  data set name start position */\nWrongDSN = \"It is not a real Data Set name. Use macro with option\",\n   \"'FOR Region'.\"\nWrongVar = \"Variabel was not found in configuration file. Check your\",\n           \"configuration.\"\n/*      End of Interface  */\n\n/*       Main line                                                   */\nif pos(' FOR ',parms) > 0 then do                          /* 12/24 */\n  parse var parms . 'FOR' Region .                       /* 12/24 */\n  if Region = '' then do                                 /* 12/24 */\n    say '  Empty Region.'                                /* 12/24 */\n    call Show_Help /* ... and leave macro */             /* 12/24 */\n  end                                                    /* 12/24 */\n  Region = strip(Region)                                 /* 12/24 */\n  ForMode = 1                                            /* 12/24 */\n  DS = \"'\"Dict||\"(#\"||Region||\")'\"                       /* 12/24 */\n  Address TSO \"ALLOC FI(INPUT) DS(\"DS\")\"                 /* 12/24 */\n  if RC > 0 then do                                      /* 12/24 */\n    say \"Data set can't be allocated:\"                   /* 12/24 */\n    say DS ', RC = ' rc                                  /* 12/24 */\n    exit 12                                              /* 12/24 */\n  end                                                    /* 12/24 */\n  Address TSO \"execio * diskr INPUT (stem Input. finis)\" /* 12/24 */\n  Address TSO \"FREE  FI(INPUT)\"                          /* 12/24 */\n  do i = 1 to Input.0                                    /* 12/24 */\n    if pos('SET',Input.i) > 0 then do                    /* 12/24 */\n      parse var Input.i OldValue '=' NewValue            /* 12/24 */\n      OldValue = word(OldValue,words(OldValue))          /* 12/24 */\n      NewValue = word(NewValue,1)                        /* 12/24 */\n      NewValue.OldValue = OldValue NewValue              /* 12/24 */\n    end                                                  /* 12/24 */\n  end                                                    /* 12/24 */\nend                                                      /* 12/24 */\nAddress ISREDIT\n'process range Z'\nRC_Range = RC\n  '(LNUM)    = LINENUM .ZLRANGE'\n  '(FIRSTLN) = LINENUM .ZFRANGE'\n/*'RES' */\n/* Next part determines if logging is required and writes log */\n'(LogM) = LINE ' 1   /* read first line */\nHistory  = 0    /* do not write history */\nLogAFound = 0   /* active log found */\nEndOfLog = 0\ndo i = 1 by 1 until EndOfLog\n  '(LogM) = LINE ' i\n  if substr(LogM,2,4) = ' LOG' then do\n    History  = 1    /* write history */\n    if substr(LogM,6,1) = 'A' then do /* current active log */\n      LogAFound = 1\n      LogPos = i       /* position of active log */\n      LogM = overlay(' LOG ',LogM,2,5)\n      'LINE ' i ' = (LogM)' /* replace line */\n    end\n    else do\n    end\n    iterate\n  end\n  else do\n    if (i = 1) then\n      leave i /* Log not found in first line - no logging */\n    EndOfLog = 1\n    LastPos = i - 1 /* last log position */\n  end\nend\n\nif History then do    /* write log */\n  if LogAFound then do\n    if LastPos = LogPos then do /* active log in last pos */\n      LogPos = 1    /* move it in first line */\n    end\n    else\n      LogPos = LogPos + 1 /* choose nex line for acive log */\n  end\n  else        /* active log not found */\n    LogPos = 1\n  FirstLn = FirstLn + 0 /* to remove 0 from num */\n  Lnum    = Lnum + 0    /* to remove 0 from num */\n  LogM = overlay('*',LogM,1,133) /* comment line and blank out */\n  LogM = overlay('LOGA',LogM,3,4) /* LOG prefix */\n  parse value DATE('U') with cDay '/' cMonth '/' .\n  parse value DATE() with . . cYear\n  cDate = cDay || '/' || cMonth || '/' || cYear\n  cTime = substr(TIME(),1,5)\n  LogM = overlay(cDate,LogM,8,10)\n  LogM = overlay(cTime,LogM,19,8)\n  UserID = UserID()\n  LogM = overlay(UserID,LogM,28,8)\n  LogM = overlay(FirstLn,LogM,37,8)\n  LogM = overlay(Lnum,LogM,46,8)\n  'LINE ' LogPos ' = (LogM)' /* replace line */\nend\n/*   END of logging     03/21/2011 */\n\nselect\n  when substr(word(parms,1),1,3) = 'REQ' then do\n    LogM = overlay('REQ  ',LogM,55,5)   /* 03/21/2011 */\n    LogM = overlay(Region,LogM,65,4)    /* 03/21/2011 */\n    call Fill_attr\n    LogM = strip(LogM,'T')              /* 04/15/2011 */\n    LogM = LogM 'V='Error.v 'N='Error.N 'E='Error.e 'OK='OK 'Ex='Ex\n    'LINE ' LogPos ' = (LogM)'          /* 03/21/2011 */\n  end\n  when substr(word(parms,1),1,5) = 'ALLOC' then do\n    LogM = overlay('ALLOC',LogM,55,5)   /* 03/21/2011 */\n    LogM = overlay(Region,LogM,65,4)    /* 03/21/2011 */\n    if substr(word(parms,2),1,3) = 'DEL' then do\n      LogM = overlay('DEL',LogM,60,3)   /* 03/21/2011 */\n      delete = 1\n    end\n    else\n      delete = 0\n    call Do_Alloc\n    LogM = strip(LogM,'T')              /* 04/15/2011 */\n    LogM = LogM 'V='Error.v 'N='Error.N 'E='Error.e 'OK='OK 'Ex='Ex\n    'LINE ' LogPos ' = (LogM)'          /* 03/21/2011 */\n  end\n  otherwise\n    call No_parm\nend\n\nexit 0\n/*                    */\n\nFill_attr:\ndo l = Firstln to lnum\n  '(TEXT) = LINE ' l\n  if substr(Text,1,1) = '*' then iterate\n  DSN = word((substr(text,StPos,49)),1)    /* 12/28 */\n  parse var DSN DSN '(' . /* isolate DSN */\n  UpdDSN = 0 /* suppose DSN has not been changed */ /* 12/24 */\n  VarFound = 0 /* if '&' was found */                     /* 12/24 */\n  VarAlert = 0                                            /* 12/24 */\n  Call CheckVariable                                      /* 12/24 */\n  if UpdDSN then do /* substitution has benn performed */ /* 12/24 */\n    'LINE_AFTER 'l' = INFOLINE (DSN)'                     /* 12/24 */\n  end                                                     /* 12/24 */\n  else do                                                 /* 12/24 */\n    if VarAlert then                                      /* 12/24 */\n      iterate                                             /* 12/24 */\n    if VarFound & \\ForMode then                           /* 12/24 */\n      iterate                                             /* 12/24 */\n  end                                                     /* 12/24 */\n  Address TSO \"LISTCAT ENTRIES('\"DSN\"') GDG ALL \"\n  if RC > 0 then do\n    call Display_TSO\n    text = overlay('N',text,1,2)\n    Error.N = Error.N + 1              /* 04/15/2011 */\n    'LINE 'l' = (TEXT)'\n    iterate\n  end\n  type = substr(tso_mes.1,1,8) /* must be GDG */\n/*text = substr(text,1,44) */\n  if type \\= 'GDG BASE' then do\n    text = overlay('N',text,1,2)  /* 03/18/2011 */\n    Error.N = Error.N + 1              /* 04/15/2011 */\n    'LINE 'l' = (TEXT)'\n  end\n  else do\n    OK = OK + 1\n    t = translate(tso_mes.7,' ','-')\n    t = word(t,1)||'('||word(t,2)||')' space(subword(t,3),1)\n    text = overlay(' ',text,1)              /* 04.20.2011 */\n    text = overlay(' ',text,StPos + 58,100) /* 04.20.2011 */\n    text = overlay(t,text,StPos + 58) /* 12/28 */\n    'LINE 'l' = (TEXT)'\n  end\nend\nreturn\n\nDo_Alloc:\n\ndo l = Firstln to lnum\n  '(TEXT) = LINE ' l\n  if substr(Text,1,1) = '*' |,              /* 03/18/2011 */\n     substr(Text,1,1) = 'N' then iterate     /* 03/18/2011 */\n  tso_mes.0 = 0\n  Texts = substr(Text,70) /* parameters list 12/28 */\n  DSN   = word((substr(text,StPos,49)),1)      /* 12/28 */\n  parse var DSN DSN '(' . /* isolate DSN */\n  UpdDSN = 0                                        /* 12/24 */\n  VarFound = 0 /* if '&' was found */               /* 12/24 */\n  VarAlert = 0                                      /* 12/24 */\n  Call CheckVariable                                /* 12/24 */\n  if UpdDSN then do                                 /* 12/24 */\n    'LINE_AFTER 'l' = INFOLINE (DSN)'               /* 12/24 */\n  end                                               /* 12/24 */\n  else do                                           /* 12/24 */\n    if VarAlert then                                      /* 12/24 */\n      iterate                                             /* 12/24 */\n    if VarFound & \\ForMode then                           /* 12/24 */\n      iterate                                             /* 12/24 */\n  end                                               /* 12/24 */\n  Options   = strip(substr(text,StPos + 58))         /* 12/28 */\n  SA = 'A'   /* suppose normal allocation */\n  Address TSO \"LISTCAT ENTRIES('\"DSN\"') GDG ALL\"\n  if RC = 0 then do /* entry already exist */\n    if delete then do\n      t = translate(tso_mes.7,' ','-')\n      t = word(t,1)||'('||word(t,2)||')' space(subword(t,3),1)\n      if t = Options then do\n        Ex = Ex + 1\n        text = overlay('X',text,1)\n        'LINE' l ' = (TEXT)'\n        iterate\n      end\n      SA = 'D' /* GDG is allocated after deletion */\n      Address TSO \"DELETE ('\"DSN\"') GDG PURGE\"\n      if RC > 0 then do /* error during deletion */\n        Text = overlay('E',Text,1,2)\n        Error.E = Error.E + 1        /* 04/15/2011 */\n        'LINE 'l' =(TEXT)'\n        call Display_TSO\n        iterate\n      end\n    end\n    else do\n      Ex = Ex + 1\n      Text = overlay('X',Text,1,2)\n      'LINE 'l' =(TEXT)'\n      iterate\n    end\n  end\n  Address TSO \"DEFINE GDG (NAME('\"DSN\"') \" options\n  if RC = 0 then do\n    OK = OK + 1\n    Text = overlay(SA,Text,1,2)\n    'LINE 'l' =(TEXT)'\n  end\n  else do /* error during allocation */\n    Text = overlay('E',Text,1,2)\n    Error.E = Error.E + 1        /* 04/15/2011 */\n    'LINE 'l' =(TEXT)'\n    call Display_TSO\n  end\nend\nreturn\n\nCheckVariable:                                        /* 12/24 */\nif pos('&',DSN) > 0 then do\n  VarFound = 1\n  if ForMode then do\n    parse var DSN FirstPart '&' OldValue '.' LastPart\n    if word(NewValue.OldValue,1) \\= '' then do\n      DSN = FirstPart||word(NewValue.OldValue,2)||LastPart\n      UpdDSN = 1\n      Call CheckVariable\n    end\n    else do /* variable has not been found in config file */\n      UpdDSN = 0\n      VarAlert = 1\n      text = overlay('V',text,1,2)\n      Error.V = Error.V + 1        /* 04/15/2011 */\n      'LINE 'l' = (TEXT)'\n      'LINE_AFTER 'l' = INFOLINE (WrongVar)'\n      'LINE_AFTER 'l' = INFOLINE (DSN)'\n    end\n  end\n  else do\n    text = overlay('N',text,1,2)        /* 03/18/2011 */\n    Error.N = Error.N + 1        /* 04/15/2011 */\n    'LINE 'l' = (TEXT)'\n    'LINE_AFTER 'l' = INFOLINE (WrongDSN)'\n  end\nend\nreturn\n\nDisplay_TSO:\nif tso_mes.0 > 0 then do\n  do si = tso_mes.0 to 1 by -1\n     Temp = tso_mes.si\n    'LINE_AFTER 'l' = INFOLINE (Temp)'\n  end\nend\nreturn\n\nNo_parm:\nsay '  Incorrect parameter was specified - 'word(parms,1)'.'\nsay '  Enter REQ for request of attributes.'\nsay '  Enter ALLOC for allocation process.'\nreturn\n\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\n/* 'RES' */\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIST#UG": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x03\\x04\\x00H\\x00=\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T03:04:00", "lines": 72, "newlines": 61, "modlines": 0, "user": "IS0485"}, "text": "   This User Guide describes all operations you need to compile\n        Data Set list you will use late to allocate DS during\n        migration.\n\n  Full process consist of few steps.\n  1. You must extract Data Set Names from your JCL library. If you\n     have a set fo libraries, then you must repeat this extraction\n     for every library and merge all extraction in one file.\n  2. Cleaning the list. Certainly you will not interested in\n     DISP=NEW Data Sets. Also you do not need system and some others\n     Data Sets. So you must clean up all of these from your list.\n  3. Determine DS types. MIGRATE macro works only with PDS/PDSE and\n     PS (including EXTENDED and LARGE) Data Sets. GDGALLOC macro\n     works with GDG only. The purpose of this step is prepare\n     the list for splitting it to two list: one for PO-PS DS, and\n     other for GDG.\n  4. List splitting.\n  5. Requesting of allocation parameters.\n\n  To accumulate DSN list you must allocate PO Data Set with LRECL=133.\n  All lines with '*' in first position will be treated as comment line.\n  You may include spacial lines fro logging in format:\n  ----+----1-\n  * LOG\n  * LOG\n  '*' must be in first position.\n  You may have as many LOG lines as you need.\n  Last LOG line (active) will be marced 'LOGA'.\n  All LOG lines will be filled by cycle.\n\n  Step 1.\n  At this step you scan your JCL library with Search-For Utility to\n  find out all occurrences of 'DISP=' and 'DSN='.\n  As SRCHFOR list is ready, run EXTRDISP. You have now DSN list with\n  its disposition. Use EDIT commands to discard '(' and ')' in\n  disposition.\n  If you have a set of JCL libraries, you must repeat 'Search-Extract'\n  for every your library.\n  Aggregate all results in one file usinf 'CUT-PASTE' EDIT commands.\n\n  Step 2.\n  Delete from result list all DSN you do not need.\n  For example:\n  x NEW 48 50 all;del x all\n  will delete all DSN with DISP=NEW. Pay attention that you may have\n  blank disposition for any DSN.\n  You may also have in your list system DSN such as 'SYS1' or others.\n  This is a good point to discart all of these.\n  You also may have duplicate names in your list.\n  Use SORT command with DELDUP macro to delete all duplicates.\n\n  Step 3 and 4.\n  Now you must determine the type of all you DSNs.\n  Run QDS macro against the list. This macro inserts DS type next to\n  disposition. You may use now\n  x all;f nonvsam 52 60 all;del x all\n  to build list of all non-VSAM Data Sets, or\n  x all;f 'gdg base' 52 60 all;del x all\n  to build list of all GDG.\n  COPY the list recieved into separate member.\n  Do not mix NONVSAM and GDG BASE in one member.\n\n  Step 5.\n  Open member with your non-VSAM Data Sets and run MIGRATE macro.\n  This macro fills allocation paramerets for every DSN in the list\n  next to the DS type.\n  For member with GDG names run GDGALLOC macro.\n\n  Now you have list of all DS with its allocation parameters.\n  You may send this list to other system or use it to reallocate\n  your DS in case of crush.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MARK": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x006\\x00\\xb0\\x00\\xa4\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:36:31", "lines": 176, "newlines": 164, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n   This macro allows you to set certain marks in colomns 72 - 80.\n   Macro works with COBOL members only.\n   If your Edit PROFILE is not NOSTD COBOL, then macro ask you to\n   change your PROFILE.\n\n   You may use macro in any time within Edit session.\n   It is does not matter if you SAVE member or not. In any case\n   macro correctly works until you leave Edit session.\n\n   Invocation format:\n\n         MARK (metric) (FORCE)\n\n   where metric is set of alfabetic symbols you want to mark the\n   strings with. You may assign null metric (use macro with blank\n   argument in quotes). Macro uses only 8 characters from metric.\n   If your metric has blank (or you issue blank metric) AND\n   you use other arguments, you must close metric in quotes.\n\n   For all non blank metric variable ZMARK will be saved in ISPF\n   profile. Next time you will want to use the macro, you may\n   do not issue metric. It will be fetched from ZMARK variable.\n\n   Use FORCE option to change 73-80 columns even they were not\n   been modified.\n\n   You also may use range commands according common ISPF rules:\n     Z - for single string;\n     ZZ or Zn - for range of strings.\n\n   Examples.\n   MARK TEST       - word 'TEST' will appear in modified strings.\n   MARK 'NEW LINE' - all modified lines will be marked with 'NEW LINE'.\n   MARK ''         - text will be blanked out from 73-80 columns.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n/*  LOG.\n   08.21.2012 FORCE realization.\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\nupper PARMS\ntrace o\nif substr(parms,1,1) = '?' then\n  call Show_help\n\nif wordpos('FORCE',PARMS) > 0 then do\n  parse value PARMS with PARMS \"FORCE\"     /* 08.21.2012 */\n  Force = 1\nend\nelse do\n  Force = 0\nend\nif substr(parms,1,1) = \"'\" then do /*metric may be some words or blank*/\n  parse value PARMS with \"'\" metr \"'\" rest\n  metr = substr(metr,1,8) /* use only 8 char */\n  if metr \u00ac= '' then do\n    ZMARK = metr\n    Address ISPEXEC \"VPUT ZMARK PROFILE\"\n  end\nend\nelse do /* metric is one word */\n  parse value PARMS with metr rest\n  if metr = '' then do\n    Address ISPEXEC \"VGET ZMARK PROFILE\"\n    if RC = 8 then do\n      say ' Variable ZMARK not found.'\n      say ' Use macro with argument.'\n      say ' '\n      call Show_help\n    end\n    else\n      metr = ZMARK\n  end\n  else do\n    ZMARK = metr\n    Address ISPEXEC \"VPUT ZMARK PROFILE\"\n  end\nend\n/*             */\nfirstln      = 1\nEdit_pattern =  '00101110110010000000000000000000'\n/*               12345678901234567890123456789012               */\n/*               ||||||||||||||| reserved       |               */\n/*               ||||||||||||||                                 */\n/*               ||||||||||||||- renumbered                     */\n/*               |||||||||||||- changed by TE, TF, TS           */\n/*               ||||||||||||- changed by >, >>, <, <<          */\n/*               |||||||||||- changed by ), )), (, ((           */\n/*               ||||||||||- changed by CHANGE pimary or        */\n/*               |||||||||              Overlay line commands   */\n/*               |||||||||- overtyped                           */\n/*               ||||||||- data was changed in the next way     */\n/*               |||||||                                        */\n/*               |||||||- created by Insert line commend        */\n/*               ||||||- created by TE                          */\n/*               |||||- created by COPY primary or macro        */\n/*               ||||- created by MOVE primary or macro         */\n/*               |||- Copy or Repeat line command               */\n/*               ||- Move line command                          */\n/*               |- original record (was before editing)        */\n/*say 'metr - 'metr*/\nAddress ISREDIT\n  '(VAR1,VAR2) = NUMBER'\n/*say 'VAR1 - 'var1', VAR2 - 'var2*/\nselect\n  when word(var2,1) = 'NOSTD' &,\n       word(var2,2) = 'COBOL' then do\n    StPos = 67\n  end\n  otherwise\n    '(VAR3)  = LRECL'\n    StPos = var3 - 7\n    var3  = var3 - 0\n    if var1 /= 'OFF' then do\n      'NUM OFF'\n      ZEDSMSG = 'NUM option changed.'\n      ZEDLMSG = 'Profile was changed to allow comments in columns',\n                StPos'-'var3'.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    end\nend\n  Range_RC = 0\n  'process range Z'\n  if Range_RC = 0 then do\n    '(LNUM)    = LINENUM .ZLRANGE'\n    '(FIRSTLN) = LINENUM .ZFRANGE'\n  end\n  do L = firstln to Lnum\n    '(ST) = LINE_STATUS 'L\n    ST = bitand(ST,Edit_pattern)\n    if (index(ST,1,1) > 0) | Force then do    /* 08.21.2012 */\n      '(TEXT) = LINE 'L\n      if words(Text) = 0 then iterate\n      Text = overlay(metr,Text,StPos,8,' ')\n      'LINE 'L' = (TEXT)'\n    end\n  end\nexit 0\n/*                    */\nShow_help:\ntrace o\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\nexit 0\n/*                    */\nERROR:\nif RC = 4 then do\n  Range_RC = RC\n  firstln  = 1\n  '(LNUM)    = LINENUM .ZLAST'\n  return\nend\n  return\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MARKC": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x11)\\x0f\\x01\\x11)\\x0f\\x02A\\x00\\x84\\x00\\x84\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2011-10-17T02:41:04", "lines": 132, "newlines": 132, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n\n   This macro writes labels in comment columns based on COMPARE\n   results.\n\n   Format:\n   MARKC metric\n\n   Metric  - 1-8 symbols, You'd like to see as label.\n             You must use quotes if metric includes blanks.\n\n   For all non blank metric variable ZMARKC will be saved in ISPF\n   profile. Next time you will want to use the macro, you may\n   do not issue metric. It will be fetched from ZMARKC variable.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\n/*                                 */\nif substr(parms,1,1) = '?' then\n  call Show_help\nif substr(parms,1,1) = \"'\" then do\n  parse upper value PARMS with \"'\" metr \"'\" rest\n  metr = substr(metr,1,8) /* use only 8 char */\n  if metr \u00ac= '' then do\n    ZMARKC = metr\n    Address ISPEXEC \"VPUT ZMARKC PROFILE\"\n  end\nend\nelse do\n  parse upper value PARMS with metr rest\n  if metr = '' then do\n    Address ISPEXEC \"VGET ZMARKC PROFILE\"\n    if RC = 8 then do\n      say ' Variable ZMARKC not found.'\n      say ' Use macro with argument.'\n      say ' '\n      call Show_help\n    end\n    else\n      metr = ZMARKC\n  end\n  else do\n    ZMARKC = metr\n    Address ISPEXEC \"VPUT ZMARKC PROFILE\"\n  end\nend\n/* code to form labels */\nLmas = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nx. = 1\n\n/* code to form labels */\n\nAddress ISREDIT\n  '(VAR1,VAR2) = NUMBER'\n  select\n    when word(var2,1) = 'NOSTD' &,\n         word(var2,2) = 'COBOL' then do\n      StPos = 67\n    end\n    when word(var2,1) = 'STD'  then do\n      StPos = 73\n      'NUM OFF'\n      ZEDSMSG = 'NUM option changed.'\n      ZEDLMSG = 'Profile was changed to allow comments in columns 73-80.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n/*    'BNDS 7 80' */\n    end\n  otherwise\n    StPos = 73\n  end\n\nRange_RC = 0\nScanEnd  = 0\nLprev    = 0\n\ndo forever\n  I1 = substr(Lmas,x.1,1)\n  I2 = substr(Lmas,x.2,1)\n  I3 = substr(Lmas,x.3,1)\n  I4 = substr(Lmas,x.4,1)\n  LabName = '.O'I4||I3||I2||I1\n  '(LCUR) = LINENUM ' LabName\n  if RC = 8 then\n    leave\n  '(TEXT) = LINE 'LCur\n/*if substr(TEXT,1,1) = '*' then iterate\n  if words(Text) = 0 then iterate*/\n  Text = overlay(metr,Text,StPos,8,' ')\n  'LINE 'LCur' = (TEXT)'\n  call graw 'x.1 x.2'\nend\nexit 0\n/*                    */\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\nexit 0\n\ngraw:\nparse arg x '.' i y '.' j\nx.i = x.i + 1\nif x.i > length(lmas) then do\n  x.i = 1\n  call graw 'x.'j 'x.'j+1\nend\nreturn\n\nERROR:\nif RC = 8 then\n  return\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MIGRATE": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x11\\x00'\\x01\\t(O\\x01\\x12%\\x8f\\x007\\x01\\xea\\x00\\xe8\\x01\\xea\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@\"", "ispf": {"version": "01.17", "flags": 0, "createdate": "2009-10-11T00:00:00", "modifydate": "2012-09-14T00:37:27", "lines": 490, "newlines": 232, "modlines": 490, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n       This macro was designed for facilitate new data sets allocation.\n   You must have PS or PDS/PDSE data set at least 133 LRECL for data\n   set attributes list. Perform 'NUM OFF' edit command!!!\n   Insert DSNs in columns 12-55. After macro is run, allocation\n   attributes appear in the right columns. This information will be\n   used as input for new DS allocation.\n\n          Call format:\n\n          MIGRATE (REQ|ALLOC (DEL)|?) {FOR Region}\n\n          REQ   - for request allocation attributes.\n          ALLOC - for new DS allocation using retrieved attributes.\n          DEL   - use this option to delete existing data sets. This\n                  option has effect only with ALLOC option.\n                  Macro will check if attributes of old DS are the same\n                  as in data set list. If no one of attributes differ\n                  from existing DS, then deletion will not be performed.\n                  Otherwise existing Ds will be deleted and a new one\n                  will be allocated.\n          FOR   - it is reserved word. If you use it, you must issue\n                  Region too.\n          Region- ENDEVOR region. In common case it is member name\n                  with variavles for substitution into DSN.\n                  You will issue this name without '#' but real\n                  member name is started with '#'.\n                  See Dict parameter of interface to define library\n                  where this member resides.\n          ?     - this help text.\n\n   First position of every string is used for status.\n   * - means comment or DS incompatible.\n   A - DS was allocated.\n   D - DS was allocated after deletion.\n   X - DS already exist.\n   E - error during allocation.\n   I - one or more attributes missing.\n   V - variable in DSN does not exist in dictionary.\n   N - DS does not exist or error in parameters.\n\n   You also may use range commands according common ISPF rules:\n     Z - for single string;\n     ZZ or Zn - for range of strings.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n/* Change log.\n   12/24 New functionality. Added 'FOR Region' capability.\n   12/28 New format of DS list.\n               - DS name\n               - DISP from JOB/PROC\n               - DS type from IDCAMS\n               - allocation parameters list in the same order.\n   03/03 Macro is learned to recall migrated DS.\n   03/18/2011  - New status is added. N - DS does not exist.\n   03/21/2011  - history capability is activated.\n   03/15/2011  - print errors in log line.\n   04/20/2011  - blank out param columns before fill attributes.\n   08.09.2012  - LARGE and EXTENDED types are recognized\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nAddress ISPEXEC CONTROL ERRORS RETURN\nS = outtrap(tso_mes.,,noconcat)\nupper parms\n/*                                                                   */\nif substr(parms,1,1) = '?' |,\n   substr(parms,1,1) = ' ' then\n  call Show_help\n\n/*        Interface  and variavles */    /* 12/24 */\nDict = 'DATALIB.WIRS.SERVBLKP.DICT' /* dictionary */\n/* Dict = 'DATALIB.WIRS.PRDP.SERVPROD.DICT' */\n/*Dict = 'IS0485.TEST.REXX'           test only */\nNewValue. = ''\nRegion  = ' '            /* 03/21/2011 */\nError.  = 0              /* 04/15/2011 */\nOK      = 0              /* 04/20/2011 for OK process */\nEx      = 0              /* 04/20/2011 for Already exist */\nForMode = 0\nStPos   = 3 /* 12  data set name start position */\nWrongDSN = \"It is not a real Data Set name. Use macro with option\",\n   \"'FOR Region'.\"\nWrongVar = \"Variabel was not found in configuration file. Check your\",\n           \"configuration.\"\n/*      End of Interface  */\n\n/*       Main line                                                   */\nif pos(' FOR ',parms) > 0 then do                          /* 12/24 */\n  parse var parms . 'FOR' Region .                       /* 12/24 */\n  if Region = '' then do                                 /* 12/24 */\n    say '  Empty Region.'                                /* 12/24 */\n    call Show_Help /* ... and leave macro */             /* 12/24 */\n  end                                                    /* 12/24 */\n  Region = strip(Region)                                 /* 12/24 */\n  ForMode = 1                                            /* 12/24 */\n  DS = \"'\"Dict||\"(#\"||Region||\")'\"                       /* 12/24 */\n  Address TSO \"ALLOC FI(INPUT) DS(\"DS\")\"                 /* 12/24 */\n  if RC > 0 then do                                      /* 12/24 */\n    say \"Data set can't be allocated:\"                   /* 12/24 */\n    say DS ', RC = ' rc                                  /* 12/24 */\n    exit 12                                              /* 12/24 */\n  end                                                    /* 12/24 */\n  Address TSO \"execio * diskr INPUT (stem Input. finis)\" /* 12/24 */\n  Address TSO \"FREE  FI(INPUT)\"                          /* 12/24 */\n  do i = 1 to Input.0                                    /* 12/24 */\n    if pos('SET',Input.i) > 0 then do                    /* 12/24 */\n      parse var Input.i OldValue '=' NewValue            /* 12/24 */\n      OldValue = word(OldValue,words(OldValue))          /* 12/24 */\n      NewValue = word(NewValue,1)                        /* 12/24 */\n      NewValue.OldValue = OldValue NewValue              /* 12/24 */\n    end                                                  /* 12/24 */\n  end                                                    /* 12/24 */\nend                                                      /* 12/24 */\nAddress ISREDIT\n\n'process range Z'\nRC_Range = RC\n'(LNUM)    = LINENUM .ZLRANGE'\n'(FIRSTLN) = LINENUM .ZFRANGE'\n/*'RES' */\n/* Next part determines if logging is required and writes log */\n'(LogM) = LINE ' 1   /* read first line */\nHistory  = 0    /* do not write history */\nLogAFound = 0   /* active log found */\nEndOfLog = 0\ndo i = 1 by 1 until EndOfLog\n  '(LogM) = LINE ' i\n  if substr(LogM,2,4) = ' LOG' then do\n    History  = 1    /* write history */\n    if substr(LogM,6,1) = 'A' then do /* current active log */\n      LogAFound = 1\n      LogPos = i       /* position of active log */\n      LogM = overlay(' LOG ',LogM,2,5)\n      'LINE ' i ' = (LogM)' /* replace line */\n    end\n    else do\n    end\n    iterate\n  end\n  else do\n    if (i = 1) then\n      leave i /* Log not found in first line - no logging */\n    EndOfLog = 1\n    LastPos = i - 1 /* last log position */\n  end\nend\n\nif History then do    /* write log */\n  if LogAFound then do\n    if LastPos = LogPos then do /* active log in last pos */\n      LogPos = 1    /* move it in first line */\n    end\n    else\n      LogPos = LogPos + 1 /* choose nex line for acive log */\n  end\n  else        /* active log not found */\n    LogPos = 1\n  FirstLn = FirstLn + 0 /* to remove 0 from num */\n  Lnum    = Lnum + 0    /* to remove 0 from num */\n  LogM = overlay('*',LogM,1,133) /* comment line and blank out */\n  LogM = overlay('LOGA',LogM,3,4) /* LOG prefix */\n  parse value DATE('U') with cDay '/' cMonth '/' .\n  parse value DATE() with . . cYear\n  cDate = cDay || '/' || cMonth || '/' || cYear\n  cTime = substr(TIME(),1,5)\n  LogM = overlay(cDate,LogM,8,10)\n  LogM = overlay(cTime,LogM,19,8)\n  UserID = UserID()\n  LogM = overlay(UserID,LogM,28,8)\n  LogM = overlay(FirstLn,LogM,37,8)\n  LogM = overlay(Lnum,LogM,46,8)\n  'LINE ' LogPos ' = (LogM)' /* replace line */\nend\n/*   END of logging     03/21/2011 */\n\nselect\n  when substr(word(parms,1),1,3) = 'REQ' then do\n    LogM = overlay('REQ  ',LogM,55,5)   /* 03/21/2011 */\n    LogM = overlay(Region,LogM,65,4)    /* 03/21/2011 */\n    call Fill_attr\n    LogM = strip(LogM,'T')                          /* 04/15/2011 */\n    LogM = LogM 'V='Error.v 'N='Error.N 'E='Error.e 'OK='OK 'EX='Ex\n    'LINE ' LogPos ' = (LogM)'          /* 03/21/2011 */\n  end\n  when substr(word(parms,1),1,5) = 'ALLOC' then do\n    LogM = overlay('ALLOC',LogM,55,5)   /* 03/21/2011 */\n    LogM = overlay(Region,LogM,65,4)    /* 03/21/2011 */\n    if substr(word(parms,2),1,3) = 'DEL' then do\n      LogM = overlay('DEL',LogM,61,3)   /* 03/21/2011 */\n      delete = 1\n    end\n    else\n      delete = 0\n    call Do_Alloc\n    LogM = strip(LogM,'T')                          /* 04/15/2011 */\n    LogM = LogM 'V='Error.v 'N='Error.N 'E='Error.e 'OK='OK 'EX='Ex\n    'LINE ' LogPos ' = (LogM)'          /* 03/21/2011 */\n  end\n  otherwise\n    call No_parm\nend\n/*                 */\nexit 0\n/*                    */\nFill_attr:\ndo l = Firstln to lnum\n  '(TEXT) = LINE ' l\n/*Texts = substr(Text,3) */\n  if substr(Text,1,1) = '*' then iterate\n  else do\n    DSN = word((substr(text,StPos,49)),1)\n    parse var DSN DSN '(' . /* isolate DSN if member typed */\n    UpdDSN = 0 /* suppose DSN has not been changed */ /* 12/24 */\n    VarFound = 0 /* if '&' was found */                     /* 12/24 */\n    VarAlert = 0                                            /* 12/24 */\n    Call CheckVariable                                      /* 12/24 */\n    if UpdDSN then do /* substitution has benn performed */ /* 12/24 */\n      'LINE_AFTER 'l' = INFOLINE (DSN)'                     /* 12/24 */\n    end                                                     /* 12/24 */\n    else do                                                 /* 12/24 */\n      if VarAlert then                                      /* 12/24 */\n        iterate                                             /* 12/24 */\n      if VarFound & \\ForMode then                           /* 12/24 */\n        iterate                                             /* 12/24 */\n    end                                                     /* 12/24 */\n\n    x = LISTDSI(\"'\"DSN\"'\" directory recall) /* 03.03.2011 */\n    if SYSREASON = 0 then do\n      if SYSDSORG = 'PS' |,\n         SYSDSORG = 'PO' then do\n        text = overlay(' ',text,StPos + 58,100)   /* 04.20.2011 */\n        text = overlay(SYSDSORG,text,StPos + 58,5)   /* 12/28 */\n        if SYSSEQDSNTYPE = 'LARGE' then do           /* 08.09.2012 */\n          text = overlay('-L',text,StPos + 60,2)     /* 08.09.2012 */\n        end                                          /* 08.09.2012 */\n        if SYSSEQDSNTYPE = 'EXTENDED' then do        /* 08.09.2012 */\n          text = overlay('-E',text,StPos + 60,2)     /* 08.09.2012 */\n        end                                          /* 08.09.2012 */\n        text = overlay(SYSRECFM,text,StPos + 63,8)   /* 12/28 */\n        text = overlay(SYSLRECL,text,StPos + 71,7)   /* 12/28 */\n        text = overlay(SYSBLKSIZE,text,StPos + 78,9) /* 12/28 */\n        text = overlay(SYSUNITS,text,StPos + 87,10)  /* 12/28 */\n        text = overlay(SYSPRIMARY,text,StPos + 97,7) /* 12/28 */\n        text = overlay(SYSSECONDS,text,StPos + 104,7) /* 12/28 */\n        if SYSADIRBLK = '' then\n           SYSADIRBLK = 0\n        text = overlay(SYSADIRBLK,text,StPos + 111,8) /* 12/28 */\n        text = overlay(' ',text,1,1,' ')\n        OK = OK + 1                   /* 04.20.2011 */\n        'LINE' l ' = (TEXT)'\n      end\n      else do\n        temp = 'Data set is not PS or PO organization.'\n        text = overlay(' ',text,StPos + 58,85)\n        text = overlay('N',text,1)         /* 03/18/2011 */\n        Error.N = Error.N + 1          /* 04/15/2011 */\n        text = overlay(temp,text,StPos + 58)\n        'LINE' l ' = (TEXT)'\n      end\n    end\n    else do\n/*    temp = 'RC = ' SYSREASON*/\n      temp = SYSMSGLVL2\n      text = overlay(' ',text,StPos + 58,85)\n      text = overlay('N',text,1)           /* 03/18/2011 */\n      Error.N = Error.N + 1          /* 04/15/2011 */\n      text = overlay(temp,text,StPos + 58)\n      'LINE' l ' = (TEXT)'\n    end\n  end\nend\nreturn\n\nDo_Alloc:\nType  =  ''                                        /* 08.09.2012 */\ndo l = Firstln to lnum\n  '(TEXT) = LINE ' l\n  Texts = substr(Text,StPos + 58) /* check number of parameters 12/28 */\n  if substr(Text,1,1) = '*' |,              /* 03/18/2011 */\n     substr(Text,1,1) = 'N' then iterate    /* 03/18/2011 */\n  else do\n    if words(Texts) < 8 then do /* list incomplete 12/28 */\n      call List_incomplete\n      iterate\n    end\n    DSN    = word((substr(text,StPos,49)),1)    /* 12/28 */\n    parse var DSN DSN '(' . /* isolate DSN if member typed */\n    UpdDSN = 0                                        /* 12/24 */\n    VarFound = 0 /* if '&' was found */               /* 12/24 */\n    VarAlert = 0                                      /* 12/24 */\n    Call CheckVariable                                /* 12/24 */\n    if UpdDSN then do                                 /* 12/24 */\n      'LINE_AFTER 'l' = INFOLINE (DSN)'               /* 12/24 */\n    end                                               /* 12/24 */\n    else do                                           /* 12/24 */\n      if VarAlert then                                /* 12/24 */\n        iterate                                       /* 12/24 */\n      if VarFound & \\ForMode then                     /* 12/24 */\n        iterate                                       /* 12/24 */\n    end                                               /* 12/24 */\n    SA = 'A'   /* suppose normal allocation */\n    x = LISTDSI(\"'\"DSN\"'\" directory recall)   /* 03.03.2011 */\n    if SYSREASON = 0 then do\n      if delete then do\n        call CheckAttrs\n        if Changed then do\n          Address TSO \"DELETE ('\"DSN\"')\"\n          SA = 'D' /* allocation after deletion */\n        end\n        else do\n          Ex = Ex + 1\n          text = overlay('X',text,1)\n          'LINE' l ' = (TEXT)'\n          iterate\n        end\n      end\n      else do\n        Ex = Ex + 1\n        text = overlay('X',text,1)\n        'LINE' l ' = (TEXT)'\n        iterate\n      end\n    end\n    Prim      = word(texts,6)   /* 12/28 */\n    select\n      when word(texts,5) = 'TRACK' then        /* 12/28 */\n        AllocUnit = 'TRACKS'\n      when word(texts,5) = 'CYLINDER' then     /* 12/28 */\n        AllocUnit = 'CYLINDERS'\n      when word(texts,5) = 'BLOCK' then        /* 12/28 */\n        AllocUnit = 'BLOCK('prim')'\n      otherwise\n        say 'AllocUnit = ' word(texts,5) /*this is an error*//* 12/28 */\n        exit 8\n    end\n    Sec       = word(texts,7)   /* 12/28 */\n    Blksz     = word(texts,4)   /* 12/28 */\n    Dsorg     = word(texts,1)   /* 12/28 */\n    if substr(DSOrg,1,2) = 'PS' then do               /* 08.09.2012 */\n      select                                          /* 08.09.2012 */\n        when substr(DSOrg,3,2) = '-L' then            /* 08.09.2012 */\n          Type = 'DSNTYPE(LARGE)'                     /* 08.09.2012 */\n        when substr(DSOrg,3,2) = '-E' then            /* 08.09.2012 */\n          Type = 'DSNTYPE(EXTREQ)'                    /* 08.09.2012 */\n        otherwise                                     /* 08.09.2012 */\n      end                                             /* 08.09.2012 */\n      DSOrg = 'PS'                                    /* 08.09.2012 */\n    end\n    if word(texts,8) = 'NO_LIM' then /* 12/28 */\n      Dir    = 0\n    else\n      Dir    = word(texts,8)    /* 12/28 */\n    Lrecl     = word(texts,3)   /* 12/28 */\n    Rf = word(texts,2)          /* 12/28 */\n    Recfmt    = ''\n    do i = 1 to LENGTH(Rf)\n      if i > 1 then\n        Recfmt  = Recfmt||' '\n      Recfmt  = Recfmt||substr(Rf,i,1)\n    end\n    select\n      when (datatype(word(texts,8)) = 'NUM') &,       /* 12/28 */\n           (word(texts,8)) > 0            then        /* 12/28 */\n        Type  = 'DSNTYPE(PDS)'\n      when word(texts,8) = 'NO_LIM' then\n        Type  = 'DSNTYPE(LIBRARY)'\n      otherwise\n    end\n\n    Address TSO\n    \"Allocate FILE (MALLOC) DSName('\"DSN\"') NEW \"AllocUnit,\n    \"SPACE(\"Prim Sec\") BLKSIZE(\"Blksz\") DIR(\"Dir\") LRECL(\"Lrecl\")\",\n    \"RECFM(\"Recfmt\") DSORG(\"Dsorg\") \"Type\n    Address ISREDIT\n    if RC = 0 then do\n      OK = OK + 1\n      text = overlay(SA,text,1)\n      'LINE' l ' = (TEXT)'\n    end\n    else do\n      text = overlay('E',text,1)\n      Error.E = Error.E + 1       /* 04/15/2011 */\n      'LINE' l ' = (TEXT)'\n      do si = tso_mes.0 to 1 by -1\n         Temp = tso_mes.si\n        'LINE_AFTER 'l' = INFOLINE (Temp)'\n      end\n    end\n    Address TSO\n    \"FREE FILE (MALLOC)\"\n    Address ISREDIT\n  end\nend\nreturn\n\nCheckAttrs:\nif word(Texts,1) \\= SYSDSORG then do        /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,2) \\= SYSRECFM then do        /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,3) \\= SYSLRECL then do        /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,4) \\= SYSBLKSIZE then do      /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,5) \\= SYSUNITS then do        /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,6) \\= SYSPRIMARY then do      /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,7) \\= SYSSECONDS then do      /* 12/28 */\n  Changed = 1\n  return\nend\nif word(Texts,8) \\= SYSADIRBLK then do      /* 12/28 */\n  Changed = 1\n  return\nend\nChanged = 0\nreturn\n\nList_incomplete:\ntext = overlay('I',text,1)\n'LINE' l ' = (TEXT)'\nreturn\n\nCheckVariable:                                        /* 12/24 */\nif pos('&',DSN) > 0 then do\n  VarFound = 1\n  if ForMode then do\n    parse var DSN FirstPart '&' OldValue '.' LastPart\n    if word(NewValue.OldValue,1) \\= '' then do\n      DSN = FirstPart||word(NewValue.OldValue,2)||LastPart\n      UpdDSN = 1\n      Call CheckVariable\n    end\n    else do /* variable has not been found in config file */\n      UpdDSN = 0\n      VarAlert = 1\n      text = overlay('V',text,1,2)\n      Error.V = Error.V + 1      /* 04/15/2011 */\n      'LINE 'l' = (TEXT)'\n      'LINE_AFTER 'l' = INFOLINE (WrongVar)'\n      'LINE_AFTER 'l' = INFOLINE (DSN)'\n    end\n  end\n  else do\n    text = overlay('N',text,1,2)          /* 03/18/2011 */\n    Error.N = Error.N + 1       /* 04/15/2011 */\n    'LINE 'l' = (TEXT)'\n    'LINE_AFTER 'l' = INFOLINE (WrongDSN)'\n  end\nend\nreturn\n\nNo_parm:\nsay '  Incorrect parameter was specified - 'word(parms,1)'.'\nsay '  Enter REQ for request of attributes.'\nsay '  Enter ALLOC for allocation process.'\nreturn\n\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\n/*'RES' */\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MIRG#UG": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x03\\x03\\x001\\x001\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T03:03:40", "lines": 49, "newlines": 49, "modlines": 0, "user": "IS0485"}, "text": "  This file describes of MIGRATE, GDGALLOC and QDS macros using.\n\n  Macros MIGRATE and GDGALLOC perform similar functions but against\n  different types of objects.\n\n  MIGRATE macro requests and allocates PDS, PDSE and PS (including\n  EXTENDED and LARGE) Data Sets.\n\n  GDGALLOC requests and defines GDG.\n\n  QDS macro asks Data Sets type and inserts it in the list.\n\n  Refer to text of macro for full description.\n\n  Lines with '*' in first position are treated as comment and do\n  not processed (LOG lines are exception).\n  Macros ignore lines with 'N' status also.\n  If you like to process such lines, so delete status manually.\n\n  Every macro may work with DSN wich contains variables. If you have\n  such Data Sets, then you must define library with dictionary.\n  This dictionary must contain members with all variables you have\n  in JCL. See #TST member as example.\n  You must provide separate dictionary member for every set of\n  variable values.\n\n  Also you must customise macros (see 'Interface  and variables'\n  section in the macro).\n  Dictionary is used only if you have variables in DSN.\n\n  Some examples.\n  MIGRATE REQ\n  This macro requests allocation parameters. All DSNs can not contain\n  variables.\n\n  MIGRATE ALLOC DEL FOR PROD\n  This macro will allocate Data Sets from the list using #PROD member\n  from dictionary. All existing DS will be deleted.\n\n  GDGALLOC ALLOC FOR TEST\n  This macro will define GDGs using #TEST member of dictionary to\n  substitute variables in DSN. If GDG exist, no action occurs.\n  Appropriate status code in first position will be issued.\n\n  You may use zz-zz line commands to applay macro to certain lines\n  from the list.\n\n  These macros write log. See LIST#UG about LOG lines.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OLD834": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12%\\x8f\\x01\\x12%\\x8f\\x132\\x02u\\x02u\\x00\\x00\\xd6\\xd3\\xc4`\\xf8\\xf3\\xf4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-14T00:00:00", "modifydate": "2012-09-14T13:32:00", "lines": 629, "newlines": 629, "modlines": 0, "user": "OLD-834"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "QDS": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x11)\\x0f\\x01\\x12%\\x8f\\x008\\x00\\xfe\\x00\\xfc\\x00\\xfe\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2012-09-14T00:38:35", "lines": 254, "newlines": 252, "modlines": 254, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n       This macro is designed to determine DS type.\n   You must have PS or PDS/PDSE data set 133 LRECL for data set\n   types list. Perform 'NUM OFF' edit command!!!\n   Insert DSNs in columns 12-55. After macro is run, type of DS\n   appear in the right column.\n\n          Call format:\n\n          QDS (?)\n\n          ?     - this help text.\n\n   First position of every string is used for status.\n   * - means comment.\n   V - variable in DSN does not exist in dictionary.\n   N - DS does not exist.\n\n   You also may use range commands according common ISPF rules:\n     Z - for single string;\n     ZZ or Zn - for range of strings.\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n/* Change log.\n   12/24 New functionality. Added 'FOR Region' capability.\n   12/28 New format of DS list.\n               - DS name\n               - DISP from JOB/PROC\n               - DS type from IDCAMS\n               - allocation parameters list in the same order.\n   03.03 Macro is learned to recall migrated DS.\n   03/21/2011  - history capability is activated.\n   04/15/2011  - print errors in log line.\n   04/20/2011  - blank out param columns before fill attributes.\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nif RC > 0 then do\n  say ' It is EDIT macro. Do not use TSO prefix.'\n  exit 0\nend\nAddress ISPEXEC CONTROL ERRORS RETURN\nS = outtrap(tso_mes.,,noconcat)\nupper parms\n/*                                                                   */\nif substr(parms,1,1) = '?' then\n  call Show_help\n\n/*        Interface  and variavles */    /* 12/24 */\nDict = 'DATALIB.WIRS.SERVBLKP.DICT' /* dictionary */\n/* Dict = 'DATALIB.WIRS.PRDP.SERVPROD.DICT' */\n/*Dict = 'IS0485.TEST.REXX'           test only */\nNewValue. = ''\nRegion  = ' '       /* 03/21/2011 */\nError.  = 0         /* 04/15/2011 */\nForMode = 0\nStPos   = 3 /* 12  data set name start position */\nWrongDSN = \"It is not a real Data Set name. Use macro with option\",\n   \"'FOR Region'.\"\nWrongVar = \"Variabel was not found in configuration file. Check your\",\n           \"configuration.\"\n/*      End of Interface  */\n\n/*       Main line                                                   */\n\nif pos('FOR ',parms) > 0 then do                          /* 12/24 */\n  parse var parms . 'FOR' Region .                       /* 12/24 */\n  if Region = '' then do                                 /* 12/24 */\n    say '  Empty Region.'                                /* 12/24 */\n    call Show_Help /* ... and leave macro */             /* 12/24 */\n  end                                                    /* 12/24 */\n  Region = strip(Region)                                 /* 12/24 */\n  ForMode = 1                                            /* 12/24 */\n  DS = \"'\"Dict||\"(#\"||Region||\")'\"                       /* 12/24 */\n  Address TSO \"ALLOC FI(INPUT) DS(\"DS\")\"                 /* 12/24 */\n  if RC > 0 then do                                      /* 12/24 */\n    say \"Data set can't be allocated:\"                   /* 12/24 */\n    say DS ', RC = ' rc                                  /* 12/24 */\n    exit 12                                              /* 12/24 */\n  end                                                    /* 12/24 */\n  Address TSO \"execio * diskr INPUT (stem Input. finis)\" /* 12/24 */\n  Address TSO \"FREE  FI(INPUT)\"                          /* 12/24 */\n  do i = 1 to Input.0                                    /* 12/24 */\n    if pos('SET',Input.i) > 0 then do                    /* 12/24 */\n      parse var Input.i OldValue '=' NewValue            /* 12/24 */\n      OldValue = word(OldValue,words(OldValue))          /* 12/24 */\n      NewValue = word(NewValue,1)                        /* 12/24 */\n      NewValue.OldValue = OldValue NewValue              /* 12/24 */\n    end                                                  /* 12/24 */\n  end                                                    /* 12/24 */\nend                                                      /* 12/24 */\n\nAddress ISREDIT\n'process range Z'\nRC_Range = RC\n  '(LNUM)    = LINENUM .ZLRANGE'\n  '(FIRSTLN) = LINENUM .ZFRANGE'\n/*'RES'*/\n/* Next part determines if logging is required and writes log */\n'(LogM) = LINE ' 1   /* read first line */\nHistory  = 0    /* do not write history */\nLogAFound = 0   /* active log found */\nEndOfLog = 0\ndo i = 1 by 1 until EndOfLog\n  '(LogM) = LINE ' i\n  if substr(LogM,2,4) = ' LOG' then do\n    History  = 1    /* write history */\n    if substr(LogM,6,1) = 'A' then do /* current active log */\n      LogAFound = 1\n      LogPos = i       /* position of active log */\n      LogM = overlay(' LOG ',LogM,2,5)\n      'LINE ' i ' = (LogM)' /* replace line */\n    end\n    else do\n    end\n    iterate\n  end\n  else do\n    if (i = 1) then\n      leave i /* Log not found in first line - no logging */\n    EndOfLog = 1\n    LastPos = i - 1 /* last log position */\n  end\nend\n\nif History then do    /* write log */\n  if LogAFound then do\n    if LastPos = LogPos then do /* active log in last pos */\n      LogPos = 1    /* move it in first line */\n    end\n    else\n      LogPos = LogPos + 1 /* choose nex line for acive log */\n  end\n  else        /* active log not found */\n    LogPos = 1\n  FirstLn = FirstLn + 0 /* to remove 0 from num */\n  Lnum    = Lnum + 0    /* to remove 0 from num */\n  LogM = overlay('*',LogM,1,133) /* comment line and blank out */\n  LogM = overlay('LOGA',LogM,3,4) /* LOG prefix */\n  parse value DATE('U') with cDay '/' cMonth '/' .\n  parse value DATE() with . . cYear\n  cDate = cDay || '/' || cMonth || '/' || cYear\n  cTime = substr(TIME(),1,5)\n  LogM = overlay(cDate,LogM,8,10)\n  LogM = overlay(cTime,LogM,19,8)\n  UserID = UserID()\n  LogM = overlay(UserID,LogM,28,8)\n  LogM = overlay(FirstLn,LogM,37,8)\n  LogM = overlay(Lnum,LogM,46,8)\n  LogM = overlay('QDS',LogM,55,5,' ')\n  LogM = overlay(Region,LogM,65,4)\n/*   END of logging     03/21/2011 */\nend\n\ndo l = Firstln to lnum\n  '(TEXT) = LINE ' l\n  if substr(Text,1,1) = '*' then iterate\n  DSN = word((substr(text,StPos,49)),1)   /* 12/28 */\n  parse var DSN DSN '(' tail /* isolate DSN */\n  UpdDSN = 0 /* suppose DSN has not been changed */ /* 12/24 */\n  VarFound = 0 /* if '&' was found */                     /* 12/24 */\n  VarAlert = 0                                            /* 12/24 */\n  Call CheckVariable                                      /* 12/24 */\n  if UpdDSN then do /* substitution has been performed */ /* 12/24 */\n    'LINE_AFTER 'l' = INFOLINE (DSN)'                     /* 12/24 */\n  end                                                     /* 12/24 */\n  else do                                                 /* 12/24 */\n    if VarAlert then                                      /* 12/24 */\n      iterate                                             /* 12/24 */\n    if VarFound & \\ForMode then                           /* 12/24 */\n      iterate                                             /* 12/24 */\n  end                                                     /* 12/24 */\n/*text = substr(text,1,44)    get only DS name and blank out all rest */\n  s = SYSDSN(\"'\"DSN\"'\")    /* to recall DS 03.03.2011 */\n  if RC > 0 then do                     /* 03.03.2011 */\n    call Display_TSO                    /* 03.03.2011 */\n    iterate                             /* 03.03.2011 */\n  end                                   /* 03.03.2011 */\n  Address TSO \"LISTCAT ENTRIES('\"DSN\"') \"\n  if RC > 0 then do\n    call Display_TSO\n    iterate\n  end\n  parse var tso_mes.1 type '-' tail\n/*text = overlay(' ',text,StPos + 49,100)     04.20.2011 */\n  text = overlay(' ',text,StPos + 49,008)  /* 04.20.2011 */\n  text = overlay(type,text,StPos + 49)   /* 12/28 */\n  text = overlay(' ',text,1,2)\n  'LINE 'l' = (TEXT)'\nend\n\nif History then do\n  LogM = strip(LogM,'T')\n  LogM = LogM 'V='Error.V 'N='Error.N  /* 04/15/2011 */\n  'LINE ' LogPos ' = (LogM)' /* replace line */\nend\nexit 0\n/*                    */\n\nCheckVariable:                                        /* 12/24 */\nif pos('&',DSN) > 0 then do\n  VarFound = 1\n  if ForMode then do\n    parse var DSN FirstPart '&' OldValue '.' LastPart\n    if word(NewValue.OldValue,1) \\= '' then do\n      DSN = FirstPart||word(NewValue.OldValue,2)||LastPart\n      UpdDSN = 1\n      Call CheckVariable\n    end\n    else do /* variable has not been found in config file */\n      UpdDSN = 0\n      VarAlert = 1\n      text = overlay('V',text,1,2)\n      Error.V = Error.V + 1      /* 04/15/2011 */\n      'LINE 'l' = (TEXT)'\n      'LINE_AFTER 'l' = INFOLINE (WrongVar)'\n      'LINE_AFTER 'l' = INFOLINE (DSN)'\n    end\n  end\n  else do\n    text = overlay('N',text,1,2)\n    Error.N = Error.N + 1  /* 04/15/2011 */\n    'LINE 'l' = (TEXT)'\n    'LINE_AFTER 'l' = INFOLINE (WrongDSN)'\n  end\nend\nreturn\n\nDisplay_TSO:\nif tso_mes.0 > 0 then do\n  Error.N = Error.N + 1       /* 04/15/2011 */\n  text = overlay('N',text,1,2)\n  'LINE 'l' = (TEXT)'\n  do si = tso_mes.0 to 1 by -1\n     Temp = tso_mes.si\n    'LINE_AFTER 'l' = INFOLINE (Temp)'\n  end\nend\nreturn\n\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\n/*'RES' */\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAMPLES": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\"O\\x01\\x10\"O\\x10H\\x009\\x009\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-08-12T00:00:00", "modifydate": "2010-08-12T10:48:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SETREPL": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x11)\\x0f\\x01\\x11)\\x0f\\x02F\\x00\\x15\\x00\\x15\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2011-10-17T02:46:59", "lines": 21, "newlines": 21, "modlines": 0, "user": "IS0485"}, "text": "PROC 1 NEWVALUE\n/* COMMAND CHANGES VALUE OF VARIABLE ZMCREP.\n/*   THIS VARIABLE CONTROLS IF TARGET DATA WILL BE\n/*   REPLACED DURING COPY OR MOVE OPERATION.\n/*\n/*CONTROL LIST SYMLIST CONLIST MSG MAIN\n\n SELECT (&NEWVALUE)\n   WHEN (YES) DO\n     SET &ZMCREP = REPLACE\n   END\n   WHEN (NO) DO\n     SET &ZMCREP =\n   END\n   OTHERWISE DO\n     WRITE VARIABLE MUST BE YES OR NO.\n     EXIT\n   END\n END\n   ISPEXEC VPUT ZMCREP PROFILE\n EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VIEWPOOL": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x11)\\x0f\\x01\\x11)\\x0f\\x02S\\x00#\\x00#\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2011-10-17T02:53:02", "lines": 35, "newlines": 35, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n\n   This command calls panel ISPYXD1.\n\n   Call format:\n\n   VIEWPOOL (ApplID)\n\n       ApplID - application name which variable pool you\n       would like to view. This parameter is optional.\n       If you do not provide it, contents of variable\n       ZAPPLID will be used (usually it is ISR).\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\n\nif arg(1) = '?' then do\n  eoh = 0\n  do line = 3 until eoh\n    if substr(sourceline(line + 1),1,2) = '*/' then\n      eoh = 1\n    say sourceline(line)\n  end\n  exit 0\nend\n/*                          */\nADDRESS ISPEXEC\nif arg() then parse upper arg zapplid .\nelse 'VGET ZAPPLID ASIS'\n'SELECT PGM(ISPYXDR) PARM('ZAPPLID') SCRNAME(VPOOL) NOCHECK'\nexit RC\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WHATCHA": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x11)\\x0f\\x01\\x11)\\x0f\\x02S\\x00\\xae\\x00\\xae\\x00\\x00\\xc9\\xe2\\xf0\\xf4\\xf8\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-10-17T00:00:00", "modifydate": "2011-10-17T02:53:54", "lines": 174, "newlines": 174, "modlines": 0, "user": "IS0485"}, "text": "/* REXX                                                              */\n/*\n\n   This macro finds all strings changed during current edit session.\n   All operations over certain string appears in NOTE strings.\n\n   You may use \"Z\" lline commands to restrict analyzing area.\n\n   Call format:\n\n   WHATCHA (?)\n\n   Author: Alexander I. Vasilenko,\n           LUXOFT, Moscow.\n           e-mail: ali_vas@mail.ru\n                   Alexander.I.Vasilenko@boeing.com\n*/\nAddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nAddress ISPEXEC CONTROL ERRORS RETURN\nCALL ON ERROR\n/*                                                                   */\nif substr(parms,1,1) = '?' then\n  call Show_help\n/*               12345678901234567890                           */\nEdit_pattern =  '01111110111110000000000000000000'\n/*    say '       'Edit_pattern ' sh-'sh 'cm-'cm*/\n/*               12345678901234567890123456789012               */\n/*               ||||||||||||||| reserved       |               */\n/*               ||||||||||||||                                 */\n/*               ||||||||||||||- renumbered                     */\n/*               |||||||||||||- changed by TE, TF, TS           */\n/*               ||||||||||||- changed by >, >>, <, <<          */\n/*               |||||||||||- changed by ), )), (, ((           */\n/*               ||||||||||- changed by CHANGE pimary or        */\n/*               |||||||||              Overlay line commands   */\n/*               |||||||||- overtyped                           */\n/*               ||||||||- data was changed in the next way     */\n/*               |||||||                                        */\n/*               |||||||- created by Insert line commend        */\n/*               ||||||- created by TE                          */\n/*               |||||- created by COPY primary or macro        */\n/*               ||||- created by MOVE primary or macro         */\n/*               |||- Copy or Repeat line command               */\n/*               ||- Move line command                          */\n/*               |- original record (was before editing)        */\n/*       Main line                                                   */\nNoteStr  = ''\nNothingFound = 1\nFline = 0\ntrace o\n/*                 */\nAddress ISREDIT\n  trace o\n'process range Z'\nif RC = 4 then do\n  firstln  = 1\n  '(LNUM)    = LINENUM .ZLAST'\nend\nif RC = 0 then do\n  '(LNUM)    = LINENUM .ZLRANGE'\n  '(FIRSTLN) = LINENUM .ZFRANGE'\nend\nAddress ISPEXEC 'VGET ZSCRMAXD'\n'(CLINE) = LINENUM .ZCSR'  /* current line of edit session */\n'RESET SPECIAL'\ndo l = FirstLn to Lnum\n  '(TEXT) = LINE ' l\n  '(ST) = LINE_STATUS 'L\n  ST = bitand(ST,Edit_pattern)\n  i   = 1 /* position pointer */\n  eos = 0\n  if ST > 0 then do\n    if \u00acFline then do\n      FL    = L     /* remember first line to locate */\n      Fline = 1\n    end\n    do until eos\n      P = pos('1',ST,i)\n      if P > 0 then do\n        NothingFound = 0\n        i = P + 1\n        call FormNote\n      end\n      else\n        eos = 1\n    end\n  end\nend\nif NothingFound then do\n    ZEDSMSG = \"Not changed.\"\n    ZEDLMSG = \"File was not changed.\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nend\nelse do\n  if (Cline+1 > FL) | ((Cline+ZSCRMAXD-7) < FL) then do\n    if FL > 2 then\n      \"LOCATE \" FL - 2\n    else\n      \"LOCATE \" 1\n  end\n  else\n    \"LOCATE \" Cline\nend\nexit 0\n/*                    */\nFormNote:\nselect\n  when P = '1' then do\n  end\n  when P = '2' then do\n    NoteStr   = '   --- Line MOVE '\n  end\n  when P = '3' then do\n    NoteStr   = '   --- Line COPY or REPEAT '\n  end\n  when P = '4' then do\n    NoteStr   = '   --- Primary MOVE or macro '\n  end\n  when P = '5' then do\n    NoteStr   = '   --- Primary COPY or macro '\n  end\n  when P = '6' then do\n    NoteStr   = '   --- TE '\n  end\n  when P = '7' then do\n    NoteStr   = '   --- Line Insert '\n  end\n  when P = '9' then do\n    NoteStr   = '   --- Overtyped '\n  end\n  when P = '10' then do\n    NoteStr   = '   --- Primary CHANGE or Line Overlay '\n  end\n  when P = '11' then do\n    NoteStr   = '   --- ), )), ( or (( '\n  end\n  when P = '12' then do\n    NoteStr   = '   --- >, >>, < or << '\n  end\n  when P = '13' then do\n    NoteStr   = '   --- TE, TF, TS '\n  end\n  when P = '14' then do\n    NoteStr   = '   --- Renumbered '\n  end\nend\ncall InsNote\nreturn\n\nInsNote:\n/*\"LINE_AFTER  \"L\" = NOTELINE '\"NoteStr\"'\" */\n  \"LINE_BEFORE \"L\" = NOTELINE '\"NoteStr\"'\"\nreturn\n\nShow_help:\neoh = 0\ndo line = 3 until eoh\n  if substr(sourceline(line + 1),1,2) = '*/' then\n    eoh = 1\n  say sourceline(line)\nend\nexit 0\n\nERROR:\nif RC = 4 then do\n  return\nend\ntrace o\n  say 'Error in string - 'SIGL', RC - 'RC\n  say sourceline(SIGL)\n  say 'Error text:'\n  say ERRORTEXT(RC)\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT834/FILE834.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT834", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}