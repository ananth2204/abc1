{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011213000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE090.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE090.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x11'", "DS1TRBAL": "b\"'\\xb6\""}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\x8d\\x00\\x02\\x00\\x8d\\x00\\n\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x06O\\x01\\x06\\x06O\\x10F\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-03-05T00:00:00", "modifydate": "2006-03-05T10:46:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  090\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE090\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 19 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,938 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/05/06    10:46:45    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99 \\x7f\\x00\\x99 \\x8f#3\\x00s\\x00s\\x00\\x00\\xe4\\xc2\\xd8\\xf0\\xf0\\xf1@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-07-26T00:00:00", "modifydate": "1999-07-27T23:33:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "UBQ001"}, "text": "\nThis file (CBT File 90) contains the \"Delinker\" package written by\n\n                          David W. Noon\n\nwhich consists of source code (PL/I and Assembler) and documentation.\n\n\nDavid Noon can be contacted by email:  dwnoon@ibm.net           -or-\n                                       dwnoon@compuserve.com\n\nIn March 1999, someone asked how to read and write RECFM=U data from\nPL/I in the comp.lang.pl1 USENET newsgroup.  David Noon posted that\nif a delinker written in PL/I was wanted then just ask.  That's not\nwhat the original poster wanted, but I asked instead, and Dave duly\nemailed it to me.\n\nThe package turned out to be a powerful batch utility to delink,\nresize and even package for later processing (such as distribution\nand reinstallation) some or all CSECTs of nominated load modules.\nIt could, for example, be used in a job stream to replace certain\nCSECTs with newer versions.\n\nI ended up plugging it into REVIEW R31.0 (CBT File 134), so that\nmembers tagged in the member list (or all members if none are\ntagged) can be dynamically delinked.\n\nPlease note that this Delinker will not process scatter-load or\nsegment-overlay programs correctly.  It will only process load\nmodules, and not program objects.\n\nIn case you do not have a suitable PL/I compiler handy, I have supplied\nDELINKI and DWNSPDSR load modules in CBT File 135.  I proposed calling\nthe program DELINK1 to distinguish it from the DELINK/DELINK0 OS/360\nFE Tool (and its derivatives), but Sam Golob preferred DELINKI, so\nDELINKI it is.  (The 1 or I denotes that it is written in PL/I.)\n\nA member contents list follows.\n                                        Greg Price, July 1999.\n\n-MEMBER-   -CONTENTS---------------------------------------------------\n\n$$DOC    - This member.\n\nDCFDOC   - This is a documentation source file Dave made in SGML.\n           It can easily be converted to GML and run through SCRIPT/VS.\n           It can be TEXT transferred to DELINK.IPF on the PC for\n           processing by the IPF compiler.  I resolved a lot (but not\n           all) of character symbolics to get it to fit into an\n           80-column file.  It also made the uncompiled source more\n           readable.\n              &apos.             was replaced by   '\n              &asterisk.         was replaced by   *\n              &colon.            was replaced by   :\n              &comma.            was replaced by   ,\n              &eq.               was replaced by   =\n              &hyphen.           was replaced by   -\n              &lpar.             was replaced by   (\n              &per.              was replaced by   .\n              &plus.             was replaced by   +\n              &rpar.             was replaced by   )\n              &slash.            was replaced by   /\n\nDELINK   - This is the main PL/I source member.\n           It should be compiled with OS PL/I Version 2 or with PL/I\n           for MVS & VM.  Requires DWNSCAN and DWNSHEX to be linked\n           into the program executable, and DWNSPDSR to be fetchable\n           during execution.\n\nDWNMPRLG - PL/I prologue macro used by DWNSCAN and DWNSHEX.\n           Seems to work for OS PL/I Version 2 and PL/I for MVS & VM.\n\nDWNSCAN  - Performs the same function as the PL/I SEARCH built-in\n           function.  The SEARCH and SEARCHR built-in functions are\n           not yet available under MVS (OS/390) at the time of writing.\n           This module should be assembled and made available at bind\n           (ie. link-edit) time for inclusion into the main program.\n\nDWNSHEX  - Performs a similar function to the PL/I HEX built-in\n           function.  The HEX and HEXIMAGE built-in functions are\n           not yet available under MVS (OS/390) at the time of writing.\n           This module should be assembled and made available at bind\n           (ie. link-edit) time for inclusion into the main program.\n\nDWNSPDSR - Provides BPAM support for the main PL/I program.\n           It should be assembled and made available for dynamic\n           fetching at execute time.\n\nDWNYBLDL - PL/I source structure for PDS program directory entry.\n           It was obviously meant to be included in the source by some\n           strange control card (not %INCLUDE), so I just copied it\n           into the source.  This member is therefore no longer used.\n\nFMBLOCK  - Housekeeping macros used by DWNSPDSR, all of which were\nFMCREDT    probably contributed to the SHARE tape by Ken True of\nFMSTART    Fairchild MSS (hence FM, no doubt).  They were moved from\nFMWORK1    from the SHARE tape to the Fairchild MSS \"Mods\" tape,\nFMWORK2    later called the Intel MVS \"Mods\" tape, circa 1982.\n\nPLIICB   - PL/I Interrupt Control Block macro used by DWNSHEX\n           on error conditions.\n\nPLISIG   - PL/I Signal macro used by DWNSHEX on error conditions.\n\nXMITBOOK - TSO/E transmit file of DELINK.INF which was created by\n           compiling DELINK.IPF (source in member DCFDOC) with IPFC\n           under OS/2.  Process with INDATASET operand of the TSO/E\n           RECEIVE command to get a RECFM=U sequential data set.\n           BINARY transfer this file to the PC (byte counts should\n           match).  Use the VIEW command of OS/2 or PC-DOS to look\n           at DELINK.INF which contains the Delinker documentation.\n           The PC-DOS VIEW command also works from the MS-DOS prompt\n           (including under Win95).  Apparently, there is an IVIEW\n           command downloadable from IBM designed to work under Win95.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DOC2": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x06\\x06\\x0f\\x01\\x06\\x06\\x0f\\x13R\\x00#\\x00#\\x00\\x00\\xe4\\xc2\\xd8\\xf0\\xf0\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-01T00:00:00", "modifydate": "2006-03-01T13:52:41", "lines": 35, "newlines": 35, "modlines": 0, "user": "UBQ001"}, "text": "\n Further small changes have been made in March 2006.\n\n Paul Gilmartin discovered that TXT records with a text byte count of\n zero are rejected by the Program Binder.  This is allowed by the\n Linkage Editor.  Since the Linkage Editor does not seem to require\n text for every control section, simply suppressing this TXT record\n fixes this problem.\n\n Looking at this problem made it apparent that my earlier 1999 changes\n exploit Binder control statements not available with the Linkage\n Editor.  If this is a problem then use an editor to delete these\n control statements, such as SETOPT.\n\n Additional changes to support 64-bit addressing mode have been made.\n No changes to support 64-bit residency have been made since the\n Contents Supervisor will not currently load programs \"above the bar\".\n\n I compile this program with PL/I for MVS and VM (V1), which will\n almost certainly be the last of the OS heritage PL/I compilers.\n\n I have not tried to compile it with VisualAge PL/I (V2) or\n Enterprise PL/I (V3) - which have closer ties to C code generation,\n and thus would probably not work with all of the DWN subroutines.\n\n The main inhibitor of moving to the latest compiler would be the\n BPAM support.  Once the details of this have been worked out the\n remaining DWN subroutines could probably be replaced by newer PL/I\n built-in functions.  Note that the program is currently reentrant\n in the OS sense.  Newer compilers only support \"C-style\" reentrancy\n where the executable should not be marked as RENT.\n\n\n                                        Greg Price, March 2006.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE090": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x06O\\x01\\x06\\x06O\\x10F\\x00\\x8f\\x00\\x8f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-03-05T00:00:00", "modifydate": "2006-03-05T10:46:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 090 is from David Noon and is a DELINKER program, which   *   FILE 090\n//*           converts load modules into 80-byte object decks.      *   FILE 090\n//*           This file was prepared for the CBT Tape by Greg       *   FILE 090\n//*           Price.                                                *   FILE 090\n//*                                                                 *   FILE 090\n//*     This file (CBT File 90) contains the \"Delinker\" package     *   FILE 090\n//*     written by David W. Noon which consists of source code      *   FILE 090\n//*     (PL/I and Assembler) and documentation.                     *   FILE 090\n//*                                                                 *   FILE 090\n//*                                                                 *   FILE 090\n//*     David Noon's email:  dwnoon@ibm.net      -or-               *   FILE 090\n//*                       dwnoon@compuserve.com                     *   FILE 090\n//*                                                                 *   FILE 090\n//*     In March 1999, someone asked how to read and write          *   FILE 090\n//*     RECFM=U data from PL/I in the comp.lang.pl1 USENET          *   FILE 090\n//*     newsgroup.  David Noon posted that if a delinker written    *   FILE 090\n//*     in PL/I was wanted then just ask.  That's not what the      *   FILE 090\n//*     original poster wanted, but I asked instead, and Dave       *   FILE 090\n//*     duly emailed it to me.                                      *   FILE 090\n//*                                                                 *   FILE 090\n//*     The package turned out to be a powerful batch utility       *   FILE 090\n//*     to delink, resize and even package for later processing     *   FILE 090\n//*     (such as distribution and reinstallation) some or all       *   FILE 090\n//*     CSECTs of nominated load modules.  It could, for            *   FILE 090\n//*     example, be used in a job stream to replace certain         *   FILE 090\n//*     CSECTs with newer versions.                                 *   FILE 090\n//*                                                                 *   FILE 090\n//*     I ended up plugging it into REVIEW R31.0 (CBT File 134),    *   FILE 090\n//*     so that members tagged in the member list (or all           *   FILE 090\n//*     members if none are tagged) can be dynamically delinked.    *   FILE 090\n//*                                                                 *   FILE 090\n//*     Please note that this Delinker will not process             *   FILE 090\n//*     scatter-load or segment-overlay programs correctly.  It     *   FILE 090\n//*     will only process load modules, and not program objects.    *   FILE 090\n//*                                                                 *   FILE 090\n//*     In case you do not have a suitable PL/I compiler handy,     *   FILE 090\n//*     I have supplied DELINKI and DWNSPDSR load modules in CBT    *   FILE 090\n//*     File 135.  I proposed calling the program DELINK1 to        *   FILE 090\n//*     distinguish it from the DELINK/DELINK0 OS/360 FE Tool       *   FILE 090\n//*     (and its derivatives), but Sam Golob preferred DELINKI,     *   FILE 090\n//*     so DELINKI it is.  (The 1 or I denotes that it is written   *   FILE 090\n//*     in PL/I.)                        Greg Price, July 1999.     *   FILE 090\n//*                                                                 *   FILE 090\n//*                                                                 *   FILE 090\n//*     Minor changes in 2006 include AMODE(64) support.            *   FILE 090\n//*                                                                 *   FILE 090\n//*     A member contents list follows.                             *   FILE 090\n//*                                                                 *   FILE 090\n//*     -MEMBER-   -CONTENTS------------------------------------    *   FILE 090\n//*                                                                 *   FILE 090\n//*     $$DOC    - This member.                                     *   FILE 090\n//*                                                                 *   FILE 090\n//*     $$DOC2   - Details of the March 2006 changes.               *   FILE 090\n//*                                                                 *   FILE 090\n//*     DCFDOC   - This is a documentation source file Dave made    *   FILE 090\n//*                in SGML.  It can easily be converted to GML      *   FILE 090\n//*                and run through SCRIPT/VS.  It can be TEXT       *   FILE 090\n//*                transferred to DELINK.IPF on the PC for          *   FILE 090\n//*                processing by the IPF compiler.  I resolved a    *   FILE 090\n//*                lot (but not all) of character symbolics to      *   FILE 090\n//*                get it to fit into an 80-column file.  It        *   FILE 090\n//*                also made the uncompiled source more             *   FILE 090\n//*                readable.                                        *   FILE 090\n//*                                                                 *   FILE 090\n//*                   &apos.             was replaced by   '        *   FILE 090\n//*                   &asterisk.         was replaced by   *        *   FILE 090\n//*                   &colon.            was replaced by   :        *   FILE 090\n//*                   &comma.            was replaced by   ,        *   FILE 090\n//*                   &eq.               was replaced by   =        *   FILE 090\n//*                   &hyphen.           was replaced by   -        *   FILE 090\n//*                   &lpar.             was replaced by   (        *   FILE 090\n//*                   &per.              was replaced by   .        *   FILE 090\n//*                   &plus.             was replaced by   +        *   FILE 090\n//*                   &rpar.             was replaced by   )        *   FILE 090\n//*                   &slash.            was replaced by   /        *   FILE 090\n//*                                                                 *   FILE 090\n//*     DELINK   - This is the main PL/I source member.             *   FILE 090\n//*                It should be compiled with OS PL/I Version 2     *   FILE 090\n//*                or with PL/I for MVS & VM.  Requires DWNSCAN     *   FILE 090\n//*                and DWNSHEX to be linked into the program        *   FILE 090\n//*                executable, and DWNSPDSR to be fetchable         *   FILE 090\n//*                during execution.                                *   FILE 090\n//*                                                                 *   FILE 090\n//*     DWNMPRLG - PL/I prologue macro used by DWNSCAN and          *   FILE 090\n//*                DWNSHEX.  Seems to work for OS PL/I Version 2    *   FILE 090\n//*                and PL/I for MVS & VM.                           *   FILE 090\n//*                                                                 *   FILE 090\n//*     DWNSCAN  - Performs the same function as the PL/I SEARCH    *   FILE 090\n//*                built-in function.  The SEARCH and SEARCHR       *   FILE 090\n//*                built-in functions are not yet available under   *   FILE 090\n//*                MVS (OS/390) at the time of writing.  This       *   FILE 090\n//*                module should be assembled and made available    *   FILE 090\n//*                at bind (ie. link-edit) time for inclusion       *   FILE 090\n//*                into the main program.                           *   FILE 090\n//*                                                                 *   FILE 090\n//*     DWNSHEX  - Performs a similar function to the PL/I HEX      *   FILE 090\n//*                built-in function.  The HEX and HEXIMAGE         *   FILE 090\n//*                built-in functions are not yet available         *   FILE 090\n//*                under MVS (OS/390) at the time of writing.       *   FILE 090\n//*                This module should be assembled and made         *   FILE 090\n//*                available at bind (ie. link-edit) time for       *   FILE 090\n//*                inclusion into the main program.                 *   FILE 090\n//*                                                                 *   FILE 090\n//*     DWNSPDSR - Provides BPAM support for the main PL/I          *   FILE 090\n//*                program.  It should be assembled and made        *   FILE 090\n//*                available for dynamic fetching at execute        *   FILE 090\n//*                time.                                            *   FILE 090\n//*                                                                 *   FILE 090\n//*     DWNYBLDL - PL/I source structure for PDS program            *   FILE 090\n//*                directory entry.  It was obviously meant to      *   FILE 090\n//*                be included in the source by some strange        *   FILE 090\n//*                control card (not %INCLUDE), so I just copied    *   FILE 090\n//*                it into the source.  This member is therefore    *   FILE 090\n//*                no longer used.                                  *   FILE 090\n//*                                                                 *   FILE 090\n//*     FMBLOCK  - Housekeeping macros used by DWNSPDSR, all of     *   FILE 090\n//*     FMCREDT    which were probably contributed to the SHARE     *   FILE 090\n//*     FMSTART    tape by Ken True of Fairchild MSS (hence FM,     *   FILE 090\n//*     FMWORK1    no doubt).  They were moved from from the        *   FILE 090\n//*     FMWORK2    SHARE tape to the Fairchild MSS \"Mods\" tape,     *   FILE 090\n//*                later called the Intel MVS \"Mods\" tape, circa    *   FILE 090\n//*                1982.                                            *   FILE 090\n//*                                                                 *   FILE 090\n//*     PLIICB   - PL/I Interrupt Control Block macro used by       *   FILE 090\n//*                DWNSHEX on error conditions.                     *   FILE 090\n//*                                                                 *   FILE 090\n//*     PLISIG   - PL/I Signal macro used by DWNSHEX on error       *   FILE 090\n//*                conditions.                                      *   FILE 090\n//*                                                                 *   FILE 090\n//*     XMITBOOK - TSO/E transmit file of DELINK.INF which was      *   FILE 090\n//*                created by compiling DELINK.IPF (source in       *   FILE 090\n//*                member DCFDOC) with IPFC under OS/2.  Process    *   FILE 090\n//*                with INDATASET operand of the TSO/E RECEIVE      *   FILE 090\n//*                command to get a RECFM=U sequential data set.    *   FILE 090\n//*                BINARY transfer this file to the PC (byte        *   FILE 090\n//*                counts should match).  Use the VIEW command of   *   FILE 090\n//*                OS/2 or PC-DOS to look at DELINK.INF which       *   FILE 090\n//*                contains the Delinker documentation.  The        *   FILE 090\n//*                PC-DOS VIEW command also works from the MS-DOS   *   FILE 090\n//*                prompt (including under Win95).  Apparently,     *   FILE 090\n//*                there is an IVIEW command downloadable from      *   FILE 090\n//*                IBM designed to work under Win95.                *   FILE 090\n//*                                                                 *   FILE 090\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DCFDOC": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99 \\x7f\\x00\\x99 \\x7f\\x03\\x14\\x01G\\x01G\\x00\\x00\\xd6\\xe2\\xf2\\xc9\\xd7\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-26T00:00:00", "modifydate": "1999-07-26T03:14:00", "lines": 327, "newlines": 327, "modlines": 0, "user": "OS2IPF"}, "text": ":userdoc.\n:title.Delinker for OS Load Modules\n:h1.Why a Delinker?\n:p.Often one needs to make changes to a load module for which one has\nno source code.  The ISPF editor refuses to edit RECFM=U datasets.\nThus, it is convenient to get the object code back into a card-image\nform.\n:p.Another reason to convert load modules into card-image form is that\nof SMP/E packaging.  It is often simplest to supply a single dataset\ntape with all the object simply wrapped with MCS ++MOD statements.\nThis program is capable of building such a tape.\n:p.For these reasons, I have written this program.\n:h1.Credits\n:p.The original author of this program is myself, David W. Noon.  I\nwrote it during the 1980s when MVS/XA was still new.  It was later\nmodified by Nigel Forbes, who still works as a contractor for Xerox\nCorp., I believe.  Some further changes were made by Greg Price,\nimmediately prior to its addition to the CBT tape.\n:p.This spans more than a decade during which this program has\nprovided sterling service.\n:h1.JCL\n:p.The schematic JCL required to run a job step to delink a program is\nas follows:\n:xmp.\n//STEP1    EXEC PGM=DELINK,\n//             REGION=2M\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=load library,\n//             DISP=SHR\n//SYSLIN   DD  DSN=object deck,\n//             DISP=(NEW,CATLG),\n//             SPACE=(TRK,10)\n//LINKCNTL DD  *\nMEMBER: modname1\nBEFORE\nlink edit control cards or MCS\n&per. &per. &per.\nAFTER\nlink edit control cards or MCS\n&per. &per. &per.\nMEMBER: modname2\nBEFORE\nlink edit control cards or MCS\n&per. &per. &per.\nAFTER\nlink edit control cards or MCS\n&per. &per. &per.\n&per. &per. &per.\n/*\n//SYSIN    DD  *\nMEMBER(modname1) NOMAP.\nMEMBER(modname2) NOMAP.\n/*\n:exmp.\n:p.The main sources of user input are the LINKCNTL and SYSIN DD\nstatements.  The options available through these are described in the\nfollowing sections of this document.\n:h1.SYSIN options\n:p.The most frequently used options are entered through the SYSIN card\nstream.  These tell the delinker which load module(s) to delink and\nwhich CSECT(s) from each load module.  They permit a wide range of\nselections to be made.\n:p.The general syntax is largely akin to that used by SMP/E for its\ninput.  The cards contain statements terminated by full-stops (periods\nin America).  All input is expected to be in capital letters.\n:p.The keywords can appear in any order.\n:dl tsize=16.\n:dthd.:hp4.Keyword:ehp4.\n:ddhd.:hp4.Description:ehp4.\n:dt.MEMBER\n:dd.The most important of the later keywords is MEMBER.  This\nspecifies the member name in the directory of the load library of the\nmodule to be delinked.  It requires a member name, of at most 8\ncharacters, to follow it enclosed in parentheses.\n:dt.ALL\n:dd.The ALL options tells the delinker to delink all CSECTs in the\nload module.  It can, optionally, be followed by a list of names of\nCSECTs that are to be re-sized.\n:dt.SELECT\n:dd.The SELECT option requires a parameter list that allows the user\nto restrict the CSECTs to be delinked to those listed.  No other CSECT\nwill be considered.  The list can contain masks to facilitate groups\nof like named CSECTs to be included.\n:dt.EXCLUDE\n:dd.The EXCLUDE option requires a parameter list that allows the user\nto restrict the CSECTs to be delinked to all those other than the ones\nlisted.  No other CSECT will be considered.  The list can contain\nmasks to facilitate groups of like named CSECTs to be excluded.\n:dt.EPCSECT\n:dd.The EPCSECT option tells the delinker to delink only the CSECT\nthat contains the load module's entry point.\n:dt.MAP\n:dd.The MAP options instructs the delinker to delink only those CSECTs\nthat have the map bit set in their attributes.  This means that only\nthose included by automatic call will be delinked.  This option is\nseldom useful, but its converse is often very useful.\n:dt.NOMAP\n:dd.The NOMAP option instructs the delinker to delink only those\nCSECTs that have the map bit reset in their attributes.  This means\nthat only CSECTs explicitly included in the load module, either by\ninclusion in the original SYSLIN stream of incorporated by an INCLUDE\ndirective, will be delinked.  This has the effect of restoring the\noriginal compiler output from a plain vanilla compile-and-link job.\nThis is because its net effect is usually to exclude those CSECTs\nbrought in from a compiler's run-time library.\n:dt.NONAME\n:dd.The NONAME option suppresses the addition of a link edit NAME\ndirective after the delinked object code in the SYSLIN output stream.\n:dt.NAME\n:dd.The NAME option provides an override member name to be put in the\nNAME link edit directive that is to follow the delinked object code.\n:edl.\n:p.The ALL, SELECT, EXCLUDE, EPCSECT, MAP and NOMAP options are\nmutually exclusive.  You can use at most one of them.  The default is\nALL.\n:p.The NAME and NONAME options are mutually exclusive.  You can use at\nmost one of them.  The default is to use NAME with the original member\nname.\n:p.The SELECT and EXCLUDE options permit the masking of CSECT names\nwith wild card characters.  This allows the selection or exclusion of\nCSECTs :hp1.en bloc:ehp1..\n:h2.Re-sizing CSECTs\n:p.The SELECT and ALL options allow you to re-size one or more CSECTs,\nto create extra patch space, or whatever you need.  To do this you\nsimply parenthesise the member name with its new size within the\nparenthesised list.\n:p.The size can be a decimal number, meaning bytes, a hexadecimal\nnumber enclosed in apostrophes with a leading 'X', or a decimal number\nfollowed by the letter 'K', meaning kilobytes, or a decimal number\nfollowed by the letter 'M', meaning megabytes.  Note that there is a\nlimit of 16MB on a CSECT.\n:p.For example, using the ALL:\n:xmp.\nMEMBER(MEMB1) ALL((CSECT1 128K) (CSECT2 X'00004000') (CSECT3 2M)).\n:exmp.\n:p.The above will delink all CSECTs in the load module and resize only\nthose listed.\n:p.For example, using the SELECT:\n:xmp.\nMEMBER(MEMB1) SELECT((CSECT1 32K) CSECT2 CSECT3).\n:exmp.\n:p.The above will delink CSECT1, CSECT2 and CSECT3, but only CSECT1\nwill be resized.\n:h2.CSECT name masks\n:p.When you want to code a mask in a selection or exclusion list, you\nsimply use the keyword MASK followed by a parenthesised parameter of\nat most 8 characters.  The mask matching rules are very simple:\n:dl tsize=16.\n:dthd.:hp4.Mask char.:ehp4.\n:ddhd.:hp4.Description:ehp4.\n:dt.?\n:dd.This matches any character in the CSECT name.\n:dt.&xclm.\n:dd.This character matches any alphabetic character.\n:dt.&splitvbar.\n:dd.This character matches any numeric.\n:dt.Others\n:dd.All other characters stand for themselves and an exact match is\nrequired.  This applies to spaces, especially trailing ones to make up\nthe 8 characters.\n:edl.\n:h1.LINKCNTL Input\n:p.The LINKCNTL stream is a means of providing additional card images\nto be wrapped around the delinked object code.  Most frequently it is\na DD DUMMY.\n:p.However, those who perform SMP/E packaging will find this a\nconvenient place to put MCS cards.\n:p.There are 3 control statements supported through this card stream.\nAll other card images are regarded as data to be written to the SYSLIN\noutput stream when needed.\n:p.The MEMBER: statement is used to match the cards in the LINKCNTL\nstream with the cards in the SYSIN stream.  The member name must\nappear in columns 9 through 16 of this card.  This is used to match\nagainst the MEMBER() option read in through SYSIN. :hp2.For successful\nmatching, the LINKCNTL and SYSIN member requests must appear in the\nsame order.:ehp2. If you delink the same member twice, for example to\nuse different CSECT selections, you should include 2 MEMBER:\nstatements so that your LINKCNTL data will be interspersed correctly\nwith the object code.  &lbrk.Normally the first instance will have a\nBEFORE statement and the second an AFTER statement succeeding\nit.&rbrk.\n:p.The BEFORE statement introduces a run of cards that is placed ahead\nof the delinked object code in the SYSLIN output stream.  The cards\ncan contain any data you wish, but the leftmost columns should not be\n&odq.MEMBER: &cdq., &odq.BEFORE &cdq. or &odq.AFTER &cdq..\n:p.The AFTER statement introduces a run of cards that is placed behind\nof the delinked object code in the SYSLIN output stream.  The cards\ncan contain any data you wish, but the leftmost columns should not be\n&odq.MEMBER: &cdq., &odq.BEFORE &cdq. or &odq.AFTER &cdq..  If the\nNAME option is specified or defaulted, the cards following the AFTER\nstatement are inserted between the end of the object code and the\ngenerated NAME statement.\n:p.An example:\n:xmp.\n//BLDPTF   EXEC PGM=DELINK,\n//             REGION=2M\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=FIXTEST.LOADLIB,\n//             DISP=SHR\n//SYSLIN   DD  DSN=FIXTEST.PTF.DWN1234,\n//             DISP=(NEW,CATLG),\n//             SPACE=(TRK,10)\n//LINKCNTL DD  *\nMEMBER: MEMB1\nBEFORE\n++PTF(DWN1234)\n  /* This PTF fixes a few load modules */ .\n\n++MOD(MEMB1).\nAFTER\n IDENTIFY MEMB1B('Updated by DWN1234.')\n NAME MEMB1(R)\nMEMBER: MEMB2\nBEFORE\n++MOD(MEMB2).\nAFTER\n IDENTIFY MEMB2A('Updated by DWN1234.')\n NAME MEMB2(R)\n/*\n//SYSIN    DD  *\nMEMBER(MEMB1) NONAME.\nMEMBER(MEMB2) NONAME.\n/*\n:exmp.\n:p.The above shows a simple strategy to build an APAR or PTF SYSMOD\ntape from a testing load library.\n:h1.DDNAME Overrides\n:p.The PARM field of the JCL can be used to override the names of the\nDD statements used by this program.  The documentation has so far used\nthe defaults.  Should you use this facility you should read the\ndocumentation to have you substitution names in place of the defaults.\n:p.The override must supply names for all 5 DD statements, otherwise\nit will be ignored.  If you want to replace only one name then you\nmust supply the default names for the other four.\n:p.The SYSLIB name can be overridden by columns 1 to 8 of the PARM string.\n:p.The SYSIN name can be overridden by columns 9 to 16 of the PARM string.\n:p.The SYSLIN name can be overridden by columns 17 to 24 of the PARM string.\n:p.The LINKCNTL name can be overridden by columns 25 to 32 of the PARM string.\n:p.The SYSPRINT name can be overridden by columns 33 to 40 of the PARM string.\n:p.For example, to replace SYSPRINT with REPORT and SYSLIB with LOADLIB:\n:xmp.\n//STEP1    EXEC PGM=DELINK,REGION=2M,\n//             PARM='/LOADLIB SYSIN   SYSLIN  LINKCNTLREPORT  '\n//REPORT   DD  SYSOUT=*\n//LOADLIB  DD  DSN=TEST.LOADLIB,\n//             DISP=SHR\n//SYSLIN   DD  DSN=TEST.OBJECT,\n//             DISP=(NEW,CATLG),\n//             SPACE=(TRK,10)\n//LINKCNTL DD  DUMMY,BLKSIZE=80\n//SYSIN    DD  *\nMEMBER(MEMB1).\nMEMBER(MEMB2).\n/*\n:exmp.\n:p.The program parameter commences with a slash because the delinker\nis a PL/I program.  Exactly 40 characters must follow the slash for\nthe parameter to be interpreted as a DDNAME override specification.\n:h1.Error Messages\n:p.The program generates some error messages when the SYSIN commands\nare syntactically invalid.  These are largely self-explanatory, but\nthey are listed here for reference.\n:table cols='30 45' frame=box rules=both.\n:row.\n:c.:hp4.Message:ehp4.\n:c.:hp4.Explanation:ehp4.\n:row.\n:c.DUPLICATE MEMBER OPTION\n:c.The word MEMBER has appeared more than once in a command.\n:row.\n:c.\"MEMBER\" NOT FOLLOWED BY \"(NAME)\"\n:c.The keyword MEMBER must be immediately followed by a member name\nenclosed in parentheses.\n:row.\n:c.MEMBER NAME TOO LONG\n:c.The member name was more than 8 characters long.\n:row.\n:c.BOTH \"NAME\" &amp. \"NONAME\" SPECIFIED\n:c.The NAME and NONAME options are mutually exclusive, so you cannot\nspecify both on the same command.\n:row.\n:c.DUPLICATE NONAME OPTION\n:c.The word NONAME has appeared more than once in a command.\n:row.\n:c.DUPLICATE NAME OPTION\n:c.The word NAME has appeared more than once in a command.\n:row.\n:c.\"NAME\" NOT FOLLOWED BY \"(NEWNAME)\"\n:c.The NAME option requires that a new member name be specified and it\nwas omitted.\n:row.\n:c.NEW NAME TOO LONG\n:c.The new member name was more than 8 characters long.\n:row.\n:c.DUPLICATE CSECT SELECTION OPTION\n:c.The ALL, MAP, NOMAP, SELECT and EXCLUDE options are mutually\nexclusive, and you have specified more than one of them.\n:row.\n:c.UNRECOGNIZED KEYWORD\n:c.A word has appeared in a position where the delinker was expecting\none of its keywords.  Check that your typing was correct and that any\nmember name has been enclosed in parentheses.\n:row.\n:c.SUPERFLUOUS \"(\"\n:c.A keyword was followed by a parenthesised name but that keyword\ntakes no further options.\n:row.\n:c.EMPTY CSECT SPECIFICATION LIST\n:c.The parenthesised list after SELECT or EXCLUDE was missing or empty.\n:row.\n:c.MISSING \")\" FROM CSECT SPECIFICATION LIST\n:c.The delinker could not find the closing parenthesis at the end of a\nSELECT or EXCLUDE list.\n:row.\n:c.INVALID LIST ITEM\n:c.An entry in a SELECT or EXCLUDE list could not be recognized as a\nmember name or MASK item.  Ensure the CSECT name is not too long.\n:row.\n:c.INVALID CSECT SIZE\n:c.The specified resize for a CSECT was in an invalid format or\nexceeded 16 megabytes.\n:row.\n:c.INVALID MASK ITEM\n:c.The string inside a MASK entry in a SELECT or EXCLUDE list was too\nlong or omitted.\n:etable.\n:euserdoc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELINK": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x05\\x00\\x99\\x08\\x9f\\x01\\x06\\x06\\x0f\\x13\\x02\\x08&\\x07\\x80\\x00\\x00\\xe4\\xc2\\xd8\\xf0\\xf0\\xf1@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "2006-03-01T13:02:05", "lines": 2086, "newlines": 1920, "modlines": 0, "user": "UBQ001"}, "text": "*PROCESS A,X(S),OPT(2),M,NIS,MAR(2,72,1),LANGLVL(SPROG),N('DELINKI');\n     /* PROGRAM TO DELINK OBJECT CODE FROM LOAD MODULES. */\n     /* STARTOPT:  */\n     /* COMPOPT: OPT(2),M,NIS  */\n     /* LINKOPT: XREF,LIST,RENT,REFR  */\n     /* ENDOPT:  */\n     /* WRITTEN 1984-1989 BY DAVID W. NOON                        */\n     /* UPDATED 1991 BY NIGEL FORBES                              */\n     /* UPDATED 10APR1999 BY GREG PRICE (GP@P6)                   */\n     /*                   - MORE LOAD MODULE ATTRS TO SYSLIN IN   */\n     /*                     IEWBLINK (NOT HEWLKED) CONTROL STMTS  */\n     /*                   - SUPPORT FOR DDNAME OVERRIDES          */\n     /* UPDATED 01MAR2006 BY GREG PRICE (GP@P6)                   */\n     /*                   - SUPPORT AMODE(64)                     */\n     /*                   - SUPPRESS TXT RECORD IF ZERO BYTES     */\n     /*                     (OK FOR HEWLKED, ERROR FOR IEWBLINK)  */\n DELINK :\n PROC (INPARM) OPTIONS(MAIN REENTRANT) REORDER;\n0    DFT  RANGE(*)            BIN FIXED;\n-    DCL  PLIXOPT             CHAR(22) VAR EXT\n                              INIT('ISA(56K) HEAP(1M)');\n1    DCL  CARD_PTR            PTR,\n          CARD                CHAR(80) BASED(CARD_PTR),\n          (MORE_CARDS,MORE_LINKCNTL) BIT(1) INIT('1'B),\n          LINKCNTL_PTR        PTR,\n          LINKCNTL_REC        CHAR(80) BASED(LINKCNTL_PTR),\n          EOM_FLAG            BIT(1) INIT('0'B),\n          INPARM              CHAR(100) VAR CONN,\n          DDSYSPRT            CHAR(8) INIT('SYSPRINT'),\n          DDSYSIN             CHAR(8) INIT('SYSIN   '),\n          DDSYSLIN            CHAR(8) INIT('SYSLIN  '),\n          DDLNKCTL            CHAR(8) INIT('LINKCNTL'),\n          (FULL_STOP,NONAME_FLAG,EXTRACT_FLAG)\n                              BIT(1) ALIGNED,\n          ERROR_FLAGS         BIT(16) ALIGNED,\n          ERROR_MSG(16)       CHAR(41) VAR STATIC INIT(\n                              'DUPLICATE MEMBER OPTION',\n                              '\"MEMBER\" NOT FOLLOWED BY \"(NAME)\"',\n                              'MEMBER NAME TOO LONG',\n                              'BOTH \"NAME\" & \"NONAME\" SPECIFIED',\n                              'DUPLICATE NONAME OPTION',\n                              'DUPLICATE NAME OPTION',\n                              '\"NAME\" NOT FOLLOWED BY \"(NEWNAME)\"',\n                              'NEW NAME TOO LONG',\n                              'DUPLICATE CSECT SELECTION OPTION',\n                              'UNRECOGNIZED KEYWORD',\n                              'SUPERFLUOUS \"(\"',\n                              'EMPTY CSECT SPECIFICATION LIST',\n                            'MISSING \")\" FROM CSECT SPECIFICATION LIST',\n                              'INVALID LIST ITEM',\n                              'INVALID CSECT SIZE',\n                              'INVALID MASK ITEM'),\n          (I,J,K,L,P,MASK_COUNT,CSECT_COUNT,LIST_TYPE_NO)\n                              BIN FIXED(15,0),\n          (ADCON,LD_ADDR,SD_ADDR,SIZE_VALUE) BIN FIXED(31,0),\n          TEMP_CHAR           CHAR(4),\n          LIST_TYPE           CHAR(1),\n          REUS_ATR            CHAR(6) VAR,\n          LOAD_ATR            CHAR(4) VAR,\n          (MEMBER,NEW_NAME)   CHAR(8) VAR,\n          TOKEN               CHAR(80) VAR,\n          NEW_SIZE            CHAR(6),\n          DELIMS              CHAR(5) STATIC INIT(' (),.'),\n          (RUN_DATE,RUN_TIME) CHAR(8),\n          (BEFORE_CNT,AFTER_CNT) DEC FIXED(5,0),\n          PAGE_CTR            DEC FIXED(5,0) INIT(0),\n          PAGE_TYPE           PIC '9' INIT(0),\n          RETURN_CODE         BIN FIXED(31,0) INIT(0B),\n-         (HOLD_PTR,CSECT_HEAD_PTR,CSECT_LIST_PTR,MASK_HEAD_PTR,\n                    MASK_LIST_PTR)  PTR INIT(NULL),\n0         1    CSECT_LIST_ENTRY    BASED(CSECT_LIST_PTR),\n               2    CSECT_LIST_SIZE     BIN FIXED(31,0) INIT(0B),\n               2    CSECT_NEXT_PTR      PTR INIT(NULL),\n               2    CSECT_LIST_NAME     CHAR(8),\n0         1    MASK_LIST_ENTRY     BASED(MASK_LIST_PTR),\n               2    MASK_NEXT_PTR       PTR INIT(NULL),\n               2    MASK_LIST_NAME      CHAR(8),\n0         1    CSECT_ARRAY(*)      CTL,\n               2    CSECT_SIZE          BIN FIXED(31,0),\n               2    CSECT_NAME          CHAR(8),\n               2    CSECT_MATCHED       BIT(1),\n0         1    MASK_ARRAY(*)       CTL,\n               2    MASK_NAME           CHAR(8),\n               2    MASK_MATCH_COUNT    BIN FIXED(31,0),\n1         1    SYSLIB,\n               2    PDS_DDNAME          CHAR(8) INIT('SYSLIB  '),\n               2    MEMBER_NAME         CHAR(8) INIT(''),\n               2    SYSLIB_WORK(2)      BIN FIXED(31,0) INIT((2)0B),\n0         (RECLEN,PDS_RET_CODE) BIN FIXED(31,0),\n          LMOD_RECORD         CHAR(32760),\n0         DIRECTORY_INFO(19)  BIN FIXED(31,0),\n-         (PDS_BLDL_PTR,PDS_BLDL_SCTR_PTR,PDS_BLDL_ALIAS_PTR,\n                        PDS_BLDL_SSI_PTR,PDS_BLDL_APF_PTR) PTR,\n0         1    PDS2_BLDL_FMT       BASED(PDS_BLDL_PTR),\n               2    PDS2NAME            CHAR(8),\n               2    PDS2TTRP            BIT(24) ALIGNED,\n               2    PDS2CNCT            BIT(8) ALIGNED,\n               2    PDS2LIBF            CHAR(1),\n               2    PDS2INDC,\n                    3    PDS2ALIS            BIT(1),\n                    3    PDS2NTTR            BIT(2),\n                    3    PDS2LUSR            BIT(5),\n0              /* FROM HERE ON IT IS LINKAGE EDITOR USER DATA */\n               2    PDS2USRD,\n                    3    PDS2TTRT            BIT(24) ALIGNED,\n                    3    PDS2ZERO            CHAR(1),\n                    3    PDS2TTRN            BIT(24) ALIGNED,\n                    3    PDS2NL              BIT(8) ALIGNED,\n                    3    PDS2ATR1,\n                         4    PDS2RENT            BIT(1),\n                         4    PDS2REUS            BIT(1),\n                         4    PDS2OVLY            BIT(1),\n                         4    PDS2TEST            BIT(1),\n                         4    PDS2LOAD            BIT(1),\n                         4    PDS2SCTR            BIT(1),\n                         4    PDS2EXEC            BIT(1),\n                         4    PDS21BLK            BIT(1),\n                    3    PDS2ATR2,\n                         4    PDS2FLVL            BIT(1),\n                         4    PDS2ORG0            BIT(1),\n                         4    PDS2EP0             BIT(1),\n                         4    PDS2NRLD            BIT(1),\n                         4    PDS2NREP            BIT(1),\n                         4    PDS2TSTN            BIT(1),\n                         4    PDS2LEF             BIT(1),\n                         4    PDS2REFR            BIT(1),\n                    3    PDS2STOR            BIT(24) ALIGNED,\n                    3    PDS2FTBL            BIN FIXED(15,0) UNAL,\n                    3    PDS2EPA             BIT(24) ALIGNED,\n                    3    PDS2FTB1,\n                         4    PDSAOSLE            BIT(1),\n                         4    PDS2BIG             BIT(1),\n                         4    PDS2PAGA            BIT(1),\n                         4    PDS2SSI             BIT(1),\n                         4    PDSAPFLG            BIT(1),\n                         4    PDS2PGMO            BIT(1),\n                         4    FILLER#2            BIT(2),\n                    3    PDS2FTB2,\n                         4    FILLER#3            BIT(3),\n                         4    PDSLRMOD            BIT(1),\n                         4    PDSAAMOD            BIT(2),\n                         4    PDSMAMOD            BIT(2),\n                    3    PDS2FTB3            BIT(8) ALIGNED,\n0         /* EXTENSION FOR SCATTER FORMAT LOAD MODULES */\n          1    PDSS01              BASED(PDS_BLDL_SCTR_PTR),\n               2    PDS2SLSZ            BIN FIXED(15,0) UNAL,\n               2    PDS2TTSZ            BIN FIXED(15,0) UNAL,\n               2    PDS2ESDT            BIT(16) ALIGNED,\n               2    PDS2ESDC            BIT(16) ALIGNED,\n0         /* EXTENSION FOR ALIAS ENTRIES */\n          1    PDSS02              BASED(PDS_BLDL_ALIAS_PTR),\n               2    PDS2EPM             BIT(24) ALIGNED,\n               2    PDS2MNM             CHAR(8),\n0         /* EXTENSION FOR SSI DATA */\n          1    PDSS03              BASED(PDS_BLDL_SSI_PTR),\n               2    PDSCHLVL            BIT(8) ALIGNED,\n               2    PDSSSIFB,\n                    3    FILLER#4            BIT(1),\n                    3    PDSFORCE            BIT(1),\n                    3    PDSUSRCH            BIT(1),\n                    3    PDSEMFIX            BIT(1),\n                    3    PDSDEPCH            BIT(1),\n                    3    PDSSYSGN,\n                         4    PDSCMSGN            BIT(1),\n                         4    PDSPTSGN            BIT(1),\n                    3    PDSIBMMB            BIT(1),\n               2    PDSMBRSN            BIT(16) ALIGNED,\n0         /* EXTENSION FOR APF AUTHORIZATION */\n          1    PDSS04              BASED(PDS_BLDL_APF_PTR),\n               2    PDSAPFCT            BIT(8) ALIGNED,\n               2    PDSAPFAC            CHAR((1) REFER (PDSAPFCT)),\n          SSI_DATA            CHAR(8),\n          (EP_ADDR,EP_OFFSET) BIN FIXED(31,0) INIT(0B),\n          EP_ESDID            BIN FIXED(15,0) INIT(0B),\n          AMODE               BIT(2),\n          SYM_AMODE           BIT(3),                          /* GP */\n0         ATTRIB(16,0:1)      CHAR(11) STATIC\n                              INIT('NORENT','RENT','NOREUS','REUS',\n                              'NOOVLY','OVLY','NOTEST','TEST',\n                              'NOOL','OL','BLOCK','SCATTER',\n                              'NOEXEC','EXEC','MULTI TXT','ONE TXT',\n                              'DOWN COMPAT','NO E LEVEL','NONZERO ORG',\n                                   'ZERO ORG',\n                              'NONZERO EP','ZERO EP','RLD','NO RLD',\n                              'EDIT','NE','NO TESTRAN','TESTRAN',\n                              'H LEVEL','F LEVEL','NOREFR','REFR'),\n0         RMODE_TYPE(0:1)     CHAR(3) STATIC INIT(' 24','ANY'),\n          AMODE_TYPE(0:3)     CHAR(3) STATIC INIT(' 24',' 64',\n                              ' 31','ANY'),                    /* GP */\n          SYM_AMODE_TYPE(0:7) CHAR(3) STATIC INIT(' 24',' 24',' 31',\n                              'ANY',' 64',' 64',' 64',' 64'),  /* GP */\n1         1    CESD_LIST_ITEM      BASED(CESD_LIST_PTR),\n               2    CESD_NEXT_PTR       PTR INIT(NULL),\n               2    CESD_ESDID          BIN FIXED(15,0),\n               2    CESD_NEW_ESDID      BIN FIXED(15,0) INIT(0B),\n               2    CESD_NAME           CHAR(8),\n               2    CESD_TYPE           BIT(8),\n               2    CESD_ADDR           BIT(24),\n               2    CESD_AMODE_RMODE,\n                    3    FILLER#1            BIT(2),\n                    3    CESD_RMODE64        BIT(1),           /* GP */\n                    3    CESD_AMODE64        BIT(1),           /* GP */\n                    3    CESD_RSECT          BIT(1),\n                    3    CESD_RMODE          BIT(1),\n                    3    CESD_AMODE          BIT(2),\n               2    CESD_LENGTH         BIT(24) ALIGNED,\n               2    CESD_DELINK_FLAG    BIT(1),\n          (CESD_LIST_PTR,CESD_HEAD_PTR) PTR INIT(NULL),\n0         1    RLD_LIST_ITEM       BASED(RLD_LIST_PTR),\n               2    RLD_NEXT_PTR        PTR INIT(NULL),\n               2    RLD_LIST_ITEM_CNT   BIN FIXED(15,0),\n               2    RLD_LIST_REL_ID     BIN FIXED(15,0),\n               2    RLD_LIST_POS_ID     BIN FIXED(15,0),\n               2    RLD_LIST_DATA((RLD_ITEM_CNT)\n                              REFER (RLD_LIST_ITEM_CNT)),\n                    3    RLD_LIST_FLAGS      BIT(8),\n                    3    RLD_LIST_ADCON_ADDR    BIT(24),\n          RLD_ITEM_CNT        BIN FIXED(15,0),\n          (RLD_LIST_PTR,RLD_HEAD_PTR) PTR INIT(NULL),\n0         1    TXT_LIST_ITEM       UNAL BASED(TXT_LIST_PTR),\n               2    TXT_NEXT_PTR        PTR INIT(NULL),\n               2    TXT_ADDR_1ST_BYTE   BIT(24),\n               2    TXT_BYTE_CNT        BIN FIXED(15,0),\n               2    TXT_ESDID           BIN FIXED(15,0),\n               2    TXT_BYTES           CHAR((TXT_LENGTH)\n                                             REFER (TXT_BYTE_CNT)),\n          TXT_LENGTH          BIN FIXED(15,0),\n          (TXT_SIZE,LAST_TXT_ADDR) BIN FIXED(31,0),\n          (TXT_LIST_PTR,TXT_HEAD_PTR) PTR INIT(NULL),\n0         1    IDR_LIST_ITEM       BASED(IDR_LIST_PTR),\n               2    IDR_NEXT_PTR        PTR INIT(NULL),\n               2    IDR_LIST_ESDID      BIN FIXED(15,0),\n               2    IDR_LIST_TRANS_CNT  BIN FIXED(15,0),\n               2    IDR_DATA((IDR_TRANS_CNT)\n                         REFER (IDR_LIST_TRANS_CNT)),\n                    3    IDR_NAME            CHAR(10),\n                    3    IDR_VVMM(4)         BIT(4) UNAL,\n                    3    IDR_DATE            DEC FIXED(5,0),\n          IDR_TRANS_CNT       BIN FIXED(15,0),\n          (IDR_LIST_PTR,IDR_HEAD_PTR) PTR INIT(NULL),\n0         1    IDR_USER_ITEM       BASED(IDR_USER_PTR),\n               2    IDR_USER_NEXT_PTR   PTR INIT(NULL),\n               2    IDR_USER_LIST_ESDID BIN FIXED(15,0),\n               2    IDR_USER_LIST_LENGTH BIN FIXED(15,0),\n               2    IDR_USER_LIST_DATA  CHAR((IDR_USER_LENGTH)\n                                        REFER (IDR_USER_LIST_LENGTH)),\n          IDR_USER_LENGTH     BIN FIXED(15,0) DEF IDR_TRANS_CNT,\n          (IDR_USER_PTR,IDR_USER_HEAD_PTR) PTR INIT(NULL),\n          SEQ#                DEC FIXED(5,0) INIT(0),\n          (TXT_ADDR,TXT_END)  BIN FIXED(31,0),\n          TXT_ADDR_BITS       BIT(24),\n          (NBYTES,NESD,LAST_ESDID,REPL_ESDID) BIN FIXED(15,0),\n1         1    ESD_OBJ             UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    ESD_ESD             CHAR(3) INIT('ESD'),\n               2    FILLER#1            CHAR(6) INIT((6)' '),\n               2    ESD_BYTE_CNT        BIN FIXED(15,0) INIT(0B),\n               2    FILLER#2            CHAR(2) INIT('  '),\n               2    ESD_1ST_ESDID       BIN FIXED(15,0) INIT(0B),\n               2    ESD_BYTES(3)        CHAR(16) INIT((3)(16)' '),\n               2    FILLER#3            CHAR(8) INIT((8)' '),\n               2    ESD_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    ESD_SEQ#            PIC '(4)9' INIT(SEQ#),\n0         1    ESD_DATA            BASED(ESD_PTR),\n               2    ESD_NAME            CHAR(8),\n               2    ESD_TYPE            BIT(8),\n               2    ESD_ADDR            BIT(24),\n               2    ESD_AMODE_RMODE     BIT(8),\n               2    ESD_LENGTH          BIT(24),\n0         ESD_PTR             PTR INIT(NULL),\n-         1    TXT_OBJ             UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    TXT_TXT             CHAR(3) INIT('TXT'),\n               2    FILLER#1            CHAR(1) INIT(' '),\n               2    TXT_1ST_BYTE        BIT(24)\n                                        INIT(TXT_ADDR_BITS),\n               2    FILLER#2            CHAR(2) INIT('  '),\n               2    TXT_CNT             BIN FIXED(15,0) INIT(56),\n               2    FILLER#3            CHAR(2) INIT('  '),\n               2    TXT_OBJ_ESDID       BIN FIXED(15,0) INIT(1B),\n               2    TXT                 CHAR(56) INIT((56)' '),\n               2    TXT_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    TXT_SEQ#            PIC '(4)9' INIT(SEQ#),\n-         1    TXT_OBJ_NULL        UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    TXT_TXT             CHAR(3) INIT('TXT'),\n               2    FILLER#1            CHAR(1) INIT(' '),\n               2    TXT_1ST_BYTE        BIT(24)\n                                        INIT(TXT_ADDR_BITS),\n               2    FILLER#2            CHAR(2) INIT('  '),\n               2    TXT_CNT_NULL        BIN FIXED(15,0) INIT(0B),\n               2    FILLER#3            CHAR(2) INIT('  '),\n               2    TXT_OBJ_ESDID       BIN FIXED(15,0) INIT(1B),\n               2    TXT_NULL            CHAR(56) INIT((56)' '),\n               2    TXT_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    TXT_SEQ#            PIC '(4)9' INIT(SEQ#),\n-         1    RLD_OBJ             UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    RLD_RLD             CHAR(3) INIT('RLD'),\n               2    FILLER#1            CHAR(6) INIT((6)' '),\n               2    RLD_BYTE_CNT        BIN FIXED(15,0) INIT(0B),\n               2    FILLER#2            CHAR(4) INIT((4)' '),\n               2    RLD_BYTE(56)        CHAR(1) INIT((56)(' ')),\n               2    RLD_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    RLD_SEQ#            PIC '(4)9' INIT(SEQ#),\n0         1    RLD_R_P             UNAL BASED(RLD_R_P_PTR),\n               2    RLD_OBJ_REL_ID      BIN FIXED(15,0),\n               2    RLD_OBJ_POS_ID      BIN FIXED(15,0),\n0         1    RLD_F_A             UNAL BASED(RLD_F_A_PTR),\n               2    RLD_OBJ_FLAGS       BIT(8),\n               2    RLD_OBJ_ADDR        BIT(24),\n0         (RLD_R_P_PTR,RLD_F_A_PTR) PTR INIT(NULL),\n-         1    END_OBJ_TYPE_1      UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    END_END             CHAR(3) INIT('END'),\n               2    FILLER#1            CHAR(1) INIT(' '),\n               2    END_EP_OFFSET       BIT(24)\n                                   INIT(SUBSTR(UNSPEC(EP_OFFSET),9,24)),\n               2    FILLER#2            CHAR(6) INIT((6)' '),\n               2    END_EP_ESDID        BIN FIXED(15,0) INIT(EP_ESDID),\n               2    FILLER#3            CHAR(56) INIT((56)' '),\n               2    END_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    END_SEQ#            PIC '(4)9' INIT(SEQ#),\n0         1    END_OBJ_TYPE_2      UNAL BASED(CARD_PTR),\n               2    OBJ_FLAG            BIT(8) INIT('02'BX),\n               2    END_END             CHAR(3) INIT('END'),\n               2    FILLER#1            CHAR(12) INIT((12)' '),\n               2    END_EP_NAME         CHAR(8) INIT((8)' '),\n               2    FILLER#2            CHAR(4) INIT((4)' '),\n               2    END_SD_LENGTH       BIT(32) INIT((4)'40'BX),\n               2    END_IDR_CNT         CHAR(1) INIT(' '),\n               2    END_IDR_DATA(2),\n                    3    IDR_NAME            CHAR(10) INIT((2)(10)' '),\n                    3    END_IDR_VVMM        CHAR(4) INIT((2)('    ')),\n                    3    IDR_DATE            PIC '(5)Z' INIT(0,0),\n               2    FILLER#3            CHAR(1) INIT(' '),\n               2    END_MOD_ID          CHAR(4)\n                                        INIT(SUBSTR(CESD_NAME,1,4)),\n               2    END_SEQ#            PIC '(4)9' INIT(SEQ#),\n1         DWNSCAN             ENTRY(CHAR(*),CHAR(*))\n                              RETURNS(BIN FIXED(15,0)),\n          DWNSHEX             ENTRY(BIT(*) ALIGNED)\n                              RETURNS(CHAR(16) VAR),\n          DWNSPDSR            ENTRY OPTIONS(ASM INTER RETCODE),\n          (ADDR,ALL,ALLOCN,DATE,HIGH,INDEX,LENGTH,LOW,MAX,MIN,MOD,NULL,\n                    PLIDUMP,PLIRETC,PLIRETV,PTRADD,PTRVALUE,\n                    STG,STRING,SUBSTR,TIME,UNSPEC,VERIFY) BUILTIN,\n-         SYSIN               FILE RECORD INPUT ENV(FB RECSIZE(80)),\n          SYSLIN              FILE RECORD OUTPUT\n                              ENV(FB RECSIZE(80) TOTAL),\n          LINKCNTL            FILE RECORD INPUT INT ENV(FB RECSIZE(80)),\n          SYSPRINT            PRINT ENV(VB RECSIZE(137) BLKSIZE(6854));\n1    ON ERROR SNAP\n     BEGIN;\n          ON ERROR SYSTEM;\n          CALL PLIDUMP('TFCHB');\n     END;\n0    PDS_BLDL_PTR = ADDR(DIRECTORY_INFO);\n-    IF LENGTH(INPARM) = 40 THEN /* PROCESS DDNAME OVERRIDES */ /*GP*/\n     DO;                                                        /*  */\n          SYSLIB.PDS_DDNAME = SUBSTR(INPARM,1,8);               /*  */\n          DDSYSIN  = SUBSTR(INPARM,9,8);                        /*  */\n          DDSYSLIN = SUBSTR(INPARM,17,8);                       /*  */\n          DDLNKCTL = SUBSTR(INPARM,25,8);                       /*  */\n          DDSYSPRT = SUBSTR(INPARM,33,8);                       /*  */\n     END;                                                       /*GP*/\n-    OPEN FILE(SYSIN) TITLE(DDSYSIN),\n          FILE(SYSLIN) TITLE(DDSYSLIN),\n          FILE(LINKCNTL) TITLE(DDLNKCTL),\n          FILE(SYSPRINT) TITLE(DDSYSPRT) PAGESIZE(65);\n0    ON ENDFILE(LINKCNTL)\n          MORE_LINKCNTL = '0'B;\n     DO WHILE(MORE_LINKCNTL)\n               UNTIL(SUBSTR(LINKCNTL_REC,1,8) = 'MEMBER: ');\n          READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n     END;\n0    PUT STRING(RUN_DATE) EDIT\n     (DATE)\n     (P'99/99/99');\n0    PUT STRING(RUN_TIME) EDIT\n     (SUBSTR(TIME,1,6))\n     (P'99/99/99');\n     SUBSTR(RUN_TIME,3,1), SUBSTR(RUN_TIME,6,1) = ':';\n0    ON ENDPAGE(SYSPRINT)\n     BEGIN;\n          DCL  LINENO              BUILTIN;\n          PAGE_CTR = PAGE_CTR + 1;\n          IF LINENO(SYSPRINT) >= 2 THEN\n               PUT FILE(SYSPRINT) PAGE;\n          PUT FILE(SYSPRINT) LINE(2) EDIT\n          (RUN_DATE,RUN_TIME,'DELINK UTILITY','PAGE',PAGE_CTR)\n          (A,X(1),A,COL(60),A,COL(124),A,F(5));\n          SELECT(PAGE_TYPE);\n          WHEN(0)\n               PUT FILE(SYSPRINT) SKIP(2);\n          WHEN(1)\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               ('<',(32)'-',' COMMAND LINE ',(32)'-','>')\n               (COL(27),5 A);\n          WHEN(2)\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               (('CSECT','A/R','OLD','NEW' DO I = 1 TO 3))\n               (X(2),4(A,X(6)))\n               (('NAME','MODE','SIZE','SIZE' DO I = 1 TO 3))\n               (SKIP,3(X(2),A,2(X(6),A),X(5),A,X(5)));\n          END;\n     END;\n-OBTAIN_A_CMD :\n     ON ENDFILE(SYSIN)\n          GO TO END_OF_JOB;\n     READ FILE(SYSIN) SET(CARD_PTR);\n     ON ENDFILE(SYSIN)\n          MORE_CARDS = '0'B;\n     PAGE_TYPE = 1;\n0    SIGNAL ENDPAGE(SYSPRINT);\n0    MEMBER,NEW_NAME = '';\n     MASK_COUNT,CSECT_COUNT = 0B;\n     BEFORE_CNT,AFTER_CNT = 0;\n     LIST_TYPE_NO = 1B;\n     LIST_TYPE = ' ';\n     FULL_STOP,NONAME_FLAG,EXTRACT_FLAG = '0'B;\n     ERROR_FLAGS = (16)'0'B;\n1    DO WHILE(MORE_CARDS);\n          PUT FILE(SYSPRINT) EDIT\n          (CARD)\n          (COL(27),A);\n          IF CARD \u00ac= (80)' ' THEN\n          DO P = VERIFY(CARD,' ') REPEAT P + L\n                    WHILE(P <= 80);\n               IF (LIST_TYPE = 'X' | LIST_TYPE = 'S') &\n                         SUBSTR(CARD,P,1) = '(' &\n                         (TOKEN = 'EXCLUDE' | TOKEN = 'SELECT') THEN\n                    L = 1;\n               ELSE\n               DO;\n                    L = DWNSCAN(SUBSTR(CARD,P+1),DELIMS);\n                    IF L = 0 THEN\n                         L = 81 - P;\n               END;\n               TOKEN = SUBSTR(CARD,P,L);\n               SELECT(LIST_TYPE);\n               WHEN(' ')\n               SELECT(TOKEN);\n               WHEN('MEMBER')\n               DO;\n                    IF MEMBER \u00ac= '' THEN\n                         SUBSTR(ERROR_FLAGS,1,1) = '1'B;\n                    ELSE IF SUBSTR(CARD,P+6,1) \u00ac= '(' THEN\n                         SUBSTR(ERROR_FLAGS,2,1) = '1'B;\n                    ELSE\n                    DO;\n                         L = DWNSCAN(SUBSTR(CARD,P+7),DELIMS);\n                         IF L < 2 | L > 9 |\n                                   SUBSTR(CARD,P+L+6,1) \u00ac= ')' THEN\n                              SUBSTR(ERROR_FLAGS,3,1) = '1'B;\n                         ELSE\n                              MEMBER = SUBSTR(CARD,P+7,L-1);\n                         L = L + 7;\n                    END;\n               END;\n               WHEN('NONAME')\n               DO;\n                    IF NEW_NAME \u00ac= '' THEN\n                         SUBSTR(ERROR_FLAGS,4,1) = '1'B;\n                    ELSE IF NONAME_FLAG THEN\n                         SUBSTR(ERROR_FLAGS,5,1) = '1'B;\n                    ELSE\n                         NONAME_FLAG = '1'B;\n               END;\n               WHEN('NAME')\n               DO;\n                    IF NEW_NAME \u00ac= '' THEN\n                         SUBSTR(ERROR_FLAGS,6,1) = '1'B;\n                    ELSE IF NONAME_FLAG THEN\n                         SUBSTR(ERROR_FLAGS,4,1) = '1'B;\n                    ELSE IF SUBSTR(CARD,P+4,1) \u00ac= '(' THEN\n                         SUBSTR(ERROR_FLAGS,7,1) = '1'B;\n                    ELSE\n                    DO;\n                         L = DWNSCAN(SUBSTR(CARD,P+5),DELIMS);\n                         IF L < 2 | L > 9 |\n                                   SUBSTR(CARD,P+L+4,1) \u00ac= ')' THEN\n                              SUBSTR(ERROR_FLAGS,8,1) = '1'B;\n                         ELSE\n                              NEW_NAME = SUBSTR(CARD,P+5,L-1);\n                         L = L + 5;\n                    END;\n               END;\n               WHEN('ALL','EXCLUDE','SELECT')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0 | MASK_COUNT \u00ac= 0 |\n                              LIST_TYPE_NO > 1B THEN\n                         SUBSTR(ERROR_FLAGS,9,1) = '1'B;\n                    ELSE\n                    DO;\n                         LIST_TYPE = SUBSTR(TOKEN,1,1);\n                         IF LIST_TYPE = 'E' THEN\n                              LIST_TYPE = 'X';\n                         LIST_TYPE_NO = INDEX('AXS',LIST_TYPE);\n                    END;\n               END;\n               WHEN('EPCSECT','MAP','NOMAP')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0 | MASK_COUNT \u00ac= 0 |\n                              LIST_TYPE_NO > 1B THEN\n                         SUBSTR(ERROR_FLAGS,9,1) = '1'B;\n                    ELSE\n                         LIST_TYPE_NO = INDEX('EMN',SUBSTR(TOKEN,1,1)) +\n                                        3;\n               END;\n               WHEN('.')\n                    FULL_STOP = '1'B;\n               OTHERWISE\n                    SUBSTR(ERROR_FLAGS,10,1) = '1'B;\n               END; /* SELECT(TOKEN) */\n1              WHEN('A')\n               SELECT;\n               WHEN(TOKEN = '(')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0B THEN\n                         SUBSTR(ERROR_FLAGS,11,1) = '1'B;\n               END;\n               WHEN(TOKEN = ')')\n               DO;\n                    IF CSECT_COUNT = 0B THEN\n                         SUBSTR(ERROR_FLAGS,12,1) = '1'B;\n                    LIST_TYPE = ' ';\n               END;\n               WHEN(TOKEN = '.')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0B THEN\n                         SUBSTR(ERROR_FLAGS,13,1) = '1'B;\n                    LIST_TYPE = ' ';\n                    FULL_STOP = '1'B;\n               END;\n               WHEN(SUBSTR(TOKEN,1,1) \u00ac= '(' |\n /*NIGEL */              SUBSTR(CARD,P+L,1) \u00ac= ' ')\n                    SUBSTR(ERROR_FLAGS,14,1) = '1'B;\n               OTHERWISE\n               DO;\n                    K = DWNSCAN(SUBSTR(CARD,P+L+1),DELIMS);\n                    IF K < 2 | SUBSTR(CARD,P+L+K,1) \u00ac= ')' |\n /*NIGEL */                        SUBSTR(CARD,P+L,1) \u00ac= ' ' THEN\n                         SUBSTR(ERROR_FLAGS,14,1) = '1'B;\n                    ELSE\n                    DO;\n                         SIZE_VALUE =\n                              EXTRACT_SIZE(SUBSTR(CARD,P+L+1,K-1),\n                              EXTRACT_FLAG);\n                         SUBSTR(ERROR_FLAGS,15,1) =\n                              SUBSTR(ERROR_FLAGS,15,1) | EXTRACT_FLAG;\n                         IF ERROR_FLAGS = (16)'0'B THEN\n                         DO;\n                              CSECT_COUNT = CSECT_COUNT + 1;\n                              ALLOC CSECT_LIST_ENTRY SET(HOLD_PTR);\n                              IF CSECT_HEAD_PTR = NULL THEN\n                                   CSECT_HEAD_PTR = HOLD_PTR;\n                              ELSE\n                                   CSECT_NEXT_PTR = HOLD_PTR;\n                              CSECT_LIST_PTR = HOLD_PTR;\n                              CSECT_LIST_SIZE = SIZE_VALUE;\n                              CSECT_LIST_NAME = SUBSTR(TOKEN,2);\n                         END;\n                    END;\n                    L = L + K + 1;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n               END; /* SELECT */\n1              WHEN('X') /* EXCLUDE LIST */\n               SELECT;\n               WHEN(TOKEN = '(')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0B THEN\n                         SUBSTR(ERROR_FLAGS,11,1) = '1'B;\n               END;\n               WHEN(TOKEN = ')')\n               DO;\n                    IF CSECT_COUNT = 0B & MASK_COUNT = 0B THEN\n                         SUBSTR(ERROR_FLAGS,12,1) = '1'B;\n                    LIST_TYPE = ' ';\n               END;\n               WHEN(TOKEN = '.')\n               DO;\n                    LIST_TYPE = ' ';\n                    SUBSTR(ERROR_FLAGS,13,1),FULL_STOP = '1'B;\n               END;\n               WHEN(TOKEN = 'MASK' & SUBSTR(CARD,P+4,1) = '(')\n               DO;\n                    L = DWNSCAN(SUBSTR(CARD,P+5),DELIMS);\n                    IF L < 2 | L > 9 |\n                              SUBSTR(CARD,P+L+4,1) \u00ac= ')' |\n                              (SUBSTR(CARD,P+L+5,1) \u00ac= ')' &\n /*NIGEL */                   SUBSTR(CARD,P+L+5,1) \u00ac= ' ') THEN\n                         SUBSTR(ERROR_FLAGS,16,1) = '1'B;\n                    ELSE\n                    DO;\n                         MASK_COUNT = MASK_COUNT + 1;\n                         ALLOC MASK_LIST_ENTRY SET(HOLD_PTR);\n                         IF MASK_HEAD_PTR = NULL THEN\n                              MASK_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              MASK_NEXT_PTR = HOLD_PTR;\n                         MASK_LIST_PTR = HOLD_PTR;\n                         MASK_LIST_NAME = SUBSTR(CARD,P+5,L-1);\n                    END;\n                    L = L + 5;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n0              OTHERWISE\n               DO;\n                    IF L < 1 | L > 8 |\n                              (SUBSTR(CARD,P+L,1) \u00ac= ')' &\n  /*NIGEL FIX , TAKEN OUT*/   SUBSTR(CARD,P+L,1) \u00ac= ' ') THEN\n                         SUBSTR(ERROR_FLAGS,14,1) = '1'B;\n                    ELSE\n                    DO;\n                         CSECT_COUNT = CSECT_COUNT + 1;\n                         ALLOC CSECT_LIST_ENTRY SET(HOLD_PTR);\n                         IF CSECT_HEAD_PTR = NULL THEN\n                              CSECT_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              CSECT_NEXT_PTR = HOLD_PTR;\n                         CSECT_LIST_PTR = HOLD_PTR;\n                         CSECT_LIST_NAME = SUBSTR(CARD,P,L);\n                         CSECT_LIST_SIZE = 0B;\n                    END;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n               END; /* SELECT */\n1              WHEN('S') /* SELECT LIST */\n               SELECT;\n               WHEN(TOKEN = '(')\n               DO;\n                    IF CSECT_COUNT \u00ac= 0B THEN\n                         SUBSTR(ERROR_FLAGS,11,1) = '1'B;\n               END;\n               WHEN(TOKEN = ')')\n               DO;\n                    IF CSECT_COUNT = 0B & MASK_COUNT = 0B THEN\n                         SUBSTR(ERROR_FLAGS,12,1) = '1'B;\n                    LIST_TYPE = ' ';\n               END;\n               WHEN(TOKEN = '.')\n               DO;\n                    LIST_TYPE = ' ';\n                    SUBSTR(ERROR_FLAGS,13,1),FULL_STOP = '1'B;\n               END;\n               WHEN(TOKEN = 'MASK' & SUBSTR(CARD,P+4,1) = '(')\n               DO;\n                    L = DWNSCAN(SUBSTR(CARD,P+5),DELIMS);\n                    IF L < 2 | L > 9 |\n                              SUBSTR(CARD,P+L+4,1) \u00ac= ')' |\n                              (SUBSTR(CARD,P+L+5,1) \u00ac= ')' &\n /*NIGEL */                   SUBSTR(CARD,P+L+5,1) \u00ac= ' ') THEN\n                         SUBSTR(ERROR_FLAGS,16,1) = '1'B;\n                    ELSE\n                    DO;\n                         MASK_COUNT = MASK_COUNT + 1;\n                         ALLOC MASK_LIST_ENTRY SET(HOLD_PTR);\n                         IF MASK_HEAD_PTR = NULL THEN\n                              MASK_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              MASK_NEXT_PTR = HOLD_PTR;\n                         MASK_LIST_PTR = HOLD_PTR;\n                         MASK_LIST_NAME = SUBSTR(CARD,P+5,L-1);\n                    END;\n                    L = L + 5;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n0              WHEN(SUBSTR(TOKEN,1,1) = '(')\n               DO;\n                    K = DWNSCAN(SUBSTR(CARD,P+L+1),DELIMS);\n                    IF K < 2 | SUBSTR(CARD,P+L+K,1) \u00ac= ')' |\n /*NIGEL */                        SUBSTR(CARD,P+L,1) \u00ac= ' ' THEN\n                         SUBSTR(ERROR_FLAGS,14,1) = '1'B;\n                    ELSE\n                    DO;\n                         SIZE_VALUE =\n                              EXTRACT_SIZE(SUBSTR(CARD,P+L+1,K-1),\n                              EXTRACT_FLAG);\n                         SUBSTR(ERROR_FLAGS,15,1) =\n                              SUBSTR(ERROR_FLAGS,15,1) | EXTRACT_FLAG;\n                         IF ERROR_FLAGS = (16)'0'B THEN\n                         DO;\n                              CSECT_COUNT = CSECT_COUNT + 1;\n                              ALLOC CSECT_LIST_ENTRY SET(HOLD_PTR);\n                              IF CSECT_HEAD_PTR = NULL THEN\n                                   CSECT_HEAD_PTR = HOLD_PTR;\n                              ELSE\n                                   CSECT_NEXT_PTR = HOLD_PTR;\n                              CSECT_LIST_PTR = HOLD_PTR;\n                              CSECT_LIST_SIZE = SIZE_VALUE;\n                              CSECT_LIST_NAME = SUBSTR(TOKEN,2);\n                         END;\n                    END;\n                    L = L + K + 1;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n0              OTHERWISE\n               DO;\n                    IF L < 1 | L > 8 |\n                              (SUBSTR(CARD,P+L,1) \u00ac= ')' &\n /*NIGEL */                   SUBSTR(CARD,P+L,1) \u00ac= ' ') THEN\n                         SUBSTR(ERROR_FLAGS,14,1) = '1'B;\n                    ELSE\n                    DO;\n                         CSECT_COUNT = CSECT_COUNT + 1;\n                         ALLOC CSECT_LIST_ENTRY SET(HOLD_PTR);\n                         IF CSECT_HEAD_PTR = NULL THEN\n                              CSECT_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              CSECT_NEXT_PTR = HOLD_PTR;\n                         CSECT_LIST_PTR = HOLD_PTR;\n                         CSECT_LIST_NAME = SUBSTR(CARD,P,L);\n                         CSECT_LIST_SIZE = 0B;\n                    END;\n /*NIGEL */         IF SUBSTR(CARD,P+L,1) = ' ' THEN\n                         L = L + 1;\n               END;\n               END; /* SELECT */\n               OTHERWISE\n                    CALL PLIDUMP('TFSHB',\n                         'LOGIC ERROR - LIST_TYPE = '||LIST_TYPE);\n               END; /* SELECT(LIST_TYPE) */\n               IF SUBSTR(CARD,P+L,1) = ' ' THEN\n               DO;\n                    K = VERIFY(SUBSTR(CARD,P+L+1),' ');\n                    IF K = 0 THEN\n                         L= 81 - P;\n                    ELSE\n                         L = L + K;\n               END;\n          END; /* DO P = REPEAT WHILE(P <= 80) */\n          IF FULL_STOP THEN\n               LEAVE;\n          READ FILE(SYSIN) SET(CARD_PTR);\n     END; /* DO WHILE(MORE_CARDS) */\n1    IF ERROR_FLAGS \u00ac= (16)'0'B | \u00ac FULL_STOP | MEMBER = '' THEN\n     DO;\n          PUT FILE(SYSPRINT) EDIT\n          ('** ERROR ** STATEMENT ABOVE IGNORED.')\n          (SKIP,A)\n          (((ERROR_MSG(I),'.' DO J = 1 WHILE(SUBSTR(ERROR_FLAGS,I,1)))\n                    DO I = 1 TO 16))\n          (SKIP,2 A);\n          DO I = 1 TO CSECT_COUNT;\n               CSECT_LIST_PTR = CSECT_HEAD_PTR;\n               CSECT_HEAD_PTR = CSECT_NEXT_PTR;\n               FREE CSECT_LIST_ENTRY;\n          END;\n          DO I = 1 TO MASK_COUNT;\n               MASK_LIST_PTR = MASK_HEAD_PTR;\n               MASK_HEAD_PTR = MASK_NEXT_PTR;\n               FREE MASK_LIST_ENTRY;\n          END;\n          RETURN_CODE = MAX(RETURN_CODE,12);\n          IF MORE_CARDS THEN\n               GO TO OBTAIN_A_CMD;\n          GO TO END_OF_JOB;\n     END;\n0    IF CSECT_COUNT > 0 THEN\n     DO;\n          ALLOC CSECT_ARRAY(CSECT_COUNT);\n          DO I = 1 TO CSECT_COUNT;\n               CSECT_LIST_PTR = CSECT_HEAD_PTR;\n               CSECT_NAME(I) = CSECT_LIST_NAME;\n               CSECT_SIZE(I) = CSECT_LIST_SIZE;\n               CSECT_MATCHED(I) = '0'B;\n               CSECT_HEAD_PTR = CSECT_NEXT_PTR;\n               FREE CSECT_LIST_ENTRY;\n          END;\n     END;\n0    IF MASK_COUNT > 0 THEN\n     DO;\n          ALLOC MASK_ARRAY(MASK_COUNT);\n          DO I = 1 TO MASK_COUNT;\n               MASK_LIST_PTR = MASK_HEAD_PTR;\n               MASK_NAME(I) = MASK_LIST_NAME;\n               MASK_MATCH_COUNT(I) = 0B;\n               MASK_HEAD_PTR = MASK_NEXT_PTR;\n               FREE MASK_LIST_ENTRY;\n          END;\n     END;\n0    IF NEW_NAME = '' THEN\n          NEW_NAME = MEMBER;\n1    /* WE HAVE NOW PARSED THE USER'S INPUT AND FOUND IT TO BE\n          SATISFACTORY. WE WILL NOW HAVE A GO AT DELINKING THE LOAD\n          MODULE AS REQUESTED BY THE USER. */\n     IF MEMBER_NAME = MEMBER THEN\n     DO;\n          MEMBER_NAME = HIGH(8);\n          CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD);\n     END;\n0    MEMBER_NAME = MEMBER;\n     RECLEN = STG(LMOD_RECORD);\n     CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD,\n               SSI_DATA,DIRECTORY_INFO);\n0    PAGE_TYPE = 0;\n     IF PLIRETV = 0B THEN\n     DO;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          ('MEMBER ',MEMBER,' FOUND.')\n          (A);\n          IF PDS2SCTR THEN /* IT'S SCATTER FORMAT */\n          DO;\n               PDS_BLDL_SCTR_PTR = PTRADD(ADDR(PDS2FTB3),1);\n               PDS_BLDL_ALIAS_PTR =\n                    PTRADD(ADDR(PDS2FTB3),STG(PDSS01)+1);\n          END;\n          ELSE /* IT'S BLOCK FORMAT */\n          DO;\n               PDS_BLDL_SCTR_PTR = NULL;\n               PDS_BLDL_ALIAS_PTR = PTRADD(ADDR(PDS2FTB3),1);\n          END;\n          IF PDS2ALIS THEN\n          DO;\n               L = INDEX(PDS2MNM,' ');\n               IF L = 0B THEN\n                    L = 8;\n               PUT FILE(SYSPRINT) EDIT\n               (' THIS IS AN ALIAS FOR MEMBER ',SUBSTR(PDS2MNM,1,L),\n                         '.')\n               (A);\n               AMODE = PDSAAMOD;\n          END;\n          ELSE\n          DO;\n               PDS_BLDL_ALIAS_PTR = NULL;\n               AMODE = PDSMAMOD;\n          END;\n          UNSPEC(EP_ADDR) = (8)'0'B || PDS2EPA;\n          EP_ESDID = 0B;\n          IF PDS2SSI THEN\n          DO;\n               PUT FILE(SYSPRINT) EDIT\n               (' SSI = \"',SSI_DATA,'\".')\n               (A);\n /*GP*/        IF PDS2ALIS\n /*  */        THEN\n /*  */             PDS_BLDL_SSI_PTR = PTRADD(PDS_BLDL_ALIAS_PTR,11);\n /*  */        ELSE              /* ENSURE HALFWORD ALIGNMENT */\n /*  */             PDS_BLDL_SSI_PTR = PTRADD(ADDR(PDS2FTB3),2);\n /*  */        IF PDS2SCTR THEN  /* ALLOW FOR SCATTER SECTION */\n /*GP*/             PDS_BLDL_SSI_PTR = PTRADD(PDS_BLDL_SSI_PTR,8);\n          END;\n          ELSE\n          DO;\n               PUT FILE(SYSPRINT) EDIT\n               (' NO SSI DATA.')\n               (A);\n               PDS_BLDL_SSI_PTR = NULL;\n          END;\n          IF PDS2PAGA THEN\n               PUT FILE(SYSPRINT) EDIT\n               (' PAGE ALIGNMENT REQUIRED.')\n               (A);\n          IF PDSAPFLG THEN\n          DO;\n               PDS_BLDL_APF_PTR = PTRADD(ADDR(PDS2FTB3),1);\n               IF PDS2SCTR THEN /* ALLOW FOR SCATTER TABLE */\n                    PDS_BLDL_APF_PTR =\n                         PTRADD(PDS_BLDL_APF_PTR,STG(PDSS01));\n               IF PDS2ALIS THEN /* ALLOW FOR ALIAS INFO. */\n                    PDS_BLDL_APF_PTR =\n                         PTRADD(PDS_BLDL_APF_PTR,STG(PDSS02));\n               IF PDS2SSI THEN /* ALLOW FOR SSI BYTES */\n                    PDS_BLDL_APF_PTR =\n                         PTRADD(PDS_BLDL_SSI_PTR,STG(PDSS03));   /*GP*/\n               PUT FILE(SYSPRINT) EDIT\n               (' AUTHORIZATION CODE IS ',DWNSHEX(UNSPEC(PDSAPFAC)),'.')\n               (A);\n          END;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          ('LOAD MODULE ATTRIBUTES :',\n               'ENTRY POINT : X''',DWNSHEX(PDS2EPA),'''',\n               'STORAGE REQUIRED : X''',DWNSHEX(PDS2STOR),'''')\n          (A,SKIP,COL(21),3 A,COL(51),3 A)\n          ((ATTRIB(I,SUBSTR(STRING(PDS2ATR1)||STRING(PDS2ATR2),I,1))\n               DO I = 1 TO 16))\n          (SKIP,X(10),8 A(15))\n          ('AMODE : ',AMODE_TYPE(AMODE),\n               'RMODE : ',RMODE_TYPE(PDSLRMOD))\n          (SKIP,X(20),2 A,COL(41),2 A);\n          REUS_ATR = 'NONE';\n /* GP */ IF PDS2REUS THEN REUS_ATR = 'SERIAL';\n /*    */ IF PDS2RENT THEN REUS_ATR = 'RENT';\n /*    */ IF PDS2REFR THEN REUS_ATR = 'REFR';\n /*    */ IF PDS2LOAD THEN LOAD_ATR = 'OL';\n /* GP */             ELSE LOAD_ATR = 'NOOL';\n     END;\n     EOM_FLAG = '0'B;\n-    DO WHILE(PLIRETV = 0B) UNTIL(EOM_FLAG);\n0         SELECT(SUBSTR(LMOD_RECORD,1,1));\n-         WHEN('40'X) /* SYM RECORD */\n          DO;\n          END;\n-         WHEN('10'X) /* SCATTER/TRANSLATION RECORD */\n          DO;\n          END;\n1         WHEN('20'X) /* CESD RECORD */\n          BEGIN;\n               DCL  1    CESD_LMOD           UNAL\n                                             BASED(ADDR(LMOD_RECORD)),\n                         2    REC_ID              BIT(8),\n                         2    FLAG_BYTE           BIT(8),\n                         2    FILLER              BIN FIXED(15,0),\n                         2    CESD_1ST_ESDID      BIN FIXED(15,0),\n                         2    CESD_BYTE_CNT       BIN FIXED(15,0),\n                         2    CESD_DATA(15),\n                              3    CESD_SYMBOL         CHAR(8),\n                              3    CESD_SYM_FLAGS,\n                                   4    CESD_SYM_MAP        BIT(1),\n                                   4    CESD_SYM_CHAIN      BIT(1),\n                                   4    CESD_SYM_INSERT     BIT(1),\n                                   4    CESD_SYM_REPLACE    BIT(1),\n                              3    CESD_SYM_TYPE       BIT(4),\n                              3    CESD_SYM_ADDR       BIT(24),\n                              3    CESD_SYM_ATTR       BIT(8),\n                              3    CESD_SYM_LENGTH     BIT(24),\n                    (CSECT_ADDR,CSECT_LENGTH) BIN FIXED(31,0) INIT(0B),\n                    (I,J,K,NBYTES,THIS_ESDID) BIN FIXED(15,0) INIT(0B);\n               DO THIS_ESDID = CESD_1ST_ESDID BY 1\n                         WHILE(NBYTES < CESD_BYTE_CNT);\n                    I = I + 1;\n                    IF CESD_SYM_TYPE(I) \u00ac= '7'BX THEN\n                    DO;\n                         ALLOC CESD_LIST_ITEM SET(HOLD_PTR);\n                         IF CESD_HEAD_PTR = NULL THEN\n                              CESD_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                         DO;\n                              CARD_PTR = NULL;\n                              DO CESD_LIST_PTR = CESD_HEAD_PTR\n                                        REPEAT CESD_NEXT_PTR\n                                        WHILE(CESD_LIST_PTR \u00ac= NULL &\n                                        CESD_ADDR < CESD_SYM_ADDR(I));\n                                   CARD_PTR = CESD_LIST_PTR;\n                              END;\n                              SELECT;\n                              WHEN(CARD_PTR = NULL)\n                              DO;\n                                   HOLD_PTR -> CESD_NEXT_PTR =\n                                             CESD_HEAD_PTR;\n                                   CESD_HEAD_PTR = HOLD_PTR;\n                              END;\n                              WHEN(CESD_LIST_PTR = NULL)\n                                   CARD_PTR -> CESD_NEXT_PTR = HOLD_PTR;\n                              OTHERWISE\n                              DO;\n                                   HOLD_PTR -> CESD_NEXT_PTR =\n                                        CESD_LIST_PTR;\n                                   CARD_PTR -> CESD_NEXT_PTR = HOLD_PTR;\n                              END;\n                              END; /* SELECT */\n                         END;\n                         CESD_LIST_PTR = HOLD_PTR;\n                         CESD_ESDID = THIS_ESDID;\n                         CESD_NAME = CESD_SYMBOL(I);\n                         CESD_TYPE = (4)'0'B || CESD_SYM_TYPE(I);\n                         CESD_ADDR = CESD_SYM_ADDR(I);\n                         STRING(CESD_AMODE_RMODE) = CESD_SYM_ATTR(I);\n                         CESD_LENGTH = CESD_SYM_LENGTH(I);\n                         CESD_DELINK_FLAG = '0'B;\n                         IF SUBSTR(CESD_TYPE,5) = (4)'0'B THEN\n                         DO;\n                              UNSPEC(CSECT_ADDR) = (8)'0'B ||\n                                        CESD_SYM_ADDR(I);\n                              UNSPEC(CSECT_LENGTH) = (8)'0'B ||\n                                        CESD_SYM_LENGTH(I);\n                              IF EP_ADDR >= CSECT_ADDR &\n                                        EP_ADDR <\n                                        (CSECT_ADDR + CSECT_LENGTH)\n                                        THEN\n                              DO;\n                                   EP_ESDID = THIS_ESDID;\n                                   EP_OFFSET = EP_ADDR - CSECT_ADDR;\n                                   IF LIST_TYPE_NO = 4 THEN\n                                        CESD_DELINK_FLAG = '1'B;\n                              END;\n                              DO J = 1 TO CSECT_COUNT\n                                        WHILE(\u00ac CESD_DELINK_FLAG);\n                                   IF CESD_NAME = CSECT_NAME(J) THEN\n                                   DO;\n                                        CESD_DELINK_FLAG = '1'B;\n                                        CSECT_MATCHED(J) = '1'B;\n                                   END;\n                              END;\n                              DO J = 1 TO MASK_COUNT\n                                        WHILE(\u00ac CESD_DELINK_FLAG);\n                                   IF MASK_MATCH(CESD_NAME,MASK_NAME(J))\n                                             THEN\n                                   DO;\n                                        CESD_DELINK_FLAG = '1'B;\n                                        MASK_MATCH_COUNT(J) =\n                                                  MASK_MATCH_COUNT(J) +\n                                                            1;\n                                   END;\n                              END;\n                              SELECT(LIST_TYPE_NO);\n                              WHEN(1) /* TYPE ALL */\n                                   CESD_DELINK_FLAG = '1'B;\n                              WHEN(2) /* TYPE EXCLUDE */\n                                   CESD_DELINK_FLAG =\n                                             \u00ac CESD_DELINK_FLAG;\n                              WHEN(3,4) /* TYPE SELECT OR EPCSECT */\n                                   /* DO NOTHING */;\n                              WHEN(5) /* TYPE MAP */\n                                   CESD_DELINK_FLAG = CESD_SYM_MAP(I);\n                              WHEN(6) /* TYPE NOMAP */\n                                   CESD_DELINK_FLAG = \u00ac CESD_SYM_MAP(I);\n                              END;\n                         END;\n                    END; /* IF CESD_SYM_TYPE \u00ac= '7'BX */\n                    NBYTES = NBYTES + 16;\n               END; /* DO THIS_ESDID = */\n          END;\n1         WHEN('80'X) /* IDR RECORD */\n          BEGIN;\n               DCL  1    IDR_LMOD            UNAL\n                                             BASED(ADDR(LMOD_RECORD)),\n                         2    IDR_REC_ID          BIT(8),\n                         2    IDR_BYTE_CNT        BIT(8),\n                         2    IDR_SUB_TYPE        BIT(8),\n                         2    IDR_BYTES(3:255)    CHAR(1),\n                    1    IDR_TRANS_ESDID     UNAL BASED(IDR_TRANS_PTR),\n                         2    IDR_ESDID(127)      BIN FIXED(15,0),\n                    1    IDR_TRANSLATOR_DATA BASED(IDR_DATA_PTR),\n                         2    FILLER#1            BIT(7),\n                         2    IDR_2_TRANS         BIT(1),\n                         2    IDR_TRANS_DATA(2),\n                              3    IDR_TRANS_NAME      CHAR(10),\n                              3    IDR_TRANS_VVMM(4)   BIT(4) UNAL,\n                              3    IDR_TRANS_DATE      DEC FIXED(5,0),\n                    1    IDR_USER_ENTRY      UNAL\n                                             BASED(IDR_TRANS_PTR),\n                         2    IDR_USER_ESDID      BIN FIXED(15,0),\n                         2    IDR_USER_DATE       BIT(24),\n                         2    IDR_USER_LENGTH_BITS BIT(8),\n                         2    IDR_USER_DATA       CHAR(40),\n                    IDR_OVFL_REC        CHAR(256) BASED(IDR_OVFL_PTR),\n                    IDR_OVFL_PTR        PTR,\n                    IDR_OVFL_FLAG       BIT(1) INIT('0'B),\n                    (IDR_TRANS_PTR,IDR_DATA_PTR) PTR INIT(NULL),\n                    (I,J,K,NBYTES,NSCAN) BIN FIXED(15,0);\n0              NSCAN = 2;\n               UNSPEC(NBYTES) = (8)'0'B || IDR_BYTE_CNT;\n               IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n-              SELECT(SUBSTR(IDR_SUB_TYPE,5,4));\n0                   WHEN('0100'B) /* TRANSLATOR IDR */\n                    DO IDR_TRANS_PTR = ADDR(IDR_BYTES(3))\n                              REPEAT ADDR(IDR_BYTES(NSCAN+1))\n                              WHILE(NSCAN < NBYTES);\n                         I = 1;\n                         DO UNTIL(I <= K);\n                              K = (NBYTES - NSCAN)/2;\n                              DO I = I TO K UNTIL(IDR_ESDID(I) < 0);\n                              END;\n                              IF I > K THEN\n                              DO;\n                                   IDR_OVFL_FLAG = '1'B;\n                                   CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,\n                                        RECLEN,IDR_OVFL_REC);\n                                   UNSPEC(J) = (8)'0'B ||\n                                       UNSPEC(SUBSTR(IDR_OVFL_REC,2,1));\n                                   NBYTES = NBYTES + J - 2;\n                                   IDR_OVFL_REC =\n                                        SUBSTR(IDR_OVFL_REC,4,253);\n                                   IDR_OVFL_PTR =\n                                        ADDR(IDR_BYTES(NBYTES+1));\n                              END;\n                         END;\n                         IDR_DATA_PTR = ADDR(IDR_ESDID(I+1));\n                         UNSPEC(IDR_ESDID(I)) = UNSPEC(IDR_ESDID(I)) &\n                                   '7FFF'BX;\n                         IF IDR_2_TRANS THEN\n                              IDR_TRANS_CNT = 2;\n                         ELSE\n                              IDR_TRANS_CNT = 1;\n                         NSCAN = NSCAN + I + I + 1 + IDR_TRANS_CNT*15;\n                         IF NSCAN > NBYTES THEN\n                         DO;\n                              IDR_OVFL_FLAG = '1'B;\n                              CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,\n                                   RECLEN,IDR_OVFL_REC);\n                              UNSPEC(J) = (8)'0'B ||\n                                   UNSPEC(SUBSTR(IDR_OVFL_REC,2,1));\n                              NBYTES = NBYTES + J - 2;\n                              IDR_OVFL_REC = SUBSTR(IDR_OVFL_REC,4,253);\n                              IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n                         END;\n                         DO J = 1 TO I;\n                              DO HOLD_PTR = CESD_HEAD_PTR\n                                        REPEAT\n                                             HOLD_PTR -> CESD_NEXT_PTR\n                                        WHILE(HOLD_PTR \u00ac= NULL)\n                                        UNTIL(HOLD_PTR -> CESD_ESDID =\n                                        IDR_ESDID(J));\n                              END;\n                              IF HOLD_PTR \u00ac= NULL &\n                                       HOLD_PTR -> CESD_DELINK_FLAG THEN\n                              DO;\n                                   ALLOC IDR_LIST_ITEM SET(HOLD_PTR);\n                                   IF IDR_HEAD_PTR = NULL THEN\n                                        IDR_HEAD_PTR = HOLD_PTR;\n                                   ELSE\n                                        IDR_NEXT_PTR = HOLD_PTR;\n                                   IDR_LIST_PTR = HOLD_PTR;\n                                   IDR_LIST_ESDID = IDR_ESDID(J);\n                                   DO K = 1 TO IDR_TRANS_CNT;\n                                        IDR_DATA(K) =\n                                             IDR_TRANS_DATA(K);\n                                   END;\n                              END;\n                         END;\n                         IF IDR_OVFL_FLAG THEN\n                         DO;\n                              IDR_OVFL_FLAG = '0'B;\n                              NBYTES = NBYTES - NSCAN;\n                              SUBSTR(LMOD_RECORD,4,NBYTES) =\n                                   SUBSTR(LMOD_RECORD,NSCAN+2,NBYTES);\n                              NBYTES = NBYTES + 2;\n                              IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n                              NSCAN = 2;\n                         END;\n                    END;\n-                   WHEN('1000'B) /* IDENTIFY (USER) IDR */\n                    DO IDR_TRANS_PTR = ADDR(IDR_BYTES(3))\n                              REPEAT ADDR(IDR_BYTES(NSCAN+1))\n                              WHILE(NSCAN < NBYTES);\n                         K = NSCAN + 6;\n                         IF K >= NBYTES THEN\n                         DO;\n                              IDR_OVFL_FLAG = '1'B;\n                              CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,\n                                   RECLEN,IDR_OVFL_REC);\n                              UNSPEC(J) = (8)'0'B ||\n                                   UNSPEC(SUBSTR(IDR_OVFL_REC,2,1));\n                              NBYTES = NBYTES + J - 2;\n                              IDR_OVFL_REC = SUBSTR(IDR_OVFL_REC,4,253);\n                              IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n                         END;\n                         UNSPEC(IDR_USER_LENGTH) = (8)'0'B ||\n                                   IDR_USER_LENGTH_BITS;\n                         NSCAN = K + IDR_USER_LENGTH;\n                         IF NSCAN > NBYTES THEN\n                         DO;\n                              IDR_OVFL_FLAG = '1'B;\n                              CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,\n                                   RECLEN,IDR_OVFL_REC);\n                              UNSPEC(J) = (8)'0'B ||\n                                   UNSPEC(SUBSTR(IDR_OVFL_REC,2,1));\n                              NBYTES = NBYTES + J - 2;\n                              IDR_OVFL_REC = SUBSTR(IDR_OVFL_REC,4,253);\n                              IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n                         END;\n                         DO HOLD_PTR = CESD_HEAD_PTR\n                                   REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                                   WHILE(HOLD_PTR \u00ac= NULL)\n                                   UNTIL(HOLD_PTR -> CESD_ESDID =\n                                   IDR_USER_ESDID);\n                         END;\n                         IF HOLD_PTR \u00ac= NULL &\n                                   HOLD_PTR -> CESD_DELINK_FLAG THEN\n                         DO;\n                              ALLOC IDR_USER_ITEM SET(HOLD_PTR);\n                              IF IDR_USER_HEAD_PTR = NULL THEN\n                                   IDR_USER_HEAD_PTR = HOLD_PTR;\n                              ELSE\n                                   IDR_USER_NEXT_PTR = HOLD_PTR;\n                              IDR_USER_PTR = HOLD_PTR;\n                              IDR_USER_LIST_ESDID = IDR_USER_ESDID;\n                              IDR_USER_LIST_DATA =\n                                SUBSTR(IDR_USER_DATA,1,IDR_USER_LENGTH);\n                         END;\n                         IF IDR_OVFL_FLAG THEN\n                         DO;\n                              IDR_OVFL_FLAG = '0'B;\n                              NBYTES = NBYTES - NSCAN;\n                              SUBSTR(LMOD_RECORD,4,NBYTES) =\n                                   SUBSTR(LMOD_RECORD,NSCAN+2,NBYTES);\n                              NBYTES = NBYTES + 2;\n                              IDR_OVFL_PTR = ADDR(IDR_BYTES(NBYTES+1));\n                              NSCAN = 2;\n                         END;\n                    END;\n0                   OTHERWISE\n                         /* DROP THIS IDR RECORD */;\n               END;\n          END;\n1         WHEN('01'X,'05'X,'0D'X) /* CTL RECORD */\n          BEGIN;\n               DCL  1    CTL_LMOD            UNAL BASED(CTL_PTR),\n                         2    CTL_REC_ID          BIT(8),\n                         2    FILLER#1            BIT(8),\n                         2    RLD_CNT             BIN FIXED(15,0),\n                         2    CTL_BYTE_CNT        BIN FIXED(15,0),\n                         2    FILLER#2            BIN FIXED(15,0),\n                         2    FILLER#3            BIT(8),\n                         2    CTL_1ST_ADDR        BIT(24),\n                         2    FILLER#4            CHAR(4),\n                         2    CTL_BYTE((NBYTES) REFER (CTL_BYTE_CNT))\n                                                  CHAR(1),\n                    1    CTL_DATA            UNAL BASED(CTL_DATA_PTR),\n                         2    CTL_ESDID           BIN FIXED(15,0),\n                         2    CTL_TXT_LENGTH      BIN FIXED(15,0),\n                    (CTL_PTR,CTL_DATA_PTR) PTR INIT(ADDR(LMOD_RECORD)),\n                    (I,J,NBYTES,NSCAN)  BIN FIXED(15,0),\n                    (SD_ADDR,TEMP)      BIN FIXED(31,0);\n0              IF CTL_REC_ID = '0D'X & RLD_CNT = 0B THEN\n                    EOM_FLAG = '1'B;\n0              NBYTES = CTL_BYTE_CNT;\n               ALLOC CTL_LMOD;\n               CTL_LMOD = CTL_DATA_PTR -> CTL_LMOD;\n               RECLEN = STG(LMOD_RECORD);\n               CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD);\n               IF PLIRETV \u00ac= 0 THEN\n                    CALL PLIDUMP('TFSHB','MISSING TXT');\n               J,NSCAN,NBYTES = 0B;\n               UNSPEC(TXT_ADDR) = (8)'0'B || CTL_1ST_ADDR;\n               DO CTL_DATA_PTR = ADDR(CTL_BYTE(1))\n                         REPEAT ADDR(CTL_BYTE(NSCAN+1))\n                         WHILE(NSCAN < CTL_BYTE_CNT);\n                    DO HOLD_PTR = CESD_HEAD_PTR\n                              REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                              WHILE(HOLD_PTR \u00ac= NULL)\n                              UNTIL(HOLD_PTR -> CESD_ESDID = CTL_ESDID);\n                    END;\n                    IF HOLD_PTR \u00ac= NULL &\n                              HOLD_PTR -> CESD_DELINK_FLAG THEN\n                    DO;\n                         UNSPEC(SD_ADDR) = (8)'0'B ||\n                                   HOLD_PTR -> CESD_ADDR;\n                         TXT_LENGTH = CTL_TXT_LENGTH;\n                         ALLOC TXT_LIST_ITEM SET(HOLD_PTR);\n                         IF TXT_HEAD_PTR = NULL THEN\n                              TXT_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              TXT_NEXT_PTR = HOLD_PTR;\n                         TXT_LIST_PTR = HOLD_PTR;\n                         TEMP = TXT_ADDR + J - SD_ADDR;\n                         TXT_ADDR_1ST_BYTE =\n                                   SUBSTR(UNSPEC(TEMP),9,24);\n                         TXT_ESDID = CTL_ESDID;\n                         TXT_BYTES = SUBSTR(LMOD_RECORD,J+1,TXT_LENGTH);\n                    END;\n                    J = J + CTL_TXT_LENGTH;\n                    NSCAN = NSCAN + 4;\n               END;\n               FREE CTL_LMOD;\n          END;\n1         WHEN('03'X,'07'X,'0F'X) /* CTL/RLD RECORD */\n          BEGIN;\n               DCL  1    CTL_RLD_LMOD        UNAL BASED(CTL_RLD_PTR),\n                         2    CTL_RLD_REC_ID      BIT(8),\n                         2    FILLER#1            BIT(24),\n                         2    CTL_BYTE_CNT        BIN FIXED(15,0),\n                         2    RLD_BYTE_CNT        BIN FIXED(15,0),\n                         2    FILLER#2            BIT(8),\n                         2    CTL_RLD_1ST_ADDR    BIT(24),\n                         2    FILLER#3            CHAR(4),\n                         2    RLD_BYTE((NSCAN) REFER (RLD_BYTE_CNT))\n                                                  CHAR(1),\n                         2    CTL_BYTE((NBYTES) REFER (CTL_BYTE_CNT))\n                                                  CHAR(1),\n                    1    CTL_DATA            UNAL BASED(CTL_DATA_PTR),\n                         2    CTL_ESDID           BIN FIXED(15,0),\n                         2    CTL_TXT_LENGTH      BIN FIXED(15,0),\n                    1    RLD_DATA            UNAL BASED(RLD_PTR),\n                         2    RLD_REL_ID          BIN FIXED(15,0),\n                         2    RLD_POS_ID          BIN FIXED(15,0),\n                         2    RLD_ITEM(59),\n                              3    RLD_FLAGS           BIT(8),\n                              3    RLD_ADCON_ADDR      BIT(24),\n                    (CTL_RLD_PTR,CTL_DATA_PTR,RLD_PTR) PTR\n                                        INIT(ADDR(LMOD_RECORD)),\n                    (I,J,NBYTES,NSCAN)  BIN FIXED(15,0),\n                    (SD_ADDR,TEMP)      BIN FIXED(31,0);\n0              IF CTL_RLD_REC_ID = '0F'X THEN\n                    EOM_FLAG = '1'B;\n0              NBYTES = CTL_BYTE_CNT;\n               NSCAN = RLD_BYTE_CNT;\n               ALLOC CTL_RLD_LMOD;\n               CTL_RLD_LMOD = CTL_DATA_PTR -> CTL_RLD_LMOD;\n               RECLEN = STG(LMOD_RECORD);\n               CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD);\n               IF PLIRETV \u00ac= 0 THEN\n                    CALL PLIDUMP('TFSHB','MISSING TXT');\n               J,NSCAN,NBYTES = 0B;\n               UNSPEC(TXT_ADDR) = (8)'0'B || CTL_RLD_1ST_ADDR;\n               DO CTL_DATA_PTR = ADDR(CTL_BYTE(1))\n                         REPEAT ADDR(CTL_BYTE(NSCAN+1))\n                         WHILE(NSCAN < CTL_BYTE_CNT);\n                    DO HOLD_PTR = CESD_HEAD_PTR\n                              REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                              WHILE(HOLD_PTR \u00ac= NULL)\n                              UNTIL(HOLD_PTR -> CESD_ESDID = CTL_ESDID);\n                    END;\n                    IF HOLD_PTR \u00ac= NULL &\n                              HOLD_PTR -> CESD_DELINK_FLAG THEN\n                    DO;\n                         UNSPEC(SD_ADDR) = (8)'0'B ||\n                                   HOLD_PTR -> CESD_ADDR;\n                         TXT_LENGTH = CTL_TXT_LENGTH;\n                         ALLOC TXT_LIST_ITEM SET(HOLD_PTR);\n                         IF TXT_HEAD_PTR = NULL THEN\n                              TXT_HEAD_PTR = HOLD_PTR;\n                         ELSE\n                              TXT_NEXT_PTR = HOLD_PTR;\n                         TXT_LIST_PTR = HOLD_PTR;\n                         TEMP = TXT_ADDR + J - SD_ADDR;\n                         TXT_ADDR_1ST_BYTE =\n                                   SUBSTR(UNSPEC(TEMP),9,24);\n                         TXT_ESDID = CTL_ESDID;\n                         TXT_BYTES = SUBSTR(LMOD_RECORD,J+1,TXT_LENGTH);\n                    END;\n                    J = J + CTL_TXT_LENGTH;\n                    NSCAN = NSCAN + 4;\n               END;\n-              NSCAN = 0B;\n               DO RLD_PTR = ADDR(RLD_BYTE(1))\n                         REPEAT ADDR(RLD_BYTE(NSCAN+1))\n                         WHILE(NSCAN < RLD_BYTE_CNT);\n                    I = (RLD_BYTE_CNT - NSCAN - 4)/4;\n                    DO RLD_ITEM_CNT = 1 TO I\n                         WHILE(SUBSTR(RLD_FLAGS(RLD_ITEM_CNT),8,1));\n                    END;\n                    IF RLD_ITEM_CNT > I THEN\n                         SIGNAL ERROR;\n                    ALLOC RLD_LIST_ITEM SET(HOLD_PTR);\n                    IF RLD_HEAD_PTR = NULL THEN\n                         RLD_HEAD_PTR = HOLD_PTR;\n                    ELSE\n                    DO;\n                         CARD_PTR = NULL;\n                         DO RLD_LIST_PTR = RLD_HEAD_PTR\n                                   REPEAT RLD_NEXT_PTR\n                                   WHILE(RLD_LIST_PTR \u00ac= NULL &\n                                   (RLD_LIST_POS_ID < RLD_POS_ID |\n                                   (RLD_LIST_POS_ID = RLD_POS_ID &\n                                   RLD_LIST_REL_ID < RLD_REL_ID)));\n                              CARD_PTR = RLD_LIST_PTR;\n                         END;\n                         SELECT;\n                         WHEN(CARD_PTR = NULL)\n                         DO;\n                              HOLD_PTR -> RLD_NEXT_PTR = RLD_HEAD_PTR;\n                              RLD_HEAD_PTR = HOLD_PTR;\n                         END;\n                         WHEN(RLD_LIST_PTR = NULL)\n                              CARD_PTR -> RLD_NEXT_PTR = HOLD_PTR;\n                         OTHERWISE\n                         DO;\n                              HOLD_PTR -> RLD_NEXT_PTR = RLD_LIST_PTR;\n                              CARD_PTR -> RLD_NEXT_PTR = HOLD_PTR;\n                         END;\n                         END; /* SELECT */\n                    END;\n                    RLD_LIST_PTR = HOLD_PTR;\n                    RLD_LIST_REL_ID = RLD_REL_ID;\n                    RLD_LIST_POS_ID = RLD_POS_ID;\n                    DO HOLD_PTR = CESD_HEAD_PTR\n                              REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                              WHILE(HOLD_PTR \u00ac= NULL)\n                              UNTIL(HOLD_PTR -> CESD_ESDID =\n                                   RLD_POS_ID);\n                    END;\n                    IF HOLD_PTR = NULL THEN\n                         SIGNAL ERROR;\n                    UNSPEC(SD_ADDR) = (8)'0'B ||\n                              HOLD_PTR -> CESD_ADDR;\n                    DO I = 1 TO RLD_ITEM_CNT;\n                         RLD_LIST_FLAGS(I) = RLD_FLAGS(I);\n                         UNSPEC(ADCON) = (8)'0'B || RLD_ADCON_ADDR(I);\n                         ADCON = ADCON - SD_ADDR;\n                         RLD_LIST_ADCON_ADDR(I) =\n                              SUBSTR(UNSPEC(ADCON),9,24);\n                    END;\n                    NSCAN = NSCAN + 4 + RLD_ITEM_CNT*4;\n               END;\n               FREE CTL_RLD_LMOD;\n          END;\n1         WHEN('02'X,'06'X,'0E'X) /* RLD RECORD */\n          BEGIN;\n               DCL  1    RLD_LMOD            UNAL\n                                             BASED(ADDR(LMOD_RECORD)),\n                         2    RLD_REC_ID          BIT(8),\n                         2    FILLER#1            BIT(8),\n                         2    RLD_CNT             BIN FIXED(15,0),\n                         2    FILLER#2            BIN FIXED(15,0),\n                         2    RLD_BYTE_CNT        BIN FIXED(15,0),\n                         2    FILLER#3            CHAR(8),\n                         2    RLD_BYTE(240 REFER (RLD_BYTE_CNT))\n                                                  CHAR(1),\n                    1    RLD_DATA            UNAL BASED(RLD_PTR),\n                         2    RLD_REL_ID          BIN FIXED(15,0),\n                         2    RLD_POS_ID          BIN FIXED(15,0),\n                         2    RLD_ITEM(59),\n                              3    RLD_FLAGS           BIT(8),\n                              3    RLD_ADCON_ADDR      BIT(24),\n                    RLD_PTR             PTR INIT(NULL),\n                    (I,NSCAN)           BIN FIXED(15,0);\n0              IF RLD_REC_ID = '0E'X THEN\n                    EOM_FLAG = '1'B;\n0              NSCAN = 0B;\n               DO RLD_PTR = ADDR(RLD_BYTE(1))\n                         REPEAT ADDR(RLD_BYTE(NSCAN+1))\n                         WHILE(NSCAN < RLD_BYTE_CNT);\n                    I = (RLD_BYTE_CNT - NSCAN - 4)/4;\n                    DO RLD_ITEM_CNT = 1 TO I\n                         WHILE(SUBSTR(RLD_FLAGS(RLD_ITEM_CNT),8,1));\n                    END;\n                    IF RLD_ITEM_CNT > I THEN\n                         SIGNAL ERROR;\n                    ALLOC RLD_LIST_ITEM SET(HOLD_PTR);\n                    IF RLD_HEAD_PTR = NULL THEN\n                         RLD_HEAD_PTR = HOLD_PTR;\n                    ELSE\n                    DO;\n                         CARD_PTR = NULL;\n                         DO RLD_LIST_PTR = RLD_HEAD_PTR\n                                   REPEAT RLD_NEXT_PTR\n                                   WHILE(RLD_LIST_PTR \u00ac= NULL &\n                                   (RLD_LIST_POS_ID < RLD_POS_ID |\n                                   (RLD_LIST_POS_ID = RLD_POS_ID &\n                                   RLD_LIST_REL_ID < RLD_REL_ID)));\n                              CARD_PTR = RLD_LIST_PTR;\n                         END;\n                         SELECT;\n                         WHEN(CARD_PTR = NULL)\n                         DO;\n                              HOLD_PTR -> RLD_NEXT_PTR = RLD_HEAD_PTR;\n                              RLD_HEAD_PTR = HOLD_PTR;\n                         END;\n                         WHEN(RLD_LIST_PTR = NULL)\n                              CARD_PTR -> RLD_NEXT_PTR = HOLD_PTR;\n                         OTHERWISE\n                         DO;\n                              HOLD_PTR -> RLD_NEXT_PTR = RLD_LIST_PTR;\n                              CARD_PTR -> RLD_NEXT_PTR = HOLD_PTR;\n                         END;\n                         END; /* SELECT */\n                    END;\n                    RLD_LIST_PTR = HOLD_PTR;\n                    RLD_LIST_REL_ID = RLD_REL_ID;\n                    RLD_LIST_POS_ID = RLD_POS_ID;\n                    DO HOLD_PTR = CESD_HEAD_PTR\n                              REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                              WHILE(HOLD_PTR \u00ac= NULL)\n                              UNTIL(HOLD_PTR -> CESD_ESDID =\n                                   RLD_POS_ID);\n                    END;\n                    IF HOLD_PTR = NULL THEN\n                         SIGNAL ERROR;\n                    UNSPEC(SD_ADDR) = (8)'0'B ||\n                              HOLD_PTR -> CESD_ADDR;\n                    DO I = 1 TO RLD_ITEM_CNT;\n                         RLD_LIST_FLAGS(I) = RLD_FLAGS(I);\n                         UNSPEC(ADCON) = (8)'0'B || RLD_ADCON_ADDR(I);\n                         ADCON = ADCON - SD_ADDR;\n                         RLD_LIST_ADCON_ADDR(I) =\n                              SUBSTR(UNSPEC(ADCON),9,24);\n                    END;\n                    NSCAN = NSCAN + 4 + RLD_ITEM_CNT*4;\n               END;\n          END;\n1         OTHERWISE /* ERROR */\n          DO;\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               ('** ERROR ** INVALID RECORD TYPE X''',\n                    DWNSHEX(UNSPEC(SUBSTR(LMOD_RECORD,1,1))),'''.')\n               (A);\n               RETURN_CODE = MAX(RETURN_CODE,16);\n          END;\n-         END; /* SELECT(REC_ID) */\n0         RECLEN = STG(LMOD_RECORD);\n          CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD);\n     END; /* DO WHILE(PLIRETV = 0) */\n1    /* NOW WE'LL SORT OUT THE RETURN CODE */\n     SELECT(PLIRETV);\n0    WHEN(0,4) /* NORMAL END OF MEMBER - GENERATE THE DECK */\n     DO;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          (('CSECT','A/R','OLD','NEW' DO I = 1 TO 3))\n          (X(2),4(A,X(6)))\n          (('NAME','MODE','SIZE','SIZE' DO I = 1 TO 3))\n          (SKIP,3(X(2),A,2(X(6),A),X(5),A,X(5)));\n          PAGE_TYPE = 2;\n          P = 81;\n          IF MORE_LINKCNTL & SUBSTR(LINKCNTL_REC,9,8) = MEMBER THEN\n          DO;\n               DO WHILE(MORE_LINKCNTL)\n                         UNTIL(SUBSTR(LINKCNTL_REC,1,7) = 'BEFORE ' |\n                               SUBSTR(LINKCNTL_REC,1,6) = 'AFTER ' |\n                               SUBSTR(LINKCNTL_REC,1,8) = 'MEMBER: ');\n                    READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n               END;\n               IF SUBSTR(LINKCNTL_REC,1,7) = 'BEFORE ' THEN\n               DO;\n                    READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n                    DO WHILE(MORE_LINKCNTL &\n                              SUBSTR(LINKCNTL_REC,1,6) \u00ac= 'AFTER ' &\n                              SUBSTR(LINKCNTL_REC,1,8) \u00ac= 'MEMBER: ');\n                         WRITE FILE(SYSLIN) FROM(LINKCNTL_REC);\n                         BEFORE_CNT = BEFORE_CNT + 1;\n                         READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n                    END;\n               END;\n          END;\n          DO CESD_LIST_PTR = CESD_HEAD_PTR REPEAT CESD_NEXT_PTR\n                    WHILE(CESD_LIST_PTR \u00ac= NULL);\n               IF CESD_DELINK_FLAG THEN\n               DO;\n                    LAST_TXT_ADDR = 0B;\n                    UNSPEC(TXT_SIZE) = (8)'0'B || CESD_LENGTH;\n                    DO I = 1 TO CSECT_COUNT\n                              UNTIL(CSECT_NAME(I) = CESD_NAME);\n                    END;\n                    IF I > CSECT_COUNT | CSECT_SIZE(I) = 0B THEN\n                         NEW_SIZE = (6)' ';\n                    ELSE\n                    DO;\n                         TXT_SIZE = MAX(TXT_SIZE,CSECT_SIZE(I));\n                         NEW_SIZE =\n                              DWNSHEX(SUBSTR(UNSPEC(TXT_SIZE),9,24));\n                    END;\n                    P = P + 40;\n                    IF P > 81 THEN\n                         P = 1;\n                    SYM_AMODE = CESD_AMODE64 || CESD_AMODE;   /* GP */\n                    PUT FILE(SYSPRINT) EDIT\n                    (CESD_NAME,SYM_AMODE_TYPE(SYM_AMODE),'/',\n                         RMODE_TYPE(CESD_RMODE),DWNSHEX(CESD_LENGTH),\n                         NEW_SIZE)\n                    (COL(P),A,X(3),3 A,2(X(3),A));\n                    SEQ# = 1;\n                    LOCATE ESD_OBJ FILE(SYSLIN);\n                    LAST_ESDID,NESD,ESD_1ST_ESDID = 1;\n                    ESD_PTR = ADDR(ESD_BYTES(1));\n                    ESD_BYTE_CNT = 16;\n                    ESD_NAME = CESD_NAME;\n                    ESD_TYPE = (8)'0'B;\n                    ESD_ADDR = (24)'0'B;\n                    ESD_AMODE_RMODE = STRING(CESD_AMODE_RMODE);\n                    ESD_LENGTH = SUBSTR(UNSPEC(TXT_SIZE),9,24);\n0                   DO HOLD_PTR = CESD_HEAD_PTR\n                              REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                              WHILE(HOLD_PTR \u00ac= NULL);\n                         HOLD_PTR -> CESD_NEW_ESDID = 0B;\n                         IF SUBSTR(HOLD_PTR->CESD_TYPE,5,4) = '0011'B &\n                                   SUBSTR(HOLD_PTR->CESD_LENGTH,9,16) =\n                                   UNSPEC(CESD_ESDID) THEN\n                         DO;\n                              NESD = NESD + 1;\n                              IF NESD > 3 THEN\n                              DO;\n                                   NESD = 1;\n                                   SEQ# = SEQ# + 1;\n                                   LOCATE ESD_OBJ FILE(SYSLIN);\n                                   ESD_1ST_ESDID = 2;\n                              END;\n                              ESD_PTR = ADDR(ESD_BYTES(NESD));\n                              ESD_BYTE_CNT = ESD_BYTE_CNT + 16;\n                              ESD_NAME = HOLD_PTR -> CESD_NAME;\n                              ESD_TYPE = '01'BX;\n                              UNSPEC(LD_ADDR) = (8)'0'B ||\n                                        HOLD_PTR -> CESD_ADDR;\n                              UNSPEC(SD_ADDR) = (8)'0'B || CESD_ADDR;\n                              LD_ADDR = LD_ADDR - SD_ADDR;\n                              ESD_ADDR =\n                                   SUBSTR(UNSPEC(LD_ADDR),9,24);\n                              ESD_LENGTH = '000001'BX;\n                              ESD_AMODE_RMODE = '40'BX;\n                         END;\n                    END; /* DO HOLD_PTR = */\n-                   DO RLD_LIST_PTR = RLD_HEAD_PTR\n                              REPEAT RLD_NEXT_PTR\n                              WHILE(RLD_LIST_PTR \u00ac= NULL);\n                         IF RLD_LIST_POS_ID = CESD_ESDID &\n                                   RLD_LIST_REL_ID \u00ac= CESD_ESDID &\n                                   RLD_LIST_REL_ID \u00ac= 0B THEN\n                         DO;\n                              DO HOLD_PTR = CESD_HEAD_PTR\n                                        REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                                        WHILE(HOLD_PTR \u00ac= NULL)\n                                        UNTIL(HOLD_PTR->CESD_ESDID =\n                                             RLD_LIST_REL_ID);\n                              END;\n                              IF HOLD_PTR = NULL THEN\n                                   SIGNAL ERROR;\n                              IF HOLD_PTR -> CESD_NEW_ESDID \u00ac= 0B THEN\n                                   LEAVE;\n                              HOLD_PTR -> CESD_NEW_ESDID,\n                                   LAST_ESDID = LAST_ESDID + 1;\n                              NESD = NESD + 1;\n                              IF NESD > 3 THEN\n                              DO;\n                                   NESD = 1;\n                                   SEQ# = SEQ# + 1;\n                                   LOCATE ESD_OBJ FILE(SYSLIN);\n                                   ESD_1ST_ESDID = LAST_ESDID;\n                              END;\n                              ESD_PTR = ADDR(ESD_BYTES(NESD));\n                              ESD_BYTE_CNT = ESD_BYTE_CNT + 16;\n                              ESD_NAME = HOLD_PTR -> CESD_NAME;\n                              ESD_ADDR = (24)'0'B;\n                              SELECT(SUBSTR(HOLD_PTR->CESD_TYPE,5));\n                              WHEN('0000'B,'0011'B,'0100'B,'0010'B)\n                                   ESD_TYPE = '02'BX;\n                              WHEN('0101'B)\n                              DO;\n                                   ESD_TYPE = '05'BX;\n                                   ESD_LENGTH = HOLD_PTR -> CESD_LENGTH;\n                              END;\n                              WHEN('0110'B)\n                              DO;\n                                   ESD_TYPE = '06'BX;\n                                   ESD_LENGTH = HOLD_PTR -> CESD_LENGTH;\n                                   ESD_AMODE_RMODE =\n                                     STRING(HOLD_PTR->CESD_AMODE_RMODE);\n                              END;\n                              WHEN('1010'B)\n                                   ESD_TYPE = '0A'BX;\n                              END; /* SELECT */\n                         END;\n                    END; /* DO RLD_LIST_PTR = */\n1                   IF CESD_LENGTH = 0B THEN;              /* GP */\n  /* MARCH 2006     DO                                        GP */\n  /*                     SEQ# = SEQ# + 1                      GP */\n  /* ERROR FOR BINDER ==>LOCATE TXT_OBJ_NULL FILE(SYSLIN)<==  GP */\n  /*                END                                       GP */\n                    ELSE\n0                   DO TXT_LIST_PTR = TXT_HEAD_PTR\n                              REPEAT TXT_NEXT_PTR\n                              WHILE(TXT_LIST_PTR \u00ac= NULL);\n                         IF TXT_ESDID = CESD_ESDID THEN\n                         DO;\n                              UNSPEC(TXT_ADDR) = (8)'0'B ||\n                                        TXT_ADDR_1ST_BYTE;\n                              TXT_END = TXT_ADDR + TXT_BYTE_CNT;\n                              DO RLD_LIST_PTR = RLD_HEAD_PTR\n                                        REPEAT RLD_NEXT_PTR\n                                        WHILE(RLD_LIST_PTR \u00ac= NULL);\n                                 IF RLD_LIST_POS_ID = TXT_ESDID &\n                                           RLD_LIST_REL_ID \u00ac= 0B THEN\n                                 DO;\n                                   DO HOLD_PTR = CESD_HEAD_PTR\n                                        REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                                        WHILE(HOLD_PTR \u00ac= NULL)\n                                        UNTIL(HOLD_PTR -> CESD_ESDID =\n                                                  RLD_LIST_REL_ID);\n                                   END;\n                                   IF HOLD_PTR = NULL THEN\n                                        SIGNAL ERROR;\n                                   UNSPEC(SD_ADDR) = (8)'0'B ||\n                                             HOLD_PTR -> CESD_ADDR;\n-                                  DO I = 1 TO RLD_LIST_ITEM_CNT;\n                                        UNSPEC(LD_ADDR) = (8)'0'B ||\n                                             RLD_LIST_ADCON_ADDR(I);\n                                        IF LD_ADDR >= TXT_ADDR &\n                                                  LD_ADDR < TXT_END &\n                             SUBSTR(RLD_LIST_FLAGS(I),1,3) = '000'B THEN\n                                        DO;\n                                             UNSPEC(L) = (14)'0'B ||\n                                             SUBSTR(RLD_LIST_FLAGS(I),\n                                                       5,2);\n                                             L = L + 1;\n                                             TEMP_CHAR = LOW(4-L) ||\n                                                  SUBSTR(TXT_BYTES,\n                                                  LD_ADDR-TXT_ADDR+1,L);\n                                             UNSPEC(ADCON) =\n                                                      UNSPEC(TEMP_CHAR);\n                                             IF\n                                           SUBSTR(RLD_LIST_FLAGS(I),7,1)\n                                                     THEN\n                                                ADCON = ADCON + SD_ADDR;\n                                             ELSE\n                                                ADCON = ADCON - SD_ADDR;\n                                             UNSPEC(TEMP_CHAR) =\n                                                       UNSPEC(ADCON);\n                                             SUBSTR(TXT_BYTES,\n                                                LD_ADDR-TXT_ADDR+1,L) =\n                                                SUBSTR(TEMP_CHAR,5-L,L);\n                                        END;\n                                   END;\n                                 END;\n                              END;\n                              DO I = 1 BY 56 TO TXT_BYTE_CNT;\n                                   SEQ# = SEQ# + 1;\n                                   TXT_ADDR_BITS =\n                                        SUBSTR(UNSPEC(TXT_ADDR),9,24);\n                                   LOCATE TXT_OBJ FILE(SYSLIN);\n                                   TXT_CNT = MIN(56,TXT_BYTE_CNT-I+1);\n                                   TXT = SUBSTR(TXT_BYTES,I,TXT_CNT);\n                                   TXT_ADDR = TXT_ADDR + TXT_CNT;\n                                   IF TXT_ADDR > CESD_LENGTH THEN\n                                   DO;\n                                        K = TXT_ADDR - CESD_LENGTH;\n                                        TXT_CNT = TXT_CNT - K;\n                                        SUBSTR(TXT,TXT_CNT+1,K) = '';\n                                        TXT_ADDR = CESD_LENGTH;\n                                   END;\n                              END;\n                              LAST_TXT_ADDR = TXT_ADDR;\n                         END;\n                    END;\n-                   /* PAD WITH BLANKS TO EXPANDED SIZE */\n                    TXT_SIZE = TXT_SIZE - CESD_LENGTH;\n                    DO I = 1 BY 56 TO TXT_SIZE;\n                         SEQ# = SEQ# + 1;\n                         TXT_ADDR_BITS =\n                              SUBSTR(UNSPEC(LAST_TXT_ADDR),9,24);\n                         LOCATE TXT_OBJ FILE(SYSLIN);\n                         TXT_CNT = MIN(56,TXT_SIZE-I+1);\n                         LAST_TXT_ADDR = LAST_TXT_ADDR + TXT_CNT;\n                    END;\n1                   K = 57;\n                    DO RLD_LIST_PTR = RLD_HEAD_PTR\n                              REPEAT RLD_NEXT_PTR\n                              WHILE(RLD_LIST_PTR \u00ac= NULL);\n                         IF RLD_LIST_POS_ID = CESD_ESDID THEN\n                         DO;\n                              SELECT(RLD_LIST_REL_ID);\n                              WHEN(0B)\n                                   REPL_ESDID = 0B;\n                              WHEN(CESD_ESDID)\n                                   REPL_ESDID = 1B;\n                              OTHERWISE\n                              DO;\n                                   DO HOLD_PTR = CESD_HEAD_PTR\n                                        REPEAT HOLD_PTR -> CESD_NEXT_PTR\n                                        WHILE(HOLD_PTR \u00ac= NULL)\n                                        UNTIL(HOLD_PTR -> CESD_ESDID =\n                                             RLD_LIST_REL_ID);\n                                   END;\n                                   IF HOLD_PTR = NULL THEN\n                                        SIGNAL ERROR;\n                                   IF HOLD_PTR -> CESD_NEW_ESDID = 0B\n                                             THEN\n                                        SIGNAL ERROR;\n                                   REPL_ESDID =\n                                        HOLD_PTR -> CESD_NEW_ESDID;\n                              END;\n                              END;\n                              NBYTES = RLD_LIST_ITEM_CNT*4 + 4;\n                              J = 1;\n                              DO I = 1 BY 13 TO RLD_LIST_ITEM_CNT - 12;\n                                   SEQ# = SEQ# + 1;\n                                   LOCATE RLD_OBJ FILE(SYSLIN);\n                                   K,RLD_BYTE_CNT = 56;\n                                   RLD_R_P_PTR = ADDR(RLD_BYTE(1));\n                                   RLD_OBJ_POS_ID = 1B;\n                                   RLD_OBJ_REL_ID = REPL_ESDID;\n                                   DO J = I TO I + 12;\n                                        RLD_F_A_PTR =\n                                             ADDR(RLD_BYTE((J-I)*4+5));\n                                        RLD_OBJ_FLAGS =\n                                             RLD_LIST_FLAGS(J);\n                                        IF SUBSTR(RLD_OBJ_FLAGS,1,4) =\n                                                  '0010'B THEN\n                                             SUBSTR(RLD_OBJ_FLAGS,1,4) =\n                                                  (4)'0'B;\n                                        RLD_OBJ_ADDR =\n                                             RLD_LIST_ADCON_ADDR(J);\n                                   END;\n                                   SUBSTR(RLD_OBJ_FLAGS,8,1) = '0'B;\n                                   NBYTES = NBYTES - 52;\n                              END;\n                              IF NBYTES <= 4 THEN\n                                   LEAVE;\n                              IF (K + NBYTES) > 56 THEN\n                              DO;\n                                   SEQ# = SEQ# + 1;\n                                   LOCATE RLD_OBJ FILE(SYSLIN);\n                                   K = 0;\n                              END;\n                              RLD_R_P_PTR = ADDR(RLD_BYTE(K+1));\n                              RLD_OBJ_POS_ID = 1B;\n                              RLD_OBJ_REL_ID = REPL_ESDID;\n                              L = K - J*4 + 5;\n                              DO I = J TO RLD_LIST_ITEM_CNT;\n                                   RLD_F_A_PTR =\n                                             ADDR(RLD_BYTE(I*4+L));\n                                   RLD_OBJ_FLAGS = RLD_LIST_FLAGS(I);\n                                   IF SUBSTR(RLD_OBJ_FLAGS,1,4) =\n                                             '0010'B THEN\n                                        SUBSTR(RLD_OBJ_FLAGS,1,4) =\n                                             (4)'0'B;\n                                   RLD_OBJ_ADDR =\n                                             RLD_LIST_ADCON_ADDR(I);\n                              END;\n                              SUBSTR(RLD_OBJ_FLAGS,8,1) = '0'B;\n                              RLD_BYTE_CNT,K = K + NBYTES;\n                         END;\n                    END; /* DO RLD_LIST_PTR = */\n                    SEQ# = SEQ# + 1;\n                    LOCATE END_OBJ_TYPE_2 FILE(SYSLIN);\n                    IF EP_ESDID = CESD_ESDID THEN\n                    DO;\n                         END_EP_ESDID = 1B;\n                         END_EP_OFFSET =\n                              SUBSTR(UNSPEC(EP_OFFSET),9,24);\n                    END;\n                    DO IDR_LIST_PTR = IDR_HEAD_PTR\n                              REPEAT IDR_NEXT_PTR\n                              WHILE(IDR_LIST_PTR \u00ac= NULL)\n                              UNTIL(IDR_LIST_ESDID = CESD_ESDID);\n                    END;\n                    IF IDR_LIST_PTR \u00ac= NULL THEN\n                    DO;\n                         PUT STRING(END_IDR_CNT) EDIT\n                         (IDR_LIST_TRANS_CNT)\n                         (P'9');\n                         DO I = 1 TO IDR_LIST_TRANS_CNT;\n                              END_IDR_DATA(I) = IDR_DATA(I), BY NAME;\n                              UNSPEC(END_IDR_VVMM(I)) =\n                                             '1111'B || IDR_VVMM(I,1) ||\n                                             '1111'B || IDR_VVMM(I,2) ||\n                                             '1111'B || IDR_VVMM(I,3) ||\n                                             '1111'B || IDR_VVMM(I,4);\n                         END;\n                    END;\n                    DO IDR_USER_PTR = IDR_USER_HEAD_PTR\n                              REPEAT IDR_USER_NEXT_PTR\n                              WHILE(IDR_USER_PTR \u00ac= NULL)\n                              UNTIL(IDR_USER_LIST_ESDID = CESD_ESDID);\n                    END;\n                    IF IDR_USER_PTR \u00ac= NULL THEN\n                    DO;\n                         L = INDEX(CESD_NAME,' ');\n                         IF L = 0 THEN\n                              L = 8;\n                         ELSE\n                              L = L + -1B;\n                         LOCATE CARD FILE(SYSLIN);\n                         CARD = ' IDENTIFY ' || SUBSTR(CESD_NAME,1,L) ||\n                              '(''' || IDR_USER_LIST_DATA || ''')';\n                    END;\n                    IF PDS2PAGA &\n                              SUBSTR(CESD_ADDR,13,12) = (12)'0'B THEN\n                    DO;\n                         LOCATE CARD FILE(SYSLIN);\n                         CARD = ' PAGE ' || CESD_NAME;\n                    END;\n               END; /* IF CESD_DELINK_FLAG */\n          END; /* DO CESD_LIST_PTR = */\n /*GP*/   IF LIST_TYPE_NO = 1B   /* FOR SELECT(ALL) ADD LOAD MODULE */\n /*  */   THEN DO;               /* ATTRS BEFORE \"AFTER\" LINKCNTL   */\n /*  */        LOCATE CARD FILE(SYSLIN);\n /*  */        CARD = ' SETOPT PARM(REUS(' || REUS_ATR || '),'\n /*  */                                    || LOAD_ATR || ')';\n /*  */        LOCATE CARD FILE(SYSLIN);\n /*  */        SELECT(AMODE);\n /*  */             WHEN('01'B)\n /*  */             DO;\n /*  */                  CARD = ' MODE AMODE(64),RMODE(24)';\n /*  */                  IF PDSLRMOD THEN\n /*  */                       SUBSTR(CARD,23,4) = 'ANY)';\n /*  */             END;\n /*  */             WHEN('10'B)\n /*  */             DO;\n /*  */                  CARD = ' MODE AMODE(31),RMODE(24)';\n /*  */                  IF PDSLRMOD THEN\n /*  */                       SUBSTR(CARD,23,4) = 'ANY)';\n /*  */             END;\n /*  */             WHEN('11'B)\n /*  */                  CARD = ' MODE AMODE(ANY)';\n /*  */             OTHERWISE\n /*  */                  CARD = ' MODE AMODE(24)';\n /*  */        END; /* SELECT(AMODE) */\n /*  */        IF PDSAPFLG THEN\n /*  */        DO;\n /*  */             IF PDSAPFCT = '00000001'B  &  PDSAPFAC = '01'X\n /*  */             THEN DO;\n /*  */                  LOCATE CARD FILE(SYSLIN);\n /*  */                  CARD = ' SETCODE AC(1) ';\n /*  */             END;\n /*  */        END;\n /*  */        IF PDS2SSI\n /*  */        THEN DO;\n /*  */             LOCATE CARD FILE(SYSLIN);\n /*  */             CARD = ' SETSSI ' || SSI_DATA;\n /*  */        END;\n /*GP*/   END;   /* LIST_TYPE_NO = 1 */\n          IF MORE_LINKCNTL & SUBSTR(LINKCNTL_REC,1,6) = 'AFTER ' THEN\n          DO;\n               READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n               DO WHILE(MORE_LINKCNTL &\n                         SUBSTR(LINKCNTL_REC,1,8) \u00ac= 'MEMBER: ');\n                    WRITE FILE(SYSLIN) FROM(LINKCNTL_REC);\n                    AFTER_CNT = AFTER_CNT + 1;\n                    READ FILE(LINKCNTL) SET(LINKCNTL_PTR);\n               END;\n          END;\n          IF \u00ac NONAME_FLAG THEN /* ADD LINKCNTL AND NAME */\n          DO;\n               LOCATE CARD FILE(SYSLIN);\n               CARD = ' NAME ' || NEW_NAME || '(R)';\n          END;\n          IF CSECT_COUNT > 0B & \u00ac ALL(CSECT_MATCHED(*)) THEN\n          DO;\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               ('CSECT NAMES NOT MATCHED : ')\n               (A);\n               DO I = 1 TO CSECT_COUNT;\n                    IF \u00ac CSECT_MATCHED(I) THEN\n                         PUT FILE(SYSPRINT) EDIT\n                         (CSECT_NAME(I))\n                         (A(11));\n               END;\n               RETURN_CODE = MAX(RETURN_CODE,4);\n          END;\n          PAGE_TYPE = 0;\n          IF MASK_COUNT > 0 THEN\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               (('MASK','MATCHES' DO I = 1 TO 6))\n               (X(2),A,X(4),A,X(3))\n               ((MASK_NAME(I),MASK_MATCH_COUNT(I)\n                         DO I = 1 TO MASK_COUNT))\n               (SKIP,6(A,X(2),F(6),X(4)));\n          IF BEFORE_CNT \u00ac= 0 | AFTER_CNT \u00ac= 0 THEN\n               PUT FILE(SYSPRINT) SKIP(2) EDIT\n               (BEFORE_CNT,\n                    ' LINK DIRECTIVES INSERTED BEFORE OBJECT CODE AND ',\n                    AFTER_CNT,\n                    ' LINK DIRECTIVES INSERTED AFTER OBJECT CODE.')\n               (F(5),A);\n     END;\n0    WHEN(8,12) /* MEMBER NOT FOUND */\n     DO;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          ('** ERROR ** MEMBER ',MEMBER,' NOT FOUND.')\n          (A);\n          RETURN_CODE = MAX(RETURN_CODE,8);\n     END;\n0    WHEN(16) /* UNABLE TO OPEN PDS */\n     DO;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          ('** ERROR ** UNABLE TO OPEN SYSLIB.')\n          (A);\n          RETURN_CODE = MAX(RETURN_CODE,20);\n     END;\n0    WHEN(28) /* I/O ERROR */\n     DO;\n          PUT FILE(SYSPRINT) SKIP(2) EDIT\n          ('** ERROR ** I/O ERROR READING SYSLIB DIRECTORY.')\n          (A);\n          RETURN_CODE = MAX(RETURN_CODE,24);\n     END;\n0    OTHERWISE\n          CALL PLIDUMP('TFSHB',\n                    'RETURN CODE '||PLIRETV||' FROM DWNSPDSR');\n     END; /* SELECT(PLIRETV) */\n1    /* NOW WE'LL CLEAN UP THE MEMORY WE'VE BEEN USING */\n0    DO WHILE(ALLOCN(CSECT_ARRAY) > 0);\n          FREE CSECT_ARRAY;\n     END;\n0    DO WHILE(ALLOCN(MASK_ARRAY) > 0);\n          FREE MASK_ARRAY;\n     END;\n0    DO WHILE(CESD_HEAD_PTR \u00ac= NULL);\n          CESD_LIST_PTR = CESD_HEAD_PTR;\n          CESD_HEAD_PTR = CESD_NEXT_PTR;\n          FREE CESD_LIST_ITEM;\n     END;\n0    DO WHILE(RLD_HEAD_PTR \u00ac= NULL);\n          RLD_LIST_PTR = RLD_HEAD_PTR;\n          RLD_HEAD_PTR = RLD_NEXT_PTR;\n          FREE RLD_LIST_ITEM;\n     END;\n0    DO WHILE(TXT_HEAD_PTR \u00ac= NULL);\n          TXT_LIST_PTR = TXT_HEAD_PTR;\n          TXT_HEAD_PTR = TXT_NEXT_PTR;\n          FREE TXT_LIST_ITEM;\n     END;\n0    DO WHILE(IDR_HEAD_PTR \u00ac= NULL);\n          IDR_LIST_PTR = IDR_HEAD_PTR;\n          IDR_HEAD_PTR = IDR_NEXT_PTR;\n          FREE IDR_LIST_ITEM;\n     END;\n0    DO WHILE(IDR_USER_HEAD_PTR \u00ac= NULL);\n          IDR_USER_PTR = IDR_USER_HEAD_PTR;\n          IDR_USER_HEAD_PTR = IDR_USER_NEXT_PTR;\n          FREE IDR_USER_ITEM;\n     END;\n-    IF MORE_CARDS & RETURN_CODE < 20 THEN\n          GO TO OBTAIN_A_CMD;\n-END_OF_JOB :\n     MEMBER_NAME = HIGH(8);\n     CALL DWNSPDSR(SYSLIB,PDS_RET_CODE,RECLEN,LMOD_RECORD);\n     RELEASE DWNSPDSR;\n     CALL PLIRETC(RETURN_CODE);\n     CLOSE FILE(SYSIN),\n          FILE(SYSLIN),\n          FILE(LINKCNTL),\n          FILE(SYSPRINT);\n     RETURN;\n1EXTRACT_SIZE :\n     PROC(SRC,BAD_SRC) RETURNS(BIN FIXED(31,0)) RED;\n          DCL  SRC                 CHAR(*),\n               BAD_SRC             BIT(1) ALIGNED;\n0         DCL  (I,J,L)             BIN FIXED(15,0),\n               RESULT              BIN FIXED(31,0) INIT(0B),\n               (INDEX,LENGTH,VERIFY) BUILTIN;\n          ON FOFL\n               GO TO OVERFLOW_EXIT;\n          BAD_SRC = '0'B;\n          L = LENGTH(SRC);\n0         SELECT;\n          WHEN(VERIFY(SRC,'0123456789') = 0)\n          DO;\n               GET STRING(SRC) LIST(RESULT);\n               IF RESULT > 16777216 THEN\n                    BAD_SRC = '1'B;\n          END;\n0         WHEN(SUBSTR(SRC,L,1) = 'K' &\n                    VERIFY(SUBSTR(SRC,1,L-1),'0123456789') = 0)\n          DO;\n               GET STRING(SUBSTR(SRC,1,L-1)) LIST(RESULT);\n               IF RESULT > 16384 THEN\n                    BAD_SRC = '1'B;\n               ELSE\n                    RESULT = RESULT*1024;\n          END;\n0         WHEN(SUBSTR(SRC,L,1) = 'M' &\n                    VERIFY(SUBSTR(SRC,1,L-1),'0123456789') = 0)\n          DO;\n               GET STRING(SUBSTR(SRC,1,L-1)) LIST(RESULT);\n               IF RESULT > 16 THEN\n                    BAD_SRC = '1'B;\n               ELSE\n                    RESULT = RESULT*1024*1024;\n          END;\n0         WHEN(SUBSTR(SRC,1,2) = 'X''' &\n                    SUBSTR(SRC,L,1) = '''' & L <= 9 &\n                    VERIFY(SUBSTR(SRC,3,L-3),'0123456789ABCDEF') = 0)\n          DO I = 3 TO L - 1;\n               J = INDEX('0123456789ABCDEF',SUBSTR(SRC,I,1)) - 1;\n               RESULT = RESULT*16 + J;\n          END;\n0         OTHERWISE\n               BAD_SRC = '1'B;\n          END;\n          RETURN(RESULT);\n0    OVERFLOW_EXIT :\n          BAD_SRC = '1'B;\n          RETURN(0B);\n     END EXTRACT_SIZE;\n1MASK_MATCH :\n     PROC(CSECT_NAME,MASK_NAME) RED RETURNS(BIT(1) ALIGNED);\n          DCL  (CSECT_NAME,MASK_NAME) CHAR(8),\n0              P                   BIN FIXED(15,0),\n               RESULT              BIT(1) ALIGNED INIT('1'B),\n               (SUBSTR,VERIFY)     BUILTIN;\n0         DO P = 1 TO 8 WHILE(RESULT);\n               SELECT(SUBSTR(MASK_NAME,P,1));\n               WHEN('?',SUBSTR(CSECT_NAME,P,1))\n                    /* THIS CHARACTER'S OK */;\n               WHEN('!')\n               DO;\n                    IF VERIFY(SUBSTR(CSECT_NAME,P,1),\n                              'ABCDEFGHIJKLMNOPQRSTUVWXYZ') \u00ac= 0 THEN\n                         RESULT = '0'B;\n               END;\n               WHEN('|')\n               DO;\n                    IF VERIFY(SUBSTR(CSECT_NAME,P,1),\n                              '0123456789') \u00ac= 0 THEN\n                         RESULT = '0'B;\n               END;\n               OTHERWISE /* NO MATCH */\n                    RESULT = '0'B;\n               END;\n          END;\n          RETURN(RESULT);\n     END MASK_MATCH;\n-END DELINK;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWNMPRLG": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\t\\x0f\\x16\\x01\\x004\\x003\\x00\\x01\\xe4\\xc2\\xd8\\xf0\\xf0\\xf1@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-31T16:01:00", "lines": 52, "newlines": 51, "modlines": 1, "user": "UBQ001"}, "text": "         MACRO\n&ENTRY   DWNMPRLG &DSASIZE=88,&STATIC=\n         LCLA  &LEN,&LENFILL\n&LEN     SETA  K'&ENTRY\n         AIF   (&LEN LE 7).LENOK\n         MNOTE 12,'PL/I ENTRY POINT MUST BE NO MORE THAN 7 CHARS.'\n         MEXIT\n.LENOK   ANOP\n         DC    0H'0'\n         AIF   (&LEN EQ 7).NOFILL\n&LENFILL SETA  7-&LEN\n         DC    CL&LENFILL' '\n.NOFILL  ANOP\n         DC    C'&ENTRY'\n         DC    AL1(&LEN)\n         ENTRY &ENTRY\n&ENTRY   STM   14,12,12(13)\n         BALR  11,0\n         USING *,11\n         LR    4,1\n         AIF   (T'&STATIC EQ 'O').NOSTAT\n         ICM   3,B'1111',*+76\n         USING &STATIC,3\n.NOSTAT  ANOP\n         ICM   0,B'1111',*+64\n         L     1,76(0,13)\n         ALR   0,1\n         CL    0,12(0,12)\n         BNH   *+10\n         L     15,116(0,12)\n         BALR  14,15\n         ST    0,76(0,1)\n         ST    1,8(0,13)\n         ST    13,4(0,1)\n         MVC   72(4,1),72(13)\n         LR    13,1\n         LR    1,4\n         MVI   0(13),X'80'\n         MVI   1(13),X'00'\n         MVC   84(4,13),*+14\n         AIF   (T'&STATIC NE 'O').B16\n         B     *+12\n         AGO   .DOCONS\n.B16     ANOP\n         B     *+16\n.DOCONS  ANOP\n         DC    AL4(&DSASIZE)\n         DC    2X'91C0'\n         AIF   (T'&STATIC EQ 'O').NOASTAT\n         DC    AL4(&STATIC)\n.NOASTAT ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DWNSCAN": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00O\\x00O\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "DELINK"}, "text": "         TITLE 'PL/I SUBROUTINE TO SCAN FOR DELIMITERS'\n* THIS SUBROUTINE IS TO BE CALLED FROM THE PL/I OPTIMIZER/CHECKOUT\n* ENVIRONMENT ONLY! IT SHOULD BE DECLARED AS\n*     SCAN ENTRY(CHAR(*),CHAR(*)) RETURNS(BIN FIXED(15,0))\n* IT IS CALLED AS A FUNCTION. THE FIRST ARGUMENT IS A STRING OF\n* CHARACTERS TO BE SCANNED; THE SECOND ARGUMENT IS A STRING OF\n* DELIMITERS FOR WHICH THE FIRST STRING IS SCANNED. THE VALUE RETURNED\n* IS THE POSITION IN THE FIRST STRING OF THE FIRST MATCHING DELIMITER\n* IN THAT STRING. IF NO MATCH IS FOUND THE VALUE ZERO IS RETURNED.\n* THE CODE IS REENTRANT, REUSABLE AND REFRESHABLE.\n* AUTHOR - DAVID NOON, SEPTEMBER 1987\n*      ++INCLUDE DWNMPRLG\nSCAN1    START\nSCAN1    AMODE ANY\nSCAN1    RMODE ANY\nSCAN     DWNMPRLG DSASIZE=DSASIZE\nDWNSCAN  EQU   SCAN\n         ENTRY DWNSCAN\n         USING DSA,13\n         LM    4,6,0(1)            LOAD ADDRESSES OF LOCATORS & RESULT\n         XC    TRTTAB(256),TRTTAB  SET TRT TABLE TO LOW VALUES\n         L     7,0(0,5)            LOAD ADDRESS OF DELIM STRING\n         BCTR  7,0                 SUBTRACT 1 FOR INDEXING\n         LH    9,4(0,5)            LOAD LENGTH OF DELIM STRING\n         LA    8,1                 LOAD INCREMENT FOR LOOP\n         SLR   10,10               ZERO MAKES FIRST INDEX 1\n         SLR   1,1                 CLEAR REGISTER 1\n* NOW LOOP THROUGH THE DELIMITER STRING PUTTING STOPPER FLAGS IN TRTTAB\nLOOP#1   BXH   10,8,ENDDELIM       INCREMENT INDEX REG.\n         IC    1,0(10,7)           PICK UP DELIMITER CHAR\n         LA    2,TRTTAB(1)         CALC ADDRESS IN TABLE\n         MVI   0(2),X'FF'          MAKE IT A STOPPER\n         B     LOOP#1              GO BACK FOR MORE\n* WE HAVE NOW BUILT OUR TRT TABLE. PICK UP THE ATTRIBUTES OF THE STRING\nENDDELIM L     7,0(0,4)            LOAD ADDRESS OF MAIN STRING\n         LH    9,4(0,4)            LOAD LENGTH OF MAIN STRING\n         TM    6(4),X'80'          IS IT A VARYING STRING ?\n         BZ    *+12                NO - USE ADDRESS AND LENGTH AS IS\n         LH    9,0(0,7)            LOAD VARYING LENGTH\n         LA    7,2(0,7)            SKIP LENGTH BYTES\n* OUR CHEAP HARDWARE CAN ONLY SCAN 256 BYTES IN A SINGLE INSTRUCTION.\n* AS A RESULT WE WILL LOOP THROUGH SCANNING 256 BYTE CHUNKS.\n         LA    8,256               256 BYTE INCREMENTS\n         SLR   10,10               R10 CONTAINS LENGTH SCANNED SO FAR\n         STH   10,0(0,6)           PUT IN PROVISIONAL RESULT - NO MATCH\nLOOP#2   BXH   10,8,SCANLAST       INCREMENT INDEX REG\n         TRT   0(256,7),TRTTAB     SCAN THIS CHUNK\n         BNZ   FOUNDIT             DID WE GET A HIT ?\n         ALR   7,8                 ADVANCE 256 BYTES\n         B     LOOP#2              GO BACK AND SCAN SOME MORE\n* WHEN WE GET HERE WE HAVE FEWER THAN 256 BYTES LEFT TO SCAN.\nSCANLAST SLR   10,8                DECREMENT BACK 256 BYTES\n         LNR   5,10                ) SUBTRACT LENGTH SCANNED SO FAR\n         AR    5,9                 ) FROM TOTAL LENGTH\n         BZ    RETURN              NONE LEFT - RETURN WITH ZERO\n         BCTR  5,0                 SUBTRACT ONE FOR HIS KNOB\n         EX    5,LASTSCAN          SCAN THE LAST FEW BYTES\n         BZ    RETURN              NO FIND - BAD LUCK\nFOUNDIT  SL    1,0(0,4)            CALCULATE OFFSET\n         LA    1,1(0,1)            ADD ONE FOR HIS KNOB\n         TM    6(4),X'80'          IS IT VARYING LENGTH ?\n         BZ    *+8                 NO - DON'T ALLOW FOR LENGTH FIELD\n         BCTR  1,0                 SUBTRACT 1\n         BCTR  1,0                 SUBTRACT 1 (MAKING 2 LENGTH BYTES)\n         STH   1,0(0,6)            MAKE IT A RESULT\nRETURN   L     13,4(0,13)          RESTORE CALLING PGM DSA\n         LM    14,12,12(13)        RESTORE CALLING PGM REGS.\n         BR    14                  RETURN TO CALLER\n         SPACE 2\nLASTSCAN TRT   0(0,7),TRTTAB            REMOTELY EXECUTED INSTRUCTION\n         EJECT\n* WORKING STORAGE\nDSA      DSECT\n         DS    22F                 PL/I DSA\nTRTTAB   DS    CL256               TRT TABLE\n         ORG\n         DS    0D\nDSASIZE  EQU   *-DSA\n         END   SCAN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DWNSHEX": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00r\\x00r\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "DELINK"}, "text": "DWNSHEX  TITLE 'PL/I SUBROUTINE TO CONVERT BIT STRINGS TO HEX CHARS.'\n***********************************************************************\n*                                                                     *\n*      THIS SUBROUTINE MUST BE CALLED FROM THE PL/I ENVIRONMENT       *\n*                                                                     *\n***********************************************************************\n* THIS SUBROUTINE TAKES A BIT STRING AS ITS PARAMETER AND RETURNS A\n* VARYING LENGTH CHARACTER STRING AS A RESULT. THE INPUT STRING AND THE\n* RESULT MAY EACH BE OF ANY LENGTH ALLOWED BY PL/I, BUT THE RESULT WILL\n* ALWAYS BE ONE QUARTER THE LENGTH OF THE PARAMETER AND WILL OCCUPY\n* TWICE AS MANY BYTES OF STORAGE.\n*\n* THIS SUBROUTINE SHOULD BE DECLARED AS FOLLOWS :-\n*     DCL    DWNSHEX    ENTRY(BIT(*) ALIGNED) RETURNS(CHAR(???) VAR);\n* WHERE ??? SHOULD BE REPLACED BY ANY NUMBER SUITABLY LARGE FOR THE\n* PARTICULAR APPLICATION PROGRAM.\n* TO CALL THIS SUBROUTINE (ACTUALLY A FUNCTION) ONE SHOULD CODE\n* SOMETHING LIKE :-\n*      HEX_CHARS = DWNSHEX(BIT_STRING);\n*                 OR\n*      HEX_CHARS = DWNSHEX(UNSPEC(ANY_VARIABLE));\n*\n* AUTHOR :- DAVID W NOON\n*           APRIL 1990\n* STARTOPT:\n* COMPOPT: RENT,XREF(SHORT)\n* PREPOPT: NOPREP\n* LINKOPT: NCAL,MAP,LIST,RENT,REFR\n* ENDOPT:\n         EJECT\nDWNSHEX1 START\nDWNSHEX1 AMODE ANY\nDWNSHEX1 RMODE ANY\nDWNSHEX  DWNMPRLG DSASIZE=DSASIZE\n         USING DSA,13                   MAKE OUR DSA ADDRESSABLE\n         LM    4,5,0(1)                 LOAD PARM POINTERS\n         L     6,0(0,4)                 LOAD BIT ADDRESS FROM LOCATOR\n         L     7,0(0,5)                 LOAD CHAR ADDRESS FROM LOCATOR\n         XC    0(2,7),0(7)              SET RESULT LENGTH TO ZERO\n         LH    8,4(0,4)                 LOAD LENGTH OF BITS\n         LR    9,8                      COPY LENGTH OF BITS\n         N     9,THREE                  TAKE MODULO 4\n         BNZ   SIGERROR                 NOT A MULTIPLE OF 4\n         LR    9,8                      COPY LENGTH AGAIN\n         SRA   9,2                      DIVIDE BY 4\n         BZ    RETURN                   ZERO MEANS A NULL STRING\n         CH    9,4(0,5)                 MAX. LENGTH OF RESULT\n         BH    SIGERROR                 TOO LONG ?\n         STH   9,0(0,7)                 PUT LENGTH IN PLACE\n         LA    7,2(0,7)                 SKIP OVER LENGTH BYTES\n         LA    14,1024                  CONVERT IN 128 BYTE CHUNKS\n         CR    8,14                     HAVE WE 1024 OR FEWER BITS ?\n         BNH   LASTBITS                 YES - NO NEED TO LOOP\n         LR    15,14                    EXIT LOOP WHEN <= 1024 BIT LEFT\n         LNR   14,14                    MAKE INCREMENT A DECREMENT\nLOOP     MVC   FIRSTDIG(128),0(6)       MOVE FOR 1ST DIGIT CONVERSION\n         MVC   SECNDDIG(128),0(6)       MOVE FOR 2ND DIGIT CONVERSION\n         TR    FIRSTDIG(128),TRTAB1     CONVERT 128 1ST DIGITS\n         TR    SECNDDIG(128),TRTAB2     CONVERT 128 2ND DIGITS\n         MVC   0(256,7),TRTAB3          COPY TR TABLE TO RESULT\n         TR    0(256,7),FIRSTDIG        CONVERT TO HEX\n         LA    7,256(0,7)               INCREMENT OUTPUT ADDRESS\n         LA    6,128(0,6)               INCREMENT INPUT ADDRESS\n         BXH   8,14,LOOP                GO BACK FOR MORE\nLASTBITS LA    9,7(0,8)                 COULD BE A SPARE HALF BYTE\n         SRA   9,3                      CONVERT TO BYTES\n         BCTR  9,0                      LESS ONE FOR M/C LENGTH\n         LR    10,9                     COPY LENGTH\n         ALR   10,10                    DOUBLE IT\n         EX    9,MOVE1ST                COPY FOR 1ST DIGIT CONVERSION\n         EX    9,MOVE2ND                COPY FOR 2ND DIGIT CONVERSION\n         EX    9,TRAN1ST                CONVERT 1ST DIGITS\n         EX    9,TRAN2ND                CONVERT 2ND DIGITS\n         N     8,SEVEN                  CHECK IF WE HAVE AN EXTRA HALF\n         BNZ   *+8                      NO - DON'T MOVE IT THEN\n         LA    10,1(0,10)               WE'VE AN EXTRA BYTE NOW\n         EX    10,MOVEIT                COPY TO RESULT\n         EX    10,TRANSLAT              CONVERT X'FA' - X'FF'\nRETURN   L     13,4(0,13)               RESTORE CALLER'S DSA\n         LM    14,12,12(13)             RESTORE CALLER'S REGISTERS\n         BR    14                       RETURN TO CALLER\n         SPACE 2\n* REMOTELY EXECUTED INSTRUCTIONS\nMOVE1ST  MVC   FIRSTDIG(0),0(6)         <<< EXECUTED >>>\nMOVE2ND  MVC   SECNDDIG(0),0(6)         <<< EXECUTED >>>\nTRAN1ST  TR    FIRSTDIG(0),TRTAB1       <<< EXECUTED >>>\nTRAN2ND  TR    SECNDDIG(0),TRTAB2       <<< EXECUTED >>>\nMOVEIT   MVC   0(0,7),TRTAB3            <<< EXECUTED >>>\nTRANSLAT TR    0(0,7),FIRSTDIG          <<< EXECUTED >>>\n         EJECT\n* CODE TO PERFORM SIGNAL ERROR.\nSIGERROR PLISIG ERRFLAGS                SIGNAL ERROR\n         B     RETURN                   WHO KNOWS ?\n         SPACE 2\n* FLAG BYTES FOR SIGNAL ERROR\nERRFLAGS PLIICB ERROR\n         EJECT\n* CONSTANTS\nTHREE    DC    F'3'\nSEVEN    DC    F'7'\nTRTAB1   DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6',16C'7'\n         DC    16C'8',16C'9',16C'A',16C'B',16C'C',16C'D',16C'E',16C'F'\nTRTAB2   DC    16C'0123456789ABCDEF'\nTRTAB3   DC    128AL1((*-TRTAB3)/2,(*-TRTAB3+1)/2+127)\n         SPACE 2\n* WORKING STORAGE\nDSA      DSECT\n         DS    22F                      PL/I DSA\nFIRSTDIG DS    CL128                    ) THESE MUST ...\nSECNDDIG DS    CL128                    ) ... REMAIN CONTIGUOUS\n         ORG\n         DS    0D\nDSASIZE  EQU   *-DSA\n         END   DWNSHEX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DWNSPDSR": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00\\xf7\\x00\\xf7\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "DELINK"}, "text": "DWNSPDSR TITLE 'DWNSPDSR - READ PDS PHYSICAL RECORD SUBROUTINE V1M0'\n*.....................................................................*\n*                                                                     *\n* PROGRAM: DWNSPDSR                                                   *\n*                                                                     *\n* PURPOSE: READ AND RETURN THE NEXT SEQUENTIAL RECORD OF A BLOCKED    *\n*          PDS MEMBER.                                                *\n*                                                                     *\n* INVOKED BY: DWNLPDSG - TRANSPARENT LOADER SUBROUTINE                *\n*                                                                     *\n* DWNLPDSG CALLING SEQUENCE (ASM):                                    *\n*                                                                     *\n*   CALL  DWNLPDSG,(DDNMBR,RETCODE,RECLEN,RECORD),VL=1                *\n*                                                                     *\n*   WHERE:                                                            *\n*   -------------------+----------------------+--------------------   *\n*   DDNMBR  DS  0F     ]  RETCODE    DS  F    ]  RECLEN   DS  F       *\n*   DDN     DC  CL8' ' ]                      ]                       *\n*   MBR     DC  CL8' ' ]                      ]                       *\n*   FILL2   DS  F      ]                      ]                       *\n*   FILL3   DS  F      ]                      ]                       *\n*   -------------------+----------------------+--------------------   *\n*   RECORD  DS  CL??   ]                      ]                       *\n*                      ]                      ]                       *\n*                      ]                      ]                       *\n*                      ]                      ]                       *\n*   -------------------+----------------------+--------------------   *\n*   AND OPTIONALLY:                                                   *\n*   -------------------+----------------------+--------------------   *\n*   SSIAREA DS  CL8    ] DIRENT      DS  CL80 ]                       *\n*                      ]                      ]                       *\n*                      ]                      ]                       *\n*                      ]                      ]                       *\n*   -------------------+----------------------+--------------------   *\n*                                                                     *\n*   DDN=DDNAME FOR DD CARD POINTING TO PDS TO READ                    *\n*   MBR=NAME OF MEMBER IN PDS POINTED TO BY <DDN> TO BE READ          *\n*       NOTE: SET TO 8X'FF' (COBOL \"HIGH-VALUE\") TO END OPERATIONS    *\n*             WHICH WILL CLOSE THE PDS FOR ACCESS.                    *\n*   RECORD=NEXT PHYSICAL RECORD FROM PDS MEMBER                       *\n*   DIRENT=DIRECTORY ENTRY IN BLDL FORMAT                             *\n*   SSIAREA=SSI INFORMATION CONVERTED TO EBCDIC FROM HEX              *\n*                                                                     *\n*   ON RETURN:                                                        *\n*                                                                     *\n*     R15, AND RETCODE=0 - NO PROBLEMS                                *\n*     R15, AND RETCODE=4 - END OF DIRECTORY                           *\n*     R15, AND RETCODE=8 - SERIOUS ERROR                              *\n*                                                                     *\n* KEN TRUE - 25 JUNE 82 - FROM O051A801 FROM MIKE FARMER              *\n*                                                                     *\n*                                                                     *\n*.....................................................................*\n*\n* STARTOPT:\n* COMPOPT: RENT,XREF(SHORT)\n* PREPOPT: NOPREP\n* LINKOPT: NCAL,MAP,LIST,RENT,REFR,OL\n* SYSLMOD: DNOON.TEST.LOAD\n* ENDOPT:\n         EJECT\nDWNSPDSR FMSTART BASE=R11,T=STDSUB,GM=WKLENG,LNK=(0,16),PRINT=YES\n         EJECT\n         LR    R10,R1             SAVE THE PARM POINTER\n         USING PASSWORK,R9\n         L     R9,0(,R10)         ADDRESS THE WORK BLOCK\n*\n         CLC   WKDDNAM,PWKDDNAM   DDNAMES MATCH?\n         BE    *+8                YES - CARRY ON\n         BAL   R14,NEWDDNAM       NO - POSSIBLE INITIALIZATION HERE\n         CLC   PWKMBR,WKMBR       IS THE MEMBER STILL THE SAME\n         BE    *+8                YES - CARRY ON WITH IT\n         BAL   R14,NEWMEMBR       POINT FOR THIS NEW MEMBER\n*\n         XC    WKRDECB(4),WKRDECB       CLEAR EVENT CONTROL BLOCK\n         READ  WKRDECB,SF,MF=E\n         CHECK WKRDECB\n*                   AND WE NOW HAVE A SHINY NEW BLOCK\n         L     R6,WKRDECB+12      ADDRESS OF BLOCK START\n         L     R2,WKRDECB+16      PICK UP IOB POINTER\n         LH    R2,14(,R2)         PLUCK OUT THE RESIDUAL COUNT\n         LH    R7,DCBBLKSI-IHADCB+WKDCB  PICK UP THE BLOCKSIZE\n         SR    R7,R2              AND THIS IS THE AMOUNT READ\n*\n         L     R2,8(,R10)         HIS RECORD LENGTH AREA\n         ST    R7,0(,R2)                PUT IN LENGTH OF BLOCK\n         L     R2,12(,R10)              ADDRESS OF CALLER'S BUFFER\n         LR    R3,R7                    PUT LENGTH INTO REG. 3\n         MVCL  R2,R6              MOVE OVER THE PHYSICAL RECORD\n         SR    R15,R15            THE PROPER RETURN CODE\n         B     SETRC\n*\nENDOFILE EQU   *                  END OF THIS MEMBER REACHED\n         LA    R15,4\n         B     SETRC\n         EJECT\n*                   HE HAS CHANGED THE DDNAME - ASSUME A COMPLETE\n*                   RESTART.\n*\nNEWDDNAM FMBLOCK  NDD\n         TM    WKDCB+48,X'10'     IS ONE NOW OPEN\n         BZ    NDDCLOZD\n         L     R2,WKRDECB+12      POINT TO OLD BUFFER ADDRESS\n         FREEBUF WKDCB,(2)\n         LA    R2,WKDCB\n         ST    R2,WKOPEN\n         MVI   WKOPEN,X'80'\n         CLOSE  MF=(E,WKOPEN)\n         FREEPOOL WKDCB\nNDDCLOZD EQU   *\n*\n         LA    R2,WKDCB\n         ST    R2,WKOPEN\n         MVI   WKOPEN,X'80'       OPEN FOR INPUT\n         MVC   WKDCB(LBPAMDCB),BPAMDCB SET IN THE DCB\n         MVC   DCBDDNAM-IHADCB+WKDCB,PWKDDNAM   INSERT THE DDNAME\n         MVC   WKDDNAM,PWKDDNAM   UPDATE INTERNAL RECORDS, TOO\n         OPEN  MF=(E,WKOPEN)\n         GETBUF WKDCB,(2)\n         XC    WKRDECB(LREAD),WKRDECB   CLEAR DECB\n         MVI   WKRDECB,X'80'            INDICATE BPAM READ DECB\n         ST    R2,WKRDECB+12      SAVE AREA ADDRESS IN THE DECB\n         LH    R1,DCBBLKSI-IHADCB+WKDCB\n         STH   R1,WKRDECB+6             PUT BLKSIZE IN DECB\n         LA    R1,WKDCB           SET DCB POINTER INTO THE DECB\n         ST    R1,WKRDECB+8       INTO THE DECB PROPERLY\n         LA    R1,ENDOFILE        THE END OF MEMBER ADDRESS\n         ST    R1,DCBEODAD-IHADCB+WKDCB INTO THE DCB\n         XC    WKMBR,WKMBR        CLEAR THE MEMBER NAME TO TRIGGER NEXT\n         B     NDDEXIT\n         EJECT\n*                    THE MEMBER NAME HAS CHANGED -\n*                    SET UP FOR THE NEW ENTRY WITH A REFIND\n*\nNEWMEMBR FMBLOCK  NMBR\n         CLC   PWKMBR,GOAWAY      IS THIS THE FINAL CALL\n         BE    NMBRGOAW           YES - GO\n         MVC   WKDEMEMB(8),PWKMBR       MOVE MEMBER NAME FOR BLDL\n         MVC   WKDEHEAD(4),BLDLHEAD     MOVE IN BLDL HEADER\n         BLDL  WKDCB,WKDEHEAD           DIRECTORY LOOKUP\n         LTR   R15,R15            IT BETTER BE THERE\n         BNZ   NMBRMISS\n* RETURN SSI DATA IF REQUESTED\n         TM    12(R10),X'80'            WAS SSI REQUIRED ?\n         BO    DOFIND                   NO - SKIP RETURN OF SSI\n         L     R1,16(,R10)              POINTER TO CALLER'S SSI FIELD\n         MVC   0(8,R1),DEFLTSSI         MOVE IN DEFAULT SSI\n* THE LENGTH OF THE DIRECTORY ENTRY USER DATA SHOULD BE 4 OR >= 26.\n* IF THE LENGTH OF THE USER DATA IS 4 THEN IT IS ALL SSI.\n* IF THE LENGTH OF THE USER DATA IS 26 OR MORE THEN THE SSI IS AT\n* OFFSET 22 (X'16'), PROVIDED THAT THE SSI FLAG IS SET.\n         ICM   R15,B'1000',WKDECNT      LOAD USER DATA COUNT\n         SLL   R15,3                    REMOVE ALIAS FLG & TTR NOTE CNT\n         SRL   R15,26                   MULTIPLY IT BY 2 AND MOVE BITS\n         C     R15,FOUR                 IS USER DATA LENGTH 4 ?\n         BNE   *+12                     NO - CHECK FOR 26 OR MORE\n         LA    R1,WKDEUSER              ADDRESS OF SSI BYTES\n         B     UNPKSSI                  GO CONVERT IT TO HEX\n         C     R15,F26                  IS LENGTH >= 26 ?\n         BL    RETRNDIR                 NO - THEN NO SSI IS PRESENT\n         TM    WKDEUSER+18,X'10'        IS THERE ANY SSI ?\n         BZ    RETRNDIR                 NO - DEFAULT WILL DO\n         LA    R1,WKDEUSER+22           ADDRESS OF LINKAGE EDITOR SSI\nUNPKSSI  UNPK  WKSSIHLD(9),0(5,R1)      UNPACK SSI INTO HOLDING AREA\n         TR    WKSSIHLD(8),SSITRTAB-C'0' TRANSLATE X'FA' TO X'C1' ETC.\n         L     R1,16(,R10)              ADDRESS OF USER'S SSI AREA\n         MVC   0(8,R1),WKSSIHLD         MOVE BACK SSI\n* RETURN DIRECTORY INFORMATION IF REQUESTED\nRETRNDIR TM    16(R10),X'80'            WAS DIRECTORY ENTRY REQUIRED ?\n         BO    DOFIND                   NO - SKIP RETURN OF DIRECTORY\n         LA    R15,13(,R15)             ADD ON FIXED LENGTH LESS 1\n         L     R1,20(,R10)              POINTER TO USER DATA\n         EX    R15,MOVEUSER             MOVE IT BACK\nDOFIND   FIND  WKDCB,WKDETTR,C\n         LTR   R15,R15            IT BETTER BE THERE\n         BNZ   NMBRMISS\n         MVC   WKMBR,PWKMBR      THIS IS NOW THE ACTIVE MEMBER\n         SR    R15,R15\n         B     NMBREXIT\n* REMOTELY EXECUTED INSTRUCTION\nMOVEUSER MVC   0(0,R1),WKDIRENT         MOVE DIRECTORY ENTRY\n*\nNMBRMISS EQU   *\n         LA    R15,8              CODE FOR SOMETHING SERIOUS\n         B     SETRC              AND GET OUT OF HERE\n*\nNMBRGOAW EQU   *                  EOF CALL - CLEAR OUT\n         TM    WKDCB+48,X'10'     IS ONE NOW OPEN\n         BZ    NMBRNOPN\n         L     R2,WKRDECB+12      POINT TO OLD BUFFER ADDRESS\n         FREEBUF WKDCB,(2)\n         LA    R2,WKDCB\n         ST    R2,WKOPEN\n         MVI   WKOPEN,X'80'\n         CLOSE  MF=(E,WKOPEN)\n         FREEPOOL WKDCB\nNMBRNOPN EQU   *\n         MVI   0(R13),X'FF'       TELL ENTER TO EXIT\n         LA    R15,4              CODE FOR EOF WITH EMPHASIS\n         B     SETRC              AND TO THE FINAL SOLUTION\n         SPACE 2                                                    NTL\nSETRC    L     R1,4(,R10)         GET ADDRESS OF RETURN CODE        NTL\n         STCM  R15,B'1111',0(R1)  SAVE AWAY RETURN CODE             NTL\n         B     RETURN             AND SPLIT BACK TO CALLER          NTL\n         EJECT\n*                    CONSTANTS OF USE IN THE PROCESS\nFOUR     DC    F'4'\nF26      DC    F'26'\nGOAWAY   DC    8X'FF'\nBLDLHEAD DC    YL2(1,L'WKDIRENT)        BLDL HEADER\nDEFLTSSI DC    C'00000000'              DEFAULT SSI\nSSITRTAB DC    C'0123456789ABCDEF'\n*\n         LTORG\n*\nBPAMDCB  DCB   DDNAME=NEEDED,DSORG=PO,MACRF=R,BUFNO=1,NCP=1\nLBPAMDCB EQU   *-BPAMDCB\n*\n         EJECT\nPASSWORK DSECT\nPWKDDNAM DS    CL8                DDNAME OF THE PDS TO READ\nPWKMBR   DS    CL8                MEMBER NAME OF INTEREST\nPWKGETMN DS    F                  ADDRESS OF THE GOTTEN MAIN\nPWKFILL  DS    F                  ADDITIONAL FILLER IN ANCHOR AREA\nPWKLENG  EQU   *-PASSWORK\n         EJECT\n         FMWORK1\nWKMBR    DS    CL8                NAME OF THE MEMBER BEING READ\nWKDDNAM  DS    CL8                DDNAME OF THE FILE WORKED OVER\nWKOPEN   DS    F                  FOR LIST FORM OF THE OPEN\n         READ  WKRDECB,SF,BPAMDCB,0,MF=L\nLREAD    EQU   *-WKRDECB\nWKDCB    DS    0F,CL(LBPAMDCB)\nWKDEHEAD DS    2H                       BLDL HEADER H'1,62'\nWKDIRENT DS    0CL80                    DIRECTORY ENTRY\nWKDEMEMB DS    CL8                      BLDL MEMBER NAME\nWKDETTR  DS    CL3                      TTR OF MEMBER\nWKDECNCT DS    B                        CONCATENATION NO.\nWKDESRC  DS    B                        SOURCE OF MEMBER\nWKDECNT  DS    B                        COUNT OF USER DATA (HALF-WORDS)\nWKDEUSER DS    CL66                     USER DATA & SSI\nWKSSIHLD DS    CL9                      SSI HOLDING AREA\n         FMWORK2\n         EJECT\n         PRINT NOGEN\n         DCBD    DSORG=PO,DEVD=DA\n         END   DWNSPDSR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWNYBLDL": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00O\\x00O\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "DELINK"}, "text": "-         (PDS_BLDL_PTR,PDS_BLDL_SCTR_PTR,PDS_BLDL_ALIAS_PTR,\n                        PDS_BLDL_SSI_PTR,PDS_BLDL_APF_PTR) PTR,\n0         1    PDS2_BLDL_FMT       BASED(PDS_BLDL_PTR),\n               2    PDS2NAME            CHAR(8),\n               2    PDS2TTRP            BIT(24) ALIGNED,\n               2    PDS2CNCT            BIT(8) ALIGNED,\n               2    PDS2LIBF            CHAR(1),\n               2    PDS2INDC,\n                    3    PDS2ALIS            BIT(1),\n                    3    PDS2NTTR            BIT(2),\n                    3    PDS2LUSR            BIT(5),\n0              /* FROM HERE ON IT IS LINKAGE EDITOR USER DATA */\n               2    PDS2USRD,\n                    3    PDS2TTRT            BIT(24) ALIGNED,\n                    3    PDS2ZERO            CHAR(1),\n                    3    PDS2TTRN            BIT(24) ALIGNED,\n                    3    PDS2NL              BIT(8) ALIGNED,\n                    3    PDS2ATR1,\n                         4    PDS2RENT            BIT(1),\n                         4    PDS2REUS            BIT(1),\n                         4    PDS2OVLY            BIT(1),\n                         4    PDS2TEST            BIT(1),\n                         4    PDS2LOAD            BIT(1),\n                         4    PDS2SCTR            BIT(1),\n                         4    PDS2EXEC            BIT(1),\n                         4    PDS21BLK            BIT(1),\n                    3    PDS2ATR2,\n                         4    PDS2FLVL            BIT(1),\n                         4    PDS2ORG0            BIT(1),\n                         4    PDS2EP0             BIT(1),\n                         4    PDS2NRLD            BIT(1),\n                         4    PDS2NREP            BIT(1),\n                         4    PDS2TSTN            BIT(1),\n                         4    PDS2LEF             BIT(1),\n                         4    PDS2REFR            BIT(1),\n                    3    PDS2STOR            BIT(24) ALIGNED,\n                    3    PDS2FTBL            BIN FIXED(15,0) UNAL,\n                    3    PDS2EPA             BIT(24) ALIGNED,\n                    3    PDS2FTB1,\n                         4    PDSAOSLE            BIT(1),\n                         4    FILLER#1            BIT(1),\n                         4    PDS2PAGA            BIT(1),\n                         4    PDS2SSI             BIT(1),\n                         4    PDSAPFLG            BIT(1),\n                         4    FILLER#2            BIT(3),\n                    3    PDS2FTB2,\n                         4    FILLER#3            BIT(3),\n                         4    PDSLRMOD            BIT(1),\n                         4    PDSAAMOD            BIT(2),\n                         4    PDSMAMOD            BIT(2),\n                    3    PDS2FTB3            BIT(8) ALIGNED,\n0         /* EXTENSION FOR SCATTER FORMAT LOAD MODULES */\n          1    PDSS01              BASED(PDS_BLDL_SCTR_PTR),\n               2    PDS2SLSZ            BIN FIXED(15,0) UNAL,\n               2    PDS2TTSZ            BIN FIXED(15,0) UNAL,\n               2    PDS2ESDT            BIT(16) ALIGNED,\n               2    PDS2ESDC            BIT(16) ALIGNED,\n0         /* EXTENSION FOR ALIAS ENTRIES */\n          1    PDSS02              BASED(PDS_BLDL_ALIAS_PTR),\n               2    PDS2EPM             BIT(24) ALIGNED,\n               2    PDS2MNM             CHAR(8),\n0         /* EXTENSION FOR SSI DATA */\n          1    PDSS03              BASED(PDS_BLDL_SSI_PTR),\n               2    PDSCHLVL            BIT(8) ALIGNED,\n               2    PDSSSIFB,\n                    3    FILLER#4            BIT(1),\n                    3    PDSFORCE            BIT(1),\n                    3    PDSUSRCH            BIT(1),\n                    3    PDSEMFIX            BIT(1),\n                    3    PDSDEPCH            BIT(1),\n                    3    PDSSYSGN,\n                         4    PDSCMSGN            BIT(1),\n                         4    PDSPTSGN            BIT(1),\n                    3    PDSIBMMB            BIT(1),\n               2    PDSMBRSN            BIT(16) ALIGNED,\n0         /* EXTENSION FOR APF AUTHORIZATION */\n          1    PDSS04              BASED(PDS_BLDL_APF_PTR),\n               2    PDSAPFCT            BIT(8) ALIGNED,\n               2    PDSAPFAC            CHAR((1) REFER (PDSAPFCT)),\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMBLOCK": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x005\\x005\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n&TAG     FMBLOCK &P,&RENT=YES\n         GBLC  &FMGPREF(50)       SAVE ROOM FOR PREFIXES\n         GBLA  &FMGSUB            POINTER TO NEXT PREFIX\n         LCLC  &PF                THE PREFIX DECIDED UPON FOR THIS ONE\n         LCLA  &WPF               USED IN GENERATING THE RENT=REGS\n.*\n         AIF   ('&RENT' NE 'REGS').GBLK      GENERATE NORMAL BLOCK\n         AIF   (&FMGSUB NE 0).GREGS          GEN REGS IF ANY NEEDED\n         MNOTE *,'       NO ENTRIES'\n         AGO   .EXIT2\n.GREGS   ANOP                     GENERATE THE REG SAVE-WORDS\n&WPF     SETA  &WPF+1             POINT ON TO NEXT ENTRY\n&PF      SETC  '&FMGPREF(&WPF)'   NAME OF THE NEXT PREFIX\n&PF.R14  DS    F\n         AIF   (&WPF LT &FMGSUB).GREGS AND DO THEM ALL\n&FMGSUB  SETA  0                  RE-CLEAR THE VALUE\n         AGO   .EXIT2             END OF RENT=REGS GENERATION\n.*\n.*\n.GBLK    ANOP\n         AIF   (T'&P EQ 'O').DEFLP DEFAULT THE PREFIX\n         AIF   (K'&P LE 4).PLNOK  LENGTH OF PROVIDED IS OK\n         MNOTE 8,'ONLY 4 CHARACTERS MAX FOR PREFIX'\n         AGO   .EXIT\n.PLNOK   ANOP\n&PF      SETC  '&P'               USE PROVIDED PREFIX\n         AGO   .PFSET\n.DEFLP   ANOP                     BUILD DEFAULT PREFIX ID\n         AIF   (K'&TAG LE 4).SMALTAG\n&PF      SETC  '&TAG'(1,4)        USE FIRST FOUR CHARS OF TAG\n         AGO   .PFSET\n.SMALTAG ANOP                     USE FULL TAG AS PREFIX\n&PF      SETC  '&TAG'\n.PFSET   ANOP                     THE PREFIX IS DECIDED UPON.....\n         AIF   ('&RENT' EQ 'YES').HAVRENT\n         AIF   (&FMGSUB NE 0).HAVRENT\n&PF.R14  DC    F'0'               HOLD RETURN ADDR\n         AGO   .GENCODE\n.HAVRENT ANOP\n&FMGSUB  SETA  &FMGSUB+1\n&FMGPREF(&FMGSUB)  SETC  '&PF'    SAVE PREFIX IN TABLE FOR LATER\n.*\n.GENCODE ANOP\n&PF.EXIT L     R14,&PF.R14        RETURN ADDR\n         MVI   &PF.R14,X'FF'      SHOW EXIT\n         BR    R14                EXIT\n&TAG     ST    R14,&PF.R14        SAVE RETURN\n.*\n.EXIT    ANOP\n         SPACE 1\n.EXIT2   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMCREDT": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00\\x04\\x00\\x04\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n         FMCREDT\n         DC    C' &SYSDATE &SYSTIME INTEL-CIS '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMSTART": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x01C\\x01C\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 323, "newlines": 323, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n&TAG     FMSTART  &BASE=R12,&RETURN=RETURN,&RC=,&T=,&PRINT=NO,&PREF=,  X\n               &GM=GMLENG,&ZAP=30,&SP=39,&SA=SAVEAREA,&LNK=,           X\n               &MBR=NEEDED\n         GBLC  &FMGSA,&FMGGM      COMMUNICATE TO THE WORK ENTRIES\n         LCLA  &SX                ABBREVIATION OF SYSNDX\n         LCLA  &X,&Y              FOR STDSUB CHAINING TO FIND GM AREA\n         LCLB  &NORENT,&SUBSYS,&SVRSYS,&RENT,&STDSUB  TYPES OF GEN\n         LCLB  &STDSWK            MORE GEN TYPES\n&SX      SETA  &SYSNDX            TRUNCATE THE ZEROES OFF TAGS\n&Y       SETA  3                  AN OBVIOUS WRONG ANSWER\n         AIF   (T'&PREF EQ 'O').NOPREF NO PREFIX GIVEN - USE DEFAULT\n.NOPREF  ANOP                     END OF PREFIX ROUTINE\n.*\n         AIF   (T'&T NE 'O').A100\n&NORENT  SETB  1\n         AGO   .A999\n.A100    AIF   ('&T' NE 'SUBSYS').A200\n         AIF   (T'&LNK NE 'O' AND T'&GM NE 'O').A110\n         MNOTE  8,'NEED LNK AND GM'\n         AGO   .EXIT\n.A110    ANOP\n&SUBSYS  SETB  1\n         AGO   .A999\n.A200    AIF   ('&T' NE 'SVRSYS').A300\n         AIF   (T'&LNK NE 'O' AND T'&GM NE 'O'AND T'&MBR NE 'O').A210\n         MNOTE  8,'NEED LNK ,GM AND MBR'\n         AGO   .EXIT\n.A210    ANOP\n&SVRSYS  SETB  1\n         AGO   .A999\n.A300    AIF   ('&T' NE 'RENT').A400\n         AIF   (T'&GM NE 'O').A310\n         MNOTE  8,'GM FOR RENT'\n         AGO   .EXIT\n.A310    ANOP\n&RENT    SETB  1\n         AGO   .A999\n.A400    AIF   ('&T' NE 'STDSUB').A500\n         AIF   (T'&LNK(1) NE 'O').A410\n         MNOTE 8,'NEED  NUMERICS FOR LNK WITH STDSUB'\n         AGO   .EXIT\n.A410    ANOP\n&X       SETA  &LNK(1)\n         AIF   (T'&LNK(2) EQ 'O').A420\n&Y       SETA  &LNK(2)\n.A420    ANOP\n         AIF   (T'&GM NE 'O').A430\n         MNOTE  8,'NEED GM FOR STD SUBROUTINES'\n         AGO   .EXIT\n.A430    ANOP\n&STDSUB  SETB  1\n         AGO   .A999\n.A500    AIF   ('&T' NE 'STDSWK').A600\n         AIF   (T'&LNK(1) NE 'O' AND T'&LNK(2) NE 'O').A510\n         MNOTE 8,'NEED 2 NUMERICS FOR LNK WITH STDSWK'\n         AGO   .EXIT\n.A510    ANOP\n&X       SETA  &LNK(1)\n&Y       SETA  &LNK(2)\n         AIF   (T'&GM NE 'O').A520\n         MNOTE  8,'NEED GM FOR STD SUBROUTINES'\n         AGO   .EXIT\n.A520    ANOP\n&STDSWK  SETB  1\n         AGO   .A999\n.*             HAVE DEFINED A PROBLEM HERE\n.A600    ANOP\n         MNOTE 8,'T MUST BE ONE OF THE STANDARD SET'\n         AGO   .EXIT\n.A999    ANOP\n.*\n.*\n&TAG     CSECT\n         B     STR&SX-&TAG.(,R15)\n         USING &TAG,&BASE(1)\n         DC    AL1(ZAP&SX-*-1),CL8'&TAG'   LENGTH AND ID\n         FMCREDT\nZAP&SX   DC    &ZAP.S(*)          ZAP AREA\n         PUSH  PRINT\n         AIF   ('&PRINT' NE 'NO').NP1X\n         PRINT NOGEN\n.NP1X    ANOP\n.*\n.*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.*\n.*                   THE CONSTANTS AS NEEDED BY VARIOUS POSSIBILITIES\n         AIF   (&NORENT).INTSA\n.*                   THINGS FOR ALL EXCEPT THE NON-REENTRANT ONES\n&FMGSA   SETC  '&SA'              PASS DSECT NAME OF WORKAREA/SAVEAREA\n&FMGGM   SETC  '&GM'              LENGTH OF GOTTEN MAIN AREA, IF ANY\n         AGO   .NORX\n.INTSA   ANOP\n&SA      DC    9D'0'             SAVEAREA\n.NORX    ANOP\n.*\n.*\n         AIF   (NOT &RENT AND NOT &STDSUB AND NOT &STDSWK).NOGMS\nGMS&SX   DC    0F'0',AL1(&SP),AL3(&GM)  GETMAIN SUBPOOL/SIZE\n.NOGMS   ANOP\n.*\n         AIF   (NOT &SVRSYS).NOMBR\nNLM&SX   DC    CL8'&MBR'          NAME OF THE WORKAREA\n.NOMBR   ANOP\n.*\n         AIF   (N'&BASE EQ 1).BAS1X\nBAS2&SX  DC    A(&TAG+4096)       FOR SECOND BASE\n         AIF   (N'&BASE EQ 2).BAS1X\nBAS3&SX  DC    A(&TAG+8192)       AND THE THIRD\n         AIF   (N'&BASE LE 3).BAS1X\n         MNOTE  8,'THREE BASES SHOULD BE ENOUGH.....'\n         AGO   .EXIT\n.BAS1X   ANOP\n.*\n         AIF   (T'&RETURN EQ 'O').ENDRT ANY RETURN LOGIC WANTED\n&RETURN  DS    0H\n         AIF   (T'&RC EQ 'O').RCSET\n         LA    R15,&RC            INSERT PRESET RETURN CODE\n.RCSET   ANOP\n.*                   IF THE NORMAL NON-REENTRANT IS IN VOGUE\n         AIF   (NOT &NORENT).B100\n         L     R13,4(,R13)        POINT BACK ONE SAVEAREA\n         AGO   .B999\n.*                   SUBSYSTEM EXIT\n.B100    AIF   (NOT &SUBSYS).B200\n         ST    R13,&LNK.(,R11)     FREE THIS SAVEAREA\n         L     R13,4(,R13)        BACK UP ONE SAVEAREA\n         AGO   .B999\n.*                   SUBSYSTEM SUPERVISOR EXIT\n.B200    AIF   (NOT &SVRSYS).B300\n         L     R13,4(,R13)        BACK OUT OF SAVE/WORK\n         LR    R3,R0\n         LR    R2,R15\n         LA    R0,NLM&SX          NAME OF THE WORKAREA\n         SVC   9                  DELETE THE LITTLE FELLA\n         LR    R0,R3\n         LR    R15,R2\n         L     R1,24(,R13)        PICK UP ORIGINAL R1\n         L     R2,&X.(,R1)        PICK UP PREDEFINED POINTER\n         XC    &Y.(4,R2),&Y.(R2)  CLEAR THE GM POINTER\n         AGO   .B999\n.*                   STD REENTRANT - FREE THE SAVE/WORK\n.B300    AIF   (NOT &RENT).B400\n         LR    R3,R0              SAVE THE RETURN CODES\n         LR    R2,R15             .\n         L     R0,GMS&SX          LENGTH/SUBPOOL VALUE\n         LR    R1,R13             START OF THE GOTTEN STUFF\n         L     R13,4(,R13)        BACK OUT OF SAVE/WORK\n         SVC   10                 FREE THE GOTTEN CORE\n         LR    R0,R3              RESET THE RETURN CODES\n         LR    R15,R2             .\n         AGO   .B999\n.*                  STANDARD SUBROUTINE - CONDITIONAL FREEING\n.B400    AIF   (NOT &STDSUB).B500\n         CLI   0(R13),X'FF'       CODE FOR ALL OVER\n         BE    *+12               YES - TO SPECIAL FREEING\n         L     R13,4(,R13)        NORMAL RETURN SO FAR\n         B     SSBX&SX            TO STD RETURN\n         L     R0,GMS&SX          FREE THE GOTTEN MAIN\n         LA    R1,0(,R13)         CLEAN POINTER TO THE MAIN\n         L     R13,4(,R13)        BACK OUT OF SAVE/WORK\n         LR    R3,R0              SAVE THE RETURN CODES\n         LR    R2,R15             .\n         SVC   10                 FREE THE GOTTEN CORE\n         L     R15,24(,R13)       THE ORIGINAL R1\n         L     R15,&X.(,R15)      FOLLOW THE POINTER CHAIN\n.*       AIF   (&Y EQ 3).B410\n.*       L     R15,&Y.(,R15)      TO ITS SAVEAREA POINTER\n.B410    ANOP\n         XC    &Y.(4,R15),&Y.(R15)  CLEAR SAVE/AREA POINTER\n         LR    R0,R3\n         LR    R15,R2\nSSBX&SX  EQU   *\n         AGO   .B999\n.*                   FOR THE SPECIAL SUBROUTINE TYPE - WITH SA\n.B500    AIF   (NOT &STDSWK).B600\n         L     R13,4(,R13)        POINT BACK ONE SAVEAREA\n         AGO   .B999\n.*                   WELL - SEEMS TO BE AN INTERNAL ERROR HERE\n.B600    ANOP\n         MNOTE  12,'NO INDICATOR SET FOR TYPE OF GEN'\n         AGO   .EXIT\n.*\n.B999    ANOP\n         L     R14,12(,R13)\n         LM    R1,R12,24(R13)\n         MVI   12(R13),X'FF'      EXIT INDICATOR\n         BR    R14\n.ENDRT   ANOP\n.*\n.*                                THE START OF THE ENTRY LOGIC\nSTR&SX   STM   R14,R12,12(R13)\n         LR    &BASE(1),R15\n         AIF   (N'&BASE EQ 1).BAS2X\n         L     &BASE(2),BAS2&SX\n         USING &TAG+4096,&BASE(2)\n         AIF   (N'&BASE EQ 2).BAS2X\n         L     &BASE(3),BAS3&SX\n         USING &TAG+8192,&BASE(3)\n.BAS2X   ANOP\n.*\n         AIF   (NOT &NORENT).C100\n         LA    R15,&SA            POINTER TO DEFINED SAVEAREA\n         XC    12(60,R15),12(R15)   CLEAR THE SAVEAREA\n         ST    R13,4(,R15)\n         ST    R15,8(,R13)\n         LR    R13,R15\n         AGO   .C999\n.*                   IF THIS IS FOR A SUBSYSTEM POINTER SETUP\n.C100    AIF   (NOT &SUBSYS AND NOT &SVRSYS).C200\n         LR    R2,R13             SAVE CURRENT SA FOR R15/R2 RELOAD\n         AIF   (&SUBSYS).C110     NORMAL TYPE - JUST RECHAIN SA\n.*                   SUBSYSTEM SVR - LOAD THE WORKAREA\n         LA    R0,NLM&SX          POINT TO THE MEMBER NAME\n         SR    R1,R1              NO DCB ALLOWED\n         SVC   8                  LOAD THE MODULE\n         LR    R11,R0             ADDRESS THAT WORKAREA\n.C110    ANOP                     STACK DOWN THE SAVEAREAS\n         L     R15,&LNK.(,R11)    POINTER TO START OF OPEN AREA\n         ST    R13,4(,R15)        CROSS-CHAIN THE SAVE-AREAS\n         ST    R15,8(,R13)        .\n         LR    R13,R15            HAVE THE NEW SAVE-AREA\n         LA    R15,&GM+31         REQUESTED WORKAREA SIZE\n         SRL   R15,5              ALIGN ON CORE-DUMP BOUNDARY\n         SLL   R15,5              .\n         LA    R15,0(R15,R13)     POINT TO END OF WORKAREA\n         C     R15,&LNK+4(,R11)   STILL INSIDE WORKAREA\n         BNH   CLR&SX+6           SO FAR, SO GOOD\n         EX    R0,*               OOPS\nCLR&SX   XC    12(0,R13),12(R13)\n         ST    R15,&LNK.(,R11)     SHOW NEW END OF SAVEAREA\n         LA    R15,&GM-13\n         LA    R14,255            OTHER ALTERNATIVE CLEARING SIZE\n         CR    R15,R14\n         BL    *+6                SELECT THE LESSER OF TWO IEWAALSS\n         LR    R15,R14\n         EX    R15,CLR&SX\n         USING &SA,R13            ADDRESS THE WORKAREA\n         MVC   72(8,R13),5(R12)   MOVE PGM NAME TO WORKAREA\n         LM    R15,R2,16(R2)      REESTABLIST THE CRITICAL POINTERS\n         AGO   .C999\n.*                   HOW ABOUT THE STRAIGHT REENTRANT VERSION\n.C200    AIF   (NOT &RENT).C300\n         L     R0,GMS&SX          SUBPOOL AND LENGTH\n         BAL   R1,*+4\n         SVC   10\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R15,R13            SAVE THE OLD SA POINTER\n         LR    R13,R1             NEW SA POINTER SET\n         USING &SA,R13            ADDRESS THE WORKAREA\n         MVC   72(8,R13),5(R12)   MOVE PGM NAME TO WORKAREA\n         LM    R15,R1,16(R15)     RESET THE CRITICAL POINTERS\n         AGO   .C999              AND ON TO FINAL GENERATION\n.*                   CODE FOR STANDARD SUBROUTINE ENTRY\n.C300    AIF   (NOT &STDSUB).C400\n         AIF   (&Y EQ 3).C310     SPECIAL ONE-POINTER CASE\n         L     R15,&X.(,R1)       HOW FAR OFF R1 IS THE POINTER\n         L     R15,&Y.(,R15)      HOW FAR INTO AREA IS SAVEAREA POINTER\n         LTR   R15,R15            IS THERE ANYTHING THERE\n         BNZ   SSBS&SX            YES - USE IT\n         L     R2,&X.(,R1)        REPOINT TO THE ENTRY\n         L     R0,GMS&SX          SUBPOOL AND LENGTH\n         BAL   R1,*+4             INDICATE GETMAIN\n         SVC   10                 AND ISSUE THE SVC\n         ST    R1,&Y.(,R2)        RECORD THIS POINTER FOR EVER\n         AGO   .C320\n.C310    ANOP                     FOR THE SINGLE-POINTER CASE\n         L     R15,&X.(,R1)       HOW FAR OFF R1 IS THE POINTER\n         LTR   R15,R15            IS THERE ANYTHING THERE\n         BNZ   SSBS&SX            YES - USE IT\n         LA    R2,&X.(,R1)        REPOINT TO THE ENTRY\n         L     R0,GMS&SX          SUBPOOL AND LENGTH\n         BAL   R1,*+4             INDICATE GETMAIN\n         SVC   10                 AND ISSUE THE SVC\n         ST    R1,0(,R2)          RECORD THIS POINTER FOR EVER\n.C320    ANOP                     REJOIN NORMAL PATH...\n         LR    R15,R1             REPOINT PROPERLY\n         MVC   72(8,R15),5(R12)   MOVE PGM NAME TO WORKAREA\n         LM    R0,R2,20(R13)      REESTABLISH THOSE DESTROYED REGISTERS\nSSBS&SX  EQU   *\n         ST    R13,4(,R15)\n         ST    R15,8(,R13)\n         LR    R13,R15            NEW SA POINTER SET\n         MVI   0(R13),X'00'       CLEAR POSSIBLE EXIT POINTER\n         USING &SA,R13            ADDRESS THE WORKAREA\n         AGO   .C999\n.*                   CODE FOR STANDARD SUBROUTINE WITH SAVEAREA PASSED\n.C400    AIF   (NOT &STDSWK).C500\n         L     R15,&X.(,R1)       HOW FAR OFF R1 IS THE POINTER\n         LA    R15,&Y.(,R15)      HOW FAR INTO AREA IS SAVEAREA POINTER\n         ST    R13,4(,R15)\n         ST    R15,8(,R13)\n         LR    R13,R15            NEW SA POINTER SET\n         USING &SA,R13            ADDRESS THE WORKAREA\n         MVC   72(8,R13),5(R12)   MOVE PGM NAME TO WORKAREA\n         AGO   .C999\n.*\n.C500    ANOP                     LOOKS LIKE A PROBLEM\n         MNOTE  12,'INTERNAL ERROR IN GENERATION TYPE'\n         AGO   .EXIT\n.C999    ANOP\n.*\n.*\n.EXIT    ANOP\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMWORK1": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n         FMWORK1\n         GBLC  &FMGSA,&FMGGM\n&FMGSA   DSECT\n         DS    18F                SAVEAREA\n         DS    CL8                IDENTIFIER OF THE OWNER OF THIS\n         FMBLOCK  RENT=REGS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FMWORK2": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00\\x13\\x00\\x13\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n         FMWORK2  &ROUND\n         GBLC  &FMGSA,&FMGGM\n         LCLA  &RD,&SX\n&RD      SETA  32                 DEFAULT AMOUNT TO ROUND\n&SX      SETA  &SYSNDX            TO ABBREVIATE THE SUFFIX\n         AIF   (T'&ROUND EQ 'O').RDSET\n         AIF   ('&ROUND' EQ 'DUMP').RDSET   ALIGN TO DUMP SIZE\n         AIF   ('&ROUND' NE 'PAGE').RDNUM\n&RD      SETA  4096               SET TO PAGE SIZE\n         AGO   .RDSET\n.RDNUM   ANOP                     GAVE AN ACTUAL NUMBER\n&RD      SETA  &ROUND\n.RDSET   ANOP\nETL&SX   EQU   *-&FMGSA           LENGTH OF ALLOCATED PART\nELX&SX   EQU   &RD*(1+ETL&SX/&RD)-ETL&SX\n         DS    CL(ELX&SX)         FILLER\n&FMGGM   EQU   *-&FMGSA           LENGTH OF WORKAREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLIICB": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00P\\x00P\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n&L       PLIICB &COND,&QUAL,&TYPE=FULL\n.* PL/I OPTIMIZER INTERRUPT CONTROL BLOCK (ICB).\n         LCLA  &LN\n         LCLC  &HEX1,&HEX2\n         AIF   (T'&L EQ 'O' AND '&TYPE' EQ 'FULL').NONAME\n         AIF   (T'&COND EQ 'O').NOCOND\n&HEX2    SETC  '00'\n&HEX1    SETC  '02'\n         AIF   ('&COND' EQ 'ZDIV' OR '&COND' EQ 'ZERODIVIDE').QUALOK\n&HEX1    SETC  '03'\n         AIF   ('&COND' EQ 'FOFL' OR '&COND' EQ 'FIXEDOVERFLOW').QUALOK\n&HEX1    SETC  '04'\n         AIF   ('&COND' EQ 'SIZE').SUBTYPE\n&HEX1    SETC  '05'\n         AIF   ('&COND' EQ 'CONV' OR '&COND' EQ 'CONVERSION').SUBTYPE\n&HEX1    SETC  '06'\n         AIF   ('&COND' EQ 'OFL' OR '&COND' EQ 'OVERFLOW').QUALOK\n&HEX1    SETC  '07'\n         AIF   ('&COND' EQ 'UFL' OR '&COND' EQ 'UNDERFLOW').QUALOK\n&HEX1    SETC  '08'\n         AIF   ('&COND' EQ 'STRZ' OR '&COND' EQ 'STRINGSIZE').QUALOK\n&HEX1    SETC  '09'\n         AIF   ('&COND' EQ 'STRG' OR '&COND' EQ 'STRINGRANGE').QUALOK\n&HEX1    SETC  '0A'\n         AIF   ('&COND' EQ 'SUBG' OR                                   *\n               '&COND' EQ 'SUBSCRIPTRANGE').SUBTYPE\n&HEX1    SETC  '0B'\n         AIF   ('&COND' EQ 'AREA').SUBTYPE\n         AIF   ('&COND' EQ 'ERR' OR '&COND' EQ 'ERROR').ERROR\n&HEX1    SETC  '0D'\n         AIF   ('&COND' EQ 'FIN' OR '&COND' EQ 'FINISH').QUALOK\n&HEX1    SETC  '0E'\n         AIF   ('&COND' EQ 'COND' OR '&COND' EQ 'CONDITION').COND\n&HEX1    SETC  '10'\n         AIF   ('&COND' EQ 'KEY').SUBTYPE\n&HEX1    SETC  '11'\n         AIF   ('&COND' EQ 'RECORD' OR '&COND' EQ 'REC').SUBTYPE\n&HEX1    SETC  '12'\n         AIF   ('&COND' EQ 'UNDEFINEDFILE').SUBTYPE\n         AIF   ('&COND' EQ 'UNDF').SUBTYPE\n&HEX1    SETC  '13'\n         AIF   ('&COND' EQ 'ENDFILE' OR '&COND' EQ 'ENDF').QUALOK\n&HEX1    SETC  '14'\n         AIF   ('&COND' EQ 'TRANSMIT' OR '&COND' EQ 'TMIT').SUBTYPE\n         MNOTE 8,'&COND IS NOT A VALID PL/1 CONDITION'\n         MNOTE 0,'ERROR ASSUMED'\n         AGO    .ERROR\n.SUBTYPE AIF   (T'&QUAL EQ 'O').NOQUAL\n         AIF   (K'&QUAL NE 2).NOTHEX\n&HEX2    SETC  '&QUAL'\n.QUALOK  AIF   ('&TYPE' NE 'FULL').SNODS\n         DS    0F\n.SNODS   ANOP\n&L       DC    X'&HEX1&HEX2'\n         MEXIT\n         MNOTE 12,'&COND IS NOT A VALID CONDITION TYPE'\n         MEXIT\n.NONAME  MNOTE 12,'A NAME MUST BE BE SUPPLIED IN THE LABEL FIELD'\n         MEXIT\n.NOCOND  MNOTE 12,'THE TYPE OF CONDITION MUST BE SUPPLIED'\n         MEXIT\n.NOTHEX  MNOTE 8,'QUALIFIER FOR &COND MUST BE TWO HEX DIGITS'\n         MEXIT\n.COND    AIF   (T'&QUAL EQ 'O').NOQUAL\n&LN      SETA  K'&QUAL\n&L       DC    0F'0',X'0F00',X'0000',A(&QUAL)\n&QUAL    CSECT\n&QUAL    AMODE ANY\n&QUAL    RMODE ANY\n         DC    AL1(&LN),C'&QUAL'\n&SYSECT  CSECT\n         MEXIT\n.*\n.NOQUAL  MNOTE 12,'CONDITION QUALIFYIER IS REQUIRED FOR ''&COND'''\n         MEXIT\n.*\n.ERROR   ANOP\n&L       DC    0F'0',X'0C00',X'0000'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLISIG": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x08\\x9f\\x00\\x99\\x08\\x9f!\\x14\\x00\\x14\\x00\\x14\\x00\\x00\\xc4\\xc5\\xd3\\xc9\\xd5\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-03-30T00:00:00", "modifydate": "1999-03-30T21:14:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "DELINK"}, "text": "         MACRO\n&L       PLISIG &ICB\n.* PL/I OPTIMIZER SIGNAL STATEMENT.\n         LCLC  &LB\n&LB      SETC  '&L'\n         AIF   (T'&ICB EQ 'O').NOICB\n         AIF   ('&ICB' EQ '(1)' OR '&ICB' EQ '(R1)').ICBOK\n         AIF   ('&ICB'(1,1) EQ '(').LRICB\n&LB      LA    1,&ICB                   ADDRESS OF ICB\n&LB      SETC  ''\n         AGO   .ICBOK\n.LRICB   ANOP\n&LB      LR    1,&ICB(1)                COPY ADDRESS OF ICB\n&LB      SETC  ''\n.ICBOK   ANOP\n&LB      L     15,120(0,12)             ENTRY POINT FOR SIGNAL\n         BALR  14,15                    SIGNAL CONDITION\n         MEXIT\n.NOICB   MNOTE 12,'NAME OF ICB IS A REQUIRED OPERAND'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XMITBOOK": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99 \\x7f\\x00\\x99 \\x7f\\x033\\x00\\x8e\\x00\\x8e\\x00\\x00\\xd6\\xe2\\xf2\\xc9\\xd5\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-26T00:00:00", "modifydate": "1999-07-26T03:33:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "OS2INF"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT090/FILE090.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT090", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}