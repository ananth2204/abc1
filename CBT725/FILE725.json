{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012654000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE725.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE725.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x05'", "DS1TRBAL": "b'\\xaf\\x0c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfb\\x00\\x00\\x04\\xfb\\x00\\t\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x14o\\x01\\x06\\x14o\\x10Q\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-05-26T00:00:00", "modifydate": "2006-05-26T10:51:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  725\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE725\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,383 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/26/06    10:51:47    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x06\\x02\\x0f\\x01\\x06\\x02\\x0f\\x10\\x04\\x00\\xb4\\x00\\xb4\\x00\\x00\\xe5\\xf1K\\xf2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-01-20T00:00:00", "modifydate": "2006-01-20T10:04:35", "lines": 180, "newlines": 180, "modlines": 0, "user": "V1.2"}, "text": "NAME     - AUX2SVG\n\nTITLE    - CICS AUXILLIARY TRACE VISUALIZER\n\nVERSION  - 1.2\n\nFUNCTION - Creates a graphical representation of a CICS auxiliary\n           trace printout by using Scalable Vector Graphics (SVG).\n           The SVG markup represents the trace data in the form\n           of a Unified Modelling Language (UML) Sequence Diagram\n           (or at least something quite like it).\n\n           The 'actors' (for example, programs) are listed side-\n           by-side at the top of the diagram. A life line is\n           drawn vertically below each actor. Interactions\n           between actors (for example, calls and returns) are\n           represented as arrows drawn between the life lines.\n           The vertical axis is time. Each interaction is labeled\n           on the left of the diagram with the relative time in\n           seconds since the start of the trace and the task id.\n           All the interactions for a task are assigned the same\n           unique color. Each interaction is annotated with the\n           trace sequence number, to enable you to refer back to\n           the original trace record for more detail, and a summ-\n           ary of the call and return values. Exception responses\n           are shown in red.\n\n           You choose which actors you are interested in by\n           specifying one or more domain names. For example, if\n           you want to visualize TCP/IP socket activity, you\n           might specify the PG (program) and SO (socket) domains:\n\n             aux2svg mytrace.txt (PG SO\n\n           If you want to examine a storage allocation problem\n           you might specify the SM (storage manager) domain:\n\n             aux2svg mytrace.txt (SM\n\n           By default, ALL domains are selected but this can take\n           a long time to process. It is best to restrict the\n           actors to a few domains that you are interested in.\n\nUSAGE    - You can run this Rexx on an IBM mainframe, or on a PC\n           by using Regina Rexx from:\n\n              http://regina-rexx.sourceforge.net\n\n           If you run aux2svg on your mainframe, you should use\n           ftp to download the resulting svg and html files by:\n\n           ftp yourmainframe\n           youruserid\n           yourpassword\n           quote site sbdataconn=(IBM-1047,ISO8859-1)\n           get 'your.output.html' your.output.html\n           get 'your.output.svg'  your.output.svg\n\n           It is easier to download the CICS trace print file and\n           run aux2svg.rexx on your PC using Regina Rexx by:\n\n           rexx aux2svg.rexx your.trace.txt (options...\n\n           You can view the resulting SVG file using either:\n\n           1. Mozilla Firefox 1.5, or later, has native SVG rend-\n              ering capability.\n\n           2. Microsoft Internet Explorer 6 with the Adobe SVG\n              Viewer plugin installed. The plugin is free from\n              www.adobe.com. Open the html file created by this\n              Rexx if you want to scroll the output in the\n              browser. Alternatively, you could publish the html\n              file on a web server and point your browser at that\n              web server. Adobe SVG Viewer supports the following\n              mouse/key actions:\n              LeftButton+Ctrl           Zoom in\n              LeftButton+Ctrl+Shift     Zoom out\n              LeftButton+Alt            Move\n              LeftButton+Alt+Shift      Move constrained\n              Tool tips are not supported by this viewer yet.\n\n           3. Apache Batik Squiggle program with Sun Java 1.3 or\n              later installed. Batik is free from www.apache.org\n              To run Squiggle: java -jar batik-squiggle.jar\n              Squiggle supports the following mouse/key actions:\n              LeftButton+Ctrl (+drag)   Zoom in to rectangle\n              LeftButton+Shift (+drag)  Move\n              RightButton+Ctrl (+drag)  Rotate\n              RightButton+Shift (+drag) Zoom (in or out)\n              Squiggle shows tool tips when you hover the mouse\n              over items that have a tool tip defined.\n\n           4. Microsoft Visio 2003 or later.\n\nSYNTAX   - AUX2SVG infile \u00dd(options...\u00a8\n\n           Where,\n           infile   = Name of file to read auxtrace printout from.\n           options  = DETAIL - Include hex data for each record.\n                      XML    - Create xml file from input file.\n                      HTML   - Create HTML file wrapper for SVG.\n                               This allows you to scroll the SVG\n                               in Internet Explorer.\n                      EVENT  - Process input EVENT trace records.\n                      DATA   - Process input DATA trace records.\n                      To negate any of the above options, prefix\n                      the option with NO. For example, NOHTML.\n                      xx     - One or more 2-letter domain names\n                               that you want to process. The\n                               default is all trace domains and\n                               can be much slower. For example,\n                               to show socket activity you would\n                               specify PG and SO.\n\nEXAMPLE  - 1. To investigate a socket programming problem:\n\n              AUX2SVG auxtrace.txt (PG SO DETAIL XML\n\n              This will create the following files:\n                auxtrace.svg  - SVG representation of trace.\n                auxtrace.html - HTML to scroll the SVG.\n                auxtrace.xml  - XML representation of trace.\n\n\nMEMBERS  - The list of members in the distribution PDS are:\n\n           $$$DOC   - This file.\n           GPL      - The GNU General Public License.\n           AUX2SVG  - The Rexx source code (including FILE647 parser).\n           RUNJOB   - JCL to run AUX2SVG in batch.\n\nINSTALL  - 1. Copy AUX2SVG to your Rexx library.\n\n           2. Run a job to print a CICS auxilliary trace file to a\n              sequential (or partitioned) dataset (RECFM=VBA).\n\n           3. You can now either:\n              a. Run AUX2SVG in batch on the mainframe, or\n              b. Download your auxilliary trace print file to a PC\n                 and run AUX2SVG on the PC (using Regina Rexx).\n              Option 'b' is better as it uses cheaper CPU cycles.\n\n           4. If you want to run AUX2SVG on the mainframe, then read\n              on...\n              In TSO (or batch), execute the AUX2SVG rexx procedure\n              specifying the name of the print dataset to process\n              and the CICS domains that you want to visualize:\n\n              TSO AUX2SVG MY.AUX.FILE (PG SO\n\n              If you supply any options, be sure to put a space before\n              the opening parenthesis. A closing parenthesis is\n              optional.\n\n           5. This will create the following datasets (or members):\n\n              MY.AUX.FILE.HTML   - HTML code for scrolling the SVG\n              MY.AUX.FILE.SVG    - Scalable Vector Graphics XML data\n\n              If you specified a partitioned dataset member in 2,\n              called xxx say, then the AUX2SVG rexx will create\n              members in the same partitioned dataset called:\n\n              xxxHTM             - HTML code for scrolling the SVG\n              xxxSVG             - Scalable Vector Graphics XML data\n\n           6. Download the HTML and SVG files to your PC and open\n              either in Internet Explorer (with the Adobe SVG Viewer\n              plugin installed).  You will have to adjust the file\n              name in the HTML file to reference the SVG file.\n\nMORE INFO  - See the AUX2SVG rexx procedure for more information\n\nNOTES      - 1. The AUX2SVG rexx procedure uses the Rexx XML parser\n                in CBTTAPE FILE647 (www.cbttape.org).\n\nAUTHOR     - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n\n----------------------------END OF $$$DOC-------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE725": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x14o\\x01\\x06\\x14o\\x10Q\\x00m\\x00m\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-05-26T00:00:00", "modifydate": "2006-05-26T10:51:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 725 is from Andrew Armstrong and contains his CICS        *   FILE 725\n//*           Auxiliary Trace Visualizer, written in REXX.  The     *   FILE 725\n//*           following is some documentation about this product.   *   FILE 725\n//*                                                                 *   FILE 725\n//*     NAME     - AUX2SVG                                          *   FILE 725\n//*                                                                 *   FILE 725\n//*     TITLE    - CICS AUXILIARY TRACE VISUALIZER                  *   FILE 725\n//*                                                                 *   FILE 725\n//*     VERSION  - 1.2                                              *   FILE 725\n//*                                                                 *   FILE 725\n//*     FUNCTION - Creates a graphical representation of a CICS     *   FILE 725\n//*                auxilliary trace printout by using Scalable      *   FILE 725\n//*                Vector Graphics (SVG).  The SVG markup           *   FILE 725\n//*                represents the trace data in the form of a       *   FILE 725\n//*                Unified Modelling Language (UML) Sequence        *   FILE 725\n//*                Diagram (or at least something quite like        *   FILE 725\n//*                it).                                             *   FILE 725\n//*                                                                 *   FILE 725\n//*                The 'actors' (for example, programs) are         *   FILE 725\n//*                listed side- by-side at the top of the           *   FILE 725\n//*                diagram. A life line is drawn vertically         *   FILE 725\n//*                below each actor. Interactions between actors    *   FILE 725\n//*                (for example, calls and returns) are             *   FILE 725\n//*                represented as arrows drawn between the life     *   FILE 725\n//*                lines.  The vertical axis is time. Each          *   FILE 725\n//*                interaction is labeled on the left of the        *   FILE 725\n//*                diagram with the relative time in seconds        *   FILE 725\n//*                since the start of the trace and the task id.    *   FILE 725\n//*                All the interactions for a task are assigned     *   FILE 725\n//*                the same unique color. Each interaction is       *   FILE 725\n//*                annotated with the trace sequence number, to     *   FILE 725\n//*                enable you to refer back to the original         *   FILE 725\n//*                trace record for more detail, and a summary      *   FILE 725\n//*                of the call and return values. Exception         *   FILE 725\n//*                responses are shown in red.                      *   FILE 725\n//*                                                                 *   FILE 725\n//*                You choose which actors you are interested       *   FILE 725\n//*                in by specifying one or more domain names.       *   FILE 725\n//*                For example, if you want to visualize TCP/IP     *   FILE 725\n//*                socket activity, you might specify the PG        *   FILE 725\n//*                (program) and SO (socket) domains:               *   FILE 725\n//*                                                                 *   FILE 725\n//*                  aux2svg mytrace.txt (PG SO                     *   FILE 725\n//*                                                                 *   FILE 725\n//*                If you want to examine a storage allocation      *   FILE 725\n//*                problem you might specify the SM (storage        *   FILE 725\n//*                manager) domain:                                 *   FILE 725\n//*                                                                 *   FILE 725\n//*                  aux2svg mytrace.txt (SM                        *   FILE 725\n//*                                                                 *   FILE 725\n//*                By default, ALL domains are selected but this    *   FILE 725\n//*                can take a long time to process. It is best      *   FILE 725\n//*                to restrict the actors to a few domains that     *   FILE 725\n//*                you are interested in.                           *   FILE 725\n//*                                                                 *   FILE 725\n//*     USAGE    - You can run this Rexx on an IBM mainframe, or    *   FILE 725\n//*                on a PC by using Regina Rexx from:               *   FILE 725\n//*                                                                 *   FILE 725\n//*                   http://regina-rexx.sourceforge.net            *   FILE 725\n//*                                                                 *   FILE 725\n//*                You can view the resulting SVG file using        *   FILE 725\n//*                either:                                          *   FILE 725\n//*                                                                 *   FILE 725\n//*                1. Microsoft Internet Explorer 6 with the        *   FILE 725\n//*                   Adobe SVG Viewer plugin installed. The        *   FILE 725\n//*                   plugin is free from www.adobe.com. Open       *   FILE 725\n//*                   the html file created by this Rexx if you     *   FILE 725\n//*                   want to scroll the output in the browser.     *   FILE 725\n//*                   Alternatively, you could publish the html     *   FILE 725\n//*                   file on a web server and point your           *   FILE 725\n//*                   browser at that web server. Adobe SVG         *   FILE 725\n//*                   Viewer supports the following mouse/key       *   FILE 725\n//*                   actions:                                      *   FILE 725\n//*                                                                 *   FILE 725\n//*                   LeftButton+Ctrl           Zoom in             *   FILE 725\n//*                   LeftButton+Ctrl+Shift     Zoom out            *   FILE 725\n//*                   LeftButton+Alt            Move                *   FILE 725\n//*                   LeftButton+Alt+Shift      Move constrained    *   FILE 725\n//*                   Tool tips are not supported by this viewer    *   FILE 725\n//*                   yet.                                          *   FILE 725\n//*                                                                 *   FILE 725\n//*                2. Apache Batik Squiggle program with Sun        *   FILE 725\n//*                   Java 1.3 or later installed. Batik is free    *   FILE 725\n//*                   from www.apache.org  To run Squiggle:         *   FILE 725\n//*                   java -jar batik-squiggle.jar                  *   FILE 725\n//*                   Squiggle supports the following               *   FILE 725\n//*                   mouse/key actions:                            *   FILE 725\n//*                                                                 *   FILE 725\n//*                   LeftButton+Ctrl (+drag)   Zoom in to rectangle*   FILE 725\n//*                   LeftButton+Shift (+drag)  Move                *   FILE 725\n//*                   RightButton+Ctrl (+drag)  Rotate              *   FILE 725\n//*                   RightButton+Shift (+drag) Zoom (in or out)    *   FILE 725\n//*                   Squiggle shows tool tips when you hover       *   FILE 725\n//*                   the mouse over items that have a tool tip     *   FILE 725\n//*                   defined.                                      *   FILE 725\n//*                                                                 *   FILE 725\n//*                3. Microsoft Visio 2003 or later.                *   FILE 725\n//*                                                                 *   FILE 725\n//*                                                                 *   FILE 725\n//*     MORE INFO  - See the AUX2SVG rexx procedure for more        *   FILE 725\n//*                  information                                    *   FILE 725\n//*                                                                 *   FILE 725\n//*     NOTES      - 1. The AUX2SVG rexx procedure uses the Rexx    *   FILE 725\n//*                     XML parser in CBTTAPE FILE647               *   FILE 725\n//*                     (www.cbttape.org).                          *   FILE 725\n//*                                                                 *   FILE 725\n//*     AUTHOR     - Andrew J. Armstrong                            *   FILE 725\n//*                  <andrew_armstrong@unwired.com.au>              *   FILE 725\n//*                                                                 *   FILE 725\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUX2SVG": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x06\\x02\\x0f\\x01\\x06\\x02\\x0f\\x10\\x04\\x0e\\x9f\\x0e\\x9f\\x00\\x00\\xe5\\xf1K\\xf2@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-01-20T00:00:00", "modifydate": "2006-01-20T10:04:35", "lines": 3743, "newlines": 3743, "modlines": 0, "user": "V1.2"}, "text": "/*REXX 0154\n\n  CICS Auxiliary Trace Visualizer V1.2\n  Copyright (C) 2005 Andrew J. Armstrong\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n  02111-1307  USA\n\n Author:\n Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - AUX2SVG                                                **\n**                                                                   **\n** FUNCTION - Creates a graphical representation of a CICS auxiliary **\n**            trace printout by using Scalable Vector Graphics (SVG).**\n**            The SVG markup represents the trace data in the form   **\n**            of a Unified Modelling Language (UML) Sequence Diagram **\n**            (or at least something quite like it).                 **\n**                                                                   **\n**            The 'actors' (for example, programs) are listed side-  **\n**            by-side at the top of the diagram. A life line is      **\n**            drawn vertically below each actor. Interactions        **\n**            between actors (for example, calls and returns) are    **\n**            represented as arrows drawn between the life lines.    **\n**            The vertical axis is time. Each interaction is labeled **\n**            on the left of the diagram with the relative time in   **\n**            seconds since the start of the trace and the task id.  **\n**            All the interactions for a task are assigned the same  **\n**            unique color. Each interaction is annotated with the   **\n**            trace sequence number, to enable you to refer back to  **\n**            the original trace record for more detail, and a summ- **\n**            ary of the call and return values. Exception responses **\n**            are shown in red.                                      **\n**                                                                   **\n**            You choose which actors you are interested in by       **\n**            specifying one or more domain names. For example, if   **\n**            you want to visualize TCP/IP socket activity, you      **\n**            might specify the PG (program) and SO (socket) domains:**\n**                                                                   **\n**              aux2svg mytrace.txt (PG SO                           **\n**                                                                   **\n**            If you want to examine a storage allocation problem    **\n**            you might specify the SM (storage manager) domain:     **\n**                                                                   **\n**              aux2svg mytrace.txt (SM                              **\n**                                                                   **\n**            By default, ALL domains are selected but this can take **\n**            a long time to process. It is best to restrict the     **\n**            actors to a few domains that you are interested in.    **\n**                                                                   **\n** USAGE    - You can run this Rexx on an IBM mainframe, or on a PC  **\n**            by using Regina Rexx from:                             **\n**                                                                   **\n**               http://regina-rexx.sourceforge.net                  **\n**                                                                   **\n**            If you run aux2svg on your mainframe, you should use   **\n**            ftp to download the resulting svg and html files by:   **\n**                                                                   **\n**            ftp yourmainframe                                      **\n**            youruserid                                             **\n**            yourpassword                                           **\n**            quote site sbdataconn=(IBM-1047,ISO8859-1)             **\n**            get 'your.output.html' your.output.html                **\n**            get 'your.output.svg'  your.output.svg                 **\n**                                                                   **\n**            It is easier to download the CICS trace print file and **\n**            run aux2svg.rexx on your PC using Regina Rexx by:      **\n**                                                                   **\n**            rexx aux2svg.rexx your.trace.txt (options...           **\n**                                                                   **\n**            You can view the resulting SVG file using either:      **\n**                                                                   **\n**            1. Mozilla Firefox 1.5, or later, has native SVG rend- **\n**               ering capability.                                   **\n**                                                                   **\n**            2. Microsoft Internet Explorer 6 with the Adobe SVG    **\n**               Viewer plugin installed. The plugin is free from    **\n**               www.adobe.com. Open the html file created by this   **\n**               Rexx if you want to scroll the output in the        **\n**               browser. Alternatively, you could publish the html  **\n**               file on a web server and point your browser at that **\n**               web server. Adobe SVG Viewer supports the following **\n**               mouse/key actions:                                  **\n**               LeftButton+Ctrl           Zoom in                   **\n**               LeftButton+Ctrl+Shift     Zoom out                  **\n**               LeftButton+Alt            Move                      **\n**               LeftButton+Alt+Shift      Move constrained          **\n**               Tool tips are not supported by this viewer yet.     **\n**                                                                   **\n**            3. Apache Batik Squiggle program with Sun Java 1.3 or  **\n**               later installed. Batik is free from www.apache.org  **\n**               To run Squiggle: java -jar batik-squiggle.jar       **\n**               Squiggle supports the following mouse/key actions:  **\n**               LeftButton+Ctrl (+drag)   Zoom in to rectangle      **\n**               LeftButton+Shift (+drag)  Move                      **\n**               RightButton+Ctrl (+drag)  Rotate                    **\n**               RightButton+Shift (+drag) Zoom (in or out)          **\n**               Squiggle shows tool tips when you hover the mouse   **\n**               over items that have a tool tip defined.            **\n**                                                                   **\n**            4. Microsoft Visio 2003 or later.                      **\n**                                                                   **\n** SYNTAX   - AUX2SVG infile \u00dd(options...\u00a8                           **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Name of file to read auxtrace printout from.**\n**            options  = DETAIL - Include hex data for each record.  **\n**                       XML    - Create xml file from input file.   **\n**                       HTML   - Create HTML file wrapper for SVG.  **\n**                                This allows you to scroll the SVG  **\n**                                in Internet Explorer.              **\n**                       EVENT  - Process input EVENT trace records. **\n**                       DATA   - Process input DATA trace records.  **\n**                       To negate any of the above options, prefix  **\n**                       the option with NO. For example, NOHTML.    **\n**                       xx     - One or more 2-letter domain names  **\n**                                that you want to process. The      **\n**                                default is all trace domains and   **\n**                                can be much slower. For example,   **\n**                                to show socket activity you would  **\n**                                specify PG and SO.                 **\n**                                                                   **\n** LOGIC    - 1. Create an in-memory <svg> document.                 **\n**                                                                   **\n**            2. Create an in-memory <auxtrace> element, but do not  **\n**               connect it to the <svg> document.                   **\n**                                                                   **\n**            3. Scan the auxiliary trace output and convert each    **\n**               pair of ENTRY/EXIT trace entries into a single XML  **\n**               <trace> element. Add each <trace> element to the    **\n**               <auxtrace> element and nest the <trace> elements.   **\n**               The <auxtrace> element is a temporary representation**\n**               of the auxiliary trace data and will be discarded   **\n**               and/or written to an output file later.             **\n**                                                                   **\n**            4. Walk through the tree of <trace> elements and when  **\n**               an interesting <trace> element is found, add        **\n**               appropriate SVG markup to the <svg> element in order**\n**               to visualize the <trace> element.                   **\n**                                                                   **\n**            5. Output an SVG document by using the PrettyPrinter   **\n**               routine to 'print' the <svg> element to a file.     **\n**                                                                   **\n**            6. Output an XML document by using the PrettyPrinter   **\n**               routine to 'print' the <auxtrace> element (only if  **\n**               the XML option was specified).                      **\n**                                                                   **\n** EXAMPLE  - 1. To investigate a socket programming problem:        **\n**                                                                   **\n**               AUX2SVG auxtrace.txt (PG SO DETAIL XML              **\n**                                                                   **\n**               This will create the following files:               **\n**                 auxtrace.svg  - SVG representation of trace.      **\n**                 auxtrace.html - HTML to scroll the SVG.           **\n**                 auxtrace.xml  - XML representation of trace.      **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top pls)  **\n**            -------- -------- ------------------------------------ **\n**            20060120 AJA      Conform to CSS2 requirements of      **\n**                              Mozilla Firefox 1.5 (font-size must  **\n**                              have a unit, stroke-dasharray must   **\n**                              use a comma as a delimiter).         **\n**            20051027 AJA      Draw colored arrow heads.            **\n**            20051026 AJA      Set xml name space to 'svg' (oops!). **\n**            20051025 AJA      Minor changes. Fixed bug in parsexml.**\n**            20051018 AJA      Documentation corrections. Enhanced  **\n**                              getDescriptionOfCall() for CC, GC,   **\n**                              DS and AP domains.                   **\n**            20051014 AJA      Intial version.                      **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn' ('sOptions')'\n\n  numeric digits 16\n  say 'AUX000I CICS Auxiliary Trace Visualizer v1.2'\n  if sFileIn = ''\n  then do\n    say 'Syntax:'\n    say '   aux2svg infile \u00dd(options\u00a8'\n    say\n    say 'Where:'\n    say '   infile  = CICS auxiliary trace print file'\n    say '   options = DETAIL - Include hex data for each record.'\n    say '             XML    - Create xml file from input file.'\n    say '             HTML   - Create HTML file wrapper for SVG.'\n    say '                      This allows you to scroll the SVG'\n    say '                      in Internet Explorer.'\n    say '             EVENT  - Include EVENT trace records.'\n    say '             DATA   - Include DATA trace records.'\n    say '             To negate of the above options, prefix the'\n    say '             option with NO. For example, NOHTML.'\n    say '             xx     - One or more 2-letter domain names'\n    say '                      that you want to process. The'\n    say '                      default is all trace domains and'\n    say '                      can be much slower. For example,'\n    say '                      to show socket activity you would'\n    say '                      specify PG and SO.'\n    exit\n  end\n  say 'AUX001I Scanning CICS auxiliary trace in' sFileIn\n\n  sOptions = 'NOBLANKS' translate(sOptions)\n  call initParser sOptions /* DO THIS FIRST! Sets g. vars to '' */\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call setFileNames sFileIn\n  call setOptions sOptions\n  call Prolog\n\n  doc = createDocument('svg')\n\n  call scanAuxTraceFile\n\n  if g.!OPTION.DUMP\n  then call _displayTree\n\n  if g.!OPTION.XML\n  then do\n    call setDocType /* we don't need a doctype declaration */\n    call prettyPrinter g.!FILEXML,,g.!AUXTRACE\n  end\n\n  call buildSVG\n\n  call setPreserveWhitespace 1 /* to keep newlines in <desc> tags */\n  call prettyPrinter g.!FILESVG\n\n  if g.!OPTION.HTML\n  then call createHTML\n\n  call Epilog\nexit\n\n/* The auxtrace input filename is supplied by the user.\nThe names of the SVG, XML and HTML output files are automatically\ngenerated from the input file filename. The generated file names also\ndepend on the operating system. Global variables are set as follows:\ng.!FILETXT = name of input text file  (e.g. auxtrace.txt)\ng.!FILESVG = name of output SVG file  (e.g. auxtrace.svg)\ng.!FILEXML = name of output XML file  (e.g. auxtrace.xml)\ng.!FILEHTM = name of output HTML file (e.g. auxtrace.html)\n*/\nsetFileNames: procedure expose g.\n  parse arg sFileIn\n  if g.!ENV = 'TSO'\n  then do\n    parse var sFileIn sDataset'('sMember')'\n    if sMember <> ''\n    then do /* make output files members in the same PDS */\n      sPrefix = strip(left(sMember,7)) /* room for a suffix char */\n      sPrefix = translate(sPrefix) /* translate to upper case */\n      g.!FILETXT = translate(sFileIn)\n      /* squeeze the file extension into the member name...*/\n      g.!FILESVG = sDataset'('strip(left(sPrefix'SVG',8))')'\n      g.!FILEXML = sDataset'('strip(left(sPrefix'XML',8))')'\n      g.!FILEHTM = sDataset'('strip(left(sPrefix'HTM',8))')'\n    end\n    else do /* make output files separate datasets */\n      g.!FILETXT = translate(sFileIn)\n      g.!FILESVG = sDataset'.SVG'\n      g.!FILEXML = sDataset'.XML'\n      g.!FILEHTM = sDataset'.HTML'\n    end\n  end\n  else do\n    sFileName  = getFilenameWithoutExtension(sFileIn)\n    g.!FILETXT = sFileIn\n    g.!FILESVG = sFileName'.svg'\n    g.!FILEXML = sFileName'.xml'\n    g.!FILEHTM = sFileName'.html'\n  end\nreturn\n\ngetFilenameWithoutExtension: procedure expose g.\n  parse arg sFile\n  parse value reverse(sFile) with '.'sRest\nreturn reverse(sRest)\n\nscanAuxTraceFile: procedure expose g.\n  g.!AUXTRACE = createElement('auxtrace')\n  g.!FILEIN = openFile(g.!FILETXT)\n  g.!K = 0   /* Trace entry count */\n  g.!KD = 0  /* Trace entry delta since last progress message */\n\n  sLine = getLineContaining('CICS - AUXILIARY TRACE FROM')\n  parse var sLine 'CICS - AUXILIARY TRACE FROM ',\n                   sDate ' - APPLID' sAppl .\n  call setAttributes g.!AUXTRACE,,\n       'date',sDate,,\n       'appl',sAppl\n\n  g.!ROWS = 0\n  bAllDomains = words(g.!DOMAIN_FILTER) = 0\n  sEntry = getFirstTraceEntry()\n  parse var g.!ENTRYDATA.1 '='g.!FIRSTSEQ'=' .\n  do while g.!RC = 0\n    parse var sEntry sDomain xType sModule sAction sParms\n    if g.!FREQ.sDomain = ''\n    then do\n      g.!FREQ.sDomain = 0\n      if g.!DOMAIN.sDomain = ''\n      then say 'AUX002W Unknown domain \"'sDomain'\" found in' sEntry\n    end\n    g.!FREQ.sDomain = g.!FREQ.sDomain + 1\n    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0\n    then do\n      parse var g.!ENTRYDATA.1 'TASK-'nTaskId . 'TIME-'sTime .,\n                               'INTERVAL-'nInterval . '='nSeq'=' .\n      if g.!TASK.nTaskId = '' /* if task is new */\n      then do\n        call initStack nTaskId\n        e = createElement('task')\n        call pushStack nTaskId,e\n        g.!TASK.nTaskId = e\n        call appendChild e,g.!AUXTRACE\n        call setAttribute e,'taskid',nTaskId\n      end\n      task = g.!TASK.nTaskId\n\n      nElapsed = getElapsed(sTime)\n      select\n        when sAction = 'ENTRY' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = strip(sParms)\n          select\n            when left(sParms,1) = '-' then do /* if new style parms */\n              /* ENTRY - FUNCTION(xxx) yyy(xxx) ... */\n              sParms = space(strip(sParms,'LEADING','-'))\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                if left(sParms,1) = '*'\n                /* e.g. '** Decode of parameter list failed **' */\n                then sFunction = sParms\n                else parse var sParms sFunction sParms\n              end\n            end\n            when pos('REQ(',sParms) > 0 then do /* old style parms */\n              /* ENTRY function                 REQ(xxx) ... */\n              parse var sParms sFixed'REQ('sParms\n              sParms = 'REQ('sParms\n              parse var sFixed sFunction sRest\n              sParms = 'PARMS('sRest')'\n            end\n            otherwise do /* old style parms */\n              /* ENTRY function parms                        */\n              /* ENTRY FUNCTION(function) parms              */\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                parse var sParms sFunction sParms\n              end\n            end\n          end\n          parent = peekStack(nTaskId)\n          e = createElement('trace')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n          then call appendDetail e,'on-entry'\n          call pushStack nTaskId,e\n        end\n        when sAction = 'EXIT' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = strip(sParms)\n          sReason = ''\n          sAbend = ''\n          select\n            when left(sParms,1) = '-' then do\n              /* EXIT - FUNCTION(xxx) yyy(xxx) ... */\n              sParms = space(strip(sParms,'LEADING','-'))\n              if pos('FUNCTION(',sParms) > 0\n              then do\n                parse var sParms 'FUNCTION('sFunction')',\n                               1 'RESPONSE('sResponse')',\n                               1 'REASON('sReason')',\n                               1 'ABEND_CODE('sAbend')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n                n = wordpos('RESPONSE('sResponse')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n              end\n              else do\n                if left(sParms,1) = '*'\n                /* e.g. '** Decode of parameter list failed **' */\n                then do\n                  sFunction = ''\n                  sResponse = ''\n                end\n                else parse var sParms sFunction sResponse sParms\n                sReason   = ''\n                sAbend    = ''\n              end\n            end\n            when pos('REQ(',sParms) > 0 then do\n              /* EXIT function response         REQ(xxx) ... */\n              /* EXIT response                  REQ(xxx) ... */\n              parse var sParms sFixed'REQ('sParms\n              sParms = 'REQ('sParms\n              if words(sFixed) = 1\n              then do\n                sFunction = ''\n                sResponse = strip(sFixed)\n              end\n              else do\n                parse var sFixed sFunction sResponse .\n              end\n            end\n            when pos('FUNCTION(',sParms) > 0 then do\n              /* EXIT FUNCTION(xxx) RESPONSE(xxx) parms ...  */\n                parse var sParms 'FUNCTION('sFunction')',\n                               1 'RESPONSE('sResponse')'\n                n = wordpos('FUNCTION('sFunction')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n                n = wordpos('RESPONSE('sResponse')',sParms)\n                if n > 0 then sParms = delword(sParms,n,1)\n            end\n            otherwise do\n              parse var sParms sFunction sParms\n            end\n          end /* select */\n          parent = popStack(nTaskId)\n          if parent <> g.!AUXTRACE\n          then do\n            call setAttributes parent,,\n                 'exitrow',g.!ROWS,,\n                 'response',sResponse,,\n                 'exitseq',nSeq\n            sCompoundReason = strip(sReason sAbend)\n            if sCompoundReason <> ''\n            then call setAttribute parent,'reason',sCompoundReason\n            call setParmAttributes parent,sParms\n          end\n          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n          then call appendDetail parent,'on-exit'\n        end\n        when sAction = 'EVENT' then do\n          if g.!OPTION.EVENT\n          then do\n            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n            sParms = space(strip(strip(sParms),'LEADING','-'))\n            parse var sParms sFunction sParms\n            parent = peekStack(nTaskId)\n            e = createElement('event')\n            call appendChild e,parent\n            call setAttributes e,,\n                 'seq',nSeq,,\n                 'row',g.!ROWS,,\n                 'elapsed',nElapsed,,\n                 'interval',getInterval(sTime),,\n                 'domain',sDomain,,\n                 'module','DFH'sModule,,\n                 'function',sFunction,,\n                 'parms',sParms,,\n                 'taskid',nTaskId\n            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n            then call appendDetail e,'detail'\n          end\n        end\n        when sAction = 'CALL' then do\n          sParms = space(strip(strip(sParms),'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('call')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n        end\n        when sAction = '*EXC*' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = space(strip(sParms,'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('exception')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'parms',sParms,,\n               'taskid',nTaskId\n        end\n        when sAction = 'DATA' then do\n          if g.!OPTION.DATA\n          then do\n            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n            sParms = space(strip(strip(sParms),'LEADING','-'))\n            parse var sParms sFunction sParms\n            parent = peekStack(nTaskId)\n            e = createElement('data')\n            call appendChild e,parent\n            call setAttributes e,,\n                 'seq',nSeq,,\n                 'row',g.!ROWS,,\n                 'elapsed',nElapsed,,\n                 'interval',getInterval(sTime),,\n                 'domain',sDomain,,\n                 'module','DFH'sModule,,\n                 'function',sFunction,,\n                 'taskid',nTaskId\n            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1\n            then call appendDetail e,'detail'\n          end\n        end\n        when sAction = 'RESUMED' then do\n          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */\n          sParms = space(strip(strip(sParms),'LEADING','-'))\n          parse var sParms sFunction sParms\n          parent = peekStack(nTaskId)\n          e = createElement('resumed')\n          call appendChild e,parent\n          call setAttributes e,,\n               'seq',nSeq,,\n               'row',g.!ROWS,,\n               'elapsed',nElapsed,,\n               'interval',getInterval(sTime),,\n               'domain',sDomain,,\n               'module','DFH'sModule,,\n               'function',sFunction,,\n               'taskid',nTaskId\n          call setParmAttributes e,sParms\n        end\n        when sAction = 'PC' then do\n          /* this trace type does not seem to add any value */\n        end\n        otherwise do\n          parent = peekStack(nTaskId)\n          call appendChild createTextNode(sEntry),parent\n          say 'AUX003E Unknown trace entry <'sAction'>:' sEntry\n        end\n      end\n    end\n    sEntry = getTraceEntry()\n  end\n  rc = closeFile(g.!FILEIN)\n  say 'AUX004I Processed' g.!K-1 'trace entries'\n  say 'AUX005I Domain processing summary:'\n  do i = 1 to g.!DOMAIN.0\n    sDomain = g.!DOMAIN.i\n    sDesc   = g.!DOMAIN.sDomain\n    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0\n    then sFilter = 'Requested'\n    else sFilter = '         '\n    if g.!FREQ.sDomain > 0\n    then sFound  = 'Found' right(g.!FREQ.sDomain,5)\n    else sFound  = '           '\n    say 'AUX006I   'sFilter sFound sDomain sDesc\n  end\nreturn\n\ninitStack: procedure expose g.\n  parse arg task\n  g.!T.task = 0         /* set top of stack index for task */\nreturn\n\npushStack: procedure expose g.\n  parse arg task,item\n  tos = g.!T.task + 1   /* get new top of stack index for task */\n  g.!E.task.tos = item  /* set new top of stack item */\n  g.!T.task = tos       /* set new top of stack index */\nreturn\n\npopStack: procedure expose g.\n  parse arg task\n  tos = g.!T.task       /* get top of stack index for task */\n  item = g.!E.task.tos  /* get item at top of stack */\n  g.!T.task = max(tos-1,1)\nreturn item\n\npeekStack: procedure expose g.\n  parse arg task\n  tos = g.!T.task       /* get top of stack index for task */\n  item = g.!E.task.tos  /* get item at top of stack */\nreturn item\n\ngetLineContaining: procedure expose g.\n  parse arg sSearchArg\n  sLine = getLine(g.!FILEIN)\n  do while g.!RC = 0 & pos(sSearchArg, sLine) = 0\n    sLine = getLine(g.!FILEIN)\n  end\nreturn sLine\n\ngetNextLine: procedure expose g.\n  sLine = getLine(g.!FILEIN)\n  if g.!RC = 0\n  then do\n    cc = left(sLine,1)\n    select\n      when cc = '0' then sLine = '' /* ASA double space */\n      when cc = '1' then do         /* ASA page eject */\n        sLine = getLine(g.!FILEIN)  /* skip blank line after title */\n        if sLine <> ''\n        then say 'AUX007W Line after heading is not blank:' sLine\n        sLine = getLine(g.!FILEIN)  /* read next data line */\n      end\n      when sLine = '<<<<  STARTING DATA FROM NEXT EXTENT  >>>>' then,\n        sLine = ''\n      otherwise nop\n    end\n  end\nreturn sLine\n\ngetFirstTraceEntry: procedure expose g.\n  sLine = getNextLine()\n  parse var sLine sDomain xType sModule .\n  do while g.!RC = 0 & length(sDomain) <> 2\n    sLine = getNextLine()\n    parse var sLine sDomain xType sModule .\n  end\nreturn getTraceEntry(sLine)\n\ngetTraceEntry: procedure expose g.\n  parse arg sEntry\n  /* The general format of a trace entry is something like:\n\nOld style:\n dd tttt mmmm action ...fixed_width_stuff... parms...\n                     moreparms...\n\n               TASK-nnnnn ....timing info etc...........  =seqno=\n                 1-0000  ...hex dump.... *...character dump...*\n                 2-0000  ...hex dump.... *...character dump...*\n                   0020  ...hex dump.... *...character dump...*\n                         .\n                         .\n                 n-0000  ...hex dump.... *...character dump...*\n                         .\n                         .\n\nNew style:\n dd tttt mmmm action - parms...\n                     moreparms...\n\n               TASK-nnnnn ....timing info etc...........  =seqno=\n                 1-0000  ...hex dump.... *...character dump...*\n                 2-0000  ...hex dump.... *...character dump...*\n                   0020  ...hex dump.... *...character dump...*\n                         .\n                         .\n                 n-0000  ...hex dump.... *...character dump...*\n                         .\n                         .\n\n  */\n  sLine = getNextLine()\n  do while g.!RC = 0 & left(strip(sLine),5) <> 'TASK-'\n    sEntry = sEntry strip(sLine)\n    sLine = getNextLine()\n  end\n  g.!ENTRYDATA.0 = 0\n  do i = 1 while g.!RC = 0 & sLine <> ''\n    g.!ENTRYDATA.i = sLine\n    g.!ENTRYDATA.0 = i\n    sLine = getNextLine()\n  end\n  g.!K = g.!K + 1\n  g.!KD = g.!KD + 1\n  if g.!KD >= 1000\n  then do\n    say 'AUX008I Processed' g.!K 'trace entries'\n    g.!KD = 0\n  end\nreturn sEntry\n\ngetElapsed: procedure expose g.\n  parse arg nHH':'nMM':'nSS\n  nThisOffset = ((nHH*60)+nMM)*60+nSS\n  if g.!FIRSTOFFSET = ''\n  then g.!FIRSTOFFSET = nThisOffset\nreturn nThisOffset - g.!FIRSTOFFSET\n\ngetInterval: procedure expose g.\n  parse arg sTime\n  nThisOffset = getElapsed(sTime) /* seconds from start of trace */\n  if g.!PREVOFFSET = ''\n  then nInterval = 0\n  else nInterval = nThisOffset - g.!PREVOFFSET\n  g.!PREVOFFSET = nThisOffset\nreturn nInterval\n\nsetParmAttributes: procedure expose g.\n  parse arg e,sParms\n  if pos('(',sParms) > 0\n  then do while sParms <> ''\n    parse var sParms sName'('sValue')'sParms\n    sName = getValidAttributeName(sName)\n    if wordpos(sName,'FIELD-A FIELD-B') > 0\n    then parse var sValue sValue .\n    call setAttribute e,space(sName,0),strip(sValue)\n  end\n  else do\n    if sParms <> ''\n    then call setAttribute e,'parms',sParms\n  end\nreturn\n\nbuildSVG: procedure expose g.\n  say 'AUX009I Building SVG'\n\n  g.!LINEDEPTH = 12\n\n  doc = getDocumentElement()\n  call setDocType 'PUBLIC \"-//W3C//DTD SVG 1.1//EN\"',\n                  '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"'\n\n  call setAttributes doc,,\n       'xmlns','http://www.w3.org/2000/svg',,\n       'xmlns:xlink','http://www.w3.org/1999/xlink'\n\n  title = createElement('title')\n  call appendChild title,doc\n  sAppl = getAttribute(g.!AUXTRACE,'appl')\n  sDate = getAttribute(g.!AUXTRACE,'date')\n  sTitle = 'CICS auxiliary trace of' sAppl 'captured on' sDate\n  call appendChild createTextNode(sTitle),title\n\n  call addTooltip doc,,\n       'Created by CICS Auxiliary Trace Visualizer v1.2 by',\n       'Andrew J. Armstrong (andrew_armstrong@unwired.com.au)'\n\n  g.!STYLE = createElement('style')\n  call appendChild g.!STYLE,doc\n\n  call setAttribute g.!STYLE,'type','text/css'\n\n  queue\n  queue '.background  {fill:white;}'\n  queue '.actors      {text-anchor:middle;' ||,\n                      'fill:lemonchiffon;stroke:slateblue;}'\n  queue '.lifeline    {stroke:yellowgreen;stroke-dasharray:5,2;' ||,\n                      'fill:none;}'\n  queue '.seq         {fill:gray;}'\n  queue '.arrows      {stroke-width:2;fill:none;}'\n  queue '.return      {stroke-dasharray:2,3;}'\n  queue '.annotation  {stroke:none;font-size:6px;}'\n  queue '.ltr         {text-anchor:start;}'\n  queue '.rtl         {text-anchor:end;}'\n  queue '.error       {fill:red;}'\n  queue 'text.dump    {font-family:monospace;font-size:10px;}'\n  queue 'text         {font-family:Arial;font-size:10px;fill:black;' ||,\n                      'stroke:none;}'\n  queue\n  styles = createCDATASection(pullLines())\n  call appendChild styles,g.!STYLE\n\n  defs = createElement('defs')\n  call appendChild defs,doc\n  path = createElement('path')\n  call appendChild path,defs\n  call setAttributes path,,\n       'id','arrow',,\n       'd','M 0 0 L 10 5 L 0 10 z'\n  circle = createElement('circle')\n  call appendChild circle,defs\n  call setAttributes circle,,\n       'id','circle',,\n       'cx',5,'cy',5,'r',5\n\n  background = createElement('rect')\n  call appendChild background,doc\n\n  g.!ACTOR_NODES = ''\n  call getActors g.!AUXTRACE\n  lifelinebg = createElement('g')\n  call setAttribute lifelinebg,'class','background'\n  lifelines = createElement('g')\n  call setAttribute lifelines,'class','lifeline'\n  g = createElement('g')\n  call setAttribute g,'class','actors'\n  call appendChild createComment(' Life lines'),doc\n  call appendChild lifelinebg,doc\n  call appendChild lifelines,doc\n  call appendChild createComment(' Actor rectangles'),doc\n  call appendChild g,doc\n  w = 60 /* width of an actor rectangle */\n  h = 22 /* height of an actor rectangle */\n  x = w  /* horizontal position of actor rectangle */\n  do i = 1 to words(g.!ACTOR_NODES) /* for each actor... */\n    node = word(g.!ACTOR_NODES,i)\n    sActor = getActorName(node)\n    sDomain = getAttribute(node,'domain')\n    xMid = x + w/2\n    /* Draw the life line background (for tooltips)... */\n    rect = createElement('rect')\n    call appendChild rect,lifelinebg\n    call setAttributes rect,,\n         'x',xMid-5,,\n         'y',h,,\n         'width',10,,\n         'height',0 /* placeholder...see below */\n    /* Add a tooltip for this life line background rect... */\n    call addTooltip rect,sActor\n    /* Draw the life line... */\n    line = createElement('line')\n    call appendChild line,lifelines\n    call setAttributes line,,\n         'x1',xMid,,\n         'y1',h,,\n         'x2',xMid,,\n         'y2',0 /* placeholder...see below */\n    /* Add an identical tooltip for this life line... */\n    call addTooltip line,sActor\n    g.!X.sActor = xMid /* remember where this actor is by name */\n    /* Draw the rectangle to contain the actor name... */\n    rect = createElement('rect')\n    call appendChild rect,g\n    call setAttributes rect,,\n         'x',x,,\n         'y',0,,\n         'width',w,,\n         'height',h,,\n         'rx',1,,\n         'ry',1\n    /* Draw the domain name and actor name within the rectangle... */\n    text = createElement('text')\n    call appendChild text,g\n    call setAttributes text,'y',9\n    domain = createElement('tspan')\n    actor = createElement('tspan')\n    call appendChild domain,text\n    call appendChild actor,text\n    call setAttributes domain,'x',xMid\n    call setAttributes actor,'x',xMid,'dy',10\n    select\n      when isProgram(node),\n        then call appendChild createTextNode('program'),domain\n      when isSocket(node),\n        then call appendChild createTextNode('socket'),domain\n      otherwise,\n        call appendChild createTextNode(sDomain),domain\n    end\n    call appendChild createTextNode(sActor),actor\n    x = x + w + 5\n  end\n\n  nImageWidth = x + w /* room on the right for a longish message */\n\n  call appendChild createComment(' Actor relationships'),doc\n  g = createElement('g')\n  call appendChild g,doc\n  call setAttribute g,'class','arrows'\n\n  g.!FIRSTARROW = 2 * g.!LINEDEPTH /* vertical offset of first arrow */\n  tasks = getChildren(g.!AUXTRACE)\n  do i = 1 to words(tasks)\n    task = word(tasks,i)\n    nTaskId = getAttribute(task,'taskid')\n    h = getHue(i)\n    s = getSaturation(i)\n    v = getValue(i)\n    sColor = hsv2rgb(h,s,v)\n    style = createTextNode('.task'nTaskId '{stroke:'sColor';}')\n    call appendChild style,g.!STYLE\n    style = createTextNode('.fill'nTaskId '{fill:'sColor';}')\n    call appendChild style,g.!STYLE\n    call createMarkers defs,nTaskId\n    call drawArrows g,task\n  end\n\n  nImageHeight = (2 + g.!ROWS + 1 ) * g.!LINEDEPTH\n  call setAttributes doc,,\n       'height',nImageHeight,,\n       'width',nImageWidth,,\n       'viewBox','-10 -10' nImageWidth+10 nImageHeight+10\n  call setAttributes background,,\n       'class','background',,\n       'x',0,,\n       'y',0,,\n       'height',nImageHeight,,\n       'width',nImageWidth\n   g.!WIDTH = nImageWidth\n   g.!HEIGHT = nImageHeight\n\n  /* Now we know the image height we can update the lifeline depth */\n  nodes = getChildren(lifelinebg)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    call setAttribute node,'height',nImageHeight\n  end\n  nodes = getChildren(lifelines)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    call setAttribute node,'y2',nImageHeight\n  end\n\n  /* Finally, remove unreferenced marker definitions...*/\n  nodes = getChildren(defs)\n  do i = 1 to words(nodes)\n    node = word(nodes,i)\n    if getNodeName(node) = 'marker'\n    then do\n      sId = getAttribute(node,'id')\n      if g.!MARKER.sId = ''\n      then call removeChild node\n    end\n  end\n\nreturn\n\ncreateMarkers: procedure expose g.\n  parse arg defs,nTaskId\n/*\n    <marker id=\"ArrowXXXXX\" viewBox=\"0 0 10 10\" refX=\"7\" refY=\"5\"\n            orient=\"auto\">\n      <use xlink:href=\"#arrow\"/>\n    </marker>\n*/\n  marker = createElement('marker')\n  call appendChild marker,defs\n  call setAttributes marker,,\n       'id','Arrow'nTaskId,,\n       'class','fill'nTaskId,,\n       'viewBox','0 0 10 10',,\n       'refX',7,,\n       'refY',5,,\n       'orient','auto'\n  use = createElement('use')\n  call appendChild use,marker\n  call setAttribute use,'xlink:href','#arrow'\n/*\n    <marker id=\"CircleXXXXX\" viewBox=\"0 0 10 10\" refX=\"8\" refY=\"5\">\n      <use xlink:href=\"#circle\"/>\n    </marker>\n*/\n  marker = createElement('marker')\n  call appendChild marker,defs\n  call setAttributes marker,,\n       'id','Circle'nTaskId,,\n       'class','fill'nTaskId,,\n       'viewBox','0 0 10 10',,\n       'refX',8,,\n       'refY',5\n  use = createElement('use')\n  call appendChild use,marker\n  call setAttribute use,'xlink:href','#circle'\nreturn\n\naddTooltip: procedure expose g.\n  parse arg node,sTip\n  tooltip = createElement('desc')\n  call appendChild tooltip,node\n  call appendChild createTextNode(sTip),tooltip\nreturn\n\ngetHue: procedure expose g.\n  arg n\nreturn (g.!HUE_INIT + (n-1) * g.!HUE_STEP) // 360\n\ngetSaturation: procedure expose g.\n  arg n\n  n = g.!SAT_LEVELS - 1 - (n-1) // g.!SAT_LEVELS\nreturn g.!SAT_MIN + n * g.!SAT_STEP\n\ngetValue: procedure expose g.\n  arg n\n  n = g.!VAL_LEVELS - 1 - (n-1) // g.!VAL_LEVELS\nreturn g.!VAL_MIN + n * g.!VAL_STEP\n\nhsv2rgb: procedure\n  parse arg h,s,v\n  /*\n  Hue (h) is from 0 to 360, where 0 = red and 360 also = red\n  Saturation (s) is from 0.0 to 1.0 (0 = least color, 1 = most color)\n  Value (v) is from 0.0 to 1.0 (0 = darkest, 1 = brightest)\n  */\n  v = 100 * v /* convert to a percentage */\n  if s = 0 /* if grayscale */\n  then do\n    v = format(v,,2)'%'\n    rgb = 'rgb('v','v','v')'\n  end\n  else do\n    sextant = trunc(h/60) /* 0 to 5 */\n    fraction = h/60 - sextant\n    p = v * (1 - s)\n    q = v * (1 - s * fraction)\n    r = v * (1 - s * (1 - fraction))\n    v = format(v,,2)'%'\n    p = format(p,,2)'%'\n    q = format(q,,2)'%'\n    r = format(r,,2)'%'\n    select\n      when sextant = 0 then rgb = 'rgb('v','r','p')'\n      when sextant = 1 then rgb = 'rgb('q','v','p')'\n      when sextant = 2 then rgb = 'rgb('p','v','r')'\n      when sextant = 3 then rgb = 'rgb('p','q','v')'\n      when sextant = 4 then rgb = 'rgb('r','q','v')'\n      when sextant = 5 then rgb = 'rgb('v','p','q')'\n      otherwise rgb = 'rgb(0,0,0)' /* should not happen :) */\n    end\n  end\nreturn rgb\n\n\npullLines: procedure expose g.\n  sLines = ''\n  do queued()\n    parse pull sLine\n    sLines = sLines || sLine || g.!LF\n  end\nreturn sLines\n\ngetActors: procedure expose g.\n  parse arg node\n  sActor = getActorName(node)\n  if sActor <> '' & g.!ACTOR.sActor = ''\n  then do /* if this node is a new actor */\n      g.!ACTOR_NODES = g.!ACTOR_NODES node\n      g.!ACTOR.sActor = 1 /* we've seen it now */\n  end\n  children = getChildren(node)\n  do i = 1 to words(children)\n    child = word(children,i)\n    call getActors child\n  end\nreturn\n\ngetActorName: procedure expose g.\n  parse arg node\n  select\n    when node = g.!AUXTRACE then do\n      sActor = '<<cics>>'\n    end\n    when getNodeName(node) = 'task' then do\n      sActor = '<<cics>>'\n    end\n    when isProgram(node) then do\n      sActor = getAttribute(node,'PROGRAM_NAME')\n      if sActor = '' then sActor = getAttribute(node,'PROGRAM')\n      if sActor = '' then sActor = '<<program>>'\n    end\n    when isSocket(node) then do\n      sActor = getAttribute(node,'SOCKET_TOKEN')\n      if sActor = '' then sActor = '<<socket>>'\n    end\n    otherwise sActor = getAttribute(node,'module')\n  end\nreturn sActor\n\nisProgram: procedure expose g.\n  parse arg node\n  sDomain = getAttribute(node,'domain')\n  sFunction = getAttribute(node,'function')\n  bIsProgram = sDomain = 'PG' &,\n     wordpos(sFunction,'LINK LINK_EXEC INITIAL_LINK',\n                       'LOAD LOAD_EXEC LINK_URM') > 0\n  bIsProgram = bIsProgram | (sDomain = 'AP' &,\n     wordpos(sFunction,'START_PROGRAM') > 0)\nreturn bIsProgram\n\nisSocket: procedure expose g.\n  parse arg node\n  sModule = getAttribute(node,'module')\n  sFunction = getAttribute(node,'function')\n  bIsSocket = sModule = 'DFHSOCK' &,\n     wordpos(sFunction,'SEND RECEIVE CONNECT CLOSE') > 0\nreturn bIsSocket\n\ndrawArrows: procedure expose g.\n  parse arg g,source\n  if isActor(source)\n  then do\n    children = getChildren(source)\n    do i = 1 to words(children)\n      target = word(children,i)\n      if isActor(target)\n      then do /* we can draw an arrow between actors */\n        sClass = 'task'getAttribute(target,'taskid')\n        group = createElement('g')\n        call appendChild group,g\n        call setAttribute group,'class',sClass\n        call drawArrow group,source,target,'call'\n        call drawArrows group,target\n        call drawArrow group,target,source,'return'\n      end\n      else do\n        call drawArrows g,target\n      end\n    end\n  end\n  else do\n    children = getChildren(caller)\n    do i = 1 to words(children)\n      child = word(children,i)\n      call drawArrows g,child\n    end\n  end\nreturn\n\nisActor: procedure expose g.\n  parse arg node\n  bIsActor = getActorName(node) <> '' | getNodeName(node) = 'task'\nreturn bIsActor\n\ndrawArrow: procedure expose g.\n  parse arg g,source,target,sClass\n  /* the source actor invokes a function on the target actor */\n  bIsCall = sClass = 'call' /* ...else it is a return arrow */\n  if bIsCall\n  then nRow = getAttribute(target,'row')\n  else nRow = getAttribute(source,'exitrow')\n  if nRow = '' then return /* <event> has no 'return' arrow */\n  y = g.!FIRSTARROW + g.!LINEDEPTH * nRow\n  sSourceActor = getActorName(source)\n  sTargetActor = getActorName(target)\n  sFunction = getAttribute(target,'function')\n\n  /* Group the arrow, text and optional tooltip together */\n  arrow = createElement('g')\n  call appendChild arrow,g\n\n  /* Draw the elapsed time and task id of this <trace> entry...*/\n  sTaskId = getAttribute(target,'taskid')\n  if bIsCall\n  then do\n    call appendChild createComment(' 'sTargetActor),arrow\n    elapsed = createElement('text')\n    call appendChild elapsed,arrow\n    call setAttributes elapsed,'x',0,'y',y\n    nElapsed = getAttribute(target,'elapsed')\n    sElapsed = '+'left(format(nElapsed,,6),8,'0')' 'sTaskId\n    call appendChild createTextNode(sElapsed),elapsed\n  end\n\n  /* Draw the arrow for this call or return...*/\n  line = createElement('line')\n  call appendChild line,arrow\n  tooltip = createElement('desc') /* tool tip for this arrow */\n  call appendChild tooltip,line\n  if \\bIsCall\n  then call setAttribute line,'class',sClass\n  x1 = g.!X.sSourceActor\n  x2 = g.!X.sTargetActor\n  if x1 < x2 /* if left-to-right arrow */\n  then do\n    x1b = x1 + 2\n    x2 = x2 - 2\n    sDir = 'ltr'\n  end\n  else do\n    x1b = x1 - 2\n    x2 = x2 + 2\n    sDir = 'rtl'\n  end\n  call setAttributes line,,\n       'x1',x1,,\n       'y1',y,,\n       'x2',x2,,\n       'y2',y\n  if sSourceActor = sTargetActor\n  then do\n    sId = 'Circle'sTaskId\n    g.!MARKER.sId = 1 /* remember that we have used this marker */\n    call setAttribute line,'marker-end','url(#'sId')'\n  end\n  else do\n    sId = 'Arrow'sTaskId\n    g.!MARKER.sId = 1 /* remember that we have used this marker */\n    call setAttribute line,'marker-end','url(#'sId')'\n  end\n\n  /* Annotate the arrow...*/\n  annotation = createElement('text')\n  call appendChild annotation,arrow\n  call setAttributes annotation,,\n       'class','annotation' sDir,,\n       'x',x1b,,\n       'y',y-2\n  if bIsCall\n  then do /* annotate the invoking arrow */\n    sExtra = getDescriptionOfCall(target)\n    sModule = getAttribute(target,'module')\n    if getNodeName(target) = 'exception'\n    then call setAttribute annotation,'class','annotation error' sDir\n  end\n  else do /* annotate the returning arrow */\n    sExtra = ''\n    sModule = getAttribute(source,'module')\n    sFunction = getAttribute(source,'function')\n    sResponse = getAttribute(source,'response')\n    if sResponse = '' |,\n       sResponse = 'NORMAL' |,\n       sResponse = 'RESPONSE(OK)'\n    then sResponse = 'OK'\n    select\n      when sSourceActor = sTargetActor then,\n        sExtra = sFunction sResponse\n      when sResponse = 'OK' then,\n        sExtra = sResponse\n      otherwise,\n        sExtra = sResponse getAttribute(source,'reason')\n    end\n    if sResponse <> 'OK'\n    then call setAttribute annotation,'class','annotation error' sDir\n  end\n\n  /* Every arrow is annotated with the trace sequence number... */\n  tspanSeq = createElement('tspan')\n  call setAttribute tspanSeq,'class','seq'\n  if bIsCall\n  then nSeq = getAttribute(target,'seq')\n  else nSeq = getAttribute(source,'exitseq')\n  call appendChild createTextNode(nSeq),tspanSeq\n\n  /* Some arrows have extra info near the sequence number... */\n  if sDir = 'ltr' /* if left-to-right arrow */\n  then do /* e.g. 001234 LOAD_EXEC ------------------>  */\n    call appendChild tspanSeq,annotation\n    if sExtra <> ''\n    then do\n      tspanExtra = createElement('tspan')\n      call appendChild createTextNode(sExtra),tspanExtra\n      call appendChild tspanExtra,annotation\n    end\n  end\n  else do /* e.g. <----------- PROGRAM_NOT_FOUND 001235 */\n    if sExtra <> ''\n    then do\n      tspanExtra = createElement('tspan')\n      call appendChild createTextNode(sExtra),tspanExtra\n      call appendChild tspanExtra,annotation\n    end\n    call appendChild tspanSeq,annotation\n  end\n\n  /* Now create a tool tip for this line */\n  sTip = nSeq sExtra\n  select\n    when sModule = 'DFHSOCK' then do\n      if sFunction = 'SEND'\n      then sTip = sTip getSocketDetail(target,'on-entry')\n      if sFunction = 'RECEIVE'\n      then sTip = sTip getSocketDetail(source,'on-exit')\n    end\n    when getNodeName(target) = 'data' then do\n      sTip = sTip getDataDetail(target)\n    end\n    otherwise nop\n  end\n  call appendChild createTextNode(sTip),tooltip\nreturn\n\ngetSocketDetail: procedure expose g.\n  parse arg node,sContainer\n  detail = getChildrenByName(node,sContainer)\n  args = getChildrenByName(detail,'arg')\n  if words(args) < 2 then return ''\n  data = word(args,2) /* arg2 contains the packet payload */\n  sData = getText(getFirstChild(data)) /* ...a CDATA node */\nreturn sData\n\ngetDataDetail: procedure expose g.\n  parse arg node\n  sData = ''\n  detail = getChildrenByName(node,'detail')\n  if detail <> ''\n  then do\n    args = getChildrenByName(detail,'arg')\n    do i = 1 to words(args)\n      data = word(args,i)\n      sData = sData getText(getFirstChild(data))\n    end\n  end\nreturn sData\n\ngetDescriptionOfCall: procedure expose g.\n  parse arg node\n  sDesc = ''\n  sDomain = getAttribute(node,'domain')\n  sFunction = getAttribute(node,'function')\n  select\n    when sDomain = 'PG' then do\n      sProgram = getAttribute(node,'PROGRAM_NAME')\n      select\n        when sProgram <> '' then,\n          sDesc = '('sProgram')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'AP' then do\n      select\n        when sFunction = 'START_PROGRAM' then,\n          sDesc = '('getAttribute(node,'PROGRAM')')'\n        when sFunction = 'WRITE_TRANSIENT_DATA' then,\n          sDesc = '('getAttribute(node,'QUEUE')')'\n        when sFunction = 'READ_UPDATE_INTO' then,\n          sDesc = '('getAttribute(node,'FILE_NAME')')'\n        when sFunction = 'LOCATE' then,\n          sDesc = getAttribute(node,'TABLE')'(' ||,\n                  getAttribute(node,'KEY')')'\n        when wordpos(sFunction,'GET_QUEUE',\n                               'PUT_QUEUE',\n                               'DELETE_QUEUE') > 0 then,\n          sDesc = '('getAttribute(node,'RECORD_TYPE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'BA' then do\n      select\n        when wordpos(sFunction,'PUT_CONTAINER',\n                               'GET_CONTAINER_SET',\n                               'GET_CONTAINER_INTO',\n                               'DELETE_CONTAINER') > 0 then,\n          sDesc = '('getAttribute(node,'CONTAINER_NAME')')'\n        when wordpos(sFunction,'ADD_ACTIVITY',\n                               'LINK_ACTIVITY',\n                               'CHECK_ACTIVITY') > 0 then,\n          sDesc = '('getAttribute(node,'ACTIVITY_NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'WB' then do\n      select\n        when wordpos(sFunction,'PUT_QUEUE',\n                               'DELETE_QUEUE',\n                               'GET_QUEUE') > 0 then,\n          sDesc = '('getAttribute(node,'RECORD_TYPE')')'\n        when wordpos(sFunction,'START_BROWSE',\n                               'READ_NEXT',\n                               'END_BROWSE') > 0 then,\n          sDesc = '('getAttribute(node,'DATA_TYPE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'SM' then do\n      select\n        when sFunction = 'GETMAIN' then do\n            if hasAttribute(node,'STORAGE_CLASS')\n            then do\n              xLen = getAttribute(node,'GET_LENGTH')\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'STORAGE_CLASS'),\n                      \"LENGTH=X'\"xLen\"' (\"x2d(xLen)')',\n                      getAttribute(node,'REMARK')\n            end\n            else,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      'SUBPOOL',\n                      getAttribute(node,'REMARK')\n        end\n        when sFunction = 'FREEMAIN' then do\n          select\n            when hasAttribute(node,'STORAGE_CLASS') then,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'STORAGE_CLASS'),\n                      getAttribute(node,'REMARK')\n            when hasAttribute(node,'SUBPOOL_TOKEN') then,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      'SUBPOOL',\n                      getAttribute(node,'REMARK')\n            otherwise,\n              sDesc = getAttribute(node,'ADDRESS'),\n                      getAttribute(node,'REMARK')\n          end\n        end\n        otherwise nop\n      end\n    end\n    when sDomain = 'DD' then do\n      select\n        when sFunction = 'LOCATE' then,\n          sDesc = getAttribute(node,'DIRECTORY_NAME')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'TS' then do\n      select\n        when wordpos(sFunction,'MATCH',\n                               'DELETE',\n                               'READ_INTO',\n                               'READ_SET',\n                               'READ_AUX_DATA',\n                               'WRITE') > 0 then,\n          sDesc = 'QUEUE('getAttribute(node,'QUEUE_NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'XS' then do\n      select\n        when sFunction = 'CHECK_CICS_RESOURCE' then,\n          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,\n                  getAttribute(node,'RESOURCE')') ACCESS(' ||,\n                  getAttribute(node,'ACCESS')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'XM' then do\n      select\n        when sFunction = 'ATTACH' then,\n          sDesc = 'TRANS('getAttribute(node,'TRANSACTION_ID')')'\n        when sFunction = 'INQUIRE_MXT' then,\n          sDesc = 'LIMIT('getAttribute(node,'MXT_LIMIT')')',\n                  'ACTIVE('getAttribute(node,'CURRENT_ACTIVE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'EM' then do\n      select\n        when wordpos(sFunction,'FIRE_EVENT',\n                               'DEFINE_ATOMIC_EVENT',\n                               'DELETE_EVENT',\n                               'RETRIEVE_REATTACH_EVENT') > 0 then,\n          sDesc = '('getAttribute(node,'EVENT')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'DU' then do\n      select\n        when wordpos(sFunction,'TRANSACTION_DUMP',\n                               'COMMIT_TRAN_DUMPCODE',\n                               'LOCATE_TRAN_DUMPCODE') > 0 then,\n          sDesc = '('getAttribute(node,'TRANSACTION_DUMPCODE')')',\n                     getAttribute(node,'DUMPID')\n        when wordpos(sFunction,'INQUIRE_SYSTEM_DUMPCODE') > 0 then,\n          sDesc = '('getAttribute(node,'SYSTEM_DUMPCODE')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'CC' then do\n      select\n        when wordpos(sFunction,'GET') > 0 then,\n          sDesc = getAttribute(node,'TYPE')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'GC' then do\n      select\n        when wordpos(sFunction,'WRITE') > 0 then,\n          sDesc = getAttribute(node,'TYPE')'(' ||,\n                  getAttribute(node,'NAME')')'\n        otherwise nop\n      end\n    end\n    when sDomain = 'DS' then do\n      select\n        when wordpos(sFunction,'SUSPEND',\n                               'WAIT_MVS',\n                               'WAIT_OLDW') > 0 then,\n          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,\n                  getAttribute(node,'RESOURCE_NAME')')'\n        otherwise nop\n      end\n    end\n    otherwise nop\n  end\n  if getNodeName(node) = 'trace'\n  then sPrefix = sFunction\n  else sPrefix = getNodeName(node)':' sFunction\nreturn strip(sPrefix sDesc)\n\nsetOptions: procedure expose g.\n  parse arg sOptions\n  /* set default options... */\n  g.!OPTION.EVENT   = 1 /* Process input EVENT trace records? */\n  g.!OPTION.DATA    = 1 /* Process input DATA trace records? */\n  g.!OPTION.DETAIL  = 0 /* Output trace detail? */\n  g.!OPTION.XML     = 0 /* Output XML file? */\n  g.!OPTION.HTML    = 1 /* Output HTML file? */\n  g.!DOMAIN_FILTER = ''\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n      if length(sOption) = 2 then,\n        g.!DOMAIN_FILTER = g.!DOMAIN_FILTER sOption\n      else do\n        if left(sOption,2) = 'NO'\n        then do\n          sOption = substr(sOption,3)\n          g.!OPTION.sOption = 0\n        end\n        else g.!OPTION.sOption = 1\n      end\n  end\nreturn\n\nProlog:\n  if g.!ENV = 'TSO'\n  then g.!LF = '15'x\n  else g.!LF = '0A'x\n\n  /* Constants for generating line colors */\n  g.!HUE_INIT   = 151 /* random(0,360) */\n  g.!HUE_STEP   = 43  /* random(0,360) */\n  g.!SAT_MIN    = 1.0\n  g.!SAT_MAX    = 1.0\n  g.!SAT_LEVELS = 2\n  g.!SAT_STEP   = (g.!SAT_MAX - g.!SAT_MIN) / (g.!SAT_LEVELS - 1)\n  g.!VAL_MIN    = 0.5\n  g.!VAL_MAX    = 0.8\n  g.!VAL_LEVELS = 2\n  g.!VAL_STEP   = (g.!VAL_MAX - g.!VAL_MIN) / (g.!VAL_LEVELS - 1)\n\n  g.!DOMAIN.0 = 0 /* Number of domains */\n  call addDomain 'AP','Application Domain'\n  call addDomain 'BA','Business Application Manager Domain'\n  call addDomain 'CC','CICS Catalog Domain'\n  call addDomain 'GC','Global Catalog Domain'\n  call addDomain 'LC','Local Catalog Domain'\n  call addDomain 'DD','Directory Domain'\n  call addDomain 'DH','Document Handler Domain'\n  call addDomain 'DM','Domain Manager Domain'\n  call addDomain 'DP','Debugging Profiles Domain'\n  call addDomain 'DS','Dispatcher Domain'\n  call addDomain 'DU','Dump Domain'\n  call addDomain 'EJ','Enterprise Java Domain'\n  call addDomain 'EM','Event Manager Domain'\n  call addDomain 'EX','External CICS Interface Domain'\n  call addDomain 'EI','External CICS Interface over TCP/IP Domain'\n  call addDomain 'FT','Feature Domain'\n  call addDomain 'II','IIOP Domain'\n  call addDomain 'KE','Kernel Domain'\n  call addDomain 'LD','Loader Domain'\n  call addDomain 'LG','Log Manager Domain'\n  call addDomain 'LM','Lock Manager Domain'\n  call addDomain 'ME','Message Domain'\n  call addDomain 'MN','Monitoring Domain'\n  call addDomain 'NQ','Enqueue Domain'\n  call addDomain 'OT','Object Transaction Domain'\n  call addDomain 'PA','Parameter Manager Domain'\n  call addDomain 'PG','Program Manager Domain'\n  call addDomain 'PI','Pipeline Manager Domain'\n  call addDomain 'PT','Partner Domain'\n  call addDomain 'RM','Recovery Manager Domain'\n  call addDomain 'RX','RRMS Domain'\n  call addDomain 'RZ','Request Streams Domain'\n  call addDomain 'SH','Scheduler Domain'\n  call addDomain 'SJ','Java Virtual Machine Domain'\n  call addDomain 'SM','Storage Manager Domain'\n  call addDomain 'SO','Socket Domain'\n  call addDomain 'ST','Statistics Domain'\n  call addDomain 'TI','Timer Domain'\n  call addDomain 'TR','Trace Domain'\n  call addDomain 'TS','Temporary Storage Domain'\n  call addDomain 'US','User Domain'\n  call addDomain 'WB','Web Domain'\n  call addDomain 'XM','Transaction Manager Domain'\n  call addDomain 'XS','Security Manager Domain'\nreturn\n\naddDomain: procedure expose g.\n  parse arg sDomain,sDesc\n  if g.!DOMAIN.sDomain = ''\n  then do\n    nDomain = g.!DOMAIN.0       /* Number of domains */\n    nDomain = nDomain + 1\n    g.!DOMAIN.sDomain = sDesc   /* e.g. g.!DOMAIN.AP = 'App Domain'  */\n    g.!DOMAIN.nDomain = sDomain /* e.g. g.!DOMAIN.1 = 'AP'           */\n    g.!DOMAIN.0 = nDomain\n  end\nreturn\n\n/* Embed the svg in an html file to allow the browser to scroll it */\ncreateHTML: procedure expose g.\n  html = openFile(g.!FILEHTM,'OUTPUT')\n  if g.!rc = 0\n  then do\n    say 'AUX010I Creating' g.!FILEHTM\n    queue '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0',\n          'Transitional//EN\">'\n    queue '<html>'\n    queue '  <body>'\n    queue '    <object data=\"'g.!FILESVG'\"',\n                      'width=\"'g.!WIDTH'\"',\n                      'height=\"'g.!HEIGHT'\"',\n                      'type=\"image/svg+xml\"></object>'\n    queue '  </body>'\n    queue '</html>'\n    do queued()\n      parse pull sLine\n      call putLine html,sLine\n    end\n    rc = closeFile(html)\n    say 'AUX011I Created' g.!FILEHTM\n  end\n  else do\n    say 'AUX012E Could not create' g.!FILEHTM'. Return code' g.!rc\n  end\nreturn\n\nEpilog: procedure expose g.\nreturn\n\n\ngetValidAttributeName: procedure expose g.\n  parse arg sName\n  sName = space(sName,0)\n  sName = strip(sName,'LEADING','-')\n  if datatype(left(sName,1),'WHOLE')\n  then sName = 'X'sName /* must start with an alphabetic */\nreturn sName\n\n\nappendDetail: procedure expose g.\n  parse arg e,sName\n  x = createElement(sName)\n  call appendChild x,e\n  sData = ''\n  do i = 2 to g.!ENTRYDATA.0\n    sLine = strip(g.!ENTRYDATA.i,'LEADING')\n    parse var sLine nArg'-0000 '\n    if datatype(nArg,'WHOLE')\n    then do\n      if sData <> ''\n      then call appendDetailArg x,sData\n      parse var sLine nArg'-'sData\n      sData = sData || g.!LF\n    end\n    else do\n      sData = sData || sLine || g.!LF\n    end\n  end\n  if sData <> ''\n  then call appendDetailArg x,sData\nreturn\n\nappendDetailArg: procedure expose g.\n  parse arg parent,sData\n  a = createElement('arg')\n  call appendChild a,parent\n  call appendChild createCDATASection(g.!LF || sData),a\nreturn\n\n/*INCLUDED pretty.rexx */\n/*REXX 0117\n\n  Rexx XML Pretty Printer V1.8\n  Copyright (C) 2003-2005 Andrew J. Armstrong\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n  02111-1307  USA\n\n Author:\n Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - PRETTY                                                 **\n**                                                                   **\n** FUNCTION - Pretty printer. This demonstrates the XML parser by    **\n**            reformatting an xml input file.                        **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - pretty infile \u00ddoutfile\u00a8 (options...)                   **\n**                                                                   **\n**            Where,                                                 **\n**            infile   = Name of file to be parsed                   **\n**            outfile  = Name of file to store the pretty output in. **\n**                       The default is the console.                 **\n**            options  = NOBLANKS - Suppress whitespace-only nodes   **\n**                       DEBUG    - Display some debugging info      **\n**                       DUMP     - Display the parse tree           **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. You will have to either append the PARSEXML source  **\n**               manually to this demo source, or run this demo      **\n**               source through the REXXPP rexx pre-processor.       **\n**                                                                   **\n**               To use the pre-processor, run:                      **\n**                                                                   **\n**               rexxpp pretty prettypp                              **\n**                                                                   **\n**               ...and then run the resulting rexx procedure over   **\n**               an XML file of your choice:                         **\n**                                                                   **\n**               prettypp testxml \u00ddoutxml\u00a8                           **\n**                ...or...                                           **\n**               prettypp testxml \u00ddoutxml\u00a8 (noblanks                 **\n**                ...or...                                           **\n**               prettypp testxml \u00ddoutxml\u00a8 (noblanks dump            **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top pls)  **\n**            -------- -------- ------------------------------------ **\n**            20050920 AJA      Allow root node to be specified.     **\n**            20050907 AJA      Escape text of attribute values.     **\n**            20040706 AJA      Assume default indentation amount.   **\n**                              Allow output to a file.              **\n**            20031031 AJA      Fix escaping text.                   **\n**            20030911 AJA      Removed default filename value. You  **\n**                              must specify your own filename.      **\n**            20030905 AJA      Intial version.                      **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n\n  /* Initialise the parser */\n  call initParser sOptions /* DO THIS FIRST! Sets g. vars to null */\n\n  /* Open the specified file and parse it */\n  nParseRC = parseFile(sFileIn)\n\n  parse source g.!ENV .\n  if g.!ENV = 'TSO'\n  then do\n    address ISPEXEC\n    'CONTROL ERRORS RETURN'\n    g.!LINES = 0\n  end\n\n  call prettyPrinter sFileOut,2 /* 2 is the indentation amount */\n\nexit nParseRC\n\n/*-------------------------------------------------------------------*\n * An example of how to navigate the tree\n *-------------------------------------------------------------------*/\n\nprettyPrinter: procedure expose g.\n  parse arg sFileOut,g.!TAB,nRoot\n  if g.!TAB = '' then g.!TAB = 2 /* indentation amount */\n  if nRoot = '' then nRoot = getRoot()\n  g.!INDENT = 0\n  g.!FILEOUT = ''\n  if sFileOut <> ''\n  then do\n    g.!FILEOUT = openFile(sFileOut,'OUTPUT')\n    if g.!rc = 0\n    then say 'PRP001I Creating' sFileOut\n    else do\n      say 'PRP002E Could not create' sFileOut'. Writing to console...'\n      g.!FILEOUT = '' /* null handle means write to console */\n    end\n  end\n\n  call _setDefaultEntities\n\n  call emitProlog\n  g.!INDENT = -g.!TAB\n  call showNode nRoot\n\n  if g.!FILEOUT <> ''\n  then do\n    say 'PRP002I Created' sFileOut\n    rc = closeFile(g.!FILEOUT)\n  end\nreturn\n\n\nemitProlog: procedure expose g.\n  if g.?xml.version = ''\n  then sVersion = '1.0'\n  else sVersion = g.?xml.version\n  if g.?xml.encoding = ''\n  then sEncoding = 'UTF-8'\n  else sEncoding = g.?xml.encoding\n  if g.?xml.standalone = ''\n  then sStandalone = 'yes'\n  else sStandalone = g.?xml.standalone\n\n  g.!INDENT = 0\n  call Say '<?xml version=\"'sVersion'\"',\n                'encoding=\"'sEncoding'\"',\n              'standalone=\"'sStandalone'\"?>'\n\n  sDocType = getDocType()\n  if sDocType <> ''\n  then call Say '<!DOCTYPE' getName(getDocumentElement()) sDocType'>'\nreturn\n\nshowNode: procedure expose g.\n  parse arg node\n  g.!INDENT = g.!INDENT + g.!TAB\n  select\n    when isTextNode(node)    then call emitTextNode    node\n    when isCommentNode(node) then call emitCommentNode node\n    when isCDATA(node)       then call emitCDATA       node\n    otherwise                     call emitElementNode node\n  end\n  g.!INDENT = g.!INDENT - g.!TAB\nreturn\n\nsetPreserveWhitespace: procedure expose g.\n  parse arg bPreserve\n  g.!PRESERVEWS = bPreserve = 1\nreturn\n\nemitTextNode: procedure expose g.\n  parse arg node\n  if g.!PRESERVEWS = 1\n  then call Say escapeText(getText(node))\n  else call Say escapeText(removeWhitespace(getText(node)))\nreturn\n\nemitCommentNode: procedure expose g.\n  parse arg node\n  call Say '<!--'getText(node)' -->'\nreturn\n\nemitCDATA: procedure expose g.\n  parse arg node\n  call Say '<!\u00ddCDATA\u00dd'getText(node)'\u00a8\u00a8>'\nreturn\n\nemitElementNode: procedure expose g.\n  parse arg node\n  sName = getName(node)\n  sAttrs = ''\n  do i = 1 to getAttributeCount(node)\n    sAttrs = sAttrs getAttributeName(node,i)'=\"' ||,\n                    escapeText(getAttribute(node,i))'\"'\n  end\n  sChildren = getChildren(node)\n  if sChildren = ''\n  then do\n    if sAttrs = ''\n    then call Say '<'sName'/>'\n    else call Say '<'sName strip(sAttrs)'/>'\n  end\n  else do\n    if sAttrs = ''\n    then call Say '<'sName'>'\n    else call Say '<'sName strip(sAttrs)'>'\n    child = getFirstChild(node)\n    do while child <> ''\n      call showNode child\n      child = getNextSibling(child)\n    end\n    call Say '</'sName'>'\n  end\nreturn\n\nSay: procedure expose g.\n  parse arg sMessage\n  sLine = copies(' ',g.!INDENT)sMessage\n  if g.!FILEOUT = ''\n  then say sLine\n  else call putLine g.!FILEOUT,sLine\nreturn\n\n/*INCLUDED io.rexx */\n/*REXX 0102\n  Rexx I/O Routines V1.8\n  Copyright (C) 2003-2005 Andrew J. Armstrong\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n  02111-1307  USA\n\n Author:\n Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n*/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - IO                                                     **\n**                                                                   **\n** FUNCTION - Simple I/O routines.                                   **\n**                                                                   **\n** API      - The routines in this module are:                       **\n**                                                                   **\n**            openFile(filename,options,attrs)                       **\n**                Opens the specified file with the specified options**\n**                and returns a file handle to be used in other I/O  **\n**                operations. By default the file will be opened for **\n**                input. Specify 'OUTPUT' to open it for output.     **\n**                For TSO, you can specify any operand of the TSO    **\n**                ALLOCATE command in the third operand. For example:**\n**                rc = openFile('MY.FILE','OUTPUT','RECFM(F,B)'      **\n**                              'LRECL(80) BLKSIZE(27920)')          **\n**                                                                   **\n**            closeFile(handle)                                      **\n**                Closes the file specified by 'handle' (which was   **\n**                returned by the openFile() routine.                **\n**                                                                   **\n**            getLine(handle)                                        **\n**                Reads the next line from the file specified by     **\n**                'handle'.                                          **\n**                                                                   **\n**            putLine(handle,data)                                   **\n**                Appends the specified data to the file specified   **\n**                by 'handle'.                                       **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top pls)  **\n**            -------- -------- ------------------------------------ **\n**            20050930 AJA      Initial version.                     **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\n/*-------------------------------------------------------------------*\n * Open a file\n *-------------------------------------------------------------------*/\n\nopenFile: procedure expose g.\n  parse arg sFile,sOptions,sAttrs\n  hFile = ''\n  select\n    when g.!ENV = 'TSO' then do\n      bOutput = wordpos('OUTPUT',sOptions) > 0\n      bQuoted = left(sFile,1) = \"'\"\n      if bQuoted then sFile = strip(sFile,,\"'\")\n      parse var sFile sDataset'('sMember')'\n      if sMember <> '' then sFile = sDataset\n      if bQuoted then sFile = \"'\"sFile\"'\"\n      if bOutput\n      then 'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n      else 'LMINIT  DATAID(hFile) DATASET(&sFile)'\n      if sMember <> ''\n      then do /* Open a member of a PDS */\n        'LMOPEN  DATAID(&hFile) OPTION(INPUT)' /* Input initially */\n        /* ... can't update ISPF stats when opened for output */\n        g.!MEMBER.hFile = sMember\n        'LMMFIND DATAID(&hFile) MEMBER('sMember') STATS(YES)'\n        if bOutput\n        then do\n          if rc = 0\n          then g.!STATS.hFile = zlvers','zlmod','zlc4date\n          else g.!STATS.hFile = '1,0,0000/00/00'\n          'LMCLOSE DATAID(&hFile)'\n          'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        end\n      end\n      else do /* Open a sequential dataset */\n        'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        if rc <> 0 /* If dataset does not already exist... */\n        then do /* Create sequential dataset then open it */\n          'LMCLOSE DATAID(&hFile)'\n          'LMFREE  DATAID(&hFile)'\n          address TSO 'ALLOCATE DATASET('sFile') NEW CATALOG',\n                      'SPACE(5,15) TRACKS RECFM(V,B) LRECL(2048)',\n                      'BLKSIZE(27990)' sAttrs\n          if bOutput\n          then do\n            'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n            'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n          end\n          else do\n            'LMINIT  DATAID(hFile) DATASET(&sFile)'\n            'LMOPEN  DATAID(&hFile) OPTION(INPUT)'\n          end\n        end\n      end\n      g.!OPTIONS.hFile = sOptions\n      g.!rc = rc /* Return code from LMOPEN */\n    end\n    when g.!ENV = 'WIN32' then do\n      if wordpos('OUTPUT',sOptions) > 0\n      then junk = stream(sFile,'COMMAND','OPEN WRITE REPLACE')\n      else junk = stream(sFile,'COMMAND','OPEN READ')\n      hFile = sFile\n      if stream(sFile,'STATUS') = 'READY'\n      then g.!rc = 0\n      else g.!rc = 4\n    end\n    otherwise say 'RIO000E Unsupported platform:' g.!ENV'.',\n                  'Cannot open file \"'sFile'\".'\n  end\nreturn hFile\n\n/*-------------------------------------------------------------------*\n * Read a line from the specified file\n *-------------------------------------------------------------------*/\n\ngetLine: procedure expose g.\n  parse arg hFile\n  sLine = ''\n  select\n    when g.!ENV = 'TSO' then do\n      'LMGET DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN(nLine) MAXLEN(32768)'\n      g.!rc = rc\n      sLine = strip(sLine,'TRAILING')\n      if sLine = '' then sLine = ' '\n    end\n    when g.!ENV = 'WIN32' then do\n      g.!rc = 0\n      if chars(hFile) > 0\n      then sLine = linein(hFile)\n      else g.!rc = 4\n    end\n    otherwise g.!rc = 4\n  end\nreturn sLine\n\n/*-------------------------------------------------------------------*\n * Append a line to the specified file\n *-------------------------------------------------------------------*/\n\nputLine: procedure expose g.\n  parse arg hFile,sLine\n  select\n    when g.!ENV = 'TSO' then do\n      g.!LINES = g.!LINES + 1\n      'LMPUT DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN('length(sLine)')'\n    end\n    when g.!ENV = 'WIN32' then do\n      junk = lineout(hFile,sLine)\n      rc = 0\n    end\n    otherwise rc = 4\n  end\nreturn rc\n\n/*-------------------------------------------------------------------*\n * Close the specified file\n *-------------------------------------------------------------------*/\n\ncloseFile: procedure expose g.\n  parse arg hFile\n  rc = 0\n  select\n    when g.!ENV = 'TSO' then do\n      if g.!MEMBER.hFile <> '', /* if its a PDS */\n      & wordpos('OUTPUT',g.!OPTIONS.hFile) > 0 /* opened for output */\n      then do\n        parse value date('STANDARD') with yyyy +4 mm +2 dd +2\n        parse var g.!STATS.hFile zlvers','zlmod','zlc4date\n        zlcnorc  = min(g.!LINES,65535)   /* Number of lines   */\n        nVer = right(zlvers,2,'0')right(zlmod,2,'0')  /* vvmm */\n        nVer = right(nVer+1,4,'0')       /* vvmm + 1          */\n        parse var nVer zlvers +2 zlmod +2\n        if zlc4date = '0000/00/00'\n        then zlc4date = yyyy'/'mm'/'dd   /* Creation date     */\n        zlm4date = yyyy'/'mm'/'dd        /* Modification date */\n        zlmtime  = time()                /* Modification time */\n        zluser   = userid()              /* Modification user */\n        'LMMREP DATAID(&hFile) MEMBER('g.!MEMBER.hFile') STATS(YES)'\n      end\n      'LMCLOSE DATAID(&hFile)'\n      'LMFREE  DATAID(&hFile)'\n    end\n    when g.!ENV = 'WIN32' then do\n      if stream(hFile,'COMMAND','CLOSE') = 'UNKNOWN'\n      then rc = 0\n      else rc = 4\n    end\n    otherwise rc = 4\n  end\nreturn rc\n/*INCLUDEZ io.rexx */\n/*INCLUDED parsexml.rexx */\n/*REXX 0118\n  Rexx XML Parser V1.8\n  Copyright (C) 2003-2005 Andrew J. Armstrong\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n  02111-1307  USA\n\n Author:\n Andrew J. Armstrong <andrew_armstrong@unwired.com.au>\n*/\n\n/**********************************************************************\n**                                                                   **\n** ALL CODE BELOW THIS POINT BELONGS TO THE XML PARSER. YOU MUST     **\n** APPEND IT TO ANY REXX SOURCE FILE THAT REQUIRES AN XML PARSING    **\n** CAPABILITY. SINCE REXX HAS NO 'LIBRARY' FUNCTIONALITY, A WAY TO   **\n** AVOID HAVING DIFFERENT VERSIONS OF THE PARSER IN EACH OF YOUR     **\n** REXX PROCS IS TO DYNAMICALLY APPEND A CENTRAL VERSION TO EACH OF  **\n** YOUR REXX PROCS BEFORE EXECUTION.                                 **\n**                                                                   **\n** THE EXACT PROCEDURE TO FOLLOW DEPENDS ON YOUR PLATFORM, BUT...    **\n** TO HELP YOU DO THIS, I HAVE INCLUDED A REXX PRE-PROCESSOR CALLED  **\n** REXXPP THAT CAN BE USED TO SEARCH FOR 'INCLUDE' DIRECTIVES AND    **\n** REPLACE THEM WITH THE SPECIFIED FILE CONTENTS. IT HAS BEEN TESTED **\n** ON TSO, AND ON WIN32 USING REGINA REXX VERSION 3.3.               **\n**                                                                   **\n**********************************************************************/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - PARSEXML                                               **\n**                                                                   **\n** FUNCTION - A Rexx XML parser. It is non-validating, so DTDs and   **\n**            XML schemas are ignored. Ok, DTD entities are processed**\n**            but that's all.                                        **\n**                                                                   **\n** USAGE    - 1. Initialize the parser by:                           **\n**                                                                   **\n**               call initParser \u00ddoptions...\u00a8                        **\n**                                                                   **\n**            2. Parse the XML file to build an in-memory model      **\n**                                                                   **\n**               returncode = parseFile('filename')                  **\n**                ...or...                                           **\n**               returncode = parseString('xml in a string')         **\n**                                                                   **\n**            3. Navigate the in-memory model with the DOM API. For  **\n**               example:                                            **\n**                                                                   **\n**               say 'The document element is called',               **\n**                                   getName(getDocumentElement())   **\n**               say 'Children of the document element are:'         **\n**               node = getFirstChild(getDocumentElement())          **\n**               do while node <> ''                                 **\n**                 if isElementNode(node)                            **\n**                 then say 'Element node:' getName(node)            **\n**                 else say '   Text node:' getText(node)            **\n**                 node = getNextSibling(node)                       **\n**               end                                                 **\n**                                                                   **\n**            4. Optionally, destroy the in-memory model:            **\n**                                                                   **\n**               call destroyParser                                  **\n**                                                                   **\n** INPUT    - An XML file containing:                                **\n**              1. An optional XML prolog:                           **\n**                 - 0 or 1 XML declaration:                         **\n**                     <?xml version=\"1.0\" encoding=\"...\" ...?>      **\n**                 - 0 or more comments, PIs, and whitespace:        **\n**                     <!-- a comment -->                            **\n**                     <?target string?>                             **\n**                 - 0 or 1 document type declaration. Formats:      **\n**                     <!DOCTYPE root SYSTEM \"sysid\">                **\n**                     <!DOCTYPE root PUBLIC \"pubid\" SYSTEM \"sysid\"> **\n**                     <!DOCTYPE root \u00ddinternal dtd\u00a8>                **\n**              2. An XML body:                                      **\n**                 - 1 Document element containing 0 or more child   **\n**                     elements. For example:                        **\n**                     <doc attr1=\"value1\" attr2=\"value2\"...>        **\n**                       Text of doc element                         **\n**                       <child1 attr1=\"value1\">                     **\n**                         Text of child1 element                    **\n**                       </child1>                                   **\n**                       More text of doc element                    **\n**                       <!-- an empty child element follows -->     **\n**                       <child2/>                                   **\n**                       Even more text of doc element               **\n**                     </doc>                                        **\n**                 - Elements may contain:                           **\n**                   Unparsed character data:                        **\n**                     <!\u00ddCDATA\u00dd...unparsed data...\u00a8\u00a8>               **\n**                   Entity references:                              **\n**                     &name;                                        **\n**                   Character references:                           **\n**                     &#nnnnn;                                      **\n**                     &#xXXXX;                                      **\n**              3. An XML epilog (which is ignored):                 **\n**                 - 0 or more comments, PIs, and whitespace.        **\n**                                                                   **\n** API      - The basic setup/teardown API calls are:                **\n**                                                                   **\n**            initParser \u00ddoptions\u00a8                                   **\n**                Initialises the parser's global variables and      **\n**                remembers any runtime options you specify. The     **\n**                options recognized are:                            **\n**                NOBLANKS - Suppress whitespace-only nodes          **\n**                DEBUG    - Display some debugging info             **\n**                DUMP     - Display the parse tree                  **\n**                                                                   **\n**            parseFile(filename)                                    **\n**                Parses the XML data in the specified filename and  **\n**                builds an in-memory model that can be accessed via **\n**                the DOM API (see below).                           **\n**                                                                   **\n**            parseString(text)                                      **\n**                Parses the XML data in the specified string.       **\n**                                                                   **\n**            destroyParser                                          **\n**                Destroys the in-memory model and miscellaneous     **\n**                global variables.                                  **\n**                                                                   **\n**          - In addition, the following utility API calls can be    **\n**            used:                                                  **\n**                                                                   **\n**            removeWhitespace(text)                                 **\n**                Returns the supplied text string but with all      **\n**                whitespace characters removed, multiple spaces     **\n**                replaced with single spaces, and leading and       **\n**                trailing spaces removed.                           **\n**                                                                   **\n**            removeQuotes(text)                                     **\n**                Returns the supplied text string but with any      **\n**                enclosing apostrophes or double-quotes removed.    **\n**                                                                   **\n**            escapeText(text)                                       **\n**                Returns the supplied text string but with special  **\n**                characters encoded (for example, '<' becomes &lt;) **\n**                                                                   **\n**            toString(node)                                         **\n**                Walks the document tree (beginning at the specified**\n**                node) and returns a string in XML format.          **\n**                                                                   **\n** DOM API  - The DOM (ok, DOM-like) calls that you can use are      **\n**            listed below:                                          **\n**                                                                   **\n**            Document query/navigation API calls                    **\n**            -----------------------------------                    **\n**                                                                   **\n**            getRoot()                                              **\n**                Returns the node number of the root node. This     **\n**                can be used in calls requiring a 'node' argument.  **\n**                In this implementation, getDocumentElement() and   **\n**                getRoot() are (incorrectly) synonymous - this may  **\n**                change, so you should use getDocumentElement()     **\n**                in preference to getRoot().                        **\n**                                                                   **\n**            getDocumentElement()                                   **\n**                Returns the node number of the document element.   **\n**                The document element is the topmost element node.  **\n**                You should use this in preference to getRoot()     **\n**                (see above).                                       **\n**                                                                   **\n**            getName(node)                                          **\n**                Returns the name of the specified node.            **\n**                                                                   **\n**            getNodeValue(node)                                     **\n**            getText(node)                                          **\n**                Returns the text content of an unnamed node. A     **\n**                node without a name can only contain text. It      **\n**                cannot have attributes or children.                **\n**                                                                   **\n**            getAttributeCount(node)                                **\n**                Returns the number of attributes present on the    **\n**                specified node.                                    **\n**                                                                   **\n**            getAttributeMap(node)                                  **\n**                Builds a map of the attributes of the specified    **\n**                node. The map can be accessed via the following    **\n**                variables:                                         **\n**                  g.!ATTRIBUTE.0 = The number of attributes mapped.**\n**                  g.!ATTRIBUTE.n = The name of attribute 'n' (in   **\n**                                   order of appearance). n > 0.    **\n**                  g.!ATTRIBUTE.name = The value of the attribute   **\n**                                   called 'name'.                  **\n**                                                                   **\n**            getAttributeName(node,n)                               **\n**                Returns the name of the nth attribute of the       **\n**                specified node (1 is first, 2 is second, etc).     **\n**                                                                   **\n**            getAttributeNames(node)                                **\n**                Returns a space-delimited list of the names of the **\n**                attributes of the specified node.                  **\n**                                                                   **\n**            getAttribute(node,name)                                **\n**                Returns the value of the attribute called 'name' of**\n**                the specified node.                                **\n**                                                                   **\n**            getAttribute(node,n)                                   **\n**                Returns the value of the nth attribute of the      **\n**                specified node (1 is first, 2 is second, etc).     **\n**                                                                   **\n**            setAttribute(node,name,value)                          **\n**                Updates the value of the attribute called 'name'   **\n**                of the specified node. If no attribute exists with **\n**                that name, then one is created.                    **\n**                                                                   **\n**            setAttributes(node,name1,value1,name2,value2,...)      **\n**                Updates the attributes of the specified node. Zero **\n**                or more name/value pairs are be specified as the   **\n**                arguments.                                         **\n**                                                                   **\n**            hasAttribute(node,name)                                **\n**                Returns 1 if the specified node has an attribute   **\n**                with the specified name, else 0.                   **\n**                                                                   **\n**            getParentNode(node)                                    **\n**            getParent(node)                                        **\n**                Returns the node number of the specified node's    **\n**                parent. If the node number returned is 0, then the **\n**                specified node is the root node.                   **\n**                All nodes have a parent (except the root node).    **\n**                                                                   **\n**            getFirstChild(node)                                    **\n**                Returns the node number of the specified node's    **\n**                first child node.                                  **\n**                                                                   **\n**            getLastChild(node)                                     **\n**                Returns the node number of the specified node's    **\n**                last child node.                                   **\n**                                                                   **\n**            getChildNodes(node)                                    **\n**            getChildren(node)                                      **\n**                Returns a space-delimited list of node numbers of  **\n**                the children of the specified node. You can use    **\n**                this list to step through the children as follows: **\n**                  children = getChildren(node)                     **\n**                  say 'Node' node 'has' words(children) 'children' **\n**                  do i = 1 to words(children)                      **\n**                     child = word(children,i)                      **\n**                     say 'Node' child 'is' getName(child)          **\n**                  end                                              **\n**                                                                   **\n**            getChildrenByName(node,name)                           **\n**                Returns a space-delimited list of node numbers of  **\n**                the immediate children of the specified node which **\n**                are called 'name'. Names are case-sensitive.       **\n**                                                                   **\n**            getElementsByTagName(node,name)                        **\n**                Returns a space-delimited list of node numbers of  **\n**                the descendants of the specified node which are    **\n**                called 'name'. Names are case-sensitive.           **\n**                                                                   **\n**            getNextSibling(node)                                   **\n**                Returns the node number of the specified node's    **\n**                next sibling node. That is, the next node sharing  **\n**                the same parent.                                   **\n**                                                                   **\n**            getPreviousSibling(node)                               **\n**                Returns the node number of the specified node's    **\n**                previous sibline node. That is, the previous node  **\n**                sharing the same parent.                           **\n**                                                                   **\n**            getProcessingInstruction(name)                         **\n**                Returns the value of the PI with the specified     **\n**                target name.                                       **\n**                                                                   **\n**            getProcessingInstructionList()                         **\n**                Returns a space-delimited list of the names of all **\n**                PI target names.                                   **\n**                                                                   **\n**            getNodeType(node)                                      **\n**                Returns a number representing the specified node's **\n**                type. The possible values can be compared to the   **\n**                following global variables:                        **\n**                g.!ELEMENT_NODE                = 1                 **\n**                g.!ATTRIBUTE_NODE              = 2                 **\n**                g.!TEXT_NODE                   = 3                 **\n**                g.!CDATA_SECTION_NODE          = 4                 **\n**                g.!ENTITY_REFERENCE_NODE       = 5                 **\n**                g.!ENTITY_NODE                 = 6                 **\n**                g.!PROCESSING_INSTRUCTION_NODE = 7                 **\n**                g.!COMMENT_NODE                = 8                 **\n**                g.!DOCUMENT_NODE               = 9                 **\n**                g.!DOCUMENT_TYPE_NODE          = 10                **\n**                g.!DOCUMENT_FRAGMENT_NODE      = 11                **\n**                g.!NOTATION_NODE               = 12                **\n**                Note: as this exposes internal implementation      **\n**                details, it is best not to use this routine.       **\n**                Consider using isTextNode() etc instead.           **\n**                                                                   **\n**            isCDATA(node)                                          **\n**                Returns 1 if the specified node is an unparsed     **\n**                character data (CDATA) node, else 0. CDATA nodes   **\n**                are used to contain content that you do not want   **\n**                to be treated as XML data. For example, HTML data. **\n**                                                                   **\n**            isElementNode(node)                                    **\n**                Returns 1 if the specified node is an element node,**\n**                else 0.                                            **\n**                                                                   **\n**            isTextNode(node)                                       **\n**                Returns 1 if the specified node is a text node,    **\n**                else 0.                                            **\n**                                                                   **\n**            isCommentNode(node)                                    **\n**                Returns 1 if the specified node is a comment node, **\n**                else 0. Note: when a document is parsed, comment   **\n**                nodes are ignored. This routine returns 1 iff a    **\n**                comment node has been inserted into the in-memory  **\n**                document tree by using createComment().            **\n**                                                                   **\n**            hasChildren(node)                                      **\n**                Returns 1 if the specified node has one or more    **\n**                child nodes, else 0.                               **\n**                                                                   **\n**            getDocType(doctype)                                    **\n**                Gets the text of the <!DOCTYPE> prolog node.       **\n**                                                                   **\n**            Document creation/mutation API calls                   **\n**            ------------------------------------                   **\n**                                                                   **\n**            createElement(name)                                    **\n**                Returns the node number of a new empty element     **\n**                node with the specified name. An element node can  **\n**                have child nodes.                                  **\n**                                                                   **\n**            createTextNode(data)                                   **\n**                Returns the node number of a new text node. A text **\n**                node can *not* have child nodes.                   **\n**                                                                   **\n**            createCDATASection(data)                               **\n**                Returns the node number of a new Character Data    **\n**                (CDATA) node. A CDATA node can *not* have child    **\n**                nodes. CDATA nodes are used to contain content     **\n**                that you do not want to be treated as XML data.    **\n**                For example, HTML data.                            **\n**                                                                   **\n**            createComment(data)                                    **\n**                Returns the node number of a new commend node.     **\n**                A command node can *not* have child nodes.         **\n**                                                                   **\n**            appendChild(node,parent)                               **\n**                Appends the specified node to the end of the list  **\n**                of children of the specified parent node.          **\n**                                                                   **\n**            insertBefore(node,refnode)                             **\n**                Inserts node 'node' before the reference node      **\n**                'refnode'.                                         **\n**                                                                   **\n**            removeChild(node)                                      **\n**                Removes the specified node from its parent.        **\n**                                                                   **\n**            replaceChild(newnode,oldnode)                          **\n**                Replaces the old child 'oldnode' with the new      **\n**                child 'newnode'.                                   **\n**                                                                   **\n**            setAttribute(node,attrname,attrvalue)                  **\n**                Adds or replaces the attribute called 'attrname'   **\n**                on the specified node.                             **\n**                                                                   **\n**            removeAttribute(node,attrname)                         **\n**                Removes the attribute called 'attrname' from the   **\n**                specified node.                                    **\n**                                                                   **\n**            setDocType(doctype)                                    **\n**                Sets the text of the <!DOCTYPE> prolog node.       **\n**                                                                   **\n** NOTES    - 1. This parser creates global variables and so its     **\n**               operation may be severely jiggered if you update    **\n**               any of them accidentally (or on purpose). The       **\n**               variables you should avoid updating yourself are:   **\n**                                                                   **\n**               g.!ATTRIBUTE.n                                      **\n**               g.!ATTRIBUTE.name                                   **\n**               g.!ATTRSOK                                          **\n**               g.!DTD                                              **\n**               g.!ENDOFDOC                                         **\n**               g.!ENTITIES                                         **\n**               g.!ENTITY.name                                      **\n**               g.!FIRST.n                                          **\n**               g.!LAST.n                                           **\n**               g.!NAME.n                                           **\n**               g.!NEXT.n                                           **\n**               g.!NEXTID                                           **\n**               g.!OPTION.name                                      **\n**               g.!OPTIONS                                          **\n**               g.!PARENT.n                                         **\n**               g.!PI                                               **\n**               g.!PI.name                                          **\n**               g.!PREV.n                                           **\n**               g.!PUBLIC                                           **\n**               g.!ROOT                                             **\n**               g.!STACK                                            **\n**               g.!SYSTEM                                           **\n**               g.!TEXT.n                                           **\n**               g.!TYPE.n                                           **\n**               g.!WHITESPACE                                       **\n**               g.!XML                                              **\n**               g.?XML                                              **\n**               g.?XML.VERSION                                      **\n**               g.?XML.ENCODING                                     **\n**               g.?XML.STANDALONE                                   **\n**                                                                   **\n**            2. To reduce the incidence of name clashes, procedure  **\n**               names that are not meant to be part of the public   **\n**               API have been prefixed with '_'.                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top pls)  **\n**            -------- -------- ------------------------------------ **\n**            20051025 AJA      Now checks parentage before adding a **\n**                              child node:                          **\n**                              Fixed appendChild(id,parent)         **\n**                              Fixed insertBefore(id,ref)           **\n**            20051014 AJA      Added alias routine names to more    **\n**                              closely match the DOM specification. **\n**                              Specifically:                        **\n**                              Added getNodeName()                  **\n**                              Added getNodeValue()                 **\n**                              Added getParentNode()                **\n**                              Added getChildNodes()                **\n**                              Added hasChildNodes()                **\n**                              Added getElementsByTagName()      .  **\n**            20050919 AJA      Added setAttributes helper routine.  **\n**            20050914 AJA      Added createComment and isComment.   **\n**            20050913 AJA      Added get/setDocType routines.       **\n**            20050907 AJA      Added _setDefaultEntities routine.   **\n**            20050601 AJA      Added '250d'x to whitespace for TSO. **\n**            20050514 AJA      Removed getAttributes API call and   **\n**                              reworked attribute processing.       **\n**                              Added toString API call.             **\n**            20040706 AJA      Added creation/modification support. **\n**            20031216 AJA      Bugfix: _parseElement with no attrs  **\n**                              causes crash.                        **\n**            20031031 AJA      Correctly parse '/' in attributes.   **\n**                              Fixed entity resolution.             **\n**            20030912 AJA      Bugfix: Initialize sXmlData first.   **\n**                              Bugfix: Correctly parse a naked '>'  **\n**                              present in an attribute value.       **\n**                              Enhancement: DUMP option now displays**\n**                              first part of each text node.        **\n**            20030901 AJA      Intial version.                      **\n**                                                                   **\n**********************************************************************/\n\n  parse source . . sSourceFile .\n  say 'You cannot invoke this rexx by itself!'\n  say\n  say 'This rexx is a collection of subroutines to be called'\n  say 'from your own rexx procedures. You should either:'\n  say '  - Append this procedure to your own rexx procedure,'\n  say '    or,'\n  say '  - Append the following line to your rexx:'\n  say '    /* INCLUDE' sSourceFile '*/'\n  say '    ...and run the rexx preprocessor:'\n  say '    rexxpp myrexx myrexxpp'\n  say '    This will create myrexxpp by appending this file to myrexx'\nexit\n\n/*-------------------------------------------------------------------*\n * Set up global variables for the parser\n *-------------------------------------------------------------------*/\n\ninitParser: procedure expose g.\n  parse arg sOptions\n  g. = '' /* Note: stuffs up caller who may have set g. variables */\n  g.!OPTIONS = translate(sOptions)\n  sOptions = 'DEBUG DUMP NOBLANKS'\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    g.!OPTION.sOption = wordpos(sOption,g.!OPTIONS) > 0\n  end\n\n  parse source sSystem sInvocation sSourceFile\n  select\n    when sSystem = 'WIN32'  then g.!WHITESPACE = '090a0d'x\n    when sSystem = 'TSO'    then g.!WHITESPACE = '05250d'x\n    otherwise                    g.!WHITESPACE = ''\n  end\n\n  g.!LEADERS = '_:ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,\n                 'abcdefghijklmnopqrstuvwxyz'\n  g.!OTHERS  = g.!LEADERS'.-0123456789'\n\n  call _setDefaultEntities\n\n  /* Not all of the following node types are used... */\n  g.!ELEMENT_NODE                   = 1\n  g.!ATTRIBUTE_NODE                 = 2\n  g.!TEXT_NODE                      = 3\n  g.!CDATA_SECTION_NODE             = 4\n  g.!ENTITY_REFERENCE_NODE          = 5     /* NOT USED */\n  g.!ENTITY_NODE                    = 6     /* NOT USED */\n  g.!PROCESSING_INSTRUCTION_NODE    = 7     /* NOT USED */\n  g.!COMMENT_NODE                   = 8\n  g.!DOCUMENT_NODE                  = 9     /* NOT USED */\n  g.!DOCUMENT_TYPE_NODE             = 10    /* NOT USED */\n  g.!DOCUMENT_FRAGMENT_NODE         = 11    /* NOT USED */\n  g.!NOTATION_NODE                  = 12    /* NOT USED */\n\n  g.!ENDOFDOC = 0\nreturn\n\n/*-------------------------------------------------------------------*\n * Clean up parser\n *-------------------------------------------------------------------*/\n\ndestroyParser: procedure expose g.\n  /* Note: it would be easy to just \"drop g.\", but this could\n     possibly stuff up the caller who may be using other\n     \"g.\" variables...\n     todo: revisit this one (parser may have to 'own' g. names)\n  */\n  drop g.?XML g.!ROOT g.!SYSTEM g.!PUBLIC g.!DTD\n  do i = 1 to words(g.!PI)\n    sName = word(g.!PI,i)\n    drop g.!PI.sName\n  end\n  drop g.!PI\n  do i = 1 to words(g.!ENTITIES)\n    sName = word(g.!ENTITIES,i)\n    drop g.!ENTITY.sName\n  end\n  drop g.!ENTITIES\n  call _setDefaultEntities\n  if datatype(g.!NEXTID,'WHOLE')\n  then do\n    do i = 1 to g.!NEXTID\n      drop g.!PARENT.i g.!FIRST.i g.!LAST.i g.!PREV.i,\n           g.!NEXT.i g.!NAME.i g.!TEXT.i\n    end\n  end\n  drop g.!NEXTID g.!STACK g.!ENDOFDOC\nreturn\n\n\n/*-------------------------------------------------------------------*\n * Read a file into a string\n *-------------------------------------------------------------------*/\n\nparseFile: procedure expose g.\n  parse arg sFile\n  parse source sSystem sInvocation sSourceFile\n  sXmlData = ''\n  select\n    when sSystem = 'WIN32' then do\n      sXmlData = charin(sFile,,chars(sFile))\n    end\n    when sSystem = 'TSO' then do\n      address TSO\n      junk = OUTTRAP('junk.') /* Trap and discard messages */\n      'ALLOCATE DD(INPUT) DSN('sFile')'\n      'EXECIO * DISKR INPUT (FINIS'\n      'FREE DD(INPUT)'\n      address\n      do queued()\n        parse pull sLine\n        sXmlData = sXmlData || sLine\n      end\n      junk = OUTTRAP('OFF')\n    end\n    otherwise call _abort 'XML001E Unsupported system:' sSystem'.',\n                          'How do you read files?'\n  end\nreturn parseString(sXmlData)\n\n/*-------------------------------------------------------------------*\n * Parse a string containing XML\n *-------------------------------------------------------------------*/\n\nparseString: procedure expose g.\n  parse arg g.!XML\n  call _parseXmlDecl\n  do while pos('<',g.!XML) > 0\n    parse var g.!XML sLeft'<'sData\n    select\n      when left(sData,1) = '?'         then call _parsePI      sData\n      when left(sData,9) = '!DOCTYPE ' then call _parseDocType sData\n      when left(sData,3) = '!--'       then call _parseComment sData\n      otherwise                             call _parseElement sData\n    end\n  end\nreturn 0\n\n/*-------------------------------------------------------------------*\n * <?xml version=\"1.0\" encoding=\"...\" ...?>\n *-------------------------------------------------------------------*/\n\n_parseXmlDecl: procedure expose g.\n  if left(g.!XML,6) = '<?xml '\n  then do\n    parse var g.!XML '<?xml 'sXMLDecl'?>'g.!XML\n    g.?xml = space(sXMLDecl)\n    sTemp = _getNormalizedAttributes(g.?xml)\n    parse var sTemp 'version='g.?xml.version'ff'x\n    parse var sTemp 'encoding='g.?xml.encoding'ff'x\n    parse var sTemp 'standalone='g.?xml.standalone'ff'x\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * <?target string?>\n *-------------------------------------------------------------------*/\n\n_parsePI: procedure expose g.\n  parse arg '?'sProcessingInstruction'?>'g.!XML\n  call _setProcessingInstruction sProcessingInstruction\nreturn\n\n/*-------------------------------------------------------------------*\n * <!DOCTYPE root SYSTEM \"sysid\">\n * <!DOCTYPE root SYSTEM \"sysid\" \u00ddinternal dtd\u00a8>\n * <!DOCTYPE root PUBLIC \"pubid\" \"sysid\">\n * <!DOCTYPE root PUBLIC \"pubid\" \"sysid\" \u00ddinternal dtd\u00a8>\n * <!DOCTYPE root \u00ddinternal dtd\u00a8>\n *-------------------------------------------------------------------*/\n\n_parseDocType: procedure expose g.\n  parse arg '!DOCTYPE' sDocType'>'\n  if g.!ROOT <> ''\n  then call _abort 'XML002E Multiple \"<!DOCTYPE\" declarations'\n  if pos('\u00dd',sDocType) > 0\n  then do\n    parse arg '!DOCTYPE' sDocType'\u00dd'g.!DTD'\u00a8>'g.!XML\n    parse var sDocType g.!ROOT sExternalId\n    if sExternalId <> '' then call _parseExternalId sExternalId\n    g.!DTD = strip(g.!DTD)\n    call _parseDTD g.!DTD\n  end\n  else do\n    parse arg '!DOCTYPE' g.!ROOT sExternalId'>'g.!XML\n    if sExternalId <> '' then call _parseExternalId sExternalId\n  end\n  g.!ROOT = strip(g.!ROOT)\nreturn\n\n/*-------------------------------------------------------------------*\n * SYSTEM \"sysid\"\n * PUBLIC \"pubid\" \"sysid\"\n *-------------------------------------------------------------------*/\n\n_parseExternalId: procedure expose g.\n  parse arg sExternalIdType .\n  select\n    when sExternalIdType = 'SYSTEM' then do\n      parse arg . g.!SYSTEM\n      g.!SYSTEM = removeQuotes(g.!SYSTEM)\n    end\n    when sExternalIdType = 'PUBLIC' then do\n      parse arg . g.!PUBLIC g.!SYSTEM\n      g.!PUBLIC = removeQuotes(g.!PUBLIC)\n      g.!SYSTEM = removeQuotes(g.!SYSTEM)\n    end\n    otherwise do\n       parse arg sExternalEntityDecl\n       call _abort 'XML003E Invalid external entity declaration:',\n                   sExternalEntityDecl\n    end\n  end\nreturn\n\n\n/*-------------------------------------------------------------------*\n * <!ENTITY name \"value\">\n * <!ENTITY name SYSTEM \"sysid\">\n * <!ENTITY name PUBLIC \"pubid\" \"sysid\">\n * <!ENTITY % name pedef>\n * <!ELEMENT elementname contentspec>\n * <!ATTLIST elementname attrname attType DefaultDecl ...>\n * <!NOTATION name notationdef>\n *-------------------------------------------------------------------*/\n\n_parseDTD: procedure expose g.\n  parse arg sDTD\n  do while pos('<!',sDTD) > 0\n    parse var sDTD '<!'sDecl sName sValue'>'sDTD\n    select\n      when sDecl = 'ENTITY' then do\n        parse var sValue sWord1 .\n        select\n          when sName = '%'       then nop\n          when sWord1 = 'SYSTEM' then nop\n          when sWord1 = 'PUBLIC' then nop\n          otherwise do\n            sValue = _resolveEntities(removeQuotes(sValue))\n            call _setEntity sName,sValue\n          end\n        end\n      end\n      otherwise nop /* silently ignore other possibilities for now */\n    end\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * <!-- comment -->\n *-------------------------------------------------------------------*/\n\n_parseComment: procedure expose g.\n  parse arg sComment'-->'g.!XML\n  /* silently ignore comments */\nreturn\n\n/*-------------------------------------------------------------------*\n * <tag attr1=\"value1\" attr2=\"value2\" ...>...</tag>\n * <tag attr1=\"value1\" attr2=\"value2\" .../>\n *-------------------------------------------------------------------*/\n\n_parseElement: procedure expose g.\n  parse arg sXML\n\n  if g.!ENDOFDOC\n  then call _abort 'XML004E Only one top level element is allowed.',\n                  'Found:' subword(g.!XML,1,3)\n  call _startDocument\n\n  g.!XML = '<'sXML\n  do while pos('<',g.!XML) > 0 & \\g.!ENDOFDOC\n    parse var g.!XML sLeft'<'sBetween'>'g.!XML\n\n    if length(sLeft) > 0\n    then call _characters sLeft\n\n    if g.!OPTION.DEBUG\n    then say g.!STACK sBetween\n\n    select\n      when left(sBetween,8) = '!\u00ddCDATA\u00dd' then do\n        g.!XML = sBetween'>'g.!XML            /* ..back it out! */\n        parse var g.!XML '!\u00ddCDATA\u00dd'sBetween'\u00a8\u00a8>'g.!XML\n        call _characterData sBetween\n      end\n      when left(sBetween,3) = '!--' then do    /* <!-- comment --> */\n        if right(sBetween,2) <> '--'\n        then do  /* backup a bit and look for end-of-comment */\n          g.!XML = sBetween'>'g.!XML\n          if pos('-->',g.!XML) = 0\n          then call _abort 'XML005E End of comment missing after:',\n                          '<'g.!XML\n          parse var g.!XML sComment'-->'g.!XML\n        end\n      end\n      when left(sBetween,1) = '?' then do    /* <?target string?> */\n        parse var sBetween '?'sProcessingInstruction'?'\n        call _setProcessingInstruction sProcessingInstruction\n      end\n      when left(sBetween,1) = '/' then do    /* </tag> */\n        call _endElement substr(sBetween,2)   /* tag */\n      end\n      when  right(sBetween,1) = '/'  /* <tag ...attrs.../> */\n      then do\n        parse var sBetween sTagName sAttrs\n        if length(sAttrs) > 0                              /*20031216*/\n        then sAttrs = substr(sAttrs,1,length(sAttrs)-1)    /*20031216*/\n        else parse var sTagName sTagName'/'     /* <tag/>    20031216*/\n        sAttrs = _getNormalizedAttributes(sAttrs)\n        call _startElement sTagName sAttrs\n        call _endElement sTagName\n      end\n      otherwise do              /* <tag ...attrs ...> ... </tag>  */\n        parse var sBetween sTagName sAttrs\n        sAttrs = _getNormalizedAttributes(sAttrs)\n        if g.!ATTRSOK\n        then do\n          call _startElement sTagName sAttrs\n        end\n        else do /* back up a bit and look for the real end of tag */\n          g.!XML = '<'sBetween'&gt;'g.!XML\n          if pos('>',g.!XML) = 0\n          then call _abort 'XML017E Missing end tag for:' sTagName\n          /* reparse on next cycle avoiding premature '>'...*/\n        end\n      end\n    end\n  end\n\n  call _endDocument\nreturn\n\n_startDocument: procedure expose g.\n  g.!NEXTID = 0\n  g.!STACK = 0\nreturn\n\n_startElement:  procedure expose g.\n  parse arg sTagName sAttrs\n  id = _getNextId()\n  call _updateLinkage id\n  g.!NAME.id = sTagName\n  g.!TYPE.id = g.!ELEMENT_NODE\n  call _addAttributes id,sAttrs\n  cid = _pushElement(id)\nreturn\n\n_updateLinkage: procedure expose g.\n  parse arg id\n  parent = _peekElement()\n  g.!PARENT.id = parent\n  parentsLastChild = g.!LAST.parent\n  g.!NEXT.parentsLastChild = id\n  g.!PREV.id = parentsLastChild\n  g.!LAST.parent = id\n  if g.!FIRST.parent = ''\n  then g.!FIRST.parent = id\nreturn\n\n_characterData: procedure expose g.\n  parse arg sChars\n  id = _getNextId()\n  call _updateLinkage id\n  g.!TEXT.id = sChars\n  g.!TYPE.id = g.!CDATA_SECTION_NODE\nreturn\n\n_characters: procedure expose g.\n  parse arg sChars\n  sText = _resolveEntities(sChars)\n  if g.!OPTION.NOBLANKS & removeWhitespace(sText) = ''\n  then return\n  id = _getNextId()\n  call _updateLinkage id\n  g.!TEXT.id = sText\n  g.!TYPE.id = g.!TEXT_NODE\nreturn\n\n_endElement: procedure expose g.\n  parse arg sTagName\n  id = _popElement()\n  g.!ENDOFDOC = id = 1\n  if sTagName == g.!NAME.id\n  then nop\n  else call _abort,\n           'XML006E Expecting </'g.!NAME.id'> but found </'sTagName'>'\nreturn\n\n_endDocument: procedure expose g.\n  id = _peekElement()\n  if id <> 0\n  then call _abort 'XML007E End of document tag missing: 'id getName(id)\n  if g.!ROOT <> '' & g.!ROOT <> getName(getRoot())\n  then call _abort 'XML008E Root element name \"'getName(getRoot())'\"',\n                  'does not match DTD root \"'g.!ROOT'\"'\n\n  if g.!OPTION.DUMP\n  then call _displayTree\nreturn\n\n_displayTree: procedure expose g.\n  say   right('',4),\n        right('',4),\n        left('',12),\n        right('',6),\n        '--child--',\n        '-sibling-',\n        'attribute'\n  say   right('id',4),\n        right('type',4),\n        left('name',12),\n        right('parent',6),\n        right('1st',4),\n        right('last',4),\n        right('prev',4),\n        right('next',4),\n        right('1st',4),\n        right('last',4)\n  do id = 1 to g.!NEXTID\n    if g.!PARENT.id <> '' | id = 1 /* skip orphans */\n    then do\n      select\n        when g.!TYPE.id = g.!CDATA_SECTION_NODE then sName = '#CDATA'\n        when g.!TYPE.id = g.!TEXT_NODE          then sName = '#TEXT'\n        otherwise                                    sName = g.!NAME.id\n      end\n      say right(id,4),\n          right(g.!TYPE.id,4),\n          left(sName,12),\n          right(g.!PARENT.id,6),\n          right(g.!FIRST.id,4),\n          right(g.!LAST.id,4),\n          right(g.!PREV.id,4),\n          right(g.!NEXT.id,4),\n          right(g.!FIRSTATTR.id,4),\n          right(g.!LASTATTR.id,4),\n          left(removeWhitespace(g.!TEXT.id),19)\n    end\n  end\nreturn\n\n_pushElement: procedure expose g.\n  parse arg id\n  g.!STACK = g.!STACK + 1\n  nStackDepth = g.!STACK\n  g.!STACK.nStackDepth = id\nreturn id\n\n_popElement: procedure expose g.\n  n = g.!STACK\n  if n = 0\n  then id = 0\n  else do\n    id = g.!STACK.n\n    g.!STACK = g.!STACK - 1\n  end\nreturn id\n\n_peekElement: procedure expose g.\n  n = g.!STACK\n  if n = 0\n  then id = 0\n  else id = g.!STACK.n\nreturn id\n\n_getNextId: procedure expose g.\n  g.!NEXTID = g.!NEXTID + 1\nreturn g.!NEXTID\n\n_addAttributes: procedure expose g.\n  parse arg id,sAttrs\n  do while pos('ff'x,sAttrs) > 0\n    parse var sAttrs sAttrName'='sAttrValue 'ff'x sAttrs\n    sAttrName = removeWhitespace(sAttrName)\n    call _addAttribute id,sAttrName,sAttrValue\n  end\nreturn\n\n_addAttribute: procedure expose g.\n  parse arg id,sAttrName,sAttrValue\n  aid = _getNextId()\n  g.!TYPE.aid = g.!ATTRIBUTE_NODE\n  g.!NAME.aid = sAttrName\n  g.!TEXT.aid = _resolveEntities(sAttrValue)\n  g.!PARENT.aid = id\n  g.!NEXT.aid = ''\n  g.!PREV.aid = ''\n  if g.!FIRSTATTR.id = '' then g.!FIRSTATTR.id = aid\n  if g.!LASTATTR.id <> ''\n  then do\n    lastaid = g.!LASTATTR.id\n    g.!NEXT.lastaid = aid\n    g.!PREV.aid = lastaid\n  end\n  g.!LASTATTR.id = aid\nreturn\n\n/*-------------------------------------------------------------------*\n * Resolve attributes to an internal normalized form:\n *   name1=value1'ff'x name2=value2'ff'x ...\n * This makes subsequent parsing of attributes easier.\n * Note: this design may fail for certain UTF-8 content\n *-------------------------------------------------------------------*/\n\n_getNormalizedAttributes: procedure expose g.\n  parse arg sAttrs\n  g.!ATTRSOK = 0\n  sNormalAttrs = ''\n  parse var sAttrs sAttr'='sAttrs\n  do while sAttr <> ''\n    sAttr = removeWhitespace(sAttr)\n    select\n      when left(sAttrs,1) = '\"' then do\n        if pos('\"',sAttrs,2) = 0 /* if no closing \"   */\n        then return ''           /* then not ok       */\n        parse var sAttrs '\"'sAttrValue'\"'sAttrs\n      end\n      when left(sAttrs,1) = \"'\" then do\n        if pos(\"'\",sAttrs,2) = 0 /* if no closing '   */\n        then return ''           /* then not ok       */\n        parse var sAttrs \"'\"sAttrValue\"'\"sAttrs\n      end\n      otherwise return ''        /* no opening ' or \" */\n    end\n    sAttrValue = removeWhitespace(sAttrValue)\n    sNormalAttrs = sNormalAttrs sAttr'='sAttrValue'ff'x\n    parse var sAttrs sAttr'='sAttrs\n  end\n  g.!ATTRSOK = 1\n  /* Note: always returns a leading blank and is required by\n    this implementation */\nreturn _resolveEntities(sNormalAttrs)\n\n\n/*-------------------------------------------------------------------*\n *  entityref  := '&' entityname ';'\n *  entityname := ('_',':',letter) (letter,digit,'.','-','_',':')*\n *-------------------------------------------------------------------*/\n\n\n_resolveEntities: procedure expose g.\n  parse arg sText\n  if pos('&',sText) > 0\n  then do\n    sNewText = ''\n    do while pos('&',sText) > 0\n      parse var sText sLeft'&'sEntityRef\n      if pos(left(sEntityRef,1),'#'g.!LEADERS) > 0\n      then do\n        n = verify(sEntityRef,g.!OTHERS,'NOMATCH',2)\n        if n > 1 & substr(sEntityRef,n,1) = ';'\n        then do\n          sEntityName = left(sEntityRef,n-1)\n          sEntity = _getEntity(sEntityName)\n          sNewText = sNewText || sLeft || sEntity\n          sText = substr(sEntityRef,n+1)\n        end\n        else do\n          sNewText = sNewText || sLeft'&'\n          sText = sEntityRef\n        end\n      end\n      else do\n        sNewText = sNewText || sLeft'&'\n        sText = sEntityRef\n      end\n    end\n    sText = sNewText || sText\n  end\nreturn sText\n\n/*-------------------------------------------------------------------*\n * &entityname;\n * &#nnnnn;\n * &#xXXXX;\n *-------------------------------------------------------------------*/\n\n_getEntity: procedure expose g.\n  parse arg sEntityName\n  if left(sEntityName,1) = '#' /* #nnnnn  OR  #xXXXX */\n  then sEntity = _getCharacterEntity(sEntityName)\n  else sEntity = _getStringEntity(sEntityName)\nreturn sEntity\n\n/*-------------------------------------------------------------------*\n * &#nnnnn;\n * &#xXXXX;\n *-------------------------------------------------------------------*/\n\n_getCharacterEntity: procedure expose g.\n  parse arg sEntityName\n  if substr(sEntityName,2,1) = 'x'\n  then do\n    parse arg 3 xEntity\n    if datatype(xEntity,'XADECIMAL')\n    then sEntity = x2c(xEntity)\n    else call _abort,\n              'XML009E Invalid hexadecimal character reference: ',\n              '&'sEntityName';'\n  end\n  else do\n    parse arg 2 nEntity\n    if datatype(nEntity,'WHOLE')\n    then sEntity = d2c(nEntity)\n    else call _abort,\n              'XML010E Invalid decimal character reference:',\n              '&'sEntityName';'\n  end\nreturn sEntity\n\n/*-------------------------------------------------------------------*\n * &entityname;\n *-------------------------------------------------------------------*/\n\n_getStringEntity: procedure expose g.\n  parse arg sEntityName\n  if wordpos(sEntityName,g.!ENTITIES) = 0\n  then call _abort 'XML011E Unable to resolve entity &'sEntityName';'\n  sEntity = g.!ENTITY.sEntityName\nreturn sEntity\n\n_setDefaultEntities: procedure expose g.\n  g.!ENTITIES = ''\n  g.!ESCAPES = '<>&\"' || \"'\"\n  sEscapes = 'lt gt amp quot apos'\n  do i = 1 to length(g.!ESCAPES)\n    c = substr(g.!ESCAPES,i,1)\n    g.!ESCAPE.c = word(sEscapes,i)\n  end\n  call _setEntity 'amp','&'\n  call _setEntity 'lt','<'\n  call _setEntity 'gt','>'\n  call _setEntity 'apos',\"'\"\n  call _setEntity 'quot','\"'\nreturn\n\n_setEntity: procedure expose g.\n  parse arg sEntityName,sValue\n  if wordpos(sEntityName,g.!ENTITIES) = 0\n  then g.!ENTITIES = g.!ENTITIES sEntityName\n  g.!ENTITY.sEntityName = sValue\nreturn\n\n_setProcessingInstruction: procedure expose g.\n  parse arg sTarget sInstruction\n  if wordpos(sTarget,g.!PI) = 0\n  then g.!PI = g.!PI sTarget\n  g.!PI.sTarget = strip(sInstruction)\nreturn\n\n_abort: procedure expose g.\n  parse arg sMsg\n  say 'ABORT:' sMsg\n  call destroyParser\nexit 16\n\n_clearNode: procedure expose g.\n  parse arg id\n  g.!NAME.id       = ''\n  g.!PARENT.id     = ''\n  g.!FIRST.id      = ''\n  g.!LAST.id       = ''\n  g.!NEXT.id       = ''\n  g.!PREV.id       = ''\n  g.!TEXT.id       = ''\n  g.!TYPE.id       = ''\n  g.!FIRSTATTR.id  = ''\n  g.!LASTATTR.id   = ''\nreturn\n\n/*-------------------------------------------------------------------*\n * Utility API\n *-------------------------------------------------------------------*/\n\nremoveWhitespace: procedure expose g.\n  parse arg sData\nreturn space(translate(sData,'',g.!WHITESPACE))\n\nremoveQuotes: procedure expose g.\n  parse arg sValue\n  c = left(sValue,1)\n  select\n    when c = '\"' then parse var sValue '\"'sValue'\"'\n    when c = \"'\" then parse var sValue \"'\"sValue\"'\"\n    otherwise nop\n  end\nreturn sValue\n\n/*-------------------------------------------------------------------*\n * Document Object Model ;-) API\n *-------------------------------------------------------------------*/\n\ngetRoot: procedure expose g.\nreturn 1\n\ngetDocumentElement: procedure expose g.\nreturn 1\n\ngetName: getNodeName: procedure expose g.\n  parse arg id\nreturn g.!NAME.id\n\ngetText: getNodeValue: procedure expose g.\n  parse arg id\nreturn g.!TEXT.id\n\ngetNodeType: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id\n\nisElementNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!ELEMENT_NODE\n\nisTextNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!TEXT_NODE\n\nisCommentNode: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!COMMENT_NODE\n\nisCDATA: procedure expose g.\n  parse arg id\nreturn g.!TYPE.id = g.!CDATA_SECTION_NODE\n\n/**\n * This is similar to the DOM API's NamedNodeMap concept, except that\n * the returned structure is built in global variables (so calling\n * it a second time will destroy the structure built on the first\n * call). The other difference is that you can access the attributes\n * by name or ordinal number. For example, g.!ATTRIBUTE.2 is the value\n * of the second attribute. If the second attribute was called 'x',\n * then you could also access it by g.!ATTRIBUTE.x (as long as x='x')\n * Note, g.!ATTRIBUTE.0 will always contain a count of the number of\n * attributes in the map.\n */\ngetAttributeMap: procedure expose g.\n  parse arg id\n  if datatype(g.!ATTRIBUTE.0,'WHOLE')\n  then do\n    do i = 1 to g.!ATTRIBUTE.0\n      sName = g.!ATTRIBUTE.i\n      drop g.!ATTRIBUTE.sName g.!ATTRIBUTE.i\n    end\n  end\n  g.!ATTRIBUTE.0 = 0\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  do i = 1 while aid <> 0\n    sName = g.!NAME.aid\n    sValue = g.!TEXT.aid\n    g.!ATTRIBUTE.0 = i\n    g.!ATTRIBUTE.i = sName\n    g.!ATTRIBUTE.sName = sValue\n  end\nreturn\n\ngetAttributeCount: procedure expose g.\n  parse arg id\n  nAttributeCount = 0\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  do while aid <> ''\n    nAttributeCount = nAttributeCount + 1\n    aid = g.!NEXT.aid /* id of next attribute */\n  end\nreturn nAttributeCount\n\ngetAttributeNames: procedure expose g.\n  parse arg id\n  sNames = ''\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  do while aid <> ''\n    sNames = sNames g.!NAME.aid\n    aid = g.!NEXT.aid /* id of next attribute */\n  end\nreturn strip(sNames)\n\ngetAttribute: procedure expose g.\n  parse arg id,sAttrName\n  sValue = ''\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  if aid <> ''\n  then do\n    n = 1\n    do while aid <> '' & (g.!NAME.aid <> sAttrName & n <> sAttrName)\n      aid = g.!NEXT.aid\n      n = n + 1\n    end\n    if g.!NAME.aid = sAttrName | n = sAttrName\n    then sValue = g.!TEXT.aid\n  end\nreturn sValue\n\ngetAttributeName: procedure expose g.\n  parse arg id,n\n  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */\n  sName = ''\n  if aid <> ''\n  then do\n    do i = 1 while aid <> '' & i < n\n      aid = g.!NEXT.aid\n    end\n    if i = n then sName = g.!NAME.aid\n  end\nreturn sName\n\nhasAttribute: procedure expose g.\n  parse arg id,sAttrName\n  bHasAttribute = 0\n  aid = g.!FIRSTATTR.id\n  if aid <> ''\n  then do\n    do while aid <> '' & g.!NAME.aid <> sAttrName\n      aid = g.!NEXT.aid\n    end\n    bHasAttribute = g.!NAME.aid = sAttrName\n  end\nreturn bHasAttribute\n\ngetParent: getParentNode: procedure expose g.\n  parse arg id\nreturn g.!PARENT.id\n\ngetFirstChild: procedure expose g.\n  parse arg id\nreturn g.!FIRST.id\n\ngetLastChild: procedure expose g.\n  parse arg id\nreturn g.!LAST.id\n\ngetChildren: getChildNodes: procedure expose g.\n  parse arg id\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    ids = ids id\n    id = getNextSibling(id)\n  end\nreturn strip(ids)\n\ngetChildrenByName: procedure expose g.\n  parse arg id,sName\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    if getName(id) = sName\n    then ids = ids id\n    id = getNextSibling(id)\n  end\nreturn strip(ids)\n\ngetElementsByTagName: procedure expose g.\n  parse arg id,sName\n  ids = ''\n  id = getFirstChild(id)\n  do while id <> ''\n    if getName(id) = sName\n    then ids = ids id\n    ids = ids getElementsByTagName(id,sName)\n    id = getNextSibling(id)\n  end\nreturn space(ids)\n\ngetNextSibling: procedure expose g.\n  parse arg id\nreturn g.!NEXT.id\n\ngetPreviousSibling: procedure expose g.\n  parse arg id\nreturn g.!PREV.id\n\ngetProcessingInstruction: procedure expose g.\n  parse arg sTarget\nreturn g.!PI.sTarget\n\ngetProcessingInstructionList: procedure expose g.\nreturn g.!PI\n\nhasChildren: hasChildNodes: procedure expose g.\n  parse arg id\nreturn g.!FIRST.id <> ''\n\ncreateDocument: procedure expose g.\n  parse arg sName\n  if sName = ''\n  then call _abort,\n            'XML016E Must specify a root tag name:',\n            'createDocument('sName')'\n  call destroyParser\n  g.!NEXTID = 0\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!ELEMENT_NODE /* ...not strictly true */\n  g.!NAME.id = sName\n  g.!PARENT.id = 0\nreturn id\n\ncreateElement: procedure expose g.\n  parse arg sName\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!ELEMENT_NODE\n  g.!NAME.id = sName\nreturn id\n\ncreateCDATASection: procedure expose g.\n  parse arg sCharacterData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!CDATA_SECTION_NODE\n  g.!TEXT.id = sCharacterData\nreturn id\n\ncreateTextNode: procedure expose g.\n  parse arg sData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!TEXT_NODE\n  g.!TEXT.id = sData\nreturn id\n\nappendChild: procedure expose g.\n  parse arg id, parent\n  if g.!TYPE.parent <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML012E Can only add children to an ELEMENT node:',\n            'appendChild('id','parent')'\n  if g.!PARENT.id = ''\n  then g.!PARENT.id = parent\n  else call _abort,\n            'XML017E Node' getNodeName(id) 'is already a child of',\n            getNodeName(g.!PARENT.id)':',\n            'appendChild('id','parent')'\n  parentsLastChild = g.!LAST.parent\n  g.!NEXT.parentsLastChild = id\n  g.!PREV.id = parentsLastChild\n  g.!LAST.parent = id\n  if g.!FIRST.parent = ''\n  then g.!FIRST.parent = id\nreturn\n\ninsertBefore: procedure expose g.\n  parse arg id, ref\n  parent = g.!PARENT.ref\n  if g.!TYPE.parent <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML012E Can only add children to an ELEMENT node:',\n            'insertBefore('id','ref')'\n  if g.!PARENT.id = ''\n  then g.!PARENT.id = parent\n  else call _abort,\n            'XML017E Node' getNodeName(id) 'is already a child of',\n            getNodeName(g.!PARENT.id)':',\n            'insertBefore('id','ref')'\n  g.!NEXT.id = ref\n  g.!PREV.ref = id\n  if g.!FIRST.parent = ref\n  then g.!FIRST.parent = id\nreturn\n\nremoveChild: procedure expose g.\n  parse arg id\n  parent = g.!PARENT.id\n  if g.!TYPE.parent <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML013E Can only remove children from an ELEMENT node:',\n            'removeChild('id')'\n  next = g.!NEXT.id\n  prev = g.!PREV.id\n  g.!NEXT.prev = next\n  g.!PREV.next = prev\n  if g.!FIRST.parent = id\n  then g.!FIRST.parent = next\n  if g.!LAST.parent = id\n  then g.!LAST.parent = prev\n  call _clearNode id\nreturn\n\nreplaceChild: procedure expose g.\n  parse arg id, extant\n  parent = g.!PARENT.extant\n  if g.!TYPE.parent <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML014E Can only replace children of an ELEMENT node:',\n            'replaceChild('id','extant')'\n  g.!PARENT.id = parent\n  g.!NEXT.id = g.!NEXT.extant\n  g.!PREV.id = g.!PREV.extant\n  if g.!FIRST.parent = extant\n  then g.!FIRST.parent = id\n  if g.!LAST.parent = extant\n  then g.!LAST.parent = id\n  call _clearNode extant\nreturn\n\nsetAttribute: procedure expose g.\n  parse arg id,sAttrName,sValue\n  if g.!TYPE.id <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML015E Can only have attributes on an ELEMENT node:',\n            'setAttribute('id','sAttrName','sValue')'\n  aid = g.!FIRSTATTR.id\n  do while aid <> '' & g.!NAME.aid <> sAttrName\n    aid = g.!NEXT.aid\n  end\n  if aid <> '' & g.!NAME.aid = sAttrName\n  then g.!TEXT.aid = sValue\n  else call _addAttribute id,sAttrName,sValue\nreturn\n\nsetAttributes: procedure expose g.\n  parse arg id /* ,name1,value1,name2,value2,...,namen,valuen */\n  do i = 2 to arg() by 2\n    sAttrName = arg(i)\n    sValue = arg(i+1)\n    call setAttribute id,sAttrName,sValue\n  end\nreturn\n\nremoveAttribute: procedure expose g.\n  parse arg id,sAttrName\n  if g.!TYPE.id <> g.!ELEMENT_NODE\n  then call _abort,\n            'XML015E Can only have attributes on an ELEMENT node:',\n            'removetAttribute('id','sAttrName')'\n  aid = g.!FIRSTATTR.id\n  do while aid <> '' & g.!NAME.aid <> sAttrName\n    aid = g.!NEXT.aid\n  end\n  if aid <> '' & g.!NAME.aid = sAttrName\n  then do\n    prevaid = g.!PREV.aid\n    nextaid = g.!NEXT.aid\n    if prevaid = ''  /* if we are deleting the first attribute */\n    then g.!FIRSTATTR.id = nextaid /* make next attr the first */\n    else g.!NEXT.prevaid = nextaid /* link prev attr to next attr */\n    if nextaid = '' /* if we are deleting the last attribute */\n    then g.!LASTATTR.id  = prevaid /* make prev attr the last */\n    else g.!PREV.nextaid = prevaid /* link next attr to prev attr */\n    call _clearNode aid\n  end\nreturn\n\ntoString: procedure expose g.\n  parse arg node\n  if node = '' then node = getRoot()\n  if node = getRoot()\n  then sXML = _getProlog()_getNode(node)\n  else sXML = _getNode(node)\nreturn sXML\n\n_getProlog: procedure expose g.\n  if g.?xml.version = ''\n  then sVersion = '1.0'\n  else sVersion = g.?xml.version\n  if g.?xml.encoding = ''\n  then sEncoding = 'UTF-8'\n  else sEncoding = g.?xml.encoding\n  if g.?xml.standalone = ''\n  then sStandalone = 'yes'\n  else sStandalone = g.?xml.standalone\n  sProlog = '<?xml version=\"'sVersion'\"',\n            'encoding=\"'sEncoding'\"',\n            'standalone=\"'sStandalone'\"?>'\nreturn sProlog\n\n_getNode: procedure expose g.\n  parse arg node\n  select\n    when g.!TYPE.node = g.!ELEMENT_NODE then,\n         sXML = _getElementNode(node)\n    when g.!TYPE.node = g.!TEXT_NODE then,\n         sXML = escapeText(removeWhitespace(getText(node)))\n    when g.!TYPE.node = g.!ATTRIBUTE_NODE then,\n         sXML = getName(node)'=\"'escapeText(getText(node))'\"'\n    when g.!TYPE.node = g.!CDATA_SECTION_NODE then,\n         sXML = '<!\u00ddCDATA\u00dd'getText(node)'\u00a8\u00a8>'\n    otherwise sXML = '' /* TODO: throw an error here? */\n  end\nreturn sXML\n\n_getElementNode: procedure expose g.\n  parse arg node\n  sName = getName(node)\n  sAttrs = ''\n  attr = g.!FIRSTATTR.node\n  do while attr <> ''\n    sAttrs = sAttrs _getNode(attr)\n    attr = g.!NEXT.attr\n  end\n  if hasChildren(node)\n  then do\n    if sAttrs = ''\n    then sXML = '<'sName'>'\n    else sXML = '<'sName strip(sAttrs)'>'\n    child = getFirstChild(node)\n    do while child <> ''\n      sXML = sXML || _getNode(child)\n      child = getNextSibling(child)\n    end\n    sXML = sXML'</'sName'>'\n  end\n  else do\n    if sAttrs = ''\n    then sXML = '<'sName'/>'\n    else sXML = '<'sName strip(sAttrs)'/>'\n  end\nreturn sXML\n\nescapeText: procedure expose g.\n  parse arg sText\n  n = verify(sText,g.!ESCAPES,'MATCH')\n  if n > 0\n  then do\n    sNewText = ''\n    do while n > 0\n      sLeft = ''\n      n = n - 1\n      if n = 0\n      then parse var sText c +1 sText\n      else parse var sText sLeft +(n) c +1 sText\n      sNewText = sNewText || sLeft'&'g.!ESCAPE.c';'\n      n = verify(sText,g.!ESCAPES,'MATCH')\n    end\n    sText = sNewText || sText\n  end\nreturn sText\n\n/*-------------------------------------------------------------------*\n * SYSTEM \"sysid\"\n * PUBLIC \"pubid\" \"sysid\"\n *-------------------------------------------------------------------*/\nsetDocType: procedure expose g.\n  parse arg sDocType\n  g.!DOCTYPE = sDocType\nreturn\n\ngetDocType: procedure expose g.\nreturn g.!DOCTYPE\n\ncreateComment: procedure expose g.\n  parse arg sData\n  id = _getNextId()\n  call _clearNode id\n  g.!TYPE.id = g.!COMMENT_NODE\n  g.!TEXT.id = sData\nreturn id\n/*INCLUDEZ parsexml.rexx */\n/*INCLUDEZ pretty.rexx */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GPL": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x050\\x1f\\x01\\x050\\x1f\\x10@\\x01\\x1b\\x01\\x1b\\x00\\x00\\xe5\\xf1K\\xf2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-28T00:00:00", "modifydate": "2005-10-28T10:40:48", "lines": 283, "newlines": 283, "modlines": 0, "user": "V1.2"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "RUNJOB": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x050\\x1f\\x01\\x050\\x1f\\x10@\\x008\\x008\\x00\\x00\\xe5\\xf1K\\xf2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-28T00:00:00", "modifydate": "2005-10-28T10:40:48", "lines": 56, "newlines": 56, "modlines": 0, "user": "V1.2"}, "text": "//myjob   JOB  account,AUX2SVG,CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID,\n//             REGION=2M RESTART=STEP2\n//*\n//*-------------------------------------------------------------------*\n//*       Specify the Rexx library containing AUX2SVG here\n//*-------------------------------------------------------------------*\n//*\n//         SET REXXLIB=&SYSUID..FILE999.V10.CNTL\n//*\n//*-------------------------------------------------------------------*\n//*       Print CICS auxilliary trace to a dataset\n//*-------------------------------------------------------------------*\n//*\n//STEP1   EXEC PGM=DFHTU620 <-- Depends on CICS version\n//STEPLIB   DD DISP=SHR,DSN=SYS2.CICSTS.SDFHLOAD\n//DFHAUXT   DD DISP=SHR,DSN=SYS4.CICSTS.D1.DFHAUXT\n//          DD DISP=SHR,DSN=SYS4.CICSTS.D1.DFHBUXT\n//DFHAXPRT  DD DISP=(NEW,CATLG),DSN=&SYSUID..MY.TRACE,\n//             SPACE=(CYL,(10,10),RLSE),\n//             RECFM=VBA,LRECL=137,BLKSIZE=27990\n//DFHAXPRM  DD *\n//*\n//*-------------------------------------------------------------------*\n//*       Convert CICS auxilliary trace print file to SVG\n//*-------------------------------------------------------------------*\n//*\n//STEP2   EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=200\n//STEPLIB   DD DISP=SHR,DSN=SYS2.ISP.SISPLOAD\n//          DD DISP=SHR,DSN=SYS2.ISP.SISPLPA\n//ISPMLIB   DD DISP=SHR,DSN=SYS2.ISP.SISPMENU\n//ISPSLIB   DD DISP=SHR,DSN=SYS2.ISP.SISPSLIB\n//ISPTLIB   DD DISP=SHR,DSN=SYS2.ISP.SISPTENU\n//ISPPLIB   DD DISP=SHR,DSN=SYS2.ISP.SISPPENU\n//ISPPROF   DD DISP=(NEW,DELETE),SPACE=(CYL,(1,1,5)),UNIT=VIO,\n//             DCB=(LRECL=80,BLKSIZE=19040,DSORG=PO,RECFM=FB),\n//             DSN=&&PROF\n//ISPLOG    DD SYSOUT=*,DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSEXEC   DD DISP=SHR,DSN=&REXXLIB\n//SYSTSIN   DD *\nISPSTART CMD(%AUX2SVG MY.TRACE (PG SO) )\n/*\n//*\n//*-------------------------------------------------------------------*\n//*       Optionally OCOPY the svg file into HFS for serving out\n//*-------------------------------------------------------------------*\n//*\n//*STEP3   EXEC PGM=IKJEFT01,DYNAMNBR=100,REGION=5M,\n//*             PARM='OCOPY INDD(IN) OUTDD(OUT)'\n//*SYSTSPRT  DD SYSOUT=*\n//*SYSTSIN   DD DUMMY\n//*OUT       DD PATH='public/my.svg',\n//*             PATHOPTS=(OWRONLY,OCREAT,OTRUNC),PATHMODE=SIRWXU\n//*IN        DD DISP=SHR,DSN=&SYSUID..MY.SVG\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT725/FILE725.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT725", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}