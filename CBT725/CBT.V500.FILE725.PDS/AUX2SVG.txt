/*REXX 0154

  CICS Auxiliary Trace Visualizer V1.2
  Copyright (C) 2005 Andrew J. Armstrong

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307  USA

 Author:
 Andrew J. Armstrong <andrew_armstrong@unwired.com.au>
*/

/*REXX*****************************************************************
**                                                                   **
** NAME     - AUX2SVG                                                **
**                                                                   **
** FUNCTION - Creates a graphical representation of a CICS auxiliary **
**            trace printout by using Scalable Vector Graphics (SVG).**
**            The SVG markup represents the trace data in the form   **
**            of a Unified Modelling Language (UML) Sequence Diagram **
**            (or at least something quite like it).                 **
**                                                                   **
**            The 'actors' (for example, programs) are listed side-  **
**            by-side at the top of the diagram. A life line is      **
**            drawn vertically below each actor. Interactions        **
**            between actors (for example, calls and returns) are    **
**            represented as arrows drawn between the life lines.    **
**            The vertical axis is time. Each interaction is labeled **
**            on the left of the diagram with the relative time in   **
**            seconds since the start of the trace and the task id.  **
**            All the interactions for a task are assigned the same  **
**            unique color. Each interaction is annotated with the   **
**            trace sequence number, to enable you to refer back to  **
**            the original trace record for more detail, and a summ- **
**            ary of the call and return values. Exception responses **
**            are shown in red.                                      **
**                                                                   **
**            You choose which actors you are interested in by       **
**            specifying one or more domain names. For example, if   **
**            you want to visualize TCP/IP socket activity, you      **
**            might specify the PG (program) and SO (socket) domains:**
**                                                                   **
**              aux2svg mytrace.txt (PG SO                           **
**                                                                   **
**            If you want to examine a storage allocation problem    **
**            you might specify the SM (storage manager) domain:     **
**                                                                   **
**              aux2svg mytrace.txt (SM                              **
**                                                                   **
**            By default, ALL domains are selected but this can take **
**            a long time to process. It is best to restrict the     **
**            actors to a few domains that you are interested in.    **
**                                                                   **
** USAGE    - You can run this Rexx on an IBM mainframe, or on a PC  **
**            by using Regina Rexx from:                             **
**                                                                   **
**               http://regina-rexx.sourceforge.net                  **
**                                                                   **
**            If you run aux2svg on your mainframe, you should use   **
**            ftp to download the resulting svg and html files by:   **
**                                                                   **
**            ftp yourmainframe                                      **
**            youruserid                                             **
**            yourpassword                                           **
**            quote site sbdataconn=(IBM-1047,ISO8859-1)             **
**            get 'your.output.html' your.output.html                **
**            get 'your.output.svg'  your.output.svg                 **
**                                                                   **
**            It is easier to download the CICS trace print file and **
**            run aux2svg.rexx on your PC using Regina Rexx by:      **
**                                                                   **
**            rexx aux2svg.rexx your.trace.txt (options...           **
**                                                                   **
**            You can view the resulting SVG file using either:      **
**                                                                   **
**            1. Mozilla Firefox 1.5, or later, has native SVG rend- **
**               ering capability.                                   **
**                                                                   **
**            2. Microsoft Internet Explorer 6 with the Adobe SVG    **
**               Viewer plugin installed. The plugin is free from    **
**               www.adobe.com. Open the html file created by this   **
**               Rexx if you want to scroll the output in the        **
**               browser. Alternatively, you could publish the html  **
**               file on a web server and point your browser at that **
**               web server. Adobe SVG Viewer supports the following **
**               mouse/key actions:                                  **
**               LeftButton+Ctrl           Zoom in                   **
**               LeftButton+Ctrl+Shift     Zoom out                  **
**               LeftButton+Alt            Move                      **
**               LeftButton+Alt+Shift      Move constrained          **
**               Tool tips are not supported by this viewer yet.     **
**                                                                   **
**            3. Apache Batik Squiggle program with Sun Java 1.3 or  **
**               later installed. Batik is free from www.apache.org  **
**               To run Squiggle: java -jar batik-squiggle.jar       **
**               Squiggle supports the following mouse/key actions:  **
**               LeftButton+Ctrl (+drag)   Zoom in to rectangle      **
**               LeftButton+Shift (+drag)  Move                      **
**               RightButton+Ctrl (+drag)  Rotate                    **
**               RightButton+Shift (+drag) Zoom (in or out)          **
**               Squiggle shows tool tips when you hover the mouse   **
**               over items that have a tool tip defined.            **
**                                                                   **
**            4. Microsoft Visio 2003 or later.                      **
**                                                                   **
** SYNTAX   - AUX2SVG infile Ý(options...¨                           **
**                                                                   **
**            Where,                                                 **
**            infile   = Name of file to read auxtrace printout from.**
**            options  = DETAIL - Include hex data for each record.  **
**                       XML    - Create xml file from input file.   **
**                       HTML   - Create HTML file wrapper for SVG.  **
**                                This allows you to scroll the SVG  **
**                                in Internet Explorer.              **
**                       EVENT  - Process input EVENT trace records. **
**                       DATA   - Process input DATA trace records.  **
**                       To negate any of the above options, prefix  **
**                       the option with NO. For example, NOHTML.    **
**                       xx     - One or more 2-letter domain names  **
**                                that you want to process. The      **
**                                default is all trace domains and   **
**                                can be much slower. For example,   **
**                                to show socket activity you would  **
**                                specify PG and SO.                 **
**                                                                   **
** LOGIC    - 1. Create an in-memory <svg> document.                 **
**                                                                   **
**            2. Create an in-memory <auxtrace> element, but do not  **
**               connect it to the <svg> document.                   **
**                                                                   **
**            3. Scan the auxiliary trace output and convert each    **
**               pair of ENTRY/EXIT trace entries into a single XML  **
**               <trace> element. Add each <trace> element to the    **
**               <auxtrace> element and nest the <trace> elements.   **
**               The <auxtrace> element is a temporary representation**
**               of the auxiliary trace data and will be discarded   **
**               and/or written to an output file later.             **
**                                                                   **
**            4. Walk through the tree of <trace> elements and when  **
**               an interesting <trace> element is found, add        **
**               appropriate SVG markup to the <svg> element in order**
**               to visualize the <trace> element.                   **
**                                                                   **
**            5. Output an SVG document by using the PrettyPrinter   **
**               routine to 'print' the <svg> element to a file.     **
**                                                                   **
**            6. Output an XML document by using the PrettyPrinter   **
**               routine to 'print' the <auxtrace> element (only if  **
**               the XML option was specified).                      **
**                                                                   **
** EXAMPLE  - 1. To investigate a socket programming problem:        **
**                                                                   **
**               AUX2SVG auxtrace.txt (PG SO DETAIL XML              **
**                                                                   **
**               This will create the following files:               **
**                 auxtrace.svg  - SVG representation of trace.      **
**                 auxtrace.html - HTML to scroll the SVG.           **
**                 auxtrace.xml  - XML representation of trace.      **
**                                                                   **
** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **
**                                                                   **
** HISTORY  - Date     By       Reason (most recent at the top pls)  **
**            -------- -------- ------------------------------------ **
**            20060120 AJA      Conform to CSS2 requirements of      **
**                              Mozilla Firefox 1.5 (font-size must  **
**                              have a unit, stroke-dasharray must   **
**                              use a comma as a delimiter).         **
**            20051027 AJA      Draw colored arrow heads.            **
**            20051026 AJA      Set xml name space to 'svg' (oops!). **
**            20051025 AJA      Minor changes. Fixed bug in parsexml.**
**            20051018 AJA      Documentation corrections. Enhanced  **
**                              getDescriptionOfCall() for CC, GC,   **
**                              DS and AP domains.                   **
**            20051014 AJA      Intial version.                      **
**                                                                   **
**********************************************************************/

  parse arg sFileIn' ('sOptions')'

  numeric digits 16
  say 'AUX000I CICS Auxiliary Trace Visualizer v1.2'
  if sFileIn = ''
  then do
    say 'Syntax:'
    say '   aux2svg infile Ý(options¨'
    say
    say 'Where:'
    say '   infile  = CICS auxiliary trace print file'
    say '   options = DETAIL - Include hex data for each record.'
    say '             XML    - Create xml file from input file.'
    say '             HTML   - Create HTML file wrapper for SVG.'
    say '                      This allows you to scroll the SVG'
    say '                      in Internet Explorer.'
    say '             EVENT  - Include EVENT trace records.'
    say '             DATA   - Include DATA trace records.'
    say '             To negate of the above options, prefix the'
    say '             option with NO. For example, NOHTML.'
    say '             xx     - One or more 2-letter domain names'
    say '                      that you want to process. The'
    say '                      default is all trace domains and'
    say '                      can be much slower. For example,'
    say '                      to show socket activity you would'
    say '                      specify PG and SO.'
    exit
  end
  say 'AUX001I Scanning CICS auxiliary trace in' sFileIn

  sOptions = 'NOBLANKS' translate(sOptions)
  call initParser sOptions /* DO THIS FIRST! Sets g. vars to '' */

  parse source g.!ENV .
  if g.!ENV = 'TSO'
  then do
    address ISPEXEC
    'CONTROL ERRORS RETURN'
    g.!LINES = 0
  end

  call setFileNames sFileIn
  call setOptions sOptions
  call Prolog

  doc = createDocument('svg')

  call scanAuxTraceFile

  if g.!OPTION.DUMP
  then call _displayTree

  if g.!OPTION.XML
  then do
    call setDocType /* we don't need a doctype declaration */
    call prettyPrinter g.!FILEXML,,g.!AUXTRACE
  end

  call buildSVG

  call setPreserveWhitespace 1 /* to keep newlines in <desc> tags */
  call prettyPrinter g.!FILESVG

  if g.!OPTION.HTML
  then call createHTML

  call Epilog
exit

/* The auxtrace input filename is supplied by the user.
The names of the SVG, XML and HTML output files are automatically
generated from the input file filename. The generated file names also
depend on the operating system. Global variables are set as follows:
g.!FILETXT = name of input text file  (e.g. auxtrace.txt)
g.!FILESVG = name of output SVG file  (e.g. auxtrace.svg)
g.!FILEXML = name of output XML file  (e.g. auxtrace.xml)
g.!FILEHTM = name of output HTML file (e.g. auxtrace.html)
*/
setFileNames: procedure expose g.
  parse arg sFileIn
  if g.!ENV = 'TSO'
  then do
    parse var sFileIn sDataset'('sMember')'
    if sMember <> ''
    then do /* make output files members in the same PDS */
      sPrefix = strip(left(sMember,7)) /* room for a suffix char */
      sPrefix = translate(sPrefix) /* translate to upper case */
      g.!FILETXT = translate(sFileIn)
      /* squeeze the file extension into the member name...*/
      g.!FILESVG = sDataset'('strip(left(sPrefix'SVG',8))')'
      g.!FILEXML = sDataset'('strip(left(sPrefix'XML',8))')'
      g.!FILEHTM = sDataset'('strip(left(sPrefix'HTM',8))')'
    end
    else do /* make output files separate datasets */
      g.!FILETXT = translate(sFileIn)
      g.!FILESVG = sDataset'.SVG'
      g.!FILEXML = sDataset'.XML'
      g.!FILEHTM = sDataset'.HTML'
    end
  end
  else do
    sFileName  = getFilenameWithoutExtension(sFileIn)
    g.!FILETXT = sFileIn
    g.!FILESVG = sFileName'.svg'
    g.!FILEXML = sFileName'.xml'
    g.!FILEHTM = sFileName'.html'
  end
return

getFilenameWithoutExtension: procedure expose g.
  parse arg sFile
  parse value reverse(sFile) with '.'sRest
return reverse(sRest)

scanAuxTraceFile: procedure expose g.
  g.!AUXTRACE = createElement('auxtrace')
  g.!FILEIN = openFile(g.!FILETXT)
  g.!K = 0   /* Trace entry count */
  g.!KD = 0  /* Trace entry delta since last progress message */

  sLine = getLineContaining('CICS - AUXILIARY TRACE FROM')
  parse var sLine 'CICS - AUXILIARY TRACE FROM ',
                   sDate ' - APPLID' sAppl .
  call setAttributes g.!AUXTRACE,,
       'date',sDate,,
       'appl',sAppl

  g.!ROWS = 0
  bAllDomains = words(g.!DOMAIN_FILTER) = 0
  sEntry = getFirstTraceEntry()
  parse var g.!ENTRYDATA.1 '='g.!FIRSTSEQ'=' .
  do while g.!RC = 0
    parse var sEntry sDomain xType sModule sAction sParms
    if g.!FREQ.sDomain = ''
    then do
      g.!FREQ.sDomain = 0
      if g.!DOMAIN.sDomain = ''
      then say 'AUX002W Unknown domain "'sDomain'" found in' sEntry
    end
    g.!FREQ.sDomain = g.!FREQ.sDomain + 1
    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0
    then do
      parse var g.!ENTRYDATA.1 'TASK-'nTaskId . 'TIME-'sTime .,
                               'INTERVAL-'nInterval . '='nSeq'=' .
      if g.!TASK.nTaskId = '' /* if task is new */
      then do
        call initStack nTaskId
        e = createElement('task')
        call pushStack nTaskId,e
        g.!TASK.nTaskId = e
        call appendChild e,g.!AUXTRACE
        call setAttribute e,'taskid',nTaskId
      end
      task = g.!TASK.nTaskId

      nElapsed = getElapsed(sTime)
      select
        when sAction = 'ENTRY' then do
          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
          sParms = strip(sParms)
          select
            when left(sParms,1) = '-' then do /* if new style parms */
              /* ENTRY - FUNCTION(xxx) yyy(xxx) ... */
              sParms = space(strip(sParms,'LEADING','-'))
              if pos('FUNCTION(',sParms) > 0
              then do
                parse var sParms 'FUNCTION('sFunction')'
                n = wordpos('FUNCTION('sFunction')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
              end
              else do
                if left(sParms,1) = '*'
                /* e.g. '** Decode of parameter list failed **' */
                then sFunction = sParms
                else parse var sParms sFunction sParms
              end
            end
            when pos('REQ(',sParms) > 0 then do /* old style parms */
              /* ENTRY function                 REQ(xxx) ... */
              parse var sParms sFixed'REQ('sParms
              sParms = 'REQ('sParms
              parse var sFixed sFunction sRest
              sParms = 'PARMS('sRest')'
            end
            otherwise do /* old style parms */
              /* ENTRY function parms                        */
              /* ENTRY FUNCTION(function) parms              */
              if pos('FUNCTION(',sParms) > 0
              then do
                parse var sParms 'FUNCTION('sFunction')'
                n = wordpos('FUNCTION('sFunction')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
              end
              else do
                parse var sParms sFunction sParms
              end
            end
          end
          parent = peekStack(nTaskId)
          e = createElement('trace')
          call appendChild e,parent
          call setAttributes e,,
               'seq',nSeq,,
               'row',g.!ROWS,,
               'elapsed',nElapsed,,
               'interval',getInterval(sTime),,
               'domain',sDomain,,
               'module','DFH'sModule,,
               'function',sFunction,,
               'taskid',nTaskId
          call setParmAttributes e,sParms
          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1
          then call appendDetail e,'on-entry'
          call pushStack nTaskId,e
        end
        when sAction = 'EXIT' then do
          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
          sParms = strip(sParms)
          sReason = ''
          sAbend = ''
          select
            when left(sParms,1) = '-' then do
              /* EXIT - FUNCTION(xxx) yyy(xxx) ... */
              sParms = space(strip(sParms,'LEADING','-'))
              if pos('FUNCTION(',sParms) > 0
              then do
                parse var sParms 'FUNCTION('sFunction')',
                               1 'RESPONSE('sResponse')',
                               1 'REASON('sReason')',
                               1 'ABEND_CODE('sAbend')'
                n = wordpos('FUNCTION('sFunction')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
                n = wordpos('RESPONSE('sResponse')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
              end
              else do
                if left(sParms,1) = '*'
                /* e.g. '** Decode of parameter list failed **' */
                then do
                  sFunction = ''
                  sResponse = ''
                end
                else parse var sParms sFunction sResponse sParms
                sReason   = ''
                sAbend    = ''
              end
            end
            when pos('REQ(',sParms) > 0 then do
              /* EXIT function response         REQ(xxx) ... */
              /* EXIT response                  REQ(xxx) ... */
              parse var sParms sFixed'REQ('sParms
              sParms = 'REQ('sParms
              if words(sFixed) = 1
              then do
                sFunction = ''
                sResponse = strip(sFixed)
              end
              else do
                parse var sFixed sFunction sResponse .
              end
            end
            when pos('FUNCTION(',sParms) > 0 then do
              /* EXIT FUNCTION(xxx) RESPONSE(xxx) parms ...  */
                parse var sParms 'FUNCTION('sFunction')',
                               1 'RESPONSE('sResponse')'
                n = wordpos('FUNCTION('sFunction')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
                n = wordpos('RESPONSE('sResponse')',sParms)
                if n > 0 then sParms = delword(sParms,n,1)
            end
            otherwise do
              parse var sParms sFunction sParms
            end
          end /* select */
          parent = popStack(nTaskId)
          if parent <> g.!AUXTRACE
          then do
            call setAttributes parent,,
                 'exitrow',g.!ROWS,,
                 'response',sResponse,,
                 'exitseq',nSeq
            sCompoundReason = strip(sReason sAbend)
            if sCompoundReason <> ''
            then call setAttribute parent,'reason',sCompoundReason
            call setParmAttributes parent,sParms
          end
          if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1
          then call appendDetail parent,'on-exit'
        end
        when sAction = 'EVENT' then do
          if g.!OPTION.EVENT
          then do
            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
            sParms = space(strip(strip(sParms),'LEADING','-'))
            parse var sParms sFunction sParms
            parent = peekStack(nTaskId)
            e = createElement('event')
            call appendChild e,parent
            call setAttributes e,,
                 'seq',nSeq,,
                 'row',g.!ROWS,,
                 'elapsed',nElapsed,,
                 'interval',getInterval(sTime),,
                 'domain',sDomain,,
                 'module','DFH'sModule,,
                 'function',sFunction,,
                 'parms',sParms,,
                 'taskid',nTaskId
            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1
            then call appendDetail e,'detail'
          end
        end
        when sAction = 'CALL' then do
          sParms = space(strip(strip(sParms),'LEADING','-'))
          parse var sParms sFunction sParms
          parent = peekStack(nTaskId)
          e = createElement('call')
          call appendChild e,parent
          call setAttributes e,,
               'seq',nSeq,,
               'row',g.!ROWS,,
               'elapsed',nElapsed,,
               'interval',getInterval(sTime),,
               'domain',sDomain,,
               'module','DFH'sModule,,
               'function',sFunction,,
               'taskid',nTaskId
          call setParmAttributes e,sParms
        end
        when sAction = '*EXC*' then do
          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
          sParms = space(strip(sParms,'LEADING','-'))
          parse var sParms sFunction sParms
          parent = peekStack(nTaskId)
          e = createElement('exception')
          call appendChild e,parent
          call setAttributes e,,
               'seq',nSeq,,
               'row',g.!ROWS,,
               'elapsed',nElapsed,,
               'interval',getInterval(sTime),,
               'domain',sDomain,,
               'module','DFH'sModule,,
               'function',sFunction,,
               'parms',sParms,,
               'taskid',nTaskId
        end
        when sAction = 'DATA' then do
          if g.!OPTION.DATA
          then do
            g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
            sParms = space(strip(strip(sParms),'LEADING','-'))
            parse var sParms sFunction sParms
            parent = peekStack(nTaskId)
            e = createElement('data')
            call appendChild e,parent
            call setAttributes e,,
                 'seq',nSeq,,
                 'row',g.!ROWS,,
                 'elapsed',nElapsed,,
                 'interval',getInterval(sTime),,
                 'domain',sDomain,,
                 'module','DFH'sModule,,
                 'function',sFunction,,
                 'taskid',nTaskId
            if g.!OPTION.DETAIL & g.!ENTRYDATA.0 > 1
            then call appendDetail e,'detail'
          end
        end
        when sAction = 'RESUMED' then do
          g.!ROWS = g.!ROWS + 1 /* row to draw arrow on */
          sParms = space(strip(strip(sParms),'LEADING','-'))
          parse var sParms sFunction sParms
          parent = peekStack(nTaskId)
          e = createElement('resumed')
          call appendChild e,parent
          call setAttributes e,,
               'seq',nSeq,,
               'row',g.!ROWS,,
               'elapsed',nElapsed,,
               'interval',getInterval(sTime),,
               'domain',sDomain,,
               'module','DFH'sModule,,
               'function',sFunction,,
               'taskid',nTaskId
          call setParmAttributes e,sParms
        end
        when sAction = 'PC' then do
          /* this trace type does not seem to add any value */
        end
        otherwise do
          parent = peekStack(nTaskId)
          call appendChild createTextNode(sEntry),parent
          say 'AUX003E Unknown trace entry <'sAction'>:' sEntry
        end
      end
    end
    sEntry = getTraceEntry()
  end
  rc = closeFile(g.!FILEIN)
  say 'AUX004I Processed' g.!K-1 'trace entries'
  say 'AUX005I Domain processing summary:'
  do i = 1 to g.!DOMAIN.0
    sDomain = g.!DOMAIN.i
    sDesc   = g.!DOMAIN.sDomain
    if bAllDomains | wordpos(sDomain,g.!DOMAIN_FILTER) > 0
    then sFilter = 'Requested'
    else sFilter = '         '
    if g.!FREQ.sDomain > 0
    then sFound  = 'Found' right(g.!FREQ.sDomain,5)
    else sFound  = '           '
    say 'AUX006I   'sFilter sFound sDomain sDesc
  end
return

initStack: procedure expose g.
  parse arg task
  g.!T.task = 0         /* set top of stack index for task */
return

pushStack: procedure expose g.
  parse arg task,item
  tos = g.!T.task + 1   /* get new top of stack index for task */
  g.!E.task.tos = item  /* set new top of stack item */
  g.!T.task = tos       /* set new top of stack index */
return

popStack: procedure expose g.
  parse arg task
  tos = g.!T.task       /* get top of stack index for task */
  item = g.!E.task.tos  /* get item at top of stack */
  g.!T.task = max(tos-1,1)
return item

peekStack: procedure expose g.
  parse arg task
  tos = g.!T.task       /* get top of stack index for task */
  item = g.!E.task.tos  /* get item at top of stack */
return item

getLineContaining: procedure expose g.
  parse arg sSearchArg
  sLine = getLine(g.!FILEIN)
  do while g.!RC = 0 & pos(sSearchArg, sLine) = 0
    sLine = getLine(g.!FILEIN)
  end
return sLine

getNextLine: procedure expose g.
  sLine = getLine(g.!FILEIN)
  if g.!RC = 0
  then do
    cc = left(sLine,1)
    select
      when cc = '0' then sLine = '' /* ASA double space */
      when cc = '1' then do         /* ASA page eject */
        sLine = getLine(g.!FILEIN)  /* skip blank line after title */
        if sLine <> ''
        then say 'AUX007W Line after heading is not blank:' sLine
        sLine = getLine(g.!FILEIN)  /* read next data line */
      end
      when sLine = '<<<<  STARTING DATA FROM NEXT EXTENT  >>>>' then,
        sLine = ''
      otherwise nop
    end
  end
return sLine

getFirstTraceEntry: procedure expose g.
  sLine = getNextLine()
  parse var sLine sDomain xType sModule .
  do while g.!RC = 0 & length(sDomain) <> 2
    sLine = getNextLine()
    parse var sLine sDomain xType sModule .
  end
return getTraceEntry(sLine)

getTraceEntry: procedure expose g.
  parse arg sEntry
  /* The general format of a trace entry is something like:

Old style:
 dd tttt mmmm action ...fixed_width_stuff... parms...
                     moreparms...

               TASK-nnnnn ....timing info etc...........  =seqno=
                 1-0000  ...hex dump.... *...character dump...*
                 2-0000  ...hex dump.... *...character dump...*
                   0020  ...hex dump.... *...character dump...*
                         .
                         .
                 n-0000  ...hex dump.... *...character dump...*
                         .
                         .

New style:
 dd tttt mmmm action - parms...
                     moreparms...

               TASK-nnnnn ....timing info etc...........  =seqno=
                 1-0000  ...hex dump.... *...character dump...*
                 2-0000  ...hex dump.... *...character dump...*
                   0020  ...hex dump.... *...character dump...*
                         .
                         .
                 n-0000  ...hex dump.... *...character dump...*
                         .
                         .

  */
  sLine = getNextLine()
  do while g.!RC = 0 & left(strip(sLine),5) <> 'TASK-'
    sEntry = sEntry strip(sLine)
    sLine = getNextLine()
  end
  g.!ENTRYDATA.0 = 0
  do i = 1 while g.!RC = 0 & sLine <> ''
    g.!ENTRYDATA.i = sLine
    g.!ENTRYDATA.0 = i
    sLine = getNextLine()
  end
  g.!K = g.!K + 1
  g.!KD = g.!KD + 1
  if g.!KD >= 1000
  then do
    say 'AUX008I Processed' g.!K 'trace entries'
    g.!KD = 0
  end
return sEntry

getElapsed: procedure expose g.
  parse arg nHH':'nMM':'nSS
  nThisOffset = ((nHH*60)+nMM)*60+nSS
  if g.!FIRSTOFFSET = ''
  then g.!FIRSTOFFSET = nThisOffset
return nThisOffset - g.!FIRSTOFFSET

getInterval: procedure expose g.
  parse arg sTime
  nThisOffset = getElapsed(sTime) /* seconds from start of trace */
  if g.!PREVOFFSET = ''
  then nInterval = 0
  else nInterval = nThisOffset - g.!PREVOFFSET
  g.!PREVOFFSET = nThisOffset
return nInterval

setParmAttributes: procedure expose g.
  parse arg e,sParms
  if pos('(',sParms) > 0
  then do while sParms <> ''
    parse var sParms sName'('sValue')'sParms
    sName = getValidAttributeName(sName)
    if wordpos(sName,'FIELD-A FIELD-B') > 0
    then parse var sValue sValue .
    call setAttribute e,space(sName,0),strip(sValue)
  end
  else do
    if sParms <> ''
    then call setAttribute e,'parms',sParms
  end
return

buildSVG: procedure expose g.
  say 'AUX009I Building SVG'

  g.!LINEDEPTH = 12

  doc = getDocumentElement()
  call setDocType 'PUBLIC "-//W3C//DTD SVG 1.1//EN"',
                  '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"'

  call setAttributes doc,,
       'xmlns','http://www.w3.org/2000/svg',,
       'xmlns:xlink','http://www.w3.org/1999/xlink'

  title = createElement('title')
  call appendChild title,doc
  sAppl = getAttribute(g.!AUXTRACE,'appl')
  sDate = getAttribute(g.!AUXTRACE,'date')
  sTitle = 'CICS auxiliary trace of' sAppl 'captured on' sDate
  call appendChild createTextNode(sTitle),title

  call addTooltip doc,,
       'Created by CICS Auxiliary Trace Visualizer v1.2 by',
       'Andrew J. Armstrong (andrew_armstrong@unwired.com.au)'

  g.!STYLE = createElement('style')
  call appendChild g.!STYLE,doc

  call setAttribute g.!STYLE,'type','text/css'

  queue
  queue '.background  {fill:white;}'
  queue '.actors      {text-anchor:middle;' ||,
                      'fill:lemonchiffon;stroke:slateblue;}'
  queue '.lifeline    {stroke:yellowgreen;stroke-dasharray:5,2;' ||,
                      'fill:none;}'
  queue '.seq         {fill:gray;}'
  queue '.arrows      {stroke-width:2;fill:none;}'
  queue '.return      {stroke-dasharray:2,3;}'
  queue '.annotation  {stroke:none;font-size:6px;}'
  queue '.ltr         {text-anchor:start;}'
  queue '.rtl         {text-anchor:end;}'
  queue '.error       {fill:red;}'
  queue 'text.dump    {font-family:monospace;font-size:10px;}'
  queue 'text         {font-family:Arial;font-size:10px;fill:black;' ||,
                      'stroke:none;}'
  queue
  styles = createCDATASection(pullLines())
  call appendChild styles,g.!STYLE

  defs = createElement('defs')
  call appendChild defs,doc
  path = createElement('path')
  call appendChild path,defs
  call setAttributes path,,
       'id','arrow',,
       'd','M 0 0 L 10 5 L 0 10 z'
  circle = createElement('circle')
  call appendChild circle,defs
  call setAttributes circle,,
       'id','circle',,
       'cx',5,'cy',5,'r',5

  background = createElement('rect')
  call appendChild background,doc

  g.!ACTOR_NODES = ''
  call getActors g.!AUXTRACE
  lifelinebg = createElement('g')
  call setAttribute lifelinebg,'class','background'
  lifelines = createElement('g')
  call setAttribute lifelines,'class','lifeline'
  g = createElement('g')
  call setAttribute g,'class','actors'
  call appendChild createComment(' Life lines'),doc
  call appendChild lifelinebg,doc
  call appendChild lifelines,doc
  call appendChild createComment(' Actor rectangles'),doc
  call appendChild g,doc
  w = 60 /* width of an actor rectangle */
  h = 22 /* height of an actor rectangle */
  x = w  /* horizontal position of actor rectangle */
  do i = 1 to words(g.!ACTOR_NODES) /* for each actor... */
    node = word(g.!ACTOR_NODES,i)
    sActor = getActorName(node)
    sDomain = getAttribute(node,'domain')
    xMid = x + w/2
    /* Draw the life line background (for tooltips)... */
    rect = createElement('rect')
    call appendChild rect,lifelinebg
    call setAttributes rect,,
         'x',xMid-5,,
         'y',h,,
         'width',10,,
         'height',0 /* placeholder...see below */
    /* Add a tooltip for this life line background rect... */
    call addTooltip rect,sActor
    /* Draw the life line... */
    line = createElement('line')
    call appendChild line,lifelines
    call setAttributes line,,
         'x1',xMid,,
         'y1',h,,
         'x2',xMid,,
         'y2',0 /* placeholder...see below */
    /* Add an identical tooltip for this life line... */
    call addTooltip line,sActor
    g.!X.sActor = xMid /* remember where this actor is by name */
    /* Draw the rectangle to contain the actor name... */
    rect = createElement('rect')
    call appendChild rect,g
    call setAttributes rect,,
         'x',x,,
         'y',0,,
         'width',w,,
         'height',h,,
         'rx',1,,
         'ry',1
    /* Draw the domain name and actor name within the rectangle... */
    text = createElement('text')
    call appendChild text,g
    call setAttributes text,'y',9
    domain = createElement('tspan')
    actor = createElement('tspan')
    call appendChild domain,text
    call appendChild actor,text
    call setAttributes domain,'x',xMid
    call setAttributes actor,'x',xMid,'dy',10
    select
      when isProgram(node),
        then call appendChild createTextNode('program'),domain
      when isSocket(node),
        then call appendChild createTextNode('socket'),domain
      otherwise,
        call appendChild createTextNode(sDomain),domain
    end
    call appendChild createTextNode(sActor),actor
    x = x + w + 5
  end

  nImageWidth = x + w /* room on the right for a longish message */

  call appendChild createComment(' Actor relationships'),doc
  g = createElement('g')
  call appendChild g,doc
  call setAttribute g,'class','arrows'

  g.!FIRSTARROW = 2 * g.!LINEDEPTH /* vertical offset of first arrow */
  tasks = getChildren(g.!AUXTRACE)
  do i = 1 to words(tasks)
    task = word(tasks,i)
    nTaskId = getAttribute(task,'taskid')
    h = getHue(i)
    s = getSaturation(i)
    v = getValue(i)
    sColor = hsv2rgb(h,s,v)
    style = createTextNode('.task'nTaskId '{stroke:'sColor';}')
    call appendChild style,g.!STYLE
    style = createTextNode('.fill'nTaskId '{fill:'sColor';}')
    call appendChild style,g.!STYLE
    call createMarkers defs,nTaskId
    call drawArrows g,task
  end

  nImageHeight = (2 + g.!ROWS + 1 ) * g.!LINEDEPTH
  call setAttributes doc,,
       'height',nImageHeight,,
       'width',nImageWidth,,
       'viewBox','-10 -10' nImageWidth+10 nImageHeight+10
  call setAttributes background,,
       'class','background',,
       'x',0,,
       'y',0,,
       'height',nImageHeight,,
       'width',nImageWidth
   g.!WIDTH = nImageWidth
   g.!HEIGHT = nImageHeight

  /* Now we know the image height we can update the lifeline depth */
  nodes = getChildren(lifelinebg)
  do i = 1 to words(nodes)
    node = word(nodes,i)
    call setAttribute node,'height',nImageHeight
  end
  nodes = getChildren(lifelines)
  do i = 1 to words(nodes)
    node = word(nodes,i)
    call setAttribute node,'y2',nImageHeight
  end

  /* Finally, remove unreferenced marker definitions...*/
  nodes = getChildren(defs)
  do i = 1 to words(nodes)
    node = word(nodes,i)
    if getNodeName(node) = 'marker'
    then do
      sId = getAttribute(node,'id')
      if g.!MARKER.sId = ''
      then call removeChild node
    end
  end

return

createMarkers: procedure expose g.
  parse arg defs,nTaskId
/*
    <marker id="ArrowXXXXX" viewBox="0 0 10 10" refX="7" refY="5"
            orient="auto">
      <use xlink:href="#arrow"/>
    </marker>
*/
  marker = createElement('marker')
  call appendChild marker,defs
  call setAttributes marker,,
       'id','Arrow'nTaskId,,
       'class','fill'nTaskId,,
       'viewBox','0 0 10 10',,
       'refX',7,,
       'refY',5,,
       'orient','auto'
  use = createElement('use')
  call appendChild use,marker
  call setAttribute use,'xlink:href','#arrow'
/*
    <marker id="CircleXXXXX" viewBox="0 0 10 10" refX="8" refY="5">
      <use xlink:href="#circle"/>
    </marker>
*/
  marker = createElement('marker')
  call appendChild marker,defs
  call setAttributes marker,,
       'id','Circle'nTaskId,,
       'class','fill'nTaskId,,
       'viewBox','0 0 10 10',,
       'refX',8,,
       'refY',5
  use = createElement('use')
  call appendChild use,marker
  call setAttribute use,'xlink:href','#circle'
return

addTooltip: procedure expose g.
  parse arg node,sTip
  tooltip = createElement('desc')
  call appendChild tooltip,node
  call appendChild createTextNode(sTip),tooltip
return

getHue: procedure expose g.
  arg n
return (g.!HUE_INIT + (n-1) * g.!HUE_STEP) // 360

getSaturation: procedure expose g.
  arg n
  n = g.!SAT_LEVELS - 1 - (n-1) // g.!SAT_LEVELS
return g.!SAT_MIN + n * g.!SAT_STEP

getValue: procedure expose g.
  arg n
  n = g.!VAL_LEVELS - 1 - (n-1) // g.!VAL_LEVELS
return g.!VAL_MIN + n * g.!VAL_STEP

hsv2rgb: procedure
  parse arg h,s,v
  /*
  Hue (h) is from 0 to 360, where 0 = red and 360 also = red
  Saturation (s) is from 0.0 to 1.0 (0 = least color, 1 = most color)
  Value (v) is from 0.0 to 1.0 (0 = darkest, 1 = brightest)
  */
  v = 100 * v /* convert to a percentage */
  if s = 0 /* if grayscale */
  then do
    v = format(v,,2)'%'
    rgb = 'rgb('v','v','v')'
  end
  else do
    sextant = trunc(h/60) /* 0 to 5 */
    fraction = h/60 - sextant
    p = v * (1 - s)
    q = v * (1 - s * fraction)
    r = v * (1 - s * (1 - fraction))
    v = format(v,,2)'%'
    p = format(p,,2)'%'
    q = format(q,,2)'%'
    r = format(r,,2)'%'
    select
      when sextant = 0 then rgb = 'rgb('v','r','p')'
      when sextant = 1 then rgb = 'rgb('q','v','p')'
      when sextant = 2 then rgb = 'rgb('p','v','r')'
      when sextant = 3 then rgb = 'rgb('p','q','v')'
      when sextant = 4 then rgb = 'rgb('r','q','v')'
      when sextant = 5 then rgb = 'rgb('v','p','q')'
      otherwise rgb = 'rgb(0,0,0)' /* should not happen :) */
    end
  end
return rgb


pullLines: procedure expose g.
  sLines = ''
  do queued()
    parse pull sLine
    sLines = sLines || sLine || g.!LF
  end
return sLines

getActors: procedure expose g.
  parse arg node
  sActor = getActorName(node)
  if sActor <> '' & g.!ACTOR.sActor = ''
  then do /* if this node is a new actor */
      g.!ACTOR_NODES = g.!ACTOR_NODES node
      g.!ACTOR.sActor = 1 /* we've seen it now */
  end
  children = getChildren(node)
  do i = 1 to words(children)
    child = word(children,i)
    call getActors child
  end
return

getActorName: procedure expose g.
  parse arg node
  select
    when node = g.!AUXTRACE then do
      sActor = '<<cics>>'
    end
    when getNodeName(node) = 'task' then do
      sActor = '<<cics>>'
    end
    when isProgram(node) then do
      sActor = getAttribute(node,'PROGRAM_NAME')
      if sActor = '' then sActor = getAttribute(node,'PROGRAM')
      if sActor = '' then sActor = '<<program>>'
    end
    when isSocket(node) then do
      sActor = getAttribute(node,'SOCKET_TOKEN')
      if sActor = '' then sActor = '<<socket>>'
    end
    otherwise sActor = getAttribute(node,'module')
  end
return sActor

isProgram: procedure expose g.
  parse arg node
  sDomain = getAttribute(node,'domain')
  sFunction = getAttribute(node,'function')
  bIsProgram = sDomain = 'PG' &,
     wordpos(sFunction,'LINK LINK_EXEC INITIAL_LINK',
                       'LOAD LOAD_EXEC LINK_URM') > 0
  bIsProgram = bIsProgram | (sDomain = 'AP' &,
     wordpos(sFunction,'START_PROGRAM') > 0)
return bIsProgram

isSocket: procedure expose g.
  parse arg node
  sModule = getAttribute(node,'module')
  sFunction = getAttribute(node,'function')
  bIsSocket = sModule = 'DFHSOCK' &,
     wordpos(sFunction,'SEND RECEIVE CONNECT CLOSE') > 0
return bIsSocket

drawArrows: procedure expose g.
  parse arg g,source
  if isActor(source)
  then do
    children = getChildren(source)
    do i = 1 to words(children)
      target = word(children,i)
      if isActor(target)
      then do /* we can draw an arrow between actors */
        sClass = 'task'getAttribute(target,'taskid')
        group = createElement('g')
        call appendChild group,g
        call setAttribute group,'class',sClass
        call drawArrow group,source,target,'call'
        call drawArrows group,target
        call drawArrow group,target,source,'return'
      end
      else do
        call drawArrows g,target
      end
    end
  end
  else do
    children = getChildren(caller)
    do i = 1 to words(children)
      child = word(children,i)
      call drawArrows g,child
    end
  end
return

isActor: procedure expose g.
  parse arg node
  bIsActor = getActorName(node) <> '' | getNodeName(node) = 'task'
return bIsActor

drawArrow: procedure expose g.
  parse arg g,source,target,sClass
  /* the source actor invokes a function on the target actor */
  bIsCall = sClass = 'call' /* ...else it is a return arrow */
  if bIsCall
  then nRow = getAttribute(target,'row')
  else nRow = getAttribute(source,'exitrow')
  if nRow = '' then return /* <event> has no 'return' arrow */
  y = g.!FIRSTARROW + g.!LINEDEPTH * nRow
  sSourceActor = getActorName(source)
  sTargetActor = getActorName(target)
  sFunction = getAttribute(target,'function')

  /* Group the arrow, text and optional tooltip together */
  arrow = createElement('g')
  call appendChild arrow,g

  /* Draw the elapsed time and task id of this <trace> entry...*/
  sTaskId = getAttribute(target,'taskid')
  if bIsCall
  then do
    call appendChild createComment(' 'sTargetActor),arrow
    elapsed = createElement('text')
    call appendChild elapsed,arrow
    call setAttributes elapsed,'x',0,'y',y
    nElapsed = getAttribute(target,'elapsed')
    sElapsed = '+'left(format(nElapsed,,6),8,'0')' 'sTaskId
    call appendChild createTextNode(sElapsed),elapsed
  end

  /* Draw the arrow for this call or return...*/
  line = createElement('line')
  call appendChild line,arrow
  tooltip = createElement('desc') /* tool tip for this arrow */
  call appendChild tooltip,line
  if \bIsCall
  then call setAttribute line,'class',sClass
  x1 = g.!X.sSourceActor
  x2 = g.!X.sTargetActor
  if x1 < x2 /* if left-to-right arrow */
  then do
    x1b = x1 + 2
    x2 = x2 - 2
    sDir = 'ltr'
  end
  else do
    x1b = x1 - 2
    x2 = x2 + 2
    sDir = 'rtl'
  end
  call setAttributes line,,
       'x1',x1,,
       'y1',y,,
       'x2',x2,,
       'y2',y
  if sSourceActor = sTargetActor
  then do
    sId = 'Circle'sTaskId
    g.!MARKER.sId = 1 /* remember that we have used this marker */
    call setAttribute line,'marker-end','url(#'sId')'
  end
  else do
    sId = 'Arrow'sTaskId
    g.!MARKER.sId = 1 /* remember that we have used this marker */
    call setAttribute line,'marker-end','url(#'sId')'
  end

  /* Annotate the arrow...*/
  annotation = createElement('text')
  call appendChild annotation,arrow
  call setAttributes annotation,,
       'class','annotation' sDir,,
       'x',x1b,,
       'y',y-2
  if bIsCall
  then do /* annotate the invoking arrow */
    sExtra = getDescriptionOfCall(target)
    sModule = getAttribute(target,'module')
    if getNodeName(target) = 'exception'
    then call setAttribute annotation,'class','annotation error' sDir
  end
  else do /* annotate the returning arrow */
    sExtra = ''
    sModule = getAttribute(source,'module')
    sFunction = getAttribute(source,'function')
    sResponse = getAttribute(source,'response')
    if sResponse = '' |,
       sResponse = 'NORMAL' |,
       sResponse = 'RESPONSE(OK)'
    then sResponse = 'OK'
    select
      when sSourceActor = sTargetActor then,
        sExtra = sFunction sResponse
      when sResponse = 'OK' then,
        sExtra = sResponse
      otherwise,
        sExtra = sResponse getAttribute(source,'reason')
    end
    if sResponse <> 'OK'
    then call setAttribute annotation,'class','annotation error' sDir
  end

  /* Every arrow is annotated with the trace sequence number... */
  tspanSeq = createElement('tspan')
  call setAttribute tspanSeq,'class','seq'
  if bIsCall
  then nSeq = getAttribute(target,'seq')
  else nSeq = getAttribute(source,'exitseq')
  call appendChild createTextNode(nSeq),tspanSeq

  /* Some arrows have extra info near the sequence number... */
  if sDir = 'ltr' /* if left-to-right arrow */
  then do /* e.g. 001234 LOAD_EXEC ------------------>  */
    call appendChild tspanSeq,annotation
    if sExtra <> ''
    then do
      tspanExtra = createElement('tspan')
      call appendChild createTextNode(sExtra),tspanExtra
      call appendChild tspanExtra,annotation
    end
  end
  else do /* e.g. <----------- PROGRAM_NOT_FOUND 001235 */
    if sExtra <> ''
    then do
      tspanExtra = createElement('tspan')
      call appendChild createTextNode(sExtra),tspanExtra
      call appendChild tspanExtra,annotation
    end
    call appendChild tspanSeq,annotation
  end

  /* Now create a tool tip for this line */
  sTip = nSeq sExtra
  select
    when sModule = 'DFHSOCK' then do
      if sFunction = 'SEND'
      then sTip = sTip getSocketDetail(target,'on-entry')
      if sFunction = 'RECEIVE'
      then sTip = sTip getSocketDetail(source,'on-exit')
    end
    when getNodeName(target) = 'data' then do
      sTip = sTip getDataDetail(target)
    end
    otherwise nop
  end
  call appendChild createTextNode(sTip),tooltip
return

getSocketDetail: procedure expose g.
  parse arg node,sContainer
  detail = getChildrenByName(node,sContainer)
  args = getChildrenByName(detail,'arg')
  if words(args) < 2 then return ''
  data = word(args,2) /* arg2 contains the packet payload */
  sData = getText(getFirstChild(data)) /* ...a CDATA node */
return sData

getDataDetail: procedure expose g.
  parse arg node
  sData = ''
  detail = getChildrenByName(node,'detail')
  if detail <> ''
  then do
    args = getChildrenByName(detail,'arg')
    do i = 1 to words(args)
      data = word(args,i)
      sData = sData getText(getFirstChild(data))
    end
  end
return sData

getDescriptionOfCall: procedure expose g.
  parse arg node
  sDesc = ''
  sDomain = getAttribute(node,'domain')
  sFunction = getAttribute(node,'function')
  select
    when sDomain = 'PG' then do
      sProgram = getAttribute(node,'PROGRAM_NAME')
      select
        when sProgram <> '' then,
          sDesc = '('sProgram')'
        otherwise nop
      end
    end
    when sDomain = 'AP' then do
      select
        when sFunction = 'START_PROGRAM' then,
          sDesc = '('getAttribute(node,'PROGRAM')')'
        when sFunction = 'WRITE_TRANSIENT_DATA' then,
          sDesc = '('getAttribute(node,'QUEUE')')'
        when sFunction = 'READ_UPDATE_INTO' then,
          sDesc = '('getAttribute(node,'FILE_NAME')')'
        when sFunction = 'LOCATE' then,
          sDesc = getAttribute(node,'TABLE')'(' ||,
                  getAttribute(node,'KEY')')'
        when wordpos(sFunction,'GET_QUEUE',
                               'PUT_QUEUE',
                               'DELETE_QUEUE') > 0 then,
          sDesc = '('getAttribute(node,'RECORD_TYPE')')'
        otherwise nop
      end
    end
    when sDomain = 'BA' then do
      select
        when wordpos(sFunction,'PUT_CONTAINER',
                               'GET_CONTAINER_SET',
                               'GET_CONTAINER_INTO',
                               'DELETE_CONTAINER') > 0 then,
          sDesc = '('getAttribute(node,'CONTAINER_NAME')')'
        when wordpos(sFunction,'ADD_ACTIVITY',
                               'LINK_ACTIVITY',
                               'CHECK_ACTIVITY') > 0 then,
          sDesc = '('getAttribute(node,'ACTIVITY_NAME')')'
        otherwise nop
      end
    end
    when sDomain = 'WB' then do
      select
        when wordpos(sFunction,'PUT_QUEUE',
                               'DELETE_QUEUE',
                               'GET_QUEUE') > 0 then,
          sDesc = '('getAttribute(node,'RECORD_TYPE')')'
        when wordpos(sFunction,'START_BROWSE',
                               'READ_NEXT',
                               'END_BROWSE') > 0 then,
          sDesc = '('getAttribute(node,'DATA_TYPE')')'
        otherwise nop
      end
    end
    when sDomain = 'SM' then do
      select
        when sFunction = 'GETMAIN' then do
            if hasAttribute(node,'STORAGE_CLASS')
            then do
              xLen = getAttribute(node,'GET_LENGTH')
              sDesc = getAttribute(node,'ADDRESS'),
                      getAttribute(node,'STORAGE_CLASS'),
                      "LENGTH=X'"xLen"' ("x2d(xLen)')',
                      getAttribute(node,'REMARK')
            end
            else,
              sDesc = getAttribute(node,'ADDRESS'),
                      'SUBPOOL',
                      getAttribute(node,'REMARK')
        end
        when sFunction = 'FREEMAIN' then do
          select
            when hasAttribute(node,'STORAGE_CLASS') then,
              sDesc = getAttribute(node,'ADDRESS'),
                      getAttribute(node,'STORAGE_CLASS'),
                      getAttribute(node,'REMARK')
            when hasAttribute(node,'SUBPOOL_TOKEN') then,
              sDesc = getAttribute(node,'ADDRESS'),
                      'SUBPOOL',
                      getAttribute(node,'REMARK')
            otherwise,
              sDesc = getAttribute(node,'ADDRESS'),
                      getAttribute(node,'REMARK')
          end
        end
        otherwise nop
      end
    end
    when sDomain = 'DD' then do
      select
        when sFunction = 'LOCATE' then,
          sDesc = getAttribute(node,'DIRECTORY_NAME')'(' ||,
                  getAttribute(node,'NAME')')'
        otherwise nop
      end
    end
    when sDomain = 'TS' then do
      select
        when wordpos(sFunction,'MATCH',
                               'DELETE',
                               'READ_INTO',
                               'READ_SET',
                               'READ_AUX_DATA',
                               'WRITE') > 0 then,
          sDesc = 'QUEUE('getAttribute(node,'QUEUE_NAME')')'
        otherwise nop
      end
    end
    when sDomain = 'XS' then do
      select
        when sFunction = 'CHECK_CICS_RESOURCE' then,
          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,
                  getAttribute(node,'RESOURCE')') ACCESS(' ||,
                  getAttribute(node,'ACCESS')')'
        otherwise nop
      end
    end
    when sDomain = 'XM' then do
      select
        when sFunction = 'ATTACH' then,
          sDesc = 'TRANS('getAttribute(node,'TRANSACTION_ID')')'
        when sFunction = 'INQUIRE_MXT' then,
          sDesc = 'LIMIT('getAttribute(node,'MXT_LIMIT')')',
                  'ACTIVE('getAttribute(node,'CURRENT_ACTIVE')')'
        otherwise nop
      end
    end
    when sDomain = 'EM' then do
      select
        when wordpos(sFunction,'FIRE_EVENT',
                               'DEFINE_ATOMIC_EVENT',
                               'DELETE_EVENT',
                               'RETRIEVE_REATTACH_EVENT') > 0 then,
          sDesc = '('getAttribute(node,'EVENT')')'
        otherwise nop
      end
    end
    when sDomain = 'DU' then do
      select
        when wordpos(sFunction,'TRANSACTION_DUMP',
                               'COMMIT_TRAN_DUMPCODE',
                               'LOCATE_TRAN_DUMPCODE') > 0 then,
          sDesc = '('getAttribute(node,'TRANSACTION_DUMPCODE')')',
                     getAttribute(node,'DUMPID')
        when wordpos(sFunction,'INQUIRE_SYSTEM_DUMPCODE') > 0 then,
          sDesc = '('getAttribute(node,'SYSTEM_DUMPCODE')')'
        otherwise nop
      end
    end
    when sDomain = 'CC' then do
      select
        when wordpos(sFunction,'GET') > 0 then,
          sDesc = getAttribute(node,'TYPE')'(' ||,
                  getAttribute(node,'NAME')')'
        otherwise nop
      end
    end
    when sDomain = 'GC' then do
      select
        when wordpos(sFunction,'WRITE') > 0 then,
          sDesc = getAttribute(node,'TYPE')'(' ||,
                  getAttribute(node,'NAME')')'
        otherwise nop
      end
    end
    when sDomain = 'DS' then do
      select
        when wordpos(sFunction,'SUSPEND',
                               'WAIT_MVS',
                               'WAIT_OLDW') > 0 then,
          sDesc = getAttribute(node,'RESOURCE_TYPE')'(' ||,
                  getAttribute(node,'RESOURCE_NAME')')'
        otherwise nop
      end
    end
    otherwise nop
  end
  if getNodeName(node) = 'trace'
  then sPrefix = sFunction
  else sPrefix = getNodeName(node)':' sFunction
return strip(sPrefix sDesc)

setOptions: procedure expose g.
  parse arg sOptions
  /* set default options... */
  g.!OPTION.EVENT   = 1 /* Process input EVENT trace records? */
  g.!OPTION.DATA    = 1 /* Process input DATA trace records? */
  g.!OPTION.DETAIL  = 0 /* Output trace detail? */
  g.!OPTION.XML     = 0 /* Output XML file? */
  g.!OPTION.HTML    = 1 /* Output HTML file? */
  g.!DOMAIN_FILTER = ''
  do i = 1 to words(sOptions)
    sOption = word(sOptions,i)
      if length(sOption) = 2 then,
        g.!DOMAIN_FILTER = g.!DOMAIN_FILTER sOption
      else do
        if left(sOption,2) = 'NO'
        then do
          sOption = substr(sOption,3)
          g.!OPTION.sOption = 0
        end
        else g.!OPTION.sOption = 1
      end
  end
return

Prolog:
  if g.!ENV = 'TSO'
  then g.!LF = '15'x
  else g.!LF = '0A'x

  /* Constants for generating line colors */
  g.!HUE_INIT   = 151 /* random(0,360) */
  g.!HUE_STEP   = 43  /* random(0,360) */
  g.!SAT_MIN    = 1.0
  g.!SAT_MAX    = 1.0
  g.!SAT_LEVELS = 2
  g.!SAT_STEP   = (g.!SAT_MAX - g.!SAT_MIN) / (g.!SAT_LEVELS - 1)
  g.!VAL_MIN    = 0.5
  g.!VAL_MAX    = 0.8
  g.!VAL_LEVELS = 2
  g.!VAL_STEP   = (g.!VAL_MAX - g.!VAL_MIN) / (g.!VAL_LEVELS - 1)

  g.!DOMAIN.0 = 0 /* Number of domains */
  call addDomain 'AP','Application Domain'
  call addDomain 'BA','Business Application Manager Domain'
  call addDomain 'CC','CICS Catalog Domain'
  call addDomain 'GC','Global Catalog Domain'
  call addDomain 'LC','Local Catalog Domain'
  call addDomain 'DD','Directory Domain'
  call addDomain 'DH','Document Handler Domain'
  call addDomain 'DM','Domain Manager Domain'
  call addDomain 'DP','Debugging Profiles Domain'
  call addDomain 'DS','Dispatcher Domain'
  call addDomain 'DU','Dump Domain'
  call addDomain 'EJ','Enterprise Java Domain'
  call addDomain 'EM','Event Manager Domain'
  call addDomain 'EX','External CICS Interface Domain'
  call addDomain 'EI','External CICS Interface over TCP/IP Domain'
  call addDomain 'FT','Feature Domain'
  call addDomain 'II','IIOP Domain'
  call addDomain 'KE','Kernel Domain'
  call addDomain 'LD','Loader Domain'
  call addDomain 'LG','Log Manager Domain'
  call addDomain 'LM','Lock Manager Domain'
  call addDomain 'ME','Message Domain'
  call addDomain 'MN','Monitoring Domain'
  call addDomain 'NQ','Enqueue Domain'
  call addDomain 'OT','Object Transaction Domain'
  call addDomain 'PA','Parameter Manager Domain'
  call addDomain 'PG','Program Manager Domain'
  call addDomain 'PI','Pipeline Manager Domain'
  call addDomain 'PT','Partner Domain'
  call addDomain 'RM','Recovery Manager Domain'
  call addDomain 'RX','RRMS Domain'
  call addDomain 'RZ','Request Streams Domain'
  call addDomain 'SH','Scheduler Domain'
  call addDomain 'SJ','Java Virtual Machine Domain'
  call addDomain 'SM','Storage Manager Domain'
  call addDomain 'SO','Socket Domain'
  call addDomain 'ST','Statistics Domain'
  call addDomain 'TI','Timer Domain'
  call addDomain 'TR','Trace Domain'
  call addDomain 'TS','Temporary Storage Domain'
  call addDomain 'US','User Domain'
  call addDomain 'WB','Web Domain'
  call addDomain 'XM','Transaction Manager Domain'
  call addDomain 'XS','Security Manager Domain'
return

addDomain: procedure expose g.
  parse arg sDomain,sDesc
  if g.!DOMAIN.sDomain = ''
  then do
    nDomain = g.!DOMAIN.0       /* Number of domains */
    nDomain = nDomain + 1
    g.!DOMAIN.sDomain = sDesc   /* e.g. g.!DOMAIN.AP = 'App Domain'  */
    g.!DOMAIN.nDomain = sDomain /* e.g. g.!DOMAIN.1 = 'AP'           */
    g.!DOMAIN.0 = nDomain
  end
return

/* Embed the svg in an html file to allow the browser to scroll it */
createHTML: procedure expose g.
  html = openFile(g.!FILEHTM,'OUTPUT')
  if g.!rc = 0
  then do
    say 'AUX010I Creating' g.!FILEHTM
    queue '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0',
          'Transitional//EN">'
    queue '<html>'
    queue '  <body>'
    queue '    <object data="'g.!FILESVG'"',
                      'width="'g.!WIDTH'"',
                      'height="'g.!HEIGHT'"',
                      'type="image/svg+xml"></object>'
    queue '  </body>'
    queue '</html>'
    do queued()
      parse pull sLine
      call putLine html,sLine
    end
    rc = closeFile(html)
    say 'AUX011I Created' g.!FILEHTM
  end
  else do
    say 'AUX012E Could not create' g.!FILEHTM'. Return code' g.!rc
  end
return

Epilog: procedure expose g.
return


getValidAttributeName: procedure expose g.
  parse arg sName
  sName = space(sName,0)
  sName = strip(sName,'LEADING','-')
  if datatype(left(sName,1),'WHOLE')
  then sName = 'X'sName /* must start with an alphabetic */
return sName


appendDetail: procedure expose g.
  parse arg e,sName
  x = createElement(sName)
  call appendChild x,e
  sData = ''
  do i = 2 to g.!ENTRYDATA.0
    sLine = strip(g.!ENTRYDATA.i,'LEADING')
    parse var sLine nArg'-0000 '
    if datatype(nArg,'WHOLE')
    then do
      if sData <> ''
      then call appendDetailArg x,sData
      parse var sLine nArg'-'sData
      sData = sData || g.!LF
    end
    else do
      sData = sData || sLine || g.!LF
    end
  end
  if sData <> ''
  then call appendDetailArg x,sData
return

appendDetailArg: procedure expose g.
  parse arg parent,sData
  a = createElement('arg')
  call appendChild a,parent
  call appendChild createCDATASection(g.!LF || sData),a
return

/*INCLUDED pretty.rexx */
/*REXX 0117

  Rexx XML Pretty Printer V1.8
  Copyright (C) 2003-2005 Andrew J. Armstrong

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307  USA

 Author:
 Andrew J. Armstrong <andrew_armstrong@unwired.com.au>
*/

/*REXX*****************************************************************
**                                                                   **
** NAME     - PRETTY                                                 **
**                                                                   **
** FUNCTION - Pretty printer. This demonstrates the XML parser by    **
**            reformatting an xml input file.                        **
**                                                                   **
**                                                                   **
** SYNTAX   - pretty infile Ýoutfile¨ (options...)                   **
**                                                                   **
**            Where,                                                 **
**            infile   = Name of file to be parsed                   **
**            outfile  = Name of file to store the pretty output in. **
**                       The default is the console.                 **
**            options  = NOBLANKS - Suppress whitespace-only nodes   **
**                       DEBUG    - Display some debugging info      **
**                       DUMP     - Display the parse tree           **
**                                                                   **
**                                                                   **
** NOTES    - 1. You will have to either append the PARSEXML source  **
**               manually to this demo source, or run this demo      **
**               source through the REXXPP rexx pre-processor.       **
**                                                                   **
**               To use the pre-processor, run:                      **
**                                                                   **
**               rexxpp pretty prettypp                              **
**                                                                   **
**               ...and then run the resulting rexx procedure over   **
**               an XML file of your choice:                         **
**                                                                   **
**               prettypp testxml Ýoutxml¨                           **
**                ...or...                                           **
**               prettypp testxml Ýoutxml¨ (noblanks                 **
**                ...or...                                           **
**               prettypp testxml Ýoutxml¨ (noblanks dump            **
**                                                                   **
**                                                                   **
**                                                                   **
** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **
**                                                                   **
** HISTORY  - Date     By       Reason (most recent at the top pls)  **
**            -------- -------- ------------------------------------ **
**            20050920 AJA      Allow root node to be specified.     **
**            20050907 AJA      Escape text of attribute values.     **
**            20040706 AJA      Assume default indentation amount.   **
**                              Allow output to a file.              **
**            20031031 AJA      Fix escaping text.                   **
**            20030911 AJA      Removed default filename value. You  **
**                              must specify your own filename.      **
**            20030905 AJA      Intial version.                      **
**                                                                   **
**********************************************************************/

  parse arg sFileIn sFileOut' ('sOptions')'

  /* Initialise the parser */
  call initParser sOptions /* DO THIS FIRST! Sets g. vars to null */

  /* Open the specified file and parse it */
  nParseRC = parseFile(sFileIn)

  parse source g.!ENV .
  if g.!ENV = 'TSO'
  then do
    address ISPEXEC
    'CONTROL ERRORS RETURN'
    g.!LINES = 0
  end

  call prettyPrinter sFileOut,2 /* 2 is the indentation amount */

exit nParseRC

/*-------------------------------------------------------------------*
 * An example of how to navigate the tree
 *-------------------------------------------------------------------*/

prettyPrinter: procedure expose g.
  parse arg sFileOut,g.!TAB,nRoot
  if g.!TAB = '' then g.!TAB = 2 /* indentation amount */
  if nRoot = '' then nRoot = getRoot()
  g.!INDENT = 0
  g.!FILEOUT = ''
  if sFileOut <> ''
  then do
    g.!FILEOUT = openFile(sFileOut,'OUTPUT')
    if g.!rc = 0
    then say 'PRP001I Creating' sFileOut
    else do
      say 'PRP002E Could not create' sFileOut'. Writing to console...'
      g.!FILEOUT = '' /* null handle means write to console */
    end
  end

  call _setDefaultEntities

  call emitProlog
  g.!INDENT = -g.!TAB
  call showNode nRoot

  if g.!FILEOUT <> ''
  then do
    say 'PRP002I Created' sFileOut
    rc = closeFile(g.!FILEOUT)
  end
return


emitProlog: procedure expose g.
  if g.?xml.version = ''
  then sVersion = '1.0'
  else sVersion = g.?xml.version
  if g.?xml.encoding = ''
  then sEncoding = 'UTF-8'
  else sEncoding = g.?xml.encoding
  if g.?xml.standalone = ''
  then sStandalone = 'yes'
  else sStandalone = g.?xml.standalone

  g.!INDENT = 0
  call Say '<?xml version="'sVersion'"',
                'encoding="'sEncoding'"',
              'standalone="'sStandalone'"?>'

  sDocType = getDocType()
  if sDocType <> ''
  then call Say '<!DOCTYPE' getName(getDocumentElement()) sDocType'>'
return

showNode: procedure expose g.
  parse arg node
  g.!INDENT = g.!INDENT + g.!TAB
  select
    when isTextNode(node)    then call emitTextNode    node
    when isCommentNode(node) then call emitCommentNode node
    when isCDATA(node)       then call emitCDATA       node
    otherwise                     call emitElementNode node
  end
  g.!INDENT = g.!INDENT - g.!TAB
return

setPreserveWhitespace: procedure expose g.
  parse arg bPreserve
  g.!PRESERVEWS = bPreserve = 1
return

emitTextNode: procedure expose g.
  parse arg node
  if g.!PRESERVEWS = 1
  then call Say escapeText(getText(node))
  else call Say escapeText(removeWhitespace(getText(node)))
return

emitCommentNode: procedure expose g.
  parse arg node
  call Say '<!--'getText(node)' -->'
return

emitCDATA: procedure expose g.
  parse arg node
  call Say '<!ÝCDATAÝ'getText(node)'¨¨>'
return

emitElementNode: procedure expose g.
  parse arg node
  sName = getName(node)
  sAttrs = ''
  do i = 1 to getAttributeCount(node)
    sAttrs = sAttrs getAttributeName(node,i)'="' ||,
                    escapeText(getAttribute(node,i))'"'
  end
  sChildren = getChildren(node)
  if sChildren = ''
  then do
    if sAttrs = ''
    then call Say '<'sName'/>'
    else call Say '<'sName strip(sAttrs)'/>'
  end
  else do
    if sAttrs = ''
    then call Say '<'sName'>'
    else call Say '<'sName strip(sAttrs)'>'
    child = getFirstChild(node)
    do while child <> ''
      call showNode child
      child = getNextSibling(child)
    end
    call Say '</'sName'>'
  end
return

Say: procedure expose g.
  parse arg sMessage
  sLine = copies(' ',g.!INDENT)sMessage
  if g.!FILEOUT = ''
  then say sLine
  else call putLine g.!FILEOUT,sLine
return

/*INCLUDED io.rexx */
/*REXX 0102
  Rexx I/O Routines V1.8
  Copyright (C) 2003-2005 Andrew J. Armstrong

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307  USA

 Author:
 Andrew J. Armstrong <andrew_armstrong@unwired.com.au>
*/

/*REXX*****************************************************************
**                                                                   **
** NAME     - IO                                                     **
**                                                                   **
** FUNCTION - Simple I/O routines.                                   **
**                                                                   **
** API      - The routines in this module are:                       **
**                                                                   **
**            openFile(filename,options,attrs)                       **
**                Opens the specified file with the specified options**
**                and returns a file handle to be used in other I/O  **
**                operations. By default the file will be opened for **
**                input. Specify 'OUTPUT' to open it for output.     **
**                For TSO, you can specify any operand of the TSO    **
**                ALLOCATE command in the third operand. For example:**
**                rc = openFile('MY.FILE','OUTPUT','RECFM(F,B)'      **
**                              'LRECL(80) BLKSIZE(27920)')          **
**                                                                   **
**            closeFile(handle)                                      **
**                Closes the file specified by 'handle' (which was   **
**                returned by the openFile() routine.                **
**                                                                   **
**            getLine(handle)                                        **
**                Reads the next line from the file specified by     **
**                'handle'.                                          **
**                                                                   **
**            putLine(handle,data)                                   **
**                Appends the specified data to the file specified   **
**                by 'handle'.                                       **
**                                                                   **
**                                                                   **
** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **
**                                                                   **
** HISTORY  - Date     By       Reason (most recent at the top pls)  **
**            -------- -------- ------------------------------------ **
**            20050930 AJA      Initial version.                     **
**                                                                   **
**********************************************************************/

  parse source . . sSourceFile .
  say 'You cannot invoke this rexx by itself!'
  say
  say 'This rexx is a collection of subroutines to be called'
  say 'from your own rexx procedures. You should either:'
  say '  - Append this procedure to your own rexx procedure,'
  say '    or,'
  say '  - Append the following line to your rexx:'
  say '    /* INCLUDE' sSourceFile '*/'
  say '    ...and run the rexx preprocessor:'
  say '    rexxpp myrexx myrexxpp'
  say '    This will create myrexxpp by appending this file to myrexx'
exit

/*-------------------------------------------------------------------*
 * Open a file
 *-------------------------------------------------------------------*/

openFile: procedure expose g.
  parse arg sFile,sOptions,sAttrs
  hFile = ''
  select
    when g.!ENV = 'TSO' then do
      bOutput = wordpos('OUTPUT',sOptions) > 0
      bQuoted = left(sFile,1) = "'"
      if bQuoted then sFile = strip(sFile,,"'")
      parse var sFile sDataset'('sMember')'
      if sMember <> '' then sFile = sDataset
      if bQuoted then sFile = "'"sFile"'"
      if bOutput
      then 'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'
      else 'LMINIT  DATAID(hFile) DATASET(&sFile)'
      if sMember <> ''
      then do /* Open a member of a PDS */
        'LMOPEN  DATAID(&hFile) OPTION(INPUT)' /* Input initially */
        /* ... can't update ISPF stats when opened for output */
        g.!MEMBER.hFile = sMember
        'LMMFIND DATAID(&hFile) MEMBER('sMember') STATS(YES)'
        if bOutput
        then do
          if rc = 0
          then g.!STATS.hFile = zlvers','zlmod','zlc4date
          else g.!STATS.hFile = '1,0,0000/00/00'
          'LMCLOSE DATAID(&hFile)'
          'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'
        end
      end
      else do /* Open a sequential dataset */
        'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'
        if rc <> 0 /* If dataset does not already exist... */
        then do /* Create sequential dataset then open it */
          'LMCLOSE DATAID(&hFile)'
          'LMFREE  DATAID(&hFile)'
          address TSO 'ALLOCATE DATASET('sFile') NEW CATALOG',
                      'SPACE(5,15) TRACKS RECFM(V,B) LRECL(2048)',
                      'BLKSIZE(27990)' sAttrs
          if bOutput
          then do
            'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'
            'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'
          end
          else do
            'LMINIT  DATAID(hFile) DATASET(&sFile)'
            'LMOPEN  DATAID(&hFile) OPTION(INPUT)'
          end
        end
      end
      g.!OPTIONS.hFile = sOptions
      g.!rc = rc /* Return code from LMOPEN */
    end
    when g.!ENV = 'WIN32' then do
      if wordpos('OUTPUT',sOptions) > 0
      then junk = stream(sFile,'COMMAND','OPEN WRITE REPLACE')
      else junk = stream(sFile,'COMMAND','OPEN READ')
      hFile = sFile
      if stream(sFile,'STATUS') = 'READY'
      then g.!rc = 0
      else g.!rc = 4
    end
    otherwise say 'RIO000E Unsupported platform:' g.!ENV'.',
                  'Cannot open file "'sFile'".'
  end
return hFile

/*-------------------------------------------------------------------*
 * Read a line from the specified file
 *-------------------------------------------------------------------*/

getLine: procedure expose g.
  parse arg hFile
  sLine = ''
  select
    when g.!ENV = 'TSO' then do
      'LMGET DATAID(&hFile) MODE(INVAR)',
            'DATALOC(sLine) DATALEN(nLine) MAXLEN(32768)'
      g.!rc = rc
      sLine = strip(sLine,'TRAILING')
      if sLine = '' then sLine = ' '
    end
    when g.!ENV = 'WIN32' then do
      g.!rc = 0
      if chars(hFile) > 0
      then sLine = linein(hFile)
      else g.!rc = 4
    end
    otherwise g.!rc = 4
  end
return sLine

/*-------------------------------------------------------------------*
 * Append a line to the specified file
 *-------------------------------------------------------------------*/

putLine: procedure expose g.
  parse arg hFile,sLine
  select
    when g.!ENV = 'TSO' then do
      g.!LINES = g.!LINES + 1
      'LMPUT DATAID(&hFile) MODE(INVAR)',
            'DATALOC(sLine) DATALEN('length(sLine)')'
    end
    when g.!ENV = 'WIN32' then do
      junk = lineout(hFile,sLine)
      rc = 0
    end
    otherwise rc = 4
  end
return rc

/*-------------------------------------------------------------------*
 * Close the specified file
 *-------------------------------------------------------------------*/

closeFile: procedure expose g.
  parse arg hFile
  rc = 0
  select
    when g.!ENV = 'TSO' then do
      if g.!MEMBER.hFile <> '', /* if its a PDS */
      & wordpos('OUTPUT',g.!OPTIONS.hFile) > 0 /* opened for output */
      then do
        parse value date('STANDARD') with yyyy +4 mm +2 dd +2
        parse var g.!STATS.hFile zlvers','zlmod','zlc4date
        zlcnorc  = min(g.!LINES,65535)   /* Number of lines   */
        nVer = right(zlvers,2,'0')right(zlmod,2,'0')  /* vvmm */
        nVer = right(nVer+1,4,'0')       /* vvmm + 1          */
        parse var nVer zlvers +2 zlmod +2
        if zlc4date = '0000/00/00'
        then zlc4date = yyyy'/'mm'/'dd   /* Creation date     */
        zlm4date = yyyy'/'mm'/'dd        /* Modification date */
        zlmtime  = time()                /* Modification time */
        zluser   = userid()              /* Modification user */
        'LMMREP DATAID(&hFile) MEMBER('g.!MEMBER.hFile') STATS(YES)'
      end
      'LMCLOSE DATAID(&hFile)'
      'LMFREE  DATAID(&hFile)'
    end
    when g.!ENV = 'WIN32' then do
      if stream(hFile,'COMMAND','CLOSE') = 'UNKNOWN'
      then rc = 0
      else rc = 4
    end
    otherwise rc = 4
  end
return rc
/*INCLUDEZ io.rexx */
/*INCLUDED parsexml.rexx */
/*REXX 0118
  Rexx XML Parser V1.8
  Copyright (C) 2003-2005 Andrew J. Armstrong

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  02111-1307  USA

 Author:
 Andrew J. Armstrong <andrew_armstrong@unwired.com.au>
*/

/**********************************************************************
**                                                                   **
** ALL CODE BELOW THIS POINT BELONGS TO THE XML PARSER. YOU MUST     **
** APPEND IT TO ANY REXX SOURCE FILE THAT REQUIRES AN XML PARSING    **
** CAPABILITY. SINCE REXX HAS NO 'LIBRARY' FUNCTIONALITY, A WAY TO   **
** AVOID HAVING DIFFERENT VERSIONS OF THE PARSER IN EACH OF YOUR     **
** REXX PROCS IS TO DYNAMICALLY APPEND A CENTRAL VERSION TO EACH OF  **
** YOUR REXX PROCS BEFORE EXECUTION.                                 **
**                                                                   **
** THE EXACT PROCEDURE TO FOLLOW DEPENDS ON YOUR PLATFORM, BUT...    **
** TO HELP YOU DO THIS, I HAVE INCLUDED A REXX PRE-PROCESSOR CALLED  **
** REXXPP THAT CAN BE USED TO SEARCH FOR 'INCLUDE' DIRECTIVES AND    **
** REPLACE THEM WITH THE SPECIFIED FILE CONTENTS. IT HAS BEEN TESTED **
** ON TSO, AND ON WIN32 USING REGINA REXX VERSION 3.3.               **
**                                                                   **
**********************************************************************/

/*REXX*****************************************************************
**                                                                   **
** NAME     - PARSEXML                                               **
**                                                                   **
** FUNCTION - A Rexx XML parser. It is non-validating, so DTDs and   **
**            XML schemas are ignored. Ok, DTD entities are processed**
**            but that's all.                                        **
**                                                                   **
** USAGE    - 1. Initialize the parser by:                           **
**                                                                   **
**               call initParser Ýoptions...¨                        **
**                                                                   **
**            2. Parse the XML file to build an in-memory model      **
**                                                                   **
**               returncode = parseFile('filename')                  **
**                ...or...                                           **
**               returncode = parseString('xml in a string')         **
**                                                                   **
**            3. Navigate the in-memory model with the DOM API. For  **
**               example:                                            **
**                                                                   **
**               say 'The document element is called',               **
**                                   getName(getDocumentElement())   **
**               say 'Children of the document element are:'         **
**               node = getFirstChild(getDocumentElement())          **
**               do while node <> ''                                 **
**                 if isElementNode(node)                            **
**                 then say 'Element node:' getName(node)            **
**                 else say '   Text node:' getText(node)            **
**                 node = getNextSibling(node)                       **
**               end                                                 **
**                                                                   **
**            4. Optionally, destroy the in-memory model:            **
**                                                                   **
**               call destroyParser                                  **
**                                                                   **
** INPUT    - An XML file containing:                                **
**              1. An optional XML prolog:                           **
**                 - 0 or 1 XML declaration:                         **
**                     <?xml version="1.0" encoding="..." ...?>      **
**                 - 0 or more comments, PIs, and whitespace:        **
**                     <!-- a comment -->                            **
**                     <?target string?>                             **
**                 - 0 or 1 document type declaration. Formats:      **
**                     <!DOCTYPE root SYSTEM "sysid">                **
**                     <!DOCTYPE root PUBLIC "pubid" SYSTEM "sysid"> **
**                     <!DOCTYPE root Ýinternal dtd¨>                **
**              2. An XML body:                                      **
**                 - 1 Document element containing 0 or more child   **
**                     elements. For example:                        **
**                     <doc attr1="value1" attr2="value2"...>        **
**                       Text of doc element                         **
**                       <child1 attr1="value1">                     **
**                         Text of child1 element                    **
**                       </child1>                                   **
**                       More text of doc element                    **
**                       <!-- an empty child element follows -->     **
**                       <child2/>                                   **
**                       Even more text of doc element               **
**                     </doc>                                        **
**                 - Elements may contain:                           **
**                   Unparsed character data:                        **
**                     <!ÝCDATAÝ...unparsed data...¨¨>               **
**                   Entity references:                              **
**                     &name;                                        **
**                   Character references:                           **
**                     &#nnnnn;                                      **
**                     &#xXXXX;                                      **
**              3. An XML epilog (which is ignored):                 **
**                 - 0 or more comments, PIs, and whitespace.        **
**                                                                   **
** API      - The basic setup/teardown API calls are:                **
**                                                                   **
**            initParser Ýoptions¨                                   **
**                Initialises the parser's global variables and      **
**                remembers any runtime options you specify. The     **
**                options recognized are:                            **
**                NOBLANKS - Suppress whitespace-only nodes          **
**                DEBUG    - Display some debugging info             **
**                DUMP     - Display the parse tree                  **
**                                                                   **
**            parseFile(filename)                                    **
**                Parses the XML data in the specified filename and  **
**                builds an in-memory model that can be accessed via **
**                the DOM API (see below).                           **
**                                                                   **
**            parseString(text)                                      **
**                Parses the XML data in the specified string.       **
**                                                                   **
**            destroyParser                                          **
**                Destroys the in-memory model and miscellaneous     **
**                global variables.                                  **
**                                                                   **
**          - In addition, the following utility API calls can be    **
**            used:                                                  **
**                                                                   **
**            removeWhitespace(text)                                 **
**                Returns the supplied text string but with all      **
**                whitespace characters removed, multiple spaces     **
**                replaced with single spaces, and leading and       **
**                trailing spaces removed.                           **
**                                                                   **
**            removeQuotes(text)                                     **
**                Returns the supplied text string but with any      **
**                enclosing apostrophes or double-quotes removed.    **
**                                                                   **
**            escapeText(text)                                       **
**                Returns the supplied text string but with special  **
**                characters encoded (for example, '<' becomes &lt;) **
**                                                                   **
**            toString(node)                                         **
**                Walks the document tree (beginning at the specified**
**                node) and returns a string in XML format.          **
**                                                                   **
** DOM API  - The DOM (ok, DOM-like) calls that you can use are      **
**            listed below:                                          **
**                                                                   **
**            Document query/navigation API calls                    **
**            -----------------------------------                    **
**                                                                   **
**            getRoot()                                              **
**                Returns the node number of the root node. This     **
**                can be used in calls requiring a 'node' argument.  **
**                In this implementation, getDocumentElement() and   **
**                getRoot() are (incorrectly) synonymous - this may  **
**                change, so you should use getDocumentElement()     **
**                in preference to getRoot().                        **
**                                                                   **
**            getDocumentElement()                                   **
**                Returns the node number of the document element.   **
**                The document element is the topmost element node.  **
**                You should use this in preference to getRoot()     **
**                (see above).                                       **
**                                                                   **
**            getName(node)                                          **
**                Returns the name of the specified node.            **
**                                                                   **
**            getNodeValue(node)                                     **
**            getText(node)                                          **
**                Returns the text content of an unnamed node. A     **
**                node without a name can only contain text. It      **
**                cannot have attributes or children.                **
**                                                                   **
**            getAttributeCount(node)                                **
**                Returns the number of attributes present on the    **
**                specified node.                                    **
**                                                                   **
**            getAttributeMap(node)                                  **
**                Builds a map of the attributes of the specified    **
**                node. The map can be accessed via the following    **
**                variables:                                         **
**                  g.!ATTRIBUTE.0 = The number of attributes mapped.**
**                  g.!ATTRIBUTE.n = The name of attribute 'n' (in   **
**                                   order of appearance). n > 0.    **
**                  g.!ATTRIBUTE.name = The value of the attribute   **
**                                   called 'name'.                  **
**                                                                   **
**            getAttributeName(node,n)                               **
**                Returns the name of the nth attribute of the       **
**                specified node (1 is first, 2 is second, etc).     **
**                                                                   **
**            getAttributeNames(node)                                **
**                Returns a space-delimited list of the names of the **
**                attributes of the specified node.                  **
**                                                                   **
**            getAttribute(node,name)                                **
**                Returns the value of the attribute called 'name' of**
**                the specified node.                                **
**                                                                   **
**            getAttribute(node,n)                                   **
**                Returns the value of the nth attribute of the      **
**                specified node (1 is first, 2 is second, etc).     **
**                                                                   **
**            setAttribute(node,name,value)                          **
**                Updates the value of the attribute called 'name'   **
**                of the specified node. If no attribute exists with **
**                that name, then one is created.                    **
**                                                                   **
**            setAttributes(node,name1,value1,name2,value2,...)      **
**                Updates the attributes of the specified node. Zero **
**                or more name/value pairs are be specified as the   **
**                arguments.                                         **
**                                                                   **
**            hasAttribute(node,name)                                **
**                Returns 1 if the specified node has an attribute   **
**                with the specified name, else 0.                   **
**                                                                   **
**            getParentNode(node)                                    **
**            getParent(node)                                        **
**                Returns the node number of the specified node's    **
**                parent. If the node number returned is 0, then the **
**                specified node is the root node.                   **
**                All nodes have a parent (except the root node).    **
**                                                                   **
**            getFirstChild(node)                                    **
**                Returns the node number of the specified node's    **
**                first child node.                                  **
**                                                                   **
**            getLastChild(node)                                     **
**                Returns the node number of the specified node's    **
**                last child node.                                   **
**                                                                   **
**            getChildNodes(node)                                    **
**            getChildren(node)                                      **
**                Returns a space-delimited list of node numbers of  **
**                the children of the specified node. You can use    **
**                this list to step through the children as follows: **
**                  children = getChildren(node)                     **
**                  say 'Node' node 'has' words(children) 'children' **
**                  do i = 1 to words(children)                      **
**                     child = word(children,i)                      **
**                     say 'Node' child 'is' getName(child)          **
**                  end                                              **
**                                                                   **
**            getChildrenByName(node,name)                           **
**                Returns a space-delimited list of node numbers of  **
**                the immediate children of the specified node which **
**                are called 'name'. Names are case-sensitive.       **
**                                                                   **
**            getElementsByTagName(node,name)                        **
**                Returns a space-delimited list of node numbers of  **
**                the descendants of the specified node which are    **
**                called 'name'. Names are case-sensitive.           **
**                                                                   **
**            getNextSibling(node)                                   **
**                Returns the node number of the specified node's    **
**                next sibling node. That is, the next node sharing  **
**                the same parent.                                   **
**                                                                   **
**            getPreviousSibling(node)                               **
**                Returns the node number of the specified node's    **
**                previous sibline node. That is, the previous node  **
**                sharing the same parent.                           **
**                                                                   **
**            getProcessingInstruction(name)                         **
**                Returns the value of the PI with the specified     **
**                target name.                                       **
**                                                                   **
**            getProcessingInstructionList()                         **
**                Returns a space-delimited list of the names of all **
**                PI target names.                                   **
**                                                                   **
**            getNodeType(node)                                      **
**                Returns a number representing the specified node's **
**                type. The possible values can be compared to the   **
**                following global variables:                        **
**                g.!ELEMENT_NODE                = 1                 **
**                g.!ATTRIBUTE_NODE              = 2                 **
**                g.!TEXT_NODE                   = 3                 **
**                g.!CDATA_SECTION_NODE          = 4                 **
**                g.!ENTITY_REFERENCE_NODE       = 5                 **
**                g.!ENTITY_NODE                 = 6                 **
**                g.!PROCESSING_INSTRUCTION_NODE = 7                 **
**                g.!COMMENT_NODE                = 8                 **
**                g.!DOCUMENT_NODE               = 9                 **
**                g.!DOCUMENT_TYPE_NODE          = 10                **
**                g.!DOCUMENT_FRAGMENT_NODE      = 11                **
**                g.!NOTATION_NODE               = 12                **
**                Note: as this exposes internal implementation      **
**                details, it is best not to use this routine.       **
**                Consider using isTextNode() etc instead.           **
**                                                                   **
**            isCDATA(node)                                          **
**                Returns 1 if the specified node is an unparsed     **
**                character data (CDATA) node, else 0. CDATA nodes   **
**                are used to contain content that you do not want   **
**                to be treated as XML data. For example, HTML data. **
**                                                                   **
**            isElementNode(node)                                    **
**                Returns 1 if the specified node is an element node,**
**                else 0.                                            **
**                                                                   **
**            isTextNode(node)                                       **
**                Returns 1 if the specified node is a text node,    **
**                else 0.                                            **
**                                                                   **
**            isCommentNode(node)                                    **
**                Returns 1 if the specified node is a comment node, **
**                else 0. Note: when a document is parsed, comment   **
**                nodes are ignored. This routine returns 1 iff a    **
**                comment node has been inserted into the in-memory  **
**                document tree by using createComment().            **
**                                                                   **
**            hasChildren(node)                                      **
**                Returns 1 if the specified node has one or more    **
**                child nodes, else 0.                               **
**                                                                   **
**            getDocType(doctype)                                    **
**                Gets the text of the <!DOCTYPE> prolog node.       **
**                                                                   **
**            Document creation/mutation API calls                   **
**            ------------------------------------                   **
**                                                                   **
**            createElement(name)                                    **
**                Returns the node number of a new empty element     **
**                node with the specified name. An element node can  **
**                have child nodes.                                  **
**                                                                   **
**            createTextNode(data)                                   **
**                Returns the node number of a new text node. A text **
**                node can *not* have child nodes.                   **
**                                                                   **
**            createCDATASection(data)                               **
**                Returns the node number of a new Character Data    **
**                (CDATA) node. A CDATA node can *not* have child    **
**                nodes. CDATA nodes are used to contain content     **
**                that you do not want to be treated as XML data.    **
**                For example, HTML data.                            **
**                                                                   **
**            createComment(data)                                    **
**                Returns the node number of a new commend node.     **
**                A command node can *not* have child nodes.         **
**                                                                   **
**            appendChild(node,parent)                               **
**                Appends the specified node to the end of the list  **
**                of children of the specified parent node.          **
**                                                                   **
**            insertBefore(node,refnode)                             **
**                Inserts node 'node' before the reference node      **
**                'refnode'.                                         **
**                                                                   **
**            removeChild(node)                                      **
**                Removes the specified node from its parent.        **
**                                                                   **
**            replaceChild(newnode,oldnode)                          **
**                Replaces the old child 'oldnode' with the new      **
**                child 'newnode'.                                   **
**                                                                   **
**            setAttribute(node,attrname,attrvalue)                  **
**                Adds or replaces the attribute called 'attrname'   **
**                on the specified node.                             **
**                                                                   **
**            removeAttribute(node,attrname)                         **
**                Removes the attribute called 'attrname' from the   **
**                specified node.                                    **
**                                                                   **
**            setDocType(doctype)                                    **
**                Sets the text of the <!DOCTYPE> prolog node.       **
**                                                                   **
** NOTES    - 1. This parser creates global variables and so its     **
**               operation may be severely jiggered if you update    **
**               any of them accidentally (or on purpose). The       **
**               variables you should avoid updating yourself are:   **
**                                                                   **
**               g.!ATTRIBUTE.n                                      **
**               g.!ATTRIBUTE.name                                   **
**               g.!ATTRSOK                                          **
**               g.!DTD                                              **
**               g.!ENDOFDOC                                         **
**               g.!ENTITIES                                         **
**               g.!ENTITY.name                                      **
**               g.!FIRST.n                                          **
**               g.!LAST.n                                           **
**               g.!NAME.n                                           **
**               g.!NEXT.n                                           **
**               g.!NEXTID                                           **
**               g.!OPTION.name                                      **
**               g.!OPTIONS                                          **
**               g.!PARENT.n                                         **
**               g.!PI                                               **
**               g.!PI.name                                          **
**               g.!PREV.n                                           **
**               g.!PUBLIC                                           **
**               g.!ROOT                                             **
**               g.!STACK                                            **
**               g.!SYSTEM                                           **
**               g.!TEXT.n                                           **
**               g.!TYPE.n                                           **
**               g.!WHITESPACE                                       **
**               g.!XML                                              **
**               g.?XML                                              **
**               g.?XML.VERSION                                      **
**               g.?XML.ENCODING                                     **
**               g.?XML.STANDALONE                                   **
**                                                                   **
**            2. To reduce the incidence of name clashes, procedure  **
**               names that are not meant to be part of the public   **
**               API have been prefixed with '_'.                    **
**                                                                   **
**                                                                   **
** AUTHOR   - Andrew J. Armstrong <andrew_armstrong@unwired.com.au>  **
**                                                                   **
** HISTORY  - Date     By       Reason (most recent at the top pls)  **
**            -------- -------- ------------------------------------ **
**            20051025 AJA      Now checks parentage before adding a **
**                              child node:                          **
**                              Fixed appendChild(id,parent)         **
**                              Fixed insertBefore(id,ref)           **
**            20051014 AJA      Added alias routine names to more    **
**                              closely match the DOM specification. **
**                              Specifically:                        **
**                              Added getNodeName()                  **
**                              Added getNodeValue()                 **
**                              Added getParentNode()                **
**                              Added getChildNodes()                **
**                              Added hasChildNodes()                **
**                              Added getElementsByTagName()      .  **
**            20050919 AJA      Added setAttributes helper routine.  **
**            20050914 AJA      Added createComment and isComment.   **
**            20050913 AJA      Added get/setDocType routines.       **
**            20050907 AJA      Added _setDefaultEntities routine.   **
**            20050601 AJA      Added '250d'x to whitespace for TSO. **
**            20050514 AJA      Removed getAttributes API call and   **
**                              reworked attribute processing.       **
**                              Added toString API call.             **
**            20040706 AJA      Added creation/modification support. **
**            20031216 AJA      Bugfix: _parseElement with no attrs  **
**                              causes crash.                        **
**            20031031 AJA      Correctly parse '/' in attributes.   **
**                              Fixed entity resolution.             **
**            20030912 AJA      Bugfix: Initialize sXmlData first.   **
**                              Bugfix: Correctly parse a naked '>'  **
**                              present in an attribute value.       **
**                              Enhancement: DUMP option now displays**
**                              first part of each text node.        **
**            20030901 AJA      Intial version.                      **
**                                                                   **
**********************************************************************/

  parse source . . sSourceFile .
  say 'You cannot invoke this rexx by itself!'
  say
  say 'This rexx is a collection of subroutines to be called'
  say 'from your own rexx procedures. You should either:'
  say '  - Append this procedure to your own rexx procedure,'
  say '    or,'
  say '  - Append the following line to your rexx:'
  say '    /* INCLUDE' sSourceFile '*/'
  say '    ...and run the rexx preprocessor:'
  say '    rexxpp myrexx myrexxpp'
  say '    This will create myrexxpp by appending this file to myrexx'
exit

/*-------------------------------------------------------------------*
 * Set up global variables for the parser
 *-------------------------------------------------------------------*/

initParser: procedure expose g.
  parse arg sOptions
  g. = '' /* Note: stuffs up caller who may have set g. variables */
  g.!OPTIONS = translate(sOptions)
  sOptions = 'DEBUG DUMP NOBLANKS'
  do i = 1 to words(sOptions)
    sOption = word(sOptions,i)
    g.!OPTION.sOption = wordpos(sOption,g.!OPTIONS) > 0
  end

  parse source sSystem sInvocation sSourceFile
  select
    when sSystem = 'WIN32'  then g.!WHITESPACE = '090a0d'x
    when sSystem = 'TSO'    then g.!WHITESPACE = '05250d'x
    otherwise                    g.!WHITESPACE = ''
  end

  g.!LEADERS = '_:ABCDEFGHIJKLMNOPQRSTUVWXYZ' ||,
                 'abcdefghijklmnopqrstuvwxyz'
  g.!OTHERS  = g.!LEADERS'.-0123456789'

  call _setDefaultEntities

  /* Not all of the following node types are used... */
  g.!ELEMENT_NODE                   = 1
  g.!ATTRIBUTE_NODE                 = 2
  g.!TEXT_NODE                      = 3
  g.!CDATA_SECTION_NODE             = 4
  g.!ENTITY_REFERENCE_NODE          = 5     /* NOT USED */
  g.!ENTITY_NODE                    = 6     /* NOT USED */
  g.!PROCESSING_INSTRUCTION_NODE    = 7     /* NOT USED */
  g.!COMMENT_NODE                   = 8
  g.!DOCUMENT_NODE                  = 9     /* NOT USED */
  g.!DOCUMENT_TYPE_NODE             = 10    /* NOT USED */
  g.!DOCUMENT_FRAGMENT_NODE         = 11    /* NOT USED */
  g.!NOTATION_NODE                  = 12    /* NOT USED */

  g.!ENDOFDOC = 0
return

/*-------------------------------------------------------------------*
 * Clean up parser
 *-------------------------------------------------------------------*/

destroyParser: procedure expose g.
  /* Note: it would be easy to just "drop g.", but this could
     possibly stuff up the caller who may be using other
     "g." variables...
     todo: revisit this one (parser may have to 'own' g. names)
  */
  drop g.?XML g.!ROOT g.!SYSTEM g.!PUBLIC g.!DTD
  do i = 1 to words(g.!PI)
    sName = word(g.!PI,i)
    drop g.!PI.sName
  end
  drop g.!PI
  do i = 1 to words(g.!ENTITIES)
    sName = word(g.!ENTITIES,i)
    drop g.!ENTITY.sName
  end
  drop g.!ENTITIES
  call _setDefaultEntities
  if datatype(g.!NEXTID,'WHOLE')
  then do
    do i = 1 to g.!NEXTID
      drop g.!PARENT.i g.!FIRST.i g.!LAST.i g.!PREV.i,
           g.!NEXT.i g.!NAME.i g.!TEXT.i
    end
  end
  drop g.!NEXTID g.!STACK g.!ENDOFDOC
return


/*-------------------------------------------------------------------*
 * Read a file into a string
 *-------------------------------------------------------------------*/

parseFile: procedure expose g.
  parse arg sFile
  parse source sSystem sInvocation sSourceFile
  sXmlData = ''
  select
    when sSystem = 'WIN32' then do
      sXmlData = charin(sFile,,chars(sFile))
    end
    when sSystem = 'TSO' then do
      address TSO
      junk = OUTTRAP('junk.') /* Trap and discard messages */
      'ALLOCATE DD(INPUT) DSN('sFile')'
      'EXECIO * DISKR INPUT (FINIS'
      'FREE DD(INPUT)'
      address
      do queued()
        parse pull sLine
        sXmlData = sXmlData || sLine
      end
      junk = OUTTRAP('OFF')
    end
    otherwise call _abort 'XML001E Unsupported system:' sSystem'.',
                          'How do you read files?'
  end
return parseString(sXmlData)

/*-------------------------------------------------------------------*
 * Parse a string containing XML
 *-------------------------------------------------------------------*/

parseString: procedure expose g.
  parse arg g.!XML
  call _parseXmlDecl
  do while pos('<',g.!XML) > 0
    parse var g.!XML sLeft'<'sData
    select
      when left(sData,1) = '?'         then call _parsePI      sData
      when left(sData,9) = '!DOCTYPE ' then call _parseDocType sData
      when left(sData,3) = '!--'       then call _parseComment sData
      otherwise                             call _parseElement sData
    end
  end
return 0

/*-------------------------------------------------------------------*
 * <?xml version="1.0" encoding="..." ...?>
 *-------------------------------------------------------------------*/

_parseXmlDecl: procedure expose g.
  if left(g.!XML,6) = '<?xml '
  then do
    parse var g.!XML '<?xml 'sXMLDecl'?>'g.!XML
    g.?xml = space(sXMLDecl)
    sTemp = _getNormalizedAttributes(g.?xml)
    parse var sTemp 'version='g.?xml.version'ff'x
    parse var sTemp 'encoding='g.?xml.encoding'ff'x
    parse var sTemp 'standalone='g.?xml.standalone'ff'x
  end
return

/*-------------------------------------------------------------------*
 * <?target string?>
 *-------------------------------------------------------------------*/

_parsePI: procedure expose g.
  parse arg '?'sProcessingInstruction'?>'g.!XML
  call _setProcessingInstruction sProcessingInstruction
return

/*-------------------------------------------------------------------*
 * <!DOCTYPE root SYSTEM "sysid">
 * <!DOCTYPE root SYSTEM "sysid" Ýinternal dtd¨>
 * <!DOCTYPE root PUBLIC "pubid" "sysid">
 * <!DOCTYPE root PUBLIC "pubid" "sysid" Ýinternal dtd¨>
 * <!DOCTYPE root Ýinternal dtd¨>
 *-------------------------------------------------------------------*/

_parseDocType: procedure expose g.
  parse arg '!DOCTYPE' sDocType'>'
  if g.!ROOT <> ''
  then call _abort 'XML002E Multiple "<!DOCTYPE" declarations'
  if pos('Ý',sDocType) > 0
  then do
    parse arg '!DOCTYPE' sDocType'Ý'g.!DTD'¨>'g.!XML
    parse var sDocType g.!ROOT sExternalId
    if sExternalId <> '' then call _parseExternalId sExternalId
    g.!DTD = strip(g.!DTD)
    call _parseDTD g.!DTD
  end
  else do
    parse arg '!DOCTYPE' g.!ROOT sExternalId'>'g.!XML
    if sExternalId <> '' then call _parseExternalId sExternalId
  end
  g.!ROOT = strip(g.!ROOT)
return

/*-------------------------------------------------------------------*
 * SYSTEM "sysid"
 * PUBLIC "pubid" "sysid"
 *-------------------------------------------------------------------*/

_parseExternalId: procedure expose g.
  parse arg sExternalIdType .
  select
    when sExternalIdType = 'SYSTEM' then do
      parse arg . g.!SYSTEM
      g.!SYSTEM = removeQuotes(g.!SYSTEM)
    end
    when sExternalIdType = 'PUBLIC' then do
      parse arg . g.!PUBLIC g.!SYSTEM
      g.!PUBLIC = removeQuotes(g.!PUBLIC)
      g.!SYSTEM = removeQuotes(g.!SYSTEM)
    end
    otherwise do
       parse arg sExternalEntityDecl
       call _abort 'XML003E Invalid external entity declaration:',
                   sExternalEntityDecl
    end
  end
return


/*-------------------------------------------------------------------*
 * <!ENTITY name "value">
 * <!ENTITY name SYSTEM "sysid">
 * <!ENTITY name PUBLIC "pubid" "sysid">
 * <!ENTITY % name pedef>
 * <!ELEMENT elementname contentspec>
 * <!ATTLIST elementname attrname attType DefaultDecl ...>
 * <!NOTATION name notationdef>
 *-------------------------------------------------------------------*/

_parseDTD: procedure expose g.
  parse arg sDTD
  do while pos('<!',sDTD) > 0
    parse var sDTD '<!'sDecl sName sValue'>'sDTD
    select
      when sDecl = 'ENTITY' then do
        parse var sValue sWord1 .
        select
          when sName = '%'       then nop
          when sWord1 = 'SYSTEM' then nop
          when sWord1 = 'PUBLIC' then nop
          otherwise do
            sValue = _resolveEntities(removeQuotes(sValue))
            call _setEntity sName,sValue
          end
        end
      end
      otherwise nop /* silently ignore other possibilities for now */
    end
  end
return

/*-------------------------------------------------------------------*
 * <!-- comment -->
 *-------------------------------------------------------------------*/

_parseComment: procedure expose g.
  parse arg sComment'-->'g.!XML
  /* silently ignore comments */
return

/*-------------------------------------------------------------------*
 * <tag attr1="value1" attr2="value2" ...>...</tag>
 * <tag attr1="value1" attr2="value2" .../>
 *-------------------------------------------------------------------*/

_parseElement: procedure expose g.
  parse arg sXML

  if g.!ENDOFDOC
  then call _abort 'XML004E Only one top level element is allowed.',
                  'Found:' subword(g.!XML,1,3)
  call _startDocument

  g.!XML = '<'sXML
  do while pos('<',g.!XML) > 0 & \g.!ENDOFDOC
    parse var g.!XML sLeft'<'sBetween'>'g.!XML

    if length(sLeft) > 0
    then call _characters sLeft

    if g.!OPTION.DEBUG
    then say g.!STACK sBetween

    select
      when left(sBetween,8) = '!ÝCDATAÝ' then do
        g.!XML = sBetween'>'g.!XML            /* ..back it out! */
        parse var g.!XML '!ÝCDATAÝ'sBetween'¨¨>'g.!XML
        call _characterData sBetween
      end
      when left(sBetween,3) = '!--' then do    /* <!-- comment --> */
        if right(sBetween,2) <> '--'
        then do  /* backup a bit and look for end-of-comment */
          g.!XML = sBetween'>'g.!XML
          if pos('-->',g.!XML) = 0
          then call _abort 'XML005E End of comment missing after:',
                          '<'g.!XML
          parse var g.!XML sComment'-->'g.!XML
        end
      end
      when left(sBetween,1) = '?' then do    /* <?target string?> */
        parse var sBetween '?'sProcessingInstruction'?'
        call _setProcessingInstruction sProcessingInstruction
      end
      when left(sBetween,1) = '/' then do    /* </tag> */
        call _endElement substr(sBetween,2)   /* tag */
      end
      when  right(sBetween,1) = '/'  /* <tag ...attrs.../> */
      then do
        parse var sBetween sTagName sAttrs
        if length(sAttrs) > 0                              /*20031216*/
        then sAttrs = substr(sAttrs,1,length(sAttrs)-1)    /*20031216*/
        else parse var sTagName sTagName'/'     /* <tag/>    20031216*/
        sAttrs = _getNormalizedAttributes(sAttrs)
        call _startElement sTagName sAttrs
        call _endElement sTagName
      end
      otherwise do              /* <tag ...attrs ...> ... </tag>  */
        parse var sBetween sTagName sAttrs
        sAttrs = _getNormalizedAttributes(sAttrs)
        if g.!ATTRSOK
        then do
          call _startElement sTagName sAttrs
        end
        else do /* back up a bit and look for the real end of tag */
          g.!XML = '<'sBetween'&gt;'g.!XML
          if pos('>',g.!XML) = 0
          then call _abort 'XML017E Missing end tag for:' sTagName
          /* reparse on next cycle avoiding premature '>'...*/
        end
      end
    end
  end

  call _endDocument
return

_startDocument: procedure expose g.
  g.!NEXTID = 0
  g.!STACK = 0
return

_startElement:  procedure expose g.
  parse arg sTagName sAttrs
  id = _getNextId()
  call _updateLinkage id
  g.!NAME.id = sTagName
  g.!TYPE.id = g.!ELEMENT_NODE
  call _addAttributes id,sAttrs
  cid = _pushElement(id)
return

_updateLinkage: procedure expose g.
  parse arg id
  parent = _peekElement()
  g.!PARENT.id = parent
  parentsLastChild = g.!LAST.parent
  g.!NEXT.parentsLastChild = id
  g.!PREV.id = parentsLastChild
  g.!LAST.parent = id
  if g.!FIRST.parent = ''
  then g.!FIRST.parent = id
return

_characterData: procedure expose g.
  parse arg sChars
  id = _getNextId()
  call _updateLinkage id
  g.!TEXT.id = sChars
  g.!TYPE.id = g.!CDATA_SECTION_NODE
return

_characters: procedure expose g.
  parse arg sChars
  sText = _resolveEntities(sChars)
  if g.!OPTION.NOBLANKS & removeWhitespace(sText) = ''
  then return
  id = _getNextId()
  call _updateLinkage id
  g.!TEXT.id = sText
  g.!TYPE.id = g.!TEXT_NODE
return

_endElement: procedure expose g.
  parse arg sTagName
  id = _popElement()
  g.!ENDOFDOC = id = 1
  if sTagName == g.!NAME.id
  then nop
  else call _abort,
           'XML006E Expecting </'g.!NAME.id'> but found </'sTagName'>'
return

_endDocument: procedure expose g.
  id = _peekElement()
  if id <> 0
  then call _abort 'XML007E End of document tag missing: 'id getName(id)
  if g.!ROOT <> '' & g.!ROOT <> getName(getRoot())
  then call _abort 'XML008E Root element name "'getName(getRoot())'"',
                  'does not match DTD root "'g.!ROOT'"'

  if g.!OPTION.DUMP
  then call _displayTree
return

_displayTree: procedure expose g.
  say   right('',4),
        right('',4),
        left('',12),
        right('',6),
        '--child--',
        '-sibling-',
        'attribute'
  say   right('id',4),
        right('type',4),
        left('name',12),
        right('parent',6),
        right('1st',4),
        right('last',4),
        right('prev',4),
        right('next',4),
        right('1st',4),
        right('last',4)
  do id = 1 to g.!NEXTID
    if g.!PARENT.id <> '' | id = 1 /* skip orphans */
    then do
      select
        when g.!TYPE.id = g.!CDATA_SECTION_NODE then sName = '#CDATA'
        when g.!TYPE.id = g.!TEXT_NODE          then sName = '#TEXT'
        otherwise                                    sName = g.!NAME.id
      end
      say right(id,4),
          right(g.!TYPE.id,4),
          left(sName,12),
          right(g.!PARENT.id,6),
          right(g.!FIRST.id,4),
          right(g.!LAST.id,4),
          right(g.!PREV.id,4),
          right(g.!NEXT.id,4),
          right(g.!FIRSTATTR.id,4),
          right(g.!LASTATTR.id,4),
          left(removeWhitespace(g.!TEXT.id),19)
    end
  end
return

_pushElement: procedure expose g.
  parse arg id
  g.!STACK = g.!STACK + 1
  nStackDepth = g.!STACK
  g.!STACK.nStackDepth = id
return id

_popElement: procedure expose g.
  n = g.!STACK
  if n = 0
  then id = 0
  else do
    id = g.!STACK.n
    g.!STACK = g.!STACK - 1
  end
return id

_peekElement: procedure expose g.
  n = g.!STACK
  if n = 0
  then id = 0
  else id = g.!STACK.n
return id

_getNextId: procedure expose g.
  g.!NEXTID = g.!NEXTID + 1
return g.!NEXTID

_addAttributes: procedure expose g.
  parse arg id,sAttrs
  do while pos('ff'x,sAttrs) > 0
    parse var sAttrs sAttrName'='sAttrValue 'ff'x sAttrs
    sAttrName = removeWhitespace(sAttrName)
    call _addAttribute id,sAttrName,sAttrValue
  end
return

_addAttribute: procedure expose g.
  parse arg id,sAttrName,sAttrValue
  aid = _getNextId()
  g.!TYPE.aid = g.!ATTRIBUTE_NODE
  g.!NAME.aid = sAttrName
  g.!TEXT.aid = _resolveEntities(sAttrValue)
  g.!PARENT.aid = id
  g.!NEXT.aid = ''
  g.!PREV.aid = ''
  if g.!FIRSTATTR.id = '' then g.!FIRSTATTR.id = aid
  if g.!LASTATTR.id <> ''
  then do
    lastaid = g.!LASTATTR.id
    g.!NEXT.lastaid = aid
    g.!PREV.aid = lastaid
  end
  g.!LASTATTR.id = aid
return

/*-------------------------------------------------------------------*
 * Resolve attributes to an internal normalized form:
 *   name1=value1'ff'x name2=value2'ff'x ...
 * This makes subsequent parsing of attributes easier.
 * Note: this design may fail for certain UTF-8 content
 *-------------------------------------------------------------------*/

_getNormalizedAttributes: procedure expose g.
  parse arg sAttrs
  g.!ATTRSOK = 0
  sNormalAttrs = ''
  parse var sAttrs sAttr'='sAttrs
  do while sAttr <> ''
    sAttr = removeWhitespace(sAttr)
    select
      when left(sAttrs,1) = '"' then do
        if pos('"',sAttrs,2) = 0 /* if no closing "   */
        then return ''           /* then not ok       */
        parse var sAttrs '"'sAttrValue'"'sAttrs
      end
      when left(sAttrs,1) = "'" then do
        if pos("'",sAttrs,2) = 0 /* if no closing '   */
        then return ''           /* then not ok       */
        parse var sAttrs "'"sAttrValue"'"sAttrs
      end
      otherwise return ''        /* no opening ' or " */
    end
    sAttrValue = removeWhitespace(sAttrValue)
    sNormalAttrs = sNormalAttrs sAttr'='sAttrValue'ff'x
    parse var sAttrs sAttr'='sAttrs
  end
  g.!ATTRSOK = 1
  /* Note: always returns a leading blank and is required by
    this implementation */
return _resolveEntities(sNormalAttrs)


/*-------------------------------------------------------------------*
 *  entityref  := '&' entityname ';'
 *  entityname := ('_',':',letter) (letter,digit,'.','-','_',':')*
 *-------------------------------------------------------------------*/


_resolveEntities: procedure expose g.
  parse arg sText
  if pos('&',sText) > 0
  then do
    sNewText = ''
    do while pos('&',sText) > 0
      parse var sText sLeft'&'sEntityRef
      if pos(left(sEntityRef,1),'#'g.!LEADERS) > 0
      then do
        n = verify(sEntityRef,g.!OTHERS,'NOMATCH',2)
        if n > 1 & substr(sEntityRef,n,1) = ';'
        then do
          sEntityName = left(sEntityRef,n-1)
          sEntity = _getEntity(sEntityName)
          sNewText = sNewText || sLeft || sEntity
          sText = substr(sEntityRef,n+1)
        end
        else do
          sNewText = sNewText || sLeft'&'
          sText = sEntityRef
        end
      end
      else do
        sNewText = sNewText || sLeft'&'
        sText = sEntityRef
      end
    end
    sText = sNewText || sText
  end
return sText

/*-------------------------------------------------------------------*
 * &entityname;
 * &#nnnnn;
 * &#xXXXX;
 *-------------------------------------------------------------------*/

_getEntity: procedure expose g.
  parse arg sEntityName
  if left(sEntityName,1) = '#' /* #nnnnn  OR  #xXXXX */
  then sEntity = _getCharacterEntity(sEntityName)
  else sEntity = _getStringEntity(sEntityName)
return sEntity

/*-------------------------------------------------------------------*
 * &#nnnnn;
 * &#xXXXX;
 *-------------------------------------------------------------------*/

_getCharacterEntity: procedure expose g.
  parse arg sEntityName
  if substr(sEntityName,2,1) = 'x'
  then do
    parse arg 3 xEntity
    if datatype(xEntity,'XADECIMAL')
    then sEntity = x2c(xEntity)
    else call _abort,
              'XML009E Invalid hexadecimal character reference: ',
              '&'sEntityName';'
  end
  else do
    parse arg 2 nEntity
    if datatype(nEntity,'WHOLE')
    then sEntity = d2c(nEntity)
    else call _abort,
              'XML010E Invalid decimal character reference:',
              '&'sEntityName';'
  end
return sEntity

/*-------------------------------------------------------------------*
 * &entityname;
 *-------------------------------------------------------------------*/

_getStringEntity: procedure expose g.
  parse arg sEntityName
  if wordpos(sEntityName,g.!ENTITIES) = 0
  then call _abort 'XML011E Unable to resolve entity &'sEntityName';'
  sEntity = g.!ENTITY.sEntityName
return sEntity

_setDefaultEntities: procedure expose g.
  g.!ENTITIES = ''
  g.!ESCAPES = '<>&"' || "'"
  sEscapes = 'lt gt amp quot apos'
  do i = 1 to length(g.!ESCAPES)
    c = substr(g.!ESCAPES,i,1)
    g.!ESCAPE.c = word(sEscapes,i)
  end
  call _setEntity 'amp','&'
  call _setEntity 'lt','<'
  call _setEntity 'gt','>'
  call _setEntity 'apos',"'"
  call _setEntity 'quot','"'
return

_setEntity: procedure expose g.
  parse arg sEntityName,sValue
  if wordpos(sEntityName,g.!ENTITIES) = 0
  then g.!ENTITIES = g.!ENTITIES sEntityName
  g.!ENTITY.sEntityName = sValue
return

_setProcessingInstruction: procedure expose g.
  parse arg sTarget sInstruction
  if wordpos(sTarget,g.!PI) = 0
  then g.!PI = g.!PI sTarget
  g.!PI.sTarget = strip(sInstruction)
return

_abort: procedure expose g.
  parse arg sMsg
  say 'ABORT:' sMsg
  call destroyParser
exit 16

_clearNode: procedure expose g.
  parse arg id
  g.!NAME.id       = ''
  g.!PARENT.id     = ''
  g.!FIRST.id      = ''
  g.!LAST.id       = ''
  g.!NEXT.id       = ''
  g.!PREV.id       = ''
  g.!TEXT.id       = ''
  g.!TYPE.id       = ''
  g.!FIRSTATTR.id  = ''
  g.!LASTATTR.id   = ''
return

/*-------------------------------------------------------------------*
 * Utility API
 *-------------------------------------------------------------------*/

removeWhitespace: procedure expose g.
  parse arg sData
return space(translate(sData,'',g.!WHITESPACE))

removeQuotes: procedure expose g.
  parse arg sValue
  c = left(sValue,1)
  select
    when c = '"' then parse var sValue '"'sValue'"'
    when c = "'" then parse var sValue "'"sValue"'"
    otherwise nop
  end
return sValue

/*-------------------------------------------------------------------*
 * Document Object Model ;-) API
 *-------------------------------------------------------------------*/

getRoot: procedure expose g.
return 1

getDocumentElement: procedure expose g.
return 1

getName: getNodeName: procedure expose g.
  parse arg id
return g.!NAME.id

getText: getNodeValue: procedure expose g.
  parse arg id
return g.!TEXT.id

getNodeType: procedure expose g.
  parse arg id
return g.!TYPE.id

isElementNode: procedure expose g.
  parse arg id
return g.!TYPE.id = g.!ELEMENT_NODE

isTextNode: procedure expose g.
  parse arg id
return g.!TYPE.id = g.!TEXT_NODE

isCommentNode: procedure expose g.
  parse arg id
return g.!TYPE.id = g.!COMMENT_NODE

isCDATA: procedure expose g.
  parse arg id
return g.!TYPE.id = g.!CDATA_SECTION_NODE

/**
 * This is similar to the DOM API's NamedNodeMap concept, except that
 * the returned structure is built in global variables (so calling
 * it a second time will destroy the structure built on the first
 * call). The other difference is that you can access the attributes
 * by name or ordinal number. For example, g.!ATTRIBUTE.2 is the value
 * of the second attribute. If the second attribute was called 'x',
 * then you could also access it by g.!ATTRIBUTE.x (as long as x='x')
 * Note, g.!ATTRIBUTE.0 will always contain a count of the number of
 * attributes in the map.
 */
getAttributeMap: procedure expose g.
  parse arg id
  if datatype(g.!ATTRIBUTE.0,'WHOLE')
  then do
    do i = 1 to g.!ATTRIBUTE.0
      sName = g.!ATTRIBUTE.i
      drop g.!ATTRIBUTE.sName g.!ATTRIBUTE.i
    end
  end
  g.!ATTRIBUTE.0 = 0
  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */
  do i = 1 while aid <> 0
    sName = g.!NAME.aid
    sValue = g.!TEXT.aid
    g.!ATTRIBUTE.0 = i
    g.!ATTRIBUTE.i = sName
    g.!ATTRIBUTE.sName = sValue
  end
return

getAttributeCount: procedure expose g.
  parse arg id
  nAttributeCount = 0
  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */
  do while aid <> ''
    nAttributeCount = nAttributeCount + 1
    aid = g.!NEXT.aid /* id of next attribute */
  end
return nAttributeCount

getAttributeNames: procedure expose g.
  parse arg id
  sNames = ''
  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */
  do while aid <> ''
    sNames = sNames g.!NAME.aid
    aid = g.!NEXT.aid /* id of next attribute */
  end
return strip(sNames)

getAttribute: procedure expose g.
  parse arg id,sAttrName
  sValue = ''
  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */
  if aid <> ''
  then do
    n = 1
    do while aid <> '' & (g.!NAME.aid <> sAttrName & n <> sAttrName)
      aid = g.!NEXT.aid
      n = n + 1
    end
    if g.!NAME.aid = sAttrName | n = sAttrName
    then sValue = g.!TEXT.aid
  end
return sValue

getAttributeName: procedure expose g.
  parse arg id,n
  aid = g.!FIRSTATTR.id /* id of first attribute of element 'id' */
  sName = ''
  if aid <> ''
  then do
    do i = 1 while aid <> '' & i < n
      aid = g.!NEXT.aid
    end
    if i = n then sName = g.!NAME.aid
  end
return sName

hasAttribute: procedure expose g.
  parse arg id,sAttrName
  bHasAttribute = 0
  aid = g.!FIRSTATTR.id
  if aid <> ''
  then do
    do while aid <> '' & g.!NAME.aid <> sAttrName
      aid = g.!NEXT.aid
    end
    bHasAttribute = g.!NAME.aid = sAttrName
  end
return bHasAttribute

getParent: getParentNode: procedure expose g.
  parse arg id
return g.!PARENT.id

getFirstChild: procedure expose g.
  parse arg id
return g.!FIRST.id

getLastChild: procedure expose g.
  parse arg id
return g.!LAST.id

getChildren: getChildNodes: procedure expose g.
  parse arg id
  ids = ''
  id = getFirstChild(id)
  do while id <> ''
    ids = ids id
    id = getNextSibling(id)
  end
return strip(ids)

getChildrenByName: procedure expose g.
  parse arg id,sName
  ids = ''
  id = getFirstChild(id)
  do while id <> ''
    if getName(id) = sName
    then ids = ids id
    id = getNextSibling(id)
  end
return strip(ids)

getElementsByTagName: procedure expose g.
  parse arg id,sName
  ids = ''
  id = getFirstChild(id)
  do while id <> ''
    if getName(id) = sName
    then ids = ids id
    ids = ids getElementsByTagName(id,sName)
    id = getNextSibling(id)
  end
return space(ids)

getNextSibling: procedure expose g.
  parse arg id
return g.!NEXT.id

getPreviousSibling: procedure expose g.
  parse arg id
return g.!PREV.id

getProcessingInstruction: procedure expose g.
  parse arg sTarget
return g.!PI.sTarget

getProcessingInstructionList: procedure expose g.
return g.!PI

hasChildren: hasChildNodes: procedure expose g.
  parse arg id
return g.!FIRST.id <> ''

createDocument: procedure expose g.
  parse arg sName
  if sName = ''
  then call _abort,
            'XML016E Must specify a root tag name:',
            'createDocument('sName')'
  call destroyParser
  g.!NEXTID = 0
  id = _getNextId()
  call _clearNode id
  g.!TYPE.id = g.!ELEMENT_NODE /* ...not strictly true */
  g.!NAME.id = sName
  g.!PARENT.id = 0
return id

createElement: procedure expose g.
  parse arg sName
  id = _getNextId()
  call _clearNode id
  g.!TYPE.id = g.!ELEMENT_NODE
  g.!NAME.id = sName
return id

createCDATASection: procedure expose g.
  parse arg sCharacterData
  id = _getNextId()
  call _clearNode id
  g.!TYPE.id = g.!CDATA_SECTION_NODE
  g.!TEXT.id = sCharacterData
return id

createTextNode: procedure expose g.
  parse arg sData
  id = _getNextId()
  call _clearNode id
  g.!TYPE.id = g.!TEXT_NODE
  g.!TEXT.id = sData
return id

appendChild: procedure expose g.
  parse arg id, parent
  if g.!TYPE.parent <> g.!ELEMENT_NODE
  then call _abort,
            'XML012E Can only add children to an ELEMENT node:',
            'appendChild('id','parent')'
  if g.!PARENT.id = ''
  then g.!PARENT.id = parent
  else call _abort,
            'XML017E Node' getNodeName(id) 'is already a child of',
            getNodeName(g.!PARENT.id)':',
            'appendChild('id','parent')'
  parentsLastChild = g.!LAST.parent
  g.!NEXT.parentsLastChild = id
  g.!PREV.id = parentsLastChild
  g.!LAST.parent = id
  if g.!FIRST.parent = ''
  then g.!FIRST.parent = id
return

insertBefore: procedure expose g.
  parse arg id, ref
  parent = g.!PARENT.ref
  if g.!TYPE.parent <> g.!ELEMENT_NODE
  then call _abort,
            'XML012E Can only add children to an ELEMENT node:',
            'insertBefore('id','ref')'
  if g.!PARENT.id = ''
  then g.!PARENT.id = parent
  else call _abort,
            'XML017E Node' getNodeName(id) 'is already a child of',
            getNodeName(g.!PARENT.id)':',
            'insertBefore('id','ref')'
  g.!NEXT.id = ref
  g.!PREV.ref = id
  if g.!FIRST.parent = ref
  then g.!FIRST.parent = id
return

removeChild: procedure expose g.
  parse arg id
  parent = g.!PARENT.id
  if g.!TYPE.parent <> g.!ELEMENT_NODE
  then call _abort,
            'XML013E Can only remove children from an ELEMENT node:',
            'removeChild('id')'
  next = g.!NEXT.id
  prev = g.!PREV.id
  g.!NEXT.prev = next
  g.!PREV.next = prev
  if g.!FIRST.parent = id
  then g.!FIRST.parent = next
  if g.!LAST.parent = id
  then g.!LAST.parent = prev
  call _clearNode id
return

replaceChild: procedure expose g.
  parse arg id, extant
  parent = g.!PARENT.extant
  if g.!TYPE.parent <> g.!ELEMENT_NODE
  then call _abort,
            'XML014E Can only replace children of an ELEMENT node:',
            'replaceChild('id','extant')'
  g.!PARENT.id = parent
  g.!NEXT.id = g.!NEXT.extant
  g.!PREV.id = g.!PREV.extant
  if g.!FIRST.parent = extant
  then g.!FIRST.parent = id
  if g.!LAST.parent = extant
  then g.!LAST.parent = id
  call _clearNode extant
return

setAttribute: procedure expose g.
  parse arg id,sAttrName,sValue
  if g.!TYPE.id <> g.!ELEMENT_NODE
  then call _abort,
            'XML015E Can only have attributes on an ELEMENT node:',
            'setAttribute('id','sAttrName','sValue')'
  aid = g.!FIRSTATTR.id
  do while aid <> '' & g.!NAME.aid <> sAttrName
    aid = g.!NEXT.aid
  end
  if aid <> '' & g.!NAME.aid = sAttrName
  then g.!TEXT.aid = sValue
  else call _addAttribute id,sAttrName,sValue
return

setAttributes: procedure expose g.
  parse arg id /* ,name1,value1,name2,value2,...,namen,valuen */
  do i = 2 to arg() by 2
    sAttrName = arg(i)
    sValue = arg(i+1)
    call setAttribute id,sAttrName,sValue
  end
return

removeAttribute: procedure expose g.
  parse arg id,sAttrName
  if g.!TYPE.id <> g.!ELEMENT_NODE
  then call _abort,
            'XML015E Can only have attributes on an ELEMENT node:',
            'removetAttribute('id','sAttrName')'
  aid = g.!FIRSTATTR.id
  do while aid <> '' & g.!NAME.aid <> sAttrName
    aid = g.!NEXT.aid
  end
  if aid <> '' & g.!NAME.aid = sAttrName
  then do
    prevaid = g.!PREV.aid
    nextaid = g.!NEXT.aid
    if prevaid = ''  /* if we are deleting the first attribute */
    then g.!FIRSTATTR.id = nextaid /* make next attr the first */
    else g.!NEXT.prevaid = nextaid /* link prev attr to next attr */
    if nextaid = '' /* if we are deleting the last attribute */
    then g.!LASTATTR.id  = prevaid /* make prev attr the last */
    else g.!PREV.nextaid = prevaid /* link next attr to prev attr */
    call _clearNode aid
  end
return

toString: procedure expose g.
  parse arg node
  if node = '' then node = getRoot()
  if node = getRoot()
  then sXML = _getProlog()_getNode(node)
  else sXML = _getNode(node)
return sXML

_getProlog: procedure expose g.
  if g.?xml.version = ''
  then sVersion = '1.0'
  else sVersion = g.?xml.version
  if g.?xml.encoding = ''
  then sEncoding = 'UTF-8'
  else sEncoding = g.?xml.encoding
  if g.?xml.standalone = ''
  then sStandalone = 'yes'
  else sStandalone = g.?xml.standalone
  sProlog = '<?xml version="'sVersion'"',
            'encoding="'sEncoding'"',
            'standalone="'sStandalone'"?>'
return sProlog

_getNode: procedure expose g.
  parse arg node
  select
    when g.!TYPE.node = g.!ELEMENT_NODE then,
         sXML = _getElementNode(node)
    when g.!TYPE.node = g.!TEXT_NODE then,
         sXML = escapeText(removeWhitespace(getText(node)))
    when g.!TYPE.node = g.!ATTRIBUTE_NODE then,
         sXML = getName(node)'="'escapeText(getText(node))'"'
    when g.!TYPE.node = g.!CDATA_SECTION_NODE then,
         sXML = '<!ÝCDATAÝ'getText(node)'¨¨>'
    otherwise sXML = '' /* TODO: throw an error here? */
  end
return sXML

_getElementNode: procedure expose g.
  parse arg node
  sName = getName(node)
  sAttrs = ''
  attr = g.!FIRSTATTR.node
  do while attr <> ''
    sAttrs = sAttrs _getNode(attr)
    attr = g.!NEXT.attr
  end
  if hasChildren(node)
  then do
    if sAttrs = ''
    then sXML = '<'sName'>'
    else sXML = '<'sName strip(sAttrs)'>'
    child = getFirstChild(node)
    do while child <> ''
      sXML = sXML || _getNode(child)
      child = getNextSibling(child)
    end
    sXML = sXML'</'sName'>'
  end
  else do
    if sAttrs = ''
    then sXML = '<'sName'/>'
    else sXML = '<'sName strip(sAttrs)'/>'
  end
return sXML

escapeText: procedure expose g.
  parse arg sText
  n = verify(sText,g.!ESCAPES,'MATCH')
  if n > 0
  then do
    sNewText = ''
    do while n > 0
      sLeft = ''
      n = n - 1
      if n = 0
      then parse var sText c +1 sText
      else parse var sText sLeft +(n) c +1 sText
      sNewText = sNewText || sLeft'&'g.!ESCAPE.c';'
      n = verify(sText,g.!ESCAPES,'MATCH')
    end
    sText = sNewText || sText
  end
return sText

/*-------------------------------------------------------------------*
 * SYSTEM "sysid"
 * PUBLIC "pubid" "sysid"
 *-------------------------------------------------------------------*/
setDocType: procedure expose g.
  parse arg sDocType
  g.!DOCTYPE = sDocType
return

getDocType: procedure expose g.
return g.!DOCTYPE

createComment: procedure expose g.
  parse arg sData
  id = _getNextId()
  call _clearNode id
  g.!TYPE.id = g.!COMMENT_NODE
  g.!TEXT.id = sData
return id
/*INCLUDEZ parsexml.rexx */
/*INCLUDEZ pretty.rexx */
