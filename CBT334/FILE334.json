{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011804000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE334.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE334.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x0c'", "DS1TRBAL": "b'>\\xb0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x80\\x00\\x0b\\x02\\x80\\x00\\x0e\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CRYPT": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12o\\x17\\x17\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-06T17:17:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "XSSGSCH"}, "text": "/* crypt.h (dummy version) -- do not perform encryption\n * Hardly worth copyrighting :-)\n */\n\n#ifdef CRYPT\n#  undef CRYPT      /* dummy version */\n#endif\n\n#define RAND_HEAD_LEN  12  /* length of encryption random header */\n\n#define zencode\n#define zdecode\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C370": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x12\\x7f\\x18\\x07\\x00t\\x00t\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-07T18:07:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "XSSGSCH"}, "text": "#ifndef C370_H\n#define C370_H\n\n#include <stdio.h>\n#include <stddef.h>\n\nvoid printhex( void *buf, int len );\n\nextern unsigned char ebcdic_ascii\u00dd\u00a8;\nextern unsigned char ascii_ebcdic\u00dd\u00a8;\n\nvoid ebcdic2ascii( unsigned char *buf, unsigned size );\nvoid ascii2ebcdic( unsigned char *buf, unsigned size );\n\n/* dirent.h definitions */\n\n#define NAMELEN     8\n\nstruct dirent {\n   struct dirent *d_next;\n   char   d_name\u00ddNAMELEN+1\u00a8;\n};\n\ntypedef struct _DIR {\n   struct  dirent *D_list;\n   struct  dirent *D_curpos;\n   char            D_path\u00ddFILENAME_MAX\u00a8;\n} DIR;\n\nDIR *          opendir(const char *dirname);\nstruct dirent *readdir(DIR *dirp);\nvoid           rewinddir(DIR *dirp);\nint            closedir(DIR *dirp);\n\n/* sys/types.h definitions   */\n\n#define off_t       long\n#define mode_t      int\n\n/* fcntl.h     definitions   */\n\n#define O_RDONLY    0x0001\n#define O_WRONLY    0x0002\n#define O_RDWR      0x0004\n\n#define O_CREAT     0x0100\n#define O_TRUNC     0x0200\n#define O_EXCL      0x0400\n#define O_APPEND    0x0800\n\n#define O_BINARY    0x1000\n#define O_MEMORY    0x2000\n#define O_RECORD    0x4000\n#define O_DCB       0x8000\nextern unsigned char dcb_flags\u00dd\u00a8;       /* used by fopen and O_DCB */\n   /* with a leading comma, eg:  \",recfm=fb,lrecl=80,blksize=6160\" */\n\nint  open(const char *path, int access);\n\n/* stdio.h         definitions   */\n\n#define fseek myfseek\n/* #define fread myfread */\nint  fileno( FILE *fp );\n\n/* unistd.h        definitions   */\n\nint      access( const char *filename, int how );\nint      close( int fd );\nint      isatty( int fd );\noff_t    lseek( int fd, off_t offset, int whence );\nsize_t   read( int fd, void *buf, size_t size );\nint      unlink( char *filename );\nint      write( int fd, void *buf, size_t len );\n\n/* io.h        definitions   */\n\nint  eof( int fd );\nint  setmode(int fd, int access);\nint  tell( int fd );\n\n/* stat.h      definitions   */\n\nstruct stat {\n  short  st_dev;\n  short  st_ino;\n  short  st_mode;\n  short  st_nlink;\n  int    st_uid;\n  int    st_gid;\n  long   st_size;\n  long   st_atime;\n  long   st_mtime;\n  long   st_ctime;\n  FILE   *fp;\n  char   fname\u00ddFILENAME_MAX\u00a8;\n};\n\nint    chmod( const char* filename, mode_t mode );\nint    stat(const char *filename, struct stat *buf );\nint    fstat(int fd, struct stat *buf );\n\n#define S_IFMT       0xFFFF\n#define _FLDATA(m) (*(fldata_t *) &m)\n#define S_ISDIR(m) (_FLDATA(m).__dsorgPDSdir)\n#define S_ISREG(m) (_FLDATA(m).__dsorgPO \u00a6 \\\n                      _FLDATA(m).__dsorgPDSmem \u00a6 \\\n                      _FLDATA(m).__dsorgPS)\n#define S_ISBLK(m) (_FLDATA(m).__recfmBlk)\n#define S_ISMEM(m) (_FLDATA(m).__dsorgMem)\n\n/* errno.h     definitions   */\n\n#define ENOENT -1\n\n#endif /* C370_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETOPT": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x12\\x7f\\x165\\x00\\x84\\x00\\x84\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-07T16:35:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "XSSGSCH"}, "text": "/* Declarations for getopt.\n   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation,\n\n   This program is free software; you can redistribute it and/or modify\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n#ifndef _GETOPT_H\n#define _GETOPT_H 1\n\n#ifdef C370\n#pragma map( getopt_long, \"GETOPT01\" )\n#pragma map( getopt_long_only, \"GETOPT02\" )\n#endif /* C370 */\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nextern char *optarg;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns EOF, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\nextern int optind;\n\n/* Callers store zero here to inhibit the error message `getopt' prints\n   for unrecognized options.  */\n\nextern int opterr;\n\n/* Set to an option character which was unrecognized.  */\n\nextern int optopt;\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vec\n   of `struct option' terminated by an element containing a name which i\n   zero.\n\n   The field `has_arg' is:\n   no_argument          (or 0) if the option does not take an argument,\n   required_argument    (or 1) if the option requires an argument,\n   optional_argument    (or 2) if the option takes an optional argument.\n\n   If the field `flag' is not NULL, it points to a variable that is set\n   to the value given in the field `val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an `int' to\n   a compiled-in constant, such as set a value from `optarg', set the\n   option's `flag' field to zero and its `val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero `flag' field, `getopt'\n   returns the contents of the `val' field.  */\n\nstruct option\n{\n#if     __STDC__\n  const char *name;\n#else\n  char *name;\n#endif\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n};\n\n/* Names for the values of the `has_arg' field of `struct option'.  */\n\n#define no_argument             0\n#define required_argument       1\n#define optional_argument       2\n\n#if __STDC__ \u00a6\u00a6 defined(PROTO)\n#if defined(__GNU_LIBRARY__)\n/* Many other libraries have conflicting prototypes for getopt, with\n   differences in the consts, in stdlib.h.  To avoid compilation\n   errors, only prototype getopt for the GNU C library.  */\nextern int getopt (int argc, char *const *argv, const char *shortopts);\n#endif /* not __GNU_LIBRARY__ */\nextern int getopt_long (int argc, char *const *argv, const char *shortop,\n                        const struct option *longopts, int *longind);\nextern int getopt_long_only (int argc, char *const *argv,\n                             const char *shortopts,\n                             const struct option *longopts, int *longind);\n\n/* Internal only.  Users should not call this directly.  */\nextern int _getopt_internal (int argc, char *const *argv,\n                             const char *shortopts,\n                             const struct option *longopts, int *longind,\n                             int long_only);\n#else /* not __STDC__ */\nextern int getopt ();\nextern int getopt_long ();\nextern int getopt_long_only ();\n\nextern int _getopt_internal ();\n#endif /* not __STDC__ */\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif /* _GETOPT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GZIP": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x12\\x7f\\x11\\x13\\x01?\\x01?\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-07T11:13:00", "lines": 319, "newlines": 319, "modlines": 0, "user": "XSSGSCH"}, "text": "/* gzip.h -- common declarations for all gzip modules\n * Copyright (C) 1992-1993 Jean-loup Gailly.\n * This is free software; you can redistribute it and/or modify it under\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#if defined(__STDC__) \u00a6\u00a6 defined(PROTO)\n#  define OF(args)  args\n#else\n#  define OF(args)  ()\n#endif\n\n#ifdef __STDC__\n   typedef void *voidp;\n#else\n   typedef char *voidp;\n#endif\n\n/* I don't like nested includes, but the string and io functions are used\n * too often\n */\n#include <stdio.h>\n#if !defined(NO_STRING_H) \u00a6\u00a6 defined(STDC_HEADERS)\n#  include <string.h>\n#  if !defined(STDC_HEADERS) && !defined(NO_MEMORY_H) && !defined(__GNUC__)\n#    include <memory.h>\n#  endif\n#  define memzero(s, n)     memset ((voidp)(s), 0, (n))\n#else\n#  include <strings.h>\n#  define strchr            index\n#  define strrchr           rindex\n#  define memcpy(d, s, n)   bcopy((s), (d), (n))\n#  define memcmp(s1, s2, n) bcmp((s1), (s2), (n))\n#  define memzero(s, n)     bzero((s), (n))\n#endif\n\n#ifndef RETSIGTYPE\n#  define RETSIGTYPE void\n#endif\n\n#define local static\n\ntypedef unsigned char  uch;\ntypedef unsigned short ush;\ntypedef unsigned long  ulg;\n\n/* Return codes from gzip */\n#define OK      0\n#define ERROR   1\n#define WARNING 2\n\n/* Compression methods (see algorithm.doc) */\n#define STORED      0\n#define COMPRESSED  1\n#define PACKED      2\n#define LZHED       3\n/* methods 4 to 7 reserved */\n#define DEFLATED    8\n#define MAX_METHODS 9\nextern int method;         /* compression method */\n\n/* To save memory for 16 bit systems, some arrays are overlaid between\n * the various modules:\n * deflate:  prev+head   window      d_buf  l_buf  outbuf\n * unlzw:    tab_prefix  tab_suffix  stack  inbuf  outbuf\n * inflate:              window             inbuf\n * unpack:               window             inbuf  prefix_len\n * unlzh:    left+right  window      c_table inbuf c_len\n * For compression, input is done in window\u00a2|. For decompression, outp  ut\n * is done in window except for unlzw.\n */\n\n#ifndef INBUFSIZ\n#  ifdef SMALL_MEM\n#    define INBUFSIZ  0x2000  /* input buffer size */\n#  else\n#    define INBUFSIZ  0x8000  /* input buffer size */\n#  endif\n#endif\n#define INBUF_EXTRA  64     /* required by unlzw() */\n\n#ifndef OUTBUFSIZ\n#  ifdef SMALL_MEM\n#    define OUTBUFSIZ   8192  /* output buffer size */\n#  else\n#    define OUTBUFSIZ  16384  /* output buffer size */\n#  endif\n#endif\n#define OUTBUF_EXTRA 2048   /* required by unlzw() */\n\n#ifndef DIST_BUFSIZE\n#  ifdef SMALL_MEM\n#    define DIST_BUFSIZE 0x2000 /* buffer for distances, see trees.c */\n#  else\n#    define DIST_BUFSIZE 0x8000 /* buffer for distances, see trees.c */\n#  endif\n#endif\n\n#ifdef DYN_ALLOC\n#  define EXTERN(type, array)  extern type * near array\n#  define DECLARE(type, array, size)  type * near array\n#  define ALLOC(type, array, size) { \\\n      array = (type*)fcalloc((size_t)(((size)+1L)/2), 2*sizeof(type)); \\\n      if (array == NULL) error(\"insufficient memory\"); \\\n   }\n#  define FREE(array) {if (array != NULL) fcfree(array), array=NULL;}\n#else\n#  define EXTERN(type, array)  extern type array\u00dd\u00a8\n#  define DECLARE(type, array, size)  type array\u00ddsize\u00a8\n#  define ALLOC(type, array, size)\n#  define FREE(array)\n#endif\n\nEXTERN(uch, inbuf);          /* input buffer */\nEXTERN(uch, outbuf);         /* output buffer */\nEXTERN(ush, d_buf);          /* buffer for distances, see trees.c */\nEXTERN(uch, window);         /* Sliding window and suffix table (unlzw) */\n#define tab_suffix window\n#ifndef MAXSEG_64K\n#  define tab_prefix prev    /* hash link (see deflate.c) */\n#  define head (prev+WSIZE)  /* hash head (see deflate.c) */\n   EXTERN(ush, tab_prefix);  /* prefix code (see unlzw.c) */\n#else\n#  define tab_prefix0 prev\n#  define head tab_prefix1\n   EXTERN(ush, tab_prefix0); /* prefix for even codes */\n   EXTERN(ush, tab_prefix1); /* prefix for odd  codes */\n#endif\n\nextern unsigned insize; /* valid bytes in inbuf */\nextern unsigned inptr;  /* index of next byte to be processed in inbuf */\nextern unsigned outcnt; /* bytes in output buffer */\n\nextern long bytes_in;   /* number of input bytes */\nextern long bytes_out;  /* number of output bytes */\nextern long header_bytes;/* number of bytes in gzip header */\n\n#define isize bytes_in\n/* for compatibility with old zip sources (to be cleaned) */\n\nextern int  ifd;        /* input file descriptor */\nextern int  ofd;        /* output file descriptor */\nextern char ifname\u00dd\u00a8;       /* input file name or \"stdin\" */\nextern char ofname\u00dd\u00a8;       /* output file name or \"stdout\" */\nextern char *progname;  /* program name */\n\nextern long time_stamp; /* original time stamp (modification time) */\nextern long ifile_size; /* input file size, -1 for devices (debug only) */\n\ntypedef int file_t;     /* Do not use stdio */\n#define NO_FILE  (-1)   /* in memory compression */\n\n\n#define PACK_MAGIC     \"\\037\\036\" //* Magic header for packed files\n#define GZIP_MAGIC     \"\\037\\213\" //* Magic header for gzip files, 1F 8B\n#define OLD_GZIP_MAGIC \"\\037\\236\" //* Magic header for gzip 0.5 = freeze\n#define LZH_MAGIC      \"\\037\\240\" //* Magic header for SCO LZH Compress f\n#define PKZIP_MAGIC    \"\\120\\113\\003\\004\" //* Magic header for pkzip file\n\n/* gzip flag byte */\n#define ASCII_FLAG   0x01 //* bit 0 set: file probably ascii text\n#define CONTINUATION 0x02 //* bit 1 set: continuation of multi-part gzip\n#define EXTRA_FIELD  0x04 //* bit 2 set: extra field present\n#define ORIG_NAME    0x08 //* bit 3 set: original file name present\n#define COMMENT      0x10 //* bit 4 set: file comment present\n#define ENCRYPTED    0x20 //* bit 5 set: file is encrypted\n#define RESERVED     0xC0 //* bit 6,7:   reserved\n\n/* internal file attribute */\n#define UNKNOWN 0xffff\n#define BINARY  0\n#define ASCII   1\n\n#ifndef WSIZE\n#  define WSIZE 0x8000     //* window size--must be a power of two, and *\n#endif                     /*  at least 32K for zip's deflate method */\n\n#define MIN_MATCH  3\n#define MAX_MATCH  258\n/* The minimum and maximum match lengths */\n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n/* Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the MIN_MATCH+1.\n */\n\n#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)\n/* In order to simplify the code, particularly on 16 bit machines, match\n * distances are limited to MAX_DIST instead of WSIZE.\n */\n\n#ifdef C370                /* needed for EBCDIC-ASCII conversions */\nextern int ascii;          /* end-of-lines and local OS conventions */\nextern int decompress;     /* decompress? (-d) */\n#endif /* C370 */\nextern int decrypt;        /* flag to turn on decryption */\nextern int exit_code;      /* program exit code */\nextern int verbose;        /* be verbose (-v) */\nextern int quiet;          /* be quiet (-q) */\nextern int level;          /* compression level */\nextern int test;           /* check .z file integrity */\nextern int to_stdout;      /* output to stdout (-c) */\nextern int save_orig_name; /* set if original name must be saved */\n\n#define get_byte()  (inptr < insize ? inbuf\u00ddinptr++\u00a8 : fill_inbuf(0))\n#define try_byte()  (inptr < insize ? inbuf\u00ddinptr++\u00a8 : fill_inbuf(1))\n\n/* put_byte is used for the compressed output, put_ubyte for the\n * uncompressed output. However unlzw() uses window for its\n * suffix table instead of its output buffer, so it does not use put_uby\n * (to be cleaned up).\n */\n#define put_byte(c) {outbuf\u00ddoutcnt++\u00a8=(uch)(c); if (outcnt==OUTBUFSIZ)\\\n   flush_outbuf();}\n#define put_ubyte(c) {window\u00ddoutcnt++\u00a8=(uch)(c); if (outcnt==WSIZE)\\\n   flush_window();}\n\n/* Output a 16 bit value, lsb first */\n#define put_short(w) \\\n{ if (outcnt < OUTBUFSIZ-2) { \\\n    outbuf\u00ddoutcnt++\u00a8 = (uch) ((w) & 0xff); \\\n    outbuf\u00ddoutcnt++\u00a8 = (uch) ((ush)(w) >> 8); \\\n  } else { \\\n    put_byte((uch)((w) & 0xff)); \\\n    put_byte((uch)((ush)(w) >> 8)); \\\n  } \\\n}\n\n/* Output a 32 bit value to the bit stream, lsb first */\n#define put_long(n) { \\\n    put_short((n) & 0xffff); \\\n    put_short(((ulg)(n)) >> 16); \\\n}\n\n#define seekable()    0  /* force sequential output */\n#define translate_eol 0  /* no option -a yet */\n\n#define tolow(c)  tolower(c)  /* force to lower case */\n\n/* Macros for getting two-byte and four-byte header values */\n#define SH(p) ((ush)(uch)((p)\u00dd0\u00a8) \u00a6 ((ush)(uch)((p)\u00dd1\u00a8) << 8))\n#define LG(p) ((ulg)(SH(p)) \u00a6 ((ulg)(SH((p)+2)) << 16))\n\n/* Diagnostic functions */\n#ifdef DEBUG\n#  define Assert(cond,msg) {if(!(cond)) error(msg);}\n#  define Trace(x) fprintf x\n#  define Tracev(x) {if (verbose) fprintf x ;}\n#  define Tracevv(x) {if (verbose>1) fprintf x ;}\n#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}\n#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}\n#else\n#  define Assert(cond,msg)\n#  define Trace(x)\n#  define Tracev(x)\n#  define Tracevv(x)\n#  define Tracec(c,x)\n#  define Tracecv(c,x)\n#endif\n\n#define WARN(msg) {if (!quiet) fprintf msg ; \\\n                   if (exit_code == OK) exit_code = WARNING;}\n\n        /* in zip.c: */\nextern int zip        OF((int in, int out));\nextern int file_read  OF((char *buf,  unsigned size));\n\n        /* in unzip.c */\nextern int unzip      OF((int in, int out));\nextern int check_zipfile OF((int in));\n\n        /* in unpack.c */\nextern int unpack     OF((int in, int out));\n\n        /* in unlzh.c */\nextern int unlzh      OF((int in, int out));\n\n        /* in gzip.c */\nRETSIGTYPE abort_gzip OF((void));\n\n        /* in deflate.c */\nvoid lm_init OF((int pack_level, ush *flags));\nulg  deflate OF((void));\n\n        /* in trees.c */\nvoid ct_init     OF((ush *attr, int *method));\nint  ct_tally    OF((int dist, int lc));\nulg  flush_block OF((char *buf, ulg stored_len, int eof));\n\n        /* in bits.c */\nvoid     bi_init    OF((file_t zipfile));\nvoid     send_bits  OF((int value, int length));\nunsigned bi_reverse OF((unsigned value, int length));\nvoid     bi_windup  OF((void));\nvoid     copy_block OF((char *buf, unsigned len, int header));\nextern   int (*read_buf) OF((char *buf, unsigned size));\n\n        /* in util.c: */\nextern int copy           OF((int in, int out));\nextern ulg  updcrc        OF((uch *s, unsigned n));\nextern void clear_bufs    OF((void));\nextern int  fill_inbuf    OF((int eof_ok));\nextern void flush_outbuf  OF((void));\nextern void flush_window  OF((void));\nextern void write_buf     OF((int fd, voidp buf, unsigned cnt));\nextern char *strlwr       OF((char *s));\nextern char *basename     OF((char *fname));\nextern void make_simple_name OF((char *name));\nextern char *add_envopt   OF((int *argcp, char ***argvp, char *env));\nextern void error         OF((char *m));\nextern void warn          OF((char *a, char *b));\nextern void read_error    OF((void));\nextern void write_error   OF((void));\nextern void display_ratio OF((long num, long den, FILE *file));\nextern voidp xmalloc      OF((unsigned int size));\n\n        /* in inflate.c */\nextern int inflate OF((void));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LZW": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x11/\\x00\\x98\\x12o\\x16P\\x00*\\x00*\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-04-22T00:00:00", "modifydate": "1998-05-06T16:50:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "XSSGSCH"}, "text": "/* lzw.h -- define the lzw functions.\n * Copyright (C) 1992-1993 Jean-loup Gailly.\n * This is free software; you can redistribute it and/or modify it under\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#if !defined(OF) && defined(lint)\n#  include \"gzip.h\"\n#endif\n\n#ifndef BITS\n#  define BITS 16\n#endif\n#define INIT_BITS 9              /* Initial number of bits per code */\n\n#define LZW_MAGIC  \"\\037\\235\"   /* Magic header for lzw files, 1F 9D */\n\n#define BIT_MASK    0x1f /* Mask for 'number of compression bits' */\n/* Mask 0x20 is reserved to mean a fourth header byte, and 0x40 is free.\n * It's a pity that old uncompress does not check bit 0x20. That makes\n * extension of the format actually undesirable because old compress\n * would just crash on the new format instead of giving a meaningful\n * error message. It does check the number of bits, but it's more\n * helpful to say \"unsupported format, get a new version\" than\n * \"can only handle 16 bits\".\n */\n\n#define BLOCK_MODE  0x80\n/* Block compression: if table is full and compression rate is dropping,\n * clear the dictionary.\n */\n\n#define LZW_RESERVED 0x60 /* reserved bits */\n\n#define CLEAR  256       /* flush the dictionary */\n#define FIRST  (CLEAR+1) /* first free entry */\n\nextern int maxbits;      /* max bits per code for LZW */\nextern int block_mode;   /* block compress mode -C compatible with 2.0 */\n\nextern int lzw    OF((int in, int out));\nextern int unlzw  OF((int in, int out));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REVISION": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x12o\\x00\\x98\\x12o\\x16\\x06\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-06T00:00:00", "modifydate": "1998-05-06T16:06:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XSSGSCH"}, "text": "/* revision.h -- define the version number\n * Copyright (C) 1992-1993 Jean-loup Gailly.\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n#define VERSION \"1.2.3\"\n#define PATCHLEVEL 0\n#define REVDATE \"24 Jun 93\"\n\n/* This version does not support compression into old compress format: */\n#ifdef LZW\n#  undef LZW\n#endif\n\n/* $Id: revision.h,v 0.24 1993/06/17 11:48:02 jloup Exp $ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAILOR": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x12_\\x00\\x98\\x12_\\x18\\x06\\x01E\\x01E\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-05T00:00:00", "modifydate": "1998-05-05T18:06:00", "lines": 325, "newlines": 325, "modlines": 0, "user": "XSSGSCH"}, "text": "/* tailor.h -- target dependent definitions\n * Copyright (C) 1992-1993 Jean-loup Gailly.\n * This is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License, see the file COPYING.\n */\n\n/* The target dependent definitions should be defined here only.\n * The target dependent functions should be defined in tailor.c.\n */\n\n/* $Id: tailor.h,v 0.18 1993/06/14 19:32:20 jloup Exp $ */\n\n#if defined(__MSDOS__) && !defined(MSDOS)\n#  define MSDOS\n#endif\n\n#if defined(__OS2__) && !defined(OS2)\n#  define OS2\n#endif\n\n#if defined(OS2) && defined(MSDOS) /* MS C under OS/2 */\n#  undef MSDOS\n#endif\n\n#ifdef MSDOS\n#  ifdef __GNUC__\n     /* DJGPP version 1.09+ on MS-DOS.\n      * The DJGPP 1.09 stat() function must be upgraded before gzip will\n      * fully work.\n      * No need for DIRENT, since <unistd.h> defines POSIX_SOURCE which\n      * implies DIRENT.\n      */\n#    define near\n#  else\n#    define MAXSEG_64K\n#    ifdef __TURBOC__\n#      define NO_UTIME\n#      define NO_OFF_T\n#    else /* MSC */\n#      define HAVE_SYS_UTIME_H\n#      define NO_UTIME_H\n#    endif\n#  endif\n#  define PATH_SEP2 '\\\\'\n#  define PATH_SEP3 ':'\n#  define MAX_PATH_LEN  128\n#  define NO_MULTIPLE_DOTS\n#  define MAX_EXT_CHARS 3\n#  define Z_SUFFIX \"z\"\n#  define NO_CHOWN\n#  define PROTO\n#  define STDC_HEADERS\n#  define NO_SIZE_CHECK\n#  define casemap(c) tolow(c) /* Force file names to lower case */\n#  include <io.h>\n#  define OS_CODE  0x00\n#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)\n#  if !defined(NO_ASM) && !defined(ASMV)\n#    define ASMV\n#  endif\n#else\n#  define near\n#endif\n\n#ifdef OS2\n#  define PATH_SEP2 '\\\\'\n#  define PATH_SEP3 ':'\n#  define MAX_PATH_LEN  260\n#  ifdef OS2FAT\n#    define NO_MULTIPLE_DOTS\n#    define MAX_EXT_CHARS 3\n#    define Z_SUFFIX \"z\"\n#  endif\n#  define NO_CHOWN\n#  define PROTO\n#  define STDC_HEADERS\n#  define casemap(c) tolow(c)\n#  include <io.h>\n#  define OS_CODE  0x06\n#  define SET_BINARY_MODE(fd) setmode(fd, O_BINARY)\n#  ifdef _MSC_VER\n#    define HAVE_SYS_UTIME_H\n#    define NO_UTIME_H\n#    define MAXSEG_64K\n#    undef near\n#    define near _near\n#  endif\n#  ifdef __EMX__\n#    define HAVE_SYS_UTIME_H\n#    define NO_UTIME_H\n#    define DIRENT\n#    define EXPAND(argc,argv) \\\n       {_response(&argc, &argv); _wildcard(&argc, &argv);}\n#  endif\n#  ifdef __BORLANDC__\n#    define DIRENT\n#  endif\n#  ifdef __ZTC__\n#    define NO_DIR\n#    define NO_UTIME_H\n#    include <dos.h>\n#    define EXPAND(argc,argv) \\\n       {response_expand(&argc, &argv);}\n#  endif\n#endif\n\n#ifdef MSDOS\n#  ifdef __TURBOC__\n#    include <alloc.h>\n#    define DYN_ALLOC\n     /* Turbo C 2.0 does not accept static allocations of large arrays */\n     void * fcalloc (unsigned items, unsigned size);\n     void fcfree (void *ptr);\n#  else /* MSC */\n#    include <malloc.h>\n#    define fcalloc(nitems,itemsize) halloc((long)(nitems),(itemsize))\n#    define fcfree(ptr) hfree(ptr)\n#  endif\n#else\n#  ifdef MAXSEG_64K\n#    define fcalloc(items,size) calloc((items),(size))\n#  else\n#    define fcalloc(items,size) malloc((size_t)(items)*(size_t)(size))\n#  endif\n#  define fcfree(ptr) free(ptr)\n#endif\n\n#if defined(VAXC) \u00a6\u00a6 defined(VMS)\n#  define PATH_SEP '|'\n#  define PATH_SEP2 ':'\n#  define SUFFIX_SEP ';'\n#  define NO_MULTIPLE_DOTS\n#  define Z_SUFFIX \"-gz\"\n#  define RECORD_IO 1\n#  define casemap(c) tolow(c)\n#  define OS_CODE  0x02\n#  define OPTIONS_VAR \"GZIP_OPT\"\n#  define STDC_HEADERS\n#  define NO_UTIME\n#  define EXPAND(argc,argv) vms_expand_args(&argc,&argv);\n#  include <file.h>\n#  define unlink delete\n#  ifdef VAXC\n#    define NO_FCNTL_H\n#    include <unixio.h>\n#  endif\n#endif\n\n#ifdef AMIGA\n#  define PATH_SEP2 ':'\n#  define STDC_HEADERS\n#  define casemap(c) tolow(c) /* Force file names to lower case */\n#  define OS_CODE  0x01\n#  define ASMV\n#  ifdef __GNUC__\n#    define DIRENT\n#    define HAVE_UNISTD_H\n#  else /* SASC */\n#    define NO_STDIN_FSTAT\n#    define SYSDIR\n#    define NO_SYMLINK\n#    define NO_CHOWN\n#    define NO_FCNTL_H\n#    include <fcntl.h> /* for read() and write() */\n#    define direct dirent\n     extern void _expand_args(int *argc, char ***argv);\n#    define EXPAND(argc,argv) _expand_args(&argc,&argv);\n#    undef  O_BINARY /* disable useless --ascii option */\n#  endif\n#endif\n\n#if defined(ATARI) \u00a6\u00a6 defined(atarist)\n#  ifndef STDC_HEADERS\n#    define STDC_HEADERS\n#    define HAVE_UNISTD_H\n#    define DIRENT\n#  endif\n#  define ASMV\n#  define OS_CODE  0x05\n#  ifdef TOSFS\n#    define NO_SYMLINK\n#    define NO_MULTIPLE_DOTS\n#    define MAX_EXT_CHARS 3\n#    define Z_SUFFIX \"z\"\n#    define NO_CHOWN\n#  endif\n#endif\n\n#ifdef MACOS\n#  define PATH_SEP ':'\n#  define DYN_ALLOC\n#  define PROTO\n#  define NO_STDIN_FSTAT\n#  define NO_CHOWN\n#  define NO_UTIME\n#  define chmod(file, mode) (0)\n#  define OPEN(name, flags, mode) open(name, flags)\n#  define OS_CODE  0x07\n#  ifdef MPW\n#    define isatty(fd) ((fd) <= 2)\n#  endif\n#endif\n\n#ifdef __50SERIES /* Prime/PRIMOS */\n#  define PATH_SEP '>'\n#  define STDC_HEADERS\n#  define NO_MEMORY_H\n#  define NO_UTIME_H\n#  define NO_UTIME\n#  define NO_CHOWN\n#  define NO_STDIN_FSTAT\n#  define NO_SIZE_CHECK\n#  define NO_SYMLINK\n#  define RECORD_IO  1\n#  define casemap(c)  tolow(c) /* Force file names to lower case */\n#  define put_char(c) put_byte((c) & 0x7F)\n#  define get_char(c) ascii2pascii(get_byte())\n#  define OS_CODE  0x0F    /* temporary, subject to change */\n#  ifdef SIGTERM\n#    undef SIGTERM         /* We don't want a signal handler for SIGTERM */\n#  endif\n#endif\n\n#ifdef C370\n# define STDC_HEADERS\n# define NO_FCNTL_H\n# define NO_UTIME_H\n# define NO_SYMLINK\n# define NO_UTIME\n# define NO_CHOWN\n# define DIRENT\n# define PROTO\n# define NO_STDIN_FSTAT\n# define NO_SIZE_CHECK\n# define NO_PIPE_TIMESTAMP\n# define NO_OFF_T\n# define OPEN(name, flags, mode) open(name, flags)\n# define SET_BINARY_MODE(fd)     setmode(fd, O_BINARY)\n# define MAX_PATH_LEN            FILENAME_MAX\n# include \"c370.h\"\n\n#pragma map( inflate_codes, \"INFLAT01\" )\n#pragma map( inflate_stored, \"INFLAT02\" )\n#pragma map( inflate_fixed, \"INFLAT03\" )\n#pragma map( inflate_dynamic, \"INFLAT04\" )\n#pragma map( inflate_block, \"INFLAT05\" )\n#endif /* C370 */\n\n#ifdef WIN32\n#  define OS_CODE  0x0b\n#endif\n\n#ifdef TOPS20\n#  define OS_CODE  0x0a\n#endif\n\n#ifndef unix\n#  define NO_ST_INO /* don't rely on inode numbers */\n#endif\n\n\n        /* Common defaults */\n\n#ifndef OS_CODE\n#  define OS_CODE  0x03  /* assume Unix */\n#endif\n\n#ifndef PATH_SEP\n#  define PATH_SEP '/'\n#endif\n\n#ifndef casemap\n#  define casemap(c) (c)\n#endif\n\n#ifndef OPTIONS_VAR\n#  define OPTIONS_VAR \"GZIP\"\n#endif\n\n#ifndef Z_SUFFIX\n#  define Z_SUFFIX \".gz\"\n#endif\n\n#ifdef MAX_EXT_CHARS\n#  define MAX_SUFFIX  MAX_EXT_CHARS\n#else\n#  define MAX_SUFFIX  30\n#endif\n\n#ifndef MAKE_LEGAL_NAME\n#  ifdef NO_MULTIPLE_DOTS\n#    define MAKE_LEGAL_NAME(name)   make_simple_name(name)\n#  else\n#    define MAKE_LEGAL_NAME(name)\n#  endif\n#endif\n\n#ifndef MIN_PART\n#  define MIN_PART 3\n   /* keep at least MIN_PART chars between dots in a file name. */\n#endif\n\n#ifndef EXPAND\n#  define EXPAND(argc,argv)\n#endif\n\n#ifndef RECORD_IO\n#  define RECORD_IO 0\n#endif\n\n#ifndef SET_BINARY_MODE\n#  define SET_BINARY_MODE(fd)\n#endif\n\n#ifndef OPEN\n#  define OPEN(name, flags, mode) open(name, flags, mode)\n#endif\n\n#ifndef get_char\n#  define get_char() get_byte()\n#endif\n\n#ifndef put_char\n#  define put_char(c) put_byte(c)\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT334/FILE334.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT334", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}