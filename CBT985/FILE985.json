{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013707000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1293292, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 18, "INMDSNAM": "CBT.V500.FILE985.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1293292, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE985.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x16\\x0f'", "DS1TRBAL": "b'\\x0f$'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n{\\x00\\x01\\n|\\x00\\x08\\x00\\x17'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x02\\x01 \\x16O\\x01 \\x16O\\x15\\x06\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T15:06:02", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  985\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE985\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 72 MEMBERS COUNTED; CUMULATIVE SIZE IS 11,862 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/12/20    15:06:02    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00!\\x00!\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:09", "lines": 33, "newlines": 33, "modlines": 0, "user": "MLEWIN"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01 \\x16O\\x01 \\x16O\\x15\\x03\\x00:\\x00:\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T15:03:06", "lines": 58, "newlines": 58, "modlines": 0, "user": "MLEWIN"}, "text": "Dear Sam,\n\nI hope that you are in good health.\n\nI would like to ask you the following favor:\n\nI would like to replace the present FILE985\n(File # 985 REXX execs from Marius Lewin)\nwith the replacement file that I am sending.\n\nI added a number of rexx including:\n\nu an edit macro executing a z/OS Unix command with standard input\n      the presently edited member and standard output the same\n      member (as info lines or as a replacement after saving the\n      edited member).\n\nvu  view or edit a library member in UTF-8.\n\ncp shows terminal code page at top right of screen.\n\nguessutf8 a called rexx which tries to provide a guess on whether\n      the received st\n\nlazy displays on the same screen in terminal codepage, in\n      IBM-1047 (Unix) and in a provided string or \"The quick\n      brown fox jumps over the lazy dog\".\n\nlastcmd and retp two rexx with different code providing the last\n      command or prev\n\nrexxmac  An example of an edit macro in rexx's clothing.\n\nt   A rexx timer. It displays every minute a small box with the\n    number of minute (default: one hour).\n\nscr  refresh panel cache.\n\nhumpty  extracts data records from a non compressed, non\n           encrypted ADRDSSU DUMP with RECFM=FB\n\nflat   rexx to sequentalize a library.\n\n\nThe original source PDS in IBM-1147 EBCDIC French codepage was\nconverted to the US IBM-1140 EBCDIC codepage then XMITed and\ndownloaded in binary by FTP.  The XMIted file contains a $$README\nsummary member and an acknowledgment member named ACK.\n\nI am sending the XMITed file.\n\nI thank you for making my rexx execs available on cbttape.org.\n\nAll the best of everything to you and your family.\n\nMarius Lewin\nmarius.lewin@gmail.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x04g\\x04g\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 1127, "newlines": 1127, "modlines": 0, "user": "MLEWIN"}, "text": "______________________________________________________________________________\n\nTitle: Rexx with Unix commands or executing another rexx given as parameter.\n       and miscellaneous rexx.\nAuthor: Marius Lewin.\n______________________________________________________________________________\n\nThis summary is divided in three parts:\n1) rexx executing z/OS Unix commands.\n2) rexx executing another rexx given as parameter.\n3) Miscellaneous rexx.\n______________________________________________________________________________\n\nrexx executing z/OS Unix commands\n\n   unix\n        Rexx and edit macro.\n        Executes BPXWUNIX.\n\n        If used as an edit macro,\n           1) all the parameters constitute the Unix command, and\n           2) the edited member or file is used as STDIN.\n\n        If used as a rexx,\n        if the last parameter is a valid dsn or dsn(mbr) then\n           1) the last parameter is used for STDIN and\n           2) only the previous parameters constitute the Unix command.\n        otherwise all parameters constitute the Unix command.\n\n        In View, edit macro unix invokation:\n        Command ===> unix grep -E 'ab.c'\n        will obtain the dsname and member name and have bpxwunix\n        execute with command\n        grep -E 'ab.c'\n        and dsname(member) as standard input.\n        Command ===> unix cal\n\n        Examples of rexx use:\n        Command ===> cmde      to preserve lower case options and regex\n        Enter TSO commands below:\n        ===> unix cal\n        ===> unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(grep05)\n        ===> viewit unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(grep05)\n        ===> viewit forallm unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(*)\n         viewit forallm unix grep -E -n 'cmd' noview userid.TEST(*)\n         viewit foralld forallm unix grep -E -n 'cmd' noview userid.T*S%(*)\n\n         Example of batch use:\n\n          //TSOSH    EXEC PGM=IKJEFT1B\n          //SYSTSPRT DD SYSOUT=*\n          //SYSTSIN  DD *\n          unix cd /tmp; dd:tsosh arg1 arg2\n          //* dd:tsoh replaced by a temporary file in /tmp, thereafter removed\n          //SYSEXEC  DD DISP=SHR,DSN=XXXXXX.TEST  Contains UNIX rexx\n          //TSOSH    DD *,DLM=EOF\n          /*    rexx  Needed: / in column 1 and * in column 2 on first line */\n          /*                  rexx is first word in comment on first line.  */\n           trace r\n           parse arg therest\n           say \"therest = \"therest\n           say \"abc\"\n           'cal' /* implicit address sh under z/OS Unix */\n           exit\n          EOF\n\n   u\n        u is an edit macro executing a z/OS Unix command.\n\n        Input to the z/OS Unix command is the\n        presently edited file.\n        The result of the z/OS Unix command, if not empty,\n        replaces the presently edited file,\n        unless a supplementary keyword 'info' is added .\n        If 'info' is added to the Unix command (anywhere)\n        the result of the Unix command is placed into infolines.\n\n        The user may cancel the result with:\n        Command ===> can\n        or restore the previous content of a library member with:\n        Command ===> u r  (or u re, u res, u rest etc... or u u)\n        or save the result.\n\n        If the word 'info', in mixed case, does not appear at right\n        of u, then edit macro u by default, saves the previous content\n        of a non empty edited library member in another member\n        called 'SAVEU' before replacing this member\n        by the result of an Unix command.\n\n        If keyword 'info', in mixed case, is placed anywhere after u,\n        then the result of an Unix command\n        does not replace the content but is added\n        at top of member or sequential file, as infolines.\n        These infolines may be deleted with RES or made datalines with\n        line commands MD and MDD.\n        The previous content is unchanged and saved in member 'SAVEU'.\n\n        Examples of use in View or Edit:\n\n        Command ===> u           (or u help)        <- shows help\n        Command ===> u u         (or u r or u re)   <- restore\n        Command ===> u cut -c 1-10                  <- first 10 char\n        Command ===> u cut -c 1-10,12-              <- col 11 disappear\n        Command ===> u sed 's/A.*b/DEF/g'           <- case sensitive\n        Command ===> u iconv -f 1047 -t 1147        <- Unix to French\n        Command ===> u awk '{print $1}'             <- Keep 1st field\n        Command ===> u cal 2020                     <- all year\n        Command ===> u cal sep 1752                 <- missing days\n        Command ===> u man sed\n        Command ===> u man sed | cut -c 1-80\n        Command ===> zexpand\n            u cat \"//'BOZO.CNTL(HAYSTACK)'\" | grep -E 'N.*dle'\n        Command ===> u cut -c 1-10 info   <- infolines, no replacement\n        Command ===> u info cut -c 1-10   <- infolines, no replacement\n        Command ===> u man woman info     <- infolines, no replacement\n        Command ===> u ls -al oedit       <- oedit temporary result\n        Command ===> u oedit man awk      <- oedit temporary result\n        oedit is used for long output lines and u may be reissued.\n        Non empty temporary result replaces member or sequential file.\n        Command ===> can                  <- not to SAVE u's result\n        Command ===> u s (or u sa, u sav) <- explicit save in 'SAVEU'\n\n        edit macro u used to process z/OS Unix commands in member:\n                   BOZO.CNTL(A)\n        Command ===> u sh                  or ===> u sh info\n        ****** *********************\n        000001 whoami\n        000002 pwd\n        000003 printenv\n        ****** *********************\n\n   to\n        Edit macro, convert from codepage to codepage.\n        Executes edit macro unix with iconv.\n        Output: Temporary file with converted code\n                (may be copied on a permanent file).\n        Examples: Command ===> TO IBM-1047 FROM IBM-1147\n                  Command ===> TO               uses default\n                  Command ===> TO LIST    list possible codepages\n\n   from\n        Edit macro, convert from codepage to codepage.\n        Code is an exact copy of the code of the 'to' edit macro.\n        Examples: Command ===> FROM IBM-1047 TO IBM-1147\n                  Command ===> FROM             uses default\n                  Command ===> FROM LIST   list possible codepages\n\n   grepit\n        Rexx to search a member or a library with a regular expression.\n        It uses the following Unix command with bpxwunix:\n        cmd = \"  strings -z -n 8 | fold -w 72 | grep -Ei '\"regex\"'\"\n        Examples:\n        Command ===> tso grepit 'regex' dsname\n        Command ===> tso grepit 'regex' 'dsname'\n        Command ===> tso grepit 'regex' dsname(member)\n        Command ===> tso grepit 'regex' 'dsname(member)'\n        Command ===> tso cmde\n                     grepit 'regex' dsname\n        The regular expression regex is in local codepage\n        (or is |) and must be between '\n        The dsname may or may not be surrounded by '\n\n   strings\n        Execute the Unix commands strings and fold.\n        Display printable strings folded to 72 columns.\n        There is an optional parameter which indicates\n        the minimum printable string length. It may be\n        obtained from the Prompt field.\n\n        Example:\n                 VIEW      XX.YYYY.USER01.LOADLIB\n         Command ===>\n                    Name     Prompt        Alias-of     Size\n         _________ ABCLDCN0                           000019D8\n         strings__ DEFGB790 1   <-- mimimum length  1 000035C0\n         strings__ DEFGB80D     default min length 20 00007F10\n\n   ux\n        Rexx, alternative to Command ===> epdf /\n        Example:  Command ===> tso ux\n\n   man\n\n        rexx which execute man Unix command in MVS or z/OS Unix.\n        man ouput is translated to local ccsid then displayed\n        with ISPF VIEW.\n\n        rexx is placed in a MVS library concatenated to SYSPROC\n        or SYSEXEC.\n\n        Examples:\n        Command ===> tso man Grep\n\n        Command ===> cmde\n        Enter TSO commands below:\n        ===> man -k compare\n\n        In z/OS Unix:\n\n        Command ===> tso omvs\n        $ tso man ls\n              versus\n        $ man ls\n        $ exit\n\n   history\n\n        rexx which edit z/OS Unix user command history file\n        from TSO or z/OS Unix.\n\n        rexx is placed in a MVS library concatenated to SYSPROC\n        or SYSEXEC.\n\n        Examples:\n        Command ===> tso history\n\n        In z/OS Unix:\n\n        Command ===> tso omvs\n        $ tso history\n        $ exit\n\n\n   split\n        rexx which executes z/OS Unix split command\n        on a MVS sequential file or a library member,\n        creating a MVS library.\n\n        Examples:\n                 VIEW      BOZO.CNTL\n         Command ===>\n                    Name     Prompt\n         split____ MEMBER01 100    <-- split every 100 lines\n         split____ MEMBER02 -100   <-- split every 100 lines\n         split____ MEMBER03 -l 100 <-- split every 100 lines\n         split____ MEMBER04 500 Z  <-- split every 500 lines\n                            and prefix created members with Z\n\n         Created library:\n         BOZO.CNTL.MEMBER01.SPLIT with members\n         XAA, XAB, XAC, ... Each one has 100 lines,\n         if parameter in Prompt field, is 100.\n\n         split____ MEMBER05     default split every 1000 lines\n         It start a new file every time it has copied\n         1000 lines.\n\n         ISPF 3.4\n                  Data Sets Matching BOZO\n         Command ===>\n\n         Command - Enter \"/\" to select action\n         ----------------------------------------------\n                  BOZO.SEQ01\n         split / 100 O.SEQ02\n         Created library:\n         BOZO.SEQ02.SPLIT with members\n         XAA, XAB, XAC, ... Each one has 100 lines.\n\n         Command ===> tso split 'BOZO.CNTL(MEMBER1)' 100\n         Command ===> cmde      <-- to preserve lower case\n         Enter TSO commands below:\n         ===> split 'BOZO.CNTL(MEMBER2)' -l 100 MBR\n          Created MVS library 'BOZO.CNTL.MEMBER2.SPLIT will\n          contain membres MBRAA, MBRAB, ...\n\n\n   od\n         rexx\n         Execute od (octal dump) Unix command.\n         If no option provided, the rexx generates option\n         for an hexadecimal dump (BSD option -Xhc).\n\n         rexx is in SYSEXEC or SYSPROC concatenation,\n         not in OMVS PATH.\n\n         rexx can be called from either MVS or OMVS.\n\n         Examples:\n         Calling from MVS:\n                  VIEW      BOZO.LOAD\n          Command ===>\n                     Name     Prompt\n          od_______ MEMBER01        <-- hex dump\n\n          ISPF 3.4\n                   Data Sets Matching BOZO\n          Command ===>\n\n          Command - Enter \"/\" to select action\n          ----------------------------------------------\n          od______ BOZO.SEQ01       <-- hex dump\n\n          Command ===> tso od 'BOZO.LOAD(MEMBER1)'\n          Command ===> cmde         <-- to preserve lower case\n          Enter TSO commands below:\n          ===> od 'BOZO.LOAD(MEMBER2)' -hc\n          ===> od /u/bozo/test.txt  <-- full path needed\n\n         Calling from OMVS:\n          Command ===> tso omvs\n          $ tso od /u/bozo/test.txt\n          $ tso od BOZO.SEQ01\n          $ exit                 (from OMVS)\n\n______________________________________________________________________________\n\n\nbatch job GREPLIB Job executes grep with BPXBATCH on a HFS copy of a library.\n\n   GREP01  Job executes grep with BPXWUNIX in a procedure\n                     on a HFS copy of a library\n\n   BPXWUNIX\n        JCL procedure.\n        Execute z/OS Unix commands in batch\n        from CMD keyword then from //STDPARM file\n\n        May replace BPXBATCH in a batch job.\n        If replacing a BPXBATCH batch job,\n           if there is a //STDPARM, replace only\n              EXEC PGM=BPXBATCH          by\n              EXEC BPXWUNIX\n              If ever parameter PARM if present, please suppress it\n              (it is ignored by BPXBATCH when //STDPARM is present)\n           if there no //STDPARM and there is a PARM, replace only\n                 EXEC PGM=BPXBATCH,PARM=    by\n                 EXEC BPXWUNIX,CMD=\n        Then run.\n\n        Examples:\n        //CUT     EXEC BPXWUNIX,CMD='cut -c 1-8,10-14',\n        //             IN=&IN,OUT=&OUT\n\n        //         SET IN=BOZO.SEQ01.FB.LRECL80\n        //         SET OUT=BOZO.SEQ01.VB.LRECL84.BZ2\n        //BZIP2    EXEC BPXWUNIX,CMD='bzip2'\n\n        //   EXEC BPXWUNIX,CMD='set -x; cal;'\n        //STDIN  DD DUMMY\n        //STDOUT DD SYSOUT=*\n        //CMD DD *\n        pwd; cat \"//'BOZO.SEQ01'\" ; echo $A\n        //DDENV  DD *\n        A=\"Bonjour\"\n\n   BZIP2\n        Batch job.\n        Uses JCL procedure BPXWUNIX to compress a MVS file\n        with bzip2.\n        Once the file is transfered in binary on another z/OS,\n        it might be decompressed with bunzip2.\n        7zip supports, on Windows and Linux, the .bz2 format.\n\n   JAVA\n        Batch job.\n        Uses JCL procedure BPXWUNIX to copy, compile and execute\n        a basic Java program.\n\n______________________________________________________________________________\n\nrexx executing another rexx given as parameter\n\n   viewit\n        ISPF rexx, ISPF edit macro and z/OS Unix rexx.\n        May be used to trace another rexx given as a parameter\n        or to display the result of a command.\n        Examples: Used as a rexx:\n                      Command ===> tso viewit rexx01 parm1\n                      instead of   tso rexx01 parm1\n                      Command ===> TSO VIEWIT RLIST GCICSTRN *\n                      Command ===> TSO VIEWIT LU\n                      Command ===> tso viewit help lu\n                      Command ===> TSO VIEWIT EX 'DSNAME(CLIST1)'\n\n                  Used as an edit macro:\n                    Execute present rexx (rexx being edited)\n                    without parameters:\n                      Command ===> viewit\n                    Execute last saved rexx without parameters:\n                      Command ===> viewit *\n                    Execute present rexx with parameters:\n                      Command ===> viewit parm1 parm2\n                    Execute last saved rexx with parameters:\n                      Command ===> viewit * parm1 parm2\n\n                  Used in a member list:\n\n                    Command ===>\n                               Name     Prompt\n                    viewit___ REXX01   PARM1\n\n                  Under z/OS Unix (rexx in SYSPROC or SYSEXEC\n                  concatenation, vsualization with ISPF VIEW):\n                    Command ===> tso omvs\n                    $ tso viewit time\n                    $ exit\n\n   forallm\n        ISPF rexx. forallm means for all members.\n        Command contains a member pattern with at least one '*' or '%'.\n        We execute the command for each member in pattern.\n        Examples:\n        Command ===> tso forallm lma XXXXXX.LOAD(A*)\n                     We execute the rexx lma for each member\n                     of library XXXXXX.LOAD whose name begins by A.\n        Command ===> tso viewit forallm lma XXXXXX.LOAD(A*)\n\n   foralld\n        ISPF rexx. foralld means for all datasets.\n        Command contains a level with at least one '*' or '%'.\n        We execute the command for each dsname contained in level.\n        forallm can follow foralld.\n        Examples:\n        Command ===> tso foralld whohas XX.YY%G.**.LOADA*\n        Command ===> tso viewit foralld whohas XX.YY%G.**.LOADA*\n\n   mac\n        ISPF rexx. Rexx to invoke macro given as a parameter\n        It uses three other rexx: viewit, forallm and macedit.\n        Example of use: (ISPF 3.4, on same line as dsname)\n         DSLIST - Data Sets Matching XX.YYYY.USER01\n         Command ===>\n         mac mac01 XX.YYYY.USER01.CNTL\n         mac mac01 /        <-- Execute macro mac01 on all members\n         mac mac01 /(*COMP*)\n         mac mac01 /(COMPCOB)\n\n   bg\n        Rexx.\n        bg for background.\n        Example of a rexx which will call another rexx asynchronously.\n        We insert bg before the rexx name.\n\n        Example:\n        Synchronous execution of REXX01 (foreground) would be:\n        Command ===> tso REXX01 parm1 parm2 ...\n\n        Asynchronous execution of REXX01 (background):\n        Command ===> tso bg REXX01 parm1 parm2 ...\n        To preserve lowercase characters in parm1 parm2 ... :\n        Command ===> cmde\n        Enter TSO commands below:\n        ===> bg REXX01 parm1 parm2 ...\n\n   invoked\n        rexx requests another rexx to call it.\n\n______________________________________________________________________________\n\nMiscellaneous rexx:\n\n   lma\n        Rexx executes Load Module Analyzer and AMBLIST\n        on a load module/program object or on a small library.\n        Example of use in ISPF 3.4:\n        LMA      XX.YYYY.USER01.LOAD\n        LMA      before dsname or member name\n\n   l2\n        Convert a pds or a pdse to a pdse version 2\n        with the implied or specified maxgens parameter.\n        Examples of use in ISPF 3.4:\n        //L2     USER01.LOAD1      <-- Group convert\n                 USER01.LOAD2          to DSNTYPE(LIBRARY,2)\n        //       USER01.LOAD3          with default MAXGENS\n                 USER01.LOAD4\n        L2       USER01.LOAD5      <-- Default convert\n                 USER01.LOAD6\n        L2 / 0   USER01.LOAD7      <-- Convert with MAXGENS=0\n        L2 / 2   USER01.LOAD8      <-- Convert with MAXGENS=2\n\n   v2\n        Convert a pds or a pdse to a pdse version 2,\n        or a pdse version 1 or a pds (extension of rexx l2).\n        Examples of use in ISPF 3.4:\n        Convert to DSNTYPE(LIBRARY,2):\n        V2       USER01.LOAD1      <-- Default MAXGENS\n        //V2     USER01.LOAD2      <-- Group convert\n                 USER01.LOAD3          with default MAXGENS\n        //       USER01.LOAD4\n        V2 / 0   USER01.LOAD5      <-- Convert with MAXGENS=0\n        V2 / 2   USER01.LOAD6      <-- Convert with MAXGENS=2\n        Convert to DSNTYPE(LIBRARY,1):\n        V2 / DSNTYPE(LIBRARY,1)\n        Convert to PDS:\n        V2 / DSNTYPE(PDS) DIR(500)\n        Examples of use on Command line:\n        Command ===> TSO V2 AB.CDEF.CNTL  <-- Default MAXGENS\n        Command ===> TSO V2 AB.*.C%EF.**.*ABC* SIMULATE\n        Command ===> TSO V2 AB.*.C%EF.**.*ABC*\n        Command ===> TSO V2 AB.CDEF.** 3  <-- MAXGENS=3\n\n   ds\n        Rexx.\n        Alternative to DSLIST\n\n        Syntax: Command ===> tso ds parameter(s)\n        There could be zero, one or two parameters.\n\n        1) With zero parameter:\n        Dataset list using a default pattern (to change in the rexx)\n        Command ===> tso ds\n\n        2) With one parameter, one of the two:\n        a) Dataset list using a specific pattern.\n        pattern may have the % and * wild characters\n        Examples:\n        Command ===> tso ds bozo.**.*jcl*\n        Command ===> cmde     <-- to preserve lower case\n        Enter TSO commands below:\n        ===> tso ds /u/boz*\n        b) Permanent screen name for the present logical screen.\n        Example:\n        Command ===> tso ds screen1\n\n        3) With two parameters:\n        Dataset list using a specific pattern\n        in a new logical screen (no parameter order)\n        Examples:\n        Command ===> tso ds bozo.**.jcl screen1\n        or\n        Command ===> tso ds screen1 bozo.**.jcl\n        screen1 is the name given to the new logical screen.\n        Command ===> tso ds bozo bozo\n        list all files with first qualifier bozo in a screen\n        named bozo.\n\n   dsm\n        Rexx.\n        Display a sorted member list with Command ===> sort cha\n\n        Examples:\n        Command ===> tso dsm           <- using content of variable\n                                          default_dsn in rexx.\n                                          All members are sorted.\n        Command ===> tso dsm BOZO.CNTL <- All members of BOZO.CNTL\n        Command ===> tso dsm A%B* <- All members with pattern A%B*\n        Command ===> tso dsm BOZO.CNTL A%B*\n        Command ===> tso dsm A%B* BOZO.CNTL\n\n   o\n        Execute TEMPNAME member of own library.\n        TEMPNAME contains altlib act appl(exec) and libdef stack\n        to use own rexx and ispf libraries.\n        Example:\n        Command ===> tso o\n\n   c\n        Issues MVS or JES2 command thru  address sdsf isfslash\n        Example:\n        Command ===> tso c d a         <-- MVS  command D A\n\n   whohas\n        Excute D GRS,RES=(SYSDSN,dsn) with  address sdsf isfslash\n        Examples:\n        Command ===> tso whohas USER01.LOAD\n        In ISPF 3.4, before dsname:\n        whohas   USER01.LOAD1\n\n   parmlib\n        Example of use of isrddn only to view and search through\n        concatenated libraries.\n        Command ===> tso parmlib\n\n   julie\n        To convert from Julian date tso standard date and reverse.\n        Example:\n        Command ===> tso julie\n\n   lmmstats\n        To update library member ISPF statistics, with LMMSTATS.\n        Examples:\n        Command ===> cmde\n        ===> lmmstats 'XX.YYYY.BOZO.CNTL(abcde)' created(66/12/01)\n        ===> viewit lmmstats 'XX.YYYY.BOZO.CNTL(abcde)' created(66/12/01)\n\n   id    To change the id in a library member list.\n        Example: (Google \"fish ascii\" or \"one line ascii art\")\n        Before:\n                VIEW      BOZO.CNTL\n        Command ===>\n                   Name     Prompt       Size   Created    ...  ID\n        id_______ J        <\u00b0(((><          6  2018/03/15  ...  BOZO\n\n        After:\n                VIEW      BOZO.CNTL\n        Command ===>\n                   Name     Prompt       Size   Created    ...  ID\n        _________ J                         6  2018/03/15  ...  <\u00b0(((><\n\n\n   abo\n        rexx which displays information related to\n        ABO (Automatic Binary Optimizer) such as\n        Architecture level, execute MVS, JES2, TSO commands\n        commands and display in View a file with the results\n        by calling itself.\n\n        Examples:\n        Command ===> tso abo       <-- information on Automatic Binary Optimizer\n        Command ===> tso abo d a   <-- MVS  command D A\n        Command ===> tso abo $di   <-- JES2 command $DI\n        Command ===> tso abo tso time\n        Command ===> cmde\n        Enter TSO commands below:\n        ===> abo tso rex01 Azerty Qwerty\n\n   codepage\n        rexx which gives the terminal codepage and\n        the terminal charset while working under ISPF\n        and other codepage information.\n\n        Example:\n        Command ===> tso codepage\n\n   cp\n        rexx which shows, under ISPF, the terminal codepage\n        at top right of screen.\n\n        Example:\n        Command ===> tso cp\n        Result, top right of screen: 'Terminal codepage: 1140'\n        Command ===> tso codepage    will give more information\n\n   dup\n        Rexx.\n        Obtain duplicate member names for specified libraries\n        using ISRDDN DUP\n        Example:\n        Command ===> tso dup\n\n\n   relink\n        Rexx.\n        Relinks a load module/program object\n        Syntax: Command ===> tso relink dsn(member) parameter(s)\n\n        If zero parameter follows dsn(member) then show help\n           and relink JCL with control statements examples to edit\n           in a file.\n        If one parameter only follows dsn(member) then use binder statement\n           SETOPT PARM(parameter)\n           and call binder\n           (in case parm is an 8 characters hex string,\n            prefix hex string by 'SSI=')\n        else use parameters as a full binder statement\n           and call binder.\n\n        relink   parameter(s) may be obtained from prompt field\n                 if at most eight characters long.\n\n   Example 1:\n    Command ===> tso relink\n    generates help and JCL file to edit.\n\n   Example 2:\n   XXXX    VIEW      BOZO.LOAD\n    Command ===>                                                  Scroll ===>\n              Name     Prompt        Size       TTR      AC    AM  RM\n    relink   COBOL01                 00001398   000015   01    31  ANY\n    generates help and JCL file to edit. dsn and member indicated.\n\n   Example 3:\n    Command ===> tso relink 'BOZO.LOAD(COBOL01)' SSI=AA190206,REUS=RENT,AC=1\n    will use binder statement        SETOPT PARM(SSI=AA190206,REUS=RENT,AC=1)\n    and call binder.\n\n   Example 4:\n    Command ===> cmde\n    Enter TSO commands below:\n    ===> relink 'BOZO.LOAD(COBOL01)' INCLUDE SYSLIB(SUB01)\n    will use binder statement        INCLUDE SYSLIB(SUB01)\n    and call binder.\n    dsn is allocated to SYSLIB.\n\n   Example 5:\n   XXXX    VIEW      BOZO.LOAD\n    Command ===>                                                  Scroll ===>\n              Name     Prompt        Size       TTR      AC    AM  RM\n    relink   COBOL01  RMODE=24       00001398   000015   01    31  ANY\n\n   Result:\n   XXXX    VIEW      BOZO.LOAD\n    Command ===>                                                  Scroll ===>\n              Name     Prompt        Size       TTR      AC    AM  RM\n    ________ COBOL01                 00001398   000015   01    31  24\n\n\n   scr\n        Rexx or edit macro.\n        Syntax: Command ===> tso scr parameter\n        There could be zero or one parameter.\n\n        1) With zero parameter:\n        Command ===> tso scr\n        Flushes the panel cache\n        (method from http://ibmmainframes.com/about59391.html\n        Stefan, Germany)\n\n        2) With one parameter:\n        Flushes the panel cache and\n        set permanent screen name.\n        Example:\n        Command ===> tso scr screen1\n        Flushes the panel cache and\n        set permanently present screen name to screen1\n\n        In Edit or View mode:\n        Command ===> scr\n        Command ===> scr screen1\n\n   ssi\n        Rexx.\n        Set SSI eight hexadecimal digit constant to\n        a load module/program object.\n        It rebinds the load module/program object setting the SSI.\n\n        It has two parameters:\n        1) 'dsn(member)' for load module/program object\n        2) optional SSI\n        SSI      optional parameter, may be obtained from prompt field\n                 Eight hexadecimal characters: 0123456789ABCDEF\n                 default:   2 hex char followed by yymmdd\n\n   Example:\n    Command ===> tso ssi 'BOZO.LOAD(COBOL01)' AA190206\n\n   Example:\n   XXXX    VIEW      BOZO.LOAD\n    Command ===>                                                  Scroll ===>\n              Name     Prompt   Alias-of    ---- Attributes ----      SSI\n   ssi______ COBOL01   AA123456                     RN RU\n   ssi______ COBOL02                                RN RU\n\n   Result:\n   XXXX    VIEW      BOZO.LOAD\n    Command ===>                                                  Scroll ===>\n              Name     Prompt   Alias-of    ---- Attributes ----      SSI\n   _________ COBOL01                                RN RU         AA123456\n   _________ COBOL02                                RN RU         FF190506\n\n\n   tallych\n        rexx procedure to count the number of times a character appears\n        in a string using space(string,0) (remove all spaces)\n\nBatch job   WHERE  Batch job illustrating a search of a generic member\n        in generic libraries (source, load, etc...) with PDSEASY\n        and post processing.\n\n   FTPUTF8\n        JCL model.\n        Transfer a RECFM=FB library with FTP\n        from IBM-1140 to UTF-8 and reverse.\n        It uses the JCL procedure that I called LMCOPY.\n\n   FTPUTF8S\n        JCL model.\n        Transfer a RECFM=FB sequential file with FTP\n        from IBM-1140 to UTF-8 and reverse.\n        It uses the JCL procedure that I called LMCOPY.\n\n   FTP1252\n        JCL model.\n        Transfer a library with FTP\n        from IBM-1140 to Windows-1252 and reverse.\n\n   DELDEF\n        JCL procedure.\n\n        Define sequential file or library (PDS or PDSE)\n        (library definition with an ICEGENER dummy write).\n\n        Examples of use:\n        //         SET DSN=BOZO.SEQ01\n        //DELDEF1  EXEC DELDEF,DSN=&DSN      Sequential\n        //         SET DSN=BOZO.PDSE01\n        //DELDEF2  EXEC DELDEF,DSN=&DSN      PDSE\n        //DEF.SYSUT2 DD DSORG=PO,DSNTYPE=(LIBRARY,2),\n        //       SPACE=(TRK,(5,50,100))\n\n\n   LMCOPY\n        JCL procedure.\n        ISPF LMCOPY service in batch (corresponds to ISPF 3.3).\n        Input and output files could have different RECFM and LRECL.\n\n        Example:\n        // SET I=dsn1\n        // SET O=dsn2\n        // EXEC LMCOPY,I=&I,O=&O\n\n   SUBBAT\n        Job example.\n        The job sends a Windows bat file hello.bat to a Windows server.\n        It will be converted in Windows 1252 aka IBM-1252, cp1252.\n        It will be executed by a periodically scheduled task\n        (code at the end of the job) and hello.bat will return\n        the result to z/OS.\n\n   GUESSUTF\n        Called rexx routine.\n        Try to guess whether a string given as a parameter is\n        in codepage UTF-8 or not.\n\n        Example:\n        call 'GUESSUTF' string\n        answer = result /* 'utf8' or 'not-utf8' */\n\n   HUMPTY\n        Rexx.\n        Extract data records from an non compressed,\n        non encrypted, ADRDSSU DUMP of a PDSE with RECFM=FB.\n        Member data records may be interspersed.\n        First parameter is the DUMP dataset name.\n        Second parameter is the PDSE fixed logical record length,\n        default value is 80.\n\n        Examples:\n        1) Command ===> tso humpty BOZO.PDS.DUMP\n        2) Command ===> tso humpty BOZO.PDS.DUMP2 40\n\n        3) In ISPF 3.4:\n        Command - Enter \"/\" to select action\n        -----------------------------------------------------------\n        humpty    BOZO.PDS.DUMP     <-- humpty before dsname\n        humpty / 40 7931.PDS.DUMP2\n\n   DUMPTY\n        Rexx.\n        Logically DUMP files with ADRDDSU using ALLDATA(*) ALLX\n\n        Examples:\n        1) Command ===> tso dumpty BOZO.PDS\n\n        2) In ISPF 3.4:\n        Command - Enter \"/\" to select action\n        -----------------------------------------------------------\n        dumpty    BOZO.PDS          <-- dumpty before dsname\n\n   LAZY\n        Rexx (using itself as an edit macro).\n        Display in terminal codepage\n         a string, given as a parameter, converted:\n         to IBM-1047 (Unix),\n         to IBM-1140 (US) if the terminal codepage is different,\n         to IBM-1208 (UTF8).\n\n        Default string contains pangram:\n        THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n\n        Examples of use:\n         1) Command ===> tso lazy\n            displays special characters and above pangram.\n\n         2) Command ===> tso lazy Bonjour []{}1\u20ac\n            displays a temporary file containing:\n            Command ===>\n            ****** ****************************\n            000001 mine 1147 Bonjour []{}1\u20ac\n                   98984FFFF4C9999A949B55F94444\n                   49550114702651649005141F0000\n            -----------------------------------\n            000002 unix 1047 Bonjour \u00dd~\u00e9\u00e81\n                   A98A4FFFF4C9999A94ABCDF34444\n                   459701047026516490DD001F0000\n            -----------------------------------\n            000003 US   1140 Bonjour \u00ac|\u00e9\u00e81\u20ac\n                   EE444FFFF4C9999A94BBCDF94444\n                   420001140026516490AB001F0000\n            -----------------------------------\n            000004 utf8 1208 \u00e2?>\u00f9?\u00cd\u00ca $)\u00a3' Sb\u00d0\n                   AA8F4FFFF44666677255773E8A22\n                   43680120802FEAF520BDBD122C00\n\n   T\n        Rexx.\n        Timer.\n        Display every minute a small box with the numbers of\n        minutes elapsed and remaining. Terminal is locked.\n         __ min __\n        | 1    59 |\n         \u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\n\n        To halt, press Attention key two times then\n        type 'hi' (halt interpretation waiting up to 3 seconds).\n\n        Examples of use:\n         1) Command ===> tso t          <-- default one hour\n         2) Command ===> tso t 7        <-- seven minutes\n\n   GENERIC\n        Edit macro with invariant code,\n        parm (maximum 200 characters) and queue controlled.\n        It obtains commands from parm and statements from stack\n        and interpret them.\n\n\n   REXX2MAC\n        Rexx.\n        Execute an edit macro on library members\n\n        Example 1:\n                VIEW      BOZO.PDS\n        Command ===> s *2* rexx2mac macro01 parm1\n                   Name     Prompt\n        _________ MBR1\n        _________ MBR2\n        _________ MBR3\n        will execute edit macro macro01 with parm parm1\n        on all members with name containing 2.\n        Members may be modified by macro.\n        parm1 will be in uppercase due to panel zcmd attribute.\n\n        Example 2:\n        Command ===> cmde\n        Enter TSO commands below:\n        ===> rexx2mac 'bozo.pds(mbr2)' macro01 parm1\n\n\n   REXXMAC\n        Example of\n        an edit macro in rexx's clothing.\n        Purpose:\n                VIEW      BOZO.PDS\n        Command ===> s *2* rexx01\n                   Name     Prompt\n        _________ MBR1\n        _________ MBR2\n        _________ MBR3\n        will execute rexx rexx01 on all members with name\n        containing 2.\n        If instead of a rexx, I would like an edit macro\n        to process all members with name containing 2,\n        I should make the edit macro to look like a rexx.\n        This is the case with rexxmac.\n        Command ===> s *2* rexxmac\n\n   RETP\n        Called rexx.\n        Get previous commands in a string.\n        Commands are separated by ' ; '\n\n        Example of use:\n\n        In calling program:\n        str = retp()  obtains last command in a string.\n        str = retp(1) obtains the last command (same as retp() ).\n        str = retp(n) obtains the n-th most recent command\n                      (until the 25th most recent command).\n\n        str = retp('all') gives the previous commands\n        in a string.\n        Commands are separated by ' ; '\n        Commands are the commands with at least one non space\n        character as would be given by\n        Command ===> retp\n        in the same order\n        and their leading and trailing spaces have been stripped.\n        Example of content of str after   str = retp('all')  :\n        str = \"tso time ; save ; cut   aa\"\n        \"tso time\" is the last command.\n\n\n   LASTCMD\n        rexx.\n        Get last command or previous commands.\n\n        Used as a called rexx:\n        In calling program:\n        cmd = lastcmd()  obtains last command.\n        cmd = lastcmd(1) obtains last command (same as previous)\n        cmd = lastcmd(2) obtains second most recent command\n        cmd = lastcmd(n) obtains the n-th command\n                      starting from the most recent command,\n                      cycling thru the command stack as\n                      Command ==> retrieve\n\n        On command line:\n        Command ===> tso lastcmd     <-- last command\n        Command ===> tso lastcmd 2   <-- next to last command\n        or cycle to last command if command stack contains only\n        one command.\n\n        Example of use:\n        When displaying a member list\n                  VIEW      BOZO.PDS\n          Command ===> s * rexx01 AA BB\n                     Name     Prompt\n          _________ MBR1\n          _________ MBR2\n          rexx01 executes on all members of the library.\n          When it executes MBR1, it receives as only parameter\n          'BOZO.PDS(MBR1)' and has no knowledge of AA BB.\n          The last command in the command stack is:\n          s * rexx01 AA BB\n          AA BB is obtained by rexx01 with subword(lastcmd(),4).\n          AA may possibly be an edit macro using parameter BB.\n\n\n   VU\n        rexx or edit macro.\n\n        Function is according to the member name:\n        vu:    View UTF-8 file converted to EBCDIC terminal codepage.\n               Edit UTF-8 file if we add a last parameter 'e' or 'E'\n               to either the rexx or the edit macro.\n        vuhex: View UTF-8 in hex (unchanged hex code)\n        eu:    Edit UTF-8 file displayed in EBCDIC terminal codepage\n        euhex: Edit UTF-8 in hex\n        Same code in the four rexx.\n\n        If the name of the rexx does not begin by 'E'\n        and in the case there are parameters, the last one is\n        not 'e' or 'E', then\n        View a MVS library member or a MVS sequential data set\n        or a z/OS Unix file\n        (member or sequential data set or z/OS Unix file\n         already in UTF-8 is converted to terminal codepage)\n        otherwise use Edit instead of View.\n\n        vu: UTF-8 to EBCDIC terminal codepage conversion by\n            ISPF service View or Edit.\n        May be used with a dbrmlib member.\n\n        Examples of use for VU:\n\n        1) As a rexx, in a member list:\n                VIEW      BOZO.DBRMLIB\n        Command ===>\n                   Name     Prompt       Size\n        vu_______ BOZO01              <--       View\n        vu_______ BOZO02    e         <-- force Edit (e in Prompt)\n\n        2) As a rexx on a command line:\n        Command ==> tso vu BOZO.DBRMLIB(BOZO01)       <--       View\n        Command ==> tso vu BOZO.DBRMLIB(BOZO01) e     <-- force Edit\n\n        3) As a rexx preserving lower case:\n        Command ==> cmde\n        Enter TSO commands below:\n        ===> vu /u/bozo/bozo01.utf8                    <--      View\n        ===> vu /u/bozo/bozo01.utf8 e              <-- e forces Edit\n        ===> vu /u/bozo/bozo01.utf8 macro(a) parm(b) e <--      Edit\n        ===> vu 'bozo.cntl(inutf8)' macro(a) parm(b)   <--      View\n        ===> vu 'bozo.cntl(inutf8)' macro(a) parm(b) noutf8 e\n        It is possible to add View or Edit extra parameters\n           and the special parameter noutf8 to remove\n           the default parameter utf8.\n\n        4) As an edit macro:\n                   BOZO.DBRMLIB(BOZO01)\n        Command ===> vu                         (vu e to force Edit)\n        000001 DBRM   `BOZO    BOZO01   \u00d0 H \u00ec/   B\n        000002\n        000003 DBRM   ]       \u00cf       \u00a3@\u00e1\u00e4< \u00ea\u00e1 \u00e4        \u00e4\u00ed\u00ea\u00eb!\u00ea \u00e3!\u00ea\n\n\n   SAV\n        Edit macro which may be used instead of the\n        'SAVE' Edit command.\n\n        Apart of the normal SAVE, it saves the library member in\n        a member named, by default, SAVED\n        Examples of use, in ISPF EDIT:\n        Command ===> sav        <-- normal save and save in member SAVED\n        Command ===> sav SAVED2 <-- normal save and save in member SAVED2\n\n        The edit macro has a parameter,\n        set by default to \"yes\", save_in_waste_basket.\n        If the library being edited has fixed record format and\n        LRECL=80, the member is also saved in a library\n        prefix.WASTE.BASKET\n        This library is created if it does not exist.\n\n   FLAT\n        FLAT is a rexx and edit macro.\n\n        It sequentializes a library using successively IEBPTPCH and\n        SORT.\n        The library should have a fixed record format\n        (RECFM=F or RECFM=FB or RECFM=FBA) and LRECL=80.\n\n        The output is in the form of input to the IEBUPDTE utility\n        (which permits to reload a library or to update it).\n        ISPF statistics are lost.\n        FLAT produces, apart of the sequential file, another file\n        containing a JCL sample to reload the first file.\n        Examples of use:\n\n        Command ===> tso flat                       <- shows help\n        Command ===> tso flat help\n\n        Command ===> tso flat bozo.cntl\n        Command ===> tso flat 'bozo.cntl(mbr1)'     <- same as above\n                                                       mbr1 ignored\n        Created or replaced files:\n        BOZO.CNTL.FLAT    and\n        BOZO.CNTL.FLAT.JCL\n\n\n        In ISPF 3.4:\n                 Data Sets Matching BOZO\n        Command ===>\n\n        Command - Enter \"/\" to select action\n        ------------------------------------\n                 BOZO.CNTL\n        flat     BOZO.CNTL2            <- flat alone.\n\n        Created or replaced files:\n        BOZO.CNTL2.FLAT    and\n        BOZO.CNTL2.FLAT.JCL\n\n        In Edit or View:\n                   BOZO.CNTL(MBR1)\n        Command ===> flat bozo.source  <- edit macro\n        000001 //JOB1 JOB ...             It sequentializes the full\n        000002 //STEP01 ...               library BOZO.SOURCE. No edit.\n\n                   BOZO.CNTL(MBR1)\n        Command ===> flat              <- flat alone.\n        000001 //JOB1 JOB ...             It sequentializes the full\n        000002 //STEP01 ...               library BOZO.CNTL.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE985": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00W\\x01 \\x16O\\x01 \\x16O\\x15\\x05\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T15:05:57", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 985 is from Marius Lewin and contains a collection of     *   FILE 985\n//*           REXX execs, primarily.                                *   FILE 985\n//*                                                                 *   FILE 985\n//*           email:  mlewin@ymail.com                              *   FILE 985\n//*           email:  marius.lewin@gmail.com                        *   FILE 985\n//*                                                                 *   FILE 985\n//*       Title: Rexx with Unix commands or executing another       *   FILE 985\n//*              REXX given as a parameter.                         *   FILE 985\n//*                                                                 *   FILE 985\n//*       Author: Marius Lewin.                                     *   FILE 985\n//*                                                                 *   FILE 985\n//*       This summary is divided in three parts:                   *   FILE 985\n//*       1) REXX executing z/OS Unix commands.                     *   FILE 985\n//*       2) REXX executing another REXX given as parameter.        *   FILE 985\n//*       3) Miscellaneous REXX.                                    *   FILE 985\n//*                                                                 *   FILE 985\n//*       Please see member $$README for much more detailed         *   FILE 985\n//*       information.                                              *   FILE 985\n//*                                                                 *   FILE 985\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ABO": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x01\\xad\\x01\\xad\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:09", "lines": 429, "newlines": 429, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n\nparse arg command\ncommand = strip(command)\ncall visualize    /* Outtrap what has been said or traced                     */\n                  /* and visualize in a file.                                 */\n\n/* When command parameter is empty then                                       */\n/*    get ARCH architecure level                                              */\n/*    and issue IEOPZ commands                                                */\n/* When command parameter contains 'TSO' then                                 */\n/*    remove 'TSO' and execute command with output visualization.             */\n/* Otherwise                                                                  */\n/*    general MVS and JES2 command processor with output visualization.       */\n/*                                                                            */\n\n/* Example of use:                                                            */\n/* Command ===> tso abo                                                       */\n/* Command ===> tso abo d a       <-- MVS  command D A                        */\n/* Command ===> tso abo $di       <-- JES2 command $DI                        */\n/* Command ===> tso abo tso time                                              */\n/* Command ===> cmde                                                          */\n/* Enter TSO commands below:                                                  */\n/* ===> abo tso rex01 Azerty Qwerty                                           */\n\n/*\nInformation on ARCH obtained from :\nGoogle search on the following string between quotes:\n  \"ARCH settings and hardware models\"\nEnterprise COBOL for z/OS, V6.3 Performance Tuning Guide,\n  \"ARCH settings and hardware models\" table\nAlso Enterprise COBOL for z/OS, V6.3 Programming Guide,\n  ARCH compilation option\n*/\n\n/*\nHardware Models (as of 2019):\nARCH(7)  2094-xxx models (IBM System z9 EC)\n         2096-xxx models (IBM System z9 BC)\nARCH(8)  2097-xxx models (IBM System z10 EC)\n         2098-xxx models (IBM System z10 BC)\nARCH(9)  2817-xxx models (IBM zEnterprise z196 EC)\n         2818-xxx models (IBM zEnterprise z114 BC)\nARCH(10) 2827-xxx models (IBM zEnterprise EC12)\n         2828-xxx models (IBM zEnterprise BC12)\nARCH(11) 2964-xxx models (IBM z13)\n         2965-xxx models (IBM z13s)\nARCH(12) 3906-xxx models (IBM z14)\n         3907-xxx (IBM z14 ZR1) models\n*/\n\n/*____________________________________________________________________________*/\n/*                     TABLE TO UPDATE (kindly modify)                        */\n\ntable = '2094 ARCH(7)     2096 ARCH(7)',         /* COBOL V6.2 default        */\n        '2097 ARCH(8)     2098 ARCH(8)',\n        '2817 ARCH(9)     2818 ARCH(9)',\n        '2827 ARCH(10)    2828 ARCH(10)',\n        '2964 ARCH(11)    2965 ARCH(11)',        /* Z13                       */\n        '3906 ARCH(12)    3907 ARCH(12)',        /* Z14                       */\n        '9996 DUMMY       9997 DUMMY   ',        /* spare1                    */\n        '9998 DUMMY       9999 DUMMY   '         /* spare2                    */\n/*____________________________________________________________________________*/\n\nsay 'Information about ABO or general command processor.'\nsay 'To exit: PF3. To copy, you may use CUT and PASTE.'\nsay\nsay \"Examples of call:                                       \"\nsay \"Information about ABO (Automatic Binary Optimizer):     \"\nsay \"Command ===> tso abo                                    \"\nsay \"General command processor:                              \"\nsay \"Command ===> tso abo d iefopz,ddname=dfhrpl             \"\nsay \"Command ===> tso abo d a       <-- MVS  command D A     \"\nsay \"Command ===> tso abo $di       <-- JES2 command $DI     \"\nsay \"TSO command processor:                                  \"\nsay \"Command ===> tso abo tso time                           \"\nsay \"Command ===> cmde                                       \"\nsay \"Enter TSO commands below:                               \"\nsay \"===> abo tso rexx01 Azerty Qwerty                       \"\nsay\n\nif command <> '' then do\n  call execute_MVS_command(command)\n  exit\nend /* if command <> ''                                                       */\n\n/* Display information if command = ''                                        */\nsay copies('_',85)\nsay\n\n/* Issue z/OS command: D M=CPU                                                */\n/* to obtain model then architecture level.                                   */\n\n/* Alternative with:                                                          */\n/* if syscpus('cpus.') = 0 then                                               */\n/*    model = right(word(cpus.1,words(cpus.1)),4)                             */\n/*    model made of four rightmost characters of last word of cpus.1          */\n\ncmd = 'd m=cpu'\ncall execute_MVS_command(cmd)\nsay res\n\n/* Try to get COBOL default ARCH option if COBOL compiler in linklist.        */\n/*                                                                            */\ncall try_to_get_COBOL_ARCH_default\n\n/* IEFOPZ commands:                                                           */\n\n/* Display status and get IEFOPZ member suffix_list                           */\ncmd = 'd iefopz,status'\ncall execute_MVS_command(cmd)\n\nif suffix_list <> '' then do\n\n  /* Get parmlib_dsn_list                                                     */\n  cmd = 'd parmlib'\n  call execute_MVS_command(cmd)\n\n  /* List PARMLIB members corresponding to suffix_list.                       */\n  call list_parmlib_members\n\nend /* if suffix_list <> ''                                                   */\n\n/* List new datasets which will be concatenated ahead of old datasets.        */\ncmd = 'd iefopz,old=*'\ncall execute_MVS_command(cmd)\n\n/* IEFOPZ help (from z/OS V2R3 MVS System Commands):                          */\ncall show_syntax\n\nexit\n/*________________________ROUTINES FOLLOW ____________________________________*/\n\nexecute_MVS_command:\nparse arg cmd\n\ndrop c.\nc.0 = 1\nc.1 = left(cmd,80)\n\n/* Execute command.                                                           */\n/* Result in isfulog. stem                                                    */\n\nrc = isfcalls(\"on\")                    /* access = on                         */\nisfcons = \"sdsf\"random()               /* console = sdsfxxx                   */\nisfdelay = 1 /* Wait 1 second before retrieving results                       */\naddress sdsf isfslash \"(\"c.\") (wait)\"\nisfslash_rc = rc                       /* save return code                    */\nrc = isfcalls(\"off\")                   /* access = off                        */\n\n/* If ok, display result.                                                     */\n\nif isfslash_rc = 0 then do\n   select /* format result according to command                               */\n\n   when translate(cmd) = 'D M=CPU' then do\n\n     say   'This model architecture level:'\n     res = 'Unknown architecture level.', /* initialize res (result)          */\n           'Consider updating table in rexx.'\n     do i = 1 to isfulog.0\n\n        p = pos('CPC SI',isfulog.i) /* result of STSI command                 */\n        if p >  0 then do /* table search with wordpos                        */\n           parse var isfulog.i . '=' model '.' . /* extract model number      */\n           q = wordpos(strip(model,'L','0'),table)\n           if q > 0 then /* model found in table, ARCH is next word           */\n                    res = word(table,q+1) /* architecture level e.g. ARCH(12) */\n           leave         /* exit loop                                         */\n        end /* if p > 0       line contains 'CPC SI'                          */\n\n     end /* do i = 1 to isfulog.0                                             */\n\n   end /* when cmd = 'D M=CPU'                                                */\n\n   when translate(cmd) = 'D IEFOPZ,STATUS' then do\n\n     suffix_list = '' /* initialize                                           */\n     say copies('_',85)\n     say\n     say 'Execution of MVS command'\n     say cmd\n     say 'gave:'\n     say\n     do i = 2 to isfulog.0\n        say isfulog.i\n        p = pos('IEFOPZ(s)',isfulog.i) /* line with IEFOPZ member suffixes    */\n        if p >  0 then do /* members IEFOPZxx exist                           */\n           suffix_list = translate(subword(isfulog.i,2),' ',',')\n        end /* if p > 0      members IEFOPZxx exist                           */\n     end /* do i = 1 to isfulog.0                                             */\n\n   end /* when cmd = 'D IEFOPZ,STATUS'                                        */\n\n   when translate(cmd) = 'D PARMLIB' then do\n   /* get parmlib_dsn_list                                                    */\n     parmlib_dsn_list = ''             /* initialize                          */\n     do k = 1 to isfulog.0\n        p = pos('VOLUME  DATA SET',isfulog.k)\n        if p =  0 then iterate         /* line not yet reached                */\n        do m = k + 1 to isfulog.0      /* lines after 'VOLUME  DATA SET'      */\n           parmlib_dsn_list = parmlib_dsn_list word(isfulog.m,4) /* 4th word  */\n        end /* do m = k + 1 to isfulog.0                                      */\n        leave\n\n     end /* do k = 1 to isfulog.0                                             */\n     parmlib_dsn_list = strip(parmlib_dsn_list ) /* remove left blank         */\n\n   end /* when cmd = 'D PARMLIB'                                              */\n\n   otherwise do /* general                                                    */\n     say copies('_',85)\n     say\n     say 'Execution of MVS command'\n     say cmd\n     say 'gave:'\n     say\n     do i = 2 to isfulog.0\n        say isfulog.i\n     end /* do i = 1 to isfulog.0                                             */\n   end   /* otherwise     general case                                        */\n\n   end /* select    format result according to command                        */\nend /* if isfslash_rc = 0                                                     */\n\nreturn\n/*____________________________________________________________________________*/\n\nlist_parmlib_members:\n\nsay copies('_',85)\nsay\nsay 'List of PARMLIB member(s):'\nsay\ndo n = 1 to words(suffix_list)\n   suffix = word(suffix_list,n)\n   member = iefopz!!suffix\n   do d = 1 to words(parmlib_dsn_list)\n      dsn = word(parmlib_dsn_list,d)\n      dsn_member = dsn\"(\"member\")\"\n      if sysdsn(\"'\"dsn_member\"'\") = 'OK' then do\n         call display_dsn_member\n         leave d\n      end /* if sysdsn(\"'\"dsn_member\"'\") = 'OK'                               */\n   end /* do d = 1 to words(parmlib_dsn_list)                                 */\nend /* do n = 1 to words(suffix_list)                                         */\n\nreturn\n/*____________________________________________________________________________*/\ndisplay_dsn_member: procedure expose dsn_member\n\nsay\nsay dsn_member\n\"alloc fi(in) da('\"dsn_member\"') shr reuse\"\nmrc = rc\nif mrc > 0 then do\n   say dsn_member \"allocate gave code \"mrc\n   exit(12)\nend /* if mrc > 0                                                             */\naddress mvs \"execio * diskr in (stem in. fini\"\n\"free fi(in)\"\ndo i = 1 to in.0; say in.i; end\n\nreturn\n/*___________________________________________________________________________*/\n\ntry_to_get_COBOL_ARCH_default:\n\n/* Empty COBOL program compilation                                            */\n/* to get COBOL default ARCH architecture level if compiler is in linklist.   */\n/* ARCH is in SYSPRINT.                                                       */\n\naddress tso\n\n/* sysin  Empty COBOL program, compilation gives rc = 16                      */\n'alloc fi(sysin) dummy reuse'\n\n/* COBOL sysprint                                                             */\n'alloc fi(sysprint) unit(vio) tr sp(1) reuse'\narc = rc\nif arc > 0 then do\n   say \"cobol sysprint allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n/*                                                                            */\n\n/* syslin                                                                     */\n'alloc fi(syslin) dummy reuse'\n\n/* sysut1 to sysut15                                                          */\ndo i = 1 to 15\n  \"alloc fi(sysut\"i\") unit(vio) tr sp(1) reuse\"\n  brc = rc\n  if brc > 0 then do\n     say \"cobol sysut\"i\" allocate gave code \"brc\n     exit(12)\n  end /* if brc > 0 */\nend /* do i = 1 to 15                                                         */\n\n/* sysmdeck                                                                   */\n'alloc fi(sysmdeck) dummy reuse'\n\n/* Execute interactively the COBOL compiler.                                  */\n' call *(igycrctl)'              /*   if in linklist                          */\n\ncmd = 'grep ARCH'       /* e.g. ARCH(12) for z14                              */\ncall bpxwunix cmd,'DD:SYSPRINT',out.\nif datatype(out.0) = 'NUM' then do\n   if out.0 > 0 then do\n      say\n      say 'COBOL default ARCH option is 'word(out.1,words(out.1))\n      /* COBOL defaults in *(igycdopt)                                        */\n   end /* if out.0 > 0                                                        */\nend /* if datatype(out.0) = 'NUM                                              */\n\n/* clean up                                                                   */\n\"free fi(sysprint syslin sysin sysmdeck)\"\ndo i = 1 to 15\n  \"free fi(sysut\"i\")\"\nend /* do i = 1 to 15                                                         */\n\naddress\nreturn\n/*____________________________________________________________________________*/\nshow_syntax:\n\nsay copies('_',85)\nsay\nsay 'Syntax of DISPLAY and SET IEFOPZ:'\nsay\nsay '   D IEFOPZ                                                            '\nsay '   {,DDNAME=ddname[,JOBNAME=jobname]}                                  '\nsay '   {,JOBNAME=jobname}                                                  '\nsay '   {,NEW=newds[,OWNER=owner][,STATE={ACTIVE|ALL}]}                     '\nsay '   {,OLD=oldds[,ARCH={MAXARCH|nn|ALL}][,MEMBERS=members][,OWNER=owner] '\nsay '   [,STATE={ACTIVE|ALL}]}                                              '\nsay '   {,OWNER=owner}                                                      '\nsay '   {,STATUS}                                                           '\nsay '   [,L={a|name|name-a}]                                                '\nsay\nsay '   {SET | T} [IEFOPZ= {(xx,...,xx [,C])|REFRESH}]                      '\nsay '                                    C: syntax check only               '\n\nreturn\n\n/*____________________________________________________________________________*/\n\n visualize: procedure expose command\n address tso\n parse source . . rexxname .\n if sysvar('sysnest') = 'NO' then do /* not invoked                           */\n    /* invoke to visualize in a file what has been said or traced             */\n    stem_name = outtrap('line.') /* stem to get display output                */\n      p = wordpos('TSO',translate(command))\n      select\n        when p > 0 then delword(command,p,1)\n        /* remove tso string then execute                                     */\n        otherwise       rexxname command   /* only one recursion level        */\n      end\n    outtrap_off = outtrap('off')\n end /* if sysvar('sysnest') = 'NO'     not invoked                           */\n else return /* execute (nested)                                              */\n\n /* Visualize.                                                                */\n if line.0 > 0 then do\n    if sysvar(sysispf) <> 'ACTIVE' then do\n       do i = 1 to line.0\n          say line.i\n       end /* do i = 1 to line.0                                              */\n       zispfrc = 0\n       exit zispfrc\n    end /* if sysvar(sysispf) <> 'ACTIVE'                                     */\n    else do /*       ispf ACTIVE                                              */\n\n       /* Allocate visualization file.                                        */\n       address tso\n       ddnm = 'dd'right(random(1,99999),5,'0') /* choose random ddname        */\n       msg_prev = msg('off')\n       \"alloc file(\"ddnm\") unit(vio) new delete tracks space(50,500)\",\n       \" reuse lrecl(132) recfm(f b) blksize(8976)\"\n       alloc_rc = rc\n       if alloc_rc <> 0 then do\n          say rexxname \"could not allocate the visualization file.\"\n          say \"We exit with code 16.\"\n          say \"alloc rc = \"alloc_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if alloc_rc <> 0                                                */\n       msg_off  = msg(msg_prev)\n       /* End of allocate visualization file.                                 */\n\n       /* Write on visualization file.                                        */\n       \"execio\" line.0  \"diskw\" ddnm \"(stem line. finis\"\n       execio_rc = rc\n       if execio_rc <> 0 then do\n          say rexxname \"could not write on visualization file.\"\n          say \"We exit with code 16.\"\n          say \"execio rc = \"execio_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if execio_rc <> 0                                               */\n       /* End of write on visualization file.                                 */\n\n       /* Visualize.                                                          */\n       address ispexec\n         \"control errors return\"\n         \"lminit dataid(list) ddname(\"ddnm\")\"\n         \"view   dataid(\"list\")\"\n         \"lmfree dataid(\"list\")\"\n       address /* resume previous environment                                 */\n       /* End of visualize.                                                   */\n\n       /* Clean up.                                                           */\n       msg_prev = msg('off')\n          \"free fi(\"ddnm\")\"\n       msg_off  = msg(msg_prev)     /* reset                                  */\n       /* End of clean up.                                                    */\n\n    end /* ispf ACTIVE                                                        */\n end /* if line.0 > 0                                                         */\n\nzispfrc = 0\nif sysvar(sysispf) = 'ACTIVE' then\n   address ispexec 'vput zispfrc'\nexit zispfrc\n /*___________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACK": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 8, "newlines": 8, "modlines": 0, "user": "MLEWIN"}, "text": "             ACKNOWLEDGMENT\n\nMarius Lewin would like to thank:\n  1) The French banks Credit Agricole, BNP and Societe Generale\n     to which he was a consultant.\n  2) The Rexx language user community from which he borrowed ideas\n     and code and particularly the following persons:\n     Mark Zelden and the late Gilbert Saint-Flour.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BG": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xae\\x00\\xae\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:09", "lines": 174, "newlines": 174, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/* This rexx is just an example.                            */\n/* It should be customized.                                 */\n/* name bg: background                                      */\n/* Execute in background a rexx.                            */\n/* May be used for parallel rexx execution.                 */\n\n/* rexx is copied to z/OS Unix present working directory.   */\n/* The copy is executed asynchronously.                     */\n\n/* An issue: possible abend SA03 (subtask present)          */\n/* not always circumvented by adding the z/OS Unix command  */\n/* wait (wait until all children complete).                 */\n\n/* Example:                                                 */\n/* Synchronous execution of REXX01 (foreground) would be:   */\n/* Command ===> tso REXX01 parm1 parm2 ...                  */\n/*                                                          */\n/* Asynchronous execution of REXX01 (background):           */\n/* Command ===> tso bg REXX01 parm1 parm2 ...               */\n/* To preserve lowercase characters in parm1 parm2 ... :    */\n/* Command ===> cmde                                        */\n/* Enter TSO commands below:                                */\n/* ===> bg REXX01 parm1 parm2 ...                           */\n\n/* In the following, arg(1) is 'REXX01 parm1 parm2 ...'     */\n/* Standard output and standard error are added             */\n/* at the end of REXX01.out in present working directory.   */\n/* They may be examined later with:                         */\n/* Command ===> tso oedit                                   */\n/* and v before REXX01.out                                  */\n\n/* To remove REXX01.out:                                    */\n/* Command ===> tso oedit                                   */\n/* and d before REXX01.out                                  */\n/* or                                                       */\n/* Command ===> tso omvs                                    */\n/* rm REXX01.out                                            */\n/* exit                                                     */\nrexx01 = word(arg(1),1)           /* first word             */\nrexx01_parm = subword(arg(1),2)   /* rest                   */\n\nlc_all = \"En_US.IBM-1140\"  /* lc_all = \"Fr_FR.IBM-1147\"     */\ncall set_env /* z/OS Unix environment variables             */\n\n/* ________________________________________________________ */\n/* Allocate rexx library with members to be copied in       */\n/* present working directory (pwd) then executed.           */\n/*                                                          */\n/* pwd may be for instance /u/userid                        */\n/*                                                          */\n/* Two members rexx01 and rexx02 will be copied in pwd.     */\n/* A copy of rexx01 in pwd may call                         */\n/* a copy of rexx02 in pwd.                                 */\n/* The copy of rexx01 in pwd will execute in background.    */\n\n/* rexx01 is the first word of arg(1).                      */\nrexx02  = \"REXX02\"          /* possibly called by rexx01    */\nrexxlib = 'BOZO.TEST'       /* contains rexx01 and rexx02   */\nrexxlib =  strip(rexxlib,,\"'\")  /* remove quotes if any     */\n\"alloc f(dd01) da('\"rexxlib\"') shr reu\"\n/* To copy rexx01 in pwd:                                   */\n/* 'cat \"dd:dd01('rexx01')\" > 'rexx01                       */\n/* example: cat \"dd:dd01(MBR1)\" > MBR1                      */\n/* The name of the copy in pwd is the member name.          */\n/* ________ End of allocate rexx library ___________________*/\n\n/* ________________________________________________________ */\n/* Copy rexx in present working directory.                  */\n/* Synchronous copy (foreground)                            */\n/*__________________________________________________________*/\n\n/* 2>&1 redirect standard error to standard output          */\ncmd =  'echo \"======== background ========\" >> 'rexx01'.out 2>&1',\n      ';echo \"'arg(1)'\"          >> 'rexx01'.out 2>&1',\n      ';echo \"run on $(date -u)\" >> 'rexx01'.out 2>&1', /* GMT */\n      ';echo                     >> 'rexx01'.out 2>&1',\n      ';echo \"printenv:\"         >> 'rexx01'.out 2>&1',\n      ';printenv                 >> 'rexx01'.out 2>&1',\n      ';echo                     >> 'rexx01'.out 2>&1',\n      ';echo \"pwd = $(pwd)\"      >> 'rexx01'.out 2>&1',\n      ';echo                     >> 'rexx01'.out 2>&1',\n      ';cat \"dd:dd01('rexx01')\"  >  'rexx01, /* copy to pwd */\n      ';chmod u+x 'rexx01,    /* make it executable by user */\n      ';cat \"dd:dd01('rexx02')\"  >  'rexx02,\n      ';chmod u+x 'rexx02     /* no comma at end            */\n\n/* pwd is present working directory                         */\n/* ';cat \"dd:dd01('rexx01')\"  >  'rexx01      copy in pwd   */\n/* ';chmod u+x 'rexx01       u: user +: add x: executable   */\n/* login shell not used: parameter after env. is 0          */\ncall bpxwunix cmd,,,,env.,0\n\n/* ________________________________________________________ */\n/* Asynchronous execution of copied rexx (background)       */\n/*__________________________________________________________*/\ncmd =  arg(1)'                 >> 'rexx01'.out 2>&1',\n      ';wait'\n/* arg(1): executes (copy of rexx01 in pwd) in background.  */\n/* arg(1) contains name of rexx to call in background       */\n/* followed by its pararameters: rexx01 parm1 parm2 ...     */\n/* rexx02 is possibly called by rexx01.                     */\n\n/* wait: wait for all children to complete.                 */\n/* wait was added to avoid a possible abend SA03            */\n/* (subtask present). An abend SA03 may still occur.        */\n/* I tried before:                                          */\n/*  ';echo \" \";sleep 5'                                     */\n/*    echo \" \": line added to nohup.out                     */\n/*          _______________________________                 */\n/* Execution under /bin/nohup: last parameter is 1          */\n/* login shell not used: parameter after env. is 0          */\n/* No stdin stdout stderr allowed for background execution. */\n/* Output is redirected.                                    */\n/* Any output from the nohup command is directed            */\n/* to the file nohup.out.                                   */\ncall bpxwunix cmd,,,,env.,0,1 /* last parameter 1           */\n                              /* to execute in background   */\n/* Immediate fall through. rexx01 continues running.        */\n\nsay\nsay arg(1)\nsay \"executing in background.\"\nsay \"You may wish to check later with:\"\nsay \"Command ===> tso oedit         (check at the end)\"\nsay \"and v before \"rexx01\".out\"\nsay\nsay \"nohup.out contains undirected output\"\nsay\n\nexit\n\n/*__________________________________________________________*/\n/*                                                          */\nset_env:\n\nenv.0 = 3\nenv.1 = \"PATH=.:/bin:usr/local/bin\"\nenv.2 = \"LC_ALL=\"lc_all\nenv.3 = \"_BPX_SHAREAS=MUST\" /* ddname friendly, e.g. cat DD:DD01 */\n                            /* cat \"dd:dd01(mbr)\"                */\n\nreturn\n/*__________________________________________________________*/\n/* Example of rexx REXX01 and REXX02:                       */\n/*__________________________________________________________*/\n/* REXX01:                                                  */\n/* /* rexx */ /* slash asterisk in column 1 (sheebang)   */ */\n/* trace r                                                  */\n/* parse source . . rexxname .                              */\n/* rexx02 = \"REXX02\" /* name of called rexx              */ */\n/*                                                          */\n/* say \"in \"rexxname\" arg(1) =\"arg(1)                       */\n/* do i = 1 to 2                                            */\n/*    'sleep 1'   /* z/OS Unix command, sleep 1 second   */ */\n/*    interpret = \"call '\"rexx02\"' arg(1)\"                  */\n/*    INTERPRET interpret                                   */\n/* /* call 'REXX02' arg(1)     <-- calling REXX02 in pwd */ */\n/* /* pwd: present working directory                     */ */\n/* /* 'sh02'        arg(1)     <-- calling shell sh02    */ */\n/* end /* do i = 1 to 2  */                                 */\n/*                                                          */\n/* /* Clean up                                           */ */\n/* 'rm 'rexxname            /* remove copy in pwd        */ */\n/* 'rm 'rexx02                                              */\n/* exit                                                     */\n/*__________________________________________________________*/\n/* REXX02:                                                  */\n/* /* rexx */                                               */\n/* trace r                                                  */\n/* say \"in REXX02 arg(1) = \"arg(1)                          */\n/* exit                                                     */\n/*__________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXWUNIX": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xbd\\x00\\xbd\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:09", "lines": 189, "newlines": 189, "modlines": 0, "user": "MLEWIN"}, "text": "//BPXWUNIX PROC CMD=,IN=&IN,OUT=&OUT,\n//         LCALL='Fr_FR.IBM-1147',   LCALL='En_US.IBM-1140'\n//*              Cf. z/OS XL C/C++ Programming Guide >\n//*              Locales supplied with z/OS XL C/C++ >\n//*              Compiled locales\n//         LOGIN=0   0: Login shell not used  1: Login shell used\n//*_____________________________________________________________________\n//* Execute Unix commands from CMD keyword then from //STDPARM file\n//*  on     standard input  IN\n//*  giving standard output OUT.\n//*\n//* May replace BPXBATCH in a batch job.\n//* If replacing a BPXBATCH batch job,\n//*    if there is a //STDPARM, replace only\n//*       EXEC PGM=BPXBATCH          by\n//*       EXEC BPXWUNIX\n//*       If ever parameter PARM if present, please suppress it\n//*       (it is ignored by BPXBATCH when //STDPARM is present)\n//*    if there no //STDPARM and there is a PARM, replace only\n//*       EXEC PGM=BPXBATCH,PARM=    by\n//*       EXEC BPXWUNIX,CMD=\n//* Then run.\n//*_____________________________________________________________________\n//*\n//* Examples:\n//*\n//* //CUT     EXEC BPXWUNIX,CMD='cut -c 1-8,10-14',\n//* //             IN=&IN,OUT=&OUT\n//*\n//* //CUT      EXEC BPXWUNIX,CMD='cut',\n//* //             IN=&IN,OUT=&OUT\n//* //STDPARM  DD *\n//*  -c\n//*  1-8,10-14\n//*\n//* //         SET IN=dsnin\n//* //         SET OUT=dsnout\n//* //CUT      EXEC BPXWUNIX\n//* //STDPARM  DD *\n//* cut -c 1-8,10-14\n//*\n//* //         SET IN=BOZO.SEQ01.FB.LRECL80\n//* //         SET OUT=BOZO.SEQ01.VB.LRECL84\n//* //BZIP2    EXEC BPXWUNIX,CMD='bzip2'\n//*\n//* //   EXEC BPXWUNIX,CMD='cal;'\n//* //STDIN   DD DUMMY\n//* //STDOUT  DD SYSOUT=*\n//* //STDPARM DD *\n//* pwd;  cat \"//'BOZO.SEQ01'\" ; echo $A;\n//*       cat DD:DD01\n//* //STDENV  DD *\n//* A=\"Bonjour\"\n//* //DD01    DD DISP=SHR,DSN=BOZO.TEST(A)\n//*\n//* Execute basic java program:\n//* //   EXEC BPXWUNIX,REGION=300M\n//* //STDIN   DD * In IBM-1147 French codepage\n//* class Bonjour {\n//*  public static void main(String args[]){\n//*   System.out.println(\"Bonjour\");\n//*  }\n//* }\n//* //STDOUT  DD SYSOUT=* Should contain \"Bonjour\"\n//* //STDPARM DD *\n//* set -x                                      ;\n//* export PATH=$JAVA_HOME/bin:$PATH            ;\n//* export LIBPATH=/lib:/usr/lib:$JAVA_HOME/bin ;\n//* cat                         > Bonjour.java  &&\n//* javac -encoding IBM01147      Bonjour.java  &&\n//* java                          Bonjour       &&\n//* rm                            Bonjour.*\n//* //STDENV  DD *\n//* PATH=/bin:/usr/local/bin:.\n//* JAVA_HOME=/usr/lpp/java/current\n//*\n//         EXPORT SYMLIST=*  Insert &CMD into SYSTSIN\n//         SET QUOTE=''''\n//         SET CMD=&QUOTE&CMD&QUOTE\n//         SET LCALL=&QUOTE&LCALL&QUOTE\n//         SET LOGIN=&LOGIN\n//GO       EXEC PGM=IKJEFT1B,DYNAMNBR=500\n//ISPLOG   DD DSN=&&ISPLOG,UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//         LRECL=125,BLKSIZE=129,RECFM=VA\n//ISPPROF  DD DSN=&ISPPROF,DISP=NEW,UNIT=SYSDA,SPACE=(TRK,(15,15,5)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3120\n//ISPPLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPTABL  DD DUMMY\n//ISPTLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//         DD DISP=SHR,DSN=ISP.SISPTENU\n//*\n//SYSTSIN  DD *,SYMBOLS=EXECSYS\nprofile noprefix\ncall *(iebgener)\nispstart cmd(%main   +\n         &cmd &login +\n            )  bdispmax(999999)\n//*\n//SYSTSPRT DD SYSOUT=*,OUTLIM=50000\n//*\n//SYSPRINT DD DUMMY\n//SYSIN    DD DUMMY\n//*\n//SYSUT2   DD DSN=&&TEMPPDS(MAIN),UNIT=VIO,SPACE=(TRK,(1,1,1))\n//SYSEXEC  DD DSN=&&TEMPPDS,VOL=REF=*.SYSUT2,DISP=(OLD,DELETE)\n//*\n//SYSUT1   DD DATA,DLM='><)))\u00b0>'\n /* rexx */\n trace o\n parse arg parm\n /* parm made of:                                                        */\n /* cmd login                                                            */\n n     = words(parm)\n cmd   = subword(parm,1,n-1) /* all words but last                       */\n login = word(parm,n)        /* last word, 0 if login shell not used     */\n                             /*            1 if login shell used         */\n\n /* Complete cmd from STDPARM file.                                      */\n \"execio * diskr STDPARM (stem cmd. finis\"\n cmd_rc = rc\n\n if cmd_rc = 0 then do\n    do i = 1 to cmd.0\n       cmd = cmd !! cmd.i   /* Concatenate                               */\n    end /* do i = 1 to cmd.0                                             */\n end /* if cmd_rc = 0                                                    */\n\n cmd = space(cmd)\n\n /* Accept BPXBATCH commands.                                            */\n /* BPXBATCH uses //STDPARM  and if not present, PARM.                   */\n /* This program uses CMD if present then //STDPARM if present.          */\n if wordpos(translate(word(cmd,1)),'SH PGM') > 0 then\n    cmd = subword(cmd,2) /* remove first word if SH or PGM               */\n\n say\n say \"cmd = \"cmd\n\n say\n if login = 0 then say 'login = 0  login shell not used.'\n if login = 1 then say 'login = 1  login shell used.'\n\n /* Read environment variables from //BASEENV AND //STDENV               */\n \"execio * diskr BASEENV (stem env. finis\"\n env_rc = rc\n\n if env_rc = 0 then do\n    say\n    say \"Environment variables from JCL:\"\n    do i = 1 to env.0\n       env.i = strip(env.i)\n       say ' 'env.i\n    end /* do i = 1 to env.0                                             */\n end /* if env_rc = 0                                                    */\n else do /* if env_rc <> 0                                               */\n    say\n    say \"Error reading BASEENV concatenation.\"\n    say \"execio rc = \"env_rc\n    address ispexec \"vput zispfrc\"\n    exit zispfrc\n end /* if env_rc <> 0                                                   */\n\n /* Second parameter is standard input.                                  */\n /* Third  parameter is standard output.                                 */\n /* call bpxwunix cmd,'DD:STDIN','DD:STDOUT','DD:STDERR',env.            */\n bpxwunix_rc = bpxwunix(cmd,'DD:STDIN','DD:STDOUT','DD:STDERR',env.,login)\n say\n say 'bpxwunix_rc = 'bpxwunix_rc\n\n /* Return code thru ISPF.                                               */\n if bpxwunix_rc = 0 then zispfrc =  0\n                    else zispfrc = 16\n say 'return code = 'zispfrc\n say\n address ispexec \"vput zispfrc\"\n exit zispfrc\n><)))\u00b0>\n//STDPARM  DD *,SYMBOLS=EXECSYS\n//         DD DDNAME=CMD\n//STDIN    DD DISP=SHR,DSN=&IN\n//STDOUT   DD DISP=SHR,DSN=&OUT\n//STDERR   DD SYSOUT=*\n//BASEENV  DD *,SYMBOLS=EXECSYS\nLC_ALL=&LCALL\nPATH=/bin:/usr/local/bin:.\n_BPX_SHAREAS=MUST\n//         DD DDNAME=STDENV\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "BZIP2": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00.\\x00.\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 46, "newlines": 46, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB ,'<--BOZO-->',CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID,TIME=1\n/*JOBPARM L=9999,BYTES=999999,SYSAFF=*\n//* ________________________________________________________________\n//*   Compress with BZIP2.\n//*   (After binary transfer on Windows or Linux,\n//*   decompress with 7zip.\n//*   When decompressed on Windows, the EBCDIC file records have\n//*   X'15' separators.)\n//*   Model JCL\n//*_________________________________________________________________\n//*\n//   SET IN=BOZO.SEQ01            Input   RECFM=FB,LRECL=80 seq\n//   SET OUT=&IN..BZ2             Output  RECFM=VB,LRECL=84 seq\n//*_________________________________________________________________\n//*  Delete, Define output dataset\n//*\n//DELOUT   EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&OUT\n//*\n//DEFOUT   EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&IN,DSN=&OUT,\n//            UNIT=(SYSDA,1),RECFM=VB,LRECL=84,BLKSIZE=0\n//*_________________________________________________________________\n//*  Execute z/OS Unix command bzip2\n//*\n//   EXEC BPXWUNIX,CMD='bzip2'\n//*\n//*  Alternative:\n//*  SET CMD='''bzip2'''          z/OS Unix command\n//*  SET CMD='''gzip'''           z/OS Unix command\n//*  EXEC BPXWUNIX,CMD=&CMD,IN=&IN,OUT=&OUT\n//*\n//*  For options:\n//*  Command ===> tso omvs\n//*               bzip2 -h       or    viewit bzip2 -h\n//*               exit\n//*_________________________________________________________________\n//*  To decompress:\n//*\n//*  EXEC BPXWUNIX,CMD='bunzip2' input  RECFM=VB,LRECL=84\n//*                              output RECFM=FB,LRECL=80\n//*  EXEC BPXWUNIX,CMD='gunzip'\n//*\n//*  Ignore message:\n//*  HPUB0006 trailing garbage after EOF ignored\n//*_________________________________________________________________\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x004\\x004\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 52, "newlines": 52, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  trace o\n\n  /*___________________________________________________________*/\n  /*                                                           */\n  say\n  say \"Examples of call:                                      \"\n  say \"Command ===> tso c d a         <-- MVS  command D A    \"\n  say \"Command ===> tso c $di         <-- JES2 command $DI    \"\n  say \"Command ===> tso viewit c d a  <-- result in View      \"\n  say\n  /*___________________________________________________________*/\n  /* Set up command                                            */\n\n  drop c.\n  c.0 = 1\n  c.1 = left(arg(1),80)\n\n  /*___________________________________________________________*/\n  /* Execute command.                                          */\n  /* Result in isfulog. stem                                   */\n\n  rc = isfcalls(\"on\")                    /* access = on        */\n  isfcons = \"sdsf\"random()               /* console = sdsfxxx  */\n  isfdelay = 1 /* Wait 1 second before retrieving results      */\n  address sdsf isfslash \"(\"c.\") (wait)\"\n  xrc = rc                               /* save return code   */\n  rc = isfcalls(\"off\")                   /* access = off       */\n\n  /*___________________________________________________________*/\n  /* If error, display command and error code.                 */\n  /*                                                           */\n\n  if xrc > 0 then do\n     say \"execution of \"\n     do i = 1 to c.0\n        say '  'c.i\n      end /* do i = 1 to c.0                                   */\n      say \"gave code \"xrc\n      exit 16\n  end /* if xrc > 0                                            */\n\n  /*___________________________________________________________*/\n  /* If ok, display result.                                    */\n  /*                                                           */\n\n  do i = 1 to isfulog.0\n     say isfulog.i\n  end /* do i = 1 to isfulog.0                                 */\n  exit\n\n  /*___________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CODEPAGE": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x01\\x1c\\x01\\x1c\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 284, "newlines": 284, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/*                                                                           */\n/*   Try to get as much information as possible, related to                  */\n/*   codepage and charset on MVS and z/OS Unix.                              */\n/*                                                                           */\n/* Example of use:                                                           */\n/* Command ===> tso codepage                                                 */\n\nif sysvar(\"sysispf\") = 'ACTIVE',\n & sysvar(\"sysenv\")  = 'FORE'    then do  /* ISPF foreground                 */\n   address ispexec\n   \"control errors return\"\n\n   /* Obtain the result of command                                           */\n   /* Command ===> environ termstat                                          */\n   /* in a stem called termstat.                                             */\n   x = outtrap('termstat.')\n       /* cf. 'SYS1.ISP.SISPTENU(ISPCMDS)' in ISPF 3.16                      */\n       zparm = 'termstat'\n       \"select pgm(ispenv) parm(\"zparm\") scrname(settings)\"\n   x = outtrap('off')\n\n   /* Extract terminal codepage and charset from stem termstat.              */\n   /*                                                                        */\n   /* Line following 'CHARACTER SETS'                                        */\n   /* CHARACTER SETS                                                         */\n   /* 001B8185 82000D1D 00000000 07000000 02B7047B 0100F103 C30136           */\n   /* Fifth word has two halfwords: charset then codepage.                   */\n   /*                                                                        */\n   address tso\n   charset  = 'Unknown'                 /* initialize                        */\n   codepage = 'Unknown'\n\n   do i = 1 to termstat.0\n      if pos('CHARACTER SETS',termstat.i) > 0 then do\n\n         j = i + 1\n         w = word(termstat.j,5) /* fifth word of following line              */\n         charset_halfword  = left(w,4)\n         charset           = right(x2d(charset_halfword),5)      /* justify  */\n         codepage_halfword = right(w,4)\n         codepage          = right(x2d(codepage_halfword),5,'0') /* 5 digits */\n         leave\n\n      end /* if pos('CHARACTER SETS',termstat.i) > 0                         */\n   end /* do i = 1 to termstat.0                                             */\n\n   /* Say charset and codepage:                                              */\n   say 'Terminal codepage from \"Command ===> environ termstat\"   = 'codepage\n   say 'Terminal charset  from \"Command ===> environ termstat\"   = 'charset\n\n   address ispexec 'vget (ztermcp5,ztermcs5) shared'\n   say 'Terminal codepage from ispf variable ztermcp5            = 'ztermcp5\n   say 'Terminal charset  from ispf variable ztermcs5            = 'charset\n   /* ztermcp5 has 5 digits.                                                 */\n   /* Suppress '0' at left but keep at least 3 digits. 037 is OK.            */\n   ccsid = strip(substr(ztermcp5,1,2),'L','0')!!substr(ztermcp5,3)\n   say 'Codepage which may be used in iconv z/OS Unix command    = IBM-'ccsid\n\n   address\nend /*                                       ISPF foreground                 */\n\n/*___________________________________________________________________________*/\n/* Try to get COBOL codepage if COBOL compiler in linklist.                  */\n/*                                                                           */\n\ncall try_to_get_COBOL_codepage_default\n\n/*___________________________________________________________________________*/\n/* Try to get WMQ Default Queue Manager ccsid (if WMQ library in linklist).  */\n/*                                                                           */\n\ncall try_to_get_WMQ_default_queue_manager_ccsid\n\n/*___________________________________________________________________________*/\n\n/* Issue z/OS command: D UNI,CONV                                            */\n\ncmd = 'D UNI,CONV'\ncall execute_MVS_command(cmd)\n\n/*___________________________________________________________________________*/\n\n/* Issue z/OS Unix commands: locale                                          */\n/*                           locale -ck charmap codeset                      */\n\ncmd = 'locale'\ncall execute_unix_command(cmd)\n\ncmd = 'locale -ck charmap codeset'\ncall execute_unix_command(cmd)\nexit\n\n/*________________________ROUTINES FOLLOW ___________________________________*/\n\nexecute_MVS_command:\nparse arg cmd\n\ndrop c.\nc.0 = 1\nc.1 = left(cmd,80)\n\n/* Execute command.                                                          */\n/* Result in isfulog. stem                                                   */\n\nrc = isfcalls(\"on\")                    /* access = on                        */\nisfcons = \"sdsf\"random()               /* console = sdsfxxx                  */\nisfdelay = 1 /* Wait 1 second before retrieving results                      */\naddress sdsf isfslash \"(\"c.\") (wait)\"\nisfslash_rc = rc                       /* save return code                   */\nrc = isfcalls(\"off\")                   /* access = off                       */\n\n/* If ok, display result.                                                    */\n\nif isfslash_rc = 0 then do\n   say\n   say 'Execution of MVS command'\n   say cmd\n   say 'gave:'\n   say\n   select /* format result according to command                              */\n\n   when cmd = 'D UNI,CONV' then do\n   /* get i, number line and p position of first line with 'CONVERSION'      */\n     do i = 1 to isfulog.0\n        p = pos('CONVERSION',isfulog.i)\n        if p >  0 then leave\n     end /* do i = 1 to isfulog.0                                            */\n\n   /* say, starting from line with 'CONVERSION' and shifting left            */\n     do k = i to isfulog.0\n        say substr(isfulog.k,p)\n     end /* do k = i to isfulog.0                                            */\n   end /* when cmd = 'D UNI,CONV'                                            */\n\n   otherwise /* general                                                      */\n     do i = 1 to isfulog.0\n        say isfulog.i\n     end /* do i = 1 to isfulog.0                                            */\n\n   end /* select    format result according to command                       */\nend /* if isfslash_rc = 0                                                    */\n\nreturn\n/*___________________________________________________________________________*/\n\nexecute_unix_command:\nparse arg cmd\n\ncall bpxwunix cmd,,out.\n\nif datatype(out.0) = 'NUM' then do\n   if out.0 > 0 then do\n      say\n      say 'Execution of z/OS Unix command'\n      say cmd\n      say 'gave:'\n      say\n      do i = 1 to out.0\n         say out.i\n      end /* do i = 1 to out.0                                               */\n   end /* if out.0 > 0                                                       */\nend /* if datatype(out.0) = 'NUM'                                            */\n\nreturn\n/*___________________________________________________________________________*/\n\ntry_to_get_COBOL_codepage_default:\n\n/* Empty COBOL program compilation                                           */\n/* to get COBOL default codepage if compiler is in linklist.                 */\n/* CODEPAGE is in SYSPRINT.                                                  */\n\naddress tso\n\n/* sysin  Empty COBOL program, compilation gives rc = 16                     */\n'alloc fi(sysin) dummy reuse'\n\n/* COBOL sysprint                                                            */\n'alloc fi(sysprint) unit(vio) tr sp(1) reuse'\narc = rc\nif arc > 0 then do\n   say \"cobol sysprint allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n/*                                                                           */\n\n/* syslin                                                                    */\n'alloc fi(syslin) dummy reuse'\n\n/* sysut1 to sysut15                                                         */\ndo i = 1 to 15\n  \"alloc fi(sysut\"i\") unit(vio) tr sp(1) reuse\"\n  brc = rc\n  if brc > 0 then do\n     say \"cobol sysut\"i\" allocate gave code \"brc\n     exit(12)\n  end /* if brc > 0 */\nend /* do i = 1 to 15                                                        */\n\n/* sysmdeck                                                                  */\n'alloc fi(sysmdeck) dummy reuse'\n\n/* Execute interactively the COBOL compiler.                                 */\n' call *(igycrctl)'              /*   if in linklist                         */\n\ncmd = 'grep CODEPAGE'   /* e.g.  CODEPAGE(1140)                              */\ncall bpxwunix cmd,'DD:SYSPRINT',out.\nif datatype(out.0) = 'NUM' then do\n   if out.0 > 0 then do\n      parse var out.1 . '(' codepage ')' .\n      say\n      say 'COBOL default codepage value is ',\n          '                           'codepage\n      /* COBOL defaults in *(igycdopt)                                       */\n   end /* if out.0 > 0                                                       */\nend /* if datatype(out.0) = 'NUM                                             */\n\n/* clean up                                                                  */\n\"free fi(sysprint syslin sysin sysmdeck)\"\ndo i = 1 to 15\n  \"free fi(sysut\"i\")\"\nend /* do i = 1 to 15                                                        */\n\naddress\nreturn\n/*___________________________________________________________________________*/\n\ntry_to_get_WMQ_default_queue_manager_ccsid:\n\n/* Determine ccsid of (default queue manager                                 */\n/*           for z/os batch programs in csqbdefv)                            */\naddress tso\n\n/*___________________________________________________________________________*/\n/*  Allocate files for csqutil                                               */\n\n\"alloc fi(csqucmd) unit(vio) tracks sp(1) recfm(f) lrecl(80) reuse\"\nnewstack\nqueue \"DISPLAY QMGR QMNAME CCSID\"\naddress mvs \"execio \"queued()\" diskw csqucmd (fini\"\ndelstack\n\n\"alloc fi(sysin) unit(vio) tracks sp(1) recfm(f) lrecl(80) reuse\"\nnewstack\nqueue \"COMMAND\"\naddress mvs \"execio \"queued()\" diskw sysin (fini\"\ndelstack\n\n\"alloc fi(sysprint) unit(vio) tracks sp(1) recfm(f b a) lrecl(133) reuse\"\n\n/*___________________________________________________________________________*/\n/* Execute CSQUTIL.                                                          */\n\n  \"call *(csqutil) \",\n  \"' '\"   /* use default Queue Manager from CSQBDEFV                         */\n  xrc = rc                /* save csqutil return code                        */\n\nif xrc = 0 then do\n   address mvs \"execio * diskr sysprint (stem csqutil. fini\"\n   do i = 1 to csqutil.0\n      if pos('QMNAME(',csqutil.i) > 0 then do\n         parse var csqutil.i . 'QMNAME(' qmname ')' .\n         iterate /* CCSID after                                              */\n      end /* if pos('QMNAME(',csqutil.i) > 0                                 */\n      if pos('CCSID(',csqutil.i) > 0  then do\n         parse var csqutil.i . 'CCSID('  ccsid  ')' .\n         leave\n      end /* if pos('CCSID(',csqutil.i) > 0                                  */\n   end /* do i = 1 to csqutil.0                                              */\n   say\n   say \"Default WMQ Queue Manager \"qmname\" has parameter CCSID \",\n       \"        \"ccsid\nend /* if xrc = 0                                                            */\n\n/* if xrc <> 0 then do nothing; library possibly not in Linklist             */\n\n\"free fi(sysin sysprint csqucmd)\"\ndrop csqutil.\n\naddress\nreturn\n/*___________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CP": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00.\\x00.\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 46, "newlines": 46, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */ /* Show terminal codepage at top right of screen         */\n\n  /* Example of use:                                                  */\n  /* Command ===> tso cp                                              */\n  /* Result, top right of screen: 'Terminal codepage: 1140'           */\n\n  /* Command ===> tso codepage     gives more results                 */\n\n  trace\n\n  address ispexec\n    \"control errors return\"\n\n   /* ------------------------------------- *\n    | Obtain terminal codepage              |\n    | - ztermcp5 has 5 digits               |\n    * ------------------------------------- */\n\n    'vget ztermcp5 shared'\n\n   /* ------------------------------------- *\n    | Build zedsmsg and zedlmsg             |\n    | - zedsmsg in shared pool, 24 char max |\n    | - zedlmsg in shared pool, 79 char max |\n    * ------------------------------------- */\n\n    if left(ztermcp5,1) = '0' then do\n       /* Suppress '0' at left but keep at least 3 digits. 037 is OK. */\n       ccsid = strip(substr(ztermcp5,1,2),'L','0')!!substr(ztermcp5,3)\n       zedsmsg = 'Terminal codepage: 'ccsid\n    end /* if left(ztermcp5,1) = '0'                                  */\n    else zedsmsg = 'Terminal codepage 'ztermcp5 /* 5 digits           */\n\n    zedlmsg = 'The terminal codepage given by ISPF',\n              'variable ztermcp5 (5 digits) is 'ztermcp5\n\n   /* ------------------------------------- *\n    | Show terminal codepage                |\n    * ------------------------------------- */\n\n    \"setmsg msg(isrz000)\"\n    /* \"setmsg msg(isrz001)\"     alarm                                */\n\n  address\n\n  exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDEF": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x19\\x00\\x19\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 25, "newlines": 25, "modlines": 0, "user": "MLEWIN"}, "text": "//DELDEF   PROC DSN=,RECFM=FB,LRECL=80,BLKSIZE=0\n//*\n//* Define sequential file or library\n//*\n//* Examples of use:\n//* //         SET DSN=BOZO.SEQ01\n//* //DELDEF1  EXEC DELDEF,DSN=&DSN      Sequential\n//* //         SET DSN=BOZO.PDSE01\n//* //DELDEF2  EXEC DELDEF,DSN=&DSN      PDSE\n//* //DEF.SYSUT2 DD DSORG=PO,DSNTYPE=(LIBRARY,2),\n//* //       SPACE=(TRK,(5,50,100))\n//*\n//      EXPORT SYMLIST=*\n//*\n//DEL   EXEC PGM=IEFBR14\n//DEL      DD DISP=(MOD,DELETE,DELETE),SPACE=(TRK,0),\n//            DSN=&DSN\n//*\n//DEF   EXEC PGM=ICEGENER\n//SYSPRINT DD DUMMY\n//SYSIN    DD DUMMY\n//SYSUT2   DD DISP=(,CATLG),DSN=&DSN,\n//            RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE,\n//            SPACE=(CYL,(5,5))\n//SYSUT1   DD DUMMY,DCB=*.SYSUT2\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DS": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xe9\\x00\\xe9\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 233, "newlines": 233, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/* Alternative to DSLIST                                            */\n\n/* Examples of use:                                                 */\n/* 1) Dataset list using a default pattern.                         */\n/*    Command ===> tso ds                                           */\n/* 2) Dataset list using a specific pattern.                        */\n/*    Command ===> tso ds boz%.**.*jcl*                             */\n/*    Command ===> cmde  <-- to preserve lower case                 */\n/*    Enter TSO commands below:                                     */\n/*    ===> tso ds /u/b?z*                                           */\n/* 3) Setting a permanent screen name to the present logical screen */\n/*    Command ===> tso ds screen1                                   */\n/* 4) Dataset list using a specific pattern                         */\n/*    in a new logical screen (no parameter order)                  */\n/*    Command ===> tso ds bozo.**.jcl screen1                       */\n/*    Command ===> tso ds screen1 bozo.**.jcl                       */\n/*    screen1 is the name given to the new logical screen.          */\n/* 5) As an edit macro in View or Edit                              */\n/*    (if there is not another ds present in the ISPF command       */\n/*    tables):                                                      */\n/*    Command ===> ds                                               */\n/*    Command ===> ds bozo.**.jcl                                   */\n/*    Command ===> ds screen1                                       */\n/*    Command ===> ds bozo.**.jcl screen1                           */\n/*    Command ===> ds screen1 bozo.**.jcl                           */\n\n/* ispexec select code obtained from:                               */\n/* ISPF 3.16    Table Data Set . . 'SYS1.ISP.SISPTENU'              */\n\n/* Obtain parameters                                                */\n/* ><)))\u00b0>  ><)))\u00b0>  ><)))\u00b0>  ><)))\u00b0>  ><)))\u00b0>  ><)))\u00b0>  ><)))\u00b0>    */\n/* No extra code needed to make a rexx an edit macro.               */\naddress isredit /* Am I an edit macro?                              */\n\"macro (parms)\"\nisr_rc = rc\nif isr_rc =  0 then do /* edit macro                                */\n   parse var parms pattern scrname .\n   nb_parm = words(parms)  /* 0, 1 or 2 parameters                  */\nend /*  if isr_rc =  0    edit macro                                */\nelse do /* isr_rc <> 0    rexx                                      */\n   parse arg pattern scrname .\n   nb_parm = words(arg(1)) /* 0, 1 or 2 parameters                  */\nend /* if isr_rc <> 0     rexx                                      */\nif nb_parm > 2 then nb_parm = 2 /* first two parameters at maximum  */\naddress\n/* <\u00b0(((><  <\u00b0(((><  <\u00b0(((><  <\u00b0(((><  <\u00b0(((><  <\u00b0(((><  <\u00b0(((><    */\n\nselect /* according to number of parameters                         */\n\n  when nb_parm = 0 then do\n  /* _____ Default pattern to change (case of zero parameter) ______*/\n  pattern = 'abc.'userid()\n  pattern    =  strip(pattern,,\"'\")  /* remove quotes if any        */\n  parse var pattern pattern '(' .    /* remove member if present    */\n  call alternative1\n  /* _______________________________________________________________*/\n  end /* when nb_parm = 0                                           */\n\n  when nb_parm = 1 then do\n  /* _______________________________________________________________*/\n  answer = look_like_a_screen_name(pattern)\n  if answer = \"no\" then do /* dataset name pattern assumed          */\n     pattern    =  strip(pattern,,\"'\")  /* remove quotes if any          */\n     parse var pattern pattern '(' .    /* remove member if present      */\n     pattern = translate(pattern,'/','\\') /* '/' for Unix           */\n\n     /* dataset list                                                */\n     if pos('/',pattern) = 0 then call alternative1\n     /* It could be:   call alternative2 or call alternative3       */\n     /* or call alternative4                                        */\n     else do /* for Unix                                            */\n        /* if no lower case in pattern, change all upper case       */\n        /* characters of pattern to lower case.                     */\n        upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        lower = 'abcdefghijklmnopqrstuvwxyz'\n        if pattern == translate(pattern) then /* no lowercase       */\n           pattern =  translate(pattern,lower,upper)\n        call alternative4 /* actual DSLIST                          */\n     end    /* for Unix                                             */\n\n  end /* if answer = \"no\" dataset name pattern assumed              */\n  else do /* if answer = \"yes\" then set permanent screen name       */\n     scrname = pattern\n     stack = 'scrname 'scrname' perm'\n     /* stack =\"command1;command2\"                                  */\n     inocuous_panel = ispblank\n     /* command(   ) implies:                                       */\n     /* panel processed in CONTROL NONDISPL ENTER mode              */\n     /* non display, simulate ENTER key                             */\n     \"ispexec display panel(\"inocuous_panel\") command(stack)\"\n  end     /* if answer = \"yes\" then set permanent screen name       */\n  /* _______________________________________________________________*/\n  end /* when nb_parm = 1                                           */\n\n  when nb_parm = 2 then do\n  /* _____ Exchange scrname and pattern if pattern ________________ */\n  /*       seems to be a screen name (case of two parameters)       */\n     call possibly_exchange_pattern_scrname\n     pattern    =  strip(pattern,,\"'\")  /* remove quotes if any     */\n     parse var pattern pattern '(' .    /* remove member if present */\n     /* Modify scrname if it is not valid.                          */\n     call check_and_try_to_correct_screen_name\n  /* _____ Start new logical screen and obtain dataset list _______ */\n\n     /* perm: permanent                                             */\n     /* tso ds pattern : dataset list                               */\n     /* could be: dslist pattern  (then not recursive)              */\n     /*           if dslist available                               */\n     /* Alternative parm if dslist available:                       */\n     /* parm = 'scrname 'scrname' perm; dslist 'pattern             */\n\n     parse source . . rexxname .    /* rexxname in upper case       */\n     /* recursive rexx with the following parm:                     */\n     parm = 'scrname 'scrname' perm; tso 'rexxname pattern\n     \"ispexec select pgm(ispstrt) parm('\"parm\"')\"\n  /* _______________________________________________________________*/\n  end /* when nb_parm = 2                                           */\n\n  otherwise nop\n\nend     /* select according to number of parameters                 */\nexit\n\nalternative1: /* for DSLIST                                         */\n/* DSL in caps                                                      */\n\"ispexec select pgm(isrdslst) parm(DSL '\"pattern\"') suspend scrname(dslist)\"\nreturn\n\nalternative2: /* for DSLIST                                         */\nzparm=\"'\"pattern\"'\"\n\"ispexec select pgm(isrdslst) parm(DSL &zparm) suspend scrname(dslist)\"\nreturn\n\nalternative3: /* for DSLIST                                         */\naddress ispexec\n  \"lmdinit listid(listidv) level(\"pattern\")\"\n  \"lmddisp listid(\"listidv\") status(yes)\"\n  \"lmdfree listid(\"listidv\")\"\naddress\nreturn\n\nalternative4: /* actual DSLIST                                      */\naddress ispexec\n  zdldsnlv = pattern\n  \"vput zdldsnlv\"          /* lv: level                             */\n  \"control nondispl enter\" /* press ENTER on next screen only       */\n  \"select pgm(isrudl) parm(isrudlp) scrname(dslist)\"\naddress\nreturn\n\n/* ________________________________________________________________ */\n\npossibly_exchange_pattern_scrname: procedure expose pattern scrname\n\n/* Exchange scrname and pattern if pattern                          */\n/* seems to be a screen name (case of two parameters)               */\n/* Original parse arg was: parse arg pattern scrname .              */\n\nanswer = look_like_a_screen_name(pattern)\nif answer = \"yes\" then do\n   first = pattern; second = scrname\n   pattern = second; scrname = first\nend /* if answer = \"yes\"                                            */\nreturn\n/* End of possibly_exchange_pattern_scrname                         */\n/* ________________________________________________________________ */\n\nlook_like_a_screen_name: procedure\nparse arg var .\n\n/* result is \"yes\" if var is small, does not contain '*' nor '%'    */\n/* nor '.' and is not an alias.                                     */\n/* result is \"no\" otherwise.                                        */\n\nanswer = \"yes\" /* default value                                     */\nif length(var)  > 8 then return(\"no\")\nif length(var)  < 2 then return(\"no\")\nif pos('.',var) > 0 then return(\"no\")\nif pos('*',var) > 0 then return(\"no\")\nif pos('%',var) > 0 then return(\"no\")\nif pos('/',var) > 0 then return(\"no\")\nif pos('\\',var) > 0 then return(\"no\")\n\n/* Check for alias.                                                 */\n/* If var is an alias, return \"no\".                                 */\n/* An alias is assumed to be a dsname pattern.                      */\nstem_name = outtrap('silent.')\n  address tso \"listc ent('\"var\"') alias\"\n  listc_alias_rc = rc /* rc = 0 if alias exists                     */\nouttrap_off = outtrap('off')\nif listc_alias_rc = 0 then return(\"no\")\n\nreturn(\"yes\") /* var assumed to be a screen name                    */\n/* ________________________________________________________________ */\n\ncheck_and_try_to_correct_screen_name:,\n  procedure expose scrname\n/* scrname is an input output parameter                    */\n/* scrname 2 to 8 characters that conform to member naming */\n/* rules , except NEXT, PREV, LIST, ON and OFF             */\n\nscrname = translate(scrname) /* set in uppercase           */\n\nif length(scrname) > 8 then do /* too long                 */\n  say 'scrname 'scrname' should have at most 8 characters.'\n  scrname = right(scrname,8) /* retain the 8 rightmost characters */\nend /* when length(scrname) > 8                            */\n\nif length(scrname) < 2 then do /* too short                */\n  say 'scrname 'scrname' should have at least 2 characters.'\n  scrname = scrname!!scrname\nend /* when length(scrname) < 2                            */\n\n/* All characters alphanumeric or national                 */\ndo i = 1 to length(scrname)\n   char = substr(scrname,i,1) /* ith character             */\n   if datatype(char,alphanumeric) then iterate\n   if pos(char,'\u00e0\u00a3$') then iterate /* national char Ok     */\n    scrname = overlay('X',scrname,i)  /* overlay ith char  */\nend /* do i = 1 to length(scrname)                         */\n\n/* First character not numeric                             */\nchar = left(scrname,1)\nif datatype(char,number) then\n    scrname = overlay('X',scrname,1)  /* overlay 1st char  */\n\n/* scrname must not be NEXT, PREV, LIST, ON, OFF.          */\nif wordpos(scrname,'NEXT PREV LIST ON OFF') > 0 then\n  scrname = scrname!!'X'\nreturn\n/* End of check_and_try_to_correct_screen_name ___________ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSM": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x01%\\x01%\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 293, "newlines": 293, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n /* Display a sorted member list with Command ===> sort cha     */\n /* The objective is to get as quick as possible                */\n /* to the most recent work.                                    */\n\n default_dsn = userid()\".TEST\" /* <- Change in your most used dataset */\n /* for bpxwunix command codepage:                              */\n lc_all = \"En_US.IBM-1140\"  /* lc_all = \"Fr_FR.IBM-1147\"        */\n\n /* Command ===> tso dsm           <- using content of variable */\n /*                                   default_dsn in rexx.      */\n /*                                   All members are sorted.   */\n /* Command ===> tso dsm BOZO.CNTL <- All members of BOZO.CNTL  */\n /* Command ===> tso dsm A%B* <- All members with pattern A%B*  */\n /* Command ===> tso dsm BOZO.CNTL A%B*                         */\n /* Command ===> tso dsm A%B* BOZO.CNTL                         */\n\n /* Implementation of Pedro's method as described in            */\n /* http://ibmmainframes.com/about31599.html                    */\n /* with an inline panel to make the rexx self-contained.       */\n /* Thank you Pedro.                                            */\n /* Note: New value of ZCMD is after .ZVARS in )INIT            */\n\n\n trace o\n parse arg dsn pattern .\n /* nparm: number of used parameters                            */\n nparm = min(2,words(arg(1))) /* 0, 1, 2                        */\n call check_parameters\n\n /* Set parameter member for address ispexec \"memlist ...\"      */\n if pattern = '' then mem = ''  /* all members                  */\n                 else mem = 'member('pattern')'\n\n address ispexec\n   \"control errors return\"\n   \"lminit  dataid(did) dataset('\"dsn\"') enq(shrw)\"\n            lminit_rc = rc\n            call check_rc lminit_rc,0,'lminit'\n   \"lmopen  dataid(\"did\")\"\n            lmopen_rc = rc\n            call check_rc lmopen_rc,0,'lmopen'\n\n   panel_name = \"isrudsm\"\n   user_panel = \"usrudsm\"\n   mycmd      = 'sort cha'             /* issued from usrudsm   */\n   call set_panel                      /* creates panel usrudsm */\n\n     \"control nondispl enter\"\n  /* address tso 'ispdptrc'            /* display trace */      */\n     \"memlist dataid(\"did\") confirm(yes) panel(usrudsm) \"mem\n  /* address tso 'ispdptrc'                                     */\n              memlist_rc = rc\n              if memlist_rc > 0 then do\n                                  call unset_panel\n                                  call check_rc memlist_rc,0,'memlist'\n                                end /* if memlist_rc > 0        */\n   call unset_panel\n   \"lmclose dataid(\"did\")\"\n            lmclose_rc = rc\n            call check_rc lmclose_rc,0,'lmclose'\n   \"lmfree  dataid(\"did\")\"\n            lmfree_rc = rc\n            call check_rc lmfree_rc,0,'lmfree'\n address /* from ispexec                                        */\n\n exit 0\n\n /*_____________________________________________________________*/\n check_rc:\n trace_previous = trace(\"o\") /* no trace                        */\n\n  /* call example:    call check_rc rc,0,'libdef isptlib'       */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then do\n     return\n     trace(trace_previous)\n  end /* if arg(1)<=arg(2)                                      */\n  /* ISPEXEC or ISREDIT error:                                  */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  say 'rc = 'arg(1)\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg\n  zispfrc = 16\n  address ispexec 'vput zispfrc'\n  exit zispfrc\n\n /* __________________________________________________________ */\n check_parameters: procedure expose default_dsn nparm dsn pattern\n /* input: default_dsn and nparm (number of parameters: 0, 1, 2) */\n /* input and output: dsn and pattern                          */\n\n dsn = translate(dsn)         /* uppercase                     */\n dsn = strip(dsn,,\"'\")        /* remove quotes if any          */\n pattern = translate(pattern) /* uppercase                     */\n\n select /* according to number of parameters nparm             */\n   when nparm = 0 then do /* no parameter                      */\n     dsn = default_dsn\n     mem = '' /* all members                                   */\n   end /* when nparm = 0                                       */\n   when nparm = 1 then do /* one parameter                     */\n     if sysdsn(\"'\"dsn\"'\") = 'OK' then mem ='' /* all members   */\n     else do /* only parameter dsn is not a valid dataset name */\n        dsn = default_dsn\n        pattern = dsn /* assume only parameter to be a pattern */\n     end /* only parameter is not a valid dataset name         */\n   end /* when nparm = 1                                       */\n   when nparm = 2 then do /* two parameters                    */\n     if sysdsn(\"'\"dsn\"'\") <> 'OK' then do\n        /* first parameter is not a valid dataset name         */\n        temp = pattern; pattern = dsn; dsn = temp /* exchange  */\n        if sysdsn(\"'\"dsn\"'\") <> 'OK' then do\n           say \"Two parameters and none of them is a valid dsname.\"\n           call help\n           exit\n        end /* two parameters and none of them is a valid dsn  */\n     end /* first parameter is not a valid dataset name        */\n   end /* when nparm = 2                                       */\n   otherwise nop\n end /* select according to number of parameters               */\n return\n\n /* ________________________________________________________ */\nhelp:\n  say\n  say \"Rexx DSM                                                   \"\n  say \"displays member list with the last changed member first.   \"\n  say \"Examples of call:                                          \"\n  say \"Command ===> tso dsm           <- All members (default dsn)\"\n  say \"Command ===> tso dsm BOZO.CNTL <- All members of BOZO.CNTL \"\n  say \"Command ===> tso dsm A%B* <- All members with pattern A%B* \"\n  say \"Command ===> tso dsm BOZO.CNTL A%B*                        \"\n  say \"Command ===> tso dsm A%B* BOZO.CNTL                        \"\n  say\n  return\n\n/* ___________________________________________________________ */\nset_panel: procedure expose panel_name user_panel mycmd lc_all,\n                     ddnm ispptemp\n\n/* lc_all defined at top of rexx.                              */\n/* lc_all = \"Fr_FR.IBM-1147\" */ /* lc_all = \"En_US.IBM-1140\"   */\n\n/* ________________________________________________________ */\n/* Copy ISRUDSM in ISPPLIB concatenation to temporary       */\n/* library.                                                 */\n/* Add three lines after .ZVARS in )INIT and                */\n/*     one line after )PROC                                 */\n/*__________________________________________________________*/\n\naddress tso\n\n/* ________________________________________________________ */\n/* Allocate a temporary panel library and a member.         */\n/*__________________________________________________________*/\n\ncall set_up_prefix\nparse source . . rexxname .    /* rexxname in upper case    */\nddnm = \"dd\"random(1,99999)\nispptemp = prefix\".\"rexxname\".\"ispptemp\".\"ddnm\n\"alloc file(\"ddnm\") unit(sysda) reuse tracks space(1,1) dir(1)\",\n\"recfm(f b) lrecl(80) blksize(0) dsn('\"ispptemp\"(\"user_panel\")')\"\nalloc_rc = rc\n\nif alloc_rc <> 0 then do\n   say rexxname\": allocation of temporary panel library gave code:\",\n       alloc_rc\n   msg_prev = msg('off')\n   \"free fi(\"ddnm\")\"\n   \"del '\"ispptemp\"'\"\n   msg_off  = msg(msg_prev)     /* reset                    */\n   zispfrc = alloc_rc\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\n\n/* ________________________________________________________ */\n/* Insert lines ini1, ini2 and ini3 after .ZVARS in )INIT   */\n/* Insert line proc1 after )PROC                            */\n/* ________________________________________________________ */\n\ncall set_env /* z/OS Unix environment variables             */\n\n/* awk -v v1=\"ABC\" ' pattern {action} ; pattern {action} '  */\n\nregex1 = 'ZVARS = '             /* .ZVARS in )INIT has ZCMD          */\nini1   = \"*rexx(*,mycmd)     \"  /* Add after .ZVARS not before       */\nini2   = \" if mycmd <> '' then zcmd = mycmd\"\nini3   = \"*endrexx           \"  /*                                   */\n/* The temporary panel will be cached.                               */\nregex2 = '^)[pP][rR][oO][cC]'   /* ^ at beginning of line            */\nproc1  = \"&mycmd = &z        \"  /* Add after )PROC                   */\n\ncmd = 'awk -v ini1=\"'ini1'\"          ', /* define awk variable ini1  */\n      '    -v ini2=\"'ini2'\"          ', /*                           */\n      '    -v ini3=\"'ini3'\"          ', /*                           */\n      '    -v proc1=\"'proc1'\"        ', /*                           */\n      \"'                             \", /* start quote               */\n      \"             {print}         ;\", /* print all lines           */\n      \"  /\"regex1\"/ {print ini1;     \", /* if regex1 matches , add   */\n      \"              print ini2;     \", /* after line, ini1, ...     */\n      \"              print ini3}    ;\", /*                           */\n      \"  /\"regex2\"/ {print proc1}    \", /* if regex2 matches , add   */\n      \"'                             \", /* end quote                 */\n      ' < cat \"dd:ispplib('panel_name')\" '  /* input                 */\n\n/* cat permits access to a member in a library concatenation.        */\n/* cat \"dd:ispplib('panel_name')\" > awk ...    failed                */\n/* awk ... < cat \"dd:ispplib('panel_name')\"    Ok                    */\n\ndrop stderr.; stderr.0 = 0         /* initialize standard error stem */\n/* standard output: \"dd:\"ddnm                                        */\ncall bpxwunix cmd,,\"dd:\"ddnm,stderr.,env.\nbpxwunix_rc = rc\n  if stderr.0 > 0 then do /* stderr.0 was expected                   */\n     say rexxname\": Insertion in temporary panel failed.\"\n     say \"bpxwunix rc = \"bpxwunix_rc\n     do i = 1 to stderr.0\n        say 'stderr.'i' = 'stderr.i\n     end /* do i = 1 to stderr.0                                        */\n     msg_prev = msg('off')\n       \"free fi(\"ddnm\")\"\n       \"del '\"ispptemp\"'\"\n     msg_off  = msg(msg_prev)     /* reset                           */\n     zispfrc = 16\n     address ispexec 'vput zispfrc'\n     exit zispfrc\n  end /* if stderr.0 > 0, stderr.0 was expected                      */\n\ndrop stderr. env.\n\n/* ________________________________________________________ */\n/* Libdef                                                   */\n/*__________________________________________________________*/\n\naddress ispexec  \"libdef ispplib library id(\",\n                 ddnm,\n                 \") stack\"\nlibdef_rc = rc\nif libdef_rc > 0 then do\n   say rexxname\": libdef ispplib rc = \"libdef_rc\n   zispfrc = libdef_rc\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if libdef_rc > 0                                     */\nreturn\n\n/*__________________________________________________________*/\n\nunset_panel: procedure expose ddnm ispptemp\n\naddress ispexec \"libdef ispplib\"\nmsg_prev = msg('off')\n  address tso\n    \"free fi(\"ddnm\")\"\n    \"del '\"ispptemp\"'\"\n  address /* from tso                                       */\nmsg_off  = msg(msg_prev)     /* reset                       */\n\nreturn\n\n/*__________________________________________________________*/\n/*                                                          */\nset_env:\n\nenv.0 = 3\nenv.1 = \"PATH=.:/bin:usr/local/bin\"\nenv.2 = \"LC_ALL=\"lc_all\nenv.3 = \"_BPX_SHAREAS=MUST\" /* ddname friendly, e.g. cat DD:DD01 */\n                            /* cat \"dd:dd01(mbr)\"                */\n\nreturn\n/*__________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n/*__________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPTY": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\x8d\\x00\\x8d\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 141, "newlines": 141, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n/* Logically DUMP files with ADRDDSU using ALLDATA(*) ALLX        */\n\ntrace o\nparse arg filter .\n/* filter designates the pattern of the files to dump.            */\n/* filter examples: ABC.DEF                                       */\n/*                  A%C.DEF.*GHI*   (% and * wild characters)     */\n\n/* Examples of use:                                               */\n/* 1) Command ===> tso dumpty BOZO.PDS                            */\n/*                                                                */\n/* 2) In ISPF 3.4:                                                */\n/* Command - Enter \"/\" to select action                           */\n/* -----------------------------------------------------------    */\n/* dumpty    BOZO.PDS          <-- dumpty before dsname           */\n\nfilter = translate(filter)         /* filter in uppercase         */\nfilter = strip(filter,,\"'\")        /* remove quotes if any        */\nparse var filter filter '(' .      /* remove member if present    */\n\nparse source var\nrexxname = word(var,3)\n\ncall build_sysin                   /* ADRDSSU control cards       */\ncall alloc_outdsn                  /* ADRDSSU output file         */\n\"alloc fi(sysprint) da(*) shr reuse\"\n\nrun = '' /* or run = 'TYPRUN=NORUN'                               */\n/* Execute ADRDSSU                                                */\n\"call *(adrdssu) '\"run\"'\"\nadrdssu_rc = rc\nif adrdssu_rc <> 0 then do\n   say rexxname \"Error in executing ADRDSSU.\"\n   say \"adrdssu_rc = \"adrdssu_rc\n   say \"We exit with code 16.\"\n   msg_prev = msg('off')\n      \"free fi(sysin,sysprint,outdd)\"\n      \"del '\"outdsn\"'\"            /* delete                       */\n   msg_off  = msg(msg_prev)\n   zispfrc = 16\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* adrdssu_rc <> 0                                            */\n\n/* normal exit                                                    */\nsay\nsay \"Output ADRDSSU file '\"outdsn\"' created.\"\nmsg_prev = msg('off')\n    \"free fi(sysin,sysprint,outdd)\"\nmsg_off  = msg(msg_prev)\nzispfrc = 0\nif sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\nexit zispfrc\n\n/* ______________________________________________________________ */\nbuild_sysin: procedure expose rexxname filter\n/* rexxname and filter in input                                   */\n/* SYSIN file will contain ADRDSSU control cards (in uppercase).  */\n\nnewstack\nqueue ' DUMP DS ( INC (' filter ') ) +'\nqueue '  OUTDD(OUTDD)                +'\nqueue '  ALLDATA(*) ALLX             +'\nqueue '  TOL(ENQF)                   +'\nqueue '  SPHERE                      +'\nqueue '  SHR                         '\nmsg_prev = msg('off')\n\"alloc file(sysin) unit(vio)\",\n\"tracks space(1,1) lrecl(80) recfm(f) reuse\"\nalloc_rc = rc\nif alloc_rc <> 0 then do\n   say rexxname \"could not allocate the SYSIN file.\"\n   say \"We exit with code 16.\"\n   say \"alloc rc = \"alloc_rc\n   zispfrc = 16\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\nmsg_off  = msg(msg_prev)\n/* End of allocate visualization file.                      */\n\n/* Write on SYSIN file.                                     */\naddress MVS \"execio \"queued()\" diskw sysin (finis\"\nexecio_rc = rc\ndelstack\nif execio_rc <> 0 then do\n   say rexxname \"could not write on SYSIN file.\"\n   say \"execio rc = \"execio_rc\n   say \"We exit with code 16.\"\n   \"free fi(sysin)\"\n   zispfrc = 16\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if execio_rc <> 0                                          */\n/* End of write on SYSIN file.                                    */\n\nreturn\n\n/* ______________________________________________________________ */\nalloc_outdsn: procedure expose rexxname filter outdsn\n/* rexxname and filter in input                                   */\n/* outdsn              in output                                  */\n/* outdsn is ADRDDSU DUMP file                                    */\n\ncall set_up_prefix /* create prefix for new file                  */\nquallist = translate(filter,' ','.')      /* qualifier list       */\nlastqual = word(quallist,words(quallist)) /* last qualifier       */\nlastqual = translate(lastqual,'XX','*%')  /* replace wild char    */\nran  = right(random(1,99999),5,'0')\noutdsn   = prefix\".\"rexxname\".\"lastqual\".R\"ran\nmsg_prev = msg('off')\n\"alloc file(outdd) da('\"outdsn\"') new catalog\",\n\"tracks space(50,500) reuse recfm(u) blksize(27998)\"\nalloc_rc = rc\nif alloc_rc <> 0 then do\n   say rexxname \"could not allocate the output file \"outdsn\n   say \"alloc rc = \"alloc_rc\n   say \"We exit with code 16.\"\n   \"free fi(sysin)\"\n   zispfrc = 16\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                           */\nmsg_off  = msg(msg_prev)\n\nreturn\n\n/* ______________________________________________________________ */\nset_up_prefix:\n\n/* Set up new output file prefix.                                 */\nprefix = sysvar('syspref')           /* tso profile prefix        */\nuid    = sysvar('sysuid')            /* tso userid                */\nif prefix = '' then prefix = uid     /* use uid if null prefix    */\nif prefix <> '' & prefix <> uid then /* different prefix than uid */\n   prefix = prefix'.'uid             /* use prefix.uid            */\n\nreturn\n /*_______________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUP": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xb8\\x00\\xb8\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 184, "newlines": 184, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n trace o\n\n /* Obtain duplicate member names for specified libraries                   */\n /* using ISRDDN DUP                                                        */\n\n if sysvar(sysispf) <> 'ACTIVE' then do\n   say rexxname 'must be invoked from ISPF, terminating!'\n   exit 12\n end\n zerrmsg=''\n parse source . . rexxname .    /* rexxname in upper case                   */\n\n /*_________________________________________________________________________*/\n /* Obtain dsnames                                                          */\n call set_up_panel /* contains libdef ispplib dataset id( ) stack           */\n address ispexec\n 'control errors return'\n 'display panel(panel)'  /* obtain dsnames                                  */\n drc = rc\n address\n if drc = 8 then do    /* user pressed PF3   Do not process  Abandon        */\n    'end'              /* exit edit macro mode                              */\n    call remove_panel  /* contains libdef ispplib                           */\n    exit 0\n end /* if drc = 8        user pressed PF3                                  */\n call remove_panel /* contains libdef ispplib                               */\n\n /*_________________________________________________________________________*/\n /* Set up dsname list                                                      */\n dsnlist = ''\n do i = 1 to 16\n    interpret \"dsn = dsn\"i\n    select /* add quotes if necessary                                       */\n      when dsn         = ''  then iterate\n      when left(dsn,1) = \"'\" then dsnlist = dsnlist dsn\n      otherwise                   dsnlist = dsnlist \"'\"dsn\"'\"\n    end /* select                                                           */\n end /* do i = 1 to 16                                                      */\n\n /*_________________________________________________________________________*/\n /* Allocate $DUP                                                           */\n \"alloc shr reuse fi($DUP) da(\"dsnlist\")\"\n alloc_rc = rc\n call check_rc alloc_rc,0,'alloc fi($DUP)'\n\n /*_________________________________________________________________________*/\n /* Search for duplicate member names using ISRDDN                          */\n\n address ispexec\n \"control errors return\"\n zparm = 'only $DUP;dup'  /* 'o $DUP;dup' or 'dup $DUP'                     */\n \"select pgm(isrddn) newappl(isr) suspend scrname(ddlist) parm(&zparm)\"\n if zerrmsg <> '' then 'setmsg msg('zerrmsg')'\n address\n \"free dd($DUP)\"\n exit 0\n\n /*_________________________________________________________________________*/\n /* Called subroutines                                                      */\n\n check_rc:\n  /* call example:    call check_rc rc,0,'libdef isptlib'                   */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return                        /* rc=0              */\n  if zerrmsg <> '' then address ispexec 'setmsg msg('zerrmsg')'\n  /* ISPEXEC or ISREDIT error:                                              */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1)\n  else say 'rc = 'arg(1)\n  exit arg(1)\n\n set_up_panel:\n  /* build panel for displ                                                  */\n  address tso\n  newstack\n   queue ')attr'\n   queue '~ type(text)   intens(low)  color(blue)    skip(on)'\n   queue '_ type(text)   intens(low)  color(turq)    skip(on)'\n   queue '] type(text)   intens(low)  color(yellow)  skip(on)'\n   queue '< type(input)  intens(high) color(yellow)  caps(off)'\n   queue '! type(text)   intens(low)  color(green)   skip(on)   hilite(reverse)'\n   queue '+ type(nt)'\n   queue ')body'\n   queue ']                C H E C K    F O R   D U P L I C A T E S'\n   queue '_                                                               '\n   queue '    To leave: press PF3.                                        '\n   queue '    Please enter the library dataset names with possible        '\n   queue '    duplicate member names.                                     '\n   queue '    Dsnames are fully qualified in upper case with or without quotes.'\n   queue '_                                                               '\n   queue '   !dsn1  = <dsn1                                        +'\n   queue '   !dsn2  = <dsn2                                        +'\n   queue '   !dsn3  = <dsn3                                        +'\n   queue '   !dsn4  = <dsn4                                        +'\n   queue '   !dsn5  = <dsn5                                        +'\n   queue '   !dsn6  = <dsn6                                        +'\n   queue '   !dsn7  = <dsn7                                        +'\n   queue '   !dsn8  = <dsn8                                        +'\n   queue '   !dsn9  = <dsn9                                        +'\n   queue '   !dsn10 = <dsn10                                       +'\n   queue '   !dsn11 = <dsn11                                       +'\n   queue '   !dsn12 = <dsn12                                       +'\n   queue '   !dsn13 = <dsn13                                       +'\n   queue '   !dsn14 = <dsn14                                       +'\n   queue '   !dsn15 = <dsn15                                       +'\n   queue '   !dsn16 = <dsn16                                       +'\n   queue ')init'\n   queue '   vget (dsn1,dsn2,dsn3,dsn4,dsn5,dsn6,dsn7,dsn8) profile'\n   queue '   vget (dsn9,dsn10,dsn11,dsn12,dsn13,dsn14,dsn15,dsn16) profile'\n\n   /* Customization (in comment)\n   /* Specific rexx DUPCOPY                                        */\n   queue '   if (&dsn2 = &Z)                                       '\n   queue '       &dsn2 = \"XXX.XXXX.COPYLIB\"                        '\n   /* End, specific rexx DUPCOPY                                   */\n      End, customization (in comment)                              */\n\n   queue '   .cursor = dsn1'\n   queue ')reinit'\n   queue '   refresh(*)'\n   queue ')proc'\n   queue \"   ver (&dsn1,dsname)\"\n   queue \"   ver (&dsn2,dsname)\"\n   queue \"   ver (&dsn3,dsname)\"\n   queue \"   ver (&dsn4,dsname)\"\n   queue \"   ver (&dsn5,dsname)\"\n   queue \"   ver (&dsn6,dsname)\"\n   queue \"   ver (&dsn7,dsname)\"\n   queue \"   ver (&dsn8,dsname)\"\n   queue \"   ver (&dsn9,dsname)\"\n   queue \"   ver (&dsn10,dsname)\"\n   queue \"   ver (&dsn11,dsname)\"\n   queue \"   ver (&dsn12,dsname)\"\n   queue \"   ver (&dsn13,dsname)\"\n   queue \"   ver (&dsn14,dsname)\"\n   queue \"   ver (&dsn15,dsname)\"\n   queue \"   ver (&dsn16,dsname)\"\n   queue '   vput (dsn1,dsn2,dsn3,dsn4,dsn5,dsn6,dsn7,dsn8) profile'\n   queue '   vput (dsn9,dsn10,dsn11,dsn12,dsn13,dsn14,dsn15,dsn16) profile'\n   queue ')end'\n\n   address tso\n   ddnm = 'dd'random(1,99999)\n   /* temporary ispllib library                                             */\n   ispltemp = userid()\".\"rexxname\".\"ispltemp\".\"ddnm\n   \"alloc file(\"ddnm\") unit(vio) reuse tracks space(1,1) dir(1)\",\n   \"recfm(f b) lrecl(80) blksize(0) dsn('\"ispltemp\"')\"\n   ddnm1 = 'dd'random(1,99999)\n   \"alloc file(\"ddnm1\") dsn('\"ispltemp\"(panel)') shr reuse\"\n   \"execio\" queued() \"diskw \"ddnm1\" (finis\"\n   delstack\n\n   /* Check content\n   \"execio * diskr \"ddnm1\" (stem abc. finis\"\n   do i = 1 to abc.0; say \"abc \" i abc.i; end\n   */\n\n   address ispexec\n   \"libdef ispplib dataset id(\",\n     \"'\"ispltemp\"'\",\n     \") stack\"\n\n   address /* resume environment                                            */\n return\n\n remove_panel:\n   address ispexec \"libdef ispplib\"\n\n   address tso\n   xmsg = msg(off)\n     \"free dd(ddnm ddnm1)\"\n     \"delete '\"ispltemp\"'\"\n   xmsg = msg(xmsg)         /* reset                                        */\n   address /* resume environment                                            */\n\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAT": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x01\\xc6\\x01\\xc6\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 454, "newlines": 454, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\nparse source . . rexxname .    /* rexxname in upper case            */\nparse arg dsn .\n\n/* Input:  dsn                                                      */\n/* Output: flatdsn     in IEBUPDTE input format with                */\n/*                     ./ NAME control cards                        */\n/*         flatdsnjcl  JCL to reload dsn from flatdsn               */\n/*                     with IEBUPDTE                                */\n/* Output dsnames are in uppercase without quotes.                  */\n/* Example:                                                         */\n/* Command ===> tso flat bozo.cntl                                  */\n/*   Input:  BOZO.CNTL           Library                            */\n/*   Output: BOZO.CNTL.FLAT      Sequential (replaced if it exists) */\n/*           BOZO.CNTL.FLAT.JCL  Sequential (replaced if it exists) */\n\n/*_________________________________________________________________*/\n/*                                                                 */\n/* Help starts                                                     */\n/* FLAT is a rexx and edit macro.                                  */\n/*                                                                 */\n/* It sequentializes a library using successively IEBPTPCH and     */\n/* SORT.                                                           */\n/* The library should have a fixed record format                   */\n/* (RECFM=F or RECFM=FB or RECFM=FBA) and LRECL=80.                */\n/*                                                                 */\n/* The output is in the form of input to the IEBUPDTE utility      */\n/* (which permits to reload a library or to update it).            */\n/* The output sequential file may be edited before reload          */\n/* (in ISPF Edit, in batch with DFSORT, with bpxwunix and awk      */\n/* command, etc...).                                               */\n/* ISPF statistics are lost.                                       */\n/* FLAT produces, apart of the sequential file, another file       */\n/* containing a JCL sample to reload the first file.               */\n/*                                                                 */\n/* Note: The PDSMAN PDSM09 batch utility accepts RECFM=FB or       */\n/* RECFM=VB and a LRECL different of 80.                           */\n/*                                                                 */\n/* Examples of use:                                                */\n/*                                                                 */\n/* Command ===> tso flat                       <- shows help       */\n/* Command ===> tso flat help                                      */\n/*                                                                 */\n/* Command ===> tso flat bozo.cntl                                 */\n/* Command ===> tso flat 'bozo.cntl(mbr1)'     <- same as above    */\n/*                                                mbr1 ignored     */\n/* Created or replaced files:                                      */\n/* BOZO.CNTL.FLAT    and                                           */\n/* BOZO.CNTL.FLAT.JCL                                              */\n/*                                                                 */\n/*                                                                 */\n/* In ISPF 3.4:                                                    */\n/*          Data Sets Matching BOZO                                */\n/* Command ===>                                                    */\n/*                                                                 */\n/* Command - Enter \"/\" to select action                            */\n/* ------------------------------------                            */\n/*          BOZO.CNTL                                              */\n/* flat     BOZO.CNTL2            <- flat alone.                   */\n/*                                                                 */\n/* Created or replaced files:                                      */\n/* BOZO.CNTL2.FLAT    and                                          */\n/* BOZO.CNTL2.FLAT.JCL                                             */\n/*                                                                 */\n/*                                                                 */\n/* In Edit or View:                                                */\n/*            BOZO.CNTL(MBR1)                                      */\n/* Command ===> flat bozo.source  <- edit macro                    */\n/* 000001 //JOB1 JOB ...             It sequentializes the full    */\n/* 000002 //STEP01 ...               library BOZO.SOURCE. No edit. */\n/*                                                                 */\n/*            BOZO.CNTL(MBR1)                                      */\n/* Command ===> flat              <- flat alone.                   */\n/* 000001 //JOB1 JOB ...             It sequentializes the full    */\n/* 000002 //STEP01 ...               library BOZO.CNTL.            */\n/*                                                                 */\n/* Help ends                                                       */\n/*_________________________________________________________________*/\n/*                                                                 */\n\n/*                                                                 */\n/* Thanks to Claus E. Mikkelsen. I used his tip:                   */\n/* http://mainframesupport.dk/tips/tip1214.html                    */\n/*                                                                 */\n\n/* If edit macro                                                   */\naddress isredit\n'macro (dsn)' /* previous value of dsn unchanged if not an edit macro */\n              /* previous value of dsn overridden if an edit macro    */\nmacro_rc = rc\nif macro_rc = 0 then                   /* edit macro               */\n   if dsn = ''  then '(dsn) = dataset' /* default                  */\naddress /* from isredit                                            */\n/* End of if edit macro                                            */\n\ncall is_help_needed(dsn)\ncall build_output_dsnames\ncall execute_iebptpch  /* input dsn,       output flatdsn81        */\ncall execute_sort      /* input flatdsn81, output flatdsn          */\ncall generate_reload_jcl\ncall show_list_of_output_datasets\nexit\n\n/*_________________________________________________________________*/\nbuild_output_dsnames: procedure expose dsn flatdsn81 flatdsn flatdsnjcl\n\n/* Input and output: dsn    will be in uppercase without quotes    */\n\n/* Output: flatdsn     in IEBUPDTE input format with               */\n/*                     ./ NAME control cards                       */\n/*         flatdsnjcl  JCL to rebuild dsn from flatdsn             */\n/*                     with IEBUPDTE                               */\n/* flatdsn81 is a temporary file, output from IEBPTPCH             */\n/*                           and  input to SORT.                   */\n/* Output dsnames are in uppercase without quotes.                 */\n\ndsn  = translate(dsn)        /* uppercase                          */\ndsn  = strip(dsn,,\"'\")       /* remove quotes if any               */\n/* If member present, it is not used.                              */\nparse var dsn dsn '(' member ')' . /* extract dsn if member present  */\nldsn = length(dsn)           /* Ok up to 40 included               */\n\n/* Check dsn validity: library with fixed record format and LRECL=80 */\n\nlistdsi_rc = listdsi(\"'\"dsn\"'\")\nif listdsi_rc       <>   0  !, /* or                               */\n   left(sysdsorg,2) <> 'PO' !,\n   left(sysrecfm,1) <> 'F'  !,\n   syslrecl         <>  80       then do /* invalid dsn            */\n   say               dsn' should be an accessible library'\n   say  copies(' ',ldsn)' with fixed record format and LRECL=80.'\n\n   select\n     when listdsi_rc <> 0 then do\n       say dsn' cannot be accessed. listdsi_rc = 'listdsi_rc\n       say sysdsn(\"'\"dsn\"'\")\n     end /* when listdsi_rc <> 0                                   */\n     when left(sysdsorg,2) <> 'PO' then\n       say dsn' should be a library.'\n     when left(sysrecfm,1) <> 'F'  then\n       say dsn' should have a fixed record format.'\n     when syslrecl <>  80          then\n       say dsn' should have a record length of 80.'\n     otherwise nop\n   end /* select                                                   */\n\n   if listdsi_rc = 0 then\n       say 'It has DSORG = 'sysdsorg,\n           'RECFM = 'sysrecfm' LRECL = 'syslrecl\n\n   say \"We exit with return code 8.         \"\n   zispfrc = 8\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec \"vput zispfrc\"\n   exit zispfrc\nend /* invalid dsn                                                 */\n\nselect /* according to dsn length (Ok up to 40 included)           */\n  when ldsn <= 44 - length('.FLAT.JCL') then do\n       flatdsn81  = dsn'.FLAT81' /* temporary file                 */\n       flatdsn    = dsn'.FLAT'\n       flatdsnjcl = dsn'.FLAT.JCL'\n  end /* when ldsn <= 44 - length('.FLAT.JCL)                      */\n  when ldsn <= 44 - length('.FLAT.J') then do\n       flatdsn81  = dsn'.FLAT81'\n       flatdsn    = dsn'.FLAT'\n       flatdsnjcl = dsn'.FLAT.J'\n  end /* when ldsn <= 44 - length('.FLAT.J)                        */\n  when ldsn <= 44 - length('.F.J') then do\n       flatdsn81  = dsn'.F81'\n       flatdsn    = dsn'.F'\n       flatdsnjcl = dsn'.F.J'\n  end /* when ldsn <= 44 - length('.F.J)                           */\n  otherwise do /* dsname length greater than 40                    */\n      say \"Input dsname length greater than 40.\"\n      say \"Output dsnames cannot be built.     \"\n      say \"We exit with return code 8.         \"\n      zispfrc = 8\n      if sysvar(sysispf) = 'ACTIVE' then address ispexec \"vput zispfrc\"\n      exit zispfrc\n  end /* otherwise    dsname length greater than 40                */\nend /* select according to dsn length                              */\n\nreturn\n/*_________________________________________________________________*/\nexecute_iebptpch: procedure expose dsn flatdsn flatdsn81\n\naddress tso\n\n/* Build SYSIN control card ______________________________________ */\n\"alloc fi(sysin)  space(1,1) tracks lrecl(80) blksize(80)\",\n      \"new        recfm(f,b) unit(vio) reuse\"\n       alloc_sysin_rc = rc\n       call check_rc alloc_sysin_rc,0,'alloc sysin for IEBPTPCH'\n\"newstack\"\nqueue \" PUNCH TYPORG=PO\"\n\"execio \"queued()\" diskw sysin (fini\"\n       execio_sysin_rc = rc\n       call check_rc execio_sysin_rc,0,'Execio on sysin for IEBPTCH'\n\"delstack\"\n\n /* Allocate sysut1 (input) and sysut2 (output) for IEBPTPCH______ */\n\"alloc fi(sysut1) da('\"dsn\"') shr reuse\"\nmsg_prev = msg(off)\n  \"del '\"flatdsn81\"'\"\nmsg_off = msg(msg_prev)\n\"alloc fi(sysut2) da('\"flatdsn81\"') new catalog\",\n  \"like('\"dsn\"') dsorg(ps) recfm(f,b,a) lrecl(81) blksize(0) reuse\"\n  alloc_sysut2_rc = rc\n  call check_rc alloc_sysut2_rc,0,'Alloc flatdsn81 SYSUT2 for IEBPTPCH'\n\n/* Allocate sysprint file                                          */\n\"alloc fi(sysprint) dummy reuse\"\n\n/* Execute iebptpch                                                */\n\"call *(iebptpch)\"\n  iebptpch_rc = rc\n  call check_rc iebptpch_rc,0,'Execution of IEBPTPCH'\n\n\"free fi(sysin sysprint sysut1 sysut2)\"\naddress /* from TSO                                                */\nreturn\n\n/*_________________________________________________________________*/\nexecute_sort: procedure expose dsn flatdsn81 flatdsn\n\n/* Replace IEBPTPCH member header by IEBUPDTE member header.       */\n/* input flatdsn81, output flatdsn                                 */\n\n\"alloc fi(sortin)  da('\"flatdsn81\"') shr reuse\"\nmsg_prev = msg(off)\n  \"del '\"flatdsn\"'\"\nmsg_off = msg(msg_prev)\n\"alloc fi(sortout) da('\"flatdsn\"') new catalog\",\n  \"like('\"dsn\"') dsorg(ps) recfm(f,b) lrecl(80) blksize(0) reuse\"\n  alloc_sortout_rc = rc\n  call check_rc alloc_sortout_rc,0,'Alloc flatdsn SORTOUT for SORT'\n\"alloc fi(sysout) dummy reuse\"\n\"alloc fi(sysin)  space(1,1) tracks lrecl(80) blksize(80)\",\n      \"new        recfm(f,b) unit(vio) reuse\"\n       alloc_sysin_rc = rc\n       call check_rc alloc_sysin_rc,0,'alloc sysin'\ndrop sysin.\n\nsysin.1  = \"  OPTION COPY\"\nsysin.2  = \"  INREC  FIELDS=(2,80) Suppress ASA first character\"\nsysin.3  = \"* Replace 'MEMBER NAME  ' after ASA character\"\nsysin.4  = \"  OUTREC IFTHEN=(WHEN=(1,13,CH,EQ,C'MEMBER NAME  '),\"\nsysin.5  = \"                       OVERLAY=(1:C'./ ADD  NAME='))\"\nsysin.0  = 5\n\"execio * diskw SYSIN (stem sysin. finis\"\n       execio_sysin_rc = rc\n       call check_rc execio_sysin_rc,0,'execio SYSIN for DFSORT'\naddress linkmvs \"SORT\"\n       sort_rc = rc\n       call check_rc sort_rc,0,'sort'\ndrop sysin.\nmsg_prev = msg(off)\n  \"del '\"flatdsn81\"'\" /* delete temporary file                     */\n  \"free  fi(sortin sortout sysout)\"\nmsg_off = msg(msg_prev)\nreturn\n\n/*_________________________________________________________________*/\ngenerate_reload_jcl: procedure expose dsn flatdsn flatdsnjcl\n\naddress tso\nmsg_prev = msg(off)\n  del \"'\"flatdsnjcl\"'\"\nmsg_off = msg(msg_prev)\n\"alloc fi(jcl) da('\"flatdsnjcl\"') new catalog\",\n  \"dsorg(ps) recfm(f,b) lrecl(80) blksize(0)\",\n  \"tracks space(1,1) reuse\"\n  alloc_flatdsnjcl_rc = rc\n  call check_rc alloc_flatdsnjcl_rc,0,'Alloc flatdsnjcl'\n\n\"newstack\"\nqueue \"//Jobname JOB     <-- Please complete                          \"\nqueue \"//*                                                            \"\nqueue \"//RELOAD EXEC PGM=IEBUPDTE,PARM=NEW Replace or Add             \"\nqueue \"//SYSPRINT DD DUMMY    SYSOUT=* will list all members          \"\n\n/* comments                                                        */\nqueue \"//*\"copies('_',58)\"*\" /* separator */\nqueue \"//* Possibly replace dsname in //SYSUT2 by a new dataset name. \"\nqueue \"//* With PARM=NEW, IEBUPDTE will add new members and           \"\nqueue \"//* replace existing members.                                  \"\nqueue \"//*                                                            \"\nqueue \"//* SYSUT2 refers to the output library to be updated.         \"\nqueue \"//* SYSIN contains members separated by ./ ADD cards           \"\nqueue \"//*\"copies('_',58)\"*\" /* separator */\nqueue \"//*                                                            \"\n\nqueue \"//SYSUT2 DD DISP=SHR,DSN=\"dsn\nqueue \"//SYSIN  DD DISP=SHR,DSN=\"flatdsn\n\"execio \"queued()\" diskw jcl (fini\"\n       execio_jcl_rc = rc\n       call check_rc execio_jcl_rc,0,'Execio JCL for IEBPUPDTE'\n\"delstack\"\naddress /* from tso                                                */\n\nreturn\n/*_________________________________________________________________*/\nshow_list_of_output_datasets: procedure expose dsn\n\n/* Equivalent to: Command ===> dslist pattern                      */\n/* DSL in caps                                                     */\npattern = dsn\n\"ispexec select pgm(isrdslst) parm(DSL '\"pattern\"') suspend scrname(dslist)\"\nreturn\n\n/*_________________________________________________________________*/\ncheck_rc:\ntrace_previous = trace(\"o\") /* no trace                            */\n\n /* call example:    call check_rc rc,0,'libdef isptlib'           */\n /* In case of error:\n ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n */\n if arg(1)<=arg(2) then do\n    return\n    trace(trace_previous)\n end /* if arg(1)<=arg(2)                                          */\n /* ISPEXEC or ISREDIT error:                                      */\n if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n say 'rc = 'arg(1)\n if debug='DEBUG' then do\n   say 'FUNC='arg(3) 'RC='arg(1)\n   if zerrmsg <> '' & zerrmsg <> 'ZERRMSG' then say 'ZERRMSG='zerrmsg\n end /* if debug='DEBUG'                                           */\n zispfrc = 16\n if sysvar(sysispf) = 'ACTIVE' then address ispexec \"vput zispfrc\"\n exit zispfrc\n/*_________________________________________________________________*/\n\nis_help_needed:\n parse arg dsn\n\n select\n   when dsn = '' & macro_rc <> 0 then call show_help /* rexx no arg  */\n   when wordpos(translate(dsn),'HELP -HELP H -H ? -? /? AIDE SOS') > 0\n        then call show_help\n   otherwise return\n end /* select                                                       */\n\n zispfrc = 0\n if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n exit zispfrc\n/*___________________________________________________________________*/\n\nshow_help:\n\n say ' Help for 'rexxname':'\n /* Show help between 'Help starts' and 'Help ends'                  */\n help = 'no'\n line_counter = 0\n do i = 1 to sourceline()\n    if pos('Help starts',sourceline(i)) > 0 then do\n       help = \"yes\"\n       iterate\n    end /* if pos('Help starts',sourceline(i)) > 0                   */\n    if pos('Help ends',sourceline(i)) > 0 then leave\n    if help = 'yes' then do /* record sourceline(i)                  */\n       line_counter = line_counter + 1\n       line.line_counter = sourceline(i)\n    end /* if help = 'yes'                                           */\n end /* do i = 1 to sourceline()                                     */\n line.0 = line_counter\n call visualize\nreturn\n/*___________________________________________________________________*/\n\n visualize: procedure expose line. rexxname\n /* Visualize.                                                */\n if line.0 > 0 then do\n    if sysvar(sysispf) <> 'ACTIVE' then do\n       do i = 1 to line.0\n          say line.i\n       end /* do i = 1 to line.0                              */\n       zispfrc = 0\n       exit zispfrc\n    end /* if sysvar(sysispf) <> 'ACTIVE'                     */\n    else do /*       ispf ACTIVE                              */\n\n       /* Allocate visualization file.                        */\n       address tso\n       ran  = right(random(1,99999),5,'0')\n       ddnm = 'dd'ran                          /* choose random ddname */\n       call set_up_prefix /* create prefix for new file                */\n       dsnprint = prefix\".\"rexxname\".R\"ran\n       msg_prev = msg('off')\n       \"alloc file(\"ddnm\") da('\"dsnprint\"') new catalog\",\n       \"tracks space(5,5) reuse lrecl(132) recfm(f b) blksize(0)\"\n       alloc_rc = rc\n       if alloc_rc <> 0 then do\n          say rexxname \"could not allocate the visualization file.\"\n          say \"We exit with code 16.\"\n          say \"alloc rc = \"alloc_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if alloc_rc <> 0                                */\n       msg_off  = msg(msg_prev)\n       /* End of allocate visualization file.                 */\n\n       /* Write on visualization file.                        */\n       \"execio\" line.0  \"diskw\" ddnm \"(stem line. finis\"\n       execio_rc = rc\n       if execio_rc <> 0 then do\n          say rexxname \"could not write on visualization file.\"\n          say \"We exit with code 16.\"\n          say \"execio rc = \"execio_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if execio_rc <> 0                               */\n       /* End of write on visualization file.                 */\n\n       /* Visualize.                                          */\n       zedsmsg = 'F3 to exit'  /* top right corner            */\n       zedlmsg = 'To exit, press F3.',\n                 'Temporary help file will be deleted.'\n       ispexec \"setmsg msg(isrz000)\"\n       ispexec \"view dataset('\"dsnprint\"')\"\n       /* End of visualize.                                   */\n\n       /* Clean up.                                           */\n       msg_prev = msg('off')\n          \"free fi(\"ddnm\")\"\n          \"del  '\"dsnprint\"'\"\n       msg_off  = msg(msg_prev)     /* reset                  */\n       /* End of clean up.                                    */\n\n    end /* ispf ACTIVE                                        */\n end /* if line.0 > 0                                         */\n\n return\n /*___________________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORALLD": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x92\\x00\\x92\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 146, "newlines": 146, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  trace o\n  parse arg command\n  parse source . . rexxname .\n\n  /*______________________________________________________________*/\n  /* Command contains a level with at least one '*' or '%'.       */\n  /* We execute the command for each dsname contained in level.   */\n  /* Examples:                                                    */\n  /* Command ===> tso foralld whohas XX.YY%G.**.LOADA*            */\n  /* Command ===> tso viewit foralld whohas XX.YY%G.**.LOADA*     */\n  /*______________________________________________________________*/\n  /*                                                              */\n\n  /* Find level in command                                        */\n  /* (in first word from left to contain a '*' or a '%').         */\n\n  w = words(command)\n  do i=1 to w\n     if pos('*',word(command,i)) > 0 then leave\n     if pos('%',word(command,i)) > 0 then leave\n  end /* do i=1 to w                                              */\n\n  /*______________________________________________________________*/\n\n  if i > w then do      /* '*' or '%' in no word of command       */\n  /* Incorrect level in command (missing or with no * or %)       */\n\n     say\n     say 'Command 'command\n     say 'does not contain a word with at least a * or % present.'\n     say 'The level cannot be determined.'\n     parse source . . rexxname .\n     say 'rexx 'rexxname' exits.'\n     say\n     address ispexec\n     'control errors return'\n     zispfrc = 20\n     'vput zispfrc'\n     exit zispfrc\n\n  end /* if i > w                                                */\n  /*_____________________________________________________________*/\n  /* We shall replace level by dsn for each dsn included in level */\n\n  head = subword(command,1,i-1)  /* before level                 */\n\n  generic = word(command,i)\n  parse var generic level '(' rest\n  /* level will be replaced by dsn                               */\n\n  tail = subword(command,i+1)    /* after  level                 */\n\n  /*_____________________________________________________________*/\n  address ispexec\n  'control errors return'\n\n  /*                  S T U C T U R E\n\n   lmdinit            provide a level\n      lmdlist           obtain dataset\n        process         rexx with explicit dsn\n   lmdfree\n\n  */\n\n  \"lmdinit listid(lidv)  level(\"level\")\"\n  lmdinitrc = rc\n  if lmdinitrc = 0 then\n    do /* lmdinit OK                                             */\n      dsn = \"                  \"\n      keepon = \"yes\"\n      do until keepon = \"no \"\n        \"lmdlist listid(\"lidv\") option(list) dataset(dsn) stats(yes)\"\n        lmdlistrc = rc\n        select /* according to lmdlistrc                         */\n          when lmdlistrc = 0  then do /* dsn found               */\n               saveenv = address()\n               address TSO\n                 call process /* dsn                             */\n               address value saveenv\n            end /* lmdlistrc = 0  dataset found                  */\n          when lmdlistrc = 8 then keepon = \"no \" /* end of list  */\n          otherwise /* lmdlistrc not 0 and not 8, error          */\n               say_error('lmdlist' lmdlistrc 'dsn')\n        end /* select according to lmdlistrc                     */\n      end /* do until keepon = \"no \"                             */\n      \"lmdfree listid(\"lidv\")\"\n    end /* lmdinitrc = 0                                         */\n  else /* lmdinit failed                                         */\n         say_error('lmdinit' lmdinitrc 'level')\n  zispfrc = 0\n  'vput zispfrc'\n  exit zispfrc\n  /*_____________________________________________________________*/\n  say_error: procedure expose level dsn zerrlm\n    parse arg function thisrc atlevel\n    say ' '\n    say function' error:'\n    if atlevel = 'dsn' then say 'dsn    = 'dsn\n                       else say 'level  = 'level\n    say function' failed with rc = 'thisrc\n    say         \"ZERRLM  = '\"strip(zerrlm)\"'\"\n    say ' '\n    zispfrc = 16\n    'vput zispfrc'\n    exit zispfrc\n  /*_____________________________________________________________*/\n  process:\n\n    if checkdsn(dsn) > 0 then return\n\n    say\n    say \"dsn = \"dsn\n    say 'in process'\n /* Execute specific command.                                    */\n /* level replaced by dsn                                        */\n    if rest = '' then specific_command = head' 'dsn' 'tail\n                 else specific_command = head' 'dsn'('rest' 'tail\n    say \"We execute: \"specific_command\n\n    interpret 'specific_command' /* command executed here        */\n\n /* End of execute specific command.                             */\n    return\n  /*_____________________________________________________________*/\n    checkdsn: procedure expose rexxname\n    /* Check syntax and existence.                               */\n    /* dsn assumed in upper characters                           */\n    parse arg dsn\n\n    dsn_msg = sysdsn(\"'\"dsn\"'\")\n    if dsn_msg <> 'OK' then do\n       say \"Dsname \"dsn\" is not correct: \"dsn_msg\n       say \"___________________________________________________________\"\n       say \" \"\n       say \"Error in \"rexxname\n       say \"       dsname = \"dsn\n       say \"Do not process.\"\n       say \"___________________________________________________________\"\n       say \" \"\n       return 4\n    end /* if sysdsn(\"'\"dsn\"'\") <> 'OK'                          */\n\n    return 0\n  /*_____________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORALLM": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\xea\\x00\\xea\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 234, "newlines": 234, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  trace o\n  parse arg command\n  parse source . . rexxname .\n  /*                                                                 */\n  /*_________________________________________________________________*/\n  /* Command contains a member pattern with at least one '*' or '%'. */\n  /* We execute the command for each member in pattern.              */\n  /* Examples:                                                       */\n  /* Command ===> tso forallm info XXXXXX.LOAD(A*)                   */\n  /* Command ===> tso viewit forallm info XXXXXX.LOAD(A*)            */\n  /* Command ===> tso viewit forallm terse info USER01.LOAD(A*)      */\n  /*                  terse applies to forallm                       */\n  /*_________________________________________________________________*/\n  /*                                                                 */\n  call terse_processing /* default terse = 'no'                      */\n\n  /* Find member pattern in command                                  */\n\n  w = words(command)\n  do i=1 to w\n     mot = word(command,i)  /* i-th word                             */\n     if pos('*',mot) = 0 & pos('%',mot) = 0 then iterate\n     if pos('(',mot) = 0                    then iterate\n     if pos(')',mot) = 0                    then iterate\n\n     /* At this point, there exists at least a '*' or '%'            */\n     /* in word(command,i) and there exists a '(' and a ')'.         */\n\n     /* Use last innermost parent for pattern.                       */\n     left    = lastpos('(',mot)      /* last left parent position    */\n     /* Determine first right parent at right of last left parent.   */\n     right   = pos(')',mot,left+1)\n     h       = substr(mot,1,left-1)  /* h: head of mot               */\n     pattern = substr(mot,left+1,right-left-1) /* innermost parent content */\n     pattern = strip(pattern)\n\n     /* check pattern                                                */\n     member0 = translate(pattern,'AA','*%')  /* '*' '%' replaced by 'A' */\n     upper member0\n     if checkmbr(member0) <> 0              then iterate\n\n     t       = substr(mot,right+1)   /* t: tail of mot               */\n     /* Extract dsn between last and next to last left parent.       */\n     h0 = translate(h,'  ',\"('\") /* replace left parent, single quote */\n     dsn = word(h0,words(h0))    /* last word                        */\n\n     /* check dsn                                                    */\n     if sysdsn(\"'\"dsn\"'\") = 'OK'            then leave /* found      */\n     /* We leave if check pattern and check dsn are OK.              */\n  end /* do i=1 to w                                                 */\n\n  /*_________________________________________________________________*/\n  if terse = 'no' then\n     say 'Generic command: 'command\n  if i > w then do\n  /* Incorrect member pattern in command (missing or with no * or %) */\n\n     say \"does not contain a word with at least a '*' or '%' present\"\n     say '     and a valid member pattern between parents.            '\n     parse source . . rexxname .\n     say 'rexx 'rexxname' exits.'\n     say\n     address ispexec\n     'control errors return'\n     zispfrc = 30\n     'vput zispfrc'\n     exit zispfrc\n\n  end /* if i > w                                                   */\n  /*________________________________________________________________*/\n  /* We shall replace member pattern by member name                 */\n  /* for each member name included in member pattern.               */\n\n  head = subword(command,1,i-1)  /* before word with member pattern */\n  tail = subword(command,i+1)    /* after  word with member pattern */\n\n  /*________________________________________________________________*/\n\n  /*                  S T U C T U R E\n\n   lminit             assign a dataid\n      lmopen\n         lmmlist      obtain member name (loop)\n            process   rexx with explicit member name\n         lmmlist option(free)\n      lmclose\n   lmfree             dataid\n\n  */\n\n  address ispexec\n  'control errors return'\n\n  \"lminit dataid(data1) dataset('\"dsn\"')\"\n  lminitrc = rc\n  if lminitrc <> 0 then say_error('lminit' lminitrc)\n\n \"lmopen dataid(\"data1\") option(input)\"\n  lmopenrc = rc\n  if lmopenrc <> 0 then say_error('lmopen' lmopenrc)\n\n /* Loop through all members of library included in pattern          */\n\n member = ' '\n count  = 0\n lmrc   = 0\n do while lmrc = 0\n\n   'lmmlist dataid('data1') option(list),\n   member(member) pattern('pattern') stats(no)'\n   lmrc = rc\n   if lmrc = 0 then /* process member */\n     do\n       count = count + 1  /* member counter                          */\n       member = strip(member) /* remove right spaces if any          */\n       if terse = 'no' then do\n          say\n          say right(count,10)' Processing member' member'.'\n       end /* if terse = 'no'                                        */\n\n       saveenv = address()    /* save environment                    */\n       address TSO\n          call process /* member                                     */\n       address value saveenv  /* restore environment                 */\n\n     end /* if lmrc = 0   process member */\n end /* do while lmrc = 0 */\n\n /*__________________________________________________________________*/\n /* Clean up.                                                        */\n /*__________________________________________________________________*/\n\n 'lmmlist dataid('data1') option(free)'\n  lmmlist_option_freerc = rc\n  if lmmlist_option_freerc <> 0 then\n     say_error('lmmlist option free' lmmlist_option_freerc)\n\n 'lmclose dataid('data1')'\n  lmcloserc = rc\n  if lmcloserc <> 0 then say_error('lmclose' lmcloserc)\n\n 'lmfree dataid('data1')'\n  lmfreerc = rc\n  if lmfreerc <> 0 then say_error('lmfree' lmfreerc)\n\n /*__________________________________________________________________*/\n /* Normal exit.                                                     */\n /*__________________________________________________________________*/\n\n  if terse = 'no' then do\n     say\n     say 'There were 'count' members processed for 'word(command,i)'.'\n  end /* if terse = 'no'                                             */\n  zispfrc = 0\n  'vput zispfrc'\n  exit zispfrc\n\n  /*_____________________________________________________________*/\n  say_error: procedure expose zerrlm\n    parse arg function thisrc\n    say ' '\n    say function' error:'\n    say function' failed with rc = 'thisrc\n    say         \"ZERRLM  = '\"strip(zerrlm)\"'\"\n    say ' '\n    zispfrc = 16\n    'vput zispfrc'\n    exit zispfrc\n  /*_____________________________________________________________*/\n  process:\n    /*\n    say\n    say \"member = \"member\n    say 'in process'\n    */\n /* Execute specific command.                                    */\n /* member pattern replaced by member name                       */\n    specific_command = head' 'h'('member')'t' 'tail\n    /*\n    say copies(' ',11)\"Execution of \"specific_command\n    */\n\n    interpret 'specific_command' /* command executed here        */\n\n /* End of execute specific command.                             */\n    return\n  /*_____________________________________________________________*/\n\n  checkmbr: procedure\n  /* Check library member name syntax, return 4 if invalid.      */\n  /* member assumed to be in upper characters.                   */\n  parse arg mbr\n\n  if length(mbr) = 0  then return 4    /* null                   */\n\n  if length(mbr) > 8  then return 4    /* too long               */\n\n  leftmost = left(mbr,1)            /* alpha or national         */\n  first = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ@$#'\n  if pos(leftmost,first) = 0 then return 4\n\n  next = first'0123456789' /* alpha or national or numeric       */\n  do j = 2 to length(mbr)\n     char = substr(mbr,j,1)         /* j-th character in mbr     */\n     if pos(char,next) = 0 then return 4 /* invalid mbr j-th  char */\n  end /* do j = 2 to length(mbr)                                 */\n\n  return 0\n /*___________________________________________________________________*/\n  terse_processing: procedure expose /* in */ command  /* out */ terse\n\n  /* Processing 'TERSE' or 'QUIET' or 'SILENT' in command, if present */\n  terse = 'no'            /* Default                                  */\n\n  t = wordpos('TERSE',translate(command))\n  if t > 0 then do\n     terse = 'yes'\n     command = delword(command,t,1) /* remove 'TERSE'                 */\n  end /* if t > 0                                                     */\n\n  q = wordpos('QUIET',translate(command))\n  if q > 0 then do\n     terse = 'yes'\n     command = delword(command,q,1) /* remove 'QUIET'                 */\n  end /* if q > 0                                                     */\n\n  s = wordpos('SILENT',translate(command))\n  if s > 0 then do\n     terse = 'yes'\n     command = delword(command,s,1) /* remove 'SILENT'                */\n  end /* if s > 0                                                     */\n  return\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FROM": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 160, "newlines": 160, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n trace o\n /*___________________________________________________________*/\n \"isredit macro (cmd)\"   /* no underline in-between parents   */\n\n cp = 'IBM-1140'         /* US codepage                       */\n /* cp = 'IBM-1147' */   /* French codepage                   */\n\n /* Convert from codepage to codepage.                        */\n /* Input:  file on which the edit macro is executed.         */\n /* Output: Temporary file with converted code                */\n /*         (may be copied on a permanent file).              */\n /* Examples: Command ===> TO IBM-1047 FROM IBM-1147          */\n /*           Command ===> FROM IBM-1147 TO IBM-1047          */\n /*           Command ===> TO               uses default      */\n /*           Command ===> TO LIST    list possible codepages */\n /* There are two EDIT macros: FROM and TO with exactly       */\n /*           the same code.                                  */\n /*___________________________________________________________*/\n /*                                                           */\n\n address isredit\n isr_rc = rc\n if isr_rc <> 0 then do /* rexx                               */\n    say 'Error. Must be used as an edit macro'\n    exit 12\n end /* isr_rc <> 0                                           */\n\n \"(dsn0) = dataset\"\n \"(mbr)  = member\"\n if mbr <> '' then dsn = dsn0'('mbr')'\n              else dsn = dsn0 /* sequential                   */\n\n /* Build Unix iconv command.                                 */\n\n upper cmd                   /* in uppercase                  */\n\n /* Remove leading and trailing quotes or apostophes          */\n /* if both exist simultaneously.                             */\n cmd = strip(cmd)            /* remove blanks from both sides */\n if left(cmd,1) = \"'\" then cmd = strip(cmd,,\"'\")\n if left(cmd,1) = '\"' then cmd = strip(cmd,,'\"')\n\n call get_rexxname_and_choose_default_codepages\n\n select /* according to rexxname                              */\n   when rexxname = 'TO' then do\n      parse var cmd to 'FROM' from\n      other = 'FROM'\n   end /* when rexxname = 'TO'                                */\n   when rexxname = 'FROM' then do\n      parse var cmd from 'TO' to\n      other = 'TO'\n   end /* when rexxname = 'FROM'                              */\n   otherwise nop\n end /* select                                                */\n\n /* Assign defaults if necessary.                             */\n if from = '' then from = from_default\n if to   = '' then to   = to_default\n unix_cmd = 'iconv -f 'from' -t 'to\n\n /* If request for help:                                      */\n if (left(cmd,1) = 'H'  )!,     /* e.g. Command ===> TO Help  */\n    (left(cmd,2) = '-H' )!,     /* e.g. Command ===> TO -H    */\n    (left(cmd,4) = 'LIST')!,    /* e.g. Command ===> TO List  */\n    (words(cmd) = 1 & word(cmd,1) = rexxname) then do\n    say '___________________________________________________'\n    say\n    say 'Syntax:'\n    say 'Command ===> 'rexxname' codepage 'other' codepage'\n    say 'Examples:'\n    say 'Command ===> 'rexxname' IBM-1047'\n    say 'Default missing codepage: from 'cp\n    say '                          to   z/OS Unix IBM-1047'\n    say 'Command ===> 'rexxname' 'other' IBM-1147'\n    say 'Command ===> 'rexxname' help'\n    say 'Usual codepages:'\n    say 'IBM-1147 French with Euro sign'\n    say 'IBM-1047 z/OS Unix international'\n    say 'IBM-1140 USA, COBOL default codepage'\n    say 'IBM-1208 UTF-8'\n    say 'IBM-1200 UTF-16BE (Big Endian) National in COBOL'\n    say 'Possible codepages in the following list.'\n    say '___________________________________________________'\n    say\n    unix_cmd = 'iconv -l' /* list possible codepages          */\n end /* request for help                                      */\n\n /* Signal to UNIX edit macro if it needs to build a large LRECL        */\n /* STDOUT file.                                                        */\n wp = wordpos('iconv',unix_cmd)  /* is 'iconv' present in unix_cmd?     */\n if wp > 0 then do          /* check for non EBCDIC codepage            */\n    tocp = word(unix_cmd,wp + 4) /* obtain to codepage tocp             */\n    /* remove ; from to codepage, if present                            */\n    if right(tocp,1) = ';' then tocp = left(tocp,length(tocp)-1)\n    parse var tocp . '-' tocp /* part at right of dash if present       */\n    /* Cf. https://en.wikipedia.org/wiki/EBCDIC_code_pages              */\n    /*           List of EBCDIC codepages                               */\n    /*           Unix USA  DE   NO   SW   IT   SP   UK   FR   INTL IS   */\n    ebcdic_cp = '1047 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149'\n    if wordpos(tocp,ebcdic_cp) > 0 then ebcdic_output = 'YES'\n                                   else ebcdic_output = 'NO'\n end /* if wordpos('iconv',unix_cmd) > 0                                */\n /* Signal to UNIX edit macro a large LRECL STDOUT file.                */\n /* The UNIX edit macro will check if the string \"large output\"         */\n /* is present in unix_cmd.                                             */\n /* Postpend \"large output\" to unix_cmd.                                */\n if ebcdic_output = 'NO' then do\n    unix_cmd = unix_cmd\" large output\"\n end /* if ebcdic_output = 'NO'                                         */\n /* End of signal to UNIX edit macro if it needs to build a large LRECL */\n\n /* End of build Unix iconv command.                                    */\n\n address ispexec\n 'control errors return'\n\n /* Specialized cmd for UNIX macro edit                       */\n mymacro = 'unix'\n \"view dataset('\"dsn\"') macro(\"mymacro\")\",\n       \"parm(unix_cmd)\"\n\n /* ISPEXEC or ISREDIT error:                                 */\n if ZERRSM   <>'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n if ZERRLM   <>'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n if ZEDMSGNO <>'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n if ZEDISMSG <>'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n if ZEDILMSG <>'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n\n address    /* resume previous environment                    */\n\n 'end'\n exit\n /*___________________________________________________________*/\n get_rexxname_and_choose_default_codepages:\n\n /* rexxname is third word in parse source result.            */\n /* Choose default codepages according to environment         */\n /* (eighth word in parse source result).                     */\n\n parse source var\n rexxname = word(var,3)\n if word(var,8) <> 'OMVS' then do /*       not z/OS Unix      */\n    from_default = cp\n    to_default   = 'IBM-1047'     /* default z/OS Unix int'l  */\n end /* if word(var,8) <> 'OMVS'     not z/OS Unix            */\n else do                          /*     z/OS Unix            */\n\n    path_string = translate(rexxname,' ','/')\n    rexxname = word(path_string,words(path_string))\n    p = pos('.',rexxname)    /* remove extension, if present  */\n    if p > 0 then rexxname = substr(rexxname,1,p-1)\n    upper rexxname\n\n    to_default   = cp\n    from_default = 'IBM-1047'     /* default z/OS Unix int'l  */\n end                              /*     z/OS Unix            */\n return\n /*___________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTPUTF8": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00w\\x00w\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 119, "newlines": 119, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB ,'<--BOZO-->' CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID,TIME=1\n/*JOBPARM L=9999,BYTES=999999,SYSAFF=*\n//* ________________________________________________________________\n//*   RECFM=FB library transfer.\n//*   FTP transfer to   UTF-8 on Windows.\n//*   FTP transfer from UTF-8 on Windows.\n//*   Model JCL\n//* ________________________________________________________________\n//*   Remark:\n//*   FTP will not accept as input or output a RECFM=FB file\n//*   for multibyte transfer.\n//*   We use to download or upload:\n//*   locsite en=mbcs mb=(IBM-1140,UTF-8)\n//*   (en: encoding; mbcs: multibyte character set;\n//*   mb: mbdataconn multi byte dataconn)\n//*   With Windows FTP client:\n//*   quote site en=mbcs mb=(IBM-1140,UTF-8)\n//*\n//*   Constraints:\n//*   1) FTP constraint:\n//*      Sending to UTF-8 or receiving from UTF-8\n//*      is a multibyte transfer.\n//*      A multibyte transfer cannot use a RECFM=FB z/OS file.\n//*   2) IEBCOPY constraint:\n//*      IEBCOPY does not copy files with different RECFM.\n//*\n//*\n//* File                  Process         File\n//* ____                  _______         ____\n//*  I RECFM=FB,LRECL=80  -LMCOPY->       SEND RECFM=VB,LRECL=84\n//*  SEND                 -FTP->          Windows UTF-8 file\n//*  Windows UTF-8 file   -FTP->          RECEIVE RECFM=VB,LRECL=84\n//*  RECEIVE              -LMCOPY->       O RECFM=FB,LRECL=80\n//*_________________________________________________________________\n//*\n//   EXPORT SYMLIST=*\n//*\n//   SET I=BOZO.CNTL                             RECFM=FB,LRECL=80 lib\n//   SET SEND=&I..VB84.S                         RECFM=VB,LRECL=84 lib\n//   SET RECEIVE=&I..VB84.R                      RECFM=VB,LRECL=84 lib\n//   SET O=&I..O                                 RECFM=FB,LRECL=80 lib\n//*\n//   SET FTPDIR=BOZO1                            Windows directory\n//*_________________________________________________________________\n//*\n//DELSEND  EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&SEND\n//*\n//DEFSEND  EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&SEND,\n//            UNIT=(SYSDA,1),RECFM=VB,LRECL=84,BLKSIZE=0,\n//            DSNTYPE=(LIBRARY,2)\n//*_________________________________________________________________\n//*\n//DELRECV  EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&RECEIVE\n//*\n//DEFRECV  EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&RECEIVE,\n//            UNIT=(SYSDA,1),RECFM=VB,LRECL=84,BLKSIZE=0,\n//            DSNTYPE=(LIBRARY,2)\n//*_________________________________________________________________\n//*\n//DELO     EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&O\n//*\n//DEFO     EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&O,\n//            UNIT=(SYSDA,1),RECFM=FB,LRECL=80,BLKSIZE=0,\n//            DSNTYPE=(LIBRARY,2)\n//*_________________________________________________________________\n//*  Copy from RECFM=FB,LRECL=80 to RECFM=VB,LRECL=84\n//*\n//   EXEC LMCOPY,I=&I,O=&SEND\n//*_________________________________________________________________\n//*        Multibyte FTP transfer\n//*        from z/OS IBM-1140 VB file to Windows UTF-8 file\n//*\n//FTPSEND    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//*          locsite SBDataconn=(IBM-1140,ISO8859-1)\n//*          locsite sbd=(IBM-1140,IBM-1252)     <-- Windows-1252\n//*          locsite en=mbcs mb=(IBM-1140,UTF-8) (download and upload)\n//*          With Windows FTP client use quote site instead of locsite.\n//*          FTP will not transfer in multibytes a RECFM=FB file.\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite en=mbcs mb=(IBM-1140,UTF-8)\n cd FTP\n mkdir &FTPDIR\n cd    &FTPDIR\n lcd '&SEND'\n mput *\n quit\n//*_________________________________________________________________\n//*        Multibyte FTP transfer\n//*        from Windows UTF-8 file to z/OS IBM-1140 VB file\n//*\n//FTPRECV    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite en=mbcs mb=(IBM-1140,UTF-8)\n cd FTP\n cd   &FTPDIR\n lcd '&RECEIVE'\n mget *\n quit\n//*_________________________________________________________________\n//*  Copy from RECFM=VB,LRECL=84 to RECFM=FB,LRECL=80\n//*\n//   EXEC LMCOPY,I=&RECEIVE,O=&O\n//*_________________________________________________________________\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTPUTF8S": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00v\\x00v\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 118, "newlines": 118, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB ,'<--BOZO-->' CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID,TIME=1\n/*JOBPARM L=9999,BYTES=999999,SYSAFF=*\n//* ________________________________________________________________\n//*   RECFM=FB sequential file transfer.\n//*   FTP transfer to   UTF-8 on Windows.\n//*   FTP transfer from UTF-8 on Windows.\n//*   Model JCL\n//* ________________________________________________________________\n//*   Remark:\n//*   FTP will not accept as input or output a RECFM=FB file\n//*   for multibyte transfer.\n//*   We use to download or upload:\n//*   locsite en=mbcs mb=(IBM-1140,UTF-8)\n//*   (en: encoding; mbcs: multibyte character set;\n//*   mb: mbdataconn multi byte dataconn)\n//*   With Windows FTP client:\n//*   quote site en=mbcs mb=(IBM-1140,UTF-8)\n//*\n//*   Constraints:\n//*   1) FTP constraint:\n//*      Sending to UTF-8 or receiving from UTF-8\n//*      is a multibyte transfer.\n//*      A multibyte transfer cannot use a RECFM=FB z/OS file.\n//*   2) IEBCOPY constraint:\n//*      IEBCOPY does not copy files with different RECFM.\n//*\n//*\n//* File                  Process         File\n//* ____                  _______         ____\n//*  I RECFM=FB,LRECL=80  -LMCOPY->       SEND RECFM=VB,LRECL=84\n//*  SEND                 -FTP->          Windows UTF-8 file\n//*  Windows UTF-8 file   -FTP->          RECEIVE RECFM=VB,LRECL=84\n//*  RECEIVE              -LMCOPY->       O RECFM=FB,LRECL=80\n//*_________________________________________________________________\n//*\n//   EXPORT SYMLIST=*\n//*\n//   SET I=BOZO.SEQ                Sequential    RECFM=FB,LRECL=80\n//   SET SEND=&I..VB84.S                         RECFM=VB,LRECL=84\n//   SET RECEIVE=&I..VB84.R                      RECFM=VB,LRECL=84\n//   SET O=&I..O                                 RECFM=FB,LRECL=80\n//*\n//   SET FTPDIR=BOZO01                           Windows directory\n//*\n//*_________________________________________________________________\n//*\n//DELSEND  EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&SEND\n//*\n//DEFSEND  EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&SEND,\n//            UNIT=(SYSDA,1),RECFM=VB,LRECL=84,BLKSIZE=0\n//*_________________________________________________________________\n//*\n//DELRECV  EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&RECEIVE\n//*\n//DEFRECV  EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&RECEIVE,\n//            UNIT=(SYSDA,1),RECFM=VB,LRECL=84,BLKSIZE=0\n//*_________________________________________________________________\n//*\n//DELO     EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&O\n//*\n//DEFO     EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&O,\n//            UNIT=(SYSDA,1),RECFM=FB,LRECL=80,BLKSIZE=0\n//*_________________________________________________________________\n//*  Copy from RECFM=FB,LRECL=80 to RECFM=VB,LRECL=84\n//*\n//*  With COPYPARM=   to copy a sequential file\n//*  Without COPYPARM to copy a library\n//*\n//   EXEC LMCOPY,I=&I,O=&SEND,COPYPARM=   Sequential file copy\n//*_________________________________________________________________\n//*        Multibyte FTP transfer\n//*        from z/OS IBM-1140 VB file to Windows UTF-8 file\n//*\n//FTPSEND    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//*          locsite SBDataconn=(IBM-1140,ISO8859-1)\n//*          locsite sbd=(IBM-1140,IBM-1252)     <-- Windows-1252\n//*          locsite en=mbcs mb=(IBM-1140,UTF-8) (download and upload)\n//*          With Windows FTP client use quote site instead of locsite.\n//*          FTP will not transfer in multibytes a RECFM=FB file.\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite en=mbcs mb=(IBM-1140,UTF-8)\n cd FTP\n mkdir &FTPDIR\n cd    &FTPDIR\n put  '&SEND'\n quit\n//*_________________________________________________________________\n//*        Multibyte FTP transfer\n//*        from Windows UTF-8 file to z/OS IBM-1140 VB file\n//*\n//FTPRECV    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite en=mbcs mb=(IBM-1140,UTF-8)\n cd FTP\n cd   &FTPDIR\n get '&SEND' '&RECEIVE' (REPLACE\n quit\n//*_________________________________________________________________\n//*  Copy from RECFM=VB,LRECL=84 to RECFM=FB,LRECL=80\n//*\n//   EXEC LMCOPY,I=&RECEIVE,O=&O,COPYPARM=  Sequential file copy\n//*_________________________________________________________________\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTP1252": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00I\\x00I\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 73, "newlines": 73, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB ,'<--BOZO-->' CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID,TIME=1\n/*JOBPARM L=9999,BYTES=999999,SYSAFF=*\n//* ___________________________________________________________________\n//*   FTP transfer to Windows-1252 (alias IBM-1252, CP1252) on Windows.\n//*   FTP transfer from Windows-1252 on Windows.\n//*   Model JCL\n//* ___________________________________________________________________\n//*   Remark:\n//*   We use to download or upload:\n//*   locsite sbd=(IBM-1140,IBM-1252)\n//*   (sbd: sbdataconn single byte dataconn)\n//*   With Windows FTP client:\n//*   quote site sbd=(IBM-1140,IBM-1252)\n//*\n//*\n//* File                  Process         File\n//* ____                  _______         ____\n//*  I RECFM=FB,LRECL=80  -FTP->          Windows-1252 file\n//*  Windows-1252  file   -FTP->          O RECFM=FB,LRECL=80\n//*_________________________________________________________________\n//*\n//   EXPORT SYMLIST=*\n//*\n//   SET I=BOZO.CNTL                             RECFM=FB,LRECL=80 lib\n//   SET O=&I..O                                 RECFM=FB,LRECL=80 lib\n//*\n//   SET FTPDIR=BOZO2                            Windows directory\n//*_________________________________________________________________\n//*\n//DELO     EXEC PGM=IEFBR14\n//DD       DD DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0),DSN=&O\n//*\n//DEFO     EXEC PGM=IEFBR14\n//DD       DD DISP=(,CATLG),LIKE=&I,DSN=&O,\n//            UNIT=(SYSDA,1),RECFM=FB,LRECL=80,BLKSIZE=0,\n//            DSNTYPE=(LIBRARY,2)\n//*_________________________________________________________________\n//*        Singlebyte FTP transfer\n//*        from z/OS IBM-1140 VB file to Windows Windows-1252 file\n//*\n//FTPSEND    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//*          With Windows FTP client use quote site instead of locsite.\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite sbd=(IBM-1140,IBM-1252)\n cd FTP\n mkdir &FTPDIR\n cd    &FTPDIR\n lcd '&I'\n mput *\n quit\n//*_________________________________________________________________\n//*        Singlebyte FTP transfer\n//*        from Windows Windows-1252 file to z/OS IBM-1140 file\n//*\n//FTPRECV    EXEC PGM=FTP,REGION=32M,PARM='(EXIT=16 TIMEOUT 480'\n//SYSPRINT   DD SYSOUT=*\n//OUTPUT     DD SYSOUT=*\n//SYSIN      DD *,SYMBOLS=EXECSYS\n ipaddress\n anonymous\n anonymous\n locsite sbd=(IBM-1140,IBM-1252)\n cd FTP\n cd   &FTPDIR\n lcd '&O'\n mget *\n quit\n//*_________________________________________________________________\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENERIC": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00I\\x00I\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 73, "newlines": 73, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/* Edit macro with invariant code,                           */\n/* parm (maximum 200 characters) and queue controlled.       */\n/* Interpret commands from parm;                             */\n/* if 'q' present in parm, interpret statements from stack,  */\n/* or both.                                                  */\n\n/* ____ Example of use: _____________________________________\naddress tso\n  dsn = \"abc.def(mbr1)\"\n  /* parm = 'hex;q;res'                                      */\n  /* parm = 'q'                                              */\n  parm = 'hex;res;q'   /* parm at maximum 200 characters     */\n\n  /* parm contains:                                          */\n  /* 1) edit commands or                                     */\n  /* 2) macros or                                            */\n  /* 3) special command q which tells:                       */\n  /*    pull lines from stack and interpret them,            */\n  /* separated by \";\"                                        */\n\n  'newstack'\n  /* queue statements to be interpreted by edit macro        */\n  queue \"z = 1 + 4\"\n  queue \"'(dsn) = dataset'\" /* edit commands in quotes       */\n  queue \"'c aBc DeF'\"\n  queue \"say dsn z\"\n  /* change 4 char string 'abc ' in 3 char string 'a b'      */\n     queue \"'c  ''abc ''  ''a b''  all'\"\n  /* queue \"'c  \"\"abc \"\"  \"\"a b\"\"  all'\"       is also Ok    */\naddress ispexec\n  \"control errors return\"\n  \"view dataset('\"dsn\"') macro(generic) parm(parm)\"\naddress\n  'delstack'\nNote: If length(parm) <= 200, it is also possible to use:\n  \"control nondispl enter\"\n  parm = \";hex;res\"\n  \"view dataset('\"dsn\"') macro(nop) parm(parm)\"\n  /* There is no macro nop */\nEnd of note\n ______ End of example of use ______________________________ */\n\naddress isredit\n  \"macro (parm)\"\n\n  str = parm\n  if str <> '' then do\n     str = str';'      /* to parse with ';' last command     */\n     do while pos(';',str) > 0\n\n        /* Obtain cmd                                        */\n        parse var str cmd  ';' str   /* split str            */\n\n        /* Process special command q                         */\n        if strip(translate(cmd)) = 'Q' then\n           do queued()\n              parse pull line\n              interpret line\n           end /* do queued()                                */\n\n        /* edit command or macro:                            */\n        else do\n          interpret cmd\n        end\n\n     end /* do while pos(';',str) > 0                        */\n  end /* if str <> ''                                        */\n\naddress\nexit\n/*___________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREPIT": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x86\\x00\\x86\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 134, "newlines": 134, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\nlc_all = \"En_US.IBM-1140\"\n/* lc_all = \"Fr_FR.IBM-1147\" */\ndsnprint_prefix = \"XX.YYYY\" /* please change dataset high level qualifiers */\n/* Execute strings, fold then grep Unix commands.           */\n/* Display printable strings folded to 72 columns.          */\n\n/* Syntax:                                                  */\n/* Command ===> tso grepit 'regex' dsname                   */\n/* Command ===> tso grepit 'regex' 'dsname'                 */\n/* Command ===> tso grepit 'regex' dsname(member)           */\n/* Command ===> tso grepit 'regex' 'dsname(member)'         */\n/* Command ===> tso cmde                                    */\n/*              grepit 'regex' dsname                       */\n/* The regular expression regex is in local codepage        */\n/* (or is |) and must be between '                          */\n/* The dsname may or may not be surrounded by '             */\n\n/* Example:                                                 */\n\n/* Before:                                                  */\n/* In ISPF 3.4:                                             */\n/*           Data Sets Matching HLQ1.SRCHIMS                */\n/*  Command ===>                                            */\n/*           HLQ1.SRCHIMS.CNTL                              */\n/*           HLQ1.SRCHIMS.XXX0999.DU210618                  */\n\n/* Use:                                                     */\n/*  Command ===>                                            */\n/*           HLQ1.SRCHIMS.CNTL                              */\n/* GREPIT 'Contrat:|Client :|Capital' /                     */\n/* The / indicates the dsname on the line.                  */\n\n/* Result:                                                  */\n/*            XX.YYYY.USERID.GREPIT.T47584                  */\n/* Command ===>                                             */\n/* ****** ********************************* Top of Data *****/\n/* 000001 \u00e90\u00e25Contrat: 11111111111 *ABC*   Solde D : 2570,12*/\n/* 000002 \u00e90\u00e25Client : 22222222222         LD liste: 0,00   */\n/* 000003 \u00e90\u00e25UNTEL  FIRSTNAME             Capital : 3000,00*/\n/* 000004 \u00e90\u00e25Contrat: 33333333333 *ABC*   Solde D : 1799,95*/\n/* 000005 \u00e90\u00e25Client : 44444444444         LD liste: 0,00   */\n\n/* Grepit could be used with a load library member.         */\n\ntrace o\n\n/*__________________________________________________________*/\n/* Get parameters                                           */\n/* Uses regex in-between '                                  */\nparm = arg(1)\nparse var parm \"'\" regex \"'\" dsn .\n\n/*__________________________________________________________*/\n/* Allocate STDIN.                                          */\ndsn = strip(dsn,,\"'\") /* remove quotes if any               */\n\"alloc fi(stdin) da('\"dsn\"') shr reu\"\nsrc = rc\nif src > 0 then do\n   say \"STDIN allocate of \"dsn\" gave code \"src\n   exit(12)\nend /* if src > 0 */\n\n/*__________________________________________________________*/\n/* Allocate STDOUT dsnprint dataset.                        */\ntime_stamp = t!!time('s')\nparse source . . rexxname .\ndsnprint = dsnprint_prefix\".\"userid()\".\"rexxname\".\"time_stamp\n\"allocate fi(stdout) da('\"dsnprint\"') reuse\",\n\"new catalog\",\n\"lrecl(80) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"STDOUT DSNPRINT allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*__________________________________________________________*/\n/* Initialize stem stderr.                                  */\ndrop stderr.\nstderr.0 = 0\n\n/*__________________________________________________________*/\n/* Set up env. environment variables stem.                  */\ndrop env.\nenv.1 = \"LANG=\"lc_all\n/* z/OS Unix commands in IBM-1147 codepage                  */\n/* env.1 = \"LANG=Fr_FR.IBM-1147\" */ /* locale gives LANG=C  */\nenv.0 = 1\n\n/*__________________________________________________________*/\n/* Build z/OS Unix command.                                 */\n\ncmd = \"  strings -z -n 8 | fold -w 72 | grep -Ei '\"regex\"'\"\n/* strings Only printable fields                            */\n/*  -z    Ignores the POSIX definition of a string and      */\n/*        searches for any group of printable characters    */\n/*        greater than four in length.                      */\n/*  -n 8  Displays strings of printable characters          */\n/*        that are at least 8 characters in length.         */\n/* fold  Visualize on w columns                             */\n/*  -w    maximum line length of width characters           */\n/* grep  Search for regular expressions                     */\n/*  -E    matches using extended regular expressions.       */\n/*  -i    case insensitive.                                 */\n\ncall bpxwunix cmd,'DD:STDIN','DD:STDOUT',stderr.,env.\n\n/* say 'stderr.0 = 'stderr.0                                */\n\nif stderr.0 <> 0 then /* z/OS Unix command failed           */\n   do i = 1 to stderr.0\n      say 'stderr.'i' ='stderr.i\n   end                /* z/OS Unix command failed           */\nelse do               /* z/OS Unix command succeeded        */\n\n/*__________________________________________________________*/\n/* Display DSNPRINT                                         */\n  \"ispexec lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n  \"ispexec view   dataid(\"dd1\")\"\n  \"ispexec lmfree dataid(\"dd1\")\"\n\nend                   /* z/OS Unix command succeeded        */\n\n/*__________________________________________________________*/\n/* Clean up                                                 */\nmsgs = msg(\"off\")\naddress tso\n\"free fi(stdin stdout)\"\n\"delete '\"dsnprint\"'\"\nmsgs = msg(msgs)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREPLIB": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00 \\x00 \\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 32, "newlines": 32, "modlines": 0, "user": "MLEWIN"}, "text": "//USERID01 JOB ,'',CLASS=X,MSGCLASS=Y,NOTIFY=&SYSUID\n/*JOBPARM L=9999,BYTES=999999\n/*JOBPARM SYSAFF=*\n//*\n//*        Regex search on a HFS copy of a MVS library\n//*\n//         EXPORT SYMLIST=*                   Insert into SYSIN\n//*\n//         SET REGEX='VIEW.T'                 Regular expression\n//         SET LIB=XX.YYYY.USERID.CNTL\n//*\n//         SET QUOTE=''''                     Define temporary folder\n//         SET TEMPDIR='temp'\n//         SET TEMPDIR=&QUOTE&TEMPDIR&LYYMMDD&LHHMMSS&QUOTE\n//*                                          'tempyymmddhhmmss'\n//BPXBATCH EXEC PGM=BPXBATCH\n//STDPARM  DD *,SYMBOLS=EXECSYS\nsh set -x                        ;\ncd                               ;\nrm -rf                &tempdir   ;\nmkdir                 &tempdir   ;\ncp \"//'&lib'\"         &tempdir   ;\ngrep -E '&regex'      &tempdir/* ;\nrm -rf                &tempdir   ;\n//STDOUT   DD SYSOUT=*\n//STDERR   DD SYSOUT=*\n//STDENV   DD *\nLC_ALL=En_US.IBM-1140\nLANG=En_US.IBM-1140\n//*\nLC_ALL=Fr_FR.IBM-1147\nLANG=Fr_FR.IBM-1147\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREP01": {"ttr": 2574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x88\\x00\\x88\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 136, "newlines": 136, "modlines": 0, "user": "MLEWIN"}, "text": "//USERID01 JOB ,,CLASS=X,MSGCLASS=Y,NOTIFY=&SYSUID\n/*JOBPARM L=9999,BYTES=999999\n/*JOBPARM SYSAFF=*\n//BPXWUNIX PROC CMD=,IN=&IN,OUT=&OUT\n//* Execute Unix command from CMD keyword or from CMD file\n//*  on     standard input  IN\n//*  giving standard output OUT.\n//*\n//* Examples:\n//*\n//* //CUT     EXEC BPXWUNIX,CMD='cut -c 1-8,10-14',\n//* //             IN=&IN,OUT=&OUT\n//*\n//* //CUT      EXEC BPXWUNIX,CMD='cut',\n//* //             IN=&IN,OUT=&OUT\n//* //CMD      DD *\n//*  -c\n//*  1-8,10-14\n//*\n//* //         SET IN=dsnin\n//* //         SET OUT=dsnout\n//* //CUT      EXEC BPXWUNIX\n//* //CMD      DD *\n//* cut -c 1-8,10-14\n//*\n//         SET QUOTE=''''\n//         EXPORT SYMLIST=*  Insert &CMD into SYSTSIN\n//         SET CMD=&QUOTE&CMD&QUOTE\n//GO       EXEC PGM=IKJEFT1B,DYNAMNBR=500\n//ISPLOG   DD DSN=&&ISPLOG,UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//         LRECL=125,BLKSIZE=129,RECFM=VA\n//ISPPROF  DD DSN=&ISPPROF,DISP=NEW,UNIT=SYSDA,SPACE=(TRK,(15,15,5)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3120\n//ISPPLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPTABL  DD DUMMY\n//ISPTLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//         DD DISP=SHR,DSN=ISP.SISPTENU\n//*\n//SYSTSIN  DD *,SYMBOLS=EXECSYS\nprofile noprefix\ncall *(iebgener)\nispstart cmd(%main +\n         &cmd      +\n            )  bdispmax(999999)\n//*\n//SYSTSPRT DD SYSOUT=*,OUTLIM=50000\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//*        Thank you Gilbert Saint-Flour.\n//SYSUT2   DD DSN=&&TEMPPDS(MAIN),UNIT=VIO,SPACE=(TRK,(1,1,1))\n//SYSEXEC  DD DSN=&&TEMPPDS,VOL=REF=*.SYSUT2,DISP=(OLD,DELETE)\n//*\n//SYSUT1   DD DATA,DLM='^-'\n /* rexx */\n trace o\n parse arg cmd\n\n /* Complete cmd from CMD file.                                          */\n \"execio * diskr CMD (stem cmd. finis\"\n cmd_rc = rc\n\n if cmd_rc = 0 then do\n    do i = 1 to cmd.0\n       cmd = cmd !! cmd.i   /* Concatenate                               */\n    end /* do i = 1 to cmd.0                                             */\n end /* if cmd_rc = 0                                                    */\n\n cmd = space(cmd)\n say \"cmd = \"cmd\n\n drop stderr. env.\n\n stderr.0 = 0\n\n /* z/OS Unix commands in IBM-1147 codepage                              */\n /* Cf. z/OS XL C/C++ Programming Guide >                                */\n /*     Locales supplied with z/OS XL C/C++ >                            */\n /*     Compiled locales                                                 */\n env.1 = \"LC_ALL=En_US.IBM-1140\"\n /* env.1 = \"LC_ALL=Fr_FR.IBM-1147\" */ /* locale gives LANG=C            */\n /* env.1 = \"LANG=Fr_FR.IBM-1147\"    works as well                       */\n env.0 = 1\n\n /* Second parameter is standard input.                                  */\n /* Third  parameter is standard output.                                 */\n /* call bpxwunix cmd,'DD:IN','DD:OUT',stderr.,env.   works as well      */\n bpxwunix_rc = bpxwunix(cmd,'DD:IN','DD:OUT',stderr.,env.)\n say ''\n say 'bpxwunix_rc = 'bpxwunix_rc\n\n say 'stderr.0    = 'stderr.0\n /* Display stderr. if non empty.                                        */\n if stderr.0 <> 0 then    /* z/OS Unix command failed                    */\n    do i = 1 to stderr.0\n       say 'stderr.'i' ='stderr.i\n    end\n\n /* Return code thru ISPF.                                               */\n if bpxwunix_rc = 0 & stderr.0 = 0          then zispfrc =  0\n                                            else zispfrc = 16\n say 'return code = 'zispfrc\n say ''\n address ispexec \"vput zispfrc\"\n exit zispfrc\n^-^\n//CMD      DD DDNAME=SYSIN\n//*CMD     DD DDNAME=CMD\n//IN       DD DISP=SHR,DSN=&IN      Input  file\n//OUT      DD DISP=SHR,DSN=&OUT     Output file\n//         PEND\n//GREP     EXEC BPXWUNIX\n//CMD      DD   *\ntso time;\nrm -rf /u/user01/cntl;\nmkdir  /u/user01/cntl;\ncp     \"//'AB.CDEF.user01.cntl'\" /u/user01/cntl;\ngrep -E 'ds.0' /u/user01/cntl/* ;\nrm -rf /u/user01/cntl\n//IN       DD   DUMMY\n//OUT      DD   SYSOUT=*\n//*FSUM9950   input lines truncated - result questionable\n//* One or more input lines are longer than grep can handle.\n//* grep assumes that the\n//* file it is searching has lines\n//* terminated by newline characters.\n//* When no newline\n//* character is found, the line is either\n//* truncated or split into multiple lines.\n//* A common cause of this message is the use of\n//* a binary file as input to the grep command.\n//* Shorten the line or lines, if possible.\n//* Do not use grep to search binary files.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GUESSUTF": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x000\\x000\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 48, "newlines": 48, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n/* Check heuristically if string is in UTF-8                   */\n/* (result will be a guess).                                   */\n\n/* Example of call:                                            */\n/* call 'GUESSUTF' string                                      */\n/* answer = result /* 'utf8' or 'not-utf8' */                  */\n\nstring = arg(1)\n\n/* Most used characters in English language:                   */\n/* (cf. \"Letter frequency\" article of Wikipedia.               */\n/* Space is slightly more frequent than the top letter \"e\" )   */\n\n/*        space \"E\"   \"e\"   \"T\"   \"t\"    \"A\"   \"a\"             */\nEBCDIC = \"X'40'  X'C5' X'85' X'E3' X'A3'  X'C1' X'81' \"\nASCII  = \"X'20'  X'45' X'65' X'54' X'74'  X'41' X'61' \"\n/* weight    8      3     3     2     2      2     2           */\nlist = EBCDIC!!ASCII\n\ndo m = 1 to words(list)\n    w = word(list,m)                    /* m-th word           */\n    two = substr(w,3,2)                 /* X'40' -->  40       */\n    interpret \"tX\"two\" = tally_char(x2c('\"two\"'),string)\"\nend /* do m = 1 to words(list)                                 */\n\n/* Calculate weighted sums                                     */\n/* Prefix t for tally.                                         */\n/*        space  \"E\"      \"e\"      \"T\"    \"t\"    \"A\"   \"a\"     */\ntEBCDIC = tX40*8 +tXC5*2 + tX85*2 + tXE3 + tXA3 + tXC1 +tX81\ntASCII  = tX20*8 +tX45*2 + tX65*2 + tX54 + tX74 + tX41 +tX61\n\nif tASCII < tEBCDIC then return \"not-utf8\"\n                    else return \"utf8\"\n/* ___________________________________________________________ */\ntally_char: procedure\n/* returns how many times char in string                       */\nchar   = arg(1)\nstring = arg(2)\n\n/* wo is length of (string WithOut char)                       */\n/* space(string,0) remove all spaces from string               */\nif char = ' ' then wo = length(space(string,0))\n/* this translate change blank in '%' and char in blank        */\nelse interpret \"wo = length(space(translate(string,'% ',' \"char\"'),0))\"\n\nreturn length(string) - wo\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HISTORY": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x13\\x00\\x13\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 19, "newlines": 19, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n/* Edit z/OS Unix user command history file                    */\n/* from TSO or z/OS Unix.                                      */\n\n/* rexx is placed in a MVS library concatenated to SYSPROC     */\n/* or SYSEXEC.                                                 */\n\n/* Examples:                                                   */\n/*  Command ===> tso history                                   */\n\n/* In z/OS Unix,                                               */\n/*                                                             */\n/*  Command ===> tso omvs                                      */\n/*  $ tso history                                              */\n/*  $ exit                                                     */\n/*_____________________________________________________________*/\n\noedit \".sh_history\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HUMPTY": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\x96\\x00\\x96\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 150, "newlines": 150, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n/* Extract data records from an non compressed, non encrypted     */\n/* ADRDSSU DUMP of a PDSE with RECFM=FB.                          */\n/* Member data records may be interspersed.                       */\n/* First parameter is the DUMP dataset name.                      */\n/* Second parameter is the PDSE fixed logical record length,      */\n/* default value is 80.                                           */\n\n/* Examples of use:                                               */\n/* 1) Command ===> tso humpty BOZO.PDS.DUMP                       */\n/* 2) Command ===> tso humpty BOZO.PDS.DUMP2 40                   */\n/*                                                                */\n/* 3) In ISPF 3.4:                                                */\n/* Command - Enter \"/\" to select action                           */\n/* -----------------------------------------------------------    */\n/* humpty    BOZO.PDS.DUMP     <-- humpty before dsname           */\n/* humpty / 40 7931.PDS.DUMP2                                     */\n\n/* For other ADRDSSU DUMPs (PDS or load libraries for instance),  */\n/* use of rexx 'strings' (Unix 'strings' command portage on MVS)  */\n/* may be considered.                                             */\n\ntrace o\nparse arg indsn len .\n\n/* _____________________________________________________________  */\n/*                                                                */\n/* indsn is the ADRDSSU DUMP dataset name for one or several      */\n/* PDSEs with RECFM=FB and the same LRECL.                        */\n\n/* len is the LRECL of the PDSE(s) with RECFM=FB with same LRECL  */\n/* which were dumped. If len is not indicated, then len=80.       */\n/* _____________________________________________________________  */\n\n/* _____________________________________________________________  */\n/* In an ADRDSSU DUMP of a PDSE with RECFM=FB, data records       */\n/* begin by X'00hh' were hh is the LRECL in hexadecimal           */\n/* characters.                                                    */\n/* For LRECL=80, the data records begin by X'0050'.               */\n\n/* In an ADRDSSU PDSE DUMP, data records of a deleted member      */\n/* may not be all present when using the DUMP parameters          */\n/* ALLDATA(*) ALLX                                                */\n\n/* In an ADRDSSU PDS DUMP, data records of a deleted member       */\n/* are present when using the DUMP parameters                     */\n/* ALLDATA(*) ALLX                                                */\n/* but the data records are not preceded by their length in       */\n/* hexadecimal characters.                                        */\n/* _____________________________________________________________  */\n\naddress tso\nparse source var\nrexxname = word(var,3)\n\n/* indsn    = \"BOZO.DUMP.BOZO.TEST\" for debugging                 */\nindsn = strip(indsn,,\"'\") /* remove quotes if any                 */\n\nif len = '' then len = 80 /* default LRECL                        */\nhhhh = \"'\"d2x(len,4)\"'x\"  /* len = 80 --> hhhh = \"'0050'x\"        */\n\ninfile  = \"DD01\"\noutfile = \"DD01O\"\n\n\"alloc fi(\"infile\") da('\"indsn\"') shr reu\"\ncall allocate_output_file\n\n\"execio 0 diskr \"infile\"  (open\"\n\"execio 0 diskw \"outfile\" (open\"\n\nmaxrecs = 10000000 /* maximum number of dump records which        */\n                   /* could be read                               */\nin = ''            /* string to scan for data records.            */\n                   /* in is current scanning string.              */\ndo n = 1 to maxrecs\n   \"execio 1 diskr \"infile /* read input record                   */\n   if rc = 2 then leave      /* at end of input file              */\n   parse pull in0            /* ADRDSSU record                    */\n   /* Concatenate non prefix part of ADRDSSU record to take care  */\n   /* of spill over data records.                                 */\n   in = in !! substr(in0,17) /* ADRDSSU record has 16 char prefix */\n\n   /* Scan 'in' record,                                           */\n   /* reducing its length after each found data record.           */\n   interpret \"k = pos(\"hhhh\",in)\" /* first match                  */\n   do while k > 0\n      line.1 = substr(in,k+2,len)\n      \"execio 1 diskw \"outfile\" (stem line.\" /* write data record */\n      /* Replace in by what is left after extracted data record.  */\n      k = k + len + 2 /* position past extracted data record      */\n      in = substr(in,k)\n      interpret \"k = pos(\"hhhh\",in)\"         /* next match        */\n   end /* do while k > 0                                          */\n   /* end of scanning in record                                   */\n\nend /* do n = 1 to maxrecs                                        */\n/* end of processing at maximum maxrecs ADRDSSU input lines       */\n\n\"execio 0 diskr \"infile\"  (finis\" /* close infile                 */\n\"execio 0 diskw \"outfile\" (finis\" /* close outfile                */\n\n\"free fi(\"infile\")\"\n\"free fi(\"outfile\")\"\n\nif sysvar(sysispf) = 'ACTIVE' then\n   address ispexec \"view dataset('\"outdsn\"')\"\n\nexit\n/* ______________________________________________________________ */\nallocate_output_file: procedure expose rexxname len infile outfile,\n                      indsn outdsn\n\n/* rexxname, len,  infile and outfile ddnames, indsn: input       */\n/* outdsn: output                                                 */\n\ncall set_up_prefix /* create prefix for new file                  */\nquallist = translate(indsn,' ','.')         /* qualifier list     */\nlastqual = word(quallist,words(quallist))   /* last qualifier     */\nran      = right(random(1,99999),5,'0')\noutdsn   = prefix\".\"rexxname\".\"lastqual\".R\"ran\nmsg_prev = msg('off')\n\"alloc file(\"outfile\") da('\"outdsn\"') new catalog\",\n\"tracks space(50,500) reuse lrecl(\"len\") recfm(f b) blksize(0)\"\nalloc_rc = rc\nif alloc_rc <> 0 then do\n   say rexxname \"could not allocate the output file \"outdsn\n   say \"We exit with code 16.\"\n   say \"alloc rc = \"alloc_rc\n   \"free f(\"infile\")\"\n   zispfrc = 16\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\nmsg_off  = msg(msg_prev)\n\nreturn\n/*________________________________________________________________*/\n\nset_up_prefix:\n\n/* Set up new output file prefix.                                 */\nprefix = sysvar('syspref')           /* tso profile prefix        */\nuid    = sysvar('sysuid')            /* tso userid                */\nif prefix = '' then prefix = uid     /* use uid if null prefix    */\nif prefix <> '' & prefix <> uid then /* different prefix than uid */\n   prefix = prefix'.'uid             /* use prefix.uid            */\n\nreturn\n /*_______________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ID": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00T\\x00T\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 84, "newlines": 84, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n\n /* Change a library member ID.                                       */\n\n\n /* Before:                                                           */\n /*         VIEW      BOZO.CNTL                                       */\n /* Command ===>                                                      */\n /*            Name     Prompt       Size   Created    ...  ID        */\n /* id_______ J        <\u00b0(((><          6  2018/03/15  ...  BOZO      */\n /*                                                                   */\n /* After:                                                            */\n /*         VIEW      BOZO.CNTL                                       */\n /* Command ===>                                                      */\n /*            Name     Prompt       Size   Created    ...  ID        */\n /* _________ J                         6  2018/03/15  ...  <\u00b0(((><   */\n\n parse arg dsn rest\n dsn0 = strip(dsn,,\"'\")               /* remove surrounding quotes    */\n parse var dsn0 dsn '(' member ')' .  /* extract member if present    */\n\n call update\n exit\n /*___________________________________________________________________*/\n\n update:\n\n /*  Update member statistics                                         */\n /*\n >>-ISPEXEC--LMMSTATS--DATAID(data-id)--MEMBER(member-name)------>\n    '-VERSION(version-number)-'      '-MODLEVEL(mod-level)-'\n    '-CREATED(create-date)-'         '-MODDATE(last-modified-date)-'\n    '-MODTIME(last-modified-time)-'  '-CURSIZE(current-size)-'\n    '-INITSIZE(initial-size)-'       '-MODRECS(records-modified)-'\n    '-USER(user-id)-'                '-DELETE-'\n    '-CREATED4(4-char-year-create-date)-'\n    '-MODDATE4(4-char-year-last-modified-date)-'\n    |       .-Off--.   |  '-NOLLA-'  |      .-NO--.   |\n    '-SCLM(-+-On---+-)-'             '-EXT(-+-YES-+-)-'\n               '-Asis-'\n    '-USER8(user-id)-'\n */\n\n address ispexec\n 'control errors return'\n \"lminit dataid(dd1) dataset('\"dsn\"') enq(shr)\"\n        lminit_rc = rc\n        if lminit_rc > 0 then do\n           say 'lminit_rc = 'lminit_rc\n           address\n           return\n        end /* if lminit_rc > 0                                       */\n\n /* Use isplink instead of ispexec and                                */\n /* hexa userid representation if problem                             */\n /* as space or right parent in userid.                               */\n /* ><)))\u00b0>    '6E4C5D5D5D4A6E'x                                      */\n /* userid   = '6E4C5D5D5D4A6E'x                                      */\n userid = left(rest,7)\n\n function = 'LMMSTATS'\n dataid   = dd1\n member   = left(member,8)\n b        = ' '\n\n /* \"lmmstats dataid(\"dd1\") member(\"member\") user8(\"rest\")\" */  /* ok */\n address linkpgm 'isplink function dataid member b b b b b b b b userid'\n\n        lmmstats_rc = rc\n        if lmmstats_rc > 0 then do\n           say 'lmmstats_rc = 'lmmstats_rc\n           say 'zerrlm      = 'zerrlm\n        end /* if lmmstats_rc > 0                                     */\n\n \"lmfree dataid(\"dd1\")\"\n        lmfree_rc = rc\n        if lmfree_rc > 0 then\n           say 'lmfree_rc = 'lmfree_rc\n address\n\n return\n\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INVOKED": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00'\\x00'\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 39, "newlines": 39, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n  trace o\n  /* Request an invoker example                                              */\n\n  parse arg command\n  invoker = 'VIEWIT'\n  call invoker\n\n  time\n  exit\n/*___________________________________________________________________________*/\n\ninvoker: procedure expose invoker command\n\n  /* Example of call:\n  parse arg command\n  invoker = 'VIEWIT' /* Change if rexx with VIEWIT function has another name.*/\n                     /* VIEWIT traps what has been said or the trace         */\n                     /* of what follows, writes in a file and display        */\n                     /* the file.                                            */\n  call invoker       /* Try to be invoked by invoker if not already invoked. */\n  */\n\n  parse source . . rexxname .\n  /* Check if invoker present after rexxname                                 */\n  p = wordpos(translate(invoker),translate(command))\n  if p > 0 then do /* invoker present after rexxname                         */\n     command = delword(command,p,1) /* remove from command                   */\n     if sysvar('sysnest') = 'NO' then do /* not invoked                      */\n        /* execute invoker which executes rexxname                           */\n        invoker rexxname command\n        xrc = rc\n        if xrc = -3 then return /* invoker not found, execute rest of rexx   */\n                    else exit   /* rexxname assumed to have been executed    */\n     end /* if sysvar('sysnest') = 'NO'      not invoked                     */\n  end /* if p > 0                invoker present after rexxname              */\n\n  return /* invoker not present after rexxname, execute rest of rexx         */\n/*___________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JAVA": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x19\\x00\\x19\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 25, "newlines": 25, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB ,'<--BOZO-->',CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID,TIME=1\n/*JOBPARM L=9999,BYTES=999999,SYSAFF=*\n//* ________________________________________________________________\n//*   Execute basic java program.\n//*_________________________________________________________________\n//*\n//   EXEC BPXWUNIX,REGION=300M\n//STDIN   DD * In IBM-1147 French codepage\nclass Bonjour {\n public static void main(String args[]){\n     System.out.println(\"Bonjour\");\n }\n}\n//STDOUT  DD SYSOUT=* Should contain \"Bonjour\"\n//STDPARM DD *\nset -x                                      ;\nexport PATH=$JAVA_HOME/bin:$PATH            ;\nexport LIBPATH=/lib:/usr/lib:$JAVA_HOME/bin ;\ncat                         > Bonjour.java  &&\njavac -encoding IBM01147      Bonjour.java  &&\njava                          Bonjour       &&\nrm                            Bonjour.*\n//STDENV  DD *\nPATH=/bin:/usr/local/bin:.\nJAVA_HOME=/usr/lpp/java/current\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "JULIE": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\xef\\x00\\xef\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 239, "newlines": 239, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx                                                             */\n /* My name is Julie because of the julian date                      */\n /* (year yy followed by number ddd of day in the year).             */\n /*                                                                  */\n /* Example of julian date:   18321     (day 321 of year 2018)       */\n /* Example of standard date: 20181117  (november 17, 2018)          */\n /* I convert from one to the other one.                             */\n /*                                                                  */\n /* Input date is julian date yyddd if argument length is odd        */\n /* (null argument converted to yyddd today's julian date).          */\n /*                                                                  */\n /* Input date is standard date yyyymmd if argument length is even.  */\n /* Verbose if not called.                                           */\n\n trace o\n parse arg julie .\n julie_save = julie\n parm = julie\n if julie = '' then julie = date(j)   /* yyddd today's date          */\n julie_save = julie\n\n parse source . . rexxname .\n if sysvar(sysnest) = 'YES' then called = 'yes'\n                            else called = 'no'\n\n if datatype(julie) <> 'NUM' then do\n    call how_to_use\n    exit(20)\n end /* if datatype(julie) <> 'NUM'                                  */\n\n /* Please note:\n    Input dates given in 2-digit year formats (i.e. European, Julian, Ordered,\n    Usa) are interpreted as being within a 100 year window as calculated by:\n    (current_year - 50) = low end of window\n    (current_year + 49) = high end of window\n */\n\n /* Process criterion is argument length.                            */\n ll = length(julie)\n\n /* If ll < 3,                                                       */\n /* Assume julie is d or dd, number of days of present year,         */\n /* complete with zeroes at left.                                    */\n if ll = 1 then julie = '00'julie\n if ll = 2 then julie = '0'julie\n /* update ll                                                        */\n if ll = 1 ! ll = 2 then ll = 3\n\n select /* According to length.                                      */\n /* If ll = 3 or 5 or 7 convert from julian to standard.             */\n /* If ll = 4 or 6 or 8 convert from standard to julian.             */\n\n   /* julian to standard                                             */\n\n   when ll = 3 then do            /*     ddd                         */\n     parse var julie 1 ddd 4\n     /* Default yy yyyy                                              */\n     yyyy = left(date(s),4)       /* present year from yyyymmdd      */\n     yy   = right(yyyy,2)\n     julie = yy!!ddd              /* adjust julie                    */\n     standard = date(s,julie,j)\n     if called = 'yes' then return standard\n     call jtos\n   end /* when ll = 3 */          /*     ddd                         */\n\n   when ll = 5 then do            /*   yyddd                         */\n     parse var julie 1 yy  3 ddd 6\n     /*  yyyy from 100 years window                                  */\n     yyyy = left(date(s,julie,j),4) /* from j to s: yyyymmdd         */\n     standard = date(s,julie,j)\n     if called = 'yes' then return standard\n     call jtos\n   end /* when ll = 5 */          /*   yyddd                         */\n\n   when ll = 7 then do            /* yyyyddd                         */\n     parse var julie 1 yyyy 5 ddd 8\n     yy = right(yyyy,2)\n     julie = yy!!ddd              /* adjust julie                    */\n     standard = date(s,julie,j)\n     if called = 'yes' then return standard\n     call jtos\n   end /* when ll = 7 */          /* yyyyddd                         */\n\n   /* standard to julian                                             */\n\n   when ll = 4 then do            /*     mmdd                        */\n     parse var julie 1 mm 3\n     /* Default yy yyyy                                              */\n     yyyy = left(date(s),4)       /* present year from yyyymmdd      */\n     yy   = right(yyyy,2)\n     julie = yyyy!!julie          /* adjust julie                    */\n     julian = yy!!right(date(d,julie,s),3,'0') /* d: from 1 to 366   */\n     if called = 'yes' then return julian\n     call stoj\n   end /* when ll = 4 */          /*     mmdd                        */\n\n   when ll = 6 then do            /*   yymmdd                        */\n     parse var julie 1 yy  3 mm 5 dd\n     julie = date(s,mm'/'dd'/'yy,u) /* from USA date to standard date */\n     yyyy = left(julie,4)           /* yyyymmdd                      */\n     julian = yy!!right(date(d,julie,s),3,'0')\n     if called = 'yes' then return julian\n     call stoj\n   end /* when ll = 6 */          /*   yymmdd                        */\n\n   when ll = 8 then do            /* yyyymmdd                        */\n     parse var julie 1 yyyy 5 mm 7\n     yy = right(yyyy,2)\n     julian = yy!!right(date(d,julie,s),3,'0')\n     if called = 'yes' then return julian\n     call stoj\n   end /* when ll = 8 */          /* yyyymmdd                        */\n\n   otherwise do /* unforeseen case                                   */\n     say 'Invalid input 'julie_save' to 'rexxname'.'\n     say 'Exit 20.'\n     exit 20\n   end /* otherwise */ /* unforeseen case                            */\n end /* select */ /* according to length                             */\n\n call cal  /* display calendar                                       */\n call miscellaneous\n call how_to_use\n exit\n\n /*__________________________________________________________________*/\n\n jtos:   /* Say result, from julian yyddd to standard yyyymmdd.      */\n\n mm = substr(standard,5,2)\n\n if parm = '' then       /* no argument                              */\n    say date()\" corresponds to today's julian date \"date('j')\".\"\n else\n    say 'Julian date 'julie_save' corresponds to 'date(,yy!!ddd,j)' or',\n        standard' (format yyyymmdd).'\n return\n\n /*__________________________________________________________________*/\n\n stoj:   /* Say result, from standard yyyymmdd to julian yyddd       */\n\n say 'Standard date 'julie_save' corresponds to julian date 'julian,\n     '(format yyddd).'\n return\n\n /*__________________________________________________________________*/\n\n how_to_use:\n\n say copies('_',76); say\n say 'How to use rexx 'rexxname':'\n say 'Convert from julian date yyddd to standard yyyymmdd or reverse.'\n say 'Calling modes:'\n say\n say 'Today:'\n say 'Command ===> tso 'rexxname\n /*\n say 'Command ===> tso viewit 'rexxname' (assuming that viewit outtraps and '\n say '                 displays what 'rexxname' said)'\n */\n say\n say 'Convert from julian date yyddd to standard date yyyymmdd:'\n say 'Command ===> tso 'rexxname'           Command ===> tso 'rexxname' 321'\n say 'Command ===> tso 'rexxname'  18321    Command ===> tso 'rexxname' 2018321'\n say 'Calling from rexx:'\n say '             yyyymmdd = 'rexxname'()           (today)'\n say '             yyyymmdd = 'rexxname'(ddd)               '\n say '             yyyymmdd = 'rexxname'(yyddd)             '\n say '             yyyymmdd = 'rexxname'(yyyyddd)           '\n say\n say 'Convert from standard date yyyymmdd to julian date yyddd:'\n say 'Command ===> tso 'rexxname'  1117     Command ===> tso 'rexxname' 181117'\n say 'Command ===> tso 'rexxname'  20181117'\n say 'Calling from rexx:'\n say '             yyddd    = 'rexxname'(mmdd)              '\n say '             yyddd    = 'rexxname'(yymmdd)            '\n say '             yyddd    = 'rexxname'(yyyymmdd)          '\n say\n say 'Valid in a 100 years window:'\n say ' (current_year - 50) = low end of window'\n say ' (current_year + 49) = high end of window'\n return\n /*__________________________________________________________________*/\n\n /* Run Unix cal calendar display.                                   */\n cal: procedure expose mm yyyy\n say copies('_',76); say\n\n /* z/OS Unix commands in IBM-1147 codepage                          */\n /* Cf. z/OS XL C/C++ Programming Guide >                            */\n /*     Locales supplied with z/OS XL C/C++ >                        */\n /*     Compiled locales                                             */\n env.1 = \"LC_ALL=En_US.IBM-1140\"\n /* env.1 = \"LC_ALL=Fr_FR.IBM-1147\" */ /* locale gives LANG=C        */\n /* env.1 = \"LANG=Fr_FR.IBM-1147\"    works as well                   */\n env.0 = 1\n\n /* Second parameter is standard input.                              */\n /* Third  parameter is standard output.                             */\n /* call bpxwunix cmd,'DD:IN','DD:OUT',stderr.,env.   works as well  */\n /* bpxwunix_rc = bpxwunix(cmd,'DD:IN','DD:OUT',stderr.,env.)        */\n cmd = 'cal  'mm'  'yyyy\n /* \"alloc fi(OUT) da(*) shr reuse\"                                  */\n /* bpxwunix_rc = bpxwunix(cmd,,'DD:OUT',stderr.,env.)               */\n bpxwunix_rc = bpxwunix(cmd,,out.,stderr.,env.)\n if bpxwunix_rc <> 0 then say \"bpxwunix_rc = \"bpxwunix_rc\n\n if stderr.0    <> 0 then say \"stderr.0    = \"stderr.0\n /* Display stderr. if non empty.                                    */\n if stderr.0 <> 0 then    /* z/OS Unix command failed                */\n    do i = 1 to stderr.0\n       say 'stderr.'i' ='stderr.i\n    end\n\n do j = 1 to out.0\n    say out.j            /* say for using outtrap                   */\n end\n return\n\n /*__________________________________________________________________*/\n\n miscellaneous: procedure\n say copies('_',76); say\n\n string1 = \"zsysid, zsysnode, zsysplex, zos390rl, zuser\"\n string2 = \"zdayofwk, zj4date, zdatestd, ztime\"\n address ispexec \"vget (\"string1\", \"string2\")\"\n say        \"On est le jour \"right(zj4date,3)\" de l'annee \"left(zj4date,4)\n say        \"date du jour        = \"zdatestd\n say        \"zuser               = \"zuser\n say        \"heure               = \"ztime\n say        \"zsysid              = \"zsysid\n say        \"zsysnode            = \"zsysnode\n say        \"zsysplex            = \"zsysplex\n say        \"zos390rl            = \"zos390rl\n say        zsysid zsysnode zsysplex zos390rl zuser,\n            zdayofwk zj4date zdatestd ztime\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTCMD": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\xec\\x00\\xec\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 236, "newlines": 236, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n trace o\n/* Get last command or previous commands.                    */\n\n/* Used as a called rexx:                                    */\n/* In calling program:                                       */\n/* cmd = lastcmd()  obtains last command.                    */\n/* cmd = lastcmd(1) obtains last command (same as previous)  */\n/* cmd = lastcmd(2) obtains second most recent command       */\n/* cmd = lastcmd(n) obtains the n-th command                 */\n/*               starting from the most recent command,      */\n/*               cycling thru the command stack as           */\n/*               Command ==> retrieve                        */\n\n/* On command line:                                          */\n/* Command ===> tso lastcmd     <-- last command             */\n/* Command ===> tso lastcmd 2   <-- next to last command     */\n/* or cycle to last command if command stack contains only   */\n/* one command.                                              */\n\n/* Example of use:                                           */\n/* When displaying a member list                             */\n/*           VIEW      BOZO.PDS                              */\n/*   Command ===> s * rexx01 AA BB                           */\n/*              Name     Prompt                              */\n/*   _________ MBR1                                          */\n/*   _________ MBR2                                          */\n/*   rexx01 executes on all members of the library.          */\n/*   When it executes MBR1, it receives as only parameter    */\n/*   'BOZO.PDS(MBR1)' and has no knowledge of AA BB.         */\n/*   The last command in the command stack is:               */\n/*   s * rexx01 AA BB                                        */\n/*   AA BB is obtained by rexx01 with subword(lastcmd(),4).  */\n/*   AA may possibly be an edit macro using parameter BB.    */\n\n/*   There exist a rexx called retp which simulates          */\n/*   Command ===> retp                                       */\n/*   and undocumented                                        */\n/*   address tso 'ispvcall status end'                       */\n/*   which writes the ISPF command stack in a dataset        */\n/*   allocated to ddname ispvcall                            */\n/*   (default userid.ISPVCALL.TRACE).                        */\n/*   cf. http://enterprisesystemsmedia.com ispvcall          */\n/*   A parameter QUIET as in ISPDPTRC and ISPFTTRC, would    */\n/*   be nice for ISPVCALL.                                   */\n\nparse arg n .\n\n/* ____ Argument validity check ____________________________ */\nif n = '' then n = 1             /* last command             */\nif datatype(n)  <> 'NUM' then do /* invalid argument         */\n   parse source . . source .\n   say source\": There must be no argument or\"\n   say \"      one numeric argument.\"\n   say source\": eg. cmd = lastcmd()  <-- most recent command\"\n   say source\": eg. cmd = lastcmd(2) <-- second most recent command\"\n   say source\": First argument provided was \"word(arg(1),1)\".\"\n   zispfrc = 16\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* invalid argument                                      */\n/* ____ End of argument validity check _____________________ */\n\n address ispexec; 'control errors return'; zerrmsg=''\n\n /* According to ISPF User's Guide:                                */\n /* \"To force a return to the top of the stack,                    */\n /* clear the command field and press Enter.\"                      */\n /*                                                                */\n /* We use a specialized panel to do it that we name 'xispcmde'.   */\n /* This panel is imbedded in the source between *PANEL            */\n /* and *ENDPANEL                                                  */\n /* zcmd field in panel is initialized to ''.                      */\n /* 'control nondispl enter' was tried unsuccesfully.              */\n\n    mypanel = 'xispcmde' /* panel between *PANEL and *ENDPANEL     */\n    call panel mypanel /* copy imbedded panel to temp lib, libdef  */\n    \"control display lock\"\n    \"display panel(\"mypanel\")\"\n /* Cycle thru command stack with 'retrieve'.                      */\n do i = 1 to n\n    stack = 'retrieve'\n    'display panel(ispcmde) command(stack)'\n        retrieve_command_rc = rc\n        call check_rc retrieve_command_rc,0,'retrieve command 'i\n end\n    res = zcmd /* last retrieved command                           */\n\n /* Return to the top of the stack.                                */\n    \"control display lock\"\n    \"display panel(\"mypanel\")\"\n    call panel         /* libdef, free                             */\n\n address /* from ispexec                                           */\n if sysvar('sysnest') = 'YES' then return res /* nested            */\n else do                               /*    not nested            */\n    select /* according to n                                       */\n      when n = 1 then say \"Last command: \"res\n      when n = 2 then say \"Second most recent command: \"res\n      otherwise do /* n-th command                                 */\n        say n\"th command starting from last command and cycling: \"\n        say res\n        end /* n-th command                                        */\n    end /* select according to n                                   */\n    zispfrc = 0\n    address ispexec 'vput zispfrc'\n    exit\n end                                   /*     not nested           */\n\n/* __ Panel to issue commands with zcmd initialized to '' _________*/\n/* delimited by *panel and *endpanel                               */\n/*                                                                 */\n/* It is placed in an unexecuted part of the rexx.                 */\n/*                                                                 */\n/* call panel 'xispcmde'                                           */\n/* will extract what is between *panel and *endpanel               */\n/* place it as a member named 'xispcmde' of a temporary library    */\n/* and libdef this library.                                        */\n\n*panel\n)attr format(mix)\n     _ type(input) caps(off) just(left)\n)body cmd(zcmd) asis\n     _zcmd\n\n\n+\n)init\n&zcmd = ''\n)reinit\n&zcmd = ''\n)proc\n)end\n*endpanel\n\n/*_________________________________________________________________*/\npanel: procedure expose set_panel\nparse arg panel\n\n if set_panel = 1 then signal unset_panel\n set_panel = 1    /* switch                                        */\n\n set_panel:\n address tso\n\n/* Extract imbedded panel into panel. stem _______________________ */\n panel.  = ''        /* initialize                                 */\n panel.0 = 0\n count= 0 /* panel stem index                                      */\n skip = 'yes'\n do i = 1 to sourceline()\n    line = sourceline(i)\n    select\n      when translate(left(line,6)) = '*PANEL'     then skip = 'no'\n      when translate(left(line,9)) = '*ENDPANEL'  then leave\n      when skip = 'no' then do\n        count = count + 1\n        panel.count = line\n        iterate\n      end /* when skip = 'no'                                      */\n      otherwise nop\n    end /* select                                                  */\n end /* do i = 1 to sourceline()                                   */\n panel.0 = count\n/* End of extract imbedded panel into panel. stem ________________ */\n\n/*________  Allocate temporary panel library ______________________*/\n   call bpxwdyn \"alloc rtddn(paneldd) rtdsn(panelds) new\",\n                \"dsntype(library,2) space(1,1) dir(1) tracks\",\n                \"recfm(f,b) lrecl(80)\"\n\n        if result <> 0 then do /* allocation failed                */\n           say\n           say \"Error in allocating panel library.\",\n               \"Bpxwdyn rc = \"result\n           if datatype s99msg.0 = 'NUM' then\n              if s99msg.0 > 0           then\n                 do k = 1 to s99msg.0\n                    say \"  \"s99msg.i\n                 end /* do k = 1 to s99msg.0                            */\n           call check_rc result,0,'bpxwdyn paneldd'\n        end /* if result <> 0                                           */\n/*________  End of allocate temporary panel library _______________*/\n\n/* Reallocate paneldd,                                             */\n/* will be used by execio (sequential) and libdef (partitioned)    */\n   \"alloc fi(paneldd) da('\"panelds\"(\"panel\")') shr reuse \"\n         realloc_paneldd_rc = rc\n         call check_rc realloc_paneldd_rc,0,'realloc paneldd'\n\n/* Copy panel into temporary library member                        */\n   address mvs \"execio * diskw paneldd (stem panel. fini\"\n         execio_rc = rc\n         call check_rc execio_rc,0,'execio'\n   address /* from tso                                             */\n\n/* Libdef temporary library                                        */\n   address ispexec; 'control errors return';zerrmsg=''\n     \"libdef ispplib library id(paneldd) stack\"\n         libdef_paneldd_rc = rc\n         call check_rc libdef_paneldd_rc,0,'libdef paneldd'\n   address /* from ispexec                                         */\n\n   return\n\n unset_panel:\n     set_panel = 0    /* switch                                    */\n     address ispexec \"libdef ispplib  \"\n         libdef_rc = rc\n         call check_rc libdef_rc,0,'libdef'\n     msg_prev = msg('off')\n       address tso   \"free file(paneldd)\"\n     msg_off  = msg(msg_prev)\n   return\n\n/*_ End of panel procedure ________________________________________*/\n check_rc:\n\n  /* call example:    call check_rc rc,0,'libdef isptlib'  */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return\n  /* ISPEXEC or ISREDIT error:                             */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  say 'rc = 'arg(1)\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg\n  zispfrc = 16\n  address ispexec 'vput zispfrc'\n  exit zispfrc\n /*________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LAZY": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\xe8\\x00\\xe8\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 232, "newlines": 232, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n/* Display in terminal codepage                             */\n/*  a string, given as a parameter, converted:              */\n/*  to IBM-1047 (Unix),                                     */\n/*  to IBM-1140 (US) if the terminal codepage is different, */\n/*  to IBM-1208 (UTF8).                                     */\n\n/* Default string contains pangram:                         */\n/* THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG              */\n\n/* Examples of use:                                         */\n/*  1) Command ===> tso lazy                                */\n/*     displays special characters and above pangram.       */\n/*                                                          */\n/*  2) Command ===> tso lazy Bonjour []{}1\u20ac                 */\n/*     displays a temporary file containing:                */\n/*     Command ===>                                         */\n/*     ****** ****************************                  */\n/*     000001 mine 1147 Bonjour []{}1\u20ac                      */\n/*            98984FFFF4C9999A949B55F94444                  */\n/*            49550114702651649005141F0000                  */\n/*     -----------------------------------                  */\n/*     000002 unix 1047 Bonjour \u00dd~\u00e9\u00e81                       */\n/*            A98A4FFFF4C9999A94ABCDF34444                  */\n/*            459701047026516490DD001F0000                  */\n/*     -----------------------------------                  */\n/*     000003 US   1140 Bonjour \u00ac|\u00e9\u00e81\u20ac                      */\n/*            EE444FFFF4C9999A94BBCDF94444                  */\n/*            420001140026516490AB001F0000                  */\n/*     -----------------------------------                  */\n/*     000004 utf8 1208 \u00e2?>\u00f9?\u00cd\u00ca $)\u00a3' Sb\u00d0                    */\n/*            AA8F4FFFF44666677255773E8A22                  */\n/*            43680120802FEAF520BDBD122C00                  */\n\ntrace o\nparse source var\nrexxname = word(var,3)\n\ncall if_an_edit_macro /* then set viewed file in hex        */\n\n/* rexx processing                                          */\nparse arg string\n\n/* for bpxwunix command codepage                            */\nlc_all = \"En_US.IBM-1140\"\n/* lc_all = \"Fr_FR.IBM-1147\"  lc_all = \"En_US.IBM-1140\"     */\n\ncall set_env /* z/OS Unix environment variables             */\n\n/* target ccsid's for iconv:                                */\nus     = '1140'\nunix   = '1047'\nutf8   = 'utf8'   /* '1208' same                            */\n\n/* ________________________________________________________ */\n/* File stdin contains code to convert                      */\n/*__________________________________________________________*/\n\nstdin_lrecl = 200\n\"alloc fi(stdin) reuse unit(vio) tracks sp(1) recfm(f)\",\n       \"lrecl(\"stdin_lrecl\")\"\nnewstack\n\nif string = '' then /* no parameter, we use default string  */\n   string = \"`~!@#$%^&*()-_=+[{]}\\|^;:'\" !! '\",<.>/?\u00a3\u20ac\u00a7\u00a8\u00b0\u00e9\u00e8\u00f9\u00b5',\n            'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',\n            'the quick brown fox jumps over the lazy dog'\n            /* This pangram is dated 1885                   */\nqueue left(string,stdin_lrecl)\n\naddress mvs \"execio \"queued()\" diskw stdin (fini\"\ndelstack\n\n/* ________________________________________________________ */\n/* Allocate stdout with DISP=MOD                            */\n/*__________________________________________________________*/\n\ncall allocate_stdout\n\n/* ________________________________________________________ */\n/* Convert                                                  */\n/*__________________________________________________________*/\n\n/* Obtain terminal codepage from ISPF variable ztermcp5.    */\naddress ispexec 'vget ztermcp5 shared'\n/* ztermcp5 has 5 digits.                                   */\n/* Suppress '0' at left but keep at least 3 digits. 037 is OK. */\nccsid = strip(substr(ztermcp5,1,2),'L','0')!!substr(ztermcp5,3)\n\ncmd = 'cat'                /* copy in terminal codepage     */\ncmd = cmd\" | sed 's/^/mine \"ccsid\" /' \"  /* prefix          */\ncall bpxwunix cmd,\"dd:stdin\",\"dd:stdout\",stderr.,env.\ncall print_stderr /* check for errors                       */\n\ncmd = 'iconv -f 'ccsid' -t 'unix   /* 1047    convert       */\ncmd = cmd\" | sed 's/^/unix 1047 /' \"  /* prefix             */\ncall bpxwunix cmd,\"dd:stdin\",\"dd:stdout\",stderr.,env.\ncall print_stderr\n\nif ccsid <> us then do\n   cmd = 'iconv -f 'ccsid' -t 'us  /* 1140  convert         */\n   cmd = cmd\" | sed 's/^/US   1140 /' \"  /* prefix          */\n   call bpxwunix cmd,\"dd:stdin\",\"dd:stdout\",stderr.,env.\n   call print_stderr\nend /* if ccsid <> us                                       */\n\ncmd = 'iconv -f 'ccsid' -t 'utf8   /* 1208  convert         */\ncmd = cmd\" | sed 's/^/utf8 1208 /' \"     /* prefix          */\ncall bpxwunix cmd,\"dd:stdin\",\"dd:stdout\",stderr.,env.\ncall print_stderr\n\n/* ________________________________________________________ */\n/* Visualize stdout and clean up                            */\n/*__________________________________________________________*/\n\ncall visualize_stdout_and_clean_up\n\nexit\n\n/*__________________________________________________________*/\n/*                                                          */\nset_env:\n\nenv.0 = 3\nenv.1 = \"PATH=.:/bin:usr/local/bin\"\nenv.2 = \"LC_ALL=\"lc_all     /* for command codepage              */\nenv.3 = \"_BPX_SHAREAS=MUST\" /* ddname friendly, e.g. cat DD:DD01 */\n                            /* cat \"dd:dd01(mbr)\"                */\n\nreturn\n/*__________________________________________________________*/\n\nallocate_stdout: procedure expose rexxname prefix stdin_lrecl dsnout\n/* Allocate stdout with DISP=MOD                            */\n\nran  = right(random(1,99999),5,'0')\ncall set_up_prefix /* create prefix for new file            */\ndsnout   = prefix\".\"rexxname\".R\"ran\nmsg_prev = msg('off')\nstdout_lrecl = stdin_lrecl * 4\n/* An UTF-8 character may have from 1 to 4 bytes.           */\n/* UTF-8 is an extension of ASCII.                          */\n\"alloc file(stdout) da('\"dsnout\"') mod catalog\",\n\"tracks space(5,5) reuse recfm(f b) blksize(0)\",\n\"lrecl(\"stdout_lrecl\")\"\nalloc_rc = rc\nif alloc_rc <> 0 then do\n   say rexxname \"could not allocate stdout.\"\n   say \"We exit with code 16.\"\n   say \"alloc rc = \"alloc_rc\n   zispfrc = 16\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\nmsg_off  = msg(msg_prev)\n\nreturn\n/* End of allocate_stdout                                   */\n\n/*__________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n/*__________________________________________________________*/\n/*                                                          */\nprint_stderr: procedure expose stderr.\n\nif datatype(stderr.0) = 'NUM' then do\n   if stderr.0 > 0 then do\n      say\n      do i = 1 to stderr.0\n         say 'stderr.'i' = 'stderr.i\n      end /* do i = 1 to stderr.0                           */\n   end /* if stderr.0 > 0                                   */\nend /* if datatype(stderr.0) = 'NUM                         */\n\nreturn\n/*__________________________________________________________*/\n/*                                                          */\n\nvisualize_stdout_and_clean_up:\n\n/* Visualize.                                               */\nzedsmsg = 'PF3 Return del this file'\nzedlmsg = 'PF3 will return and delete this file'\naddress ispexec\n  \"setmsg msg(isrz000)\"\n  \"view dataset('\"dsnout\"') macro(\"rexxname\")\"\n  /* \"view dataset('\"dsnout\"') macro(hex)\"    also Ok       */\n  /* Also Ok:\n  \"control nondispl enter\"\n  parm = \";hex;res\"\n  \"view dataset('\"dsnout\"') macro(nop) parm(parm)\"\n  */\naddress\n/* Same rexx used as an edit macro.                         */\n/* End of visualize.                                        */\n\n/* Clean up.                                                */\nmsg_prev = msg('off')\n   \"free fi(stdin, stdout)\"\n   \"del  '\"dsnout\"'\"\nmsg_off  = msg(msg_prev)     /* reset                       */\n/* End of clean up.                                         */\n\nreturn\n/*__________________________________________________________*/\n\nif_an_edit_macro:\n/* Set viewed file in hexadecimal                           */\n\naddress isredit\n\"macro\"\nisr_rc = rc\n/* \"macro (parm)\"                                           */\nif isr_rc = 0 then do /* edit macro                         */\n   'hex'\n   'res'\n   exit\nend /* isr_rc = 0                                           */\naddress\nreturn\n/*__________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMA": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00a\\x00a\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 97, "newlines": 97, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/* LMA Load Module Analyzer provided with Debug Tool */\n/* AMBLIST                                           */\n/*                                                          */\n\nsay \"                                     \"\nsay \"Example of use in ISPF 3.4:          \"\nsay \"LMA      XX.YYYY.USERID.LOAD         \"\nsay \"LMA      before dsname or member name\"\nsay \"                                     \"\n\ndtprfx=\"xxxx.dbg.eqaw\" /* First qualifiers for Debug Tool libraries */\ndsnprint_prefix = \"XX.YYYY\" /* please change dataset high level qualifiers */\n\nparse arg dsn .\ndsn = strip(dsn,,\"'\")                /* remove surrounding quotes */\nparse var dsn dsn '(' member ')' .   /* extract member if present */\n\n/* Build EQAIN control card                                 */\nif member = \"\" then 'alloc fi(eqain) dummy reuse'\n               else do /* member <> \"\" */\n                     \"newstack\"\n                      queue \"SELECT MEMBER=\"member\n     'alloc fi(eqain) unit(vio) tracks sp(1) recfm(f) lrecl(80) reuse'\n                     \"execio\" queued() \"diskw eqain (finis\"\n                     \"delstack\"\n                    end /* member <> \"\" */\n/*                                                          */\n/* Allocate EQAPRINT file                                   */\ntime_stamp = t!!time('s')\ndsnprint = dsnprint_prefix\".\"userid().\"LMA.\"time_stamp    /* SYSPRINT file */\n\"allocate fi(eqaprint) da('\"dsnprint\"')           reuse\",\n\"new catalog\",\n\"lrecl(121) recfm(f b a) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"LMA EQAPRINT allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n/*                                                          */\n\"alloc fi(eqasyspf) da('\"dtprfx\".seqatlib(eqalmpfx)') shr reuse\"\n\"alloc fi(eqapgmnm) da('\"dtprfx\".seqatlib(eqalmpgm)') shr reuse\"\n\"alloc fi(eqalib)   da('\"dsn\"')                       shr reuse\"\n\n\"call *(eqalma) \",\n\"'NATLANG=ENU,LISTLD,LEINFO,COMPOPTS,LOUD,SHOWLIB,DATEFMT=YYYYMMDD'\"\n\n/* Clean up                                                 */\n\"free fi(eqain eqaprint eqasyspf eqapgmnm eqalib)\"\n\n/* Allocate input library                                   */\n\"alloc fi(ddn) da('\"dsn\"') shr reuse\"\n/* End of allocating input library        */\n/*                                                          */\n/* Building SYSIN control card                              */\n\"newstack\"\nif member = \"\" then queue \" LISTIDR  OUTPUT=ALL,DDN=DDN\"\n               else do  /* member <> \"\" */\n                    queue \" LISTIDR  OUTPUT=ALL,DDN=DDN,MEMBER=\"member\n           /* queue \" LISTLOAD OUTPUT=XREF,DDN=DDN,MEMBER=\"member */\n                    end /* member <> \"\" */\n'alloc fi(sysin) unit(vio) tracks sp(1)   reuse'\n   \"execio\" queued() \"diskw sysin (finis\"\n\"delstack\"\n/*                                                          */\n/* Allocate SYSPRINT file                                   */\n\"allocate fi(SYSPRINT) da('\"dsnprint\"')           reuse\",\n\"mod catalog\"\nbrc = rc\nif brc > 0 then do\n   say \"AMBLIST SYSPRINT allocate gave code \"brc\n   exit(12)\nend /* if brc > 0 */\n/*                                                          */\n/* Execute AMBLIST                                          */\n'amblist'\nxrc = rc                /* save amblist return code */\nif xrc > 0 then do\n   say \"AMBLIST execution gave code \"xrc\n   exit(12)\nend /* if xrc > 0 */\n/*                                                          */\n/* Display SYSPRINT                                         */\n\"ispexec lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n\"ispexec view   dataid(\"dd1\")\"\n\n/* Clean up                                                 */\n\"free fi(sysprint ddn)\"\n\"ispexec lmfree dataid(\"dd1\")\"\nx = msg(\"off\")\naddress tso\n\"delete '\"dsnprint\"'\"\nx = msg(x)\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMCOPY": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xa1\\x00\\xa1\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 161, "newlines": 161, "modlines": 0, "user": "MLEWIN"}, "text": "//LMCOPY PROC I=, Input dataset, sequential or library\n//            O=, Output dataset, sequential or library\n//*  Set LMCOPY parameters:\n//            COPYPARM='FROMMEM(*) TRUNC'\n//*      LMCOPY parameters: FROMMEM(pattern) TOMEM(to-member-name)\n//*                         pattern example: %A*B*\n//*                         REPLACE PACK TRUNC ALIAS NOALIAS\n//*_________________________________________________________________\n//*\n//*      LMCOPY in batch (corresponds to ISPF 3.3)\n//*      Input and output files could have different RECFM and LRECL.\n//*\n//*      Example of use:\n//*      // SET I=dsn1\n//*      // SET O=dsn2\n//*      // EXEC LMCOPY,I=&I,O=&O\n//*_________________________________________________________________\n//*\n//*\n//   EXPORT SYMLIST=*\n//   SET QUOTE=''''\n//   SET COPYPARM=&QUOTE&COPYPARM&QUOTE To insert in //SYSTSIN\n//*\n//LMCOPY   EXEC PGM=IKJEFT1B,DYNAMNBR=50\n//ISPLOG   DD DSN=&&ISPLOG,UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//         LRECL=125,BLKSIZE=129,RECFM=VA\n//ISPPROF  DD DSN=&ISPPROF,DISP=NEW,UNIT=SYSDA,SPACE=(TRK,(15,15,5)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3120\n//ISPPLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//ISPTABL  DD DUMMY\n//ISPTLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//         DD DISP=SHR,DSN=ISP.SISPTENU\n//*\n//SYSTSIN  DD *,SYMBOLS=EXECSYS\nprofile noprefix\ncall *(iebgener)\nispstart cmd(%main +\n         &copyparm +\n            )  bdispmax(999999)\n//*\n//SYSTSPRT DD SYSOUT=*,OUTLIM=50000\n//*\n//SYSPRINT DD DUMMY SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//SYSUT2   DD DSN=&&TEMPPDS(MAIN),UNIT=VIO,SPACE=(TRK,(1,1,1))\n//SYSEXEC  DD DSN=&&TEMPPDS,VOL=REF=*.SYSUT2,DISP=(OLD,DELETE)\n//*\n//SYSUT1   DD DATA,DLM='><)))\u00b0>'\n /* rexx */\n\n /*___________________________________________________________________*/\n /*                                                                   */\n /* LMCOPY to a sequential dataset or a library                       */\n /* with possible different RECFM and LRECL                           */\n /* as ISPF 3.3.                                                      */\n /* IEBCOPY does not copy from FB to VB in z/OS 2.3.                  */\n /*___________________________________________________________________*/\n\n trace o\n parse arg copyparm             /* LMCOPY parameters                  */\n parse source . . rexxname .    /* rexxname in upper case             */\n\n address ispexec\n \"control errors return\"\n\n /* Copy library with LMCOPY.                                         */\n \"lminit dataid(dd1) ddname(i) enq(shr)\"\n        lminit_dd1_rc = rc\n        if lminit_dd1_rc > 0 then do\n           say 'Error at allocate ddname I.'\n           say 'lminit_dd1_rc = 'lminit_dd1_rc\n           zispfrc = 8\n           signal fin\n        end /* if lminit_dd1_rc > 0                                   */\n  \"lminit dataid(dd2) ddname(o) enq(shr)\"\n        lminit_dd2_rc = rc\n        if lminit_dd2_rc > 0 then do\n           say 'Error at allocate ddname O.'\n           say 'lminit_dd2_rc = 'lminit_dd2_rc\n           zispfrc = 8\n           signal lmfree2\n        end /* if lminit_dd2_rc > 0                                   */\n\n \"lmcopy fromid(\"dd1\") todataid(\"dd2\") \"copyparm\n /* Examples:\n \"lmcopy fromid(\"dd1\") todataid(\"dd2\") frommem(*) trunc\"\n \"lmcopy fromid(\"dd1\") todataid(\"dd2\")\",\n \"frommem(\"rexxname\")\" tomem(\"member_new\") replace\"\n */\n        lmcopy_rc = rc\n        if lmcopy_rc > 0 then do\n           say 'Copy error.'\n           say 'lmcopy_rc = 'lmcopy_rc\n           call say_lmcopy_error\n           zispfrc = lmcopy_rc\n           signal lmfree1\n        end /* if lmcopy_rc > 0                                       */\n\n lmfree1:\n \"lmfree dataid(\"dd1\")\"\n        lmfree_dd1_rc = rc\n        if lmfree_dd1_rc > 0 then do\n           zispfrc = 8\n           say 'lmfree_dd1_rc = 'lmfree_dd1_rc\n        end /* if lmfree_dd1_rc > 0                                   */\n lmfree2:\n \"lmfree dataid(\"dd2\")\"\n        lmfree_dd2_rc = rc\n        if lmfree_dd2_rc > 0 then do\n           zispfrc = 8\n           say 'lmfree_dd2_rc = 'lmfree_dd2_rc\n        end /* if lmfree_dd2_rc > 0                                   */\n\n fin:\n zispfrc = 0\n \"vput (zispfrc) shared\"\n exit zispfrc\n /*___________________________________________________________________*/\n say_lmcopy_error: procedure expose lmcopy_rc\n   select /* according to lmcopy return code                          */\n     when lmcopy_rc = 0 then return /* for completeness               */\n     when lmcopy_rc = 4 then do\n          say \"The 'from' data set is empty or\"\n          say \"no members matched the specified pattern\",\n              \"in the 'from' data set.\"\n     end /* when lmcopy_rc = 4                                        */\n     when lmcopy_rc = 8 then do\n          say \"The from-member-name was not found or\"\n          say \"the same name was specified for to-member-name and\",\n          say \"from-member-name.\"\n     end /* when lmcopy_rc = 8                                        */\n     when lmcopy_rc = 10 then do\n          say \"No data set is associated with the given data ID.\"\n     end /* when lmcopy_rc = 10                                       */\n     when lmcopy_rc = 12 then do\n          say \"One of these:\"\n          say \"A like-named member already exists in the 'to' data set\"\n          say \"  and the Replace option was not specified\"\n          say \"One or more members of the 'to' data set are 'in use',\"\n          say \"  either by you or by another user, and could not be copied\"\n          say \"Invalid data set organization\"\n          say \"Data set attribute invalid for copying or copying packed data\"\n          say \"Open error\"\n          say \"LOCK parameter is specified\"\n     end /* when lmcopy_rc = 12                                       */\n     when lmcopy_rc = 16 then do\n          say \"Truncation error.\"\n     end /* when lmcopy_rc = 16                                       */\n     when lmcopy_rc = 20 then do\n          say \"Severe error.\"\n     end /* when lmcopy_rc = 20                                       */\n     otherwise nop\n   end /* select according to lmcopy return code                      */\n   return\n /*___________________________________________________________________*/\n><)))\u00b0>\n//I        DD DISP=SHR,DSN=&I       Input  file\n//O        DD DISP=SHR,DSN=&O       Output file\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMMSTATS": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00;\\x00;\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 59, "newlines": 59, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n\n /* Command ===> cmde                                                 */\n /* ===> viewit lmmstats 'XX.YYYY.BOZO.CNTL(abcde)' created(66/12/01) */\n /* ===> viewit lmmstats 'XX.YYYY.BOZO.CNTL(abcde)' user(<BOZO>)      */\n\n parse arg dsn rest\n dsn0 = strip(dsn,,\"'\")               /* remove surrounding quotes    */\n parse var dsn0 dsn '(' member ')' .  /* extract member if present    */\n\n call update\n exit\n /*___________________________________________________________________*/\n\n update:\n\n /*  Update member statistics                                         */\n /*\n >>-ISPEXEC--LMMSTATS--DATAID(data-id)--MEMBER(member-name)------>\n    '-VERSION(version-number)-'      '-MODLEVEL(mod-level)-'\n    '-CREATED(create-date)-'         '-MODDATE(last-modified-date)-'\n    '-MODTIME(last-modified-time)-'  '-CURSIZE(current-size)-'\n    '-INITSIZE(initial-size)-'       '-MODRECS(records-modified)-'\n    '-USER(user-id)-'                '-DELETE-'\n    '-CREATED4(4-char-year-create-date)-'\n    '-MODDATE4(4-char-year-last-modified-date)-'\n    |       .-Off--.   |  '-NOLLA-'  |      .-NO--.   |\n    '-SCLM(-+-On---+-)-'             '-EXT(-+-YES-+-)-'\n               '-Asis-'\n    USER8(user-id)\n */\n\n address ispexec\n 'control errors return'\n \"lminit dataid(dd1) dataset('\"dsn\"') enq(shr)\"\n        lminit_rc = rc\n        if lminit_rc > 0 then do\n           say 'lminit_rc = 'lminit_rc\n           address\n           return\n        end /* if lminit_rc > 0                                       */\n\n \"lmmstats dataid(\"dd1\") member(\"member\") \"rest\n        lmmstats_rc = rc\n        if lmmstats_rc > 0 then do\n           say 'lmmstats_rc = 'lmmstats_rc\n           say 'zerrlm      = 'zerrlm\n        end /* if lmmstats_rc > 0                                     */\n\n \"lmfree dataid(\"dd1\")\"\n        lmfree_rc = rc\n        if lmfree_rc > 0 then\n           say 'lmfree_rc = 'lmfree_rc\n address\n\n return\n\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "L2": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x8d\\x00\\x8d\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 141, "newlines": 141, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\narg dsn maxgens .\ntrace o\n\n/* Individual convert a pds or a pdse to                    */\n/*  a pdse version 2 with the implied or specified          */\n/*  maxgens parameter.                                      */\n\nsay \"                           \"\nsay \"Example of use in ISPF 3.4:                            \"\nsay \"//L2     USER01.LOAD1      <-- Group convert           \"\nsay \"         USER01.LOAD2          to DSNTYPE(LIBRARY,2)   \"\nsay \"//       USER01.LOAD3          with default MAXGENS    \"\nsay \"         USER01.LOAD4                                  \"\nsay \"L2       USER01.LOAD5      <-- Default convert         \"\nsay \"         USER01.LOAD6                                  \"\nsay \"L2 / 0   USER01.LOAD7      <-- Convert with MAXGENS=0  \"\nsay \"L2 / 2   USER01.LOAD8      <-- Convert with MAXGENS=2  \"\nsay \"                           \"\n\n/* dsn of dataset to become library of type 2               */\n/* maxgens is the number of member generations              */\n/*         with the oldest deleted.                         */\n/*         If not specified, then system default            */\n/*         (parameter MAXGENS_LIMIT( ) in MACLIB(IGDSMSXX)).*/\n/* maxgens of 1 means member plus one generation            */\n\ndsn = strip(dsn,,\"'\")    /* remove surrounding quotes */\n\ntime_stamp = t!!time('s')\ndsnprint = userid().\"IEBCOPY.\"time_stamp   /* SYSPRINT file */\n\n\"allocate fi(SYSPRINT) da('\"dsnprint\"')           reuse\",\n\"new catalog\",\n\"lrecl(125) recfm(v b a) blksize(27875)\",\n\"space(1 1) tracks\"\n\nx = msg(\"off\")      /* quiet free           */\n\"free     fi(SYSUT1)   da('\"dsn\"')\"\ny = msg(x)          /* reset msg status     */\n\"allocate fi(SYSUT1)   da('\"dsn\"')    shr         reuse\"\n\nx = msg(\"off\")      /* quiet free and delete attempt */\n\"free     fi(SYSUT2)\"\n\"delete \"dsn\".L2\"   /* avoid duplicate      */\ny = msg(x)          /* reset msg status     */\n\nif maxgens = \"\" then do           /* max number of generation */\n\"allocate fi(SYSUT2)   da('\"dsn\".L2') new catalog reuse\",\n                    \"like('\"dsn\"')\",\n                    \"dsntype(library,2)\"\n                end /* maxgens not precised => system default */\n                else do       /* maxgens precised: 0, 1, 2 etc... */\n\"allocate fi(SYSUT2)   da('\"dsn\".L2') new catalog reuse\",\n                    \"like('\"dsn\"')\",\n                    \"dsntype(library,2) maxgens(\"maxgens\")\"\n                end /* maxgens precised: 0, 1, 2 etc... */\narc = rc\nif arc > 0 then do\n   say \"Allocate of new file gave code \"arc\n   say dsn\" unchanged\"\n   exit(12)\nend /* if arc > 0 */\n\nlib = \"sys1.linklib\"\n\"call '\"lib\"(iebcopy)' 'COPY' \"\nxrc = rc                /* save iebcopy return code */\n\n\"ispexec lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n\"ispexec view   dataid(\"dd1\")\"\n\nend:\n\"ispexec lmfree dataid(\"dd1\")\"\n\n/* if iebcopy ok delete old dsn                                      */\n/*               rename new dsn into old dsn                         */\n/*               delete dsnprint                                     */\nif xrc = 0 then do /* iebcopy ok */\n           x = msg(\"off\")      /* quiet alter               */\n           \"alter  '\"dsn\"' newname('\"dsn\".ANC')\"\n                 brc = rc\n           y = msg(x)          /* reset msg status          */\n                 if brc > 0 then do\n                    say \"IEBCOPY ok\"\n                    say \"Copy \"dsn\".L2 created\"\n                    say \"but \"dsn\" could not be renamed into \"dsn\".ANC\"\n                    say \"Code \"brc\" at rename time\"\n                    say dsn\" unchanged\"\n                    exit(10)\n                 end /* if brc > 0 */\n           x = msg(\"off\")      /* quiet alter               */\n           \"alter  '\"dsn\".L2' newname('\"dsn\"')\"\n                 crc = rc\n           y = msg(x)          /* reset msg status          */\n                 if crc > 0 then do\n                    say \"IEBCOPY ok\"\n                    say dsn\" was renamed into \"dsn\".ANC\"\n                    say \"but \"dsn\".L2 could not renamed into \"dsn\n                    say \"and gave code \"crc\n                    exit(10)\n                 end /* if crc > 0 */\n           say \"IEBCOPY return code = \"xrc\n           x = msg(\"off\")      /* quiet delete attempt      */\n           \"delete '\"dsn\".ANC' scratch purge\"\n                 drc = rc\n           y = msg(x)          /* reset msg status          */\n                 if drc > 0 then do\n                    say \"IEBCOPY ok but delete of \",\n                        \"old \"dsn\".ANC not done\"\n                    say \"code \"drc\" at delete time.\"\n                    say dsn\" changed and correct\"\n                    exit(4)\n                 end /* if drc > 0 */\n           say \"_______________________________________________\"\n           say \"                                               \"\n           say dsn\" changed to DSNTYPE=(LIBRARY,2)\"\n           if maxgens = \"\" then\n           say \" and default MAXGENS              \"\n                           else\n           say \" and MAXGENS=\"maxgens\n           say \"_______________________________________________\"\n\n           x = msg(\"off\")      /* quiet free and delete attempt      */\n           \"free fi(SYSUT1,SYSUT2)\"\n           /*  Attempt to delete IEBCOPY SYSPRINT:                   */\n           \"delete '\"dsnprint\"' scratch purge\"\n           y = msg(x)          /* reset msg status                   */\n           exit(0)\nend /* if xrc = 0  iebcopy ok */\n\nelse do          /* xrc <> 0 iebcopy ko */\n/* if iebcopy ko keep old dsn not modified                           */\n/*               keep new L2 file                                    */\n/*               keep dsnprint                                       */\n           say \"IEBCOPY return code = \"xrc\n           say dsn\" not modified\"\n           say \"New file \"dsn\".L2 kept\"\n           say \"IEBCOPY SYSPRINT kept\"\n           exit(12)         /* xrc <> 0 iebcopy ko */\nend /* if xrc <> 0  iebcopy ko */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAC": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x88\\x00\\x88\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 136, "newlines": 136, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n parse source . . rexxname .    /* rexxname in upper case                  */\n /*                                                                        */\n /*  Rexx to invoke macro given as a parameter.                            */\n /*                                                                        */\n /* It uses three other rexx: viewit, forallm and macedit.                 */\n /*  In the invoked macro, kindly replace 'say' by 'queue'                 */\n /*  as the content of the queue is 'pulled' then 'said' by MACEDIT        */\n /*  to fit in the context in which MACEDIT is called.                     */\n /*                                                                        */\n /*  Example of use: (ISPF 3.4, on same line as dsname)                    */\n /*   DSLIST - Data Sets Matching XX.YYYY.USER01                           */\n /*   Command ===>                                                         */\n /*   mac mac01 XX.YYYY.USER01.CNTL                                        */\n /*   mac mac01 /        <-- Execute macro mac01 on all members            */\n /*   mac mac01 /(*COMP*)                                                  */\n /*   mac mac01 /(COMPCOB)                                                 */\n\n if sysvar(sysispf) <> 'ACTIVE' then do\n   say rexxname 'must be invoked from ISPF, terminating!'\n   exit 12\n end\n argu = arg(1)      /* argu can be modified                                */\n w = words(argu)    /* number of words at right of MACEDIT                 */\n\n if w <> 2 then do /* Not two words at right of MAC                        */\n    say rexxname arg(1)\n    say 'There must be two parameters at right of 'rexxname'.'\n    say 'The first one must be the macro to execute.'\n    say 'The last one must be a library with possibly parents such as:'\n    say \"        'XX.YYYY.USER01.LIB'\"\n    say '         XX.YYYY.USER01.LIB'\n    say '         XX.YYYY.USER01.LIB(*)'\n    say '         XX.YYYY.USER01.LIB(*AB*)'\n    say '         XX.YYYY.USER01.LIB(*AB%)'\n    zispfrc = 12\n    signal fin\n end /* if w <> 2   Not two words at right of MAC                          */\n\n mac   = word(argu,1)         /* first                                     */\n dsn   = word(argu,w)         /* last                                      */\n\n upper dsn\n dsn = strip(dsn,,\"'\")                     /* remove quotes if any         */\n dsnx = translate(dsn,'  ','()')           /* replace parent by blank      */\n dsn0 = word(dsnx,1)\n call check_dsn   dsn0\n call check_dsorg dsn0\n\n /* member name must be a pattern to use rexx forallm                      */\n specific_member = \"no\"\n select\n   when words(dsnx) = 1 then dsn = dsn'(*)'   /* add (*) to dsname         */\n   when words(dsnx) = 2 then do               /* member was specified      */\n        member = word(dsnx,2)\n        if pos('%',member) = 0 & pos('*',member) = 0 then do\n           specific_member = \"yes\"\n           call check_dsn     dsn\n        end /* if pos('%',member) = 0 & pos('*',member) = 0                */\n\n   end /* when words(dsnx) = 2                                             */\n   otherwise\n end /* select                                                             */\n\n address ispexec\n \"control errors return\"\n\n do queued(); pull ; end     /* Exhaust queue preventively.                */\n\n if specific_member = \"no\" then\n       call viewit \"forallm macedit \"mac\" \"dsn\n else do /* specific_member = \"yes\"                                        */\n       say \"dsn = \"dsn\n       say \"mac = \"mac\n       \"edit dataset('\"dsn\"') macro(\"mac\")\"\n end /*     specific_member = \"yes\"                                        */\n\n /* Say what has been queued by invoked macro and exhaust queue.           */\n do queued(); pull line; say line; end\n\n zispfrc = 0\n\n say\n /*________________________________________________________________________*/\n /*                                                                        */\n fin:\n   /*\n   if zispfrc > 0 then do\n      say 'return code = 'zispfrc\n      say\n   end /* if zispfrc > 0                                                   */\n   */\n   address ispexec \"vput zispfrc\"\n   exit zispfrc\n /*                                                                        */\n /*________________________________________________________________________*/\n check_dsn: procedure expose mac rexxname\n  parse arg dsn  /* dsn without quotes                                     */\n  msgs = msg(\"off\")\n     libelle = sysdsn(\"'\"dsn\"'\")\n  msgs = msg(msgs)\n  if libelle <> 'OK' then do\n     say 'mac   = 'mac\n     say 'dsn   = 'dsn' 'libelle\n     say rexxname' ends with rc = 16.'\n     zispfrc = 16\n     signal fin\n  end /* if sysdsn(\"'\"dsn\"'\") <> 'OK'                                      */\n  return\n\n /*________________________________________________________________________*/\n check_dsorg: procedure expose rexxname\n  parse arg dsn  /* dsn without quotes                                     */\n  rc = listdsi(\"'\"dsn\"'\")\n  xrc = rc\n  if xrc <> 0 then do\n     say\n     say   \"Listdsi on dsn \"dsn\" failed\",\n           \"with RC = \"xrc\" and reason = \"sysreason\n     queue \"Dsn \"dsn\" was not processed.\"\n     say rexxname' ends with rc = 16.'\n     zispfrc = 16\n     signal fin\n  end /* if xrc <> 0 Listdsi failed                                        */\n  dsorg = left(sysdsorg,2) /* remove unmovable if present                  */\n  /* End of obtain dataset organization dsorg 'PS' 'PO'.                   */\n  if dsorg <> 'PO' then do\n     say\n     say   dsn\" is not a library.\"\n     say   \"Dsn \"dsn\" was not processed.\"\n     say rexxname' ends with rc = 16.'\n     zispfrc = 16\n     signal fin\n  end /* if dsorg <> 'PO'                                                  */\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACEDIT": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00r\\x00r\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 114, "newlines": 114, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n parse source . . rexxname .    /* rexxname in upper case                  */\n /*                                                                        */\n /*  Rexx to invoke macro given as a parameter.                            */\n /*                                                                        */\n /*  In the invoked macro, kindly replace 'say' by 'queue'                 */\n /*  as the content of the queue is 'pulled' then 'said' by MACEDIT        */\n /*  to fit in the context in which MACEDIT is called.                     */\n /*                                                                        */\n /*  Example of use:                                                       */\n /*  Command ===> cmde                                                     */\n /*  viewit forallm macedit mac01 parm1 parm2 USER01.TEST(*)               */\n /*  Explanation:                                                          */\n /*  For all members (forallm) of USER01.TEST, we call rexx MACEDIT        */\n /*  which invoke macro mac01 with one parm made of 'parm1 parm2'.         */\n /*  Viewit will gather all 'say' in a file to be viewed.                  */\n\n if sysvar(sysispf) <> 'ACTIVE' then do\n   say rexxname 'must be invoked from ISPF, terminating!'\n   exit 12\n end\n\n /* Obtain command to execute (dsname(member) at end)                      */\n /* say 'arg(1)  = 'arg(1)                                                 */\n argu = arg(1)      /* argu can be modified                                */\n w = words(argu)    /* number of words at right of MACEDIT                 */\n\n select /* according to w                                                  */\n\n   when w < 2 then do /* less than two words at right of MACEDIT           */\n      say 'There must be at least two parameters at right of 'rexxname'.'\n      say 'The first one must be the macro to execute.'\n      say 'The last one must be a library with possibly parents such as:'\n      say \"        'XX.YYYY.USER01.LIB'\"\n      say '         XX.YYYY.USER01.LIB'\n      say '         XX.YYYY.USER01.LIB(*)'\n      say '         XX.YYYY.USER01.LIB(*AB*)'\n      say '         XX.YYYY.USER01.LIB(*AB%)'\n      say 'Intermediate parameters make the parameter to the macro.'\n      zispfrc = 12\n      signal fin\n   end /* when w < 2 less than two words at right of MACEDIT               */\n\n   when w > 1 then do /* two or more words at right of MACEDIT             */\n      mac   = word(argu,1)         /* first                                */\n      dsn   = word(argu,w)         /* last                                 */\n      parm0 = subword(argu,2,w-2)  /* rest, empty if w = 2                 */\n   end /* when w > 1 two or more words at right of MACEDIT                 */\n\n   otherwise\n end /* select according to w, number of words at right of MACEDIT         */\n\n upper dsn\n dsn = strip(dsn,,\"'\")                     /* remove quotes if any         */\n\n /* Check dsn                                                              */\n msgs = msg(\"off\")\n    libelle = sysdsn(\"'\"dsn\"'\")\n msgs = msg(msgs)\n if libelle <> 'OK' then do\n    say 'mac   = 'mac\n    say 'parm0 = 'parm0\n    say 'dsn   = 'dsn' 'libelle\n    say rexxname' ends with rc = 12.'\n    zispfrc = 12\n    signal fin\n end /* if sysdsn(\"'\"dsn\"'\") <> 'OK'                                       */\n\n address ispexec\n \"control errors return\"\n\n do queued(); pull ; end     /* Exhaust queue preventively.                */\n\n \"edit dataset('\"dsn\"') macro(\"mac\") parm(parm0)\"\n /* Invoked macro may see parm0 as several parameters.                     */\n /*\n xrc = rc\n say 'edit rc = 'xrc\n */\n /* No single quote around parm0 which may contain blanks and              */\n /* lower case characters. Max length of parm0 is 200.                     */\n /* The invoked macro may contain:                                         */\n /* 'isredit macro (parm1,parm2)'                                          */\n /*          where parm1 = word(parm0,1) and parm2 = word(parm0,2)         */\n\n /* Say what has been queued by invoked macro and exhaust queue.           */\n do queued(); pull line; say line; end\n\n /*\n say \"arg(1) = \"arg(1)\n address ispexec 'vget zdllcmd shared'\n say 'zdllcmd = 'zdllcmd\n /* this works:                                                            */\n call viewit \"forallm macedit mac01 parm1 parm2 USER01.TEST(*)\"\n exit\n */\n\n zispfrc = 0\n\n say\n /*________________________________________________________________________*/\n /*                                                                        */\n fin:\n   /*\n   if zispfrc > 0 then do\n      say 'return code = 'zispfrc\n      say\n   end /* if zispfrc > 0                                                   */\n   */\n   address ispexec \"vput zispfrc\"\n   exit zispfrc\n /*                                                                        */\n /*________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAC01": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00.\\x00.\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 46, "newlines": 46, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx                                                             */\ntrace r\n/* Allocate stdenv in a macro edit with regex.                      */\n\"isredit macro\"\n/* address ispexec                                                  */\n/* \"vget (zdldsn) shared\"                                           */\n/*  say \" dsn    = \"zdldsn                                          */\n\naddress isredit\n'(dsn)  = dataset'\n'(memb) = member'\nsay \" dsn    = \"dsn\nsay \" memb   = \"memb\naddress\n\n/*__________________________________________________________________*/\n/* Allocate stdenv dataset.                                         */\naddress tso\n\"allocate fi(stdenv) reuse unit(vio)\",\n\"lrecl(80) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"STDENV allocate gave code \"arc\n   exit(12)\nend /* if arc > 0                                                   */\n\nqueue 'LANG=En_US.IBM-1140'\n/* queue 'LANG=Fr_FR.IBM-1147'                                      */\n\"execio \"queued()\" diskw stdenv (finis\"\nsay \"rc = \"rc\naddress /* resume previous environment                              */\n\n/*__________________________________________________________________*/\naddress isredit\n\"isredit find r'/[0-9]{8}/' first\" /* exactly 8 digits between /    */\n\n/*__________________________________________________________________*/\naddress tso\n'free fi(stdenv)'\nexit\n/* instructions below OK:                                           */\n\"isredit find r'/[0-9]{8}/' first\" /* exactly 8 digits between /    */\n\"isredit find first r'/.{8}/'  \" /*  8 chars between slashes        */\n\"isredit find r'\\/.*\\/' first\" /* 2 slashes and any char in between */\n\"isredit find r'/.*/' first\"  /*zero or more char between slashes   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAN": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x96\\x00\\x96\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 150, "newlines": 150, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n/* Execute man Unix command in MVS or z/OS Unix.               */\n/* man ouput is translated to terminal codepage if obtained    */\n/* (or to a rexx default codepage if the terminal codepage     */\n/* is not obtained)                                            */\n/* then it is displayed with ISPF VIEW.                        */\n\n/* If the terminal code page is not obtained, we use:          */\nccsid_default = '01140' /* '01140' English US with Euro sign   */\n                        /* '01147' French     with Euro sign   */\n\n/* rexx is placed in a MVS library concatenated to SYSPROC     */\n/* or SYSEXEC                                                  */\n\n/* Examples:                                                   */\n/*  Command ===> tso man grep                                  */\n\n/*  Command ===> cmde          (to preserve lower case)        */\n/*  Enter TSO commands below:                                  */\n/*  ===> man -k compare                                        */\n\n/* In z/OS Unix,                                               */\n/*                                                             */\n/*  Command ===> tso omvs                                      */\n/*  $ tso man ls                                               */\n/*        versus                                               */\n/*  $ man ls                                                   */\n/*  $ exit                                                     */\n\n/* Alternative:                                                */\n/*  Command ===> epdf /        then                            */\n/*  Command ===> tso man grep  instead of man grep             */\n/*_____________________________________________________________*/\n\ntrace o\nparse source var\nrexxname = word(var,3)\n\nccsid = get_terminal_codepage() /* from ISPF variable ztermcp5 */\n/* terminal codepage not obtained if the rexx is called from OMVS */\nif ccsid = 'ZTERMCP5' then ccsid = ccsid_default\n\n/*_____________________________________________________________*/\n/* Build man z/OS Unix command in IBM-1047 codepage (default). */\nparse arg rest\n/* rest is what is at right of man.                            */\nrest = strip(rest)\npipe  = '4F'x    /* pipe symbol (vertical bar) in IBM-1047     */\n\n/* cmd = 'MANPATH=/usr/man/%L man' rest <-- result in IBM-1047 */\ncmd = 'man -M /usr/man/%L 'rest pipe 'iconv -f 1047 -t 'ccsid\n\n/*_____________________________________________________________*/\n/* Allocate STDOUT dsnprint dataset.                           */\ncall set_up_prefix /* create prefix for new file               */\ntime_stamp = t!!time('s')\ndsnprint = prefix\".\"rexxname\".\"time_stamp\n\"allocate fi(stdout) da('\"dsnprint\"') reuse\",\n\"new catalog\",\n\"lrecl(132) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"STDOUT DSNPRINT allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*_____________________________________________________________*/\n/* Initialize stem stderr.                                     */\ndrop stderr.\nstderr.0 = 0\n\n/*_____________________________________________________________*/\n/* Initialize env. environment variables stem.                 */\ndrop env.\n\n/* bpxwunix command in French:                                 */\n/* env.1 = \"LC_ALL=Fr_FR.IBM-1147\"; env.0 = 1                  */\n/* bpxwunix command in English US:                             */\n/* env.1 = \"LC_ALL=En_US.IBM-1140\"; env.0 = 1                  */\n\n/* bpxwunix command is in IBM-1047 (z/OS Unix and C) default:  */\nenv.0 = 0\n\n/*_____________________________________________________________*/\n/* Execute Unix command                                        */\ncall bpxwunix cmd,,'DD:STDOUT',stderr.,env.\n\nif stderr.0 <> 0 then /* z/OS Unix command failed              */\n   do i = 1 to stderr.0\n      say 'stderr.'i' ='stderr.i\n   end                /* z/OS Unix command failed              */\nelse do               /* z/OS Unix command succeeded           */\n\n   /* Display DSNPRINT                                         */\n    address ispexec\n      \"control errors return\"\n      \"control display line start(0)\" /* if rexx called under OMVS */\n      \"view   dataset('\"dsnprint\"')\"\n      view_rc = rc\n    address\n\n    if view_rc > 0 then do\n       say \"view for dataset \"dsnprint\" gave code \"view_rc\n       \"free fi(stdin)\"\n       exit(16)\n    end /* if view_rc > 0                                      */\n\nend                   /* z/OS Unix command succeeded           */\n\n/*_____________________________________________________________*/\n\n/* Clean up                                                    */\n\"free fi(stdout)\"\nmsgs = msg(\"off\")\naddress tso\n  \"delete '\"dsnprint\"'\"\nmsgs = msg(msgs)\nexit\n\n/*___________________________________________________________________*/\nset_up_prefix:\n\n/* Set up new output file prefix.                                    */\nprefix = sysvar('syspref')              /* tso profile prefix        */\nuid    = sysvar('sysuid')               /* tso userid                */\nif prefix = '' then prefix = uid        /* use uid if null prefix    */\nif prefix <> '' & prefix <> uid then    /* different prefix than uid */\n   prefix = prefix'.'uid                /* use prefix.uid            */\n\nreturn\n/*___________________________________________________________________*/\nget_terminal_codepage:\n\n/* example of call: ccsid = get_terminal_codepage()                  */\n/* e.g. ccsid = '001140' English US                                  */\n/*      ccsid = '001147' French                                      */\n\n/* ccsid with 5 digits may be used with iconv -f or -t               */\n/* ccsid with 5 digits is required if using                          */\n/* address ispexec                                                   */\n/*   \"trans fromccsid(...) toccsid(...) fromvar(...) tovar(...)\"     */\n\naddress ispexec\n  \"control errors return\"\n  \"vget ztermcp5 shared\"\naddress\n\nreturn(ztermcp5)\n/*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "O": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x03\\x00\\x03\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 3, "newlines": 3, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\"ex 'xx.yyyy.\"userid()\".cntl'\"   /* execute tempname member */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OD": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x9f\\x00\\x9f\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 159, "newlines": 159, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n/* Execute od (octal dump) Unix command.                      */\n/* If no option provided, the rexx generates option           */\n/* for an hexadecimal dump (BSD option -Xhc).                 */\n\n/* rexx is in SYSEXEC or SYSPROC concatenation,               */\n/* not in OMVS PATH.                                          */\n\n/* rexx can be called from either MVS or OMVS.                */\n\ntrace o\nlang = \"En_US.IBM-1140\"      /* \"Fr_FR.IBM-1147\"              */\n\n/* Examples:                                                  */\n/* Calling from MVS:                                          */\n/*          VIEW      BOZO.LOAD                               */\n/*  Command ===>                                              */\n/*             Name     Prompt                                */\n/*  od_______ MEMBER01        <-- hex dump                    */\n\n/*  ISPF 3.4                                                  */\n/*           Data Sets Matching BOZO                          */\n/*  Command ===>                                              */\n/*                                                            */\n/*  Command - Enter \"/\" to select action                      */\n/*  ----------------------------------------------            */\n/*  od______ BOZO.SEQ01       <-- hex dump                    */\n\n/*  Command ===> tso od 'BOZO.LOAD(MEMBER1)'                  */\n/*  Command ===> cmde         <-- to preserve lower case      */\n/*  Enter TSO commands below:                                 */\n/*  ===> od 'BOZO.LOAD(MEMBER2)' -hc                          */\n/*  ===> od /u/bozo/test.txt  <-- full path needed            */\n\n/* Calling from OMVS:                                         */\n/*  Command ===> tso omvs                                     */\n/*  $ tso od /u/bozo/test.txt                                 */\n/*  $ tso od BOZO.SEQ01                                       */\n/*  $ exit                 (from OMVS)                        */\n/* End of examples.                                           */\n\n/*____________________________________________________________*/\n/* Build od z/OS Unix command.                                */\n\nparse arg dsn rest\n\nrest = strip(rest)\nrest0 = rest /* initial value after strip                     */\nif rest = '' then rest = '-Xhc' /* hexadecimal dump           */\n                     /*  '-A x -t x1z -v'    in bash          */\n\ncmd = 'od' rest /* Unix command                               */\nif rest0 <> '' then do /* od options were specified           */\n   say 'Generated z/OS Unix od command for bpxwunix:'\n   say cmd\nend /* if rest0 <> ''                                         */\n\n/*____________________________________________________________*/\n/* Allocate STDIN.                                            */\ndsn = strip(dsn,,\"'\") /* remove quotes if any                 */\nparse var dsn dsn0 '(' member ')' .\nmsgs = msg(\"off\") /* HFS file will give messages              */\n   \"alloc fi(stdin) da('\"dsn\"') shr reu\"\nmsgs = msg(msgs)\narc = rc\nif arc > 0 then do  /* dsn is a full path                     */\n   \"alloc fi(stdin) path('\"dsn\"') pathopts(ordonly) reu\"\n   brc = rc\n   if brc > 0 then do\n      say \"STDIN allocate gave codes \"arc\" (MVS),\",\n                                      brc\" (HFS or zFS)\"\n      exit(12)\n   end /* if brc > 0 */\nend /* if arc > 0 */\n\n/*____________________________________________________________*/\n/* Allocate STDOUT dsnprint dataset.                          */\ncall set_up_prefix /* create prefix for new file              */\ntime_stamp = t!!time('s')\nparse source . . rexxname .\ndsnprint = prefix\".\"rexxname\".\"time_stamp\n\"allocate fi(stdout) da('\"dsnprint\"') reuse\",\n\"new catalog\",\n\"lrecl(160) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"STDOUT DSNPRINT allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*____________________________________________________________*/\n/* Initialize stem stderr.                                    */\ndrop stderr.\nstderr.0 = 0\n\n/*____________________________________________________________*/\n/* Set up env. environment variables stem.                    */\ndrop env.\nenv.1 = \"LANG=\"lang\nenv.0 = 1\n\n/*____________________________________________________________*/\n/* Execute Unix od command.                                   */\n\nbpxwunix_rc = bpxwunix(cmd,'DD:STDIN','DD:STDOUT',stderr.,env.)\n/*____________________________________________________________*/\n/* Display result.                                            */\n\nif bpxwunix_rc = 0 then do\n\n  /* Display DSNPRINT                                         */\n  address ispexec\n    \"control errors return\"\n    \"control display line start(0)\" /* if rexx called under OMVS      */\n    \"view   dataset('\"dsnprint\"')\"  /* dataid not provided under OMVS */\n    view_rc = rc\n\n    if view_rc > 0 then do\n       say \"view for dataset \"dsnprint\" gave code \"view_rc\n       call clean_up_and_exit view_rc\n    end /* if view > 0                                        */\n\n  address\nend /* if bpxwunix_rc = 0                                     */\n\nelse do /* bpxwunix_rc <> 0                                   */\n   if stderr.0 <> 0 then\n      do i = 1 to stderr.0\n         say 'stderr.'i' ='stderr.i\n      end\n   say 'bpxwunix_rc = 'bpxwunix_rc\n   call clean_up_and_exit bpxwunix_rc\nend /* bpxwunix_rc <> 0                                       */\ncall clean_up_and_exit 0 /* normal exit                       */\n\n/*____________________________________________________________*/\nclean_up_and_exit:\n\nparse arg exit_code\naddress tso\n\"free fi(stdin,stdout)\"\nmsgs = msg(\"off\")\n   \"delete '\"dsnprint\"'\"\nmsgs = msg(msgs)\nexit exit_code\n\n/*___________________________________________________________________*/\nset_up_prefix:\n\n/* Set up new output file prefix.                                    */\nprefix = sysvar('syspref')              /* tso profile prefix        */\nuid    = sysvar('sysuid')               /* tso userid                */\nif prefix = '' then prefix = uid        /* use uid if null prefix    */\nif prefix <> '' & prefix <> uid then    /* different prefix than uid */\n   prefix = prefix'.'uid                /* use prefix.uid            */\n\nreturn\n/*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARMLIB": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x08\\x00\\x08\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 8, "newlines": 8, "modlines": 0, "user": "MLEWIN"}, "text": "alloc shr reuse fi(SPARMLIB) da(              +\n'SYS1.PARMLIB.ABC'                            +\n'SYS1.PARMLIB.DEF'                            +\n'SYS1.PARMLIB'                                +\n)\nWRITE Exemples de commandes:\nWRITE Command ===> M ABCDEF     M ABC*    DUP    HELP\nisrddn only SPARMLIB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RELINK": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xfc\\x00\\xfc\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 252, "newlines": 252, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n\n/*____________________________________________________________________________*/\n/*                                                                            */\n/* Help starts                                                                */\n/* Relinkedit/rebind a load module/program object.                            */\n/*                                                                            */\n/* Syntax: Command ===> tso relink dsn(member) parameter(s)                   */\n/*                                                                            */\n/* If zero parameter follows dsn(member) then show help                       */\n/*    and relink JCL with control statements examples to edit                 */\n/*    in a file.                                                              */\n/* If one parameter only follows dsn(member) then use binder statement        */\n/*    SETOPT PARM(parameter)                                                  */\n/*    and call binder                                                         */\n/*    (in case parm is an 8 characters hex string,                            */\n/*     prefix hex string by 'SSI=')                                           */\n/* else use parameters as a full binder statement                             */\n/*    and call binder.                                                        */\n/*                                                                            */\n/* relink   parameter(s) may be obtained from prompt field                    */\n/*          if at most eight characters long.                                 */\n/*                                                                            */\n/* Example 1:                                                                 */\n/*  Command ===> tso relink                                                   */\n/*  generates help and JCL file to edit.                                      */\n/*                                                                            */\n/* Example 2:                                                                 */\n/* XXXX    VIEW      BOZO.LOAD                                                */\n/*  Command ===>                                                  Scroll ===> */\n/*            Name     Prompt        Size       TTR      AC    AM  RM         */\n/*  relink   COBOL01                 00001398   000015   01    31  ANY        */\n/*  generates help and JCL file to edit. dsn and member indicated.            */\n/*                                                                            */\n/* Example 3:                                                                 */\n/*  Command ===> tso relink 'BOZO.LOAD(COBOL01)' SSI=AA190206,REUS=RENT,AC=1  */\n/*  will use binder statement        SETOPT PARM(SSI=AA190206,REUS=RENT,AC=1) */\n/*  and call binder.                                                          */\n/*                                                                            */\n/* Example 4:                                                                 */\n/*  Command ===> cmde                                                         */\n/*  Enter TSO commands below:                                                 */\n/*  ===> relink 'BOZO.LOAD(COBOL01)' INCLUDE SYSLIB(SUB01)                    */\n/*  will use binder statement        INCLUDE SYSLIB(SUB01)                    */\n/*  and call binder.                                                          */\n/*  dsn is allocated to SYSLIB.                                               */\n/*                                                                            */\n/* Example 5:                                                                 */\n/* XXXX    VIEW      BOZO.LOAD                                                */\n/*  Command ===>                                                  Scroll ===> */\n/*            Name     Prompt        Size       TTR      AC    AM  RM         */\n/*  relink   COBOL01  RMODE=24       00001398   000015   01    31  ANY        */\n/*                                                                            */\n/* Result:                                                                    */\n/* XXXX    VIEW      BOZO.LOAD                                                */\n/*  Command ===>                                                  Scroll ===> */\n/*            Name     Prompt        Size       TTR      AC    AM  RM         */\n/*  ________ COBOL01                 00001398   000015   01    31  24         */\n/*____________________________________________________________________________*/\n/* Help ends                                                                  */\n/*                                                                            */\n\n/*__________________________________________________________*/\n/* Get parameters                                           */\n\nparse arg dsn0 parm\n\ndsn = strip(dsn0,,\"'\") /* remove quotes if any              */\nparse var dsn dsn '(' member ')'\nif member = '' then do\n   say ' Load module/program object missing.'\n   say \" Kindly press enter.\"\n   call show_help\n   exit\nend /* if member = ''                                       */\n\nif parm = '' then do\n   say \" No Parameter(s) were present with \"dsn0\".\"\n   say \" Kindly press enter.\"\n   call show_help\n   exit\nend /* if parm = ''                                         */\n\n/*__________________________________________________________*/\n/* Allocate SYSLIB      <-- input                           */\n\"alloc fi(syslib) da('\"dsn\"') shr reu\"\n   alloc_syslib_rc = rc\n   call check_rc alloc_syslib_rc,0,'alloc fi(syslib)'\n\n/* Allocate SYSLMOD     <-- output                          */\n\"alloc fi(syslmod) da('\"dsn\"') shr reu\"\n   alloc_syslmod_rc = rc\n   call check_rc alloc_syslmod_rc,0,'alloc fi(syslmod)'\n\n/* Allocate SYSPRINT                                        */\n\"alloc fi(sysprint) dummy reu\" /* da(*) instead of dummy    */\n   alloc_sysprint_rc = rc\n   call check_rc alloc_sysprint_rc,0,'alloc fi(sysprint)'\n\n/* Allocate SYSUT1                                          */\n\"alloc fi(sysut1) unit(vio) cyl space(2 2) reu\"\n   alloc_sysut1_rc = rc\n   call check_rc alloc_sysut1_rc,0,'alloc fi(sysut1)'\n\n/*__________________________________________________________*/\n/* Allocate SYSLIN control cards dataset.                   */\n\"allocate fi(syslin) unit(vio) reu\",\n\"lrecl(80) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\n   alloc_syslin_rc = rc\n   call check_rc alloc_syslin_rc,0,'alloc fi(syslin)'\n\n/*__________________________________________________________*/\n/* Set IEWL SYSLIN control cards.                           */\nnewstack\nqueue ' INCLUDE  -ATTR,-ALIASES,SYSLIB('member')'\n/* -ATTR:   The attributes which are copied are:                    */\n/*          AC, AMODE, DC, OL, REUS, RMODE, SSI, TEST, entry point, */\n/*          DYNAM and MIGRATABLE.                                   */\n/*                                                                  */\nif length(parm) = 8 & verify(parm,'0123456789ABCDEF') = 0 then\n   parm = 'SSI='parm\nif words(parm) = 1 then /* only one parameter                       */\n   queue \" SETOPT   PARM(\"parm\")\"\n/* SETOPT   overrides PARM and INCLUDE -ATTR                        */\n/* SETOPT   example:                                                */\n/* SETOPT   PARM(OVLY=NO,TEST=NO,OL=NO,DC=NO,EDIT,REUS=RENT,        */\n/*          SSI=01118876,AC=0,AMODE=ANY,RMODE=24,NOLONGPARM)        */\n/* Note for REUS= parameter: NONE < SERIAL < RENT < REFR            */\n/*                                                                  */\nelse queue ' 'parm      /* two or more parameters                   */\nqueue ' NAME     'member'(R)'\n\"execio \"queued()\" diskw SYSLIN (fini\"\n   SYSLIN_execio_rc = rc\n   call check_rc SYSLIN_execio_rc,0,'SYSLIN execio'\ndelstack\n\n/*__________________________________________________________*/\n/* Execute linkedit/binder.                                 */\n\n\"call *(iewl) \",\n\"'LIST,XREF'\"\n\n/*__________________________________________________________*/\n/* Clean up                                                 */\n\"free fi(syslib syslmod sysprint sysut1 syslin)\"\nexit\n\n /*_________________________________________________________________________*/\n /* Called subroutines                                                      */\n\n check_rc:\n  /* call example:    call check_rc rc,0,'libdef isptlib'                   */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return                        /* rc=0              */\n  if zerrmsg <> '' then address ispexec 'setmsg msg('zerrmsg')'\n  /* ISPEXEC or ISREDIT error:                                              */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1)\n  else say 'rc = 'arg(1)\n  exit arg(1)\n\n /*________________________________________________________________________*/\n show_help: procedure expose dsn member\n\n  newstack\n  queue left('/* Help and JCL file to edit. F3 to exit.',78)'*/'\n  /* Show help between 'Help starts' and 'Help ends'                       */\n  help = 'no'\n  do i = 1 to sourceline()\n     if pos('Help starts',sourceline(i)) > 0 then do\n        help = \"yes\"\n        iterate\n     end /* if pos('Help starts',sourceline(i)) > 0                        */\n     if pos('Help ends',sourceline(i)) > 0 then leave\n     if help = 'yes' then queue sourceline(i)\n  end /* do i = 1 to sourceline()                                          */\n\n  queue '//*                                            '\n  queue '//* Please add a JOB card and change control cards.'\n  queue '//* An asterisk in column 1, in a control card, indicates a comment.'\n  queue '//* To save data, use cre, repl or cut.        '\n  queue '//* This temporary file disappears when you press F3.'\n  queue '//*                                            '\n  queue '//         EXPORT SYMLIST=*                    '\n  queue '//         SET DSN='dsn\n  queue '//         SET MEMBER='member\n  queue '//*                                            '\n  queue '//LKED     EXEC PGM=IEWL,PARM=(LIST,XREF)      '\n  queue '//SYSPRINT DD  SYSOUT=*                        '\n  queue '//SYSLIB   DD  DISP=SHR,DSN=&DSN               '\n  queue '//SYSLMOD  DD  DISP=SHR,DSN=&DSN               '\n  queue '//SYSUT1   DD  UNIT=VIO,DISP=NEW,SPACE=(CYL,(2,2))'\n  queue '//SYSLIN   DD  *,SYMBOLS=EXECSYS               '\n  queue '  INCLUDE  -ATTR,-ALIASES,SYSLIB(&MEMBER)      '\n  queue '* -ATTR:   The attributes which are copied are:'\n  queue '*          AC, AMODE, DC, OL, REUS, RMODE, SSI, TEST, entry point,'\n  queue '*          DYNAM and MIGRATABLE.               '\n  queue '*                                              '\n  queue '* SETOPT   PARM(........)         Overrides PARM and INCLUDE -ATTR'\n  queue '* Example:                                     '\n  queue '* SETOPT   PARM(OVLY=NO,TEST=NO,OL=NO,DC=NO,EDIT,REUS=RENT,  '\n  queue '*          SSI=AF&LYYMMDD,AC=0,AMODE=ANY,RMODE=24,NOLONGPARM)'\n  queue \"* Google search: 'binder options table inurl:IBM' \"\n  queue '* Note for REUS= parameter: NONE < SERIAL < RENT < REFR      '\n  queue '*          if  REUS=RENT, normally parameter RENT at compile.'\n  queue '* Note:    if  AMODE=ANY, code should support it.            '\n  queue '*                                              '\n  queue '* INCLUDE  MYDD(MEMBER2)    Add //MYDD to JCL  '\n  queue '*                                              '\n  queue '*          If not indicated, ENTRY point comes from -ATTR'\n  queue '  NAME     &MEMBER(R)  To not replace, change name or SYSLMOD'\n  queue ''\n\n  /* Allocate temporary file.                                  */\n  address tso\n  ddnm = 'dd'random(1,99999)    /* choose random ddname        */\n  msg_prev = msg(off)\n  \"alloc file(\"ddnm\") unit(vio) new delete tracks space(1 1)\",\n  \" reuse lrecl(80) recfm(f b) blksize(0)\"\n     alloc_temp_rc = rc\n     call check_rc alloc_temp_rc,0,'Alloc help temporary file'\n  msg_off = msg(msg_prev)\n  /* End of allocate temporary file.                           */\n\n  /* Write on temporary file.                                  */\n  \"execio * diskw\" ddnm \"(fini\"\n   execio_temp_rc = rc\n   call check_rc execio_temp_rc,0,'Execio on help temporary file'\n   delstack\n  /* End of write on temporary file.                           */\n\n  /* Edit temporary file.                                      */\n  address ispexec\n    \"control errors return\"\n    \"lminit dataid(list) ddname(\"ddnm\")\"\n    \"edit   dataid(\"list\")\"\n    \"lmfree dataid(\"list\")\"\n    \"free fi(\"ddnm\")\"\n  address /* resume previous environment                       */\n  /* End of edit temporary file.                               */\n\n return\n /*________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RETP": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x01\\xbb\\x01\\xbb\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 443, "newlines": 443, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n parse source . . rexxname .\n\n/* Get last command or previous commands.                    */\n\n/* Used as a called rexx:                                    */\n/* In calling program:                                       */\n/* str = retp()  obtains last command in a string.           */\n/* str = retp(1) obtains the last command (same as retp() ). */\n/* str = retp(n) obtains the n-th most recent command        */\n/*               (until the 25th most recent command).       */\n\n/* str = retp('all') gives the previous commands             */\n/* in a string.                                              */\n/* Commands are separated by ' ; '                           */\n/* Commands are the commands with at least one non space     */\n/* character as would be given by                            */\n/* Command ===> retp                                         */\n/* in the same order                                         */\n/* and their leading and trailing spaces have been stripped. */\n/* Example: \"tso time ; save ; cut   aa\"                     */\n/*           The most recent command is \"tso time\"           */\n\n/* We assume that the number of previous commands            */\n/* displayed by                                              */\n/* Command ===> retp                                         */\n/* is 25.                                                    */\n/* (It corresponds to a default ISPF configuration           */\n/*  parameter RETRIEVE_COMMAND_STACK_SIZE of 512.            */\n/*  cf. Command ===> tso ispcconf   and option 1)            */\n\n/* ========================================================= */\n/* ___ Examples of code in calling program ________________\n/*     to obtain previous commands.                          */\nlastcmd = retp()\n\nstr = retp('all')\n/* Last non empty 25 commands separated by ' ; '             */\n/* string str to stem cmd.                                   */\ncmd.  = ''       /* initialize                               */\ncmd.0 = 0\nif str <> '' then do\n   str = str' ; '\n   do i = 1 while pos(' ; ',str) > 0\n      parse var str cmd.i ' ; ' str   /* split str           */\n   end\n   cmd.0 = i - 1\nend /* if str <> ''                                          */\n\ndo i = 1 to cmd.0; say cmd.i; end     /* check               */\n\n   ___ End of exampled of code in calling program __________ */\n/* ========================================================= */\n\n/* On command line:                                          */\n/* Command ===> tso retp all                                 */\n/* Command ===> tso retp 2                                   */\n\n/* ____ Process as either a rexx or an edit macro __________ */\n\naddress isredit\n'macro (parm)'\nisr_rc = rc\nif isr_rc = 0 then signal process_as_an_edit_macro /* then exit    */\n/* if isr_rc = 0 then parm contains a number from 1 to 25 or 'ALL' */\nelse address /* resume previous environment                  */\n\n/* I am a rexx                                               */\n/* ____ Copy ispretp panel to temporary dataset ____________ */\n/*      Edit it by calling myself as an edit macro.          */\n/*      ispretp )INIT will contain selected command number   */\n/*      and .resp = enter.                                   */\n/*      Display panel ispcmde issuing retp command.          */\n/*      retp command uses ispretp modified panel and         */\n/*      ispcmde zcmd variable will contain selected command: */\n/*                                                           */\n/*      stack = \"retp\"                                       */\n/*      \"display panel(ispcmde) command(stack)\"              */\n/*      /* modified panel ispretp is used by retp */         */\n/*      command = zcmd /* zcmd is a variable of ispcmde */   */\n/*      /* no panel shown */                                 */\n/* _________________________________________________________ */\n\nparse arg parm .\n\n/* ____ Argument validity check ____________________________ */\nparm = translate(parm)\nif parm = '' then parm = 1 /* last command                   */\nif (datatype(parm)  <> 'NUM'     &,\n    parm            <> 'ALL')    !,\n   (datatype(parm)  =  'NUM'     & ,\n    parm > 25)                       then do\n   parse source . . rexxname .\n   say rexxname\": There must be no argument or\"\n   say \"      one numeric argument from 1 to 25 or\"\n   say \"      one argument with value 'ALL'.\"\n   say rexxname\": eg. str = retp()      <-- most recent command\"\n   say rexxname\": eg. str = retp(2)     <-- second most recent command\"\n   say rexxname\": eg. str = retp('all') <-- all commands\"\n   say rexxname\": First argument provided was \"word(arg(1),1)\".\"\n   if sysvar('sysnest') = 'NO' then do   /* not nested       */\n      zispfrc = 0\n      address ispexec 'vput zispfrc'\n      exit zispfrc\n   end                                   /* not nested       */\n   else do                               /*     nested       */\n      say rexxname\": Empty string returned.\"\n      return ''\n   end                                   /*     nested       */\nend /* invalid argument                                      */\n/* ____ End of argument validity check _____________________ */\n\n/* ____ Copy ispretp panel to temporary dataset ____________ */\n address ispexec; 'control errors return';zerrmsg=''\n\n \"lminit dataid(dd1) ddname(ispplib) enq(shr)\"\n         lmninit1_rc = rc\n         call check_rc lminit1_rc,0,'lminit ispplib'\n\n call allocate_ddout\n \"lminit dataid(dd2) ddname(ddout) enq(shr)\"\n         lmninit2_rc = rc\n         if lmninit2_rc <> 0 then call lmfree_dd1\n         call check_rc lminit2_rc,0,'lminit ddout'\n\n \"lmcopy fromid(\"dd1\") todataid(\"dd2\") frommem(ispretp)\"\n         lmcopy_rc = rc\n         if lmcopy_rc <> 0 then do\n            say 'Copy error.'\n            say 'lmcopy_rc = 'lmcopy_rc\n            call say_lmcopy_error\n            call lmfree_dd1\n            call lmfree_dd2\n            call check_rc lmcopy_rc,0,'lmcopy'\n         end /* if lmcopy_rc <> 0                          */\n\n call lmfree_dd1\n         if lmfree1_rc <> 0 then\n            call check_rc lmfree1_rc,0,'lmfree dd1'\n\n /* Make ispretp modified panel to be selected first       */\n \"libdef ispplib library id(ddout) stack\"\n        libdef1_rc = rc\n        if libdef1_rc <> 0 then do\n           say 'Libdef with id(ddout) error.'\n           say 'libdef rc = 'libdef1_rc\n           call lmfree_dd2\n           call check_rc libdef1_rc,0,'libdef with id(ddout)'\n        end /* if libdef1_rc <> 0                          */\n\n/* ____ End of copy ispretp panel to temporary dataset ___ */\n\n  cmd. = '' /* non empty command lines stem                */\n  k = 0  /* counter for cmd.                               */\n  do i = 1 to 25\n     if parm <> 'ALL' & parm <> i then iterate\n\n/* parm = 'ALL' or parm = i                                */\n/* ____ Edit member ispretp in temporary dataset _________ */\n/*      to get i-th command                                */\n \"edit dataid(\"dd2\") member(ispretp) macro(\"rexxname\") parm(i)\"\n         edit_rc = rc\n         if edit_rc <> 0 then do\n            say 'Edit error.'\n            say 'edit_rc = 'edit_rc\n            call lmfree_dd2\n            call check_rc edit_rc,0,'edit'\n         end /* if edit_rc <> 0                            */\n\n /* Refresh panel cache after editing panel ispretp        */\n /* more than once (was not in cache after first edition). */\n if parm = 'ALL' & i > 1 then call refresh_panel_cache\n/* ____ End of edit member ispretp in temporary dataset __ */\n/* ____ Issue retp _______________________________________ */\n\n  stack = \"retp\" /* variable compulsary                    */\n     /* Using modified panel ISPRETP with                  */\n     /* retsel = i and .resp = enter                       */\n     /* added at end of )INIT section.                     */\n\n /*  address tso \"ispdptrc\"      <-- for debugging         */\n     \"display panel(ispcmde) command(stack)\"\n /*  command in zcmd                                       */\n /*  address tso \"ispdptrc\"      <-- for debugging         */\n\n/* ____ End of issue retp ________________________________ */\n\n     cmd = strip(zcmd) /* zcmd result from retp (ispcmde field) */\n     if cmd <> '' then do\n        k = k + 1\n        cmd.k = cmd\n     end /* if cmd <> ''                                   */\n  end /* do i = 1 to 25                                    */\n  cmd.0 = k\n\n  \"libdef ispplib\"\n             libdef2_rc = rc\n             call check_rc libdef2_rc,0,'second libdef'\n\n  call lmfree_dd2\n          if lmfree2_rc <> 0 then\n             call check_rc lmfree2_rc,0,'lmfree dd2'\n\n  x = msg(\"off\")\n  address tso\n    \"free dd(ddout)\"\n    \"delete '\"dsnout\"'\"\n  address\n  x = msg(x)\n\n  /* stem cmd. to string str (str returned)                */\n  str = ''\n  do i = 1 to cmd.0\n     str = str' ; 'cmd.i\n  end /* do i = 1 to cmd.0                                 */\n\n  /* remove ' ; ' at start                                 */\n  if str <> '' then str = substr(str,4)\n\n  address\n  if sysvar('sysnest') = 'NO' then do /* not nested        */\n     if parm = 'ALL' then\n       do i = 1 to cmd.0\n          say 'i =' right(i,2) cmd.i\n       end /* do i = 1 to cmd.0                            */\n     else select /* on parm value                          */\n       when parm = 1 then say 'Most recent command: 'str\n       when parm = 2 then say 'Second most recent command: 'str\n       when parm = 3 then say 'Third most recent command: 'str\n       otherwise say parm'-th most recent command: 'str\n     end /* select on parm value                           */\n     zispfrc = 0\n     address ispexec 'vput zispfrc'\n     exit zispfrc\n  end /* if sysvar('sysnest') = 'NO'     not nested        */\n  else return str /* nested                                */\n\n  /* end of rexx processing                                */\n\n/* _______________________________________________________ */\n\n process_as_an_edit_macro:\n trace o\n\n '(mbr)  = member'\n\n l1 = \"*rexx(*)\"\n l2 = \"  retsel = '\"parm\"'\"\n l3 = \"*endrexx\"\n l4 = \".resp = enter\"\n /* Edition of ispretp )INIT:                               */\n /* Find first occurence of '.resp'  in column 1.           */\n /* If found, insert panel rexx just before .resp           */\n /* If .resp not found,                                     */\n /* find first occurence of ')PROC ' in column 1.           */\n /*      If found, insert panel rexx and .resp              */\n /*      just before )PROC                                  */\n\n string = '.resp'\n \"find '\"string\"' 1 first\"\n find_rc = rc\n /*\n Return codes:\n 0 Normal completion\n 4 String not found\n 12 Syntax error\n 20 Severe error\n */\n if find_rc = 0 then do /* .resp already present           */\n     /* Insert panel rexx before .resp                     */\n     do k = 1 to 3\n   /*  \"line_before .zcsr = '\"l1\"'\"                        */\n       \"line_before .zcsr = '\"value('l'k)\"'\"\n     end /* do k = 1 to 3                                  */\n end /* .resp already present                              */\n else do /* .resp not present (first time panel edited)    */\n    string = ')PROC '\n    \"find '\"string\"' 1 first\"\n    find_rc = rc\n    select /* according to find_rc for )PROC               */\n\n      when find_rc = 0 then do /* )PROC found              */\n\n     /* Insert panel rexx and .resp before )PROC           */\n        do k = 1 to 4\n          \"line_before .zcsr = '\"value('l'k)\"'\"\n        end /* do k = 1 to 4                               */\n\n      end /* when find_rc = 0     )PROC found              */\n\n      when find_rc = 4 then do /* string was not found     */\n        say 'Member 'right(mbr,8)', find rc = 'find_rc\n        say 'String = 'string' was not found.'\n        'can'\n      end /* when find_rc = 4                              */\n\n      otherwise do /* find_rc = 12 or 20                   */\n        say 'Member 'right(mbr,8)', find rc = 'find_rc\n        if find_rc = 12 then say 'Syntax error'\n        if find_rc = 20 then say 'Severe error'\n        'can'\n      end /* otherwise                                     */\n\n    end /* select according to find_rc for )PROC           */\n end     /* .resp not present                              */\n\n 'save'\n 'end'\n\n exit 0 /* from edit macro processing                      */\n\n /* _____ Following routines used by rexx processing _____ */\n\n check_rc: /* used by rexx */\n\n  /* call example:    call check_rc rc,0,'libdef isptlib'  */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return\n  /* ISPEXEC or ISREDIT error:                             */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  /* \"LMCLOSE DATAID(\"dataid\")\" */\n  say 'rc = 'arg(1)\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg\n  zispfrc = 16\n  address ispexec 'vput zispfrc'\n  exit zispfrc\n /*________________________________________________________*/\n\nallocate_ddout: procedure expose rexxname prefix dsnout\n\nran  = right(random(1,99999),5,'0')\ncall set_up_prefix /* create prefix for new file           */\n parse source . . rexxname .\ndsnout   = prefix\".\"rexxname\".R\"ran\nmsg_prev = msg('off')\naddress tso \"alloc file(ddout) da('\"dsnout\"') new catalog\",\n       \"dsorg(po) dsntype(library 2) tracks space(5,5) dir(5)\",\n       \"recfm(f b) lrecl(80) blksize(0) reuse\"\nalloc_rc = rc\n/* zerrmsg = '' */                           /* debug */\n/* call check_rc alloc_rc,0,'alloc ddout' */ /* debug */\nif alloc_rc <> 0 then do\n   say rexxname \"could not allocate ddout.\"\n   say \"We exit with code 16.\"\n   say \"alloc rc = \"alloc_rc\n   zispfrc = 16\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\nmsg_off  = msg(msg_prev)\n\nreturn\n/* End of allocate_ddout                                    */\n\n/*__________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n /*___________________________________________________________________*/\n\n say_lmcopy_error: procedure expose lmcopy_rc\n   select /* according to lmcopy return code                          */\n     when lmcopy_rc = 0 then return /* for completeness               */\n     when lmcopy_rc = 4 then do\n          say \"The 'from' data set is empty or\"\n          say \"no members matched the specified pattern\",\n              \"in the 'from' data set.\"\n     end /* when lmcopy_rc = 4                                        */\n     when lmcopy_rc = 8 then do\n          say \"The from-member-name was not found or\"\n          say \"the same name was specified for to-member-name and\",\n          say \"from-member-name.\"\n     end /* when lmcopy_rc = 8                                        */\n     when lmcopy_rc = 10 then do\n          say \"No data set is associated with the given data ID.\"\n     end /* when lmcopy_rc = 10                                       */\n     when lmcopy_rc = 12 then do\n          say \"One of these:\"\n          say \"A like-named member already exists in the 'to' data set\"\n          say \"  and the Replace option was not specified\"\n          say \"One or more members of the 'to' data set are 'in use',\"\n          say \"  either by you or by another user, and could not be copied\"\n          say \"Invalid data set organization\"\n          say \"Data set attribute invalid for copying or copying packed data\"\n          say \"Open error\"\n          say \"LOCK parameter is specified\"\n     end /* when lmcopy_rc = 12                                       */\n     when lmcopy_rc = 16 then do\n          say \"Truncation error.\"\n     end /* when lmcopy_rc = 16                                       */\n     when lmcopy_rc = 20 then do\n          say \"Severe error.\"\n     end /* when lmcopy_rc = 20                                       */\n     otherwise nop\n   end /* select according to lmcopy return code                      */\n   return\n /*___________________________________________________________________*/\n\n lmfree_dd1:\n\n \"lmfree dataid(\"dd1\")\"\n lmfree1_rc = rc\n return\n/*____________________________________________________________________*/\n\n lmfree_dd2:\n\n \"lmfree dataid(\"dd2\")\"\n lmfree2_rc = rc\n return\n/*____________________________________________________________________*/\n\nrefresh_panel_cache: procedure\n/* Refresh panel cache method from                         */\n/* http://ibmmainframes.com/about59391.html                */\n/* Author: Stefan  Germany                                 */\n/* Thank you Stefan.                                       */\n  address ispexec\n  do i = 1 to 12\n     /* non display, simulate END key                      */\n     \"control nondispl end\"\n     /* isr00301 isr00302 ... isr00312 reflist panels      */\n     \"display panel(isr003\"right(i,2,'0')\")\"\n  end /* do i = 1 to 12                                    */\n  address\nreturn\n/*_________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXMAC": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00D\\x00D\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 68, "newlines": 68, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace('o')\n\n/* Example:                                                */\n/* An edit macro in rexx's clothing.                       */\n\n/* Purpose:                                                */\n/*         VIEW      BOZO.PDS                              */\n/* Command ===> s *2* rexx01                               */\n/*            Name     Prompt                              */\n/* _________ MBR1                                          */\n/* _________ MBR2                                          */\n/* _________ MBR3                                          */\n/* will execute rexx rexx01 on all members with name       */\n/* containing 2.                                           */\n/* If instead of a rexx, I would like an edit macro        */\n/* to process all members with name containing 2,          */\n/* I should make the edit macro to look like a rexx.       */\n/* This is the case with rexxmac.                          */\n/* Command ===> s *2* rexxmac                              */\n\n/* Other example:                                          */\n/* Command ===> cmde                                       */\n/* Enter TSO commands below:                               */\n/* ===> rexxmac 'bozo.pds(mbr2)' aA bB                     */\n\nparse arg dsn parm\ndsn  = strip(dsn,,\"'\") /* remove surrounding quotes if any */\n\ncall rexx_to_edit_macro\n\n/* I am an edit macro from thereon until exit.             */\naddress isredit\n\n  say \"parm   = \"parm\n  '(mbr) = member '\n  say \"member = \"mbr\n  \"c 'MBR1' 'MBR2' all\"\n  'save'\n  'end'\naddress /* resume environment prior to address isredit     */\n\nexit /* leave edit macro and return to rexx                */\n\n/* _______________________________________________________ */\n\nrexx_to_edit_macro: procedure expose dsn parm\n\n/* edit macro will return.                                 */\n/* rexx will exit.                                         */\n\naddress isredit\n'macro (parm)'\nisr_rc = rc\n\nif isr_rc <> 0 then do\n   /* Actually rc = 20                                     */\n   /* I am a rexx                                          */\n   address ispexec; 'control errors return'\n     parse source . . rexxname .\n     \"edit dataset('\"dsn\"') macro(\"rexxname\") parm(parm)\"\n  /*  edit if changes have to be made.                     */\n  /* \"view dataset('\"dsn\"') macro(\"rexxname\") parm(parm)\"  */\n   address\n   exit /* final rexx exit                                 */\nend         /* if isr_rc <> 0       rexx                   */\nelse return /*    isr_rc =  0       edit macro             */\n/* _______________________________________________________ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXX2MAC": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00O\\x00O\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 79, "newlines": 79, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace('o')\n\n/* Execute an edit macro on library members                 */\n\n/* Purpose:                                                 */\n/*         VIEW      BOZO.PDS                               */\n/* Command ===> s *2* rexx2mac macro01 parm1                */\n/*            Name     Prompt                               */\n/* _________ MBR1                                           */\n/* _________ MBR2                                           */\n/* _________ MBR3                                           */\n/* will execute edit macro macro01 with parm parm1          */\n/* on all members with name containing 2.                   */\n/* Members may be modified by macro.                        */\n/* parm1 will be in uppercase due to panel zcmd attribute.  */\n\n/* Other example:                                           */\n/* Command ===> cmde                                        */\n/* Enter TSO commands below:                                */\n/* ===> rexx2mac 'bozo.pds(mbr2)' macro01 parm1             */\n\n parse arg dsn . /* qualified dsname with or without member */\n address ispexec; 'control errors return'\n\n  cmd   = lastcmd()     /* last command from command stack  */\n  /* alternative: cmd = retp()                              */\n  macro = word(cmd,4)\n  parm  = subword(cmd,5) /* rest starting from 5th word     */\n  /* For Command ===> s * rexx2mac macro01 aA bB            */\n  /* in View panel ISRUDSM with ZCMD attribute CAPS(ON)     */\n  /* lastcmd() gives:                                       */\n  /* 'S * REXX2MAC MACRO01 AA BB'                           */\n  /* and we have: macro = 'MACRO01' and parm = 'AA BB'      */\n\n  \"edit dataset(\"dsn\") macro(\"macro\") parm(parm)\"\n        edit_rc = rc\n        call check_rc edit_rc,0,'edit'\n  /* With ispexec \"view ...\" member not saved by the edit macro */\n  /* Edit return codes:\n      0 Normal completion; data was saved.\n      4 Normal completion; data was not saved for one of these reasons:\n        No data changes were made during the EDIT session.\n        The CANCEL command was used to exit EDIT.\n        Browse was substituted for EDIT because of insufficient storage.\n     10 Member or generation (if specified) not found.\n     12 YES was specified for the LOCK parameter.\n     14 Member, sequential data set, or z/OS UNIX file in use.\n     16 Either:  No members matched the specified pattern\n                 No members in the partitioned data set\n     18 A VSAM data set was specified but the ISPF Configuration Table\n        does not allow VSAM processing.\n     20 Severe error; unable to continue.\n  */\n  zispfrc = 0\n  'vput zispfrc'\n  address /* from ispexec                                   */\n exit zispfrc\n /*_________________________________________________________*/\n check_rc:\n\n  /* call example:    call check_rc rc,0,'libdef isptlib'   */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return\n  /* ISPEXEC or ISREDIT error:                              */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  say 'rc = 'arg(1)\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1) 'ZERRMSG='zerrmsg\n  zispfrc = 16\n  address ispexec 'vput zispfrc'\n  exit zispfrc\n /*_________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAV": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\xac\\x00\\xac\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 172, "newlines": 172, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n trace o\n\n /* Edit macro which may be used instead of the                  */\n /* 'SAVE' Edit command.                                         */\n\n /* Apart of the normal SAVE, it saves the library member in     */\n /* a member named, by default, SAVED                            */\n /* Examples of use, in ISPF EDIT:                               */\n /* Command ===> sav      <-- normal save and save in member SAVED    */\n /* Command ===> sav SAVED2 <-- normal save and save in member SAVED2 */\n /*                                                              */\n /* The edit macro has a parameter,                              */\n /* set by default to \"yes\", save_in_waste_basket.               */\n /* If the library being edited has fixed record format and      */\n /* LRECL=80, the member is also saved in a library              */\n /* prefix.WASTE.BASKET                                          */\n /* This library is created if it does not exist.                */\n\n /* For a sequential dataset or a library member, the first      */\n /* lines are also stored in a clipboard for the length of       */\n /* the TSO session.                                             */\n\n /* If a library member is inadvertently deleted, a previous     */\n /* version may be copied from member saved.                     */\n /* Case of inadvertent member deletion:                         */\n /* In the member list of a library with no generation           */\n /* while CONFIRM NO is in force, 'D' is typed instead of 'S'.   */\n /* Touches 'S' and 'D' are adjacent on a keyboard.              */\n\n saved     = \"SAVED\" /* save member in member saved              */\n\n clipboard = \"SAVED\" /* save beginning in clipboard              */\n maxcut    = 3000    /* Maximum number of lines to cut           */\n                     /* into clipboard.                          */\n                     /* Compromise between size and              */\n                     /* being unuseful most of the time.         */\n\n save_in_waste_basket = \"yes\" /* may be set to \"no\"              */\n /* waste_basket is a library with RECFM=FB and LRECL=80         */\n /* Its dsname is: prefix\".\"waste_basket_but_prefix              */\n /* prefix is determined by: call set_up_prefix                  */\n /* using profile or userid.                                     */\n waste_basket_but_prefix = \"WASTE.BASKET\" /* <== Change if needed */\n /* If the library does not exist, it is created.                */\n\n set_delete_confirmation_on = \"no\"  /* may be set to \"yes\"       */\n /* if \"no\" leave variable zmemconf as it is.                    */\n /* if \"yes\" then zmemconf = \"ON\"; \"vput zmemconf shared\"        */\n\n address isredit\n 'macro (parm)'\n macro_rc = rc\n select /* according to macro_rc                                 */\n\n /*_______________ EDIT MACRO ___________________________________*/\n   when macro_rc = 0  then do /* it is an edit macro             */\n\n     /* NEWGEN and NOGEN are parameters of SAVE Edit command     */\n\n     /* Separate parm into parm1 and parm2:                      */\n     /* parm1 has neither NEWGEN or NOGEN                        */\n     /* parm2 has         NEWGEN or NOGEN                        */\n     parm1 = ''; parm2 = ''    /* initialize                     */\n     do i = 1 to words(parm)\n        w = word(parm,i)       /* i-th word of parm              */\n        w_upper = translate(w) /* upper case                     */\n        if wordpos(w_upper,'NEWGEN NOGEN') = 0 then parm1 = parm1' 'w\n                                               else parm2 = parm2' 'w\n     end /* do i = 1 to words(parm)                              */\n\n     /*    Normal SAVE always done:                              */\n     'builtin save 'parm2   /* parm2 may contain NEWGEN or NOGEN */\n\n     /*    Extra saves follow:                                   */\n     if sysvar(sysispf)  = 'ACTIVE' &,\n        sysvar(\"sysenv\") = 'FORE'   then do\n        /* ISPF foreground                                       */\n\n        if words(parm1) > 0 then do\n           /* Change default name of member where to save        */\n           /* using first word of parm1.                         */\n           saved = translate(word(parm,1))\n           clipboard = saved\n        end /* Change default name of member where to save       */\n\n        '(member) = member'\n        if member <> '' &,                      /* library       */\n           member <> saved then do\n\n           /* Extra save in own library                          */\n           \"rep \"saved\" .zf .zl\"                /* save member   */\n\n           if save_in_waste_basket = \"yes\" then do\n             /* Extra save in waste basket library.              */\n             /* If a library member is being edited and          */\n             /* if the library has fixed record format           */\n             /* and LRECL=80,                                    */\n             /* then save member in a waste basket library.      */\n             '(blksize) = blksize'\n             '(lrecl)   = lrecl'\n             if blksize//lrecl = 0 then do /* multiple           */\n                '(dataset) = dataset'\n                address tso\n                  listdsi_rc = listdsi(\"'\"dataset\"'\")\n                address\n                if left(sysrecfm,1) = \"F\" then do\n                /* Edited library has fixed record format and    */\n                /* LRECL=80.                                     */\n                   call set_up_prefix\n                   /* waste_basket_but_prefix defined            */\n                   /* at the beginning of this edit macro.       */\n                   waste_basket = prefix\".\"waste_basket_but_prefix\n                   ret_sysdsn = sysdsn(\"'\"waste_basket\"'\")\n                   if ret_sysdsn <> 'OK' then do\n                      /* Create waste_basket                     */\n                      address tso \"alloc da('\"waste_basket\"')  \",\n                       \"unit(sysda) cyl sp(5 10) dir(300)      \",\n                       \"dsntype(library,2) recfm(f b) lrecl(80)\",\n                       \"blksize(0) new catalog reuse\"\n                       ret_alloc = rc\n                       if ret_alloc <> 0 then\n                          say \"Could not allocate \"waste_basket\n                   end /* if ret_sysdsn <> 'OK'                  */\n\n                   if ret_sysdsn = 'OK' ! ret_alloc = 0 then do\n                      saved2 = waste_basket'('member')'\n                     \"rep '\"saved2\"' .zf .zl\"   /* save member   */\n                   end /* if ret_sysdsn = 'OK' ! ret_alloc = 0   */\n\n                end /* if left(sysrecfm,1) = \"F\"                 */\n             end /* if blksize//lrecl = 0 multiple               */\n           end /* if save_in_waste_basket = \"yes\"                */\n        end /* if member <> '' & member <> saved                 */\n\n        /* Save for \"as long as you are logged on to TSO\"        */\n        '(lines) = linenum .zl' /* total number of lines         */\n        'cut 1 'min(lines,maxcut) clipboard' replace'\n\n        if set_delete_confirmation_on = \"yes\" then do\n           zmemconf = \"ON\"\n           address ispexec \"vput zmemconf shared\"\n        end /* if set_delete_confirmation_on = \"yes\"             */\n\n     end /* ISPF foreground                                      */\n\n     exit 1\n\n /*_______________ OTHERWISE ____________________________________*/\n   otherwise do /* macro_rc different of 0                       */\n     parse source . . rexxname .    /* rexxname in upper case    */\n     say\n     say 'This is customized macro 'rexxname'.'\n     say rexxname\" macro_rc = \"macro_rc\n     say \"We exit with code 16.\"\n     exit 16\n   end /* otherwise                                              */\n\n end /* select according to macro_rc                             */\n /*___________________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n /*__________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCR": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00h\\x00h\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 104, "newlines": 104, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n/*_________________________________________________________*/\n/*    scr:                                                 */\n/*    With no parameter: refresh panel cache               */\n/*    With one parameter: refresh panel cache              */\n/*                      and set permanent screen name.     */\n/*    May be used as a rexx or edit macro.                 */\n/*    Examples:                                            */\n/*                                                         */\n/*    Command ===> tso scr                                 */\n/*    or scr before panel name                             */\n/*    (after modifying a panel)                            */\n/*    Flushes the panel cache.                             */\n/*                                                         */\n/*    Command ===> tso scr screen1                         */\n/*    Flushes the panel cache and                          */\n/*    set permanently present screen name to screen1       */\n/*                                                         */\n/*    In Edit or View mode:                                */\n/*    Command ===> scr                                     */\n/*    Command ===> scr screen1                             */\n/*_________________________________________________________*/\n/*                                                         */\n/* Obtain parameter if any (edit macro or rexx).           */\n/* If no parameter, scrname = ''                           */\naddress isredit /* Am I an edit macro?                     */\n\"macro (scrname)\"\nisr_rc = rc\nif isr_rc <> 0 then parse arg scrname . /* rexx            */\naddress\n/*_________________________________________________________*/\n/*                                                         */\naddress ispexec\n\"control errors return\"\n  call refresh_panel_cache\n  if scrname <> '' then do\n     call check_and_try_to_correct_screen_name\n     call set_screename_permanent\n  end /* if scrname <> ''                                  */\naddress\nexit\n/*_________________________________________________________*/\n/*                                                         */\nrefresh_panel_cache: procedure\n/* Refresh panel cache method from                         */\n/* http://ibmmainframes.com/about59391.html                */\n/* Author: Stefan  Germany                                 */\n/* Thank you Stefan.                                       */\n  do i = 1 to 12\n     /* non display, simulate END key                      */\n     \"control nondispl end\"\n     /* isr00301 isr00302 ... isr00312 reflist panels      */\n     \"display panel(isr003\"right(i,2,'0')\")\"\n  end /* do i = 1 to 12                                    */\nreturn\n/*_________________________________________________________*/\n/*                                                         */\nset_screename_permanent: procedure expose scrname\n  stack = 'scrname 'scrname' perm'\n  /* stack =\"command1;command2\"                            */\n  inocuous_panel = ispblank\n  /* command(   ) implies:                                 */\n  /* panel processed in CONTROL NONDISPL ENTER mode        */\n  /* non display, simulate ENTER key                       */\n  \"display panel(\"inocuous_panel\") command(stack)\"\nreturn\n/*_________________________________________________________*/\n/*                                                         */\ncheck_and_try_to_correct_screen_name:,\n  procedure expose scrname\n/* scrname is an input output parameter                    */\n/* scrname 2 to 8 characters that conform to member naming */\n/* rules , except NEXT, PREV, LIST, ON and OFF             */\n\nscrname = translate(scrname) /* set in uppercase           */\n\nif length(scrname) > 8 then do /* too long                 */\n  say 'scrname 'scrname' should have at most 8 characters.'\n  scrname = right(scrname,8) /* retain the 8 rightmost characters */\nend /* when length(scrname) > 8                            */\n\nif length(scrname) < 2 then do /* too short                */\n  say 'scrname 'scrname' should have at least 2 characters.'\n  scrname = scrname!!scrname\nend /* when length(scrname) < 2                            */\n\n/* All characters alphanumeric or national                 */\ndo i = 1 to length(scrname)\n   char = substr(scrname,i,1) /* ith character             */\n   if datatype(char,alphanumeric) then iterate\n   if pos(char,'\u00e0\u00a3$') then iterate /* national char Ok     */\n    scrname = overlay('X',scrname,i)  /* overlay ith char  */\nend /* do i = 1 to length(scrname)                         */\n\n/* First character not numeric                             */\nchar = left(scrname,1)\nif datatype(char,number) then\n    scrname = overlay('X',scrname,1)  /* overlay 1st char  */\n\n/* scrname must not be NEXT, PREV, LIST, ON, OFF.          */\nif wordpos(scrname,'NEXT PREV LIST ON OFF') > 0 then\n  scrname = scrname!!'X'\nreturn\n/* End of check_and_try_to_correct_screen_name ___________ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SFGREP": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00b\\x00b\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 98, "newlines": 98, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n parse source . . rexxname .    /* rexxname in upper case              */\n dsnout_prefix = \"XX.YYYY\" /* please change dataset high level qualifiers */\n\n /* Grep search                                                        */\n\n /* Example of use:                                                    */\n /* Command ===> cmde                                                  */\n /* Enter TSO commands below:                                          */\n /* ===> sfgrep 'listc a' 'XX.YYYY.USER01.CNTL'                        */\n\n if left(word(arg(1),1),1) = \"'\" /* argument list begins by quote      */\n    then parse value arg(1) with \"'\" regex \"'\" dsn .\n    else parse arg regex dsn .\n dsn = strip(translate(dsn,'',\"'\"))\n say 'dsn   = 'dsn\n say 'regex = 'regex\n\n /* z/OS Unix commands in local codepage                               */\n env.1 = \"LANG=En_US.IBM-1140\"\n /* env.1 = \"LANG=Fr_FR.IBM-1147\" */    /* locale gives LANG=C         */\n env.0 = 1\n\n call alloc_dsnout                      /* STDOUT allocation           */\n\n cmd = 'rm -rf temp;',                  /* remove /$HOME/temp          */\n       'mkdir  temp;',                  /* create /$HOME/temp folder   */\n       'cp \"//'!!\"'\"dsn\"'\"!!'\" temp;',  /* copy lib \"//'dsn'\" to temp  */\n       'cd     temp;',                  /* in temp                     */\n       \"grep -E '\"regex\"' * ;\",         /* search all with regex       */\n       'cd     ..;',                    /* over temp                   */\n       'rm -rf temp'                    /* remove /$HOME/temp          */\n\n zispfrc = address_sh(cmd)              /* address_sh('set -x;' cmd)   */\n\n call view_dsnout                       /* View BPXWUNIX STDOUT STDERR */\n\n signal fin\n\n /*____________________________________________________________________*/\n\n fin:   /* normal and abnormal exit                                    */\n address ispexec \"vput zispfrc\"\n exit zispfrc\n\n /*____________________________________________________________________*/\n\n address_sh: procedure expose env.\n /* stdin is /dev/null                                                 */\n newstack\n\n xrc = bpxwunix(arg(1),,STACK,STACK,env.)\n\n queue copies('_',80)\n \"execio \"queued()\" diskw stdout (open finis\"\n /* execio rc = 1 if truncation occurs e.g. grep expanded statement    */\n\n delstack\n if xrc <> 0 then say \"bpxwunix failed with rc = \"xrc\n return xrc\n /*____________________________________________________________________*/\n /*                                                                    */\n alloc_dsnout:\n /* Allocate STDOUT dsnout dataset.                                    */\n /* \"alloc fi(stdout) da(*) reu recfm(f b) lrecl(133)\"                 */\n time_stamp = t!!time('s')\n dsnout = dsnout_prefix\".\"userid()\".\"rexxname\".\"time_stamp\n allo = \"allocate fi(stdout) da('\"dsnout\"') reuse\",\n \"mod catalog\",\n \"dsorg(ps) space(1 15) tracks recfm(f b) lrecl(133) blksize(0)\"\n allo                           /* execute                             */\n arc = rc\n if arc > 0 then do\n    say \"STDOUT dsnout allocate gave code \"arc\n    zispfrc = 16\n    signal fin\n end /* if arc > 0                                                     */\n return\n\n /*____________________________________________________________________*/\n /*                                                                    */\n view_dsnout:\n\n /* Display dsnout                                                     */\n   address ispexec\n    \"lminit dataid(dd1) dataset('\"dsnout\"') enq(shr)\"\n    \"view   dataid(\"dd1\")\"\n    \"lmfree dataid(\"dd1\")\"\n   address\n\n /* Clean up                                                           */\n msgs = msg(\"off\")\n  \"delete '\"dsnout\"'\"\n msgs = msg(msgs)\n\n return\n /*____________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPLIT": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xd2\\x00\\xd2\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:10", "lines": 210, "newlines": 210, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n/* Execute split Unix command.                                */\n\ntrace o\nlang = \"En_US.IBM-1140\"      /* \"Fr_FR.IBM-1147\"              */\n\n/* User is supposed to have an OMVS segment as                */\n/* the rexx uses a temporary subdirectory of the home         */\n/* directory before copying the result to a MVS library.      */\n\n/* Examples:                                                  */\n/*          VIEW      BOZO.CNTL                               */\n/*  Command ===>                                              */\n/*             Name     Prompt                                */\n/*  split____ MEMBER01 100    <-- split every 100 lines       */\n/*  split____ MEMBER02 -100   <-- split every 100 lines       */\n/*  split____ MEMBER03 -l 100 <-- split every 100 lines       */\n/*  split____ MEMBER04 500 Z  <-- split every 500 lines       */\n/*                     and prefix created members with Z      */\n\n/*  Created library:                                          */\n/*  BOZO.CNTL.MEMBER01.SPLIT with members                     */\n/*  XAA, XAB, XAC, ... Each one has 100 lines,                */\n/*  if parameter in Prompt field, is 100.                     */\n\n/*  split____ MEMBER05     default split every 1000 lines     */\n/*  It start a new file every time it has copied              */\n/*  1000 lines.                                               */\n\n/*  ISPF 3.4                                                  */\n/*           Data Sets Matching BOZO                          */\n/*  Command ===>                                              */\n/*                                                            */\n/*  Command - Enter \"/\" to select action                      */\n/*  ----------------------------------------------            */\n/*           BOZO.SEQ01                                       */\n/*  split / 100 O.SEQ02                                       */\n/*  Created library:                                          */\n/*  BOZO.SEQ02.SPLIT with members                             */\n/*  XAA, XAB, XAC, ... Each one has 100 lines.                */\n\n/*  Command ===> tso split 'BOZO.CNTL(MEMBER1)' 100           */\n/*  Command ===> cmde      <-- to preserve lower case         */\n/*  Enter TSO commands below:                                 */\n/*  ===> split 'BOZO.CNTL(MEMBER2)' -l 100 MBR                */\n/*   Created MVS library 'BOZO.CNTL.MEMBER2.SPLIT will        */\n/*   contain membres MBRAA, MBRAB, ...                        */\n/* End of examples.                                           */\n\n/*  For a library member,                                     */\n/*  the generated library name is suffixed by the             */\n/*  member name and '.SPLIT'.                                 */\n/*  For a sequential data set,                                */\n/*  the generated library name is suffixed by '.SPLIT'.       */\n/*  '.SPLIT' may be truncated from 5 to 2 characters          */\n/*  ('.SPLI' to '.S') in order that the generated library     */\n/*  name fits into 44 characters.                             */\n\n/*____________________________________________________________*/\n/* Build split z/OS Unix command.                             */\n\nparse arg dsn rest\n/* In a member list, rest                                     */\n/* may be obtained from prompt field.                         */\n\n/* Command ===> tso OMVS                                      */\n/* man split    gives:                                        */\n/*         split [-a n] [-l n] [file [prefix]]                */\n/*         split -b n[bkm] [-a n] [file [prefix]]             */\n/*         split [-n] [-a n] file [prefix]                    */\n\n/* This rexx uses stdin as file and at right of dsname,       */\n/* rest is made of:                                           */\n/*               [-a n] [-l n] [prefix]                       */\n/*               -b n[bkm] [-a n] [prefix]                    */\n/*               [-n] [-a n] [prefix]                         */\n/* prefix, if present, is supposed to be at right.            */\n\n/* Command ===> tso split dsn 150                             */\n/* gives the Unix command: split -l 150                       */\n/* split every 150 lines, generated member names are          */\n/* XAA, XAB, XAC, ... the default member names and            */\n/* dsn is in stdin.                                           */\n\n/* Command ===> tso split dsn 150 MBR                         */\n/* gives the Unix command: split -l 150 - MBR                 */\n/* split every 150 lines, generated member names are          */\n/* MBRAA, MBRAB, ... instead of the default member names      */\n/* XAA, XAB, ...     and                                      */\n/* dsn is in stdin (the dash before MBR).                     */\n\nrest = strip(rest)\n\n/* If following dsname, there is a number, prefix it by -l    */\nif datatype(word(rest,1)) = 'NUM' then\n   rest = '-l 'rest /* Use standard Unix parameter form.      */\n\n/* If last word of what follows dsname, begins by an          */\n/* alphabetic or national character and                       */\n/* next to last word is not -b,                               */\n/* assume it is prefix.                                       */\n/* It replaces the default 'X' first character of generated   */\n/* member names.                                              */\nw = words(rest)\nlast_word = word(rest,w)\nfirst_char = left(last_word,1)\nif datatype(first_char,'M') = 1 ! pos(first_char,'@#$') > 0 then do\n   /* 'M' mixed case: a-z or A-Z                              */\n   /* first_char could be the first character of a member name */\n   if w = 1 then rest = ' - 'last_word\n   if w > 1 & wordpos(translate(word(rest,w-1)),'-B -') = 0 then\n      rest = subword(rest,1,w-1)' - 'last_word\n      /* - indicates input from STDIN                         */\nend /* if datatype(first_char,'M') = 1 ! pos(first_char,'@#$') > 0 */\n\ncmd = 'split' rest /* Unix command                            */\nsay 'Generated z/OS Unix split command for bpxwunix:'\nsay cmd\n\n/*____________________________________________________________*/\n/* Allocate STDIN.                                            */\ndsn = strip(dsn,,\"'\") /* remove quotes if any                 */\nparse var dsn dsn0 '(' member ')' .\n\"alloc fi(stdin) da('\"dsn\"') shr reu\"\narc = rc\nif arc > 0 then do\n   say \"STDIN allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*____________________________________________________________*/\n/* Allocate generated library.                                */\nif member <> '' then splitdsn = dsn0'.'member'.SPLIT'\n                else splitdsn = dsn0'.SPLIT'\nif length(splitdsn) > 48 then exit 16\n/* truncate leaving at least '.S' at end                      */\nsplitdsn = strip(left(splitdsn,44))\nmsgs = msg(\"off\")\n\"delete '\"splitdsn\"'\"\nmsgs = msg(msgs)\n\"alloc fi(dd01) da('\"splitdsn\"') like('\"dsn0\"')\",\n       \"dsorg(po) dsntype(library,2) new catalog\"\narc = rc\nif arc > 0 then do\n   say splitdsn\" allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*____________________________________________________________*/\n/* Complete z/OS Unix command.                                */\nq  = \"'\"                     /* quote                         */\ndq = '\"'                     /* double quote                  */\nhead = dq'//'q               /* head contains \"//'            */\ntail = q!!dq                 /* tail contains '\"              */\n/* head and tail to surround splitdsn:                        */\n/* cp splitdsn/asterisk \"//'splitdsn'\"                        */\n/*    Environnement variable _BPX_SHAREAS=MUST                */\n/*    needed with \"//'splitdsn'\"                              */\n\ncmd = \"set -x           ;\",  /* trace                         */\n      \"rm -rf \"splitdsn\";\",  /* remove subdirectory           */\n      \"mkdir  \"splitdsn\";\",  /* define subdirectory           */\n      \"cd     \"splitdsn\";\",  /* subdirectory is pwd           */\n      cmd              \";\",  /* split result in subdirectory  */\n      \"cd ..            ;\",  /* return to parent directory    */\n      'cp 'splitdsn'/* ' head!!splitdsn!!tail \";\",\n      \"rm -rf \"splitdsn      /* remove subdirectory           */\n\n      /* 'cp 'splitdsn'/asterisk ' head!!splitdsn!!tail \";\",  */\n      /*  copy all subdirectory members to MVS library        */\n\n/*____________________________________________________________*/\n/* Initialize stem stderr.                                    */\ndrop stderr.\nstderr.0 = 0\n/*____________________________________________________________*/\n/* Set up env. environment variables stem.                    */\ndrop env.\nenv.1 = \"LANG=\"lang\nenv.2 = \"_BPX_SHAREAS=MUST\" /* needed by cp with \"//'dsn'\"    */\nenv.0 = 2\n\n/*____________________________________________________________*/\n/* Execute Unix split command.                                */\n/* call bpxwunix cmd,'DD:STDIN',,stderr.,env.                 */\n\nbpxwunix_rc = bpxwunix(cmd,'DD:STDIN',,stderr.,env.)\nif bpxwunix_rc = 0 then do\n   say 'File 'dsn' split into 'splitdsn\n   /* Edit created MVS library splitdsn.                      */\n   address ispexec\n    \"control errors return\"\n    \"edit dataset('\"splitdsn\"')\"\n   address\nend /* if bpxwunix_rc = 0                                     */\nelse do /* bpxwunix_rc <> 0                                   */\n   say 'Splitting file 'dsn' into 'splitdsn\n   say 'bpxwunix_rc = 'bpxwunix_rc\n   if stderr.0 <> 0 then\n      do i = 1 to stderr.0\n         say 'stderr.'i' ='stderr.i\n      end\nend /* bpxwunix_rc <> 0                                       */\n\n/*____________________________________________________________*/\n/* Clean up                                                   */\n\"free fi(stdin)\"\n\"free da('\"splitdsn\"')\"\nexit bpxwunix_rc\n/*____________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSI": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xa2\\x00\\xa2\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:11", "lines": 162, "newlines": 162, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\nparse source . . rexxname .\n\n/*____________________________________________________________________________*/\n/*                                                                            */\n/*  Help starts                                                               */\n/*                                                                            */\n/* Set SSI eight hexadecimal digit constant to                                */\n/* a load module/program object.                                              */\n/* Rebind the load module/program object setting the SSI.                     */\n/*                                                                            */\n/* ssi      optional parameter, may be obtained from prompt field             */\n/* ssi      Eight hexadecimal characters: 0123456789ABCDEF                    */\n/* ssi default:   2 hex char followed by yymmdd                               */\n/*                                                                            */\n/* Example:                                                                   */\n/*  Command ===> tso ssi 'BOZO.LOAD(COBOL01)' AA190206                        */\n/*                                                                            */\n/* Example:                                                                   */\n/* XXXX    VIEW      BOZO.LOAD                                                */\n/*  Command ===>                                                  Scroll ===> */\n/*            Name     Prompt   Alias-of    ---- Attributes ----      SSI     */\n/* ssi______ COBOL01   AA123456                     RN RU                     */\n/* ssi______ COBOL02                                RN RU                     */\n/*                                                                            */\n/* Result:                                                                    */\n/* XXXX    VIEW      BOZO.LOAD                                                */\n/*  Command ===>                                                  Scroll ===> */\n/*            Name     Prompt   Alias-of    ---- Attributes ----      SSI     */\n/* _________ COBOL01                                RN RU         AA123456    */\n/* _________ COBOL02                                RN RU         FF190506    */\n/*____________________________________________________________________________*/\n/* Help ends                                                                  */\n/*                                                                            */\n\n/*__________________________________________________________*/\n/* Get parameters                                           */\n\nparse arg dsn ssi .\n\ndsn = strip(dsn,,\"'\") /* remove quotes if any               */\nparse var dsn dsn '(' member ')'\nif member = '' then do\n   say 'Load module/program object missing.'\n   call show_help\n   exit\nend /* if member = ''                                       */\n\nif ssi = '' then ssi = 'FF'substr(date('s'),3) /* FFyymmdd  */\n\nif length(ssi) <> 8 then do\n   say ssi 'must be an hex string eight characters long',\n           \"such as '019ABCEF'.\"\n   call show_help\n   exit\nend /* if length(ssi) <> 8                                  */\n\nif verify(ssi,'0123456789ABCDEF') > 0 then do\n   say ssi 'not an hex string.'\n   call show_help\n   exit\nend /* if not hex string                                    */\n\n/*__________________________________________________________*/\n/* Allocate SYSLIB      <-- input                           */\n\"alloc fi(syslib) da('\"dsn\"') shr reu\"\n   alloc_syslib_rc = rc\n   call check_rc alloc_syslib_rc,0,'alloc fi(syslib)'\n\n/* Allocate SYSLMOD     <-- output                          */\n\"alloc fi(syslmod) da('\"dsn\"') shr reu\"\n   alloc_syslmod_rc = rc\n   call check_rc alloc_syslmod_rc,0,'alloc fi(syslmod)'\n\n/* Allocate SYSPRINT                                        */\n\"alloc fi(sysprint) dummy reu\" /* da(*) instead of dummy    */\n   alloc_sysprint_rc = rc\n   call check_rc alloc_sysprint_rc,0,'alloc fi(sysprint)'\n\n/* Allocate SYSUT1                                          */\n\"alloc fi(sysut1) unit(vio) cyl space(2 2) reu\"\n   alloc_sysut1_rc = rc\n   call check_rc alloc_sysut1_rc,0,'alloc fi(sysut1)'\n\n/*__________________________________________________________*/\n/* Allocate SYSLIN control cards dataset.                   */\n\"allocate fi(syslin) unit(vio) reu\",\n\"lrecl(80) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\n   alloc_syslin_rc = rc\n   call check_rc alloc_syslin_rc,0,'alloc fi(syslin)'\n\n/*__________________________________________________________*/\n/* Set IEWL SYSLIN control cards.                           */\nnewstack\nqueue ' INCLUDE  -ATTR,-ALIASES,SYSLIB('member')'\n/* -ATTR:   The attributes which are copied are:                    */\n/*          AC, AMODE, DC, OL, REUS, RMODE, SSI, TEST, entry point, */\n/*          DYNAM and MIGRATABLE.                                   */\n/*                                                                  */\nqueue ' SETOPT   PARM(SSI='ssi')'\n/* SETOPT   overrides PARM and INCLUDE -ATTR                        */\n/* SETOPT   example:                                                */\n/* SETOPT   PARM(OVLY=NO,TEST=NO,OL=NO,DC=NO,EDIT,REUS=RENT,        */\n/*          SSI=01118876,AC=0,AMODE=ANY,RMODE=24,NOLONGPARM)        */\n/* Note for REUS= parameter: NONE < SERIAL < RENT < REFR            */\n/*                                                                  */\nqueue ' NAME     'member'(R)'\n\"execio \"queued()\" diskw SYSLIN (fini\"\n   SYSLIN_execio_rc = rc\n   call check_rc SYSLIN_execio_rc,0,'SYSLIN execio'\ndelstack\n\n/*__________________________________________________________*/\n/* Execute linkedit/binder.                                 */\n\n\"call *(iewl) \",\n\"'LIST,XREF'\"\n\n/*__________________________________________________________*/\n/* Clean up                                                 */\n\"free fi(syslib syslmod sysprint sysut1 syslin)\"\nexit\n\n /*_________________________________________________________________________*/\n /* Called subroutines                                                      */\n\n check_rc:\n  /* call example:    call check_rc rc,0,'libdef isptlib'                   */\n  /* In case of error:\n  ZEDMSGNO (message identifier), ZEDISMSG (short message text) and ZEDILMSG\n  */\n  if arg(1)<=arg(2) then return                        /* rc=0              */\n  if zerrmsg <> '' then address ispexec 'setmsg msg('zerrmsg')'\n  /* ISPEXEC or ISREDIT error:                                              */\n  if ZERRSM   <> 'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n  if ZERRLM   <> 'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n  if ZEDMSGNO <> 'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n  if ZEDISMSG <> 'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n  if ZEDILMSG <> 'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n  if debug='DEBUG' then\n    say 'FUNC='arg(3) 'RC='arg(1)\n  else say 'rc = 'arg(1)\n  exit arg(1)\n\n /*________________________________________________________________________*/\n show_help: procedure expose rexxname\n\n  say ' Help for 'rexxname':'\n  /* Show help between 'Help starts' and 'Help ends'                       */\n  help = 'no'\n  do i = 1 to sourceline()\n     if pos('Help starts',sourceline(i)) > 0 then do\n        help = \"yes\"\n        iterate\n     end /* if pos('Help starts',sourceline(i)) > 0                        */\n     if pos('Help ends',sourceline(i)) > 0 then leave\n     if help = 'yes' then say sourceline(i)\n  end /* do i = 1 to sourceline()                                          */\n return\n /*________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRINGS": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00e\\x00e\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 101, "newlines": 101, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n\n/* Execute strings then fold Unix commands.                 */\n/* Display printable strings folded to 72 columns.          */\n/* There is an optional parameter which indicates           */\n/* the minimum printable string length. It may be           */\n/* obtained from the Prompt field.                          */\n\n/* Example:                                                 */\n/*          VIEW      XX.YYYY.USER01.LOADLIB                */\n/*  Command ===>                                            */\n/*             Name     Prompt        Alias-of     Size     */\n/*  _________ ABCLDCN0                           000019D8   */\n/*  strings__ DEFGB790 1   <-- mimimum length  1 000035C0   */\n/*  strings__ DEFGB80D     default min length 20 00007F10   */\n\ntrace o\ndsnprint_prefix = \"XX.YYYY\" /* please change dataset high level qualifiers */\n\n/*__________________________________________________________*/\n/* Get parameters                                           */\n\nparse arg dsn atleast .\n/* atleast  optional parameter, may be obtained from prompt */\n/*          field.                                          */\n/* atleast  Display printable strings of at least           */\n/*          atleast characters.                             */\nif atleast = '' then atleast = 20 /* at least 20 char.      */\n\n/*__________________________________________________________*/\n/* Allocate STDIN.                                          */\ndsn = strip(dsn,,\"'\") /* remove quotes if any               */\n\"alloc fi(stdin) da('\"dsn\"') shr reu\"\n\n/*__________________________________________________________*/\n/* Allocate STDOUT dsnprint dataset.                        */\ntime_stamp = t!!time('s')\nparse source . . rexxname .\ndsnprint = dsnprint_prefix\".\"userid()\".\"rexxname\".\"time_stamp\n\"allocate fi(stdout) da('\"dsnprint\"') reuse\",\n\"new catalog\",\n\"lrecl(80) recfm(f b) blksize(0)\",\n\"space(1 15) tracks\"\narc = rc\nif arc > 0 then do\n   say \"STDOUT DSNPRINT allocate gave code \"arc\n   exit(12)\nend /* if arc > 0 */\n\n/*__________________________________________________________*/\n/* Initialize stem stderr.                                  */\ndrop stderr.\nstderr.0 = 0\n\n/*__________________________________________________________*/\n/* Set up env. environment variables stem.                  */\ndrop env.\n/* z/OS Unix commands in local codepage                     */\nenv.1 = \"LANG=En_US.IBM-1140\"\n/* env.1 = \"LANG=Fr_FR.IBM-1147\" */ /* locale gives LANG=C  */\nenv.0 = 1\n\n/*__________________________________________________________*/\n/* Build z/OS Unix command.                                 */\n\ncmd = \"  strings -z -n \"atleast\" | fold -w 72\"\n/* strings Only printable fields                            */\n/*  -z    Ignores the POSIX definition of a string and      */\n/*        searches for any group of printable characters    */\n/*        greater than four in length.                      */\n/*  -n    number Displays strings of printable characters   */\n/*        that are at least number characters in length.    */\n/* fold  Visualize on w columns                             */\n/*  -w    maximum line length of width characters           */\n\ncall bpxwunix cmd,'DD:STDIN','DD:STDOUT',stderr.,env.\n\n/* say 'stderr.0 = 'stderr.0                                */\n\nif stderr.0 <> 0 then /* z/OS Unix command failed           */\n   do i = 1 to stderr.0\n      say 'stderr.'i' ='stderr.i\n   end                /* z/OS Unix command failed           */\nelse do               /* z/OS Unix command succeeded        */\n\n/*__________________________________________________________*/\n/* Display DSNPRINT                                         */\n  \"ispexec lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n  \"ispexec view   dataid(\"dd1\")\"\n  \"ispexec lmfree dataid(\"dd1\")\"\n\nend                   /* z/OS Unix command succeeded        */\n\n/*__________________________________________________________*/\n/* Clean up                                                 */\n\"free fi(stdin stdout)\"\nmsgs = msg(\"off\")\naddress tso\n\"delete '\"dsnprint\"'\"\nmsgs = msg(msgs)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBBAT": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\xf7\\x00\\xf7\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:11", "lines": 247, "newlines": 247, "modlines": 0, "user": "MLEWIN"}, "text": "//BOZO01  JOB CLASS=D,MSGCLASS=S,NOTIFY=&SYSUID\n/*JOBPARM L=999999,BYTES=999999,PAGES=99999,S=*\n//*\n//* Some of the code below may be useful\n//* to send .bat files to Windows,\n//* to have them executed by a scheduled task and\n//* to return the result to z/OS.\n//*\n//*\n//* Send hello.bat to Windows server.\n//* It will be converted in Windows 1252 aka IBM-1252, cp1252.\n//* It will be executed by a periodically scheduled task\n//* and return result to sender.\n//*______________________________________________________________\n//* Remark regarding UTF-8:\n//*   FTP will not accept as input or output a RECFM=FB file\n//*   for multibyte transfer.\n//*   1 UTF-8 character = 1 to 4 bytes\n//*   1 Windows 1252 character = 1 byte\n//*   We use to download with FTP:\n//*   locsite en=mbcs mb=(IBM-1140,UTF-8) mbsendeol=crlf nordw\n//*   (en: encoding; mbcs: multibyte character set\n//*   mb: mbdataconn multi byte dataconn\n//*   mbsendeol: multibyte send end of line\n//*   crlf: carriage return, line feed, Windows end of line\n//*   nordw: no (Record Descriptor Word 4 characters before data\n//*             containing length))\n//*   With Windows FTP client:\n//*   quote site en=mbcs mb=(IBM-1140,UTF-8) mbsendeol=crlf nordw\n//*      FTP constraint:\n//*      Sending to UTF-8 or receiving from UTF-8\n//*      is a multibyte transfer.\n//*      A multibyte transfer cannot use a RECFM=FB z/OS file.\n//*      Conversion to RECFM=VB may be done with\n//*      DFSORT (FTOV) for a sequential file\n//*      LMCOPY        for a library\n//*\n//*   Alternative using BPXBATCH or (BPXWUNIX in a rexx):\n//*      cat \"//'MVSsequential'\" | iconv -f IBM-1140 -t UTF-8\n//*      then pipe the result to ftp with transfer in binary\n//*      If transfering to Windows, convert end of line LF\n//*      to CRLF.\n//*      GNU utilities (sed, awk, unix2dos)\n//*      (using the correct SET PATH)\n//*      ported on Windows from (for instance)\n//*      https://gitforwindows.org/\n//*      could be used in the periodically scheduled script\n//*      processing transmitted files.\n//*\n//*   A transmitted .bat file should begin by:\n//*   chcp 65001\n//*   which is valid only for the length of the script.\n//*   Remark: (Windows cp65001) = (z/OS IBM-1208) = UTF-8\n//*__ End of remark regarding UTF-8 _____________________________\n//*\n//       EXPORT SYMLIST=*\n//       SET WINIP='Windows_server_ip_address' please change\n//       SET BATPATH='C:\\development\\cntl\\bat'\n//*      .bat files in this directory wait for execution\n//       SET ZOSIP='zOS_ip_address'\n//       SET RESULT=&SYSUID..RESULT\n//       SET PASS='mypassword'\n//*\n//RESULT EXEC DELDEF,DSN=&RESULT\n//*\n//SUBBAT   EXEC PGM=FTP\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *,SYMBOLS=EXECSYS\n &WINIP\n &SYSUID\n &PASS\n locsite sbd=(ibm-1140,ibm-1252)\n cd &BATPATH\n put dd:bat hello.bat\n qui\n//BAT DD *,SYMBOLS=EXECSYS Content of hello.bat\nrem C functions will use temporarily the Windows 1252 codepage\nchcp 1252\necho Hello > result.txt\nrem  Upload result.txt to z/OS.\ncall :ftp result.txt\ndel result.txt\nrem  /b  Return to caller\nexit /b\nrem  _____________________________________________\n:ftp\nrem  Return %1 to z/OS\nrem  %1 is first parameter such as result.txt\nrem  EBCDIC codepage conversion only done by z/OS\nrem  Build ftp command file.\nrem  Inner parentheses to remove extra blanks at right\nrem  ^ is Windows escape character\n> ftp.txt (\n echo &SYSUID\n (echo &PASS)\n echo quote site sbd=^(ibm-1140,ibm-1252^)\n echo put %1 '&RESULT'\n echo qui\n)\nftp -s:ftp.txt &ZOSIP\nrem pause     for debugging\ndel ftp.txt\nrem  _____________________________________________\n//\n________________________________________________________\n             Scheduling Windows scripts\n1) sch_intrdr.cmd is executed once.\n     Every 10 minutes or at a specified periodicity,\n     it makes the script intrdr.cmd to execute all\n     the files with extension .bat present in a\n     specified directory.\n     The script intrdr.cmd changes, after executing\n     the .bat file, its extension .bat into .done\n2) sch_list_intrdr.cmd is executed to know the task status.\n3) sch_del_intrdr.cmd is executed to delete the task.\n\nAfter the sources of these three scheduling scripts,\nis presented the script intrdr.cmd which is executed\nevery 10 minutes.\n________________________________________________________\nContent of script sch_intrdr.cmd executed once\n________________________________________________________\n@echo off\nsetlocal\n\necho  _______________________________________________________________\necho ! Define task to execute                                        !\necho !_______________________________________________________________!\n\n\nrem Use full name for command\n\nrem Test set \"pgm=C:\\Windows\\System32\\notepad.exe\"\nrem Test set \"file=C:\\development\\cntl\\test.txt\"\nrem Test set \"this_cmd='%pgm%' '%file%'\"\n\nset \"this_cmd='C:\\development\\cntl\\intrdr.cmd'\"\necho this_cmd=%this_cmd%\n\nset \"task_name=intrdr\"\necho task_name=%task_name%\n\necho  _______________________________________________________________\necho ! Execute task every ten minutes                                !\necho !_______________________________________________________________!\n\nrem https://docs.microsoft.com/en-us/windows-server/administration\nrem         /windows-commands/schtasks\n\nrem Execute task every ten minutes, every day until deleted\nrem /sc schedule type\nrem /mo modification\nschtasks /create /tn \"%task_name%\" /tr \"%this_cmd%\" /sc minute /mo 10\n\nexit\n___________________________________________________________\nContent of script sch_list_intrdr.cmd lists the task status\n___________________________________________________________\n@echo off\nsetlocal\n\necho  _______________________________________________________________\necho ! Define task to list                                           !\necho !_______________________________________________________________!\n\nset \"task_name=intrdr\"\necho %task_name%\n\necho  _______________________________________________________________\necho ! List task                                                     !\necho !_______________________________________________________________!\n\nrem https://docs.microsoft.com/en-us/windows-server/administration\nrem         /windows-commands/schtasks\n\n\nrem  fo format\nrem  v  verbose\n\necho schtasks /query /tn \"%task_name%\" /fo list /v\nschtasks /query /tn \"%task_name%\" /fo list /v\n\nrem pause to see result\nrem Check if scheduling off battery.\npause\nendlocal\n\nexit\n\n________________________________________________________\nContent of script sch_del_intrdr.cmd delete the task\n________________________________________________________\n@echo off\nsetlocal\n\necho  _______________________________________________________________\necho ! Define task to delete                                         !\necho !_______________________________________________________________!\n\nset \"task_name=intrdr\"\necho task_name=%task_name%\n\necho  _______________________________________________________________\necho ! Delete task                                                   !\necho !_______________________________________________________________!\n\nrem https://docs.microsoft.com/en-us/windows-server/administration/\nrem         /windows-commands/schtasks\n\nrem      /f does not confirm\nschtasks /delete /tn \"%task_name%\" /f\n\npause\nendlocal\nexit\n________________________________________________________\nContent of script intrdr.cmd executed every 10 minutes.\n       Executes every .bat file in specified directory.\n       Renames the .bat files into .done after execution.\n________________________________________________________\nrem @echo off\nsetlocal enabledelayedexpansion\n\nrem %~dp0 history.txt in same directory as intrdr.cmd\necho  =================================== >> %~dp0history.txt\n\nrem   _______________________________________________________________\nrem  ! Execute each file with extension .bat in directory BAT        !\nrem  !_______________________________________________________________!\n\nset \"BATPATH=C:\\development\\cntl\\BAT\\\"\nset \"all=%BATPATH%*.bat\"\n\nfor %%f in (%all%) do (\n  echo  ___________________________________\n  echo \"Processing: %%f\"\n  rem Individual .bat files must end by exit /b to return\n  rem Execute .bat file\n  call %%f\n  rem Rename extension bat into done\n  ren \"%%~f\" *.done\n) >> %~dp0history.txt\n\nrem pause\nendlocal\nexit /b\n________________________________________________________\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\xfd\\x00\\xfd\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 253, "newlines": 253, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  /*                                                           */\n  /* Timer.                                                    */\n  /* Display every minute a small box with the numbers of      */\n  /* minutes elapsed and remaining. Terminal is locked.        */\n  /*     __ min __                                             */\n  /*    | 1    59 |                                            */\n  /*     \u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af                                             */\n  /* To halt, press Attention key two times then               */\n  /* type 'hi' (halt interpretation waiting up to 3 seconds).  */\n  /*___________________________________________________________*/\n\n  /*\n  say\n  say \"Examples of call:                                      \"\n  say \"Command ===> tso t          <-- default one hour       \"\n  say \"Command ===> tso t 7        <-- seven minutes          \"\n  say\n  */\n\n  /*___________________________________________________________*/\n  trace\n  signal on halt\n\n  parse arg min .\n  /* min is the total number of minutes to wait.               */\n  /* Leftmost three digits of min are displayed.               */\n\n  /* Check argument.                                           */\n  if min = '' then do              /* default                  */\n     min = 60 /* 1 hour default                                */\n  end /* if min = ''                                           */\n\n  parse source var\n  rexxname = word(var,3)\n  if min = '' & pos('EGG',rexxname) > 0 then min = 7\n\n  if datatype(min) <> 'NUM' then do\n     call help\n     exit\n  end /* if datatype(min) <> 'NUM'                             */\n\n  /*___________________________________________________________*/\n\n  address ispexec\n\n  call set_panel\n\n  /*\n  x = time('E')                 /* Start elapsed time counter  */\n  */\n\n  /* Show timer panel updated each minute.                     */\n  do i = 0 to min-1\n     zedsmsg = left(i,3)!!right(min-i,4)\n     \"setmsg msg(isrz000)\"\n     call display_panel\n\n     /* Sleep 60 seconds.                                      */\n     /* Check with time('E') at start and end.                 */\n     do n = 1 to 20\n        /* Wait at maximum 3 second if halted with             */\n        /* ATTN + AATN + 'hi'                                  */\n        address syscall 'sleep 3' /* sleep 3: 3 seconds        */\n     end /* do n = 1 to 20                                     */\n\n  end /* do i = 0 to min-1                                     */\n\n  /* Alarm 3 times at end                                      */\n  do k = 1 to 3\n     zedsmsg = left(i,3)!!right(min-i,4)\n     \"setmsg msg(isrz001)\"      /* alarm set                   */\n     call display_panel\n     address syscall 'sleep  1' /* sleep 1: 1 second           */\n  end /* do k = 1 to 3                                         */\n\nhalt: /* or normal exit                                        */\n\n  /*\n  elapsed = time('E')\n  say 'Temps elapsed : ' left(elapsed,pos('.',elapsed)-1) 'seconds.'\n  */\n\n  address\n  call unset_panel\n\n  exit\n/* ___________________________________________________________ */\n\nhelp:\n  say\n  say \"Examples of call:                                      \"\n  say \"Command ===> tso t       <-- default one hour          \"\n  say \"Command ===> tso t 7     <-- seven minutes             \"\n  say \"To halt, press Attention key two times then type HI.   \"\n  say\n  return\n\n  /*___________________________________________________________*/\n\ndisplay_panel:\n\n  \"control display lock\"\n  \"addpop row(1) column(49)\"\n  zwinttl = \"min\"   /* name popup windows                      */\n  \"display panel(\"panel_name\")\"\n  \"rempop\"\n\n  return\n/* ___________________________________________________________ */\nset_panel: procedure expose panel_name ddnm ispptemp\n\npanel_name = \"pnpop\"\n/* Panel starts\n)BODY WINDOW(8,1)\n\n)END\n   Panel ends */\n\naddress tso\n/* ________________________________________________________ */\n/* Allocate a temporary panel library and a member.         */\n/*__________________________________________________________*/\n\ncall set_up_prefix\nparse source var\nrexxname = word(var,3)\nddnm = \"dd\"random(1,99999)\nispptemp = prefix\".\"rexxname\".\"ispptemp\".\"ddnm\n\"alloc file(\"ddnm\") unit(sysda) reuse tracks space(1,1) dir(1)\",\n\"recfm(f b) lrecl(80) blksize(0) dsn('\"ispptemp\"(\"panel_name\")')\"\nalloc_rc = rc\n\nif alloc_rc <> 0 then do\n   say rexxnam\": allocation of temporary panel library gave code:\",\n       alloc_rc\n   msg_prev = msg('off')\n   \"free fi(\"ddnm\")\"\n   msg_off  = msg(msg_prev)     /* reset                    */\n   zispfrc = alloc_rc\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if alloc_rc <> 0                                     */\n\n/* ________________________________________________________ */\n/* Copy panel from rexx source using Unix sed command.      */\n/*__________________________________________________________*/\n\n/* for bpxwunix command codepage                            */\nlc_all = \"En_US.IBM-1140\"  /* lc_all = \"Fr_FR.IBM-1147\"     */\n\ncall set_env /* z/OS Unix environment variables             */\n\n/* ________________________________________________________ */\n/* sed input file will be rexx source in stem srcline.      */\n/*__________________________________________________________*/\n\ndrop srcline.\ndo i = 1 to sourceline(); srcline.i = sourceline(i); end\nsrcline.0 = sourceline()\n\n/* ________________________________________________________ */\n/* Extract member panel from rexx source.                   */\n/*__________________________________________________________*/\n\nregex1 = '^)BODY'          /* ^ at beginning of line        */\nregex2 = '^)END'\n\n/* Print from line with regex1 included to                  */\n/* line with regex2 included,                               */\n/* reading all input file.                                  */\n/* -n do not print                                          */\n/*  p        print                                          */\ncmd1 = \"sed -n '/\"regex1\"/,/\"regex2\"/p' \"\n\n/* Print until line with regex2 included,                   */\n/* quit after line with regex2 is printed.                  */\n/*  q        quit                                           */\ncmd2 = \"sed    '/\"regex2\"/q' \"\n\ncmd  = \"sed -n '/\"regex1\"/,/\"regex2\"/p;/\"regex2\"/q' \"\n\ncall bpxwunix cmd,srcline.,\"dd:\"ddnm,stderr.,env.\ncall print_stderr /* check for errors                       */\n\ndrop srcline. stderr.\n\n/* ________________________________________________________ */\n/* Libdef                                                   */\n/*__________________________________________________________*/\n\naddress ispexec  \"libdef ispplib library id(\",\n                 ddnm,\n                 \") stack\"\nlibdef_rc = rc\nif libdef_rc > 0 then do\n   say rexxname\": libdef ispplib rc = \"libdef_rc\n   zispfrc = libdef_rc\n   address ispexec 'vput zispfrc'\n   exit zispfrc\nend /* if libdef_rc > 0                                     */\nreturn\n\n/*__________________________________________________________*/\n\nunset_panel: procedure expose ddnm ispptemp\n\naddress ispexec \"libdef ispplib\"\nmsg_prev = msg('off')\n  \"free fi(\"ddnm\")\"\n  \"del '\"ispptemp\"'\"\nmsg_off  = msg(msg_prev)     /* reset                       */\n\nreturn\n\n/*__________________________________________________________*/\n/*                                                          */\nset_env:\n\nenv.0 = 3\nenv.1 = \"PATH=.:/bin:usr/local/bin\"\nenv.2 = \"LC_ALL=\"lc_all\nenv.3 = \"_BPX_SHAREAS=MUST\" /* ddname friendly, e.g. cat DD:DD01 */\n                            /* cat \"dd:dd01(mbr)\"                */\n\nreturn\n/*__________________________________________________________*/\n/*                                                          */\nprint_stderr: procedure expose stderr.\n\nif datatype(stderr.0) = 'NUM' then do\n   if stderr.0 > 0 then do\n      queue\n      do i = 1 to stderr.0\n         queue 'stderr.'i' = 'stderr.i\n      end /* do i = 1 to stderr.0                           */\n   end /* if stderr.0 > 0                                   */\nend /* if datatype(stderr.0) = 'NUM                         */\n\nreturn\n/*__________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n/*__________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TALLYCH": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:11", "lines": 26, "newlines": 26, "modlines": 0, "user": "MLEWIN"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TO": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 160, "newlines": 160, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n trace o\n /*___________________________________________________________*/\n \"isredit macro (cmd)\"   /* no underline in-between parents   */\n\n cp = 'IBM-1140'         /* US codepage                       */\n /* cp = 'IBM-1147' */   /* French codepage                   */\n\n /* Convert from codepage to codepage.                        */\n /* Input:  file on which the edit macro is executed.         */\n /* Output: Temporary file with converted code                */\n /*         (may be copied on a permanent file).              */\n /* Examples: Command ===> TO IBM-1047 FROM IBM-1147          */\n /*           Command ===> FROM IBM-1147 TO IBM-1047          */\n /*           Command ===> TO               uses default      */\n /*           Command ===> TO LIST    list possible codepages */\n /* There are two EDIT macros: FROM and TO with exactly       */\n /*           the same code.                                  */\n /*___________________________________________________________*/\n /*                                                           */\n\n address isredit\n isr_rc = rc\n if isr_rc <> 0 then do /* rexx                               */\n    say 'Error. Must be used as an edit macro'\n    exit 12\n end /* isr_rc <> 0                                           */\n\n \"(dsn0) = dataset\"\n \"(mbr)  = member\"\n if mbr <> '' then dsn = dsn0'('mbr')'\n              else dsn = dsn0 /* sequential                   */\n\n /* Build Unix iconv command.                                 */\n\n upper cmd                   /* in uppercase                  */\n\n /* Remove leading and trailing quotes or apostophes          */\n /* if both exist simultaneously.                             */\n cmd = strip(cmd)            /* remove blanks from both sides */\n if left(cmd,1) = \"'\" then cmd = strip(cmd,,\"'\")\n if left(cmd,1) = '\"' then cmd = strip(cmd,,'\"')\n\n call get_rexxname_and_choose_default_codepages\n\n select /* according to rexxname                              */\n   when rexxname = 'TO' then do\n      parse var cmd to 'FROM' from\n      other = 'FROM'\n   end /* when rexxname = 'TO'                                */\n   when rexxname = 'FROM' then do\n      parse var cmd from 'TO' to\n      other = 'TO'\n   end /* when rexxname = 'FROM'                              */\n   otherwise nop\n end /* select                                                */\n\n /* Assign defaults if necessary.                             */\n if from = '' then from = from_default\n if to   = '' then to   = to_default\n unix_cmd = 'iconv -f 'from' -t 'to\n\n /* If request for help:                                      */\n if (left(cmd,1) = 'H'  )!,     /* e.g. Command ===> TO Help  */\n    (left(cmd,2) = '-H' )!,     /* e.g. Command ===> TO -H    */\n    (left(cmd,4) = 'LIST')!,    /* e.g. Command ===> TO List  */\n    (words(cmd) = 1 & word(cmd,1) = rexxname) then do\n    say '___________________________________________________'\n    say\n    say 'Syntax:'\n    say 'Command ===> 'rexxname' codepage 'other' codepage'\n    say 'Examples:'\n    say 'Command ===> 'rexxname' IBM-1047'\n    say 'Default missing codepage: from 'cp\n    say '                          to   z/OS Unix IBM-1047'\n    say 'Command ===> 'rexxname' 'other' IBM-1147'\n    say 'Command ===> 'rexxname' help'\n    say 'Usual codepages:'\n    say 'IBM-1147 French with Euro sign'\n    say 'IBM-1047 z/OS Unix international'\n    say 'IBM-1140 USA, COBOL default codepage'\n    say 'IBM-1208 UTF-8'\n    say 'IBM-1200 UTF-16BE (Big Endian) National in COBOL'\n    say 'Possible codepages in the following list.'\n    say '___________________________________________________'\n    say\n    unix_cmd = 'iconv -l' /* list possible codepages          */\n end /* request for help                                      */\n\n /* Signal to UNIX edit macro if it needs to build a large LRECL        */\n /* STDOUT file.                                                        */\n wp = wordpos('iconv',unix_cmd)  /* is 'iconv' present in unix_cmd?     */\n if wp > 0 then do          /* check for non EBCDIC codepage            */\n    tocp = word(unix_cmd,wp + 4) /* obtain to codepage tocp             */\n    /* remove ; from to codepage, if present                            */\n    if right(tocp,1) = ';' then tocp = left(tocp,length(tocp)-1)\n    parse var tocp . '-' tocp /* part at right of dash if present       */\n    /* Cf. https://en.wikipedia.org/wiki/EBCDIC_code_pages              */\n    /*           List of EBCDIC codepages                               */\n    /*           Unix USA  DE   NO   SW   IT   SP   UK   FR   INTL IS   */\n    ebcdic_cp = '1047 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149'\n    if wordpos(tocp,ebcdic_cp) > 0 then ebcdic_output = 'YES'\n                                   else ebcdic_output = 'NO'\n end /* if wordpos('iconv',unix_cmd) > 0                                */\n /* Signal to UNIX edit macro a large LRECL STDOUT file.                */\n /* The UNIX edit macro will check if the string \"large output\"         */\n /* is present in unix_cmd.                                             */\n /* Postpend \"large output\" to unix_cmd.                                */\n if ebcdic_output = 'NO' then do\n    unix_cmd = unix_cmd\" large output\"\n end /* if ebcdic_output = 'NO'                                         */\n /* End of signal to UNIX edit macro if it needs to build a large LRECL */\n\n /* End of build Unix iconv command.                                    */\n\n address ispexec\n 'control errors return'\n\n /* Specialized cmd for UNIX macro edit                       */\n mymacro = 'unix'\n \"view dataset('\"dsn\"') macro(\"mymacro\")\",\n       \"parm(unix_cmd)\"\n\n /* ISPEXEC or ISREDIT error:                                 */\n if ZERRSM   <>'ZERRSM'   then say 'ZERRSM   = 'ZERRSM\n if ZERRLM   <>'ZERRLM'   then say 'ZERRLM   = 'ZERRLM\n if ZEDMSGNO <>'ZEDMSGNO' then say 'ZEDMSGNO = 'ZEDMSGNO\n if ZEDISMSG <>'ZEDISMSG' then say 'ZEDISMSG = 'ZEDISMSG\n if ZEDILMSG <>'ZEDILMSG' then say 'ZEDILMSG = 'ZEDILMSG\n\n address    /* resume previous environment                    */\n\n 'end'\n exit\n /*___________________________________________________________*/\n get_rexxname_and_choose_default_codepages:\n\n /* rexxname is third word in parse source result.            */\n /* Choose default codepages according to environment         */\n /* (eighth word in parse source result).                     */\n\n parse source var\n rexxname = word(var,3)\n if word(var,8) <> 'OMVS' then do /*       not z/OS Unix      */\n    from_default = cp\n    to_default   = 'IBM-1047'     /* default z/OS Unix int'l  */\n end /* if word(var,8) <> 'OMVS'     not z/OS Unix            */\n else do                          /*     z/OS Unix            */\n\n    path_string = translate(rexxname,' ','/')\n    rexxname = word(path_string,words(path_string))\n    p = pos('.',rexxname)    /* remove extension, if present  */\n    if p > 0 then rexxname = substr(rexxname,1,p-1)\n    upper rexxname\n\n    to_default   = cp\n    from_default = 'IBM-1047'     /* default z/OS Unix int'l  */\n end                              /*     z/OS Unix            */\n return\n /*___________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "U": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x01\\xec\\x01\\xec\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 492, "newlines": 492, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\n/*________________________________________________________________*/\n/*                                                                */\n/* Edit macro executing a z/OS Unix command.                      */\n/*________________________________________________________________*/\n\n\n/*________________________________________________________________*/\n/*                                                                */\n/* Help starts                                                    */\n/* u is an edit macro executing a z/OS Unix command.              */\n/*                                                                */\n/* Input to the z/OS Unix command is the                          */\n/* presently edited file.                                         */\n/* The result of the z/OS Unix command, if not empty,             */\n/* replaces the presently edited file,                            */\n/* unless a supplementary keyword 'info' is added .               */\n/* If 'info' is added to the Unix command (anywhere)              */\n/* the result of the Unix command is placed into infolines.       */\n/*                                                                */\n/* The user may cancel the result with:                           */\n/* Command ===> can                                               */\n/* or restore the previous content of a library member with:      */\n/* Command ===> u r  (or u re, u res, u rest etc... or u u)       */\n/* or save the result.                                            */\n/*                                                                */\n/* If the word 'info', in mixed case, does not appear at right    */\n/* of u, then edit macro u by default, saves the previous content */\n/* of a non empty edited library member in another member         */\n/* called 'SAVEU' before replacing this member                    */\n/* by the result of an Unix command.                              */\n/*                                                                */\n/* If keyword 'info', in mixed case, is placed anywhere after u,  */\n/* then the result of an Unix command                             */\n/* does not replace the content but is added                      */\n/* at top of member or sequential file, as infolines.             */\n/* These infolines may be deleted with RES or made datalines with */\n/* line commands MD and MDD.                                      */\n/* The previous content is unchanged and saved in member 'SAVEU'. */\n/*                                                                */\n/* Examples of use in View or Edit:                               */\n/*                                                                */\n/* Command ===> u           (or u help)        <- shows help      */\n/* Command ===> u u         (or u r or u re)   <- restore         */\n/* Command ===> u cut -c 1-10                  <- first 10 char   */\n/* Command ===> u cut -c 1-10,12-              <- col 11 disappears */\n/* Command ===> u sed 's/A.*b/DEF/g'           <- case sensitive  */\n/* Command ===> u iconv -f 1047 -t 1147        <- Unix to French  */\n/* Command ===> u awk '{print $1}'             <- Keep 1st field  */\n/* Command ===> u cal 2020                     <- all year        */\n/* Command ===> u cal sep 1752                 <- missing days    */\n/* Command ===> u man sed                                         */\n/* Command ===> u man sed | cut -c 1-80                           */\n/* Command ===> zexpand                                           */\n/*     u cat \"//'BOZO.CNTL(HAYSTACK)'\" | grep -E 'N.*dle'         */\n/* Command ===> u cut -c 1-10 info   <- infolines, no replacement */\n/* Command ===> u info cut -c 1-10   <- infolines, no replacement */\n/* Command ===> u man woman info     <- infolines, no replacement */\n/* Command ===> u ls -al oedit       <- oedit temporary result    */\n/* Command ===> u oedit man awk      <- oedit temporary result    */\n/* oedit is used for long output lines and u may be reissued.     */\n/* Non empty temporary result replaces member or sequential file. */\n/* Command ===> can                  <- not to SAVE u's result    */\n/* Command ===> u s (or u sa, u sav) <- explicit save in 'SAVEU'  */\n/* edit macro u used to process z/OS Unix commands in member:     */\n/*            BOZO.CNTL(A)                                        */\n/* Command ===> u sh                  or ===> u sh info           */\n/* ****** *********************                                   */\n/* 000001 whoami                                                  */\n/* 000002 pwd                                                     */\n/* 000003 printenv                                                */\n/* ****** *********************                                   */\n/* Help ends                                                      */\n/*________________________________________________________________*/\n/*                                                                */\n\n/* for bpxwunix command codepage:                                 */\nlc_all = \"En_US.IBM-1140\"  /* lc_all = \"Fr_FR.IBM-1147\"           */\nparse source . . rexxname .    /* rexxname in upper case          */\n\naddress isredit\n'macro (parm)' /* parm may be up to 200 characters in mixed case  */\ncall check_parm                /* for help                        */\n\n/* SAVE or RESTORE                                                */\nW1 = translate(word(parm,1))\n/* If first word of parm translated to uppercase begins by 'S'    */\n   if abbrev('SAVE',W1,1)    then do /* explicit save             */\n      call save\n      exit 0\n   end /* if abbrev('SAVE',W1,1)        explicit save             */\n/* If first word of parm translated to uppercase begins by 'R'    */\n/* or is rexxname (Command ===> u u) then restore                 */\n   if abbrev('RESTORE',W1,1) !,      /* or                        */\n      W1 = rexxname          then do /* restore                   */\n      call restore\n      exit 0\n   end /* if abbrev('RESTORE',W1,1)           restore             */\n\n/* Set up z/OS Unix command to execute:                           */\n/* temp is a temporary file in /tmp                               */\n/* /tmp is normally automatically cleaned.                        */\n/* It will be copied to replace the presently edited file         */\n/* then deleted (not moved to avoid a possible confirmation       */\n/* panel).                                                        */\ntemp = '/tmp/temp'random(1,99999)  /* temporary file              */\nif info = \"no\"\n   /* Use of temp file is possibly faster than using stem stdout. */\n   /* We use stem stdout. only when infolines have to be created. */\n   then cmd = parm '>' temp /* redirect standard output to temp   */\n   else cmd = parm          /* stdout. to be written as infolines */\n/* Copy content of presently edited file into stack.              */\ntrace_previous = trace(\"o\") /* no trace                           */\n'(last) = linenum .zl'\ndrop line.\ndo i = 1 to last\n   '(li)  = line 'i\n   line.i = li\nend /* do i = 1 to last                                           */\nline.0 = last\ntrace(trace_previous)\n\n/* Issue z/OS unix command.                                       */\ncall set_env /* z/OS Unix environment variables                   */\ndrop stderr.; stderr.0 = 0    /* initialize standard error stem   */\ndrop stdout.; stdout.0 = 0    /* used only if info = \"yes\"        */\ncall bpxwunix cmd,line.,stdout.,stderr.,env.\nbpxwunix_rc = rc\n\ncall check_for_error\ndrop line. stderr.\n\ncall save      /* save of a library member in member 'SAVEU'      */\n\nif info = \"no\" then do /* no word 'info' after u, default case    */\n\n   /* Using oedit: Command ===> u cal 2020 oedit                  */\n   /* Content of member not replaced if temp made empty with oedit */\n   if oedit = \"yes\" then address tso \"oedit '\"temp\"'\"\n\n   member_replaced = \"no\"\n   if size(temp) > 0 then do\n      /* Remove all file content.                                 */\n      'del all .zf .zl'\n\n      /* Copy temporary file then delete it.                      */\n      'copy 'temp after .zf\n      member_replaced = \"yes\"\n      call delete_temp_file\n   end /* if size(temp) > 0                                       */\n\nend /* if info = \"no\"      no word 'info' after u, default case   */\nelse do /* info = \"yes\"    word 'info' after u                    */\n\n   /* Insert stdout. as infolines at top of edited member or      */\n   /* sequential file.                                            */\n   do i = stdout.0 to 1 by -1\n      stdout = stdout.i\n      'line_after 0 = infoline (stdout)'\n   end /* do i = stdout.0 to 1 by -1                              */\n   drop stdout.\n\nend     /* info = \"yes\"    word 'info' after u                    */\n\n'(member) = member'         /* Check if editing a library member. */\nif member <> '' &,          /* library member                     */\n   member_replaced = \"yes\" then do\n   zedsmsg = 'u u <- to restore'   /* top right corner            */\n   zedlmsg = 'You may issue Command ===> can or Command ===> save',\n             'or Command ===> u restore'\nend /* if member <> '' and replaced                               */\nelse do /* not a library member                                   */\n   zedsmsg = ''\n   zedlmsg = ''\nend     /* not a library member                                   */\naddress ispexec \"setmsg msg(isrz000)\"\n\nexit 0\n/*________________________________________________________________*/\n/*                                                                */\ncheck_parm:\n\n/* Check for special keywords: HELP, OEDIT, INFO                  */\n/* OEDIT: oedit the temporary file temp.                          */\n/*        if this file made empty, no change to edited member.    */\n/* INFO : Do not create a temporary file.                         */\n/*        stdout. written at top edited member as infolines.      */\n\nupper_parm = translate(parm) /* parm in uppercase                 */\nW1 = word(upper_parm,1)      /* first word of upper_parm          */\nif W1 = ''      !,     /* no parm or first word in list           */\n   wordpos(W1,'HELP -H --HELP ? /H') > 0 !, /* or 'HELP somewhere */\n   wordpos('HELP',upper_parm) > 0  then do\n     call show_help\n     exit 0\nend /* if help needed                                             */\n\noedit = 'no' /* Shall we oedit the temporary file?                */\n             /* If empty, it will not replace the edited member.  */\nk = wordpos('OEDIT',upper_parm)\nif k > 0 then do /* oedit present in parm                         */\n   oedit = \"yes\"\n   parm = delword(parm,k,1)  /* remove oedit from parm            */\nend /* oedit present in parm                                      */\n\ninfo = 'no' /* Is string 'info' in mixed case, present in parm?   */\n            /* If yes, sandard output is placed at top of edited  */\n            /* member as infolines, and                           */\n            /* edited member is not saved and not changed.        */\n            /* If string 'info' in mixed case, is not present     */\n            /* in parm then edited member is saved and replaced.  */\n/* Default behavior is to save and replace.                       */\n/* We should add 'info' not to (save and replace).                */\nk = wordpos('INFO',upper_parm)\nif k > 0 then do /* info present in parm                          */\n   info = \"yes\"\n   parm = delword(parm,k,1)  /* remove info from parm             */\nend /* info present in parm                                       */\n\nreturn\n/*________________________________________________________________*/\n/*                                                                */\nset_env:\n\nenv.0 = 3\nenv.1 = \"PATH=.:/bin:usr/local/bin\"\nenv.2 = \"LC_ALL=\"lc_all\nenv.3 = \"_BPX_SHAREAS=MUST\" /* ddname friendly, e.g. cat DD:DD01  */\n                            /* awk ... < cat \"dd:dd01(mbr)\"       */\n\nreturn\n/*________________________________________________________________*/\n/*                                                                */\ncheck_for_error: procedure expose rexxname bpxwunix_rc stderr. env. temp\n\n  if stderr.0 > 0 then do /* stderr.0 was expected                */\n     say rexxname\": Execution of 'cmd' failed.\"\n     /* For debug:\n     do i = 1 to stderr.0\n        say 'stderr.'i' = 'stderr.i\n     end /* do i = 1 to stderr.0                                  */\n     */\n     /* Insert stderr. as infolines at top of edited member or    */\n     /* sequential file.                                          */\n     do i = stderr.0 to 1 by -1\n        stderr = stderr.i\n        'line_after 0 = infoline (stderr)'\n     end /* do i = stderr.0 to 1 by -1                            */\n\n     if info = \"no\" then call delete_temp_file\n\n     zispfrc = 16\n     address ispexec 'vput zispfrc'\n     exit zispfrc\n  end /* if stderr.0 > 0, stderr.0 was expected                   */\n\nreturn\n/*________________________________________________________________*/\n/*                                                                */\ndelete_temp_file: procedure expose env. temp\n\n  drop stderr2.; stderr2.0 = 0\n  cmd2 = 'rm 'temp /* remove temporary file                       */\n  call bpxwunix cmd2,,,stderr2.,env.\n     do i = 1 to stderr2.0 /* stderr2.0 is expected               */\n        say 'stderr2.'i' = 'stderr2.i\n     end /* do i = 1 to stderr2.0                                 */\n  drop env.\n\nreturn\n/*________________________________________________________________*/\n/*                                                                */\nsave:\n\n  /* If a library member, save it in member 'SAVEU'               */\n  address isredit\n    '(member) = member'\n    'isredit (recs) = linenum .zl'   /* recs is total line number */\n    if member <> '' & recs <> 0 then do\n       save_member = 'SAVE'strip(left(rexxname,2))\n       /* if rexxname = 'U' then save_member = 'SAVEU'            */\n       'repl ('save_member') .zf .zl' /* create if does not exist */\n       zedsmsg = member' saved in 'save_member\n       /*         ----+----1----+----2----   zedsmsg max 24 char  */\n       zedlmsg = 'Backup copy created in member 'save_member'.'\n    end /* if member <> '' and is non empty                       */\n    else do /* file edited not a library member                   */\n       zedsmsg = 'Only for non empty mbr'\n       zedlmsg = 'Save command available only to save',\n                 'a non empty library member.'\n    end /* file edited not a library member                       */\n  address /* from isredit                                         */\n\n  address ispexec \"setmsg msg(isrz000)\"\n\nreturn\n/*________________________________________________________________*/\n/*                                                                */\nrestore:\n\n  /* If a library member, restore it from member 'SAVEU'.         */\n  address isredit\n    '(member) = member'\n    if member <> '' then do\n       save_member = 'SAVE'strip(left(rexxname,2))\n       /* if rexxname = 'U' then save_member = 'SAVEU'            */\n       'del all .zf .zl' /* delete all present content            */\n       'copy ('save_member') after .zf'  /* restore               */\n       zedsmsg = 'Member restored'\n       /*         ----+----1----+----2----   zedsmsg max 24 char  */\n       zedlmsg = 'Member restored from backup copy 'save_member\n    end /* if member <> ''                                        */\n    else do /* file edited not a library member                   */\n       zedsmsg = 'Only for member'\n       zedlmsg = 'Restore command available only to restore',\n                 'a library member.'\n    end /* file edited not a library member                       */\n  address /* from isredit                                         */\n\n  address ispexec \"setmsg msg(isrz000)\"\n\nreturn\n/*________________________________________________________________*/\n\nsize:\n/* Size in bytes of a regular file.                    */\n/* -1 if unknown, 0 if empty                           */\n/* Example of call:                                    */\n/*   temp = '/u/bozo/test01.txt'                       */\n/*   size = size(temp)                                 */\nparse arg path\n\n/* call syscalls 'ON' */\nparse source . . . . . . envir .\n/* envir: host command environment                     */\nif envir <> 'SH' then\n   if syscalls('ON') > 3 then\n      do\n      say 'Unable to establish the SYSCALL environment'\n      say 'Return code : 'rc\n      return -1      /* -1: cannot obtain size         */\n      end\n\naddress syscall\n  syscmd ='stat (path) st.'\n  syscmd /* execute *                                  */\n  syscmd_rc = rc\n  call syscall_rc /* will return ok or nok             */\naddress /* from syscall                                */\n\nif ok & st.0 <> 0 then ret = st.st_size\n                  else ret = -1\nreturn ret\n\n/*_____________________________________________________*/\nsyscall_rc: procedure expose syscmd syscmd_rc retval errno errnojr,\n                             ok nok /* <- output       */\n\nnok = syscmd_rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0)\nok  = 1 - nok            /* ok  boolean, 1 if true     */\n\nif nok then do\n   say 'syscall command = 'syscmd\n   say\n\n   /* not_OK information string                        */\n   not_OK = '(rc<>0 ! retval<0 ! retval=0 & (errno<>0 ! errnojr<>0))'\n   say 'not_OK = 'not_OK\n\n   say 'syscall rc                   =  'syscmd_rc\n   say 'syscall return value retval  = 'retval\n   say 'syscall return code  errno   = 'errno\n   say 'syscall reason code  errnojr = 'errnojr\n\n   'strerror' errno errnojr 'err.' /* address syscall propagated */\n   /* if rc=0 & retval>=0 then do                      */\n   if datatype(err.0) = 'NUM' then\n      if err.0 > 0 then do\n         if err.se_errno  <> '' & err.se_errno  <> 'ERR.SE_ERRNO'  then\n            say '   errno   : 'err.se_errno\n         if err.se_reason <> '' & err.se_reason <> 'ERR.SE_REASON' then\n            say '   errnojr : 'err.se_reason\n         if err.se_action <> '' & err.se_action <> 'ERR.SE_ACTION' then\n            say '   action  : 'err.se_action\n      end /* if err.0 > 0                              */\n   say\nend /* if nok                                          */\n\nreturn\n/*___________________________________________________________________*/\n\nshow_help:\n\n say ' Help for 'rexxname':'\n /* Show help between 'Help starts' and 'Help ends'                  */\n help = 'no'\n line_counter = 0\n do i = 1 to sourceline()\n    if pos('Help starts',sourceline(i)) > 0 then do\n       help = \"yes\"\n       iterate\n    end /* if pos('Help starts',sourceline(i)) > 0                   */\n    if pos('Help ends',sourceline(i)) > 0 then leave\n    if help = 'yes' then do /* record sourceline(i)                  */\n       line_counter = line_counter + 1\n       line.line_counter = sourceline(i)\n    end /* if help = 'yes'                                           */\n end /* do i = 1 to sourceline()                                     */\n line.0 = line_counter\n call visualize\nreturn\n/*___________________________________________________________________*/\n\n visualize: procedure expose line. rexxname\n /* Visualize.                                                */\n if line.0 > 0 then do\n    if sysvar(sysispf) <> 'ACTIVE' then do\n       do i = 1 to line.0\n          say line.i\n       end /* do i = 1 to line.0                              */\n       zispfrc = 0\n       exit zispfrc\n    end /* if sysvar(sysispf) <> 'ACTIVE'                     */\n    else do /*       ispf ACTIVE                              */\n\n       /* Allocate visualization file.                        */\n       address tso\n       ran  = right(random(1,99999),5,'0')\n       ddnm = 'dd'ran                          /* choose random ddname */\n       call set_up_prefix /* create prefix for new file                */\n       dsnprint = prefix\".\"rexxname\".R\"ran\n       msg_prev = msg('off')\n       \"alloc file(\"ddnm\") da('\"dsnprint\"') new catalog\",\n       \"tracks space(5,5) reuse lrecl(132) recfm(f b) blksize(0)\"\n       alloc_rc = rc\n       if alloc_rc <> 0 then do\n          say rexxname \"could not allocate the visualization file.\"\n          say \"We exit with code 16.\"\n          say \"alloc rc = \"alloc_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if alloc_rc <> 0                                */\n       msg_off  = msg(msg_prev)\n       /* End of allocate visualization file.                 */\n\n       /* Write on visualization file.                        */\n       \"execio\" line.0  \"diskw\" ddnm \"(stem line. finis\"\n       execio_rc = rc\n       if execio_rc <> 0 then do\n          say rexxname \"could not write on visualization file.\"\n          say \"We exit with code 16.\"\n          say \"execio rc = \"execio_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if execio_rc <> 0                               */\n       /* End of write on visualization file.                 */\n\n       /* Visualize.                                          */\n       zedsmsg = 'F3 to exit'  /* top right corner            */\n       zedlmsg = 'To exit, press F3.',\n                 'Temporary help file will be deleted.'\n       ispexec \"setmsg msg(isrz000)\"\n       ispexec \"view dataset('\"dsnprint\"')\"\n       /* End of visualize.                                   */\n\n       /* Clean up.                                           */\n       msg_prev = msg('off')\n          \"free fi(\"ddnm\")\"\n          \"del  '\"dsnprint\"'\"\n       msg_off  = msg(msg_prev)     /* reset                  */\n       /* End of clean up.                                    */\n\n    end /* ispf ACTIVE                                        */\n end /* if line.0 > 0                                         */\n\n return\n /*___________________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNIX": {"ttr": 4876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x01y\\x01y\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 377, "newlines": 377, "modlines": 0, "user": "MLEWIN"}, "text": " /* rexx */\n trace o\n\n dsnprint_prefix = \"XX.YYYY\" /* please change dataset high level qualifiers */\n\n lc_all = \"En_US.IBM-1140\"        /* locale                                */\n /* lc_all = \"Fr_FR.IBM-1147\" */\n /* Google search with:  \"Compiled locales\" inurl:IBM                      */\n /*       En_US.IBM-1140 IBM-1140 is default COBOL codepage                */\n /*       Unix USA  DE   NO   SW   IT   SP   UK   FR   INTL IS             */\n /*       1047 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149           */\n\n parse source . . rexxname . /* rexxname in upper case                     */\n /*  Help starts                                                           */\n /*________________________________________________________________________*/\n /*                                                                        */\n /*  rexx and macro edit.                                                  */\n /*  Executes BPXWUNIX.                                                    */\n\n /*  If used as an edit macro,                                             */\n /*     1) all the parameters constitute the Unix command, and             */\n /*     2) the edited member or file is used as STDIN.                     */\n\n /*  If used as a rexx,                                                    */\n /*  if the last parameter is a valid dsn or dsn(mbr) then                 */\n /*     1) the last parameter is used for STDIN and                        */\n /*     2) only the previous parameters constitute the Unix command.       */\n /*  otherwise all parameters constitute the Unix command.                 */\n\n /*  Thus, in View, edit macro unix invokation:                            */\n /*  Command ===> unix grep -E 'ab.c'                                      */\n /*  will obtain the dsname and member name and have bpxwunix              */\n /*  execute with command                                                  */\n /*  grep -E 'ab.c'                                                        */\n /*  and dsname(member) as standard input.                                 */\n /*  Command ===> unix cal                                                 */\n\n /* Examples of rexx use:                                                  */\n /* Command ===> cmde      to preserve lower case options and regex        */\n /* Enter TSO commands below:                                              */\n /* ===> unix cal                                                          */\n /* ===> unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(grep05)               */\n /* ===> viewit unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(grep05)        */\n /* ===> viewit forallm unix grep -E  'ar *g\\(|upp[ef]' userid.TEST(*)     */\n /*  viewit forallm unix grep -E -n 'cmd' noview userid.TEST(*)            */\n /*  viewit foralld forallm unix grep -E -n 'cmd' noview userid.T*S%(*)    */\n /* Remark:                                                                */\n /* Command ===> epdf /    then   man grep for choice of options.          */\n\n /* Example of batch use:                                                  */\n /*                                                                        */\n /*  //TSOSH    EXEC PGM=IKJEFT1B                                          */\n /*  //SYSTSPRT DD SYSOUT=*                                                */\n /*  //SYSTSIN  DD *                                                       */\n /*  unix cd /tmp; dd:tsosh arg1 arg2                                      */\n /*  //* dd:tsoh replaced by a temporary file in /tmp, thereafter removed  */*/\n /*  //SYSEXEC  DD DISP=SHR,DSN=XXXXXX.TEST  Contains UNIX rexx            */\n /*  //TSOSH    DD *,DLM=EOF                                               */\n /*  /*    rexx  Needed: / in column 1 and * in column 2 on first line */  */\n /*  /*                  rexx is first word in comment on first line.  */  */\n /*   trace r                                                              */\n /*   parse arg therest                                                    */\n /*   say \"therest = \"therest                                              */\n /*   say \"abc\"                                                            */\n /*   'cal' /* implicit address sh under z/OS Unix */                      */\n /*   exit                                                                 */\n /*  EOF                                                                   */\n /*________________________________________________________________________*/\n /*  Help ends                                                             */\n /*                                                                        */\n /* Extract Unix command and dsn.                                          */\n\n address isredit /* Am I an edit macro?                                    */\n \"macro (cmd)\"   /* cmd in mixed case                                      */\n isr_rc = rc\n\n if isr_rc = 0 then do /* edit macro                                       */\n    call is_help_needed\n    \"(dsn0) = dataset\"\n    \"(mbr)  = member\"\n    if mbr <> '' then dsn = dsn0'('mbr')'\n                 else dsn = dsn0 /* sequential                             */\n    address            /* resume previous environment                      */\n end /* isr_rc = 0        edit macro                                       */\n\n else do               /* rexx, arg(1) contains dsn(mbr) at end            */\n\n    cmd   = arg(1)                        /* all parameters                */\n    call is_help_needed\n\n    w     = words(arg(1))                 /* number of parameters          */\n    cmd   = subword(arg(1),1,w-1)         /* all but last parameter        */\n    dsn   = word(arg(1),w)                /* last parameter                */\n    upper dsn\n    dsn = strip(dsn,,\"'\")                 /* remove quotes if any          */\n    /* Check dsn                                                           */\n    msgs = msg(\"off\")\n       libelle = sysdsn(\"'\"dsn\"'\")\n    msgs = msg(msgs)\n    if libelle <> 'OK' then do\n       dsn = ''      /* Assume last parm is not a dsname                   */\n       cmd = arg(1)  /* Command made up of all parameters                  */\n    end /* if sysdsn(\"'\"dsn\"'\") <> 'OK'                                    */\n end                   /* rexx                                             */\n\n /* Change all 'xx:' in 'DD:' in cmd where x is lower or upper case d.     */\n call ovall 'dd:' 'DD:' cmd\n cmd = result\n call ovall 'dd=' 'DD:' cmd\n cmd = result\n\n /* Change all 'DD:' in cmd into a temporary file to be removed at end     */\n p = pos('DD:',cmd)\n do while p > 0               /* while 'DD:' present                       */\n\n    indd = word(substr(cmd,p+3),1)\n    address tso\n\n    /* Define executable tempfile.                                         */\n    tempfile = 'temp-'date('s')'-'space(translate(time(),'',':'),0)\n    tempfile = \"/tmp/\"userid()\"-\"tempfile   /* full path                   */\n    \"alloc fi(outdd) path('\"tempfile\"')\",\n           \"pathmode(sirwxu,sixgrp,sirgrp) pathopts(ocreat, owronly) reu\"\n    allocrc = rc\n    if allocrc <> 0 then do\n       say \"Alloc tempfile = \"tempfile\" return code is: \"allocrc\".\",\n           \"Do not process.\"\n       zispfrc = 16\n       signal fin\n    end /* if allocrc <> 0                                                 */\n    /* relfile is relative file of tempfile in /tmp                        */\n    relfile = substr(tempfile,pos('/',tempfile,2)+1) /* after second '/'   */\n\n    \"ocopy indd(\"indd\") outdd(outdd)\"  /* text default                     */\n    ocopyrc = rc\n    if ocopyrc <> 0 then do\n       say \"ocopy return code is: \"ocopyrc\".\",\n           \"Do not process.\"\n       zispfrc = 16\n       signal fin\n    end /* if ocopyrc <> 0                                                 */\n    address\n\n    /* Replace 'DD:' by tempfile, remove tempfile at end.                  */\n    parse var cmd head 'DD:' tail\n    tail = ' 'subword(tail,2)        /* past ddname                        */\n    cmd = head!!relfile!!tail'; rm 'relfile\n\n    p = pos('DD:',cmd)\n end /* do while p > 0                                                     */\n\n if dsn <> '' then say dsn\" is processed.\"\n\n say\n /* End of extract Unix command and dsn.                                   */\n /*________________________________________________________________________*/\n /*                                                                        */\n /* Execute command with bpxwunix                                          */\n\n address tso\n\n drop stderr. env.\n stderr.0 = 0\n\n /* z/OS Unix commands in IBM-1147 French codepage                         */\n /* Cf. z/OS XL C/C++ Programming Guide >                                  */\n /*     Locales supplied with z/OS XL C/C++ >                              */\n /*     Compiled locales                                                   */\n env.1 = \"LC_ALL=\"lc_all\n /* env.1 = \"LC_ALL=Fr_FR.IBM-1147\"         locale gives LANG=C            */\n /* env.1 = \"LANG=Fr_FR.IBM-1147\"           works as well                  */\n env.2 = \"PATH=/bin:.:/usr/local/bin:/tmp\"\n env.0 = 2\n\n /* Second parameter is standard input.                                    */\n if dsn <> '' then do\n    \"alloc fi(STDIN) da('\"dsn\"') shr reu\"\n    allocrc = rc\n    if allocrc <> 0 then do\n       say \"Alloc STDIN dsn = \"dsn\" return code is: \"allocrc\".\",\n           \"Do not process.\"\n       zispfrc = 16\n       signal fin\n    end /* if allocrc <> 0                                                 */\n end /* if dsn <> ''                                                       */\n\n /* Third  parameter is standard output.                                   */\n\n view = \"yes\"                         /* Default                           */\n\n i = wordpos('NOVIEW',translate(cmd))            /* Check for 'noview'     */\n if i > 0 then do /* If noview present                                     */\n          view = 'no'\n          cmd = strip(delword(cmd,i))\n end\n\n i = wordpos('VIEW',translate(cmd))              /* Check for 'view'       */\n if i > 0 then do /* If view present                                       */\n          view = 'yes'\n          cmd = strip(delword(cmd,i))\n end\n\n if sysvar(sysenv)  = 'BACK'       then view = \"no\"\n if sysvar(sysispf) = 'NOT ACTIVE' then view = \"no\"\n say \"Command: \"cmd\n\n if view = 'yes' then call alloc_dsnprint\n\n select /* according to (view = 'yes' or 'no') and (dsn = '' or dsn <> '') */\n   when view = 'no'  & dsn <> '' then\n        bpxwunix_rc = bpxwunix(cmd,'DD:STDIN',stdout.,stderr.,env.)\n   when view = 'yes' & dsn <> '' then\n        bpxwunix_rc = bpxwunix(cmd,'DD:STDIN','DD:STDOUT',stderr.,env.)\n   when view = 'no'  & dsn =  '' then\n        bpxwunix_rc = bpxwunix(cmd,,stdout.,stderr.,env.)\n   when view = 'yes' & dsn =  '' then\n        bpxwunix_rc = bpxwunix(cmd,,'DD:STDOUT',stderr.,env.)\n   otherwise nop\n end    /* select according to view and (dsn = '' or dsn <> '')            */\n\n /* We use say for rexx output as say may be out trapped.                  */\n if dsn <> '' then 'free fi(STDIN)'\n /*\n if bpxwunix_rc <> 0 ! stderr.0 <> 0 then do\n\n    say 'bpxwunix_rc = 'bpxwunix_rc\n    say 'stderr.0    = 'stderr.0\n end /* if bpxwunix_rc <> 0 ! stderr.0 <> 0                                */\n */\n /*________________________________________________________________________*/\n /*                                                                        */\n /* Process result                                                         */\n\n /* Display stderr.                                                        */\n if datatype(stderr.0) = 'NUM' & stderr.0 <> 0 then do\n    say 'dsn         = 'dsn\n    say 'cmd         = 'cmd\n    say 'bpxwunix_rc = 'bpxwunix_rc\n    do i = 1 to stderr.0\n       say 'stderr.'i' ='stderr.i\n    end\n end /* if datatype(stderr.0) = 'NUM'                                      */\n\n /* Display stdout.                                                        */\n if datatype(stdout.0) = 'NUM' & stdout.0 <> 0 then do\n    /* say */\n       do i = 1 to stdout.0\n          say stdout.i\n       end\n end /* if datatype(stdout.0) = 'NUM'                                      */\n\n if view = 'yes' then call view_dsnprint\n\n /* Return code thru ISPF.                                                 */\n if bpxwunix_rc = 255 then bpxwunix_rc = 0 /* 255: terminated              */\n if bpxwunix_rc = 0 & stderr.0 = 0          then zispfrc =  0\n                                            else zispfrc = 16\n fin:\n   /*\n   if zispfrc > 0 then do\n      say 'return code = 'zispfrc\n      say\n   end /* if zispfrc > 0                                                   */\n   */\n   if sysvar(sysispf) = 'ACTIVE' then address ispexec \"vput zispfrc\"\n   exit zispfrc\n /*                                                                        */\n /* End of process result                                                  */\n /*________________________________________________________________________*/\n\n alloc_dsnprint:\n /* Allocate STDOUT dsnprint dataset.                                      */\n time_stamp = t!!time('s')\n dsnprint = dsnprint_prefix\".\"userid()\".\"rexxname\".\"time_stamp\n allo = \"allocate fi(stdout) da('\"dsnprint\"') reuse\",\n \"new catalog\",\n \"dsorg(ps) blksize(0)\",\n \"space(1 15) tracks\"\n allo_large = \" recfm(v b) lrecl(32756)\"\n if isr_rc = 0 then do /* edit macro                                       */\n    allo = allo !! \" like('\"dsn0\"')\"\n    if pos('large output',cmd) > 0 then allo = allo !! allo_large\n end /* if isr_rc = 0     edit macro                                       */\n else do /* rexx                                                           */\n    if pos('large output',cmd) > 0 then allo = allo !! allo_large\n       else allo = allo !! \" recfm(f b) lrecl(133)\"\n end /* rexx                                                               */\n\n allo                           /* execute                                 */\n arc = rc\n if arc > 0 then do\n    say \"STDOUT DSNPRINT allocate gave code \"arc\n    exit(12)\n end /* if arc > 0                                                         */\n\n /* Remove 'large output' from cmd if present.                             */\n pos_lo = pos('large output',cmd)\n if pos_lo > 0 then do /* remove 'large output'                            */\n    length_lo = length('large output')\n    /* delete starting at pos_lo for length_lo characters                  */\n    cmd = delstr(cmd,pos_lo,length_lo)\n    cmd = strip(cmd)\n end /* if pos_lo > 0                                                      */\n\n return\n\n /*________________________________________________________________________*/\n view_dsnprint:\n\n /*________________________________________________________________________*/\n /* Display DSNPRINT if not empty                                          */\n   address ispexec\n    \"dsinfo dataset('\"dsnprint\"')\"\n    /* zdstotu is used space units 13 characters                           */\n    if zdstotu <> 0 then do /* not empty                                   */\n       \"lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n       \"view   dataid(\"dd1\")\"\n       \"lmfree dataid(\"dd1\")\"\n    end /* if zdstotu <> 0     not empty                                   */\n   address\n\n /*________________________________________________________________________*/\n /* Clean up                                                               */\n msgs = msg(\"off\")\n  \"free fi(stdout)\"\n  \"delete '\"dsnprint\"'\"\n msgs = msg(msgs)\n\n return\n /*________________________________________________________________________*/\n ovall: procedure\n\n /* Replace all occurences of translate(a) in translate(c) by b            */\n /* (only the characters of string a are replaced).                        */\n parse arg a b c\n p = pos(translate(a),translate(c))\n do while p > 0               /* while a present                           */\n    /* overlay c at p by b for no more than length of a characters         */\n    c = overlay(b,c,p,length(a))\n    p = pos(translate(a),translate(c),p+length(a)) /* third parm is start  */\n end /* do while p > 0                                                     */\n return c\n /*________________________________________________________________________*/\n is_help_needed:\n\n  w = words(cmd)\n  if w = 0 then do /* at least one parameter: unix cmd                     */\n     say ' 'rexxname': At least one parameter is needed.'\n     call show_help\n     zispfrc = 8\n     signal fin\n  end /* if w = 0     at least one parameter                               */\n  w1 = word(cmd,1) /* first parameter                                      */\n\n  if wordpos(translate(w1),'H HELP -H -HELP ? -? /? AIDE SOS') > 0 then do\n     call show_help\n     zispfrc = 0\n     signal fin\n  end /* if wordpos(translate(w1),'...') > 0                               */\n\n return\n /*________________________________________________________________________*/\n show_help: procedure expose rexxname\n\n  say ' Help for 'rexxname':'\n  /* Show help between 'Help starts' and 'Help ends'                       */\n  help = 'no'\n  do i = 1 to sourceline()\n     if pos('Help starts',sourceline(i)) > 0 then do\n        help = \"yes\"\n        iterate\n     end /* if pos('Help starts',sourceline(i)) > 0                        */\n     if pos('Help ends',sourceline(i)) > 0 then leave\n     if help = 'yes' then say sourceline(i)\n  end /* do i = 1 to sourceline()                                          */\n return\n /*________________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UX": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x00\\x07\\x00\\x07\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 7, "newlines": 7, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\ntrace o\naddress ispexec\n\"control errors return\"\nmypath = '/'                     /* '/u' */\n\"dirlist path(mypath)\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VIEWIT": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01 \\x05\\x0f\\x01 \\x05\\x0f\\x12C\\x019\\x019\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-19T00:00:00", "modifydate": "2020-02-19T12:43:11", "lines": 313, "newlines": 313, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx           '/' in column 1 if run as a z/OS Unix rexx  */\n trace o\n\n /*___________________________________________________________*/\n /*                                                           */\n /* Help starts                                               */\n /* Visualize rexx output in a file if ISPF active.           */\n /* Examples: Used as a rexx:                                 */\n /*                                                           */\n /*               Command ===> TSO VIEWIT RLIST GCICSTRN *    */\n /*               Command ===> TSO VIEWIT LU                  */\n /*               Command ===> tso viewit help lu             */\n /*                                                           */\n /* Visualize clist or rexx output                            */\n /*               Command ===> TSO VIEWIT EX 'DSNAME(CLIST1)' */\n /*                                                           */\n /*           Used as an edit macro:                          */\n /*                                                           */\n /*             Execute present rexx (rexx being edited)      */\n /*             without parameters:                           */\n /*               Command ===> viewit                         */\n /*                                                           */\n /*             Execute last saved rexx without parameters:   */\n /*               Command ===> viewit *                       */\n /*                                                           */\n /*             Execute present rexx with parameters:         */\n /*               Command ===> viewit parm1 parm2             */\n /*                                                           */\n /*             Execute last saved rexx with parameters:      */\n /*               Command ===> viewit * parm1 parm2           */\n /*                                                           */\n /*           Used in a member list:                          */\n /*                                                           */\n /*                     EDIT      BOZO.TEST                   */\n /*             Command ===>                                  */\n /*                        Name     Prompt                    */\n /*             viewit___ REXX01   PARM1                      */\n /*                                                           */\n /*           Under z/OS Unix (rexx in SYSPROC or SYSEXEC     */\n /*           concatenation, vsualization with ISPF VIEW):    */\n /*             Command ===> tso omvs                         */\n /*             $ tso viewit time                             */\n /*             $ exit                                        */\n /*___________________________________________________________*/\n /* In z/OS Unix, to run as as z/OS Unix rexx.                */\n /* Visualize shell or rexx output in a temporary z/OS Unix   */\n /* file.                                                     */\n /* rexx viewit should be placed in a $PATH file.             */\n /* Examples:                                                 */\n /*                                                           */\n /*               Command ===> tso omvs                       */\n /*               $ viewit cal 2019                           */\n /*               $ viewit shell01.sh arg1 arg2               */\n /*               $ viewit rexx01.rex arg1 arg2               */\n /*               $ viewit cat test.txt                       */\n /*               $ cat test.txt ! viewit                     */\n /*               $ history 0 ! viewit                        */\n /*               $ exit                                      */\n /*___________________________________________________________*/\n /* Help ends                                                 */\n /*                                                           */\n parse source var\n rexxname = word(var,3)\n call is_help_needed(arg(1))\n\n /* Visualize rexx output.                                    */\n /*                                                           */\n if word(var,8) = 'OMVS' then do /* executed from z/OS Unix   */\n\n    tempx = 'temp'random(1,99999)\n    /* If arg(1) not blank or empty,                          */\n    /*    execute argument redirecting standard output        */\n    /*    and standard error to tempx.                        */\n    /* else visualize standard output from previous command   */\n    /*    as in:  cat abc.txt ! viewit                        */\n\n    /* Example:                                               */\n    /* viewit cat test.txt   <-- arg(1) = 'cat test.txt'      */\n\n    if strip(arg(1)) <> '' then do\n    /* ' ' at beginning to avoid IRX0031I */\n    ' 'arg(1)' > 'tempx' 2>&1'\n    /*                   2>&1'    STDERR redirected to STDOUT */\n    /* ' 'arg(1)' > 'tempx              Ok                    */\n    /* address sh arg(1) '> 'tempx      works as well         */\n    end /* if strip(arg(1)) <> ''                             */\n\n    /* Example:                                               */\n    /* cat test.txt ! viewit  <-- arg(1) empty                */\n\n    else 'cp /dev/fd/0 'tempx  /* copy to regular file        */\n    /* /dev/fd/0 after pipe is standard output /dev/fd/1      */\n    /* from previous command.                                 */\n    /* /dev/fd0                         works as well         */\n\n    'oedit 'tempx         /* Open MVS Edit                    */\n    'rm    'tempx         /* remove temp file                 */\n    return\n end /* if word(var,8) = 'OMVS'      executed from z/OS Unix  */\n /*___________________________________________________________*/\n /*                                                           */\n address isredit /* Am I an edit macro?                       */\n \"macro (parm)\" /* no underline in_between parents            */\n isr_rc = rc\n\n /* Obtain command to execute.                                */\n if isr_rc = 0 then do /* edit macro                          */\n\n  \"(dsn0) = dataset\"\n  /* By default (no word '*' in parm) execute what is being viewed or   */\n  /* edited.                                                            */\n  /* If there is a word '*' in parm (which will be removed), execute    */\n  /* last saved version.                                                */\n  wp = wordpos('*',parm)   /* Is word '*' in parm (wp > 0)?             */\n  if wp > 0 then do /* execute saved file, '*' present in parm          */\n     parm = delword(parm,wp,1) /* remove '*' from parm                  */\n    \"(mbr)  = member\"\n    mbr = strip(mbr) /* '' when no member                               */\n    if mbr <> '' then dsn = dsn0'('mbr')'\n                 else dsn = dsn0 /* sequential                          */\n\n    /* say \"dsn = \"dsn                                                  */\n    /*\n    if left(dsn,1) = '/' then do\n       address sh\n       dsn\" \"parm\n       exit\n    end /* if left(dsn,1) = '/'                                         */\n    */\n\n    command = \"exec '\"dsn\"' '\"parm\"'\"\n\n  end /* if wp > 0     execute saved file, '*' present in parm          */\n\n  else do           /* execute copy,         no '*' in parm             */\n     /* Copy present version, possibly unsaved, to dsn_copy.            */\n     /* Execute dsn_copy.                                               */\n     /* Delete dsn_copy.                                                */\n     call set_up_prefix /* create prefix for new file                   */\n     dsn_copy = prefix'.temp.t'!!right(random(1,99999),5,'0')\n     address tso, /* create file dsn_copy                               */\n       \"alloc da('\"dsn_copy\"') like('\"dsn0\"')\",\n       \"dsorg(ps) tracks space(1,1)\",\n       \"new catalog\" /* dsn_copy needs to be cataloged for exec         */\n     \"repl '\"dsn_copy\"' .zf .zl\" /* copy to temporary file              */\n\n     command = \"exec '\"dsn_copy\"' '\"parm\"'\"\n\n  end /* if wp = 0     execute copy,         no '*' in parm             */\n\n end /* isr_rc = 0                                            */\n else parse arg command /* rexx                               */\n /* End of obtain command to execute.                         */\n\n /* Execute command.                                          */\n address tso\n stem_name = outtrap('line.') /* stem to get display output   */\n\n /* If first word of command begins by a valid dsname         */\n /*    or dsname(member) (e.g. viewit used in a member list), */\n /*    then, assume it is a rexx and execute it with          */\n /*    parameters in single quote.                            */\n /* else execute 'command'.                                   */\n\n w1 = word(command,1)           /* first word                 */\n upper w1                       /* upper case                 */\n w1 = strip(w1,,\"'\")            /* remove quotes if any       */\n\n if sysdsn(\"'\"w1\"'\") = 'OK' then do /* command begins by dsn  */\n    this_exec      = word(command,1)\n    this_exec_parm = subword(command,2)\n    'exec 'this_exec \"'\"this_exec_parm\"'\"   /* execute        */\n end /* command begins by a valid dsname or dsname(member)    */\n else   command                             /* execute        */\n\n outtrap_off = outtrap('off')\n /* End of execute command.                                   */\n\n if isr_rc = 0                              &,      /* edit macro      */\n    pos('.TEMP.T',translate(dsn_copy)) > 0  then do /* check dsn_copy  */\n      msg_prev = msg('off')\n        address tso \"del '\"dsn_copy\"'\"              /* delete          */\n      msg_off  = msg(msg_prev)\n      drop dsn_copy\n    end\n\n call visualize\n\n zispfrc = 0\n if sysvar(sysispf) = 'ACTIVE' then\n    address ispexec 'vput zispfrc'\n exit zispfrc\n /*___________________________________________________________*/\n\n visualize: procedure expose line. rexxname\n /* Visualize.                                                */\n if line.0 > 0 then do\n    if sysvar(sysispf) <> 'ACTIVE' then do\n       do i = 1 to line.0\n          say line.i\n       end /* do i = 1 to line.0                              */\n       zispfrc = 0\n       exit zispfrc\n    end /* if sysvar(sysispf) <> 'ACTIVE'                     */\n    else do /*       ispf ACTIVE                              */\n\n       /* Allocate visualization file.                        */\n       address tso\n       ran  = right(random(1,99999),5,'0')\n       ddnm = 'dd'ran                          /* choose random ddname */\n       call set_up_prefix /* create prefix for new file                */\n       dsnprint = prefix\".\"rexxname\".R\"ran\n       msg_prev = msg('off')\n       \"alloc file(\"ddnm\") da('\"dsnprint\"') new catalog\",\n       \"tracks space(50,500) reuse lrecl(132) recfm(f b) blksize(0)\"\n       alloc_rc = rc\n       if alloc_rc <> 0 then do\n          say rexxname \"could not allocate the visualization file.\"\n          say \"We exit with code 16.\"\n          say \"alloc rc = \"alloc_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if alloc_rc <> 0                                */\n       msg_off  = msg(msg_prev)\n       /* End of allocate visualization file.                 */\n\n       /* Write on visualization file.                        */\n       \"execio\" line.0  \"diskw\" ddnm \"(stem line. finis\"\n       execio_rc = rc\n       if execio_rc <> 0 then do\n          say rexxname \"could not write on visualization file.\"\n          say \"We exit with code 16.\"\n          say \"execio rc = \"execio_rc\n          zispfrc = 16\n          address ispexec 'vput zispfrc'\n          exit zispfrc\n       end /* if execio_rc <> 0                               */\n       /* End of write on visualization file.                 */\n\n       /* Visualize.                                          */\n       \"ispexec view dataset('\"dsnprint\"')\"\n       /* End of visualize.                                   */\n\n       /* Clean up.                                           */\n       msg_prev = msg('off')\n          \"free fi(\"ddnm\")\"\n          \"del  '\"dsnprint\"'\"\n       msg_off  = msg(msg_prev)     /* reset                  */\n       /* End of clean up.                                    */\n\n    end /* ispf ACTIVE                                        */\n end /* if line.0 > 0                                         */\n\n return\n /*___________________________________________________________________*/\n\n set_up_prefix:\n\n /* Set up new output file prefix.                                    */\n prefix = sysvar('syspref')              /* tso profile prefix        */\n uid    = sysvar('sysuid')               /* tso userid                */\n if prefix = '' then prefix = uid        /* use uid if null prefix    */\n if prefix <> '' & prefix <> uid then    /* different prefix than uid */\n    prefix = prefix'.'uid                /* use prefix.uid            */\n\n return\n /*___________________________________________________________________*/\n\n is_help_needed:\n  parse arg cmd\n\n  /* Good    for Command ===> tso viewit\n     but not for Command ===>     viewit\n                 where it is supposed to execute the member\n  if length(space(arg(1))) = 0 then\n     signal call_show_help\n  */\n\n  w1 = word(cmd,1) /* first parameter                                 */\n  if wordpos(translate(w1),'-HELP H -H ? -? /? AIDE SOS') > 0 then\n     signal call_show_help\n  else return\n\n  call_show_help: /* show help and exit                               */\n     call show_help\n     zispfrc = 0\n     if sysvar(sysispf) = 'ACTIVE' then\n        address ispexec 'vput zispfrc'\n     exit zispfrc\n /*___________________________________________________________________*/\n\n show_help:\n\n  say ' Help for 'rexxname':'\n  /* Show help between 'Help starts' and 'Help ends'                  */\n  help = 'no'\n  line_counter = 0\n  do i = 1 to sourceline()\n     if pos('Help starts',sourceline(i)) > 0 then do\n        help = \"yes\"\n        iterate\n     end /* if pos('Help starts',sourceline(i)) > 0                   */\n     if pos('Help ends',sourceline(i)) > 0 then leave\n     if help = 'yes' then do /* record sourceline(i)                  */\n        line_counter = line_counter + 1\n        line.line_counter = sourceline(i)\n     end /* if help = 'yes'                                           */\n  end /* do i = 1 to sourceline()                                     */\n  line.0 = line_counter\n  call visualize\n return\n /*___________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VU": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x002\\x01 \\x16O\\x01 \\x16O\\x14V\\x01'\\x01'\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-12T00:00:00", "modifydate": "2020-06-12T14:56:32", "lines": 295, "newlines": 295, "modlines": 0, "user": "MLEWIN"}, "text": "/* rexx */\n /* rexx or edit macro.                                             */\n\n /* For a library member, accessed in ISPF 3.4,                     */\n /* this is an alternative to                                       */\n /* 1) Selection with a '/' in prompt field, such as:               */\n /*            Name     Prompt                                      */\n /* S________ BOZO01   /                                            */\n /* and                                                             */\n /* 2) On the next panel, selecting  2. UTF-8 under Data Encoding.  */\n /*    This panel is named \"EDIT entry panel\" (ISRUEDIT).           */\n /*                                                                 */\n /* The same \"EDIT entry panel\" may be used to clear                */\n /* the Initial Macro field, in case of a remaining unwanted        */\n /* initial macro (cf message at top right).                        */\n /*         VIEW      BOZO.PDSE              Initial edit macro set */\n /* Command ===>                                                    */\n /* Confer also Command ===> edset                                  */\n /*        and edit profile IMACRO.                                 */\n\n /* Function is according to the member name:                       */\n /* vu:    View UTF-8 file converted to EBCDIC terminal codepage.   */\n /*        Edit UTF-8 file if we add a last parameter 'e' or 'E'    */\n /*        to either the rexx or the edit macro.                    */\n /* vuhex: View UTF-8 in hex (unchanged hex code)                   */\n /* eu:    Edit UTF-8 file displayed in EBCDIC terminal codepage    */\n /* euhex: Edit UTF-8 in hex                                        */\n /* Same code in the four rexx.                                     */\n\n /* If the name of the rexx does not begin by 'E'                */\n /* and in the case there are parameters, the last one is        */\n /* not 'e' or 'E', then                                         */\n /* View a MVS library member or a MVS sequential data set       */\n /* or a z/OS Unix file                                          */\n /* (member or sequential data set or z/OS Unix file             */\n /*  already in UTF-8 is converted to terminal codepage)         */\n /* otherwise use Edit instead of View.                          */\n\n /* vu: UTF-8 to EBCDIC terminal codepage conversion by          */\n /*     ISPF service View or Edit.                               */\n /* May be used with a dbrmlib member.                           */\n\n /* Notes:                                                       */\n /* ISPF 3.17 also uses a command 'vu' to visualize              */\n /* UTF-8 z/OS Unix files.                                       */\n /* Terminal codepage is in ISPF variable ztermcp5.              */\n\n /* Examples of use for VU:                                      */\n /*                                                              */\n /* 1) As a rexx, in a member list:                              */\n /*         VIEW      BOZO.DBRMLIB                               */\n /* Command ===>                                                 */\n /*            Name     Prompt       Size                        */\n /* vu_______ BOZO01              <--       View                 */\n /* vu_______ BOZO02    e         <-- force Edit (e in Prompt)   */\n /*                                                              */\n /* 2) As a rexx on a command line:                              */\n /* Command ==> tso vu BOZO.DBRMLIB(BOZO01)       <--       View */\n /* Command ==> tso vu BOZO.DBRMLIB(BOZO01) e     <-- force Edit */\n /*                                                              */\n /* 3) As a rexx preserving lower case:                          */\n /* Command ==> cmde                                             */\n /* Enter TSO commands below:                                    */\n /* ===> vu /u/bozo/bozo01.utf8                    <--      View */\n /* ===> vu /u/bozo/bozo01.utf8 e              <-- e forces Edit */\n /* ===> vu /u/bozo/bozo01.utf8 macro(a) parm(b) e <--      Edit */\n /* ===> vu 'bozo.cntl(inutf8)' macro(a) parm(b)   <--      View */\n /* ===> vu 'bozo.cntl(inutf8)' macro(a) parm(b) noutf8 e        */\n /* It is possible to add View or Edit extra parameters          */\n /*    and the special parameter noutf8 to remove                */\n /*    the default parameter utf8.                               */\n /*                                                              */\n /* 4) As an edit macro:                                         */\n /*            BOZO.DBRMLIB(BOZO01)                              */\n /* Command ===> vu                         (vu e to force Edit) */\n /* 000001 DBRM   `BOZO    BOZO01   \u00d0 H \u00ec/   B                   */\n /* 000002                                                       */\n /* 000003 DBRM   ]       \u00cf       \u00a3@\u00e1\u00e4< \u00ea\u00e1 \u00e4        \u00e4\u00ed\u00ea\u00eb!\u00ea \u00e3!\u00ea   */\n\n trace o\n parse source . . rexxname .    /* rexxname in upper case        */\n\n address isredit\n 'macro (parm)'\n macro_rc = rc\n select /* according to macro_rc                                 */\n\n /*_______________ EDIT MACRO ___________________________________*/\n   when macro_rc = 0  then do /* it is an edit macro             */\n     '(save)   = user_state'\n     '(dataset) = dataset'\n     '(member)  = member'\n     /* member = '' for a sequential data set                    */\n     if member <> '' then dataset = dataset\"(\"member\")\"\n\n     service = \"view\" /* default                                 */\n     /* If edit macro name begins by 'E' then Edit.              */\n     if left(rexxname,1) = 'E' then service = 'edit'\n\n     /* If parm begins by dataset, remove it.                    */\n     a = translate(strip(word(parm,1),,\"'\"))\n     b = translate(dataset)\n     if length(a) = length(b) then do /* same length             */\n        if a = b then\n           parm = subword(parm,2) /* remove first word with dataset */\n     end /* if length(a) = length(b)                             */\n     else do /* not the same length                              */\n        parse var a a1 '('\n        parse var b b1 '('\n        if a1 = b1 then /* compare what is before left parent    */\n           parm = subword(parm,2) /* remove first word with dataset */\n     end /*     not the same length                              */\n\n     /* If last parameter is 'e' or 'E'  then Edit.              */\n     if parm = '' then parm = 'PARM' /* to avoid syntax error    */\n     /* word(string,0) gives: Incorrect call to routine          */\n     lastword = word(parm,words(parm)) /* last word of parm      */\n     if translate(lastword) = 'E' then do                /* Edit */\n        service = 'edit'\n        parm = delword(parm,words(parm),1) /* remove last word   */\n     end /* if translate(lastword) = 'E'                    Edit */\n     if parm = 'PARM' then parm = '' /* reset to initial value   */\n\n     /* Add extra parameters to View or Edit in string extra.    */\n     /*                                                          */\n     /* With ISPF View and Edit service,                         */\n     /* only the last parameter of same name is used.            */\n     /* Thus if the four parameters                              */\n     /* macro(a) parm(a) macro(b) parm(b) are present,           */\n     /* macro(a) and parm(a) are ignored and                     */\n     /* macro(b) and parm(b) are used.                           */\n     /*                                                          */\n     /* If edit macro name contains 'HEX', try to use            */\n     /* edit command 'hex' transmitted thru macro() parameter.   */\n     if pos('HEX',rexxname) > 0   then extra = 'macro(hex)'\n                                  else extra = 'macro(res)'\n     extra = extra' 'parm /* last View or Edit parameter is used */\n     /* Process special parameter noutf8 if present.             */\n     wp = wordpos('NOUTF8',translate(parm))\n     if wp = 0 then extra = extra' utf8' /* 'noutf8' not present */\n     /* End of adding extra parameters to View or Edit           */\n\n     address ispexec\n       'control errors return'\n\n       /* Set short and long message on next panel.              */\n       if service = 'edit' then do                       /* Edit */\n           zedsmsg = '>in EDIT<'     /* top right corner         */\n           zedlmsg = 'We are in Edit mode.'\n       end /* if service = 'edit'                           Edit */\n       else do                                           /* View */\n           zedsmsg = 'exit by can' /* top right corner           */\n           zedlmsg = 'We are in View, please exit with Command ===> can'\n       end                                               /* View */\n       \"setmsg msg(isrz000)\"\n\n       /* View or Edit                                           */\n       /* A z/OS Unix file begins by '/' or '.'.                 */\n       if pos(left(dataset,1),'/.') = 0 then\n            service \"dataset('\"dataset\"') \"extra    /* MVS       */\n       else service \"file(dataset)        \"extra    /* z/OS Unix */\n       xrc = rc\n       if xrc > 4 then do /* Edit or View incorrect return code    */\n          say\n          say rexxname' had return code 'xrc\n          say 'when trying to 'service' 'dataset\n          interpret \"call set_\"service\"rc\" /* set up message stem  */\n          /* say message for this return code                    */\n          interpret \"say \"service\"rc.xrc\"\n          say 'We exit with code 16.'\n          exit 16\n       end                 /* Edit or View incorrect return code */\n\n     address /* from ispexec                                     */\n     'user_state = (save)'\n     'end'\n     address /* from isredit                                     */\n     exit\n   end /* when macro_rc = 0             it is an edit macro      */\n\n /*_______________ REXX _________________________________________*/\n   when macro_rc = 20 then do /* assume it is a rexx             */\n     parse arg dataset .\n     parm = arg(1) /* dataset is first word of parm              */\n     dataset = strip(dataset,,\"'\")       /* remove quotes if any */\n     address ispexec\n     'control errors return'\n\n       call save_initial_macro /* reset at end if changed        */\n\n       if pos(left(dataset,1),'/.') = 0 then do           /* MVS */\n            /* Check MVS dataset existence.                      */\n            sysdsn_result = sysdsn(\"'\"dataset\"'\")\n            if sysdsn_result <> 'OK' then do\n               say\n               say rexxname\" sysdsn('\"dataset\"') gave result:\"\n               say sysdsn_result\n               say 'We exit with code 16.'\n               exit 16\n            end /* if sysdsn_result <> 'OK'                      */\n            /* parm(parm) edit macro will inherit rexx parameters */\n            \"view dataset('\"dataset\"') macro(\"rexxname\") parm(parm)\"\n       end /* MVS                                                */\n       /* If z/OS Unix file does not exist, it will be created   */\n       else \"view file(dataset) macro(\"rexxname\") parm(parm)\"\n       view_from_rexx_rc = rc\n\n       if view_from_rexx_rc <> 0 then do\n          say\n          say rexxname\" View from rexx gave rc = \"view_from_rexx_rc\n               call restore_initial_macro\n               call set_viewrc /* set up message stem            */\n               /* say message for this return code               */\n               say viewrc.view_from_rexx_rc\n               say 'We exit with code 16.'\n               exit 16\n       end /* if view_from_rexx_rc <> 0                          */\n\n       call restore_initial_macro\n\n     address /* from ispexec                                     */\n     exit\n   end /* when macro_rc = 20     assume it is a rexx             */\n\n /*_______________ OTHERWISE ____________________________________*/\n   otherwise do /* macro_rc different of 0 and 20                */\n     say\n     say rexxname\" macro_rc = \"macro_rc\n     say \"We exit with code 16.\"\n     exit 16\n   end /* otherwise                                              */\n\n end /* select according to macro_rc                             */\n /* end of rexx main part (we exit in select)                    */\n\n /*_________________________________________________________________*/\n save_initial_macro:\n\n   address ispexec\n   'control errors return'\n     \"vget zdaemac profile\" /* variable in panel ISRUEDIT           */\n     /* (ISRUEDIT is \"EDIT Entry Panel\" obtained by S before        */\n     /* member name and a '/' in the prompt column).                */\n     /* Confer also Command ===> edset                              */\n     /*        and edit profile IMACRO.                             */\n     zdaemac_old = zdaemac  /* save to reset at exit if changed     */\n   address /* from ispexec                                          */\n   return\n /*_________________________________________________________________*/\n restore_initial_macro:\n\n   /* If initial edit macro name changed as                         */\n   /* in View of a z/OS Unix directory,                             */\n   /* reset initial edit macro name to previous value.              */\n   address ispexec\n   'control errors return'\n     \"vget zdaemac profile\" /* variable in panel ISRUEDIT           */\n     if zdaemac <> zdaemac_old then do\n        zdaemac = zdaemac_old\n        \"vput zdaemac profile\" /* restore                           */\n        /* to suppress: \"verase zdaemac profile\"                    */\n     end /* if zdaemac was changed                                  */\n   address /* from ispexec                                          */\n   return\n /*_________________________________________________________________*/\n set_viewrc: procedure expose viewrc.\n\n /* Set up viewrc. message stem for ISPF View.                      */\n /* viewrc.i contains the message for View return code i            */\n viewrc.0  = \"Normal completion.\"\n viewrc.10 = \"Member or generation (if specified) not found.\"\n viewrc.12 = \"VIEW has been disabled through the ISPF configuration\",\n             \"table.\"\n viewrc.14 = \"Member, sequential data set, or z/OS UNIX file in use.\"\n viewrc.16 = \"No members matched the pattern or no members in the PDS.\"\n viewrc.18 = \"VSAM data set was specified but VSAM processing\",\n             \"not allowed.\"\n viewrc.20 = \"Severe error; unable to continue.\"\n return\n /*_________________________________________________________________*/\n set_editrc: procedure expose editrc.\n\n /* Set up editrc. message stem for ISPF Edit.                      */\n /* editrc.i contains the message for Edit return code i            */\n editrc.0  = \"Normal completion; data was saved.\"\n editrc.4  = \"Normal completion; data was not saved.\"\n editrc.10 = \"Member or generation (if specified) not found.\"\n editrc.14 = \"Member, sequential data set, or z/OS UNIX file in use.\"\n editrc.12 = \"YES was specified for the LOCK parameter.\"\n editrc.16 = \"No members matched the pattern or no members in the PDS.\"\n editrc.18 = \"VSAM data set was specified but VSAM processing\",\n             \"not allowed.\"\n editrc.20 = \"Severe error; unable to continue.\"\n return\n /*_________________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "V2": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x01\\xf1\\x01\\xf1\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 497, "newlines": 497, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  /* trace r                                                      */\n\n  /*______________________________________________________________*/\n  /* Convert non migrated library from                            */\n  /* PDS            to PDS or PDSE version 1 or PDSE version 2,   */\n  /* PDSE version 1 to PDS or PDSE version 1 or PDSE version 2,   */\n  /* PDSE version 2 to PDS or PDSE version 1 or PDSE version 2,   */\n  /* to unload or reload a library.                               */\n  /* Defaut is conversion to PDSE version 2.                      */\n  /* It is possible to add parameters to output allocation.       */\n  /*                                                              */\n  /* It can compress a PDS and change the PDSE version 2 maxgens  */\n  /* parameter.                                                   */\n  /*______________________________________________________________*/\n  /*                                                              */\n\n  /* Individual convert a pds or a pdse version 1 to              */\n  /*  a pdse version 2 with the implied or specified              */\n  /*  maxgens parameter.                                          */\n\n  parse arg parm               /* upper case                      */\n  parse source . . rexxname .\n\n  help_only = 'no'\n  if length(parm) = 0     then help_only = 'yes'\n  if pos('HELP',parm) > 0 then help_only = 'yes'\n  if pos('-H',parm) > 0   then help_only = 'yes'\n\n  wpos = wordpos('SIMULATE',parm)\n  if wpos > 0 then do\n     simulate = 'yes'\n     parm = delword(parm,wpos) /* clean up parm                  */\n  end /* if wpos > 0 */\n  else simulate = 'no'\n\n  if sysvar(sysenv)  = 'BACK' !,\n     sysvar(sysnest) = 'YES' !,\n     help_only       = 'yes'       then do\n\n  say \"__________________________________________________________\"\n  say \"V2 converts to PDSE version 2 by default.\"\n  say \"V2 works on levels\",\n      \"with * and % and possible supplementary qualifiers.    \"\n  say\n  say \"Examples of use in ISPF 3.4:                           \"\n  say \"Convert to DSNTYPE(LIBRARY,2):                         \"\n  say \"V2       USER01.LOAD1      <-- Default MAXGENS         \"\n  say \"//V2     USER01.LOAD2      <-- Group convert           \"\n  say \"         USER01.LOAD3          with default MAXGENS    \"\n  say \"//       USER01.LOAD4                                  \"\n  say \"V2 / 0   USER01.LOAD5      <-- Convert with MAXGENS=0  \"\n  say \"V2 / 2   USER01.LOAD6      <-- Convert with MAXGENS=2  \"\n  say \"Convert to DSNTYPE(LIBRARY,1):                         \"\n  say \"V2 / DSNTYPE(LIBRARY,1)                                \"\n  say \"Convert to PDS:                                        \"\n  say \"V2 / DSNTYPE(PDS) DIR(500)                             \"\n  say \"If a rexx such as VIEWIT is available                  \"\n  say \" (VIEWIT: rexx to outtrap, execute parm, outtrap\",\n  say \"and view what was said):                               \"\n  say \"viewit v2 /7931.LOAD4                                  \"\n  say\n  say \"Examples of use on Command line:                       \"\n  say \"Command ===> TSO V2               <-- HELP             \"\n  say \"Command ===> TSO V2 AB.CDEF.CNTL  <-- Default MAXGENS  \"\n  say \"Command ===> TSO V2 AB.*.C%EF.**.*ABC* SIMULATE        \"\n  say \"Command ===> TSO V2 AB.*.C%EF.**.*ABC*                 \"\n  say \"             * any number of characters                \"\n  say \"             % exactly one character                   \"\n  say \"             ** any number of qualifiers including zero\"\n  say \"             *ABC* any qualifier with ABC inside       \"\n  say \"Command ===> TSO V2 AB.CDEF.** 3  <-- MAXGENS=3        \"\n  say \"Command ===> tso viewit v2 USER01.load*\",\n                   \"dir(500) blksize(32760) dsntype(pds)\"\n  say \"Command ===> tso viewit v2 ab.cdef.cntl dsntype(library,1)\"\n  say\n  say \"If used, parameter MAXGENS must be less or equal to\"\n  say \" IGDSMSxx PARMLIB parameter MAXGENS_LIMIT of \"maxgens_limit()\n  /* Cf.   D SMS,OPTIONS        SET SMS,MAXGENS_LIMIT=9          */\n  say \"__________________________________________________________\"\n\n  end /* if sysvar(sysenv) = 'BACK' or nested or help_only = 'yes' */\n\n  if help_only = 'yes' then exit\n\n  /* Library of type 2:                                          */\n  /* maxgens is the number of member generations                 */\n  /*         with the oldest deleted.                            */\n  /*         If not specified, then system default               */\n  /*         (parameter MAXGENS_LIMIT( ) in MACLIB(IGDSMSXX)).   */\n  /* maxgens of 1 means member plus one generation               */\n\n  /* This rexx does not process dsnames ending                   */\n  /* in .V2- or .ANC- as it creates itself temporary             */\n  /* datasets ending this way, in order to protect from a loop.  */\n\n  say\n  say \"Command processed: \"rexxname arg(1)\n\n  trace o\n  parse var parm level rest\n  /* arg(1) is stripped and is read only.                        */\n  /* Please note that we process a level and not a dsname.       */\n  /* Any further qualifiers will be included.                    */\n  /* rest, if present, is used for output allocation.            */\n\n  level = strip(level,,\"'\") /* remove surrounding quotes if any  */\n\n  /* Process rest.                                               */\n  /* If rest begins by a numeric, this numeric is maxgens.       */\n  maxgens = '' /*     default                                    */\n  if datatype(word(rest,1)) = 'NUM' then do\n     maxgens = \" maxgens(\"word(rest,1)\")\"\n     rest    = subword(rest,2)\n  end /* if datatype(word(rest,1)) = 'NUM'                       */\n  if pos('DSNTYPE',rest) = 0 then               /* default       */\n     rest = 'DSNTYPE(LIBRARY,2) 'rest\n  /* Pick up extra control parameters in rest                    */\n  /* (for added functionalities):                                */\n\n  /* if NOCONTROL added to parameters, no verification of        */\n  /*    migration status.                                        */\n  /* Example:                                                    */\n  /* Command ===> tso v2 USER01.load 3 nocontrol                 */\n  /*   If USER01.LOAD is LIBRARY version 2 maxgens 2,            */\n  /*                  will be maxgens 3.                         */\n  wpos = wordpos('NOCONTROL',rest)\n  if wpos > 0 then do\n     nocontrol = 'yes'\n     rest = delword(rest,wpos) /* clean up rest                  */\n  end /* if wpos > 0 */\n  else nocontrol = 'no'\n\n  /* if DSNTYPE added to parameters, override of                 */\n  /* default output file DSNTYPE(LIBRARY,2)                      */\n  /* (for instance to change a LIBRARY version 2 to a PDS        */\n  /* when possible).                                             */\n  /* Examples:                                                   */\n  /* Command ===> tso v2 USER01.load dsntype(pds) dir(500)       */\n  /*   If USER01.LOAD is PDS or LIBRARY, will be PDS,            */\n  /*                  if PDS, will be compressed.                */\n  /* Command ===> tso v2 USER01.load dsntype(library,1)          */\n  /*_____________________________________________________________*/\n  /*                                                             */\n  address ispexec\n  'control errors return'\n\n  /*                  S T U C T U R E\n\n   lmdinit            provide a level\n      lmdlist           obtain dataset\n        convert to PDSE version 2\n   lmdfree\n\n  */\n\n  \"lmdinit listid(lidv)  level(\"level\")\"\n  lmdinitrc = rc\n  if lmdinitrc = 0 then\n    do /* lmdinit OK                                             */\n      dsn = \"                  \"\n      keepon = \"yes\"\n      do until keepon = \"no \"\n        \"lmdlist listid(\"lidv\") option(list) dataset(dsn) stats(yes)\"\n        lmdlistrc = rc\n        select /* according to lmdlistrc                         */\n          when lmdlistrc = 0  then do /* dsn found               */\n               saveenv = address()\n               address TSO\n                 call process  /* dsn                            */\n               address value saveenv\n            end /* lmdlistrc = 0  dataset found                  */\n          when lmdlistrc = 8 then keepon = \"no \" /* end of list  */\n          otherwise /* lmdlistrc not 0 and not 8, error          */\n               say_error('lmdlist' lmdlistrc 'dsn')\n        end /* select according to lmdlistrc                     */\n      end /* do until keepon = \"no \"                             */\n      \"lmdfree listid(\"lidv\")\"\n    end /* lmdinitrc = 0                                         */\n  else /* lmdinit failed                                         */\n         say_error('lmdinit' lmdinitrc 'level')\n  zispfrc = 0\n  \"vput zispfrc\"\n  exit zispfrc\n  /*_____________________________________________________________*/\n  say_error: procedure expose level dsn zerrlm\n    parse arg function thisrc atlevel\n    say\n    say function' error:'\n    if atlevel = 'dsn' then say 'dsn    = 'dsn\n                       else say 'level  = 'level\n    say function' failed with rc = 'thisrc\n    say         \"ZERRLM  = '\"strip(zerrlm)\"'\"\n    say\n    zispfrc = 16\n    \"vput zispfrc\"\n    exit zispfrc\n  /*_____________________________________________________________*/\n\n  process:\n\n    if simulate = 'yes' then do\n       say \"Sysdsn('\"dsn\"') = \"sysdsn(\"'\"dsn\"'\")\n       enq_number = whohas(dsn) /* how many enqueues?            */\n       if enq_number > 0 then do\n          say \" Contention on '\"dsn\"':\",\n               enq_number' enqueue(s).'\n       end /* if enq_number > 0                                  */\n       else say ' No enqueue.'\n       say\n       return\n    end /* if simulate = 'yes'                                   */\n\n    if checkdsn(dsn) > 0 then return\n\n    /* Convert.                                                  */\n\n    if nocontrol = 'no' then do /* control on by default         */\n\n       /* Comment\n       /* In older, more restrictive version                     */\n       /* (now, we permit unloaded libraries and PDSE version 2):*/\n       /* Do not process if not a PDS or a library:              */\n          if pos(strip(zdldsntp),'PDS LIBRARY') = 0     then return\n       /* Do not process if library but not version 1:           */\n          if strip(zdldsntp) = 'LIBRARY' & zdldsnv <> 1 then return\n       End of comment                                            */\n\n       /* Do not process if migrated                             */\n       /* or on volume with name containing 'MIG':               */\n          if strip(zdlmigr) = 'YES'                     then return\n          if pos('MIG',zdlvol) > 0                      then return\n    end /* if nocontrol = 'no'     control on by default         */\n\n    /* Avoid loop on temporary datasets .V2- and .ANC-           */\n    if right(dsn,4) = '.V2-'                            then return\n    if right(dsn,5) = '.ANC-'                           then return\n\n  /*                  S T U C T U R E\n\n   0) Should return to process next dsn at first problem.\n   1) Allocate dsn.V2- using dsn as a model.\n   2) Copy dsn on dsn.V2- with iebcopy.\n   3) Check if no enqueue on dsn with d grs\n         if enqueue, a) delete dsn.V2-,\n                     b) return to process next dsn.\n   4) Rename dsn in dsn.ANC- with ALTER NEWNAME,\n      possible because of no enqueue.\n   5) Rename dsn.V2- in dsn with ALTER NEWNAME\n   6) Delete dsn.ANC-\n   7) Return to process next dsn.\n\n  */\n\n    say\n    say \"dsn = \"dsn\n    say 'in process'\n\n    time_stamp = t!!time('s')\n    dsnprint = userid().\"IEBCOPY.\"time_stamp   /* SYSPRINT file  */\n\n    x = msg(\"off\")      /* quiet delete                          */\n    \"delete '\"dsnprint\"' scratch purge\"   /* avoid duplicate     */\n    y = msg(x)          /* reset msg status                      */\n    \"allocate fi(SYSPRINT) da('\"dsnprint\"') reuse\",\n    \"new catalog\",\n    \"lrecl(125) recfm(v b a) blksize(27875)\",\n    \"space(1 1) tracks\"\n\n    x = msg(\"off\")      /* quiet free                            */\n    \"free     fi(SYSUT1)   da('\"dsn\"')\"\n    y = msg(x)          /* reset msg status                      */\n    \"allocate fi(SYSUT1)   da('\"dsn\"')    shr         reuse\"\n\n    x = msg(\"off\")      /* quiet free and delete attempt         */\n    \"free     fi(SYSUT2)\"\n    \"delete '\"dsn\".V2-' scratch purge\"   /* avoid duplicate      */\n    y = msg(x)          /* reset msg status                      */\n\n    /* ucount(1) to avoid multi-volume                           */\n    \"allocate fi(SYSUT2)   da('\"dsn\".V2-') new catalog reuse ucount(1)\",\n                        \"like('\"dsn\"')\",\n                        maxgens,   /* default empty              */\n                        rest       /* default DSNTYPE(LIBRARY,2) */\n    arc = rc\n    if arc > 0 then do\n       say \"Allocate of new file \"dsn\".V2- gave code \"arc\n       say dsn\" *** unchanged ***\"\n       return  /* process next dsn                               */\n    end /* if arc > 0                                            */\n\n    lib = \"sys1.linklib\"\n    \"call '\"lib\"(iebcopy)' 'COPY' \"\n    xrc = rc                /* save iebcopy return code          */\n\n    if sysvar(sysenv) = 'FORE' then do /* View IEBCOPY sysprint  */\n       \"ispexec lminit dataid(dd1) dataset('\"dsnprint\"') enq(shr)\"\n       \"ispexec view   dataid(\"dd1\")\"\n       \"ispexec lmfree dataid(\"dd1\")\"\n    end /* if sysvar(sysenv) = 'FORE'                            */\n\n    x = msg(\"off\")  /* quiet free, delete                        */\n    \"free fi(SYSUT1,SYSUT2)\" /* free fdn, dsn.V2-                */\n    \"delete '\"dsnprint\"' scratch purge\"\n    y = msg(x)\n\n    /* if iebcopy ok: check for enqueues before dsn rename       */\n    /*                rename     dsn into old dsn                */\n    /*                rename new dsn into     dsn                */\n    /*                delete old dsn                             */\n    /*                delete dsnprint                            */\n    if xrc = 0 then do /* iebcopy ok                             */\n\n    /* Check for enqueues on dsn after iebcopy ok and            */\n    /* before rename dsn.                                        */\n    /* If number of enqueues on dsn positive,                    */\n    /*    do not rename dsn, clean up and process next dsn       */\n      enq_number = whohas(dsn) /* how many enqueues?             */\n      if enq_number > 0 then do\n         say \"IEBCOPY ok but there exists\",\n             \"contention on \"dsn\n         say \"No rename possible.\"\n         say dsn\" *** unchanged ***\"\n\n         x = msg(\"off\")      /* quiet delete attempt             */\n         \"delete '\"dsn\".V2-' scratch purge\"\n               frc = rc\n         y = msg(x)          /* reset msg status                 */\n\n         if frc > 0 then do\n            /* Could not delete temporary copy dsn.V2-           */\n            say \"The temporary copy \"dsn\".V2-\",\n                \"could also not be deleted.\"\n            say \"Code \"frc\" at delete time.\"\n            say \"Extra copy \"dsn\".V2- present.\"\n         end /* if frc > 0                                       */\n         else say \"Temporary copy removed.\"\n\n         x = msg(\"off\")\n         \"delete '\"dsnprint\"' scratch purge\"\n         y = msg(x)\n         return /* process next dsn                              */\n      end /* if enq_number > 0                                   */\n    /* End of checking for enqueues on dsn after iebcopy ok and  */\n    /* before rename dsn.                                        */\n\n      /* iebcopy ok and no enqueues on dsn                       */\n      x = msg(\"off\")      /* quiet alter                         */\n      /* most sensitive part of the code:                        */\n      \"alter  '\"dsn\"' newname('\"dsn\".ANC-')\"\n            brc = rc\n      y = msg(x)          /* reset msg status                    */\n            if brc > 0 then do\n               say \"IEBCOPY ok\"\n               say \"Copy \"dsn\".V2- created\"\n               say \"but \"dsn\" could not be renamed into \"dsn\".ANC-\"\n               say \"Code \"brc\" at rename time\"\n               say dsn\" *** unchanged ***\"\n               return\n            end /* if brc > 0                                    */\n      x = msg(\"off\")      /* quiet alter                         */\n      \"alter  '\"dsn\".V2-' newname('\"dsn\"')\"\n            crc = rc\n      y = msg(x)          /* reset msg status                    */\n            if crc > 0 then do\n               say \"IEBCOPY ok\"\n               say dsn\" was renamed into \"dsn\".ANC-\"\n               say \"but \"dsn\".V2- could not renamed into \"dsn\n               say \"and gave code \"crc\n               return\n            end /* if crc > 0                                    */\n      say \"IEBCOPY return code = \"xrc\n      x = msg(\"off\")      /* quiet delete attempt                */\n      \"delete '\"dsn\".ANC-' scratch purge\"\n            drc = rc\n      y = msg(x)          /* reset msg status                    */\n            if drc > 0 then do\n               say \"IEBCOPY ok but delete of \",\n                   \"old \"dsn\".ANC- not done\"\n               say \"code \"drc\" at delete time.\"\n               say dsn\" changed and correct\"\n               return\n            end /* if drc > 0                                    */\n\n      message = dsn\" changed to\"maxgens rest\n      message_length = length(message)\n      say copies('_',message_length)\n      say\n      say message\n      say copies('_',message_length)\n\n      x = msg(\"off\")      /* quiet delete attempt                */\n      /*  Attempt to delete IEBCOPY SYSPRINT:                    */\n      \"delete '\"dsnprint\"' scratch purge\"\n      y = msg(x)          /* reset msg status                    */\n      return\n    end /* if xrc = 0  iebcopy ok                                */\n\n    else do          /* xrc <> 0 iebcopy ko                      */\n    /* if iebcopy ko keep old dsn not modified                   */\n    /*               keep new V2 file                            */\n    /*               keep dsnprint                               */\n               say \"IEBCOPY return code = \"xrc\n               say dsn\" not modified\"\n               say \"New file \"dsn\".V2- kept\"\n               say \"IEBCOPY SYSPRINT kept\"\n               return                     /* xrc <> 0 iebcopy ko */\n    end /* if xrc <> 0  iebcopy ko                               */\n    return\n\n  /*_____________________________________________________________*/\n    whohas: procedure\n\n    dsn = word(arg(1),1)    /* first word                        */\n    dsn = strip(dsn,,\"'\")   /* remove surrounding quotes if any  */\n    upper dsn\n    /*___________________________________________________________*/\n    /*                                                           */\n    /* Set up commands                                           */\n\n    drop command.\n    command.0 = 1\n    command.1 = left('D GRS,RES=(SYSDSN,'dsn')',80)\n    /*___________________________________________________________*/\n    /*                                                           */\n    /* Execute command                                           */\n    /* Result in isfulog. stem                                   */\n\n     rc = isfcalls(\"on\")                    /* access = on       */\n     isfcons = \"sdsf\"random()               /* console = sdsfxxx */\n     isfdelay = 1 /* Wait 1 second before retrieving results     */\n     /* isfulog.0 = 2 if isfdelay = 0  delay is necessary        */\n     address sdsf isfslash \"(\"command.\") (wait)\"\n     xrc = rc                  /* save return code               */\n     rc = isfcalls(\"off\")                   /* access = off      */\n\n     if xrc > 0 then do\n        say \"execution of \"\n        do i = 1 to command.0\n          say '  'command.i\n        end /* do i = 1 to command.0                             */\n        say \"gave code \"xrc\n        say \"Continue as if no enqueue on \"dsn\n        return 0\n     end /* if xrc > 0                                           */\n     /*__________________________________________________________*/\n    /*                                                           */\n     /* Examine result                                           */\n\n     /* Search for 'NO REQUESTORS'                               */\n       do i = 2 to isfulog.0\n          if pos('NO REQUESTORS',isfulog.i) > 0 then do\n             enq_count = 0\n             leave\n          end /* if pos('NO REQUESTORS',isfulog.i) > 0           */\n       end /* do i = 2 to isfulog.0                              */\n\n       if enq_count = 0 then return 0 /* zero owner              */\n\n       enq_count = isfulog.0 - 5 /* number of owners             */\n\n       /* List owners                                            */\n          say 'Contention analysis for 'dsn':'\n          do i = 2 to isfulog.0\n             say isfulog.i\n          end /* do i = 2 to isfulog.0                           */\n\n       return enq_count     /* return number of owners           */\n  /*_____________________________________________________________*/\n    maxgens_limit:\n\n      cvt = c2d(storage(10,4))\n      cvtdfa = c2d(storage(d2x(cvt + 1216),4))\n      /* cvt + 4c0 */\n      dfamgen = c2d(storage(d2x(cvtdfa + 76),4))\n      /* dfa + 4c */\n      return dfamgen       /* system maxgens limit               */\n  /*_____________________________________________________________*/\n    checkdsn: procedure expose rexxname\n    /* Check syntax and existence.                               */\n    /* dsn assumed in upper characters                           */\n    parse arg dsn\n\n    dsn_msg = sysdsn(\"'\"dsn\"'\")\n    if dsn_msg <> 'OK' then do\n       say \"Dsname \"dsn\" is not correct: \"dsn_msg\n       say \"___________________________________________________________\"\n       say \" \"\n       say \"Error in \"rexxname\n       say \"       dsname = \"dsn\n       say \"Do not process.\"\n       say \"___________________________________________________________\"\n       say \" \"\n       return 4\n    end /* if sysdsn(\"'\"dsn\"'\") <> 'OK'                          */\n\n    return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WAIT": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\x01\\x00\\x01\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 1, "newlines": 1, "modlines": 0, "user": "MLEWIN"}, "text": "//WAIT     EXEC PGM=BPXBATCH,PARM='sh sleep 120'  ===> epdf /;man sleep\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WHERE": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00\\xf6\\x00\\xf6\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 246, "newlines": 246, "modlines": 0, "user": "MLEWIN"}, "text": "//USER01   JOB ,CLASS=X,TIME=6\n/*JOBPARM L=9999,BYTES=999999\n//*_________________________________________________________________\n//*       Search of generic member in generic libraries\n//*       (source, load, etc...)\n//*_________________________________________________________________\n//*       Where is member &MEMBER\n//*       in files with dsname corresponding to &LEVEL?\n//*       (Non migrated PDS or PDSE)\n//*_________________________________________________________________\n//*\n//        EXPORT SYMLIST=*\n//*\n//*       Input:\n//        SET MEMBER='A2DTFP2*'     Member searched for     Input\n//*       SET MEMBER='*2D%FP2*'     % 1 char, * n char\n//*\n//        SET LEVEL1='**.SOUR*'                             Input\n//        SET LEVEL2='**.COBOL'                             Input\n//*\n//*       Output:\n//        SET PREFIX=XX.YYYY        Prefix for user files\n//*       List of libraries with &MEMBER\n//        SET LIBS=&PREFIX..&SYSUID..WHERE.LIBS\n//*\n//*       List of libraries and member statistics,\n//*       ranked by decreasing order of last modification date\n//        SET MEMBERS=&PREFIX..&SYSUID..WHERE.MEMBERS\n//*\n//*       Output dsname unicity for parallelism:\n//        SET LIBS=&LIBS..J&LJDAY&LHR&LMIN Julian Hour Minute\n//        SET MEMBERS=&MEMBERS..J&LJDAY&LHR&LMIN\n//*_________________________________________________________________\n//*\n//DELDEF   PROC DSN=,RECFM=FB,LRECL=80,BLKSIZE=28320\n//*\n//DEL   EXEC PGM=IEFBR14\n//DEL      DD DISP=(MOD,DELETE,DELETE),SPACE=(TRK,0),\n//            DSN=&DSN\n//*\n//DEF   EXEC PGM=ICEGENER\n//SYSPRINT DD DUMMY\n//SYSIN    DD DUMMY\n//SYSUT2   DD DISP=(,CATLG),DSN=&DSN,\n//            RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE,\n//            SPACE=(CYL,(5,5))\n//SYSUT1   DD DUMMY,DCB=*.SYSUT2\n//DELDEF   PEND\n//*_________________________________________________________________\n//*\n//DELDEF1 EXEC DELDEF,DSN=&LIBS,LRECL=132,BLKSIZE=0\n//DELDEF2 EXEC DELDEF,DSN=&MEMBERS,LRECL=164,BLKSIZE=0\n//*_________________________________________________________________\n//*\n//PDSEASY EXEC PGM=PDSEASY,DYNAMNBR=3200\n//* DYNAMNBR\n//* from 0 through 3273 minus the number of DD statements in the step\n//EZYPRINT DD DISP=SHR,DSN=&LIBS  Output list of libraries with &MEMBER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *,SYMBOLS=EXECSYS\n DSL '&LEVEL1'                    /* Dataset List */\n APP '&LEVEL2'                    /* Append       */\n FINDMEM &MEMBER  ALL             /* FIND &MBR IN ALL DSNS */\n IF MESSAGE EQ '*Mem-Found'       /* MESSAGE <> ' ' */\n HC                               /* HARDCOPY REPORT */\n//*_________________________________________________________________\n//*\n//REXBAT   PROC\n//         EXEC PGM=IKJEFT1B,DYNAMNBR=500\n//ISPCTL1  DD DSN=&&ISPCTL1,DISP=(,DELETE),\n//         RECFM=FB,LRECL=80,BLKSIZE=27920\n//ISPFILE  DD DSN=&&ISPFILE,DISP=(,DELETE),\n//         RECFM=FB,LRECL=80,BLKSIZE=27920\n//ISPLOG  DD DSN=&&ISPLOG,UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//         LRECL=125,BLKSIZE=129,RECFM=VA\n//ISPPROF  DD DSN=&ISPPROF,DISP=NEW,UNIT=SYSDA,SPACE=(TRK,(15,15,5)),\n//         RECFM=FB,LRECL=80,BLKSIZE=3120\n//ISPPLIB  DD DISP=SHR,DSN=ISP.SISPPENU\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSENU\n//ISPTABL  DD DUMMY\n//ISPTLIB  DD RECFM=FB,LRECL=80,UNIT=VIO,SPACE=(TRK,(1,0,1))\n//         DD DISP=SHR,DSN=ISP.SISPTENU\n//ISPLLIB  DD DISP=SHR,DSN=ISP.SISPLOAD\n//SYSPROC  DD DISP=SHR,DSN=ISP.SISPCLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXEXEC\n//*SYSEXEC no //SYSEXEC due to IEBGENER use\n//SYSTSPRT DD SYSOUT=*,OUTLIM=50000\n//*        //SYSTSIN  DD DUMMY     Add at invokation\n//REXBAT   PEND\n//*_________________________________________________________________\n//*\n//GO       EXEC REXBAT,COND=(4,LT)\n//SYSTSIN  DD *,SYMBOLS=EXECSYS\nprofile noprefix\ncall *(iebgener)\nispstart cmd(%main &member)  bdispmax(999999)\n/*\n//LIBS     DD DISP=SHR,DSN=&LIBS       Input  file\n//MEMBERS  DD DISP=MOD,DSN=&MEMBERS    Output file\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT2   DD DSN=&&TEMPPDS(MAIN),UNIT=VIO,SPACE=(TRK,(1,1,1))\n//SYSEXEC  DD DSN=&&TEMPPDS,VOL=REF=*.SYSUT2,DISP=(OLD,DELETE)\n//SYSUT1   DD *\n /* rexx */\n trace o\n parse arg pattern .\n /* Example: pattern = \"A2DTFP2*\"                                    */\n /* pattern is &member in SYSTSIN control card:                      */\n /*         ispstart cmd(%main &member)  bdispmax(999999)            */\n /* pattern is a LMMLIST parameter.                                  */\n /* This rexx has name main.                                         */\n /*__________________________________________________________________*/\n /*     LMMLIST with pattern                                         */\n /*     on each of the libraries whose name                          */\n /*     is present in &LIBS.                                         */\n /*__________________________________________________________________*/\n /* Obtain libraries names and process (lmmlist) each library        */\n\n /* Second qualifier of:                                             */\n /*   (LMMLIST output with SAVE option:                              */\n /*   dsnmbrs = prefix'.'group'.MEMBERS')                            */\n group='T'time('s') /* second qualifier                              */\n\n \"execio * diskr libs (stem stem. finis\"\n do i = 1 to stem.0\n    if pos('*Mem-Found',stem.i) = 0 then iterate\n    dsn = word(stem.i,1)   /* first word of line                     */\n    call process_dsn\n end /* do i = 1 to stem.0                                           */\n\n  /* Clean up LMMLIST output.                                        */\n  address tso\n  x = msg(\"off\")\n      \"delete '\"dsnmbrs\"'\"\n  x = msg(x)\n  address\n\n zispfrc  = 0     /* return code thru ISPF  */\n address ispexec \"vput zispfrc\"\n exit 0\n\n /*__________________________________________________________________*/\n\n process_dsn: procedure expose dsn pattern group dsnmbrs\n /********************************************************************/\n /* Get dataid for data set and issue LMOPEN.                        */\n /********************************************************************/\n  address ispexec\n  \"control errors return\"\n  \"lminit dataid(data1) dataset('\"dsn\"')\"\n  xrc = rc\n  if xrc <> 0 then\n    do  /* lminit not ok */\n        say \"Error processing \"dsn\":\"\n        say \" lminit failed with \"xrc\" return code\"\n        return\n    end /* lminit not ok */\n\n \"lmopen dataid(\"data1\") option(input)\"\n  xrc = rc\n  if xrc <> 0 then\n    do  /* lmopen not ok */\n        say \"Error processing \"dsn\":\"\n        say \" lmopen failed with \"xrc\" return code\"\n    end /* lmopen not ok */\n\n /********************************************************************/\n /* Get statistics for specified members                             */\n /********************************************************************/\n\n  /* Set up profile prefix to userid if no prefix.                   */\n  address tso\n  prefix0 = sysvar('syspref')       /* tso profile prefix            */\n  if prefix0 = '' then do           /* noprefix                      */\n     uid = sysvar('sysuid')         /* use userid                    */\n    \"profile prefix(\"uid\")\"\n     prefix  = sysvar('syspref')    /* tso profile prefix            */\n  end /* if prefix0 = ''                                             */\n  else prefix = prefix0\n\n  /* Delete MEMBERS file preventively if it exists.                  */\n  dsnmbrs = prefix'.'group'.MEMBERS'\n  x = msg(\"off\")\n      \"delete '\"dsnmbrs\"'\"\n  x = msg(x)\n  address\n\n 'lmmlist dataid('data1')',\n 'option(save) stats(yes)',\n 'group('group') pattern('pattern') long'\n  xrc = rc\n\n  address tso\n  if prefix0 = '' then profile noprefix  /* restore      */\n  address\n\n  /* xrc = 4 if empty member list                        */\n  if xrc > 4 then\n     do  /* lmmlist option(save) not ok */\n     say \"Error processing \"dsn\":\"\n     say \" lmmlist option(save) failed with \"xrc\" return code\"\n     return\n  end /* lmmlist option(save) not ok */\n\n address tso\n \"alloc fi(ddnmbrs) da('\"dsnmbrs\"') shr reu\"\n 'execio * diskr ddnmbrs (stem members. finis'\n  do i = 1 to members.0\n     members.i = left(dsn,44)' 'members.i /* prefix by dsname */\n  end /* do i = 1 to members.0 */\n 'execio * diskw members (stem members. finis' /* DISP=MOD */\n address      /* resume previous environment */\n\n /********************************************************************/\n /* Clean up.                                                        */\n /********************************************************************/\n 'lmclose dataid('data1')'\n  xrc = rc\n  if xrc <> 0 then\n     do  /* lmclose not ok */\n     say \"Error processing \"dsn\":\"\n     say \" lmclose failed with \"xrc\" return code\"\n     return\n  end /* lmclose not ok */\n\n 'lmfree  dataid('data1')'\n  xrc = rc\n  if xrc <> 0 then\n     do  /* lmfree  not ok */\n     say \"Error processing \"dsn\":\"\n     say \" lmfree  failed with \"xrc\" return code\"\n     return\n  end /* lmfree  not ok */\n\n return\n//*_________________________________________________________________\n//* Sort by decreasing last modification date\n//*\n//LASTMOD  EXEC PGM=SORT,COND=(4,LT)\n//SORTIN   DD DISP=SHR,DSN=&MEMBERS    Input  file\n//SORTOUT  DD DISP=SHR,DSN=&MEMBERS    Output file\n//SYSOUT   DD SYSOUT=*\n SORT FIELDS=(104,10,CH,D)  Last modification date first (SOURCE)\n*SORT FIELDS=(91,8,CH,D)    Decreasing size              (LOAD)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHOHAS": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x184?\\x01\\x184?\\tB\\x00Q\\x00Q\\x00\\x00\\xd4\\xd3\\xc5\\xe6\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-09T00:00:00", "modifydate": "2018-12-09T09:42:46", "lines": 81, "newlines": 81, "modlines": 0, "user": "MLEWIN"}, "text": "  /* rexx */\n  trace o\n\n  /* Driver\n    dsn = 'USER01.LOAD'\n    enq_number = whohas(dsn) /* how many enqueues?             */\n    say \"enq_number = \"enq_number\n    exit\n    whohas: procedure\n  */\n\n  /*___________________________________________________________*/\n  /*                                                           */\n  /* Example of call:                                          */\n  /* enq_count = whohas(dsn)                                   */\n  /*                                                           */\n  /* Display result of /d grs,res=(sysdsn,dsn)                 */\n  /* and enq_count, the number of owners.                      */\n  /*                                                           */\n  dsn = word(arg(1),1)    /* first word                        */\n  dsn = strip(dsn,,\"'\")   /* remove surrounding quotes if any  */\n  upper dsn              /* uppercase                          */\n  say\n  say \"Example of use on Command line:                         \"\n  say \"Command ===> tso whohas USER01.LOAD                     \"\n  say\n  say \"Example of use in ISPF 3.4, before dsname:              \"\n  say \"whohas   USER01.LOAD1                                   \"\n  say\n  /*___________________________________________________________*/\n  /*                                                           */\n  /* Set up commands                                           */\n\n  drop command.\n  command.0 = 1\n  command.1 = left('D GRS,RES=(SYSDSN,'dsn')',80)\n  /*___________________________________________________________*/\n  /*                                                           */\n  /* Execute command                                           */\n  /* Result in isfulog. stem                                   */\n\n  rc = isfcalls(\"on\")                    /* access = on        */\n  isfcons = \"sdsf\"random()               /* console = sdsfxxx  */\n  isfdelay = 1 /* Wait 1 second before retrieving results      */\n  /* isfulog.0 = 2 if isfdelay = 0  delay is necessary         */\n  address sdsf isfslash \"(\"command.\") (wait)\"\n  xrc = rc                               /* save return code   */\n  rc = isfcalls(\"off\")                   /* access = off       */\n\n  if xrc > 0 then do\n     say \"execution of \"\n     do i = 1 to command.0\n        say '  'command.i\n      end /* do i = 1 to command.0                             */\n      say \"gave code \"xrc\n      return -1                          /* abnormal return    */\n  end /* if xrc > 0                                            */\n  /*___________________________________________________________*/\n  /*                                                           */\n  /* Examine result                                            */\n\n  /* enq_count is the number of owners                         */\n  /* Search for 'NO REQUESTORS'                                */\n  do i = 2 to isfulog.0\n     if pos('NO REQUESTORS',isfulog.i) > 0 then do\n        enq_count = 0\n        leave\n     end /* if pos('NO REQUESTORS',isfulog.i) > 0              */\n  end /* do i = 2 to isfulog.0                                 */\n\n  if enq_count <> 0 then enq_count = isfulog.0 - 5\n\n  /* List owners                                               */\n  say 'Contention analysis for 'dsn':'\n  do i = 2 to isfulog.0\n     say isfulog.i\n  end /* do i = 2 to isfulog.0                                 */\n  say \"Number of owners of dsn '\"dsn\"' = \"enq_count\n\n  return enq_count                       /* normal return      */\n  /*___________________________________________________________*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT985/FILE985.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT985", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}