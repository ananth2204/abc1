#pragma runopts(POSIX(ON),XPLINK(ON),ALL31(ON))
#define _OPEN_SYS_EXT 1
#define _OPEN_SOURCE 1
#define ISIS_ALLOW_OS_FUNCTIONS 1
#include "isisdef.h"
#define _OPEN_SYS_EXT 1
#define _OPEN_SOURCE 1
#define _ISOC99_SOURCE
#include "mvstool.hpp"

char * strupr(char *s)
ä
	if (NOT s) return (NULL);
	for(int i = 0;i<strlen(s);i++) sÄiÜ = toupper(sÄiÜ);
	return s;
ü

int memcmpi(const char * s1,const char * s2,int l)
ä
	for(int i = 0; i<l; i++)
		if ( tolower(s1ÄiÜ) - tolower(s2ÄiÜ) )
			return (tolower(s1ÄiÜ) - tolower(s2ÄiÜ));
	return 0;
ü

char * makeString(char * s,int l)
ä
	char * c = (char *)malloc(l+1);
	memcpy(c,s,l);
	cÄlÜ = 0;
	for(l;l;l--)
		if ( cÄl-1Ü NEQ ' ')  break;
	cÄlÜ = null;
	return c;
ü

int initTestCases(char * n,testRoutine f)
ä
	if (testCasesIndex==0)
		memset(&testCases,0,sizeof(testCases));
	testCasesÄtestCasesIndexÜ.name = n;
	testCasesÄtestCasesIndex++Ü.addr = f;
	return testCasesIndex;
ü

typedef struct smf14 * smf14P;
typedef struct smf30cas * smf30casP;
typedef struct smf30id  * smf30idP;
typedef struct smf30sap * smf30sapP;
typedef struct smf30cmp * smf30cmpP;
typedef struct smf30mse * smf30mseP;
typedef struct smf30ud  * smf30udP;
typedef struct smf30acs * smf30acsP;
typedef struct smf30dr  * smf30drP;
typedef struct smf30op  * smf30opP;
typedef struct smf30ura * smf30uraP;
typedef struct smf30ar  * smf30arP;
typedef struct smf30exp * smf30expP;
typedef struct smf30ops * smf30opsP;
typedef struct smf30rm  * smf30rmP;
typedef struct smf30prf * smf30prfP;
typedef struct smfrcd30 * smfrcd30P;
typedef struct smfrcd92 * smfrcd92P;
typedef struct smf92fcl * smf92fclP;
typedef struct smf92fop * smf92fopP;
typedef struct smf92fsm * smf92fsmP;
typedef struct smf92fsp * smf92fspP;
typedef struct smf92fsr * smf92fsrP;
typedef struct smf92fsu * smf92fsuP;
typedef struct smf92fsv * smf92fsvP;
typedef struct smf92id  * smf92idP;
typedef struct smf92mmp * smf92mmpP;
typedef struct smf92mun * smf92munP;
typedef struct smf92sss * smf92sssP;


const int     SMF_MAXBUFFER = 1024*1024;
const char * SMF_FILE = "//DD:SMF";
#define FT_DIR        1  //Directory File
#define FT_CHARSPEC   2      //Character Special File
#define FT_REGFILE    3      //Regular File
#define FT_FIFO       4      //Named Pipe (FIFO) File
#define FT_SYMLINK    5      //Symbolic link
#define FT_SOCKET     7      //Socket File                  ºD2A

#define sF(d,v) printf(" %s:%#10.4f(sec)Ön",#d,float(p->v)/100);
#define sI(d,v) printf(" %s:%dÖn",#d,p->v);

long long totalCPUsu = 0;
long long indepCPUsu = 0;

static int rst_14 = 0;
static int rst_15 = 0;
static int rst_30 = 0;
static int rsd_14 = 0;
static int rsd_15 = 0;
static int rsd_30 = 0;
static bool debugF = atoi(getenv("DEBUG_SMF"));
typedef struct
ä
	short int     _smf14esl;     /* LENGTH OF SECTION IN EXTENDED INFORMATION @L1A */
	char          _filler4;      /* RESERVED                                  @L1A */
	char          _smf14sty;     /* SECTION TYPE                              @L1A */
	unsigned char _smf14xf1;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 1    @L1A */
	unsigned char _smf14xf2;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 2    @L1A */
	unsigned char _smf14cdlÄ8Ü;  /* NUMBER OF BYTES OF COMPRESSED DATA READ   @L1A */
	unsigned char _smf14udlÄ8Ü;  /* NUMBER OF BYTES OF DATA READ OR WRITTEN   @L1A */
	unsigned char _smf14cdsÄ8Ü;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */
	unsigned char _smf14udsÄ8Ü;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */
	unsigned char _smf14cisÄ4Ü;  /* PHYSICAL BLOCK SIZE OF COMPRESSED FORMAT  @02C */
	short int     _smf14tkl;     /* DICTIONARY TOKEN LENGTH(NOT INCLUDING     @L1A */
	unsigned char _smf14tknÄ36Ü; /* DICTIONARY TOKEN FOR COMPRESSED FORMAT    @02C */
	unsigned char _filler5Ä53Ü;
ü
* smf14EISP;

typedef struct
ä
	unsigned char _filler8Ä4Ü;
	unsigned char _smf14spnÄ8Ü;   /* STEP NAME                                 @L2A */
	unsigned char _smf14pgnÄ8Ü;   /* ACTIVE PROGRAM NAME                       @L2A */
	unsigned char _filler9Ä113Ü;
ü
* smf14STEP;
char pstepnameÄ9Ü;
char pprognameÄ256Ü;
char stepnameÄ9Ü;
int write_30 = 0;
char jobnameÄ9Ü;
char jobidÄ9Ü = "";
char usernameÄ128Ü;
static int countersÄ256Ü;
static int total_read = 0;
static int total_write = 0;
static int total_dir = 0;
int printSMF(char * b,bool & idflag,size_t rl,int need30 = 1, int  need92 = 1)
ä
	//printf(" LRECL:%5.5d %8.8x %8.8x %8.8x %8.8x Ön",l,*(int *)b,*(int *)(b+4),*(int *)(b+8),*(int *)(b+12));
	countersÄsmfrcd30P(b)->smf30rtyÜ++;
	switch(smfrcd30P(b)->smf30rty)
	ä
	case 2:
		//printf(" >>>start of dump>>>Ön");
		break;
	case 3:
		//printf(" >>>end of dump>>>Ön");
		break;
	case 14:
	case 15:
		ä
			char prognameÄ256Ü;
			smf14P smf14p = (smf14P)b;
			int sdc = smf14p->smf14sdc; //size of DCB segment
			int nuc = smf14p->smf14nuc; //no. of UCB sections
			int suc = smf14p->smf14suc; //size of each of UCB sections
			int excp = 0;
			memcpy(&rst_15,smf14p->smf14rst,4);
			memcpy(&rsd_15,smf14p->smf14rsd,4);
			if (rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))
				break;
			if (nuc > 0)
				excp = *(int*)smf14p->smfexcp;
			if (excp == 0)
				break;
			if (debugF)
				_dump(" SMF 14 or 15 record dump",b,rl);
			ä
				unsigned char* dcbp = smf14p->smfdcbor; //DCB Section
				unsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section
				unsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section
				unsigned char* eisp = ucbp + nuc*suc;
				short int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Sections
				unsigned char* eispr = eisp + 2;
				short int eispl = 1; //length of next Extended Information Section
				int write_14_15 = 0; //=0 do not write line
				char stepname_14Ä9Ü;
				char progname_14Ä9Ü;
				while (smf14esll > 0 && eispl > 0)
				ä
					eispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section
					char sty = ((smf14EISP)eispr)->_smf14sty; //Section type
					switch(sty)
					ä
					case smf14stp:
						strncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);
						strncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);
						stepname_14Ä8Ü = 0;
						progname_14Ä8Ü = 0;
						if (*pstepname == 0 && *pprogname == 0)
							write_14_15 = 1;
						else if (*pstepname && |strcasecmp(stepname_14,pstepname))
							write_14_15 = 1;
						else if (*pprogname && |strcasecmp(progname_14,pprogname))
							write_14_15 = 1;
						break;
					default:
						break;
					ü
					smf14esll -= eispl;
					eispr += eispl;
					//printf("smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%dÖn",smf14p,ucbp,eispr,eisp,smf14esll);
				ü
				if (write_14_15)
				ä
					char dsnameÄ45Ü;
					write_30 = 1; //write step sum
					/*
					if (*stepname == 0)
					ä
					strcpy(stepname,stepname_14);
					strcpy(progname,progname_14);
					printf(" === Start stepname:'%s' progname:'%s' ===Ön",stepname,progname);
					ü
					*/
					strncpy(dsname,(const char*)smf14p->smfjfcb1,44);
					dsnameÄ44Ü = 0;
					printf("%8.8s %s' excp=%8d ",smf14p->smftioe5,dsname,excp);
					if (smfrcd30P(b)->smf30rty == 14)
						printf("input ");
					else
						printf("output ");
					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14dad)
						printf("DASD ");
					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14tds)
						printf("Temporary ");
					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14vio)
						printf("VIO ");
					printf("Ön");
				ü
			ü
		ü
		break;
	case 30:
		// Identification section

		//if (*(short *)(smfrcd30P(b)->smf30stp)|=5)
		//  break;
		switch (*(short *)(smfrcd30P(b)->smf30stp))
		ä
		case 1:
			if (argvÄ1Ü&&memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)
			ä
				memcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);
				jobidÄ8Ü = 0;
				memcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
				jobnameÄ8Ü = 0;
				memcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);
				usernameÄ8Ü = 0;
				rst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;
				memcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);
			ü
			else
				return 0;
			break;
		case 2:
			return 0;
			break;
		case 3:
			return 0;
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		default:
			break;
		ü
		if (memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))
			break;
		switch (*(short *)(smfrcd30P(b)->smf30stp))
		ä
		case 1:
			printf(" ============================== J O B S T A R T ===================Ön");
			break;
		case 4:
			printf(" ========================= S T E P T O T A L ======================Ön");
			break;
		case 5:
			printf(" ====================== J O B T E R M I N A T I O N  =============Ön");
			break;
		case 6:
			printf(" ===========System address space=====================================Ön");
			break;
		default:
			break;
		ü
		int rest , v , ss, mm, hh;
		rest = (*(int *)smfrcd30P(b)->smf30tme)%100;
		v =  (*(int *)smfrcd30P(b)->smf30tme)/100;
		ss = v%60;
		v /= 60;
		mm = v%60;
		hh = v/60;

		if (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)
		ä
			smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
			if (debugF)
			ä
				_dump(" SMF 30 record dump",b,rl);
				printf(" Subsystem     :%dÖn",*(short *)(smfrcd30P(b)->smf30son));
				printf(" Identification :%dÖn",*(short *)(smfrcd30P(b)->smf30ion));
				printf(" I/O Activity :%dÖn",*(short *)(smfrcd30P(b)->smf30uon));
				printf(" Completion :%dÖn",*(short *)(smfrcd30P(b)->smf30ton));
				printf(" Processor  :%dÖn",*(short *)(smfrcd30P(b)->smf30con));
				printf(" Accounting :%dÖn",*(short *)(smfrcd30P(b)->smf30aon));
				printf(" Storage    :%dÖn",*(short *)(smfrcd30P(b)->smf30ron));
				printf(" Performance :%dÖn",*(short *)(smfrcd30P(b)->smf30pon));
				printf(" Operator   :%dÖn",*(short *)(smfrcd30P(b)->smf30oon));
				printf(" EXCP       :%dÖn",*(short *)(smfrcd30P(b)->smf30eon));
				printf(" APPC       :%dÖn",*(short *)(smfrcd30P(b)->smf30drn));
				printf(" OMVS       :%dÖn",*(short *)(smfrcd30P(b)->smf30opn));
				printf(" Usage      :%dÖn",*(short *)(smfrcd30P(b)->smf30udn));
			ü
			printf(" Job:%8.8s JobId:%8.8s Step:%8.8s User:%20.20s RacfGrp:%8.8s RacfUsr:%8.8sÖn",
				p->smf30jbn,jobid,p->smf30stm,p->smf30usr,p->smf30grp,p->smf30rud);
			printf(" Program:%8.8s",p->smf30pgm);
			idflag = true;
		ü
		printf(" Record Created at:%2.2d:%2.2d:%2.2d:%2.2dÖn",hh,mm,ss,rest);
		// I/O activity
		if (*(short *)(smfrcd30P(b)->smf30uon))
		ä
			smf30uraP p = smf30uraP(b+smfrcd30P(b)->smf30uof);
			printf(" Accumplated EXCP count:%8.8dÖn",
				p->smf30tep);
		ü
		// Processor cumulative CPU
		if (*(short *)(smfrcd30P(b)->smf30con))
		ä
			smf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);
			printf(" Total CPU time:%#10.4f(sec) SRB time:%#10.4f(sec)Ön",
				float(p->smf30cpt)/100,float(p->smf30cps)/100);
			/*
			sF(process I/O interrupts,smf30iip)
			sF(client and preempt SRB,smf30asr)
			sF(independent enclave,smf30enc)
			sF(dependent enclave,smf30det)
			*/
		ü
		// EXCP section
		if (*(short *)(smfrcd30P(b)->smf30eon))
		ä
			smf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);
			for(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)
			ä
				if (p->smf30blk)
					printf(" Device(CUA):%2.2X%2.2X EXCP count:%8.8dÖn",
					p->smf30cuaÄ0Ü,p->smf30cuaÄ1Ü,p->smf30blk);
				p = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);
			ü
		ü
		// Storage
		if (*(short *)(smfrcd30P(b)->smf30ron))
		ä
			smf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);
			printf(" Max Region Size:%8.8d(Mbyte) Max Allocated Storage:%8.8d(Mbyte)Ön",
				(*(int *)p->smf30rgn)/1024,p->smf30eur/(1024*1024));
		ü

		// Performance
		if (*(short *)(smfrcd30P(b)->smf30pon))
		ä
			smf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);
			printf(" Total Service units:%8.8d CPU:%8.8d SRB:%8.8d I/O:%8.8dÖn",
				p->smf30srv,p->smf30csu,p->smf30srb,p->smf30io);
			totalCPUsu  += p->smf30csu;
			indepCPUsu += p->smf30esu;
			/*
			sI(Independent enclave tansaction active,smf30eta);
			sI(Independent enclave CPU service uints,smf30esu);
			sI(Independent enclave trasnsaction count,smf30etc);
			*/
		ü

		// Operator
		if (*(short *)(smfrcd30P(b)->smf30oon))
		ä
			smf30opsP p = smf30opsP(b+smfrcd30P(b)->smf30oof);
			if (p->smf30pdm]]p->smf30prd)
				printf(" Non Specific mounts :%8.8d Specific mounts:%8.8dÖn",
				p->smf30pdm,p->smf30prd);
			if (p->smf30mtm]]p->smf30msr)
				printf(" SMS Non Specific mounts:%8.8d Specific mounts:%8.8dÖn",
				p->smf30mtm,p->smf30msr);

		ü
		// Open Edition
		if (*(short *)smfrcd30P(b)->smf30opn)
		ä
			smf30opP p = smf30opP(b+*(int *)smfrcd30P(b)->smf30opo);
			for(int i=0;i<*(short*)smfrcd30P(b)->smf30opn;i++)
			ä
				printf(" Process:%d Process group:%d User:%d Group:%d Session:%dÖn",
					p->smf30opi,p->smf30opg,p->smf30oui,p->smf30oug,p->smf30osi);
				printf(" CPU:%#10.2f(sec) Kernel Calls:%d Ön",
					float(p->smf30ost)/100,p->smf30osc);
				printf(" Directory Reads:%8.8dÖn",p->smf30odr);
				printf(" Regular file   :%8.8d %8.8dÖn",p->smf30ofr,p->smf30ofw);
				printf(" Pipe       :%8.8d %8.8dÖn",p->smf30opr,p->smf30opw);
				printf(" Special file :%8.8d %8.8dÖn",p->smf30osr,p->smf30osw);
				printf(" Path lookup :%8.8d %8.8dÖn",p->smf30oll,p->smf30olp);
				printf(" Path generation:%8.8d %8.8dÖn",p->smf30ogl,p->smf30ogp);
				printf(" Socket     :%8.8d %8.8dÖn",p->smf30okr,p->smf30okw);
				printf(" Message queue :%8.8d %8.8dÖn",p->smf30oms,p->smf30omr);
				p = smf30opP((char *)p+*(short *)smfrcd30P(b)->smf30opl);
			ü
			printf(" Total_read : %8.8dÖn",total_read);
			printf(" Total_write : %8.8dÖn",total_write);
			printf(" Total_dir : %8.8dÖn",total_dir);

			total_read = total_write = total_dir = 0;
		ü
		printf(" ====================================================================Ön");
		if (*(short *)(smfrcd30P(b)->smf30stp)==5)
			return 5;
		break;

		break;
	case 42:
		if (smfrcd92P(b)->smf92stp==6)
		ä
			_dump(" SMF 42 record dump",b,rl);
			break;
		ü
	case 92:
		if (smfrcd92P(b)->smf92stp==5)
		ä
			_dump(" SMF 92 record dump",b,rl);
			break;
		ü

		if (smfrcd92P(b)->smf92ion)
		ä

			smf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);
			if (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)
				]]memcmp(jobname,pid->smf92jbn,8))
				break;
			//if (|need92]](strlen(argvÄ1Ü)&&memcmp(jobid,argvÄ1Ü,strlen(argvÄ1Ü))))
			if (debugF)
				_dump(" SMF 92 record dump",b,rl);
			int rest , v , ss, mm, hh;
			rest = smfrcd92P(b)->smf92tme%100;
			v = smfrcd92P(b)->smf92tme/100;
			ss = v%60;
			v /= 60;
			mm = v%60;
			hh = v/60;
			switch (smfrcd92P(b)->smf92stp)
			ä
			case 11:
				if (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)
				ä
					smf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);
					for(int i=0;i<smfrcd92P(b)->smf92don;i++)
					ä
						char nameÄ65Ü;
						nameÄ64Ü=0;
						if (p->smf92cty==FT_SOCKET)
							sprintf(name," SOCKET inode:%d device:%d",p->smf92cin,p->smf92cdn);
						else
							memcpy(name,p->smf92cpn,sizeof(p->smf92cpn));
						/*
						printf(" Job:%8.8s at:%2.2d:%2.2d:%2.2d:%2.2d closing:%sÖn",pid->smf92jbn,hh,mm,ss,rest,name);
						printf(" Process:%d User:%d Group:%dÖn",
						pid->smf92pid,pid->smf92uid,pid->smf92gid);

						if (p->smf92cdi)
						printf(" Directory I/O blocks :%8.8dÖn",p->smf92cdi);
						if (p->smf92cir]]p->smf92csr)
						printf(" I/O blocks read :%8.8d read calls :%dÖn",
						p->smf92cir,p->smf92csr);
						if (p->smf92ciw]]p->smf92csw)
						printf(" I/O blocks write :%8.8d write calls:%dÖn",
						p->smf92ciw,p->smf92csw);
						*/
						printf("'%s' r:%8.8d w:%8.8d d:%8.8d pid:%dÖn",name,p->smf92cir,p->smf92ciw,p->smf92cdi,pid->smf92pid);
						total_read +=p->smf92cir;
						total_write += p->smf92ciw;
						total_dir += p->smf92cdi;
						p = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);
					ü
				ü
			case 13:
				//if (*(short *)smfrcd92P(b)->smf92don)
				if (0)
				ä
					smf92munP p = smf92munP(b+smfrcd92P(b)->smf92dof);
					for(int i=0;i<*(short*)smfrcd92P(b)->smf92don;i++)
					ä
						if (p->smf92mutk)
							printf(" Memory map token:%8.8d size:%8.8d read:%8.8d write:%8.8d (I/O blocks)Ön",
							p->smf92mutk,p->smf92musz,p->smf92muir,p->smf92muiw);
						p = smf92munP((char *)p+smfrcd92P(b)->smf92dln);
					ü
				ü
			default:
				break;
			ü
		ü
		break;
	default:
		//  printf(" invalid typeÖn");
		break;
	ü
	return 0;
ü

static time_t set_epoch()
ä
	unsigned long long t19720101 = (0x8126D60E46000000LL>>12)/1000000;
	struct tm _tm;
	memset(&_tm,0,sizeof(_tm));
	_tm.tm_year = 72;
	_tm.tm_isdst = 0;
	_tm.tm_mday = 0;
	time_t r = mktime(&_tm);
	r = 63072000;
	//printf("epoch:%u r:%u diff:%uÖn",(unsigned long)t19720101,r,(unsigned long )(t19720101-r));
	return (t19720101-r);
ü

const  time_t epoch = set_epoch();


char * formatTime(pULL tod)
ä
	static char wÄ128Ü;
	unsigned long t, rest, v, ss, mm, hh;
	ULL tt = (*tod>>12)/1000;
	t =tt%(1000*60*60*24);
	rest = t%1000;
	v = t/1000;
	ss =  v%60;
	v /= 60;
	mm =  v%60;
	hh =  v/60;
	sprintf(w,"%2.2d:%2.2d:%2.2d.%3.3d",hh,mm,ss,rest);
	return w;
ü



char * var(char * v0,int i0,char * v1 = NULL,int i1 = 0, char * v2 =NULL)
ä
	static char retÄ256Ü;
	strcpy(ret,v0);
	sprintf(ret+strlen(ret),".%d",i0);
	if (v1)
	ä
		strcat(ret,".");
		strcat(ret,v1);

		if (v2)
		ä
			sprintf(ret+strlen(ret),".%d",i1);
			strcat(ret,".");
			strcat(ret,v2);
		ü
	ü
	return strupr(ret);
ü

typedef struct dscb DSCB;

struct ext
ä
	unsigned char flag ;
	unsigned char seq;
	short        CC;
	short        HH;
	short        hCC;
	short        hHH;
ü;

typedef struct ext EXT;

static char _date2TextÄ80Ü;

char * date2Text(unsigned int d)
ä

	int yy =d/0x10000;
	int tt =d%0x10000;
	int dayÄÜ = ä31,28,31,30,31,30,31,31,30,31,30,31ü;
	if ( yy%4 == 0 )
		dayÄ1Ü = 29;
	int i = 0;
	for(i;i<12;i++)
		if ((tt-dayÄiÜ)<0) break;
		else
			tt-=dayÄiÜ;
	i++;
	sprintf(_date2Text,"%4.4d/%2.2d/%2.2d",yy+1900,i,tt);
	return _date2Text;
ü

int allocated(EXT * e)
ä
	if (e->flag ==0 )
		return 0;
	else
		return((e->hCC*15+e->hHH)-(e->CC*15+e->HH)+1);
ü

unsigned int bit24Int(char * c)
ä
	return(*(unsigned int *)(c-1)&0x007FFFFF);
ü

struct CatInfo
ä
	char type;
	char dsnÄ44Ü;
	char volÄ6Ü;
ü;

typedef struct CatInfo CATINFO;

struct ISPF_Stats
ä
	unsigned int ver:8;
	unsigned int mod:8;
	unsigned int flags:8;
	unsigned int mod_sec:8;

	unsigned int cr_date_rsv:8;
	unsigned int cr_date_y:8;
	unsigned int cr_date_d:12;
	unsigned int cr_date_f:4;

	unsigned int mod_date_rsv:8;
	unsigned int mod_date_y:8;
	unsigned int mod_date_d:12;
	unsigned int mod_date_f:4;

	unsigned int mod_hh:8;
	unsigned int mod_mm:8;
	short lines;

	short ilines;
	short m_lines;

	char userÄ7Ü;
	char rsvdÄ3Ü;
ü;

typedef struct ISPF_Stats ISPF;

int _rexxlist()
ä
	char maskÄ45Ü;
	char mmaskÄ9Ü;
	bool dir = false;
	bool migr = false;
	bool debug = false;
	bool exact = false;
	CATINFO catinfo;

	if (argc < 2 )
		return -1;
	strcpy(mask,strupr(argvÄ1Ü));
	for (int i =2;i<argc;i++)
	ä
		if ( strcasecmp(argvÄiÜ,"DIR")==0)
		ä
			dir = true;
			if (i+1<argc)
				strcpy(mmask,strupr(argvÄ++iÜ));
			else
				strcpy(mmask,"*");
		ü
		else
			if ( strcasecmp(argvÄiÜ,"EXACT")==0)
			ä
				dir = true;
				exact = true;
				if (i+1<argc)
					strcpy(mmask,strupr(argvÄ++iÜ));
				else
					strcpy(mmask,"*");
			ü
			else
				if (strcasecmp(argvÄiÜ,"MIGR") == 0)
					migr = true;
				else
					if (strcasecmp(argvÄiÜ,"DEBUG") == 0)
						debug = true;

	ü
	REXXVAR rexx(debug);
	CmdService::debug = debug;
	if (debug)
		printf(" catalog:%s member:%sÖn",mask,mmask);
	DsnCmdService serv;
	int index = 0;
	int rc = serv.cmd(mask,(char *)&catinfo);
	while(rc==1)
	ä
		if (debug)
			_dump("catalog",(char *)&catinfo,sizeof(catinfo));
		if ((catinfo.type == 'A' ]] catinfo.type == 'C'))
		ä
			int online = memcmp("MIGRAT",catinfo.vol,sizeof(catinfo.vol));
			index++;
			rexx.set(var("DS",0),index);
			rexx.set(var("DS",index,"dsn"),catinfo.dsn,sizeof(catinfo.dsn));
			rexx.set(var("DS",index,"vol"),catinfo.vol,sizeof(catinfo.vol));
			rexx.set(var("DS",index,"online"),online);
			rexx.set(var("DS",index,"member"),0);

			if (online)
			ä
				DSCB f1dscb;
				F3DSCB _f3dscb;
				memset(&f1dscb,0,sizeof(f1dscb));

				memcpy(f1dscb.ds1dsnam,(char *)catinfo.dsn,sizeof(catinfo.dsn));
				if (mvs()->Obtain((const char *)f1dscb.ds1dsnam,catinfo.vol,(char *)&f1dscb.ds1fmtid)==0)
				ä
					rexx.set(var("DS",index,"credt"),date2Text(bit24Int((char *)f1dscb.ds1credt)));
					rexx.set(var("DS",index,"expdt"),date2Text(bit24Int((char *)f1dscb.ds1expdt)));
					rexx.set(var("DS",index,"refdt"),date2Text(bit24Int((char *)f1dscb.ds1refd)));

					if (f1dscb.ds1dsorgÄ0Ü&ds1dsgps)
						rexx.set(var("DS",index,"dsorg"),"PS");
					else
						if (f1dscb.ds1dsorgÄ0Ü&ds1dsgpo)
							rexx.set(var("DS",index,"dsorg"),"PO");
						else
							if (f1dscb.ds1dsorgÄ0Ü&ds1acbm)
								rexx.set(var("DS",index,"dsorg"),"VSAM");
							else
								rexx.set(var("DS",index,"dsorg"),"????");
					char recfmÄÜ = " ";
					int ind = 0;
					if (f1dscb.ds1recfm==ds1recfu)
						recfmÄ0Ü = 'U';
					else
					ä
						if (f1dscb.ds1recfm&ds1recff)
							recfmÄ0Ü = 'F';
						else
							if (f1dscb.ds1recfm&ds1recfv)
								recfmÄ0Ü = 'V';
						if (f1dscb.ds1recfm&ds1recfb)
							recfmÄ++indÜ = 'B';
						if (f1dscb.ds1recfm&ds1recfa)
							recfmÄ++indÜ ='A';
						else
							if (f1dscb.ds1recfm&ds1recmc)
								recfmÄ++indÜ ='M';
					ü
					recfmÄind+1Ü = 0;
					rexx.set(var("DS",index,"recfm"),recfm);
					rexx.set(var("DS",index,"blksize"),int(*(short *)f1dscb.ds1blkl));
					rexx.set(var("DS",index,"lrecl"),int(*(short *)f1dscb.ds1lrecl));
					int alloc = allocated((EXT *)f1dscb.ds1ext1)+
						allocated((EXT *)f1dscb.ds1ext2)+
						allocated((EXT *)f1dscb.ds1ext3);
					memcpy(_f3dscb.ds3ptrds,f1dscb.ds1ptrds,5);
					if (debug)
						_dump("F3DSCB addr",(char *)&_f3dscb.ds3ptrds,5);
					while (memcmp(_f3dscb.ds3ptrds,nulls,5)&&(mvs()->Obtain((const char *)_f3dscb.ds3ptrds,catinfo.vol,(char *)&_f3dscb)==0))
					ä
						if (debug)
							_dump("F3DSCB",(char *)&_f3dscb,sizeof(_f3dscb));
						EXT *  ext = (EXT * )&_f3dscb.ds3extnt;
						for (int i =0;i<4;i++)
							alloc+= allocated(ext+i);
						ext = (EXT * )&_f3dscb.ds3adext;
						for (int i =0;i<9;i++)
							alloc+= allocated(ext+i);
					ü
					rexx.set(var("DS",index,"alloc"),alloc);
					if (dir&&(f1dscb.ds1dsorgÄ0Ü&ds1dsgpo))
					ä
						char patternÄ128Ü="//";
						memcpy(pattern+2,catinfo.dsn,sizeof(catinfo.dsn));
						patternÄ46Ü =0;
						if (strchr(pattern,' '))
							*strchr(pattern,' ') = 0;

						strcat(pattern,"(*)");
						/*
						strcat(pattern,"(");
						strcat(pattern,mmask);
						strcat(pattern,")");
						*/
						DSNINFO dsninfo;
						int mindex = 0;
						memset(&dsninfo,0,sizeof(dsninfo));
						int rcd = osdfind(&dsninfo,pattern);
						if (debug)
						ä
							printf(" osdfind:%s %dÖn",pattern,rcd);
							_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));
						ü
						while(rcd>=0)
						ä
							if ((|exact&&stcpma(dsninfo.mem,mmask))]](exact&&strcmp(dsninfo.mem,mmask)==0))
							ä
								mindex++;
								rexx.set(var("DS",index,"member"),mindex);
								rexx.set(var("DS",index,"member",mindex,"name"),dsninfo.mem);
								rexx.set(var("DS",index,"member",mindex,"alias"),dsninfo.alias);

								if (dsninfo.user_data_halfwords*2 == sizeof(ISPF))
								ä
									ISPF * ispf =(ISPF *)dsninfo.user_data;
									rexx.set(var("DS",index,"member",mindex,"size"),ispf->lines);
									rexx.set(var("DS",index,"member",mindex,"user"),ispf->user);
									rexx.set(var("DS",index,"member",mindex,"created"),date2Text(cvb(ispf->cr_date_y,2)*0x10000+cvb(ispf->cr_date_d,3)));
									rexx.set(var("DS",index,"member",mindex,"modified"),date2Text(cvb(ispf->mod_date_y,2)*0x10000+cvb(ispf->mod_date_d,3)));
								ü
								else
								ä
									rexx.set(var("DS",index,"member",mindex,"size"),"");
									rexx.set(var("DS",index,"member",mindex,"user"),"");
									rexx.set(var("DS",index,"member",mindex,"created"),"");
									rexx.set(var("DS",index,"member",mindex,"modified"),"");
								ü
							ü
							rcd = osdnext(&dsninfo);
							if (debug)
							ä
								printf(" osdnext:%s %dÖn",pattern,rcd);
								_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));
							ü
						ü
						osdquit(&dsninfo);
					ü
				ü
				else
				ä
					rexx.set(var("DS",index,"credt"),"");
					rexx.set(var("DS",index,"expdt"),"");
					rexx.set(var("DS",index,"refdt"),"");
					rexx.set(var("DS",index,"dsorg"),"");
					rexx.set(var("DS",index,"recfm"),"");
					rexx.set(var("DS",index,"lrecl"),"");
					rexx.set(var("DS",index,"blksize"),"");
					rexx.set(var("DS",index,"alloc"),"");

				ü
			ü
		ü
		rc = serv.cmd(NULL,(char *)&catinfo);
	ü
ü

#define DEF_TAB_SIZE  128000
class tablePull
ä
private:
	char tablenameÄ256Ü;
	FILE * table;
	char * t;
	char * p ;
	size_t rl;
	size_t total ;
	size_t offset;
	bool ok;

public:
	tablePull(const char *n)
	ä
		char wÄ256Ü;
		ok = false;
		strcpy(tablename,n);
		table = fopen(genOpenName(tablename,w),"rb");
		if (table==NULL)
		ä
			printf(" unbale to open:%sÖn",tablename);
			return ;
		ü
		t  = (char *)malloc(DEF_TAB_SIZE);
		p = t;
		total = DEF_TAB_SIZE;
		rl = total;

		if (t==NULL)
		ä
			printf(" unbale to allocte:%s bytesÖn",total);
			return ;
		ü
		bool cont = true;

		while(cont)
		ä
			size_t rlr =fread(p,1,rl,table);
			if (rlr>=0)
				total +=rlr;
			if (feof(table)]]rlr<rl)
				cont = false;
			else
			ä
				t =(char *)realloc(t,total*2);
				p = t+rl;
				rl = total;
				total*=2;
				if (t==NULL)
				ä
					printf(" unbale to allocte:%s bytesÖn",total);
					return ;
				ü
			ü
		ü
		fclose(table);
		offset = 0;
		ok = true;
		p = t;
	ü

	unsigned short getShort()
	ä
		if  ((total-offset)>sizeof(short))
		ä
			unsigned short r = *(unsigned short *)p;
			p+=sizeof(short);
			offset-=sizeof(short);
			return r;
		ü
		else
			return -1;
	ü

	char * getString(size_t l)
	ä
		if  ((total-offset)>l)
		ä
			char * c = (char *)malloc(l+1);
			memcpy(c,p,l);
			cÄlÜ = 0;
			p+=l;
			offset-=l;
			return c;
		ü
		else
			abort();
		return NULL;
	ü

	bool isOk()
	ä
		return ok;
	ü
ü;

int _rexx4tab()
ä
	bool debug = false;
	for (int i =3;i<argc;i++)
	ä
		if (strcasecmp(argvÄiÜ,"DEBUG") == 0)
			debug = true;

	ü
	REXXVAR rexx(debug);
	char * variablesÄ256Ü;
	char  tableÄ9Ü;
	size_t numrows = 0;
	memset(&variables,0,sizeof(variables));
	tablePull pull(argc<2?"//DD:TABLE":argvÄ1Ü);
	//tablePull pull("//esa.maint.isptlib(infocust)");

	char * tablename = (argc<3?"TABLE":argvÄ2Ü);
	if (|pull.isOk())
		return 8;
	char * head =pull.getString(pull.getShort());
	memcpy(table,head+10,8);
	numrows = *(size_t *)(head+32);
	short temp = pull.getShort();
	char * cols = pull.getString(temp);
	size_t numcols = temp/16;
	rexx.set(var(tablename,0),numrows);
	rexx.set(var(tablename,0,"TABLE"),table);
	rexx.set(var(tablename,0,"COLS",0),numcols);
	for (int o =0 , i=0;colsÄoÜ;o+=16,i++)
	ä
		variablesÄiÜ =(char *) malloc(9);
		memset(variablesÄiÜ,0,9);
		for (int j=0;j<8&&(*(cols+o+2+j)-' ');j++)
			*(variablesÄiÜ+j) = *(cols+o+2+j);
		rexx.set(var(tablename,0,"COLS",i+1,"NAME"),variablesÄiÜ);
	ü
	short rl = 0;
	size_t rowindex = 0;
	while((rl=pull.getShort()) >0&& rowindex<numrows)
	ä
		char * row = pull.getString(rl);
		short numvar = *(short *)(row+4);
		free(row);
		short rowDataLength =pull.getShort();
		char * rowdata =pull.getString(rowDataLength);
		rowindex++;
		for(int i =0;i<numvar;i++)
		ä
			short offset = (*(short *)(rowdata+i*2))-22;
			if (offset>0&&offset<rowDataLength)
			ä
				short length = *(short *)(rowdata+offset);
				if (length > 0&& (offset+length)<rowDataLength)
				ä
					char * value =(char *)malloc(length+1);
					memcpy(value,rowdata+offset+2,length);
					valueÄlengthÜ = 0;
					rexx.set(var(tablename,rowindex,variablesÄiÜ),value,length);
					free(value);
				ü
				else
					rexx.set(var(tablename,rowindex,variablesÄiÜ),"");
			ü
			else
				rexx.set(var(tablename,rowindex,variablesÄiÜ),"");

		ü
		free(rowdata);
		free(row);
	ü
ü
int intDebug = 0;

char * cmdnext(UssCmdService &cmd,char * w=NULL)
ä
	char * c =cmd.next(w);
	//  if (intDebug)
	//  printf("%sÖn",c);
	return c;
ü
_browselogger()
ä
	printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold"));
	int rc = mvs()->LoggerOpen(argvÄ2Ü);
	const char * pointer = NULL;
	char dateÄ32Ü;
	*(int *)date =(13*3600+1*60+1)*100;
	strcpy(date+4,"2010242");
	size_t length = 0;
	size_t * lP   = &length;
	pasm PASM = NULL;
	//BrowseLogger(const char * & addr,size_t & length,int direction,int all,char * date_time)
	//return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)date_time));

	/* 18/11/05 LOGGER support
	* 13/01/06 browse logger
	*---------------------------------------------------------------------*
	* LOGGER support                                                     *
	* +0 0 connect to logger stream                                      *
	*  -1 discoonect                                                     *
	*   1 log a request                                                  *
	*   2 read logger from oldtoyoung                                    *
	*   3 read log from youngtoold (parm+8 contain addr , length)        *
	*   a stream to log                                                  *
	* +4 stream or logger name address                                   *
	* +8 length of the stream                                            *
	* +c time stemp field pointer                                        *
	*   +0 binary time value in .01 sec                                  *
	*   +4 DATE in YYYYDDD    char format                                *
	*---------------------------------------------------------------------*/

	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),atoi(argvÄ4Ü),NULL)==0)
	ä
		PASM = mvs()->getpasm();
		//if (debugF)

		if (0)
		ä
			_dump("logger rc",(char *)&(PASM->asm_rc),256);
			_dump("asm logger",(char *)&(PASM->asm_logger_length),
				(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
			_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
			_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
			printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
		ü
		unsigned short ubl = *(unsigned short *)pointer;
		int bl = ubl;
		bl-=4;
		//if (debugF)

		if (0)
			printf("length:%u bl:%d ubl:%uÖn",length,bl,ubl);
		char * p = (char *)pointer+4;
		while(bl>0)
		ä
			unsigned short url;
			url = *(unsigned short *)p;
			int rl = url;
			//  if (debugF)
			//    printf("head length:%uÖn",rl);
			if (rl==72)
			ä
				//  if (debugF)
				//    _dump("head",p,rl);
				p+=rl;
				bl-=rl;
				length-=rl;
				rl = *(short *)p;
				if (bl >0 && rl>0 && bl>rl)
				ä
					//  if (debugF)
					//  printf("rec length:%u (bl:%d)Ön",rl,bl);
					//  if (debugF)
					//    _dump("SMF rec",p,rl);
					bool idflag = false;
					if (printSMF(p,idflag,rl)==5)
						return 0;
					p+=rl;
					bl-=rl;
					length=-rl;
				ü
				else
					bl = 0;
			ü
			else
			ä
				bl = 0;
			ü
		ü
		//printf(" rc:%d p:%p l:%dÖn",rc,pointer,length);
	ü
	//printf(" rc:%d p:%p l:%dÖn",rc,pointer,length);
	if (debugF)
	ä
		_dump("asm logger",(char *)&(PASM->asm_logger_length),
			(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
		_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
		_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
		printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
	ü
	mvs()->LoggerClose();
	for(int i =0;i<255;i++)
		if (countersÄiÜ)
			printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
	return 0;
ü

int _rct()
ä
	cvtP      cvt = *(cvtP* )0x10;
	rmctP   rmct = (rmctP)cvt->cvtopctp;
	cctP     cct  = (cctP)rmct->rmctcct;
	ictP     ict  = (ictP)rmct->rmctict;
	mctP     mct  = (mctP)rmct->rmctmct;
	char buffÄ256Ü;
	buffÄ0Ü =0;
	FILE * reply = popen("uname -Ia","r");
	if (reply==NULL]]fgets(buff,sizeof(buff),reply)<=0)
		printf(" popen error %sÖn",strerror(errno));
	else
		fclose(reply);

	printf("System:%s Online CPU Count:%d RealStorage Size:%d (Mbyte)Ön",buff,cct->ccvrcpct,cvt->cvtrlstg/1024);
	int lihb = ict->icvslihb;
	int pib = ict->iccend._icvtpib;
	for(int i =0;i<6;i++)
	ä
		sleep(10);
		char ttÄ32Ü;
		char fmÄÜ = "%H:%M:%S ";
		formatTime(tt,sizeof(tt),fm);
		printf(" %s ======================================Ön CPU utilization:%d %% Available Frame Count:%d Ön",tt,cct->ccvutilp,cct->ccvlgfmc);
		printf(" I/O interrupt rates:: % d %dÖn",ict->icvslihb-lihb,ict->iccend._icvtpib-pib);
		printf(" Paging Rate:%dÖn",mct->mcvsipr);
		_dump("CCT",(char *)cct,sizeof(*cct));
		lihb = ict->icvslihb;
		pib = ict->iccend._icvtpib;
	ü
	return 0;
ü

int _spawn()
ä
	pid_t child;
	struct inheritance inherit;
	memset(&inherit,0,sizeof(inherit));
	int fd_count =  0;
	int fd_mapÄ1Ü ;

	const char *c_argvÄ10Ü, *c_envpÄ10Ü;
	c_argvÄ0Ü="mvsproc";
	int i = 0;
	for (i =1;i<=argc&&i<10;i++)
		c_argvÄiÜ = argvÄiÜ;
	c_argvÄ++iÜ = 0;
	char wÄ256Ü;
	sprintf(w,"_BPX_ACCOUNT=%s",argvÄ1Ü);
	c_envpÄ0Ü=w;
	c_envpÄ1Ü="_BPX_SHAREAS=NO";
	c_envpÄ2Ü="_BPX_JOBNAME=TTTTTTTT";
	c_envpÄ3Ü=NULL;

	/* Spawn the child process */
	child=spawnp("mvsproc", fd_count, NULL, &inherit, c_argv, c_envp);
	if(child==-1)
	ä
		printf("spawn error:%sÖn",strerror(errno));
		return(8);
	ü
	printf(" child:%dÖn",child);
	int status = 0;
	if (wait(&status)==-1)
		printf(" wait error:%s",strerror(errno));
	return 0;
ü

int _spawned()
ä
	//FILE *fp=fopen("spawntest.out","w");
	int i = 0;
	printf( "Environment:Ön");
	char *e = 0;
	char **env=environ;

	while(e=envÄi++Ü)
		printf( "%sÖn", e);
	printf( "ÖnÖn");
	i=0;
	printf("Args:Ön");
	while(e=argvÄi++Ü)
		printf("%sÖn", e);
	printf("ÖnÖn");
	return 0;

ü

int _brsmf()
ä
	return _browselogger();
ü


typedef struct r79cchnl * R79celem;
typedef struct smf79pro * Smf79pro;
typedef struct r79cchnl   R79cchnl;
typedef struct r793     * R793;
#if (0)
'00'X='00X:UNKNOWN'                              /*UNDEF*/
'01'X='01X:PARALLEL BLOCK MPX'                   /*BLOCK*/
'02'X='02X:PARALLEL BYTE MPX'                    /*BYTE*/
'03'X='03X:ESCON POINT TO POINT'                 /*CNC_P*/
'04'X='04X:ESCON SWITCHED OR POINT TO POINT'     /*CNC_?*/
'05'X='05X:ESCON SWITCHED POINT TO POINT'        /*CNC_S*/
'06'X='06X:ESCON PATH TO A BLOCK CONVERTER'      /*CVC*/
'07'X='07X:NATIVE INTERFACE'                     /*NTV*/
'08'X='08X:CTC POINT TO POINT'                   /*CTC_P*/
'09'X='09X:CTC SWITCHED POINT TO POINT'          /*CTC_S*/
'0A'X='0AX:CTC SWITCHED OR POINT TO POINT'       /*CTC_?*/
'0B'X='0BX:COUPLING FACILITY SENDER'             /*CFS*/
'0C'X='0CX:COUPLING FACILITY RECEIVER'           /*CFR*/
'0D'X='0DX:UNKNOWN'                              /*UNDEF*/
'0E'X='0EX:UNKNOWN'                              /*UNDEF*/
'0F'X='0FX:ESCON PATH TO A BYTE CONVERTER'       /*CBY*/
'10'X='10X:OSA EXPRESS'                          /*OSE*/
'11'X='11X:OSA DIRECT EXPRESS'                   /*OSD*/
'12'X='12X:OSA CHANNEL'                          /*OSA*/
'13'X='13X:INTERNAL SYSTEM DEVICE'               /*ISD*/
'14'X='14X:HSSI OPEN SYSTEM ADAPTER CHANNEL'     /*OSC*/
'15'X='15X:ETHERNET OPEN SYSTEM ADAPTER CHANL'   /*OSN*/
'16'X='16X:CLUSTER BUS SENDER'                   /*CBS*/
'17'X='17X:CLUSTER BUS RECEIVER'                 /*CBR*/
'18'X='18X:INTERNAL COUPLING ISC SENDER'         /*ICS*/
'19'X='19X:INTERNAL COUPLING ISC RECEIVER'       /*ICR*/
'1A'X='1AX:FICON POINT TO POINT'                 /*FC */
'1B'X='1BX:FICON SWITCHED'                       /*FC_S*/
'1C'X='1CX:FICON TO ESCON BRIDGE'                /*FCV*/
'1D'X='1DX:FICON INCOMPLETE'                     /*FC_?*/
'1E'X='1EX:DIRECT SYSTEM DEVICE'                 /*DSD */
'1F'X='1FX:EMULATED I/O'                         /*EIO */
'20'X='20X:RESERVED'                             /*UNDEF*/
'21'X='21X:INTEGRATED CLUSTER BUS PEER'          /*CBP*/
'22'X='22X:COUPLING FACILITY PEER'               /*CFP*/
'23'X='23X:INTERNAL COUPLING PEER'               /*ICP*/
'24'X='24X:INTERNAL QUEUED DIRECT COMM'          /*IQD*/
'25'X='25X:FCT CHANNEL'                          /*FCP*/
'26'X='26X:COUPLING OVER INFINIBAND'             /*CIB*/
'30'X='30X:OSA ZBX DATA'                         /*OSX*/
'31'X='31X:OSA ZBX MANAGEMENT'                   /*OSM*/
#endif
#define UINTF(n) (*(unsigned int *)(n))
#define INTF(n) (*(signed int *)(n))

//============================================================================

class line;
class dataset;
class jesJcl;
class DD;
class DDs;
class STEP;

static const int k32 = 32768;
static const int k1  = 1024;

enum lineType
ä
	unknown        =0,
	execStmt      =1,
	steplibStmt    =2,
	steplibStmtConcat =3,
	ddStmt        =4,
	ddStmtConcat  =5,
	inlineStmt    =6,
	inlineData    =7,
	sysoutStmt    =8
ü;


static const char * JCL_COMMENT        = "//*";
static const char * JCL_COMMENT_XX    = "XX*";
static const char * JCL_JES2          = "/*";
static const char * JCL_EXEC_PGM      = "PGM=";
static const char * JCL_EXEC_PARM     = "PARM=";
static const char * JCL_PROC          = "++";
static const char * JCL_SUBSTITUTION  = "IEFC653I SUBSTITUTION JCL - ";
static const char * JCL_DD_STMT       = "DD";
static const char * JCL_EXEC_STMT     = "EXEC";
static const char * JCL_STEPLIB_STMT  = "STEPLIB";
static const char * JCL_SYSIN         = "*";
static const char * JCL_SYSIN_DATA    = "DATA";
static const char * JCL_SYSIN_DATA_DLM= "DATA,DLM=";
static const char * JCL_SYSOUT        = "SYSOUT=";

const char * lineTypeTextÄÜ =
ä
	"unknown",
	"execStmt",
	"steplibStmt",
	"steplibStmtConcat",
	"ddStmt",
	"ddStmtConcat",
	"inlineStmt",
	"inlineData",
	"sysoutStmt"
ü;

const char * datasetStatusTextÄÜ=
ä
	"unknown",
	"dumpOk",
	"restoreOk",
	"markedForDump",
	"markedForRestore",
	"error"
ü;

const  char *  datasetDispTextÄÜ =
ä
	"unknownDisp",
	"temporary",
	"input",
	"output",
	"jes2",
	"instream",
	"included",
	"excluded"
	"errorDisp",
	NULL
ü;


struct _jclType ä
	char * n;
	int   t;
ü;

typedef struct _jclType jclType;
jclType jclTypesÄÜ=ä
	ä"JOB",0ü,
	ä"OUTPUT",1ü,
	ä"SET",2ü,
	ä"INCLUDE",3ü,
	ä"JCLLIB",4ü,
	ä"IF",5ü,
	ä"ENDIF",6ü,
	ä"ELSE",7ü,
	ä"COMMAND",8ü,
	ä"JOBLIB",9ü,
	ä"CTL",10ü,
	ä"ENDCTL",11ü,
	ä"XMIT",12ü,
	ä"PROC",13ü,
	ä"PEND",14ü,
	ä"EXEC",20ü,
	ä"DD",24ü,
	äNULL,-1ü
ü;

static const int TYPE_EXEC = 20;
static const int TYPE_DD   = 24;
static const int oS = 10;
static const int oN = 12;

static char actualStepNameÄ9Ü;
static char actualProcstepNameÄ9Ü;
static STEP * actualStep;

class line:public chainE
ä
private:
	DD * ddP;
	dataset * datasetP;
	lineType type;
public:
	line(const char *);
	ßline()
	äü
	lineType getLineType()
	ä
		return type;
	ü
	char * getLine()
	ä
		return chainEid;
	ü
	DD * getDD()
	ä
		return ddP;
	ü
	dataset * getDataset()
	ä
		return datasetP;
	ü
ü;

class DD:public chainE
ä
private:
	int index;
	line *   lineP;
	char *   member;
public:
	DD(char * n,int i = 0,line * l = NULL):chainE(n)
	ä
		JOBENV::DEBUG(1,"DD:",n);
		index = i;
		lineP = l;
		member = NULL;
	ü
	ßDD()äü
	void setMember(const char * m)
	ä
		member = strdup(m);
	ü
	char * getMember()
	ä
		return member;
	ü
	int getIndex()
	ä
		return index;
	ü
	void setIndex(int i)
	ä
		index = i;
	ü
	char * put(char * b)
	ä
		sprintf(b,"%s Type:%s Concat:%d Member:%s ",
			chainEid,
			lineTypeTextÄint(lineP->getLineType())Ü,
			index,
			(member?member:""));
		return b;
	ü
	line * getLine()
	ä
		return lineP;
	ü
ü;

class DDs:public mCHAIN
ä
public:
	static char lastddÄ9Ü;
	static  int concatIndex;
	DDs():mCHAIN()
	ä
		memset(lastdd,0,sizeof(lastdd));
		concatIndex = 0;
	ü
	ßDDs()äü
ü;


class dataset:public chainE
ä
public:
	enum datasetDisp
	ä
		unknownDisp,
		temporary,
		input,
		output,
		jes2,
		instream,
		included,
		excludedDisp,
		errorDisp
	ü;
	enum datasetStatus
	ä
		unknown,
		dumpOk,
		restoreOk,
		markedForDump,
		markedForRestore,
		error
	ü;
private:
	DD * ddListÄ256Ü;
	int iDdnames;
	datasetDisp  disp;
	datasetStatus status;
	char * newDsn;
	long long size;

public:
	static datasetStatus name2Status(const char * n)
	ä
		if (strcasecmp(n,"unknown")==0)
			return unknown;
		else
			if (strcasecmp(n,"dumpOk")==0)
				return dumpOk;
			else
				if (strcasecmp(n,"restoreOk")==0)
					return restoreOk;
				else
					if (strcasecmp(n,"markedForDump")==0)
						return markedForDump;
					else
						if (strcasecmp(n,"markedForRestore")==0)
							return markedForRestore;
						else
							return error;
	ü

	static datasetDisp name2Disp(const char *n)
	ä
		if (strcasecmp(n,"unknown")==0)
			return unknownDisp;
		else
			if (strcasecmp(n,"temporary")==0)
				return temporary;
		if (strcasecmp(n,"input")==0)
			return input;
		else
			if (strcasecmp(n,"output")==0)
				return output;
			else
				if (strcasecmp(n,"jes2")==0)
					return jes2;
				else
					if (strcasecmp(n,"instream")==0)
						return instream;
					else
						if (strcasecmp(n,"included")==0)
							return included;
						else
							if (strcasecmp(n,"excluded")==0)
								return excludedDisp;

							else
								return errorDisp;
	ü

	dataset(const char * n):chainE(n)
	ä
		JOBENV::DEBUG(1,"dataset:",(char *)n);
		status = unknown;
		disp = unknownDisp;
		memset(ddList,0,256*4);
		iDdnames = 0;
		size = 0;
		newDsn = "";
	ü
	ßdataset()
	äü
	void setNextDd(DD *d)
	ä
		ddListÄiDdnames++Ü = d;
		if (iDdnames>255)
			abort();
	ü
	void setStatus(datasetStatus s)
	ä
		status = s;
	ü
	void setDisp(datasetDisp d)
	ä
		disp=d;
	ü
	DD * getFirstDd()
	ä
		iDdnames = 0;
		return ddListÄiDdnames++Ü;
	ü
	DD * getNextDd()
	ä
		return ddListÄiDdnames++Ü;
	ü
	datasetStatus getStatus()
	ä
		return status;
	ü
	datasetDisp getDisp()
	ä
		return disp;
	ü
	char * getDsn()
	ä
		return chainEid;
	ü
	char * getNewDsn()
	ä
		return newDsn;
	ü
	void setNewDsn(const char * n)
	ä
		newDsn = strdup(n);
	ü
	long long getSize()
	ä
		return size;
	ü
	void setSize(long long s)
	ä
		size = s;
	ü
	char * put(char *b)
	ä
		sprintf(b,"%s Status:%s Disp:%s NewName:%s DDnames:",chainEid,
			datasetStatusTextÄint(status)Ü,
			datasetDispTextÄint(disp)Ü,
			newDsn);
		for(int i =0;i<iDdnames;i++)
			sprintf(b+strlen(b)," %s ",ddListÄiÜ->chainEid);
		return b;
	ü
	bool excluded()
	ä
		int r = 0;
		return ((r>0)?true:false);
	ü
	bool restore()
	ä
		return true;
	ü
	bool rename()
	ä
		return true;
	ü
ü;


class datasets:public mCHAIN
ä
public:
	datasets():mCHAIN()
	äü
	ßdatasets()
	äü
	void restored(const char * ,int);
	void dumped(const char *,int);
	void setSize(const char *,long long);
ü;



class STEP:public chainE
ä
private:
	char * pgm;
	char * parm;
	DDs * dds;
	char * step;
	char * procstep;
public:
	STEP(const char * stepName,const char * procstepName,const char * _pgm,const char * _parm)
		:chainE(key(stepName,procstepName))
	ä
		JOBENV::DEBUG(1,"STEP",chainEid);
		if (_pgm)
			pgm=strdup(_pgm);
		if (_parm)
			parm = strdup(_parm);
		JOBENV::DEBUG(1,"PGM:",pgm);
		JOBENV::DEBUG(1,"PARM:",parm);
		if (stepName)
			step = strdup(stepName);
		if (procstepName)
			procstep = strdup(procstepName);
		dds = new DDs;
	ü
	ßSTEP()
	ä
		if (pgm)
			free(pgm);
		if (parm)
			free(parm);
		if (step)
			free(step);
		if (procstep)
			free(procstep);
		//  if (dds)
		//    delete dds;
	ü
	void addDD(DD * dd)
	ä
		dds->addlast(dd);
	ü
	void print()
	ä
		printf("%s PGM:%s PARM:%sÖn",chainEid,pgm,parm);
		DD * dd = (DD *)dds->goFirst();
		while(dd)
		ä
			printf(" %s dsn:%sÖn",dd->chainEid,dd->getLine()->getDataset()->getDsn());
			dd = (DD *)dds->goNext();
		ü
	ü
	char * getPgm()
	ä
		return pgm;
	ü
	char *getParm()
	ä
		return parm;
	ü
	DDs * getDDs()
	ä
		return dds;
	ü
	char * getStep()
	ä
		return step;
	ü
	char * getProcstep()
	ä
		return procstep;
	ü
private:
	char * key(const char * s,const char * ps)
	ä
		char _keyÄ18Ü;
		memset(_key,0,sizeof(_key));
		sprintf(_key,"%s.%s",s?s:"",ps?ps:"");
		return _key;
	ü
ü;

class STEPs:public mCHAIN
ä
public:
	STEPs():mCHAIN()
	ä  ü
	ßSTEPs()
	äü
	void   print()
	ä
		STEP * step = (STEP *)goFirst();
		while(step)
		ä
			step->print();
			step = (STEP *)goNext();
		ü
	ü
ü;

DDs dds;
STEPs steps;
datasets datasetList;


line::line(const char *b):chainE(b)
ä
	ddP = NULL;
	datasetP = NULL;
	type = unknown;
	JOBENV::DEBUG(1,"line:",(char *)b);

	mvsSTRING lin(b), prefix, label, stmt, rest, dsn, member, disp, rest1, rest2;
	lin.split(label," ",stmt," ",rest);
	prefix = label,(0,2);
	label = label(2,strlen(label)-2);

	if (strcmp(stmt,JCL_EXEC_STMT)==0)
	ä
		type = execStmt;
		const char *pgmO = strstr((const char *)rest,JCL_EXEC_PGM);
		if (pgmO)
		ä
			/*
			if (strcmp(prefix,JCL_PROC) == 0)
			strcpy(actualProcstepName,label);
			else
			strcpy(actualStepName,label);
			*/
			char pgmÄ9Ü;
			memset(pgm,0,sizeof(pgm));
			for(int i=0;i<9&&restÄstrlen(JCL_EXEC_PGM)+iÜ-' '&&restÄstrlen(JCL_EXEC_PGM)+iÜ-',';i++)
				pgmÄiÜ=restÄstrlen(JCL_EXEC_PGM)+iÜ;
			const char * parmO = strstr((const char *)rest,JCL_EXEC_PARM);
			char parmÄ256Ü;
			memset(parm,0,sizeof(parm));
			char apost=0x7D;
			if (parmO)
			ä
				char term= *(parmO+strlen(JCL_EXEC_PARM));
				if (term == '(')
					term = ')';
				else
					if (term == 'Ö'')
						term = 'Ö'';
					else
						term = ' ';
				bool cont = true;
				int j =(parmO-rest)+strlen(JCL_EXEC_PARM);
				int jl = strlen((char *)rest+j);
				for(int i = 0;cont&&(i<255)&&(j<jl);i++,j++)
				ä
					if (term == ' ' &&(restÄjÜ==' ']]restÄjÜ==','))
						cont = false;
					else
					ä
						//if (term== 'Ö'' && restÄjÜ==term&&restÄj+1Ü-term)
						if (term== apost && restÄjÜ==term&&restÄj+1Ü-term)
							cont = false;
						else
							parmÄiÜ=restÄjÜ;
					ü
				ü
			ü
			actualStep = new STEP(actualStepName,actualProcstepName,pgm,parm);
			steps.addlast(actualStep);
		ü
	ü
	else
		if (strcmp(stmt,JCL_DD_STMT)==0)
		ä
			type = ddStmt;
			if (strlen(label))
			ä
				DDs::concatIndex = 0;
				strcpy(DDs::lastdd,label);
				if (strcmp(label,JCL_STEPLIB_STMT)==0)
					type = steplibStmt;
			ü
			else
			ä
				if (strcmp(DDs::lastdd,JCL_STEPLIB_STMT))
					type = ddStmtConcat;
				else
					type = steplibStmtConcat;
				DDs::concatIndex++;
			ü
			ddP = new DD(DDs::lastdd,DDs::concatIndex,this);
			dds.addlast(ddP);

			if (actualStep)
				actualStep->addDD(ddP);

			if (strcmp(rest,JCL_SYSIN)==0]]strcmp(rest,JCL_SYSIN_DATA)==0]]
				memcmp(JCL_SYSIN_DATA_DLM,(char *)rest,strlen(JCL_SYSIN_DATA_DLM)-1)==0)
				type = inlineStmt;
			else
				if (strstr((char *)rest,JCL_SYSOUT))
					type = sysoutStmt;
				else
				ä
					rest.parse(rest1,"DSN=",dsn,",",rest2);
					if (strlen(dsn))
					ä
						//ToDo GDG handling
						dsn.parse(dsn,"(",member,")",rest1);
						if (strlen(member))
							ddP->setMember(member);
						datasetP = (dataset *)datasetList.search(dsn);
						if (datasetP==NULL)
						ä
							datasetP = new dataset(dsn);
							datasetList.addlast(datasetP);
							if (strstr((char *)rest,"DISP=SHR")]]strstr((char *)rest,"DISP=MOD")]]strstr((char *)rest,"DISP=KEEP"))
								datasetP->setDisp(dataset::input);
							else
								if (dsnÄ0Ü=='&')
									datasetP->setDisp(dataset::temporary);
								else
									datasetP->setDisp(dataset::output);
						ü
						datasetP->setNextDd(ddP);
					ü
					else
						type = unknown;
				ü
		ü
ü

jesJcl * jesjcl = NULL;

class jesJcl
ä
private:
	mCHAIN lines;
	lineType type;
	bool    req;
	char bÄk32Ü;
	char bwÄk32Ü;
	int bOffset;
	FILE * file;
	int  t;
	int count ;

public:
	jesJcl(FILE *f)
	ä
		JOBENV::DEBUG(1,"JESJCL construct");
		file = f;
		t = -1;
		bOffset = 0;
		count = 0;
		req = true;
	ü
	ßjesJcl()
	ä
		if (file)
			fclose(file);
	ü
	int parse();
	int generate(FILE *);
private:
	void put(const char * format, ...)
	ä
		va_list args;
		va_start(args,format);
		vsprintf(bw,format,args);
		if (strchr(bw,'Ön'))
			*strchr(bw,'Ön')=0;
		if (file)
			fprintf(file,"%sÖn",bw);
		JOBENV::DEBUG(1," jcl:",bw);
		Msg(8120)<<bw<<eol;
		va_end(args);
	ü
	void splitLine(char * l)
	ä
		if (strlen(l)<70)
			put("//%s",l);
		else
		ä
			char * c = strchr(l,',');
			char sc;
			if (c)
			ä
				sc = *(c+1);
				*(c+1) = 0;
			ü
			put("//%s",l);
			if (c)
			ä
				*(c+1)=sc;
				*c =' ';
			ü
			splitLine(c);
		ü
	ü
	char * get(char *buf,size_t l)
	ä
		char * r = fgets(buf,l,file);
		JOBENV::DEBUG(1,buf);
		return r;
	ü
ü;

int jesJcl::generate(FILE *f)
ä
	/*
	file = f;
	CHAINITER iter(lines);
	put("//* ");
	put("//* JOB     :%s",reqJobname);
	put("//* JOBNUMBER:%s",reqJobnumber);
	put("//* STEP    :%s",reqStepname);
	put("//* PROCSTEP :%s",reqProcstep);
	char ttÄ32Ü;
	char fmÄÜ = "%Y:%m:%d %H:%M:%S ";
	formatTime(tt,sizeof(tt),fm);
	put("//* AT      :%s",tt);
	bool ok = true;
	line * l = NULL;
	while(ok&&(l=(line *)iter.next()))
	ä
	strcpy(b,l->chainEid);
	JOBENV::DEBUG(1,b);
	switch(l->getLineType())
	ä
	case execStmt:
	ä
	bÄ0Ü = bÄ1Ü = '/';
	if (strlen(b)>72)
	ä
	char * c = strstr(b,"PARM=");
	if (c)
	ä
	*c = 0;
	put("%s",b);
	*c ='P';
	count++;
	put("// %s",c);
	ü
	else
	put("%s",b);
	count++;
	ü
	break;
	case steplibStmt:
	case steplibStmtConcat:
	case ddStmt:
	case ddStmtConcat:
	if (l->getDD()&&l->getDataset())
	if (|l->getDataset()->excluded())
	ä
	char w0Ä128Ü;
	char wmÄ128Ü;
	char wcÄ128Ü;
	if (l->getDD()->getMember())
	sprintf(wm,"(%s)",l->getDD()->getMember());
	else
	wmÄ0Ü = 0;
	DD * dd = l->getDataset()->getFirstDd();
	if (dd->getIndex())
	//szm20080929    sprintf(wc,"C%7.7d",dd->getIndex());
	//szm20090812    sprintf(wc,".C%7.7d",dd->getIndex());

	sprintf(wc,"C%7.7d",dd->getIndex());
	else
	wcÄ0Ü = 0;
	//put("//* %s",l->getDataset()->chainEid);
	if (strlen(wc))
	sprintf(w0,"%s.%s",dd->chainEid,wc);
	else
	sprintf(w0,"%s",dd->chainEid);
	l->getDataset()->setNewDsn(w0);
	if (l->getLineType()==steplibStmt]]l->getLineType()==ddStmt)
	put("//%s DD DISP=SHR,DSN=%s..%s%s",l->getDD()->chainEid,parmÄrestHQÜ,w0,wm);
	else
	put("// DD DISP=SHR,DSN=%s..%s%s",parmÄrestHQÜ,w0,wm);
	count++;
	ü
	else
	//if (l->getDataset()->getDisp()==dataset::temporary)
	splitLine(b+2);
	break;
	case sysoutStmt:
	//put("//* %s",l->getDataset()->chainEid);
	put("//%s DD %s",l->getDD()->chainEid,parmÄrestSysoutÜ);
	count++;
	break;
	case inlineStmt:
	case inlineData:
	ä
	char wÄ128Ü;
	put("//* %s",b);
	put("%s",b);
	sprintf(w,"%s(JESJCLIN)",parmÄworkFileNameÜ);
	FILE * jesJclinFile = fopen(genOpenName(w,b),"r");
	if (jesJclinFile)
	ä
	int ok = 1;
	JOBENV::DEBUG(1,"JESJCLIN read");
	while(ok>0&&fgets(b,sizeof(b),jesJclinFile))
	ä
	JOBENV::DEBUG(1,b);
	switch (ok)
	ä
	case 1:
	ä
	mvsSTRING lin,label , stmt, rest;
	if (memcmp(b,"//",2)==0&&bÄ2Ü-'*')
	ä
	lin = b+2;
	lin.split(label," ",stmt," ",rest);
	ü
	if (strcmp(label,reqStepname)==0 && strcmp(stmt,"EXEC")==0)
	ok = 2;
	ü
	break;
	case 2:
	ä
	mvsSTRING lin,label , stmt, rest;
	if (memcmp(b,"//",2)==0&&bÄ2Ü-'*')
	ä
	lin = b+2;
	lin.split(label," ",stmt," ",rest);
	ü
	if (strcmp(label,l->getDD()->chainEid)==0 && strcmp(stmt,"DD")==0)
	ok = 3;
	ü
	break;
	case 3:
	if (memcmp(b,"//",2))
	put("%s",b);
	else
	ok = 0;
	break;
	ü
	ü
	fclose(jesJclinFile);
	ü
	break;
	ü
	default:
	break;
	ü
	ü
	ü
	return count;
	*/
ü

int jesJcl::parse()
ä
	char cÄk32Ü;
	while(get(c,sizeof(c)))
	ä
		if (memcmp(c+oS,JCL_COMMENT,strlen(JCL_COMMENT))==0]]
			memcmp(c+oS,JCL_COMMENT_XX,strlen(JCL_COMMENT_XX))==0]]
			memcmp(c+oS,JCL_JES2,strlen(JCL_JES2))==0)
			continue;

		cÄoS-1Ü = 0;
		int seq = atoi(c);
		char nameÄ9Ü;
		char stmtÄ9Ü;
		int i=0;
		int j=0;
		int o=0;
		char stepNameÄ9Ü;
		char procStepÄ9Ü;

		if (seq)
		ä
			if (bOffset>0)
			ä
				lines.addlast(new line(b));
				bOffset = 0;
			ü
			for(i=0;cÄoN+iÜ-' '&&i<8;i++)
				nameÄiÜ=cÄoN+iÜ;
			nameÄiÜ =0;
			for(;cÄoN+iÜ==' '&&i<70;i++);
			if (i>16)
				continue;
			for(o=oN+i,j=0;cÄo+jÜ-' '&&j<8;j++)
				stmtÄjÜ=cÄo+jÜ;
			stmtÄjÜ = 0;
			t = -1;
			for(i=0;jclTypesÄiÜ.t>=0&&strcmp(stmt,jclTypesÄiÜ.n);i++);
			t = jclTypesÄiÜ.t;

			if(jclTypesÄiÜ.t<20)
				continue;

			if (t==TYPE_EXEC)
			ä
				procStepÄ0Ü = 0;
				for(i=o+j;i<o+j+8&&cÄiÜ==' ';i++);
				if (memcmp(c+oS,"++",2)&&memcmp(c+oS,"XX",2))
					strcpy(stepName,name);
				else
					strcpy(procStep,name);
				//stop = req;
				JOBENV::DEBUG(1,"step:",stepName);
				JOBENV::DEBUG(1,"procStep:",procStep);
				strcpy(actualStepName,stepName);
				strcpy(actualProcstepName,procStep);
			ü
			strcpy(b,c+oS);
			bOffset=strlen(b);
			if (bOffset>0&&(memcmp(c+oS,"++",2)&&memcmp(c+oS,"XX",2)))
			ä
				lines.addlast(new line(b));
				bOffset = 0;
			ü
		ü
		else
		ä
			if (memcmp(c+oS,JCL_SUBSTITUTION,strlen(JCL_SUBSTITUTION))==0)
			ä
				if (t==TYPE_EXEC)
				ä
					sprintf(b,"//%s EXEC %s",name,c+oS+strlen(JCL_SUBSTITUTION));
					while(*(c+strlen(c)-1)==','&&get(c,sizeof(c)))
						sprintf(b+strlen(b),"%s",c+oS);
					lines.addlast(new line(b));
					bOffset = 0;
				ü
				else
					if (t==TYPE_DD)
					ä
						sprintf(b,"//%s DD %s",name,c+oS+strlen(JCL_SUBSTITUTION));
						while((*c+strlen(c)-1)==','&&get(c,sizeof(c)))
							sprintf(b+strlen(b),"%s",c+oS);
						lines.addlast(new line(b));
						bOffset = 0;
					ü
			ü
			else
				sprintf(b+strlen(b),"%s",c+oS);
		ü
	ü
	if (bOffset>0)
		lines.addlast(new line(b));
	return 1;
ü

char DDs::lastddÄ9Ü;
int  DDs::concatIndex;

int _rexxjcl()
ä
	jobEnv = new JOBENV(argvÄ0Ü);
	//printf("starting rexxjcl");
	char filenameÄ16Ü;
	sprintf(filename,"//DD:%s",argvÄ1Ü);
	REXXVAR rexx(JOBENV::debug);
	int stepC = 0;
	rexx.set(var("JCL",0),stepC);
	FILE * jclFile = fopen(filename,"r,noseek");
	if (jclFile)
	ä
		jesjcl = new jesJcl(jclFile);
		if (|jesjcl->parse())
			printf(" parse error");
		else
			if (JOBENV::debug)
				steps.print();
		fclose(jclFile);
	ü
	else
		printf("file open error");
	STEP * step = (STEP *)steps.goFirst();

	while (step)
	ä
		stepC++;
		rexx.set(var("JCL",stepC,"STEP"),step->getStep());
		rexx.set(var("JCL",stepC,"PROCSTEP"),step->getProcstep());
		rexx.set(var("JCL",stepC,"PGM"),step->getPgm());
		rexx.set(var("JCL",stepC,"PARM"),step->getParm());
		DDs * dds = step->getDDs();
		int ddC = 0;
		if (dds)
		ä
			DD * dd = (DD *)dds->goFirst();
			while(dd)
			ä
				ddC++;
				rexx.set(var("JCL",stepC,"DD",ddC,"DDNAME"),dd->chainEid);
				rexx.set(var("JCL",stepC,"DD",ddC,"DSN"),dd->getLine()->getDataset()->getDsn());
				dd = (DD *)dds->goNext();
			ü
			rexx.set(var("JCL",stepC,"DD",0),ddC);
		ü
		step = (STEP *)steps.goNext();
	ü
	rexx.set(var("JCL",0),stepC);
	if (JOBENV::debug)
	ä
		printf("printing dddsÖn");
		dds.print_all_ids();
		printf("printing stepsÖn");
		steps.print_all_ids();
		printf("printing datasetListÖn");
		datasetList.print_all_ids();
		printf("ending rexxjcl");
	ü
	return 0;
ü

char * rexxSMFTimeDate(int &time, int &date)
ä
	static char wÄ128Ü= "";
	int _dateÄ2Ü;
	_dateÄ0Ü = 0;
	_dateÄ1Ü = date;
	int dateI = __cvb((char *)_date);
	int rest , v , ss, mm, hh;
	rest = time%100;
	v  =  time/100;
	ss =  v%60;
	v /= 60;
	mm =  v%60;
	hh =  v/60;
	int d =dateI/1000;
	sprintf(w," %d.%d ",(dateI/1000)+1900,dateI%1000);
	sprintf(w+strlen(w),"%2.2d:%2.2d:%2.2d:%2.2dÖn",hh,mm,ss,rest);
	return w;
ü

typedef struct cvtxtnt2 * cvtxtnt2P;

const char * rexxSMFtod(pULL tod,char * format=NULL)
ä
	static char wÄ128Ü;
	struct tm *  p_tm;
	time_t     t;
	unsigned long  rest;
	unsigned long long microsec = (*tod>>12);
	t      = microsec/1000000-epoch;
	p_tm = localtime(&t);

	rest =  microsec%1000000;
	if (format)
		strftime(w,sizeof(w),format,p_tm);
	else
	ä
		strftime(w,sizeof(w),"%FT%T",p_tm);
		sprintf(w+strlen(w),".%6.6d",rest);
	ü
	return ((const char *)w);
ü

class Smf2Job :public chainE
ä
private:
	char jobnameÄ9Ü;
	char jobidÄ9Ü;
	char useridÄ9Ü;
public:
	Smf2Job(const char *p,const char * jp,const  char * ip,char * up):chainE(p)
	ä
		strcpy(jobname,jp);
		strcpy(jobid,ip);
		strcpy(userid,up);
	ü
	virtual ßSmf2Job()
	äü

	const char * getJobname()
	ä
		return ((const char *)jobname);
	ü

	const char * getJobid()
	ä
		return ((const char *)jobid);
	ü
	const char * getUserid()
	ä
		return ((const char *)userid);
	ü

ü;

SORTEDmCHAIN * Smf2Jobs = new SORTEDmCHAIN();

int rexxSMF(REXXVAR & rexx ,int & index,char * b,bool & idflag,size_t rl,int need30 = 1, int  need92 = 1, int need102 = 1)
ä
	char recordQualÄ16Ü;
	countersÄsmfrcd30P(b)->smf30rtyÜ++;
	switch(smfrcd30P(b)->smf30rty)
	ä
	case 14:
	case 15:
		ä
			char prognameÄ256Ü;
			smf14P smf14p = (smf14P)b;
			int sdc = smf14p->smf14sdc; //size of DCB segment
			int nuc = smf14p->smf14nuc; //no. of UCB sections
			int suc = smf14p->smf14suc; //size of each of UCB sections
			int excp = 0;
			memcpy(&rst_15,smf14p->smf14rst,4);
			memcpy(&rsd_15,smf14p->smf14rsd,4);
			if ((rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))&&strcasecmp("rexxsmf",argvÄ0Ü)==0)
				break;
			if (nuc > 0)
				excp = *(int*)smf14p->smfexcp;
			if (excp == 0)
				break;
			if (JOBENV::debug)
				_dump(" SMF 14 or 15 record dump",b,rl);
			unsigned char* dcbp = smf14p->smfdcbor; //DCB Section
			unsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section
			unsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section
			unsigned char* eisp = ucbp + nuc*suc;
			short int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Sections
			unsigned char* eispr = eisp + 2;
			short int eispl = 1; //length of next Extended Information Section
			int write_14_15 = 0; //=0 do not write line
			char stepname_14Ä9Ü;
			char progname_14Ä9Ü;
			while (smf14esll > 0 && eispl > 0)
			ä
				eispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section
				char sty = ((smf14EISP)eispr)->_smf14sty; //Section type
				switch(sty)
				ä
				case smf14stp:
					strncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);
					strncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);
					stepname_14Ä8Ü = 0;
					progname_14Ä8Ü = 0;
					if (*pstepname == 0 && *pprogname == 0)
						write_14_15 = 1;
					else if (*pstepname && |strcasecmp(stepname_14,pstepname))
						write_14_15 = 1;
					else if (*pprogname && |strcasecmp(progname_14,pprogname))
						write_14_15 = 1;
					break;
				default:
					break;
				ü
				smf14esll -= eispl;
				eispr += eispl;
			ü
			//printf("smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%dÖn",smf14p,ucbp,eispr,eisp,smf14esll);
			if (write_14_15)
			ä
				char dsnameÄ128Ü;
				write_30 = 1; //write step sum
				if (*stepname == 0)
				ä
					strcpy(stepname,stepname_14);
					strcpy(progname,progname_14);
				ü
				strncpy(dsname,(const char*)smf14p->smfjfcb1,44);
				dsnameÄ44Ü = 0;
				if (smf14p->smfjfcb1Ä44Ü-' ')
				ä
					int i = 0;
					int j = 0;
					for(;dsnameÄiÜ-' '&&dsnameÄiÜ-0;i++);
					dsnameÄi++Ü= '(';
					for(;j<8&&smf14p->smfjfcb1Ä44+jÜ>='A';j++)
						dsnameÄi+jÜ=smf14p->smfjfcb1Ä44+jÜ;
					dsnameÄi+jÜ=')';
					dsnameÄi+j+1Ü=0;
				ü
				if (strcasecmp("rexxdsmf",argvÄ0Ü)==0&&stcpma(dsname,argvÄ1Ü)==0)
					break;

				if (smf14p->smf14rty == 14)
					strcpy(recordQual,"SMF14");
				else
					strcpy(recordQual,"SMF15");
				index++;
				if (strcasecmp("rexxdsmf",argvÄ0Ü)==0)
				ä
					char smf2jobÄ17Ü;
					memcpy(smf2job,smf14p->smf14jbn,16);
					smf2jobÄ16Ü = 0;
					Smf2Job * pjob = (Smf2Job *)Smf2Jobs->search(smf2job);
					if (pjob)
					ä
						rexx.set(var("SMF",index,"JOBNAME"),pjob->getJobname());
						rexx.set(var("SMF",index,"JOBID"),pjob->getJobid());
						rexx.set(var("SMF",index,"USERID"),(char *)smf14p->smf14uid,8);

					ü
				ü
				rexx.set(var("SMF",index,"TYPE"),recordQual);
				rexx.set(var("SMF",index,"DD"),(char *)smf14p->smftioe5,8);
				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smf14p->smf14tme,*(int *)smf14p->smf14dte));
				rexx.set(var("SMF",index,"DD"),(char *)smf14p->smftioe5,8);
				rexx.set(var("SMF",index,"DSN"),dsname);
				rexx.set(var("SMF",index,"EXCP"),excp);
				rexx.set(var("SMF",index,"STEP"),stepname);
				rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
				rexx.set(var("SMF",index,"PROGRAM"),progname);


				char workÄ10Ü = "";
				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14dad)
					strcpy(work,"DASD");
				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14tds)
					strcpy(work,"Temporary");
				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14vio)
					strcpy(work,"VIO ");
				rexx.set(var("SMF",index,"DSTYPE"),work);

			ü
		ü
		break;
	case 30:
		ä

			switch (*(short *)(smfrcd30P(b)->smf30stp))
			ä
			case 1:
				if ((argvÄ1Ü&&memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)]]strcasecmp(argvÄ0Ü,"rexxdsmf")==0)
				ä
					memcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);
					jobidÄ8Ü = 0;
					memcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
					jobnameÄ8Ü = 0;
					memcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);
					usernameÄ8Ü = 0;
					rst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;
					memcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);
					if (strcasecmp("rexxdsmf",argvÄ0Ü)==0)
					ä
						char smf2jobÄ17Ü;
						memcpy(smf2job,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
						memcpy(smf2job+8,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst),4);
						memcpy(smf2job+12,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd),4);
						smf2jobÄ16Ü = 0;
						Smf2Jobs->add(new Smf2Job(smf2job,jobname,jobid,username));
					ü
				ü
				else
					return 0;
				break;
			case 2:
				return 0;
				break;
			case 3:
				return 0;
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			default:
				break;
			ü
			if (strcasecmp(argvÄ0Ü,"rexxdsmf")==0)
				break;
			if (memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))
				break;
			if (JOBENV::debug)
				_dump(" SMF 30 record dump",b,rl);
			if (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)
			ä
				smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
				strcpy(recordQual,"SMF30");
				rexx.set(var("SMF",0,"JOBNAME"),(char *)p->smf30jbn,8);
				rexx.set(var("SMF",0,"JOBID"),jobid);
				rexx.set(var("SMF",0,"USER"),(const char *)p->smf30usr);
				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30P(b)->smf30dte));
				idflag = true;
			ü
			else
			ä
				smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
				index++;
				strcpy(recordQual,"SMF30");
				rexx.set(var("SMF",index,"TYPE"),recordQual);
				rexx.set(var("SMF",index,"PROGRAM"),(char *)p->smf30pgm,8);
				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30P(b)->smf30dte));
				rexx.set(var("SMF",index,"STEP"),stepname);
				rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
			ü
			// I/O activity


			int excp = 0;
			if (*(short *)(smfrcd30P(b)->smf30uon))
				excp = smf30uraP(b+smfrcd30P(b)->smf30uof)->smf30tep;
			rexx.set(var("SMF",index,"EXCP"),excp);

			// Processor cumulative CPU
			double cpu = 0;
			double srb = 0;
			if (*(short *)(smfrcd30P(b)->smf30con))
			ä
				smf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);
				cpu = float(p->smf30cpt)/100;
				srb = float(p->smf30cps)/100;
			ü
			rexx.set(var("SMF",index,"CPU"),cpu);
			rexx.set(var("SMF",index,"SRB"),cpu);

			// EXCP section
			if (*(short *)(smfrcd30P(b)->smf30eon))
			ä
				/*
				smf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);
				for(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)
				ä
				if (p->smf30blk)
				printf(" Device(CUA):%2.2X%2.2X EXCP count:%8.8dÖn",
				p->smf30cuaÄ0Ü,p->smf30cuaÄ1Ü,p->smf30blk);
				p = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);
				ü
				*/
			ü
			int storage = 0;
			int region = 0;
			if (*(short *)(smfrcd30P(b)->smf30ron))
			ä
				smf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);
				region = (*(int *)p->smf30rgn)/1024;
				storage =  p->smf30eur/(1024*1024);
			ü
			rexx.set(var("SMF",index,"REGION"),region);
			rexx.set(var("SMF",index,"STORAGE"),storage);

			int totalsu = 0;
			int cpusu = 0;
			int srbsu = 0;
			int iosu = 0;
			// Performance
			if (*(short *)(smfrcd30P(b)->smf30pon))
			ä
				smf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);
				totalsu =   p->smf30srv;
				cpusu = p->smf30csu;
				srbsu = p->smf30srb;
				iosu = p->smf30io;
			ü
			rexx.set(var("SMF",index,"TOTALSU"),totalsu);
			rexx.set(var("SMF",index,"CPUSU"),cpusu);
			rexx.set(var("SMF",index,"SRBSU"),srbsu);
			rexx.set(var("SMF",index,"IOSU"),iosu);
			if (*(short *)(smfrcd30P(b)->smf30stp)==5)
				return 5;
		ü
		break;
	case 92:
		if (smfrcd92P(b)->smf92ion)
		ä
			smf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);
			if (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)
				]]memcmp(jobname,pid->smf92jbn,8))
				break;
			if (JOBENV::debug)
				_dump(" SMF 92 record dump",b,rl);
			strcpy(recordQual,"SMF92");
			switch (smfrcd92P(b)->smf92stp)
			ä
			case 11:
				if (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)
				ä
					smf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);
					for(int i=0;i<smfrcd92P(b)->smf92don;i++)
					ä
						char nameÄ65Ü;
						nameÄ64Ü=0;
						if (p->smf92cty==FT_SOCKET)
							sprintf(name," SOCKET inode:%d device:%d",p->smf92cin,p->smf92cdn);
						else
							memcpy(name,p->smf92cpn,sizeof(p->smf92cpn));
						index++;
						rexx.set(var("SMF",index,"READ"),p->smf92cir);
						rexx.set(var("SMF",index,"WRITE"),p->smf92ciw);

						p = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);
						rexx.set(var("SMF",index,"TYPE"),recordQual);
						rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(smfrcd92P(b)->smf92tme,smfrcd92P(b)->smf92dte));
						/*    rexx.set(var("SMF",index,"TIME"),rexxSMFtod(pULL(p->smf92ctc)));*/
						rexx.set(var("SMF",index,"PATH"),name);
						rexx.set(var("SMF",index,"STEP"),stepname);
						rexx.set(var("SMF",index,"PROCSTEP"),pstepname);

					ü
				ü
				break;
			default:
				break;
			ü
		ü
		break;
	case 100:
		//_dump(" SMF 100 record dump",b,rl);
		break;
	case 101:
		//_dump(" SMF 101 record dump",b,rl);
		break;
	case 102:
		ä
			typedef struct sm102 * sm102P;
			typedef struct qwt0 * qwt0P;
			typedef struct qwhs * qwhsP;
			typedef struct qwhc * qwhcP;
			qwt0P qwt0p = qwt0P(b+sizeof(struct sm102)-1);
			int pso = int(qwt0p->qwt02pso);
			int psl = *(short *)(qwt0p->qwt02psl);
			int psn = *(short *)(qwt0p->qwt02psn);
			bool our = false;
			sm102P sm102p = sm102P(b);
			qwhcP qwhcp = qwhcP(b+pso);
			qwhsP qwhsp = NULL;
			while (|our&&(char *)qwhcp<(b+pso+psl))
			ä
				if (qwhcp->qwhctyp == 1)
					qwhsp = (qwhsP)qwhcp;
				if (qwhcp->qwhctyp == 2 && strcmp((const char *)(qwhcp->qwhccv),jobid) ==0 )
					our = true;
				qwhcp = qwhcP((char *)qwhcp+*(short *)qwhcp->qwhclen);
			ü
			if (|need102 ]] |our ]] |qwhsp)
				break;
			if (JOBENV::debug)
				_dump(" SMF 102 record dump",b,rl);


			char ssidÄ5Ü;
			memcpy(ssid,qwhsp->qwhsssid,4);
			ssidÄ4Ü = 0;
			strcpy(recordQual,"SMF102");
			char workÄ1024*32Ü;
			for(int i = 0;i<qwhsp->qwhsnsda-1;i++)
			ä
				qwt0P datasection = qwt0P((char *)qwt0p+i*8+8);
				int offset = int(datasection->qwt02pso);
				int length = *(short *)(datasection->qwt02psl);
				int count = *(short *)(datasection->qwt02psn);
				char * start = b+offset;
				//for(int j = 0;j<count;j++)
				ä
					index++;
					rexx.set(var("SMF",index,"STEP"),stepname);
					rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
					rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)sm102p->sm102tme,*(int *)sm102p->sm102dte));
					rexx.set(var("SMF",index,"TYPE"),recordQual);
					rexx.set(var("SMF",index,"ON"),ssid);

					switch(*(short *)qwhsp->qwhsiid)
					ä
					case 22:
						ä
							typedef struct qw0022 * qw0022P;
							rexx.set(var("SMF",index,"NOTES"),"0022 THE MINI-PLANS GENERATED");
							rexx.set(var("SMF",index,"INFO"),(const char *)qw0022P(start)->qw0022tn,18);
							rexx.set(var("SMF",index,"STATS"),(const char *)qw0022P(start)->qw0022pg,8);
						ü
						break;
					case 53:
						ä
							typedef struct qw0053 * qw0053P;
							rexx.set(var("SMF",index,"NOTES"),"0053 END OF DESCRIBE SQL COMMIT, ROLLBACK, ERROR CONDITION");
							if (memcmp(qw0053P(start)->qw0053sq,"SQLCA",5) == 0)
							ä
								if (*(int *)(qw0053P(start)->qw0053sq+12) == 0 )
								ä
									strcpy(work,"SQLOK");
								ü
								else
								ä
									ERROR_MESSAGE error_message;
									error_message.error_len = 10*72;
									int rc = DSNTIAR(qw0053P(start)->qw0053sq,&error_message,&data_len);
									if ( rc )
										sprintf(work,"DSNTIAR rc:%d",rc);
									else
									ä
										workÄ0Ü =0;
										for(int i = 0;i<data_dim;i++)
											sprintf(work+strlen(work),"<p>%72.72s",error_message.error_textÄiÜ);
									ü
								ü
							ü
							else
							ä
								sprintf(work,"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu",
									*(long long *)qw0053P(start)->qw0053rq,
									*(long long *)qw0053P(start)->qw0053in,
									*(long long *)qw0053P(start)->qw0053up,
									*(long long *)qw0053P(start)->qw0053de);
							ü
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 55:
						index--;
						break;
					case 58:
						ä
							typedef struct qw0058 * qw0058P;
							rexx.set(var("SMF",index,"NOTES"),"0058 END SQL STATEMENT EXECUTION");
							if (memcmp(qw0058P(start)->qw0058sq,"SQLCA",5) == 0)
							ä
								if (*(int *)(qw0058P(start)->qw0058sq+12) == 0 )
								ä
									strcpy(work,"SQLOK");
								ü
								else
								ä
									ERROR_MESSAGE error_message;
									error_message.error_len = 10*72;
									int rc = DSNTIAR(qw0058P(start)->qw0058sq,&error_message,&data_len);
									if ( rc )
										sprintf(work,"DSNTIAR rc:%d",rc);
									else
									ä
										workÄ0Ü =0;
										for(int i = 0;i<data_dim;i++)
											sprintf(work+strlen(work),"<p>%72.72s",error_message.error_textÄiÜ);
									ü
								ü
							ü
							else
							ä
								sprintf(work,"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu",
									*(long long *)qw0058P(start)->qw0058rp,
									*(long long *)qw0058P(start)->qw0058in,
									*(long long *)qw0058P(start)->qw0058up,
									*(long long *)qw0058P(start)->qw0058de);
							ü
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 59:
						ä
							typedef struct qw0059 * qw0059P;
							rexx.set(var("SMF",index,"NOTES"),"0059 FETCH SQL STATEMENT EXECUTION START");
							sprintf(work,"Cursor:%*.*s Sensitive:%c Orientation:%c",
								*(short*)qw0059P(start)->qw0059cl,*(short*)qw0059P(start)->qw0059cl,qw0059P(start)->qw0059cn,qw0059P(start)->qw0059fs,qw0059P(start)->qw0059fo);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 60:
						ä
							typedef struct qw0060 * qw0060P;
							rexx.set(var("SMF",index,"NOTES"),"0060 SELECT SQL STATEMENT EXECUTION START");
							sprintf(work,"Isolation:%c",
								qw0060P(start)->qw0060i);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 61:
						ä
							typedef struct qw0061 * qw0061P;
							rexx.set(var("SMF",index,"NOTES"),"0061 FETCH SQL STATEMENT START - INSERT, UPDATE, DELETE");
							char typeÄ32Ü;
							if (qw0061P(start)->qw0061st = 0x10)
								strcpy(type,"INSERT");
							else
								if (qw0061P(start)->qw0061st = 0x20)
									strcpy(type,"UPDATE NON CURSOR");
								else
									if (qw0061P(start)->qw0061st = 0x21)
										strcpy(type,"UPDATE CURSOR");
									else
										if (qw0061P(start)->qw0061st = 0x30)
											strcpy(type,"MERGE");
										else
											if (qw0061P(start)->qw0061st = 0x41)
												strcpy(type,"DELETE CURSOR");
											else
												if (qw0061P(start)->qw0061st = 0x50)
													strcpy(type,"TRUNCATE");
							sprintf(work,"Cursor:%*.*s Type:%s",
								*(short*)qw0061P(start)->qw0061cl,*(short*)qw0061P(start)->qw0061cl,qw0061P(start)->qw0061cn,type);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 62:
						ä
							typedef struct qw0062 * qw0062P;
							rexx.set(var("SMF",index,"NOTES"),"0062 RECORDS DLL EXECUTION STATEMENT START");
							sprintf(work,"Object:%*.*s type:%c",
								*(short*)qw0062P(start)->qw0062ol,*(short*)qw0062P(start)->qw0062ol,qw0062P(start)->qw0062on,qw0062P(start)->qw0062st);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 63:
						ä
							typedef struct qw0063 * qw0063P;
							rexx.set(var("SMF",index,"NOTES"),"0063 THE SQL STATEMENTT");
							sprintf(work,"%*.*s",
								*(short*)qw0063P(start)->qw0063ll,*(short*)qw0063P(start)->qw0063ll,(char *)&qw0063P(start)->qw0063st);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 64:
						ä
							typedef struct qw0064 * qw0064P;
							rexx.set(var("SMF",index,"NOTES"),"0064 PREPARE STATEMET START");
							sprintf(work,"Cursor:%*.*s",
								*(short*)qw0064P(start)->qw0064cl,*(short*)qw0064P(start)->qw0064cl,qw0064P(start)->qw0064cn);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 65:
						ä
							typedef struct qw0065 * qw0065P;
							rexx.set(var("SMF",index,"NOTES"),"0065 OPEN CURSOR STATEMENT START");
							sprintf(work,"Cursor:%*.*s Sensitive:%c Isolation:%c",
								*(short*)qw0065P(start)->qw0065cl,*(short*)qw0065P(start)->qw0065cl,qw0065P(start)->qw0065cn,
								qw0065P(start)->qw0065sv,qw0065P(start)->qw0065i);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 66:
						ä
							typedef struct qw0066 * qw0066P;
							rexx.set(var("SMF",index,"NOTES"),"0066 OPEN CURSOR STATEMENT START");
							sprintf(work,"Cursor:%*.*s",
								*(short*)qw0066P(start)->qw0066cl,*(short*)qw0066P(start)->qw0066cl,qw0066P(start)->qw0066cn);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 92:
						ä
							typedef struct qw0092 * qw0092P;
							rexx.set(var("SMF",index,"NOTES"),"0092 AN AMS COMMAND START");
							sprintf(work,"Command:%*.*s",
								*(short*)qw0092P(start)->qw0092pl,*(short*)qw0092P(start)->qw0092pl,qw0092P(start)->qw0092p1);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 96:
						ä
							typedef struct qw0096 * qw0096P;
							rexx.set(var("SMF",index,"NOTES"),"0096 RECORDS SORT ENDED");
							sprintf(work,"Records:%d DataSize:%d KeySize:%d",
								qw0096P(start)->qw0096nr,qw0096P(start)->qw0096dl,qw0096P(start)->qw0096kl);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 97:
						ä
							typedef struct qw0097 * qw0097P;
							rexx.set(var("SMF",index,"NOTES"),"0097 AMS COMMAND COMPLETION");
							sprintf(work,"Command:%*.*s ReturnCode:%d",
								*(short*)qw0097P(start)->qw0097pl,*(short*)qw0097P(start)->qw0097pl,qw0097P(start)->qw0097p1,
								qw0097P(start)->qw0097rc);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 112:
						ä
							typedef struct qw0112 * qw0112P;
							rexx.set(var("SMF",index,"NOTES"),"0112 THE ATTRIBUTES FOR THE PLAN");
							sprintf(work,"Plan:%8.8s Isolation:%2.2s Aqu:%c Rel:%c Keep:%c Prot:%c",
								qw0112P(start)->qw0112pn,qw0112P(start)->qw0112i,
								qw0112P(start)->qw0112q,qw0112P(start)->qw0112r,
								qw0112P(start)->qw0112kd,qw0112P(start)->qw0112pr);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 173:
						index--;
						break;
					case 177:
						ä
							typedef struct qw0177 * qw0177P;
							rexx.set(var("SMF",index,"NOTES"),"0177 FOR SUCCESSFUL PACKAGE ALLOCATION");
							sprintf(work,"Package:%126.126s",
								(char *)&(qw0177P(start)->qw0177pk));
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 233:
						ä
							typedef struct qw0233 * qw0233P;
							rexx.set(var("SMF",index,"NOTES"),"0233 START OR END OF A CALL TO A USER ROUTINE");
							sprintf(work,"Routine:18.18s",
								qw0233P(start)->qw0233pr);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 237:
						ä
							typedef struct qw0237 * qw0237P;
							rexx.set(var("SMF",index,"NOTES"),"0237 AT EXECUTION of SET CURRENT DEGREE");
							sprintf(work,"Prev:%3.3s New:%3.3s Status:%c",
								qw0237P(start)->qw0237oi,qw0237P(start)->qw0237ni,
								qw0237P(start)->qw0237st);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 250:
						index--;
						break;
					case 272:
						ä
							typedef struct qw0272 * qw0272P;
							rexx.set(var("SMF",index,"NOTES"),"0272 ASSOCIATE LOCATORS");
							sprintf(work,"StoredProc:%*.*s",
								qw0272P(start)->qw0272pl,qw0272P(start)->qw0272pl,qw0272P(start)->qw0272pn);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 273:
						ä
							typedef struct qw0273 * qw0273P;
							rexx.set(var("SMF",index,"NOTES"),"0273 ALLOCATE CURSOR");
							sprintf(work,"Cursor:%*.*s",
								qw0273P(start)->qw0273cl,qw0273P(start)->qw0273cl,qw0273P(start)->qw0273cn);
							rexx.set(var("SMF",index,"STATS"),work);
							rexx.set(var("SMF",index,"INFO"),"");
						ü
						break;
					case 325:
						index--;
						break;
					default:
						break;
					ü
					if (offset)
						start +=offset;
					else
						start += *(short *)start;
				ü
			ü
		ü
		break;
	default:
		break;
	ü
	return 0;
ü

_rexxsmf()
ä
	//printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold"));
	jobEnv = new JOBENV(argvÄ0Ü);
	int rc = mvs()->LoggerOpen(argvÄ2Ü);
	const char * pointer = NULL;
	char dateÄ32Ü;
	char * dateP = NULL;
	if (argc >= 4 && argvÄ4Ü)
	ä
		char * p = strchr(argvÄ4Ü,',');
		if (p)
			*(int *)date = atoi(p+1);
		memcpy(date+4,argvÄ4Ü,7);
		dateP = date;
	ü

	size_t length = 0;
	size_t * lP   = &length;
	pasm PASM = NULL;
	REXXVAR rexx(JOBENV::debug);
	bool idflag = false;
	int index = 0;
	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),0,dateP)==0)
	ä
		PASM = mvs()->getpasm();
		if (JOBENV::debug)
		ä
			/*
			_dump("logger rc",(char *)&(PASM->asm_rc),256);
			_dump("asm logger",(char *)&(PASM->asm_logger_length),
			(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
			_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
			_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
			printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
			*/
		ü
		unsigned short ubl = *(unsigned short *)pointer;
		int bl = ubl;
		bl-=4;
		char * p = (char *)pointer+4;
		while(bl>0)
		ä
			unsigned short url;
			url = *(unsigned short *)p;
			int rl = url;
			if (rl==72)
			ä
				p+=rl;
				bl-=rl;
				length-=rl;
				rl = *(short *)p;
				if (bl >0 && rl>0 && bl>rl)
				ä
					if (rexxSMF(rexx,index,p,idflag,rl)==5)
					ä
						rexx.set(var("SMF",0),index);
						return 0;
					ü
					p+=rl;
					bl-=rl;
					length=-rl;
				ü
				else
					bl = 0;
			ü
			else
			ä
				bl = 0;
			ü
		ü
	ü
	mvs()->LoggerClose();

	if (index>0)
		rexx.set(var("SMF",0),index);
	else
		for(int i =0;i<255;i++)
			if (countersÄiÜ)
				printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
	return 0;
ü

_rexxdsmf()
ä
	//printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold"));
	jobEnv = new JOBENV(argvÄ0Ü);
	int rc = mvs()->LoggerOpen(argvÄ2Ü);
	const char * pointer = NULL;
	char dateÄ32Ü;
	char * dateP = NULL;
	if (argc >= 4 && argvÄ4Ü)
	ä
		char * p = strchr(argvÄ4Ü,',');
		if (p)
			*(int *)date = atoi(p+1);
		memcpy(date+4,argvÄ4Ü,7);
		dateP = date;
	ü

	size_t length = 0;
	size_t * lP   = &length;
	pasm PASM = NULL;
	REXXVAR rexx(JOBENV::debug);
	bool idflag = false;
	int index = 0;
	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),0,dateP)==0)
	ä
		PASM = mvs()->getpasm();
		unsigned short ubl = *(unsigned short *)pointer;
		int bl = ubl;
		bl-=4;
		char * p = (char *)pointer+4;
		while(bl>0)
		ä
			unsigned short url;
			url = *(unsigned short *)p;
			int rl = url;
			if (rl==72)
			ä
				p+=rl;
				bl-=rl;
				length-=rl;
				rl = *(short *)p;
				if (bl >0 && rl>0 && bl>rl)
				ä
					if (rexxSMF(rexx,index,p,idflag,rl)==5)
					ä
						rexx.set(var("SMF",0),index);
						return 0;
					ü
					p+=rl;
					bl-=rl;
					length=-rl;
				ü
				else
					bl = 0;
			ü
			else
			ä
				bl = 0;
			ü
		ü
	ü
	mvs()->LoggerClose();

	if (index>0)
		rexx.set(var("SMF",0),index);
	else
		for(int i =0;i<255;i++)
			if (countersÄiÜ)
				printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
	return 0;
ü

extern dump(FILE *,char *,char *,int);

int _dumpfile()
ä
	char wÄ1024Ü;
	char bÄ32756Ü;
	FILE * f =fopen(genOpenName(argvÄ1Ü,w),"rb,type=record");
	int l = 0;
	if (f)
	ä
		int count = 0;
		while((l = fread(b,1,sizeof(b),f))>0)
		ä
			count++;
			sprintf(w,"record:%d in %d length",count,l);
			dump(stdout,w,b,l);
		ü
		fclose(f);
	ü
	return 0;
ü


int _listfile()
ä
	char buffÄ32760Ü;
	FILE * file = NULL;
	size_t l = 0;
	size_t max = argvÄ2Ü?atoi(argvÄ2Ü):99999999;
	if (argvÄ1Ü&&(file=fopen(genOpenName(argvÄ1Ü,buff),"rb,type=record,noseek")))
	ä
		while ((l=fread(buff,1,sizeof(buff),file))>0&&--max>0)
			printf("%*.*sÖn",l,l,buff);
		fclose(file);
	ü
	else
		printf("<h1>unable to open %s (%s)Ön",argvÄ1Ü,strerror(errno));
	return 0;
ü
typedef struct ensg * ENSGP;
typedef struct enf70 * ENF70P;
typedef struct hdlogrec * HDLOGRECP;
typedef struct sdwa * SDWAP;
typedef struct adsrcmps * ADSRCMPSP;


static char *  logrec_typesÄ255Ü;
int logrec_types_init()
ä
	logrec_typesÄ0x10Ü =  "Machine Check Handler";
	logrec_typesÄ0x13Ü =  "Machine Check in the System";
	logrec_typesÄ0x23Ü =  "Subchannel Logout Handler";
	logrec_typesÄ0x25Ü =  "Channel Record Word";
	logrec_typesÄ0x30Ü =  "Outboard";
	logrec_typesÄ0x34Ü =  "Outboard TCAM";
	logrec_typesÄ0x36Ü =  "Outboard VTAM";
	logrec_typesÄ0x3aÜ =  "Outboard DPA";
	logrec_typesÄ0x40Ü =  "Software-detected software error";
	logrec_typesÄ0x42Ü =  "Hardware-detected software error";
	logrec_typesÄ0x44Ü =  "Operator-detected error";
	logrec_typesÄ0x48Ü =  "Hardware-detected hardware error";
	logrec_typesÄ0x4cÜ =  "Symptom record";
	logrec_typesÄ0x4FÜ =  "Lost record summary";
	logrec_typesÄ0x50Ü =  "IPL";
	logrec_typesÄ0x60Ü =  "DDR";
	logrec_typesÄ0x70Ü =  "MIH";
	logrec_typesÄ0x80Ü =  "EOD";
	logrec_typesÄ0x81Ü =  "System-initiated end";
	logrec_typesÄ0x84Ü =  "EOD from IOS";
	logrec_typesÄ0xA1Ü =  "ETR";
	logrec_typesÄ0xa2Ü =    "LMI";
	logrec_typesÄ0xa3Ü =  "SIM";
	logrec_typesÄ0xc2Ü =  "DPSV";
	return 1;
ü
int _logrec_types = logrec_types_init();

static char * enf70_qualifier_listÄÜ=
ä
	NULL,
	/* Values for field "enf70_qualifier" */
	"Job was selected",
	"Job was processed",
	"Job queued to new phase",
	"Job was purged"
ü;

static char * enf70_comp_listÄÜ =
ä
	/* Values for field "enf70_comp" */
#define enf70_cab        0x80 /* ABEND CODE                       */
#define enf70_ccc        0x40 /* Completion code                  */
	"No completion info",
	"Job ended normally",
	"Job ended by cc",
	"Job had a JCL error",
	"Job was canceled",
	"Job ABENDed",
	"Converter ABENDed",
	"Security error",
	"Job ABENDed in end of"
ü;

/* Values for field "enf70_queue" */
static char * enf70_queue_listÄ138Ü =
ä
	/*'#define enf70_q_none     0   .*/ "  No previous queue (job create)  ",
	NULL,
	/*'#define enf70_q_convert  2   .*/ "  Conversion                      ",
	/*'#define enf70_q_pscbat   3   .*/ "  Postscan (batch)                ",
	/*'#define enf70_q_pscdsl   4   .*/ "  Postscan (demand select)        ",
	/*'#define enf70_q_fetch    5   .*/ "  Volume fetch                    ",
	/*'#define enf70_q_volwt    6   .*/ "  Start Setup                     ",
	/*'#define enf70_q_syssel   7   .*/ "  MDS system select processing    ",
	/*'#define enf70_q_alloc    8   .*/ "  resource allocation             ",
	/*'#define enf70_q_voluav   9   .*/ "  unavailable VOL(s)              ",
	/*'#define enf70_q_verify   10  .*/ "  volume mounts                   ",
	/*'#define enf70_q_sysver   11  .*/ "  MDS system verify processing    ",
	/*'#define enf70_q_error    12  .*/ "  Demand Select                   ",
	/*'#define enf70_q_select   13  .*/ "  Execution                       ",
	/*'#define enf70_q_onmain   14  .*/ "  Execution                       ",
	NULL,
	NULL,
	/*'#define enf70_q_brkdwn   17  .*/ "  Breakdown                       ",
	/*'#define enf70_q_restrt   18  .*/ "  MDS restart proc                ",
	/*'#define enf70_q_done     19  .*/ "  Main and MDS proc. complete     ",
	/*'#define enf70_q_output   20  .*/ "  Output service                  ",
	/*'#define enf70_q_outque   21  .*/ "  Output service WTR              ",
	/*'#define enf70_q_oswait   22  .*/ "  Awaiting rsvd services          ",
	/*'#define enf70_q_cmplt    23  .*/ "  Output service complete         ",
	/*'#define enf70_q_demsel   24  .*/ "  Demand Select                   ",
	/*'#define enf70_q_efwait   25  .*/ "  Ending function rq waiting      ",
	/*'#define enf70_q_efbad    26  .*/ "  Ending function rq not Processed"
ü;
int init_const()
ä
	enf70_queue_listÄ128Ü=
		/*'#define enf70_q_input    128 .*/ "  Input queue (pre-execution)     ";
	enf70_queue_listÄ136Ü=
		/*'#define enf70_q_receiver 136 .*/ "  Input queue (post-execution)    ";
	enf70_queue_listÄ132Ü=
		/*'#define enf70_q_spin     132 .*/ "  Spin queue                      ";
	enf70_queue_listÄ134Ü=
		/*'#define enf70_q_purge    134 .*/ "  Purge queue                     ";
	enf70_queue_listÄ137Ü=
		/*'#define enf70_q_xmit     137 .*/ "  NJE transmission queue          ";
	return 0;
ü

int _init_const = init_const();

typedef struct pfswrec PFSWREC;
typedef struct dumpxrec DUMPXREC;
typedef struct mpfxrec MPFXREC;

char * pfswrec_typesÄ23Ü;
int _rexxenfs()
ä
	// argvÄ2Ü = logstream name
	// argvÄ3Ü = direction (seems 3 youngtoold)
	// argvÄ4Ü = recordcount (default 1000?)
	// argvÄ5Ü = TZ envar
	if (argc > 4 )
		setenv("TZ",argvÄ5Ü,1);
	char wÄ32760Ü;
	jobEnv = new JOBENV(argvÄ0Ü);
	REXXVAR rexx(JOBENV::debug);
	pfswrec_typesÄ1Ü = "Update";
	pfswrec_typesÄ2Ü = "Delete";
	pfswrec_typesÄ3Ü = "Rename";
	pfswrec_typesÄ11Ü = "Add member";
	pfswrec_typesÄ12Ü = "Delete_member";
	pfswrec_typesÄ13Ü = "Rename_member";
	pfswrec_typesÄ21Ü = "Update path";
	pfswrec_typesÄ22Ü = "Delete path";
	pfswrec_typesÄ23Ü = "Rename path";

	if (JOBENV::debug)
		printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold"));
	int rc = mvs()->LoggerOpen(argvÄ2Ü);
	if (rc)
	ä
		rexx.set(var("ENF",0),0);
		rexx.set(var("ENF_ERROR",0),sprintf(w," unable to open %s logstream",argvÄ2Ü));
		return 8;
	ü
	size_t length = 0;
	size_t * lP   = &length;
	pasm PASM = NULL;
	char * pointer = NULL;
	int max = (argc>3)?atoi(argvÄ4Ü):100;

	bool idflag = false;
	int index = 1;
	while (rc=mvs()->BrowseLogger((const char * &)pointer,lP,atoi(argvÄ3Ü),NULL,NULL)==0 && max>=index)
	ä
		PASM = mvs()->getpasm();

		int rl = *(int *)pointer;
		PFSWREC * pfswrec =(PFSWREC *)(pointer +4);
		if (JOBENV::debug)
			_dump(" logger",pointer,rl);
		bool need = false;
		ENSGP ensgP = ENSGP(pointer-8);
		HDLOGRECP hdlogrecP = HDLOGRECP((char *)pointer+ifbenf36_header_length+sizeof(*ensgP)-8);
		SDWAP sdwaP=NULL;
		if (JOBENV::debug)
		ä
			_dump(" ensg",(char *)ensgP,128);
			printf(" ENF code:%dÖn ",ensgP->ensg_event_code);
		ü
		switch(ensgP->ensg_event_code)
		ä
		case 0:
			ä
				need = true;
				switch(pfswrec->pfswrec_type)
				ä
				case pfswrec_type_update:
				case pfswrec_type_delete:
					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_dsn,44);
					break;
				case pfswrec_type_rename:
					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_newdsn,44);
					rexx.set(var("ENF",index,"OLD_DSN"),(char *)pfswrec->pfswrec_dsn,44);
					break;
				case pfswrec_type_add_member:
				case pfswrec_type_delete_member:
					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_dsn,44);
					rexx.set(var("ENF",index,"MEMBER"),(char *)pfswrec->pfswrec_member,8);
					break;
				case pfswrec_type_rename_member:
					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_newdsn,44);
					rexx.set(var("ENF",index,"OLD_DSN"),(char *)pfswrec->pfswrec_dsn,44);
					rexx.set(var("ENF",index,"MEMBER"),(char *)pfswrec->pfswrec_member,8);
					break;
				case pfswrec_type_update_path:
				case pfswrec_type_delete_path:
					rexx.set(var("ENF",index,"PATH"),(char *)pfswrec->pfswrec_path,64);
					break;
				case pfswrec_type_rename_path:
					rexx.set(var("ENF",index,"PATH"),(char *)pfswrec->pfswrec_newpath,64);
					rexx.set(var("ENF",index,"OLD_PATH"),(char *)pfswrec->pfswrec_path,64);
					break;

				ü
			ü
			break;
		case 1:
			ä
				DUMPXREC * rec =(DUMPXREC *)pointer;
				need = true;
				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(rec->dumpxrec_dumpxrec_stck)));
				rexx.set(var("ENF",index,"SYSTEM"),(char *)rec->dumpxrec_dumpxrec_prdsname,4);
				rexx.set(var("ENF",index,"JOBNAME"),(char *)rec->dumpxrec_dumpxrec_sdepljob,8);
				rexx.set(var("ENF",index,"CHANGE"),"Dump created");
				rexx.set(var("ENF",index,"DSN"),(char *)rec->dumpxrec_dumpxrec_prddsnam,40);
				rexx.set(var("ENF",index,"SIGNAL"),1);

			ü
			break;
		case 2:
			ä
				MPFXREC  * rec =(MPFXREC *)pointer;
				need = true;
				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(rec->mpfxrec_mpfxrec_stck)));
				rexx.set(var("ENF",index,"SYSTEM"),(char *)rec->mpfxrec_mpfxrec_sysname,4);
				rexx.set(var("ENF",index,"JOBNAME"),(char *)rec->mpfxrec_mpfxrec_jobname,8);
				rexx.set(var("ENF",index,"JOBID"),(char *)rec->mpfxrec_mpfxrec_jobid,8);
				sprintf(w,"%4.4X",*(short *)rec->mpfxrec_mpfxrec_asid);
				rexx.set(var("ENF",index,"ASID"),w	);
				rexx.set(var("ENF",index,"CHANGE"),"critical message");
				rexx.set(var("ENF",index,"MSG"),(char *)rec->mpfxrec_mpfxrec_ctxttmsg,126);

			ü
			break;

		case 36:
			need = true;
			rexx.set(var("ENF",index,"LOGRECTYPE"),logrec_typesÄhdlogrecP->hdrtypÜ);
			switch(hdlogrecP->hdrtyp)
		case 0x40:
		default:
			ä
				sdwaP = SDWAP((char *)hdlogrecP+sizeof(*hdlogrecP));
				rexx.set(var("ENF",index,"JOBNAME"),(char *)sdwaP,8);
				sdwaP = SDWAP((char *)sdwaP+8);
				unsigned int cc = *(int *)&(sdwaP->sdwafiob.sdwaabcc);
				if ((cc&0x00FFF000)>>12)
					sprintf(w,"S%3.3X",(cc&0x00FFF000)>>12);
				else
					sprintf(w,"U%3.3X",cc&0x00000FFF);
				rexx.set(var("ENF",index,"CMPC"),w);
				rexx.set(var("ENF",index,"MODULE"),(char *)sdwaP->sdwamodn,8);
			ü
			break;
		case 0x4c:
			break;
		case 29:
		case 30:
		case 55:
		case 67:
			need = true;
			break;
		case 70:
			//need = true;
			ENF70P enf70P = ENF70P(pointer+sizeof(*ensgP)-8);
			/*
			if (enf70P->enf70_queue == enf70_q_onmain && enf70P->enf70_qualifier == enf70_deselect &&
			(enf70P->enf70_comp&enf70_cab]]enf70P->enf70_comp==enf70_cabn]]enf70P->enf70_comp==enf70_ccab]]enf70P->enf70_comp==enf70_csec]]enf70P->enf70_comp==enf70_ceom))
			*/
			if (enf70P->enf70_comp&&enf70P->enf70_queue == enf70_q_onmain)
			ä
				need = true;
				rexx.set(var("ENF",index,"JOBNAME"),(char *)enf70P->enf70_jobname,sizeof(enf70P->enf70_jobname));
				rexx.set(var("ENF",index,"JOBID"),(char *)enf70P->enf70_jobid,sizeof(enf70P->enf70_jobid));
				if (isprint(*enf70P->enf70_srvclass))
					rexx.set(var("ENF",index,"SRVCLASS"),(char *)enf70P->enf70_srvclass,sizeof(enf70P->enf70_srvclass));
				else
					rexx.set(var("ENF",index,"SRVCLASS")," ");
				rexx.set(var("ENF",index,"COMP"),int(enf70P->enf70_comp));
				sprintf(w,"%8.8x",*(int *)&(enf70P->enf70_comp)&0x00FFFFFF);
				rexx.set(var("ENF",index,"CODE"),w);
			ü
			break;
		ü
		if (need)
		ä
			rexx.set(var("ENF",0),index);
			rexx.set(var("ENF",index,"SIGNAL"),ensgP->ensg_event_code);
			if (ensgP->ensg_event_code > 2)
			ä
				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL((char *)&(ensgP->ensg_source_system_slot)+4)));
				sprintf(w,"%8.8X",*(int *)(ensgP->ensg_qual));
				rexx.set(var("ENF",index,"QUAL"),w);
				sprintf(w,"%8.8X",*(int *)(ensgP->ensg_bitmap_qual));
				rexx.set(var("ENF",index,"BITQUAL"),w);
				rexx.set(var("ENF",index,"SYSTEM"),(char *)ensgP->ensg_source_system_name,sizeof(ensgP->ensg_source_system_name));
			ü
			else
				if (ensgP->ensg_event_code == 0)
				ä
					rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(pfswrec->pfswrec_stck)));
					rexx.set(var("ENF",index,"SYSTEM"),(char *)pfswrec->pfswrec_id_system,4);
					rexx.set(var("ENF",index,"JOBNAME"),(char *)pfswrec->pfswrec_id_jobname,8);
					rexx.set(var("ENF",index,"CHANGE"),pfswrec_typesÄpfswrec->pfswrec_typeÜ);
				ü
				index++;
		ü
	ü
	return 0;
ü

struct MSGXBUF_T
ä
	time_t     mtime;   // Time and date message was sent
	uid_t      muid;    // Sender's effective user ID
	gid_t      mgid;    // Sender's effective group ID
	pid_t      mpid;    // Sender's process ID
	long int   mtype;   // Message type
	int        mtextÄ256Ü; // Message text
ü ;

typedef struct MSGXBUF_T msgxbuf_t;

struct LOGSTREAM_T
ä
	int length;
	int type;
	int  mtextÄ256Ü;
ü;



int _dump(char * id,char * p,int l)
ä
	unsigned char ATOEÄ256Ü =
	ä
		0, 0x1, 0x2, 0x3, 0x37, 0x2d, 0x2e, 0x2f,
		0x16, 0x5, 0x25, 0xb, 0xc, 0xd, 0xe, 0xf,
		0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26,
		0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f,
		0x40, 0x4f, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d,
		0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61,
		0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
		0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f,
		0xb5, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
		0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,
		0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
		0xe7, 0xe8, 0xe9, 0x63, 0xec, 0xfc, 0x5f, 0x6d,
		0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
		0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
		0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
		0xa7, 0xa8, 0xa9, 0x43, 0xbb, 0xdc, 0x59, 0x7,
		0x68, 0xd0, 0x51, 0x42, 0xc0, 0x44, 0x47, 0x48,
		0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4a, 0x67,
		0x71, 0x9c, 0x9e, 0xcb, 0x6a, 0xcd, 0xdb, 0xdd,
		0xdf, 0xe0, 0x5a, 0x70, 0xb1, 0x80, 0xbf, 0xff,
		0x45, 0x55, 0xce, 0xde, 0x49, 0x69, 0x9a, 0x9b,
		0xab, 0xaf, 0xba, 0xb8, 0xb7, 0xaa, 0x8a, 0x8b,
		0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x62, 0x64,
		0xb4, 0xff, 0xff, 0xff, 0xff, 0xb0, 0xb2, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x46, 0x66,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f,
		0x8c, 0xac, 0x72, 0x73, 0x74, 0xff, 0x75, 0x76,
		0x77, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x78, 0xff,
		0xee, 0xa1, 0xeb, 0xed, 0xcf, 0xef, 0xa0, 0x8e,
		0xae, 0xfe, 0xfb, 0xfd, 0x8d, 0xad, 0xbc, 0xbe,
		0xca, 0x8f, 0xff, 0xb9, 0xb6, 0x7c, 0xe1, 0x9d,
		0x90, 0xbd, 0xb3, 0xda, 0xfa, 0xea, 0xff, 0x41
	ü;
	int i , o;
	printf("%s at:%x(%d)ÖnÖn",id,p,l);
	if (p)
		for(o = 0;o <((l/16)+1)*16;o+=16)
		ä
			printf("%4.4lx:",o);
			for(i = o;i<o+16;i++)
			ä
				if ( i < l )
				ä
					printf("%2.2x",pÄiÜ& 0xFF );
					if (i%4 == 3) printf(" ");

				ü

				else
				ä
					if ( i%4 == 3) printf(" ");
					printf(" ");
				ü
			ü
			printf(" ");
			for(i = o;i<o+16;i++)
				if ( i < l )
					printf("%c",isprint(pÄiÜ)? pÄiÜ:'.');
				else printf(" ");
				printf(" ");
				for(i = o;i<o+16;i++)
					if ( i < l )
						printf("%c",isprint(ATOEÄpÄiÜÜ)?ATOEÄpÄiÜÜ:'.');  printf("Ön");

		ü
		return l;
ü

static iconv_t cpconv = 0;
char    msgbufÄ1024Ü;

char* translate(char* input, char* tbl)
ä
	char *outbuf = msgbuf;
	char *limit  = input + 1023;
	outbufÄ1023Ü = 'Ö0';

	if (cpconv == 0)
	ä
		size_t  i,   il, ol;
		char   *pe_to_a, *pa_to_e, cÄ256Ü, *pc = c;

		for (i=0; i<256; ++i) cÄiÜ = i;

		cpconv = iconv_open("ISO8859-1", "IBM-273");
		pc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;
		iconv(cpconv, &pc, &il, &pe_to_a, &ol);

		cpconv = iconv_open("IBM-273", "ISO8859-1");
		pc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;
		iconv(cpconv, &pc, &il, &pa_to_e, &ol);
	ü
	while ((input < limit) && (*outbuf = tblÄ*inputÜ))
	ä
		++input; ++outbuf;
	ü
	return msgbuf;
ü








typedef struct r79cchnl * R79celem;
typedef struct smf79pro * Smf79pro;
typedef struct r79cchnl   R79cchnl;
typedef struct r793     * R793;
#define UINTF(n) (*(unsigned int *)(n))
#define INTF(n) (*(signed int *)(n))
static R79cchnl channelsÄ256Ü;
typedef struct r792elem R792elem;
typedef struct r79chl R79chl;
typedef struct smf79hdr  SMF79hdr;
typedef struct smf79pro  SMF79pro;
typedef struct ascb * ascbP;
typedef struct asvt * asvtP;

int _rexxrmf2()
ä
	char wÄ32760Ü;
	jobEnv = new JOBENV(argvÄ0Ü);
	REXXVAR rexx(JOBENV::debug);

	cvtP      cvt = *(cvtP* )0x10;
	asvtP    asvt = asvtP(cvt->cvtasvt);
	unsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);
	if (JOBENV::debug)
		_dump("ASVT",(char *)asvtEntryP,4096);

	rexx.set(var("RMF2",0),0);

	ERB2XDGS_Addr Get_SMF_Record_79 = (ERB2XDGS_Addr) NULL;
	/* This program's ERB2XDGS default parameters */

	AnswerAreaAddress MyDgsAnswerAreaAddress = 0;
	ALET             MyDgsAnswerAreaALET    = 0;
	unsigned long int MyDgsAnswerAreaLength = 1048576;

	SystemName       MySystemName           ;
	memcpy(MySystemName,"*ALL",sizeof(MySystemName));

	DataGatheringParm MyDataGatheringParm   = ä 79, 2, "" ü;
	DataGatheringPLen MyDataGatheringPLen   = 4;

	ExitName         MyExitName             ;
	memcpy(MyExitName,"ERB2XSMF",sizeof(MyExitName));
	ExitParm         MyExitParm             = "";
	ExitParmLength   MyExitParmLength       = 0;

	unsigned long int MyDgsTimeOut          = 30;

	unsigned long int MyDgsReturnCode       = 0;
	unsigned long int MyDgsReasonCode       = 0;

	/* Get ERB2XDGS Answer Area storage */

	if ( ( MyDgsAnswerAreaAddress
		= (AnswerAreaAddress) malloc( MyDgsAnswerAreaLength ) ) == (AnswerAreaAddress) NULL )
	ä
		rexx.set("RMF2_ERROR",sprintf( w,"ÖnERB2XDGS Answer Area allocation failed.Ön" ));
		return( 8 );
	ü;

	/* Load RMF callable services ... */

	if ( ( Get_SMF_Record_79 = (ERB2XDGS_Addr)fetch("ERB2XDGS")) == (ERB2XDGS_Addr) NULL )
	ä
		rexx.set("RMF2_ERROR",sprintf(w, "ÖnERB2XDGS fetch failed.Ön" ));
		return( 8 );
	ü;

	/* Now invoke RMF callable service ... */


	(*Get_SMF_Record_79)( &MyDgsAnswerAreaAddress,
		&MyDgsAnswerAreaALET,
		&MyDgsAnswerAreaLength,
		&MySystemName,
		&MyDataGatheringParm,
		&MyDataGatheringPLen,
		&MyExitName,
		MyExitParm,
		&MyExitParmLength,
		&MyDgsTimeOut,
		&MyDgsReturnCode,
		&MyDgsReasonCode );


	/* Work with the returned RMF Monitor II data ... */
	if (MyDgsReturnCode == 0)
	ä

		//printf(" Answer area:%pÖn",MyDgsAnswerAreaAddress);

		AnswerAreaHeader * h = (AnswerAreaHeader *)MyDgsAnswerAreaAddress;
		SystemListEntry * s = (SystemListEntry * )
			((char *)h+h->SystemListOffset);
		/* Release Answer Area storage */
		sprintf(w,"%8.8s",h->SysplexName);
		rexx.set("RMF2_SYSPLEX_NAME",w);

		rexx.set(var("RMF2_SYSPLEX",0),int(h->SystemListEntryNumber));
		for (int i =0;i <h->SystemListEntryNumber;i++)
		ä
			sprintf(w,"%8.8s",s->MVSSystemName);
			rexx.set(var("RMF2_SYSPLEX",i+1,"SYSTEM_NAME"),w);
			sprintf(w,"%4.4s",s->SMFSystemID);
			rexx.set(var("RMF2_SYSPLEX",i+1,"SYSTEM_SMFID"),w);
			s =(SystemListEntry *)((char *)s+h->SystemListEntryLength);
		ü
		Monitor2DataEntry * d = (Monitor2DataEntry *)((char *)h+h->DataOffset);
		SMF79hdr * hdr       =(SMF79hdr *)((char *)d+d->Monitor2HeaderLength);

		//printf(" SMF79hdr:%d SMF79pro:%d R79chl:%dÖn",
		//  sizeof(SMF79hdr),sizeof(SMF79pro),sizeof(R79chl));

		R792elem * r = (R792elem *)((char *)hdr+hdr->smf79ass);
		rexx.set("RMF2_CPU",int(d->Monitor2DataSystemCpuUtilization));
		/*
		if (argvÄ1Ü)
		printf(" %s (%d)Ön",argvÄ1Ü,strlen(argvÄ1Ü));
		*/
		int count = 0;
		for (int i =0;i<hdr->smf79asn;i++)
		ä
			//if (argvÄ1Ü==0]]memcmpi((const char *)(r->r792jbn),argvÄ1Ü,strlen(argvÄ1Ü))==0)
			ä
				count++;
				sprintf(w,"%4.4X",*(short *)r->r792asid);
				rexx.set(var("RMF2",count,"ASID"),w);
				rexx.set(var("RMF2",count,"JOBID"),"");
				//if ((unsigned char )((*asvtEntryPÄ(*(short *)r->r792asid)Ü)-1)&(unsigned char)0x80==0)
				ä
					ascbP myascb = (ascbP)asvtEntryPÄ((*(short *)r->r792asid))-1Ü;
					assbP myassb = (assbP)myascb->ascbassb;
					iazjsabP myjsab = (iazjsabP)myassb->assbjsab;
					if (JOBENV::debug)
					ä
						_dump("ASCB",(char *)myascb,1024);
						_dump("ASSB",(char *)myassb,sizeof(*myassb));
						_dump("JSAB",(char *)myjsab,sizeof(*myjsab));
					ü

					if (myjsab&&myjsab->jsabjbidÄ0Ü)
					ä
						sprintf(w,"%8.8s",myjsab->jsabjbid);
						rexx.set(var("RMF2",count,"JOBID"),w);
					ü

				ü
				sprintf(w,"%8.8s",r->r792jbn);
				rexx.set(var("RMF2",count,"JOBNAME"),w);
				rexx.set(var("RMF2",count,"DOMAIN"),*(short *)r->r792jbn);
				rexx.set(var("RMF2",count,"PERFORMANCE_GROUP"),*(short*)r->r792npg);
				rexx.set(var("RMF2",count,"CURRENT_LOCATION"),*(short*)r->r792cl);
				rexx.set(var("RMF2",count,"TRANSACTION_COUNT"),*(short *)r->r792trc);
				rexx.set(var("RMF2",count,"TRANSACTION_TIME"),(*(int *)r->r792trc)/1000);
				rexx.set(var("RMF2",count,"PRIVATE_FRAMES"),*(int *)r->r792prfx);
				rexx.set(var("RMF2",count,"SRM_SERVICE_RATE"),*(int *)r->r792svar);
				rexx.set(var("RMF2",count,"TCB_CPU"),(*(int *)r->r792tcpu)/1000);
				rexx.set(var("RMF2",count,"TOTAL_CPU"),(*(int *)r->r792ejst)/1000);
				rexx.set(var("RMF2",count,"TOTAL_SRM"),*(int *)r->r792tsrm);
				rexx.set(var("RMF2",count,"STEP_RESIDENT_TIME"),*(int *)r->r792rtm);
				rexx.set(var("RMF2",count,"EXCP_COUNT"),*(int *)r->r792excp);

				rexx.set(var("RMF2",count,"PAGES_COMMON"),*(int *)r->r792cmni);
				rexx.set(var("RMF2",count,"PAGES_NONVIO"),*(int *)r->r792pnv);
				rexx.set(var("RMF2",count,"PAGES_VIO"),*(int *)r->r792pvio);
				rexx.set(var("RMF2",count,"PAGES_FIXED"),*(int *)r->r792fxbl);
				rexx.set(var("RMF2",count,"PAGES_SWAPPED_IN"),*(int *)r->r792pswp);
				rexx.set(var("RMF2",count,"PAGES_LPA_SWAPPED_IN"),*(int *)r->r792lpai);
				rexx.set(var("RMF2",count,"PAGES_CSA_SWAPPED_IN"),*(int *)r->r792csai);
				rexx.set(var("RMF2",count,"PAGES_FIXED_LSQA"),*(int *)r->r792cmni);
				rexx.set(var("RMF2",count,"PAGES_FIXED_NONLSQA"),*(int *)r->r792cmni);
				rexx.set(var("RMF2",count,"DEVICE_CONNECT"),*(int *)r->r792tdev);
				rexx.set(var("RMF2",count,"PAGE_IN"),*(int *)r->r792pin);
				rexx.set(var("RMF2",count,"TRANSACTION_RESIDENCY"),(*(int *)r->r792trtm)/1000);
				rexx.set(var("RMF2",count,"LSQA_REAL"),*(int *)r->r792lsqr);
				rexx.set(var("RMF2",count,"LSQA_EXTENDED"),*(int *)r->r792lsqe);
				rexx.set(var("RMF2",count,"REAL_FRAME_AVERAGE"),*(int *)r->r792ars);
				rexx.set(var("RMF2",count,"SRM_TARGET_WORKINGSET"),*(int *)r->r792twss);
				rexx.set(var("RMF2",count,"HIPERSPACE_PAGES"),*(int *)r->r792phsp);
				rexx.set(var("RMF2",count,"PAGES_COMMONT"),*(int *)r->r792cmni);
				sprintf(w,"%8.8s",r->r792scl);
				rexx.set(var("RMF2",count,"SERVICE_CLASS"),w);
				rexx.set(var("RMF2",count,"SERVICE_CLASS_PERIOD"),*(short *)r->r792scp);
				sprintf(w,"%8.8s",r->r792wkld);
				rexx.set(var("RMF2",count,"WORKLOAD_NAME"),w);
				sprintf(w,"%8.8s",r->r792rgrp);
				rexx.set(var("RMF2",count,"RESOURCE_GROUP"),w);
			ü
			r =(R792elem *)((char *)r+hdr->smf79asl);

		ü
		rexx.set(var("RMF2",0),count);
	ü
	else
	ä
		sprintf(w," ERB2XDGS rc:%d reason:%dÖn",MyDgsReturnCode,MyDgsReasonCode);
		rexx.set("RMF2_ERROR",w);
	ü
	free( MyDgsAnswerAreaAddress );

	return( MyDgsReturnCode );

ü;

const int Mbyte = 1024*1024;
char vsmlistÄMbyteÜ;
cvtP      cvt = *(cvtP* )0x10;
asvtP    asvt = asvtP(cvt->cvtasvt);
unsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);
int procVsmlist(char *);

class  asData
ä
public:
	ascbP ascb;
	short asid;
	char jobnameÄ9Ü;
	char jobidÄ9Ü;
	DBLWRD cpu;
	DBLWRD cpuOld;
	DBLWRD * ejst;
	DBLWRD * srbt;
	int stor;
	int storDiff;
	DBLWRD * iosx;
	DBLWRD  excp;
	DBLWRD  excpDiff;
	char timeÄ30Ü;
	int times;
public:
	asData(const char * );
	asData(int id)
	ä
		if ((unsigned char )(*asvtEntryPÄidÜ)&(unsigned char)0x80==0)
			ascb = (ascbP)asvtEntryPÄidÜ;
		init();
	ü
	int set();
	void print();
	int printRexx(REXXVAR *);
	void get();
	void printTitle()
	ä
		printf(" %s %sÖn",jobname,jobid);
		printf("    Cpu     CpuD      Stor      StorD      Excp    ExcpD Ön");
	ü
private:
	ascbP search(const char *);
	void init();
ü ;

asData::asData(const char * name)
ä
	if (ascb = search(name))
		init();
ü

ascbP asData::search(const char * name)
ä
	ascbP a = NULL;
	unsigned char * pascb =(unsigned char *)&(asvt->asvtenty);
	for (int i =0;i<asvt->asvtmaxi;i++,pascb+=4)
	ä
		if ((*pascb&(unsigned char)0x80)==0)
		ä
			a = *(ascbP *)pascb;
			if (a)
			ä
				if (a->ascbjbni)
				ä
					if (memcmp(name,a->ascbjbni,strlen(name))==0)
						break;
				ü
				else
					if  (memcmp(name,a->ascbjbns,strlen(name))==0)
						break;
			ü
		ü
	ü
	if (JOBENV::debug)
		_dump("ASCB",(char *)a,1024);
	return a;
ü

void asData::init()
ä
	asid  = ascb->ascbasid;
	if (ascb->ascbjbni)
		sprintf(jobname,"%8.8s",ascb->ascbjbni);
	else
		sprintf(jobname,"%8.8s",ascb->ascbjbns);
	for(int i =0;i<8;i++)
		if (jobnameÄiÜ == ' ')
			jobnameÄiÜ = 0;

	assbP assb = (assbP)ascb->ascbassb;
	iazjsabP jsab = (iazjsabP)assb->assbjsab;
	if (jsab->jsabjbidÄ0Ü)
		sprintf(jobid,"%8.8s",jsab->jsabjbid);
	else
		jobidÄ0Ü =0;
	ejst = (DBLWRD *)&(ascb->ascbejst);
	srbt = (DBLWRD *)&(ascb->ascbsrbt);
	cpu = *ejst+*srbt;
	cpuOld = cpu;
	iosx = (DBLWRD *)&(ascb->ascbiosx);
	excp = *iosx;
	excpDiff = excp;
	if (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))
		stor = procVsmlist(vsmlist);
	else
		stor = 0;
	storDiff = stor;
	times = 0;
	formatTime(time,sizeof(time),"%H:%M:%S");
	if (JOBENV::debug)
		_dump("asData",(char *)this,sizeof(asData));
ü;

int  asData::set()
ä
	times +=   (argvÄ2Ü?atoi(argvÄ2Ü):60);
	assbP assb = (assbP)ascb->ascbassb;
	iazjsabP jsab = (iazjsabP)assb->assbjsab;

	if (((ascb->ascbjbni&&memcmp(jobname,ascb->ascbjbni,8)==0)]]
		memcmp(jobname,ascb->ascbjbns,8)==0)&&
		memcmp(jobid,jsab->jsabjbid,8)==0)
	ä
		cpuOld = cpu;
		cpu = *ejst+*srbt;
		excpDiff = *iosx-excp;
		excp = *iosx;
		if (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))
		ä
			int _stor = procVsmlist(vsmlist);
			storDiff = _stor-stor;
			stor = _stor;
		ü
		else
			stor = storDiff =0;
		formatTime(time,sizeof(time),"%H:%M:%S");
		if (JOBENV::debug)
			_dump("asData",(char *)this,sizeof(asData));
		return 1;
	ü
	else
		return 0;
ü

void asData::print()
ä
	int _cpu = ((cpu>>12)+500)/1000;
	int _cpuOld = ((cpuOld>>12)+500)/1000;
	printf("%d %d %d %d %d %llu  %lluÖn",times,
		_cpu,_cpu-_cpuOld,
		stor,storDiff,
		excp,excpDiff);
ü

int asData::printRexx(REXXVAR * rexx)
ä
	int _cpu = ((cpu>>12)+500)/1000;
	int _excp = excp/1024;
	/*
	rexx->set(var(jobname,0,"CPU"),_cpu);
	rexx->set(var(jobname,0,"EXCP"),_excp);
	rexx->set(var(jobname,0,"VSTOR"),stor);
	*/
	return stor;
ü

int procVsmlist(char * pList)
ä
	if (JOBENV::debug)
		_dump("vsmList",pList,4096);
	int size = 0;
	int *p   = (int *)pList;
	int  tcbcount = *p++;
	while (tcbcount--)
	ä
		bool need = true;
		int tcb    =  *p++;
		int spcount = *p++;
		while(spcount--)
		ä
			int subpool = (*p>>8&0x000000FF);
			p+=1;
			need = (tcb == *p++);
			int bcount = *p++;
			while(bcount--)
			ä
				if ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)
				ä
					if (JOBENV::debug)
						printf(" %p  ",*p);
					p+=1;
					if (JOBENV::debug)
						printf(" %p",*p);
					size +=*p++;
					if (JOBENV::debug)
						printf(" size:%d subpool:%dÖn",size,subpool);
				ü
				else
					p+=2;
				int fcount = *p++;
				while(fcount--)
				ä
					if ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)
					ä
						if (JOBENV::debug)
							printf(" %p  ",*p);
						p+=1;
						if (JOBENV::debug)
							printf(" %p",*p);
						size -=*p++;
						if (JOBENV::debug)
							printf(" size:%d subpool:%dÖn",size,subpool);
					ü
					else
						p+=2;
				ü
			ü
		ü
	ü
	return (size+512)/1024;
ü


int _vsmlist()
ä
	jobEnv = new JOBENV(argvÄ0Ü);
	asData * as = new asData(argvÄ1Ü);
	as->printTitle();
	int count= argvÄ3Ü?atoi(argvÄ2Ü):10;
	for(int i = 0;i<count;i++)
	ä
		sleep(argvÄ2Ü?atoi(argvÄ2Ü):60);
		as->set();
		as->print();
	ü
	return 0;
ü

int _rexxvsm()
ä
	REXXVAR rexx(JOBENV::debug);
	jobEnv = new JOBENV(argvÄ0Ü);
	asData * as = new asData(argvÄ1Ü);
	return as->printRexx(&rexx);
ü
#define GIM_FREE      "FREE    "
#define GIM_QUERY     "QUERY   "
#define GIM_VERSION   "VERSION "
#define APILANG   "ENU"
#define TXT_VER   "VER"
#define LEN_ETYPE        12
#define LEN_ENAME         8
#define LEN_ZNAME         7
#define LEN_VERNUM        3
#define LEN_TXTVER        3
#define LEN_MSG         256
typedef void APIPGM(char *,void *,void *,char *,long *,long  *, char *);
typedef void cfunc();
#pragma linkage(APIPGM,OS)

static void errprint(char *, long, long, ITEM_LIST *,REXXVAR &);
static char *valprint(ITEM_LIST *);
static void resprint(ENTRY_LIST *,REXXVAR & );

int _rexxgim()
ä
	char wÄ32760Ü;
	jobEnv = new JOBENV(argvÄ0Ü);
	REXXVAR rexx(JOBENV::debug);
	long  rc,cc;
	QUERY_PARMS qparms;
	P_QUERY_PARMS pqparms = &qparms;
	ENTRY_LIST  *qreslt;
	ITEM_LIST   *msgbuff;
	APIPGM      *gimapi;
	API_VERSION pgmversion;
	API_VERSION *apiversion;

	char csiÄ45Ü;
	char zoneÄ100Ü;
	char entÄ100Ü;
	char subentÄ100Ü;
	char filterÄ1024Ü;

	rc = 0;
	cc = 0;

	/******************************************************************/
	/* Initialize pgmversion to API version used when program was     */
	/* written.  This is compared with the version returned from a    */
	/* call to GIMAPI with the VERSION command.                       */
	/******************************************************************/

	strncpy((char *)&pgmversion,"01090500",8);

	/***********************************************/
	/* Load the GIMAPI load module for use later   */
	/***********************************************/
	gimapi = (APIPGM *) fetch("GIMAPI");
	rexx.set(var("GIM",0),0);
	rexx.set("GIM_ERROR","");
	/****************************************************************/
	/* Call GIMAPI with VERSION to check if compatible with version */
	/* used when program was written.                               */
	/****************************************************************/
	gimapi(GIM_VERSION,0,(void**) &apiversion,APILANG,&rc,&cc,(char *)&msgbuff);

	if (rc|=0)
	ä
		errprint(GIM_VERSION, rc, cc, msgbuff,rexx);
		if (rc>4) goto EXIT;
	ü

	if (strncmp((const char *)&pgmversion,(const char *)apiversion,8)>0)
	ä
		printf("Incompatible Versions of the APIÖn");
		printf("  API Version: %.8sÖn",apiversion);
		printf("  Pgm Version: %.8sÖn",&pgmversion);
		goto EXIT;
	ü
	sprintf(w,"%.2s %.2s %.2s %.2s",apiversion->apiver,apiversion->apirel,apiversion->apimod,apiversion->apiptf);
	rexx.set("GIM_VERSION",w);
	/*
	printf("API Version Used:Ön");
	printf("  Version: %.2sÖn",apiversion->apiver);
	printf("  Release: %.2sÖn",apiversion->apirel);
	printf("  Mod    : %.2sÖn",apiversion->apimod);
	printf("  PTF    : %.2sÖnÖn",apiversion->apiptf);
	*/
	/*****************************************************/
	/* Create the QUERY. Put the parameter strings into  */
	/* variables and put the addresses of those variables*/
	/* in the query parameter structure along with the   */
	/* length of those strings.                          */
	/*****************************************************/
	strcpy(csi,rexx.fetch("GIM_CSI"));
	strcpy(zone,rexx.fetch("GIM_ZONE"));
	strcpy(ent,rexx.fetch("GIM_ENTRY"));
	strcpy(subent,rexx.fetch("GIM_SUBENTRY"));
	strcpy(filter,rexx.fetch("GIM_FILTER"));

	qparms.csi          = csi;
	qparms.csilen       = strlen(csi);
	qparms.zone         = zone;
	qparms.zonelen      = strlen(zone);
	qparms.entrytype    = ent;
	qparms.entrylen     = strlen(ent);
	qparms.subentrytype = subent;
	qparms.subentrylen  = strlen(subent);
	qparms.filter       = filter;
	qparms.filterlen    = strlen(filter);

	gimapi(GIM_QUERY,&pqparms,(void**) &qreslt,APILANG,&rc,&cc,(char *)&msgbuff);

	if (rc|=0)
	ä
		errprint(GIM_QUERY, rc, cc, msgbuff,rexx);
		if (rc>4) goto EXIT;
	ü

	/******************************************/
	/* Call routine to print results of query */
	/******************************************/
	resprint(qreslt,rexx);

EXIT:
	/****************************************/
	/* Free storage returned from the QUERY */
	/****************************************/
	gimapi(GIM_FREE,0,0,APILANG,&rc,&cc,(char *)&msgbuff);
	return 0;
	//release ((cfunc*)gimapi); ????????????????
ü

/******************************/
/* Print results of the query */
/******************************/
static void resprint(ENTRY_LIST *head,REXXVAR &rexx)
ä
	ENTRY_LIST  *curetype;
	CSI_ENTRY   *curentry;
	SUBENTRY    *cursubent;
	VER         *curver;
	SUBENTRY    *curversub;
	char        etypeÄ13Ü;
	char        vernumberÄ13Ü;
	char        versubtypeÄ13Ü;
	char        stEnameÄLEN_ENAME+1Ü;
	char        stZnameÄLEN_ZNAME+1Ü;
	char wÄ32760Ü;
	/********************************/
	/* Loop through each entry type */
	/********************************/
	int index = 0;
	for (curetype=head; curetype|=0 ; curetype=curetype->next)
	ä
		/********************************************/
		/* Print name of entry type being processed */
		/********************************************/

		strncpy(etype,curetype->type,LEN_ETYPE);
		etypeÄLEN_ETYPEÜ = 'Ö0';
		rexx.set(var("GIM",++index,"ETYPE"),etype);

		/********************************************************/
		/* Loop through each entry printing the ename and zone  */
		/* then the list of subentry values.                    */
		/********************************************************/
		for (curentry=curetype->entries;
			curentry|=0;
			curentry=curentry->next)
		ä
			strncpy(stEname,curentry->entryname,LEN_ENAME);
			stEnameÄLEN_ENAMEÜ='Ö0';
			strncpy(stZname,curentry->zonename,LEN_ZNAME);
			stZnameÄLEN_ZNAMEÜ='Ö0';

			rexx.set(var("GIM",index,"ENAME"),stEname);
			rexx.set(var("GIM",index,"ZONE"),stZname);
			int vindex= 0;
			for (cursubent=curentry->subentries;
				cursubent|=0;
				cursubent=cursubent->next)
			ä
				strncpy(etype,cursubent->type,LEN_ETYPE);
				etypeÄLEN_ETYPEÜ = 'Ö0';
				char * val ;
				if ((strncmp(etype,TXT_VER,LEN_TXTVER)) == 0)
				ä
					for (curver=(P_VER) cursubent->subentrydata;
						curver|=0;
						curver=curver->next)
					ä
						strncpy(vernumber,curver->vernum,LEN_VERNUM);
						vernumberÄLEN_VERNUMÜ='Ö0';
						for (curversub=curver->verdata;
							curversub|=0;
							curversub=curversub->next)
						ä

							/*********************************/
							/* Now print ver subentry values */
							/*********************************/
							strncpy(versubtype,curversub->type,LEN_ETYPE);
							versubtypeÄLEN_ETYPEÜ='Ö0';
							sprintf(w,"%.6s.%s",versubtype,vernumber);
							val = valprint((ITEM_LIST *)curversub->subentrydata);
							rexx.set(var("GIM",index,w),val);
							rexx.set(var("GIM",index,"VAR",++vindex,"TYPE"),w);
							rexx.set(var("GIM",index,"VAR",vindex,"VALUE"),val);
						ü
					ü
				ü
				else
				ä
					val = valprint((ITEM_LIST *)cursubent->subentrydata);
					rexx.set(var("GIM",index,etype),val);
					rexx.set(var("GIM",index,"VAR",++vindex,"TYPE"),etype);
					rexx.set(var("GIM",index,"VAR",vindex,"VALUE"),val);
				ü
			ü
			rexx.set(var("GIM",index,"VAR",0,"VALUE"),vindex);
		ü
	ü
	rexx.set(var("GIM",0),index);
ü

static char * valprint(ITEM_LIST *item1)
ä
	static char wÄ1024*1024Ü;
	char        databuffÄ1024*128Ü;
	ITEM_LIST   *curitem;
	wÄ0Ü = 0;
	for (curitem=item1;
		curitem|=0;
		curitem=curitem->next)
	ä
		strncpy(databuff,curitem->data,curitem->datalen);
		databuffÄcuritem->datalenÜ = 'Ö0';
		sprintf(w+strlen(w),"%s ",databuff);
	ü   return w;
ü

static void errprint(char *cmd, long rc, long cc, ITEM_LIST *msgs,REXXVAR & rexx)
ä
	char   msgoutÄLEN_MSG+1Ü;
	ITEM_LIST *curmsg;
	unsigned short i;
	char wÄ1024Ü;
	sprintf(w,"Error processing command: %s. RC=%d CC=%dÖn",
		cmd,rc,cc);
	rexx.set("GIM_ERROR",w);
	int index= 1;
	/*************************************************/
	/* Loop through a linked list of error messages  */
	/* printing them out.                            */
	/*************************************************/
	for (curmsg=msgs; curmsg|=0; curmsg=curmsg->next)
	ä
		strncpy(msgout,curmsg->data,curmsg->datalen);
		msgoutÄcurmsg->datalenÜ = 'Ö0';
		rexx.set(var("GIM_ERR",index),msgout);
	ü
	rexx.set(var("GIM_ERR",0),index);
ü


int main(int argC,char * argVÄÜ)
ä
	const static char *version=ISIS_VERSION;
	const static char *compileDate=ISIS_VERSION_DATE;
	if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
		printf(" MVSTOOL tester %s %s Version:%s Compiled:%sÖn",ISIS_PF_SID,ISIS_PF_NAME,version,compileDate);
	int j = 0;
	int count = 1;
	for (j= 0;testCasesÄjÜ.addr;j++)
		if (memcmpi(testCasesÄjÜ.name,argVÄ0Ü,strlen(argVÄ0Ü))==0)
			break;
	if (testCasesÄjÜ.addr==NULL)
	ä
		for (int i = 0;i<argC;i++)
		ä
			if (memcmpi(argVÄiÜ,"-t",2)==0)
			ä
				for (j= 0;testCasesÄjÜ.addr;j++)
					if (memcmpi(testCasesÄjÜ.name,argVÄiÜ+2,strlen(argVÄiÜ)-2)==0)
						break;
				if (testCasesÄjÜ.addr==NULL)
				ä
					printf("Invalid test case, %sÖn",argVÄiÜ+2);
					for(j=0;testCasesÄjÜ.addr;j++)
						printf("  %sÖn",testCasesÄjÜ.name);
					exit(8);
				ü
			ü
			/*
			else if (memcmpi(argVÄiÜ,"-r",2)==NULL)
			ä
			count = atoi(argVÄiÜ+2);
			if (count==0)
			count = 1;
			ü
			*/
			else
			ä
				argvÄargc++Ü = argVÄiÜ;
				if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
					printf("argÄ%dÜ:%sÖn",argc-1,argvÄargc-1Ü);
			ü
		ü
	ü
	else
	ä
		for (int i =0;i<argC;i++)
			argvÄargc++Ü = argVÄiÜ;
		if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
			printf("argÄ%dÜ:%sÖn",argc-1,argvÄargc-1Ü);
	ü
	if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
	ä
		printf(" Starting %s %d times(argc:%d)ÖnÖnÖn",testCasesÄjÜ.name,count,argc);
		for(;count;count--)
		ä
			if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
				printf(" ended with %dÖn",testCasesÄjÜ.addr());
		ü
		return 0;
	ü
	else
		return (testCasesÄjÜ.addr());
ü
