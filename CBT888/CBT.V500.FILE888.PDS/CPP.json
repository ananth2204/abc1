{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "ESA", "INMTNODE": "JES2P390", "INMTUID": "ESA", "INMFTIME": "20130207124354000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 548454, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 255, "INMBLKSZ": 32760, "INMRECFM": "VB", "INMDIR": 1, "INMDSNAM": "ESA.PRJ.CBTEXP.CPP", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 548454, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 548454, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ESA.PRJ.CBTEXP.CPP": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32760, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"APACALL": {"ttr": 267, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//-------------------------------------------------------------------\n// Copyright (c) 2006 by BankNet Technologies Inc.\n//    All Rights Reserved.  No part of the contents of this source\n//    program may be reproduced or transmitted in any form or by\n//    any means without the written permission of the publisher.\n//-------------------------------------------------------------------\n//\n// Function: Program to test a call to CAZAPI01.\n//\n//-------------------------------------------------------------------\n\n#include \"stdio.h\"\n// #include \"stdlib.h\"\n#include \"string.h\"\n\nstruct varchar\n{\n  unsigned short int slen;    /* length of string that follows    */\n  char string\u00dd512+1\u00a8;         /* the string                       */\n};\n\nextern \"OS\" {\n      void CAZAPI01(varchar *,varchar *,char *,int *,int *);\n            }\n\nmain(int argc , char * argv\u00dd\u00a8)\n{\n struct varchar Command;\n struct varchar Reply;\n\n int            ReturnCode = 0;\n int            ReasonCode = 0;\n\n char           *STCID = \"   \";\n char           *CommandString = \"NEW JOBNAME=(%s) DURATION=(10) \\\nSAMPLES=(1000) ACTIVE=(YES) RUNTOEOS=(N) DESCR='C++ API CALL'\";\n\nchar w\u00dd1024\u00a8;\nsprintf(w,CommandString,argv\u00dd1\u00a8);\n Command.slen = strlen(w);\n strcpy(Command.string,w);\n\n printf(\"Command:%s\\n\",w);\n Reply.slen = sizeof(Reply.string);\n Reply.string\u00dd0\u00a8 = 0;\n\n CAZAPI01(&Command,&Reply,STCID,&ReturnCode,&ReasonCode);\n\n printf(\"RC,RSN = %d,%d\\n\",ReturnCode,ReasonCode);\n printf(\"Reply:%s\\n\",Reply.string);\n\n return (ReasonCode);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CALLAPA": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x13\\x01\\x9f\\x01\\x13\\x01\\x9f\\x188\\x004\\x004\\x00\\x00\\xc5\\xe2\\xc1@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-01-19T00:00:00", "modifydate": "2013-01-19T18:38:06", "lines": 52, "newlines": 52, "modlines": 0, "user": "ESA"}, "text": "//-------------------------------------------------------------------\n// Copyright (c) 2006 by BankNet Technologies Inc.\n//    All Rights Reserved.  No part of the contents of this source\n//    program may be reproduced or transmitted in any form or by\n//    any means without the written permission of the publisher.\n//-------------------------------------------------------------------\n//\n// Function: Program to test a call to CAZAPI01.\n//\n//-------------------------------------------------------------------\n\n#include \"stdio.h\"\n#include \"string.h\"\n\nstruct varchar\n{\n  unsigned short int slen;    /* length of string that follows    */\n  char string\u00dd512+1\u00a8;         /* the string                       */\n};\n\nextern \"OS\" {\n      void CAZAPI01(varchar *,varchar *,char *,int *,int *);\n            }\n\nmain(int argc , char * argv\u00dd\u00a8)\n{\n struct varchar Command;\n struct varchar Reply;\n\n int            ReturnCode = 0;\n int            ReasonCode = 0;\n\n char           *STCID = \"   \";\n char           *CommandString = \"NEW JOBNAME=(%s) DURATION=(10) \\\nSAMPLES=(1000) ACTIVE=(YES) RUNTOEOS=(N) DESCR='C++ API CALL'\";\n\nchar w\u00dd1024\u00a8;\nsprintf(w,CommandString,argv\u00dd1\u00a8);\n Command.slen = strlen(w);\n strcpy(Command.string,w);\n\n printf(\"Command:%s\\n\",w);\n Reply.slen = sizeof(Reply.string);\n Reply.string\u00dd0\u00a8 = 0;\n\n CAZAPI01(&Command,&Reply,STCID,&ReturnCode,&ReasonCode);\n\n printf(\"RC,RSN = %d,%d\\n\",ReturnCode,ReasonCode);\n printf(\"Reply:%s\\n\",Reply.string);\n\n return (ReasonCode);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CASMIF": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/casmif.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#if  defined(OWN_STDIO) == 1\n#include \"stdio.hpp\"\n//#include \"crctable.hpp\"\n#include \"filesys.hpp\"\n#endif\n\n#include \"casmif.hpp\"\n#include \"mchain.hpp\"\n#include \"merror.hpp\"\n#include \"mvsbase.hpp\"\n#include \"mvstime.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0  //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifndef OWN_STDIO\n#include <assert.h>\n#endif\n\nISIS_EXT_ASM unsigned int ASMIF(void *);\nstatic pMvsInterface  _mvsInterface\u00c4\u00dc = \u00e40,0,0,0,0,0,0,0\u00fc;\nstatic pcsul          _tcb\u00c4\u00dc         = \u00e40,0,0,0,0,0,0,0\u00fc;\n//szm20081215 zIIP\nbool MvsInterface::zIIP = getenv(\"ISIS_ZIIP_SUPPORT\")?true:false;\npcsul  MvsInterface::wlmEnclave = 0;\n//szm20081215 zIIP\n\n//ZA030610 always 8\nstatic int            MAX_TCB        = 8;\nstatic char CRITICAL_MAJOR\u00c4\u00dc = \"ASM__MVS\";\nstatic char CRITICAL_MINOR\u00c4\u00dc = \"ASM__MVS__CRITICAL\";\nstatic char MSG_MAJOR\u00c4\u00dc      = \"ASM__MSG\";\nstatic char MSG_MINOR\u00c4\u00dc      = \"OMSMSGMN\";\nstatic char ASM_MAJOR\u00c4\u00dc      = \"OMS     \";\nstatic char ASM_MSG\u00c4\u00dc        = \"ASM_MSG\";\nstatic char WAIT_MAJOR\u00c4\u00dc     = \"ASM_WAIT\";\nstatic char POST_MAJOR\u00c4\u00dc     = \"ASM_POST\";\n#ifndef sym_init\n#define sym_init -1\n#endif\n\n//20060418MessageTEXT * messagetext = NULL; //szm2041120\n\nstatic int _init_messagetext = initMessageText();\n\nint  GlobalTraceFlag = getenv(\"TRACE\") ? atoi(getenv(\"TRACE\")):0;\nint  GlobalCicsFlag  = 0;\nstatic char* MSGQ    = getenv(\"MSGQ\") ? getenv(\"MSGQ\"):\"SASO\";\nstatic int   MvsTimer_status = 0;\n\nstatic void btracef(const char * text)\n \u00e4\n printf(\" %s \u00d6n\",text);\n \u00fc\n\n\nstatic int CompareAndSwap(pcsul &p1,pcsul p2,void *p3)\n \u00e4\n // if ( p1 == *p3 ) *p3 = p2\n // else p1 = *p3\n return 1;\n \u00fc\n\n#if (MEM_SUPPORT)\n//\n//------------------------------------------------------------------------------\n//\n\nvoid * OwnRealloc(void *a, size_t size)\n \u00e4\n if ( size == 0 )\n  return NULL;\n else if ( a == NULL )\n  return (OwnMalloc(size));\n void * n = OwnMalloc(size);\n if ( NOT n ) return NULL;\n size_t oldsize =*((int *)a-2)-16;\n assert(oldsize > 0);\n if ( oldsize < size )\n  memcpy(n,a,oldsize);\n else\n  memcpy(n,a,size);\n OwnFree(a);\n return n;\n \u00fc\n#endif\n/*-----------------------------------------------------------------\nMvsInterface\n------------------------------------------------------------------*/\n\nvoid MvsInterface::trace(char * t)\n \u00e4\n if ( GlobalTraceFlag && file )\n  fprintf(file,\"%s\u00d6n\",t);\n \u00fc\n\nvoid MvsInterface::tracedump(char * t,void * bv,int  bl)\n \u00e4\n if ( GlobalTraceFlag )\n  \u00e4\n  if ( file )\n   fprintf(file,\"%s === %p\u00d6n\",t,bv);\n  char p\u00c4512\u00dc;\n  char * b = (char *)bv;\n  for(int o = 0;o<=bl;o+=16)\n   \u00e4\n   dump(p,o,b,bl);\n   fprintf(file,\"%s %s \u00d6n\",DatetoString(),p);\n   \u00fc\n  \u00fc\n \u00fc\n\nvoid MvsInterface::extractOper(char * text)\n \u00e4\n mvsSTRING s(text), p1, p2, st;\n s.parse(p1,\"=\",st,\" \",p2);\n while ( st.lengthOf() )\n  \u00e4\n  char* c = strchr((char *)st,'=');\n  if ( c )\n   *c = 0;\n  else\n   c = \" 1\";\n  if ( strcmp(st,\"TRACE\") == 0)\n   GlobalTraceFlag = atoi(getenv(\"TRACE\"));\n  s = p1+p2;\n  s.parse(p1,\" =\",st,\" \",p2);\n  \u00fc\n strcpy(text,s);\n \u00fc\n\n/*-----------------------------------------------------------------\nMvsStcInterface\n------------------------------------------------------------------*/\n\nchar * function_name_table\u00c4\u00dc  = \u00e4\n \"CLEANUP\",\n \"GETTOKEN\",\n \"CREATETOKEN\",\n \"DELETETOKEN\",\n \"ALLOCATEPAGES\",\n \"FREEPAGES\",\n \"ENQ\",\n \"DEQ\",\n \"SLEEP\",\n \"GETECB\",\n \"WAIT\",\n \"POST\",\n \"RESET\",\n \"SELECT\",\n \"CONNECTSHMEM\",\n \"DISCONNECTSHMEM\",\n \"OPER\",\n \"WTO\",\n \"MALLOC\",\n \"FREE\",\n \"SVC\",\n \"ATTCHMVS\",\n \"CLOCK\",\n \"TIMEUSED\",    //szm0050301\n \"TDUMP\",       //szm\n \"LOGGER\",\n \"VTOC\",\n \"SRB\",\n \"WLM\",\n \"OBTAIN\",\n \"TESTAUTH\",\n \"DIAGNOSE\",\n \"VSMLIST\",\n NULL\n \u00fc;\n\n\nMvsInterface::MvsInterface()\n \u00e4\n srb = false;\n jobname\u00c48\u00dc = programname\u00c48\u00dc = 0x00;\n if ( GlobalTraceFlag && NOT GlobalCicsFlag )\n  \u00e4\n  file  = fopen(\"SYSPRINT\",\"w\");\n  \u00fc\n else file = 0;\n CASMIF(sym_init);\n memcpy(jobname,pASM->asm_jobname,8);\n memcpy(programname,pASM->asm_programname,8);\n // TRACE(4,Msg(9503)<<\">MvsInterface\"<<jobname<<programname<<eol);\n \u00fc\n\nMvsInterface::\u00dfMvsInterface()\n \u00e4\n if ( file ) fclose(file);\n CASMIF(sym_cleanup);\n pASM = 0;\n TRACE(4,SMsg(9501)<<\"<MvsInterface\"<<eol);\n \u00fc\n\nint MvsInterface::TCPCALL(int      function,\n             void *   p0,void *   p1,void *   p2,void * p3,\n             void *   p4,void *   p5,void *   p6,void * p7)\n \u00e4\n CASMIF(function,p0,p1,p2,p3,\n  p4,p5,p6,p7);\n#if 0\n if ( rc == -1 )\n  \u00e4\n  CASMIF(sym_lasterror);\n  TRACE(1,Msg(9502)<<\">Socket errror\"<<int(rc)<<eol);\n  MsgEnq();\n  Msg(9511)<<function_name_table\u00c4function\u00dc\n  <<\" code:\"<<rc<<eol;\n  MsgDeq();\n  return -1;\n  \u00fc\n#endif\n return rc;\n \u00fc\n\nint MvsInterface::CASMIF(int      function,\n             void * p0,void * p1,void * p2,void *p3,\n             void * p4,void * p5,void * p6,void *p7)\n \u00e4\n if (function == sym_init)\n  \u00e4\n  pASM = (pasm)ASMIF(0);\n  assert(pASM);\n  pASM->asm_mvs = this;\n  \u00fc\n else\n  \u00e4\n  pASM->asm_function_code = char(function);\n  pASM->asm_parms\u00c40\u00dc= p0;\n  pASM->asm_parms\u00c41\u00dc= p1;\n  pASM->asm_parms\u00c42\u00dc= p2;\n  pASM->asm_parms\u00c43\u00dc= p3;\n  pASM->asm_parms\u00c44\u00dc= p4;\n  pASM->asm_parms\u00c45\u00dc= p5;\n  pASM->asm_parms\u00c46\u00dc= p6;\n  pASM->asm_parms\u00c47\u00dc= p7;\n  ASMIF(pASM);\n  rc = int(pASM->asm_rc);\n  reason = int(pASM->asm_reason);\n  //szm20030616 no check for ENQ/DEQ\n  if ( function NEQ sym_sleep &&  function NEQ sym_wait && function NEQ sym_attachmvs\n   && function NEQ sym_svc &&  function NEQ sym_clock && function NEQ sym_logger && function NEQ sym_wlm\n   && function NEQ sym_srb   // no check for SRB\n   &&function NEQ sym_obtain)\n   check(rc,function,\" CASMIF \");\n  else\n   return (rc);\n  \u00fc\n return (rc==0);\n \u00fc\nint MvsInterface::check(int r,char *function,char * action)\n \u00e4\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<rc<<hex<<function<<action<<eol);\n if ( r )\n  \u00e4\n  MsgEnq();\n  Msg(9510)<<function<<action<<r<<eol;\n  MsgDeq();\n  \u00fc\n return r;\n \u00fc\n\n\nint MvsInterface::check(int r,int function,char * action)\n \u00e4\n\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n char hexrsn\u00c49\u00dc;\n sprintf(hexrsn,\"%8.8x\",pASM->asm_bpx1_rsncode);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<int(rc)<<hex<<\n  function_name_table\u00c4function\u00dc<<action<<eol);\n if ( r )\n  \u00e4\n  switch(function)\n   \u00e4\n   case sym_select:      if ( r < 0 )\n    \u00e4\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     hex<<hexrsn<<eol;\n    MsgDeq();\n    \u00fc\n              break;\n   case sym_enq:         if ( r == -1 ) break;\n   case sym_wait:        if ( r == -1 ) break;\n   case sym_gettoken:    if ( r == 4 ) break;\n   case sym_deletetoken: if ( r == 4 ) break;\n   case sym_disconnectshmem: if ( r == 4 ) break;\n   case sym_vtoc:        if ( r ==4 ) break;\n   default:\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     r<<hex<<eol;\n    MsgDeq();\n   \u00fc\n  \u00fc\n return r;\n \u00fc\n\n\npcsul MvsInterface::GetTCB()\n \u00e4\n return (*(pcsul *)PSATOLD);\n \u00fc\n\npcsul MvsInterface::GetASCB()\n \u00e4\n return(*(pcsul *)PSAAOLD);\n \u00fc\n\nint MvsInterface::CheckASCB(pcsul ascb)\n \u00e4\n return(NOT (memcmp(\"ASCB\",(char *)ascb,4)));\n \u00fc\n\npcsul MvsInterface::GetToken(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">GetToken\"<<n<<eol);\n if ( n  &&  CASMIF(sym_gettoken,n,wt))\n  \u00e4\n  TRACEDUMP(4,SMsg(9501)<<\"<GetToken\"<<eol,(void *)wt,sizeof(*wt));\n  return ((pcsul)wt);\n  \u00fc\n return ((pcsul)NULL);\n \u00fc\n\npcsul MvsInterface::CreateToken(char *n,pcsul * v)\n \u00e4\n TRACE(4,SMsg(9502)<<\">CreateToken\"<<n<<eol);\n wt\u00c40\u00dc = v\u00c40\u00dc;\n wt\u00c41\u00dc = v\u00c41\u00dc;\n wt\u00c42\u00dc = v\u00c42\u00dc;\n wt\u00c43\u00dc = v\u00c43\u00dc;\n rc = 16;\n if ( n )\n  \u00e4\n  CASMIF(sym_createtoken,n,wt);\n  if ( rc == 4 )\n   \u00e4\n   CASMIF(sym_deletetoken,n);\n   CASMIF(sym_createtoken,n,wt);\n   \u00fc\n  \u00fc\n TRACEDUMP(4,SMsg(9501)<<\">CreateToken\"<<eol,(void *)wt,sizeof(*wt));\n return (rc==0);\n \u00fc\n\nvoid MvsInterface::DeleteToken(char *n)\n \u00e4\n TRACEDUMP(4,SMsg(9501)<<\">DeleteToken\"<<eol,(void *)n,strlen(n));\n CASMIF(sym_deletetoken,n);\n TRACE(4,SMsg(9501)<<\"<DeleteToken\"<<eol);\n \u00fc\n\n\nint MvsInterface::WaitEcb(pcsul  ms,\n             void * pecb0,void * pecb1,void * pecb2,void * pecb3)\n \u00e4\n TRACEDUMP(4,SMsg(9503)<<\">WaitEcb\"<<rc<<ms<<eol,pecb0,20);\n CASMIF(sym_wait,(void *)ms,pecb0,pecb1,pecb2,pecb3);\n TRACE(4,SMsg(9502)<<\"<WaitEcb\"<<rc<<eol);\n return rc;\n \u00fc\n\nint MvsInterface::PostEcb(void * pecb,pcsul code)\n \u00e4\n TRACE(3,SMsg(9502)<<\">PostEcb\"<<code<<eol);\n CASMIF(sym_post,pecb,(void *)code);\n TRACEDUMP(3,SMsg(9502)<<\"<PostEcb\"<<rc<<eol,pecb,20);\n return rc;\n \u00fc\n\nint MvsInterface::Enq(char * n,int ms)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Enq\"<<n<<ms<<eol);\n CASMIF(sym_enq,ASM_MAJOR,n,(void *)strlen(n),(void *)ms);\n TRACE(4,SMsg(9502)<<\"<Enq\"<<rc<<eol);\n if ( rc == 0 ) return 1;\n else if ( rc < 0 ) return 0;\n else return -1;\n \u00fc\n\nint MvsInterface::Deq(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Deq\"<<n<<eol);\n CASMIF(sym_deq,ASM_MAJOR,n,(void *)strlen(n));\n TRACE(4,SMsg(9503)<<\"<Deq\"<<rc<<n<<eol);\n return (rc==0);\n \u00fc\n\n\nint MvsInterface::Svc(int n, void *p)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Svc\"<<n<<eol);\n CASMIF(sym_svc,(void *)n,(void *)p);\n TRACE(4,SMsg(9503)<<\"<Svc\"<<rc<<n<<eol);\n return (rc);\n \u00fc\n\nint MvsInterface::AttachMvs(const char * module,const char * parms)\n \u00e4\n size_t l_module= strlen(module);\n size_t l_parms = strlen(parms);\n TRACE(4,SMsg(9503)<<\">AttachMvs\"<<module<<parms<<eol);\n CASMIF(sym_attachmvs,(void *)&l_module,(void *)module,(void *)&l_parms,(void *)parms);\n TRACE(4,SMsg(9503)<<\"<AttachMvs\"<<rc<<module<<eol);\n return (rc);\n \u00fc\n\nvoid MvsInterface::Clock(void * stck)\n \u00e4\n CASMIF(sym_clock,stck);\n \u00fc\n\n//szm\nvoid MvsInterface::Timeused(void * time) //szm\n \u00e4\n CASMIF(sym_timeused,time);\n \u00fc\n\nlong long clock_mvs()\n \u00e4\n long long here;\n mvs()->Timeused(&here);\n return here;\n \u00fc\n//szm\n//szm\nint MvsInterface::Tdump(const char * n,const char *d,int dd = 0)\n \u00e4\n return (CASMIF(sym_tdump,(void *)n,(void *)d,(void *)dd));\n \u00fc\n\nint tdump(const char *n, const char *d,int dd)\n \u00e4\n return mvs()->Tdump(n,d,dd);\n \u00fc\n\n//szm20071005 get back reason code\nint mvsReasonCode()\n \u00e4\n return mvs()->getReasonCode();\n \u00fc\n//szm20071005 get back reason code\n\n\n//szm\n\n//szm20051118 LOGGER\n//szm\nint MvsInterface::LoggerOpen(const char * stream)\n \u00e4\n char zeros\u00c417\u00dc = \"\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\";\n char token\u00c417\u00dc = \"                \";\n memcpy(token,stream,(strlen(stream)<16?strlen(stream):16));\n pcsul  p =NULL;\n\n if (strcmp(stream,(const char *)(pASM->asm_streamname))==0)\n  \u00e4\n  if (memcmp(pASM->asm_streamtoken,zeros,16)==0)\n   \u00e4\n   if (p=GetToken(token))\n    memcpy(pASM->asm_streamtoken,(char *)p,16);\n   else\n    if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))==0)\n     CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n    else\n     return 0;\n   \u00fc\n  return 1;\n  \u00fc\n\n if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))|=0);\n return 0;\n\n CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n return 1;\n \u00fc\nint MvsInterface::Logger(const char * stream,size_t l)\n \u00e4\n return (CASMIF(sym_logger,(void *)1,(void *)stream,(void *)(l?l:strlen(stream)))==0);\n \u00fc\n//szm\nint MvsInterface::BrowseLogger(const char * & addr,size_t *  & length,int direction,int all,char * date_time)\n \u00e4\n  if (direction ==0) //szm\n   direction = 2;\n return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)date_time));\n \u00fc\n\n//szm\nint MvsInterface::LoggerClose()\n \u00e4\n //return (CASMIF(sym_logger,(void *)-1)); szm\n // never close the logger\n return 1;\n \u00fc\n//szm20051118 LOGGER\n//szm20051121 VTOC\nint MvsInterface::VtocOpen(const char * ddname,const char * mask,char *dscb)\n \u00e4\n char _mask\u00c446\u00dc;\n char _ddname\u00c49\u00dc;\n memcpy(_mask+1,mask,44);\n _mask\u00c445\u00dc = 0;\n if (strchr(_mask+1,' '))\n  *strchr(_mask+1,' ')= 0;\n _mask\u00c40\u00dc = strlen(_mask+1);\n memset(_ddname,' ',8);\n _ddname\u00c48\u00dc = 0;\n memcpy(_ddname,ddname,(strlen(ddname)<=8)?strlen(ddname):8);\n CASMIF(sym_vtoc,(void *)0,(void *)_ddname,(void *)_mask,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::Vtoc(char * dscb)\n \u00e4\n CASMIF(sym_vtoc,(void *)1,(void *)0,(void *)0,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::VtocClose()\n \u00e4\n return (CASMIF(sym_vtoc,(void *)-1));\n \u00fc\n//szm20051121 VTOC\n\n//szm\nint MvsInterface::initEnclave()\n  \u00e4\n \treturn wlmEnclave;\n  \u00fc\n\nint MvsInterface::Srb()\n \u00e4\n if (srb)\n  \u00e4\n CASMIF(sym_srb);\n srb = false;\n //printf(\" exit from SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  \u00fc\n else\n  \u00e4\n  //printf(\" entry to SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  srb = true;\n  CASMIF(sym_srb);\n  \u00fc\n return rc;\n \u00fc\n\n\nint MvsInterface::Wlm(const char * subsys,const char * subsysnm)\n \u00e4\n /*\n if (CASMIF(sym_wlm,(void *)subsys,(void *)subsysnm)|=0)\n  \u00e4\n  printf(\" WLM function:%8.8s rc:%d(%8.8x) rsn:%d(%8.8x)\u00d6n\",\n   pASM->asm_wlm_macro,pASM->asm_wlm_retcode,pASM->asm_wlm_retcode,\n   pASM->asm_wlm_rsncode,pASM->asm_wlm_rsncode);\n  return 8;\n  \u00fc\n */\n\n return 0;\n \u00fc\n\nint MvsInterface::Obtain(const char * dsn, const char * volser,char * dscb)\n\u00e4\n return (CASMIF(sym_obtain,(void *)dsn,(void *)volser,(void *)dscb));\n\u00fc\n\nint MvsInterface::Testauth()\n\u00e4\n return (CASMIF(sym_testauth));\n\u00fc\n\nint MvsInterface::Diagnose(int function,void * reply)\n\u00e4\n return(CASMIF(sym_diagnose,(void *)function,reply));\n\u00fc\n\n\nint MvsInterface::Vsmlist(void * ascb,void * address, int length )\n\u00e4\n return(CASMIF(sym_vsmlist,ascb,address,(void *)length));\n\u00fc\n\nvoid MvsInterface::Chap(pcsul t,int p)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Chap\"<<t<<long(p)<<eol);\n#ifdef __SASC_\n CHAP(p,&t);\n#endif\n TRACE(4,SMsg(9501)<<\"<Chap\"<<eol);\n \u00fc\n\npcsul MvsInterface::Attach(char * pgm,char ** param,pcsul ecb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Attach\"<<pgm<<eol);\n pcsul tcb = 0;\n *(pcsul *)ecb = 0;\n pcsul lparam\u00c416\u00dc;\n int i;\n for(i =0;i<16 && param\u00c4i\u00dc;i++)lparam\u00c4i\u00dc = (pcsul)(param\u00c4i\u00dc);\n lparam\u00c4i\u00dc = lparam\u00c4i\u00dc ] 0x80000000;\n check(rc,\"Attach\",\"ATTACH\");\n TRACE(4,SMsg(9501)<<\"<Attach\"<<eol);\n return tcb;\n \u00fc\n\nvoid MvsInterface::Detach(pcsul tcb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Detach\"<<tcb<<eol);\n check(rc,\"Deatch\",\"DETACH\");\n TRACE(4,SMsg(9501)<<\"<Detach\"<<eol);\n \u00fc\n\nvoid MvsInterface::Sleep(int ms)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Sleep\"<<ms<<eol);\n if (ms) CASMIF(sym_sleep,(void *)ms);\n TRACE(4,SMsg(9501)<<\"<Sleep\"<<eol);\n \u00fc\n\nint MvsInterface::Oper(char *to,const size_t length)\n \u00e4\n TRACE(4,SMsg(9501)<<\">Oper\"<<eol);\n memset(to,0,length);\n CASMIF(sym_oper,(void *)to,(void *)length);\n if ( rc == 0 ) extractOper(to);\n TRACE(4,SMsg(9503)<<\"<Oper\"<<to<<rc<<eol);\n return rc;\n \u00fc\n\nvoid MvsInterface::Wto(const char *text,const int desc)\n \u00e4\n if ( text == 0 ) return;\n TRACE(4,SMsg(9502)<<\">Wto\"<<text<<eol);\n char  t\u00c4128\u00dc;\n memset(t,0,sizeof(t));\n strncpy(t,text,sizeof(t)-1);\n for(char * ct = t;*ct;ct++) if( *ct == '\u00d6n') *ct = ' ';\n CASMIF(sym_wto,(void *)t,(void *)strlen(t),(void *)desc);\n TRACE(4,SMsg(9501)<<\"<Wto\"<<eol);\n \u00fc\n\nvoid * MvsInterface::Malloc(size_t size)\n \u00e4\n void * a = 0;\n CASMIF(sym_malloc,(void *)size,(void *)&a);\n check(rc,\"Malloc\",\"MALLOC\");\n return a;\n \u00fc\n\nvoid  MvsInterface::Free(void * a)\n \u00e4\n CASMIF(sym_free,(void *)a);\n check(rc,\"Free\",\"FREE\");\n return ;\n \u00fc\n\n\nint MvsInterface::Select(pcsul numfds,\n             void *rfds,void *wfds,void *efds,void *time)\n \u00e4\n CASMIF(sym_select,(void *)numfds,rfds,wfds,efds,time);\n TRACE(4,SMsg(9502)<<\"<Select\"<<rc<<eol);\n return rc;\n \u00fc\n\n/*-----------------------------------------------------------------\nCOMMON functions\n------------------------------------------------------------------*/\n\nint isCics()\u00e4 return GlobalCicsFlag;\u00fc\n\n\nMvsInterface * getTcbUser()\n \u00e4\n pcsul  p = * (pcsul  * )PSATOLD;\n pasm pASM = ((pasm)*(pasm *)(p+TCBUSER));\n if (pASM)\n  return((MvsInterface *)(pASM->asm_mvs));\n else\n  return((MvsInterface * )NULL);\n \u00fc\n\n\nMvsInterface * mvs()\n \u00e4\n int i = 0;\n for(;i<MAX_TCB && _mvsInterface\u00c4i\u00dc;i++)\n  if (_tcb\u00c4i\u00dc == *(pcsul *)PSATOLD) break;\n assert(i<MAX_TCB);\n if (_mvsInterface\u00c4i\u00dc && _tcb\u00c4i\u00dc == *(pcsul *)PSATOLD)\n  return(_mvsInterface\u00c4i\u00dc);\n _tcb\u00c4i\u00dc = *(pcsul *)PSATOLD;\n return (_mvsInterface\u00c4i\u00dc = (MvsInterface*)new MvsInterface());\n \u00fc\n\nint MsgEnq()\n \u00e4\n int rc = 0;\n rc = ( ENQ(MSG_MAJOR,MSG_MINOR,E,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\nint MsgDeq()\n \u00e4\n int rc = 0;\n rc = ( DEQ(MSG_MAJOR,MSG_MINOR,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\n//KV\nSyncVar::SyncVar(pcsul w)\n \u00e4\n var  = 0;\n wait = w;\n ecb  = 0;\n \u00fc\n\nSyncVar::SyncVar(const SyncVar & v)\n \u00e4\n var  = v.var;\n wait = v.wait;\n ecb = 0;\n \u00fc\nSyncVar::\u00dfSyncVar()\n \u00e4\n if (ecb&WAITcode)\n  mvs()->PostEcb(&ecb,0);\n \u00fc\nSyncVar& SyncVar::operator=(pcsul t)\n \u00e4\n // printf(\" %p TCB %s %d\u00d6n\",*(pcsul *)PSATOLD,\">operator\",t);\n // btrace(&btracef);\n for(;;)\n  \u00e4\n  // if ( p1 == *p3 ) *p3 = p2\n  // else p1 = *p3\n  pcsul x = var;\n  if (CompareAndSwap(x,t,&var)==0)\n   break;\n  \u00fc\n mvs()->PostEcb(&ecb,t);\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<operator\",var);\n return(*this);\n \u00fc\n\nSyncVar::operator int()\n \u00e4\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"init()\",var);\n return int(var);\n \u00fc\n\npcsul waitSyncVar(SyncVar &s)\n \u00e4\n //printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\">wait\",s.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if (mvs()->WaitEcb(s.wait,&s.ecb) <0)\n   return (-1);\n // printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<wait\",s.var);\n return(s.var);\n \u00fc\npcsul waitSyncVars(SyncVar &s1,SyncVar &s2)\n \u00e4\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\">waits\",s1.var, s2.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s1.ecb)&0x80000000 ]] int(s2.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if\n   (mvs()->WaitEcb((s1.wait<s2.wait?s1.wait:s2.wait),&s1.ecb,&s2.ecb) < 0)\n   return (-1);\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\"<waits\",s1.var, s2.var);\n return(1);\n \u00fc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EBCDICUT": {"ttr": 245, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/isislib/ebcdicut.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   Definitions for ascii/ebcdic conversion\n*******************************************************************************/\n#define ISIS_DONT_USE_PCSDLL\n#include \"isisdef.h\"\n// EBCDIC->ASCII table (273->850)\nextern const unsigned char isis_etoa\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x9F, 0x09, 0xB0, 0x7F,\n  0xB1, 0xB2, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0xB4, 0x0A, 0x08, 0xBA,\n  0x18, 0x19, 0xBB, 0xBC, 0x1C, 0x1D, 0x1E, 0x1F,\n  0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0x0A, 0x17, 0x1B,\n  0xC4, 0xC5, 0xC8, 0xC9, 0xCA, 0x05, 0x06, 0x07,\n  0xCB, 0xCC, 0x16, 0xCD, 0xCE, 0xD5, 0xD9, 0x04,\n  0xDA, 0xDB, 0xDC, 0xDF, 0x14, 0x15, 0xF2, 0x1A,\n  0x20, 0xFF, 0x83, 0x7B, 0x85, 0xA0, 0xC6, 0x86,\n  0x87, 0xA4, 0x8E, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n  0x26, 0x82, 0x88, 0x89, 0x8A, 0xA1, 0x8C, 0x8B,\n  0x8D, 0x7E, 0x9A, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n  0x2D, 0x2F, 0xB6, 0x5B, 0xB7, 0xB5, 0xC7, 0x8F,\n  0x80, 0xA5, 0x94, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n  0x9B, 0x90, 0xD2, 0xD3, 0xD4, 0xD6, 0xD7, 0xD8,\n  0xDE, 0x60, 0x3A, 0x23, 0xF5, 0x27, 0x3D, 0x22,\n  0x9D, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n  0x68, 0x69, 0xAE, 0xAF, 0xD0, 0xEC, 0xE7, 0xF1,\n  0xF8, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n  0x71, 0x72, 0xA6, 0xA7, 0x91, 0xF7, 0x92, 0xCF,\n  0xE6, 0xE1, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n  0x79, 0x7A, 0xAD, 0xA8, 0xD1, 0xED, 0xE8, 0xA9,\n  0xBD, 0x9C, 0xBE, 0xFA, 0xB8, 0x40, 0xF4, 0xAC,\n  0xAB, 0xF3, 0xAA, 0x7C, 0xEE, 0xF9, 0xEF, 0x9E,\n  0x84, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n  0x48, 0x49, 0xF0, 0x93, 0xDD, 0x95, 0xA2, 0xE4,\n  0x81, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n  0x51, 0x52, 0xFB, 0x96, 0x7D, 0x97, 0xA3, 0x98,\n  0x5C, 0xF6, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n  0x59, 0x5A, 0xFD, 0xE2, 0x5C, 0xE3, 0xE0, 0xE5,\n  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n  0x38, 0x39, 0xFC, 0xEA, 0x5D, 0xEB, 0xE9, 0xFE\n\u00fc ;\n\n// ASCII->EBCDIC table (850->273)\nextern const unsigned char isis_atoe\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x68, 0xD0, 0x51, 0x42, 0xC0, 0x44, 0x47, 0x48,\n  0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4A, 0x67,\n  0x71, 0x9C, 0x9E, 0xCB, 0x6A, 0xCD, 0xDB, 0xDD,\n  0xDF, 0xE0, 0x5A, 0x70, 0xB1, 0x80, 0xBF, 0x04,\n  0x45, 0x55, 0xCE, 0xDE, 0x49, 0x69, 0x9A, 0x9B,\n  0xAB, 0xAF, 0xBA, 0xB8, 0xB7, 0xAA, 0x8A, 0x8B,\n  0x06, 0x08, 0x09, 0x0A, 0x14, 0x65, 0x62, 0x64,\n  0xB4, 0x15, 0x17, 0x1A, 0x1B, 0xB0, 0xB2, 0x20,\n  0x21, 0x22, 0x23, 0x24, 0x28, 0x29, 0x46, 0x66,\n  0x2A, 0x2B, 0x2C, 0x30, 0x31, 0x33, 0x34, 0x9F,\n  0x8C, 0xAC, 0x72, 0x73, 0x74, 0x35, 0x75, 0x76,\n  0x77, 0x36, 0x38, 0x39, 0x3A, 0xCC, 0x78, 0x3B,\n  0xEE, 0xA1, 0xEB, 0xED, 0xCF, 0xEF, 0xA0, 0x8E,\n  0xAE, 0xFE, 0xFB, 0xFD, 0x8D, 0xAD, 0xBC, 0xBE,\n  0xCA, 0x8F, 0x3E, 0xB9, 0xB6, 0x7C, 0xE1, 0x9D,\n  0x90, 0xBD, 0xB3, 0xDA, 0xFA, 0xEA, 0xFF, 0x41\n\u00fc ;\n\n// EBCDIC->ASCII table (273->ISO8859-1)\nextern const unsigned char isis_etoa_ISO8859_1\u00c4256\u00dc =\n\u00e4\n   0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F,\n   0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n   0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87,\n   0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,\n   0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B,\n   0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,\n   0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,\n   0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,\n   0x20, 0xA0, 0xE2, 0x7B, 0xE0, 0xE1, 0xE3, 0xE5,\n   0xE7, 0xF1, 0xC4, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n   0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF,\n   0xEC, 0x7E, 0xDC, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n   0x2D, 0x2F, 0xC2, 0x5B, 0xC0, 0xC1, 0xC3, 0xC5,\n   0xC7, 0xD1, 0xF6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n   0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF,\n   0xCC, 0x60, 0x3A, 0x23, 0xA7, 0x27, 0x3D, 0x22,\n   0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n   0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,\n   0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n   0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,\n   0xB5, 0xDF, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n   0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,\n   0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0x40, 0xB6, 0xBC,\n   0xBD, 0xBE, 0xAC, 0x7C, 0xAF, 0xA8, 0xB4, 0xD7,\n   0xE4, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n   0x48, 0x49, 0xAD, 0xF4, 0xA6, 0xF2, 0xF3, 0xF5,\n   0xFC, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n   0x51, 0x52, 0xB9, 0xFB, 0x7D, 0xF9, 0xFA, 0xFF,\n   0xD6, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n   0x59, 0x5A, 0xB2, 0xD4, 0x5C, 0xD2, 0xD3, 0xD5,\n   0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n   0x38, 0x39, 0xB3, 0xDB, 0x5D, 0xD9, 0xDA, 0x9F\n\u00fc ;\n\n// ASCII->EBCDIC table (ISO8859-1->273)\nextern const unsigned char isis_atoe_ISO8859_1\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17,\n  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,\n  0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08,\n  0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,\n  0x41, 0xAA, 0xB0, 0xB1, 0x9F, 0xB2, 0xCC, 0x7C,\n  0xBD, 0xB4, 0x9A, 0x8A, 0xBA, 0xCA, 0xAF, 0xBC,\n  0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3,\n  0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,\n  0x64, 0x65, 0x62, 0x66, 0x4A, 0x67, 0x9E, 0x68,\n  0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,\n  0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xE0, 0xBF,\n  0x80, 0xFD, 0xFE, 0xFB, 0x5A, 0xAD, 0xAE, 0xA1,\n  0x44, 0x45, 0x42, 0x46, 0xC0, 0x47, 0x9C, 0x48,\n  0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,\n  0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0x6A, 0xE1,\n  0x70, 0xDD, 0xDE, 0xDB, 0xD0, 0x8D, 0x8E, 0xDF\n\u00fc ;\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBENV": {"ttr": 249, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/jobenv.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <string.h>\n#include <strings.h>\n#if defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\" //szm\n#endif\n#include \"jobenv.hpp\"\n#include \"msgmgr.hpp\"\n#include \"misc.hpp\"\n#include \"tiot1.hpp\"\n#include \"ikjrb.hpp\"\n#include \"ihacde.hpp\"\n#include \"psa.hpp\"\n#include \"tcbfix.hpp\"\n#include \"iezjscb.hpp\"\n#include \"ssib.hpp\"\n#include \"tiot1ds.hpp\"\n\nint JOBENV::debug = 0;\nchar * KEYWORD_DEBUG = \"DEBUG\";\nJOBENV * jobEnv = NULL;\n\n\nJOBENV::JOBENV(char * argv0)\n\u00e4\n  program        = argv0;\n\n  psa    *  psaP    = (psa *)NULL;\n  tcbfix *  tcbfixP = (tcbfix*)psaP->psatold;\n            tcbfixP = (tcbfix*)((char *)tcbfixP-sizeof(tcbfixP->tcbfrs));\n  tiot1ds *  tiot1P  = (tiot1ds*)tcbfixP->tcbtio;\n  iezjscb*  iezjscbP= (iezjscb*)((tcbfixP->tcbjscb._tcbjscbb)&0x00ffffff);\n  iezjscbP       = (iezjscb*)iezjscbP->jscbact;\n  ssib  *  ssibP = (ssib *)iezjscbP->jscbssib;\n\n\trbprfx * rbprfxP = (rbprfx *)tcbfixP->tcbrbp;\n\trbprfxP        = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\tint ok = 1;\n\twhile (ok&&(rbprfxP->xstab1&rbftp))\n\t\t\u00e4\n\t\t  if (rbprfxP->xstab2&rbtcbnxt)\n\t\t\t\tok = 0;\n\t\t\trbprfxP = (rbprfx *)(rbprfxP->xrblnka);\n\t\t\trbprfxP = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\t\t\u00fc\n\tif (ok)\n\t\t\u00e4\n\t\t cdentry * cdentryP = (cdentry *)(rbprfxP->rbcde1);\n\t\t programRb = mvsSTRING((char *)cdentryP->cdname,8);\n\t\t\u00fc\n\telse\n\t\tprogramRb = \"\";\n\n  jobName        = mvsSTRING((char *)tiot1P->tiocnjob,8);\n  stepName       = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  procStepName   = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  jobId          = mvsSTRING((char *)ssibP->ssibjbid,8);\n\n  jobName.strip();\n  jobId.strip();\n  stepName.strip();\n  procStepName.strip();\n  program.strip();\n\n  if (getenv(KEYWORD_DEBUG))\n    debug = atoi(getenv(KEYWORD_DEBUG));\n  else\n    debug = 0;\n\u00fc\n\nvoid JOBENV::print()\n\u00e4\n  Msg(400)<<jobName<<jobId<<program<<eol;\n\u00fc\n\nvoid JOBENV::Error(char *,JOBENV_ACTION a)\n\u00e4\n if (a == Abort)\n \u00e4\n    Msg(500)<<eol;\n    abort();\n \u00fc\n\n\u00fc\nint  JOBENV::DEBUG(int l,char* p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<p0<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,size_t p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<int(p0)<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,int p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2,char *p3)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<p3<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* t,char* d,int dl)\n\u00e4\n if (l>debug) return 0;\n dump(messagetext->getFILE()?messagetext->getFILE():stdout,t,d,dl);\n  return 1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MCHAIN": {"ttr": 251, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mchain.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include \"mchain.hpp\"\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#ifndef MU_STANDALONE\n#include \"xfile.hpp\"\n#endif\n#endif\n\n/*--------------------------------------------------------------+\n| mCHAIN global class                                       |\n|                                                              |\n|                                                              |\n+--------------------------------------------------------------*/\n\nmCHAIN::\u00dfmCHAIN()\n\u00e4\n\tchainE * pa , * pp;\n\tpa = first;\n\twhile ( pa )\n\t\u00e4\n\t\tpp = pa;\n\t\tpa = pa->next;\n\t\tdelete pp;\n\t\u00fc\n\n\u00fc\n\nlong int mCHAIN::add(chainE * nc,chainE * c,long int code )\n\u00e4\n\tcounter++;\n\tif ( first == 0) first = last = nc ;\n\tif ( c )\n\t\u00e4\n\t\tif ( code < 0 )\n\t\t\u00e4\n\t\t\tif ( first == c)\n\t\t\t\u00e4\n\t\t\t\tfirst = nc ;\n\t\t\t\tnc->prev = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc ->prev = c->prev ;\n\t\t\tnc ->next = c ;\n\t\t\tc->prev = nc ;\n\t\t\tif ( nc->prev) nc->prev->next = nc ;\n\t\t\u00fc\n\t\telse if ( code > 0)\n\t\t\u00e4\n\t\t\tif ( last == c)\n\t\t\t\u00e4\n\t\t\t\tlast = nc ;\n\t\t\t\tnc->next = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc->next = c ->next ;\n\t\t\tnc->prev = c ;\n\t\t\tc->next = nc ;\n\t\t\tif ( nc->next) nc->next->prev = nc ;\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tdelete \u00c4\u00dc c->chainEid ;\n\t\t\tc->chainEidl = nc->chainEidl;\n\t\t\tc ->chainEid = new char\u00c4nc->chainEidl+1\u00dc ;\n\t\t\tmemcpy(c->chainEid,nc->chainEid,c->chainEidl+1) ;\n\t\t\tcounter --;\n\t\t\u00fc\n\t\u00fc\n\treturn counter ;\n\u00fc\n\nlong int mCHAIN::del(chainE * c)\n\u00e4\n\tif ( c == first ) first = c->next ;\n\tif ( c == last ) last = c->prev ;\n\n\tif ( c->prev) c->prev->next = c->next ;\n\tif ( c->next) c->next->prev = c->prev ;\n\treturn --counter ;\n\u00fc\n\nvoid mCHAIN::swap(chainE * a , chainE * b)\n\u00e4\n\tif ( a->next NEQ b ]] b->prev NEQ a ]] a == 0 ]] b == 0)\n\t\treturn ;\n\n\tif ( first == a ) first = b ;\n\n\tif ( last == b) last = a ;\n\n\tif ( a->prev ) a->prev->next = b ;\n\tif ( b->next ) b->next->prev = a ;\n\n\tb->prev = a->prev ;\n\ta->next = b->next ;\n\tb->next = a;\n\ta->prev = b ;\n\u00fc\n\n\nchainE* mCHAIN::goNext()\n\u00e4\n\tif ( pgo )\n\t\tpgo = pgo->next;\n\treturn pgo;\n\n\u00fc\n\nchainE* mCHAIN::goPrev()\n\u00e4\n\tif ( pgo)\n\t\tpgo = pgo->prev;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goFirst()\n\u00e4\n\tpgo = first;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goLast()\n\u00e4\n\tpgo = last;\n\treturn pgo;\n\u00fc\n\nchainE* mCHAIN::go(int n)\n\u00e4\n\tpgo = first;\n\twhile ((--n)>0 && pgo)\n\t\u00e4\n\t\tpgo = pgo->next;\n\t\u00fc\n\treturn pgo;\n\u00fc\n\n\n\nchainE * mCHAIN::search(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id && length >= c->chainEidl && memcmp(id,c->chainEid,c->chainEidl) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::searchEQ(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id &&  strcmp(id,c->chainEid) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::search(const mvsSTRING & s)\n\u00e4\n\tint sl = s.lengthOf();\n\tfor(chainE * c = first; c ; c = c->next)\n\t\tif ( sl == c->chainEidl && memcmp((char*)s,c->chainEid,sl) == 0)\n\t\t\treturn c;\n\treturn 0;\n\u00fc\n\nvoid mCHAIN::sort(long int direction = 1)\n\u00e4\n\tlong int ind  = 1 ;\n\tchainE   * a ;\n\n\twhile(ind)\n\t\u00e4 ind = 0;\n\n\tfor(a = first ; a && a->next;)\n\t\u00e4\n\n\t\tif ( idcmp(a,a->next)*direction > 0)\n\t\t\u00e4 ind = 1;\n\t\tswap(a,a->next);\u00fc\n\t\ta = a->next ;\n\t\u00fc\n\t\u00fc\n\u00fc\n\nvoid mCHAIN::print_all_ids()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tputs(c->chainEid);\n\u00fc\n\n\nvoid mCHAIN::print()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tc->print();\n\u00fc\n\nlong int SORTEDmCHAIN::add(chainE *nc,chainE *,long int)\n\u00e4\n\tif ( first == 0)\u00e4counter = 1; first = last = nc ;\u00fc\n\telse\n\t\u00e4\n\t\tint comp;\n\t\tint h = counter;\n\t\tint l = 1;\n\t\tint m ;\n\t\tchainE * a;\n\t\twhile (h>l)\n\t\t\u00e4\n\t\t\tm = l+(h-l)/2;\n\t\t\ta = go(m);\n\t\t\tcomp = idcmp(nc,a);\n\t\t\tif ( comp > 0 )  l = m+1;\n\t\t\telse if ( comp < 0 ) h= m-1;\n\t\t\telse if ( comp == 0 )\n\t\t\t\treturn 0;\n\t\t\t// return mCHAIN::add(nc,a,int(unique));\n\t\t\u00fc\n\t\ta = go(l);\n\t\tcomp= idcmp(nc,a);\n\t\tif ( comp )\n\t\t\treturn mCHAIN::add(nc,a,comp?comp:unique);\n\t\telse return 0;\n\n\t\u00fc\n\treturn counter;\n\u00fc\n\n\nmHASH::mHASH(int h):mCHAIN()\n\u00e4\n\tpi = 0;\n\thash\t= h;\n\ttable =(chainE * *)malloc(h*sizeof(chainE *));\n\tmemset(table,0,h*sizeof(chainE *));\n\u00fc\n\nmHASH::\u00dfmHASH()\n\u00e4\n\tif (table)\n\t\u00e4\n\t\tfor(int i =0;i<hash;i++)\n\t\t\twhile(table\u00c4i\u00dc)\n\t\t\t\u00e4\n\t\t\t\tpgo = table\u00c4i\u00dc;\n\t\t\t\ttable\u00c4i\u00dc= table\u00c4i\u00dc->next;\n\t\t\t\tdelete pgo;\n\t\t\t\u00fc\n\t\t\tfree(table);\n\t\t\ttable = NULL;\n\t\u00fc\n\u00fc\n\nlong int mHASH::add(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (table\u00c4i\u00dc)\n\t\u00e4\n\t\tc->next=table\u00c4i\u00dc;\n\t\tc->prev = NULL;\n\t\ttable\u00c4i\u00dc->prev=c;\n\t\ttable\u00c4i\u00dc = c;\n\t\u00fc\n\telse\n\t\ttable\u00c4i\u00dc = c;\n\treturn i;\n\u00fc\n\nchainE * mHASH::search(chainE *c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tchainE *n = table\u00c4i\u00dc;\n\twhile(n)\n\t\tif(idcmp(c,n)==0)\n\t\t\tbreak;\n\t\telse\n\t\t\tn = n->next;\n\treturn n;\n\u00fc\n\nlong int mHASH::del(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (c->prev)\n\t\tc->prev->next = c->next;\n\tif (c->next)\n\t\tc->next->prev= c->prev;\n\tif (c==table\u00c4i\u00dc)\n\t\u00e4\n\t\tif (table\u00c4i\u00dc = c->next)\n\t\t\ttable\u00c4i\u00dc->prev = NULL;\n\t\u00fc\n\treturn i;\n\u00fc\n\nchainE * mHASH::next()\n\u00e4\n\tif (pgo)\n\t\tpgo = pgo->next;\n\tfor(;pgo==NULL&&pi<hash;pi++)\n\t\tpgo=table\u00c4pi\u00dc;\n\tif(pgo==NULL)\n\t\tpi = 0;\n\treturn pgo;\n\u00fc\n\nint idcmp(chainE * a, chainE * b)\n\u00e4\n\tint comp;\n\tif ( a == 0 && b == 0) return 0;\n\telse if ( a == 0) return -1;\n\telse if ( b == 0) return 1;\n\n\tif ( a->chainEidl == b->chainEidl)\n\t\treturn memcmp(a->chainEid,b->chainEid,a->chainEidl);\n\telse\n\t\tif ( a->chainEidl < b->chainEidl)\n\t\t\u00e4comp = memcmp(a->chainEid,b->chainEid,a->chainEidl); return comp?comp :-1;\u00fc\n\t\tcomp = memcmp(a->chainEid,b->chainEid,b->chainEidl);\n\t\treturn comp ? comp : +1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MERROR": {"ttr": 253, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/merror.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include \"merror.hpp\"\n#include <assert.h>\n\n#ifndef mERRORP\n#define mERRORP mERROR *\n#endif\n\nmERRORPSTACK mErrorPStack(512);\n\nmERRORPSTACK::mERRORPSTACK(long int size)\n\u00e4\n   ip = 0; max = size;\n   sp = new mERRORP\u00c4size\u00dc ;\n\n\u00fc\n\nvoid mERRORPSTACK::push(mERRORP value)\n\u00e4\n  assert( ip < max);\n  sp\u00c4ip++\u00dc = value;\n\u00fc\n\nmERRORP mERRORPSTACK::examine()\n\u00e4\n   return( ip ? sp\u00c4ip-1\u00dc : (mERRORP ) 0 );\n\u00fc\n\nint mERRORPSTACK::callNextHandler(int)\n\u00e4\n//for(int i=ip-1;i>=0;i--)\n//if ( sp\u00c4i\u00dc && sp\u00c4i\u00dc->handler) return (sp\u00c4i\u00dc->handler)(code);\n  return 0;\n\u00fc\n\nmERRORP mERRORPSTACK::pop()\n\u00e4\n  if (ip>0) return sp\u00c4--ip\u00dc;\n  else return (mERRORP) 0 ;\n\n\u00fc\nvoid  mERRORPSTACK::reset()\n\n\u00e4\n  ip = 0;\n\u00fc\n\nmERRORPSTACK::\u00dfmERRORPSTACK()\n\u00e4\n delete \u00c4\u00dc sp;\n\u00fc\n\n\nint mERROR::max_rc = 0;\n\n\nmERROR::mERROR()\n\u00e4\n    err = 0;\n    handler =0;\n//  mErrorPStack.push(this);\n\u00fc\n\nmERROR::mERROR(int (*h)(int) )\n\u00e4\n     err = 0;\n     handler = h;\n//   mErrorPStack.push(this);\n\u00fc\n\n\nint mERROR::error(char *,ERROR_ACTION a)\n \u00e4\n  switch(a)\n    \u00e4\n     case Warning:\n    \t\t max_rc = 4;\n          return 0;\n       case Abort:\n          exit(8);\n       default:\n          exit(8);\n    \u00fc\n    return 0;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MISC": {"ttr": 247, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/misc.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifdef    OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mvsbase.hpp\"\n#if defined(MU_STANDALONE) == 0\n#include \"pcsdll.hpp\"\n#include \"ebcdicut.hpp\"\n#else\n#include \"mvsebcdic.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"mvsbase.hpp\"\n#ifdef CALL_PROJECT\n#include \"project.hpp\"\n#endif\n\n//#if defined(ISIS_PF_MI) == 1 && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\n#if (defined(ISIS_PF_MI) == 1 ]] defined(ISIS_PF_MU) == 1) && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\nint _isis_pf_mi_debug = 1;\n#endif\n#if defined(ISIS_PF_HOST) ]] defined (ISIS_PF_MU)\n  #if defined(OWN_STDIO) == 0\n      #include <assert.h>\n  #endif\n  #include <ctype.h>\n  #include <regex.h>\n  #include <locale.h>\n  #include <sys/time.h> //ZA040225\n  #include \"casmif.hpp\" //ENQ DEQ\n  #include <unistd.h>\n#endif\n\n#ifndef MU_STANDALONE\n#include \"systems.hpp\" //KV20040915 for stricmp\n#else\n#include <strings.h>\n#ifndef stricmp\n    #define stricmp strcmpi\n#endif\n#ifndef strcmpi\n#define strcmpi strcasecmp\n#endif\n#define MVSBatch() 1\n#endif\n\n#define UKEY_MAJOR \"STRTUKEY\"\n#define UKEY_MINOR \"ISIS_UKEY\"\nstatic unsigned char tUK\u00c4\u00dc =\n     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\u00d6\n         \"0123456789#$\"\u00d6\n         \"abcdefghijklmnopqrstuvwxyz\";\n\n\nvoid formatTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\nchar *strrev(char *s)  //szm\n\u00e4\n    if (s==NULL]]strlen(s)==0) return s;\n    char c;\n    int i , j;\n    for(i =0, j =strlen(s)-1; i<j;i++,j--)\n    \u00e4\n      c    =  s\u00c4i\u00dc;\n      s\u00c4i\u00dc =  s\u00c4j\u00dc;\n      s\u00c4j\u00dc = c;\n    \u00fc\n    return(s);\n\u00fc\n\n\nunsigned long cvb(unsigned long f , unsigned long length)\n \u00e4\n  unsigned long r = 0;\n    unsigned long m = 1;\n    for(int i = 0;f && i<length;i++)\n    \u00e4\n     r += (f&0x0000000fL)*m;\n       m *= 10;\n       f = f>>4;\n    \u00fc\n    return r;\n\u00fc\n\n\nunsigned long cvd(unsigned long f)\n\u00e4\n unsigned long r = 0;\n   for ( int i = 0;f && i<8;i++)\n   \u00e4\n    r ]= ((f%10)<<(i*4));\n      f = f/10;\n   \u00fc\n   return r;\n\u00fc\n\n\n//KV20050725 dump functions moved to isislib/isismisc.cpp\n//SZM20050810 If it is CICSAPPL , there is no isismisc\n//SZM20090629 If standalone  , there is no isismisc\n//#if defined(ISIS_PF_MU) == 0 ]] defined(MU_STANDALONE) == 0\n#if defined(CICSAPPL)   ]] defined(MU_STANDALONE)\nint dump(FILE * dumpf,char * id,void * from,int l)\n\u00e4\n    return (dump(dumpf,id,(char *)from,l));\n\u00fc\nint dump(FILE *f,char * id,char * p,int l)\n\u00e4\n    int i , o;\n    fprintf(f,\"%s\u00d6n\u00d6n\",id);\n\n    for(o = 0;o <((l/16)+1)*16;o+=16)\n    \u00e4\n        fprintf(f,\"%4.4lx:\",o);\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n                fprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n                if (i%4 == 3) fprintf(f,\" \");\n\n            \u00fc\n\n            else\n            \u00e4\n                if ( i%4 == 3) fprintf(f,\" \");\n                fprintf(f,\" \");\n            \u00fc\n        \u00fc\n        fprintf(f,\" \");\n\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n                fprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n            else fprintf(f,\" \");\n        \u00fc\n        fprintf(f,\" \");\n\n        // print ebcdic -> ascii  converted chars on ascii platforms,\n        //        ascii -> ebcdic converted chars on ebcdic platforms\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n#if ' ' == 0x20\n                char c=etoa(p\u00c4i\u00dc);\n#else\n                char c=atoe(p\u00c4i\u00dc);\n#endif\n                fprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            \u00fc\n        \u00fc\n        fprintf(f,\"\u00d6n\");\n    \u00fc\n    return l;\n\u00fc\n\nint dump(char *f,int o,char * p,int l)\n\u00e4\n    int i;\n\n    sprintf(f,\"%4.4lx:\",o);\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n        \u00e4\n            sprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n            f+=strlen(f);\n            if (i%4 == 3)\n            \u00e4\n                sprintf(f,\" \");f+=strlen(f);\n            \u00fc\n\n        \u00fc\n\n        else\n        \u00e4\n            if ( i%4 == 3)\n            \u00e4\n                sprintf(f,\" \"); f+=strlen(f);\n            \u00fc\n            sprintf(f,\" \");f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n            sprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n        else sprintf(f,\" \");\n        f+=strlen(f);\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n\n    // print ebcdic -> ascii  converted chars on ascii platforms,\n    //        ascii -> ebcdic converted chars on ebcdic platforms\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l ) \u00e4\n#if ' ' == 0x20\n            char c=etoa(p\u00c4i\u00dc);\n#else\n            char c=atoe(p\u00c4i\u00dc);\n#endif\n            sprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\"\u00d6n\");\n\n    return l;\n\u00fc\n\n\nlong toInt(unsigned char  * p, int l)\n\u00e4\n    char  t\u00c44\u00dc;\n    memset(t,'\u00d600',4);\n    if ( l > 4) l =l%4;\n    int i;\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    for(i=3;l;l--,i--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    return int(*(int *)t);\n#else\n    int ll = l;\n    for(i=0;l;i++,l--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    if( ll == 1) return int(*(UCHAR*)t) ;\n    else if ( ll == 2) return short(*(short*)t);\n    else  return long(*(long *)t);\n#endif\n\u00fc\n\nlong toInt(char  * p, int l)\n  \u00e4\n  return(toInt((unsigned char *)p,l));\n  \u00fc\n\n\nint fromInt(char  * to,long v,unsigned int  l)\n  \u00e4\n  return fromInt(to,v,int(l));\n  \u00fc\n\nint fromInt(char  * to,long v,int l )\n\u00e4\n\n //assert(l<=sizeof( long)); ?????\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    memcpy(to,((char * )&v)+(sizeof( int)-l),l);\n#else\n    char * t = (char *)&v;\n    for(int i = l;i;i--)to\u00c4i-1\u00dc = *(t++);\n#endif\n    return (l>=sizeof(long));\n\u00fc\n\nint Char2Hex(char * c)\n\u00e4\n   int v = 0;\n   for(int i = 2;i; i--)\n   \u00e4    v<<=4;\n      if ( *c >= '0' && *c <= '9' ) v += *c-'0';\n      else if ( *c >= 'A' && *c <= 'F' ) v += *c-'A'+10;\n      else if ( *c >= 'a' && *c <= 'f' ) v += *c-'a'+10;\n      c++;\n   \u00fc\n   return v;\n\u00fc\n\nchar * Hex2Char(char c)\n\u00e4\n   static char r\u00c43\u00dc;\n   memset(r,null,sizeof(r));\n   int v = (c&0xf0)>>4;\n   if ( v >= 0 && v <= 9 ) r\u00c40\u00dc = char('0'+v);\n   else r\u00c40\u00dc = char('A'+v-10);\n   v = (c&0x0f);\n   if ( v >= 0 && v <= 9 ) r\u00c41\u00dc = char('0'+v);\n   else r\u00c41\u00dc = char('A'+v-10);   return r;\n\u00fc\n\nint isnull(char * s,int l)\n\u00e4\n if ( l == 0 ) l = int(strlen(s));\n for(l;l>0;l--)if ( s\u00c4l-1\u00dc  ) return 0;\n return 1;\n\u00fc\n\nint roundToInt(double f)\n\u00e4\n   double w;\n   if ( modf(f,&w) >= 0.5 ) return (int(f)+1);\n   else return int(f);\n\u00fc\n\n\nstatic char ts\u00c430\u00dc;\nchar  * getTimeStemp()\n\u00e4\n\n  formatTime(ts,sizeof(ts),\"%Y:%m:%d %H:%M:%S\");\n  return ts;\n\u00fc\n\nstatic char *days\u00c47\u00dc  =\u00e4 \"Mon\", \"Tue\", \"Wen\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"\u00fc;\nstatic char *ldays\u00c47\u00dc =\u00e4 \"Monday\",\n             \"Tuesday\",\n             \"Wednesday\",\n             \"Thursday\",\n             \"Friday\",\n             \"Saturday\",\n             \"Sunday\" \u00fc;\nstatic char *month\u00c412\u00dc = \u00e4 \"Jan\", \"Feb\", \"Mar\",\n             \"Apr\", \"May\", \"Jun\",\n             \"Jul\", \"Aug\", \"Sep\",\n             \"Oct\", \"Nov\", \"Dec\"\u00fc;\n\nint DatetoTm(tm & t, char * st)\n\u00e4\n  char * term = \",:- \";\n  char * c;\n  char * day = strtok(st,term);\n\n  int i = 0;\n  for(i = 7;i;i--)if ( stricmp(days\u00c4i-1\u00dc,day) == 0 ) break;\n  if ( i == 0 )\n   for(i = 7;i;i--)if (strcmp(ldays\u00c4i-1\u00dc,day) == 0 ) break;\n\n  t.tm_wday = i-1;\n\n  c = strtok(0,term);\n  if ( isdigit(*c) )\n  \u00e4\n    t.tm_mday = atoi(c);\n    c = strtok(0,term);\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    i = atoi(strtok(0,term));\n    t.tm_year = i>1900? i-1900 : i;\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_yday = 0;\n   \u00fc\n   else\n   \u00e4\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    t.tm_mday = atoi(strtok(0,term));\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_year = atoi(strtok(0,term));    t.tm_yday = 0;\n  \u00fc\n  return 0;\n\u00fc\n\nchar * DatetoString()\n\u00e4\n  static char dmvsSTRING\u00c464\u00dc;\n  time_t now;\n  time(&now);\n  strcpy(dmvsSTRING,asctime(gmtime(&now)));\n  strcpy(dmvsSTRING+strlen(dmvsSTRING)-1,\" GMT\");\n  return dmvsSTRING;\n\u00fc\n\nchar * DatetoString(tm t,char * st)\n\u00e4\n  strcpy(st,asctime(&t));\n  strcpy(st+strlen(st)-1,\" GMT\");\n  return st;\u00fc\n#endif\n//#endif //ifndef ISIS_PF_MU\n\n static char dateInIBM\u00c413\u00dc;\n\n void formatIBMTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\n char * DatetoIBM(char * from)\n \u00e4\n   memset(dateInIBM,0,sizeof(dateInIBM));\n   char today\u00c412\u00dc;\n   if ( from == NULL)\n   \u00e4\n      from = today;\n      formatIBMTime(today,sizeof(today),\"%d.%m.%Y\");\n   \u00fc\n   int mv\u00c412\u00dc = \u00e4 31,28,31,30,31,30,31,31,30,31,30,31\u00fc;\n   mvsSTRING d, m, y;\n   mvsSTRING date(from);\n   date.parse(d,\".\",m,\".\",y);\n   int id = atoi(d);\n   int im = atoi(m);\n   int iy = atoi(y);\n   if ( id > 31 ]] im < 1 ]] im > 12 )\n     return (char *)NULL;\n\n   int leapyear ;\n   if ((iy%4) ]] ((iy%100) == 0  && (iy%400))) leapyear = 0 ;\n     else leapyear = 1;\n   int dd = 0;\n   for(int i = 0;i < (im-1);i++)dd += mv\u00c4i\u00dc;\n   if ( leapyear && im > 2) dd++;\n   dd +=id;\n   if (iy < 100) iy += 2000;\n   sprintf(dateInIBM,\"%d     \",iy*1000+dd);\n   return (dateInIBM);\n \u00fc\n\nvoid getUniqueKEY(char * t)\n\u00e4\n\n\n  char _dummy=0, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int  i, w1 , w2;\n  _dummy = 0;\n\n  w1 = *(int *)(stck-1);\n  w2 = *(int *)(stck+3);\n  for (i = 0;i<5;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w1&0x1f\u00dc; w1 = w1>>5;\n  \u00fc\n  for (i = 5;i<10;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w2&0x1f\u00dc; w2 = w2>>5;\n  \u00fc\n  t\u00c410\u00dc = _dummy;\n\n\u00fc\n\nvoid getUniqueLongKEY(char * t)\n\u00e4\n  char _dummy, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int w1 = *(int *)(stck);\n  int w2 = *(int *)(stck+4);\n  sprintf(t,\"%8.8x%8.8x\",w1,w2);\n  t\u00c416\u00dc = 0;\n\u00fc\n\n\n//KV20040824 still needed?\n//char * StrTok(char * mvsSTRING,char * termtokens)\n//\u00e4\n//  char * c = strtok(mvsSTRING,termtokens);\n//  return ( c ? c :\"\");\n//\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc)\n\u00e4\n   for (int i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n   return 0;\n   return 1;\n\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc,int & i)\n\u00e4\n   for ( i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n    return 0;\n   return 1;\n\u00fc\n\n//KV20040825 strnicmp replaced by strnicmp\n#if 0\nint strnicmp(const char * s1,const char * s2,int l)\n\u00e4\n   for(int i = 0; i<l; i++)\n   if ( tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc) )\n   return (tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc));\n   return 0;\n\u00fc\n#endif\n\nint stcpma(char * mvsSTRING ,const char * pattern)\n\u00e4\n   regex_t    preg;\n   size_t     nmatch = 1;\n   regmatch_t pmatch\u00c41\u00dc;\n   int rc = 0;\n   if ( strlen(pattern) == 0 ]] strcmp(pattern,\"*\") == 0)\n    return 1;\n   //char patt\u00c416\u00dc;\n   char patt\u00c4512\u00dc; //ZA060607 for VSAM\n   char * p = patt;\n   int j = strlen(pattern);\n   int k = j - 1; //index of last nonzero char\n\tbool usepattern = false;//ToDo36320\n   for(int i = 0;i<=j;i++)\n   \u00e4\n   \t  char c = pattern\u00c4i\u00dc;\n      if (c == '*' ]] c == '?')\n\t\t\u00e4\n          *p++= '.';\n\t\t\tusepattern = true; //ToDo36320\n\t\t\u00fc\n      else if (c == '.' ]] c == '$')\n      \u00e4\n      \tif (i < k) //not last char\n      \t\u00e4\n      \t\t*p++= '\u00d6xe0'; // backslash\n      \t\t*p++= c; //no special character\n      \t\u00fc\n      \telse\n      \t    *p++= c; //last char, remains special\n      \u00fc\n        else\n        *p++ = c;\n   \u00fc\n\tif (usepattern)//ToDo36320\n\t\u00e4\n   if (regcomp(&preg,patt,REG_EXTENDED))\n    return 0;\n   else\n   \u00e4\n    rc = NOT regexec(&preg,mvsSTRING, nmatch, pmatch, 0);\n      regfree(&preg);\n      return rc;\n   \u00fc\n\u00fc\n\telse //ToDo36320\n\t\u00e4\n\t\tchar * copy = strdup(mvsSTRING);\n\t\tif (strchr(copy,' '))\n\t\t\t* strchr(copy,' ') = 0;\n\t\tint rc = | strcmp(copy,pattern);\n\t\tfree(copy);\n\t\treturn (rc);//ToDo36320\n\t\u00fc\n\u00fc\n\nmvsSTRING makemvsSTRING(char * s,int l)\n\u00e4\n for(l--;l;l--)\n if ( s\u00c4l-1\u00dc NEQ ' ')  break;\n s\u00c4l\u00dc = null;\n return mvsSTRING(s);\n\u00fc\nchar * StrDup(char * o)\n\u00e4\n  char * rs =(char *)0;\n  if ( o == (char *)0 ) return rs;\n  rs = new char\u00c4strlen(o)+1\u00dc;\n  strcpy(rs,o);\n  return rs;\n\u00fc\n\n#ifndef ISIS_PF_MU\n#if defined(CICSAPPL)\nchar bit_rotate(unsigned char from)\n \u00e4\n static unsigned char rtab\u00c4256\u00dc =\n \u00e4\n    0x00, 0x80, 0x40, 0xc0, 0x20, 0xA0, 0x60, 0xe0,\n    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,  // 0x00 bis 0x0f\n    0x08, 0x88, 0x48, 0xc8, 0x28, 0xA8, 0x68, 0xe8,\n    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,  // 0x10 bis 0x1f\n    0x04, 0x84, 0x44, 0xc4, 0x24, 0xA4, 0x64, 0xe4,\n    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,  // 0x20 bis 0x2f\n    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xAc, 0x6c, 0xec,\n    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,  // 0x30 bis 0x3f\n    0x02, 0x82, 0x42, 0xc2, 0x22, 0xA2, 0x62, 0xe2,\n    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,  // 0x40 bis 0x4f\n    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xAa, 0x6a, 0xea,\n    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,  // 0x50 bis 0x5f\n    0x06, 0x86, 0x46, 0xc6, 0x26, 0xA6, 0x66, 0xe6,\n    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,  // 0x60 bis 0x6f\n    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xAe, 0x6e, 0xee,\n    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,  // 0x70 bis 0x7f\n    0x01, 0x81, 0x41, 0xc1, 0x21, 0xA1, 0x61, 0xe1,\n    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,  // 0x80 bis 0x8f\n    0x09, 0x89, 0x49, 0xc9, 0x29, 0xA9, 0x69, 0xe9,\n    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,  // 0x90 bis 0x9f\n    0x05, 0x85, 0x45, 0xc5, 0x25, 0xA5, 0x65, 0xe5,\n    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,  // 0xa0 bis 0xaf\n    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xAd, 0x6d, 0xed,\n    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,  // 0xb0 bis 0xbf\n    0x03, 0x83, 0x43, 0xc3, 0x23, 0xA3, 0x63, 0xe3,\n    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,  // 0xc0 bis 0xcf\n    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xAb, 0x6b, 0xeb,\n    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,  // 0xd0 bis 0xdf\n    0x07, 0x87, 0x47, 0xc7, 0x27, 0xA7, 0x67, 0xe7,\n    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,  // 0xe0 bis 0xef\n    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xAf, 0x6f, 0xef,\n    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,  // 0xf0 bis 0xff\n \u00fc;\n   return rtab\u00c4from\u00dc;\n\u00fc\n#endif\n#endif //ifndef ISIS_PF_MU\n\n/*\nvoid swab(char *source, char *target,int len) //ZA030918 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   if(ungerade(len))\n   \u00e4 target\u00c4len\u00dc=source\u00c4len\u00dc;\n     target\u00c4len+1\u00dc='\u00d60'; \u00fc\n   else target\u00c4len\u00dc = '\u00d60';\n   return;\n\u00fc\n*/\n\n\nvoid swab(char *source, char *target,int len) //ZA030924 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len-1; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   return;\n\u00fc\n\n/*\nunsigned int ungerade(int len)\n\u00e4\n   if (len%2) return TRUE;\n      else return FALSE;\n\u00fc\n*/\n\n#ifndef __TEST__\n#define __TEST__ 1\n#endif\n\nchar __test__ = __TEST__ ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGMGR": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/msgmgr.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#ifdef ISIS_PF_MU\n#pragma csect(CODE,\"msgmgrmC\")\n#pragma csect(STATIC,\"msgmgrmS\")\n#pragma csect(TEST,\"msgmgrmT\")\n#endif\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n//#include \"iqvprj.hpp\"\n#endif\n#include \"mvsbase.hpp\"\n#include \"casmif.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifdef PANEL_ID\n#include \"panel.hpp\"\n#include \"cicbase.hpp\"\n#endif\n#include <dll.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <strings.h>\n\nnamespace isis_ns_mvs\n\t\u00e4\n\t//KV20040216 protection exception in pas dll\n\t//???MessageTEXT * messagetext   = new MessageTEXT();\n\tMessageTEXT * messagetext   = 0;\n\tExternalTEXT * externaltext = 0;  //szm\n\t/*--------------------------------------------------------------+\n\n\tMSGE rouines                                                 ]\n\t+--------------------------------------------------------------*/\n\n\n\n//#define ERROR_BUFF 512 szm\n#define ERROR_BUFF 4096\n\tstatic char g_ebb\u00c4 ERROR_BUFF \u00dc;\n\tstatic char g_ebb_flag = 0;\n\n\n\tvoid * TEXTVER();\n\tMSGE * tCHARp(char * c ,int l)\n\t\t\u00e4 return new MSGE(c,l);\u00fc\n\tMSGE * tINT(int i,int l )\n\t\t\u00e4 return new MSGE(i,l); \u00fc\n\tMSGE * tSHORT(int i,int l )\n\t\t\u00e4 return new MSGE(i, l);\u00fc\n\tMSGE * tmvsSTRING( mvsSTRING & s,int l )\n\t\t\u00e4 return new MSGE(s,l); \u00fc\n\tMSGE * tHEX(int i ,int  l  )\n\t\t\u00e4 return new MSGE(i,l,msgfx);\u00fc\n\tMSGE * tHEX(char * c, int l)\n\t\t\u00e4 return new MSGE(c,l,msgfx);\u00fc\n\n\tMSGE::MSGE():length(0), type(msgundef),to(NULL)\u00e4\u00fc\nMSGE::MSGE(int i,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmint = i;length = l; type = msgint;form = f;\n\t\u00fc\nMSGE::MSGE(short s,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmshort = s; length = l; type = msgshort;form = f;\n\t\u00fc\nMSGE::MSGE(char * c,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmcharp = c; if ( l == 0) l = int(strlen(c)); length = l;\n\ttype = msgcharp;\n\tform = f;\n\t\u00fc\nMSGE::MSGE(const mvsSTRING &s,int l,MSGEForm f):to(NULL)\n\t\u00e4\n\tmmvsSTRING = new mvsSTRING(s);\n\tif ( l == 0) l = int(mvsSTRING(s).lengthOf());\n\tlength = l;\n\ttype = msgmvsSTRING;\n\tform = f;\n\t\u00fc\nMSGE:: MSGE(char c):to(NULL)\n\t\u00e4\n\tmchar = c;\n\tlength = 1;\n\ttype = msgchar;\n\tform = msgfc;\n\t\u00fc\n\n\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  MSGE format                                                  ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nchar * MSGE::format()\n\t\u00e4\n\tchar * f;\n\tto = new char\u00c42*length+1\u00dc;//szm20050907 heap demage in uprun\n\n\n\tswitch(form)\n\t\t\u00e4\n\t\tcase msgfc: f = \"%c\";\n\t\t\tbreak;\n\t\tcase msgfd: f = \"%*d\";\n\t\t\tbreak;\n\t\tcase msgfs: f = \"%*s\";\n\t\t\tbreak;\n\t\tcase msgfx: f = \"x\u00d6\"%0*x\u00d6\"\";\n\t\t\tbreak;\n\t\t\u00fc\n\n\tswitch ( type)\n\t\t\u00e4\n\t\tcase msgshort:sprintf(to,f,length,mshort);\n\t\t\tbreak;\n\t\tcase msgint  :sprintf(to,f,length,mint);\n\t\t\tbreak;\n\t\tcase msgcharp:sprintf(to,f,length,mcharp);\n\t\t\tbreak;\n\t\tcase msgmvsSTRING: sprintf(to,f,length,(char * )(*mmvsSTRING));\n\t\t\tbreak;\n\t\tcase msgchar: sprintf(to,f,mchar);\n\t\t\tbreak;\n\t\t\u00fc\n\treturn to;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  TEXT class                                                   ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nstatic TEXTENTRY Textvector\u00c4\u00dc =\n\t\u00e4\n#define  MESSAGE_TEXT\n#define t( a , b ) \u00e4 a , b \u00fc ,\n#include \"msgtext.hpp\"\n#undef t\n#undef   MESSAGE_TEXT\n\t\t\u00e40,0\u00fc\n\t\u00fc;\n\nint initMessageText()\n\n\t\t\u00e4\n\t\tif (messagetext==NULL)\n\t\t\tmessagetext = new MessageTEXT();\n\t\treturn 0;\n\t\t\u00fc\n\nMessageTEXT::MessageTEXT(char * fn ,char * logstream)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\tonlylogger = false;\n\tlogger = false; //szm20060410 init logger\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\tmsgfile = NULL; //szm\n\tvector = Textvector;\n\tprintfv = 0;\n\ttimestemp = 1;\n\t\u00fc\n\nvoid MessageTEXT::setFileName(char * fn)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\t\u00fc\n\nvoid MessageTEXT::setLogger(const char *logstream)\n\t\u00e4\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\t\u00fc\n\nMessageTEXT::\u00dfMessageTEXT()\n\t\u00e4\n\tif (msgfile) fclose(msgfile); //szm\n\tif (logger)  mvs()->LoggerClose();\n\tlogger = false;\n\tdelete \u00c4\u00dc msgfilename;\n\t\u00fc\n\nchar * MessageTEXT::getText(int i)\n\t\u00e4\n\t// printf(\"Message %d \u00d6n\",i);\n\n\tTEXTENTRY * te = Textvector;\n\twhile (te->t && (te->i > 0)  )\n\t\t\u00e4\n\t\tif ( te->i == i )\n\t\t\t\u00e4\n\t\t\t//      printf(\"%s\u00d6n\",te->t);\n\t\t\treturn te->t;\n\t\t\t\u00fc\n\t\tte++;\n\t\t\u00fc\n\t// printf(\"Undefined message %d\u00d6n\",i );\n\tsprintf(deflt,\"Undefined message %d\u00d6n\",i );\n\treturn deflt;\n\n\t\u00fc\n\nint MessageTEXT::copyText(int i,char * to,int l)\n\t\u00e4\n\tchar   tm\u00c4ERROR_BUFF\u00dc;\n\tchar * from = getText(i);\n\tif (messagetext->getTimeStempFlag() )\n\t\t\u00e4\n\t\tchar tt\u00c432\u00dc;\n\t\tchar fm\u00c4\u00dc = \"%Y:%m:%d %H:%M:%S \";\n\t\tformatTime(tt,sizeof(tt),fm);\n\t\tstrcpy(tm,tt);\n\t\tstrcat(tm,from);\n\t\tfrom = tm;\n\t\t\u00fc\n\n\tint lf = strlen(from);\n\tif ( lf <= l)\n\t\tstrcpy(to,from);\n\telse\n\t\t\u00e4\n\t\tmemcpy(to,from,l-1);\n\t\tto\u00c4l-1\u00dc  = null;\n\t\t\u00fc\n\treturn ( l -lf );\n\t\u00fc\n\nchar * MessageTEXT::print(char * t)\n\t\u00e4\n\tif (|onlylogger)\n\t\t\u00e4\n\t\tif ( msgfilename)\n\t\t\t\u00e4\n\t\t\tif (msgfile == NULL)\n\t\t\t\tmsgfile = fopen(msgfilename,\"wt,type=record\"); //szm\n\t\t\tif (msgfile)\n\t\t\t\t\u00e4\n\n\t\t\t\t//fprintf(msgfile,\"%s\u00d6n\",t); szm\n\t\t\t\tfputs(t,msgfile);\n\t\t\t\tfflush(msgfile);\n\t\t\t\t//fclose(msgfile); //szm\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\tif ( printfv ) printfv(t);\n\t\telse\n\t\t\tputs(t);\n\t\t\u00fc\n\tif (logger)\n\t\tmvs()->Logger(t);\n\treturn t;\n\t\u00fc\n\nvoid MessageTEXT::setNumber(int n)\n\t\u00e4\n\tnumber = n;\n\tvi = 0;\n\tfor (int i=0;i<8;i++)v\u00c4i\u00dc = 0;\n\t\u00fc\n\n\nMessageTEXT&  MessageTEXT::operator<<(int i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tINT(i);\n\treturn * this;\n\t\u00fc\n#if 0   //szm\nMessageTEXT&  MessageTEXT::operator<<(short i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tSHORT(i);\n\treturn * this;\n\t\u00fc\n#endif\nMessageTEXT&  MessageTEXT::operator<<(char *c)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tCHARp(c);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(const mvsSTRING& s)\n\t\u00e4\n\tmvsSTRING temp = s;\n\tv\u00c4vi++\u00dc = tmvsSTRING(temp);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(void * p)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tHEX((char *)p,8);\n\treturn * this;\n\t\u00fc\nchar * MessageTEXT::operator<<(const EOL eol)\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tint i;\n\tmemset(ebb,null,sizeof(ebb));\n\tcopyText(number,format,ERROR_BUFF);\n\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = v\u00c4i\u00dc;\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);              break;\n\t\t\u00fc\n\n\tprint(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\n\t\tif ( v\u00c4i\u00dc )\n\t\t\t\u00e4 delete v\u00c4i\u00dc ; v\u00c4i\u00dc = 0;\u00fc\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]  Text formatting                                              ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\n\n\nMessageTEXT& Err(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\nMessageTEXT& Msg(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\n\nint   Error(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\tmessagetext->print(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn 0;\n\t\u00fc\n\n\nchar *  Message(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->log(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\nchar * getErrorText()\n\t\u00e4\n\tif ( g_ebb_flag == 0 ) return 0;\n\tg_ebb_flag = 0;\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nchar * getMessageText()\n\t\u00e4\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nExternalTEXT::ExternalTEXT(char * name ):language('E')\n\t\u00e4init(name);\u00fc\nExternalTEXT::ExternalTEXT(char * name, char lang ):language(lang)\n\t\u00e4init(name);\u00fc\n\nvoid ExternalTEXT::init(char * name)\n\t\u00e4\n\tmodulname\u00c40\u00dc = language==' ' ? 'E':language;\n\tstrcpy(modulname+1,name);\n\tdllhandle * handle = dllload(modulname);\n\t//fp = (void *(*)())dllqueryfn(handle,\"_dynamn\");\n\tfp = (EXT_C_fp)dllqueryfn(handle,\"_dynamn\");\n\tif (fp == 0)\n\t\t\u00e4\n\t\tchar _b\u00c4128\u00dc;\n\t\tsprintf(_b,\"unable to load the '%s' text module \u00d6n handle:%p function:%p d\u00d6n\",modulname,handle,fp);\n\t\tputs(_b);\n\t\tabort();\n\t\t\u00fc\n\ttext = fp();\n\t\u00fc\n\nint ExternalTEXT::MSGTEXT(int id, char * buff,int len)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\t\u00e4 if ( id == atoi(etp->cid) )\n\t\t\t\u00e4\n\t\t\tstrncpy(buff,*(etp->ett),len-1);\n\t\t\t*(buff+len-1) = 0;\n\t\t\treturn 1;\n\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t*buff = 0;\n\t\treturn 0;\n\t\u00fc\n\nchar * ExternalTEXT::HelpText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn *(etp->ett);\n\treturn 0;\n\t\u00fc\n\nselection* ExternalTEXT::SelectionText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (selection *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\nentry * ExternalTEXT::EntryText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (entry *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\n\t\u00fc //namespace isis_ns_mvs\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSBASE": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mvsbase.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifndef MU_STANDALONE\n#include \"pcsdll.hpp\"\n#include \"systems.hpp\" //szm\n#else\n\t#ifndef stricmp\n    #define stricmp strcmpi\n\t#endif\n\t#ifndef strcmpi\n\t\t#define strcmpi strcasecmp\n\t#endif\n\t#define MVSBatch() 1\n\t#ifndef PCS_MAX_PATH\n\t\t#define PCS_MAX_PATH 1024\n\t#endif\n#endif\n\n#include \"mvsbase.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0 //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#ifdef CALL_TAG\n#include \"pphctags.hpp\"\n#endif\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <assert.h>\n#include <stdio.h>\n#endif\n#include <string.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <ctype.h>\n#include <new.h>\n\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\n#include \"ibmdebug.hpp\"\n#if defined(ISIS_PF_MI) ]] defined (ISIS_PF_MU)\n#include <ctest.h>\n#endif\n#endif\n\n#define MVSBASE  0\nchar mvsSTRING::parseSepCh=0 ; //szm20061218 mvsSTRING parse escape ch is null|||||||\n\nmvsSTRING nullstring(\"\"); //szm\n\n//KV20050203 why not for ms,mu ??\n//#if defined(ISIS_PF_MS)==0 && defined(ISIS_PF_MU)==0\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_t ssize, int pad)\n\t\u00e4\n\tif ( target == 0 ]] source == 0 ]] tsize <= 0) return NULL;\n\tif( tsize<=ssize)\n\t\tmemcpy(target,source,tsize);\n\telse\n\t\t\u00e4\n\t\tmemcpy(target,source,ssize);\n\t\tfor(;ssize<tsize;ssize++) *((char *)target+ssize) = char(pad);\n\t\t\u00fc\n\treturn target;\n\t\u00fc\n\nstatic const char * SAS_HFS = \"hfs\";\nstatic const char * IBM_HFS = \"///\";\nstatic const char * SAS_DSN = \"dsn\";\nstatic const char * IBM_DSN = \"//\";\nstatic const char * SAS_DDN = \"ddn\";\nstatic const char * IBM_DDN  = \"dd\";\nstatic const char * IBM_DDN_SLASH = \"//dd\";\nstatic const char * _MEM     = \"mem\"; //szm0040909\nstatic const char * IBM_OMS  = \"oms\"; //szm20080215 ToDo 17339\nstatic const char * IBM_HTTP = \"http\"; //szm\nstatic const char * IBM_HTTPS = \"https\"; //szm\n\n\ngenOpenNameType genOpenType(const char *name)\n\t\u00e4\n\tchar  nm\u00c4256\u00dc;\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > sizeof(nm))\n\t\treturn(t);\n\n\tstrcpy(np,name);\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\tif (stricmp(pf,IBM_OMS))  //szm20080215 ToDo 17339\n\t\t\u00e4                       //szm20080215 ToDo 17339\n\t\tif (stricmp(pf,SAS_HFS) == 0) t = sas_hfs;\n\t\telse if (stricmp(pf,_MEM) == 0) t = ont_mem;   //szm0040909\n\t\telse if (stricmp(pf,IBM_DDN) == 0 ]] stricmp(pf,IBM_DDN_SLASH) == 0) t = ibm_ddn;\n\t\telse  if (stricmp(pf,SAS_DDN) == 0) t = sas_ddn;\n\t\telse if (stricmp(pf,SAS_DSN) == 0) t = sas_dsn;\n    else if (stricmp(pf,IBM_HTTP) == 0]]stricmp(pf,IBM_HTTPS) == 0) t = ibm_hfs; //szm\n\t\telse\n\t\t\t\u00e4\n      if (strncasecmp   (np,IBM_HFS,strlen(IBM_HFS)) == 0 ]] (np\u00c40\u00dc == '/' && np\u00c41\u00dc-'/') ]](np\u00c40\u00dc == '.' && np\u00c41\u00dc=='/'))//szm\n\t\t\t\tt = ibm_hfs;\n\t\t\telse if (strncasecmp   (np,IBM_DSN,strlen(IBM_DSN)) == 0) t = ibm_dsn;\n\t\t\t//KV20050419 in mvsbatch execution dataset names and ddnames don't need prefix\n\t\t\t// in unix execution such names are interpreted as unix file names\n\t\t\telse if(MVSBatch())\n\t\t\t\t\u00e4\n\t\t\t\tif (*n == '\"' ]] *n =='\u00d6'') t = ibm_dsn;\n\t\t\t\telse if (strchr(n,'(') && (strchr(n,'(')-n) <= 8 ) t = ont_ddn;\n\t\t\t\telse if (strchr(n,'.')) t = ont_dsn;\n\t\t\t\telse if (strlen(n) <= 8) t = ont_ddn;\n\t\t\t\telse if (strlen(n) <=18 && strchr(n,'(') && strchr(n,')')) t = ont_ddn;\n\t\t\t\telse\n\t\t\t\t\tt = ont_unknown;\n\t\t\t\t\u00fc\n\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\tt=ibm_hfs;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc //szm20080215 ToDo 17339\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) //ZA030711\n\t//  HOST_IBM_TRACE_sd(name,t);\n#endif\n\treturn t;\n\t\u00fc\n\n\n//KV20060329 buffer nm to avoid static variable\nchar * onlyMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p1));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nchar * stripMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p0+p2));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nISIS_EXT_C\nchar * genOpenName(const char *name,char *nm)\n\t\u00e4\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > PCS_MAX_PATH-1)\n\t\treturn(\"??invalid name??\");\n\n\tif (*name-'\"' && *name-'\u00d6'')\n\t\t\u00e4\n\t\tstrcpy(np,name);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstrcpy(np,name+1);\n\t\t//KV20030714: avoid deleting ending qoutes for //'datat.set.name'\n\t\tif (np\u00c4strlen(np)-1\u00dc == '\"' ]] np\u00c4strlen(np)-1\u00dc == '\u00d6'')\n\t\t\tnp\u00c4strlen(np)-1\u00dc  = 0;\n\t\t\u00fc\n\tfor(int i =strlen(np)-1;i>=0&&np\u00c4i\u00dc==' ';i--)np\u00c4i\u00dc=0;\n\tt = genOpenType(np);\n\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) // IBM or UNIX (not SAS)szm20031030\n\tif (strcmp(\"(*)\",n+strlen(n)-3)==0) //szm 20100628 zOS 1.11 fopen difference\n\t\t*(n+strlen(n)-3) = 0;       //szm 20100628 zOS 1.11 fopen difference\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\t\tif (*(n+2) - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n+2);\n\t\t\telse\n\t\t\t\tstrcpy(nm,n);\n\t\t\tbreak;\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tif (*n - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n);\n\t\t\telse\n\t\t\t\tsprintf(nm,\"//%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"//dd:%s\",n);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#else\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tsprintf(nm,\"dsn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"ddn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",nm+3);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",n);\n\t\t\tbreak;\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#endif\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n\tHOST_IBM_TRACE_sss(name,nm,n);\n#endif\n\treturn (nm);\n\t\u00fc\n\nUSHORT  Ushort(int i)\n\t\u00e4 return ((unsigned short)i);\u00fc\nUSHORT  Ushort(short s)\n\t\u00e4 return ((unsigned short)s);\u00fc\nUSHORT  Ushort(char c)\n\t\u00e4 return ((unsigned short)c);\u00fc\n\n\n/*--------------------------------------------------------------+\n]  mvsSTRING global class                                          ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n/*\nFORMAT F_alcu(aLEFT,cUPPER);\nFORMAT F_alcw(aLEFT,cWORD);\nFORMAT F_arcu(aRIGHT,cUPPER);\n*/\n\nmvsSTRING::mvsSTRING()\n\t\u00e4\n\tst.l = 1;\n\tst.c = new char\u00c41\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\t*st.c = null;\u00fc\nmvsSTRING::mvsSTRING(const char * y)\n\t\u00e4\n\tchar * x = (y ? (char *) y : \"\");\n\tst.l = (long int ) strlen(x);\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\tstrcpy(st.c,x);\n\t\u00fc\nmvsSTRING::mvsSTRING(const mvsSTRING & x )\n\t\u00e4\n\tst.l = x.st.l;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = x.st.type ;\n\tst.ltype = x.st.ltype ;\n\tmemcpy(st.c,x.st.c,st.l+1);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char * y,long int xl )\n\t\u00e4\n\tchar * x = y ? (char *) y : \"\";\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tif ( memchr(x,xl+1,0) ) st.type = str::_INVALID ;\n\telse     \u00e4  st.type = str::_VALID ; st.c\u00c4st.l\u00dc = 0; \u00fc\n\tmemcpy(st.c,x,xl);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char def ,const long int xl )\n\t\u00e4\n\tst.ltype = str::FIX ;\n\tst.type  = str::_VALID;\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tmemset(st.c,def,st.l);\n\tst.c\u00c4st.l\u00dc = 0;\n\t\u00fc\nmvsSTRING::\u00dfmvsSTRING()\n\t\u00e4\n\tif ( st.c) delete \u00c4\u00dc st.c;\n\tif ( st.lls) delete \u00c4\u00dc st.lls;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::operator=(const char * y )\n\t\u00e4\n\tchar * x = (y ? (char *)y : \"\");\n\tif ( x NEQ st.c)\n\t\t\u00e4 if ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * sv = st.c;\n\t\tst.l = (long int ) strlen(x);\n\t\tst.c = new char \u00c4st.l+1\u00dc;\n\t\tstrcpy(st.c,x);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc sv;\n\t\tst.type = str::_VALID;\n\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tlong int l =(strlen(x)<= st.l ? strlen(x) : st.l);\n\t\t\tmemcpy(st.c,x,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this ;\n\t\u00fc\nmvsSTRING& mvsSTRING::operator=(const mvsSTRING &x)\n\t\u00e4\n\tif (x.st.c NEQ st.c)\n\t\tif (st.ltype == str::VARIABLE )\n\t\t\t\u00e4\n\t\t\tchar * sv = st.c;\n\t\t\tst.l = x.st.l;\n\t\t\tst.c = new char\u00c4st.l+1\u00dc;\n\t\t\tmemcpy(st.c,x.st.c,st.l+1);\n\t\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\t\tdelete \u00c4\u00dc sv ;\n\t\t\t//   st.type = x.st.type;     don't assign fix type\n\t\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tst.ltype =str::FIX ;\n\t\t\tlong int l =(x.st.l<= st.l ? x.st.l : st.l);\n\t\t\tmemcpy(st.c,x.st.c,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\t\u00fc\n\t\treturn * this;\n\t\u00fc\n\nmvsSTRING & mvsSTRING::operator=(const sLL & s)\n\t\u00e4\n\tchar * sv = st.c;\n\tst.ltype = str::VARIABLE;\n\tst.l = s.getLength();\n\tst.c = new char\u00c4st.l\u00dc;\n\tmemcpy(st.c,s.getStart(),st.l);\n\tdelete \u00c4\u00dc sv;\n\treturn *this;\n\t\u00fc\n\nlong int operator==(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\tif (x.st.type == str::_VALID && y.st.type == str::_VALID)\n\t\treturn (strcmp(x.st.c,y.st.c) == 0);\n\telse if ( x.st.l == y.st.l)\n\t\treturn( memcmp(x.st.c,y.st.c,x.st.l) == 0 );\n\telse return 0;\n\t\u00fc\nlong int operator |=(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\treturn ( NOT( x == y) );\n\t\u00fc\n\nmvsSTRING operator+(const mvsSTRING& s1, const mvsSTRING& s2)\n\t\u00e4\n\tmvsSTRING r = s1;\n\tr+=s2;\n\treturn r;\n\t\u00fc\n/*\nmvsSTRING mvsSTRING::operator+(const mvsSTRING & x)\n\u00e4\nif ( &x == 0) return * this;\nmvsSTRING r;\nr.st.l = st.l + x.st.l;\nr.st.c = new char \u00c4 r.st.l+1\u00dc;\nmemcpy(r.st.c,st.c,st.l);\nmemcpy(r.st.c+st.l,x.st.c,x.st.l+1);\nif (st.type == str::_VALID && x.st.type == str::_VALID)\nr.st.type = str::_VALID ;\nelse r.st.type = str::_INVALID ;\nreturn r;\n\u00fc\n*/\n\nmvsSTRING& mvsSTRING::operator+=(const mvsSTRING& x )\n\t\u00e4\n\tif ( &x == 0 ) return * this;\n\tif ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * save = st.c;\n\t\tlong int savel = st.l;\n\t\tst.l += x.st.l;\n\t\tst.c  = new char \u00c4st.l+1\u00dc;\n\t\tmemcpy(st.c,save,savel);\n\t\tmemcpy(st.c+savel,x.st.c,x.st.l+1);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc save;\n\t\tif ( st.type NEQ str::_VALID ]] x.st.type NEQ str::_VALID)\n\t\t\tst.type = str::_INVALID ;\n\t\t\u00fc\n\telse perror(\" unable to add to a fix mvsSTRING\");\n\treturn * this ;\n\t\u00fc\n\nchar& mvsSTRING::operator\u00c4\u00dc(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\nchar& mvsSTRING::byte(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\n\nmvsSTRING mvsSTRING::operator()(const long int o,  long int l = 1 )\n\t\u00e4\n\tif ( o < 0 ]] o+l > st.l ]]  l < 0 )\n\t\t\u00e4perror(\" _INVALID STRING operation\");return * this ;\u00fc\n\treturn mvsSTRING((const char *)(st.c+o),l);\n\t\u00fc\n\nvoid mvsSTRING::operator<<(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = 0;i<st.l;i++)\n\t\tif (i+l<st.l)\n\t\t\t\u00e4*(c+i) = *(c+i+l); *(c+i+l) = ' ';\u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nvoid mvsSTRING::operator>>(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = st.l-1;i;i--)\n\t\tif (i-l>=0)\n\t\t\t\u00e4*(c+i)= *(c+i-l); *(c+i-l) = ' '; \u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nlong int mvsSTRING::hashcode()\n\t\u00e4\n\tlong int r = 0;\n\tfor (long int i = st.l ;i;i--)\n\t\tr = (r<<1) \u00ac (st.c\u00c4i\u00dc) ;\n\treturn (r<0 ? -r:r);\n\t\u00fc\nchar * mvsSTRING::nameOf()\n\t\u00e4\n\treturn \"mvsSTRING\" ;\n\t\u00fc\n\n/*\nlong int    mvsSTRING::lengthOf()\n\u00e4\nreturn st.l;\n\u00fc;\n*/\n\nvoid mvsSTRING::changeAll(char f,char t)\n\t\u00e4\n\tfor(char * c =st.c;*c;c++) if ( *c == f) *c = t;\n\t\u00fc\n\nvoid mvsSTRING::align(ALIGNTYPE falign)\n\t\u00e4\n\tlong int i , is , iz ;\n\tif ( st.type NEQ str::_VALID ) return ;\n\tswitch(falign)\n\t\t\u00e4\n\t\tcase aLEFT  :\n\t\t\tfor( i =0;i<st.l;i++)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this<<i;\n\t\t\tbreak ;\n\t\tcase aRIGHT :\n\t\t\tfor( i=st.l-1;i;i--)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this>>(st.l-1-i);\n\t\t\tbreak ;\n\t\tcase aCENTER:\n\t\t\tfor( is =0;is<st.l;is++)\n\t\t\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\t\t\tfor( iz=st.l-1;iz;iz--)\n\t\t\t\tif (st.c\u00c4iz\u00dc NEQ ' ') break ;\n\t\t\tif ( is >= iz ) break ;\n\t\t\ti = (st.l-(iz-is))/2;\n\t\t\tif (i < is ) *this<<(is-i);\n\t\t\telse if( i>is) *this>>(i-is);\n\t\t\tbreak ;\n\t\tcase aASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\nvoid mvsSTRING::caps(CAPSTYPE fcaps)\n\t\u00e4\n\tlong int i = st.l-1;\n\tif ( i <0 ]] st.type NEQ str::_VALID ) return ;\n\tlong int flag = 1;\n\tswitch(fcaps)\n\t\t\u00e4\n\t\tcase cUPPER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )toupper(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cLOWER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cWORD:\n\t\t\tfor(i=0;i<st.l;i++)\n\t\t\t\t\u00e4 if ( st.c\u00c4i\u00dc == ' ' ) flag = 1 ;\n\t\t\t\telse if (flag) \u00e4 flag = 0; st.c\u00c4i\u00dc =(char ) toupper(st.c\u00c4i\u00dc);\u00fc\n\t\t\t\telse st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i\u00dc); \u00fc\n\t\t\tbreak ;\n\t\tcase cASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\n\nmvsSTRING& mvsSTRING::strip()\n\t\u00e4\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\tchar linefeed = '\u00d6x15';\n\tchar horizontaltab = '\u00d6x05';\n#else\n\tchar linefeed  = '\u00d6x0a';\n\tchar horizontaltab = '\u00d6x09';\n#endif\n\tlong int is , iz ;\n\tif ( st.type NEQ str::_VALID ]]\n\t\tst.ltype == str::FIX ) return *this;\n\tfor( is =0;is<st.l;is++)\n\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\tfor( iz=st.l-1;iz;iz--)\n\t\tif (st.c\u00c4iz\u00dc NEQ ' ' && st.c\u00c4iz\u00dc NEQ linefeed && st.c\u00c4iz\u00dc NEQ horizontaltab) break ;\n\tif ( is > iz ) *this = \"\";\n\telse \u00e4 st.c\u00c4iz+1\u00dc = 0; st.ltype = str::VARIABLE ;\n\tif (is) *this = (char *)&(st.c\u00c4is\u00dc);\n\telse\n\t\t\u00e4\n\t\tchar * temp = new char\u00c4strlen(st.c)+1\u00dc;\n\t\tstrcpy(temp,st.c);\n\t\t* this = temp ;\n\t\tdelete \u00c4\u00dc temp;\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nint mvsSTRING::isEmpty()\n\t\u00e4\n\tif ( st.l == 0 ) return 1;\n\tmvsSTRING t = *this;\n\tt.st.ltype = str::VARIABLE;\n\tt.strip();\n\tif ( t.lengthOf() == 0) return 1;\n\treturn 0;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::stripmvsSTRING()\n\t\u00e4\n\tst.ltype = str::VARIABLE;\n\tstrip();\n\treturn *this;\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char c, mvsSTRING &rest )\n\t\u00e4\n\n\tchar *p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\tif ( p ) \u00e4 *p = '\u00d6x00'; rest = p+1; s = st.c ; *p = c; \u00fc\n\telse\n\t\t\u00e4\n\t\ts = st.c;\n\t\trest = \"\";\n\t\t\u00fc\n\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char * c, mvsSTRING & rest)\n\t\u00e4\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&memcmp(st.c+i,c,strlen(c))==0)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif ( p)\n\t\t\u00e4\n\t\t//KV20051205 if s==*this or rest == *this then st.c might be deleted in assignment operator\n\t\t// -> p must not be used after assignment\n\t\tmvsSTRING tmp(st.c,p-st.c);\n\t\trest = p+strlen(c);\n\t\ts = tmp;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\ts = *this;\n\t\trest = \"\";\n\t\t\u00fc\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING& s1,char c1, mvsSTRING& s2, char c2,mvsSTRING& rest)\n\t\u00e4\n\tmvsSTRING re;\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff|=off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c1)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif (p)\n\t\t\u00e4\n\t\tparse(s1,c1,re);\n\n\t\tre.parse(s2,c2,rest);\n\t\t\u00fc\n\telse \u00e4 s1 = st.c; s2 = \"\"; rest = \"\"; \u00fc\n\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1;\n\ts20 = s2;\n\ts30 = s3;\n\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tstrip();\n\tparse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.strip();\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\n\t\u00fc\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40)\n\t\u00e4\n\tparse(s10,c1,s20,c2,s30,c3,s40);\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40,\n\t\t\t\t\t\t\t\t\t\t\tchar * c4, mvsSTRING&s50)\n\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tmvsSTRING s5 = \"\";\n\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4,c4,s5);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n  s50 = s5.strip();\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s30, char * c3, mvsSTRING&s40)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n\t\u00fc\n\nvoid mvsSTRING::dump(const char * f,int l)\n\t\u00e4\n#if 0\n\tchar * use = \"mvsSTRING\";\n\t// if ( 0 ) //( __test__ )\n\t// ::dump((FILE *)f,use,st.c,st.l);\n\tchar _d\u00c41024\u00dc;\n\tsprintf(_d,\" File:%s Line:%d %s: %*s (%d %d %d) \u00d6n\",f,l,use,st.l,st.c,st.l,st.ltype,st.type);\n\tputs(_d);\n#endif\n\t\u00fc\n\nmvsSTRING& mvsSTRING::format(FORMAT * f)\n\t\u00e4\n\tcaps(f->fcaps);\n\talign(f->falign);\n\treturn * this ;\n\t\u00fc\n\nchar * mvsSTRING::getLlmvsSTRING()\n\t\u00e4\n\tst.lls = new char\u00c4st.l+2\u00dc;\n\t*(short*)st.lls = short(st.l);\n\tmemcpy(st.lls+2,st.c,st.l);\n\treturn st.lls;\n\t\u00fc\n\n\n\n\n#if 0\n\nmvsSTRING patternchng(mvsSTRING  input,char *  mask,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING  (*f)(mvsSTRING ))\n\t\u00e4\n\tchar * mv\u00c432\u00dc;\n\tlong int mflag = 1, mi = 0 ;\n\tlong int ml = strlen(mask);\n\tlong int i  , j ;\n\n\tfor(i=0;i<ml;i++)\n\t\t\u00e4  if ( *(mask+i) == '*' )\n\t\t\u00e4 *(mask+i ) = 0 ;\n\tmv\u00c4mi++\u00dc   = 0 ;\n\tmflag = 1;\n\t\t\u00fc\n\t\telse\n\t\t\tif (mflag)\n\t\t\t\t\u00e4 mflag = 0;\n\tmv\u00c4mi++\u00dc = mask+i ; \u00fc\n\t\t\u00fc\n\n\n\tlong int start = 0, stop = 0, offset = 0;\n\tmvsSTRING outputstr(\" \",0);\n\tmvsSTRING r = input ;\n\tchar * s ;\n\n\n\tfor(i=0;i<strlen(input);i++)\n\t\t\u00e4\n\t\tfor(j=0;j<mi;j++)\n\t\t\tif ( j == 0)\n\t\t\t\t\u00e4 if ( mv\u00c40\u00dc == 0)\n\t\t\t\t\u00e4 start = i ;  stop = strlen(input) ; \u00fc\n\t\t\t\telse if ( ( s = strstr(((char *)input)+i,mv\u00c40\u00dc) ) NEQ 0)\n\t\t\t\t\t\u00e4 start  = s - (char *)input ;  stop= start+strlen(mv\u00c40\u00dc);\n\t\toffset =stop-start ; \u00fc\n\t\t\t\telse \u00e4 stop = 0 ;break; \u00fc\n\t\t\t\t\u00fc\n\t\t\telse\n\n\t\t\t\t\u00e4\n\t\t\t\tif (  mv\u00c4j\u00dc == 0 ) \u00e4 stop =  strlen(input) ; continue ;\u00fc\n\n\t\t\t\telse if ( ( s = strstr((char *)input+start+offset,mv\u00c4j\u00dc)) NEQ 0 )\n\t\t\t\t\tstop = s-input+strlen(mv\u00c4j\u00dc);\n\t\t\t\telse \u00e4 stop = 0; break;\u00fc\n\t\t\t\t\u00fc\n\n\n\n\n\n\t\t\tif ( start < stop)\n\n\t\t\t\t\u00e4  outputstr  = outputstr + input(i,start-i);\n\t\t\tmvsSTRING t((char *)input+start,stop-start);\n\t\t\tr = input+stop;\n\t\t\toutputstr = outputstr + f(t) ;\n\t\t\ti =stop ;\n\t\t\tstart = stop = offset = 0;\n\t\t\t\t\u00fc\n\t\t\u00fc\n\toutputstr = outputstr+r;\n\treturn outputstr ;\n\n\t\u00fc\n#endif\n\n\n//#include <stdlib.h>\n\n\n\nsLLType  sLLTypeTable\u00c4\u00dc = \u00e4 sLLt0, sLLt1, sLLt2, sLLt3, sLLt4, sLLt0\u00fc;\n\n// Construtors:\n// default output\n//\n\n\nsLL::sLL(sLLType st , sLLUsage su,int l):mERROR()\n\t\u00e4\n\ttype = st;\n\tusage = su;\n\tstatus = sLLOk;\n\tallocl = 0;\n\n\tbase = child = (sLL*)0;\n\tllength = int(type);\n\n\tif ( usage NEQ sLLinput )\n\t\t\u00e4\n\t\tallocl = l;\n\t\tstart = new char \u00c4l\u00dc;\n\t\tstoredl = offset = llength;\n\t\tcursor = start+offset;\n\t\tlength = l;\n\t\tfromInt(start,length,llength);\n\t\t\u00fc\n\t\u00fc\n\n//\n// From a base sLL\n//\n\nsLL ::sLL (sLL  * b,int o,sLLType st):mERROR()\n\t\u00e4\n\tinit(b,o,st);\n\t\u00fc\n\n//\n// From a base SLL with offset\n//\n\nsLL::sLL(sLL * b,char  * s,\n\t\t\t\t sLLType st):mERROR()\n\t\u00e4\n\tinit(b,s-(b->start),st);\n\t\u00fc\n\n//\n// From a mvsSTRING\n//\n\nsLL ::sLL (char  * s,sLLType  st):mERROR()\n\t\u00e4\n\tallocl = 0;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl = llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\n\t\u00fc\n\nsLL :: sLL(char  * s, int ix):mERROR()\n\t\u00e4\n\tsLLType st = sLLTypeTable\u00c4ix\u00dc;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl =  llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\t\u00fc\n\n//\n// Copy constructor\n//\n\nsLL ::sLL (const sLL & f):mERROR()\n\t\u00e4\n\tallocl = f.allocl;\n\ttype   = f.type;\n\tusage  = f.usage;\n\tstatus = f.status;\n\n\tif ( usage NEQ sLLinput)\n\t\tstart = new char \u00c4f.allocl\u00dc;\n\telse\n\t\tstart = new char \u00c4f.length\u00dc;\n\n\tlength = f.length;\n\toffset = f.offset;\n\tllength = f.llength;\n\tstoredl = f.storedl;\n\tbase = NULL ;\n\tcursor = start+(f.cursor-f.start);\n\tmemcpy(start,f.start,length);\n\t\u00fc\n\n// Destructor\n\nsLL::\u00dfsLL()\n\t\u00e4\n\tif ( allocl ) delete \u00c4\u00dc start;\n\t\u00fc\n\n//\n// Assignemnt operator\n//\n\nsLL & sLL ::operator=(sLL  & from)\n\t\u00e4\n\tif ( &from == this ) return *this;\n\n\tif (allocl )\n\t\t\u00e4\n\t\tdelete \u00c4\u00dc start ;\n\t\t\u00fc\n\terr = from.err;\n\tallocl = from.allocl ? from.allocl : from.length;\n\tstart = new char \u00c4allocl\u00dc;\n\tlength = from.length;\n\n\tusage = from.usage;\n\ttype  = from.type;\n\tstatus = from.status;\n\tllength = from.llength;\n\toffset = from.offset;\n\tstoredl= from.storedl;\n\tcursor = start+(from.cursor-from.start);\n\n\tbase = from.base;\n\tchild = from.child;\n\n\tmemcpy(start,from.start,length);\n\treturn * this;\n\t\u00fc\n\nsLL::operator int()\n\t\u00e4\n\tif ( status == sLLOk && NOT iserror() )\n\t\t\u00e4\n\t\tif (usage == sLLinput) return  getRemainderLength() ;\n\t\telse return storeOk(1);\n\t\t\u00fc\n\n\telse\n\t\treturn 0;\n\t\u00fc\n\nchar  & sLL::operator\u00c4\u00dc(int o)\n\t\u00e4\n\tif ( offset < length )\n\t\treturn start\u00c4o\u00dc;\n\n\tstatus = sLLOf; markerror();\n\treturn dummy;\n\t\u00fc\n\n//\n// Iterate on base - child structure\n//\n\nsLL *sLL::iterate(sLLType st,int resetf)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tif ( resetf ) resetCursor();\n\tchild = new sLL(this,cursor,st);\n\tif (child->iserror()) return NULL;\n\treturn child;\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLL  *sLL ::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLL *)0;\n\tint    l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLL(this,cursor,type);\n\t\treturn child;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\nvoid sLL::remove(sLL& o)\n\t\u00e4\n\n\tsLL s(type,sLLoutputVar,storedl);\n\tsLL * si = iterate(type);\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n// Get info\n\n\nsLL   * sLL ::getBase()\u00e4 return base;\u00fc\nint     sLL ::getOffset()\u00e4 return offset;\u00fc\nint     sLL ::getFullLength()\u00e4 return length;\u00fc\nint     sLL ::getStoredLength()\u00e4 return storedl;\u00fc\nint     sLL ::getRemainderLength()\n\t\u00e4 if (status == sLLOk )\n\treturn (length - (cursor - start) ) ;\nreturn 0;\n\t\u00fc\nchar  * sLL ::getCursor()\u00e4 return cursor;\u00fc\nsLL   * sLL ::getChild()\u00e4 return child;\u00fc\nvoid    sLL ::setBase(sLL *b)\u00e4 base = b;\u00fc\nvoid    sLL ::setChild(sLL *c)\u00e4 child = c;\u00fc\nvoid    sLL ::setUsage(sLLUsage u)\n\t\u00e4\n\tif ( u == usage ) return;\n\n\tif ( u == sLLinput )\n\t\t\u00e4\n\t\tsetLength();\n\t\tlength = storedl;\n\t\tresetCursor();\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\t\u00fc\n\tstatus = sLLOk;\n\tclearerror();\n\tusage = u;\n\t\u00fc\n// Cursor\n\nvoid sLL::resetCursor()\n\t\u00e4\n\tstatus = sLLOk;\n\tclearerror();\n\tcursor = start+llength;\n\tif ( usage NEQ sLLinput ) setLength();\n\n\t\u00fc\n\nchar  * sLL::goCursor(int v)\n\t\u00e4\n\tchar * c = cursor+v;\n\tif ( iserror() ]] status NEQ sLLOk ) return 0;\n\tif ( (c-start) <= length && (c-start ) >= llength )\n\t\t\u00e4\n\t\tcursor = c;\n\t\tif ( usage NEQ sLLinput) setLength();\n\t\treturn cursor ;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstatus = sLLUf;\n\t\tcursor = start +length;\n\t\tmarkerror();\n\t\treturn 0;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLL::setLength()\n\t\u00e4\n\tstoredl = cursor-start;\n\tfromInt(start,cursor-start,int(type));\n\t\u00fc\n\nsLL& sLL::operator >>(int& i)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ti = int(toInt(cursor,sizeof(int)));\n\tgoCursor(sizeof( int));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(unsigned short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =(unsigned short) toInt(cursor,sizeof(short));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = short(toInt(cursor,sizeof(short)));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\n\nsLL& sLL::operator>>(char  & c)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tc = *cursor;\n\tgoCursor(1);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator >>(char * & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =  cursor;\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(mvsSTRING & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = mvsSTRING(cursor,getRemainderLength());\n\tgoCursor(getRemainderLength());\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator >>(sLL& s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tsLL ns(cursor,s.type);\n\ts = ns;\n\tgoCursor(s.length);\n\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(INT3 & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = int(toInt(cursor,3));\n\tgoCursor(3);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(sLLskip & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tgoCursor(int(s));\n\treturn *this;\n\n\t\u00fc\n\nsLL& sLL::operator<<(int i)\n\t\u00e4\n\tif ( storeOk(sizeof(int)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(int));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(unsigned short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,short(i),sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  c)\n\t\u00e4\n\tif (storeOk(1))\n\t\t\u00e4\n\t\t*cursor=c;\n\t\tgoCursor(1);\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  * str)\n\t\u00e4\n\tint l = strlen(str);\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,str,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(mvsSTRING & s)\n\t\u00e4\n\tint l = s.lengthOf();\n\tif (storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,(char *)(s),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\nsLL& sLL::operator<<(sLL & s)\n\t\u00e4\n\tint l = s.getLength();\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,s.getStart(),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(INT3& i)\n\t\u00e4\n\tif (storeOk(3)  )\n\t\t\u00e4\n\t\tfromInt(cursor,int(i),3);\n\t\tgoCursor(3);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(sLLskip& s)\n\t\u00e4\n\tif ( storeOk(int(s))  )\n\t\t\u00e4\n\t\tmemset(cursor,null,int(s));\n\t\tgoCursor(int(s));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::store(char  * p,int l)\n\t\u00e4\n\tif ( l <= 0 ) return *this;\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,p,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\n//szm20050629\nmvsSTRING sLL::getString()\n\t\u00e4\n\tif ( *(getCursor()+getRemainderLength()) == '\u00d6x00' )\n\t\tstring = getCursor();\n\telse\n\t\t\u00e4\n\t\tchar * c = new char\u00c4getRemainderLength()+1\u00dc;\n\t\tc\u00c4getRemainderLength()\u00dc = null;\n\t\tmemcpy(c,getCursor(),getRemainderLength());\n\t\tstring = c;\n\t\tdelete \u00c4\u00dc c;\n\t\t\u00fc\n\treturn string;\n\t\u00fc\n//szm\n\n//\n// Utilies\n//\n\nvoid sLL::init(sLL * b,int o,sLLType st)\n\t\u00e4\n\ttype  = st;\n\tusage = sLLinput;\n\tstatus = sLLOk;\n\tallocl = 0;\n\tbase  = b;\n\tchild = 0;\n\tstart = (b->start)+o;\n\n\toffset = llength = int(st);\n\tcursor = start+offset;\n\tb->setChild(this);\n\tif ( usage == sLLinput  ]] b  )\n\t\tstoredl = length = int(toInt (start,llength));\n\telse\n\t\tstoredl = length = llength ;\n\t\u00fc\n\nint sLL::storeOk(int l)\n\t\u00e4\n#if defined(OWN_STDIO) == 0\n\tassert ( l >= 0 );\n#endif\n\tint r;\n\tif ( usage == sLLinput )\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\tusage = sLLoutputVar;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tr = allocl -(cursor-start);\n\t\tif ( r >= l ) return 1;\n\t\tif ( usage == sLLoutput )\n\t\t\t\u00e4\n\t\t\tstatus = sLLOf;\n\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\tr =l+(cursor-start);\n\tchar * n = new char \u00c4r\u00dc;\n\n\tint o = cursor-start;\n\tmemcpy(n,start,o);\n\tif ( allocl )\n\t\tdelete \u00c4\u00dc start;\n\tlength = allocl = r;\n\tstart = n;\n\tcursor = n+o;\n\treturn 1;\n\t\u00fc\n\n//\n//\n//\n\nvoid sLL::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar * use = (usage == sLLinput) ? \"Input\" : \"Output\" ;\n\tint l   = (usage == sLLinput) ? length : storedl;\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d %s %d \u00d6n\",f,ln,use,l\n\t\t);\n\tputs(b);\n\tstring.dump(f,ln);\n#endif\n\t\u00fc\n\n\nint sLL::write(void * f)\n\t\u00e4\n\treturn fwrite(start,1,getLength(),(FILE *)f);\n\t\u00fc\n\nsLL * readsLL(void* f,sLLType t)\n\t\u00e4\n\tint l;\n\tchar lx\u00c44\u00dc;\n\n\tif ( fread(lx,1,int(t),(FILE *)f) )\n\t\t\u00e4\n\n\t\tl = int(toInt(lx,int(t)));\n\t\tchar * b = new char \u00c4l\u00dc;\n\t\tmemcpy(b,lx,int(t));\n\t\tsLL * ret = NULL;\n\t\tif ( fread(b+int(t),1,l-int(t),(FILE *)f) )\n\t\t\t\u00e4\n\t\t\tsLL buff(b,t);\n\t\t\tret = new sLL(buff);\n\t\t\t\u00fc\n\t\tdelete \u00c4\u00dcb;\n\t\treturn ret;\n\n\t\t\u00fc\n\telse return NULL;\n\t\u00fc\n\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n\n/*\nsLLTag class fix type sLLt2 ( two bytes length)\nshort code\n...\n*/\n\nvoid sLLTag::init(short c )\n\t\u00e4\n\t//printf(\"code :%d\u00d6n\",c);\n\tcode = c ;\n\tsearchcode = 0;\n#ifdef CALL_TAG\n\tname = TagCatalog\u00c4code\u00dc ?(char *)(TagCatalog\u00c4code\u00dc->name) :  \"???\";\n#endif\n\t//  printf(\"%s\u00d6n\",name);\n\t\u00fc\n\nsLLTag::sLLTag():sLL(sLLt2,sLLoutputVar)\n\t\u00e4\n\tinit(0);\n\t(*this)<<short(0);\n\t\u00fc\n\nsLLTag::sLLTag(short c)\n#ifdef CALL_TAG\n:sLL(sLLt2,sLLoutputVar,TagCatalog\u00c4c\u00dc->maxlength+5)\n#endif\n\t\u00e4\n\tinit(c);\n\t(*this)<<c;\n\t\u00fc\n\nsLLTag::sLLTag(char * s):sLL(s)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag::sLLTag(const sLLTag & s):sLL(s)\n\t\u00e4\n\tcode = s.code;\n\tname = s.name;\n\tsearchcode = s.searchcode;\n\t\u00fc\n\nsLLTag::sLLTag(sLL * b,char  * s):sLL(b,s,sLLt2)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag& sLLTag::operator=(sLLTag&  from)\n\t\u00e4\n\n\tif ( &from == this ) return *this;\n\tthis->sLL::operator=(from);\n\tcode   = from.code;\n\tname   = from.name;\n\tsearchcode = from.searchcode;\n\treturn *this;\n\t\u00fc\n\nsLLTag * sLLTag::search(short c)\n\t\u00e4\n\tsLLTag * s ;\n\tsetUsage(sLLinput);\n\tif ( c )\n\t\t\u00e4\n\t\tsearchcode = c;\n\t\tresetCursor();\n\t\ts = iterate();\n\t\t\u00fc\n\telse s = next();\n\twhile( s && searchcode NEQ s->getCode() )\n\t\t\u00e4\n\t\ts = next();\n\t\t\u00fc\n\n\tstatus = sLLOk;\n\tclearerror();\n\treturn (s);\n\t\u00fc\n\nsLLTag * sLLTag::update(sLLTag & f )\n\t\u00e4\n\n\tsLLTag * s = search(f.code);\n\tif ( s )\n\t\t\u00e4\n\t\tremove(*s);\n\t\t\u00fc\n\t(*this)<<f;\n\treturn s;\n\t\u00fc\n\nvoid sLLTag::resetCursor()\n\t\u00e4\n\tsLL::resetCursor();\n\tgoCursor(sizeof(short));\n\t\u00fc\n\n\nvoid sLLTag::remove(sLLTag& o)\n\t\u00e4\n\n\tsLLTag s(code);\n\tresetCursor();\n\tsLLTag * si = iterate();\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n\nsLLTag *sLLTag::iterate()\n\t\u00e4\n\n\tchild = new sLLTag(this,cursor);\n\tif (child->iserror()) return NULL;\n\t//child->dump(__FILE__,__LINE__);\n\treturn ((sLLTag *)child);\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLLTag * sLLTag::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLLTag *)0;\n\tint l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLLTag(this,cursor);\n\t\t//child->dump(__FILE__,__LINE__);\n\t\treturn ((sLLTag *)child);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLLTag::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d Name:%s Code:%d \u00d6n\",f,ln,name,code);\n\tputs(b);\n\tsLL::dump(\"\",0);\n#endif\n\t\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSTOOL": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma runopts(POSIX(ON),XPLINK(ON),ALL31(ON))\n#define _OPEN_SYS_EXT 1\n#define _OPEN_SOURCE 1\n#define ISIS_ALLOW_OS_FUNCTIONS 1\n#include \"isisdef.h\"\n#define _OPEN_SYS_EXT 1\n#define _OPEN_SOURCE 1\n#define _ISOC99_SOURCE\n#include \"mvstool.hpp\"\n\nchar * strupr(char *s)\n\u00e4\n\tif (NOT s) return (NULL);\n\tfor(int i = 0;i<strlen(s);i++) s\u00c4i\u00dc = toupper(s\u00c4i\u00dc);\n\treturn s;\n\u00fc\n\nint memcmpi(const char * s1,const char * s2,int l)\n\u00e4\n\tfor(int i = 0; i<l; i++)\n\t\tif ( tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc) )\n\t\t\treturn (tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc));\n\treturn 0;\n\u00fc\n\nchar * makeString(char * s,int l)\n\u00e4\n\tchar * c = (char *)malloc(l+1);\n\tmemcpy(c,s,l);\n\tc\u00c4l\u00dc = 0;\n\tfor(l;l;l--)\n\t\tif ( c\u00c4l-1\u00dc NEQ ' ')  break;\n\tc\u00c4l\u00dc = null;\n\treturn c;\n\u00fc\n\nint initTestCases(char * n,testRoutine f)\n\u00e4\n\tif (testCasesIndex==0)\n\t\tmemset(&testCases,0,sizeof(testCases));\n\ttestCases\u00c4testCasesIndex\u00dc.name = n;\n\ttestCases\u00c4testCasesIndex++\u00dc.addr = f;\n\treturn testCasesIndex;\n\u00fc\n\ntypedef struct smf14 * smf14P;\ntypedef struct smf30cas * smf30casP;\ntypedef struct smf30id  * smf30idP;\ntypedef struct smf30sap * smf30sapP;\ntypedef struct smf30cmp * smf30cmpP;\ntypedef struct smf30mse * smf30mseP;\ntypedef struct smf30ud  * smf30udP;\ntypedef struct smf30acs * smf30acsP;\ntypedef struct smf30dr  * smf30drP;\ntypedef struct smf30op  * smf30opP;\ntypedef struct smf30ura * smf30uraP;\ntypedef struct smf30ar  * smf30arP;\ntypedef struct smf30exp * smf30expP;\ntypedef struct smf30ops * smf30opsP;\ntypedef struct smf30rm  * smf30rmP;\ntypedef struct smf30prf * smf30prfP;\ntypedef struct smfrcd30 * smfrcd30P;\ntypedef struct smfrcd92 * smfrcd92P;\ntypedef struct smf92fcl * smf92fclP;\ntypedef struct smf92fop * smf92fopP;\ntypedef struct smf92fsm * smf92fsmP;\ntypedef struct smf92fsp * smf92fspP;\ntypedef struct smf92fsr * smf92fsrP;\ntypedef struct smf92fsu * smf92fsuP;\ntypedef struct smf92fsv * smf92fsvP;\ntypedef struct smf92id  * smf92idP;\ntypedef struct smf92mmp * smf92mmpP;\ntypedef struct smf92mun * smf92munP;\ntypedef struct smf92sss * smf92sssP;\n\n\nconst int     SMF_MAXBUFFER = 1024*1024;\nconst char * SMF_FILE = \"//DD:SMF\";\n#define FT_DIR        1  //Directory File\n#define FT_CHARSPEC   2      //Character Special File\n#define FT_REGFILE    3      //Regular File\n#define FT_FIFO       4      //Named Pipe (FIFO) File\n#define FT_SYMLINK    5      //Symbolic link\n#define FT_SOCKET     7      //Socket File                  \u00baD2A\n\n#define sF(d,v) printf(\" %s:%#10.4f(sec)\u00d6n\",#d,float(p->v)/100);\n#define sI(d,v) printf(\" %s:%d\u00d6n\",#d,p->v);\n\nlong long totalCPUsu = 0;\nlong long indepCPUsu = 0;\n\nstatic int rst_14 = 0;\nstatic int rst_15 = 0;\nstatic int rst_30 = 0;\nstatic int rsd_14 = 0;\nstatic int rsd_15 = 0;\nstatic int rsd_30 = 0;\nstatic bool debugF = atoi(getenv(\"DEBUG_SMF\"));\ntypedef struct\n\u00e4\n\tshort int     _smf14esl;     /* LENGTH OF SECTION IN EXTENDED INFORMATION @L1A */\n\tchar          _filler4;      /* RESERVED                                  @L1A */\n\tchar          _smf14sty;     /* SECTION TYPE                              @L1A */\n\tunsigned char _smf14xf1;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 1    @L1A */\n\tunsigned char _smf14xf2;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 2    @L1A */\n\tunsigned char _smf14cdl\u00c48\u00dc;  /* NUMBER OF BYTES OF COMPRESSED DATA READ   @L1A */\n\tunsigned char _smf14udl\u00c48\u00dc;  /* NUMBER OF BYTES OF DATA READ OR WRITTEN   @L1A */\n\tunsigned char _smf14cds\u00c48\u00dc;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */\n\tunsigned char _smf14uds\u00c48\u00dc;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */\n\tunsigned char _smf14cis\u00c44\u00dc;  /* PHYSICAL BLOCK SIZE OF COMPRESSED FORMAT  @02C */\n\tshort int     _smf14tkl;     /* DICTIONARY TOKEN LENGTH(NOT INCLUDING     @L1A */\n\tunsigned char _smf14tkn\u00c436\u00dc; /* DICTIONARY TOKEN FOR COMPRESSED FORMAT    @02C */\n\tunsigned char _filler5\u00c453\u00dc;\n\u00fc\n* smf14EISP;\n\ntypedef struct\n\u00e4\n\tunsigned char _filler8\u00c44\u00dc;\n\tunsigned char _smf14spn\u00c48\u00dc;   /* STEP NAME                                 @L2A */\n\tunsigned char _smf14pgn\u00c48\u00dc;   /* ACTIVE PROGRAM NAME                       @L2A */\n\tunsigned char _filler9\u00c4113\u00dc;\n\u00fc\n* smf14STEP;\nchar pstepname\u00c49\u00dc;\nchar pprogname\u00c4256\u00dc;\nchar stepname\u00c49\u00dc;\nint write_30 = 0;\nchar jobname\u00c49\u00dc;\nchar jobid\u00c49\u00dc = \"\";\nchar username\u00c4128\u00dc;\nstatic int counters\u00c4256\u00dc;\nstatic int total_read = 0;\nstatic int total_write = 0;\nstatic int total_dir = 0;\nint printSMF(char * b,bool & idflag,size_t rl,int need30 = 1, int  need92 = 1)\n\u00e4\n\t//printf(\" LRECL:%5.5d %8.8x %8.8x %8.8x %8.8x \u00d6n\",l,*(int *)b,*(int *)(b+4),*(int *)(b+8),*(int *)(b+12));\n\tcounters\u00c4smfrcd30P(b)->smf30rty\u00dc++;\n\tswitch(smfrcd30P(b)->smf30rty)\n\t\u00e4\n\tcase 2:\n\t\t//printf(\" >>>start of dump>>>\u00d6n\");\n\t\tbreak;\n\tcase 3:\n\t\t//printf(\" >>>end of dump>>>\u00d6n\");\n\t\tbreak;\n\tcase 14:\n\tcase 15:\n\t\t\u00e4\n\t\t\tchar progname\u00c4256\u00dc;\n\t\t\tsmf14P smf14p = (smf14P)b;\n\t\t\tint sdc = smf14p->smf14sdc; //size of DCB segment\n\t\t\tint nuc = smf14p->smf14nuc; //no. of UCB sections\n\t\t\tint suc = smf14p->smf14suc; //size of each of UCB sections\n\t\t\tint excp = 0;\n\t\t\tmemcpy(&rst_15,smf14p->smf14rst,4);\n\t\t\tmemcpy(&rsd_15,smf14p->smf14rsd,4);\n\t\t\tif (rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))\n\t\t\t\tbreak;\n\t\t\tif (nuc > 0)\n\t\t\t\texcp = *(int*)smf14p->smfexcp;\n\t\t\tif (excp == 0)\n\t\t\t\tbreak;\n\t\t\tif (debugF)\n\t\t\t\t_dump(\" SMF 14 or 15 record dump\",b,rl);\n\t\t\t\u00e4\n\t\t\t\tunsigned char* dcbp = smf14p->smfdcbor; //DCB Section\n\t\t\t\tunsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section\n\t\t\t\tunsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section\n\t\t\t\tunsigned char* eisp = ucbp + nuc*suc;\n\t\t\t\tshort int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Sections\n\t\t\t\tunsigned char* eispr = eisp + 2;\n\t\t\t\tshort int eispl = 1; //length of next Extended Information Section\n\t\t\t\tint write_14_15 = 0; //=0 do not write line\n\t\t\t\tchar stepname_14\u00c49\u00dc;\n\t\t\t\tchar progname_14\u00c49\u00dc;\n\t\t\t\twhile (smf14esll > 0 && eispl > 0)\n\t\t\t\t\u00e4\n\t\t\t\t\teispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section\n\t\t\t\t\tchar sty = ((smf14EISP)eispr)->_smf14sty; //Section type\n\t\t\t\t\tswitch(sty)\n\t\t\t\t\t\u00e4\n\t\t\t\t\tcase smf14stp:\n\t\t\t\t\t\tstrncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);\n\t\t\t\t\t\tstrncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);\n\t\t\t\t\t\tstepname_14\u00c48\u00dc = 0;\n\t\t\t\t\t\tprogname_14\u00c48\u00dc = 0;\n\t\t\t\t\t\tif (*pstepname == 0 && *pprogname == 0)\n\t\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\t\telse if (*pstepname && |strcasecmp(stepname_14,pstepname))\n\t\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\t\telse if (*pprogname && |strcasecmp(progname_14,pprogname))\n\t\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\u00fc\n\t\t\t\t\tsmf14esll -= eispl;\n\t\t\t\t\teispr += eispl;\n\t\t\t\t\t//printf(\"smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%d\u00d6n\",smf14p,ucbp,eispr,eisp,smf14esll);\n\t\t\t\t\u00fc\n\t\t\t\tif (write_14_15)\n\t\t\t\t\u00e4\n\t\t\t\t\tchar dsname\u00c445\u00dc;\n\t\t\t\t\twrite_30 = 1; //write step sum\n\t\t\t\t\t/*\n\t\t\t\t\tif (*stepname == 0)\n\t\t\t\t\t\u00e4\n\t\t\t\t\tstrcpy(stepname,stepname_14);\n\t\t\t\t\tstrcpy(progname,progname_14);\n\t\t\t\t\tprintf(\" === Start stepname:'%s' progname:'%s' ===\u00d6n\",stepname,progname);\n\t\t\t\t\t\u00fc\n\t\t\t\t\t*/\n\t\t\t\t\tstrncpy(dsname,(const char*)smf14p->smfjfcb1,44);\n\t\t\t\t\tdsname\u00c444\u00dc = 0;\n\t\t\t\t\tprintf(\"%8.8s %s' excp=%8d \",smf14p->smftioe5,dsname,excp);\n\t\t\t\t\tif (smfrcd30P(b)->smf30rty == 14)\n\t\t\t\t\t\tprintf(\"input \");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"output \");\n\t\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14dad)\n\t\t\t\t\t\tprintf(\"DASD \");\n\t\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14tds)\n\t\t\t\t\t\tprintf(\"Temporary \");\n\t\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14vio)\n\t\t\t\t\t\tprintf(\"VIO \");\n\t\t\t\t\tprintf(\"\u00d6n\");\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tcase 30:\n\t\t// Identification section\n\n\t\t//if (*(short *)(smfrcd30P(b)->smf30stp)|=5)\n\t\t//  break;\n\t\tswitch (*(short *)(smfrcd30P(b)->smf30stp))\n\t\t\u00e4\n\t\tcase 1:\n\t\t\tif (argv\u00c41\u00dc&&memcmp(argv\u00c41\u00dc,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)\n\t\t\t\u00e4\n\t\t\t\tmemcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);\n\t\t\t\tjobid\u00c48\u00dc = 0;\n\t\t\t\tmemcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);\n\t\t\t\tjobname\u00c48\u00dc = 0;\n\t\t\t\tmemcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);\n\t\t\t\tusername\u00c48\u00dc = 0;\n\t\t\t\trst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;\n\t\t\t\tmemcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\u00fc\n\t\tif (memcmp(argv\u00c41\u00dc,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))\n\t\t\tbreak;\n\t\tswitch (*(short *)(smfrcd30P(b)->smf30stp))\n\t\t\u00e4\n\t\tcase 1:\n\t\t\tprintf(\" ============================== J O B S T A R T ===================\u00d6n\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\" ========================= S T E P T O T A L ======================\u00d6n\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\" ====================== J O B T E R M I N A T I O N  =============\u00d6n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\" ===========System address space=====================================\u00d6n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\u00fc\n\t\tint rest , v , ss, mm, hh;\n\t\trest = (*(int *)smfrcd30P(b)->smf30tme)%100;\n\t\tv =  (*(int *)smfrcd30P(b)->smf30tme)/100;\n\t\tss = v%60;\n\t\tv /= 60;\n\t\tmm = v%60;\n\t\thh = v/60;\n\n\t\tif (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)\n\t\t\u00e4\n\t\t\tsmf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);\n\t\t\tif (debugF)\n\t\t\t\u00e4\n\t\t\t\t_dump(\" SMF 30 record dump\",b,rl);\n\t\t\t\tprintf(\" Subsystem     :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30son));\n\t\t\t\tprintf(\" Identification :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30ion));\n\t\t\t\tprintf(\" I/O Activity :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30uon));\n\t\t\t\tprintf(\" Completion :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30ton));\n\t\t\t\tprintf(\" Processor  :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30con));\n\t\t\t\tprintf(\" Accounting :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30aon));\n\t\t\t\tprintf(\" Storage    :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30ron));\n\t\t\t\tprintf(\" Performance :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30pon));\n\t\t\t\tprintf(\" Operator   :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30oon));\n\t\t\t\tprintf(\" EXCP       :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30eon));\n\t\t\t\tprintf(\" APPC       :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30drn));\n\t\t\t\tprintf(\" OMVS       :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30opn));\n\t\t\t\tprintf(\" Usage      :%d\u00d6n\",*(short *)(smfrcd30P(b)->smf30udn));\n\t\t\t\u00fc\n\t\t\tprintf(\" Job:%8.8s JobId:%8.8s Step:%8.8s User:%20.20s RacfGrp:%8.8s RacfUsr:%8.8s\u00d6n\",\n\t\t\t\tp->smf30jbn,jobid,p->smf30stm,p->smf30usr,p->smf30grp,p->smf30rud);\n\t\t\tprintf(\" Program:%8.8s\",p->smf30pgm);\n\t\t\tidflag = true;\n\t\t\u00fc\n\t\tprintf(\" Record Created at:%2.2d:%2.2d:%2.2d:%2.2d\u00d6n\",hh,mm,ss,rest);\n\t\t// I/O activity\n\t\tif (*(short *)(smfrcd30P(b)->smf30uon))\n\t\t\u00e4\n\t\t\tsmf30uraP p = smf30uraP(b+smfrcd30P(b)->smf30uof);\n\t\t\tprintf(\" Accumplated EXCP count:%8.8d\u00d6n\",\n\t\t\t\tp->smf30tep);\n\t\t\u00fc\n\t\t// Processor cumulative CPU\n\t\tif (*(short *)(smfrcd30P(b)->smf30con))\n\t\t\u00e4\n\t\t\tsmf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);\n\t\t\tprintf(\" Total CPU time:%#10.4f(sec) SRB time:%#10.4f(sec)\u00d6n\",\n\t\t\t\tfloat(p->smf30cpt)/100,float(p->smf30cps)/100);\n\t\t\t/*\n\t\t\tsF(process I/O interrupts,smf30iip)\n\t\t\tsF(client and preempt SRB,smf30asr)\n\t\t\tsF(independent enclave,smf30enc)\n\t\t\tsF(dependent enclave,smf30det)\n\t\t\t*/\n\t\t\u00fc\n\t\t// EXCP section\n\t\tif (*(short *)(smfrcd30P(b)->smf30eon))\n\t\t\u00e4\n\t\t\tsmf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);\n\t\t\tfor(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)\n\t\t\t\u00e4\n\t\t\t\tif (p->smf30blk)\n\t\t\t\t\tprintf(\" Device(CUA):%2.2X%2.2X EXCP count:%8.8d\u00d6n\",\n\t\t\t\t\tp->smf30cua\u00c40\u00dc,p->smf30cua\u00c41\u00dc,p->smf30blk);\n\t\t\t\tp = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);\n\t\t\t\u00fc\n\t\t\u00fc\n\t\t// Storage\n\t\tif (*(short *)(smfrcd30P(b)->smf30ron))\n\t\t\u00e4\n\t\t\tsmf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);\n\t\t\tprintf(\" Max Region Size:%8.8d(Mbyte) Max Allocated Storage:%8.8d(Mbyte)\u00d6n\",\n\t\t\t\t(*(int *)p->smf30rgn)/1024,p->smf30eur/(1024*1024));\n\t\t\u00fc\n\n\t\t// Performance\n\t\tif (*(short *)(smfrcd30P(b)->smf30pon))\n\t\t\u00e4\n\t\t\tsmf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);\n\t\t\tprintf(\" Total Service units:%8.8d CPU:%8.8d SRB:%8.8d I/O:%8.8d\u00d6n\",\n\t\t\t\tp->smf30srv,p->smf30csu,p->smf30srb,p->smf30io);\n\t\t\ttotalCPUsu  += p->smf30csu;\n\t\t\tindepCPUsu += p->smf30esu;\n\t\t\t/*\n\t\t\tsI(Independent enclave tansaction active,smf30eta);\n\t\t\tsI(Independent enclave CPU service uints,smf30esu);\n\t\t\tsI(Independent enclave trasnsaction count,smf30etc);\n\t\t\t*/\n\t\t\u00fc\n\n\t\t// Operator\n\t\tif (*(short *)(smfrcd30P(b)->smf30oon))\n\t\t\u00e4\n\t\t\tsmf30opsP p = smf30opsP(b+smfrcd30P(b)->smf30oof);\n\t\t\tif (p->smf30pdm]]p->smf30prd)\n\t\t\t\tprintf(\" Non Specific mounts :%8.8d Specific mounts:%8.8d\u00d6n\",\n\t\t\t\tp->smf30pdm,p->smf30prd);\n\t\t\tif (p->smf30mtm]]p->smf30msr)\n\t\t\t\tprintf(\" SMS Non Specific mounts:%8.8d Specific mounts:%8.8d\u00d6n\",\n\t\t\t\tp->smf30mtm,p->smf30msr);\n\n\t\t\u00fc\n\t\t// Open Edition\n\t\tif (*(short *)smfrcd30P(b)->smf30opn)\n\t\t\u00e4\n\t\t\tsmf30opP p = smf30opP(b+*(int *)smfrcd30P(b)->smf30opo);\n\t\t\tfor(int i=0;i<*(short*)smfrcd30P(b)->smf30opn;i++)\n\t\t\t\u00e4\n\t\t\t\tprintf(\" Process:%d Process group:%d User:%d Group:%d Session:%d\u00d6n\",\n\t\t\t\t\tp->smf30opi,p->smf30opg,p->smf30oui,p->smf30oug,p->smf30osi);\n\t\t\t\tprintf(\" CPU:%#10.2f(sec) Kernel Calls:%d \u00d6n\",\n\t\t\t\t\tfloat(p->smf30ost)/100,p->smf30osc);\n\t\t\t\tprintf(\" Directory Reads:%8.8d\u00d6n\",p->smf30odr);\n\t\t\t\tprintf(\" Regular file   :%8.8d %8.8d\u00d6n\",p->smf30ofr,p->smf30ofw);\n\t\t\t\tprintf(\" Pipe       :%8.8d %8.8d\u00d6n\",p->smf30opr,p->smf30opw);\n\t\t\t\tprintf(\" Special file :%8.8d %8.8d\u00d6n\",p->smf30osr,p->smf30osw);\n\t\t\t\tprintf(\" Path lookup :%8.8d %8.8d\u00d6n\",p->smf30oll,p->smf30olp);\n\t\t\t\tprintf(\" Path generation:%8.8d %8.8d\u00d6n\",p->smf30ogl,p->smf30ogp);\n\t\t\t\tprintf(\" Socket     :%8.8d %8.8d\u00d6n\",p->smf30okr,p->smf30okw);\n\t\t\t\tprintf(\" Message queue :%8.8d %8.8d\u00d6n\",p->smf30oms,p->smf30omr);\n\t\t\t\tp = smf30opP((char *)p+*(short *)smfrcd30P(b)->smf30opl);\n\t\t\t\u00fc\n\t\t\tprintf(\" Total_read : %8.8d\u00d6n\",total_read);\n\t\t\tprintf(\" Total_write : %8.8d\u00d6n\",total_write);\n\t\t\tprintf(\" Total_dir : %8.8d\u00d6n\",total_dir);\n\n\t\t\ttotal_read = total_write = total_dir = 0;\n\t\t\u00fc\n\t\tprintf(\" ====================================================================\u00d6n\");\n\t\tif (*(short *)(smfrcd30P(b)->smf30stp)==5)\n\t\t\treturn 5;\n\t\tbreak;\n\n\t\tbreak;\n\tcase 42:\n\t\tif (smfrcd92P(b)->smf92stp==6)\n\t\t\u00e4\n\t\t\t_dump(\" SMF 42 record dump\",b,rl);\n\t\t\tbreak;\n\t\t\u00fc\n\tcase 92:\n\t\tif (smfrcd92P(b)->smf92stp==5)\n\t\t\u00e4\n\t\t\t_dump(\" SMF 92 record dump\",b,rl);\n\t\t\tbreak;\n\t\t\u00fc\n\n\t\tif (smfrcd92P(b)->smf92ion)\n\t\t\u00e4\n\n\t\t\tsmf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);\n\t\t\tif (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)\n\t\t\t\t]]memcmp(jobname,pid->smf92jbn,8))\n\t\t\t\tbreak;\n\t\t\t//if (|need92]](strlen(argv\u00c41\u00dc)&&memcmp(jobid,argv\u00c41\u00dc,strlen(argv\u00c41\u00dc))))\n\t\t\tif (debugF)\n\t\t\t\t_dump(\" SMF 92 record dump\",b,rl);\n\t\t\tint rest , v , ss, mm, hh;\n\t\t\trest = smfrcd92P(b)->smf92tme%100;\n\t\t\tv = smfrcd92P(b)->smf92tme/100;\n\t\t\tss = v%60;\n\t\t\tv /= 60;\n\t\t\tmm = v%60;\n\t\t\thh = v/60;\n\t\t\tswitch (smfrcd92P(b)->smf92stp)\n\t\t\t\u00e4\n\t\t\tcase 11:\n\t\t\t\tif (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)\n\t\t\t\t\u00e4\n\t\t\t\t\tsmf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);\n\t\t\t\t\tfor(int i=0;i<smfrcd92P(b)->smf92don;i++)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tchar name\u00c465\u00dc;\n\t\t\t\t\t\tname\u00c464\u00dc=0;\n\t\t\t\t\t\tif (p->smf92cty==FT_SOCKET)\n\t\t\t\t\t\t\tsprintf(name,\" SOCKET inode:%d device:%d\",p->smf92cin,p->smf92cdn);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmemcpy(name,p->smf92cpn,sizeof(p->smf92cpn));\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tprintf(\" Job:%8.8s at:%2.2d:%2.2d:%2.2d:%2.2d closing:%s\u00d6n\",pid->smf92jbn,hh,mm,ss,rest,name);\n\t\t\t\t\t\tprintf(\" Process:%d User:%d Group:%d\u00d6n\",\n\t\t\t\t\t\tpid->smf92pid,pid->smf92uid,pid->smf92gid);\n\n\t\t\t\t\t\tif (p->smf92cdi)\n\t\t\t\t\t\tprintf(\" Directory I/O blocks :%8.8d\u00d6n\",p->smf92cdi);\n\t\t\t\t\t\tif (p->smf92cir]]p->smf92csr)\n\t\t\t\t\t\tprintf(\" I/O blocks read :%8.8d read calls :%d\u00d6n\",\n\t\t\t\t\t\tp->smf92cir,p->smf92csr);\n\t\t\t\t\t\tif (p->smf92ciw]]p->smf92csw)\n\t\t\t\t\t\tprintf(\" I/O blocks write :%8.8d write calls:%d\u00d6n\",\n\t\t\t\t\t\tp->smf92ciw,p->smf92csw);\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tprintf(\"'%s' r:%8.8d w:%8.8d d:%8.8d pid:%d\u00d6n\",name,p->smf92cir,p->smf92ciw,p->smf92cdi,pid->smf92pid);\n\t\t\t\t\t\ttotal_read +=p->smf92cir;\n\t\t\t\t\t\ttotal_write += p->smf92ciw;\n\t\t\t\t\t\ttotal_dir += p->smf92cdi;\n\t\t\t\t\t\tp = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\tcase 13:\n\t\t\t\t//if (*(short *)smfrcd92P(b)->smf92don)\n\t\t\t\tif (0)\n\t\t\t\t\u00e4\n\t\t\t\t\tsmf92munP p = smf92munP(b+smfrcd92P(b)->smf92dof);\n\t\t\t\t\tfor(int i=0;i<*(short*)smfrcd92P(b)->smf92don;i++)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (p->smf92mutk)\n\t\t\t\t\t\t\tprintf(\" Memory map token:%8.8d size:%8.8d read:%8.8d write:%8.8d (I/O blocks)\u00d6n\",\n\t\t\t\t\t\t\tp->smf92mutk,p->smf92musz,p->smf92muir,p->smf92muiw);\n\t\t\t\t\t\tp = smf92munP((char *)p+smfrcd92P(b)->smf92dln);\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tdefault:\n\t\t//  printf(\" invalid type\u00d6n\");\n\t\tbreak;\n\t\u00fc\n\treturn 0;\n\u00fc\n\nstatic time_t set_epoch()\n\u00e4\n\tunsigned long long t19720101 = (0x8126D60E46000000LL>>12)/1000000;\n\tstruct tm _tm;\n\tmemset(&_tm,0,sizeof(_tm));\n\t_tm.tm_year = 72;\n\t_tm.tm_isdst = 0;\n\t_tm.tm_mday = 0;\n\ttime_t r = mktime(&_tm);\n\tr = 63072000;\n\t//printf(\"epoch:%u r:%u diff:%u\u00d6n\",(unsigned long)t19720101,r,(unsigned long )(t19720101-r));\n\treturn (t19720101-r);\n\u00fc\n\nconst  time_t epoch = set_epoch();\n\n\nchar * formatTime(pULL tod)\n\u00e4\n\tstatic char w\u00c4128\u00dc;\n\tunsigned long t, rest, v, ss, mm, hh;\n\tULL tt = (*tod>>12)/1000;\n\tt =tt%(1000*60*60*24);\n\trest = t%1000;\n\tv = t/1000;\n\tss =  v%60;\n\tv /= 60;\n\tmm =  v%60;\n\thh =  v/60;\n\tsprintf(w,\"%2.2d:%2.2d:%2.2d.%3.3d\",hh,mm,ss,rest);\n\treturn w;\n\u00fc\n\n\n\nchar * var(char * v0,int i0,char * v1 = NULL,int i1 = 0, char * v2 =NULL)\n\u00e4\n\tstatic char ret\u00c4256\u00dc;\n\tstrcpy(ret,v0);\n\tsprintf(ret+strlen(ret),\".%d\",i0);\n\tif (v1)\n\t\u00e4\n\t\tstrcat(ret,\".\");\n\t\tstrcat(ret,v1);\n\n\t\tif (v2)\n\t\t\u00e4\n\t\t\tsprintf(ret+strlen(ret),\".%d\",i1);\n\t\t\tstrcat(ret,\".\");\n\t\t\tstrcat(ret,v2);\n\t\t\u00fc\n\t\u00fc\n\treturn strupr(ret);\n\u00fc\n\ntypedef struct dscb DSCB;\n\nstruct ext\n\u00e4\n\tunsigned char flag ;\n\tunsigned char seq;\n\tshort        CC;\n\tshort        HH;\n\tshort        hCC;\n\tshort        hHH;\n\u00fc;\n\ntypedef struct ext EXT;\n\nstatic char _date2Text\u00c480\u00dc;\n\nchar * date2Text(unsigned int d)\n\u00e4\n\n\tint yy =d/0x10000;\n\tint tt =d%0x10000;\n\tint day\u00c4\u00dc = \u00e431,28,31,30,31,30,31,31,30,31,30,31\u00fc;\n\tif ( yy%4 == 0 )\n\t\tday\u00c41\u00dc = 29;\n\tint i = 0;\n\tfor(i;i<12;i++)\n\t\tif ((tt-day\u00c4i\u00dc)<0) break;\n\t\telse\n\t\t\ttt-=day\u00c4i\u00dc;\n\ti++;\n\tsprintf(_date2Text,\"%4.4d/%2.2d/%2.2d\",yy+1900,i,tt);\n\treturn _date2Text;\n\u00fc\n\nint allocated(EXT * e)\n\u00e4\n\tif (e->flag ==0 )\n\t\treturn 0;\n\telse\n\t\treturn((e->hCC*15+e->hHH)-(e->CC*15+e->HH)+1);\n\u00fc\n\nunsigned int bit24Int(char * c)\n\u00e4\n\treturn(*(unsigned int *)(c-1)&0x007FFFFF);\n\u00fc\n\nstruct CatInfo\n\u00e4\n\tchar type;\n\tchar dsn\u00c444\u00dc;\n\tchar vol\u00c46\u00dc;\n\u00fc;\n\ntypedef struct CatInfo CATINFO;\n\nstruct ISPF_Stats\n\u00e4\n\tunsigned int ver:8;\n\tunsigned int mod:8;\n\tunsigned int flags:8;\n\tunsigned int mod_sec:8;\n\n\tunsigned int cr_date_rsv:8;\n\tunsigned int cr_date_y:8;\n\tunsigned int cr_date_d:12;\n\tunsigned int cr_date_f:4;\n\n\tunsigned int mod_date_rsv:8;\n\tunsigned int mod_date_y:8;\n\tunsigned int mod_date_d:12;\n\tunsigned int mod_date_f:4;\n\n\tunsigned int mod_hh:8;\n\tunsigned int mod_mm:8;\n\tshort lines;\n\n\tshort ilines;\n\tshort m_lines;\n\n\tchar user\u00c47\u00dc;\n\tchar rsvd\u00c43\u00dc;\n\u00fc;\n\ntypedef struct ISPF_Stats ISPF;\n\nint _rexxlist()\n\u00e4\n\tchar mask\u00c445\u00dc;\n\tchar mmask\u00c49\u00dc;\n\tbool dir = false;\n\tbool migr = false;\n\tbool debug = false;\n\tbool exact = false;\n\tCATINFO catinfo;\n\n\tif (argc < 2 )\n\t\treturn -1;\n\tstrcpy(mask,strupr(argv\u00c41\u00dc));\n\tfor (int i =2;i<argc;i++)\n\t\u00e4\n\t\tif ( strcasecmp(argv\u00c4i\u00dc,\"DIR\")==0)\n\t\t\u00e4\n\t\t\tdir = true;\n\t\t\tif (i+1<argc)\n\t\t\t\tstrcpy(mmask,strupr(argv\u00c4++i\u00dc));\n\t\t\telse\n\t\t\t\tstrcpy(mmask,\"*\");\n\t\t\u00fc\n\t\telse\n\t\t\tif ( strcasecmp(argv\u00c4i\u00dc,\"EXACT\")==0)\n\t\t\t\u00e4\n\t\t\t\tdir = true;\n\t\t\t\texact = true;\n\t\t\t\tif (i+1<argc)\n\t\t\t\t\tstrcpy(mmask,strupr(argv\u00c4++i\u00dc));\n\t\t\t\telse\n\t\t\t\t\tstrcpy(mmask,\"*\");\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tif (strcasecmp(argv\u00c4i\u00dc,\"MIGR\") == 0)\n\t\t\t\t\tmigr = true;\n\t\t\t\telse\n\t\t\t\t\tif (strcasecmp(argv\u00c4i\u00dc,\"DEBUG\") == 0)\n\t\t\t\t\t\tdebug = true;\n\n\t\u00fc\n\tREXXVAR rexx(debug);\n\tCmdService::debug = debug;\n\tif (debug)\n\t\tprintf(\" catalog:%s member:%s\u00d6n\",mask,mmask);\n\tDsnCmdService serv;\n\tint index = 0;\n\tint rc = serv.cmd(mask,(char *)&catinfo);\n\twhile(rc==1)\n\t\u00e4\n\t\tif (debug)\n\t\t\t_dump(\"catalog\",(char *)&catinfo,sizeof(catinfo));\n\t\tif ((catinfo.type == 'A' ]] catinfo.type == 'C'))\n\t\t\u00e4\n\t\t\tint online = memcmp(\"MIGRAT\",catinfo.vol,sizeof(catinfo.vol));\n\t\t\tindex++;\n\t\t\trexx.set(var(\"DS\",0),index);\n\t\t\trexx.set(var(\"DS\",index,\"dsn\"),catinfo.dsn,sizeof(catinfo.dsn));\n\t\t\trexx.set(var(\"DS\",index,\"vol\"),catinfo.vol,sizeof(catinfo.vol));\n\t\t\trexx.set(var(\"DS\",index,\"online\"),online);\n\t\t\trexx.set(var(\"DS\",index,\"member\"),0);\n\n\t\t\tif (online)\n\t\t\t\u00e4\n\t\t\t\tDSCB f1dscb;\n\t\t\t\tF3DSCB _f3dscb;\n\t\t\t\tmemset(&f1dscb,0,sizeof(f1dscb));\n\n\t\t\t\tmemcpy(f1dscb.ds1dsnam,(char *)catinfo.dsn,sizeof(catinfo.dsn));\n\t\t\t\tif (mvs()->Obtain((const char *)f1dscb.ds1dsnam,catinfo.vol,(char *)&f1dscb.ds1fmtid)==0)\n\t\t\t\t\u00e4\n\t\t\t\t\trexx.set(var(\"DS\",index,\"credt\"),date2Text(bit24Int((char *)f1dscb.ds1credt)));\n\t\t\t\t\trexx.set(var(\"DS\",index,\"expdt\"),date2Text(bit24Int((char *)f1dscb.ds1expdt)));\n\t\t\t\t\trexx.set(var(\"DS\",index,\"refdt\"),date2Text(bit24Int((char *)f1dscb.ds1refd)));\n\n\t\t\t\t\tif (f1dscb.ds1dsorg\u00c40\u00dc&ds1dsgps)\n\t\t\t\t\t\trexx.set(var(\"DS\",index,\"dsorg\"),\"PS\");\n\t\t\t\t\telse\n\t\t\t\t\t\tif (f1dscb.ds1dsorg\u00c40\u00dc&ds1dsgpo)\n\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"dsorg\"),\"PO\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (f1dscb.ds1dsorg\u00c40\u00dc&ds1acbm)\n\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"dsorg\"),\"VSAM\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"dsorg\"),\"????\");\n\t\t\t\t\tchar recfm\u00c4\u00dc = \" \";\n\t\t\t\t\tint ind = 0;\n\t\t\t\t\tif (f1dscb.ds1recfm==ds1recfu)\n\t\t\t\t\t\trecfm\u00c40\u00dc = 'U';\n\t\t\t\t\telse\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (f1dscb.ds1recfm&ds1recff)\n\t\t\t\t\t\t\trecfm\u00c40\u00dc = 'F';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (f1dscb.ds1recfm&ds1recfv)\n\t\t\t\t\t\t\t\trecfm\u00c40\u00dc = 'V';\n\t\t\t\t\t\tif (f1dscb.ds1recfm&ds1recfb)\n\t\t\t\t\t\t\trecfm\u00c4++ind\u00dc = 'B';\n\t\t\t\t\t\tif (f1dscb.ds1recfm&ds1recfa)\n\t\t\t\t\t\t\trecfm\u00c4++ind\u00dc ='A';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (f1dscb.ds1recfm&ds1recmc)\n\t\t\t\t\t\t\t\trecfm\u00c4++ind\u00dc ='M';\n\t\t\t\t\t\u00fc\n\t\t\t\t\trecfm\u00c4ind+1\u00dc = 0;\n\t\t\t\t\trexx.set(var(\"DS\",index,\"recfm\"),recfm);\n\t\t\t\t\trexx.set(var(\"DS\",index,\"blksize\"),int(*(short *)f1dscb.ds1blkl));\n\t\t\t\t\trexx.set(var(\"DS\",index,\"lrecl\"),int(*(short *)f1dscb.ds1lrecl));\n\t\t\t\t\tint alloc = allocated((EXT *)f1dscb.ds1ext1)+\n\t\t\t\t\t\tallocated((EXT *)f1dscb.ds1ext2)+\n\t\t\t\t\t\tallocated((EXT *)f1dscb.ds1ext3);\n\t\t\t\t\tmemcpy(_f3dscb.ds3ptrds,f1dscb.ds1ptrds,5);\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\t_dump(\"F3DSCB addr\",(char *)&_f3dscb.ds3ptrds,5);\n\t\t\t\t\twhile (memcmp(_f3dscb.ds3ptrds,nulls,5)&&(mvs()->Obtain((const char *)_f3dscb.ds3ptrds,catinfo.vol,(char *)&_f3dscb)==0))\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\t_dump(\"F3DSCB\",(char *)&_f3dscb,sizeof(_f3dscb));\n\t\t\t\t\t\tEXT *  ext = (EXT * )&_f3dscb.ds3extnt;\n\t\t\t\t\t\tfor (int i =0;i<4;i++)\n\t\t\t\t\t\t\talloc+= allocated(ext+i);\n\t\t\t\t\t\text = (EXT * )&_f3dscb.ds3adext;\n\t\t\t\t\t\tfor (int i =0;i<9;i++)\n\t\t\t\t\t\t\talloc+= allocated(ext+i);\n\t\t\t\t\t\u00fc\n\t\t\t\t\trexx.set(var(\"DS\",index,\"alloc\"),alloc);\n\t\t\t\t\tif (dir&&(f1dscb.ds1dsorg\u00c40\u00dc&ds1dsgpo))\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tchar pattern\u00c4128\u00dc=\"//\";\n\t\t\t\t\t\tmemcpy(pattern+2,catinfo.dsn,sizeof(catinfo.dsn));\n\t\t\t\t\t\tpattern\u00c446\u00dc =0;\n\t\t\t\t\t\tif (strchr(pattern,' '))\n\t\t\t\t\t\t\t*strchr(pattern,' ') = 0;\n\n\t\t\t\t\t\tstrcat(pattern,\"(*)\");\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tstrcat(pattern,\"(\");\n\t\t\t\t\t\tstrcat(pattern,mmask);\n\t\t\t\t\t\tstrcat(pattern,\")\");\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tDSNINFO dsninfo;\n\t\t\t\t\t\tint mindex = 0;\n\t\t\t\t\t\tmemset(&dsninfo,0,sizeof(dsninfo));\n\t\t\t\t\t\tint rcd = osdfind(&dsninfo,pattern);\n\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tprintf(\" osdfind:%s %d\u00d6n\",pattern,rcd);\n\t\t\t\t\t\t\t_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\twhile(rcd>=0)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tif ((|exact&&stcpma(dsninfo.mem,mmask))]](exact&&strcmp(dsninfo.mem,mmask)==0))\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tmindex++;\n\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\"),mindex);\n\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"name\"),dsninfo.mem);\n\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"alias\"),dsninfo.alias);\n\n\t\t\t\t\t\t\t\tif (dsninfo.user_data_halfwords*2 == sizeof(ISPF))\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tISPF * ispf =(ISPF *)dsninfo.user_data;\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"size\"),ispf->lines);\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"user\"),ispf->user);\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"created\"),date2Text(cvb(ispf->cr_date_y,2)*0x10000+cvb(ispf->cr_date_d,3)));\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"modified\"),date2Text(cvb(ispf->mod_date_y,2)*0x10000+cvb(ispf->mod_date_d,3)));\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"size\"),\"\");\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"user\"),\"\");\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"created\"),\"\");\n\t\t\t\t\t\t\t\t\trexx.set(var(\"DS\",index,\"member\",mindex,\"modified\"),\"\");\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\trcd = osdnext(&dsninfo);\n\t\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tprintf(\" osdnext:%s %d\u00d6n\",pattern,rcd);\n\t\t\t\t\t\t\t\t_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tosdquit(&dsninfo);\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\trexx.set(var(\"DS\",index,\"credt\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"expdt\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"refdt\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"dsorg\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"recfm\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"lrecl\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"blksize\"),\"\");\n\t\t\t\t\trexx.set(var(\"DS\",index,\"alloc\"),\"\");\n\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\trc = serv.cmd(NULL,(char *)&catinfo);\n\t\u00fc\n\u00fc\n\n#define DEF_TAB_SIZE  128000\nclass tablePull\n\u00e4\nprivate:\n\tchar tablename\u00c4256\u00dc;\n\tFILE * table;\n\tchar * t;\n\tchar * p ;\n\tsize_t rl;\n\tsize_t total ;\n\tsize_t offset;\n\tbool ok;\n\npublic:\n\ttablePull(const char *n)\n\t\u00e4\n\t\tchar w\u00c4256\u00dc;\n\t\tok = false;\n\t\tstrcpy(tablename,n);\n\t\ttable = fopen(genOpenName(tablename,w),\"rb\");\n\t\tif (table==NULL)\n\t\t\u00e4\n\t\t\tprintf(\" unbale to open:%s\u00d6n\",tablename);\n\t\t\treturn ;\n\t\t\u00fc\n\t\tt  = (char *)malloc(DEF_TAB_SIZE);\n\t\tp = t;\n\t\ttotal = DEF_TAB_SIZE;\n\t\trl = total;\n\n\t\tif (t==NULL)\n\t\t\u00e4\n\t\t\tprintf(\" unbale to allocte:%s bytes\u00d6n\",total);\n\t\t\treturn ;\n\t\t\u00fc\n\t\tbool cont = true;\n\n\t\twhile(cont)\n\t\t\u00e4\n\t\t\tsize_t rlr =fread(p,1,rl,table);\n\t\t\tif (rlr>=0)\n\t\t\t\ttotal +=rlr;\n\t\t\tif (feof(table)]]rlr<rl)\n\t\t\t\tcont = false;\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tt =(char *)realloc(t,total*2);\n\t\t\t\tp = t+rl;\n\t\t\t\trl = total;\n\t\t\t\ttotal*=2;\n\t\t\t\tif (t==NULL)\n\t\t\t\t\u00e4\n\t\t\t\t\tprintf(\" unbale to allocte:%s bytes\u00d6n\",total);\n\t\t\t\t\treturn ;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tfclose(table);\n\t\toffset = 0;\n\t\tok = true;\n\t\tp = t;\n\t\u00fc\n\n\tunsigned short getShort()\n\t\u00e4\n\t\tif  ((total-offset)>sizeof(short))\n\t\t\u00e4\n\t\t\tunsigned short r = *(unsigned short *)p;\n\t\t\tp+=sizeof(short);\n\t\t\toffset-=sizeof(short);\n\t\t\treturn r;\n\t\t\u00fc\n\t\telse\n\t\t\treturn -1;\n\t\u00fc\n\n\tchar * getString(size_t l)\n\t\u00e4\n\t\tif  ((total-offset)>l)\n\t\t\u00e4\n\t\t\tchar * c = (char *)malloc(l+1);\n\t\t\tmemcpy(c,p,l);\n\t\t\tc\u00c4l\u00dc = 0;\n\t\t\tp+=l;\n\t\t\toffset-=l;\n\t\t\treturn c;\n\t\t\u00fc\n\t\telse\n\t\t\tabort();\n\t\treturn NULL;\n\t\u00fc\n\n\tbool isOk()\n\t\u00e4\n\t\treturn ok;\n\t\u00fc\n\u00fc;\n\nint _rexx4tab()\n\u00e4\n\tbool debug = false;\n\tfor (int i =3;i<argc;i++)\n\t\u00e4\n\t\tif (strcasecmp(argv\u00c4i\u00dc,\"DEBUG\") == 0)\n\t\t\tdebug = true;\n\n\t\u00fc\n\tREXXVAR rexx(debug);\n\tchar * variables\u00c4256\u00dc;\n\tchar  table\u00c49\u00dc;\n\tsize_t numrows = 0;\n\tmemset(&variables,0,sizeof(variables));\n\ttablePull pull(argc<2?\"//DD:TABLE\":argv\u00c41\u00dc);\n\t//tablePull pull(\"//esa.maint.isptlib(infocust)\");\n\n\tchar * tablename = (argc<3?\"TABLE\":argv\u00c42\u00dc);\n\tif (|pull.isOk())\n\t\treturn 8;\n\tchar * head =pull.getString(pull.getShort());\n\tmemcpy(table,head+10,8);\n\tnumrows = *(size_t *)(head+32);\n\tshort temp = pull.getShort();\n\tchar * cols = pull.getString(temp);\n\tsize_t numcols = temp/16;\n\trexx.set(var(tablename,0),numrows);\n\trexx.set(var(tablename,0,\"TABLE\"),table);\n\trexx.set(var(tablename,0,\"COLS\",0),numcols);\n\tfor (int o =0 , i=0;cols\u00c4o\u00dc;o+=16,i++)\n\t\u00e4\n\t\tvariables\u00c4i\u00dc =(char *) malloc(9);\n\t\tmemset(variables\u00c4i\u00dc,0,9);\n\t\tfor (int j=0;j<8&&(*(cols+o+2+j)-' ');j++)\n\t\t\t*(variables\u00c4i\u00dc+j) = *(cols+o+2+j);\n\t\trexx.set(var(tablename,0,\"COLS\",i+1,\"NAME\"),variables\u00c4i\u00dc);\n\t\u00fc\n\tshort rl = 0;\n\tsize_t rowindex = 0;\n\twhile((rl=pull.getShort()) >0&& rowindex<numrows)\n\t\u00e4\n\t\tchar * row = pull.getString(rl);\n\t\tshort numvar = *(short *)(row+4);\n\t\tfree(row);\n\t\tshort rowDataLength =pull.getShort();\n\t\tchar * rowdata =pull.getString(rowDataLength);\n\t\trowindex++;\n\t\tfor(int i =0;i<numvar;i++)\n\t\t\u00e4\n\t\t\tshort offset = (*(short *)(rowdata+i*2))-22;\n\t\t\tif (offset>0&&offset<rowDataLength)\n\t\t\t\u00e4\n\t\t\t\tshort length = *(short *)(rowdata+offset);\n\t\t\t\tif (length > 0&& (offset+length)<rowDataLength)\n\t\t\t\t\u00e4\n\t\t\t\t\tchar * value =(char *)malloc(length+1);\n\t\t\t\t\tmemcpy(value,rowdata+offset+2,length);\n\t\t\t\t\tvalue\u00c4length\u00dc = 0;\n\t\t\t\t\trexx.set(var(tablename,rowindex,variables\u00c4i\u00dc),value,length);\n\t\t\t\t\tfree(value);\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\trexx.set(var(tablename,rowindex,variables\u00c4i\u00dc),\"\");\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\trexx.set(var(tablename,rowindex,variables\u00c4i\u00dc),\"\");\n\n\t\t\u00fc\n\t\tfree(rowdata);\n\t\tfree(row);\n\t\u00fc\n\u00fc\nint intDebug = 0;\n\nchar * cmdnext(UssCmdService &cmd,char * w=NULL)\n\u00e4\n\tchar * c =cmd.next(w);\n\t//  if (intDebug)\n\t//  printf(\"%s\u00d6n\",c);\n\treturn c;\n\u00fc\n_browselogger()\n\u00e4\n\tprintf(\" Browse %s loggerstream %s direction\u00d6n\",argv\u00c42\u00dc,(atoi(argv\u00c43\u00dc)==0?\"oldtoyoung\":\"youngtoold\"));\n\tint rc = mvs()->LoggerOpen(argv\u00c42\u00dc);\n\tconst char * pointer = NULL;\n\tchar date\u00c432\u00dc;\n\t*(int *)date =(13*3600+1*60+1)*100;\n\tstrcpy(date+4,\"2010242\");\n\tsize_t length = 0;\n\tsize_t * lP   = &length;\n\tpasm PASM = NULL;\n\t//BrowseLogger(const char * & addr,size_t & length,int direction,int all,char * date_time)\n\t//return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)date_time));\n\n\t/* 18/11/05 LOGGER support\n\t* 13/01/06 browse logger\n\t*---------------------------------------------------------------------*\n\t* LOGGER support                                                     *\n\t* +0 0 connect to logger stream                                      *\n\t*  -1 discoonect                                                     *\n\t*   1 log a request                                                  *\n\t*   2 read logger from oldtoyoung                                    *\n\t*   3 read log from youngtoold (parm+8 contain addr , length)        *\n\t*   a stream to log                                                  *\n\t* +4 stream or logger name address                                   *\n\t* +8 length of the stream                                            *\n\t* +c time stemp field pointer                                        *\n\t*   +0 binary time value in .01 sec                                  *\n\t*   +4 DATE in YYYYDDD    char format                                *\n\t*---------------------------------------------------------------------*/\n\n\twhile (rc=mvs()->BrowseLogger(pointer,lP,atoi(argv\u00c43\u00dc),atoi(argv\u00c44\u00dc),NULL)==0)\n\t\u00e4\n\t\tPASM = mvs()->getpasm();\n\t\t//if (debugF)\n\n\t\tif (0)\n\t\t\u00e4\n\t\t\t_dump(\"logger rc\",(char *)&(PASM->asm_rc),256);\n\t\t\t_dump(\"asm logger\",(char *)&(PASM->asm_logger_length),\n\t\t\t\t(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));\n\t\t\t_dump(\" ASM LOGGER\",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));\n\t\t\t_dump(\" ASM ansarea\",(char *)PASM->asm_ansarea,40);\n\t\t\tprintf(\" RC:%d REASON:%d(%8.8x)\u00d6n\",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);\n\t\t\u00fc\n\t\tunsigned short ubl = *(unsigned short *)pointer;\n\t\tint bl = ubl;\n\t\tbl-=4;\n\t\t//if (debugF)\n\n\t\tif (0)\n\t\t\tprintf(\"length:%u bl:%d ubl:%u\u00d6n\",length,bl,ubl);\n\t\tchar * p = (char *)pointer+4;\n\t\twhile(bl>0)\n\t\t\u00e4\n\t\t\tunsigned short url;\n\t\t\turl = *(unsigned short *)p;\n\t\t\tint rl = url;\n\t\t\t//  if (debugF)\n\t\t\t//    printf(\"head length:%u\u00d6n\",rl);\n\t\t\tif (rl==72)\n\t\t\t\u00e4\n\t\t\t\t//  if (debugF)\n\t\t\t\t//    _dump(\"head\",p,rl);\n\t\t\t\tp+=rl;\n\t\t\t\tbl-=rl;\n\t\t\t\tlength-=rl;\n\t\t\t\trl = *(short *)p;\n\t\t\t\tif (bl >0 && rl>0 && bl>rl)\n\t\t\t\t\u00e4\n\t\t\t\t\t//  if (debugF)\n\t\t\t\t\t//  printf(\"rec length:%u (bl:%d)\u00d6n\",rl,bl);\n\t\t\t\t\t//  if (debugF)\n\t\t\t\t\t//    _dump(\"SMF rec\",p,rl);\n\t\t\t\t\tbool idflag = false;\n\t\t\t\t\tif (printSMF(p,idflag,rl)==5)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tp+=rl;\n\t\t\t\t\tbl-=rl;\n\t\t\t\t\tlength=-rl;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\t//printf(\" rc:%d p:%p l:%d\u00d6n\",rc,pointer,length);\n\t\u00fc\n\t//printf(\" rc:%d p:%p l:%d\u00d6n\",rc,pointer,length);\n\tif (debugF)\n\t\u00e4\n\t\t_dump(\"asm logger\",(char *)&(PASM->asm_logger_length),\n\t\t\t(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));\n\t\t_dump(\" ASM LOGGER\",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));\n\t\t_dump(\" ASM ansarea\",(char *)PASM->asm_ansarea,40);\n\t\tprintf(\" RC:%d REASON:%d(%8.8x)\u00d6n\",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);\n\t\u00fc\n\tmvs()->LoggerClose();\n\tfor(int i =0;i<255;i++)\n\t\tif (counters\u00c4i\u00dc)\n\t\t\tprintf(\" SMF type:%d, records:%d\u00d6n\",i,counters\u00c4i\u00dc);\n\treturn 0;\n\u00fc\n\nint _rct()\n\u00e4\n\tcvtP      cvt = *(cvtP* )0x10;\n\trmctP   rmct = (rmctP)cvt->cvtopctp;\n\tcctP     cct  = (cctP)rmct->rmctcct;\n\tictP     ict  = (ictP)rmct->rmctict;\n\tmctP     mct  = (mctP)rmct->rmctmct;\n\tchar buff\u00c4256\u00dc;\n\tbuff\u00c40\u00dc =0;\n\tFILE * reply = popen(\"uname -Ia\",\"r\");\n\tif (reply==NULL]]fgets(buff,sizeof(buff),reply)<=0)\n\t\tprintf(\" popen error %s\u00d6n\",strerror(errno));\n\telse\n\t\tfclose(reply);\n\n\tprintf(\"System:%s Online CPU Count:%d RealStorage Size:%d (Mbyte)\u00d6n\",buff,cct->ccvrcpct,cvt->cvtrlstg/1024);\n\tint lihb = ict->icvslihb;\n\tint pib = ict->iccend._icvtpib;\n\tfor(int i =0;i<6;i++)\n\t\u00e4\n\t\tsleep(10);\n\t\tchar tt\u00c432\u00dc;\n\t\tchar fm\u00c4\u00dc = \"%H:%M:%S \";\n\t\tformatTime(tt,sizeof(tt),fm);\n\t\tprintf(\" %s ======================================\u00d6n CPU utilization:%d %% Available Frame Count:%d \u00d6n\",tt,cct->ccvutilp,cct->ccvlgfmc);\n\t\tprintf(\" I/O interrupt rates:: % d %d\u00d6n\",ict->icvslihb-lihb,ict->iccend._icvtpib-pib);\n\t\tprintf(\" Paging Rate:%d\u00d6n\",mct->mcvsipr);\n\t\t_dump(\"CCT\",(char *)cct,sizeof(*cct));\n\t\tlihb = ict->icvslihb;\n\t\tpib = ict->iccend._icvtpib;\n\t\u00fc\n\treturn 0;\n\u00fc\n\nint _spawn()\n\u00e4\n\tpid_t child;\n\tstruct inheritance inherit;\n\tmemset(&inherit,0,sizeof(inherit));\n\tint fd_count =  0;\n\tint fd_map\u00c41\u00dc ;\n\n\tconst char *c_argv\u00c410\u00dc, *c_envp\u00c410\u00dc;\n\tc_argv\u00c40\u00dc=\"mvsproc\";\n\tint i = 0;\n\tfor (i =1;i<=argc&&i<10;i++)\n\t\tc_argv\u00c4i\u00dc = argv\u00c4i\u00dc;\n\tc_argv\u00c4++i\u00dc = 0;\n\tchar w\u00c4256\u00dc;\n\tsprintf(w,\"_BPX_ACCOUNT=%s\",argv\u00c41\u00dc);\n\tc_envp\u00c40\u00dc=w;\n\tc_envp\u00c41\u00dc=\"_BPX_SHAREAS=NO\";\n\tc_envp\u00c42\u00dc=\"_BPX_JOBNAME=TTTTTTTT\";\n\tc_envp\u00c43\u00dc=NULL;\n\n\t/* Spawn the child process */\n\tchild=spawnp(\"mvsproc\", fd_count, NULL, &inherit, c_argv, c_envp);\n\tif(child==-1)\n\t\u00e4\n\t\tprintf(\"spawn error:%s\u00d6n\",strerror(errno));\n\t\treturn(8);\n\t\u00fc\n\tprintf(\" child:%d\u00d6n\",child);\n\tint status = 0;\n\tif (wait(&status)==-1)\n\t\tprintf(\" wait error:%s\",strerror(errno));\n\treturn 0;\n\u00fc\n\nint _spawned()\n\u00e4\n\t//FILE *fp=fopen(\"spawntest.out\",\"w\");\n\tint i = 0;\n\tprintf( \"Environment:\u00d6n\");\n\tchar *e = 0;\n\tchar **env=environ;\n\n\twhile(e=env\u00c4i++\u00dc)\n\t\tprintf( \"%s\u00d6n\", e);\n\tprintf( \"\u00d6n\u00d6n\");\n\ti=0;\n\tprintf(\"Args:\u00d6n\");\n\twhile(e=argv\u00c4i++\u00dc)\n\t\tprintf(\"%s\u00d6n\", e);\n\tprintf(\"\u00d6n\u00d6n\");\n\treturn 0;\n\n\u00fc\n\nint _brsmf()\n\u00e4\n\treturn _browselogger();\n\u00fc\n\n\ntypedef struct r79cchnl * R79celem;\ntypedef struct smf79pro * Smf79pro;\ntypedef struct r79cchnl   R79cchnl;\ntypedef struct r793     * R793;\n#if (0)\n'00'X='00X:UNKNOWN'                              /*UNDEF*/\n'01'X='01X:PARALLEL BLOCK MPX'                   /*BLOCK*/\n'02'X='02X:PARALLEL BYTE MPX'                    /*BYTE*/\n'03'X='03X:ESCON POINT TO POINT'                 /*CNC_P*/\n'04'X='04X:ESCON SWITCHED OR POINT TO POINT'     /*CNC_?*/\n'05'X='05X:ESCON SWITCHED POINT TO POINT'        /*CNC_S*/\n'06'X='06X:ESCON PATH TO A BLOCK CONVERTER'      /*CVC*/\n'07'X='07X:NATIVE INTERFACE'                     /*NTV*/\n'08'X='08X:CTC POINT TO POINT'                   /*CTC_P*/\n'09'X='09X:CTC SWITCHED POINT TO POINT'          /*CTC_S*/\n'0A'X='0AX:CTC SWITCHED OR POINT TO POINT'       /*CTC_?*/\n'0B'X='0BX:COUPLING FACILITY SENDER'             /*CFS*/\n'0C'X='0CX:COUPLING FACILITY RECEIVER'           /*CFR*/\n'0D'X='0DX:UNKNOWN'                              /*UNDEF*/\n'0E'X='0EX:UNKNOWN'                              /*UNDEF*/\n'0F'X='0FX:ESCON PATH TO A BYTE CONVERTER'       /*CBY*/\n'10'X='10X:OSA EXPRESS'                          /*OSE*/\n'11'X='11X:OSA DIRECT EXPRESS'                   /*OSD*/\n'12'X='12X:OSA CHANNEL'                          /*OSA*/\n'13'X='13X:INTERNAL SYSTEM DEVICE'               /*ISD*/\n'14'X='14X:HSSI OPEN SYSTEM ADAPTER CHANNEL'     /*OSC*/\n'15'X='15X:ETHERNET OPEN SYSTEM ADAPTER CHANL'   /*OSN*/\n'16'X='16X:CLUSTER BUS SENDER'                   /*CBS*/\n'17'X='17X:CLUSTER BUS RECEIVER'                 /*CBR*/\n'18'X='18X:INTERNAL COUPLING ISC SENDER'         /*ICS*/\n'19'X='19X:INTERNAL COUPLING ISC RECEIVER'       /*ICR*/\n'1A'X='1AX:FICON POINT TO POINT'                 /*FC */\n'1B'X='1BX:FICON SWITCHED'                       /*FC_S*/\n'1C'X='1CX:FICON TO ESCON BRIDGE'                /*FCV*/\n'1D'X='1DX:FICON INCOMPLETE'                     /*FC_?*/\n'1E'X='1EX:DIRECT SYSTEM DEVICE'                 /*DSD */\n'1F'X='1FX:EMULATED I/O'                         /*EIO */\n'20'X='20X:RESERVED'                             /*UNDEF*/\n'21'X='21X:INTEGRATED CLUSTER BUS PEER'          /*CBP*/\n'22'X='22X:COUPLING FACILITY PEER'               /*CFP*/\n'23'X='23X:INTERNAL COUPLING PEER'               /*ICP*/\n'24'X='24X:INTERNAL QUEUED DIRECT COMM'          /*IQD*/\n'25'X='25X:FCT CHANNEL'                          /*FCP*/\n'26'X='26X:COUPLING OVER INFINIBAND'             /*CIB*/\n'30'X='30X:OSA ZBX DATA'                         /*OSX*/\n'31'X='31X:OSA ZBX MANAGEMENT'                   /*OSM*/\n#endif\n#define UINTF(n) (*(unsigned int *)(n))\n#define INTF(n) (*(signed int *)(n))\n\n//============================================================================\n\nclass line;\nclass dataset;\nclass jesJcl;\nclass DD;\nclass DDs;\nclass STEP;\n\nstatic const int k32 = 32768;\nstatic const int k1  = 1024;\n\nenum lineType\n\u00e4\n\tunknown        =0,\n\texecStmt      =1,\n\tsteplibStmt    =2,\n\tsteplibStmtConcat =3,\n\tddStmt        =4,\n\tddStmtConcat  =5,\n\tinlineStmt    =6,\n\tinlineData    =7,\n\tsysoutStmt    =8\n\u00fc;\n\n\nstatic const char * JCL_COMMENT        = \"//*\";\nstatic const char * JCL_COMMENT_XX    = \"XX*\";\nstatic const char * JCL_JES2          = \"/*\";\nstatic const char * JCL_EXEC_PGM      = \"PGM=\";\nstatic const char * JCL_EXEC_PARM     = \"PARM=\";\nstatic const char * JCL_PROC          = \"++\";\nstatic const char * JCL_SUBSTITUTION  = \"IEFC653I SUBSTITUTION JCL - \";\nstatic const char * JCL_DD_STMT       = \"DD\";\nstatic const char * JCL_EXEC_STMT     = \"EXEC\";\nstatic const char * JCL_STEPLIB_STMT  = \"STEPLIB\";\nstatic const char * JCL_SYSIN         = \"*\";\nstatic const char * JCL_SYSIN_DATA    = \"DATA\";\nstatic const char * JCL_SYSIN_DATA_DLM= \"DATA,DLM=\";\nstatic const char * JCL_SYSOUT        = \"SYSOUT=\";\n\nconst char * lineTypeText\u00c4\u00dc =\n\u00e4\n\t\"unknown\",\n\t\"execStmt\",\n\t\"steplibStmt\",\n\t\"steplibStmtConcat\",\n\t\"ddStmt\",\n\t\"ddStmtConcat\",\n\t\"inlineStmt\",\n\t\"inlineData\",\n\t\"sysoutStmt\"\n\u00fc;\n\nconst char * datasetStatusText\u00c4\u00dc=\n\u00e4\n\t\"unknown\",\n\t\"dumpOk\",\n\t\"restoreOk\",\n\t\"markedForDump\",\n\t\"markedForRestore\",\n\t\"error\"\n\u00fc;\n\nconst  char *  datasetDispText\u00c4\u00dc =\n\u00e4\n\t\"unknownDisp\",\n\t\"temporary\",\n\t\"input\",\n\t\"output\",\n\t\"jes2\",\n\t\"instream\",\n\t\"included\",\n\t\"excluded\"\n\t\"errorDisp\",\n\tNULL\n\u00fc;\n\n\nstruct _jclType \u00e4\n\tchar * n;\n\tint   t;\n\u00fc;\n\ntypedef struct _jclType jclType;\njclType jclTypes\u00c4\u00dc=\u00e4\n\t\u00e4\"JOB\",0\u00fc,\n\t\u00e4\"OUTPUT\",1\u00fc,\n\t\u00e4\"SET\",2\u00fc,\n\t\u00e4\"INCLUDE\",3\u00fc,\n\t\u00e4\"JCLLIB\",4\u00fc,\n\t\u00e4\"IF\",5\u00fc,\n\t\u00e4\"ENDIF\",6\u00fc,\n\t\u00e4\"ELSE\",7\u00fc,\n\t\u00e4\"COMMAND\",8\u00fc,\n\t\u00e4\"JOBLIB\",9\u00fc,\n\t\u00e4\"CTL\",10\u00fc,\n\t\u00e4\"ENDCTL\",11\u00fc,\n\t\u00e4\"XMIT\",12\u00fc,\n\t\u00e4\"PROC\",13\u00fc,\n\t\u00e4\"PEND\",14\u00fc,\n\t\u00e4\"EXEC\",20\u00fc,\n\t\u00e4\"DD\",24\u00fc,\n\t\u00e4NULL,-1\u00fc\n\u00fc;\n\nstatic const int TYPE_EXEC = 20;\nstatic const int TYPE_DD   = 24;\nstatic const int oS = 10;\nstatic const int oN = 12;\n\nstatic char actualStepName\u00c49\u00dc;\nstatic char actualProcstepName\u00c49\u00dc;\nstatic STEP * actualStep;\n\nclass line:public chainE\n\u00e4\nprivate:\n\tDD * ddP;\n\tdataset * datasetP;\n\tlineType type;\npublic:\n\tline(const char *);\n\t\u00dfline()\n\t\u00e4\u00fc\n\tlineType getLineType()\n\t\u00e4\n\t\treturn type;\n\t\u00fc\n\tchar * getLine()\n\t\u00e4\n\t\treturn chainEid;\n\t\u00fc\n\tDD * getDD()\n\t\u00e4\n\t\treturn ddP;\n\t\u00fc\n\tdataset * getDataset()\n\t\u00e4\n\t\treturn datasetP;\n\t\u00fc\n\u00fc;\n\nclass DD:public chainE\n\u00e4\nprivate:\n\tint index;\n\tline *   lineP;\n\tchar *   member;\npublic:\n\tDD(char * n,int i = 0,line * l = NULL):chainE(n)\n\t\u00e4\n\t\tJOBENV::DEBUG(1,\"DD:\",n);\n\t\tindex = i;\n\t\tlineP = l;\n\t\tmember = NULL;\n\t\u00fc\n\t\u00dfDD()\u00e4\u00fc\n\tvoid setMember(const char * m)\n\t\u00e4\n\t\tmember = strdup(m);\n\t\u00fc\n\tchar * getMember()\n\t\u00e4\n\t\treturn member;\n\t\u00fc\n\tint getIndex()\n\t\u00e4\n\t\treturn index;\n\t\u00fc\n\tvoid setIndex(int i)\n\t\u00e4\n\t\tindex = i;\n\t\u00fc\n\tchar * put(char * b)\n\t\u00e4\n\t\tsprintf(b,\"%s Type:%s Concat:%d Member:%s \",\n\t\t\tchainEid,\n\t\t\tlineTypeText\u00c4int(lineP->getLineType())\u00dc,\n\t\t\tindex,\n\t\t\t(member?member:\"\"));\n\t\treturn b;\n\t\u00fc\n\tline * getLine()\n\t\u00e4\n\t\treturn lineP;\n\t\u00fc\n\u00fc;\n\nclass DDs:public mCHAIN\n\u00e4\npublic:\n\tstatic char lastdd\u00c49\u00dc;\n\tstatic  int concatIndex;\n\tDDs():mCHAIN()\n\t\u00e4\n\t\tmemset(lastdd,0,sizeof(lastdd));\n\t\tconcatIndex = 0;\n\t\u00fc\n\t\u00dfDDs()\u00e4\u00fc\n\u00fc;\n\n\nclass dataset:public chainE\n\u00e4\npublic:\n\tenum datasetDisp\n\t\u00e4\n\t\tunknownDisp,\n\t\ttemporary,\n\t\tinput,\n\t\toutput,\n\t\tjes2,\n\t\tinstream,\n\t\tincluded,\n\t\texcludedDisp,\n\t\terrorDisp\n\t\u00fc;\n\tenum datasetStatus\n\t\u00e4\n\t\tunknown,\n\t\tdumpOk,\n\t\trestoreOk,\n\t\tmarkedForDump,\n\t\tmarkedForRestore,\n\t\terror\n\t\u00fc;\nprivate:\n\tDD * ddList\u00c4256\u00dc;\n\tint iDdnames;\n\tdatasetDisp  disp;\n\tdatasetStatus status;\n\tchar * newDsn;\n\tlong long size;\n\npublic:\n\tstatic datasetStatus name2Status(const char * n)\n\t\u00e4\n\t\tif (strcasecmp(n,\"unknown\")==0)\n\t\t\treturn unknown;\n\t\telse\n\t\t\tif (strcasecmp(n,\"dumpOk\")==0)\n\t\t\t\treturn dumpOk;\n\t\t\telse\n\t\t\t\tif (strcasecmp(n,\"restoreOk\")==0)\n\t\t\t\t\treturn restoreOk;\n\t\t\t\telse\n\t\t\t\t\tif (strcasecmp(n,\"markedForDump\")==0)\n\t\t\t\t\t\treturn markedForDump;\n\t\t\t\t\telse\n\t\t\t\t\t\tif (strcasecmp(n,\"markedForRestore\")==0)\n\t\t\t\t\t\t\treturn markedForRestore;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn error;\n\t\u00fc\n\n\tstatic datasetDisp name2Disp(const char *n)\n\t\u00e4\n\t\tif (strcasecmp(n,\"unknown\")==0)\n\t\t\treturn unknownDisp;\n\t\telse\n\t\t\tif (strcasecmp(n,\"temporary\")==0)\n\t\t\t\treturn temporary;\n\t\tif (strcasecmp(n,\"input\")==0)\n\t\t\treturn input;\n\t\telse\n\t\t\tif (strcasecmp(n,\"output\")==0)\n\t\t\t\treturn output;\n\t\t\telse\n\t\t\t\tif (strcasecmp(n,\"jes2\")==0)\n\t\t\t\t\treturn jes2;\n\t\t\t\telse\n\t\t\t\t\tif (strcasecmp(n,\"instream\")==0)\n\t\t\t\t\t\treturn instream;\n\t\t\t\t\telse\n\t\t\t\t\t\tif (strcasecmp(n,\"included\")==0)\n\t\t\t\t\t\t\treturn included;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (strcasecmp(n,\"excluded\")==0)\n\t\t\t\t\t\t\t\treturn excludedDisp;\n\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn errorDisp;\n\t\u00fc\n\n\tdataset(const char * n):chainE(n)\n\t\u00e4\n\t\tJOBENV::DEBUG(1,\"dataset:\",(char *)n);\n\t\tstatus = unknown;\n\t\tdisp = unknownDisp;\n\t\tmemset(ddList,0,256*4);\n\t\tiDdnames = 0;\n\t\tsize = 0;\n\t\tnewDsn = \"\";\n\t\u00fc\n\t\u00dfdataset()\n\t\u00e4\u00fc\n\tvoid setNextDd(DD *d)\n\t\u00e4\n\t\tddList\u00c4iDdnames++\u00dc = d;\n\t\tif (iDdnames>255)\n\t\t\tabort();\n\t\u00fc\n\tvoid setStatus(datasetStatus s)\n\t\u00e4\n\t\tstatus = s;\n\t\u00fc\n\tvoid setDisp(datasetDisp d)\n\t\u00e4\n\t\tdisp=d;\n\t\u00fc\n\tDD * getFirstDd()\n\t\u00e4\n\t\tiDdnames = 0;\n\t\treturn ddList\u00c4iDdnames++\u00dc;\n\t\u00fc\n\tDD * getNextDd()\n\t\u00e4\n\t\treturn ddList\u00c4iDdnames++\u00dc;\n\t\u00fc\n\tdatasetStatus getStatus()\n\t\u00e4\n\t\treturn status;\n\t\u00fc\n\tdatasetDisp getDisp()\n\t\u00e4\n\t\treturn disp;\n\t\u00fc\n\tchar * getDsn()\n\t\u00e4\n\t\treturn chainEid;\n\t\u00fc\n\tchar * getNewDsn()\n\t\u00e4\n\t\treturn newDsn;\n\t\u00fc\n\tvoid setNewDsn(const char * n)\n\t\u00e4\n\t\tnewDsn = strdup(n);\n\t\u00fc\n\tlong long getSize()\n\t\u00e4\n\t\treturn size;\n\t\u00fc\n\tvoid setSize(long long s)\n\t\u00e4\n\t\tsize = s;\n\t\u00fc\n\tchar * put(char *b)\n\t\u00e4\n\t\tsprintf(b,\"%s Status:%s Disp:%s NewName:%s DDnames:\",chainEid,\n\t\t\tdatasetStatusText\u00c4int(status)\u00dc,\n\t\t\tdatasetDispText\u00c4int(disp)\u00dc,\n\t\t\tnewDsn);\n\t\tfor(int i =0;i<iDdnames;i++)\n\t\t\tsprintf(b+strlen(b),\" %s \",ddList\u00c4i\u00dc->chainEid);\n\t\treturn b;\n\t\u00fc\n\tbool excluded()\n\t\u00e4\n\t\tint r = 0;\n\t\treturn ((r>0)?true:false);\n\t\u00fc\n\tbool restore()\n\t\u00e4\n\t\treturn true;\n\t\u00fc\n\tbool rename()\n\t\u00e4\n\t\treturn true;\n\t\u00fc\n\u00fc;\n\n\nclass datasets:public mCHAIN\n\u00e4\npublic:\n\tdatasets():mCHAIN()\n\t\u00e4\u00fc\n\t\u00dfdatasets()\n\t\u00e4\u00fc\n\tvoid restored(const char * ,int);\n\tvoid dumped(const char *,int);\n\tvoid setSize(const char *,long long);\n\u00fc;\n\n\n\nclass STEP:public chainE\n\u00e4\nprivate:\n\tchar * pgm;\n\tchar * parm;\n\tDDs * dds;\n\tchar * step;\n\tchar * procstep;\npublic:\n\tSTEP(const char * stepName,const char * procstepName,const char * _pgm,const char * _parm)\n\t\t:chainE(key(stepName,procstepName))\n\t\u00e4\n\t\tJOBENV::DEBUG(1,\"STEP\",chainEid);\n\t\tif (_pgm)\n\t\t\tpgm=strdup(_pgm);\n\t\tif (_parm)\n\t\t\tparm = strdup(_parm);\n\t\tJOBENV::DEBUG(1,\"PGM:\",pgm);\n\t\tJOBENV::DEBUG(1,\"PARM:\",parm);\n\t\tif (stepName)\n\t\t\tstep = strdup(stepName);\n\t\tif (procstepName)\n\t\t\tprocstep = strdup(procstepName);\n\t\tdds = new DDs;\n\t\u00fc\n\t\u00dfSTEP()\n\t\u00e4\n\t\tif (pgm)\n\t\t\tfree(pgm);\n\t\tif (parm)\n\t\t\tfree(parm);\n\t\tif (step)\n\t\t\tfree(step);\n\t\tif (procstep)\n\t\t\tfree(procstep);\n\t\t//  if (dds)\n\t\t//    delete dds;\n\t\u00fc\n\tvoid addDD(DD * dd)\n\t\u00e4\n\t\tdds->addlast(dd);\n\t\u00fc\n\tvoid print()\n\t\u00e4\n\t\tprintf(\"%s PGM:%s PARM:%s\u00d6n\",chainEid,pgm,parm);\n\t\tDD * dd = (DD *)dds->goFirst();\n\t\twhile(dd)\n\t\t\u00e4\n\t\t\tprintf(\" %s dsn:%s\u00d6n\",dd->chainEid,dd->getLine()->getDataset()->getDsn());\n\t\t\tdd = (DD *)dds->goNext();\n\t\t\u00fc\n\t\u00fc\n\tchar * getPgm()\n\t\u00e4\n\t\treturn pgm;\n\t\u00fc\n\tchar *getParm()\n\t\u00e4\n\t\treturn parm;\n\t\u00fc\n\tDDs * getDDs()\n\t\u00e4\n\t\treturn dds;\n\t\u00fc\n\tchar * getStep()\n\t\u00e4\n\t\treturn step;\n\t\u00fc\n\tchar * getProcstep()\n\t\u00e4\n\t\treturn procstep;\n\t\u00fc\nprivate:\n\tchar * key(const char * s,const char * ps)\n\t\u00e4\n\t\tchar _key\u00c418\u00dc;\n\t\tmemset(_key,0,sizeof(_key));\n\t\tsprintf(_key,\"%s.%s\",s?s:\"\",ps?ps:\"\");\n\t\treturn _key;\n\t\u00fc\n\u00fc;\n\nclass STEPs:public mCHAIN\n\u00e4\npublic:\n\tSTEPs():mCHAIN()\n\t\u00e4  \u00fc\n\t\u00dfSTEPs()\n\t\u00e4\u00fc\n\tvoid   print()\n\t\u00e4\n\t\tSTEP * step = (STEP *)goFirst();\n\t\twhile(step)\n\t\t\u00e4\n\t\t\tstep->print();\n\t\t\tstep = (STEP *)goNext();\n\t\t\u00fc\n\t\u00fc\n\u00fc;\n\nDDs dds;\nSTEPs steps;\ndatasets datasetList;\n\n\nline::line(const char *b):chainE(b)\n\u00e4\n\tddP = NULL;\n\tdatasetP = NULL;\n\ttype = unknown;\n\tJOBENV::DEBUG(1,\"line:\",(char *)b);\n\n\tmvsSTRING lin(b), prefix, label, stmt, rest, dsn, member, disp, rest1, rest2;\n\tlin.split(label,\" \",stmt,\" \",rest);\n\tprefix = label,(0,2);\n\tlabel = label(2,strlen(label)-2);\n\n\tif (strcmp(stmt,JCL_EXEC_STMT)==0)\n\t\u00e4\n\t\ttype = execStmt;\n\t\tconst char *pgmO = strstr((const char *)rest,JCL_EXEC_PGM);\n\t\tif (pgmO)\n\t\t\u00e4\n\t\t\t/*\n\t\t\tif (strcmp(prefix,JCL_PROC) == 0)\n\t\t\tstrcpy(actualProcstepName,label);\n\t\t\telse\n\t\t\tstrcpy(actualStepName,label);\n\t\t\t*/\n\t\t\tchar pgm\u00c49\u00dc;\n\t\t\tmemset(pgm,0,sizeof(pgm));\n\t\t\tfor(int i=0;i<9&&rest\u00c4strlen(JCL_EXEC_PGM)+i\u00dc-' '&&rest\u00c4strlen(JCL_EXEC_PGM)+i\u00dc-',';i++)\n\t\t\t\tpgm\u00c4i\u00dc=rest\u00c4strlen(JCL_EXEC_PGM)+i\u00dc;\n\t\t\tconst char * parmO = strstr((const char *)rest,JCL_EXEC_PARM);\n\t\t\tchar parm\u00c4256\u00dc;\n\t\t\tmemset(parm,0,sizeof(parm));\n\t\t\tchar apost=0x7D;\n\t\t\tif (parmO)\n\t\t\t\u00e4\n\t\t\t\tchar term= *(parmO+strlen(JCL_EXEC_PARM));\n\t\t\t\tif (term == '(')\n\t\t\t\t\tterm = ')';\n\t\t\t\telse\n\t\t\t\t\tif (term == '\u00d6'')\n\t\t\t\t\t\tterm = '\u00d6'';\n\t\t\t\t\telse\n\t\t\t\t\t\tterm = ' ';\n\t\t\t\tbool cont = true;\n\t\t\t\tint j =(parmO-rest)+strlen(JCL_EXEC_PARM);\n\t\t\t\tint jl = strlen((char *)rest+j);\n\t\t\t\tfor(int i = 0;cont&&(i<255)&&(j<jl);i++,j++)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (term == ' ' &&(rest\u00c4j\u00dc==' ']]rest\u00c4j\u00dc==','))\n\t\t\t\t\t\tcont = false;\n\t\t\t\t\telse\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\t//if (term== '\u00d6'' && rest\u00c4j\u00dc==term&&rest\u00c4j+1\u00dc-term)\n\t\t\t\t\t\tif (term== apost && rest\u00c4j\u00dc==term&&rest\u00c4j+1\u00dc-term)\n\t\t\t\t\t\t\tcont = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparm\u00c4i\u00dc=rest\u00c4j\u00dc;\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tactualStep = new STEP(actualStepName,actualProcstepName,pgm,parm);\n\t\t\tsteps.addlast(actualStep);\n\t\t\u00fc\n\t\u00fc\n\telse\n\t\tif (strcmp(stmt,JCL_DD_STMT)==0)\n\t\t\u00e4\n\t\t\ttype = ddStmt;\n\t\t\tif (strlen(label))\n\t\t\t\u00e4\n\t\t\t\tDDs::concatIndex = 0;\n\t\t\t\tstrcpy(DDs::lastdd,label);\n\t\t\t\tif (strcmp(label,JCL_STEPLIB_STMT)==0)\n\t\t\t\t\ttype = steplibStmt;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tif (strcmp(DDs::lastdd,JCL_STEPLIB_STMT))\n\t\t\t\t\ttype = ddStmtConcat;\n\t\t\t\telse\n\t\t\t\t\ttype = steplibStmtConcat;\n\t\t\t\tDDs::concatIndex++;\n\t\t\t\u00fc\n\t\t\tddP = new DD(DDs::lastdd,DDs::concatIndex,this);\n\t\t\tdds.addlast(ddP);\n\n\t\t\tif (actualStep)\n\t\t\t\tactualStep->addDD(ddP);\n\n\t\t\tif (strcmp(rest,JCL_SYSIN)==0]]strcmp(rest,JCL_SYSIN_DATA)==0]]\n\t\t\t\tmemcmp(JCL_SYSIN_DATA_DLM,(char *)rest,strlen(JCL_SYSIN_DATA_DLM)-1)==0)\n\t\t\t\ttype = inlineStmt;\n\t\t\telse\n\t\t\t\tif (strstr((char *)rest,JCL_SYSOUT))\n\t\t\t\t\ttype = sysoutStmt;\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\trest.parse(rest1,\"DSN=\",dsn,\",\",rest2);\n\t\t\t\t\tif (strlen(dsn))\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\t//ToDo GDG handling\n\t\t\t\t\t\tdsn.parse(dsn,\"(\",member,\")\",rest1);\n\t\t\t\t\t\tif (strlen(member))\n\t\t\t\t\t\t\tddP->setMember(member);\n\t\t\t\t\t\tdatasetP = (dataset *)datasetList.search(dsn);\n\t\t\t\t\t\tif (datasetP==NULL)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tdatasetP = new dataset(dsn);\n\t\t\t\t\t\t\tdatasetList.addlast(datasetP);\n\t\t\t\t\t\t\tif (strstr((char *)rest,\"DISP=SHR\")]]strstr((char *)rest,\"DISP=MOD\")]]strstr((char *)rest,\"DISP=KEEP\"))\n\t\t\t\t\t\t\t\tdatasetP->setDisp(dataset::input);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (dsn\u00c40\u00dc=='&')\n\t\t\t\t\t\t\t\t\tdatasetP->setDisp(dataset::temporary);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdatasetP->setDisp(dataset::output);\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tdatasetP->setNextDd(ddP);\n\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\ttype = unknown;\n\t\t\t\t\u00fc\n\t\t\u00fc\n\u00fc\n\njesJcl * jesjcl = NULL;\n\nclass jesJcl\n\u00e4\nprivate:\n\tmCHAIN lines;\n\tlineType type;\n\tbool    req;\n\tchar b\u00c4k32\u00dc;\n\tchar bw\u00c4k32\u00dc;\n\tint bOffset;\n\tFILE * file;\n\tint  t;\n\tint count ;\n\npublic:\n\tjesJcl(FILE *f)\n\t\u00e4\n\t\tJOBENV::DEBUG(1,\"JESJCL construct\");\n\t\tfile = f;\n\t\tt = -1;\n\t\tbOffset = 0;\n\t\tcount = 0;\n\t\treq = true;\n\t\u00fc\n\t\u00dfjesJcl()\n\t\u00e4\n\t\tif (file)\n\t\t\tfclose(file);\n\t\u00fc\n\tint parse();\n\tint generate(FILE *);\nprivate:\n\tvoid put(const char * format, ...)\n\t\u00e4\n\t\tva_list args;\n\t\tva_start(args,format);\n\t\tvsprintf(bw,format,args);\n\t\tif (strchr(bw,'\u00d6n'))\n\t\t\t*strchr(bw,'\u00d6n')=0;\n\t\tif (file)\n\t\t\tfprintf(file,\"%s\u00d6n\",bw);\n\t\tJOBENV::DEBUG(1,\" jcl:\",bw);\n\t\tMsg(8120)<<bw<<eol;\n\t\tva_end(args);\n\t\u00fc\n\tvoid splitLine(char * l)\n\t\u00e4\n\t\tif (strlen(l)<70)\n\t\t\tput(\"//%s\",l);\n\t\telse\n\t\t\u00e4\n\t\t\tchar * c = strchr(l,',');\n\t\t\tchar sc;\n\t\t\tif (c)\n\t\t\t\u00e4\n\t\t\t\tsc = *(c+1);\n\t\t\t\t*(c+1) = 0;\n\t\t\t\u00fc\n\t\t\tput(\"//%s\",l);\n\t\t\tif (c)\n\t\t\t\u00e4\n\t\t\t\t*(c+1)=sc;\n\t\t\t\t*c =' ';\n\t\t\t\u00fc\n\t\t\tsplitLine(c);\n\t\t\u00fc\n\t\u00fc\n\tchar * get(char *buf,size_t l)\n\t\u00e4\n\t\tchar * r = fgets(buf,l,file);\n\t\tJOBENV::DEBUG(1,buf);\n\t\treturn r;\n\t\u00fc\n\u00fc;\n\nint jesJcl::generate(FILE *f)\n\u00e4\n\t/*\n\tfile = f;\n\tCHAINITER iter(lines);\n\tput(\"//* \");\n\tput(\"//* JOB     :%s\",reqJobname);\n\tput(\"//* JOBNUMBER:%s\",reqJobnumber);\n\tput(\"//* STEP    :%s\",reqStepname);\n\tput(\"//* PROCSTEP :%s\",reqProcstep);\n\tchar tt\u00c432\u00dc;\n\tchar fm\u00c4\u00dc = \"%Y:%m:%d %H:%M:%S \";\n\tformatTime(tt,sizeof(tt),fm);\n\tput(\"//* AT      :%s\",tt);\n\tbool ok = true;\n\tline * l = NULL;\n\twhile(ok&&(l=(line *)iter.next()))\n\t\u00e4\n\tstrcpy(b,l->chainEid);\n\tJOBENV::DEBUG(1,b);\n\tswitch(l->getLineType())\n\t\u00e4\n\tcase execStmt:\n\t\u00e4\n\tb\u00c40\u00dc = b\u00c41\u00dc = '/';\n\tif (strlen(b)>72)\n\t\u00e4\n\tchar * c = strstr(b,\"PARM=\");\n\tif (c)\n\t\u00e4\n\t*c = 0;\n\tput(\"%s\",b);\n\t*c ='P';\n\tcount++;\n\tput(\"// %s\",c);\n\t\u00fc\n\telse\n\tput(\"%s\",b);\n\tcount++;\n\t\u00fc\n\tbreak;\n\tcase steplibStmt:\n\tcase steplibStmtConcat:\n\tcase ddStmt:\n\tcase ddStmtConcat:\n\tif (l->getDD()&&l->getDataset())\n\tif (|l->getDataset()->excluded())\n\t\u00e4\n\tchar w0\u00c4128\u00dc;\n\tchar wm\u00c4128\u00dc;\n\tchar wc\u00c4128\u00dc;\n\tif (l->getDD()->getMember())\n\tsprintf(wm,\"(%s)\",l->getDD()->getMember());\n\telse\n\twm\u00c40\u00dc = 0;\n\tDD * dd = l->getDataset()->getFirstDd();\n\tif (dd->getIndex())\n\t//szm20080929    sprintf(wc,\"C%7.7d\",dd->getIndex());\n\t//szm20090812    sprintf(wc,\".C%7.7d\",dd->getIndex());\n\n\tsprintf(wc,\"C%7.7d\",dd->getIndex());\n\telse\n\twc\u00c40\u00dc = 0;\n\t//put(\"//* %s\",l->getDataset()->chainEid);\n\tif (strlen(wc))\n\tsprintf(w0,\"%s.%s\",dd->chainEid,wc);\n\telse\n\tsprintf(w0,\"%s\",dd->chainEid);\n\tl->getDataset()->setNewDsn(w0);\n\tif (l->getLineType()==steplibStmt]]l->getLineType()==ddStmt)\n\tput(\"//%s DD DISP=SHR,DSN=%s..%s%s\",l->getDD()->chainEid,parm\u00c4restHQ\u00dc,w0,wm);\n\telse\n\tput(\"// DD DISP=SHR,DSN=%s..%s%s\",parm\u00c4restHQ\u00dc,w0,wm);\n\tcount++;\n\t\u00fc\n\telse\n\t//if (l->getDataset()->getDisp()==dataset::temporary)\n\tsplitLine(b+2);\n\tbreak;\n\tcase sysoutStmt:\n\t//put(\"//* %s\",l->getDataset()->chainEid);\n\tput(\"//%s DD %s\",l->getDD()->chainEid,parm\u00c4restSysout\u00dc);\n\tcount++;\n\tbreak;\n\tcase inlineStmt:\n\tcase inlineData:\n\t\u00e4\n\tchar w\u00c4128\u00dc;\n\tput(\"//* %s\",b);\n\tput(\"%s\",b);\n\tsprintf(w,\"%s(JESJCLIN)\",parm\u00c4workFileName\u00dc);\n\tFILE * jesJclinFile = fopen(genOpenName(w,b),\"r\");\n\tif (jesJclinFile)\n\t\u00e4\n\tint ok = 1;\n\tJOBENV::DEBUG(1,\"JESJCLIN read\");\n\twhile(ok>0&&fgets(b,sizeof(b),jesJclinFile))\n\t\u00e4\n\tJOBENV::DEBUG(1,b);\n\tswitch (ok)\n\t\u00e4\n\tcase 1:\n\t\u00e4\n\tmvsSTRING lin,label , stmt, rest;\n\tif (memcmp(b,\"//\",2)==0&&b\u00c42\u00dc-'*')\n\t\u00e4\n\tlin = b+2;\n\tlin.split(label,\" \",stmt,\" \",rest);\n\t\u00fc\n\tif (strcmp(label,reqStepname)==0 && strcmp(stmt,\"EXEC\")==0)\n\tok = 2;\n\t\u00fc\n\tbreak;\n\tcase 2:\n\t\u00e4\n\tmvsSTRING lin,label , stmt, rest;\n\tif (memcmp(b,\"//\",2)==0&&b\u00c42\u00dc-'*')\n\t\u00e4\n\tlin = b+2;\n\tlin.split(label,\" \",stmt,\" \",rest);\n\t\u00fc\n\tif (strcmp(label,l->getDD()->chainEid)==0 && strcmp(stmt,\"DD\")==0)\n\tok = 3;\n\t\u00fc\n\tbreak;\n\tcase 3:\n\tif (memcmp(b,\"//\",2))\n\tput(\"%s\",b);\n\telse\n\tok = 0;\n\tbreak;\n\t\u00fc\n\t\u00fc\n\tfclose(jesJclinFile);\n\t\u00fc\n\tbreak;\n\t\u00fc\n\tdefault:\n\tbreak;\n\t\u00fc\n\t\u00fc\n\t\u00fc\n\treturn count;\n\t*/\n\u00fc\n\nint jesJcl::parse()\n\u00e4\n\tchar c\u00c4k32\u00dc;\n\twhile(get(c,sizeof(c)))\n\t\u00e4\n\t\tif (memcmp(c+oS,JCL_COMMENT,strlen(JCL_COMMENT))==0]]\n\t\t\tmemcmp(c+oS,JCL_COMMENT_XX,strlen(JCL_COMMENT_XX))==0]]\n\t\t\tmemcmp(c+oS,JCL_JES2,strlen(JCL_JES2))==0)\n\t\t\tcontinue;\n\n\t\tc\u00c4oS-1\u00dc = 0;\n\t\tint seq = atoi(c);\n\t\tchar name\u00c49\u00dc;\n\t\tchar stmt\u00c49\u00dc;\n\t\tint i=0;\n\t\tint j=0;\n\t\tint o=0;\n\t\tchar stepName\u00c49\u00dc;\n\t\tchar procStep\u00c49\u00dc;\n\n\t\tif (seq)\n\t\t\u00e4\n\t\t\tif (bOffset>0)\n\t\t\t\u00e4\n\t\t\t\tlines.addlast(new line(b));\n\t\t\t\tbOffset = 0;\n\t\t\t\u00fc\n\t\t\tfor(i=0;c\u00c4oN+i\u00dc-' '&&i<8;i++)\n\t\t\t\tname\u00c4i\u00dc=c\u00c4oN+i\u00dc;\n\t\t\tname\u00c4i\u00dc =0;\n\t\t\tfor(;c\u00c4oN+i\u00dc==' '&&i<70;i++);\n\t\t\tif (i>16)\n\t\t\t\tcontinue;\n\t\t\tfor(o=oN+i,j=0;c\u00c4o+j\u00dc-' '&&j<8;j++)\n\t\t\t\tstmt\u00c4j\u00dc=c\u00c4o+j\u00dc;\n\t\t\tstmt\u00c4j\u00dc = 0;\n\t\t\tt = -1;\n\t\t\tfor(i=0;jclTypes\u00c4i\u00dc.t>=0&&strcmp(stmt,jclTypes\u00c4i\u00dc.n);i++);\n\t\t\tt = jclTypes\u00c4i\u00dc.t;\n\n\t\t\tif(jclTypes\u00c4i\u00dc.t<20)\n\t\t\t\tcontinue;\n\n\t\t\tif (t==TYPE_EXEC)\n\t\t\t\u00e4\n\t\t\t\tprocStep\u00c40\u00dc = 0;\n\t\t\t\tfor(i=o+j;i<o+j+8&&c\u00c4i\u00dc==' ';i++);\n\t\t\t\tif (memcmp(c+oS,\"++\",2)&&memcmp(c+oS,\"XX\",2))\n\t\t\t\t\tstrcpy(stepName,name);\n\t\t\t\telse\n\t\t\t\t\tstrcpy(procStep,name);\n\t\t\t\t//stop = req;\n\t\t\t\tJOBENV::DEBUG(1,\"step:\",stepName);\n\t\t\t\tJOBENV::DEBUG(1,\"procStep:\",procStep);\n\t\t\t\tstrcpy(actualStepName,stepName);\n\t\t\t\tstrcpy(actualProcstepName,procStep);\n\t\t\t\u00fc\n\t\t\tstrcpy(b,c+oS);\n\t\t\tbOffset=strlen(b);\n\t\t\tif (bOffset>0&&(memcmp(c+oS,\"++\",2)&&memcmp(c+oS,\"XX\",2)))\n\t\t\t\u00e4\n\t\t\t\tlines.addlast(new line(b));\n\t\t\t\tbOffset = 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tif (memcmp(c+oS,JCL_SUBSTITUTION,strlen(JCL_SUBSTITUTION))==0)\n\t\t\t\u00e4\n\t\t\t\tif (t==TYPE_EXEC)\n\t\t\t\t\u00e4\n\t\t\t\t\tsprintf(b,\"//%s EXEC %s\",name,c+oS+strlen(JCL_SUBSTITUTION));\n\t\t\t\t\twhile(*(c+strlen(c)-1)==','&&get(c,sizeof(c)))\n\t\t\t\t\t\tsprintf(b+strlen(b),\"%s\",c+oS);\n\t\t\t\t\tlines.addlast(new line(b));\n\t\t\t\t\tbOffset = 0;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tif (t==TYPE_DD)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tsprintf(b,\"//%s DD %s\",name,c+oS+strlen(JCL_SUBSTITUTION));\n\t\t\t\t\t\twhile((*c+strlen(c)-1)==','&&get(c,sizeof(c)))\n\t\t\t\t\t\t\tsprintf(b+strlen(b),\"%s\",c+oS);\n\t\t\t\t\t\tlines.addlast(new line(b));\n\t\t\t\t\t\tbOffset = 0;\n\t\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tsprintf(b+strlen(b),\"%s\",c+oS);\n\t\t\u00fc\n\t\u00fc\n\tif (bOffset>0)\n\t\tlines.addlast(new line(b));\n\treturn 1;\n\u00fc\n\nchar DDs::lastdd\u00c49\u00dc;\nint  DDs::concatIndex;\n\nint _rexxjcl()\n\u00e4\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\t//printf(\"starting rexxjcl\");\n\tchar filename\u00c416\u00dc;\n\tsprintf(filename,\"//DD:%s\",argv\u00c41\u00dc);\n\tREXXVAR rexx(JOBENV::debug);\n\tint stepC = 0;\n\trexx.set(var(\"JCL\",0),stepC);\n\tFILE * jclFile = fopen(filename,\"r,noseek\");\n\tif (jclFile)\n\t\u00e4\n\t\tjesjcl = new jesJcl(jclFile);\n\t\tif (|jesjcl->parse())\n\t\t\tprintf(\" parse error\");\n\t\telse\n\t\t\tif (JOBENV::debug)\n\t\t\t\tsteps.print();\n\t\tfclose(jclFile);\n\t\u00fc\n\telse\n\t\tprintf(\"file open error\");\n\tSTEP * step = (STEP *)steps.goFirst();\n\n\twhile (step)\n\t\u00e4\n\t\tstepC++;\n\t\trexx.set(var(\"JCL\",stepC,\"STEP\"),step->getStep());\n\t\trexx.set(var(\"JCL\",stepC,\"PROCSTEP\"),step->getProcstep());\n\t\trexx.set(var(\"JCL\",stepC,\"PGM\"),step->getPgm());\n\t\trexx.set(var(\"JCL\",stepC,\"PARM\"),step->getParm());\n\t\tDDs * dds = step->getDDs();\n\t\tint ddC = 0;\n\t\tif (dds)\n\t\t\u00e4\n\t\t\tDD * dd = (DD *)dds->goFirst();\n\t\t\twhile(dd)\n\t\t\t\u00e4\n\t\t\t\tddC++;\n\t\t\t\trexx.set(var(\"JCL\",stepC,\"DD\",ddC,\"DDNAME\"),dd->chainEid);\n\t\t\t\trexx.set(var(\"JCL\",stepC,\"DD\",ddC,\"DSN\"),dd->getLine()->getDataset()->getDsn());\n\t\t\t\tdd = (DD *)dds->goNext();\n\t\t\t\u00fc\n\t\t\trexx.set(var(\"JCL\",stepC,\"DD\",0),ddC);\n\t\t\u00fc\n\t\tstep = (STEP *)steps.goNext();\n\t\u00fc\n\trexx.set(var(\"JCL\",0),stepC);\n\tif (JOBENV::debug)\n\t\u00e4\n\t\tprintf(\"printing ddds\u00d6n\");\n\t\tdds.print_all_ids();\n\t\tprintf(\"printing steps\u00d6n\");\n\t\tsteps.print_all_ids();\n\t\tprintf(\"printing datasetList\u00d6n\");\n\t\tdatasetList.print_all_ids();\n\t\tprintf(\"ending rexxjcl\");\n\t\u00fc\n\treturn 0;\n\u00fc\n\nchar * rexxSMFTimeDate(int &time, int &date)\n\u00e4\n\tstatic char w\u00c4128\u00dc= \"\";\n\tint _date\u00c42\u00dc;\n\t_date\u00c40\u00dc = 0;\n\t_date\u00c41\u00dc = date;\n\tint dateI = __cvb((char *)_date);\n\tint rest , v , ss, mm, hh;\n\trest = time%100;\n\tv  =  time/100;\n\tss =  v%60;\n\tv /= 60;\n\tmm =  v%60;\n\thh =  v/60;\n\tint d =dateI/1000;\n\tsprintf(w,\" %d.%d \",(dateI/1000)+1900,dateI%1000);\n\tsprintf(w+strlen(w),\"%2.2d:%2.2d:%2.2d:%2.2d\u00d6n\",hh,mm,ss,rest);\n\treturn w;\n\u00fc\n\ntypedef struct cvtxtnt2 * cvtxtnt2P;\n\nconst char * rexxSMFtod(pULL tod,char * format=NULL)\n\u00e4\n\tstatic char w\u00c4128\u00dc;\n\tstruct tm *  p_tm;\n\ttime_t     t;\n\tunsigned long  rest;\n\tunsigned long long microsec = (*tod>>12);\n\tt      = microsec/1000000-epoch;\n\tp_tm = localtime(&t);\n\n\trest =  microsec%1000000;\n\tif (format)\n\t\tstrftime(w,sizeof(w),format,p_tm);\n\telse\n\t\u00e4\n\t\tstrftime(w,sizeof(w),\"%FT%T\",p_tm);\n\t\tsprintf(w+strlen(w),\".%6.6d\",rest);\n\t\u00fc\n\treturn ((const char *)w);\n\u00fc\n\nclass Smf2Job :public chainE\n\u00e4\nprivate:\n\tchar jobname\u00c49\u00dc;\n\tchar jobid\u00c49\u00dc;\n\tchar userid\u00c49\u00dc;\npublic:\n\tSmf2Job(const char *p,const char * jp,const  char * ip,char * up):chainE(p)\n\t\u00e4\n\t\tstrcpy(jobname,jp);\n\t\tstrcpy(jobid,ip);\n\t\tstrcpy(userid,up);\n\t\u00fc\n\tvirtual \u00dfSmf2Job()\n\t\u00e4\u00fc\n\n\tconst char * getJobname()\n\t\u00e4\n\t\treturn ((const char *)jobname);\n\t\u00fc\n\n\tconst char * getJobid()\n\t\u00e4\n\t\treturn ((const char *)jobid);\n\t\u00fc\n\tconst char * getUserid()\n\t\u00e4\n\t\treturn ((const char *)userid);\n\t\u00fc\n\n\u00fc;\n\nSORTEDmCHAIN * Smf2Jobs = new SORTEDmCHAIN();\n\nint rexxSMF(REXXVAR & rexx ,int & index,char * b,bool & idflag,size_t rl,int need30 = 1, int  need92 = 1, int need102 = 1)\n\u00e4\n\tchar recordQual\u00c416\u00dc;\n\tcounters\u00c4smfrcd30P(b)->smf30rty\u00dc++;\n\tswitch(smfrcd30P(b)->smf30rty)\n\t\u00e4\n\tcase 14:\n\tcase 15:\n\t\t\u00e4\n\t\t\tchar progname\u00c4256\u00dc;\n\t\t\tsmf14P smf14p = (smf14P)b;\n\t\t\tint sdc = smf14p->smf14sdc; //size of DCB segment\n\t\t\tint nuc = smf14p->smf14nuc; //no. of UCB sections\n\t\t\tint suc = smf14p->smf14suc; //size of each of UCB sections\n\t\t\tint excp = 0;\n\t\t\tmemcpy(&rst_15,smf14p->smf14rst,4);\n\t\t\tmemcpy(&rsd_15,smf14p->smf14rsd,4);\n\t\t\tif ((rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))&&strcasecmp(\"rexxsmf\",argv\u00c40\u00dc)==0)\n\t\t\t\tbreak;\n\t\t\tif (nuc > 0)\n\t\t\t\texcp = *(int*)smf14p->smfexcp;\n\t\t\tif (excp == 0)\n\t\t\t\tbreak;\n\t\t\tif (JOBENV::debug)\n\t\t\t\t_dump(\" SMF 14 or 15 record dump\",b,rl);\n\t\t\tunsigned char* dcbp = smf14p->smfdcbor; //DCB Section\n\t\t\tunsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section\n\t\t\tunsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section\n\t\t\tunsigned char* eisp = ucbp + nuc*suc;\n\t\t\tshort int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Sections\n\t\t\tunsigned char* eispr = eisp + 2;\n\t\t\tshort int eispl = 1; //length of next Extended Information Section\n\t\t\tint write_14_15 = 0; //=0 do not write line\n\t\t\tchar stepname_14\u00c49\u00dc;\n\t\t\tchar progname_14\u00c49\u00dc;\n\t\t\twhile (smf14esll > 0 && eispl > 0)\n\t\t\t\u00e4\n\t\t\t\teispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section\n\t\t\t\tchar sty = ((smf14EISP)eispr)->_smf14sty; //Section type\n\t\t\t\tswitch(sty)\n\t\t\t\t\u00e4\n\t\t\t\tcase smf14stp:\n\t\t\t\t\tstrncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);\n\t\t\t\t\tstrncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);\n\t\t\t\t\tstepname_14\u00c48\u00dc = 0;\n\t\t\t\t\tprogname_14\u00c48\u00dc = 0;\n\t\t\t\t\tif (*pstepname == 0 && *pprogname == 0)\n\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\telse if (*pstepname && |strcasecmp(stepname_14,pstepname))\n\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\telse if (*pprogname && |strcasecmp(progname_14,pprogname))\n\t\t\t\t\t\twrite_14_15 = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t\u00fc\n\t\t\t\tsmf14esll -= eispl;\n\t\t\t\teispr += eispl;\n\t\t\t\u00fc\n\t\t\t//printf(\"smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%d\u00d6n\",smf14p,ucbp,eispr,eisp,smf14esll);\n\t\t\tif (write_14_15)\n\t\t\t\u00e4\n\t\t\t\tchar dsname\u00c4128\u00dc;\n\t\t\t\twrite_30 = 1; //write step sum\n\t\t\t\tif (*stepname == 0)\n\t\t\t\t\u00e4\n\t\t\t\t\tstrcpy(stepname,stepname_14);\n\t\t\t\t\tstrcpy(progname,progname_14);\n\t\t\t\t\u00fc\n\t\t\t\tstrncpy(dsname,(const char*)smf14p->smfjfcb1,44);\n\t\t\t\tdsname\u00c444\u00dc = 0;\n\t\t\t\tif (smf14p->smfjfcb1\u00c444\u00dc-' ')\n\t\t\t\t\u00e4\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tfor(;dsname\u00c4i\u00dc-' '&&dsname\u00c4i\u00dc-0;i++);\n\t\t\t\t\tdsname\u00c4i++\u00dc= '(';\n\t\t\t\t\tfor(;j<8&&smf14p->smfjfcb1\u00c444+j\u00dc>='A';j++)\n\t\t\t\t\t\tdsname\u00c4i+j\u00dc=smf14p->smfjfcb1\u00c444+j\u00dc;\n\t\t\t\t\tdsname\u00c4i+j\u00dc=')';\n\t\t\t\t\tdsname\u00c4i+j+1\u00dc=0;\n\t\t\t\t\u00fc\n\t\t\t\tif (strcasecmp(\"rexxdsmf\",argv\u00c40\u00dc)==0&&stcpma(dsname,argv\u00c41\u00dc)==0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (smf14p->smf14rty == 14)\n\t\t\t\t\tstrcpy(recordQual,\"SMF14\");\n\t\t\t\telse\n\t\t\t\t\tstrcpy(recordQual,\"SMF15\");\n\t\t\t\tindex++;\n\t\t\t\tif (strcasecmp(\"rexxdsmf\",argv\u00c40\u00dc)==0)\n\t\t\t\t\u00e4\n\t\t\t\t\tchar smf2job\u00c417\u00dc;\n\t\t\t\t\tmemcpy(smf2job,smf14p->smf14jbn,16);\n\t\t\t\t\tsmf2job\u00c416\u00dc = 0;\n\t\t\t\t\tSmf2Job * pjob = (Smf2Job *)Smf2Jobs->search(smf2job);\n\t\t\t\t\tif (pjob)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"JOBNAME\"),pjob->getJobname());\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"JOBID\"),pjob->getJobid());\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"USERID\"),(char *)smf14p->smf14uid,8);\n\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\trexx.set(var(\"SMF\",index,\"TYPE\"),recordQual);\n\t\t\t\trexx.set(var(\"SMF\",index,\"DD\"),(char *)smf14p->smftioe5,8);\n\t\t\t\trexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFTimeDate(*(int *)smf14p->smf14tme,*(int *)smf14p->smf14dte));\n\t\t\t\trexx.set(var(\"SMF\",index,\"DD\"),(char *)smf14p->smftioe5,8);\n\t\t\t\trexx.set(var(\"SMF\",index,\"DSN\"),dsname);\n\t\t\t\trexx.set(var(\"SMF\",index,\"EXCP\"),excp);\n\t\t\t\trexx.set(var(\"SMF\",index,\"STEP\"),stepname);\n\t\t\t\trexx.set(var(\"SMF\",index,\"PROCSTEP\"),pstepname);\n\t\t\t\trexx.set(var(\"SMF\",index,\"PROGRAM\"),progname);\n\n\n\t\t\t\tchar work\u00c410\u00dc = \"\";\n\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14dad)\n\t\t\t\t\tstrcpy(work,\"DASD\");\n\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14tds)\n\t\t\t\t\tstrcpy(work,\"Temporary\");\n\t\t\t\tif (smf14p->smf14rin\u00c40\u00dc & (unsigned char)smf14vio)\n\t\t\t\t\tstrcpy(work,\"VIO \");\n\t\t\t\trexx.set(var(\"SMF\",index,\"DSTYPE\"),work);\n\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tcase 30:\n\t\t\u00e4\n\n\t\t\tswitch (*(short *)(smfrcd30P(b)->smf30stp))\n\t\t\t\u00e4\n\t\t\tcase 1:\n\t\t\t\tif ((argv\u00c41\u00dc&&memcmp(argv\u00c41\u00dc,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)]]strcasecmp(argv\u00c40\u00dc,\"rexxdsmf\")==0)\n\t\t\t\t\u00e4\n\t\t\t\t\tmemcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);\n\t\t\t\t\tjobid\u00c48\u00dc = 0;\n\t\t\t\t\tmemcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);\n\t\t\t\t\tjobname\u00c48\u00dc = 0;\n\t\t\t\t\tmemcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);\n\t\t\t\t\tusername\u00c48\u00dc = 0;\n\t\t\t\t\trst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;\n\t\t\t\t\tmemcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);\n\t\t\t\t\tif (strcasecmp(\"rexxdsmf\",argv\u00c40\u00dc)==0)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tchar smf2job\u00c417\u00dc;\n\t\t\t\t\t\tmemcpy(smf2job,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);\n\t\t\t\t\t\tmemcpy(smf2job+8,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst),4);\n\t\t\t\t\t\tmemcpy(smf2job+12,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd),4);\n\t\t\t\t\t\tsmf2job\u00c416\u00dc = 0;\n\t\t\t\t\t\tSmf2Jobs->add(new Smf2Job(smf2job,jobname,jobid,username));\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t\u00fc\n\t\t\tif (strcasecmp(argv\u00c40\u00dc,\"rexxdsmf\")==0)\n\t\t\t\tbreak;\n\t\t\tif (memcmp(argv\u00c41\u00dc,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))\n\t\t\t\tbreak;\n\t\t\tif (JOBENV::debug)\n\t\t\t\t_dump(\" SMF 30 record dump\",b,rl);\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)\n\t\t\t\u00e4\n\t\t\t\tsmf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);\n\t\t\t\tstrcpy(recordQual,\"SMF30\");\n\t\t\t\trexx.set(var(\"SMF\",0,\"JOBNAME\"),(char *)p->smf30jbn,8);\n\t\t\t\trexx.set(var(\"SMF\",0,\"JOBID\"),jobid);\n\t\t\t\trexx.set(var(\"SMF\",0,\"USER\"),(const char *)p->smf30usr);\n\t\t\t\trexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30P(b)->smf30dte));\n\t\t\t\tidflag = true;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tsmf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);\n\t\t\t\tindex++;\n\t\t\t\tstrcpy(recordQual,\"SMF30\");\n\t\t\t\trexx.set(var(\"SMF\",index,\"TYPE\"),recordQual);\n\t\t\t\trexx.set(var(\"SMF\",index,\"PROGRAM\"),(char *)p->smf30pgm,8);\n\t\t\t\trexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30P(b)->smf30dte));\n\t\t\t\trexx.set(var(\"SMF\",index,\"STEP\"),stepname);\n\t\t\t\trexx.set(var(\"SMF\",index,\"PROCSTEP\"),pstepname);\n\t\t\t\u00fc\n\t\t\t// I/O activity\n\n\n\t\t\tint excp = 0;\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30uon))\n\t\t\t\texcp = smf30uraP(b+smfrcd30P(b)->smf30uof)->smf30tep;\n\t\t\trexx.set(var(\"SMF\",index,\"EXCP\"),excp);\n\n\t\t\t// Processor cumulative CPU\n\t\t\tdouble cpu = 0;\n\t\t\tdouble srb = 0;\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30con))\n\t\t\t\u00e4\n\t\t\t\tsmf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);\n\t\t\t\tcpu = float(p->smf30cpt)/100;\n\t\t\t\tsrb = float(p->smf30cps)/100;\n\t\t\t\u00fc\n\t\t\trexx.set(var(\"SMF\",index,\"CPU\"),cpu);\n\t\t\trexx.set(var(\"SMF\",index,\"SRB\"),cpu);\n\n\t\t\t// EXCP section\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30eon))\n\t\t\t\u00e4\n\t\t\t\t/*\n\t\t\t\tsmf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);\n\t\t\t\tfor(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)\n\t\t\t\t\u00e4\n\t\t\t\tif (p->smf30blk)\n\t\t\t\tprintf(\" Device(CUA):%2.2X%2.2X EXCP count:%8.8d\u00d6n\",\n\t\t\t\tp->smf30cua\u00c40\u00dc,p->smf30cua\u00c41\u00dc,p->smf30blk);\n\t\t\t\tp = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);\n\t\t\t\t\u00fc\n\t\t\t\t*/\n\t\t\t\u00fc\n\t\t\tint storage = 0;\n\t\t\tint region = 0;\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30ron))\n\t\t\t\u00e4\n\t\t\t\tsmf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);\n\t\t\t\tregion = (*(int *)p->smf30rgn)/1024;\n\t\t\t\tstorage =  p->smf30eur/(1024*1024);\n\t\t\t\u00fc\n\t\t\trexx.set(var(\"SMF\",index,\"REGION\"),region);\n\t\t\trexx.set(var(\"SMF\",index,\"STORAGE\"),storage);\n\n\t\t\tint totalsu = 0;\n\t\t\tint cpusu = 0;\n\t\t\tint srbsu = 0;\n\t\t\tint iosu = 0;\n\t\t\t// Performance\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30pon))\n\t\t\t\u00e4\n\t\t\t\tsmf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);\n\t\t\t\ttotalsu =   p->smf30srv;\n\t\t\t\tcpusu = p->smf30csu;\n\t\t\t\tsrbsu = p->smf30srb;\n\t\t\t\tiosu = p->smf30io;\n\t\t\t\u00fc\n\t\t\trexx.set(var(\"SMF\",index,\"TOTALSU\"),totalsu);\n\t\t\trexx.set(var(\"SMF\",index,\"CPUSU\"),cpusu);\n\t\t\trexx.set(var(\"SMF\",index,\"SRBSU\"),srbsu);\n\t\t\trexx.set(var(\"SMF\",index,\"IOSU\"),iosu);\n\t\t\tif (*(short *)(smfrcd30P(b)->smf30stp)==5)\n\t\t\t\treturn 5;\n\t\t\u00fc\n\t\tbreak;\n\tcase 92:\n\t\tif (smfrcd92P(b)->smf92ion)\n\t\t\u00e4\n\t\t\tsmf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);\n\t\t\tif (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)\n\t\t\t\t]]memcmp(jobname,pid->smf92jbn,8))\n\t\t\t\tbreak;\n\t\t\tif (JOBENV::debug)\n\t\t\t\t_dump(\" SMF 92 record dump\",b,rl);\n\t\t\tstrcpy(recordQual,\"SMF92\");\n\t\t\tswitch (smfrcd92P(b)->smf92stp)\n\t\t\t\u00e4\n\t\t\tcase 11:\n\t\t\t\tif (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)\n\t\t\t\t\u00e4\n\t\t\t\t\tsmf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);\n\t\t\t\t\tfor(int i=0;i<smfrcd92P(b)->smf92don;i++)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tchar name\u00c465\u00dc;\n\t\t\t\t\t\tname\u00c464\u00dc=0;\n\t\t\t\t\t\tif (p->smf92cty==FT_SOCKET)\n\t\t\t\t\t\t\tsprintf(name,\" SOCKET inode:%d device:%d\",p->smf92cin,p->smf92cdn);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmemcpy(name,p->smf92cpn,sizeof(p->smf92cpn));\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"READ\"),p->smf92cir);\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"WRITE\"),p->smf92ciw);\n\n\t\t\t\t\t\tp = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"TYPE\"),recordQual);\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFTimeDate(smfrcd92P(b)->smf92tme,smfrcd92P(b)->smf92dte));\n\t\t\t\t\t\t/*    rexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFtod(pULL(p->smf92ctc)));*/\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"PATH\"),name);\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STEP\"),stepname);\n\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"PROCSTEP\"),pstepname);\n\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tcase 100:\n\t\t//_dump(\" SMF 100 record dump\",b,rl);\n\t\tbreak;\n\tcase 101:\n\t\t//_dump(\" SMF 101 record dump\",b,rl);\n\t\tbreak;\n\tcase 102:\n\t\t\u00e4\n\t\t\ttypedef struct sm102 * sm102P;\n\t\t\ttypedef struct qwt0 * qwt0P;\n\t\t\ttypedef struct qwhs * qwhsP;\n\t\t\ttypedef struct qwhc * qwhcP;\n\t\t\tqwt0P qwt0p = qwt0P(b+sizeof(struct sm102)-1);\n\t\t\tint pso = int(qwt0p->qwt02pso);\n\t\t\tint psl = *(short *)(qwt0p->qwt02psl);\n\t\t\tint psn = *(short *)(qwt0p->qwt02psn);\n\t\t\tbool our = false;\n\t\t\tsm102P sm102p = sm102P(b);\n\t\t\tqwhcP qwhcp = qwhcP(b+pso);\n\t\t\tqwhsP qwhsp = NULL;\n\t\t\twhile (|our&&(char *)qwhcp<(b+pso+psl))\n\t\t\t\u00e4\n\t\t\t\tif (qwhcp->qwhctyp == 1)\n\t\t\t\t\tqwhsp = (qwhsP)qwhcp;\n\t\t\t\tif (qwhcp->qwhctyp == 2 && strcmp((const char *)(qwhcp->qwhccv),jobid) ==0 )\n\t\t\t\t\tour = true;\n\t\t\t\tqwhcp = qwhcP((char *)qwhcp+*(short *)qwhcp->qwhclen);\n\t\t\t\u00fc\n\t\t\tif (|need102 ]] |our ]] |qwhsp)\n\t\t\t\tbreak;\n\t\t\tif (JOBENV::debug)\n\t\t\t\t_dump(\" SMF 102 record dump\",b,rl);\n\n\n\t\t\tchar ssid\u00c45\u00dc;\n\t\t\tmemcpy(ssid,qwhsp->qwhsssid,4);\n\t\t\tssid\u00c44\u00dc = 0;\n\t\t\tstrcpy(recordQual,\"SMF102\");\n\t\t\tchar work\u00c41024*32\u00dc;\n\t\t\tfor(int i = 0;i<qwhsp->qwhsnsda-1;i++)\n\t\t\t\u00e4\n\t\t\t\tqwt0P datasection = qwt0P((char *)qwt0p+i*8+8);\n\t\t\t\tint offset = int(datasection->qwt02pso);\n\t\t\t\tint length = *(short *)(datasection->qwt02psl);\n\t\t\t\tint count = *(short *)(datasection->qwt02psn);\n\t\t\t\tchar * start = b+offset;\n\t\t\t\t//for(int j = 0;j<count;j++)\n\t\t\t\t\u00e4\n\t\t\t\t\tindex++;\n\t\t\t\t\trexx.set(var(\"SMF\",index,\"STEP\"),stepname);\n\t\t\t\t\trexx.set(var(\"SMF\",index,\"PROCSTEP\"),pstepname);\n\t\t\t\t\trexx.set(var(\"SMF\",index,\"TIME\"),rexxSMFTimeDate(*(int *)sm102p->sm102tme,*(int *)sm102p->sm102dte));\n\t\t\t\t\trexx.set(var(\"SMF\",index,\"TYPE\"),recordQual);\n\t\t\t\t\trexx.set(var(\"SMF\",index,\"ON\"),ssid);\n\n\t\t\t\t\tswitch(*(short *)qwhsp->qwhsiid)\n\t\t\t\t\t\u00e4\n\t\t\t\t\tcase 22:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0022 * qw0022P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0022 THE MINI-PLANS GENERATED\");\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),(const char *)qw0022P(start)->qw0022tn,18);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),(const char *)qw0022P(start)->qw0022pg,8);\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 53:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0053 * qw0053P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0053 END OF DESCRIBE SQL COMMIT, ROLLBACK, ERROR CONDITION\");\n\t\t\t\t\t\t\tif (memcmp(qw0053P(start)->qw0053sq,\"SQLCA\",5) == 0)\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tif (*(int *)(qw0053P(start)->qw0053sq+12) == 0 )\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tstrcpy(work,\"SQLOK\");\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tERROR_MESSAGE error_message;\n\t\t\t\t\t\t\t\t\terror_message.error_len = 10*72;\n\t\t\t\t\t\t\t\t\tint rc = DSNTIAR(qw0053P(start)->qw0053sq,&error_message,&data_len);\n\t\t\t\t\t\t\t\t\tif ( rc )\n\t\t\t\t\t\t\t\t\t\tsprintf(work,\"DSNTIAR rc:%d\",rc);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\t\twork\u00c40\u00dc =0;\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i<data_dim;i++)\n\t\t\t\t\t\t\t\t\t\t\tsprintf(work+strlen(work),\"<p>%72.72s\",error_message.error_text\u00c4i\u00dc);\n\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tsprintf(work,\"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu\",\n\t\t\t\t\t\t\t\t\t*(long long *)qw0053P(start)->qw0053rq,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0053P(start)->qw0053in,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0053P(start)->qw0053up,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0053P(start)->qw0053de);\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 55:\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 58:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0058 * qw0058P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0058 END SQL STATEMENT EXECUTION\");\n\t\t\t\t\t\t\tif (memcmp(qw0058P(start)->qw0058sq,\"SQLCA\",5) == 0)\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tif (*(int *)(qw0058P(start)->qw0058sq+12) == 0 )\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tstrcpy(work,\"SQLOK\");\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tERROR_MESSAGE error_message;\n\t\t\t\t\t\t\t\t\terror_message.error_len = 10*72;\n\t\t\t\t\t\t\t\t\tint rc = DSNTIAR(qw0058P(start)->qw0058sq,&error_message,&data_len);\n\t\t\t\t\t\t\t\t\tif ( rc )\n\t\t\t\t\t\t\t\t\t\tsprintf(work,\"DSNTIAR rc:%d\",rc);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\t\twork\u00c40\u00dc =0;\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i<data_dim;i++)\n\t\t\t\t\t\t\t\t\t\t\tsprintf(work+strlen(work),\"<p>%72.72s\",error_message.error_text\u00c4i\u00dc);\n\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tsprintf(work,\"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu\",\n\t\t\t\t\t\t\t\t\t*(long long *)qw0058P(start)->qw0058rp,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0058P(start)->qw0058in,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0058P(start)->qw0058up,\n\t\t\t\t\t\t\t\t\t*(long long *)qw0058P(start)->qw0058de);\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 59:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0059 * qw0059P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0059 FETCH SQL STATEMENT EXECUTION START\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s Sensitive:%c Orientation:%c\",\n\t\t\t\t\t\t\t\t*(short*)qw0059P(start)->qw0059cl,*(short*)qw0059P(start)->qw0059cl,qw0059P(start)->qw0059cn,qw0059P(start)->qw0059fs,qw0059P(start)->qw0059fo);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 60:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0060 * qw0060P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0060 SELECT SQL STATEMENT EXECUTION START\");\n\t\t\t\t\t\t\tsprintf(work,\"Isolation:%c\",\n\t\t\t\t\t\t\t\tqw0060P(start)->qw0060i);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 61:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0061 * qw0061P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0061 FETCH SQL STATEMENT START - INSERT, UPDATE, DELETE\");\n\t\t\t\t\t\t\tchar type\u00c432\u00dc;\n\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x10)\n\t\t\t\t\t\t\t\tstrcpy(type,\"INSERT\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x20)\n\t\t\t\t\t\t\t\t\tstrcpy(type,\"UPDATE NON CURSOR\");\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x21)\n\t\t\t\t\t\t\t\t\t\tstrcpy(type,\"UPDATE CURSOR\");\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x30)\n\t\t\t\t\t\t\t\t\t\t\tstrcpy(type,\"MERGE\");\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x41)\n\t\t\t\t\t\t\t\t\t\t\t\tstrcpy(type,\"DELETE CURSOR\");\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tif (qw0061P(start)->qw0061st = 0x50)\n\t\t\t\t\t\t\t\t\t\t\t\t\tstrcpy(type,\"TRUNCATE\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s Type:%s\",\n\t\t\t\t\t\t\t\t*(short*)qw0061P(start)->qw0061cl,*(short*)qw0061P(start)->qw0061cl,qw0061P(start)->qw0061cn,type);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 62:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0062 * qw0062P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0062 RECORDS DLL EXECUTION STATEMENT START\");\n\t\t\t\t\t\t\tsprintf(work,\"Object:%*.*s type:%c\",\n\t\t\t\t\t\t\t\t*(short*)qw0062P(start)->qw0062ol,*(short*)qw0062P(start)->qw0062ol,qw0062P(start)->qw0062on,qw0062P(start)->qw0062st);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 63:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0063 * qw0063P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0063 THE SQL STATEMENTT\");\n\t\t\t\t\t\t\tsprintf(work,\"%*.*s\",\n\t\t\t\t\t\t\t\t*(short*)qw0063P(start)->qw0063ll,*(short*)qw0063P(start)->qw0063ll,(char *)&qw0063P(start)->qw0063st);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0064 * qw0064P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0064 PREPARE STATEMET START\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s\",\n\t\t\t\t\t\t\t\t*(short*)qw0064P(start)->qw0064cl,*(short*)qw0064P(start)->qw0064cl,qw0064P(start)->qw0064cn);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 65:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0065 * qw0065P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0065 OPEN CURSOR STATEMENT START\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s Sensitive:%c Isolation:%c\",\n\t\t\t\t\t\t\t\t*(short*)qw0065P(start)->qw0065cl,*(short*)qw0065P(start)->qw0065cl,qw0065P(start)->qw0065cn,\n\t\t\t\t\t\t\t\tqw0065P(start)->qw0065sv,qw0065P(start)->qw0065i);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 66:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0066 * qw0066P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0066 OPEN CURSOR STATEMENT START\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s\",\n\t\t\t\t\t\t\t\t*(short*)qw0066P(start)->qw0066cl,*(short*)qw0066P(start)->qw0066cl,qw0066P(start)->qw0066cn);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 92:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0092 * qw0092P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0092 AN AMS COMMAND START\");\n\t\t\t\t\t\t\tsprintf(work,\"Command:%*.*s\",\n\t\t\t\t\t\t\t\t*(short*)qw0092P(start)->qw0092pl,*(short*)qw0092P(start)->qw0092pl,qw0092P(start)->qw0092p1);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 96:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0096 * qw0096P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0096 RECORDS SORT ENDED\");\n\t\t\t\t\t\t\tsprintf(work,\"Records:%d DataSize:%d KeySize:%d\",\n\t\t\t\t\t\t\t\tqw0096P(start)->qw0096nr,qw0096P(start)->qw0096dl,qw0096P(start)->qw0096kl);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 97:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0097 * qw0097P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0097 AMS COMMAND COMPLETION\");\n\t\t\t\t\t\t\tsprintf(work,\"Command:%*.*s ReturnCode:%d\",\n\t\t\t\t\t\t\t\t*(short*)qw0097P(start)->qw0097pl,*(short*)qw0097P(start)->qw0097pl,qw0097P(start)->qw0097p1,\n\t\t\t\t\t\t\t\tqw0097P(start)->qw0097rc);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 112:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0112 * qw0112P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0112 THE ATTRIBUTES FOR THE PLAN\");\n\t\t\t\t\t\t\tsprintf(work,\"Plan:%8.8s Isolation:%2.2s Aqu:%c Rel:%c Keep:%c Prot:%c\",\n\t\t\t\t\t\t\t\tqw0112P(start)->qw0112pn,qw0112P(start)->qw0112i,\n\t\t\t\t\t\t\t\tqw0112P(start)->qw0112q,qw0112P(start)->qw0112r,\n\t\t\t\t\t\t\t\tqw0112P(start)->qw0112kd,qw0112P(start)->qw0112pr);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 173:\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 177:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0177 * qw0177P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0177 FOR SUCCESSFUL PACKAGE ALLOCATION\");\n\t\t\t\t\t\t\tsprintf(work,\"Package:%126.126s\",\n\t\t\t\t\t\t\t\t(char *)&(qw0177P(start)->qw0177pk));\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 233:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0233 * qw0233P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0233 START OR END OF A CALL TO A USER ROUTINE\");\n\t\t\t\t\t\t\tsprintf(work,\"Routine:18.18s\",\n\t\t\t\t\t\t\t\tqw0233P(start)->qw0233pr);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 237:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0237 * qw0237P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0237 AT EXECUTION of SET CURRENT DEGREE\");\n\t\t\t\t\t\t\tsprintf(work,\"Prev:%3.3s New:%3.3s Status:%c\",\n\t\t\t\t\t\t\t\tqw0237P(start)->qw0237oi,qw0237P(start)->qw0237ni,\n\t\t\t\t\t\t\t\tqw0237P(start)->qw0237st);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 250:\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 272:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0272 * qw0272P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0272 ASSOCIATE LOCATORS\");\n\t\t\t\t\t\t\tsprintf(work,\"StoredProc:%*.*s\",\n\t\t\t\t\t\t\t\tqw0272P(start)->qw0272pl,qw0272P(start)->qw0272pl,qw0272P(start)->qw0272pn);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 273:\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\ttypedef struct qw0273 * qw0273P;\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"NOTES\"),\"0273 ALLOCATE CURSOR\");\n\t\t\t\t\t\t\tsprintf(work,\"Cursor:%*.*s\",\n\t\t\t\t\t\t\t\tqw0273P(start)->qw0273cl,qw0273P(start)->qw0273cl,qw0273P(start)->qw0273cn);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"STATS\"),work);\n\t\t\t\t\t\t\trexx.set(var(\"SMF\",index,\"INFO\"),\"\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 325:\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\u00fc\n\t\t\t\t\tif (offset)\n\t\t\t\t\t\tstart +=offset;\n\t\t\t\t\telse\n\t\t\t\t\t\tstart += *(short *)start;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t\u00fc\n\treturn 0;\n\u00fc\n\n_rexxsmf()\n\u00e4\n\t//printf(\" Browse %s loggerstream %s direction\u00d6n\",argv\u00c42\u00dc,(atoi(argv\u00c43\u00dc)==0?\"oldtoyoung\":\"youngtoold\"));\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tint rc = mvs()->LoggerOpen(argv\u00c42\u00dc);\n\tconst char * pointer = NULL;\n\tchar date\u00c432\u00dc;\n\tchar * dateP = NULL;\n\tif (argc >= 4 && argv\u00c44\u00dc)\n\t\u00e4\n\t\tchar * p = strchr(argv\u00c44\u00dc,',');\n\t\tif (p)\n\t\t\t*(int *)date = atoi(p+1);\n\t\tmemcpy(date+4,argv\u00c44\u00dc,7);\n\t\tdateP = date;\n\t\u00fc\n\n\tsize_t length = 0;\n\tsize_t * lP   = &length;\n\tpasm PASM = NULL;\n\tREXXVAR rexx(JOBENV::debug);\n\tbool idflag = false;\n\tint index = 0;\n\twhile (rc=mvs()->BrowseLogger(pointer,lP,atoi(argv\u00c43\u00dc),0,dateP)==0)\n\t\u00e4\n\t\tPASM = mvs()->getpasm();\n\t\tif (JOBENV::debug)\n\t\t\u00e4\n\t\t\t/*\n\t\t\t_dump(\"logger rc\",(char *)&(PASM->asm_rc),256);\n\t\t\t_dump(\"asm logger\",(char *)&(PASM->asm_logger_length),\n\t\t\t(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));\n\t\t\t_dump(\" ASM LOGGER\",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));\n\t\t\t_dump(\" ASM ansarea\",(char *)PASM->asm_ansarea,40);\n\t\t\tprintf(\" RC:%d REASON:%d(%8.8x)\u00d6n\",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);\n\t\t\t*/\n\t\t\u00fc\n\t\tunsigned short ubl = *(unsigned short *)pointer;\n\t\tint bl = ubl;\n\t\tbl-=4;\n\t\tchar * p = (char *)pointer+4;\n\t\twhile(bl>0)\n\t\t\u00e4\n\t\t\tunsigned short url;\n\t\t\turl = *(unsigned short *)p;\n\t\t\tint rl = url;\n\t\t\tif (rl==72)\n\t\t\t\u00e4\n\t\t\t\tp+=rl;\n\t\t\t\tbl-=rl;\n\t\t\t\tlength-=rl;\n\t\t\t\trl = *(short *)p;\n\t\t\t\tif (bl >0 && rl>0 && bl>rl)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (rexxSMF(rexx,index,p,idflag,rl)==5)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\trexx.set(var(\"SMF\",0),index);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\u00fc\n\t\t\t\t\tp+=rl;\n\t\t\t\t\tbl-=rl;\n\t\t\t\t\tlength=-rl;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\tmvs()->LoggerClose();\n\n\tif (index>0)\n\t\trexx.set(var(\"SMF\",0),index);\n\telse\n\t\tfor(int i =0;i<255;i++)\n\t\t\tif (counters\u00c4i\u00dc)\n\t\t\t\tprintf(\" SMF type:%d, records:%d\u00d6n\",i,counters\u00c4i\u00dc);\n\treturn 0;\n\u00fc\n\n_rexxdsmf()\n\u00e4\n\t//printf(\" Browse %s loggerstream %s direction\u00d6n\",argv\u00c42\u00dc,(atoi(argv\u00c43\u00dc)==0?\"oldtoyoung\":\"youngtoold\"));\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tint rc = mvs()->LoggerOpen(argv\u00c42\u00dc);\n\tconst char * pointer = NULL;\n\tchar date\u00c432\u00dc;\n\tchar * dateP = NULL;\n\tif (argc >= 4 && argv\u00c44\u00dc)\n\t\u00e4\n\t\tchar * p = strchr(argv\u00c44\u00dc,',');\n\t\tif (p)\n\t\t\t*(int *)date = atoi(p+1);\n\t\tmemcpy(date+4,argv\u00c44\u00dc,7);\n\t\tdateP = date;\n\t\u00fc\n\n\tsize_t length = 0;\n\tsize_t * lP   = &length;\n\tpasm PASM = NULL;\n\tREXXVAR rexx(JOBENV::debug);\n\tbool idflag = false;\n\tint index = 0;\n\twhile (rc=mvs()->BrowseLogger(pointer,lP,atoi(argv\u00c43\u00dc),0,dateP)==0)\n\t\u00e4\n\t\tPASM = mvs()->getpasm();\n\t\tunsigned short ubl = *(unsigned short *)pointer;\n\t\tint bl = ubl;\n\t\tbl-=4;\n\t\tchar * p = (char *)pointer+4;\n\t\twhile(bl>0)\n\t\t\u00e4\n\t\t\tunsigned short url;\n\t\t\turl = *(unsigned short *)p;\n\t\t\tint rl = url;\n\t\t\tif (rl==72)\n\t\t\t\u00e4\n\t\t\t\tp+=rl;\n\t\t\t\tbl-=rl;\n\t\t\t\tlength-=rl;\n\t\t\t\trl = *(short *)p;\n\t\t\t\tif (bl >0 && rl>0 && bl>rl)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (rexxSMF(rexx,index,p,idflag,rl)==5)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\trexx.set(var(\"SMF\",0),index);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\u00fc\n\t\t\t\t\tp+=rl;\n\t\t\t\t\tbl-=rl;\n\t\t\t\t\tlength=-rl;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tbl = 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\tmvs()->LoggerClose();\n\n\tif (index>0)\n\t\trexx.set(var(\"SMF\",0),index);\n\telse\n\t\tfor(int i =0;i<255;i++)\n\t\t\tif (counters\u00c4i\u00dc)\n\t\t\t\tprintf(\" SMF type:%d, records:%d\u00d6n\",i,counters\u00c4i\u00dc);\n\treturn 0;\n\u00fc\n\nextern dump(FILE *,char *,char *,int);\n\nint _dumpfile()\n\u00e4\n\tchar w\u00c41024\u00dc;\n\tchar b\u00c432756\u00dc;\n\tFILE * f =fopen(genOpenName(argv\u00c41\u00dc,w),\"rb,type=record\");\n\tint l = 0;\n\tif (f)\n\t\u00e4\n\t\tint count = 0;\n\t\twhile((l = fread(b,1,sizeof(b),f))>0)\n\t\t\u00e4\n\t\t\tcount++;\n\t\t\tsprintf(w,\"record:%d in %d length\",count,l);\n\t\t\tdump(stdout,w,b,l);\n\t\t\u00fc\n\t\tfclose(f);\n\t\u00fc\n\treturn 0;\n\u00fc\n\n\nint _listfile()\n\u00e4\n\tchar buff\u00c432760\u00dc;\n\tFILE * file = NULL;\n\tsize_t l = 0;\n\tsize_t max = argv\u00c42\u00dc?atoi(argv\u00c42\u00dc):99999999;\n\tif (argv\u00c41\u00dc&&(file=fopen(genOpenName(argv\u00c41\u00dc,buff),\"rb,type=record,noseek\")))\n\t\u00e4\n\t\twhile ((l=fread(buff,1,sizeof(buff),file))>0&&--max>0)\n\t\t\tprintf(\"%*.*s\u00d6n\",l,l,buff);\n\t\tfclose(file);\n\t\u00fc\n\telse\n\t\tprintf(\"<h1>unable to open %s (%s)\u00d6n\",argv\u00c41\u00dc,strerror(errno));\n\treturn 0;\n\u00fc\ntypedef struct ensg * ENSGP;\ntypedef struct enf70 * ENF70P;\ntypedef struct hdlogrec * HDLOGRECP;\ntypedef struct sdwa * SDWAP;\ntypedef struct adsrcmps * ADSRCMPSP;\n\n\nstatic char *  logrec_types\u00c4255\u00dc;\nint logrec_types_init()\n\u00e4\n\tlogrec_types\u00c40x10\u00dc =  \"Machine Check Handler\";\n\tlogrec_types\u00c40x13\u00dc =  \"Machine Check in the System\";\n\tlogrec_types\u00c40x23\u00dc =  \"Subchannel Logout Handler\";\n\tlogrec_types\u00c40x25\u00dc =  \"Channel Record Word\";\n\tlogrec_types\u00c40x30\u00dc =  \"Outboard\";\n\tlogrec_types\u00c40x34\u00dc =  \"Outboard TCAM\";\n\tlogrec_types\u00c40x36\u00dc =  \"Outboard VTAM\";\n\tlogrec_types\u00c40x3a\u00dc =  \"Outboard DPA\";\n\tlogrec_types\u00c40x40\u00dc =  \"Software-detected software error\";\n\tlogrec_types\u00c40x42\u00dc =  \"Hardware-detected software error\";\n\tlogrec_types\u00c40x44\u00dc =  \"Operator-detected error\";\n\tlogrec_types\u00c40x48\u00dc =  \"Hardware-detected hardware error\";\n\tlogrec_types\u00c40x4c\u00dc =  \"Symptom record\";\n\tlogrec_types\u00c40x4F\u00dc =  \"Lost record summary\";\n\tlogrec_types\u00c40x50\u00dc =  \"IPL\";\n\tlogrec_types\u00c40x60\u00dc =  \"DDR\";\n\tlogrec_types\u00c40x70\u00dc =  \"MIH\";\n\tlogrec_types\u00c40x80\u00dc =  \"EOD\";\n\tlogrec_types\u00c40x81\u00dc =  \"System-initiated end\";\n\tlogrec_types\u00c40x84\u00dc =  \"EOD from IOS\";\n\tlogrec_types\u00c40xA1\u00dc =  \"ETR\";\n\tlogrec_types\u00c40xa2\u00dc =    \"LMI\";\n\tlogrec_types\u00c40xa3\u00dc =  \"SIM\";\n\tlogrec_types\u00c40xc2\u00dc =  \"DPSV\";\n\treturn 1;\n\u00fc\nint _logrec_types = logrec_types_init();\n\nstatic char * enf70_qualifier_list\u00c4\u00dc=\n\u00e4\n\tNULL,\n\t/* Values for field \"enf70_qualifier\" */\n\t\"Job was selected\",\n\t\"Job was processed\",\n\t\"Job queued to new phase\",\n\t\"Job was purged\"\n\u00fc;\n\nstatic char * enf70_comp_list\u00c4\u00dc =\n\u00e4\n\t/* Values for field \"enf70_comp\" */\n#define enf70_cab        0x80 /* ABEND CODE                       */\n#define enf70_ccc        0x40 /* Completion code                  */\n\t\"No completion info\",\n\t\"Job ended normally\",\n\t\"Job ended by cc\",\n\t\"Job had a JCL error\",\n\t\"Job was canceled\",\n\t\"Job ABENDed\",\n\t\"Converter ABENDed\",\n\t\"Security error\",\n\t\"Job ABENDed in end of\"\n\u00fc;\n\n/* Values for field \"enf70_queue\" */\nstatic char * enf70_queue_list\u00c4138\u00dc =\n\u00e4\n\t/*'#define enf70_q_none     0   .*/ \"  No previous queue (job create)  \",\n\tNULL,\n\t/*'#define enf70_q_convert  2   .*/ \"  Conversion                      \",\n\t/*'#define enf70_q_pscbat   3   .*/ \"  Postscan (batch)                \",\n\t/*'#define enf70_q_pscdsl   4   .*/ \"  Postscan (demand select)        \",\n\t/*'#define enf70_q_fetch    5   .*/ \"  Volume fetch                    \",\n\t/*'#define enf70_q_volwt    6   .*/ \"  Start Setup                     \",\n\t/*'#define enf70_q_syssel   7   .*/ \"  MDS system select processing    \",\n\t/*'#define enf70_q_alloc    8   .*/ \"  resource allocation             \",\n\t/*'#define enf70_q_voluav   9   .*/ \"  unavailable VOL(s)              \",\n\t/*'#define enf70_q_verify   10  .*/ \"  volume mounts                   \",\n\t/*'#define enf70_q_sysver   11  .*/ \"  MDS system verify processing    \",\n\t/*'#define enf70_q_error    12  .*/ \"  Demand Select                   \",\n\t/*'#define enf70_q_select   13  .*/ \"  Execution                       \",\n\t/*'#define enf70_q_onmain   14  .*/ \"  Execution                       \",\n\tNULL,\n\tNULL,\n\t/*'#define enf70_q_brkdwn   17  .*/ \"  Breakdown                       \",\n\t/*'#define enf70_q_restrt   18  .*/ \"  MDS restart proc                \",\n\t/*'#define enf70_q_done     19  .*/ \"  Main and MDS proc. complete     \",\n\t/*'#define enf70_q_output   20  .*/ \"  Output service                  \",\n\t/*'#define enf70_q_outque   21  .*/ \"  Output service WTR              \",\n\t/*'#define enf70_q_oswait   22  .*/ \"  Awaiting rsvd services          \",\n\t/*'#define enf70_q_cmplt    23  .*/ \"  Output service complete         \",\n\t/*'#define enf70_q_demsel   24  .*/ \"  Demand Select                   \",\n\t/*'#define enf70_q_efwait   25  .*/ \"  Ending function rq waiting      \",\n\t/*'#define enf70_q_efbad    26  .*/ \"  Ending function rq not Processed\"\n\u00fc;\nint init_const()\n\u00e4\n\tenf70_queue_list\u00c4128\u00dc=\n\t\t/*'#define enf70_q_input    128 .*/ \"  Input queue (pre-execution)     \";\n\tenf70_queue_list\u00c4136\u00dc=\n\t\t/*'#define enf70_q_receiver 136 .*/ \"  Input queue (post-execution)    \";\n\tenf70_queue_list\u00c4132\u00dc=\n\t\t/*'#define enf70_q_spin     132 .*/ \"  Spin queue                      \";\n\tenf70_queue_list\u00c4134\u00dc=\n\t\t/*'#define enf70_q_purge    134 .*/ \"  Purge queue                     \";\n\tenf70_queue_list\u00c4137\u00dc=\n\t\t/*'#define enf70_q_xmit     137 .*/ \"  NJE transmission queue          \";\n\treturn 0;\n\u00fc\n\nint _init_const = init_const();\n\ntypedef struct pfswrec PFSWREC;\ntypedef struct dumpxrec DUMPXREC;\ntypedef struct mpfxrec MPFXREC;\n\nchar * pfswrec_types\u00c423\u00dc;\nint _rexxenfs()\n\u00e4\n\t// argv\u00c42\u00dc = logstream name\n\t// argv\u00c43\u00dc = direction (seems 3 youngtoold)\n\t// argv\u00c44\u00dc = recordcount (default 1000?)\n\t// argv\u00c45\u00dc = TZ envar\n\tif (argc > 4 )\n\t\tsetenv(\"TZ\",argv\u00c45\u00dc,1);\n\tchar w\u00c432760\u00dc;\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tREXXVAR rexx(JOBENV::debug);\n\tpfswrec_types\u00c41\u00dc = \"Update\";\n\tpfswrec_types\u00c42\u00dc = \"Delete\";\n\tpfswrec_types\u00c43\u00dc = \"Rename\";\n\tpfswrec_types\u00c411\u00dc = \"Add member\";\n\tpfswrec_types\u00c412\u00dc = \"Delete_member\";\n\tpfswrec_types\u00c413\u00dc = \"Rename_member\";\n\tpfswrec_types\u00c421\u00dc = \"Update path\";\n\tpfswrec_types\u00c422\u00dc = \"Delete path\";\n\tpfswrec_types\u00c423\u00dc = \"Rename path\";\n\n\tif (JOBENV::debug)\n\t\tprintf(\" Browse %s loggerstream %s direction\u00d6n\",argv\u00c42\u00dc,(atoi(argv\u00c43\u00dc)==0?\"oldtoyoung\":\"youngtoold\"));\n\tint rc = mvs()->LoggerOpen(argv\u00c42\u00dc);\n\tif (rc)\n\t\u00e4\n\t\trexx.set(var(\"ENF\",0),0);\n\t\trexx.set(var(\"ENF_ERROR\",0),sprintf(w,\" unable to open %s logstream\",argv\u00c42\u00dc));\n\t\treturn 8;\n\t\u00fc\n\tsize_t length = 0;\n\tsize_t * lP   = &length;\n\tpasm PASM = NULL;\n\tchar * pointer = NULL;\n\tint max = (argc>3)?atoi(argv\u00c44\u00dc):100;\n\n\tbool idflag = false;\n\tint index = 1;\n\twhile (rc=mvs()->BrowseLogger((const char * &)pointer,lP,atoi(argv\u00c43\u00dc),NULL,NULL)==0 && max>=index)\n\t\u00e4\n\t\tPASM = mvs()->getpasm();\n\n\t\tint rl = *(int *)pointer;\n\t\tPFSWREC * pfswrec =(PFSWREC *)(pointer +4);\n\t\tif (JOBENV::debug)\n\t\t\t_dump(\" logger\",pointer,rl);\n\t\tbool need = false;\n\t\tENSGP ensgP = ENSGP(pointer-8);\n\t\tHDLOGRECP hdlogrecP = HDLOGRECP((char *)pointer+ifbenf36_header_length+sizeof(*ensgP)-8);\n\t\tSDWAP sdwaP=NULL;\n\t\tif (JOBENV::debug)\n\t\t\u00e4\n\t\t\t_dump(\" ensg\",(char *)ensgP,128);\n\t\t\tprintf(\" ENF code:%d\u00d6n \",ensgP->ensg_event_code);\n\t\t\u00fc\n\t\tswitch(ensgP->ensg_event_code)\n\t\t\u00e4\n\t\tcase 0:\n\t\t\t\u00e4\n\t\t\t\tneed = true;\n\t\t\t\tswitch(pfswrec->pfswrec_type)\n\t\t\t\t\u00e4\n\t\t\t\tcase pfswrec_type_update:\n\t\t\t\tcase pfswrec_type_delete:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"DSN\"),(char *)pfswrec->pfswrec_dsn,44);\n\t\t\t\t\tbreak;\n\t\t\t\tcase pfswrec_type_rename:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"DSN\"),(char *)pfswrec->pfswrec_newdsn,44);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"OLD_DSN\"),(char *)pfswrec->pfswrec_dsn,44);\n\t\t\t\t\tbreak;\n\t\t\t\tcase pfswrec_type_add_member:\n\t\t\t\tcase pfswrec_type_delete_member:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"DSN\"),(char *)pfswrec->pfswrec_dsn,44);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"MEMBER\"),(char *)pfswrec->pfswrec_member,8);\n\t\t\t\t\tbreak;\n\t\t\t\tcase pfswrec_type_rename_member:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"DSN\"),(char *)pfswrec->pfswrec_newdsn,44);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"OLD_DSN\"),(char *)pfswrec->pfswrec_dsn,44);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"MEMBER\"),(char *)pfswrec->pfswrec_member,8);\n\t\t\t\t\tbreak;\n\t\t\t\tcase pfswrec_type_update_path:\n\t\t\t\tcase pfswrec_type_delete_path:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"PATH\"),(char *)pfswrec->pfswrec_path,64);\n\t\t\t\t\tbreak;\n\t\t\t\tcase pfswrec_type_rename_path:\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"PATH\"),(char *)pfswrec->pfswrec_newpath,64);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"OLD_PATH\"),(char *)pfswrec->pfswrec_path,64);\n\t\t\t\t\tbreak;\n\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t\u00e4\n\t\t\t\tDUMPXREC * rec =(DUMPXREC *)pointer;\n\t\t\t\tneed = true;\n\t\t\t\trexx.set(var(\"ENF\",index,\"TIME\"),rexxSMFtod(pULL(rec->dumpxrec_dumpxrec_stck)));\n\t\t\t\trexx.set(var(\"ENF\",index,\"SYSTEM\"),(char *)rec->dumpxrec_dumpxrec_prdsname,4);\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBNAME\"),(char *)rec->dumpxrec_dumpxrec_sdepljob,8);\n\t\t\t\trexx.set(var(\"ENF\",index,\"CHANGE\"),\"Dump created\");\n\t\t\t\trexx.set(var(\"ENF\",index,\"DSN\"),(char *)rec->dumpxrec_dumpxrec_prddsnam,40);\n\t\t\t\trexx.set(var(\"ENF\",index,\"SIGNAL\"),1);\n\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t\u00e4\n\t\t\t\tMPFXREC  * rec =(MPFXREC *)pointer;\n\t\t\t\tneed = true;\n\t\t\t\trexx.set(var(\"ENF\",index,\"TIME\"),rexxSMFtod(pULL(rec->mpfxrec_mpfxrec_stck)));\n\t\t\t\trexx.set(var(\"ENF\",index,\"SYSTEM\"),(char *)rec->mpfxrec_mpfxrec_sysname,4);\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBNAME\"),(char *)rec->mpfxrec_mpfxrec_jobname,8);\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBID\"),(char *)rec->mpfxrec_mpfxrec_jobid,8);\n\t\t\t\tsprintf(w,\"%4.4X\",*(short *)rec->mpfxrec_mpfxrec_asid);\n\t\t\t\trexx.set(var(\"ENF\",index,\"ASID\"),w\t);\n\t\t\t\trexx.set(var(\"ENF\",index,\"CHANGE\"),\"critical message\");\n\t\t\t\trexx.set(var(\"ENF\",index,\"MSG\"),(char *)rec->mpfxrec_mpfxrec_ctxttmsg,126);\n\n\t\t\t\u00fc\n\t\t\tbreak;\n\n\t\tcase 36:\n\t\t\tneed = true;\n\t\t\trexx.set(var(\"ENF\",index,\"LOGRECTYPE\"),logrec_types\u00c4hdlogrecP->hdrtyp\u00dc);\n\t\t\tswitch(hdlogrecP->hdrtyp)\n\t\tcase 0x40:\n\t\tdefault:\n\t\t\t\u00e4\n\t\t\t\tsdwaP = SDWAP((char *)hdlogrecP+sizeof(*hdlogrecP));\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBNAME\"),(char *)sdwaP,8);\n\t\t\t\tsdwaP = SDWAP((char *)sdwaP+8);\n\t\t\t\tunsigned int cc = *(int *)&(sdwaP->sdwafiob.sdwaabcc);\n\t\t\t\tif ((cc&0x00FFF000)>>12)\n\t\t\t\t\tsprintf(w,\"S%3.3X\",(cc&0x00FFF000)>>12);\n\t\t\t\telse\n\t\t\t\t\tsprintf(w,\"U%3.3X\",cc&0x00000FFF);\n\t\t\t\trexx.set(var(\"ENF\",index,\"CMPC\"),w);\n\t\t\t\trexx.set(var(\"ENF\",index,\"MODULE\"),(char *)sdwaP->sdwamodn,8);\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase 0x4c:\n\t\t\tbreak;\n\t\tcase 29:\n\t\tcase 30:\n\t\tcase 55:\n\t\tcase 67:\n\t\t\tneed = true;\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t//need = true;\n\t\t\tENF70P enf70P = ENF70P(pointer+sizeof(*ensgP)-8);\n\t\t\t/*\n\t\t\tif (enf70P->enf70_queue == enf70_q_onmain && enf70P->enf70_qualifier == enf70_deselect &&\n\t\t\t(enf70P->enf70_comp&enf70_cab]]enf70P->enf70_comp==enf70_cabn]]enf70P->enf70_comp==enf70_ccab]]enf70P->enf70_comp==enf70_csec]]enf70P->enf70_comp==enf70_ceom))\n\t\t\t*/\n\t\t\tif (enf70P->enf70_comp&&enf70P->enf70_queue == enf70_q_onmain)\n\t\t\t\u00e4\n\t\t\t\tneed = true;\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBNAME\"),(char *)enf70P->enf70_jobname,sizeof(enf70P->enf70_jobname));\n\t\t\t\trexx.set(var(\"ENF\",index,\"JOBID\"),(char *)enf70P->enf70_jobid,sizeof(enf70P->enf70_jobid));\n\t\t\t\tif (isprint(*enf70P->enf70_srvclass))\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"SRVCLASS\"),(char *)enf70P->enf70_srvclass,sizeof(enf70P->enf70_srvclass));\n\t\t\t\telse\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"SRVCLASS\"),\" \");\n\t\t\t\trexx.set(var(\"ENF\",index,\"COMP\"),int(enf70P->enf70_comp));\n\t\t\t\tsprintf(w,\"%8.8x\",*(int *)&(enf70P->enf70_comp)&0x00FFFFFF);\n\t\t\t\trexx.set(var(\"ENF\",index,\"CODE\"),w);\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\t\u00fc\n\t\tif (need)\n\t\t\u00e4\n\t\t\trexx.set(var(\"ENF\",0),index);\n\t\t\trexx.set(var(\"ENF\",index,\"SIGNAL\"),ensgP->ensg_event_code);\n\t\t\tif (ensgP->ensg_event_code > 2)\n\t\t\t\u00e4\n\t\t\t\trexx.set(var(\"ENF\",index,\"TIME\"),rexxSMFtod(pULL((char *)&(ensgP->ensg_source_system_slot)+4)));\n\t\t\t\tsprintf(w,\"%8.8X\",*(int *)(ensgP->ensg_qual));\n\t\t\t\trexx.set(var(\"ENF\",index,\"QUAL\"),w);\n\t\t\t\tsprintf(w,\"%8.8X\",*(int *)(ensgP->ensg_bitmap_qual));\n\t\t\t\trexx.set(var(\"ENF\",index,\"BITQUAL\"),w);\n\t\t\t\trexx.set(var(\"ENF\",index,\"SYSTEM\"),(char *)ensgP->ensg_source_system_name,sizeof(ensgP->ensg_source_system_name));\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tif (ensgP->ensg_event_code == 0)\n\t\t\t\t\u00e4\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"TIME\"),rexxSMFtod(pULL(pfswrec->pfswrec_stck)));\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"SYSTEM\"),(char *)pfswrec->pfswrec_id_system,4);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"JOBNAME\"),(char *)pfswrec->pfswrec_id_jobname,8);\n\t\t\t\t\trexx.set(var(\"ENF\",index,\"CHANGE\"),pfswrec_types\u00c4pfswrec->pfswrec_type\u00dc);\n\t\t\t\t\u00fc\n\t\t\t\tindex++;\n\t\t\u00fc\n\t\u00fc\n\treturn 0;\n\u00fc\n\nstruct MSGXBUF_T\n\u00e4\n\ttime_t     mtime;   // Time and date message was sent\n\tuid_t      muid;    // Sender's effective user ID\n\tgid_t      mgid;    // Sender's effective group ID\n\tpid_t      mpid;    // Sender's process ID\n\tlong int   mtype;   // Message type\n\tint        mtext\u00c4256\u00dc; // Message text\n\u00fc ;\n\ntypedef struct MSGXBUF_T msgxbuf_t;\n\nstruct LOGSTREAM_T\n\u00e4\n\tint length;\n\tint type;\n\tint  mtext\u00c4256\u00dc;\n\u00fc;\n\n\n\nint _dump(char * id,char * p,int l)\n\u00e4\n\tunsigned char ATOE\u00c4256\u00dc =\n\t\u00e4\n\t\t0, 0x1, 0x2, 0x3, 0x37, 0x2d, 0x2e, 0x2f,\n\t\t0x16, 0x5, 0x25, 0xb, 0xc, 0xd, 0xe, 0xf,\n\t\t0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26,\n\t\t0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t0x40, 0x4f, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d,\n\t\t0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61,\n\t\t0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n\t\t0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f,\n\t\t0xb5, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n\t\t0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,\n\t\t0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,\n\t\t0xe7, 0xe8, 0xe9, 0x63, 0xec, 0xfc, 0x5f, 0x6d,\n\t\t0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t\t0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n\t\t0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,\n\t\t0xa7, 0xa8, 0xa9, 0x43, 0xbb, 0xdc, 0x59, 0x7,\n\t\t0x68, 0xd0, 0x51, 0x42, 0xc0, 0x44, 0x47, 0x48,\n\t\t0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4a, 0x67,\n\t\t0x71, 0x9c, 0x9e, 0xcb, 0x6a, 0xcd, 0xdb, 0xdd,\n\t\t0xdf, 0xe0, 0x5a, 0x70, 0xb1, 0x80, 0xbf, 0xff,\n\t\t0x45, 0x55, 0xce, 0xde, 0x49, 0x69, 0x9a, 0x9b,\n\t\t0xab, 0xaf, 0xba, 0xb8, 0xb7, 0xaa, 0x8a, 0x8b,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x62, 0x64,\n\t\t0xb4, 0xff, 0xff, 0xff, 0xff, 0xb0, 0xb2, 0xff,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x46, 0x66,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f,\n\t\t0x8c, 0xac, 0x72, 0x73, 0x74, 0xff, 0x75, 0x76,\n\t\t0x77, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x78, 0xff,\n\t\t0xee, 0xa1, 0xeb, 0xed, 0xcf, 0xef, 0xa0, 0x8e,\n\t\t0xae, 0xfe, 0xfb, 0xfd, 0x8d, 0xad, 0xbc, 0xbe,\n\t\t0xca, 0x8f, 0xff, 0xb9, 0xb6, 0x7c, 0xe1, 0x9d,\n\t\t0x90, 0xbd, 0xb3, 0xda, 0xfa, 0xea, 0xff, 0x41\n\t\u00fc;\n\tint i , o;\n\tprintf(\"%s at:%x(%d)\u00d6n\u00d6n\",id,p,l);\n\tif (p)\n\t\tfor(o = 0;o <((l/16)+1)*16;o+=16)\n\t\t\u00e4\n\t\t\tprintf(\"%4.4lx:\",o);\n\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\u00e4\n\t\t\t\tif ( i < l )\n\t\t\t\t\u00e4\n\t\t\t\t\tprintf(\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n\t\t\t\t\tif (i%4 == 3) printf(\" \");\n\n\t\t\t\t\u00fc\n\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tif ( i%4 == 3) printf(\" \");\n\t\t\t\t\tprintf(\" \");\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tprintf(\" \");\n\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\tif ( i < l )\n\t\t\t\t\tprintf(\"%c\",isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n\t\t\t\telse printf(\" \");\n\t\t\t\tprintf(\" \");\n\t\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\t\tif ( i < l )\n\t\t\t\t\t\tprintf(\"%c\",isprint(ATOE\u00c4p\u00c4i\u00dc\u00dc)?ATOE\u00c4p\u00c4i\u00dc\u00dc:'.');  printf(\"\u00d6n\");\n\n\t\t\u00fc\n\t\treturn l;\n\u00fc\n\nstatic iconv_t cpconv = 0;\nchar    msgbuf\u00c41024\u00dc;\n\nchar* translate(char* input, char* tbl)\n\u00e4\n\tchar *outbuf = msgbuf;\n\tchar *limit  = input + 1023;\n\toutbuf\u00c41023\u00dc = '\u00d60';\n\n\tif (cpconv == 0)\n\t\u00e4\n\t\tsize_t  i,   il, ol;\n\t\tchar   *pe_to_a, *pa_to_e, c\u00c4256\u00dc, *pc = c;\n\n\t\tfor (i=0; i<256; ++i) c\u00c4i\u00dc = i;\n\n\t\tcpconv = iconv_open(\"ISO8859-1\", \"IBM-273\");\n\t\tpc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;\n\t\ticonv(cpconv, &pc, &il, &pe_to_a, &ol);\n\n\t\tcpconv = iconv_open(\"IBM-273\", \"ISO8859-1\");\n\t\tpc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;\n\t\ticonv(cpconv, &pc, &il, &pa_to_e, &ol);\n\t\u00fc\n\twhile ((input < limit) && (*outbuf = tbl\u00c4*input\u00dc))\n\t\u00e4\n\t\t++input; ++outbuf;\n\t\u00fc\n\treturn msgbuf;\n\u00fc\n\n\n\n\n\n\n\n\ntypedef struct r79cchnl * R79celem;\ntypedef struct smf79pro * Smf79pro;\ntypedef struct r79cchnl   R79cchnl;\ntypedef struct r793     * R793;\n#define UINTF(n) (*(unsigned int *)(n))\n#define INTF(n) (*(signed int *)(n))\nstatic R79cchnl channels\u00c4256\u00dc;\ntypedef struct r792elem R792elem;\ntypedef struct r79chl R79chl;\ntypedef struct smf79hdr  SMF79hdr;\ntypedef struct smf79pro  SMF79pro;\ntypedef struct ascb * ascbP;\ntypedef struct asvt * asvtP;\n\nint _rexxrmf2()\n\u00e4\n\tchar w\u00c432760\u00dc;\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tREXXVAR rexx(JOBENV::debug);\n\n\tcvtP      cvt = *(cvtP* )0x10;\n\tasvtP    asvt = asvtP(cvt->cvtasvt);\n\tunsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);\n\tif (JOBENV::debug)\n\t\t_dump(\"ASVT\",(char *)asvtEntryP,4096);\n\n\trexx.set(var(\"RMF2\",0),0);\n\n\tERB2XDGS_Addr Get_SMF_Record_79 = (ERB2XDGS_Addr) NULL;\n\t/* This program's ERB2XDGS default parameters */\n\n\tAnswerAreaAddress MyDgsAnswerAreaAddress = 0;\n\tALET             MyDgsAnswerAreaALET    = 0;\n\tunsigned long int MyDgsAnswerAreaLength = 1048576;\n\n\tSystemName       MySystemName           ;\n\tmemcpy(MySystemName,\"*ALL\",sizeof(MySystemName));\n\n\tDataGatheringParm MyDataGatheringParm   = \u00e4 79, 2, \"\" \u00fc;\n\tDataGatheringPLen MyDataGatheringPLen   = 4;\n\n\tExitName         MyExitName             ;\n\tmemcpy(MyExitName,\"ERB2XSMF\",sizeof(MyExitName));\n\tExitParm         MyExitParm             = \"\";\n\tExitParmLength   MyExitParmLength       = 0;\n\n\tunsigned long int MyDgsTimeOut          = 30;\n\n\tunsigned long int MyDgsReturnCode       = 0;\n\tunsigned long int MyDgsReasonCode       = 0;\n\n\t/* Get ERB2XDGS Answer Area storage */\n\n\tif ( ( MyDgsAnswerAreaAddress\n\t\t= (AnswerAreaAddress) malloc( MyDgsAnswerAreaLength ) ) == (AnswerAreaAddress) NULL )\n\t\u00e4\n\t\trexx.set(\"RMF2_ERROR\",sprintf( w,\"\u00d6nERB2XDGS Answer Area allocation failed.\u00d6n\" ));\n\t\treturn( 8 );\n\t\u00fc;\n\n\t/* Load RMF callable services ... */\n\n\tif ( ( Get_SMF_Record_79 = (ERB2XDGS_Addr)fetch(\"ERB2XDGS\")) == (ERB2XDGS_Addr) NULL )\n\t\u00e4\n\t\trexx.set(\"RMF2_ERROR\",sprintf(w, \"\u00d6nERB2XDGS fetch failed.\u00d6n\" ));\n\t\treturn( 8 );\n\t\u00fc;\n\n\t/* Now invoke RMF callable service ... */\n\n\n\t(*Get_SMF_Record_79)( &MyDgsAnswerAreaAddress,\n\t\t&MyDgsAnswerAreaALET,\n\t\t&MyDgsAnswerAreaLength,\n\t\t&MySystemName,\n\t\t&MyDataGatheringParm,\n\t\t&MyDataGatheringPLen,\n\t\t&MyExitName,\n\t\tMyExitParm,\n\t\t&MyExitParmLength,\n\t\t&MyDgsTimeOut,\n\t\t&MyDgsReturnCode,\n\t\t&MyDgsReasonCode );\n\n\n\t/* Work with the returned RMF Monitor II data ... */\n\tif (MyDgsReturnCode == 0)\n\t\u00e4\n\n\t\t//printf(\" Answer area:%p\u00d6n\",MyDgsAnswerAreaAddress);\n\n\t\tAnswerAreaHeader * h = (AnswerAreaHeader *)MyDgsAnswerAreaAddress;\n\t\tSystemListEntry * s = (SystemListEntry * )\n\t\t\t((char *)h+h->SystemListOffset);\n\t\t/* Release Answer Area storage */\n\t\tsprintf(w,\"%8.8s\",h->SysplexName);\n\t\trexx.set(\"RMF2_SYSPLEX_NAME\",w);\n\n\t\trexx.set(var(\"RMF2_SYSPLEX\",0),int(h->SystemListEntryNumber));\n\t\tfor (int i =0;i <h->SystemListEntryNumber;i++)\n\t\t\u00e4\n\t\t\tsprintf(w,\"%8.8s\",s->MVSSystemName);\n\t\t\trexx.set(var(\"RMF2_SYSPLEX\",i+1,\"SYSTEM_NAME\"),w);\n\t\t\tsprintf(w,\"%4.4s\",s->SMFSystemID);\n\t\t\trexx.set(var(\"RMF2_SYSPLEX\",i+1,\"SYSTEM_SMFID\"),w);\n\t\t\ts =(SystemListEntry *)((char *)s+h->SystemListEntryLength);\n\t\t\u00fc\n\t\tMonitor2DataEntry * d = (Monitor2DataEntry *)((char *)h+h->DataOffset);\n\t\tSMF79hdr * hdr       =(SMF79hdr *)((char *)d+d->Monitor2HeaderLength);\n\n\t\t//printf(\" SMF79hdr:%d SMF79pro:%d R79chl:%d\u00d6n\",\n\t\t//  sizeof(SMF79hdr),sizeof(SMF79pro),sizeof(R79chl));\n\n\t\tR792elem * r = (R792elem *)((char *)hdr+hdr->smf79ass);\n\t\trexx.set(\"RMF2_CPU\",int(d->Monitor2DataSystemCpuUtilization));\n\t\t/*\n\t\tif (argv\u00c41\u00dc)\n\t\tprintf(\" %s (%d)\u00d6n\",argv\u00c41\u00dc,strlen(argv\u00c41\u00dc));\n\t\t*/\n\t\tint count = 0;\n\t\tfor (int i =0;i<hdr->smf79asn;i++)\n\t\t\u00e4\n\t\t\t//if (argv\u00c41\u00dc==0]]memcmpi((const char *)(r->r792jbn),argv\u00c41\u00dc,strlen(argv\u00c41\u00dc))==0)\n\t\t\t\u00e4\n\t\t\t\tcount++;\n\t\t\t\tsprintf(w,\"%4.4X\",*(short *)r->r792asid);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"ASID\"),w);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"JOBID\"),\"\");\n\t\t\t\t//if ((unsigned char )((*asvtEntryP\u00c4(*(short *)r->r792asid)\u00dc)-1)&(unsigned char)0x80==0)\n\t\t\t\t\u00e4\n\t\t\t\t\tascbP myascb = (ascbP)asvtEntryP\u00c4((*(short *)r->r792asid))-1\u00dc;\n\t\t\t\t\tassbP myassb = (assbP)myascb->ascbassb;\n\t\t\t\t\tiazjsabP myjsab = (iazjsabP)myassb->assbjsab;\n\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\t_dump(\"ASCB\",(char *)myascb,1024);\n\t\t\t\t\t\t_dump(\"ASSB\",(char *)myassb,sizeof(*myassb));\n\t\t\t\t\t\t_dump(\"JSAB\",(char *)myjsab,sizeof(*myjsab));\n\t\t\t\t\t\u00fc\n\n\t\t\t\t\tif (myjsab&&myjsab->jsabjbid\u00c40\u00dc)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tsprintf(w,\"%8.8s\",myjsab->jsabjbid);\n\t\t\t\t\t\trexx.set(var(\"RMF2\",count,\"JOBID\"),w);\n\t\t\t\t\t\u00fc\n\n\t\t\t\t\u00fc\n\t\t\t\tsprintf(w,\"%8.8s\",r->r792jbn);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"JOBNAME\"),w);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"DOMAIN\"),*(short *)r->r792jbn);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PERFORMANCE_GROUP\"),*(short*)r->r792npg);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"CURRENT_LOCATION\"),*(short*)r->r792cl);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TRANSACTION_COUNT\"),*(short *)r->r792trc);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TRANSACTION_TIME\"),(*(int *)r->r792trc)/1000);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PRIVATE_FRAMES\"),*(int *)r->r792prfx);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"SRM_SERVICE_RATE\"),*(int *)r->r792svar);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TCB_CPU\"),(*(int *)r->r792tcpu)/1000);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TOTAL_CPU\"),(*(int *)r->r792ejst)/1000);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TOTAL_SRM\"),*(int *)r->r792tsrm);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"STEP_RESIDENT_TIME\"),*(int *)r->r792rtm);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"EXCP_COUNT\"),*(int *)r->r792excp);\n\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_COMMON\"),*(int *)r->r792cmni);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_NONVIO\"),*(int *)r->r792pnv);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_VIO\"),*(int *)r->r792pvio);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_FIXED\"),*(int *)r->r792fxbl);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_SWAPPED_IN\"),*(int *)r->r792pswp);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_LPA_SWAPPED_IN\"),*(int *)r->r792lpai);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_CSA_SWAPPED_IN\"),*(int *)r->r792csai);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_FIXED_LSQA\"),*(int *)r->r792cmni);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_FIXED_NONLSQA\"),*(int *)r->r792cmni);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"DEVICE_CONNECT\"),*(int *)r->r792tdev);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGE_IN\"),*(int *)r->r792pin);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"TRANSACTION_RESIDENCY\"),(*(int *)r->r792trtm)/1000);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"LSQA_REAL\"),*(int *)r->r792lsqr);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"LSQA_EXTENDED\"),*(int *)r->r792lsqe);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"REAL_FRAME_AVERAGE\"),*(int *)r->r792ars);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"SRM_TARGET_WORKINGSET\"),*(int *)r->r792twss);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"HIPERSPACE_PAGES\"),*(int *)r->r792phsp);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"PAGES_COMMONT\"),*(int *)r->r792cmni);\n\t\t\t\tsprintf(w,\"%8.8s\",r->r792scl);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"SERVICE_CLASS\"),w);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"SERVICE_CLASS_PERIOD\"),*(short *)r->r792scp);\n\t\t\t\tsprintf(w,\"%8.8s\",r->r792wkld);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"WORKLOAD_NAME\"),w);\n\t\t\t\tsprintf(w,\"%8.8s\",r->r792rgrp);\n\t\t\t\trexx.set(var(\"RMF2\",count,\"RESOURCE_GROUP\"),w);\n\t\t\t\u00fc\n\t\t\tr =(R792elem *)((char *)r+hdr->smf79asl);\n\n\t\t\u00fc\n\t\trexx.set(var(\"RMF2\",0),count);\n\t\u00fc\n\telse\n\t\u00e4\n\t\tsprintf(w,\" ERB2XDGS rc:%d reason:%d\u00d6n\",MyDgsReturnCode,MyDgsReasonCode);\n\t\trexx.set(\"RMF2_ERROR\",w);\n\t\u00fc\n\tfree( MyDgsAnswerAreaAddress );\n\n\treturn( MyDgsReturnCode );\n\n\u00fc;\n\nconst int Mbyte = 1024*1024;\nchar vsmlist\u00c4Mbyte\u00dc;\ncvtP      cvt = *(cvtP* )0x10;\nasvtP    asvt = asvtP(cvt->cvtasvt);\nunsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);\nint procVsmlist(char *);\n\nclass  asData\n\u00e4\npublic:\n\tascbP ascb;\n\tshort asid;\n\tchar jobname\u00c49\u00dc;\n\tchar jobid\u00c49\u00dc;\n\tDBLWRD cpu;\n\tDBLWRD cpuOld;\n\tDBLWRD * ejst;\n\tDBLWRD * srbt;\n\tint stor;\n\tint storDiff;\n\tDBLWRD * iosx;\n\tDBLWRD  excp;\n\tDBLWRD  excpDiff;\n\tchar time\u00c430\u00dc;\n\tint times;\npublic:\n\tasData(const char * );\n\tasData(int id)\n\t\u00e4\n\t\tif ((unsigned char )(*asvtEntryP\u00c4id\u00dc)&(unsigned char)0x80==0)\n\t\t\tascb = (ascbP)asvtEntryP\u00c4id\u00dc;\n\t\tinit();\n\t\u00fc\n\tint set();\n\tvoid print();\n\tint printRexx(REXXVAR *);\n\tvoid get();\n\tvoid printTitle()\n\t\u00e4\n\t\tprintf(\" %s %s\u00d6n\",jobname,jobid);\n\t\tprintf(\"    Cpu     CpuD      Stor      StorD      Excp    ExcpD \u00d6n\");\n\t\u00fc\nprivate:\n\tascbP search(const char *);\n\tvoid init();\n\u00fc ;\n\nasData::asData(const char * name)\n\u00e4\n\tif (ascb = search(name))\n\t\tinit();\n\u00fc\n\nascbP asData::search(const char * name)\n\u00e4\n\tascbP a = NULL;\n\tunsigned char * pascb =(unsigned char *)&(asvt->asvtenty);\n\tfor (int i =0;i<asvt->asvtmaxi;i++,pascb+=4)\n\t\u00e4\n\t\tif ((*pascb&(unsigned char)0x80)==0)\n\t\t\u00e4\n\t\t\ta = *(ascbP *)pascb;\n\t\t\tif (a)\n\t\t\t\u00e4\n\t\t\t\tif (a->ascbjbni)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (memcmp(name,a->ascbjbni,strlen(name))==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tif  (memcmp(name,a->ascbjbns,strlen(name))==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\tif (JOBENV::debug)\n\t\t_dump(\"ASCB\",(char *)a,1024);\n\treturn a;\n\u00fc\n\nvoid asData::init()\n\u00e4\n\tasid  = ascb->ascbasid;\n\tif (ascb->ascbjbni)\n\t\tsprintf(jobname,\"%8.8s\",ascb->ascbjbni);\n\telse\n\t\tsprintf(jobname,\"%8.8s\",ascb->ascbjbns);\n\tfor(int i =0;i<8;i++)\n\t\tif (jobname\u00c4i\u00dc == ' ')\n\t\t\tjobname\u00c4i\u00dc = 0;\n\n\tassbP assb = (assbP)ascb->ascbassb;\n\tiazjsabP jsab = (iazjsabP)assb->assbjsab;\n\tif (jsab->jsabjbid\u00c40\u00dc)\n\t\tsprintf(jobid,\"%8.8s\",jsab->jsabjbid);\n\telse\n\t\tjobid\u00c40\u00dc =0;\n\tejst = (DBLWRD *)&(ascb->ascbejst);\n\tsrbt = (DBLWRD *)&(ascb->ascbsrbt);\n\tcpu = *ejst+*srbt;\n\tcpuOld = cpu;\n\tiosx = (DBLWRD *)&(ascb->ascbiosx);\n\texcp = *iosx;\n\texcpDiff = excp;\n\tif (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))\n\t\tstor = procVsmlist(vsmlist);\n\telse\n\t\tstor = 0;\n\tstorDiff = stor;\n\ttimes = 0;\n\tformatTime(time,sizeof(time),\"%H:%M:%S\");\n\tif (JOBENV::debug)\n\t\t_dump(\"asData\",(char *)this,sizeof(asData));\n\u00fc;\n\nint  asData::set()\n\u00e4\n\ttimes +=   (argv\u00c42\u00dc?atoi(argv\u00c42\u00dc):60);\n\tassbP assb = (assbP)ascb->ascbassb;\n\tiazjsabP jsab = (iazjsabP)assb->assbjsab;\n\n\tif (((ascb->ascbjbni&&memcmp(jobname,ascb->ascbjbni,8)==0)]]\n\t\tmemcmp(jobname,ascb->ascbjbns,8)==0)&&\n\t\tmemcmp(jobid,jsab->jsabjbid,8)==0)\n\t\u00e4\n\t\tcpuOld = cpu;\n\t\tcpu = *ejst+*srbt;\n\t\texcpDiff = *iosx-excp;\n\t\texcp = *iosx;\n\t\tif (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))\n\t\t\u00e4\n\t\t\tint _stor = procVsmlist(vsmlist);\n\t\t\tstorDiff = _stor-stor;\n\t\t\tstor = _stor;\n\t\t\u00fc\n\t\telse\n\t\t\tstor = storDiff =0;\n\t\tformatTime(time,sizeof(time),\"%H:%M:%S\");\n\t\tif (JOBENV::debug)\n\t\t\t_dump(\"asData\",(char *)this,sizeof(asData));\n\t\treturn 1;\n\t\u00fc\n\telse\n\t\treturn 0;\n\u00fc\n\nvoid asData::print()\n\u00e4\n\tint _cpu = ((cpu>>12)+500)/1000;\n\tint _cpuOld = ((cpuOld>>12)+500)/1000;\n\tprintf(\"%d %d %d %d %d %llu  %llu\u00d6n\",times,\n\t\t_cpu,_cpu-_cpuOld,\n\t\tstor,storDiff,\n\t\texcp,excpDiff);\n\u00fc\n\nint asData::printRexx(REXXVAR * rexx)\n\u00e4\n\tint _cpu = ((cpu>>12)+500)/1000;\n\tint _excp = excp/1024;\n\t/*\n\trexx->set(var(jobname,0,\"CPU\"),_cpu);\n\trexx->set(var(jobname,0,\"EXCP\"),_excp);\n\trexx->set(var(jobname,0,\"VSTOR\"),stor);\n\t*/\n\treturn stor;\n\u00fc\n\nint procVsmlist(char * pList)\n\u00e4\n\tif (JOBENV::debug)\n\t\t_dump(\"vsmList\",pList,4096);\n\tint size = 0;\n\tint *p   = (int *)pList;\n\tint  tcbcount = *p++;\n\twhile (tcbcount--)\n\t\u00e4\n\t\tbool need = true;\n\t\tint tcb    =  *p++;\n\t\tint spcount = *p++;\n\t\twhile(spcount--)\n\t\t\u00e4\n\t\t\tint subpool = (*p>>8&0x000000FF);\n\t\t\tp+=1;\n\t\t\tneed = (tcb == *p++);\n\t\t\tint bcount = *p++;\n\t\t\twhile(bcount--)\n\t\t\t\u00e4\n\t\t\t\tif ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\tprintf(\" %p  \",*p);\n\t\t\t\t\tp+=1;\n\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\tprintf(\" %p\",*p);\n\t\t\t\t\tsize +=*p++;\n\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\tprintf(\" size:%d subpool:%d\u00d6n\",size,subpool);\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tp+=2;\n\t\t\t\tint fcount = *p++;\n\t\t\t\twhile(fcount--)\n\t\t\t\t\u00e4\n\t\t\t\t\tif ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\t\tprintf(\" %p  \",*p);\n\t\t\t\t\t\tp+=1;\n\t\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\t\tprintf(\" %p\",*p);\n\t\t\t\t\t\tsize -=*p++;\n\t\t\t\t\t\tif (JOBENV::debug)\n\t\t\t\t\t\t\tprintf(\" size:%d subpool:%d\u00d6n\",size,subpool);\n\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\tp+=2;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\treturn (size+512)/1024;\n\u00fc\n\n\nint _vsmlist()\n\u00e4\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tasData * as = new asData(argv\u00c41\u00dc);\n\tas->printTitle();\n\tint count= argv\u00c43\u00dc?atoi(argv\u00c42\u00dc):10;\n\tfor(int i = 0;i<count;i++)\n\t\u00e4\n\t\tsleep(argv\u00c42\u00dc?atoi(argv\u00c42\u00dc):60);\n\t\tas->set();\n\t\tas->print();\n\t\u00fc\n\treturn 0;\n\u00fc\n\nint _rexxvsm()\n\u00e4\n\tREXXVAR rexx(JOBENV::debug);\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tasData * as = new asData(argv\u00c41\u00dc);\n\treturn as->printRexx(&rexx);\n\u00fc\n#define GIM_FREE      \"FREE    \"\n#define GIM_QUERY     \"QUERY   \"\n#define GIM_VERSION   \"VERSION \"\n#define APILANG   \"ENU\"\n#define TXT_VER   \"VER\"\n#define LEN_ETYPE        12\n#define LEN_ENAME         8\n#define LEN_ZNAME         7\n#define LEN_VERNUM        3\n#define LEN_TXTVER        3\n#define LEN_MSG         256\ntypedef void APIPGM(char *,void *,void *,char *,long *,long  *, char *);\ntypedef void cfunc();\n#pragma linkage(APIPGM,OS)\n\nstatic void errprint(char *, long, long, ITEM_LIST *,REXXVAR &);\nstatic char *valprint(ITEM_LIST *);\nstatic void resprint(ENTRY_LIST *,REXXVAR & );\n\nint _rexxgim()\n\u00e4\n\tchar w\u00c432760\u00dc;\n\tjobEnv = new JOBENV(argv\u00c40\u00dc);\n\tREXXVAR rexx(JOBENV::debug);\n\tlong  rc,cc;\n\tQUERY_PARMS qparms;\n\tP_QUERY_PARMS pqparms = &qparms;\n\tENTRY_LIST  *qreslt;\n\tITEM_LIST   *msgbuff;\n\tAPIPGM      *gimapi;\n\tAPI_VERSION pgmversion;\n\tAPI_VERSION *apiversion;\n\n\tchar csi\u00c445\u00dc;\n\tchar zone\u00c4100\u00dc;\n\tchar ent\u00c4100\u00dc;\n\tchar subent\u00c4100\u00dc;\n\tchar filter\u00c41024\u00dc;\n\n\trc = 0;\n\tcc = 0;\n\n\t/******************************************************************/\n\t/* Initialize pgmversion to API version used when program was     */\n\t/* written.  This is compared with the version returned from a    */\n\t/* call to GIMAPI with the VERSION command.                       */\n\t/******************************************************************/\n\n\tstrncpy((char *)&pgmversion,\"01090500\",8);\n\n\t/***********************************************/\n\t/* Load the GIMAPI load module for use later   */\n\t/***********************************************/\n\tgimapi = (APIPGM *) fetch(\"GIMAPI\");\n\trexx.set(var(\"GIM\",0),0);\n\trexx.set(\"GIM_ERROR\",\"\");\n\t/****************************************************************/\n\t/* Call GIMAPI with VERSION to check if compatible with version */\n\t/* used when program was written.                               */\n\t/****************************************************************/\n\tgimapi(GIM_VERSION,0,(void**) &apiversion,APILANG,&rc,&cc,(char *)&msgbuff);\n\n\tif (rc|=0)\n\t\u00e4\n\t\terrprint(GIM_VERSION, rc, cc, msgbuff,rexx);\n\t\tif (rc>4) goto EXIT;\n\t\u00fc\n\n\tif (strncmp((const char *)&pgmversion,(const char *)apiversion,8)>0)\n\t\u00e4\n\t\tprintf(\"Incompatible Versions of the API\u00d6n\");\n\t\tprintf(\"  API Version: %.8s\u00d6n\",apiversion);\n\t\tprintf(\"  Pgm Version: %.8s\u00d6n\",&pgmversion);\n\t\tgoto EXIT;\n\t\u00fc\n\tsprintf(w,\"%.2s %.2s %.2s %.2s\",apiversion->apiver,apiversion->apirel,apiversion->apimod,apiversion->apiptf);\n\trexx.set(\"GIM_VERSION\",w);\n\t/*\n\tprintf(\"API Version Used:\u00d6n\");\n\tprintf(\"  Version: %.2s\u00d6n\",apiversion->apiver);\n\tprintf(\"  Release: %.2s\u00d6n\",apiversion->apirel);\n\tprintf(\"  Mod    : %.2s\u00d6n\",apiversion->apimod);\n\tprintf(\"  PTF    : %.2s\u00d6n\u00d6n\",apiversion->apiptf);\n\t*/\n\t/*****************************************************/\n\t/* Create the QUERY. Put the parameter strings into  */\n\t/* variables and put the addresses of those variables*/\n\t/* in the query parameter structure along with the   */\n\t/* length of those strings.                          */\n\t/*****************************************************/\n\tstrcpy(csi,rexx.fetch(\"GIM_CSI\"));\n\tstrcpy(zone,rexx.fetch(\"GIM_ZONE\"));\n\tstrcpy(ent,rexx.fetch(\"GIM_ENTRY\"));\n\tstrcpy(subent,rexx.fetch(\"GIM_SUBENTRY\"));\n\tstrcpy(filter,rexx.fetch(\"GIM_FILTER\"));\n\n\tqparms.csi          = csi;\n\tqparms.csilen       = strlen(csi);\n\tqparms.zone         = zone;\n\tqparms.zonelen      = strlen(zone);\n\tqparms.entrytype    = ent;\n\tqparms.entrylen     = strlen(ent);\n\tqparms.subentrytype = subent;\n\tqparms.subentrylen  = strlen(subent);\n\tqparms.filter       = filter;\n\tqparms.filterlen    = strlen(filter);\n\n\tgimapi(GIM_QUERY,&pqparms,(void**) &qreslt,APILANG,&rc,&cc,(char *)&msgbuff);\n\n\tif (rc|=0)\n\t\u00e4\n\t\terrprint(GIM_QUERY, rc, cc, msgbuff,rexx);\n\t\tif (rc>4) goto EXIT;\n\t\u00fc\n\n\t/******************************************/\n\t/* Call routine to print results of query */\n\t/******************************************/\n\tresprint(qreslt,rexx);\n\nEXIT:\n\t/****************************************/\n\t/* Free storage returned from the QUERY */\n\t/****************************************/\n\tgimapi(GIM_FREE,0,0,APILANG,&rc,&cc,(char *)&msgbuff);\n\treturn 0;\n\t//release ((cfunc*)gimapi); ????????????????\n\u00fc\n\n/******************************/\n/* Print results of the query */\n/******************************/\nstatic void resprint(ENTRY_LIST *head,REXXVAR &rexx)\n\u00e4\n\tENTRY_LIST  *curetype;\n\tCSI_ENTRY   *curentry;\n\tSUBENTRY    *cursubent;\n\tVER         *curver;\n\tSUBENTRY    *curversub;\n\tchar        etype\u00c413\u00dc;\n\tchar        vernumber\u00c413\u00dc;\n\tchar        versubtype\u00c413\u00dc;\n\tchar        stEname\u00c4LEN_ENAME+1\u00dc;\n\tchar        stZname\u00c4LEN_ZNAME+1\u00dc;\n\tchar w\u00c432760\u00dc;\n\t/********************************/\n\t/* Loop through each entry type */\n\t/********************************/\n\tint index = 0;\n\tfor (curetype=head; curetype|=0 ; curetype=curetype->next)\n\t\u00e4\n\t\t/********************************************/\n\t\t/* Print name of entry type being processed */\n\t\t/********************************************/\n\n\t\tstrncpy(etype,curetype->type,LEN_ETYPE);\n\t\tetype\u00c4LEN_ETYPE\u00dc = '\u00d60';\n\t\trexx.set(var(\"GIM\",++index,\"ETYPE\"),etype);\n\n\t\t/********************************************************/\n\t\t/* Loop through each entry printing the ename and zone  */\n\t\t/* then the list of subentry values.                    */\n\t\t/********************************************************/\n\t\tfor (curentry=curetype->entries;\n\t\t\tcurentry|=0;\n\t\t\tcurentry=curentry->next)\n\t\t\u00e4\n\t\t\tstrncpy(stEname,curentry->entryname,LEN_ENAME);\n\t\t\tstEname\u00c4LEN_ENAME\u00dc='\u00d60';\n\t\t\tstrncpy(stZname,curentry->zonename,LEN_ZNAME);\n\t\t\tstZname\u00c4LEN_ZNAME\u00dc='\u00d60';\n\n\t\t\trexx.set(var(\"GIM\",index,\"ENAME\"),stEname);\n\t\t\trexx.set(var(\"GIM\",index,\"ZONE\"),stZname);\n\t\t\tint vindex= 0;\n\t\t\tfor (cursubent=curentry->subentries;\n\t\t\t\tcursubent|=0;\n\t\t\t\tcursubent=cursubent->next)\n\t\t\t\u00e4\n\t\t\t\tstrncpy(etype,cursubent->type,LEN_ETYPE);\n\t\t\t\tetype\u00c4LEN_ETYPE\u00dc = '\u00d60';\n\t\t\t\tchar * val ;\n\t\t\t\tif ((strncmp(etype,TXT_VER,LEN_TXTVER)) == 0)\n\t\t\t\t\u00e4\n\t\t\t\t\tfor (curver=(P_VER) cursubent->subentrydata;\n\t\t\t\t\t\tcurver|=0;\n\t\t\t\t\t\tcurver=curver->next)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tstrncpy(vernumber,curver->vernum,LEN_VERNUM);\n\t\t\t\t\t\tvernumber\u00c4LEN_VERNUM\u00dc='\u00d60';\n\t\t\t\t\t\tfor (curversub=curver->verdata;\n\t\t\t\t\t\t\tcurversub|=0;\n\t\t\t\t\t\t\tcurversub=curversub->next)\n\t\t\t\t\t\t\u00e4\n\n\t\t\t\t\t\t\t/*********************************/\n\t\t\t\t\t\t\t/* Now print ver subentry values */\n\t\t\t\t\t\t\t/*********************************/\n\t\t\t\t\t\t\tstrncpy(versubtype,curversub->type,LEN_ETYPE);\n\t\t\t\t\t\t\tversubtype\u00c4LEN_ETYPE\u00dc='\u00d60';\n\t\t\t\t\t\t\tsprintf(w,\"%.6s.%s\",versubtype,vernumber);\n\t\t\t\t\t\t\tval = valprint((ITEM_LIST *)curversub->subentrydata);\n\t\t\t\t\t\t\trexx.set(var(\"GIM\",index,w),val);\n\t\t\t\t\t\t\trexx.set(var(\"GIM\",index,\"VAR\",++vindex,\"TYPE\"),w);\n\t\t\t\t\t\t\trexx.set(var(\"GIM\",index,\"VAR\",vindex,\"VALUE\"),val);\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\u00fc\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tval = valprint((ITEM_LIST *)cursubent->subentrydata);\n\t\t\t\t\trexx.set(var(\"GIM\",index,etype),val);\n\t\t\t\t\trexx.set(var(\"GIM\",index,\"VAR\",++vindex,\"TYPE\"),etype);\n\t\t\t\t\trexx.set(var(\"GIM\",index,\"VAR\",vindex,\"VALUE\"),val);\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\trexx.set(var(\"GIM\",index,\"VAR\",0,\"VALUE\"),vindex);\n\t\t\u00fc\n\t\u00fc\n\trexx.set(var(\"GIM\",0),index);\n\u00fc\n\nstatic char * valprint(ITEM_LIST *item1)\n\u00e4\n\tstatic char w\u00c41024*1024\u00dc;\n\tchar        databuff\u00c41024*128\u00dc;\n\tITEM_LIST   *curitem;\n\tw\u00c40\u00dc = 0;\n\tfor (curitem=item1;\n\t\tcuritem|=0;\n\t\tcuritem=curitem->next)\n\t\u00e4\n\t\tstrncpy(databuff,curitem->data,curitem->datalen);\n\t\tdatabuff\u00c4curitem->datalen\u00dc = '\u00d60';\n\t\tsprintf(w+strlen(w),\"%s \",databuff);\n\t\u00fc   return w;\n\u00fc\n\nstatic void errprint(char *cmd, long rc, long cc, ITEM_LIST *msgs,REXXVAR & rexx)\n\u00e4\n\tchar   msgout\u00c4LEN_MSG+1\u00dc;\n\tITEM_LIST *curmsg;\n\tunsigned short i;\n\tchar w\u00c41024\u00dc;\n\tsprintf(w,\"Error processing command: %s. RC=%d CC=%d\u00d6n\",\n\t\tcmd,rc,cc);\n\trexx.set(\"GIM_ERROR\",w);\n\tint index= 1;\n\t/*************************************************/\n\t/* Loop through a linked list of error messages  */\n\t/* printing them out.                            */\n\t/*************************************************/\n\tfor (curmsg=msgs; curmsg|=0; curmsg=curmsg->next)\n\t\u00e4\n\t\tstrncpy(msgout,curmsg->data,curmsg->datalen);\n\t\tmsgout\u00c4curmsg->datalen\u00dc = '\u00d60';\n\t\trexx.set(var(\"GIM_ERR\",index),msgout);\n\t\u00fc\n\trexx.set(var(\"GIM_ERR\",0),index);\n\u00fc\n\n\nint main(int argC,char * argV\u00c4\u00dc)\n\u00e4\n\tconst static char *version=ISIS_VERSION;\n\tconst static char *compileDate=ISIS_VERSION_DATE;\n\tif (strcmp(argV\u00c40\u00dc,\"MVSTOOL\")==0)\n\t\tprintf(\" MVSTOOL tester %s %s Version:%s Compiled:%s\u00d6n\",ISIS_PF_SID,ISIS_PF_NAME,version,compileDate);\n\tint j = 0;\n\tint count = 1;\n\tfor (j= 0;testCases\u00c4j\u00dc.addr;j++)\n\t\tif (memcmpi(testCases\u00c4j\u00dc.name,argV\u00c40\u00dc,strlen(argV\u00c40\u00dc))==0)\n\t\t\tbreak;\n\tif (testCases\u00c4j\u00dc.addr==NULL)\n\t\u00e4\n\t\tfor (int i = 0;i<argC;i++)\n\t\t\u00e4\n\t\t\tif (memcmpi(argV\u00c4i\u00dc,\"-t\",2)==0)\n\t\t\t\u00e4\n\t\t\t\tfor (j= 0;testCases\u00c4j\u00dc.addr;j++)\n\t\t\t\t\tif (memcmpi(testCases\u00c4j\u00dc.name,argV\u00c4i\u00dc+2,strlen(argV\u00c4i\u00dc)-2)==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (testCases\u00c4j\u00dc.addr==NULL)\n\t\t\t\t\u00e4\n\t\t\t\t\tprintf(\"Invalid test case, %s\u00d6n\",argV\u00c4i\u00dc+2);\n\t\t\t\t\tfor(j=0;testCases\u00c4j\u00dc.addr;j++)\n\t\t\t\t\t\tprintf(\"  %s\u00d6n\",testCases\u00c4j\u00dc.name);\n\t\t\t\t\texit(8);\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\t/*\n\t\t\telse if (memcmpi(argV\u00c4i\u00dc,\"-r\",2)==NULL)\n\t\t\t\u00e4\n\t\t\tcount = atoi(argV\u00c4i\u00dc+2);\n\t\t\tif (count==0)\n\t\t\tcount = 1;\n\t\t\t\u00fc\n\t\t\t*/\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\targv\u00c4argc++\u00dc = argV\u00c4i\u00dc;\n\t\t\t\tif (strcmp(argV\u00c40\u00dc,\"MVSTOOL\")==0)\n\t\t\t\t\tprintf(\"arg\u00c4%d\u00dc:%s\u00d6n\",argc-1,argv\u00c4argc-1\u00dc);\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\telse\n\t\u00e4\n\t\tfor (int i =0;i<argC;i++)\n\t\t\targv\u00c4argc++\u00dc = argV\u00c4i\u00dc;\n\t\tif (strcmp(argV\u00c40\u00dc,\"MVSTOOL\")==0)\n\t\t\tprintf(\"arg\u00c4%d\u00dc:%s\u00d6n\",argc-1,argv\u00c4argc-1\u00dc);\n\t\u00fc\n\tif (strcmp(argV\u00c40\u00dc,\"MVSTOOL\")==0)\n\t\u00e4\n\t\tprintf(\" Starting %s %d times(argc:%d)\u00d6n\u00d6n\u00d6n\",testCases\u00c4j\u00dc.name,count,argc);\n\t\tfor(;count;count--)\n\t\t\u00e4\n\t\t\tif (strcmp(argV\u00c40\u00dc,\"MVSTOOL\")==0)\n\t\t\t\tprintf(\" ended with %d\u00d6n\",testCases\u00c4j\u00dc.addr());\n\t\t\u00fc\n\t\treturn 0;\n\t\u00fc\n\telse\n\t\treturn (testCases\u00c4j\u00dc.addr());\n\u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "OSMFND": {"ttr": 255, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/osmfnd.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#if defined(OWN_STDIO) == 1\n#include \"stdio.hpp\"\n#endif\n\n#ifndef PCS_MAX_PATH\n#define PCS_MAX_PATH 1024\n#endif\n\n\n//#ifndef OWN_STDIO  common code for OWN_STDIO and non OWN_STDIO szm\n#include \"os.hpp\"\n#include \"mchain.hpp\"\n#include \"osmfind.hpp\"\n#include \"mvsbase.hpp\"\n#include \"misc.hpp\"\n#include \"casmif.hpp\"\n#include \"ibmdebug.hpp\"\n#include <stdio.h>\n#include <strings.h>\n#include <map>\n#include <string>\n#include \"xxstdio.hpp\"\n//szm20050825 ddname reallocation and free code moved here from XFILE\n#include <dynit.h>\n\nclass  ddAlloc:public chainE\n\u00e4\nprivate:\n\tchar * req;\npublic:\n\tddAlloc(const char * ddReq,const char * ddUsed):chainE(ddUsed)\n\t\u00e4\n\t\tif(ddReq)\n\t\t\treq = strdup(ddReq);\n\t\telse\n\t\t\treq = NULL;\n\t\u00fc\n\tddAlloc():chainE()\n\t\u00e4 req = NULL;\u00fc\n\t\u00dfddAlloc()\n\t\u00e4\n\t\tif (req)\n\t\t\tfree(req);\n\t\treq = NULL;\n\t\u00fc\n\tchar * getDdUsed()\u00e4return chainEid;\u00fc\n\tchar * getDdReq()\u00e4return req;\u00fc\n\u00fc;\n\nclass  ddAllocList:public SORTEDmCHAIN\n\u00e4\nprivate:\n\t__dyn_t ip;\n\tchar    ddn_\u00c49\u00dc;\n\tCHAINITER * iter;\npublic:\n\tddAllocList():SORTEDmCHAIN()\n\t\u00e4\n\t\tmemset(ddn_,0,sizeof(ddn_));\n\t\titer = NULL;\n\t\u00fc\n\tvirtual \u00dfddAllocList()\n\t\u00e4\n\t\tddAlloc * a = NULL;\n\t\tif (iter==NULL)\n\t\t\titer = new CHAINITER(this);\n\n\t\titer->reset();\n\t\twhile(a=(ddAlloc*)iter->next())\n\t\t\u00e4\n\t\t\tdyninit(&ip);\n\t\t\tip.__ddname=a->getDdUsed();\n\t\t\tHOST_IBM_TRACE_ss(\" Dynamic free\",ip.__ddname);\n\t\t\tif (dynfree(&ip))\n\t\t\t\tprintf(\" Dynamic free error for %s\u00d6n\",ip.__ddname);\n\t\t\u00fc\n\t\tif (iter)\n\t\t\tdelete iter;\n\t\u00fc\n\tchar *  alloc(const char * dsn,const char * dd)\n\t\u00e4\n\t\tddAlloc * a = NULL;\n\t\tif (iter==NULL)\n\t\t\titer = new CHAINITER(this);\n\n\t\titer->reset();\n\t\tint rc = 0;\n\t\twhile(a=(ddAlloc*)iter->next())\n\t\t\u00e4\n\t\t\t//if (strcmp(dd,a->getDdUsed()) == NULL) //ZA070731\n\t\t\tif (strcmp(dd,a->getDdReq()) == NULL) //ZA070731\n\t\t\t\treturn a->getDdUsed();\n\t\t\u00fc\n\t\tdyninit(&ip);\n\t\tstrcpy(ddn_,\"????????\");\n\t\tip.__ddname = ddn_;\n\t\tip.__dsname = (char *)dsn;\n\t\tip.__status = __DISP_SHR;\n\t\tif (rc=dynalloc(&ip))\n\t\t\u00e4\n\t\t\tprintf(\" Dynalloc error for:%s rc:%d info:%d errcode:%d\u00d6n\",dsn,rc,ip.__infocode,ip.__errcode);\n\t\t\treturn NULL;\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tHOST_IBM_TRACE_ss(\" Dynamic alloc\",ip.__ddname);\n\t\t\tadd(new ddAlloc(dd,ip.__ddname));\n\t\t\treturn ddn_;\n\t\t\u00fc\n\t\u00fc\n\u00fc;\n\nddAllocList  * dal = NULL;\nclass ddAllocListHelper\n\u00e4\npublic:\n\tddAllocListHelper()\u00e4\u00fc;\n\t\u00dfddAllocListHelper()\u00e4 if (dal) delete dal;dal = NULL;\u00fc\n\u00fc;\nddAllocListHelper dalHelper;\n\nint ddDynAlloc(char * dsn,char * member,char * ddn,char * togen)\n\u00e4\n\tint rc = 0;\n\tif (dsn==NULL ]] member == NULL ]] ddn == NULL ]] togen == NULL )\n\t\treturn 0;\n\tif (dal==NULL)\n\t\tdal = new ddAllocList();\n\tchar * d = dal->alloc(dsn,ddn);\n\tif (d)\n\t\u00e4\n\t\tsprintf(togen,\"%s%s(%s)\",DDNAME_PREFIX,d,member);\n\t\trc = 1;\n\t\u00fc\n\treturn rc;\n\u00fc\n\n//szm20050825 ddname reallocation and free code moved here from XFILE\n\nint osmfindo(struct DSNINFO * dsninfo,const char * pattern);\nISIS_EXT_ASM int DDNAMES(char * dd,char * dsns,int max,char * );\n\nstatic _DDNAMES(char *dd,char *dsns,int max,char * member=NULL)\n\u00e4\n\tint rc = DDNAMES(dd,dsns,max,member);\n\treturn rc;\n\u00fc\n\n//contains the chain of datasets\nDataSNames * datasnames = new DataSNames();\n\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n#include <regex.h>\n#include <locale.h>\n#include <ctest.h>\n#endif\n\n// temp file allocation for IBM\n/*\n\n*/\n\nclass tmpName : public chainE\n\u00e4\nprivate:\n\tFILE * f;\npublic:\n\t\u00dftmpName()\u00e4\u00fc\n\ttmpName(char * n,FILE *fp):chainE(n),f(fp)\u00e4\u00fc\n\tFILE * getFile()\u00e4return f;\u00fc\n\u00fc;\nclass tmpNames : public SORTEDmCHAIN\n\u00e4\nprivate:\n\tCHAINITER * iter;\npublic:\n\ttmpNames():SORTEDmCHAIN()\n\t\u00e4 iter = new CHAINITER( *this);\u00fc\n\t\u00dftmpNames()\n\t\u00e4\n\t\titer->reset();\n\t\ttmpName * n = (tmpName *)iter->next();\n\t\twhile(n)\n\t\t\u00e4\n\t\t\tif (remove(n->chainEid))\n\t\t\t\u00e4\n\t\t\t\tfclose(n->getFile());\n\t\t\t\tremove(n->chainEid);\n\t\t\t\u00fc\n\t\t\tn = (tmpName *)iter->next();\n\t\t\u00fc\n\t\u00fc\n\u00fc;\n\n\ntmpNames _tmpNames;\n\nstatic const char * systmp\t\t\t= \"SYSTMP\";\nstatic        char  systmpDef\u00c4256\u00dc = \"wb+,space=(trk,(150,150))\";\nstatic        char  systmpPref\u00c464\u00dc= \"SYSTMP\";\nstatic       int    systmpIndex = 1; //szm20040202 from SYSTMP01\nstatic       int    systmpFlag  = 0;\nstatic       int    systmpUss   = 0;\nFILE   * tmpFile(char * usedname)//szm20060908 tmpFile in mu\n\u00e4\n\n\t//char work\u00c41024\u00dc; problem with more than 16 concat's szm\n\tchar work\u00c4MAXDSNS\u00dc;\n\tchar prefix\u00c4128\u00dc;\n\n\tstatic FILE * f = NULL;\n\tif (systmpFlag==0)\n\t\u00e4\n\t\tsystmpUss = getenv(\"TEMP_HFS\")?1:0;\n\t\tf = fopen(\"dd:SYSTMPZZ\",\"r\");\n\t\tif (f && fgets(work,sizeof(work)-1,f))\n\t\t\u00e4\n\t\t\tint i;\n\t\t\tfor(i = 0;i<sizeof(work)-1&&i<sizeof(systmpDef)-1&&work\u00c4i\u00dc-' '&&work\u00c4i\u00dc-'\u00d6n';i++)\n\t\t\t\tsystmpDef\u00c4i+4\u00dc = work\u00c4i\u00dc;\n\t\t\tsystmpDef\u00c4i+4\u00dc = 0;\n\t\t\tif (fgets(work,sizeof(work)-1,f))\n\t\t\t\u00e4\n\t\t\t\tint i;\n\t\t\t\tfor(i= 0;i<sizeof(work)-1&&i<sizeof(systmpDef)-1&&work\u00c4i\u00dc-' '&&work\u00c4i\u00dc-'\u00d6n';i++)\n\t\t\t\t\tsystmpPref\u00c4i\u00dc = work\u00c4i\u00dc;\n\t\t\t\tsystmpPref\u00c4i\u00dc = 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tif (strchr(systmpPref,' '))\n\t\t\t\t\t*strchr(systmpPref,' ')=0;\n\t\t\tfclose(f);\n\t\t\u00fc\n\t\u00fc\n\tsprintf(work,\"%s%0.2d\",systmp,systmpIndex);\n\tHOST_IBM_TRACE_ss(work,systmpDef);\n\tif (_DDNAMES(work,work,MAXDSNS))\n\t\u00e4\n\t\tsystmpIndex++;\n\t\tif (f==NULL&&systmpUss)\n\t\t\treturn (tmpfile());\n\t\tsystmpFlag++;\n\t\tchar  * dsn = tmpnam(NULL);\n\t\tchar  * p   = dsn;\n\t\twhile(p=strchr(dsn,'/'))\n\t\t\tdsn=p+1;\n\t\tdsn\u00c435\u00dc = 0;\n\t\tif (systmpUss) //szm\n\t\t\t//sprintf(work,\"//'%s.T%s'\",systmpPref,dsn+1);\n\t\t\tsprintf(work,\"//%s.T%s\",systmpPref,dsn+1); //szm\n\t\telse\t\t\t\t\t//szm\n\t\t\tsprintf(work,\"//'%s.T%s'\",systmpPref,dsn+1); //szm\n\n\t\tFILE * f = fopen(work,systmpDef);\n\t\tif (f && usedname)\t\t\t\t\t\t//szm20060908 tmpFile in mu\n\t\t\tstrcpy(usedname,systmpDef); //szm20060908 tmpFile in mu\n\t\t_tmpNames.add(new tmpName(work,f));\n\t\tHOST_IBM_TRACE_ss(work,systmpDef);\n\t\treturn(f);\n\t\u00fc\n\telse\n\t\u00e4\n\t\tsprintf(work,\"//dd:%s%0.2d\",systmp,systmpIndex++); //szm\n\t\tif (usedname)                      //szm20060908 tmpFile in mu\n\t\t\tstrcpy(usedname,work);           //szm20060908 tmpFile in mu\n\t\treturn(fopen(work,\"wb+\"));\n\t\u00fc\n\u00fc\n\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n/* Some typedefs */\ntypedef unsigned char  byte;\ntypedef unsigned short ushort;\ntypedef unsigned long  ulong;\n\n\nISIS_EXT_ASM\n\u00e4\n\ttypedef int (IGGCSI00_f)(void *, void *, void *);\n\u00fc;\n\ntypedef struct\n\u00e4\n\tbyte csiretm_ab\u00c42\u00dc,\n\t\tcsiretr_b,\n\t\tcsiretc_b;\n\u00fc CSIRetInfo;\n\ntypedef struct\n\u00e4\n\tchar   csifiltk_ac\u00c444\u00dc,\n\t\tcsicatnm_ac\u00c444\u00dc,\n\t\tcsiresnm_ac\u00c444\u00dc,\n\t\tcsidtyps_ac\u00c416\u00dc,\n\t\tcsicldi_c,\n\t\tcsiresum_c,\n\t\tcsis1cat_c,\n\t\tcsioptns_c;\n\tushort csinumen_us;\n\tchar   csifldnm\u00c48\u00dc;\n\u00fc CSISelFields;\n\ntypedef struct\n\u00e4\n\tulong  csiusrln_ul,\n\t\tcsireqln_ul,\n\t\tcsiusdln_ul;\n\tushort csinumfd_us;\n\u00fc CSIWorkData;\n\n/* Some coding */\n\n#define CWORK_SIZE 65015\n#define CSINUMFD   12\n#define CSIETYPE    1\n#define CSIENAME    2\n#define CSIELENGTH 50\n\nvoid lsmvs_osdquit(DSNINFO * info)\n\u00e4\n\tif (info&&info->lsmvs_flag)\n\t\u00e4\n\t\tinfo->lsmvs_flag  =  NULL;\n\t\u00fc\n\u00fc\n\n\nint lsmvs_osdnext(DSNINFO * info)\n\u00e4\n\tif (info==NULL)\n\t\treturn -1;\n\n\tchar * p = (char *)info->lsmvs_pointer;\n\tif (*p==0)\n\t\u00e4\n\t\treturn -1;\n\t\u00fc\n\tinfo->cattype = *(char *)(p+CSIETYPE);\n\tmemcpy(info->dsname,p+CSIENAME,sizeof(info->dsname)-1);\n\tinfo->dsname\u00c444\u00dc = 0;\n\tmemset(info->mem,' ',sizeof(info->mem));\n\tinfo->lsmvs_pointer = (void *)((char *)(info->lsmvs_pointer)+CSIELENGTH);\n\tinfo->lsmvs_counter ++;\n\treturn 0;\n\u00fc\n\nint  lsmvs_osdfind(DSNINFO * info ,const char * pat,char catType= 'A')\n\u00e4\n\tchar pattern\u00c4255\u00dc;\n\tif (info==NULL ]] pat==NULL)\n\t\treturn -1;\n\tint i,j;                                  //ToDo27057\n\tfor( i=0,j=0;pat\u00c4i\u00dc&&j<255;i++)\t\t\t    \t//ToDo27057\n\t\tif(pat\u00c4i\u00dc-'\u00d6''&&pat\u00c4i\u00dc-'/'&&pat\u00c4i\u00dc-'\"') //ToDo27057\n\t\t\tpattern\u00c4j++\u00dc=pat\u00c4i\u00dc;\t\t\t          //ToDo27057\n\tpattern\u00c4j\u00dc =0;                            //ToDo27057\n\t//strcpy(pattern,pat);                    //ToDo27057\n\tif (catType=='A')\n\t\u00e4\n\t\tif (pat\u00c4strlen(pat)-1\u00dc == '.' )\n\t\t\tstrcat(pattern,\"**\");\n\t\telse\tif(strchr(pat,'*') == NULL)\n\t\t\tstrcat(pattern,\".**\");\n\t\u00fc\n\t//static char * info->lsmvs_cwork = NULL; szm\n\t// cwork into dsninfo struct cwork -->> lsmvs_cwork\n\tif (info->lsmvs_cwork==NULL)\n\t\tinfo->lsmvs_cwork = (char *)malloc(CWORK_SIZE);\n\tif (info->lsmvs_cwork==NULL)\n\t\u00e4\n\t\tprintf(\" Unable to allocate %s in %d\u00d6n\",__FILE__,__LINE__);\n\t\tabort();\n\t\u00fc\n\tint csiret_i;\n\tstatic IGGCSI00_f*  IGGCSI00_gpf = 0; //ZA070731\n\tCSIRetInfo   retinfo_st;\n\tCSISelFields selfields_st;\n\tCSIWorkData* csirwork_pst;\n\n\t/* fetching CSI */\n\tif (IGGCSI00_gpf == 0) //ZA070731\n\t\tIGGCSI00_gpf = (IGGCSI00_f *) fetch(\"IGGCSI00\");\n\n\t/* Clear return values */\n\tmemset((void *) &(retinfo_st), 0, sizeof(CSIRetInfo));\n\n\t/* Blank input structure */\n\tmemset((void *) &(selfields_st), ' ', sizeof(CSISelFields));\n\n\t/* Fill in Pattern */\n\tmemcpy(selfields_st.csifiltk_ac, pattern, strlen(pattern));\n\n\t/* Set entry type to 'A', thus only non-VSAM datasets will be returned\n\t*/\n\tselfields_st.csidtyps_ac\u00c40\u00dc = catType;\n\tselfields_st.csidtyps_ac\u00c41\u00dc = ' ';\n\tselfields_st.csicldi_c = ' ';\n\tselfields_st.csiresum_c = ' ';\n\tselfields_st.csis1cat_c = 'Y';\n\tselfields_st.csioptns_c = ' ';\n\tselfields_st.csinumen_us    = 0;  /* only return name */\n\t/* Clear work area */\n\tmemset((void *) info->lsmvs_cwork, 0,CWORK_SIZE);\n\t/* Overlay workarea to fill length */\n\tcsirwork_pst = (CSIWorkData *) info->lsmvs_cwork;\n\t/* Set length */\n\tcsirwork_pst->csiusrln_ul = CWORK_SIZE;\n\tcsiret_i = IGGCSI00_gpf((void *) &retinfo_st,\n\t\t(void *) &selfields_st,\n\t\t(void *) info->lsmvs_cwork);\n\tHOST_IBM_TRACE_sss(catType,pat,pattern); //ZA040924\n\tif (csiret_i==0)\n\t\u00e4\n\t\tif (short(*(short *)(info->lsmvs_cwork+CSINUMFD))==0)\n\t\t\u00e4\n\t\t\tfree (info->lsmvs_cwork);\n\t\t\tinfo->lsmvs_cwork = NULL;\n\t\t\treturn -1;\n\t\t\u00fc\n\n\t\tchar *p = (char *)(info->lsmvs_cwork+CSINUMFD+2+CSIELENGTH);\n\t\tinfo->cattype = *(p+CSIETYPE);\n\t\tmemcpy(info->dsname,p+CSIENAME,sizeof(info->dsname)-1);\n\t\tinfo->dsname\u00c444\u00dc = 0;\n\t\tmemset(info->mem,' ',sizeof(info->mem));\n\t\tint entries= *(short *)(info->lsmvs_cwork+CSINUMFD);\n\t\tinfo->lsmvs_flag = entries;\n\t\tinfo->lsmvs_pointer = (void *)(p+CSIELENGTH);\n\t\tinfo->lsmvs_counter = 1;\n\t\tif(info->dsname\u00c40\u00dc=='\u00d60' ]] info->dsname\u00c40\u00dc==' ')\n\t\t\u00e4\n\t\t\tHOST_IBM_TRACE_s(info->dsname);//|||||\n\t\t\treturn -1;\n\t\t\u00fc\n\t\treturn 0;\n\t\u00fc\n\telse\n\t\u00e4\n\t\tif (catType == 'A' ]] pattern\u00c4strlen(pattern) - 1\u00dc NEQ '.') //ZA041008\n\t\t\u00e4\n\t\t\tchar work\u00c4256\u00dc;\n\t\t\tsprintf(work,\"IGGICS00 catalog search error, for %s pattern ,rc: %d reason code %8x\u00d6n\",pattern,csiret_i,retinfo_st);\n\t\t\tperror(work);\n\t\t\u00fc\n\t\tfree(info->lsmvs_cwork);\n\t\tinfo->lsmvs_cwork = NULL;\n\t\treturn -1;\n\t\u00fc\n\u00fc\n\n/*\nRECORD: each record of a pds will be read into one of these structures.\nThe first 2 bytes is the record length, which is put into\n'count', the remaining 254 bytes are put into rest.  Each record\nis 256 bytes long.\n*\n* Each record has the form:\n*\n* +------------+------+------+------+------+----------------+\n* + # of bytes ]Member]Member]......]Member]  Unused        +\n* + in record  ]  1   ]  2   ]      ]  n   ]                +\n* +------------+------+------+------+------+----------------+\n*  ]--count---]]-----------------rest-----------------------]\n*  (Note that the number stored in count includes its own\n*   two bytes)\n*\n* And, each member has the form:\n*\n* +--------+-------+----+-----------------------------------+\n* + Member ]TTR    ]info]                                   +\n* + Name   ]       ]byte]  User Data TTRN's (halfwords)     +\n* + 8 bytes]3 bytes]    ]                                   +\n* +--------+-------+----+-----------------------------------+\n*/\n\n#define TTRLEN 3      /* The TTR's are 3 bytes long */\n/*\n* bit 0 of the info-byte is '1' if the member is an alias,\n* 0 otherwise. ALIAS_MASK is used to extract this information\n*/\n#define ALIAS_MASK ((unsigned int) 0x80)\n/*\n* The number of user data half-words is in bits 3-7 of the info byte.\n* SKIP_MASK is used to extraction this information.  Since this number\n* is in half-words, it needs to be double to obtain the number of bytes.\n*/\n#define SKIP_MASK ((unsigned int) 0x1F)\n\n/*\n* 8 hex FF's mark the end of the directory\n*/\nchar *endmark = \"\u00d6xFF\u00d6xFF\u00d6xFF\u00d6xFF\u00d6xFF\u00d6xFF\u00d6xFF\u00d6xFF\";\n\n\n#define NAMELEN   8\n#define RECLEN  254\n\n\ntypedef struct _RECORD \u00e4\n\tunsigned short count;\n\tchar rest\u00c4RECLEN\u00dc;\n\u00fc RECORD;\n\ntypedef  struct _readDir \u00e4\n\tFILE * file;\n\tint   offset;\n\tRECORD record;\n\t_readDir()\u00e4 file= NULL;offset = 0;\u00fc //constructor  szm\n\u00fc     readDir;\n\nint osdnextSet(DSNINFO * info,readDir * rd)\n\u00e4\n\tmemcpy(info->mem,rd->record.rest+rd->offset,NAMELEN);\n\tinfo->mem\u00c48\u00dc = 0;\n\tmemcpy(&(info->TTR),rd->record.rest+rd->offset+NAMELEN,TTRLEN);\n\tinfo->alias = ALIAS_MASK & *(rd->record.rest+rd->offset+NAMELEN+TTRLEN);\n\tinfo->user_TTR_count = (((unsigned int)0x30) & *(rd->record.rest+rd->offset+NAMELEN+TTRLEN))>>5;\n\tinfo->user_data_halfwords = SKIP_MASK & *(rd->record.rest+rd->offset+NAMELEN+TTRLEN);\n\tmemcpy(info->user_data,rd->record.rest+rd->offset+NAMELEN+TTRLEN+1,info->user_data_halfwords*2);\n\trd->offset +=(NAMELEN+TTRLEN+info->user_data_halfwords*2+1);\n\treturn 0;\n\u00fc\n\n\nISIS_EXT_C int osdfind(struct DSNINFO * info, const char * name)\n\u00e4\n\tif (info==NULL)\n\t\treturn -1;\n\tif(strstr(name,\"(*)\")==NULL)\n\t\u00e4\n\t\tinfo->lsmvs_counter = 1;\n\t\treturn (lsmvs_osdfind(info,name));\n\t\u00fc\n\tinfo->lsmvs_counter = 0;\n\tif (info->filepointer) delete (readDir*)info->filepointer;\n\treadDir * rd = new readDir;\n\tinfo->filepointer   = rd;\n\trd->offset = 0;\n\tinfo->cattype = 'A';\n\tmemset(info->dsname,0,sizeof(info->dsname));\n\tmemcpy(info->dsname,name,strlen(name));\n\tchar _name\u00c4256\u00dc;\n\tstrcpy(_name,name);\n\tchar * c = strstr(_name,\"(*)\");\n\tchar buf_name\u00c4PCS_MAX_PATH\u00dc;\n\tif (c ) strcpy(c,c+3); //szm\n\trd->file = fopen(genOpenName(_name,buf_name),\"rb,noseek\");\n\tif (rd->file\n\t\t&& fread(&(rd->record), 1, sizeof(rd->record), rd->file) == sizeof(rd->record)\n\t\t&& memcmp(rd->record.rest+rd->offset,endmark,NAMELEN) )\n\t\treturn (osdnextSet(info,rd));\n\telse\n\t\treturn -1;\n\u00fc\n\nISIS_EXT_C int osdnext(struct DSNINFO * info)\n\u00e4\n\tif(info&&info->lsmvs_counter)\n\t\treturn(lsmvs_osdnext(info));\n\tif (info && info->filepointer)\n\t\u00e4\n\t\treadDir * rd = (readDir*)info->filepointer;\n\t\tif (memcmp(rd->record.rest+rd->offset,endmark,NAMELEN) == 0 )\n\t\t\treturn -1;\n\t\telse if (rd->offset < rd->record.count -2)\n\t\t\treturn (osdnextSet(info,rd));\n\t\telse\n\t\t\u00e4\n\t\t\trd->offset = 0;\n\t\t\tif ( fread(&(rd->record), 1, sizeof(rd->record), rd->file) == sizeof(rd->record)\n\t\t\t\t&& memcmp(rd->record.rest+rd->offset,endmark,NAMELEN) )\n\t\t\t\treturn (osdnextSet(info,rd));\n\t\t\telse return -1;\n\t\t\u00fc\n\t\u00fc\n\telse\n\t\treturn -1;\n\u00fc\n\nISIS_EXT_C void osdquit(struct DSNINFO * info)\n\u00e4\n\tif (info&&info->lsmvs_counter)\n\t\tlsmvs_osdquit(info);\n\telse if (info && info->filepointer)\n\t\u00e4\n\t\treadDir * rd = (readDir*)info->filepointer;\n\t\tif (rd->file)\n\t\t\tfclose(rd->file);\n\t\trd->file = NULL;\n\t\tdelete rd;\n\t\tinfo->filepointer = NULL;\n\t\u00fc\n\u00fc\n#endif\n\nISIS_EXT_C int osmfind(struct DSNINFO * dsninfo, const char * pattern)\n\u00e4\n#ifndef VSAM_NO\n\tif(isVsam(pattern))\n\t\u00e4\n\t\tint ret = NAMESPACE_MVSSTDIO osmfind(dsninfo,pattern);\n\t\tdsninfo->isVsam = true;\n\t\treturn ret;\n\t\u00fc\n#endif\n\tint rc;\n\tlong rc1;                  //the number of inserted members\n\tint rc2;\n\tchar pat\u00c455\u00dc, *c2;\n\t// if  prefix like e.g. HFS: exists get part after prefix otherwise entire pattern\n\tconst char *without_prefix = strchr(pattern,':');\n\tif ( without_prefix )  without_prefix++; else without_prefix = pattern;\n\n\tstrncpy(pat,without_prefix,54);\n\tpat\u00c454\u00dc = 0;\n\tmemset(dsninfo->dsnsl,0,MAXDSNS);\n\tdsninfo->dsns =dsninfo->dsnsl;\n\tdsninfo->isVsam = false;\n\n\t//printf(\"%s\u00d6n\",pattern);\n\t//printf(\"%s\u00d6n\",pat);\n\tc2 = dsninfo->mmask;\n\n\t// get member if pattern contains partitioned data set memeber name\n\t// and put it into dsninfo->nmask\n\tchar * c1;\n\tif ( (c1 = strchr(pat,'(')) NEQ  0)\n\t\u00e4\n\t\t*c1++ = 0;\n\t\twhile (*c1 && *c1 NEQ  ')') *c2++ = *c1++;\n\t\u00fc\n\t*c2 = 0 ;\n\tif (NOT *dsninfo->mmask)\n\t\u00e4\n\t\treturn osmfindo(dsninfo,pattern);  //osmfind old version\n\t\u00fc\n\n\tint ddn = ((strlen(pat) <= 8 && strchr(pat,'.') == 0))?1:0;\n\tif (NOT ddn)\n\t\tstrcpy(dsninfo->dsns,pat);              //ds-name specified\n\tDataSName* dsnameg = datasnames->get(pat);\n\tif ((rc = dsnameg->getRC()) NEQ NEWRC)    //if previous call there\n\t\u00e4\n\t\tdsnameg->FetchDSNINFO(dsninfo);         //back dsnameg, rc\n\t\u00fc\n\tif (rc < 0)                               //if previous call error\n\t\treturn rc;\n\n\tif (rc == NEWRC)                          //if new ddn or dsn\n\t\u00e4\n\t\tif (ddn)                                //if dd-name specified\n\t\t\u00e4\n\t\t\tif ( ( rc = _DDNAMES(pat,dsninfo->dsns,MAXDSNS)) NEQ  0 )\n\t\t\t\u00e4\n\t\t\t\trc = -1 ;\n\t\t\t\tdsnameg->UpdateDSNINFO(dsninfo,rc); //dsnameg, rc put\n\t\t\t\treturn rc;\n\t\t\t\u00fc\n\t\t\u00fc\n\n\t\twhile ((rc >= 0) && *dsninfo->dsns)\n\t\t\u00e4\n\t\t\tstrcpy(pat,dsninfo->dsns);\n\t\t\t//printf(\"Search %s\",pat);\n\t\t\tdsninfo->dsns+=strlen(dsninfo->dsns)+1;\n\t\t\tstrcat(pat,\"(*)\");\n\t\t\tif (strchr(pat,'\u00d6'')) strcat(pat,\"'\"); //szm\n\t\t\trc = osdfind(dsninfo,pat);\n\t\t\tif (rc >= 0)\n\t\t\t\u00e4\n\t\t\t\tdo\n\t\t\t\t\u00e4\n\t\t\t\t\trc1 = dsnameg->smc->add(new DataSMember(dsninfo,dsnameg));\n\t\t\t\t\u00fc\n\t\t\t\twhile (( rc2 = osdnext(dsninfo) ) >= 0) ;\n\t\t\t\u00fc\n\t\t\tosdquit(dsninfo);//szm\n\t\t\u00fc\n\t\tdsnameg->UpdateDSNINFO(dsninfo,rc);     //dsnameg, rc put\n\t\tdsnameg->FetchDSNINFO(dsninfo);         //back dsnameg, rc\n\t\u00fc\n\treturn osmnext(dsninfo);\n\u00fc\n\nISIS_EXT_C int osmnext(struct DSNINFO * dsninfo)\n\u00e4\n#ifndef VSAM_NO\n\tif(dsninfo->isVsam)\n\t\treturn NAMESPACE_MVSSTDIO osmnext(dsninfo);\n#endif\n\tif (NOT *dsninfo->mmask)\n\t\u00e4\n\t\treturn osmnexto(dsninfo);     //osmnext old version\n\t\u00fc\n\tint rc = 1;\n\t//DataSName* dsnameg   = (DataSName*)((DSNINF*)dsninfo)->ptdatasname;\n\tDataSName* dsnameg   = (DataSName*)dsninfo->ptdatasname; //ZA030926\n\t//DataSMember* dsnamem = (DataSMember*)((DSNINF*)dsninfo)->ptdatasmember;\n\tDataSMember* dsnamem = (DataSMember*)dsninfo->ptdatasmember;\n\tif (dsnamem)\n\t\u00e4\n\t\tDataSMember* dsnamem1 = (DataSMember*)dsnameg->smc->goFirst();\n\t\twhile(dsnamem1 && (dsnamem NEQ dsnamem1))\n\t\t\u00e4\n\t\t\tdsnamem1 = (DataSMember*)dsnameg->smc->goNext();\n\t\t\u00fc\n\t\tdsnamem = (DataSMember*)dsnameg->smc->goNext();\n\t\u00fc\n\telse\n\t\tdsnamem = (DataSMember*)dsnameg->smc->goFirst();\n\twhile(dsnamem  && rc)\n\t\u00e4\n\t\tif (stcpma(dsnamem->chainEid,dsninfo->mmask))\n\t\t\trc = 0;\n\t\telse\n\t\t\tdsnamem = (DataSMember*)dsnameg->smc->goNext();\n\t\u00fc\n\tif (dsnamem)\n\t\tdsnamem->FetchDSNINFO(dsninfo);         //back dsnamem, rc\n\telse\n\t\trc = -1;                                //not found\n\treturn rc;\n\u00fc\nISIS_EXT_C  void osmquit(struct DSNINFO * dsninfo)\n\u00e4\n#ifndef VSAM_NO\n\tif(dsninfo->isVsam)\n\t\treturn NAMESPACE_MVSSTDIO osmquit(dsninfo);\n#endif\n\tosdquit(dsninfo);\n\u00fc\n\n//this is the old version: called if no mmask there\nint osmfindo(struct DSNINFO * dsninfo,const char * pattern)\n\u00e4\n\tint rc ;\n\tchar pat\u00c455\u00dc;\n\tconst char * without_prefix = strchr(pattern,':');\n\tif ( without_prefix ) without_prefix++; else without_prefix = pattern;\n\n\tstrncpy(pat,without_prefix,54);\n\tpat\u00c454\u00dc = 0;\n\tmemset(dsninfo->dsnsl,0,MAXDSNS);\n\tdsninfo->dsns =dsninfo->dsnsl;\n\t//printf(\"%s\u00d6n\",pattern);\n\t//printf(\"%s\u00d6n\",pat);\n\tchar *c2 = dsninfo->mmask;\n\tchar * c1;\n\tif ( (c1 = strchr(pat,'(')) NEQ  0)\n\t\u00e4\n\t\t*c1++ = 0;\n\t\twhile (*c1 && *c1 NEQ  ')') *c2++ = *c1++;\n\t\u00fc\n\t*c2 = 0 ;\n\n\tif (strlen(pat) <= 8 && strchr(pat,'.') == 0)\n\t\u00e4\n\t\tif ( ( rc = _DDNAMES(pat,dsninfo->dsns,MAXDSNS)) NEQ  0 )\n\t\t\treturn rc ;\n\t\u00fc\n\telse\n\t\tstrcpy(dsninfo->dsns,pat);\n\n\twhile (strlen(dsninfo->dsns))\n\t\u00e4\n\t\tstrcpy(pat,dsninfo->dsns);\n\t\t//printf(\"Search %s\",pat);\n\t\tdsninfo->dsns+=strlen(dsninfo->dsns)+1;\n\t\tif (strlen(dsninfo->mmask))\n\t\t\u00e4\n\t\t\tstrcat(pat,\"(*)\");\n\t\t\tif (strchr(pat,'\u00d6'')) strcat(pat,\"'\"); //szm\n\t\t\u00fc\n\t\trc = osdfind(dsninfo,pat);\n\t\tif ( rc  <  0 )\n\t\t\treturn rc ;\n\n\t\tdo\n\t\t\u00e4\n\t\t\tif( stcpma(dsninfo->mem,dsninfo->mmask) ]] * dsninfo->mmask == 0)\n\t\t\t\treturn rc;\n\t\t\u00fc\n\t\twhile (( rc = osdnext(dsninfo) ) >= 0) ;\n\t\u00fc\n\n\treturn rc ;\n\u00fc\n\nint osmnexto(struct DSNINFO * dsninfo)\n\u00e4\n\tint rc ;\n\tchar pat\u00c455\u00dc;\n\tfor(;;)\n\t\u00e4\n\t\twhile(  ( rc =osdnext(dsninfo) )  >= 0 )\n\t\t\u00e4\n\t\t\tif (stcpma(dsninfo->mem,dsninfo->mmask) ]] * dsninfo->mmask == 0)\n\t\t\t\treturn rc;\n\t\t\u00fc\n\n\t\tif ( strlen(dsninfo->dsns) == 0) return rc;\n\t\tstrcpy(pat,dsninfo->dsns);\n\t\tif (strlen(dsninfo->mmask))\n\t\t\u00e4\n\t\t\tstrcat(pat,\"(*)\");\n\t\t\tif (strchr(pat,'\u00d6'')) strcat(pat,\"'\"); //szm\n\t\t\u00fc\n\t\tdsninfo->dsns+=strlen(dsninfo->dsns)+1;\n\t\tif ( ( rc = osdfind(dsninfo,pat)) <  0 )\n\t\t\treturn rc ;\n\t\telse\n\t\t\tif (stcpma(dsninfo->mem,dsninfo->mmask) ]] * dsninfo->mmask == 0)\n\t\t\t\treturn rc;\n\t\u00fc\n\u00fc\n\nclass FileTypeCache\n\u00e4\nprotected:\n\tstd::map<std::string,FILE_TYPE > cache_;\n\ttypedef std::pair<std::string,FILE_TYPE> cache_pair;\n#if defined(ISIS_PF_MU) == 1 && defined(MU_STANDALONE) == 0\n\tPcsMutex m_mutex;\n#endif\n\npublic:\n\tFileTypeCache()\n#if defined(ISIS_PF_MU) == 1 && defined(MU_STANDALONE) == 0\n\t\t//:m_mutex(PCS_MUTEX_NORMAL,-1,PcsString(\"FileTypeCache\"))\n\t\t:m_mutex(PCS_MUTEX_NORMAL,-1,\"FileTypeCache\")\n#endif\n\t\u00e4\n\t\u00fc\n\n\tvoid insert(const char* name,FILE_TYPE type)\n\t\u00e4\n#if defined(ISIS_PF_MU) == 1 && defined(MU_STANDALONE) == 0\n\t\tPcsScopeLock lock(&m_mutex);\n#endif\n\t\tcache_\u00c4name\u00dc = type;\n\t\u00fc\n\tbool get(const char* name, FILE_TYPE * type)\n\t\u00e4\n#if defined(ISIS_PF_MU) == 1 && defined(MU_STANDALONE) == 0\n\t\tPcsScopeLock lock(&m_mutex);\n#endif\n\t\tstd::map<std::string,FILE_TYPE>::const_iterator i = cache_.find(name);\n\t\tif(i == cache_.end())\n\t\t\u00e4\n\t\t\treturn false;\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\t*type = i->second;\n\t\t\treturn true;\n\t\t\u00fc\n\t\u00fc\n\u00fc;\n\n\nFILE_TYPE getFileTypeLocal(const char * n)\n\u00e4\n\tchar FileName\u00c4300\u00dc;\n\tchar * fn, *s;\n\tchar dsn\u00c4300\u00dc;\n\tmemset(dsn,0,sizeof(dsn));\n\tunsigned short  dsOrg =0;\n\tstrcpy(FileName,n);\n\n\tfn = FileName;\n\ts  = strchr(fn,'(');\n\tif (s)\n\t\u00e4\n\t\t*s = 0;\n\t\tif (n\u00c4strlen(n)-1\u00dc=='\u00d6'')\n\t\t\tstrcat(fn,\"'\");\n\t\u00fc\n\t/************** special\n\t*********************************************************/\n\tif ( strncasecmp   (fn,\"VSAM\",4) == 0)\n\t\treturn  FILE_VSAM ;\n\n\t// if filename is contained in filetype cache return it, else evaluate filetype and insert into cache\n\tstatic FileTypeCache cache;\n\tFILE_TYPE filetype;\n\tif(cache.get(fn,&filetype))\n\t\u00e4\n\t\treturn filetype;\n\t\u00fc\n\t/************** special for DDN:OMS\n\t*********************************************************/\n\tif (genOpenType(fn) == ibm_hfs)\n\t\u00e4\n\t\tcache.insert(fn,FILE_QSAM);\n\t\treturn FILE_QSAM; //ZA040906 so that pipe will not be opened\n\t\u00fc\n\tchar ns\u00c4PCS_MAX_PATH\u00dc;\n\tgenOpenName(fn,ns);\n\tif (strncasecmp   (\"dd:\",ns,3) == 0 ]] strncasecmp   (\"//dd:\",ns,5) == 0) //szm\n\t\u00e4\n\t\tchar dsns\u00c444*16\u00dc;\n\t\tchar mem\u00c49\u00dc;\n\t\tmemset(dsns,0,sizeof(dsns));\n\t\tif (_DDNAMES(strchr(ns,':')+1,dsns,sizeof(dsns),mem))\n\t\t\u00e4\n\t\t\tcache.insert(fn,FILE_QSAM);\n\t\t\treturn FILE_QSAM;\n\t\t\u00fc\n\t\tchar * c = NULL;\n\t\tif ((c = strchr(dsns,' '))) *c = 0;\n\t\tstrcpy(ns,dsns);\n\t\u00fc\n\telse\n\t\tif (strncasecmp   (\"//'\",ns,3) == 0)\n\t\t\u00e4\n\t\t\tstrcpy(ns,ns+3);\n\t\t\tif (ns\u00c4strlen(ns)-1\u00dc=='\u00d6'')\n\t\t\t\tns\u00c4strlen(ns)-1\u00dc = 0;\n\n\t\t\u00fc\n\t\tDSNINFO dsninfo;\n\t\tint rc =  lsmvs_osdfind(&dsninfo,ns,'C');\n\t\t//#if  0\n\t\t//szm20060324 currently I have no idea why it was necesarry\n\t\t// to open  a dataset and reissue a VSAM cluster search\n\t\t//szm20060613 now we see, if it is a migrated VSAM cluster, we have to recall via fopen and reissue the catalog search\n\t\tif (rc&&getenv(\"ISIS_DISABLE_VSAM\")==NULL)\n\t\t\u00e4\n\t\t\tchar buf_name\u00c4PCS_MAX_PATH\u00dc;\n\t\t\tFILE * f = fopen(genOpenName(fn,buf_name),\"rb, type=record\");\n\t\t\tif (f)\n\t\t\t\u00e4\n\t\t\t\trc =  lsmvs_osdfind(&dsninfo,ns,'C');\n\t\t\t\tfclose(f);\n\t\t\t\u00fc\n#if 0 //ZA040820 comes message even if ok\n\t\t\telse perror(genOpenName(fn,buf_name));\n#endif\n\t\t\u00fc\n\t\t//#endif\n\t\tHOST_IBM_TRACE_d(rc);\n\t\tHOST_IBM_TRACE_s(ns);\n\t\tHOST_IBM_TRACE_s(n);\n\t\tlsmvs_osdquit(&dsninfo);\n\t\tfiletype =  (rc?FILE_QSAM:FILE_VSAM);\n\t\tcache.insert(fn,filetype);\n\t\treturn filetype;\n\u00fc\n\nDataSName::DataSName(char * name,FILE_TYPE type)\n:chainE(name)\n\u00e4\n\tmemset(&dsninfo,0,sizeof(DSNINFO));\n\t//((DSNINF*)dsninf)->ptdatasname = (void*)this;\n\t//((DSNINF*)dsninf)->ptdatasmember = NULL;\n\t//dsninfo._\u00c42\u00dc = (void*)NEWRC; //shows rc after new\n\tdsninfo.rc = (void*)NEWRC;     //shows rc after new ZA030926\n\tfile_type = type;\n\tsmc = new SORTEDmCHAIN();\n\u00fc\n\nDataSName::\u00dfDataSName()\n\u00e4\n\tif (smc)delete smc;\n\u00fc\n\nDataSName *  DataSNames::get(char * na)\n\u00e4\n\tchar * s;\n\tchar  name\u00c4300\u00dc;\n\tstrcpy(name,na);\n\n\ts  = strtok(name,\"(\");\n\tif ( s  ) strcpy(name,s);\n\n\tDataSName * dsn = 0;\n\titer->reset();\n\twhile ( ( dsn = (DataSName*)iter->next() ) NEQ 0 )\n\t\tif ( strcmp(name,dsn->chainEid ) == 0 )  break ;\n\tif ( dsn ) return dsn;\n\n\tdsn = new DataSName(name,getFileTypeLocal(name));\n\tdatasnames->add(dsn);\n\treturn dsn;\n\u00fc\n\nDataSNames::DataSNames():SORTEDmCHAIN()\n\u00e4\n\titer = new CHAINITER(*this);\n\u00fc\n\nDataSNames::\u00dfDataSNames()\n\u00e4\n\titer->reset();\n\tDataSName * n = (DataSName*)iter->next();\n\twhile(n)\n\t\u00e4\n\t\tdel(n);\n\t\tn = (DataSName*)iter->next();\n\t\u00fc\n\u00fc\n\n\n//DataSMember(DSNINFO* dsninfo)\n//DataSMember(DSNINFO* dsninfo,DataSName* dsnameg)\n//\u00e4\n//\u00fc\n//DataSMember::DataSMember(DSNINFO* dsninfo,DataSName* dsnameg)\nDataSMember::DataSMember(DSNINFO* dsni,DataSName* dsnameg) //ZA030926\n:chainE(dsni->mem)\n\u00e4\n\t//memcpy(&dsninf,(DSNINF*)dsninfo,sizeof(DSNINF));\n\tmemcpy(&dsninfo,dsni,sizeof(DSNINFO));\n\tdsninfo.ptdatasname = dsnameg;\n\tdsninfo.ptdatasmember = this;\n\u00fc\n//#endif OWN_STDIO  common code for OWN_STDIO and non OWN_STDIO szm\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXVAR": {"ttr": 243, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include \"versinfo.h\"\n#include \"osmfind.hpp\"\n#define _XOPEN_SOURCE 500\n#define _LARGE_FILES 1\n#ifndef _SHR_ENVIRON\n#define _SHR_ENVIRON 1\n#endif\n#define _SHARE_EXT_VARS 1\n#define  environ  (*(__Envn()))\n#include <signal.h>\n#include <dll.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <strings.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"ibmdebug.hpp\"\n\n#include \"misc.hpp\"\n#include \"osmfind.hpp\"\n#include \"jesi.hpp\"\n#include \"caljesi.hpp\"\n#include \"mchain.hpp\"\n#include \"casmif.hpp\"\n#include \"msgmgr.hpp\"\n#include \"jobenv.hpp\"\n#include \"rexxvar.hpp\"\n\n//#include \"mvssamp.hpp\"\n\nint _dump(char * id,char * p,int l)\n\u00e4\n\tunsigned char ETOA\u00c4256\u00dc =\n\t\u00e4\n\t\t0, 0x1, 0x2, 0x3, 0xff, 0x9, 0xff, 0x7f,\n\t\t0xff, 0xff, 0xff, 0xb, 0xc, 0xd, 0xe, 0xf,\n\t\t0x10, 0x11, 0x12, 0x13, 0xff, 0xff, 0x8, 0xff,\n\t\t0x18, 0x19, 0xff, 0xff, 0x1c, 0x1d, 0x1e, 0x1f,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xa, 0x17, 0x1b,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0x5, 0x6, 0x7,\n\t\t0xff, 0xff, 0x16, 0xff, 0xff, 0xff, 0xff, 0x4,\n\t\t0xff, 0xff, 0xff, 0xff, 0x14, 0x15, 0xff, 0x1a,\n\t\t0x20, 0xff, 0x83, 0x7b, 0x85, 0xa0, 0xc6, 0x86,\n\t\t0x87, 0xa4, 0x8e, 0x2e, 0x3c, 0x28, 0x2b, 0x21,\n\t\t0x26, 0x82, 0x88, 0x89, 0x8a, 0xa1, 0x8c, 0x8b,\n\t\t0x8d, 0x7e, 0x9a, 0x24, 0x2a, 0x29, 0x3b, 0x5e,\n\t\t0x2d, 0x2f, 0xb6, 0x5b, 0xb7, 0xb5, 0xc7, 0x8f,\n\t\t0x80, 0xa5, 0x94, 0x2c, 0x25, 0x5f, 0x3e, 0x3f,\n\t\t0x9b, 0x90, 0xd2, 0xd3, 0xd4, 0xd6, 0xd7, 0xd8,\n\t\t0xde, 0x60, 0x3a, 0x23, 0xf5, 0x27, 0x3d, 0x22,\n\t\t0x9d, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t\t0x68, 0x69, 0xae, 0xaf, 0xd0, 0xec, 0xe7, 0xf1,\n\t\t0xf8, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,\n\t\t0x71, 0x72, 0xa6, 0xa7, 0x91, 0xf7, 0x92, 0xcf,\n\t\t0xe6, 0xe1, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n\t\t0x79, 0x7a, 0xad, 0xa8, 0xd1, 0xed, 0xe8, 0xa9,\n\t\t0xbd, 0x9c, 0xbe, 0xfa, 0xb8, 0x40, 0xf4, 0xac,\n\t\t0xab, 0xf3, 0xaa, 0x7c, 0xee, 0xf9, 0xef, 0x9e,\n\t\t0x84, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t\t0x48, 0x49, 0xf0, 0x93, 0xdd, 0x95, 0xa2, 0xe4,\n\t\t0x81, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,\n\t\t0x51, 0x52, 0xfb, 0x96, 0x7d, 0x97, 0xa3, 0x98,\n\t\t0x99, 0xf6, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n\t\t0x59, 0x5a, 0xfd, 0xe2, 0x5c, 0xe3, 0xe0, 0xe5,\n\t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t\t0x38, 0x39, 0xfc, 0xea, 0x5d, 0xeb, 0xe9, 0xff\n\t\u00fc;\n\tint i , o;\n\tprintf(\"%s at:%x(%d)\u00d6n\u00d6n\",id,p,l);\n\tif (p)\n\t\tfor(o = 0;o <((l/16)+1)*16;o+=16)\n\t\t\u00e4\n\t\t\tprintf(\"%4.4lx:\",o);\n\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\u00e4\n\t\t\t\tif ( i < l )\n\t\t\t\t\u00e4\n\t\t\t\t\tprintf(\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n\t\t\t\t\tif (i%4 == 3) printf(\" \");\n\n\t\t\t\t\u00fc\n\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tif ( i%4 == 3) printf(\" \");\n\t\t\t\t\tprintf(\" \");\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tprintf(\" \");\n\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\tif ( i < l )\n\t\t\t\t\tprintf(\"%c\",isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n\t\t\t\telse printf(\" \");\n\t\t\t\tprintf(\" \");\n\t\t\t\tfor(i = o;i<o+16;i++)\n\t\t\t\t\tif ( i < l )\n\t\t\t\t\tprintf(\"%c\",isprint(ETOA\u00c4p\u00c4i\u00dc\u00dc)?ETOA\u00c4p\u00c4i\u00dc\u00dc:'.');  printf(\"\u00d6n\");\n//\t\t\t\tprintf(\"%c\",isprint(ATOE\u00c4p\u00c4i\u00dc\u00dc)?ATOE\u00c4p\u00c4i\u00dc\u00dc:'.');  printf(\"\u00d6n\");\n\n\n\t\t\u00fc\n\t\treturn l;\n\u00fc\n\n\nbool debug = false;\nstatic const int  TSVEUPDT = 2;\nstatic const int  TSVERETR = 1;\n\nchar * REXXVAR::fetch(const char * name)\n\u00e4\n\tshv.shvnext = NULL;\n\tshv.shvuser = 0;\n\tshv.shvcode = shvfetch;\n\tshv.shvbufl = bufflength;\n\tshv.shvnama = (void *)name;\n\tshv.shvnaml = strlen(name);\n\tshv.shvvala = to;\n\tshv.shvvall = 0;\n\tmemset(to,' ',bufflength);\n\trc = 0;\n\tirxexcom(\"IRXEXCOM\",&rc,&rc,&shv,&envaddr,&rc);\n\t/*\n\tetc = -1;\n\tnext = 0;\n\trc = ikjct441(&TSVERETR,(char * *)&name,&shv.shvnaml,&to,&shv.shvvall,&token,&etc,&next,&rc);\n\t*/\n\tif (rc==0&&shv.shvvall)\n\t\u00e4\n\t\tto\u00c4shv.shvvall\u00dc = 0;\n\t\tif (debug)\n\t\t\t_dump((char *)name,to,strlen(to));\n\n\t\treturn to;\n\t\u00fc\n\telse\n\t\tfprintf(stderr,\" REXX var fetch error for %s code:%d\u00d6n\",name,rc);\n\treturn NULL;\n\u00fc\n\nsize_t REXXVAR::set(const char * name,const char * from,size_t length)\n\u00e4\n\tshv.shvnext = NULL;\n\tshv.shvuser = 0;\n\tshv.shvcode = shvstore;\n\tshv.shvbufl = bufflength;\n\tshv.shvnama = (void *)name;\n\tshv.shvnaml = strlen(name);\n\tshv.shvvala = (void *)from;\n\tshv.shvvall = length?length:strlen(from);\n\trc = 0;\n\tif (debug)\n\t\t_dump((char *)name,(char *)from,shv.shvvall);\n\n\tirxexcom(\"IRXEXCOM\",&rc,&rc,&shv,&envaddr,&rc);\n\t/*\n\tetc = -1;\n\tnext = 0;\n\trc = ikjct441(&TSVEUPDT,(char * *)&name,&shv.shvnaml,(char * *)&from,&shv.shvvall,&token,&etc,&next,&rc);\n\t*/\n\tif (rc==0)\n\t\u00e4\n\t\tif (debug)\n\t\t\tfprintf(stderr,\" Set %s %*.*s\u00d6n\",name,shv.shvvall,shv.shvvall,from);\n\t\treturn shv.shvvall;\n\t\u00fc\n\telse\n\t\tfprintf(stderr,\" REXX var set error for %s code:%d\u00d6n\",name,rc);\n\treturn 0;\n\n\u00fc\n\nsize_t REXXVAR::setStem(const char * name,int &index ,const char * from,size_t length)\n\u00e4\n\tchar varName\u00c41024\u00dc;\n\tsprintf(varName,\"%s.%d\",name,++index);\n\treturn (set(varName,from,length));\n\u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "STRSERV": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma runopts(POSIX(ON),XPLINK(ON))\n\n#define ISIS_ALLOW_OS_FUNCTIONS 1\n#define _XOPEN_SOURCE_EXTENDED 1\n#define  _OPEN_SYS             1\n#define  _OPEN_THREADS         1\n#define _XOPEN_SOURCE 500\n#define _LARGE_FILES 1\n#ifndef _SHR_ENVIRON\n#define _SHR_ENVIRON 1\n#endif\n#define _SHARE_EXT_VARS 1\n#define  environ  (*(__Envn()))\n\n#include \"isisdef.h\"\n#include \"versinfo.h\"\n#include \"osmfind.hpp\"\n\n#include <signal.h>\n#include <dll.h>\n#include <limits.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <assert.h>\n#include <ctype.h>\n#include <string.h>\n#include <strings.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <errno.h>\n\nint _edc_add_errno2   = setenv(\"_EDC_ADD_ERRNO2\",\"1\",1);  //szm20040129 byteseek set\n\n#include \"misc.hpp\"\n#include \"osmfind.hpp\"\n#include \"jesi.hpp\"\n#include \"caljesi.hpp\"\n#include \"mchain.hpp\"\n#include \"casmif.hpp\"\n#include \"msgmgr.hpp\"\n#include \"jobenv.hpp\"\n#include \"rexxvar.hpp\"\n#include \"strserv.hpp\"\n#include \"misc.hpp\"\n#include \"caljesi.hpp\"\n#include \"jesi.hpp\"\n#include \"mchain.hpp\"\n#include \"casmif.hpp\"\n#include \"msgmgr.hpp\"\n#include \"jobenv.hpp\"\n#include \"mvsbase.hpp\"\n#include \"msgmgr.hpp\"\n#include \"strnode.hpp\"\n#include \"mvsstr.hpp\"\n\nint _dump(char * ,char * ,int );\n\ntimeval    tcpipClient::timeout\t\t= \u00e4300,0\u00fc;\nint        tcpipClient::connwait\t= 5;\nchar       tcpipClient::URL\u00c4255\u00dc  = \"\";\nbool       CmdService::debug = false;\n\n#ifndef ERROR_CODE\n#define ERROR_CODE -1\n#endif\n\nstatic const char * REXXCMD     =  \"STRREXX\" ;\nstatic const char * CALLBACK_PROGRAM    =  \"MVSSERVB\";\nstatic const char * SERVER      =  \"MVSSERVS\";\nstatic const char * AUTHSERVER  =  \"MVSSERVA\";\nstatic const char * SPOOL       =  \"SPOOL\";\nstatic const int    PRINTBUFF_MAX = 1024*256;\nstatic const char * ISFIN       =  \"//DD:ISFIN   \";\nstatic const char * ISFOUT      =  \"//DD:ISFOUT  \";\nstatic const char * MX_COMMAND  =  \"COMMAND\";\nstatic const char * MX_USERID   =  \"USER\";\nstatic const char * MX_GROUPID  =  \"GROUP\";\nstatic const char * MX_MQS      =  \"MQS\";\nstatic const char * MX_DB2      =  \"DB2\";\nstatic const char * RESULT_STEM = \"STRRESULTSTEM\";\nstatic const short  MX_PORT\t\t\t\t\t=  8001;\nstatic const short  REXXSERVER_PORT =  8002;\nstatic const char * REXXSERVER_TYPE =\t\t\"TYPE\";\nstatic const char * REXXSERVER_COMMAND= \"COMMAND\";\nstatic const char * REXXSERVER_REPLYID= \"REPLYID\";\nstatic const char * WD4Z              = \"WD4Z\";\ntypedef struct\n\u00e4\n\tchar type\u00c410\u00dc;\n\tchar replyid\u00c486\u00dc;\n\tchar command\u00c44000\u00dc;\n\u00fc REXXSERVER_REQUEST;\n\nBPXWDYN  * CmdService::dyn  = (BPXWDYN *)fetch(\"BPXWDYN \");\n\nFILE * _cgitrace = fopen(\"//dd:cgitrace\",\"w\");\nFILE * cgitrace = CmdService::debug?(_cgitrace?_cgitrace:stderr):NULL;\n\nclass keyvalue\n\u00e4\npublic:\n\tmvsSTRING * key;\n\tmvsSTRING * value;\n\tkeyvalue(mvsSTRING *k,mvsSTRING *v)\n\t\u00e4\n\t\tkey\t\t= k;\n\t\tvalue = v;\n\t\u00fc\n\u00fc;\n\nkeyvalue ** parse(const char * com,const char *sep=\",\")\n\u00e4\n\tif (com&&strlen(com))\n\t\u00e4\n\t\tstatic keyvalue * kv\u00c4256\u00dc;\n\t\tmvsSTRING s(com);\n\t\ts.strip();\n\t\tsize_t ind = 0;\n\t\twhile (strlen(s)>0)\n\t\t\u00e4\n\t\t\tmvsSTRING key , value , rest;\n\t\t\ts.strip().parse(key,\"=\",value,(char *)sep,rest);\n\t\t\tkey.strip();\n\t\t\tvalue.strip();\n\t\t\tif (value\u00c40\u00dc == '\u00d6'' ]] value\u00c40\u00dc == '\"')\n\t\t\t\tvalue = value(1,strlen(value)-2);\n\t\t\tif (CmdService::debug)\n\t\t\t\tprintf(\"string:%s key:%s value:%s rest:%s\u00d6n\",(char *)s,(char *)key,(char *)value,(char *)rest);\n\t\t\tkv\u00c4ind++\u00dc = new keyvalue(new mvsSTRING(key),new mvsSTRING(value));\n\t\t\ts = rest;\n\t\t\tkv\u00c4ind\u00dc = NULL;\n\t\t\u00fc\n\t\treturn kv;\n\t\u00fc\n\telse\n\t\treturn NULL;\n\u00fc\n\ntcpipClient::tcpipClient(short p):port(p)\n\u00e4\n\tsocket = ERROR_CODE;\n\tconnected = false;\n\tmemset(&sockaddr,0,sizeof(sockaddr));\n\tmemset(&sockaddrUnix,0,sizeof(sockaddrUnix));\n\tFD_ZERO(&readSockets);\n\tFD_ZERO(&writeSockets);\n\tFD_ZERO(&exceptionSockets);\n\tsockaddr.sin_family = AF_INET;\n\tsockaddrUnix.sun_family = AF_UNIX;\n\tunsigned long addr  = 0;\n\tif (port)\n\t\u00e4\n\t\tif (strlen(URL)==0)\n\t\t\tgethostname(URL,sizeof(URL));\n\t\tif (isdigit(URL\u00c40\u00dc))\n\t\t\taddr = inet_addr(URL);\n\t\telse\n\t\t\u00e4\n\t\t\thostent * he = gethostbyname(URL);\n\t\t\tif ( he == 0 )\n\t\t\t\u00e4\n\t\t\t\tdiag(\"gethostbyname\");\n\t\t\t\treturn;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\taddr =*((unsigned*)(he->h_addr));\n\t\t\u00fc\n\t\tsockaddr.sin_addr.s_addr = addr;\n\t\tsockaddr.sin_port   =(unsigned short)htons(port);\n\t\tsocket = ::socket(AF_INET,SOCK_STREAM,0);\n\t\u00fc\n\telse\n\t\u00e4\n\t\tsockaddrUnix.sun_len = strlen(URL);\n\t\tstrcpy(sockaddrUnix.sun_path,URL);\n\t\tsocket = ::socket(AF_UNIX,SOCK_STREAM,0);\n\t\tif (JOBENV::debug)\n\t\t\t_dump(\" sockAddrUnix\",(char *)&sockaddrUnix,sizeof(sockaddrUnix));\n\t\u00fc\n\tif (socket == ERROR_CODE )\n\t\u00e4\n\t\tdiag(\"socket\");\n\t\treturn;\n\t\u00fc\n\n\tvoid * addrPointer = NULL;\n\tsize_t addrLength = 0;\n\tif (port)\n\t\u00e4\n\t\taddrPointer = &sockaddr;\n\t\taddrLength = sizeof(sockaddr);\n\t\u00fc\n\telse\n\t\u00e4\n\t\taddrPointer = &sockaddrUnix;\n\t\taddrLength = sizeof(sockaddrUnix);\n\t\u00fc\n\n\n\twhile(connect(socket,(struct sockaddr*)addrPointer,addrLength)== ERROR_CODE)\n\t\u00e4\n\t\tif ( errno == EWOULDBLOCK )\n\t\t\u00e4\n\t\t\tFD_SET(socket,&writeSockets);\n\t\t\tif (select(socket+1,NULL,&writeSockets,NULL,&timeout) |=   1)\n\t\t\t\u00e4\n\t\t\t\tdiag(\"connect\");\n\t\t\t\treturn;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\telse if ( errno == ECONNREFUSED)\n\t\t\u00e4\n\t\t\tstatic startToSleep = 0;\n\t\t\tif ( | startToSleep)\n\t\t\t\u00e4\n\t\t\t\tstartToSleep = 1;\n\t\t\t\tprintf(\" Waiting for connection URL:%s port:%d for %d seconds \u00d6n\",URL,port,connwait);\n\t\t\t\u00fc\n\t\t\tsleep(connwait);\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tdiag(\"connect\");\n\t\t\treturn;\n\t\t\u00fc\n\t\u00fc\n\tconnected = true;\n\n\u00fc\n\ntcpipClient::\u00dftcpipClient()\n\u00e4\n\tif (socket|=ERROR_CODE)\n\t\tif (close(socket) == ERROR_CODE)\n\t\t\tdiag(\"close\");\n\tsocket = ERROR_CODE;\n\n\u00fc\n\nint tcpipClient::send(char * from,size_t len)\n\u00e4\n\tchar * off = from;\n\tsize_t snd = 0;\n\tsize_t l   = 0;\n\tif (|connected)\n\t\treturn 0;\n\tFD_SET(socket,&writeSockets);\n\twhile(select(socket+1,NULL,&writeSockets,NULL,&timeout) == 1 && len >0)\n\t\u00e4\n\t\tif ( (l = ::send(socket,off,len,0)) > 0)\n\t\t\u00e4\n\t\t\tsnd += l;\n\t\t\toff += l;\n\t\t\tlen -= l;\n\t\t\u00fc\n\t\telse return(diag(\"send\"));\n\t\u00fc\n\tif (len > 0)\n\t\treturn(diag(\"select send\"));\n\tif (CmdService::debug)\n\t\tprintf(\" tcpipClint send:%s\",from);\n\n\treturn snd;\n\u00fc\n\nint tcpipClient::receive(char * buf,size_t max)\n\u00e4\n\tif (|connected)\n\t\treturn 0;\n\tchar * borig = buf;\n\tsize_t l\t\t\t= max;\n\tsize_t rcv   = 0;\n\twhile(l&&max)\n\t\u00e4\n\t\tFD_SET(socket,&readSockets);\n\t\tif (select(socket+1,&readSockets,NULL,NULL,&timeout) == 1)\n\t\t\u00e4\n\t\t\tif ( (l = ::recv(socket,buf,max,0)) >= 0)\n\t\t\t\u00e4\n\t\t\t\tbuf += l;\n\t\t\t\tmax -= l;\n\t\t\t\trcv += l;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\treturn(diag(\"recv\"));\n\t\t\u00fc\n\t\telse\n\t\t\treturn(diag(\"select receive\"));\n\t\u00fc\n\tif (CmdService::debug)\n\t\u00e4\n\t\tprintf(\" tcpipClint receive:%s\",borig);\n\t\tdump(cgitrace,\"Received tcpip client\",borig,rcv);\n\t\u00fc\n\tif (l==0)\n\t\trcv = -rcv;\n\treturn rcv;\n\u00fc\n\nint tcpipClient::diag(char * t)\n\u00e4\n\tprintf(\" %s %d %s\u00d6n\",t,errno,strerror(errno));\n\treturn 0;\n\u00fc\n\n/*\nint CmdService::printf(const char * format,...)\n\u00e4\nchar w\u00c4PRINTBUFF_MAX\u00dc;\nva_list arg_ptr;\nva_start(arg_ptr,format);\n\nint l = vsprintf(w,format, arg_ptr);\nif (print)\nprint->addBuff(w,l);\nelse\nputs(w);\nva_end(arg_ptr);\nreturn l;\n\u00fc\n*/\n\nint CmdService::backFromRexx()\n\u00e4\n\tchar w\u00c41024\u00dc;\n\tsprintf(w,\"%s.0\",RESULT_STEM);\n\tif (imax=atoi(rexx->fetch(w)))\n\t\tfor(int i=1;i<=imax;i++)\n\t\t\u00e4\n\t\t\tsprintf(w,\"%s.%d\",RESULT_STEM,i);\n\t\t\tchar * c = rexx->fetch(w);\n\t\t\tif (c)\n\t\t\t\u00e4\n\t\t\t\tprintf(\"%s\u00d6n\",c);\n\t\t\t\u00fc\n\t\t\u00fc\n\t\treturn imax;\n\u00fc\n\nTsoCmdService::TsoCmdService(reply p):CmdService(\"TsoCmdService\",p)\n\u00e4\n\ttsi = (IKJEFTSI *)fetch(\"IKJEFTSI\");\n\ttsr = (IKJEFTSR *)fetch(\"IKJEFTSR\");\n\ttst = (IKJEFTST *)fetch(\"IKJEFTST\");\n\ttso = (IKJTSOEV *)fetch(\"IKJTSOEV\");\n\n\tmemset(token,0,sizeof(token));\n\tmemset(cppl,0,sizeof(cppl));\n\tflag=etc=resv=length=program_parm=cpplTso=0;\n\tetc = -1;\n\tif (rc = tso(&resv,&rc,&abend,&reason,&cpplTso))\n\t\u00e4\n\t\tdiag(\"IKJTSOEV\");\n\t\u00fc\n\telse\n\t\u00e4\n\t\tif (rc = tsi(&etc,&resv,token,&rc,&abend,&reason))\n\t\t\u00e4\n\t\t\tdiag(\"IKJEFTSI\");\n\t\t\u00fc\n\t\telse\n\t\t\tok = 1;\n\t\u00fc\n\u00fc\n\nTsoCmdService::\u00dfTsoCmdService()\n\u00e4\n\tif (ok)\n\t\tif (rc = tst(&etc,&resv,token,&rc,&abend,&reason))\n\t\t\u00e4\n\t\t\tdiag(\"IKJEFTSV\");\n\t\t\u00fc\n\t\telse\n\t\t\tok = 0;\n\u00fc\n\nint TsoCmdService::cmd(char *input)\n\u00e4\n\tif (ok&&input)\n\t\u00e4\n\t\tchar w\u00c432000\u00dc;\n\t\tsprintf(w,\"%s %d %s\",REXXCMD,this,input);\n\t\tflag = 1*256*256+debug*256+1;\n\t\tlength = strlen(w);\n\t\tabend=reason = 0;\n\t\trc =  tsr(&flag,w,&length,&rc,&abend,&reason,&program_parm,cppl,token);\n\t\tif (rc>0&&(abend]]reason))\n\t\t\tdiag(input);\n\t\tprintf(\" %s cmd ended with %d, generated %d lines\u00d6n\",input,rc,imax);\n\t\treturn rc;\n\t\u00fc\n\telse\n\t\treturn -1;\n\u00fc\n\nSdsfCmdService::SdsfCmdService(reply p):CmdService(\"SdsfCmdService\",p)\n\u00e4\n\tsdsf = (SDSF *)fetch(\"SDSF\");\n\tif (sdsf)\n\t\tok = 1;\n\u00fc\n\nSdsfCmdService::\u00dfSdsfCmdService()\n\u00e4\n\u00fc\n\nint SdsfCmdService::cmd(char *)\n\u00e4\n\trc = -1;\n\tif (ok)\n\t\u00e4\n\t\tstrcpy(arg.arg_v,\"++250,180\");\n\t\targ.arg_l = strlen(arg.arg_v);\n\t\tvoid * argp\t\t= (void *)&arg;\n\t\tvoid * argpp  = (void *)(unsigned(argp)+unsigned(0x80000000));\n\t\trc = sdsf(argp);\n\t\u00fc\n\treturn rc;\n\u00fc\n\nUssCmdService::UssCmdService(reply p):CmdService(\"UssCmdService\",p)\n\u00e4\u00fc\n\nUssCmdService::\u00dfUssCmdService()\n\u00e4\n\tif (replyFile)\n\t\tfclose(replyFile);\n\u00fc\n\nint UssCmdService::cmd(char *input)\n\u00e4\n\treplyFile = popen(input,\"r\");\n\tif (replyFile)\n\t\u00e4\n\t\timax = 0;\n\t\trc = 0;\n\t\twhile(fgets(buff,sizeof(buff),replyFile))\n\t\t\u00e4\n\t\t\timax++;\n\t\t\tprintf(\" %s\u00d6n\",buff);\n\t\t\u00fc\n\t\tfclose (replyFile);\n\t\tprintf(\" %s cmd ended with %d, generated %d lines\u00d6n\",input,rc,imax);\n\t\u00fc\n\telse\n\t\u00e4\n\t\trc = -1;\n\t\tprintf(\" popen error %s\u00d6n\",strerror(errno));\n\t\u00fc\n\treturn rc;\n\u00fc\n\n\nchar * UssCmdService::next(char *input)\n\u00e4\n\tif (input)\n\t\treplyFile = popen(input,\"rt\");\n\tif(replyFile)\n\t\u00e4\n\t\tif (fgets(buff,sizeof(buff)-1,replyFile))\n\t\t\treturn buff;\n\t\telse\n\t\t\u00e4\n\t\t\tif (replyFile)\n\t\t\t\tfclose(replyFile);\n\t\t\treplyFile = NULL;\n\t\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\n\telse\n\t\treturn NULL;\n\u00fc\n\nJesCmdService::JesCmdService(reply p):CmdService(\"JesCmdSErvice\",p)\n\u00e4\u00fc\nJesCmdService::\u00dfJesCmdService()\n\u00e4\u00fc\n\nint JesCmdService::cmd(char * input)\n\u00e4\n#ifndef SAPI_NO\n\tmvsSTRING from(input);\n\tfrom.strip();\n\tchar w\u00c41024\u00dc;\n\tFILE * iFile = fopen(genOpenName(from,w),\"r\");\n\t/*\n\tFILE * jesSpool = fopen(genOpenName(SPOOL,w),\"w\");\n\tif (|jesSpool)\n\t\u00e4\n\tprintf(\" open error for %s, %s\u00d6n\",SPOOL,strerror(errno));\n\treturn -1;\n\t\u00fc\n\t*/\n\tif (|iFile)\n\t\u00e4\n\t\tprintf(\" open error for %s, %s\u00d6n\",input,strerror(errno));\n\t\treturn -1;\n\t\u00fc\n\n\n\tJES * jes = _X_initJESI();\n\trc = _X_initINTR(jes);\n\tpIOQE ioqe = pIOQE((char *)jes->jes_ioqe-8);\n\n\tif (rc)\n\t\u00e4\n\t\tprintf(\" initINTR error, rc:%d SAPI message:'%s'\u00d6n\",rc,ioqe->ioqe_qsambuf+6);\n\t\treturn 8;\n\t\u00fc\n\n\tchar   jobid\u00c49\u00dc;\n\tchar * jobcard =\tNULL;\n\tchar * jobname  = NULL;\n\twhile(fgets(buff,sizeof(buff),iFile))\n\t\u00e4\n\t\tif (strchr(buff,'\u00d6n'))\n\t\t\t*strchr(buff,'\u00d6n') = 0;\n\t\tchar * jcl = buff;\n\t\tif (|jobcard)\n\t\t\u00e4\n\t\t\tjobcard = strdup(jcl);\n\t\t\tif (strchr(jobcard,' '))\n\t\t\t\t*strchr(jobcard,' ') = 0;\n\t\t\tjobname = jobcard +2;\n\t\t\u00fc\n\t\tif (strlen(jcl)<80)\n\t\t\tmemset(jcl+strlen(jcl),' ',80-strlen(jcl));\n\t\tjcl\u00c480\u00dc = 0;\n\t\trc = _X_nextINTR(jes,jcl);\n\t\tif (rc)\n\t\t\u00e4\n\t\t\tprintf(\" nextINTR error, rc:%d\u00d6n\",rc);\n\t\t\treturn 8;\n\t\t\u00fc\n\t\u00fc\n\tfclose(iFile);\n\tstrcpy(jobid,_X_termINTR(jes));\n\tjobid\u00c48\u00dc  = 0;\n\t//if (debug)\n\tprintf(\" SUBMITTED %s(%s)\u00d6n\",jobname,jobid);\n\n\tchar select\u00c41024\u00dc;\n\tsprintf(select,\" SAPI JOBID(%s) \",jobid);\n\tSAPI sapi;\n\t//if (debug)\n\tprintf(\" SAPI output selection:%s\u00d6n\",select);\n\tvoid  * ECB = NULL;\n\n\trc = _X_initSAPI(jes,select,strlen(select),&sapi,(void *)&ECB,\"JES2\",NULL);\n\trc = _X_nextSAPI(jes);\n\n\twhile (rc==4)\n\t\u00e4\n\t\trc = _X_waitSAPI(jes);\n\t\trc = _X_nextSAPI(jes);\n\t\u00fc\n\n\tif (rc)\n\t\u00e4\n\t\tioqe = pIOQE((char *)jes->jes_ioqe-8);\n\t\tprintf(\" SAPI rc : %d message:'%s'\u00d6n\",rc,ioqe->ioqe_qsambuf+6);\n\t\treturn 8;\n\t\u00fc\n\n\twhile (rc==0)\n\t\u00e4\n\t\tprintf(\" Job:%8.8s JobId:%8.8s Step:%8.8s DDname:%8.8s in SYSOUT class:%c\u00d6n\",\n\t\t\tsapi.sss2->sss2jobr,sapi.sss2->sss2jbir,sapi.sss2->sss2stpd,sapi.sss2->sss2ddnd,sapi.sss2->sss2clar);\n\t\tprintf(\" Step:%8.8s DDname=%8.8s\u00d6n\",sapi.sss2->sss2stpd,sapi.sss2->sss2ddnd);\n\t\tFILE * spool = fopen(sapi.ddname,\"rb,type=record\");\n\n\t\tif (spool)\n\t\t\u00e4\n\n\t\t\tsize_t len=fread(buff,1,32768,spool);\n\t\t\twhile(len>0)\n\t\t\t\u00e4\n\t\t\t\tprintf(\" %*.*s\u00d6n\",len,len,buff);\n\t\t\t\tmemset(buff,0,sizeof(buff));\n\t\t\t\tlen=fread(buff,1,sizeof(buff),spool);\n\t\t\t\u00fc\n\t\t\tfclose(spool);\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tprintf(\" Unable to open %s spool file\u00d6n\",sapi.ddname);\n\t\t\treturn 8;\n\t\t\u00fc\n\t\trc = _X_nextSAPI(jes);\n\t\tif (rc>4)\n\t\t\u00e4\n\t\t\t//if (*(int *)ioqe->ioqe_qsambuf)\n\t\t\tprintf(\" SAPI error rc:%d message:'%s'\u00d6n\",rc,ioqe->ioqe_qsambuf+6);\n\t\t\treturn 8;\n\t\t\u00fc\n\t\telse\n\t\t\tif (rc==4)\n\t\t\t\tbreak;\n\t\u00fc\n\t/*\n\tif (jesSpool)\n\tfclose(jesSpool);\n\t*/\n\t_X_termSAPI(jes);\n\t_X_cleanupJESI(jes);\n\t//_exit(0);\n#endif\n\treturn 0;\n\u00fc\n\nDsnCmdService::DsnCmdService(reply rep):CmdService(\"DsnCmdService\",rep)\n\u00e4\n\tcsi = (IGGCSI00*)fetch(\"IGGCSI00\");\n\tif (csi==NULL)\n\t\u00e4\n\t\tprintf(\" unable to load IGGCSI00\u00d6n\");\n\t\tabort();\n\t\u00fc\n\tasasymbm = (ASASYMBM*)fetch(\"ASASYMBM\");\n\tif (asasymbm==NULL)\n\t\u00e4\n\t\tprintf(\" unable to load ASASYMBM\u00d6n\");\n\t\tabort();\n\t\u00fc\n\tmemset(&symbp,0,sizeof(symbp));\n\tcwork = (char *)malloc(CWORK_SIZE);\n\tif (cwork==NULL)\n\t\u00e4\n\t\tprintf(\" unable to allocate in %d\u00d6n\",CWORK_SIZE);\n\t\tabort();\n\t\u00fc\n\tmemset((void *) &(retinfo_st), 0, sizeof(CSIRetInfo));\n\tmemset((void *) &(selfields_st), ' ', sizeof(CSISelFields));\n\n\tselfields_st.csicldi_c = 'Y';\n\tselfields_st.csiresum_c = ' ';\n\tselfields_st.csis1cat_c = 'Y';\n\tselfields_st.csioptns_c = ' ';\n\tmemset(selfields_st.csicatnm_ac,' ',sizeof(selfields_st.csicatnm_ac));\n\tselfields_st.csinumen_us\t  = 3;\n\tmemcpy( selfields_st.csifldnm,\"VOLSER  NAME    TYPE    \",24);\n\tmemset((void *) cwork, 0,CWORK_SIZE);\n\tcsirwork_pst = (CSIWorkData *) cwork;\n\tcsirwork_pst->csiusrln_ul = CWORK_SIZE;\n\tp = NULL;\n\u00fc\n\nDsnCmdService::\u00dfDsnCmdService()\n\u00e4\n\tif (cwork)\n\t\tfree(cwork);\n\tcwork = NULL;\n\u00fc\n\nint DsnCmdService::cmd(char * pattern,char * reply)\n\u00e4\n\tint csiret_i = 0;\n\tint i,j;\n\n\tif (pattern)\n\t\tmemcpy( selfields_st.csifiltk_ac,pattern, strlen(pattern));\n\n\t//printf(\" CSIEntryData %46.46s \u00d6n\",p);\n\tchar key\u00c451\u00dc;\n\tunsigned char  assoctype;\n\tchar assocname\u00c444\u00dc;\n\tchar volser\u00c46\u00dc;\n\tif (CmdService::debug)\n\t\t_dump(\" Dsn pattern\",pattern,strlen(pattern));\n\tdo\n\t\u00e4\n\t\tif (p==NULL]]\n\t\t\t(((unsigned long)((char *)p-cwork)>=csirwork_pst->csiusdln_ul)&&selfields_st.csiresum_c == 'Y'))\n\t\t\u00e4\n\t\t\tcsiret_i = csi((void *)&retinfo_st,(void *)&selfields_st,(void *)cwork);\n\t\t\tif (csiret_i==0)\n\t\t\t\u00e4\n\t\t\t\tif (short(*(short *)(cwork+CSINUMFD))==0)\n\t\t\t\t\u00e4\n\t\t\t\t\treturn 0;\n\t\t\t\t\u00fc\n\t\t\t\tp = (CSIEntryData *)(cwork+sizeof(CSIWorkData));\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tprintf(\" Catalog search error, for %s \u00d6n    rc: %d reason code %8x\u00d6n\"\n\t\t\t\t\t,pattern,csiret_i,retinfo_st);\n\t\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tif\t((unsigned long)((char *)p-cwork)>=csirwork_pst->csiusdln_ul)\n\t\t\treturn 0;\n\t\tchar  *f = (char *)p+sizeof(CSIEntryData);\n\t\tmemset(key,' ',50);\n\t\tkey\u00c450\u00dc = 0;\n\t\tassoctype = ' ';\n\t\tmemset(assocname,' ',44);\n\t\tmemset(volser,' ',6);\n\t\tif (p->csietype-'0')\n\t\t\u00e4\n\t\t\tif (p->_union._csiel.csielvol)\n\t\t\t\u00e4\n\t\t\t\tmemcpy(volser,f,6);\n\t\t\t\tf +=p->_union._csiel.csielvol;\n\t\t\t\u00fc\n\t\t\tif (p->_union._csiel.csielnam)\n\t\t\t\u00e4\n\t\t\t\tmemcpy(assocname,f,44);\n\t\t\t\tf +=p->_union._csiel.csielnam;\n\t\t\t\u00fc\n\t\t\tif (p->_union._csiel.csieltyp)\n\t\t\t\u00e4\n\t\t\t\tassoctype = *f;\n\t\t\t\tf +=p->_union._csiel.csieltyp;\n\t\t\t\u00fc\n\t\t\u00fc\n\t\telse\n\t\t\tf -=6; //if it is a catalog record\n\n\t\tif (volser\u00c40\u00dc == '&')\n\t\t\u00e4\n\t\t\tvoid * pointer = &symbp;\n\t\t\tchar rvolser\u00c46\u00dc;\n\t\t\tint rvolser_length = 6;\n\t\t\tint symbp_return = 0;\n\t\t\tchar timestamp\u00c432\u00dc;\n\t\t\tsymbp.symbppatternaddr = (void *)volser;\n\t\t\tsymbp.symbppatternlength = 6;\n\t\t\tsymbp.symbptargetaddr        = (void *)rvolser;\n\t\t\tsymbp.symbptargetlengthaddr  = &rvolser_length;\n\t\t\tsymbp.symbpreturncodeaddr    = &symbp_return;\n\t\t\tsymbp.symbptimestampaddr = timestamp;\n\t\t\tsymbp.symbpsymboltableaddr = NULL;\n\t\t\tsymbp_return = asasymbm(volser,6,rvolser,&rvolser_length,NULL,timestamp,&symbp_return);\n\t\t\tif (symbp_return == 0)\n\t\t\t\tmemcpy(&volser,&rvolser,6);\n\t\t\telse\n\t\t\t\tprintf(\" ASASYMBP return code:%d\u00d6n\",symbp_return);\n\t\t\u00fc\n\t\tswitch(p->csietype)\n\t\t\u00e4\n\t\tcase '0':\n\t\t\tbreak;\n\t\tcase 'A':\n\t\tcase 'C':\n\t\tcase 'G':\n\t\tcase 'I':\n\t\tcase 'R':\n\t\tcase 'D':\n\n\t\t\tmemcpy(key,p->csiename,44);\n\t\t\tif (key\u00c40\u00dc==0)\n\t\t\t\tmemset(key,'0',44);\n\t\t\tmemcpy(key+44,volser,6);\n\t\t\tkey\u00c450\u00dc = 0;\n\t\t\tif (reply==NULL)\n\t\t\t\tprintf(\" %s %s %c\u00d6n\",key,volser,p->csietype);\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\treply\u00c40\u00dc=p->csietype;\n\t\t\t\tmemcpy(reply+1,key,50);\n\t\t\t\tp = (CSIEntryData *)f;\n\t\t\t\treturn 1;\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\u00fc\n\t\tp = (CSIEntryData *)f;\n\t\u00fc  while ((char *)p<(cwork+csirwork_pst->csiusdln_ul));\n\treturn 1;\n\u00fc\n\nvoid CmdService::diag(const char * cmd)\n\u00e4\n\tprintf(\" Error in %s, command:%s rc:%d abend:%d reason:%d\u00d6n\",\n\t\tservice,cmd,rc,abend,reason);\n\u00fc\nstatic const char * MXI_TABLE_HEAD\t= \"<table border='1' ='blue' bordercolor='black' class=sortable>\";\nstatic const char * MXI_TABLE_TRAIL = \"</table>\";\nstatic char * refMxi\u00c464\u00dc;\nstatic int    initRefMxi()\n\u00e4\n#define mxiattr(v,name,link) static const int name = v;\u00d6\n\trefMxi\u00c4v\u00dc = link;\n\tmxiattr(0x01,input_pas_dataset,NULL)\n\t\tmxiattr(0x02,output_attr_text,NULL)\n\t\tmxiattr(0x03,output_attr_exception,NULL)\n\t\tmxiattr(0x04,output_attr_warning,NULL)\n\t\tmxiattr(0x05,field_labels,NULL)\n\t\tmxiattr(0x06,outputattr_field_normal,NULL)\n\t\tmxiattr(0x07,outputattr_field_inactive,NULL)\n\t\tmxiattr(0x08,field_column_headings,NULL)\n\t\tmxiattr(0x09,outputattr_field_high,NULL)\n\t\t/*\n\t\tmxiattr(0x0a,reserved)\n\t\tmxiattr(0x0b,reserved)\n\t\tmxiattr(0x0c,reserved)\n\t\t*/\n\t\tmxiattr(0x0d,refdslist,\"REFDSLIST %s\")\n\t\tmxiattr(0x0e,refdslist_volser,\"<a href='vol.sh?%s'>%s</a>\")\n\t\tmxiattr(0x10,refdasd_volser,\"<a href='vol.sh?%s'>%s</a>\")\n\t\tmxiattr(0x11,refdataset_name,\"<a href='dataset.sh?DATASET=%s'>%s</a>\")\n\t\tmxiattr(0x12,refsvc,\"<a href='mxicmd.sh?SVC %s'>%s</a>\")\n\t\tmxiattr(0x13,refaddress_mem,\"<a href='mxicmd.sh?MEM %s'>%s</a>\")\n\t\tmxiattr(0x14,refsubsystem_name,\"\")\n\t\tmxiattr(0x15,reftape_unit,\"\")\n\t\tmxiattr(0x16,refdasd_unit,\"\")\n\t\tmxiattr(0x17,refunit_name,\"\")\n\t\tmxiattr(0x18,refxcf_structure,\"<a href='mxicmd.sh?XCF %s'>%s</a>\")\n\t\tmxiattr(0x19,refsp,\"<a href='mxicmd.sh?SP %s'>%s</a>\")\n\t\tmxiattr(0x1a,refagrp,\"<a href='mxicmd.sh?AGRP %s'>%s</a>\")\n\t\tmxiattr(0x1b,refsrvc,\"<a href='mxicmd.sh?SRVC %s'>%s</a>\")\n\t\tmxiattr(0x1c,refrcls,\"<a href='mxicmd.sh?RCLS %s'>%s</a>\")\n\t\tmxiattr(0x1d,refrl,\"<a href='mxicmd.sh?RL %s'>%s</a>\")\n\t\tmxiattr(0x1e,refemcs,\"<a href='mxicmd.sh?EMCS %s'>%s</a>\")\n\t\tmxiattr(0x1f,refmcs,\"<a href='mxicmd.sh?MCS %s'>%s</a>\")\n\t\tmxiattr(0x21,refsgrp,\"<a href='mxicmd.sh?SGRP %s'>%s</a>\")\n\t\tmxiattr(0x22,refdae,\"<a href='mxicmd.sh?DAE %s'>%s</a>\")\n\t\tmxiattr(0x23,refcf,\"<a href='mxicmd.sh?RL %s'>%s</a>\")\n\t\tmxiattr(0x24,refscls,\"<a href='mxicmd.sh?SCLS %s'>%s</a>\")\n\t\tmxiattr(0x25,refmcls,\"<a href='mxicmd.sh?CF %s'>%s</a>\")\n\t\tmxiattr(0x26,refmxi_command,\"\")\n\t\tmxiattr(0x27,refdcls,\"<a href='mxicmd.sh?DCLS %s'>%s</a>\")\n\t\tmxiattr(0x28,reflls,\"<a href='mxicmd.sh?LLS %s'>%s</a>\")\n\t\tmxiattr(0x29,refjobname_da,\"<a href='mxicmd.sh?DA %s'>%s</a>\")\n\t\tmxiattr(0x2a,reflx,\"<a href='mxicmd.sh?LX %s'>%s</a>\")\n\t\tmxiattr(0x2b,refwlmg,\"<a href='mxicmd.sh?WLMG %s'>%s</a>\")\n\t\tmxiattr(0x2c,refuserid_rl,\"<a href='mxicmd.sh?RL %s'>%s</a>\")\n\t\tmxiattr(0x2d,refhfs,\"<a href='mxicmd.sh?HFS %s'>%s</a>\")\n\t\tmxiattr(0x2e,refpid,\"<a href='mxicmd.sh?PID %s'>%s</a>\")\n\t\tmxiattr(0x2f,refwlma,\"<a href='mxicmd.sh?WLMA %s'>%s</a>\")\n\t\tmxiattr(0x30,refasid,\"<a href='mxicmd.sh?DA A=%s'>%s</a>\")\n\t\tmxiattr(0x31,refwlms,\"<a href='mxicmd.sh?WLMS %s'>%s</a>\")\n\t\tmxiattr(0x32,reflla,\"<a href='mxicmd.sh?LLA %s'>%s</a>\")\n\t\tmxiattr(0x33,refrsys,\"<a href='mxicmd.sh?RSYS %s'>%s</a>\")\n\t\tmxiattr(0x34,refenc,\"<a href='mxicmd.sh?ENC %s'>%s</a>\")\n\t\tmxiattr(0x35,reflogr,\"<a href='mxicmd.sh?LOGR %s'>%s</a>\")\n\t\tmxiattr(0x36,refcon,\"\")\n\t\tmxiattr(0x37,refmqq,\"\")\n\t\tmxiattr(0x38,refmq,\"\")\n\t\tmxiattr(0x39,refmqc,\"\")\n\t\tmxiattr(0x3a,refmqcs,\"\")\n\t\tmxiattr(0x3b,refdb,\"\")\n\t\tmxiattr(0x3c,refdbda,\"\")\n\t\tmxiattr(0x3d,refdbbp,\"\")\n\t\tmxiattr(0x3e,refcommand_group,\"\")\n\t\tmxiattr(0x20,found_string,\"\")\n\t\treturn 0;\n\u00fc\nstatic int    _initRefMxi = initRefMxi();\n\n/*\nMXPS3PT4  EQU  X'0D'             Point-and-shoot DSLIST\nMXPSVTOC  EQU  X'0E'             Point-and-shoot DSLIST Volser\nMXPSVOL   EQU  X'10'             point-and-shoot DASD Volser\nMXPSDSN   EQU  X'11'             point-and-shoot Dataset name\nMXPSSVC   EQU  X'12'             point-and-shoot SVC\nMXPSADDR  EQU  X'13'             point-and-shoot Address (MEM)\nMXPSSSI   EQU  X'14'             point-and-shoot Subsystem name\nMXPSTUNT  EQU  X'15'             point-and-shoot TAPE Unit\nMXPSDUNT  EQU  X'16'             point-and-shoot DASD unit\nMXPSUNTN  EQU  X'17'             point-and-shoot UNIT name\nMXPSXCFS  EQU  X'18'             point-and-shoot XCF structure\nMXPSSP    EQU  X'19'             point-and-shoot SP\nMXPSAGRP  EQU  X'1A'             Point-and-shoot AGRP\nMXPSSRVC  EQU  X'1B'             Point-and-shoot SRVC\nMXPSRCLS  EQU  X'1C'             Point-and-shoot RCLS\nMXPSRL    EQU  X'1D'             Point-and-shoot RL\nMXPSEMCS  EQU  X'1E'             Point-and-shoot EMCS\nMXPSMCS   EQU  X'1F'             Point-and-shoot MCS\nMXPSSGRP  EQU  X'21'             point-and-shoot SGRP\nMXPSDAE   EQU  X'22'             point-and-shoot DAE\nMXPSCF    EQU  X'23'             point-and-shoot CF\nMXPSSCLS  EQU  X'24'             point-and-shoot SCLS\nMXPSMCLS  EQU  X'25'             point-and-shoot MCLS\nMXPSCMD   EQU  X'26'             point-and-shoot MXI Command\nMXPSDCLS  EQU  X'27'             point-and-shoot DCLS\nMXPSLLS   EQU  X'28'             point-and-shoot LLS\nMXPSJOBN  EQU  X'29'             point-and-shoot Jobname (DA)\nMXPSLX    EQU  X'2A'             point-and-shoot LX\nMXPSWLMG  EQU  X'2B'             point-and-shoot WLMG\nMXPSUSER  EQU  X'2C'             point-and-shoot USERID (RL)\nMXPSHFS   EQU  X'2D'             point-and-shoot HFS\nMXPSPID   EQU  X'2E'             point-and-shoot PID\nMXPSWLMA  EQU  X'2F'             point-and-shoot WLMA\nMXPSASID  EQU  X'30'             point-and-shoot ASID\nMXPSWLMS  EQU  X'31'             point-and-shoot WLMS\nMXPSLLA   EQU  X'32'             point-and-shoot LLA\nMXPSRSYS  EQU  X'33'             point-and-shoot RSYS\nMXPSENC   EQU  X'34'             point-and-shoot ENC\nMXPSLOGR  EQU  X'35'             point-and-shoot LOGR\nMXPSCON   EQU  X'36'             point-and-shoot CON\nMXPSMQQ   EQU  X'37'             point-and-shoot MQQ\nMXPSMQ    EQU  X'38'             point-and-shoot MQ\nMXPSMQC   EQU  X'39'             point-and-shoot MQC\nMXPSMQCS  EQU  X'3A'             point-and-shoot MQCS\nMXPSDB    EQU  X'3B'             point-and-shoot DB\nMXPSDBDA  EQU  X'3C'             point-and-shoot DBDA\nMXPSDBBP  EQU  X'3D'             point-and-shoot DBBP\nMXPSCGRP  EQU  X'3E'             point-and-shoot Command Group\n*/\n\n\nMxServerCmdService::MxServerCmdService(reply p):CmdService(\"MxServerCmdService\",p),tcpipClient(MX_PORT)\n\u00e4\n\tif (socket>=0)\n\t\tok = 1;\n\u00fc\n\nMxServerCmdService::\u00dfMxServerCmdService()\n\u00e4\u00fc\n\nchar * nextResult(char * &p)\n\u00e4\n\tstatic char w\u00c4512\u00dc;\n\tif (*p >= ' ' ]]*p==0)\n\t\treturn NULL;\n\tchar * text = refMxi\u00c4int(*p)\u00dc;\n\tint i =1;\n\tfor(;i<80&&p\u00c4i\u00dc>=' ';i++);\n\tchar control = p\u00c4i\u00dc;\n\tp\u00c4i\u00dc = 0;\n\tif (text&&strlen(text))\n\t\tsprintf(w,text,p+1,p+1);\n\telse\n\t\tstrcpy(w,p+1);\n\tp\u00c4i\u00dc = control;\n\tp+=i;\n\tbool empty = true;\n\tfor (i=0;i<strlen(w)&&empty;i++)\n\t\tempty&=(w\u00c4i\u00dc==' ');\n\tif (empty)\n\t\tstrcpy(w,\"&nbsp;\");\n\treturn w;\n\u00fc\n\nint MxServerCmdService::cmd(char * command)\n\u00e4\n\tkeyvalue ** kv = NULL;\n\tchar * title   = NULL;\n\tif (ok&&command&&(kv=parse(command)))\n\t\u00e4\n\t\tmxireq r;\n\t\tmemset(&r,' ',sizeof(r));\n\t\tmemcpy(r.mxireq_operating_sys,\"MVS\",3);\n\t\tfor(int i =0;kv\u00c4i\u00dc;i++)\n\t\t\u00e4\n\t\t\tchar * from = *(kv\u00c4i\u00dc->value);\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),MX_COMMAND)==0)\n\t\t\t\u00e4\n\t\t\t\ttitle = from;\n\t\t\t\tsize_t l = strlen(from)<sizeof(r.mxireq_command)?strlen(from):sizeof(r.mxireq_command);\n\t\t\t\tr.mxireq_command_length = (unsigned char)l;\n\t\t\t\tmemcpy(r.mxireq_command,from,l);\n\t\t\t\u00fc\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),MX_USERID)==0)\n\t\t\t\u00e4\n\t\t\t\tsize_t l = strlen(from)<sizeof(r.mxireq_userid)?strlen(from):sizeof(r.mxireq_userid);\n\t\t\t\tr.mxireq_userid_length = (unsigned char)l;\n\t\t\t\tmemcpy(r.mxireq_userid,from,l);\n\t\t\t\u00fc\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),MX_GROUPID)==0)\n\t\t\t\u00e4\n\t\t\t\tsize_t l = strlen(from)<sizeof(r.mxireq_group_name)?strlen(from):sizeof(r.mxireq_group_name);\n\t\t\t\tr.mxireq_group_length = (unsigned char)l;\n\t\t\t\tmemcpy(r.mxireq_group_name,from,l);\n\t\t\t\u00fc\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),MX_MQS)==0)\n\t\t\t\u00e4\n\t\t\t\tsize_t l = strlen(from)<sizeof(r.mxireq_mqs_ssid)?strlen(from):sizeof(r.mxireq_mqs_ssid);\n\t\t\t\tmemcpy(r.mxireq_mqs_ssid,from,l);\n\t\t\t\u00fc\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),MX_DB2)==0)\n\t\t\t\u00e4\n\t\t\t\tsize_t l = strlen(from)<sizeof(r.mxireq_db2_ssid)?strlen(from):sizeof(r.mxireq_db2_ssid);\n\t\t\t\tmemcpy(r.mxireq_db2_ssid,from,l);\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tif (send((char *)&r,sizeof(r)))\n\t\t\u00e4\n\t\t\tmxis m;\n\t\t\tchar * msg = (char *)&m;\n\t\t\tif (receive((char *)&m,sizeof(m))|=sizeof(m))\n\t\t\t\u00e4\n\t\t\t\tprintf(\" MX message %24.24s (%70.70s)\u00d6n\u00d6n\u00d6n\",(char *)msg+4,msg+28);\n\t\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\u00e4\n\t\t\t\tbool table = (m.mxissnum&&(memcmp(m.mxispanm,\"MXIPANEL\",8)==0));\n\t\t\t\tmxdt t;\n\t\t\t\tif (receive((char *)&t,sizeof(t)-1)==0)\n\t\t\t\t\u00e4\n\t\t\t\t\tprintf(\" MX message error\u00d6n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tif (CmdService::debug)\n\t\t\t\t\t\tdump(cgitrace,\"Received mxis:\",&m,sizeof(m));\n\t\t\t\t\t/*\n\t\t\t\t\tprintf(\"<title>%s</title><meta http-equiv=\u00d6\"pragma\u00d6\" content=\u00d6\"no-cache\u00d6\"><body BGCOLOR=\u00d6\"#000000\u00d6\" TEXT=\u00d6\"#00FFFF\u00d6\"><pre>\u00d6n\",title);\n\t\t\t\t\tprintf(\"%80.80s\u00d6n%80.80s\u00d6n%80.80s\u00d6n\",t.mxdtttl,t.mxdtlb2,t.mxdtlb3);\n\t\t\t\t\t*/\n\t\t\t\t\tsize_t resultLen = t.mxdtsiz+1-sizeof(t);\n\t\t\t\t\tchar * result = new char\u00c4resultLen+1\u00dc;\n\t\t\t\t\tmemset(result,0,resultLen+1);\n\t\t\t\t\tif ((receive(result,resultLen))==0)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tprintf(\" MX result error\u00d6n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tint colspan = 0;\n\t\t\t\t\t\tif (CmdService::debug)\n\t\t\t\t\t\t\tdump(cgitrace,\"Received result:\",result,resultLen);\n\t\t\t\t\t\tif (table)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tprintf(\"%s\u00d6n\",MXI_TABLE_HEAD);\n\t\t\t\t\t\t\tprintf(\"<tr>\u00d6n\");\n\t\t\t\t\t\t\tfor(int i =1;i<=m.mxissnum;i++)\n\t\t\t\t\t\t\t\tprintf(\"<th align=left>%8.8s</th>\u00d6n\",m.mxissf1+(i-1)*16+1);\n\t\t\t\t\t\t\tprintf(\"</tr>\u00d6n\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tprintf(\"%s\u00d6n\",MXI_TABLE_HEAD);\n\t\t\t\t\t\t\tfor(int i=0,j=1;i<resultLen&&j<=t.mxdtnum;i+=80,j++)\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tchar w\u00c481\u00dc;\n\t\t\t\t\t\t\t\tmemcpy(w,result+i,80);\n\t\t\t\t\t\t\t\tw\u00c480\u00dc =0;\n\t\t\t\t\t\t\t\tint cs = 0;\n\t\t\t\t\t\t\t\tfor(int k =0;k<80;k++)\n\t\t\t\t\t\t\t\t\tif (w\u00c4k\u00dc<' '&&w\u00c4k\u00dc)\n\t\t\t\t\t\t\t\t\t\tcs++;\n\t\t\t\t\t\t\t\tif (cs>colspan)\n\t\t\t\t\t\t\t\t\tcolspan = cs;\n\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tfor(int i=0,j=1;i<resultLen&&j<=t.mxdtnum;i+=80,j++)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tif (table]]1)\n\t\t\t\t\t\t\t\tif (j%2 == 1)\n\t\t\t\t\t\t\t\t\tprintf(\"<tr class='odd'>\u00d6n\");\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tprintf(\"<tr>\u00d6n\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tprintf(\"<p>\");\n\t\t\t\t\t\t\tchar w\u00c481\u00dc;\n\t\t\t\t\t\t\tmemcpy(w,result+i,80);\n\t\t\t\t\t\t\tw\u00c480\u00dc =0;\n\t\t\t\t\t\t\tchar * next = w;\n\t\t\t\t\t\t\tchar * print = NULL ;\n\t\t\t\t\t\t\t//if (*next==0)\n\t\t\t\t\t\t\t//\tbreak;\n\t\t\t\t\t\t\tbool first = true;\n\t\t\t\t\t\t\tint col = 0;\n\t\t\t\t\t\t\twhile(print = nextResult(next))\n\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\tcol++;\n\t\t\t\t\t\t\t\tbool lastcol = true;\n\t\t\t\t\t\t\t\tfor(int k=0;next\u00c4k\u00dc;k++)\n\t\t\t\t\t\t\t\t\tif (next\u00c4k\u00dc<' ')\n\t\t\t\t\t\t\t\t\t\tlastcol = false;\n\t\t\t\t\t\t\t\tif (table]]1)\n\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\tif (colspan&&lastcol)\n\t\t\t\t\t\t\t\t\t\tprintf(\"<td colspan='%d'>\",colspan-col+1);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tprintf(\"<td>\");\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\tprintf(\"%s\",print);\n\t\t\t\t\t\t\t\tif (table]]1)\n\t\t\t\t\t\t\t\t\tprintf(\"</td>\");\n\t\t\t\t\t\t\t\u00fc;\n\t\t\t\t\t\t\tif (table]]1)\n\t\t\t\t\t\t\t\tprintf(\"</tr>\u00d6n\");\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tif (table]]1)\n\t\t\t\t\t\t\tprintf(\"%s\u00d6n\",MXI_TABLE_TRAIL);\n\t\t\t\t\t\u00fc\n\t\t\t\t\tif (result)\n\t\t\t\t\t\tdelete result;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\treturn 0;\n\u00fc\n\n\n\nRexxServerCmdService::RexxServerCmdService(reply p):CmdService(\"RexxServerCmdService\",p),tcpipClient(REXXSERVER_PORT)\n\u00e4\n\tif (socket>=0)\n\t\tok = 1;\n\u00fc\n\nRexxServerCmdService::\u00dfRexxServerCmdService()\n\u00e4\u00fc\n\nint RexxServerCmdService::cmd(char * command)\n\u00e4\n\tkeyvalue ** kv = NULL;\n\tif (ok&&command&&(kv=parse(command)))\n\t\u00e4\n\t\tREXXSERVER_REQUEST r;\n\t\tmemset(&r,' ',sizeof(r));\n\t\tfor(int i =0;kv\u00c4i\u00dc;i++)\n\t\t\u00e4\n\t\t\tchar * from = *(kv\u00c4i\u00dc->value);\n\t\t\tint    l    = strlen(from);\n\t\t\tif (strcasecmp(*(kv\u00c4i\u00dc->key),REXXSERVER_COMMAND)==0)\n\t\t\t\u00e4\n\t\t\t\tl = l<sizeof(r.command)?l:sizeof(r.command);\n\t\t\t\tmemcpy(r.command,from,l);\n\t\t\t\u00fc\n\t\t\telse\tif (strcasecmp(*(kv\u00c4i\u00dc->key),REXXSERVER_TYPE)==0)\n\t\t\t\u00e4\n\t\t\t\tl = l<sizeof(r.type)?l:sizeof(r.type);\n\t\t\t\tmemcpy(r.type,from,l);\n\t\t\t\u00fc\n\t\t\telse if (strcasecmp(*(kv\u00c4i\u00dc->key),REXXSERVER_REPLYID)==0)\n\t\t\t\u00e4\n\t\t\t\tl = l<sizeof(r.replyid)?l:sizeof(r.replyid);\n\t\t\t\tmemcpy(r.replyid,from,l);\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tif (send((char *)&r,sizeof(r)))\n\t\t\u00e4\n\t\t\tchar b\u00c432000\u00dc;\n\t\t\tint rc = 0;\n\t\t\tif ((rc=receive((char *)b,sizeof(b))-1)==0)\n\t\t\t\u00e4\n\t\t\t\tprintf(\" REXXSERVER error, nothing received\u00d6n\");\n\t\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\twhile(rc)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (rc<0)\n\t\t\t\t\t\trc=-rc;\n\t\t\t\t\tint bc=0;\n\t\t\t\t\tfor(int i =0;i<rc;i++)\n\t\t\t\t\t\tif (b\u00c4i\u00dc < ' ' && b\u00c4i\u00dc-'\u00d6n')\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tb\u00c4i\u00dc = ' ';\n\t\t\t\t\t\t\tbc++;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\tif (CmdService::debug)\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\tprintf(\" REXXSERVER:%s\",b);\n\t\t\t\t\t\t\tdump(cgitrace,\"Received\",b,rc);\n\t\t\t\t\t\t\u00fc\n\n\n\t\t\t\t\t\tb\u00c4rc\u00dc=0;\n\t\t\t\t\t\t//if (bc<rc)\n\t\t\t\t\t\tprintf(\" %s\",b);\n\t\t\t\t\t\trc=receive((char *)b,sizeof(b)-1);\n\t\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\treturn 0;\n\u00fc\n\n/*\nOperCmdService::OperCmdService(reply p):CmdService(\"OperCmdService\",p)\n\u00e4\u00fc\nOperCmdService::\u00dfOperCmdService()\n\u00e4\u00fc\nint OperCmdService::cmd(char *c)\n\u00e4\nprintf(\" Oper command %s\u00d6n\",c);\nreturn 0;\n\u00fc\n*/\n\n\nOperCmdService::OperCmdService(reply p):CmdService(\"OperCmdService\",p),tcpipClient(REXXSERVER_PORT)\n\u00e4\n\tif (socket>=0)\n\t\tok = 1;\n\u00fc\n\nOperCmdService::\u00dfOperCmdService()\n\u00e4\u00fc\n\nint OperCmdService::cmd(char * command)\n\u00e4\n\tkeyvalue ** kv = NULL;\n\tif (ok&&command&&(kv=parse(command)))\n\t\u00e4\n\t\tREXXSERVER_REQUEST r;\n\t\tmemset(&r,' ',sizeof(r));\n\t\tmemcpy(r.command,command,strlen(command));\n\t\tmemcpy(r.type,WD4Z,strlen(WD4Z));\n\t\tif (send((char *)&r,sizeof(r)))\n\t\t\u00e4\n\t\t\tchar b\u00c432000\u00dc;\n\t\t\tint rc = 0;\n\t\t\tif ((rc=receive((char *)b,sizeof(b))-1)==0)\n\t\t\t\u00e4\n\t\t\t\tprintf(\" REXXSERVER error, nothing received\u00d6n\");\n\t\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\twhile(rc)\n\t\t\t\t\u00e4\n\t\t\t\t\tif (rc<0)\n\t\t\t\t\t\trc=-rc;\n\t\t\t\t\tint bc=0;\n\t\t\t\t\t/*\n\t\t\t\t\tfor(int i =0;i<rc;i++)\n\t\t\t\t\tif (b\u00c4i\u00dc==0x25)\n\t\t\t\t\tb\u00c4i\u00dc = '\u00d6n';\n\t\t\t\t\t*/\n\t\t\t\t\tif (CmdService::debug)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tprintf(\" REXXSERVER:%s\",b);\n\t\t\t\t\t\tdump(cgitrace,\"Received\",b,rc);\n\t\t\t\t\t\u00fc\n\n\n\t\t\t\t\tb\u00c4rc\u00dc=0;\n\t\t\t\t\t//if (bc<rc)\n\t\t\t\t\tprintf(\" %s\",b);\n\t\t\t\t\trc=receive((char *)b,sizeof(b)-1);\n\t\t\t\t\u00fc\n\t\t\u00fc\n\t\u00fc\n\treturn 0;\n\u00fc\n\n//int main(int argc,char * argv\u00c4\u00dc)??????????????????\nint mainX(int argc,char * argv\u00c4\u00dc)\n\n\u00e4\n\tmvsSTRING::parseSepCh='\u00d6''; //szm20061218 mvsSTRING parse escape ch set here to apostrophe , all other cases null|||||||\n\t//FILE * reopen_stdout = freopen(\"//dd:sysprint\",\"w,recfm=VB,lrecl=32756,blksize=32760\",stdout);\n\n\tTsoCmdService *\t\t\t\ttso =  NULL;\n\tUssCmdService\t*\t\t\t\tunix = NULL;\n\tJesCmdService *   \t\tjes  = NULL;\n\tDsnCmdService *  \t\t\tdsn  = NULL;\n\tOperCmdService *\t\t\toper = NULL;\n\tSdsfCmdService *\t\t\tsdsf = NULL;\n\tMxServerCmdService *  mx  = NULL;\n\tRexxServerCmdService *rs  = NULL;\n\n\tconst static char *version=ISIS_VERSION;\n\tconst static char *compileDate=ISIS_VERSION_DATE;\n#if 0\n\tvoid * * R1 = __osplist;\n\tchar * argv\u00c42\u00dc = \u00e4 \"MVSSERVS\",NULL\u00fc;\n\tint    argc    = 2;\n\tchar _b\u00c432700\u00dc;\n\tint l\t\t\t= *(int *)*(R1+1);\n\tchar * c  = *(char **)*R1;\n\tmemcpy(_b,c,l);\n\t_b\u00c4l\u00dc = 0;\n\targv\u00c41\u00dc = _b;\n#endif\n\tif (CmdService::debug)\n\t\tprintf(\" %s tester %s %s Version:%s Compiled:%s\u00d6n\",argv\u00c40\u00dc,ISIS_PF_SID,ISIS_PF_NAME,version,compileDate);\n\tif (strcasecmp(argv\u00c40\u00dc,CALLBACK_PROGRAM)==0)\n\t\u00e4\n\t\tCmdService * cmd = (CmdService *)(atoi(argv\u00c41\u00dc));\n\t\tif (cmd)\n\t\t\u00e4\n\t\t\tcmd->backFromRexx();\n\t\t\u00fc\n\t\telse\n\t\t\tprintf(\" Callbak address zero\u00d6n\");\n\t\u00fc\n\telse\n\t\u00e4\n\t\tmvsSTRING b;\n\t\tchar buff\u00c432700\u00dc;\n\t\tbuff\u00c40\u00dc = 0;\n\t\tif (argc>1)\n\t\t\u00e4\n\t\t\tif (CmdService::debug)\n\t\t\t\tprintf(\" argc:%d\u00d6n\",argc);\n\t\t\tfor (int i =1;i<=argc;i++)\n\t\t\t\u00e4\n\t\t\t\tif (CmdService::debug)\n\t\t\t\t\tprintf(\"argv\u00c4%d\u00dc:%s\u00d6n\",i,argv\u00c4i\u00dc);\n\t\t\t\tstrcpy(buff+strlen(buff),argv\u00c4i\u00dc);\n\t\t\t\tstrcat(buff,\" \");\n\n\t\t\t\u00fc\n\n\t\t\tif (strchr(buff,'\u00d6n'))\n\t\t\t\t*strchr(buff,'\u00d6n') = 0;\n\t\t\tfor(int i=0;i<strlen(buff);i++)\n\t\t\t\u00e4\n\t\t\t\tif (buff\u00c4i\u00dc=='+')\n\t\t\t\t\tbuff\u00c4i\u00dc = ' ';\n\t\t\t\telse\n\t\t\t\t\tif (buff\u00c4i\u00dc=='-')\n\t\t\t\t\t\tbuff\u00c4i\u00dc = '+';\n\t\t\t\t\telse\n\t\t\t\t\t\tif (buff\u00c4i\u00dc=='_')\n\t\t\t\t\t\t\tbuff\u00c4i\u00dc = '%';\n\n\t\t\t\u00fc\n\t\t\tb =buff+1;\n\t\t\tif (CmdService::debug)\n\t\t\t\tprintf(\">>%s\u00d6n\",buff);\n\t\t\tb.strip();\n\t\t\u00fc\n\t\telse\n\t\t\tbuff\u00c40\u00dc = 'S';\n\n\t\tswitch (buff\u00c40\u00dc)\n\t\t\u00e4\n\t\tcase 'r':\n\t\tcase 'R':\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tif (strcasecmp(argv\u00c40\u00dc,AUTHSERVER))\n\t\t\t\u00e4\n\t\t\t\tif (|tso)\n\t\t\t\t\ttso = new TsoCmdService();\n\t\t\t\ttso->cmd(b);\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tprintf(\" We can't start TSO in auth environment\u00d6n\");\n\t\t\tbreak;\n\t\tcase 'u':\n\t\tcase 'U':\n\t\t\tif (|unix)\n\t\t\t\tunix = new UssCmdService();\n\t\t\tunix->cmd(b);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\tcase 'J':\n\t\t\tif (strcasecmp(argv\u00c40\u00dc,SERVER))\n\t\t\t\u00e4\n\t\t\t\tif (|jes)\n\t\t\t\t\tjes = new JesCmdService();\n\t\t\t\tjes->cmd(b);\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tprintf(\" We can't start JES in Unauth environment\u00d6n\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tif (|dsn)\n\t\t\t\tdsn = new DsnCmdService();\n\t\t\tdsn->cmd(b,NULL);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'O':\n\t\t\tif (|oper)\n\t\t\t\toper = new OperCmdService();\n\t\t\toper->cmd(b);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (|sdsf)\n\t\t\t\tsdsf = new SdsfCmdService();\n\t\t\tsdsf->cmd(b);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tif (|mx)\n\t\t\t\tmx = new MxServerCmdService();\n\t\t\tmx->cmd(b);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tif (|rs)\n\t\t\t\trs = new RexxServerCmdService();\n\t\t\trs->cmd(b);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"?? %s\u00d6n\",buff);\n\t\t\u00fc\n\t\tif (tso)\n\t\t\tdelete tso;\n\t\tif (unix)\n\t\t\tdelete unix;\n\t\tif (jes)\n\t\t\tdelete jes;\n\t\tif (dsn)\n\t\t\tdelete dsn;\n\t\tif (sdsf)\n\t\t\tdelete sdsf;\n\t\tif (mx)\n\t\t\tdelete mx;\n\t\tif (rs)\n\t\t\tdelete rs;\n\n\t\u00fc\n\n\treturn 0;\n\u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT888/CBT.V500.FILE888.PDS/CPP.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT888/CBT.V500.FILE888.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}