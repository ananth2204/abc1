
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(STRSERV)'                      07.01.13 11:00:48
0                                      * * * * *   P R O L O G   * * * * *
    Compiler options. . . . . . . :AGGRCOPY(NOOVERLAP)             ANSIALIAS       ARCH(7)         ARGPARSE        NOASCII
                                  :NOATTRIBUTE     ASSERT(RESTRICT)                BITFIELD(UNSIGNED)              CHARS(UNSIGNED)
                                  :NOCOMPACT       NOCOMPRESS      CVFT            NODFP           DIGRAPH
                                  :DLL(NOCALLBACKANY)              ENUMSIZE(SMALL) NOEVENTS        EXECOPS         EXH
                                  :NOEXPMAC        NOEXPORTALL     NOFASTTEMPINC   FLAG(I)         GOFF            GONUMBER
                                  :HALT(16)        NOHGPR(NOPRESERVE)              NOHOT           NOIGNERRNO      ILP32
                                  :NOINITAUTO      NOINLRPT        NOLIBANSI       NOLIST          LONGNAME        NOMAKEDEP
                                  :NOMARGINS       MAXMEM(2097152) MEMORY          NAMEMANGLING(zOSV1R2)           NESTINC(255)
                                  :OBJECT          OBJECTMODEL(COMPAT)             NOOE            NOOFFSET        OPTIMIZE(2)
                                  :PLIST(HOST)     NOPORT          NOPPONLY        PREFETCH        REDIR           NOREPORT
                                  :ROSTRING        ROCONST         RTTI(ALL)       NOSEQUENCE      NOSHOWINC       NOSHOWMACROS
                                  :SOURCE          SKIPSRC(SHOW)   SPILL(3600)     START           NOSTATICINLINE  STRICT
                                  :NOSTRICT_INDUCTION              TARGET(LE,CURRENT)              NOTEMPLATEREGISTRY
                                  :TEMPLATERECOMPILE               TERMINAL        TEST(HOOK)      TMPLPARSE(NO)   TUNE(7)
                                  :UNROLL(AUTO)    UTF             NOWARN0X        NOWARN64        NOWSIZEOF       NOXREF
                                  :NOCICS
                                  :NOCONVLIT
                                  :CSECT()
                                  :DEBUG(FORMAT(ISD),LEVEL(0),HOOK(NOLINE,NOBLOCK,NOPATH,CALL,FUNC),NOSYMBOL)
                                  :DEFINE(__OS390__=1,_POSIX_SOURCE=1,_XOPEN_SOURCE_EXTENDED=1,MU_STANDALONE=1,ISIS_PF_MU=1,
                                   MU_STANDALONE=1,SAPI_NO=1,VSAM_NO=1)
                                  :FLOAT(HEX,FOLD,AFP(NOVOLATILE)) ROUND(Z)
                                  :NOHALTONMSG
                                  :INFO(LAN)
                                  :INLINE(AUTO,NOREPORT,100,1000)
                                  :NOIPA
                                  :KEYWORD(bool,explicit,export,false,mutable,namespace,true,typename,using,restrict,__restrict__,
                                   __restrict,_Pragma,__alignof__,__asm__,__attribute__,__const__,__extension__,__volatile__,
                                   __inline__,__signed__,__typeof__)
                                  :NOKEYWORD(char16_t,char32_t,static_assert,typeof)
                                  :LANGLVL(ANONSTRUCT,ANONUNION,ANSIFOR,ANSISINIT,NOAUTOTYPEDEDUCTION,C99VLA,C99__FUNC__,
                                   NOC99LONGLONG,NOC99PREPROCESSOR,NODBCS,NODECLTYPE,NODELEGATINGCTORS,DEPENDENTBASELOOKUP,
                                   NODOLLARINNAMES,EMPTYSTRUCT,NOEXTENDEDFRIEND,NOEXTENDEDINTEGERSAFE,EXTERNTEMPLATE,ILLPTOM,
                                   IMPLICITINT,NOINLINENAMESPACE,LIBEXT,LONGLONG,NONEWEXCP,OFFSETNONPOD,NOOLDDIGRAPH,OLDFRIEND,
                                   NOOLDMATH,NOOLDSTR,OLDTEMPACC,NOOLDTMPLALIGN,OLDTMPLSPEC,NOSTATIC_ASSERT,TRAILENUM,TYPEDEFCLASS,
                                   NOUCS,VARARGMACROS,NOVARIADICTEMPLATES,GNU_INCLUDE_NEXT,ZEROEXTARRAY)
                                  :LOCALE(DE_DE.IBM-273)
                                  :NOLSEARCH
                                  :OPTFILE(DD:OPTFILE)
                                  :NORTCHECK
                                  :SEARCH(//'CEE.SCEEH.+', //'CBC.SCLBH.+', CEE.SCEEH.+, CBC.SCLBH.+, DD:USERLIB)
                                  :NOSERVICE
                                  :NOSQL
                                  :NOSUPPRESS
                                  :TEMPINC(./tempinc)
                                  :XPLINK(NOBACKCHAIN,NOCALLBACK,GUARD,OSCALL(NOSTACK),NOSTOREARGS)
    Version Macros. . . . . . . . : __COMPILER_VER__=0x410C0000
                                  : __LIBREL__=0x410C0000
                                  : __TARGET_LIB__=0x410C0000
    Source margins. . . . . . . . :
      Varying length. . . . . . . : 1 - 32760
      Fixed length. . . . . . . . : 1 - 32760
    Sequence columns. . . . . . . :
      Varying length. . . . . . . : none
      Fixed length. . . . . . . . : none
    Locale name . . . . . . . . . : DE_DE.IBM-273
    Code set. . . . . . . . . . . : IBM-273
    Listing name. . . . . . . . . : DD:SYSCPRT
0                                 * * * * *   E N D   O F   P R O L O G   * * * * *
-
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(STRSERV)'                      07.01.13 11:00:48
-
                                       * * * * *   S O U R C E   * * * * *
0            1 | #pragma runopts(POSIX(ON),XPLINK(ON))
             2 |
             3 | #define ISIS_ALLOW_OS_FUNCTIONS 1
             4 | #define _XOPEN_SOURCE_EXTENDED 1
             5 | #define  _OPEN_SYS             1
             6 | #define  _OPEN_THREADS         1
             7 | #define _XOPEN_SOURCE 500
             8 | #define _LARGE_FILES 1
             9 | #ifndef _SHR_ENVIRON
            10 | #define _SHR_ENVIRON 1
            11 | #endif
            12 | #define _SHARE_EXT_VARS 1
            13 | #define  environ  (*(__Envn()))
            14 |
            15 | #include "isisdef.h"
            16 | #include "versinfo.h"
            17 | #include "osmfind.hpp"
            18 |
            19 | #include <signal.h>
            20 | #include <dll.h>
            21 | #include <limits.h>
            22 | #include <unistd.h>
            23 | #include <stdlib.h>
            24 | #include <pwd.h>
            25 | #include <assert.h>
            26 | #include <ctype.h>
            27 | #include <string.h>
            28 | #include <strings.h>
            29 | #include <dirent.h>
            30 | #include <fcntl.h>
            31 | #include <sys/types.h>
            32 | #include <sys/stat.h>
            33 | #include <sys/wait.h>
            34 | #include <errno.h>
            35 | #include <stdarg.h>
            36 | #include <stdlib.h>
            37 | #include <stdio.h>
            38 | #include <assert.h>
            39 | #include <ctype.h>
            40 | #include <fcntl.h>
            41 | #include <stdlib.h>
            42 | #include <string.h>
            43 | #include <sys/socket.h>
            44 | #include <sys/time.h>
            45 | #include <arpa/inet.h>
            46 | #include <netdb.h>
            47 | #include <fcntl.h>
            48 | #include <errno.h>
            49 | #include <netinet/in.h>
            50 | #include <errno.h>
            51 |
            52 | int _edc_add_errno2   = setenv("_EDC_ADD_ERRNO2","1",1);  //szm20040129 byteseek set
            53 |
            54 | #include "misc.hpp"
            55 | #include "osmfind.hpp"
            56 | #include "jesi.hpp"
            57 | #include "caljesi.hpp"
            58 | #include "mchain.hpp"
            59 | #include "casmif.hpp"
            60 | #include "msgmgr.hpp"
            61 | #include "jobenv.hpp"
            62 | #include "rexxvar.hpp"
            63 | #include "strserv.hpp"
            64 | #include "misc.hpp"
            65 | #include "caljesi.hpp"
            66 | #include "jesi.hpp"
            67 | #include "mchain.hpp"
            68 | #include "casmif.hpp"
            69 | #include "msgmgr.hpp"
            70 | #include "jobenv.hpp"
            71 | #include "mvsbase.hpp"
            72 | #include "msgmgr.hpp"
            73 | #include "strnode.hpp"
            74 | #include "mvsstr.hpp"
            75 |
            76 | int _dump(char * ,char * ,int );
            77 |
            78 | timeval    tcpipClient::timeout		= ä300,0ü;
            79 | int        tcpipClient::connwait	= 5;
            80 | char       tcpipClient::URLÄ255Ü  = "";
            81 | bool       CmdService::debug = false;
            82 |
            83 | #ifndef ERROR_CODE
            84 | #define ERROR_CODE -1
            85 | #endif
            86 |
            87 | static const char * REXXCMD     =  "STRREXX" ;
            88 | static const char * CALLBACK_PROGRAM    =  "MVSSERVB";
            89 | static const char * SERVER      =  "MVSSERVS";
            90 | static const char * AUTHSERVER  =  "MVSSERVA";
            91 | static const char * SPOOL       =  "SPOOL";
            92 | static const int    PRINTBUFF_MAX = 1024*256;
            93 | static const char * ISFIN       =  "//DD:ISFIN   ";
            94 | static const char * ISFOUT      =  "//DD:ISFOUT  ";
            95 | static const char * MX_COMMAND  =  "COMMAND";
            96 | static const char * MX_USERID   =  "USER";
            97 | static const char * MX_GROUPID  =  "GROUP";
            98 | static const char * MX_MQS      =  "MQS";
            99 | static const char * MX_DB2      =  "DB2";
           100 | static const char * RESULT_STEM = "STRRESULTSTEM";
           101 | static const short  MX_PORT					=  8001;
           102 | static const short  REXXSERVER_PORT =  8002;
           103 | static const char * REXXSERVER_TYPE =		"TYPE";
           104 | static const char * REXXSERVER_COMMAND= "COMMAND";
           105 | static const char * REXXSERVER_REPLYID= "REPLYID";
           106 | static const char * WD4Z              = "WD4Z";
           107 | typedef struct
           108 | ä
           109 | 	char typeÄ10Ü;
           110 | 	char replyidÄ86Ü;
           111 | 	char commandÄ4000Ü;
           112 | ü REXXSERVER_REQUEST;
           113 |
           114 | BPXWDYN  * CmdService::dyn  = (BPXWDYN *)fetch("BPXWDYN ");
           115 |
           116 | FILE * _cgitrace = fopen("//dd:cgitrace","w");
           117 | FILE * cgitrace = CmdService::debug?(_cgitrace?_cgitrace:stderr):NULL;
           118 |
           119 | class keyvalue
           120 | ä
           121 | public:
           122 | 	mvsSTRING * key;
           123 | 	mvsSTRING * value;
           124 | 	keyvalue(mvsSTRING *k,mvsSTRING *v)
           125 | 	ä
           126 | 		key		= k;
           127 | 		value = v;
           128 | 	ü
           129 | ü;
           130 |
           131 | keyvalue ** parse(const char * com,const char *sep=",")
           132 | ä
           133 | 	if (com&&strlen(com))
           134 | 	ä
           135 | 		static keyvalue * kvÄ256Ü;
           136 | 		mvsSTRING s(com);
           137 | 		s.strip();
           138 | 		size_t ind = 0;
           139 | 		while (strlen(s)>0)
           140 | 		ä
           141 | 			mvsSTRING key , value , rest;
           142 | 			s.strip().parse(key,"=",value,(char *)sep,rest);
           143 | 			key.strip();
           144 | 			value.strip();
           145 | 			if (valueÄ0Ü == 'Ö'' ]] valueÄ0Ü == '"')
           146 | 				value = value(1,strlen(value)-2);
           147 | 			if (CmdService::debug)
           148 | 				printf("string:%s key:%s value:%s rest:%sÖn",(char *)s,(char *)key,(char *)value,(char *)rest);
           149 | 			kvÄind++Ü = new keyvalue(new mvsSTRING(key),new mvsSTRING(value));
           150 | 			s = rest;
           151 | 			kvÄindÜ = NULL;
           152 | 		ü
           153 | 		return kv;
           154 | 	ü
           155 | 	else
           156 | 		return NULL;
           157 | ü
           158 |
           159 | tcpipClient::tcpipClient(short p):port(p)
           160 | ä
           161 | 	socket = ERROR_CODE;
           162 | 	connected = false;
           163 | 	memset(&sockaddr,0,sizeof(sockaddr));
           164 | 	memset(&sockaddrUnix,0,sizeof(sockaddrUnix));
           165 | 	FD_ZERO(&readSockets);
           166 | 	FD_ZERO(&writeSockets);
           167 | 	FD_ZERO(&exceptionSockets);
           168 | 	sockaddr.sin_family = AF_INET;
           169 | 	sockaddrUnix.sun_family = AF_UNIX;
           170 | 	unsigned long addr  = 0;
           171 | 	if (port)
           172 | 	ä
           173 | 		if (strlen(URL)==0)
           174 | 			gethostname(URL,sizeof(URL));
           175 | 		if (isdigit(URLÄ0Ü))
           176 | 			addr = inet_addr(URL);
           177 | 		else
           178 | 		ä
           179 | 			hostent * he = gethostbyname(URL);
           180 | 			if ( he == 0 )
           181 | 			ä
           182 | 				diag("gethostbyname");
           183 | 				return;
           184 | 			ü
           185 | 			else
           186 | 				addr =*((unsigned*)(he->h_addr));
           187 | 		ü
           188 | 		sockaddr.sin_addr.s_addr = addr;
           189 | 		sockaddr.sin_port   =(unsigned short)htons(port);
           190 | 		socket = ::socket(AF_INET,SOCK_STREAM,0);
           191 | 	ü
           192 | 	else
           193 | 	ä
           194 | 		sockaddrUnix.sun_len = strlen(URL);
           195 | 		strcpy(sockaddrUnix.sun_path,URL);
           196 | 		socket = ::socket(AF_UNIX,SOCK_STREAM,0);
           197 | 		if (JOBENV::debug)
           198 | 			_dump(" sockAddrUnix",(char *)&sockaddrUnix,sizeof(sockaddrUnix));
           199 | 	ü
           200 | 	if (socket == ERROR_CODE )
           201 | 	ä
           202 | 		diag("socket");
           203 | 		return;
           204 | 	ü
           205 |
           206 | 	void * addrPointer = NULL;
           207 | 	size_t addrLength = 0;
           208 | 	if (port)
           209 | 	ä
           210 | 		addrPointer = &sockaddr;
           211 | 		addrLength = sizeof(sockaddr);
           212 | 	ü
           213 | 	else
           214 | 	ä
           215 | 		addrPointer = &sockaddrUnix;
           216 | 		addrLength = sizeof(sockaddrUnix);
           217 | 	ü
           218 |
           219 |
           220 | 	while(connect(socket,(struct sockaddr*)addrPointer,addrLength)== ERROR_CODE)
           221 | 	ä
           222 | 		if ( errno == EWOULDBLOCK )
           223 | 		ä
           224 | 			FD_SET(socket,&writeSockets);
           225 | 			if (select(socket+1,NULL,&writeSockets,NULL,&timeout) |=   1)
           226 | 			ä
           227 | 				diag("connect");
           228 | 				return;
           229 | 			ü
           230 | 		ü
           231 | 		else if ( errno == ECONNREFUSED)
           232 | 		ä
           233 | 			static startToSleep = 0;
           234 | 			if ( | startToSleep)
           235 | 			ä
           236 | 				startToSleep = 1;
           237 | 				printf(" Waiting for connection URL:%s port:%d for %d seconds Ön",URL,port,connwait);
           238 | 			ü
           239 | 			sleep(connwait);
           240 | 		ü
           241 | 		else
           242 | 		ä
           243 | 			diag("connect");
           244 | 			return;
           245 | 		ü
           246 | 	ü
           247 | 	connected = true;
           248 |
           249 | ü
           250 |
           251 | tcpipClient::ßtcpipClient()
           252 | ä
           253 | 	if (socket|=ERROR_CODE)
           254 | 		if (close(socket) == ERROR_CODE)
           255 | 			diag("close");
           256 | 	socket = ERROR_CODE;
           257 |
           258 | ü
           259 |
           260 | int tcpipClient::send(char * from,size_t len)
           261 | ä
           262 | 	char * off = from;
           263 | 	size_t snd = 0;
           264 | 	size_t l   = 0;
           265 | 	if (|connected)
           266 | 		return 0;
           267 | 	FD_SET(socket,&writeSockets);
           268 | 	while(select(socket+1,NULL,&writeSockets,NULL,&timeout) == 1 && len >0)
           269 | 	ä
           270 | 		if ( (l = ::send(socket,off,len,0)) > 0)
           271 | 		ä
           272 | 			snd += l;
           273 | 			off += l;
           274 | 			len -= l;
           275 | 		ü
           276 | 		else return(diag("send"));
           277 | 	ü
           278 | 	if (len > 0)
           279 | 		return(diag("select send"));
           280 | 	if (CmdService::debug)
           281 | 		printf(" tcpipClint send:%s",from);
           282 |
           283 | 	return snd;
           284 | ü
           285 |
           286 | int tcpipClient::receive(char * buf,size_t max)
           287 | ä
           288 | 	if (|connected)
           289 | 		return 0;
           290 | 	char * borig = buf;
           291 | 	size_t l			= max;
           292 | 	size_t rcv   = 0;
           293 | 	while(l&&max)
           294 | 	ä
           295 | 		FD_SET(socket,&readSockets);
           296 | 		if (select(socket+1,&readSockets,NULL,NULL,&timeout) == 1)
           297 | 		ä
           298 | 			if ( (l = ::recv(socket,buf,max,0)) >= 0)
           299 | 			ä
           300 | 				buf += l;
           301 | 				max -= l;
           302 | 				rcv += l;
           303 | 			ü
           304 | 			else
           305 | 				return(diag("recv"));
           306 | 		ü
           307 | 		else
           308 | 			return(diag("select receive"));
           309 | 	ü
           310 | 	if (CmdService::debug)
           311 | 	ä
           312 | 		printf(" tcpipClint receive:%s",borig);
           313 | 		dump(cgitrace,"Received tcpip client",borig,rcv);
           314 | 	ü
           315 | 	if (l==0)
           316 | 		rcv = -rcv;
           317 | 	return rcv;
           318 | ü
           319 |
           320 | int tcpipClient::diag(char * t)
           321 | ä
           322 | 	printf(" %s %d %sÖn",t,errno,strerror(errno));
           323 | 	return 0;
           324 | ü
           325 |
           326 | /*
           327 | int CmdService::printf(const char * format,...)
           328 | ä
           329 | char wÄPRINTBUFF_MAXÜ;
           330 | va_list arg_ptr;
           331 | va_start(arg_ptr,format);
           332 |
           333 | int l = vsprintf(w,format, arg_ptr);
           334 | if (print)
           335 | print->addBuff(w,l);
           336 | else
           337 | puts(w);
           338 | va_end(arg_ptr);
           339 | return l;
           340 | ü
           341 | */
           342 |
           343 | int CmdService::backFromRexx()
           344 | ä
           345 | 	char wÄ1024Ü;
           346 | 	sprintf(w,"%s.0",RESULT_STEM);
           347 | 	if (imax=atoi(rexx->fetch(w)))
           348 | 		for(int i=1;i<=imax;i++)
           349 | 		ä
           350 | 			sprintf(w,"%s.%d",RESULT_STEM,i);
           351 | 			char * c = rexx->fetch(w);
           352 | 			if (c)
           353 | 			ä
           354 | 				printf("%sÖn",c);
           355 | 			ü
           356 | 		ü
           357 | 		return imax;
           358 | ü
           359 |
           360 | TsoCmdService::TsoCmdService(reply p):CmdService("TsoCmdService",p)
           361 | ä
           362 | 	tsi = (IKJEFTSI *)fetch("IKJEFTSI");
           363 | 	tsr = (IKJEFTSR *)fetch("IKJEFTSR");
           364 | 	tst = (IKJEFTST *)fetch("IKJEFTST");
           365 | 	tso = (IKJTSOEV *)fetch("IKJTSOEV");
           366 |
           367 | 	memset(token,0,sizeof(token));
           368 | 	memset(cppl,0,sizeof(cppl));
           369 | 	flag=etc=resv=length=program_parm=cpplTso=0;
           370 | 	etc = -1;
           371 | 	if (rc = tso(&resv,&rc,&abend,&reason,&cpplTso))
           372 | 	ä
           373 | 		diag("IKJTSOEV");
           374 | 	ü
           375 | 	else
           376 | 	ä
           377 | 		if (rc = tsi(&etc,&resv,token,&rc,&abend,&reason))
           378 | 		ä
           379 | 			diag("IKJEFTSI");
           380 | 		ü
           381 | 		else
           382 | 			ok = 1;
           383 | 	ü
           384 | ü
           385 |
           386 | TsoCmdService::ßTsoCmdService()
           387 | ä
           388 | 	if (ok)
           389 | 		if (rc = tst(&etc,&resv,token,&rc,&abend,&reason))
           390 | 		ä
           391 | 			diag("IKJEFTSV");
           392 | 		ü
           393 | 		else
           394 | 			ok = 0;
           395 | ü
           396 |
           397 | int TsoCmdService::cmd(char *input)
           398 | ä
           399 | 	if (ok&&input)
           400 | 	ä
           401 | 		char wÄ32000Ü;
           402 | 		sprintf(w,"%s %d %s",REXXCMD,this,input);
           403 | 		flag = 1*256*256+debug*256+1;
           404 | 		length = strlen(w);
           405 | 		abend=reason = 0;
           406 | 		rc =  tsr(&flag,w,&length,&rc,&abend,&reason,&program_parm,cppl,token);
           407 | 		if (rc>0&&(abend]]reason))
           408 | 			diag(input);
           409 | 		printf(" %s cmd ended with %d, generated %d linesÖn",input,rc,imax);
           410 | 		return rc;
           411 | 	ü
           412 | 	else
           413 | 		return -1;
           414 | ü
           415 |
           416 | SdsfCmdService::SdsfCmdService(reply p):CmdService("SdsfCmdService",p)
           417 | ä
           418 | 	sdsf = (SDSF *)fetch("SDSF");
           419 | 	if (sdsf)
           420 | 		ok = 1;
           421 | ü
           422 |
           423 | SdsfCmdService::ßSdsfCmdService()
           424 | ä
           425 | ü
           426 |
           427 | int SdsfCmdService::cmd(char *)
           428 | ä
           429 | 	rc = -1;
           430 | 	if (ok)
           431 | 	ä
           432 | 		strcpy(arg.arg_v,"++250,180");
           433 | 		arg.arg_l = strlen(arg.arg_v);
           434 | 		void * argp		= (void *)&arg;
           435 | 		void * argpp  = (void *)(unsigned(argp)+unsigned(0x80000000));
           436 | 		rc = sdsf(argp);
           437 | 	ü
           438 | 	return rc;
           439 | ü
           440 |
           441 | UssCmdService::UssCmdService(reply p):CmdService("UssCmdService",p)
           442 | äü
           443 |
           444 | UssCmdService::ßUssCmdService()
           445 | ä
           446 | 	if (replyFile)
           447 | 		fclose(replyFile);
           448 | ü
           449 |
           450 | int UssCmdService::cmd(char *input)
           451 | ä
           452 | 	replyFile = popen(input,"r");
           453 | 	if (replyFile)
           454 | 	ä
           455 | 		imax = 0;
           456 | 		rc = 0;
           457 | 		while(fgets(buff,sizeof(buff),replyFile))
           458 | 		ä
           459 | 			imax++;
           460 | 			printf(" %sÖn",buff);
           461 | 		ü
           462 | 		fclose (replyFile);
           463 | 		printf(" %s cmd ended with %d, generated %d linesÖn",input,rc,imax);
           464 | 	ü
           465 | 	else
           466 | 	ä
           467 | 		rc = -1;
           468 | 		printf(" popen error %sÖn",strerror(errno));
           469 | 	ü
           470 | 	return rc;
           471 | ü
           472 |
           473 |
           474 | char * UssCmdService::next(char *input)
           475 | ä
           476 | 	if (input)
           477 | 		replyFile = popen(input,"rt");
           478 | 	if(replyFile)
           479 | 	ä
           480 | 		if (fgets(buff,sizeof(buff)-1,replyFile))
           481 | 			return buff;
           482 | 		else
           483 | 		ä
           484 | 			if (replyFile)
           485 | 				fclose(replyFile);
           486 | 			replyFile = NULL;
           487 | 			return NULL;
           488 | 		ü
           489 | 	ü
           490 | 	else
           491 | 		return NULL;
           492 | ü
           493 |
           494 | JesCmdService::JesCmdService(reply p):CmdService("JesCmdSErvice",p)
           495 | äü
           496 | JesCmdService::ßJesCmdService()
           497 | äü
           498 |
           499 | int JesCmdService::cmd(char * input)
           500 | ä
           501 | #ifndef SAPI_NO
           502 | 	mvsSTRING from(input);
           503 | 	from.strip();
           504 | 	char wÄ1024Ü;
           505 | 	FILE * iFile = fopen(genOpenName(from,w),"r");
           506 | 	/*
           507 | 	FILE * jesSpool = fopen(genOpenName(SPOOL,w),"w");
           508 | 	if (|jesSpool)
           509 | 	ä
           510 | 	printf(" open error for %s, %sÖn",SPOOL,strerror(errno));
           511 | 	return -1;
           512 | 	ü
           513 | 	*/
           514 | 	if (|iFile)
           515 | 	ä
           516 | 		printf(" open error for %s, %sÖn",input,strerror(errno));
           517 | 		return -1;
           518 | 	ü
           519 |
           520 |
           521 | 	JES * jes = _X_initJESI();
           522 | 	rc = _X_initINTR(jes);
           523 | 	pIOQE ioqe = pIOQE((char *)jes->jes_ioqe-8);
           524 |
           525 | 	if (rc)
           526 | 	ä
           527 | 		printf(" initINTR error, rc:%d SAPI message:'%s'Ön",rc,ioqe->ioqe_qsambuf+6);
           528 | 		return 8;
           529 | 	ü
           530 |
           531 | 	char   jobidÄ9Ü;
           532 | 	char * jobcard =	NULL;
           533 | 	char * jobname  = NULL;
           534 | 	while(fgets(buff,sizeof(buff),iFile))
           535 | 	ä
           536 | 		if (strchr(buff,'Ön'))
           537 | 			*strchr(buff,'Ön') = 0;
           538 | 		char * jcl = buff;
           539 | 		if (|jobcard)
           540 | 		ä
           541 | 			jobcard = strdup(jcl);
           542 | 			if (strchr(jobcard,' '))
           543 | 				*strchr(jobcard,' ') = 0;
           544 | 			jobname = jobcard +2;
           545 | 		ü
           546 | 		if (strlen(jcl)<80)
           547 | 			memset(jcl+strlen(jcl),' ',80-strlen(jcl));
           548 | 		jclÄ80Ü = 0;
           549 | 		rc = _X_nextINTR(jes,jcl);
           550 | 		if (rc)
           551 | 		ä
           552 | 			printf(" nextINTR error, rc:%dÖn",rc);
           553 | 			return 8;
           554 | 		ü
           555 | 	ü
           556 | 	fclose(iFile);
           557 | 	strcpy(jobid,_X_termINTR(jes));
           558 | 	jobidÄ8Ü  = 0;
           559 | 	//if (debug)
           560 | 	printf(" SUBMITTED %s(%s)Ön",jobname,jobid);
           561 |
           562 | 	char selectÄ1024Ü;
           563 | 	sprintf(select," SAPI JOBID(%s) ",jobid);
           564 | 	SAPI sapi;
           565 | 	//if (debug)
           566 | 	printf(" SAPI output selection:%sÖn",select);
           567 | 	void  * ECB = NULL;
           568 |
           569 | 	rc = _X_initSAPI(jes,select,strlen(select),&sapi,(void *)&ECB,"JES2",NULL);
           570 | 	rc = _X_nextSAPI(jes);
           571 |
           572 | 	while (rc==4)
           573 | 	ä
           574 | 		rc = _X_waitSAPI(jes);
           575 | 		rc = _X_nextSAPI(jes);
           576 | 	ü
           577 |
           578 | 	if (rc)
           579 | 	ä
           580 | 		ioqe = pIOQE((char *)jes->jes_ioqe-8);
           581 | 		printf(" SAPI rc : %d message:'%s'Ön",rc,ioqe->ioqe_qsambuf+6);
           582 | 		return 8;
           583 | 	ü
           584 |
           585 | 	while (rc==0)
           586 | 	ä
           587 | 		printf(" Job:%8.8s JobId:%8.8s Step:%8.8s DDname:%8.8s in SYSOUT class:%cÖn",
           588 | 			sapi.sss2->sss2jobr,sapi.sss2->sss2jbir,sapi.sss2->sss2stpd,sapi.sss2->sss2ddnd,sapi.sss2->sss2cl
           588 | ar);
           589 | 		printf(" Step:%8.8s DDname=%8.8sÖn",sapi.sss2->sss2stpd,sapi.sss2->sss2ddnd);
           590 | 		FILE * spool = fopen(sapi.ddname,"rb,type=record");
           591 |
           592 | 		if (spool)
           593 | 		ä
           594 |
           595 | 			size_t len=fread(buff,1,32768,spool);
           596 | 			while(len>0)
           597 | 			ä
           598 | 				printf(" %*.*sÖn",len,len,buff);
           599 | 				memset(buff,0,sizeof(buff));
           600 | 				len=fread(buff,1,sizeof(buff),spool);
           601 | 			ü
           602 | 			fclose(spool);
           603 | 		ü
           604 | 		else
           605 | 		ä
           606 | 			printf(" Unable to open %s spool fileÖn",sapi.ddname);
           607 | 			return 8;
           608 | 		ü
           609 | 		rc = _X_nextSAPI(jes);
           610 | 		if (rc>4)
           611 | 		ä
           612 | 			//if (*(int *)ioqe->ioqe_qsambuf)
           613 | 			printf(" SAPI error rc:%d message:'%s'Ön",rc,ioqe->ioqe_qsambuf+6);
           614 | 			return 8;
           615 | 		ü
           616 | 		else
           617 | 			if (rc==4)
           618 | 				break;
           619 | 	ü
           620 | 	/*
           621 | 	if (jesSpool)
           622 | 	fclose(jesSpool);
           623 | 	*/
           624 | 	_X_termSAPI(jes);
           625 | 	_X_cleanupJESI(jes);
           626 | 	//_exit(0);
           627 | #endif
           628 | 	return 0;
           629 | ü
           630 |
           631 | DsnCmdService::DsnCmdService(reply rep):CmdService("DsnCmdService",rep)
           632 | ä
           633 | 	csi = (IGGCSI00*)fetch("IGGCSI00");
           634 | 	if (csi==NULL)
           635 | 	ä
           636 | 		printf(" unable to load IGGCSI00Ön");
           637 | 		abort();
           638 | 	ü
           639 | 	asasymbm = (ASASYMBM*)fetch("ASASYMBM");
           640 | 	if (asasymbm==NULL)
           641 | 	ä
           642 | 		printf(" unable to load ASASYMBMÖn");
           643 | 		abort();
           644 | 	ü
           645 | 	memset(&symbp,0,sizeof(symbp));
           646 | 	cwork = (char *)malloc(CWORK_SIZE);
           647 | 	if (cwork==NULL)
           648 | 	ä
           649 | 		printf(" unable to allocate in %dÖn",CWORK_SIZE);
           650 | 		abort();
           651 | 	ü
           652 | 	memset((void *) &(retinfo_st), 0, sizeof(CSIRetInfo));
           653 | 	memset((void *) &(selfields_st), ' ', sizeof(CSISelFields));
           654 |
           655 | 	selfields_st.csicldi_c = 'Y';
           656 | 	selfields_st.csiresum_c = ' ';
           657 | 	selfields_st.csis1cat_c = 'Y';
           658 | 	selfields_st.csioptns_c = ' ';
           659 | 	memset(selfields_st.csicatnm_ac,' ',sizeof(selfields_st.csicatnm_ac));
           660 | 	selfields_st.csinumen_us	  = 3;
           661 | 	memcpy( selfields_st.csifldnm,"VOLSER  NAME    TYPE    ",24);
           662 | 	memset((void *) cwork, 0,CWORK_SIZE);
           663 | 	csirwork_pst = (CSIWorkData *) cwork;
           664 | 	csirwork_pst->csiusrln_ul = CWORK_SIZE;
           665 | 	p = NULL;
           666 | ü
           667 |
           668 | DsnCmdService::ßDsnCmdService()
           669 | ä
           670 | 	if (cwork)
           671 | 		free(cwork);
           672 | 	cwork = NULL;
           673 | ü
           674 |
           675 | int DsnCmdService::cmd(char * pattern,char * reply)
           676 | ä
           677 | 	int csiret_i = 0;
           678 | 	int i,j;
           679 |
           680 | 	if (pattern)
           681 | 		memcpy( selfields_st.csifiltk_ac,pattern, strlen(pattern));
           682 |
           683 | 	//printf(" CSIEntryData %46.46s Ön",p);
           684 | 	char keyÄ51Ü;
           685 | 	unsigned char  assoctype;
           686 | 	char assocnameÄ44Ü;
           687 | 	char volserÄ6Ü;
           688 | 	if (CmdService::debug)
           689 | 		_dump(" Dsn pattern",pattern,strlen(pattern));
           690 | 	do
           691 | 	ä
           692 | 		if (p==NULL]]
           693 | 			(((unsigned long)((char *)p-cwork)>=csirwork_pst->csiusdln_ul)&&selfields_st.csiresum_c == 'Y'))
           694 | 		ä
           695 | 			csiret_i = csi((void *)&retinfo_st,(void *)&selfields_st,(void *)cwork);
           696 | 			if (csiret_i==0)
           697 | 			ä
           698 | 				if (short(*(short *)(cwork+CSINUMFD))==0)
           699 | 				ä
           700 | 					return 0;
           701 | 				ü
           702 | 				p = (CSIEntryData *)(cwork+sizeof(CSIWorkData));
           703 | 			ü
           704 | 			else
           705 | 			ä
           706 | 				printf(" Catalog search error, for %s Ön    rc: %d reason code %8xÖn"
           707 | 					,pattern,csiret_i,retinfo_st);
           708 | 				return 0;
           709 | 			ü
           710 | 		ü
           711 | 		if	((unsigned long)((char *)p-cwork)>=csirwork_pst->csiusdln_ul)
           712 | 			return 0;
           713 | 		char  *f = (char *)p+sizeof(CSIEntryData);
           714 | 		memset(key,' ',50);
           715 | 		keyÄ50Ü = 0;
           716 | 		assoctype = ' ';
           717 | 		memset(assocname,' ',44);
           718 | 		memset(volser,' ',6);
           719 | 		if (p->csietype-'0')
           720 | 		ä
           721 | 			if (p->_union._csiel.csielvol)
           722 | 			ä
           723 | 				memcpy(volser,f,6);
           724 | 				f +=p->_union._csiel.csielvol;
           725 | 			ü
           726 | 			if (p->_union._csiel.csielnam)
           727 | 			ä
           728 | 				memcpy(assocname,f,44);
           729 | 				f +=p->_union._csiel.csielnam;
           730 | 			ü
           731 | 			if (p->_union._csiel.csieltyp)
           732 | 			ä
           733 | 				assoctype = *f;
           734 | 				f +=p->_union._csiel.csieltyp;
           735 | 			ü
           736 | 		ü
           737 | 		else
           738 | 			f -=6; //if it is a catalog record
           739 |
           740 | 		if (volserÄ0Ü == '&')
           741 | 		ä
           742 | 			void * pointer = &symbp;
           743 | 			char rvolserÄ6Ü;
           744 | 			int rvolser_length = 6;
           745 | 			int symbp_return = 0;
           746 | 			char timestampÄ32Ü;
           747 | 			symbp.symbppatternaddr = (void *)volser;
           748 | 			symbp.symbppatternlength = 6;
           749 | 			symbp.symbptargetaddr        = (void *)rvolser;
           750 | 			symbp.symbptargetlengthaddr  = &rvolser_length;
           751 | 			symbp.symbpreturncodeaddr    = &symbp_return;
           752 | 			symbp.symbptimestampaddr = timestamp;
           753 | 			symbp.symbpsymboltableaddr = NULL;
           754 | 			symbp_return = asasymbm(volser,6,rvolser,&rvolser_length,NULL,timestamp,&symbp_return);
           755 | 			if (symbp_return == 0)
           756 | 				memcpy(&volser,&rvolser,6);
           757 | 			else
           758 | 				printf(" ASASYMBP return code:%dÖn",symbp_return);
           759 | 		ü
           760 | 		switch(p->csietype)
           761 | 		ä
           762 | 		case '0':
           763 | 			break;
           764 | 		case 'A':
           765 | 		case 'C':
           766 | 		case 'G':
           767 | 		case 'I':
           768 | 		case 'R':
           769 | 		case 'D':
           770 |
           771 | 			memcpy(key,p->csiename,44);
           772 | 			if (keyÄ0Ü==0)
           773 | 				memset(key,'0',44);
           774 | 			memcpy(key+44,volser,6);
           775 | 			keyÄ50Ü = 0;
           776 | 			if (reply==NULL)
           777 | 				printf(" %s %s %cÖn",key,volser,p->csietype);
           778 | 			else
           779 | 			ä
           780 | 				replyÄ0Ü=p->csietype;
           781 | 				memcpy(reply+1,key,50);
           782 | 				p = (CSIEntryData *)f;
           783 | 				return 1;
           784 | 			ü
           785 | 			break;
           786 | 		default:
           787 | 			break;
           788 | 		ü
           789 | 		p = (CSIEntryData *)f;
           790 | 	ü  while ((char *)p<(cwork+csirwork_pst->csiusdln_ul));
           791 | 	return 1;
           792 | ü
           793 |
           794 | void CmdService::diag(const char * cmd)
           795 | ä
           796 | 	printf(" Error in %s, command:%s rc:%d abend:%d reason:%dÖn",
           797 | 		service,cmd,rc,abend,reason);
           798 | ü
           799 | static const char * MXI_TABLE_HEAD	= "<table border='1' ='blue' bordercolor='black' class=sortable>"
           799 | ;
           800 | static const char * MXI_TABLE_TRAIL = "</table>";
           801 | static char * refMxiÄ64Ü;
           802 | static int    initRefMxi()
           803 | ä
           804 | #define mxiattr(v,name,link) static const int name = v;Ö
           805 | 	refMxiÄvÜ = link;
           806 | 	mxiattr(0x01,input_pas_dataset,NULL)
           807 | 		mxiattr(0x02,output_attr_text,NULL)
           808 | 		mxiattr(0x03,output_attr_exception,NULL)
           809 | 		mxiattr(0x04,output_attr_warning,NULL)
           810 | 		mxiattr(0x05,field_labels,NULL)
           811 | 		mxiattr(0x06,outputattr_field_normal,NULL)
           812 | 		mxiattr(0x07,outputattr_field_inactive,NULL)
           813 | 		mxiattr(0x08,field_column_headings,NULL)
           814 | 		mxiattr(0x09,outputattr_field_high,NULL)
           815 | 		/*
           816 | 		mxiattr(0x0a,reserved)
           817 | 		mxiattr(0x0b,reserved)
           818 | 		mxiattr(0x0c,reserved)
           819 | 		*/
           820 | 		mxiattr(0x0d,refdslist,"REFDSLIST %s")
           821 | 		mxiattr(0x0e,refdslist_volser,"<a href='vol.sh?%s'>%s</a>")
           822 | 		mxiattr(0x10,refdasd_volser,"<a href='vol.sh?%s'>%s</a>")
           823 | 		mxiattr(0x11,refdataset_name,"<a href='dataset.sh?DATASET=%s'>%s</a>")
           824 | 		mxiattr(0x12,refsvc,"<a href='mxicmd.sh?SVC %s'>%s</a>")
           825 | 		mxiattr(0x13,refaddress_mem,"<a href='mxicmd.sh?MEM %s'>%s</a>")
           826 | 		mxiattr(0x14,refsubsystem_name,"")
           827 | 		mxiattr(0x15,reftape_unit,"")
           828 | 		mxiattr(0x16,refdasd_unit,"")
           829 | 		mxiattr(0x17,refunit_name,"")
           830 | 		mxiattr(0x18,refxcf_structure,"<a href='mxicmd.sh?XCF %s'>%s</a>")
           831 | 		mxiattr(0x19,refsp,"<a href='mxicmd.sh?SP %s'>%s</a>")
           832 | 		mxiattr(0x1a,refagrp,"<a href='mxicmd.sh?AGRP %s'>%s</a>")
           833 | 		mxiattr(0x1b,refsrvc,"<a href='mxicmd.sh?SRVC %s'>%s</a>")
           834 | 		mxiattr(0x1c,refrcls,"<a href='mxicmd.sh?RCLS %s'>%s</a>")
           835 | 		mxiattr(0x1d,refrl,"<a href='mxicmd.sh?RL %s'>%s</a>")
           836 | 		mxiattr(0x1e,refemcs,"<a href='mxicmd.sh?EMCS %s'>%s</a>")
           837 | 		mxiattr(0x1f,refmcs,"<a href='mxicmd.sh?MCS %s'>%s</a>")
           838 | 		mxiattr(0x21,refsgrp,"<a href='mxicmd.sh?SGRP %s'>%s</a>")
           839 | 		mxiattr(0x22,refdae,"<a href='mxicmd.sh?DAE %s'>%s</a>")
           840 | 		mxiattr(0x23,refcf,"<a href='mxicmd.sh?RL %s'>%s</a>")
           841 | 		mxiattr(0x24,refscls,"<a href='mxicmd.sh?SCLS %s'>%s</a>")
           842 | 		mxiattr(0x25,refmcls,"<a href='mxicmd.sh?CF %s'>%s</a>")
           843 | 		mxiattr(0x26,refmxi_command,"")
           844 | 		mxiattr(0x27,refdcls,"<a href='mxicmd.sh?DCLS %s'>%s</a>")
           845 | 		mxiattr(0x28,reflls,"<a href='mxicmd.sh?LLS %s'>%s</a>")
           846 | 		mxiattr(0x29,refjobname_da,"<a href='mxicmd.sh?DA %s'>%s</a>")
           847 | 		mxiattr(0x2a,reflx,"<a href='mxicmd.sh?LX %s'>%s</a>")
           848 | 		mxiattr(0x2b,refwlmg,"<a href='mxicmd.sh?WLMG %s'>%s</a>")
           849 | 		mxiattr(0x2c,refuserid_rl,"<a href='mxicmd.sh?RL %s'>%s</a>")
           850 | 		mxiattr(0x2d,refhfs,"<a href='mxicmd.sh?HFS %s'>%s</a>")
           851 | 		mxiattr(0x2e,refpid,"<a href='mxicmd.sh?PID %s'>%s</a>")
           852 | 		mxiattr(0x2f,refwlma,"<a href='mxicmd.sh?WLMA %s'>%s</a>")
           853 | 		mxiattr(0x30,refasid,"<a href='mxicmd.sh?DA A=%s'>%s</a>")
           854 | 		mxiattr(0x31,refwlms,"<a href='mxicmd.sh?WLMS %s'>%s</a>")
           855 | 		mxiattr(0x32,reflla,"<a href='mxicmd.sh?LLA %s'>%s</a>")
           856 | 		mxiattr(0x33,refrsys,"<a href='mxicmd.sh?RSYS %s'>%s</a>")
           857 | 		mxiattr(0x34,refenc,"<a href='mxicmd.sh?ENC %s'>%s</a>")
           858 | 		mxiattr(0x35,reflogr,"<a href='mxicmd.sh?LOGR %s'>%s</a>")
           859 | 		mxiattr(0x36,refcon,"")
           860 | 		mxiattr(0x37,refmqq,"")
           861 | 		mxiattr(0x38,refmq,"")
           862 | 		mxiattr(0x39,refmqc,"")
           863 | 		mxiattr(0x3a,refmqcs,"")
           864 | 		mxiattr(0x3b,refdb,"")
           865 | 		mxiattr(0x3c,refdbda,"")
           866 | 		mxiattr(0x3d,refdbbp,"")
           867 | 		mxiattr(0x3e,refcommand_group,"")
           868 | 		mxiattr(0x20,found_string,"")
           869 | 		return 0;
           870 | ü
           871 | static int    _initRefMxi = initRefMxi();
           872 |
           873 | /*
           874 | MXPS3PT4  EQU  X'0D'             Point-and-shoot DSLIST
           875 | MXPSVTOC  EQU  X'0E'             Point-and-shoot DSLIST Volser
           876 | MXPSVOL   EQU  X'10'             point-and-shoot DASD Volser
           877 | MXPSDSN   EQU  X'11'             point-and-shoot Dataset name
           878 | MXPSSVC   EQU  X'12'             point-and-shoot SVC
           879 | MXPSADDR  EQU  X'13'             point-and-shoot Address (MEM)
           880 | MXPSSSI   EQU  X'14'             point-and-shoot Subsystem name
           881 | MXPSTUNT  EQU  X'15'             point-and-shoot TAPE Unit
           882 | MXPSDUNT  EQU  X'16'             point-and-shoot DASD unit
           883 | MXPSUNTN  EQU  X'17'             point-and-shoot UNIT name
           884 | MXPSXCFS  EQU  X'18'             point-and-shoot XCF structure
           885 | MXPSSP    EQU  X'19'             point-and-shoot SP
           886 | MXPSAGRP  EQU  X'1A'             Point-and-shoot AGRP
           887 | MXPSSRVC  EQU  X'1B'             Point-and-shoot SRVC
           888 | MXPSRCLS  EQU  X'1C'             Point-and-shoot RCLS
           889 | MXPSRL    EQU  X'1D'             Point-and-shoot RL
           890 | MXPSEMCS  EQU  X'1E'             Point-and-shoot EMCS
           891 | MXPSMCS   EQU  X'1F'             Point-and-shoot MCS
           892 | MXPSSGRP  EQU  X'21'             point-and-shoot SGRP
           893 | MXPSDAE   EQU  X'22'             point-and-shoot DAE
           894 | MXPSCF    EQU  X'23'             point-and-shoot CF
           895 | MXPSSCLS  EQU  X'24'             point-and-shoot SCLS
           896 | MXPSMCLS  EQU  X'25'             point-and-shoot MCLS
           897 | MXPSCMD   EQU  X'26'             point-and-shoot MXI Command
           898 | MXPSDCLS  EQU  X'27'             point-and-shoot DCLS
           899 | MXPSLLS   EQU  X'28'             point-and-shoot LLS
           900 | MXPSJOBN  EQU  X'29'             point-and-shoot Jobname (DA)
           901 | MXPSLX    EQU  X'2A'             point-and-shoot LX
           902 | MXPSWLMG  EQU  X'2B'             point-and-shoot WLMG
           903 | MXPSUSER  EQU  X'2C'             point-and-shoot USERID (RL)
           904 | MXPSHFS   EQU  X'2D'             point-and-shoot HFS
           905 | MXPSPID   EQU  X'2E'             point-and-shoot PID
           906 | MXPSWLMA  EQU  X'2F'             point-and-shoot WLMA
           907 | MXPSASID  EQU  X'30'             point-and-shoot ASID
           908 | MXPSWLMS  EQU  X'31'             point-and-shoot WLMS
           909 | MXPSLLA   EQU  X'32'             point-and-shoot LLA
           910 | MXPSRSYS  EQU  X'33'             point-and-shoot RSYS
           911 | MXPSENC   EQU  X'34'             point-and-shoot ENC
           912 | MXPSLOGR  EQU  X'35'             point-and-shoot LOGR
           913 | MXPSCON   EQU  X'36'             point-and-shoot CON
           914 | MXPSMQQ   EQU  X'37'             point-and-shoot MQQ
           915 | MXPSMQ    EQU  X'38'             point-and-shoot MQ
           916 | MXPSMQC   EQU  X'39'             point-and-shoot MQC
           917 | MXPSMQCS  EQU  X'3A'             point-and-shoot MQCS
           918 | MXPSDB    EQU  X'3B'             point-and-shoot DB
           919 | MXPSDBDA  EQU  X'3C'             point-and-shoot DBDA
           920 | MXPSDBBP  EQU  X'3D'             point-and-shoot DBBP
           921 | MXPSCGRP  EQU  X'3E'             point-and-shoot Command Group
           922 | */
           923 |
           924 |
           925 | MxServerCmdService::MxServerCmdService(reply p):CmdService("MxServerCmdService",p),tcpipClient(MX_PO
           925 | RT)
           926 | ä
           927 | 	if (socket>=0)
           928 | 		ok = 1;
           929 | ü
           930 |
           931 | MxServerCmdService::ßMxServerCmdService()
           932 | äü
           933 |
           934 | char * nextResult(char * &p)
           935 | ä
           936 | 	static char wÄ512Ü;
           937 | 	if (*p >= ' ' ]]*p==0)
           938 | 		return NULL;
           939 | 	char * text = refMxiÄint(*p)Ü;
           940 | 	int i =1;
           941 | 	for(;i<80&&pÄiÜ>=' ';i++);
           942 | 	char control = pÄiÜ;
           943 | 	pÄiÜ = 0;
           944 | 	if (text&&strlen(text))
           945 | 		sprintf(w,text,p+1,p+1);
           946 | 	else
           947 | 		strcpy(w,p+1);
           948 | 	pÄiÜ = control;
           949 | 	p+=i;
           950 | 	bool empty = true;
           951 | 	for (i=0;i<strlen(w)&&empty;i++)
           952 | 		empty&=(wÄiÜ==' ');
           953 | 	if (empty)
           954 | 		strcpy(w,"&nbsp;");
           955 | 	return w;
           956 | ü
           957 |
           958 | int MxServerCmdService::cmd(char * command)
           959 | ä
           960 | 	keyvalue ** kv = NULL;
           961 | 	char * title   = NULL;
           962 | 	if (ok&&command&&(kv=parse(command)))
           963 | 	ä
           964 | 		mxireq r;
           965 | 		memset(&r,' ',sizeof(r));
           966 | 		memcpy(r.mxireq_operating_sys,"MVS",3);
           967 | 		for(int i =0;kvÄiÜ;i++)
           968 | 		ä
           969 | 			char * from = *(kvÄiÜ->value);
           970 | 			if (strcasecmp(*(kvÄiÜ->key),MX_COMMAND)==0)
           971 | 			ä
           972 | 				title = from;
           973 | 				size_t l = strlen(from)<sizeof(r.mxireq_command)?strlen(from):sizeof(r.mxireq_command);
           974 | 				r.mxireq_command_length = (unsigned char)l;
           975 | 				memcpy(r.mxireq_command,from,l);
           976 | 			ü
           977 | 			if (strcasecmp(*(kvÄiÜ->key),MX_USERID)==0)
           978 | 			ä
           979 | 				size_t l = strlen(from)<sizeof(r.mxireq_userid)?strlen(from):sizeof(r.mxireq_userid);
           980 | 				r.mxireq_userid_length = (unsigned char)l;
           981 | 				memcpy(r.mxireq_userid,from,l);
           982 | 			ü
           983 | 			if (strcasecmp(*(kvÄiÜ->key),MX_GROUPID)==0)
           984 | 			ä
           985 | 				size_t l = strlen(from)<sizeof(r.mxireq_group_name)?strlen(from):sizeof(r.mxireq_group_name);
           986 | 				r.mxireq_group_length = (unsigned char)l;
           987 | 				memcpy(r.mxireq_group_name,from,l);
           988 | 			ü
           989 | 			if (strcasecmp(*(kvÄiÜ->key),MX_MQS)==0)
           990 | 			ä
           991 | 				size_t l = strlen(from)<sizeof(r.mxireq_mqs_ssid)?strlen(from):sizeof(r.mxireq_mqs_ssid);
           992 | 				memcpy(r.mxireq_mqs_ssid,from,l);
           993 | 			ü
           994 | 			if (strcasecmp(*(kvÄiÜ->key),MX_DB2)==0)
           995 | 			ä
           996 | 				size_t l = strlen(from)<sizeof(r.mxireq_db2_ssid)?strlen(from):sizeof(r.mxireq_db2_ssid);
           997 | 				memcpy(r.mxireq_db2_ssid,from,l);
           998 | 			ü
           999 | 		ü
          1000 | 		if (send((char *)&r,sizeof(r)))
          1001 | 		ä
          1002 | 			mxis m;
          1003 | 			char * msg = (char *)&m;
          1004 | 			if (receive((char *)&m,sizeof(m))|=sizeof(m))
          1005 | 			ä
          1006 | 				printf(" MX message %24.24s (%70.70s)ÖnÖnÖn",(char *)msg+4,msg+28);
          1007 | 				return 0;
          1008 | 			ü
          1009 | 			else
          1010 | 			ä
          1011 | 				bool table = (m.mxissnum&&(memcmp(m.mxispanm,"MXIPANEL",8)==0));
          1012 | 				mxdt t;
          1013 | 				if (receive((char *)&t,sizeof(t)-1)==0)
          1014 | 				ä
          1015 | 					printf(" MX message errorÖn");
          1016 | 					return 0;
          1017 | 				ü
          1018 | 				else
          1019 | 				ä
          1020 | 					if (CmdService::debug)
          1021 | 						dump(cgitrace,"Received mxis:",&m,sizeof(m));
          1022 | 					/*
          1023 | 					printf("<title>%s</title><meta http-equiv=Ö"pragmaÖ" content=Ö"no-cacheÖ"><body BGCOLOR=Ö"#0000
          1023 | 00Ö" TEXT=Ö"#00FFFFÖ"><pre>Ön",title);
          1024 | 					printf("%80.80sÖn%80.80sÖn%80.80sÖn",t.mxdtttl,t.mxdtlb2,t.mxdtlb3);
          1025 | 					*/
          1026 | 					size_t resultLen = t.mxdtsiz+1-sizeof(t);
          1027 | 					char * result = new charÄresultLen+1Ü;
          1028 | 					memset(result,0,resultLen+1);
          1029 | 					if ((receive(result,resultLen))==0)
          1030 | 					ä
          1031 | 						printf(" MX result errorÖn");
          1032 | 						return 0;
          1033 | 					ü
          1034 | 					else
          1035 | 					ä
          1036 | 						int colspan = 0;
          1037 | 						if (CmdService::debug)
          1038 | 							dump(cgitrace,"Received result:",result,resultLen);
          1039 | 						if (table)
          1040 | 						ä
          1041 | 							printf("%sÖn",MXI_TABLE_HEAD);
          1042 | 							printf("<tr>Ön");
          1043 | 							for(int i =1;i<=m.mxissnum;i++)
          1044 | 								printf("<th align=left>%8.8s</th>Ön",m.mxissf1+(i-1)*16+1);
          1045 | 							printf("</tr>Ön");
          1046 | 						ü
          1047 | 						else
          1048 | 						ä
          1049 | 							printf("%sÖn",MXI_TABLE_HEAD);
          1050 | 							for(int i=0,j=1;i<resultLen&&j<=t.mxdtnum;i+=80,j++)
          1051 | 							ä
          1052 | 								char wÄ81Ü;
          1053 | 								memcpy(w,result+i,80);
          1054 | 								wÄ80Ü =0;
          1055 | 								int cs = 0;
          1056 | 								for(int k =0;k<80;k++)
          1057 | 									if (wÄkÜ<' '&&wÄkÜ)
          1058 | 										cs++;
          1059 | 								if (cs>colspan)
          1060 | 									colspan = cs;
          1061 | 							ü
          1062 | 						ü
          1063 | 						for(int i=0,j=1;i<resultLen&&j<=t.mxdtnum;i+=80,j++)
          1064 | 						ä
          1065 | 							if (table]]1)
          1066 | 								if (j%2 == 1)
          1067 | 									printf("<tr class='odd'>Ön");
          1068 | 								else
          1069 | 									printf("<tr>Ön");
          1070 | 							else
          1071 | 								printf("<p>");
          1072 | 							char wÄ81Ü;
          1073 | 							memcpy(w,result+i,80);
          1074 | 							wÄ80Ü =0;
          1075 | 							char * next = w;
          1076 | 							char * print = NULL ;
          1077 | 							//if (*next==0)
          1078 | 							//	break;
          1079 | 							bool first = true;
          1080 | 							int col = 0;
          1081 | 							while(print = nextResult(next))
          1082 | 							ä
          1083 | 								col++;
          1084 | 								bool lastcol = true;
          1085 | 								for(int k=0;nextÄkÜ;k++)
          1086 | 									if (nextÄkÜ<' ')
          1087 | 										lastcol = false;
          1088 | 								if (table]]1)
          1089 | 								ä
          1090 | 									if (colspan&&lastcol)
          1091 | 										printf("<td colspan='%d'>",colspan-col+1);
          1092 | 									else
          1093 | 										printf("<td>");
          1094 | 									first = false;
          1095 | 								ü
          1096 | 								printf("%s",print);
          1097 | 								if (table]]1)
          1098 | 									printf("</td>");
          1099 | 							ü;
          1100 | 							if (table]]1)
          1101 | 								printf("</tr>Ön");
          1102 | 						ü
          1103 | 						if (table]]1)
          1104 | 							printf("%sÖn",MXI_TABLE_TRAIL);
          1105 | 					ü
          1106 | 					if (result)
          1107 | 						delete result;
          1108 | 				ü
          1109 | 			ü
          1110 | 		ü
          1111 | 	ü
          1112 | 	return 0;
          1113 | ü
          1114 |
          1115 |
          1116 |
          1117 | RexxServerCmdService::RexxServerCmdService(reply p):CmdService("RexxServerCmdService",p),tcpipClient
          1117 | (REXXSERVER_PORT)
          1118 | ä
          1119 | 	if (socket>=0)
          1120 | 		ok = 1;
          1121 | ü
          1122 |
          1123 | RexxServerCmdService::ßRexxServerCmdService()
          1124 | äü
          1125 |
          1126 | int RexxServerCmdService::cmd(char * command)
          1127 | ä
          1128 | 	keyvalue ** kv = NULL;
          1129 | 	if (ok&&command&&(kv=parse(command)))
          1130 | 	ä
          1131 | 		REXXSERVER_REQUEST r;
          1132 | 		memset(&r,' ',sizeof(r));
          1133 | 		for(int i =0;kvÄiÜ;i++)
          1134 | 		ä
          1135 | 			char * from = *(kvÄiÜ->value);
          1136 | 			int    l    = strlen(from);
          1137 | 			if (strcasecmp(*(kvÄiÜ->key),REXXSERVER_COMMAND)==0)
          1138 | 			ä
          1139 | 				l = l<sizeof(r.command)?l:sizeof(r.command);
          1140 | 				memcpy(r.command,from,l);
          1141 | 			ü
          1142 | 			else	if (strcasecmp(*(kvÄiÜ->key),REXXSERVER_TYPE)==0)
          1143 | 			ä
          1144 | 				l = l<sizeof(r.type)?l:sizeof(r.type);
          1145 | 				memcpy(r.type,from,l);
          1146 | 			ü
          1147 | 			else if (strcasecmp(*(kvÄiÜ->key),REXXSERVER_REPLYID)==0)
          1148 | 			ä
          1149 | 				l = l<sizeof(r.replyid)?l:sizeof(r.replyid);
          1150 | 				memcpy(r.replyid,from,l);
          1151 | 			ü
          1152 | 		ü
          1153 | 		if (send((char *)&r,sizeof(r)))
          1154 | 		ä
          1155 | 			char bÄ32000Ü;
          1156 | 			int rc = 0;
          1157 | 			if ((rc=receive((char *)b,sizeof(b))-1)==0)
          1158 | 			ä
          1159 | 				printf(" REXXSERVER error, nothing receivedÖn");
          1160 | 				return 0;
          1161 | 			ü
          1162 | 			else
          1163 | 				while(rc)
          1164 | 				ä
          1165 | 					if (rc<0)
          1166 | 						rc=-rc;
          1167 | 					int bc=0;
          1168 | 					for(int i =0;i<rc;i++)
          1169 | 						if (bÄiÜ < ' ' && bÄiÜ-'Ön')
          1170 | 						ä
          1171 | 							bÄiÜ = ' ';
          1172 | 							bc++;
          1173 | 						ü
          1174 | 						if (CmdService::debug)
          1175 | 						ä
          1176 | 							printf(" REXXSERVER:%s",b);
          1177 | 							dump(cgitrace,"Received",b,rc);
          1178 | 						ü
          1179 |
          1180 |
          1181 | 						bÄrcÜ=0;
          1182 | 						//if (bc<rc)
          1183 | 						printf(" %s",b);
          1184 | 						rc=receive((char *)b,sizeof(b)-1);
          1185 | 				ü
          1186 | 		ü
          1187 | 	ü
          1188 | 	return 0;
          1189 | ü
          1190 |
          1191 | /*
          1192 | OperCmdService::OperCmdService(reply p):CmdService("OperCmdService",p)
          1193 | äü
          1194 | OperCmdService::ßOperCmdService()
          1195 | äü
          1196 | int OperCmdService::cmd(char *c)
          1197 | ä
          1198 | printf(" Oper command %sÖn",c);
          1199 | return 0;
          1200 | ü
          1201 | */
          1202 |
          1203 |
          1204 | OperCmdService::OperCmdService(reply p):CmdService("OperCmdService",p),tcpipClient(REXXSERVER_PORT)
          1205 | ä
          1206 | 	if (socket>=0)
          1207 | 		ok = 1;
          1208 | ü
          1209 |
          1210 | OperCmdService::ßOperCmdService()
          1211 | äü
          1212 |
          1213 | int OperCmdService::cmd(char * command)
          1214 | ä
          1215 | 	keyvalue ** kv = NULL;
          1216 | 	if (ok&&command&&(kv=parse(command)))
          1217 | 	ä
          1218 | 		REXXSERVER_REQUEST r;
          1219 | 		memset(&r,' ',sizeof(r));
          1220 | 		memcpy(r.command,command,strlen(command));
          1221 | 		memcpy(r.type,WD4Z,strlen(WD4Z));
          1222 | 		if (send((char *)&r,sizeof(r)))
          1223 | 		ä
          1224 | 			char bÄ32000Ü;
          1225 | 			int rc = 0;
          1226 | 			if ((rc=receive((char *)b,sizeof(b))-1)==0)
          1227 | 			ä
          1228 | 				printf(" REXXSERVER error, nothing receivedÖn");
          1229 | 				return 0;
          1230 | 			ü
          1231 | 			else
          1232 | 				while(rc)
          1233 | 				ä
          1234 | 					if (rc<0)
          1235 | 						rc=-rc;
          1236 | 					int bc=0;
          1237 | 					/*
          1238 | 					for(int i =0;i<rc;i++)
          1239 | 					if (bÄiÜ==0x25)
          1240 | 					bÄiÜ = 'Ön';
          1241 | 					*/
          1242 | 					if (CmdService::debug)
          1243 | 					ä
          1244 | 						printf(" REXXSERVER:%s",b);
          1245 | 						dump(cgitrace,"Received",b,rc);
          1246 | 					ü
          1247 |
          1248 |
          1249 | 					bÄrcÜ=0;
          1250 | 					//if (bc<rc)
          1251 | 					printf(" %s",b);
          1252 | 					rc=receive((char *)b,sizeof(b)-1);
          1253 | 				ü
          1254 | 		ü
          1255 | 	ü
          1256 | 	return 0;
          1257 | ü
          1258 |
          1259 | //int main(int argc,char * argvÄÜ)??????????????????
          1260 | int mainX(int argc,char * argvÄÜ)
          1261 |
          1262 | ä
          1263 | 	mvsSTRING::parseSepCh='Ö''; //szm20061218 mvsSTRING parse escape ch set here to apostrophe , all ot
          1263 | her cases null|||||||
          1264 | 	//FILE * reopen_stdout = freopen("//dd:sysprint","w,recfm=VB,lrecl=32756,blksize=32760",stdout);
          1265 |
          1266 | 	TsoCmdService *				tso =  NULL;
          1267 | 	UssCmdService	*				unix = NULL;
          1268 | 	JesCmdService *   		jes  = NULL;
          1269 | 	DsnCmdService *  			dsn  = NULL;
          1270 | 	OperCmdService *			oper = NULL;
          1271 | 	SdsfCmdService *			sdsf = NULL;
          1272 | 	MxServerCmdService *  mx  = NULL;
          1273 | 	RexxServerCmdService *rs  = NULL;
          1274 |
          1275 | 	const static char *version=ISIS_VERSION;
          1276 | 	const static char *compileDate=ISIS_VERSION_DATE;
          1277 | #if 0
          1278 | 	void * * R1 = __osplist;
          1279 | 	char * argvÄ2Ü = ä "MVSSERVS",NULLü;
          1280 | 	int    argc    = 2;
          1281 | 	char _bÄ32700Ü;
          1282 | 	int l			= *(int *)*(R1+1);
          1283 | 	char * c  = *(char **)*R1;
          1284 | 	memcpy(_b,c,l);
          1285 | 	_bÄlÜ = 0;
          1286 | 	argvÄ1Ü = _b;
          1287 | #endif
          1288 | 	if (CmdService::debug)
          1289 | 		printf(" %s tester %s %s Version:%s Compiled:%sÖn",argvÄ0Ü,ISIS_PF_SID,ISIS_PF_NAME,version,compil
          1289 | eDate);
          1290 | 	if (strcasecmp(argvÄ0Ü,CALLBACK_PROGRAM)==0)
          1291 | 	ä
          1292 | 		CmdService * cmd = (CmdService *)(atoi(argvÄ1Ü));
          1293 | 		if (cmd)
          1294 | 		ä
          1295 | 			cmd->backFromRexx();
          1296 | 		ü
          1297 | 		else
          1298 | 			printf(" Callbak address zeroÖn");
          1299 | 	ü
          1300 | 	else
          1301 | 	ä
          1302 | 		mvsSTRING b;
          1303 | 		char buffÄ32700Ü;
          1304 | 		buffÄ0Ü = 0;
          1305 | 		if (argc>1)
          1306 | 		ä
          1307 | 			if (CmdService::debug)
          1308 | 				printf(" argc:%dÖn",argc);
          1309 | 			for (int i =1;i<=argc;i++)
          1310 | 			ä
          1311 | 				if (CmdService::debug)
          1312 | 					printf("argvÄ%dÜ:%sÖn",i,argvÄiÜ);
          1313 | 				strcpy(buff+strlen(buff),argvÄiÜ);
          1314 | 				strcat(buff," ");
          1315 |
          1316 | 			ü
          1317 |
          1318 | 			if (strchr(buff,'Ön'))
          1319 | 				*strchr(buff,'Ön') = 0;
          1320 | 			for(int i=0;i<strlen(buff);i++)
          1321 | 			ä
          1322 | 				if (buffÄiÜ=='+')
          1323 | 					buffÄiÜ = ' ';
          1324 | 				else
          1325 | 					if (buffÄiÜ=='-')
          1326 | 						buffÄiÜ = '+';
          1327 | 					else
          1328 | 						if (buffÄiÜ=='_')
          1329 | 							buffÄiÜ = '%';
          1330 |
          1331 | 			ü
          1332 | 			b =buff+1;
          1333 | 			if (CmdService::debug)
          1334 | 				printf(">>%sÖn",buff);
          1335 | 			b.strip();
          1336 | 		ü
          1337 | 		else
          1338 | 			buffÄ0Ü = 'S';
          1339 |
          1340 | 		switch (buffÄ0Ü)
          1341 | 		ä
          1342 | 		case 'r':
          1343 | 		case 'R':
          1344 | 		case 't':
          1345 | 		case 'T':
          1346 | 			if (strcasecmp(argvÄ0Ü,AUTHSERVER))
          1347 | 			ä
          1348 | 				if (|tso)
          1349 | 					tso = new TsoCmdService();
          1350 | 				tso->cmd(b);
          1351 | 			ü
          1352 | 			else
          1353 | 				printf(" We can't start TSO in auth environmentÖn");
          1354 | 			break;
          1355 | 		case 'u':
          1356 | 		case 'U':
          1357 | 			if (|unix)
          1358 | 				unix = new UssCmdService();
          1359 | 			unix->cmd(b);
          1360 | 			break;
          1361 | 		case 'j':
          1362 | 		case 'J':
          1363 | 			if (strcasecmp(argvÄ0Ü,SERVER))
          1364 | 			ä
          1365 | 				if (|jes)
          1366 | 					jes = new JesCmdService();
          1367 | 				jes->cmd(b);
          1368 | 			ü
          1369 | 			else
          1370 | 				printf(" We can't start JES in Unauth environmentÖn");
          1371 | 			break;
          1372 | 		case 'd':
          1373 | 		case 'D':
          1374 | 			if (|dsn)
          1375 | 				dsn = new DsnCmdService();
          1376 | 			dsn->cmd(b,NULL);
          1377 | 			break;
          1378 | 		case 'o':
          1379 | 		case 'O':
          1380 | 			if (|oper)
          1381 | 				oper = new OperCmdService();
          1382 | 			oper->cmd(b);
          1383 | 			break;
          1384 | 		case 's':
          1385 | 		case 'S':
          1386 | 			if (|sdsf)
          1387 | 				sdsf = new SdsfCmdService();
          1388 | 			sdsf->cmd(b);
          1389 | 			break;
          1390 | 		case 'm':
          1391 | 		case 'M':
          1392 | 			if (|mx)
          1393 | 				mx = new MxServerCmdService();
          1394 | 			mx->cmd(b);
          1395 | 			break;
          1396 |
          1397 | 		case 'x':
          1398 | 		case 'X':
          1399 | 			if (|rs)
          1400 | 				rs = new RexxServerCmdService();
          1401 | 			rs->cmd(b);
          1402 | 			break;
          1403 |
          1404 | 		default:
          1405 | 			printf("?? %sÖn",buff);
          1406 | 		ü
          1407 | 		if (tso)
          1408 | 			delete tso;
          1409 | 		if (unix)
          1410 | 			delete unix;
          1411 | 		if (jes)
          1412 | 			delete jes;
          1413 | 		if (dsn)
          1414 | 			delete dsn;
          1415 | 		if (sdsf)
          1416 | 			delete sdsf;
          1417 | 		if (mx)
          1418 | 			delete mx;
          1419 | 		if (rs)
          1420 | 			delete rs;
          1421 |
          1422 | 	ü
          1423 |
          1424 | 	return 0;
          1425 | ü
0                                   * * * * *   E N D   O F   S O U R C E   * * * * *
-

15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(STRSERV)'                      07.01.13 11:00:48
0                                    * * * * *   I N C L U D E S   * * * * *
     1  =  //'ESA.PRJ.CBTEXP.HPP(ISISDEF)'
     2  =  //'ESA.PRJ.CBTEXP.HPP(VERSINFO)'
     3  =  //'ESA.PRJ.CBTEXP.HPP(OSMFIND)'
     4  =  //'ESA.PRJ.CBTEXP.HPP(OS)'
     5  =  //'CEE.SCEEH.H(STDLIB)'
     6  =  //'CEE.SCEEH.H(FEATURES)'
     7  =  //'CEE.SCEEH.H(BUILTINS)'
     8  =  //'CEE.SCEEH.H(STDDEF)'
     9  =  //'CEE.SCEEH.H(STRING)'
    10  =  //'ESA.PRJ.CBTEXP.HPP(MCHAIN)'
    11  =  //'ESA.PRJ.CBTEXP.HPP(MVSBASE)'
    12  =  //'ESA.PRJ.CBTEXP.HPP(MERROR)'
    13  =  //'ESA.PRJ.CBTEXP.HPP(DSNAMEUT)'
    14  =  //'CEE.SCEEH.H(ASSERT)'
    15  =  //'CEE.SCEEH.H(STDIO)'
    16  =  //'CEE.SCEEH.SYS.H(TYPES)'
    17  =  //'ESA.PRJ.CBTEXP.HPP(FILETYPE)'
    18  =  //'CEE.SCEEH.H(SIGNAL)'
    19  =  //'CEE.SCEEH.H(TIME)'
    20  =  //'CEE.SCEEH.H(DLL)'
    21  =  //'CEE.SCEEH.H(LIMITS)'
    22  =  //'CEE.SCEEH.H(UNISTD)'
    23  =  //'CEE.SCEEH.H(INTTYPES)'
    24  =  //'CEE.SCEEH.H(STDINT)'
    25  =  //'CEE.SCEEH.H(PWD)'
    26  =  //'CEE.SCEEH.H(ASSERT)'
    27  =  //'CEE.SCEEH.H(CTYPE)'
    28  =  //'CEE.SCEEH.H(STRINGS)'
    29  =  //'CEE.SCEEH.H(DIRENT)'
    30  =  //'CEE.SCEEH.SYS.H(STAT)'
    31  =  //'CEE.SCEEH.SYS.H(MODES)'
    32  =  //'CEE.SCEEH.SYS.H(MNTENT)'
    33  =  //'CEE.SCEEH.SYS.H(STAT)'
    34  =  //'CEE.SCEEH.H(FCNTL)'
    35  =  //'CEE.SCEEH.SYS.H(WAIT)'
    36  =  //'CEE.SCEEH.H(ERRNO)'
    37  =  //'CEE.SCEEH.H(STDARG)'
    38  =  //'CEE.SCEEH.H(ASSERT)'
    39  =  //'CEE.SCEEH.SYS.H(SOCKET)'
    40  =  //'CEE.SCEEH.SYS.H(UIO)'
    41  =  //'CEE.SCEEH.NETINET.H(IN)'
    42  =  //'CEE.SCEEH.SYS.H(TIME)'
    43  =  //'CEE.SCEEH.ARPA.H(INET)'
    44  =  //'CEE.SCEEH.H(NETDB)'
    45  =  //'ESA.PRJ.CBTEXP.HPP(MISC)'
    46  =  //'ESA.PRJ.CBTEXP.HPP(JESI)'
    47  =  //'ESA.PRJ.CBTEXP.HPP(PPDECVT)'
    48  =  //'ESA.PRJ.CBTEXP.HPP(JES)'
    49  =  //'ESA.PRJ.CBTEXP.HPP(SSS2)'
    50  =  //'ESA.PRJ.CBTEXP.HPP(SAPISEL)'
    51  =  //'ESA.PRJ.CBTEXP.HPP(SAPIINFO)'
    52  =  //'ESA.PRJ.CBTEXP.HPP(IOQE)'
    53  =  //'ESA.PRJ.CBTEXP.HPP(CALJESI)'
    54  =  //'ESA.PRJ.CBTEXP.HPP(DEFJESI)'
    55  =  //'ESA.PRJ.CBTEXP.HPP(DLLDEF)'
    56  =  //'ESA.PRJ.CBTEXP.HPP(CASMIF)'
    57  =  //'ESA.PRJ.CBTEXP.HPP(ASMIF)'
    58  =  //'ESA.PRJ.CBTEXP.HPP(MSGMGR)'
    59  =  //'ESA.PRJ.CBTEXP.HPP(JOBENV)'
    60  =  //'ESA.PRJ.CBTEXP.HPP(REXXVAR)'
    61  =  //'ESA.PRJ.CBTEXP.HPP(SHVBLOCK)'
    62  =  //'ESA.PRJ.CBTEXP.HPP(STRSERV)'
    63  =  //'ESA.PRJ.CBTEXP.HPP(IBMDEBUG)'
    64  =  //'CEE.SCEEH.H(CTEST)'
    65  =  //'ESA.PRJ.CBTEXP.HPP(IGGCSI00)'
    66  =  //'ESA.PRJ.CBTEXP.HPP(SUBTASK)'
    67  =  //'CEE.SCEEH.SYS.H(MSG)'
    68  =  //'CEE.SCEEH.SYS.H(IPC)'
    69  =  //'CEE.SCEEH.SYS.H(@@GETIPC)'
    70  =  //'ESA.PRJ.CBTEXP.HPP(SYMBP)'
    71  =  //'ESA.PRJ.CBTEXP.HPP(STRNODE)'
    72  =  //'ESA.PRJ.CBTEXP.HPP(MVSSTR)'
    73  =  //'ESA.PRJ.CBTEXP.HPP(IHAPSA)'
    74  =  //'ESA.PRJ.CBTEXP.HPP(IHACVT)'
    75  =  //'ESA.PRJ.CBTEXP.HPP(IHASCVT)'
    76  =  //'ESA.PRJ.CBTEXP.HPP(IKJTCB)'
    77  =  //'ESA.PRJ.CBTEXP.HPP(IHALDA)'
    78  =  //'ESA.PRJ.CBTEXP.HPP(IHAECVT)'
    79  =  //'ESA.PRJ.CBTEXP.HPP(IHAASCB)'
    80  =  //'ESA.PRJ.CBTEXP.HPP(IHAASSB)'
    81  =  //'ESA.PRJ.CBTEXP.HPP(CSVDLCB)'
    82  =  //'ESA.PRJ.CBTEXP.HPP(IHALLT)'
    83  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOCVT)'
    84  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOPNT)'
    85  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOCVE)'
    86  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMAR)'
    87  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARA)'
    88  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARL)'
    89  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARR)'
    90  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESB)'
    91  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESD)'
    92  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESL)'
    93  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESN)'
    94  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESP)'
    95  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESR)'
    96  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESX)'
    97  =  //'ESA.PRJ.CBTEXP.HPP(IGWDST)'
    98  =  //'ESA.PRJ.CBTEXP.HPP(SMDE)'
    99  =  //'ESA.PRJ.CBTEXP.HPP(SMDEFD)'
   100  =  //'ESA.PRJ.CBTEXP.HPP(SMDENAME)'
   101  =  //'ESA.PRJ.CBTEXP.HPP(SMDENLST)'
   102  =  //'ESA.PRJ.CBTEXP.HPP(SMDEPNAM)'
   103  =  //'ESA.PRJ.CBTEXP.HPP(SMDETOKN)'
   104  =  //'ESA.PRJ.CBTEXP.HPP(TSVT)'
   105  =  //'ESA.PRJ.CBTEXP.HPP(TJDSECTD)'
   106  =  //'ESA.PRJ.CBTEXP.HPP(TVDSECTD)'
   107  =  //'ESA.PRJ.CBTEXP.HPP(DCUOUTH)'
   108  =  //'ESA.PRJ.CBTEXP.HPP(F1DSCB)'
   109  =  //'ESA.PRJ.CBTEXP.HPP(F2DSCB)'
   110  =  //'ESA.PRJ.CBTEXP.HPP(F3DSCB)'
   111  =  //'ESA.PRJ.CBTEXP.HPP(MXDT)'
   112  =  //'ESA.PRJ.CBTEXP.HPP(MXIS)'
   113  =  //'ESA.PRJ.CBTEXP.HPP(MXIREQ)'
   114  =  //'ESA.PRJ.CBTEXP.HPP(PGTHA)'
   115  =  //'ESA.PRJ.CBTEXP.HPP(PGTHB)'
   116  =  //'ESA.PRJ.CBTEXP.HPP(PGTHC)'
   117  =  //'ESA.PRJ.CBTEXP.HPP(PGTHD)'
   118  =  //'ESA.PRJ.CBTEXP.HPP(PGTHE)'
   119  =  //'ESA.PRJ.CBTEXP.HPP(PGTHF)'
   120  =  //'ESA.PRJ.CBTEXP.HPP(PGTHG)'
   121  =  //'ESA.PRJ.CBTEXP.HPP(PGTHH)'
   122  =  //'ESA.PRJ.CBTEXP.HPP(PGTHJ)'
   123  =  //'ESA.PRJ.CBTEXP.HPP(PGTHK)'
   124  =  //'ESA.PRJ.CBTEXP.HPP(PGPS)'
   125  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOTCB)'
   126  =  //'ESA.PRJ.CBTEXP.HPP(BPXZTHLI)'
   127  =  //'ESA.PRJ.CBTEXP.HPP(BPXZPRLI)'
   128  =  //'ESA.PRJ.CBTEXP.HPP(BPXYOPNF)'
   129  =  //'ESA.PRJ.CBTEXP.HPP(RMCT)'
   130  =  //'ESA.PRJ.CBTEXP.HPP(CSD)'
   131  =  //'ESA.PRJ.CBTEXP.HPP(PCCA)'
   132  =  //'ESA.PRJ.CBTEXP.HPP(PCCAVT)'
   133  =  //'ESA.PRJ.CBTEXP.HPP(SMCABASE)'
   134  =  //'ESA.PRJ.CBTEXP.HPP(IHAASVT)'
   135  =  //'ESA.PRJ.CBTEXP.HPP(MNTE)'
   136  =  //'ESA.PRJ.CBTEXP.HPP(MNTEH)'
   137  =  //'ESA.PRJ.CBTEXP.HPP(TRVT)'
   138  =  //'ESA.PRJ.CBTEXP.HPP(TBVT)'
   139  =  //'ESA.PRJ.CBTEXP.HPP(TTE)'
   140  =  //'ESA.PRJ.CBTEXP.HPP(CEECAA)'
   141  =  //'ESA.PRJ.CBTEXP.HPP(CEEMCH)'
   142  =  //'ESA.PRJ.CBTEXP.HPP(CEEDSAHP)'
   143  =  //'ESA.PRJ.CBTEXP.HPP(CEEDSA)'
   144  =  //'ESA.PRJ.CBTEXP.HPP(CEEPCB)'
   145  =  //'ESA.PRJ.CBTEXP.HPP(CEECEDB)'
   146  =  //'ESA.PRJ.CBTEXP.HPP(CEECDLL)'
   147  =  //'ESA.PRJ.CBTEXP.HPP(PA1H)'
   148  =  //'ESA.PRJ.CBTEXP.HPP(PA2H)'
   149  =  //'ESA.PRJ.CBTEXP.HPP(PA1EPNM)'
   150  =  //'ESA.PRJ.CBTEXP.HPP(IHASTCB)'
   151  =  //'ESA.PRJ.CBTEXP.HPP(IHAASXB)'
   152  =  //'ESA.PRJ.CBTEXP.HPP(CCT)'
   153  =  //'ESA.PRJ.CBTEXP.HPP(ICT)'
   154  =  //'ESA.PRJ.CBTEXP.HPP(MCT)'
   155  =  //'ESA.PRJ.CBTEXP.HPP(EZBYPTHA)'
   156  =  //'ESA.PRJ.CBTEXP.HPP(EZBCTHDR)'
   157  =  //'ESA.PRJ.CBTEXP.HPP(PCOMS83)'
   158  =  //'ESA.PRJ.CBTEXP.HPP(RFIS)'
   159  =  //'ESA.PRJ.CBTEXP.HPP(RFIM)'
   160  =  //'ESA.PRJ.CBTEXP.HPP(IOCC)'
   161  =  //'ESA.PRJ.CBTEXP.HPP(IAZJSAB)'
   162  =  //'ESA.PRJ.CBTEXP.HPP(CVTXTNT1)'
   163  =  //'ESA.PRJ.CBTEXP.HPP(CVTXTNT2)'
0"//'ESA.PRJ.CBTEXP.HPP(SSS2)'", line 142.58: CCN5804 (W) The characters "/*" are detected in a comment.
-                                 * * * * *   E N D   O F   I N C L U D E S   * * * * *
0
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(STRSERV)'                      07.01.13 11:00:48
-                           * * * * *   M E S S A G E   S U M M A R Y   * * * * *
0TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
                (U)       (S)         (E)        (W)          (I)
     1           0         0           0          1            0
0                    * * * * *   E N D   O F   M E S S A G E   S U M M A R Y   * * * * *
0                        * * * * *   E N D   O F   C O M P I L A T I O N   * * * * *
