
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'                      07.01.13 11:01:28
0                                      * * * * *   P R O L O G   * * * * *
    Compiler options. . . . . . . :AGGRCOPY(NOOVERLAP)             ANSIALIAS       ARCH(7)         ARGPARSE        NOASCII
                                  :NOATTRIBUTE     ASSERT(RESTRICT)                BITFIELD(UNSIGNED)              CHARS(UNSIGNED)
                                  :NOCOMPACT       NOCOMPRESS      CVFT            NODFP           DIGRAPH
                                  :DLL(NOCALLBACKANY)              ENUMSIZE(SMALL) NOEVENTS        EXECOPS         EXH
                                  :NOEXPMAC        NOEXPORTALL     NOFASTTEMPINC   FLAG(I)         GOFF            GONUMBER
                                  :HALT(16)        NOHGPR(NOPRESERVE)              NOHOT           NOIGNERRNO      ILP32
                                  :NOINITAUTO      NOINLRPT        NOLIBANSI       NOLIST          LONGNAME        NOMAKEDEP
                                  :NOMARGINS       MAXMEM(2097152) MEMORY          NAMEMANGLING(zOSV1R2)           NESTINC(255)
                                  :OBJECT          OBJECTMODEL(COMPAT)             NOOE            NOOFFSET        OPTIMIZE(2)
                                  :PLIST(HOST)     NOPORT          NOPPONLY        PREFETCH        REDIR           NOREPORT
                                  :ROSTRING        ROCONST         RTTI(ALL)       NOSEQUENCE      NOSHOWINC       NOSHOWMACROS
                                  :SOURCE          SKIPSRC(SHOW)   SPILL(3600)     START           NOSTATICINLINE  STRICT
                                  :NOSTRICT_INDUCTION              TARGET(LE,CURRENT)              NOTEMPLATEREGISTRY
                                  :TEMPLATERECOMPILE               TERMINAL        TEST(HOOK)      TMPLPARSE(NO)   TUNE(7)
                                  :UNROLL(AUTO)    UTF             NOWARN0X        NOWARN64        NOWSIZEOF       NOXREF
                                  :NOCICS
                                  :NOCONVLIT
                                  :CSECT()
                                  :DEBUG(FORMAT(ISD),LEVEL(0),HOOK(NOLINE,NOBLOCK,NOPATH,CALL,FUNC),NOSYMBOL)
                                  :DEFINE(__OS390__=1,_POSIX_SOURCE=1,_XOPEN_SOURCE_EXTENDED=1,MU_STANDALONE=1,ISIS_PF_MU=1,
                                   MU_STANDALONE=1,SAPI_NO=1,VSAM_NO=1)
                                  :FLOAT(HEX,FOLD,AFP(NOVOLATILE)) ROUND(Z)
                                  :NOHALTONMSG
                                  :INFO(LAN)
                                  :INLINE(AUTO,NOREPORT,100,1000)
                                  :NOIPA
                                  :KEYWORD(bool,explicit,export,false,mutable,namespace,true,typename,using,restrict,__restrict__,
                                   __restrict,_Pragma,__alignof__,__asm__,__attribute__,__const__,__extension__,__volatile__,
                                   __inline__,__signed__,__typeof__)
                                  :NOKEYWORD(char16_t,char32_t,static_assert,typeof)
                                  :LANGLVL(ANONSTRUCT,ANONUNION,ANSIFOR,ANSISINIT,NOAUTOTYPEDEDUCTION,C99VLA,C99__FUNC__,
                                   NOC99LONGLONG,NOC99PREPROCESSOR,NODBCS,NODECLTYPE,NODELEGATINGCTORS,DEPENDENTBASELOOKUP,
                                   NODOLLARINNAMES,EMPTYSTRUCT,NOEXTENDEDFRIEND,NOEXTENDEDINTEGERSAFE,EXTERNTEMPLATE,ILLPTOM,
                                   IMPLICITINT,NOINLINENAMESPACE,LIBEXT,LONGLONG,NONEWEXCP,OFFSETNONPOD,NOOLDDIGRAPH,OLDFRIEND,
                                   NOOLDMATH,NOOLDSTR,OLDTEMPACC,NOOLDTMPLALIGN,OLDTMPLSPEC,NOSTATIC_ASSERT,TRAILENUM,TYPEDEFCLASS,
                                   NOUCS,VARARGMACROS,NOVARIADICTEMPLATES,GNU_INCLUDE_NEXT,ZEROEXTARRAY)
                                  :LOCALE(DE_DE.IBM-273)
                                  :NOLSEARCH
                                  :OPTFILE(DD:OPTFILE)
                                  :NORTCHECK
                                  :SEARCH(//'CEE.SCEEH.+', //'CBC.SCLBH.+', CEE.SCEEH.+, CBC.SCLBH.+, DD:USERLIB)
                                  :NOSERVICE
                                  :NOSQL
                                  :NOSUPPRESS
                                  :TEMPINC(./tempinc)
                                  :XPLINK(NOBACKCHAIN,NOCALLBACK,GUARD,OSCALL(NOSTACK),NOSTOREARGS)
    Version Macros. . . . . . . . : __COMPILER_VER__=0x410C0000
                                  : __LIBREL__=0x410C0000
                                  : __TARGET_LIB__=0x410C0000
    Source margins. . . . . . . . :
      Varying length. . . . . . . : 1 - 32760
      Fixed length. . . . . . . . : 1 - 32760
    Sequence columns. . . . . . . :
      Varying length. . . . . . . : none
      Fixed length. . . . . . . . : none
    Locale name . . . . . . . . . : DE_DE.IBM-273
    Code set. . . . . . . . . . . : IBM-273
    Listing name. . . . . . . . . : DD:SYSCPRT
0                                 * * * * *   E N D   O F   P R O L O G   * * * * *
-
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'                      07.01.13 11:01:28
-
                                       * * * * *   S O U R C E   * * * * *
0            1 | #pragma runopts(POSIX(ON),XPLINK(ON),ALL31(ON))
             2 | #define _OPEN_SYS_EXT 1
             3 | #define _OPEN_SOURCE 1
             4 | #define ISIS_ALLOW_OS_FUNCTIONS 1
             5 | #include "isisdef.h"
             6 | #define _OPEN_SYS_EXT 1
             7 | #define _OPEN_SOURCE 1
             8 | #define _ISOC99_SOURCE
             9 | #include "mvstool.hpp"
            10 |
            11 | char * strupr(char *s)
            12 | ä
            13 | 	if (NOT s) return (NULL);
            14 | 	for(int i = 0;i<strlen(s);i++) sÄiÜ = toupper(sÄiÜ);
            15 | 	return s;
            16 | ü
            17 |
            18 | int memcmpi(const char * s1,const char * s2,int l)
            19 | ä
            20 | 	for(int i = 0; i<l; i++)
            21 | 		if ( tolower(s1ÄiÜ) - tolower(s2ÄiÜ) )
            22 | 			return (tolower(s1ÄiÜ) - tolower(s2ÄiÜ));
            23 | 	return 0;
            24 | ü
            25 |
            26 | char * makeString(char * s,int l)
            27 | ä
            28 | 	char * c = (char *)malloc(l+1);
            29 | 	memcpy(c,s,l);
            30 | 	cÄlÜ = 0;
            31 | 	for(l;l;l--)
            32 | 		if ( cÄl-1Ü NEQ ' ')  break;
            33 | 	cÄlÜ = null;
            34 | 	return c;
            35 | ü
            36 |
            37 | int initTestCases(char * n,testRoutine f)
            38 | ä
            39 | 	if (testCasesIndex==0)
            40 | 		memset(&testCases,0,sizeof(testCases));
            41 | 	testCasesÄtestCasesIndexÜ.name = n;
            42 | 	testCasesÄtestCasesIndex++Ü.addr = f;
            43 | 	return testCasesIndex;
            44 | ü
            45 |
            46 | typedef struct smf14 * smf14P;
            47 | typedef struct smf30cas * smf30casP;
            48 | typedef struct smf30id  * smf30idP;
            49 | typedef struct smf30sap * smf30sapP;
            50 | typedef struct smf30cmp * smf30cmpP;
            51 | typedef struct smf30mse * smf30mseP;
            52 | typedef struct smf30ud  * smf30udP;
            53 | typedef struct smf30acs * smf30acsP;
            54 | typedef struct smf30dr  * smf30drP;
            55 | typedef struct smf30op  * smf30opP;
            56 | typedef struct smf30ura * smf30uraP;
            57 | typedef struct smf30ar  * smf30arP;
            58 | typedef struct smf30exp * smf30expP;
            59 | typedef struct smf30ops * smf30opsP;
            60 | typedef struct smf30rm  * smf30rmP;
            61 | typedef struct smf30prf * smf30prfP;
            62 | typedef struct smfrcd30 * smfrcd30P;
            63 | typedef struct smfrcd92 * smfrcd92P;
            64 | typedef struct smf92fcl * smf92fclP;
            65 | typedef struct smf92fop * smf92fopP;
            66 | typedef struct smf92fsm * smf92fsmP;
            67 | typedef struct smf92fsp * smf92fspP;
            68 | typedef struct smf92fsr * smf92fsrP;
            69 | typedef struct smf92fsu * smf92fsuP;
            70 | typedef struct smf92fsv * smf92fsvP;
            71 | typedef struct smf92id  * smf92idP;
            72 | typedef struct smf92mmp * smf92mmpP;
            73 | typedef struct smf92mun * smf92munP;
            74 | typedef struct smf92sss * smf92sssP;
            75 |
            76 |
            77 | const int     SMF_MAXBUFFER = 1024*1024;
            78 | const char * SMF_FILE = "//DD:SMF";
            79 | #define FT_DIR        1  //Directory File
            80 | #define FT_CHARSPEC   2      //Character Special File
            81 | #define FT_REGFILE    3      //Regular File
            82 | #define FT_FIFO       4      //Named Pipe (FIFO) File
            83 | #define FT_SYMLINK    5      //Symbolic link
            84 | #define FT_SOCKET     7      //Socket File                  ºD2A
            85 |
            86 | #define sF(d,v) printf(" %s:%#10.4f(sec)Ön",#d,float(p->v)/100);
            87 | #define sI(d,v) printf(" %s:%dÖn",#d,p->v);
            88 |
            89 | long long totalCPUsu = 0;
            90 | long long indepCPUsu = 0;
            91 |
            92 | static int rst_14 = 0;
            93 | static int rst_15 = 0;
            94 | static int rst_30 = 0;
            95 | static int rsd_14 = 0;
            96 | static int rsd_15 = 0;
            97 | static int rsd_30 = 0;
            98 | static bool debugF = atoi(getenv("DEBUG_SMF"));
            99 | typedef struct
           100 | ä
           101 | 	short int     _smf14esl;     /* LENGTH OF SECTION IN EXTENDED INFORMATION @L1A */
           102 | 	char          _filler4;      /* RESERVED                                  @L1A */
           103 | 	char          _smf14sty;     /* SECTION TYPE                              @L1A */
           104 | 	unsigned char _smf14xf1;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 1    @L1A */
           105 | 	unsigned char _smf14xf2;     /* EXTENDED SEGMENT INDICATOR FLAG BYTE 2    @L1A */
           106 | 	unsigned char _smf14cdlÄ8Ü;  /* NUMBER OF BYTES OF COMPRESSED DATA READ   @L1A */
           107 | 	unsigned char _smf14udlÄ8Ü;  /* NUMBER OF BYTES OF DATA READ OR WRITTEN   @L1A */
           108 | 	unsigned char _smf14cdsÄ8Ü;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */
           109 | 	unsigned char _smf14udsÄ8Ü;  /* COMPRESSED FORMAT DATA SET SIZE TO THIS   @02C */
           110 | 	unsigned char _smf14cisÄ4Ü;  /* PHYSICAL BLOCK SIZE OF COMPRESSED FORMAT  @02C */
           111 | 	short int     _smf14tkl;     /* DICTIONARY TOKEN LENGTH(NOT INCLUDING     @L1A */
           112 | 	unsigned char _smf14tknÄ36Ü; /* DICTIONARY TOKEN FOR COMPRESSED FORMAT    @02C */
           113 | 	unsigned char _filler5Ä53Ü;
           114 | ü
           115 | * smf14EISP;
           116 |
           117 | typedef struct
           118 | ä
           119 | 	unsigned char _filler8Ä4Ü;
           120 | 	unsigned char _smf14spnÄ8Ü;   /* STEP NAME                                 @L2A */
           121 | 	unsigned char _smf14pgnÄ8Ü;   /* ACTIVE PROGRAM NAME                       @L2A */
           122 | 	unsigned char _filler9Ä113Ü;
           123 | ü
           124 | * smf14STEP;
           125 | char pstepnameÄ9Ü;
           126 | char pprognameÄ256Ü;
           127 | char stepnameÄ9Ü;
           128 | int write_30 = 0;
           129 | char jobnameÄ9Ü;
           130 | char jobidÄ9Ü = "";
           131 | char usernameÄ128Ü;
           132 | static int countersÄ256Ü;
           133 | static int total_read = 0;
           134 | static int total_write = 0;
           135 | static int total_dir = 0;
           136 | int printSMF(char * b,bool & idflag,size_t rl,int need30 = 1, int  need92 = 1)
           137 | ä
           138 | 	//printf(" LRECL:%5.5d %8.8x %8.8x %8.8x %8.8x Ön",l,*(int *)b,*(int *)(b+4),*(int *)(b+8),*(int *)
           138 | (b+12));
           139 | 	countersÄsmfrcd30P(b)->smf30rtyÜ++;
           140 | 	switch(smfrcd30P(b)->smf30rty)
           141 | 	ä
           142 | 	case 2:
           143 | 		//printf(" >>>start of dump>>>Ön");
           144 | 		break;
           145 | 	case 3:
           146 | 		//printf(" >>>end of dump>>>Ön");
           147 | 		break;
           148 | 	case 14:
           149 | 	case 15:
           150 | 		ä
           151 | 			char prognameÄ256Ü;
           152 | 			smf14P smf14p = (smf14P)b;
           153 | 			int sdc = smf14p->smf14sdc; //size of DCB segment
           154 | 			int nuc = smf14p->smf14nuc; //no. of UCB sections
           155 | 			int suc = smf14p->smf14suc; //size of each of UCB sections
           156 | 			int excp = 0;
           157 | 			memcpy(&rst_15,smf14p->smf14rst,4);
           158 | 			memcpy(&rsd_15,smf14p->smf14rsd,4);
           159 | 			if (rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))
           160 | 				break;
           161 | 			if (nuc > 0)
           162 | 				excp = *(int*)smf14p->smfexcp;
           163 | 			if (excp == 0)
           164 | 				break;
           165 | 			if (debugF)
           166 | 				_dump(" SMF 14 or 15 record dump",b,rl);
           167 | 			ä
           168 | 				unsigned char* dcbp = smf14p->smfdcbor; //DCB Section
           169 | 				unsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section
           170 | 				unsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section
           171 | 				unsigned char* eisp = ucbp + nuc*suc;
           172 | 				short int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Secti
           172 | ons
           173 | 				unsigned char* eispr = eisp + 2;
           174 | 				short int eispl = 1; //length of next Extended Information Section
           175 | 				int write_14_15 = 0; //=0 do not write line
           176 | 				char stepname_14Ä9Ü;
           177 | 				char progname_14Ä9Ü;
           178 | 				while (smf14esll > 0 && eispl > 0)
           179 | 				ä
           180 | 					eispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section
           181 | 					char sty = ((smf14EISP)eispr)->_smf14sty; //Section type
           182 | 					switch(sty)
           183 | 					ä
           184 | 					case smf14stp:
           185 | 						strncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);
           186 | 						strncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);
           187 | 						stepname_14Ä8Ü = 0;
           188 | 						progname_14Ä8Ü = 0;
           189 | 						if (*pstepname == 0 && *pprogname == 0)
           190 | 							write_14_15 = 1;
           191 | 						else if (*pstepname && |strcasecmp(stepname_14,pstepname))
           192 | 							write_14_15 = 1;
           193 | 						else if (*pprogname && |strcasecmp(progname_14,pprogname))
           194 | 							write_14_15 = 1;
           195 | 						break;
           196 | 					default:
           197 | 						break;
           198 | 					ü
           199 | 					smf14esll -= eispl;
           200 | 					eispr += eispl;
           201 | 					//printf("smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%dÖn",smf14p,ucbp,eispr,eisp,smf14esll);
           202 | 				ü
           203 | 				if (write_14_15)
           204 | 				ä
           205 | 					char dsnameÄ45Ü;
           206 | 					write_30 = 1; //write step sum
           207 | 					/*
           208 | 					if (*stepname == 0)
           209 | 					ä
           210 | 					strcpy(stepname,stepname_14);
           211 | 					strcpy(progname,progname_14);
           212 | 					printf(" === Start stepname:'%s' progname:'%s' ===Ön",stepname,progname);
           213 | 					ü
           214 | 					*/
           215 | 					strncpy(dsname,(const char*)smf14p->smfjfcb1,44);
           216 | 					dsnameÄ44Ü = 0;
           217 | 					printf("%8.8s %s' excp=%8d ",smf14p->smftioe5,dsname,excp);
           218 | 					if (smfrcd30P(b)->smf30rty == 14)
           219 | 						printf("input ");
           220 | 					else
           221 | 						printf("output ");
           222 | 					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14dad)
           223 | 						printf("DASD ");
           224 | 					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14tds)
           225 | 						printf("Temporary ");
           226 | 					if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14vio)
           227 | 						printf("VIO ");
           228 | 					printf("Ön");
           229 | 				ü
           230 | 			ü
           231 | 		ü
           232 | 		break;
           233 | 	case 30:
           234 | 		// Identification section
           235 |
           236 | 		//if (*(short *)(smfrcd30P(b)->smf30stp)|=5)
           237 | 		//  break;
           238 | 		switch (*(short *)(smfrcd30P(b)->smf30stp))
           239 | 		ä
           240 | 		case 1:
           241 | 			if (argvÄ1Ü&&memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)
           242 | 			ä
           243 | 				memcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);
           244 | 				jobidÄ8Ü = 0;
           245 | 				memcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
           246 | 				jobnameÄ8Ü = 0;
           247 | 				memcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);
           248 | 				usernameÄ8Ü = 0;
           249 | 				rst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;
           250 | 				memcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);
           251 | 			ü
           252 | 			else
           253 | 				return 0;
           254 | 			break;
           255 | 		case 2:
           256 | 			return 0;
           257 | 			break;
           258 | 		case 3:
           259 | 			return 0;
           260 | 			break;
           261 | 		case 4:
           262 | 			break;
           263 | 		case 5:
           264 | 			break;
           265 | 		case 6:
           266 | 			break;
           267 | 		default:
           268 | 			break;
           269 | 		ü
           270 | 		if (memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))
           271 | 			break;
           272 | 		switch (*(short *)(smfrcd30P(b)->smf30stp))
           273 | 		ä
           274 | 		case 1:
           275 | 			printf(" ============================== J O B S T A R T ===================Ön");
           276 | 			break;
           277 | 		case 4:
           278 | 			printf(" ========================= S T E P T O T A L ======================Ön");
           279 | 			break;
           280 | 		case 5:
           281 | 			printf(" ====================== J O B T E R M I N A T I O N  =============Ön");
           282 | 			break;
           283 | 		case 6:
           284 | 			printf(" ===========System address space=====================================Ön");
           285 | 			break;
           286 | 		default:
           287 | 			break;
           288 | 		ü
           289 | 		int rest , v , ss, mm, hh;
           290 | 		rest = (*(int *)smfrcd30P(b)->smf30tme)%100;
           291 | 		v =  (*(int *)smfrcd30P(b)->smf30tme)/100;
           292 | 		ss = v%60;
           293 | 		v /= 60;
           294 | 		mm = v%60;
           295 | 		hh = v/60;
           296 |
           297 | 		if (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)
           298 | 		ä
           299 | 			smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
           300 | 			if (debugF)
           301 | 			ä
           302 | 				_dump(" SMF 30 record dump",b,rl);
           303 | 				printf(" Subsystem     :%dÖn",*(short *)(smfrcd30P(b)->smf30son));
           304 | 				printf(" Identification :%dÖn",*(short *)(smfrcd30P(b)->smf30ion));
           305 | 				printf(" I/O Activity :%dÖn",*(short *)(smfrcd30P(b)->smf30uon));
           306 | 				printf(" Completion :%dÖn",*(short *)(smfrcd30P(b)->smf30ton));
           307 | 				printf(" Processor  :%dÖn",*(short *)(smfrcd30P(b)->smf30con));
           308 | 				printf(" Accounting :%dÖn",*(short *)(smfrcd30P(b)->smf30aon));
           309 | 				printf(" Storage    :%dÖn",*(short *)(smfrcd30P(b)->smf30ron));
           310 | 				printf(" Performance :%dÖn",*(short *)(smfrcd30P(b)->smf30pon));
           311 | 				printf(" Operator   :%dÖn",*(short *)(smfrcd30P(b)->smf30oon));
           312 | 				printf(" EXCP       :%dÖn",*(short *)(smfrcd30P(b)->smf30eon));
           313 | 				printf(" APPC       :%dÖn",*(short *)(smfrcd30P(b)->smf30drn));
           314 | 				printf(" OMVS       :%dÖn",*(short *)(smfrcd30P(b)->smf30opn));
           315 | 				printf(" Usage      :%dÖn",*(short *)(smfrcd30P(b)->smf30udn));
           316 | 			ü
           317 | 			printf(" Job:%8.8s JobId:%8.8s Step:%8.8s User:%20.20s RacfGrp:%8.8s RacfUsr:%8.8sÖn",
           318 | 				p->smf30jbn,jobid,p->smf30stm,p->smf30usr,p->smf30grp,p->smf30rud);
           319 | 			printf(" Program:%8.8s",p->smf30pgm);
           320 | 			idflag = true;
           321 | 		ü
           322 | 		printf(" Record Created at:%2.2d:%2.2d:%2.2d:%2.2dÖn",hh,mm,ss,rest);
           323 | 		// I/O activity
           324 | 		if (*(short *)(smfrcd30P(b)->smf30uon))
           325 | 		ä
           326 | 			smf30uraP p = smf30uraP(b+smfrcd30P(b)->smf30uof);
           327 | 			printf(" Accumplated EXCP count:%8.8dÖn",
           328 | 				p->smf30tep);
           329 | 		ü
           330 | 		// Processor cumulative CPU
           331 | 		if (*(short *)(smfrcd30P(b)->smf30con))
           332 | 		ä
           333 | 			smf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);
           334 | 			printf(" Total CPU time:%#10.4f(sec) SRB time:%#10.4f(sec)Ön",
           335 | 				float(p->smf30cpt)/100,float(p->smf30cps)/100);
           336 | 			/*
           337 | 			sF(process I/O interrupts,smf30iip)
           338 | 			sF(client and preempt SRB,smf30asr)
           339 | 			sF(independent enclave,smf30enc)
           340 | 			sF(dependent enclave,smf30det)
           341 | 			*/
           342 | 		ü
           343 | 		// EXCP section
           344 | 		if (*(short *)(smfrcd30P(b)->smf30eon))
           345 | 		ä
           346 | 			smf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);
           347 | 			for(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)
           348 | 			ä
           349 | 				if (p->smf30blk)
           350 | 					printf(" Device(CUA):%2.2X%2.2X EXCP count:%8.8dÖn",
           351 | 					p->smf30cuaÄ0Ü,p->smf30cuaÄ1Ü,p->smf30blk);
           352 | 				p = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);
           353 | 			ü
           354 | 		ü
           355 | 		// Storage
           356 | 		if (*(short *)(smfrcd30P(b)->smf30ron))
           357 | 		ä
           358 | 			smf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);
           359 | 			printf(" Max Region Size:%8.8d(Mbyte) Max Allocated Storage:%8.8d(Mbyte)Ön",
           360 | 				(*(int *)p->smf30rgn)/1024,p->smf30eur/(1024*1024));
           361 | 		ü
           362 |
           363 | 		// Performance
           364 | 		if (*(short *)(smfrcd30P(b)->smf30pon))
           365 | 		ä
           366 | 			smf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);
           367 | 			printf(" Total Service units:%8.8d CPU:%8.8d SRB:%8.8d I/O:%8.8dÖn",
           368 | 				p->smf30srv,p->smf30csu,p->smf30srb,p->smf30io);
           369 | 			totalCPUsu  += p->smf30csu;
           370 | 			indepCPUsu += p->smf30esu;
           371 | 			/*
           372 | 			sI(Independent enclave tansaction active,smf30eta);
           373 | 			sI(Independent enclave CPU service uints,smf30esu);
           374 | 			sI(Independent enclave trasnsaction count,smf30etc);
           375 | 			*/
           376 | 		ü
           377 |
           378 | 		// Operator
           379 | 		if (*(short *)(smfrcd30P(b)->smf30oon))
           380 | 		ä
           381 | 			smf30opsP p = smf30opsP(b+smfrcd30P(b)->smf30oof);
           382 | 			if (p->smf30pdm]]p->smf30prd)
           383 | 				printf(" Non Specific mounts :%8.8d Specific mounts:%8.8dÖn",
           384 | 				p->smf30pdm,p->smf30prd);
           385 | 			if (p->smf30mtm]]p->smf30msr)
           386 | 				printf(" SMS Non Specific mounts:%8.8d Specific mounts:%8.8dÖn",
           387 | 				p->smf30mtm,p->smf30msr);
           388 |
           389 | 		ü
           390 | 		// Open Edition
           391 | 		if (*(short *)smfrcd30P(b)->smf30opn)
           392 | 		ä
           393 | 			smf30opP p = smf30opP(b+*(int *)smfrcd30P(b)->smf30opo);
           394 | 			for(int i=0;i<*(short*)smfrcd30P(b)->smf30opn;i++)
           395 | 			ä
           396 | 				printf(" Process:%d Process group:%d User:%d Group:%d Session:%dÖn",
           397 | 					p->smf30opi,p->smf30opg,p->smf30oui,p->smf30oug,p->smf30osi);
           398 | 				printf(" CPU:%#10.2f(sec) Kernel Calls:%d Ön",
           399 | 					float(p->smf30ost)/100,p->smf30osc);
           400 | 				printf(" Directory Reads:%8.8dÖn",p->smf30odr);
           401 | 				printf(" Regular file   :%8.8d %8.8dÖn",p->smf30ofr,p->smf30ofw);
           402 | 				printf(" Pipe       :%8.8d %8.8dÖn",p->smf30opr,p->smf30opw);
           403 | 				printf(" Special file :%8.8d %8.8dÖn",p->smf30osr,p->smf30osw);
           404 | 				printf(" Path lookup :%8.8d %8.8dÖn",p->smf30oll,p->smf30olp);
           405 | 				printf(" Path generation:%8.8d %8.8dÖn",p->smf30ogl,p->smf30ogp);
           406 | 				printf(" Socket     :%8.8d %8.8dÖn",p->smf30okr,p->smf30okw);
           407 | 				printf(" Message queue :%8.8d %8.8dÖn",p->smf30oms,p->smf30omr);
           408 | 				p = smf30opP((char *)p+*(short *)smfrcd30P(b)->smf30opl);
           409 | 			ü
           410 | 			printf(" Total_read : %8.8dÖn",total_read);
           411 | 			printf(" Total_write : %8.8dÖn",total_write);
           412 | 			printf(" Total_dir : %8.8dÖn",total_dir);
           413 |
           414 | 			total_read = total_write = total_dir = 0;
           415 | 		ü
           416 | 		printf(" ====================================================================Ön");
           417 | 		if (*(short *)(smfrcd30P(b)->smf30stp)==5)
           418 | 			return 5;
           419 | 		break;
           420 |
           421 | 		break;
           422 | 	case 42:
           423 | 		if (smfrcd92P(b)->smf92stp==6)
           424 | 		ä
           425 | 			_dump(" SMF 42 record dump",b,rl);
           426 | 			break;
           427 | 		ü
           428 | 	case 92:
           429 | 		if (smfrcd92P(b)->smf92stp==5)
           430 | 		ä
           431 | 			_dump(" SMF 92 record dump",b,rl);
           432 | 			break;
           433 | 		ü
           434 |
           435 | 		if (smfrcd92P(b)->smf92ion)
           436 | 		ä
           437 |
           438 | 			smf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);
           439 | 			if (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)
           440 | 				]]memcmp(jobname,pid->smf92jbn,8))
           441 | 				break;
           442 | 			//if (|need92]](strlen(argvÄ1Ü)&&memcmp(jobid,argvÄ1Ü,strlen(argvÄ1Ü))))
           443 | 			if (debugF)
           444 | 				_dump(" SMF 92 record dump",b,rl);
           445 | 			int rest , v , ss, mm, hh;
           446 | 			rest = smfrcd92P(b)->smf92tme%100;
           447 | 			v = smfrcd92P(b)->smf92tme/100;
           448 | 			ss = v%60;
           449 | 			v /= 60;
           450 | 			mm = v%60;
           451 | 			hh = v/60;
           452 | 			switch (smfrcd92P(b)->smf92stp)
           453 | 			ä
           454 | 			case 11:
           455 | 				if (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)
           456 | 				ä
           457 | 					smf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);
           458 | 					for(int i=0;i<smfrcd92P(b)->smf92don;i++)
           459 | 					ä
           460 | 						char nameÄ65Ü;
           461 | 						nameÄ64Ü=0;
           462 | 						if (p->smf92cty==FT_SOCKET)
           463 | 							sprintf(name," SOCKET inode:%d device:%d",p->smf92cin,p->smf92cdn);
           464 | 						else
           465 | 							memcpy(name,p->smf92cpn,sizeof(p->smf92cpn));
           466 | 						/*
           467 | 						printf(" Job:%8.8s at:%2.2d:%2.2d:%2.2d:%2.2d closing:%sÖn",pid->smf92jbn,hh,mm,ss,rest,name);
           468 | 						printf(" Process:%d User:%d Group:%dÖn",
           469 | 						pid->smf92pid,pid->smf92uid,pid->smf92gid);
           470 |
           471 | 						if (p->smf92cdi)
           472 | 						printf(" Directory I/O blocks :%8.8dÖn",p->smf92cdi);
           473 | 						if (p->smf92cir]]p->smf92csr)
           474 | 						printf(" I/O blocks read :%8.8d read calls :%dÖn",
           475 | 						p->smf92cir,p->smf92csr);
           476 | 						if (p->smf92ciw]]p->smf92csw)
           477 | 						printf(" I/O blocks write :%8.8d write calls:%dÖn",
           478 | 						p->smf92ciw,p->smf92csw);
           479 | 						*/
           480 | 						printf("'%s' r:%8.8d w:%8.8d d:%8.8d pid:%dÖn",name,p->smf92cir,p->smf92ciw,p->smf92cdi,pid->s
           480 | mf92pid);
           481 | 						total_read +=p->smf92cir;
           482 | 						total_write += p->smf92ciw;
           483 | 						total_dir += p->smf92cdi;
           484 | 						p = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);
           485 | 					ü
           486 | 				ü
           487 | 			case 13:
           488 | 				//if (*(short *)smfrcd92P(b)->smf92don)
           489 | 				if (0)
           490 | 				ä
           491 | 					smf92munP p = smf92munP(b+smfrcd92P(b)->smf92dof);
           492 | 					for(int i=0;i<*(short*)smfrcd92P(b)->smf92don;i++)
           493 | 					ä
           494 | 						if (p->smf92mutk)
           495 | 							printf(" Memory map token:%8.8d size:%8.8d read:%8.8d write:%8.8d (I/O blocks)Ön",
           496 | 							p->smf92mutk,p->smf92musz,p->smf92muir,p->smf92muiw);
           497 | 						p = smf92munP((char *)p+smfrcd92P(b)->smf92dln);
           498 | 					ü
           499 | 				ü
           500 | 			default:
           501 | 				break;
           502 | 			ü
           503 | 		ü
           504 | 		break;
           505 | 	default:
           506 | 		//  printf(" invalid typeÖn");
           507 | 		break;
           508 | 	ü
           509 | 	return 0;
           510 | ü
           511 |
           512 | static time_t set_epoch()
           513 | ä
           514 | 	unsigned long long t19720101 = (0x8126D60E46000000LL>>12)/1000000;
           515 | 	struct tm _tm;
           516 | 	memset(&_tm,0,sizeof(_tm));
           517 | 	_tm.tm_year = 72;
           518 | 	_tm.tm_isdst = 0;
           519 | 	_tm.tm_mday = 0;
           520 | 	time_t r = mktime(&_tm);
           521 | 	r = 63072000;
           522 | 	//printf("epoch:%u r:%u diff:%uÖn",(unsigned long)t19720101,r,(unsigned long )(t19720101-r));
           523 | 	return (t19720101-r);
           524 | ü
           525 |
           526 | const  time_t epoch = set_epoch();
           527 |
           528 |
           529 | char * formatTime(pULL tod)
           530 | ä
           531 | 	static char wÄ128Ü;
           532 | 	unsigned long t, rest, v, ss, mm, hh;
           533 | 	ULL tt = (*tod>>12)/1000;
           534 | 	t =tt%(1000*60*60*24);
           535 | 	rest = t%1000;
           536 | 	v = t/1000;
           537 | 	ss =  v%60;
           538 | 	v /= 60;
           539 | 	mm =  v%60;
           540 | 	hh =  v/60;
           541 | 	sprintf(w,"%2.2d:%2.2d:%2.2d.%3.3d",hh,mm,ss,rest);
           542 | 	return w;
           543 | ü
           544 |
           545 |
           546 |
           547 | char * var(char * v0,int i0,char * v1 = NULL,int i1 = 0, char * v2 =NULL)
           548 | ä
           549 | 	static char retÄ256Ü;
           550 | 	strcpy(ret,v0);
           551 | 	sprintf(ret+strlen(ret),".%d",i0);
           552 | 	if (v1)
           553 | 	ä
           554 | 		strcat(ret,".");
           555 | 		strcat(ret,v1);
           556 |
           557 | 		if (v2)
           558 | 		ä
           559 | 			sprintf(ret+strlen(ret),".%d",i1);
           560 | 			strcat(ret,".");
           561 | 			strcat(ret,v2);
           562 | 		ü
           563 | 	ü
           564 | 	return strupr(ret);
           565 | ü
           566 |
           567 | typedef struct dscb DSCB;
           568 |
           569 | struct ext
           570 | ä
           571 | 	unsigned char flag ;
           572 | 	unsigned char seq;
           573 | 	short        CC;
           574 | 	short        HH;
           575 | 	short        hCC;
           576 | 	short        hHH;
           577 | ü;
           578 |
           579 | typedef struct ext EXT;
           580 |
           581 | static char _date2TextÄ80Ü;
           582 |
           583 | char * date2Text(unsigned int d)
           584 | ä
           585 |
           586 | 	int yy =d/0x10000;
           587 | 	int tt =d%0x10000;
           588 | 	int dayÄÜ = ä31,28,31,30,31,30,31,31,30,31,30,31ü;
           589 | 	if ( yy%4 == 0 )
           590 | 		dayÄ1Ü = 29;
           591 | 	int i = 0;
           592 | 	for(i;i<12;i++)
           593 | 		if ((tt-dayÄiÜ)<0) break;
           594 | 		else
           595 | 			tt-=dayÄiÜ;
           596 | 	i++;
           597 | 	sprintf(_date2Text,"%4.4d/%2.2d/%2.2d",yy+1900,i,tt);
           598 | 	return _date2Text;
           599 | ü
           600 |
           601 | int allocated(EXT * e)
           602 | ä
           603 | 	if (e->flag ==0 )
           604 | 		return 0;
           605 | 	else
           606 | 		return((e->hCC*15+e->hHH)-(e->CC*15+e->HH)+1);
           607 | ü
           608 |
           609 | unsigned int bit24Int(char * c)
           610 | ä
           611 | 	return(*(unsigned int *)(c-1)&0x007FFFFF);
           612 | ü
           613 |
           614 | struct CatInfo
           615 | ä
           616 | 	char type;
           617 | 	char dsnÄ44Ü;
           618 | 	char volÄ6Ü;
           619 | ü;
           620 |
           621 | typedef struct CatInfo CATINFO;
           622 |
           623 | struct ISPF_Stats
           624 | ä
           625 | 	unsigned int ver:8;
           626 | 	unsigned int mod:8;
           627 | 	unsigned int flags:8;
           628 | 	unsigned int mod_sec:8;
           629 |
           630 | 	unsigned int cr_date_rsv:8;
           631 | 	unsigned int cr_date_y:8;
           632 | 	unsigned int cr_date_d:12;
           633 | 	unsigned int cr_date_f:4;
           634 |
           635 | 	unsigned int mod_date_rsv:8;
           636 | 	unsigned int mod_date_y:8;
           637 | 	unsigned int mod_date_d:12;
           638 | 	unsigned int mod_date_f:4;
           639 |
           640 | 	unsigned int mod_hh:8;
           641 | 	unsigned int mod_mm:8;
           642 | 	short lines;
           643 |
           644 | 	short ilines;
           645 | 	short m_lines;
           646 |
           647 | 	char userÄ7Ü;
           648 | 	char rsvdÄ3Ü;
           649 | ü;
           650 |
           651 | typedef struct ISPF_Stats ISPF;
           652 |
           653 | int _rexxlist()
           654 | ä
           655 | 	char maskÄ45Ü;
           656 | 	char mmaskÄ9Ü;
           657 | 	bool dir = false;
           658 | 	bool migr = false;
           659 | 	bool debug = false;
           660 | 	bool exact = false;
           661 | 	CATINFO catinfo;
           662 |
           663 | 	if (argc < 2 )
           664 | 		return -1;
           665 | 	strcpy(mask,strupr(argvÄ1Ü));
           666 | 	for (int i =2;i<argc;i++)
           667 | 	ä
           668 | 		if ( strcasecmp(argvÄiÜ,"DIR")==0)
           669 | 		ä
           670 | 			dir = true;
           671 | 			if (i+1<argc)
           672 | 				strcpy(mmask,strupr(argvÄ++iÜ));
           673 | 			else
           674 | 				strcpy(mmask,"*");
           675 | 		ü
           676 | 		else
           677 | 			if ( strcasecmp(argvÄiÜ,"EXACT")==0)
           678 | 			ä
           679 | 				dir = true;
           680 | 				exact = true;
           681 | 				if (i+1<argc)
           682 | 					strcpy(mmask,strupr(argvÄ++iÜ));
           683 | 				else
           684 | 					strcpy(mmask,"*");
           685 | 			ü
           686 | 			else
           687 | 				if (strcasecmp(argvÄiÜ,"MIGR") == 0)
           688 | 					migr = true;
           689 | 				else
           690 | 					if (strcasecmp(argvÄiÜ,"DEBUG") == 0)
           691 | 						debug = true;
           692 |
           693 | 	ü
           694 | 	REXXVAR rexx(debug);
           695 | 	CmdService::debug = debug;
           696 | 	if (debug)
           697 | 		printf(" catalog:%s member:%sÖn",mask,mmask);
           698 | 	DsnCmdService serv;
           699 | 	int index = 0;
           700 | 	int rc = serv.cmd(mask,(char *)&catinfo);
           701 | 	while(rc==1)
           702 | 	ä
           703 | 		if (debug)
           704 | 			_dump("catalog",(char *)&catinfo,sizeof(catinfo));
           705 | 		if ((catinfo.type == 'A' ]] catinfo.type == 'C'))
           706 | 		ä
           707 | 			int online = memcmp("MIGRAT",catinfo.vol,sizeof(catinfo.vol));
           708 | 			index++;
           709 | 			rexx.set(var("DS",0),index);
           710 | 			rexx.set(var("DS",index,"dsn"),catinfo.dsn,sizeof(catinfo.dsn));
           711 | 			rexx.set(var("DS",index,"vol"),catinfo.vol,sizeof(catinfo.vol));
           712 | 			rexx.set(var("DS",index,"online"),online);
           713 | 			rexx.set(var("DS",index,"member"),0);
           714 |
           715 | 			if (online)
           716 | 			ä
           717 | 				DSCB f1dscb;
           718 | 				F3DSCB _f3dscb;
           719 | 				memset(&f1dscb,0,sizeof(f1dscb));
           720 |
           721 | 				memcpy(f1dscb.ds1dsnam,(char *)catinfo.dsn,sizeof(catinfo.dsn));
           722 | 				if (mvs()->Obtain((const char *)f1dscb.ds1dsnam,catinfo.vol,(char *)&f1dscb.ds1fmtid)==0)
           723 | 				ä
           724 | 					rexx.set(var("DS",index,"credt"),date2Text(bit24Int((char *)f1dscb.ds1credt)));
           725 | 					rexx.set(var("DS",index,"expdt"),date2Text(bit24Int((char *)f1dscb.ds1expdt)));
           726 | 					rexx.set(var("DS",index,"refdt"),date2Text(bit24Int((char *)f1dscb.ds1refd)));
           727 |
           728 | 					if (f1dscb.ds1dsorgÄ0Ü&ds1dsgps)
           729 | 						rexx.set(var("DS",index,"dsorg"),"PS");
           730 | 					else
           731 | 						if (f1dscb.ds1dsorgÄ0Ü&ds1dsgpo)
           732 | 							rexx.set(var("DS",index,"dsorg"),"PO");
           733 | 						else
           734 | 							if (f1dscb.ds1dsorgÄ0Ü&ds1acbm)
           735 | 								rexx.set(var("DS",index,"dsorg"),"VSAM");
           736 | 							else
           737 | 								rexx.set(var("DS",index,"dsorg"),"????");
           738 | 					char recfmÄÜ = " ";
           739 | 					int ind = 0;
           740 | 					if (f1dscb.ds1recfm==ds1recfu)
           741 | 						recfmÄ0Ü = 'U';
           742 | 					else
           743 | 					ä
           744 | 						if (f1dscb.ds1recfm&ds1recff)
           745 | 							recfmÄ0Ü = 'F';
           746 | 						else
           747 | 							if (f1dscb.ds1recfm&ds1recfv)
           748 | 								recfmÄ0Ü = 'V';
           749 | 						if (f1dscb.ds1recfm&ds1recfb)
           750 | 							recfmÄ++indÜ = 'B';
           751 | 						if (f1dscb.ds1recfm&ds1recfa)
           752 | 							recfmÄ++indÜ ='A';
           753 | 						else
           754 | 							if (f1dscb.ds1recfm&ds1recmc)
           755 | 								recfmÄ++indÜ ='M';
           756 | 					ü
           757 | 					recfmÄind+1Ü = 0;
           758 | 					rexx.set(var("DS",index,"recfm"),recfm);
           759 | 					rexx.set(var("DS",index,"blksize"),int(*(short *)f1dscb.ds1blkl));
           760 | 					rexx.set(var("DS",index,"lrecl"),int(*(short *)f1dscb.ds1lrecl));
           761 | 					int alloc = allocated((EXT *)f1dscb.ds1ext1)+
           762 | 						allocated((EXT *)f1dscb.ds1ext2)+
           763 | 						allocated((EXT *)f1dscb.ds1ext3);
           764 | 					memcpy(_f3dscb.ds3ptrds,f1dscb.ds1ptrds,5);
           765 | 					if (debug)
           766 | 						_dump("F3DSCB addr",(char *)&_f3dscb.ds3ptrds,5);
           767 | 					while (memcmp(_f3dscb.ds3ptrds,nulls,5)&&(mvs()->Obtain((const char *)_f3dscb.ds3ptrds,catinfo.
           767 | vol,(char *)&_f3dscb)==0))
           768 | 					ä
           769 | 						if (debug)
           770 | 							_dump("F3DSCB",(char *)&_f3dscb,sizeof(_f3dscb));
           771 | 						EXT *  ext = (EXT * )&_f3dscb.ds3extnt;
           772 | 						for (int i =0;i<4;i++)
           773 | 							alloc+= allocated(ext+i);
           774 | 						ext = (EXT * )&_f3dscb.ds3adext;
           775 | 						for (int i =0;i<9;i++)
           776 | 							alloc+= allocated(ext+i);
           777 | 					ü
           778 | 					rexx.set(var("DS",index,"alloc"),alloc);
           779 | 					if (dir&&(f1dscb.ds1dsorgÄ0Ü&ds1dsgpo))
           780 | 					ä
           781 | 						char patternÄ128Ü="//";
           782 | 						memcpy(pattern+2,catinfo.dsn,sizeof(catinfo.dsn));
           783 | 						patternÄ46Ü =0;
           784 | 						if (strchr(pattern,' '))
           785 | 							*strchr(pattern,' ') = 0;
           786 |
           787 | 						strcat(pattern,"(*)");
           788 | 						/*
           789 | 						strcat(pattern,"(");
           790 | 						strcat(pattern,mmask);
           791 | 						strcat(pattern,")");
           792 | 						*/
           793 | 						DSNINFO dsninfo;
           794 | 						int mindex = 0;
           795 | 						memset(&dsninfo,0,sizeof(dsninfo));
           796 | 						int rcd = osdfind(&dsninfo,pattern);
           797 | 						if (debug)
           798 | 						ä
           799 | 							printf(" osdfind:%s %dÖn",pattern,rcd);
           800 | 							_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));
           801 | 						ü
           802 | 						while(rcd>=0)
           803 | 						ä
           804 | 							if ((|exact&&stcpma(dsninfo.mem,mmask))]](exact&&strcmp(dsninfo.mem,mmask)==0))
           805 | 							ä
           806 | 								mindex++;
           807 | 								rexx.set(var("DS",index,"member"),mindex);
           808 | 								rexx.set(var("DS",index,"member",mindex,"name"),dsninfo.mem);
           809 | 								rexx.set(var("DS",index,"member",mindex,"alias"),dsninfo.alias);
           810 |
           811 | 								if (dsninfo.user_data_halfwords*2 == sizeof(ISPF))
           812 | 								ä
           813 | 									ISPF * ispf =(ISPF *)dsninfo.user_data;
           814 | 									rexx.set(var("DS",index,"member",mindex,"size"),ispf->lines);
           815 | 									rexx.set(var("DS",index,"member",mindex,"user"),ispf->user);
           816 | 									rexx.set(var("DS",index,"member",mindex,"created"),date2Text(cvb(ispf->cr_date_y,2)*0x10000
           816 | +cvb(ispf->cr_date_d,3)));
           817 | 									rexx.set(var("DS",index,"member",mindex,"modified"),date2Text(cvb(ispf->mod_date_y,2)*0x100
           817 | 00+cvb(ispf->mod_date_d,3)));
           818 | 								ü
           819 | 								else
           820 | 								ä
           821 | 									rexx.set(var("DS",index,"member",mindex,"size"),"");
           822 | 									rexx.set(var("DS",index,"member",mindex,"user"),"");
           823 | 									rexx.set(var("DS",index,"member",mindex,"created"),"");
           824 | 									rexx.set(var("DS",index,"member",mindex,"modified"),"");
           825 | 								ü
           826 | 							ü
           827 | 							rcd = osdnext(&dsninfo);
           828 | 							if (debug)
           829 | 							ä
           830 | 								printf(" osdnext:%s %dÖn",pattern,rcd);
           831 | 								_dump(pattern,(char *)&dsninfo,sizeof(dsninfo));
           832 | 							ü
           833 | 						ü
           834 | 						osdquit(&dsninfo);
           835 | 					ü
           836 | 				ü
           837 | 				else
           838 | 				ä
           839 | 					rexx.set(var("DS",index,"credt"),"");
           840 | 					rexx.set(var("DS",index,"expdt"),"");
           841 | 					rexx.set(var("DS",index,"refdt"),"");
           842 | 					rexx.set(var("DS",index,"dsorg"),"");
           843 | 					rexx.set(var("DS",index,"recfm"),"");
           844 | 					rexx.set(var("DS",index,"lrecl"),"");
           845 | 					rexx.set(var("DS",index,"blksize"),"");
           846 | 					rexx.set(var("DS",index,"alloc"),"");
           847 |
           848 | 				ü
           849 | 			ü
           850 | 		ü
           851 | 		rc = serv.cmd(NULL,(char *)&catinfo);
           852 | 	ü
           853 | ü
 ================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 853.1: CCN6101 (W) A return value of type "int" is expected.
           854 |
           855 | #define DEF_TAB_SIZE  128000
           856 | class tablePull
           857 | ä
           858 | private:
           859 | 	char tablenameÄ256Ü;
           860 | 	FILE * table;
           861 | 	char * t;
           862 | 	char * p ;
           863 | 	size_t rl;
           864 | 	size_t total ;
           865 | 	size_t offset;
           866 | 	bool ok;
           867 |
           868 | public:
           869 | 	tablePull(const char *n)
           870 | 	ä
           871 | 		char wÄ256Ü;
           872 | 		ok = false;
           873 | 		strcpy(tablename,n);
           874 | 		table = fopen(genOpenName(tablename,w),"rb");
           875 | 		if (table==NULL)
           876 | 		ä
           877 | 			printf(" unbale to open:%sÖn",tablename);
           878 | 			return ;
           879 | 		ü
           880 | 		t  = (char *)malloc(DEF_TAB_SIZE);
           881 | 		p = t;
           882 | 		total = DEF_TAB_SIZE;
           883 | 		rl = total;
           884 |
           885 | 		if (t==NULL)
           886 | 		ä
           887 | 			printf(" unbale to allocte:%s bytesÖn",total);
           888 | 			return ;
           889 | 		ü
           890 | 		bool cont = true;
           891 |
           892 | 		while(cont)
           893 | 		ä
           894 | 			size_t rlr =fread(p,1,rl,table);
           895 | 			if (rlr>=0)
           896 | 				total +=rlr;
           897 | 			if (feof(table)]]rlr<rl)
           898 | 				cont = false;
           899 | 			else
           900 | 			ä
           901 | 				t =(char *)realloc(t,total*2);
           902 | 				p = t+rl;
           903 | 				rl = total;
           904 | 				total*=2;
           905 | 				if (t==NULL)
           906 | 				ä
           907 | 					printf(" unbale to allocte:%s bytesÖn",total);
           908 | 					return ;
           909 | 				ü
           910 | 			ü
           911 | 		ü
           912 | 		fclose(table);
           913 | 		offset = 0;
           914 | 		ok = true;
           915 | 		p = t;
           916 | 	ü
           917 |
           918 | 	unsigned short getShort()
           919 | 	ä
           920 | 		if  ((total-offset)>sizeof(short))
           921 | 		ä
           922 | 			unsigned short r = *(unsigned short *)p;
           923 | 			p+=sizeof(short);
           924 | 			offset-=sizeof(short);
           925 | 			return r;
           926 | 		ü
           927 | 		else
           928 | 			return -1;
           929 | 	ü
           930 |
           931 | 	char * getString(size_t l)
           932 | 	ä
           933 | 		if  ((total-offset)>l)
           934 | 		ä
           935 | 			char * c = (char *)malloc(l+1);
           936 | 			memcpy(c,p,l);
           937 | 			cÄlÜ = 0;
           938 | 			p+=l;
           939 | 			offset-=l;
           940 | 			return c;
           941 | 		ü
           942 | 		else
           943 | 			abort();
           944 | 		return NULL;
           945 | 	ü
           946 |
           947 | 	bool isOk()
           948 | 	ä
           949 | 		return ok;
           950 | 	ü
           951 | ü;
           952 |
           953 | int _rexx4tab()
           954 | ä
           955 | 	bool debug = false;
           956 | 	for (int i =3;i<argc;i++)
           957 | 	ä
           958 | 		if (strcasecmp(argvÄiÜ,"DEBUG") == 0)
           959 | 			debug = true;
           960 |
           961 | 	ü
           962 | 	REXXVAR rexx(debug);
           963 | 	char * variablesÄ256Ü;
           964 | 	char  tableÄ9Ü;
           965 | 	size_t numrows = 0;
           966 | 	memset(&variables,0,sizeof(variables));
           967 | 	tablePull pull(argc<2?"//DD:TABLE":argvÄ1Ü);
           968 | 	//tablePull pull("//esa.maint.isptlib(infocust)");
           969 |
           970 | 	char * tablename = (argc<3?"TABLE":argvÄ2Ü);
           971 | 	if (|pull.isOk())
           972 | 		return 8;
           973 | 	char * head =pull.getString(pull.getShort());
           974 | 	memcpy(table,head+10,8);
           975 | 	numrows = *(size_t *)(head+32);
           976 | 	short temp = pull.getShort();
           977 | 	char * cols = pull.getString(temp);
           978 | 	size_t numcols = temp/16;
           979 | 	rexx.set(var(tablename,0),numrows);
           980 | 	rexx.set(var(tablename,0,"TABLE"),table);
           981 | 	rexx.set(var(tablename,0,"COLS",0),numcols);
           982 | 	for (int o =0 , i=0;colsÄoÜ;o+=16,i++)
           983 | 	ä
           984 | 		variablesÄiÜ =(char *) malloc(9);
           985 | 		memset(variablesÄiÜ,0,9);
           986 | 		for (int j=0;j<8&&(*(cols+o+2+j)-' ');j++)
           987 | 			*(variablesÄiÜ+j) = *(cols+o+2+j);
           988 | 		rexx.set(var(tablename,0,"COLS",i+1,"NAME"),variablesÄiÜ);
           989 | 	ü
           990 | 	short rl = 0;
           991 | 	size_t rowindex = 0;
           992 | 	while((rl=pull.getShort()) >0&& rowindex<numrows)
           993 | 	ä
           994 | 		char * row = pull.getString(rl);
           995 | 		short numvar = *(short *)(row+4);
           996 | 		free(row);
           997 | 		short rowDataLength =pull.getShort();
           998 | 		char * rowdata =pull.getString(rowDataLength);
           999 | 		rowindex++;
          1000 | 		for(int i =0;i<numvar;i++)
          1001 | 		ä
          1002 | 			short offset = (*(short *)(rowdata+i*2))-22;
          1003 | 			if (offset>0&&offset<rowDataLength)
          1004 | 			ä
          1005 | 				short length = *(short *)(rowdata+offset);
          1006 | 				if (length > 0&& (offset+length)<rowDataLength)
          1007 | 				ä
          1008 | 					char * value =(char *)malloc(length+1);
          1009 | 					memcpy(value,rowdata+offset+2,length);
          1010 | 					valueÄlengthÜ = 0;
          1011 | 					rexx.set(var(tablename,rowindex,variablesÄiÜ),value,length);
          1012 | 					free(value);
          1013 | 				ü
          1014 | 				else
          1015 | 					rexx.set(var(tablename,rowindex,variablesÄiÜ),"");
          1016 | 			ü
          1017 | 			else
          1018 | 				rexx.set(var(tablename,rowindex,variablesÄiÜ),"");
          1019 |
          1020 | 		ü
          1021 | 		free(rowdata);
          1022 | 		free(row);
          1023 | 	ü
          1024 | ü
 ================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1024.1: CCN6101 (W) A return value of type "int" is expected.
          1025 | int intDebug = 0;
          1026 |
          1027 | char * cmdnext(UssCmdService &cmd,char * w=NULL)
          1028 | ä
          1029 | 	char * c =cmd.next(w);
          1030 | 	//  if (intDebug)
          1031 | 	//  printf("%sÖn",c);
          1032 | 	return c;
          1033 | ü
          1034 | _browselogger()
          1035 | ä
          1036 | 	printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold"
          1036 | ));
          1037 | 	int rc = mvs()->LoggerOpen(argvÄ2Ü);
          1038 | 	const char * pointer = NULL;
          1039 | 	char dateÄ32Ü;
          1040 | 	*(int *)date =(13*3600+1*60+1)*100;
          1041 | 	strcpy(date+4,"2010242");
          1042 | 	size_t length = 0;
          1043 | 	size_t * lP   = &length;
          1044 | 	pasm PASM = NULL;
          1045 | 	//BrowseLogger(const char * & addr,size_t & length,int direction,int all,char * date_time)
          1046 | 	//return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)d
          1046 | ate_time));
          1047 |
          1048 | 	/* 18/11/05 LOGGER support
          1049 | 	* 13/01/06 browse logger
          1050 | 	*---------------------------------------------------------------------*
          1051 | 	* LOGGER support                                                     *
          1052 | 	* +0 0 connect to logger stream                                      *
          1053 | 	*  -1 discoonect                                                     *
          1054 | 	*   1 log a request                                                  *
          1055 | 	*   2 read logger from oldtoyoung                                    *
          1056 | 	*   3 read log from youngtoold (parm+8 contain addr , length)        *
          1057 | 	*   a stream to log                                                  *
          1058 | 	* +4 stream or logger name address                                   *
          1059 | 	* +8 length of the stream                                            *
          1060 | 	* +c time stemp field pointer                                        *
          1061 | 	*   +0 binary time value in .01 sec                                  *
          1062 | 	*   +4 DATE in YYYYDDD    char format                                *
          1063 | 	*---------------------------------------------------------------------*/
          1064 |
          1065 | 	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),atoi(argvÄ4Ü),NULL)==0)
          1066 | 	ä
          1067 | 		PASM = mvs()->getpasm();
          1068 | 		//if (debugF)
          1069 |
          1070 | 		if (0)
          1071 | 		ä
          1072 | 			_dump("logger rc",(char *)&(PASM->asm_rc),256);
          1073 | 			_dump("asm logger",(char *)&(PASM->asm_logger_length),
          1074 | 				(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
          1075 | 			_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
          1076 | 			_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
          1077 | 			printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
          1078 | 		ü
          1079 | 		unsigned short ubl = *(unsigned short *)pointer;
          1080 | 		int bl = ubl;
          1081 | 		bl-=4;
          1082 | 		//if (debugF)
          1083 |
          1084 | 		if (0)
          1085 | 			printf("length:%u bl:%d ubl:%uÖn",length,bl,ubl);
          1086 | 		char * p = (char *)pointer+4;
          1087 | 		while(bl>0)
          1088 | 		ä
          1089 | 			unsigned short url;
          1090 | 			url = *(unsigned short *)p;
          1091 | 			int rl = url;
          1092 | 			//  if (debugF)
          1093 | 			//    printf("head length:%uÖn",rl);
          1094 | 			if (rl==72)
          1095 | 			ä
          1096 | 				//  if (debugF)
          1097 | 				//    _dump("head",p,rl);
          1098 | 				p+=rl;
          1099 | 				bl-=rl;
          1100 | 				length-=rl;
          1101 | 				rl = *(short *)p;
          1102 | 				if (bl >0 && rl>0 && bl>rl)
          1103 | 				ä
          1104 | 					//  if (debugF)
          1105 | 					//  printf("rec length:%u (bl:%d)Ön",rl,bl);
          1106 | 					//  if (debugF)
          1107 | 					//    _dump("SMF rec",p,rl);
          1108 | 					bool idflag = false;
          1109 | 					if (printSMF(p,idflag,rl)==5)
          1110 | 						return 0;
          1111 | 					p+=rl;
          1112 | 					bl-=rl;
          1113 | 					length=-rl;
          1114 | 				ü
          1115 | 				else
          1116 | 					bl = 0;
          1117 | 			ü
          1118 | 			else
          1119 | 			ä
          1120 | 				bl = 0;
          1121 | 			ü
          1122 | 		ü
          1123 | 		//printf(" rc:%d p:%p l:%dÖn",rc,pointer,length);
          1124 | 	ü
          1125 | 	//printf(" rc:%d p:%p l:%dÖn",rc,pointer,length);
          1126 | 	if (debugF)
          1127 | 	ä
          1128 | 		_dump("asm logger",(char *)&(PASM->asm_logger_length),
          1129 | 			(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
          1130 | 		_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
          1131 | 		_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
          1132 | 		printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
          1133 | 	ü
          1134 | 	mvs()->LoggerClose();
          1135 | 	for(int i =0;i<255;i++)
          1136 | 		if (countersÄiÜ)
          1137 | 			printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
          1138 | 	return 0;
          1139 | ü
          1140 |
          1141 | int _rct()
          1142 | ä
          1143 | 	cvtP      cvt = *(cvtP* )0x10;
          1144 | 	rmctP   rmct = (rmctP)cvt->cvtopctp;
          1145 | 	cctP     cct  = (cctP)rmct->rmctcct;
          1146 | 	ictP     ict  = (ictP)rmct->rmctict;
          1147 | 	mctP     mct  = (mctP)rmct->rmctmct;
          1148 | 	char buffÄ256Ü;
          1149 | 	buffÄ0Ü =0;
          1150 | 	FILE * reply = popen("uname -Ia","r");
          1151 | 	if (reply==NULL]]fgets(buff,sizeof(buff),reply)<=0)
          1152 | 		printf(" popen error %sÖn",strerror(errno));
          1153 | 	else
          1154 | 		fclose(reply);
          1155 |
          1156 | 	printf("System:%s Online CPU Count:%d RealStorage Size:%d (Mbyte)Ön",buff,cct->ccvrcpct,cvt->cvtrls
          1156 | tg/1024);
          1157 | 	int lihb = ict->icvslihb;
          1158 | 	int pib = ict->iccend._icvtpib;
          1159 | 	for(int i =0;i<6;i++)
          1160 | 	ä
          1161 | 		sleep(10);
          1162 | 		char ttÄ32Ü;
          1163 | 		char fmÄÜ = "%H:%M:%S ";
          1164 | 		formatTime(tt,sizeof(tt),fm);
          1165 | 		printf(" %s ======================================Ön CPU utilization:%d %% Available Frame Count:%
          1165 | d Ön",tt,cct->ccvutilp,cct->ccvlgfmc);
          1166 | 		printf(" I/O interrupt rates:: % d %dÖn",ict->icvslihb-lihb,ict->iccend._icvtpib-pib);
          1167 | 		printf(" Paging Rate:%dÖn",mct->mcvsipr);
          1168 | 		_dump("CCT",(char *)cct,sizeof(*cct));
          1169 | 		lihb = ict->icvslihb;
          1170 | 		pib = ict->iccend._icvtpib;
          1171 | 	ü
          1172 | 	return 0;
          1173 | ü
          1174 |
          1175 | int _spawn()
          1176 | ä
          1177 | 	pid_t child;
          1178 | 	struct inheritance inherit;
          1179 | 	memset(&inherit,0,sizeof(inherit));
          1180 | 	int fd_count =  0;
          1181 | 	int fd_mapÄ1Ü ;
          1182 |
          1183 | 	const char *c_argvÄ10Ü, *c_envpÄ10Ü;
          1184 | 	c_argvÄ0Ü="mvsproc";
          1185 | 	int i = 0;
          1186 | 	for (i =1;i<=argc&&i<10;i++)
          1187 | 		c_argvÄiÜ = argvÄiÜ;
          1188 | 	c_argvÄ++iÜ = 0;
          1189 | 	char wÄ256Ü;
          1190 | 	sprintf(w,"_BPX_ACCOUNT=%s",argvÄ1Ü);
          1191 | 	c_envpÄ0Ü=w;
          1192 | 	c_envpÄ1Ü="_BPX_SHAREAS=NO";
          1193 | 	c_envpÄ2Ü="_BPX_JOBNAME=TTTTTTTT";
          1194 | 	c_envpÄ3Ü=NULL;
          1195 |
          1196 | 	/* Spawn the child process */
          1197 | 	child=spawnp("mvsproc", fd_count, NULL, &inherit, c_argv, c_envp);
          1198 | 	if(child==-1)
          1199 | 	ä
          1200 | 		printf("spawn error:%sÖn",strerror(errno));
          1201 | 		return(8);
          1202 | 	ü
          1203 | 	printf(" child:%dÖn",child);
          1204 | 	int status = 0;
          1205 | 	if (wait(&status)==-1)
          1206 | 		printf(" wait error:%s",strerror(errno));
          1207 | 	return 0;
          1208 | ü
          1209 |
          1210 | int _spawned()
          1211 | ä
          1212 | 	//FILE *fp=fopen("spawntest.out","w");
          1213 | 	int i = 0;
          1214 | 	printf( "Environment:Ön");
          1215 | 	char *e = 0;
          1216 | 	char **env=environ;
          1217 |
          1218 | 	while(e=envÄi++Ü)
          1219 | 		printf( "%sÖn", e);
          1220 | 	printf( "ÖnÖn");
          1221 | 	i=0;
          1222 | 	printf("Args:Ön");
          1223 | 	while(e=argvÄi++Ü)
          1224 | 		printf("%sÖn", e);
          1225 | 	printf("ÖnÖn");
          1226 | 	return 0;
          1227 |
          1228 | ü
          1229 |
          1230 | int _brsmf()
          1231 | ä
          1232 | 	return _browselogger();
          1233 | ü
          1234 |
          1235 |
          1236 | typedef struct r79cchnl * R79celem;
          1237 | typedef struct smf79pro * Smf79pro;
          1238 | typedef struct r79cchnl   R79cchnl;
          1239 | typedef struct r793     * R793;
          1240 | #if (0)
          1241 | '00'X='00X:UNKNOWN'                              /*UNDEF*/
          1242 | '01'X='01X:PARALLEL BLOCK MPX'                   /*BLOCK*/
          1243 | '02'X='02X:PARALLEL BYTE MPX'                    /*BYTE*/
          1244 | '03'X='03X:ESCON POINT TO POINT'                 /*CNC_P*/
          1245 | '04'X='04X:ESCON SWITCHED OR POINT TO POINT'     /*CNC_?*/
          1246 | '05'X='05X:ESCON SWITCHED POINT TO POINT'        /*CNC_S*/
          1247 | '06'X='06X:ESCON PATH TO A BLOCK CONVERTER'      /*CVC*/
          1248 | '07'X='07X:NATIVE INTERFACE'                     /*NTV*/
          1249 | '08'X='08X:CTC POINT TO POINT'                   /*CTC_P*/
          1250 | '09'X='09X:CTC SWITCHED POINT TO POINT'          /*CTC_S*/
          1251 | '0A'X='0AX:CTC SWITCHED OR POINT TO POINT'       /*CTC_?*/
          1252 | '0B'X='0BX:COUPLING FACILITY SENDER'             /*CFS*/
          1253 | '0C'X='0CX:COUPLING FACILITY RECEIVER'           /*CFR*/
          1254 | '0D'X='0DX:UNKNOWN'                              /*UNDEF*/
          1255 | '0E'X='0EX:UNKNOWN'                              /*UNDEF*/
          1256 | '0F'X='0FX:ESCON PATH TO A BYTE CONVERTER'       /*CBY*/
          1257 | '10'X='10X:OSA EXPRESS'                          /*OSE*/
          1258 | '11'X='11X:OSA DIRECT EXPRESS'                   /*OSD*/
          1259 | '12'X='12X:OSA CHANNEL'                          /*OSA*/
          1260 | '13'X='13X:INTERNAL SYSTEM DEVICE'               /*ISD*/
          1261 | '14'X='14X:HSSI OPEN SYSTEM ADAPTER CHANNEL'     /*OSC*/
          1262 | '15'X='15X:ETHERNET OPEN SYSTEM ADAPTER CHANL'   /*OSN*/
          1263 | '16'X='16X:CLUSTER BUS SENDER'                   /*CBS*/
          1264 | '17'X='17X:CLUSTER BUS RECEIVER'                 /*CBR*/
          1265 | '18'X='18X:INTERNAL COUPLING ISC SENDER'         /*ICS*/
          1266 | '19'X='19X:INTERNAL COUPLING ISC RECEIVER'       /*ICR*/
          1267 | '1A'X='1AX:FICON POINT TO POINT'                 /*FC */
          1268 | '1B'X='1BX:FICON SWITCHED'                       /*FC_S*/
          1269 | '1C'X='1CX:FICON TO ESCON BRIDGE'                /*FCV*/
          1270 | '1D'X='1DX:FICON INCOMPLETE'                     /*FC_?*/
          1271 | '1E'X='1EX:DIRECT SYSTEM DEVICE'                 /*DSD */
          1272 | '1F'X='1FX:EMULATED I/O'                         /*EIO */
          1273 | '20'X='20X:RESERVED'                             /*UNDEF*/
          1274 | '21'X='21X:INTEGRATED CLUSTER BUS PEER'          /*CBP*/
          1275 | '22'X='22X:COUPLING FACILITY PEER'               /*CFP*/
          1276 | '23'X='23X:INTERNAL COUPLING PEER'               /*ICP*/
          1277 | '24'X='24X:INTERNAL QUEUED DIRECT COMM'          /*IQD*/
          1278 | '25'X='25X:FCT CHANNEL'                          /*FCP*/
          1279 | '26'X='26X:COUPLING OVER INFINIBAND'             /*CIB*/
          1280 | '30'X='30X:OSA ZBX DATA'                         /*OSX*/
          1281 | '31'X='31X:OSA ZBX MANAGEMENT'                   /*OSM*/
          1282 | #endif
          1283 | #define UINTF(n) (*(unsigned int *)(n))
          1284 | #define INTF(n) (*(signed int *)(n))
          1285 |
          1286 | //============================================================================
          1287 |
          1288 | class line;
          1289 | class dataset;
          1290 | class jesJcl;
          1291 | class DD;
          1292 | class DDs;
          1293 | class STEP;
          1294 |
          1295 | static const int k32 = 32768;
          1296 | static const int k1  = 1024;
          1297 |
          1298 | enum lineType
          1299 | ä
          1300 | 	unknown        =0,
          1301 | 	execStmt      =1,
          1302 | 	steplibStmt    =2,
          1303 | 	steplibStmtConcat =3,
          1304 | 	ddStmt        =4,
          1305 | 	ddStmtConcat  =5,
          1306 | 	inlineStmt    =6,
          1307 | 	inlineData    =7,
          1308 | 	sysoutStmt    =8
          1309 | ü;
          1310 |
          1311 |
          1312 | static const char * JCL_COMMENT        = "//*";
          1313 | static const char * JCL_COMMENT_XX    = "XX*";
          1314 | static const char * JCL_JES2          = "/*";
          1315 | static const char * JCL_EXEC_PGM      = "PGM=";
          1316 | static const char * JCL_EXEC_PARM     = "PARM=";
          1317 | static const char * JCL_PROC          = "++";
          1318 | static const char * JCL_SUBSTITUTION  = "IEFC653I SUBSTITUTION JCL - ";
          1319 | static const char * JCL_DD_STMT       = "DD";
          1320 | static const char * JCL_EXEC_STMT     = "EXEC";
          1321 | static const char * JCL_STEPLIB_STMT  = "STEPLIB";
          1322 | static const char * JCL_SYSIN         = "*";
          1323 | static const char * JCL_SYSIN_DATA    = "DATA";
          1324 | static const char * JCL_SYSIN_DATA_DLM= "DATA,DLM=";
          1325 | static const char * JCL_SYSOUT        = "SYSOUT=";
          1326 |
          1327 | const char * lineTypeTextÄÜ =
          1328 | ä
          1329 | 	"unknown",
          1330 | 	"execStmt",
          1331 | 	"steplibStmt",
          1332 | 	"steplibStmtConcat",
          1333 | 	"ddStmt",
          1334 | 	"ddStmtConcat",
          1335 | 	"inlineStmt",
          1336 | 	"inlineData",
          1337 | 	"sysoutStmt"
          1338 | ü;
          1339 |
          1340 | const char * datasetStatusTextÄÜ=
          1341 | ä
          1342 | 	"unknown",
          1343 | 	"dumpOk",
          1344 | 	"restoreOk",
          1345 | 	"markedForDump",
          1346 | 	"markedForRestore",
          1347 | 	"error"
          1348 | ü;
          1349 |
          1350 | const  char *  datasetDispTextÄÜ =
          1351 | ä
          1352 | 	"unknownDisp",
          1353 | 	"temporary",
          1354 | 	"input",
          1355 | 	"output",
          1356 | 	"jes2",
          1357 | 	"instream",
          1358 | 	"included",
          1359 | 	"excluded"
          1360 | 	"errorDisp",
          1361 | 	NULL
          1362 | ü;
          1363 |
          1364 |
          1365 | struct _jclType ä
          1366 | 	char * n;
          1367 | 	int   t;
          1368 | ü;
          1369 |
          1370 | typedef struct _jclType jclType;
          1371 | jclType jclTypesÄÜ=ä
          1372 | 	ä"JOB",0ü,
          1373 | 	ä"OUTPUT",1ü,
          1374 | 	ä"SET",2ü,
          1375 | 	ä"INCLUDE",3ü,
          1376 | 	ä"JCLLIB",4ü,
          1377 | 	ä"IF",5ü,
          1378 | 	ä"ENDIF",6ü,
          1379 | 	ä"ELSE",7ü,
          1380 | 	ä"COMMAND",8ü,
          1381 | 	ä"JOBLIB",9ü,
          1382 | 	ä"CTL",10ü,
          1383 | 	ä"ENDCTL",11ü,
          1384 | 	ä"XMIT",12ü,
          1385 | 	ä"PROC",13ü,
          1386 | 	ä"PEND",14ü,
          1387 | 	ä"EXEC",20ü,
          1388 | 	ä"DD",24ü,
          1389 | 	äNULL,-1ü
          1390 | ü;
          1391 |
          1392 | static const int TYPE_EXEC = 20;
          1393 | static const int TYPE_DD   = 24;
          1394 | static const int oS = 10;
          1395 | static const int oN = 12;
          1396 |
          1397 | static char actualStepNameÄ9Ü;
          1398 | static char actualProcstepNameÄ9Ü;
          1399 | static STEP * actualStep;
          1400 |
          1401 | class line:public chainE
          1402 | ä
          1403 | private:
          1404 | 	DD * ddP;
          1405 | 	dataset * datasetP;
          1406 | 	lineType type;
          1407 | public:
          1408 | 	line(const char *);
          1409 | 	ßline()
          1410 | 	äü
          1411 | 	lineType getLineType()
          1412 | 	ä
          1413 | 		return type;
          1414 | 	ü
          1415 | 	char * getLine()
          1416 | 	ä
          1417 | 		return chainEid;
          1418 | 	ü
          1419 | 	DD * getDD()
          1420 | 	ä
          1421 | 		return ddP;
          1422 | 	ü
          1423 | 	dataset * getDataset()
          1424 | 	ä
          1425 | 		return datasetP;
          1426 | 	ü
          1427 | ü;
          1428 |
          1429 | class DD:public chainE
          1430 | ä
          1431 | private:
          1432 | 	int index;
          1433 | 	line *   lineP;
          1434 | 	char *   member;
          1435 | public:
          1436 | 	DD(char * n,int i = 0,line * l = NULL):chainE(n)
          1437 | 	ä
          1438 | 		JOBENV::DEBUG(1,"DD:",n);
          1439 | 		index = i;
          1440 | 		lineP = l;
          1441 | 		member = NULL;
          1442 | 	ü
          1443 | 	ßDD()äü
          1444 | 	void setMember(const char * m)
          1445 | 	ä
          1446 | 		member = strdup(m);
          1447 | 	ü
          1448 | 	char * getMember()
          1449 | 	ä
          1450 | 		return member;
          1451 | 	ü
          1452 | 	int getIndex()
          1453 | 	ä
          1454 | 		return index;
          1455 | 	ü
          1456 | 	void setIndex(int i)
          1457 | 	ä
          1458 | 		index = i;
          1459 | 	ü
          1460 | 	char * put(char * b)
          1461 | 	ä
          1462 | 		sprintf(b,"%s Type:%s Concat:%d Member:%s ",
          1463 | 			chainEid,
          1464 | 			lineTypeTextÄint(lineP->getLineType())Ü,
          1465 | 			index,
          1466 | 			(member?member:""));
          1467 | 		return b;
          1468 | 	ü
          1469 | 	line * getLine()
          1470 | 	ä
          1471 | 		return lineP;
          1472 | 	ü
          1473 | ü;
          1474 |
          1475 | class DDs:public mCHAIN
          1476 | ä
          1477 | public:
          1478 | 	static char lastddÄ9Ü;
          1479 | 	static  int concatIndex;
          1480 | 	DDs():mCHAIN()
          1481 | 	ä
          1482 | 		memset(lastdd,0,sizeof(lastdd));
          1483 | 		concatIndex = 0;
          1484 | 	ü
          1485 | 	ßDDs()äü
          1486 | ü;
          1487 |
          1488 |
          1489 | class dataset:public chainE
          1490 | ä
          1491 | public:
          1492 | 	enum datasetDisp
          1493 | 	ä
          1494 | 		unknownDisp,
          1495 | 		temporary,
          1496 | 		input,
          1497 | 		output,
          1498 | 		jes2,
          1499 | 		instream,
          1500 | 		included,
          1501 | 		excludedDisp,
          1502 | 		errorDisp
          1503 | 	ü;
          1504 | 	enum datasetStatus
          1505 | 	ä
          1506 | 		unknown,
          1507 | 		dumpOk,
          1508 | 		restoreOk,
          1509 | 		markedForDump,
          1510 | 		markedForRestore,
          1511 | 		error
          1512 | 	ü;
          1513 | private:
          1514 | 	DD * ddListÄ256Ü;
          1515 | 	int iDdnames;
          1516 | 	datasetDisp  disp;
          1517 | 	datasetStatus status;
          1518 | 	char * newDsn;
          1519 | 	long long size;
          1520 |
          1521 | public:
          1522 | 	static datasetStatus name2Status(const char * n)
          1523 | 	ä
          1524 | 		if (strcasecmp(n,"unknown")==0)
          1525 | 			return unknown;
          1526 | 		else
          1527 | 			if (strcasecmp(n,"dumpOk")==0)
          1528 | 				return dumpOk;
          1529 | 			else
          1530 | 				if (strcasecmp(n,"restoreOk")==0)
          1531 | 					return restoreOk;
          1532 | 				else
          1533 | 					if (strcasecmp(n,"markedForDump")==0)
          1534 | 						return markedForDump;
          1535 | 					else
          1536 | 						if (strcasecmp(n,"markedForRestore")==0)
          1537 | 							return markedForRestore;
          1538 | 						else
          1539 | 							return error;
          1540 | 	ü
          1541 |
          1542 | 	static datasetDisp name2Disp(const char *n)
          1543 | 	ä
          1544 | 		if (strcasecmp(n,"unknown")==0)
          1545 | 			return unknownDisp;
          1546 | 		else
          1547 | 			if (strcasecmp(n,"temporary")==0)
          1548 | 				return temporary;
          1549 | 		if (strcasecmp(n,"input")==0)
          1550 | 			return input;
          1551 | 		else
          1552 | 			if (strcasecmp(n,"output")==0)
          1553 | 				return output;
          1554 | 			else
          1555 | 				if (strcasecmp(n,"jes2")==0)
          1556 | 					return jes2;
          1557 | 				else
          1558 | 					if (strcasecmp(n,"instream")==0)
          1559 | 						return instream;
          1560 | 					else
          1561 | 						if (strcasecmp(n,"included")==0)
          1562 | 							return included;
          1563 | 						else
          1564 | 							if (strcasecmp(n,"excluded")==0)
          1565 | 								return excludedDisp;
          1566 |
          1567 | 							else
          1568 | 								return errorDisp;
          1569 | 	ü
          1570 |
          1571 | 	dataset(const char * n):chainE(n)
          1572 | 	ä
          1573 | 		JOBENV::DEBUG(1,"dataset:",(char *)n);
          1574 | 		status = unknown;
          1575 | 		disp = unknownDisp;
          1576 | 		memset(ddList,0,256*4);
          1577 | 		iDdnames = 0;
          1578 | 		size = 0;
          1579 | 		newDsn = "";
          1580 | 	ü
          1581 | 	ßdataset()
          1582 | 	äü
          1583 | 	void setNextDd(DD *d)
          1584 | 	ä
          1585 | 		ddListÄiDdnames++Ü = d;
          1586 | 		if (iDdnames>255)
          1587 | 			abort();
          1588 | 	ü
          1589 | 	void setStatus(datasetStatus s)
          1590 | 	ä
          1591 | 		status = s;
          1592 | 	ü
          1593 | 	void setDisp(datasetDisp d)
          1594 | 	ä
          1595 | 		disp=d;
          1596 | 	ü
          1597 | 	DD * getFirstDd()
          1598 | 	ä
          1599 | 		iDdnames = 0;
          1600 | 		return ddListÄiDdnames++Ü;
          1601 | 	ü
          1602 | 	DD * getNextDd()
          1603 | 	ä
          1604 | 		return ddListÄiDdnames++Ü;
          1605 | 	ü
          1606 | 	datasetStatus getStatus()
          1607 | 	ä
          1608 | 		return status;
          1609 | 	ü
          1610 | 	datasetDisp getDisp()
          1611 | 	ä
          1612 | 		return disp;
          1613 | 	ü
          1614 | 	char * getDsn()
          1615 | 	ä
          1616 | 		return chainEid;
          1617 | 	ü
          1618 | 	char * getNewDsn()
          1619 | 	ä
          1620 | 		return newDsn;
          1621 | 	ü
          1622 | 	void setNewDsn(const char * n)
          1623 | 	ä
          1624 | 		newDsn = strdup(n);
          1625 | 	ü
          1626 | 	long long getSize()
          1627 | 	ä
          1628 | 		return size;
          1629 | 	ü
          1630 | 	void setSize(long long s)
          1631 | 	ä
          1632 | 		size = s;
          1633 | 	ü
          1634 | 	char * put(char *b)
          1635 | 	ä
          1636 | 		sprintf(b,"%s Status:%s Disp:%s NewName:%s DDnames:",chainEid,
          1637 | 			datasetStatusTextÄint(status)Ü,
          1638 | 			datasetDispTextÄint(disp)Ü,
          1639 | 			newDsn);
          1640 | 		for(int i =0;i<iDdnames;i++)
          1641 | 			sprintf(b+strlen(b)," %s ",ddListÄiÜ->chainEid);
          1642 | 		return b;
          1643 | 	ü
          1644 | 	bool excluded()
          1645 | 	ä
          1646 | 		int r = 0;
          1647 | 		return ((r>0)?true:false);
          1648 | 	ü
          1649 | 	bool restore()
          1650 | 	ä
          1651 | 		return true;
          1652 | 	ü
          1653 | 	bool rename()
          1654 | 	ä
          1655 | 		return true;
          1656 | 	ü
          1657 | ü;
          1658 |
          1659 |
          1660 | class datasets:public mCHAIN
          1661 | ä
          1662 | public:
          1663 | 	datasets():mCHAIN()
          1664 | 	äü
          1665 | 	ßdatasets()
          1666 | 	äü
          1667 | 	void restored(const char * ,int);
          1668 | 	void dumped(const char *,int);
          1669 | 	void setSize(const char *,long long);
          1670 | ü;
          1671 |
          1672 |
          1673 |
          1674 | class STEP:public chainE
          1675 | ä
          1676 | private:
          1677 | 	char * pgm;
          1678 | 	char * parm;
          1679 | 	DDs * dds;
          1680 | 	char * step;
          1681 | 	char * procstep;
          1682 | public:
          1683 | 	STEP(const char * stepName,const char * procstepName,const char * _pgm,const char * _parm)
          1684 | 		:chainE(key(stepName,procstepName))
          1685 | 	ä
          1686 | 		JOBENV::DEBUG(1,"STEP",chainEid);
          1687 | 		if (_pgm)
          1688 | 			pgm=strdup(_pgm);
          1689 | 		if (_parm)
          1690 | 			parm = strdup(_parm);
          1691 | 		JOBENV::DEBUG(1,"PGM:",pgm);
          1692 | 		JOBENV::DEBUG(1,"PARM:",parm);
          1693 | 		if (stepName)
          1694 | 			step = strdup(stepName);
          1695 | 		if (procstepName)
          1696 | 			procstep = strdup(procstepName);
          1697 | 		dds = new DDs;
          1698 | 	ü
          1699 | 	ßSTEP()
          1700 | 	ä
          1701 | 		if (pgm)
          1702 | 			free(pgm);
          1703 | 		if (parm)
          1704 | 			free(parm);
          1705 | 		if (step)
          1706 | 			free(step);
          1707 | 		if (procstep)
          1708 | 			free(procstep);
          1709 | 		//  if (dds)
          1710 | 		//    delete dds;
          1711 | 	ü
          1712 | 	void addDD(DD * dd)
          1713 | 	ä
          1714 | 		dds->addlast(dd);
          1715 | 	ü
          1716 | 	void print()
          1717 | 	ä
          1718 | 		printf("%s PGM:%s PARM:%sÖn",chainEid,pgm,parm);
          1719 | 		DD * dd = (DD *)dds->goFirst();
          1720 | 		while(dd)
          1721 | 		ä
          1722 | 			printf(" %s dsn:%sÖn",dd->chainEid,dd->getLine()->getDataset()->getDsn());
          1723 | 			dd = (DD *)dds->goNext();
          1724 | 		ü
          1725 | 	ü
          1726 | 	char * getPgm()
          1727 | 	ä
          1728 | 		return pgm;
          1729 | 	ü
          1730 | 	char *getParm()
          1731 | 	ä
          1732 | 		return parm;
          1733 | 	ü
          1734 | 	DDs * getDDs()
          1735 | 	ä
          1736 | 		return dds;
          1737 | 	ü
          1738 | 	char * getStep()
          1739 | 	ä
          1740 | 		return step;
          1741 | 	ü
          1742 | 	char * getProcstep()
          1743 | 	ä
          1744 | 		return procstep;
          1745 | 	ü
          1746 | private:
          1747 | 	char * key(const char * s,const char * ps)
          1748 | 	ä
          1749 | 		char _keyÄ18Ü;
          1750 | 		memset(_key,0,sizeof(_key));
          1751 | 		sprintf(_key,"%s.%s",s?s:"",ps?ps:"");
          1752 | 		return _key;
 =======================================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1752.24: CCN6103 (W) The address of a local variable or temporary is used in a return
 expression.
          1753 | 	ü
          1754 | ü;
          1755 |
          1756 | class STEPs:public mCHAIN
          1757 | ä
          1758 | public:
          1759 | 	STEPs():mCHAIN()
          1760 | 	ä  ü
          1761 | 	ßSTEPs()
          1762 | 	äü
          1763 | 	void   print()
          1764 | 	ä
          1765 | 		STEP * step = (STEP *)goFirst();
          1766 | 		while(step)
          1767 | 		ä
          1768 | 			step->print();
          1769 | 			step = (STEP *)goNext();
          1770 | 		ü
          1771 | 	ü
          1772 | ü;
          1773 |
          1774 | DDs dds;
          1775 | STEPs steps;
          1776 | datasets datasetList;
          1777 |
          1778 |
          1779 | line::line(const char *b):chainE(b)
          1780 | ä
          1781 | 	ddP = NULL;
          1782 | 	datasetP = NULL;
          1783 | 	type = unknown;
          1784 | 	JOBENV::DEBUG(1,"line:",(char *)b);
          1785 |
          1786 | 	mvsSTRING lin(b), prefix, label, stmt, rest, dsn, member, disp, rest1, rest2;
          1787 | 	lin.split(label," ",stmt," ",rest);
          1788 | 	prefix = label,(0,2);
          1789 | 	label = label(2,strlen(label)-2);
          1790 |
          1791 | 	if (strcmp(stmt,JCL_EXEC_STMT)==0)
          1792 | 	ä
          1793 | 		type = execStmt;
          1794 | 		const char *pgmO = strstr((const char *)rest,JCL_EXEC_PGM);
          1795 | 		if (pgmO)
          1796 | 		ä
          1797 | 			/*
          1798 | 			if (strcmp(prefix,JCL_PROC) == 0)
          1799 | 			strcpy(actualProcstepName,label);
          1800 | 			else
          1801 | 			strcpy(actualStepName,label);
          1802 | 			*/
          1803 | 			char pgmÄ9Ü;
          1804 | 			memset(pgm,0,sizeof(pgm));
          1805 | 			for(int i=0;i<9&&restÄstrlen(JCL_EXEC_PGM)+iÜ-' '&&restÄstrlen(JCL_EXEC_PGM)+iÜ-',';i++)
          1806 | 				pgmÄiÜ=restÄstrlen(JCL_EXEC_PGM)+iÜ;
          1807 | 			const char * parmO = strstr((const char *)rest,JCL_EXEC_PARM);
          1808 | 			char parmÄ256Ü;
          1809 | 			memset(parm,0,sizeof(parm));
          1810 | 			char apost=0x7D;
          1811 | 			if (parmO)
          1812 | 			ä
          1813 | 				char term= *(parmO+strlen(JCL_EXEC_PARM));
          1814 | 				if (term == '(')
          1815 | 					term = ')';
          1816 | 				else
          1817 | 					if (term == 'Ö'')
          1818 | 						term = 'Ö'';
          1819 | 					else
          1820 | 						term = ' ';
          1821 | 				bool cont = true;
          1822 | 				int j =(parmO-rest)+strlen(JCL_EXEC_PARM);
          1823 | 				int jl = strlen((char *)rest+j);
          1824 | 				for(int i = 0;cont&&(i<255)&&(j<jl);i++,j++)
          1825 | 				ä
          1826 | 					if (term == ' ' &&(restÄjÜ==' ']]restÄjÜ==','))
          1827 | 						cont = false;
          1828 | 					else
          1829 | 					ä
          1830 | 						//if (term== 'Ö'' && restÄjÜ==term&&restÄj+1Ü-term)
          1831 | 						if (term== apost && restÄjÜ==term&&restÄj+1Ü-term)
          1832 | 							cont = false;
          1833 | 						else
          1834 | 							parmÄiÜ=restÄjÜ;
          1835 | 					ü
          1836 | 				ü
          1837 | 			ü
          1838 | 			actualStep = new STEP(actualStepName,actualProcstepName,pgm,parm);
          1839 | 			steps.addlast(actualStep);
          1840 | 		ü
          1841 | 	ü
          1842 | 	else
          1843 | 		if (strcmp(stmt,JCL_DD_STMT)==0)
          1844 | 		ä
          1845 | 			type = ddStmt;
          1846 | 			if (strlen(label))
          1847 | 			ä
          1848 | 				DDs::concatIndex = 0;
          1849 | 				strcpy(DDs::lastdd,label);
          1850 | 				if (strcmp(label,JCL_STEPLIB_STMT)==0)
          1851 | 					type = steplibStmt;
          1852 | 			ü
          1853 | 			else
          1854 | 			ä
          1855 | 				if (strcmp(DDs::lastdd,JCL_STEPLIB_STMT))
          1856 | 					type = ddStmtConcat;
          1857 | 				else
          1858 | 					type = steplibStmtConcat;
          1859 | 				DDs::concatIndex++;
          1860 | 			ü
          1861 | 			ddP = new DD(DDs::lastdd,DDs::concatIndex,this);
          1862 | 			dds.addlast(ddP);
          1863 |
          1864 | 			if (actualStep)
          1865 | 				actualStep->addDD(ddP);
          1866 |
          1867 | 			if (strcmp(rest,JCL_SYSIN)==0]]strcmp(rest,JCL_SYSIN_DATA)==0]]
          1868 | 				memcmp(JCL_SYSIN_DATA_DLM,(char *)rest,strlen(JCL_SYSIN_DATA_DLM)-1)==0)
          1869 | 				type = inlineStmt;
          1870 | 			else
          1871 | 				if (strstr((char *)rest,JCL_SYSOUT))
          1872 | 					type = sysoutStmt;
          1873 | 				else
          1874 | 				ä
          1875 | 					rest.parse(rest1,"DSN=",dsn,",",rest2);
          1876 | 					if (strlen(dsn))
          1877 | 					ä
          1878 | 						//ToDo GDG handling
          1879 | 						dsn.parse(dsn,"(",member,")",rest1);
          1880 | 						if (strlen(member))
          1881 | 							ddP->setMember(member);
          1882 | 						datasetP = (dataset *)datasetList.search(dsn);
          1883 | 						if (datasetP==NULL)
          1884 | 						ä
          1885 | 							datasetP = new dataset(dsn);
          1886 | 							datasetList.addlast(datasetP);
          1887 | 							if (strstr((char *)rest,"DISP=SHR")]]strstr((char *)rest,"DISP=MOD")]]strstr((char *)rest,"DI
          1887 | SP=KEEP"))
          1888 | 								datasetP->setDisp(dataset::input);
          1889 | 							else
          1890 | 								if (dsnÄ0Ü=='&')
          1891 | 									datasetP->setDisp(dataset::temporary);
          1892 | 								else
          1893 | 									datasetP->setDisp(dataset::output);
          1894 | 						ü
          1895 | 						datasetP->setNextDd(ddP);
          1896 | 					ü
          1897 | 					else
          1898 | 						type = unknown;
          1899 | 				ü
          1900 | 		ü
          1901 | ü
          1902 |
          1903 | jesJcl * jesjcl = NULL;
          1904 |
          1905 | class jesJcl
          1906 | ä
          1907 | private:
          1908 | 	mCHAIN lines;
          1909 | 	lineType type;
          1910 | 	bool    req;
          1911 | 	char bÄk32Ü;
          1912 | 	char bwÄk32Ü;
          1913 | 	int bOffset;
          1914 | 	FILE * file;
          1915 | 	int  t;
          1916 | 	int count ;
          1917 |
          1918 | public:
          1919 | 	jesJcl(FILE *f)
          1920 | 	ä
          1921 | 		JOBENV::DEBUG(1,"JESJCL construct");
          1922 | 		file = f;
          1923 | 		t = -1;
          1924 | 		bOffset = 0;
          1925 | 		count = 0;
          1926 | 		req = true;
          1927 | 	ü
          1928 | 	ßjesJcl()
          1929 | 	ä
          1930 | 		if (file)
          1931 | 			fclose(file);
          1932 | 	ü
          1933 | 	int parse();
          1934 | 	int generate(FILE *);
          1935 | private:
          1936 | 	void put(const char * format, ...)
          1937 | 	ä
          1938 | 		va_list args;
          1939 | 		va_start(args,format);
          1940 | 		vsprintf(bw,format,args);
          1941 | 		if (strchr(bw,'Ön'))
          1942 | 			*strchr(bw,'Ön')=0;
          1943 | 		if (file)
          1944 | 			fprintf(file,"%sÖn",bw);
          1945 | 		JOBENV::DEBUG(1," jcl:",bw);
          1946 | 		Msg(8120)<<bw<<eol;
          1947 | 		va_end(args);
          1948 | 	ü
          1949 | 	void splitLine(char * l)
          1950 | 	ä
          1951 | 		if (strlen(l)<70)
          1952 | 			put("//%s",l);
          1953 | 		else
          1954 | 		ä
          1955 | 			char * c = strchr(l,',');
          1956 | 			char sc;
          1957 | 			if (c)
          1958 | 			ä
          1959 | 				sc = *(c+1);
          1960 | 				*(c+1) = 0;
          1961 | 			ü
          1962 | 			put("//%s",l);
          1963 | 			if (c)
          1964 | 			ä
          1965 | 				*(c+1)=sc;
          1966 | 				*c =' ';
          1967 | 			ü
          1968 | 			splitLine(c);
          1969 | 		ü
          1970 | 	ü
          1971 | 	char * get(char *buf,size_t l)
          1972 | 	ä
          1973 | 		char * r = fgets(buf,l,file);
          1974 | 		JOBENV::DEBUG(1,buf);
          1975 | 		return r;
          1976 | 	ü
          1977 | ü;
          1978 |
          1979 | int jesJcl::generate(FILE *f)
          1980 | ä
          1981 | 	/*
          1982 | 	file = f;
          1983 | 	CHAINITER iter(lines);
          1984 | 	put("//* ");
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1984.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1985 | 	put("//* JOB     :%s",reqJobname);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1985.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1986 | 	put("//* JOBNUMBER:%s",reqJobnumber);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1986.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1987 | 	put("//* STEP    :%s",reqStepname);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1987.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1988 | 	put("//* PROCSTEP :%s",reqProcstep);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1988.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1989 | 	char ttÄ32Ü;
          1990 | 	char fmÄÜ = "%Y:%m:%d %H:%M:%S ";
          1991 | 	formatTime(tt,sizeof(tt),fm);
          1992 | 	put("//* AT      :%s",tt);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 1992.16: CCN5804 (W) The characters "/*" are detected in a comment.
          1993 | 	bool ok = true;
          1994 | 	line * l = NULL;
          1995 | 	while(ok&&(l=(line *)iter.next()))
          1996 | 	ä
          1997 | 	strcpy(b,l->chainEid);
          1998 | 	JOBENV::DEBUG(1,b);
          1999 | 	switch(l->getLineType())
          2000 | 	ä
          2001 | 	case execStmt:
          2002 | 	ä
          2003 | 	bÄ0Ü = bÄ1Ü = '/';
          2004 | 	if (strlen(b)>72)
          2005 | 	ä
          2006 | 	char * c = strstr(b,"PARM=");
          2007 | 	if (c)
          2008 | 	ä
          2009 | 	*c = 0;
          2010 | 	put("%s",b);
          2011 | 	*c ='P';
          2012 | 	count++;
          2013 | 	put("// %s",c);
          2014 | 	ü
          2015 | 	else
          2016 | 	put("%s",b);
          2017 | 	count++;
          2018 | 	ü
          2019 | 	break;
          2020 | 	case steplibStmt:
          2021 | 	case steplibStmtConcat:
          2022 | 	case ddStmt:
          2023 | 	case ddStmtConcat:
          2024 | 	if (l->getDD()&&l->getDataset())
          2025 | 	if (|l->getDataset()->excluded())
          2026 | 	ä
          2027 | 	char w0Ä128Ü;
          2028 | 	char wmÄ128Ü;
          2029 | 	char wcÄ128Ü;
          2030 | 	if (l->getDD()->getMember())
          2031 | 	sprintf(wm,"(%s)",l->getDD()->getMember());
          2032 | 	else
          2033 | 	wmÄ0Ü = 0;
          2034 | 	DD * dd = l->getDataset()->getFirstDd();
          2035 | 	if (dd->getIndex())
          2036 | 	//szm20080929    sprintf(wc,"C%7.7d",dd->getIndex());
          2037 | 	//szm20090812    sprintf(wc,".C%7.7d",dd->getIndex());
          2038 |
          2039 | 	sprintf(wc,"C%7.7d",dd->getIndex());
          2040 | 	else
          2041 | 	wcÄ0Ü = 0;
          2042 | 	//put("//* %s",l->getDataset()->chainEid);
 =================================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 2042.18: CCN5804 (W) The characters "/*" are detected in a comment.
          2043 | 	if (strlen(wc))
          2044 | 	sprintf(w0,"%s.%s",dd->chainEid,wc);
          2045 | 	else
          2046 | 	sprintf(w0,"%s",dd->chainEid);
          2047 | 	l->getDataset()->setNewDsn(w0);
          2048 | 	if (l->getLineType()==steplibStmt]]l->getLineType()==ddStmt)
          2049 | 	put("//%s DD DISP=SHR,DSN=%s..%s%s",l->getDD()->chainEid,parmÄrestHQÜ,w0,wm);
          2050 | 	else
          2051 | 	put("// DD DISP=SHR,DSN=%s..%s%s",parmÄrestHQÜ,w0,wm);
          2052 | 	count++;
          2053 | 	ü
          2054 | 	else
          2055 | 	//if (l->getDataset()->getDisp()==dataset::temporary)
          2056 | 	splitLine(b+2);
          2057 | 	break;
          2058 | 	case sysoutStmt:
          2059 | 	//put("//* %s",l->getDataset()->chainEid);
 =================================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 2059.18: CCN5804 (W) The characters "/*" are detected in a comment.
          2060 | 	put("//%s DD %s",l->getDD()->chainEid,parmÄrestSysoutÜ);
          2061 | 	count++;
          2062 | 	break;
          2063 | 	case inlineStmt:
          2064 | 	case inlineData:
          2065 | 	ä
          2066 | 	char wÄ128Ü;
          2067 | 	put("//* %s",b);
 ===============================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 2067.16: CCN5804 (W) The characters "/*" are detected in a comment.
          2068 | 	put("%s",b);
          2069 | 	sprintf(w,"%s(JESJCLIN)",parmÄworkFileNameÜ);
          2070 | 	FILE * jesJclinFile = fopen(genOpenName(w,b),"r");
          2071 | 	if (jesJclinFile)
          2072 | 	ä
          2073 | 	int ok = 1;
          2074 | 	JOBENV::DEBUG(1,"JESJCLIN read");
          2075 | 	while(ok>0&&fgets(b,sizeof(b),jesJclinFile))
          2076 | 	ä
          2077 | 	JOBENV::DEBUG(1,b);
          2078 | 	switch (ok)
          2079 | 	ä
          2080 | 	case 1:
          2081 | 	ä
          2082 | 	mvsSTRING lin,label , stmt, rest;
          2083 | 	if (memcmp(b,"//",2)==0&&bÄ2Ü-'*')
          2084 | 	ä
          2085 | 	lin = b+2;
          2086 | 	lin.split(label," ",stmt," ",rest);
          2087 | 	ü
          2088 | 	if (strcmp(label,reqStepname)==0 && strcmp(stmt,"EXEC")==0)
          2089 | 	ok = 2;
          2090 | 	ü
          2091 | 	break;
          2092 | 	case 2:
          2093 | 	ä
          2094 | 	mvsSTRING lin,label , stmt, rest;
          2095 | 	if (memcmp(b,"//",2)==0&&bÄ2Ü-'*')
          2096 | 	ä
          2097 | 	lin = b+2;
          2098 | 	lin.split(label," ",stmt," ",rest);
          2099 | 	ü
          2100 | 	if (strcmp(label,l->getDD()->chainEid)==0 && strcmp(stmt,"DD")==0)
          2101 | 	ok = 3;
          2102 | 	ü
          2103 | 	break;
          2104 | 	case 3:
          2105 | 	if (memcmp(b,"//",2))
          2106 | 	put("%s",b);
          2107 | 	else
          2108 | 	ok = 0;
          2109 | 	break;
          2110 | 	ü
          2111 | 	ü
          2112 | 	fclose(jesJclinFile);
          2113 | 	ü
          2114 | 	break;
          2115 | 	ü
          2116 | 	default:
          2117 | 	break;
          2118 | 	ü
          2119 | 	ü
          2120 | 	ü
          2121 | 	return count;
          2122 | 	*/
          2123 | ü
 ================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 2123.1: CCN6101 (W) A return value of type "int" is expected.
          2124 |
          2125 | int jesJcl::parse()
          2126 | ä
          2127 | 	char cÄk32Ü;
          2128 | 	while(get(c,sizeof(c)))
          2129 | 	ä
          2130 | 		if (memcmp(c+oS,JCL_COMMENT,strlen(JCL_COMMENT))==0]]
          2131 | 			memcmp(c+oS,JCL_COMMENT_XX,strlen(JCL_COMMENT_XX))==0]]
          2132 | 			memcmp(c+oS,JCL_JES2,strlen(JCL_JES2))==0)
          2133 | 			continue;
          2134 |
          2135 | 		cÄoS-1Ü = 0;
          2136 | 		int seq = atoi(c);
          2137 | 		char nameÄ9Ü;
          2138 | 		char stmtÄ9Ü;
          2139 | 		int i=0;
          2140 | 		int j=0;
          2141 | 		int o=0;
          2142 | 		char stepNameÄ9Ü;
          2143 | 		char procStepÄ9Ü;
          2144 |
          2145 | 		if (seq)
          2146 | 		ä
          2147 | 			if (bOffset>0)
          2148 | 			ä
          2149 | 				lines.addlast(new line(b));
          2150 | 				bOffset = 0;
          2151 | 			ü
          2152 | 			for(i=0;cÄoN+iÜ-' '&&i<8;i++)
          2153 | 				nameÄiÜ=cÄoN+iÜ;
          2154 | 			nameÄiÜ =0;
          2155 | 			for(;cÄoN+iÜ==' '&&i<70;i++);
          2156 | 			if (i>16)
          2157 | 				continue;
          2158 | 			for(o=oN+i,j=0;cÄo+jÜ-' '&&j<8;j++)
          2159 | 				stmtÄjÜ=cÄo+jÜ;
          2160 | 			stmtÄjÜ = 0;
          2161 | 			t = -1;
          2162 | 			for(i=0;jclTypesÄiÜ.t>=0&&strcmp(stmt,jclTypesÄiÜ.n);i++);
          2163 | 			t = jclTypesÄiÜ.t;
          2164 |
          2165 | 			if(jclTypesÄiÜ.t<20)
          2166 | 				continue;
          2167 |
          2168 | 			if (t==TYPE_EXEC)
          2169 | 			ä
          2170 | 				procStepÄ0Ü = 0;
          2171 | 				for(i=o+j;i<o+j+8&&cÄiÜ==' ';i++);
          2172 | 				if (memcmp(c+oS,"++",2)&&memcmp(c+oS,"XX",2))
          2173 | 					strcpy(stepName,name);
          2174 | 				else
          2175 | 					strcpy(procStep,name);
          2176 | 				//stop = req;
          2177 | 				JOBENV::DEBUG(1,"step:",stepName);
          2178 | 				JOBENV::DEBUG(1,"procStep:",procStep);
          2179 | 				strcpy(actualStepName,stepName);
          2180 | 				strcpy(actualProcstepName,procStep);
          2181 | 			ü
          2182 | 			strcpy(b,c+oS);
          2183 | 			bOffset=strlen(b);
          2184 | 			if (bOffset>0&&(memcmp(c+oS,"++",2)&&memcmp(c+oS,"XX",2)))
          2185 | 			ä
          2186 | 				lines.addlast(new line(b));
          2187 | 				bOffset = 0;
          2188 | 			ü
          2189 | 		ü
          2190 | 		else
          2191 | 		ä
          2192 | 			if (memcmp(c+oS,JCL_SUBSTITUTION,strlen(JCL_SUBSTITUTION))==0)
          2193 | 			ä
          2194 | 				if (t==TYPE_EXEC)
          2195 | 				ä
          2196 | 					sprintf(b,"//%s EXEC %s",name,c+oS+strlen(JCL_SUBSTITUTION));
          2197 | 					while(*(c+strlen(c)-1)==','&&get(c,sizeof(c)))
          2198 | 						sprintf(b+strlen(b),"%s",c+oS);
          2199 | 					lines.addlast(new line(b));
          2200 | 					bOffset = 0;
          2201 | 				ü
          2202 | 				else
          2203 | 					if (t==TYPE_DD)
          2204 | 					ä
          2205 | 						sprintf(b,"//%s DD %s",name,c+oS+strlen(JCL_SUBSTITUTION));
          2206 | 						while((*c+strlen(c)-1)==','&&get(c,sizeof(c)))
          2207 | 							sprintf(b+strlen(b),"%s",c+oS);
          2208 | 						lines.addlast(new line(b));
          2209 | 						bOffset = 0;
          2210 | 					ü
          2211 | 			ü
          2212 | 			else
          2213 | 				sprintf(b+strlen(b),"%s",c+oS);
          2214 | 		ü
          2215 | 	ü
          2216 | 	if (bOffset>0)
          2217 | 		lines.addlast(new line(b));
          2218 | 	return 1;
          2219 | ü
          2220 |
          2221 | char DDs::lastddÄ9Ü;
          2222 | int  DDs::concatIndex;
          2223 |
          2224 | int _rexxjcl()
          2225 | ä
          2226 | 	jobEnv = new JOBENV(argvÄ0Ü);
          2227 | 	//printf("starting rexxjcl");
          2228 | 	char filenameÄ16Ü;
          2229 | 	sprintf(filename,"//DD:%s",argvÄ1Ü);
          2230 | 	REXXVAR rexx(JOBENV::debug);
          2231 | 	int stepC = 0;
          2232 | 	rexx.set(var("JCL",0),stepC);
          2233 | 	FILE * jclFile = fopen(filename,"r,noseek");
          2234 | 	if (jclFile)
          2235 | 	ä
          2236 | 		jesjcl = new jesJcl(jclFile);
          2237 | 		if (|jesjcl->parse())
          2238 | 			printf(" parse error");
          2239 | 		else
          2240 | 			if (JOBENV::debug)
          2241 | 				steps.print();
          2242 | 		fclose(jclFile);
          2243 | 	ü
          2244 | 	else
          2245 | 		printf("file open error");
          2246 | 	STEP * step = (STEP *)steps.goFirst();
          2247 |
          2248 | 	while (step)
          2249 | 	ä
          2250 | 		stepC++;
          2251 | 		rexx.set(var("JCL",stepC,"STEP"),step->getStep());
          2252 | 		rexx.set(var("JCL",stepC,"PROCSTEP"),step->getProcstep());
          2253 | 		rexx.set(var("JCL",stepC,"PGM"),step->getPgm());
          2254 | 		rexx.set(var("JCL",stepC,"PARM"),step->getParm());
          2255 | 		DDs * dds = step->getDDs();
          2256 | 		int ddC = 0;
          2257 | 		if (dds)
          2258 | 		ä
          2259 | 			DD * dd = (DD *)dds->goFirst();
          2260 | 			while(dd)
          2261 | 			ä
          2262 | 				ddC++;
          2263 | 				rexx.set(var("JCL",stepC,"DD",ddC,"DDNAME"),dd->chainEid);
          2264 | 				rexx.set(var("JCL",stepC,"DD",ddC,"DSN"),dd->getLine()->getDataset()->getDsn());
          2265 | 				dd = (DD *)dds->goNext();
          2266 | 			ü
          2267 | 			rexx.set(var("JCL",stepC,"DD",0),ddC);
          2268 | 		ü
          2269 | 		step = (STEP *)steps.goNext();
          2270 | 	ü
          2271 | 	rexx.set(var("JCL",0),stepC);
          2272 | 	if (JOBENV::debug)
          2273 | 	ä
          2274 | 		printf("printing dddsÖn");
          2275 | 		dds.print_all_ids();
          2276 | 		printf("printing stepsÖn");
          2277 | 		steps.print_all_ids();
          2278 | 		printf("printing datasetListÖn");
          2279 | 		datasetList.print_all_ids();
          2280 | 		printf("ending rexxjcl");
          2281 | 	ü
          2282 | 	return 0;
          2283 | ü
          2284 |
          2285 | char * rexxSMFTimeDate(int &time, int &date)
          2286 | ä
          2287 | 	static char wÄ128Ü= "";
          2288 | 	int _dateÄ2Ü;
          2289 | 	_dateÄ0Ü = 0;
          2290 | 	_dateÄ1Ü = date;
          2291 | 	int dateI = __cvb((char *)_date);
          2292 | 	int rest , v , ss, mm, hh;
          2293 | 	rest = time%100;
          2294 | 	v  =  time/100;
          2295 | 	ss =  v%60;
          2296 | 	v /= 60;
          2297 | 	mm =  v%60;
          2298 | 	hh =  v/60;
          2299 | 	int d =dateI/1000;
          2300 | 	sprintf(w," %d.%d ",(dateI/1000)+1900,dateI%1000);
          2301 | 	sprintf(w+strlen(w),"%2.2d:%2.2d:%2.2d:%2.2dÖn",hh,mm,ss,rest);
          2302 | 	return w;
          2303 | ü
          2304 |
          2305 | typedef struct cvtxtnt2 * cvtxtnt2P;
          2306 |
          2307 | const char * rexxSMFtod(pULL tod,char * format=NULL)
          2308 | ä
          2309 | 	static char wÄ128Ü;
          2310 | 	struct tm *  p_tm;
          2311 | 	time_t     t;
          2312 | 	unsigned long  rest;
          2313 | 	unsigned long long microsec = (*tod>>12);
          2314 | 	t      = microsec/1000000-epoch;
          2315 | 	p_tm = localtime(&t);
          2316 |
          2317 | 	rest =  microsec%1000000;
          2318 | 	if (format)
          2319 | 		strftime(w,sizeof(w),format,p_tm);
          2320 | 	else
          2321 | 	ä
          2322 | 		strftime(w,sizeof(w),"%FT%T",p_tm);
          2323 | 		sprintf(w+strlen(w),".%6.6d",rest);
          2324 | 	ü
          2325 | 	return ((const char *)w);
          2326 | ü
          2327 |
          2328 | class Smf2Job :public chainE
          2329 | ä
          2330 | private:
          2331 | 	char jobnameÄ9Ü;
          2332 | 	char jobidÄ9Ü;
          2333 | 	char useridÄ9Ü;
          2334 | public:
          2335 | 	Smf2Job(const char *p,const char * jp,const  char * ip,char * up):chainE(p)
          2336 | 	ä
          2337 | 		strcpy(jobname,jp);
          2338 | 		strcpy(jobid,ip);
          2339 | 		strcpy(userid,up);
          2340 | 	ü
          2341 | 	virtual ßSmf2Job()
          2342 | 	äü
          2343 |
          2344 | 	const char * getJobname()
          2345 | 	ä
          2346 | 		return ((const char *)jobname);
          2347 | 	ü
          2348 |
          2349 | 	const char * getJobid()
          2350 | 	ä
          2351 | 		return ((const char *)jobid);
          2352 | 	ü
          2353 | 	const char * getUserid()
          2354 | 	ä
          2355 | 		return ((const char *)userid);
          2356 | 	ü
          2357 |
          2358 | ü;
          2359 |
          2360 | SORTEDmCHAIN * Smf2Jobs = new SORTEDmCHAIN();
          2361 |
          2362 | int rexxSMF(REXXVAR & rexx ,int & index,char * b,bool & idflag,size_t rl,int need30 = 1, int  need92
          2362 |  = 1, int need102 = 1)
          2363 | ä
          2364 | 	char recordQualÄ16Ü;
          2365 | 	countersÄsmfrcd30P(b)->smf30rtyÜ++;
          2366 | 	switch(smfrcd30P(b)->smf30rty)
          2367 | 	ä
          2368 | 	case 14:
          2369 | 	case 15:
          2370 | 		ä
          2371 | 			char prognameÄ256Ü;
          2372 | 			smf14P smf14p = (smf14P)b;
          2373 | 			int sdc = smf14p->smf14sdc; //size of DCB segment
          2374 | 			int nuc = smf14p->smf14nuc; //no. of UCB sections
          2375 | 			int suc = smf14p->smf14suc; //size of each of UCB sections
          2376 | 			int excp = 0;
          2377 | 			memcpy(&rst_15,smf14p->smf14rst,4);
          2378 | 			memcpy(&rsd_15,smf14p->smf14rsd,4);
          2379 | 			if ((rst_30 |= rst_15 ]] rsd_30 |= rsd_15 ]] memcmp(jobname,smf14p->smf14jbn,8))&&strcasecmp("rex
          2379 | xsmf",argvÄ0Ü)==0)
          2380 | 				break;
          2381 | 			if (nuc > 0)
          2382 | 				excp = *(int*)smf14p->smfexcp;
          2383 | 			if (excp == 0)
          2384 | 				break;
          2385 | 			if (JOBENV::debug)
          2386 | 				_dump(" SMF 14 or 15 record dump",b,rl);
          2387 | 			unsigned char* dcbp = smf14p->smfdcbor; //DCB Section
          2388 | 			unsigned char* ucbp = smf14p->smfdcbor + sdc; //UCB Section
          2389 | 			unsigned char* eis1 = ucbp + nuc*suc; //Extended Information Section
          2390 | 			unsigned char* eisp = ucbp + nuc*suc;
          2391 | 			short int smf14esll = ((smf14EISP)eisp)->_smf14esl-2; //length of all Extended Information Sectio
          2391 | ns
          2392 | 			unsigned char* eispr = eisp + 2;
          2393 | 			short int eispl = 1; //length of next Extended Information Section
          2394 | 			int write_14_15 = 0; //=0 do not write line
          2395 | 			char stepname_14Ä9Ü;
          2396 | 			char progname_14Ä9Ü;
          2397 | 			while (smf14esll > 0 && eispl > 0)
          2398 | 			ä
          2399 | 				eispl = ((smf14EISP)eispr)->_smf14esl; //length of next Extended Information Section
          2400 | 				char sty = ((smf14EISP)eispr)->_smf14sty; //Section type
          2401 | 				switch(sty)
          2402 | 				ä
          2403 | 				case smf14stp:
          2404 | 					strncpy(stepname_14,(char*)((smf14STEP)eispr)->_smf14spn,8);
          2405 | 					strncpy(progname_14,(char*)((smf14STEP)eispr)->_smf14pgn,8);
          2406 | 					stepname_14Ä8Ü = 0;
          2407 | 					progname_14Ä8Ü = 0;
          2408 | 					if (*pstepname == 0 && *pprogname == 0)
          2409 | 						write_14_15 = 1;
          2410 | 					else if (*pstepname && |strcasecmp(stepname_14,pstepname))
          2411 | 						write_14_15 = 1;
          2412 | 					else if (*pprogname && |strcasecmp(progname_14,pprogname))
          2413 | 						write_14_15 = 1;
          2414 | 					break;
          2415 | 				default:
          2416 | 					break;
          2417 | 				ü
          2418 | 				smf14esll -= eispl;
          2419 | 				eispr += eispl;
          2420 | 			ü
          2421 | 			//printf("smf14p=%p ucbp=%p eispr=%p eisp=%p smf14esll=%dÖn",smf14p,ucbp,eispr,eisp,smf14esll);
          2422 | 			if (write_14_15)
          2423 | 			ä
          2424 | 				char dsnameÄ128Ü;
          2425 | 				write_30 = 1; //write step sum
          2426 | 				if (*stepname == 0)
          2427 | 				ä
          2428 | 					strcpy(stepname,stepname_14);
          2429 | 					strcpy(progname,progname_14);
          2430 | 				ü
          2431 | 				strncpy(dsname,(const char*)smf14p->smfjfcb1,44);
          2432 | 				dsnameÄ44Ü = 0;
          2433 | 				if (smf14p->smfjfcb1Ä44Ü-' ')
          2434 | 				ä
          2435 | 					int i = 0;
          2436 | 					int j = 0;
          2437 | 					for(;dsnameÄiÜ-' '&&dsnameÄiÜ-0;i++);
          2438 | 					dsnameÄi++Ü= '(';
          2439 | 					for(;j<8&&smf14p->smfjfcb1Ä44+jÜ>='A';j++)
          2440 | 						dsnameÄi+jÜ=smf14p->smfjfcb1Ä44+jÜ;
          2441 | 					dsnameÄi+jÜ=')';
          2442 | 					dsnameÄi+j+1Ü=0;
          2443 | 				ü
          2444 | 				if (strcasecmp("rexxdsmf",argvÄ0Ü)==0&&stcpma(dsname,argvÄ1Ü)==0)
          2445 | 					break;
          2446 |
          2447 | 				if (smf14p->smf14rty == 14)
          2448 | 					strcpy(recordQual,"SMF14");
          2449 | 				else
          2450 | 					strcpy(recordQual,"SMF15");
          2451 | 				index++;
          2452 | 				if (strcasecmp("rexxdsmf",argvÄ0Ü)==0)
          2453 | 				ä
          2454 | 					char smf2jobÄ17Ü;
          2455 | 					memcpy(smf2job,smf14p->smf14jbn,16);
          2456 | 					smf2jobÄ16Ü = 0;
          2457 | 					Smf2Job * pjob = (Smf2Job *)Smf2Jobs->search(smf2job);
          2458 | 					if (pjob)
          2459 | 					ä
          2460 | 						rexx.set(var("SMF",index,"JOBNAME"),pjob->getJobname());
          2461 | 						rexx.set(var("SMF",index,"JOBID"),pjob->getJobid());
          2462 | 						rexx.set(var("SMF",index,"USERID"),(char *)smf14p->smf14uid,8);
          2463 |
          2464 | 					ü
          2465 | 				ü
          2466 | 				rexx.set(var("SMF",index,"TYPE"),recordQual);
          2467 | 				rexx.set(var("SMF",index,"DD"),(char *)smf14p->smftioe5,8);
          2468 | 				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smf14p->smf14tme,*(int *)smf14p->smf14d
          2468 | te));
          2469 | 				rexx.set(var("SMF",index,"DD"),(char *)smf14p->smftioe5,8);
          2470 | 				rexx.set(var("SMF",index,"DSN"),dsname);
          2471 | 				rexx.set(var("SMF",index,"EXCP"),excp);
          2472 | 				rexx.set(var("SMF",index,"STEP"),stepname);
          2473 | 				rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
          2474 | 				rexx.set(var("SMF",index,"PROGRAM"),progname);
          2475 |
          2476 |
          2477 | 				char workÄ10Ü = "";
          2478 | 				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14dad)
          2479 | 					strcpy(work,"DASD");
          2480 | 				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14tds)
          2481 | 					strcpy(work,"Temporary");
          2482 | 				if (smf14p->smf14rinÄ0Ü & (unsigned char)smf14vio)
          2483 | 					strcpy(work,"VIO ");
          2484 | 				rexx.set(var("SMF",index,"DSTYPE"),work);
          2485 |
          2486 | 			ü
          2487 | 		ü
          2488 | 		break;
          2489 | 	case 30:
          2490 | 		ä
          2491 |
          2492 | 			switch (*(short *)(smfrcd30P(b)->smf30stp))
          2493 | 			ä
          2494 | 			case 1:
          2495 | 				if ((argvÄ1Ü&&memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8)==0)]]strcasecmp(arg
          2495 | vÄ0Ü,"rexxdsmf")==0)
          2496 | 				ä
          2497 | 					memcpy(jobid,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8);
          2498 | 					jobidÄ8Ü = 0;
          2499 | 					memcpy(jobname,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
          2500 | 					jobnameÄ8Ü = 0;
          2501 | 					memcpy(username,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30usr,8);
          2502 | 					usernameÄ8Ü = 0;
          2503 | 					rst_30 = smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst;
          2504 | 					memcpy(&rsd_30,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd,4);
          2505 | 					if (strcasecmp("rexxdsmf",argvÄ0Ü)==0)
          2506 | 					ä
          2507 | 						char smf2jobÄ17Ü;
          2508 | 						memcpy(smf2job,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jbn,8);
          2509 | 						memcpy(smf2job+8,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rst),4);
          2510 | 						memcpy(smf2job+12,(char *)&(smf30idP(b+smfrcd30P(b)->smf30iof)->smf30rsd),4);
          2511 | 						smf2jobÄ16Ü = 0;
          2512 | 						Smf2Jobs->add(new Smf2Job(smf2job,jobname,jobid,username));
          2513 | 					ü
          2514 | 				ü
          2515 | 				else
          2516 | 					return 0;
          2517 | 				break;
          2518 | 			case 2:
          2519 | 				return 0;
          2520 | 				break;
          2521 | 			case 3:
          2522 | 				return 0;
          2523 | 				break;
          2524 | 			case 4:
          2525 | 				break;
          2526 | 			case 5:
          2527 | 				break;
          2528 | 			case 6:
          2529 | 				break;
          2530 | 			default:
          2531 | 				break;
          2532 | 			ü
          2533 | 			if (strcasecmp(argvÄ0Ü,"rexxdsmf")==0)
          2534 | 				break;
          2535 | 			if (memcmp(argvÄ1Ü,smf30idP(b+smfrcd30P(b)->smf30iof)->smf30jnm,8))
          2536 | 				break;
          2537 | 			if (JOBENV::debug)
          2538 | 				_dump(" SMF 30 record dump",b,rl);
          2539 | 			if (*(short *)(smfrcd30P(b)->smf30ion)&&|idflag)
          2540 | 			ä
          2541 | 				smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
          2542 | 				strcpy(recordQual,"SMF30");
          2543 | 				rexx.set(var("SMF",0,"JOBNAME"),(char *)p->smf30jbn,8);
          2544 | 				rexx.set(var("SMF",0,"JOBID"),jobid);
          2545 | 				rexx.set(var("SMF",0,"USER"),(const char *)p->smf30usr);
          2546 | 				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30
          2546 | P(b)->smf30dte));
          2547 | 				idflag = true;
          2548 | 			ü
          2549 | 			else
          2550 | 			ä
          2551 | 				smf30idP p = smf30idP(b+smfrcd30P(b)->smf30iof);
          2552 | 				index++;
          2553 | 				strcpy(recordQual,"SMF30");
          2554 | 				rexx.set(var("SMF",index,"TYPE"),recordQual);
          2555 | 				rexx.set(var("SMF",index,"PROGRAM"),(char *)p->smf30pgm,8);
          2556 | 				rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)smfrcd30P(b)->smf30tme,*(int *)smfrcd30
          2556 | P(b)->smf30dte));
          2557 | 				rexx.set(var("SMF",index,"STEP"),stepname);
          2558 | 				rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
          2559 | 			ü
          2560 | 			// I/O activity
          2561 |
          2562 |
          2563 | 			int excp = 0;
          2564 | 			if (*(short *)(smfrcd30P(b)->smf30uon))
          2565 | 				excp = smf30uraP(b+smfrcd30P(b)->smf30uof)->smf30tep;
          2566 | 			rexx.set(var("SMF",index,"EXCP"),excp);
          2567 |
          2568 | 			// Processor cumulative CPU
          2569 | 			double cpu = 0;
          2570 | 			double srb = 0;
          2571 | 			if (*(short *)(smfrcd30P(b)->smf30con))
          2572 | 			ä
          2573 | 				smf30casP p = smf30casP(b+smfrcd30P(b)->smf30cof);
          2574 | 				cpu = float(p->smf30cpt)/100;
          2575 | 				srb = float(p->smf30cps)/100;
          2576 | 			ü
          2577 | 			rexx.set(var("SMF",index,"CPU"),cpu);
          2578 | 			rexx.set(var("SMF",index,"SRB"),cpu);
          2579 |
          2580 | 			// EXCP section
          2581 | 			if (*(short *)(smfrcd30P(b)->smf30eon))
          2582 | 			ä
          2583 | 				/*
          2584 | 				smf30expP p = smf30expP(b+smfrcd30P(b)->smf30eof);
          2585 | 				for(int i=0;i<*(short*)smfrcd30P(b)->smf30eon;i++)
          2586 | 				ä
          2587 | 				if (p->smf30blk)
          2588 | 				printf(" Device(CUA):%2.2X%2.2X EXCP count:%8.8dÖn",
          2589 | 				p->smf30cuaÄ0Ü,p->smf30cuaÄ1Ü,p->smf30blk);
          2590 | 				p = smf30expP((char *)p+*(short *)smfrcd30P(b)->smf30eln);
          2591 | 				ü
          2592 | 				*/
          2593 | 			ü
          2594 | 			int storage = 0;
          2595 | 			int region = 0;
          2596 | 			if (*(short *)(smfrcd30P(b)->smf30ron))
          2597 | 			ä
          2598 | 				smf30sapP p = smf30sapP(b+smfrcd30P(b)->smf30rof);
          2599 | 				region = (*(int *)p->smf30rgn)/1024;
          2600 | 				storage =  p->smf30eur/(1024*1024);
          2601 | 			ü
          2602 | 			rexx.set(var("SMF",index,"REGION"),region);
          2603 | 			rexx.set(var("SMF",index,"STORAGE"),storage);
          2604 |
          2605 | 			int totalsu = 0;
          2606 | 			int cpusu = 0;
          2607 | 			int srbsu = 0;
          2608 | 			int iosu = 0;
          2609 | 			// Performance
          2610 | 			if (*(short *)(smfrcd30P(b)->smf30pon))
          2611 | 			ä
          2612 | 				smf30prfP p = smf30prfP(b+smfrcd30P(b)->smf30pof);
          2613 | 				totalsu =   p->smf30srv;
          2614 | 				cpusu = p->smf30csu;
          2615 | 				srbsu = p->smf30srb;
          2616 | 				iosu = p->smf30io;
          2617 | 			ü
          2618 | 			rexx.set(var("SMF",index,"TOTALSU"),totalsu);
          2619 | 			rexx.set(var("SMF",index,"CPUSU"),cpusu);
          2620 | 			rexx.set(var("SMF",index,"SRBSU"),srbsu);
          2621 | 			rexx.set(var("SMF",index,"IOSU"),iosu);
          2622 | 			if (*(short *)(smfrcd30P(b)->smf30stp)==5)
          2623 | 				return 5;
          2624 | 		ü
          2625 | 		break;
          2626 | 	case 92:
          2627 | 		if (smfrcd92P(b)->smf92ion)
          2628 | 		ä
          2629 | 			smf92idP pid = smf92idP(b+smfrcd92P(b)->smf92iof);
          2630 | 			if (|need92]](pid->smf92rst-rst_30)]]memcmp(pid->smf92rsd,(char *)&rsd_30,4)
          2631 | 				]]memcmp(jobname,pid->smf92jbn,8))
          2632 | 				break;
          2633 | 			if (JOBENV::debug)
          2634 | 				_dump(" SMF 92 record dump",b,rl);
          2635 | 			strcpy(recordQual,"SMF92");
          2636 | 			switch (smfrcd92P(b)->smf92stp)
          2637 | 			ä
          2638 | 			case 11:
          2639 | 				if (smfrcd92P(b)->smf92don&&smfrcd92P(b)->smf92dln&&smfrcd92P(b)->smf92dof)
          2640 | 				ä
          2641 | 					smf92fclP p = smf92fclP(b+smfrcd92P(b)->smf92dof);
          2642 | 					for(int i=0;i<smfrcd92P(b)->smf92don;i++)
          2643 | 					ä
          2644 | 						char nameÄ65Ü;
          2645 | 						nameÄ64Ü=0;
          2646 | 						if (p->smf92cty==FT_SOCKET)
          2647 | 							sprintf(name," SOCKET inode:%d device:%d",p->smf92cin,p->smf92cdn);
          2648 | 						else
          2649 | 							memcpy(name,p->smf92cpn,sizeof(p->smf92cpn));
          2650 | 						index++;
          2651 | 						rexx.set(var("SMF",index,"READ"),p->smf92cir);
          2652 | 						rexx.set(var("SMF",index,"WRITE"),p->smf92ciw);
          2653 |
          2654 | 						p = smf92fclP((char *)p+smfrcd92P(b)->smf92dln);
          2655 | 						rexx.set(var("SMF",index,"TYPE"),recordQual);
          2656 | 						rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(smfrcd92P(b)->smf92tme,smfrcd92P(b)->smf92dte
          2656 | ));
          2657 | 						/*    rexx.set(var("SMF",index,"TIME"),rexxSMFtod(pULL(p->smf92ctc)));*/
          2658 | 						rexx.set(var("SMF",index,"PATH"),name);
          2659 | 						rexx.set(var("SMF",index,"STEP"),stepname);
          2660 | 						rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
          2661 |
          2662 | 					ü
          2663 | 				ü
          2664 | 				break;
          2665 | 			default:
          2666 | 				break;
          2667 | 			ü
          2668 | 		ü
          2669 | 		break;
          2670 | 	case 100:
          2671 | 		//_dump(" SMF 100 record dump",b,rl);
          2672 | 		break;
          2673 | 	case 101:
          2674 | 		//_dump(" SMF 101 record dump",b,rl);
          2675 | 		break;
          2676 | 	case 102:
          2677 | 		ä
          2678 | 			typedef struct sm102 * sm102P;
          2679 | 			typedef struct qwt0 * qwt0P;
          2680 | 			typedef struct qwhs * qwhsP;
          2681 | 			typedef struct qwhc * qwhcP;
          2682 | 			qwt0P qwt0p = qwt0P(b+sizeof(struct sm102)-1);
          2683 | 			int pso = int(qwt0p->qwt02pso);
          2684 | 			int psl = *(short *)(qwt0p->qwt02psl);
          2685 | 			int psn = *(short *)(qwt0p->qwt02psn);
          2686 | 			bool our = false;
          2687 | 			sm102P sm102p = sm102P(b);
          2688 | 			qwhcP qwhcp = qwhcP(b+pso);
          2689 | 			qwhsP qwhsp = NULL;
          2690 | 			while (|our&&(char *)qwhcp<(b+pso+psl))
          2691 | 			ä
          2692 | 				if (qwhcp->qwhctyp == 1)
          2693 | 					qwhsp = (qwhsP)qwhcp;
          2694 | 				if (qwhcp->qwhctyp == 2 && strcmp((const char *)(qwhcp->qwhccv),jobid) ==0 )
          2695 | 					our = true;
          2696 | 				qwhcp = qwhcP((char *)qwhcp+*(short *)qwhcp->qwhclen);
          2697 | 			ü
          2698 | 			if (|need102 ]] |our ]] |qwhsp)
          2699 | 				break;
          2700 | 			if (JOBENV::debug)
          2701 | 				_dump(" SMF 102 record dump",b,rl);
          2702 |
          2703 |
          2704 | 			char ssidÄ5Ü;
          2705 | 			memcpy(ssid,qwhsp->qwhsssid,4);
          2706 | 			ssidÄ4Ü = 0;
          2707 | 			strcpy(recordQual,"SMF102");
          2708 | 			char workÄ1024*32Ü;
          2709 | 			for(int i = 0;i<qwhsp->qwhsnsda-1;i++)
          2710 | 			ä
          2711 | 				qwt0P datasection = qwt0P((char *)qwt0p+i*8+8);
          2712 | 				int offset = int(datasection->qwt02pso);
          2713 | 				int length = *(short *)(datasection->qwt02psl);
          2714 | 				int count = *(short *)(datasection->qwt02psn);
          2715 | 				char * start = b+offset;
          2716 | 				//for(int j = 0;j<count;j++)
          2717 | 				ä
          2718 | 					index++;
          2719 | 					rexx.set(var("SMF",index,"STEP"),stepname);
          2720 | 					rexx.set(var("SMF",index,"PROCSTEP"),pstepname);
          2721 | 					rexx.set(var("SMF",index,"TIME"),rexxSMFTimeDate(*(int *)sm102p->sm102tme,*(int *)sm102p->sm102
          2721 | dte));
          2722 | 					rexx.set(var("SMF",index,"TYPE"),recordQual);
          2723 | 					rexx.set(var("SMF",index,"ON"),ssid);
          2724 |
          2725 | 					switch(*(short *)qwhsp->qwhsiid)
          2726 | 					ä
          2727 | 					case 22:
          2728 | 						ä
          2729 | 							typedef struct qw0022 * qw0022P;
          2730 | 							rexx.set(var("SMF",index,"NOTES"),"0022 THE MINI-PLANS GENERATED");
          2731 | 							rexx.set(var("SMF",index,"INFO"),(const char *)qw0022P(start)->qw0022tn,18);
          2732 | 							rexx.set(var("SMF",index,"STATS"),(const char *)qw0022P(start)->qw0022pg,8);
          2733 | 						ü
          2734 | 						break;
          2735 | 					case 53:
          2736 | 						ä
          2737 | 							typedef struct qw0053 * qw0053P;
          2738 | 							rexx.set(var("SMF",index,"NOTES"),"0053 END OF DESCRIBE SQL COMMIT, ROLLBACK, ERROR CONDITION
          2738 | ");
          2739 | 							if (memcmp(qw0053P(start)->qw0053sq,"SQLCA",5) == 0)
          2740 | 							ä
          2741 | 								if (*(int *)(qw0053P(start)->qw0053sq+12) == 0 )
          2742 | 								ä
          2743 | 									strcpy(work,"SQLOK");
          2744 | 								ü
          2745 | 								else
          2746 | 								ä
          2747 | 									ERROR_MESSAGE error_message;
          2748 | 									error_message.error_len = 10*72;
          2749 | 									int rc = DSNTIAR(qw0053P(start)->qw0053sq,&error_message,&data_len);
          2750 | 									if ( rc )
          2751 | 										sprintf(work,"DSNTIAR rc:%d",rc);
          2752 | 									else
          2753 | 									ä
          2754 | 										workÄ0Ü =0;
          2755 | 										for(int i = 0;i<data_dim;i++)
          2756 | 											sprintf(work+strlen(work),"<p>%72.72s",error_message.error_textÄiÜ);
          2757 | 									ü
          2758 | 								ü
          2759 | 							ü
          2760 | 							else
          2761 | 							ä
          2762 | 								sprintf(work,"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu",
          2763 | 									*(long long *)qw0053P(start)->qw0053rq,
          2764 | 									*(long long *)qw0053P(start)->qw0053in,
          2765 | 									*(long long *)qw0053P(start)->qw0053up,
          2766 | 									*(long long *)qw0053P(start)->qw0053de);
          2767 | 							ü
          2768 | 							rexx.set(var("SMF",index,"STATS"),work);
          2769 | 							rexx.set(var("SMF",index,"INFO"),"");
          2770 | 						ü
          2771 | 						break;
          2772 | 					case 55:
          2773 | 						index--;
          2774 | 						break;
          2775 | 					case 58:
          2776 | 						ä
          2777 | 							typedef struct qw0058 * qw0058P;
          2778 | 							rexx.set(var("SMF",index,"NOTES"),"0058 END SQL STATEMENT EXECUTION");
          2779 | 							if (memcmp(qw0058P(start)->qw0058sq,"SQLCA",5) == 0)
          2780 | 							ä
          2781 | 								if (*(int *)(qw0058P(start)->qw0058sq+12) == 0 )
          2782 | 								ä
          2783 | 									strcpy(work,"SQLOK");
          2784 | 								ü
          2785 | 								else
          2786 | 								ä
          2787 | 									ERROR_MESSAGE error_message;
          2788 | 									error_message.error_len = 10*72;
          2789 | 									int rc = DSNTIAR(qw0058P(start)->qw0058sq,&error_message,&data_len);
          2790 | 									if ( rc )
          2791 | 										sprintf(work,"DSNTIAR rc:%d",rc);
          2792 | 									else
          2793 | 									ä
          2794 | 										workÄ0Ü =0;
          2795 | 										for(int i = 0;i<data_dim;i++)
          2796 | 											sprintf(work+strlen(work),"<p>%72.72s",error_message.error_textÄiÜ);
          2797 | 									ü
          2798 | 								ü
          2799 | 							ü
          2800 | 							else
          2801 | 							ä
          2802 | 								sprintf(work,"Rows:%llu Inserted:%llu Updated:%llu Deleted:%llu",
          2803 | 									*(long long *)qw0058P(start)->qw0058rp,
          2804 | 									*(long long *)qw0058P(start)->qw0058in,
          2805 | 									*(long long *)qw0058P(start)->qw0058up,
          2806 | 									*(long long *)qw0058P(start)->qw0058de);
          2807 | 							ü
          2808 | 							rexx.set(var("SMF",index,"STATS"),work);
          2809 | 							rexx.set(var("SMF",index,"INFO"),"");
          2810 | 						ü
          2811 | 						break;
          2812 | 					case 59:
          2813 | 						ä
          2814 | 							typedef struct qw0059 * qw0059P;
          2815 | 							rexx.set(var("SMF",index,"NOTES"),"0059 FETCH SQL STATEMENT EXECUTION START");
          2816 | 							sprintf(work,"Cursor:%*.*s Sensitive:%c Orientation:%c",
          2817 | 								*(short*)qw0059P(start)->qw0059cl,*(short*)qw0059P(start)->qw0059cl,qw0059P(start)->qw0059cn
          2817 | ,qw0059P(start)->qw0059fs,qw0059P(start)->qw0059fo);
          2818 | 							rexx.set(var("SMF",index,"STATS"),work);
          2819 | 							rexx.set(var("SMF",index,"INFO"),"");
          2820 | 						ü
          2821 | 						break;
          2822 | 					case 60:
          2823 | 						ä
          2824 | 							typedef struct qw0060 * qw0060P;
          2825 | 							rexx.set(var("SMF",index,"NOTES"),"0060 SELECT SQL STATEMENT EXECUTION START");
          2826 | 							sprintf(work,"Isolation:%c",
          2827 | 								qw0060P(start)->qw0060i);
          2828 | 							rexx.set(var("SMF",index,"STATS"),work);
          2829 | 							rexx.set(var("SMF",index,"INFO"),"");
          2830 | 						ü
          2831 | 						break;
          2832 | 					case 61:
          2833 | 						ä
          2834 | 							typedef struct qw0061 * qw0061P;
          2835 | 							rexx.set(var("SMF",index,"NOTES"),"0061 FETCH SQL STATEMENT START - INSERT, UPDATE, DELETE");
          2836 | 							char typeÄ32Ü;
          2837 | 							if (qw0061P(start)->qw0061st = 0x10)
          2838 | 								strcpy(type,"INSERT");
          2839 | 							else
          2840 | 								if (qw0061P(start)->qw0061st = 0x20)
          2841 | 									strcpy(type,"UPDATE NON CURSOR");
          2842 | 								else
          2843 | 									if (qw0061P(start)->qw0061st = 0x21)
          2844 | 										strcpy(type,"UPDATE CURSOR");
          2845 | 									else
          2846 | 										if (qw0061P(start)->qw0061st = 0x30)
          2847 | 											strcpy(type,"MERGE");
          2848 | 										else
          2849 | 											if (qw0061P(start)->qw0061st = 0x41)
          2850 | 												strcpy(type,"DELETE CURSOR");
          2851 | 											else
          2852 | 												if (qw0061P(start)->qw0061st = 0x50)
          2853 | 													strcpy(type,"TRUNCATE");
          2854 | 							sprintf(work,"Cursor:%*.*s Type:%s",
          2855 | 								*(short*)qw0061P(start)->qw0061cl,*(short*)qw0061P(start)->qw0061cl,qw0061P(start)->qw0061cn
          2855 | ,type);
          2856 | 							rexx.set(var("SMF",index,"STATS"),work);
          2857 | 							rexx.set(var("SMF",index,"INFO"),"");
          2858 | 						ü
          2859 | 						break;
          2860 | 					case 62:
          2861 | 						ä
          2862 | 							typedef struct qw0062 * qw0062P;
          2863 | 							rexx.set(var("SMF",index,"NOTES"),"0062 RECORDS DLL EXECUTION STATEMENT START");
          2864 | 							sprintf(work,"Object:%*.*s type:%c",
          2865 | 								*(short*)qw0062P(start)->qw0062ol,*(short*)qw0062P(start)->qw0062ol,qw0062P(start)->qw0062on
          2865 | ,qw0062P(start)->qw0062st);
          2866 | 							rexx.set(var("SMF",index,"STATS"),work);
          2867 | 							rexx.set(var("SMF",index,"INFO"),"");
          2868 | 						ü
          2869 | 						break;
          2870 | 					case 63:
          2871 | 						ä
          2872 | 							typedef struct qw0063 * qw0063P;
          2873 | 							rexx.set(var("SMF",index,"NOTES"),"0063 THE SQL STATEMENTT");
          2874 | 							sprintf(work,"%*.*s",
          2875 | 								*(short*)qw0063P(start)->qw0063ll,*(short*)qw0063P(start)->qw0063ll,(char *)&qw0063P(start)-
          2875 | >qw0063st);
          2876 | 							rexx.set(var("SMF",index,"STATS"),work);
          2877 | 							rexx.set(var("SMF",index,"INFO"),"");
          2878 | 						ü
          2879 | 						break;
          2880 | 					case 64:
          2881 | 						ä
          2882 | 							typedef struct qw0064 * qw0064P;
          2883 | 							rexx.set(var("SMF",index,"NOTES"),"0064 PREPARE STATEMET START");
          2884 | 							sprintf(work,"Cursor:%*.*s",
          2885 | 								*(short*)qw0064P(start)->qw0064cl,*(short*)qw0064P(start)->qw0064cl,qw0064P(start)->qw0064cn
          2885 | );
          2886 | 							rexx.set(var("SMF",index,"STATS"),work);
          2887 | 							rexx.set(var("SMF",index,"INFO"),"");
          2888 | 						ü
          2889 | 						break;
          2890 | 					case 65:
          2891 | 						ä
          2892 | 							typedef struct qw0065 * qw0065P;
          2893 | 							rexx.set(var("SMF",index,"NOTES"),"0065 OPEN CURSOR STATEMENT START");
          2894 | 							sprintf(work,"Cursor:%*.*s Sensitive:%c Isolation:%c",
          2895 | 								*(short*)qw0065P(start)->qw0065cl,*(short*)qw0065P(start)->qw0065cl,qw0065P(start)->qw0065cn
          2895 | ,
          2896 | 								qw0065P(start)->qw0065sv,qw0065P(start)->qw0065i);
          2897 | 							rexx.set(var("SMF",index,"STATS"),work);
          2898 | 							rexx.set(var("SMF",index,"INFO"),"");
          2899 | 						ü
          2900 | 						break;
          2901 | 					case 66:
          2902 | 						ä
          2903 | 							typedef struct qw0066 * qw0066P;
          2904 | 							rexx.set(var("SMF",index,"NOTES"),"0066 OPEN CURSOR STATEMENT START");
          2905 | 							sprintf(work,"Cursor:%*.*s",
          2906 | 								*(short*)qw0066P(start)->qw0066cl,*(short*)qw0066P(start)->qw0066cl,qw0066P(start)->qw0066cn
          2906 | );
          2907 | 							rexx.set(var("SMF",index,"STATS"),work);
          2908 | 							rexx.set(var("SMF",index,"INFO"),"");
          2909 | 						ü
          2910 | 						break;
          2911 | 					case 92:
          2912 | 						ä
          2913 | 							typedef struct qw0092 * qw0092P;
          2914 | 							rexx.set(var("SMF",index,"NOTES"),"0092 AN AMS COMMAND START");
          2915 | 							sprintf(work,"Command:%*.*s",
          2916 | 								*(short*)qw0092P(start)->qw0092pl,*(short*)qw0092P(start)->qw0092pl,qw0092P(start)->qw0092p1
          2916 | );
          2917 | 							rexx.set(var("SMF",index,"STATS"),work);
          2918 | 							rexx.set(var("SMF",index,"INFO"),"");
          2919 | 						ü
          2920 | 						break;
          2921 | 					case 96:
          2922 | 						ä
          2923 | 							typedef struct qw0096 * qw0096P;
          2924 | 							rexx.set(var("SMF",index,"NOTES"),"0096 RECORDS SORT ENDED");
          2925 | 							sprintf(work,"Records:%d DataSize:%d KeySize:%d",
          2926 | 								qw0096P(start)->qw0096nr,qw0096P(start)->qw0096dl,qw0096P(start)->qw0096kl);
          2927 | 							rexx.set(var("SMF",index,"STATS"),work);
          2928 | 							rexx.set(var("SMF",index,"INFO"),"");
          2929 | 						ü
          2930 | 						break;
          2931 | 					case 97:
          2932 | 						ä
          2933 | 							typedef struct qw0097 * qw0097P;
          2934 | 							rexx.set(var("SMF",index,"NOTES"),"0097 AMS COMMAND COMPLETION");
          2935 | 							sprintf(work,"Command:%*.*s ReturnCode:%d",
          2936 | 								*(short*)qw0097P(start)->qw0097pl,*(short*)qw0097P(start)->qw0097pl,qw0097P(start)->qw0097p1
          2936 | ,
          2937 | 								qw0097P(start)->qw0097rc);
          2938 | 							rexx.set(var("SMF",index,"STATS"),work);
          2939 | 							rexx.set(var("SMF",index,"INFO"),"");
          2940 | 						ü
          2941 | 						break;
          2942 | 					case 112:
          2943 | 						ä
          2944 | 							typedef struct qw0112 * qw0112P;
          2945 | 							rexx.set(var("SMF",index,"NOTES"),"0112 THE ATTRIBUTES FOR THE PLAN");
          2946 | 							sprintf(work,"Plan:%8.8s Isolation:%2.2s Aqu:%c Rel:%c Keep:%c Prot:%c",
          2947 | 								qw0112P(start)->qw0112pn,qw0112P(start)->qw0112i,
          2948 | 								qw0112P(start)->qw0112q,qw0112P(start)->qw0112r,
          2949 | 								qw0112P(start)->qw0112kd,qw0112P(start)->qw0112pr);
          2950 | 							rexx.set(var("SMF",index,"STATS"),work);
          2951 | 							rexx.set(var("SMF",index,"INFO"),"");
          2952 | 						ü
          2953 | 						break;
          2954 | 					case 173:
          2955 | 						index--;
          2956 | 						break;
          2957 | 					case 177:
          2958 | 						ä
          2959 | 							typedef struct qw0177 * qw0177P;
          2960 | 							rexx.set(var("SMF",index,"NOTES"),"0177 FOR SUCCESSFUL PACKAGE ALLOCATION");
          2961 | 							sprintf(work,"Package:%126.126s",
          2962 | 								(char *)&(qw0177P(start)->qw0177pk));
          2963 | 							rexx.set(var("SMF",index,"STATS"),work);
          2964 | 							rexx.set(var("SMF",index,"INFO"),"");
          2965 | 						ü
          2966 | 						break;
          2967 | 					case 233:
          2968 | 						ä
          2969 | 							typedef struct qw0233 * qw0233P;
          2970 | 							rexx.set(var("SMF",index,"NOTES"),"0233 START OR END OF A CALL TO A USER ROUTINE");
          2971 | 							sprintf(work,"Routine:18.18s",
          2972 | 								qw0233P(start)->qw0233pr);
          2973 | 							rexx.set(var("SMF",index,"STATS"),work);
          2974 | 							rexx.set(var("SMF",index,"INFO"),"");
          2975 | 						ü
          2976 | 						break;
          2977 | 					case 237:
          2978 | 						ä
          2979 | 							typedef struct qw0237 * qw0237P;
          2980 | 							rexx.set(var("SMF",index,"NOTES"),"0237 AT EXECUTION of SET CURRENT DEGREE");
          2981 | 							sprintf(work,"Prev:%3.3s New:%3.3s Status:%c",
          2982 | 								qw0237P(start)->qw0237oi,qw0237P(start)->qw0237ni,
          2983 | 								qw0237P(start)->qw0237st);
          2984 | 							rexx.set(var("SMF",index,"STATS"),work);
          2985 | 							rexx.set(var("SMF",index,"INFO"),"");
          2986 | 						ü
          2987 | 						break;
          2988 | 					case 250:
          2989 | 						index--;
          2990 | 						break;
          2991 | 					case 272:
          2992 | 						ä
          2993 | 							typedef struct qw0272 * qw0272P;
          2994 | 							rexx.set(var("SMF",index,"NOTES"),"0272 ASSOCIATE LOCATORS");
          2995 | 							sprintf(work,"StoredProc:%*.*s",
          2996 | 								qw0272P(start)->qw0272pl,qw0272P(start)->qw0272pl,qw0272P(start)->qw0272pn);
          2997 | 							rexx.set(var("SMF",index,"STATS"),work);
          2998 | 							rexx.set(var("SMF",index,"INFO"),"");
          2999 | 						ü
          3000 | 						break;
          3001 | 					case 273:
          3002 | 						ä
          3003 | 							typedef struct qw0273 * qw0273P;
          3004 | 							rexx.set(var("SMF",index,"NOTES"),"0273 ALLOCATE CURSOR");
          3005 | 							sprintf(work,"Cursor:%*.*s",
          3006 | 								qw0273P(start)->qw0273cl,qw0273P(start)->qw0273cl,qw0273P(start)->qw0273cn);
          3007 | 							rexx.set(var("SMF",index,"STATS"),work);
          3008 | 							rexx.set(var("SMF",index,"INFO"),"");
          3009 | 						ü
          3010 | 						break;
          3011 | 					case 325:
          3012 | 						index--;
          3013 | 						break;
          3014 | 					default:
          3015 | 						break;
          3016 | 					ü
          3017 | 					if (offset)
          3018 | 						start +=offset;
          3019 | 					else
          3020 | 						start += *(short *)start;
          3021 | 				ü
          3022 | 			ü
          3023 | 		ü
          3024 | 		break;
          3025 | 	default:
          3026 | 		break;
          3027 | 	ü
          3028 | 	return 0;
          3029 | ü
          3030 |
          3031 | _rexxsmf()
          3032 | ä
          3033 | 	//printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtool
          3033 | d"));
          3034 | 	jobEnv = new JOBENV(argvÄ0Ü);
          3035 | 	int rc = mvs()->LoggerOpen(argvÄ2Ü);
          3036 | 	const char * pointer = NULL;
          3037 | 	char dateÄ32Ü;
          3038 | 	char * dateP = NULL;
          3039 | 	if (argc >= 4 && argvÄ4Ü)
          3040 | 	ä
          3041 | 		char * p = strchr(argvÄ4Ü,',');
          3042 | 		if (p)
          3043 | 			*(int *)date = atoi(p+1);
          3044 | 		memcpy(date+4,argvÄ4Ü,7);
          3045 | 		dateP = date;
          3046 | 	ü
          3047 |
          3048 | 	size_t length = 0;
          3049 | 	size_t * lP   = &length;
          3050 | 	pasm PASM = NULL;
          3051 | 	REXXVAR rexx(JOBENV::debug);
          3052 | 	bool idflag = false;
          3053 | 	int index = 0;
          3054 | 	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),0,dateP)==0)
          3055 | 	ä
          3056 | 		PASM = mvs()->getpasm();
          3057 | 		if (JOBENV::debug)
          3058 | 		ä
          3059 | 			/*
          3060 | 			_dump("logger rc",(char *)&(PASM->asm_rc),256);
          3061 | 			_dump("asm logger",(char *)&(PASM->asm_logger_length),
          3062 | 			(char *)&(PASM->asm_logger_stck)-(char *)&(PASM->asm_logger_length));
          3063 | 			_dump(" ASM LOGGER",(char *)PASM->asm_logger_buffer,int(PASM->asm_logger_bufflen));
          3064 | 			_dump(" ASM ansarea",(char *)PASM->asm_ansarea,40);
          3065 | 			printf(" RC:%d REASON:%d(%8.8x)Ön",PASM->asm_rc,PASM->asm_reason,PASM->asm_reason);
          3066 | 			*/
          3067 | 		ü
          3068 | 		unsigned short ubl = *(unsigned short *)pointer;
          3069 | 		int bl = ubl;
          3070 | 		bl-=4;
          3071 | 		char * p = (char *)pointer+4;
          3072 | 		while(bl>0)
          3073 | 		ä
          3074 | 			unsigned short url;
          3075 | 			url = *(unsigned short *)p;
          3076 | 			int rl = url;
          3077 | 			if (rl==72)
          3078 | 			ä
          3079 | 				p+=rl;
          3080 | 				bl-=rl;
          3081 | 				length-=rl;
          3082 | 				rl = *(short *)p;
          3083 | 				if (bl >0 && rl>0 && bl>rl)
          3084 | 				ä
          3085 | 					if (rexxSMF(rexx,index,p,idflag,rl)==5)
          3086 | 					ä
          3087 | 						rexx.set(var("SMF",0),index);
          3088 | 						return 0;
          3089 | 					ü
          3090 | 					p+=rl;
          3091 | 					bl-=rl;
          3092 | 					length=-rl;
          3093 | 				ü
          3094 | 				else
          3095 | 					bl = 0;
          3096 | 			ü
          3097 | 			else
          3098 | 			ä
          3099 | 				bl = 0;
          3100 | 			ü
          3101 | 		ü
          3102 | 	ü
          3103 | 	mvs()->LoggerClose();
          3104 |
          3105 | 	if (index>0)
          3106 | 		rexx.set(var("SMF",0),index);
          3107 | 	else
          3108 | 		for(int i =0;i<255;i++)
          3109 | 			if (countersÄiÜ)
          3110 | 				printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
          3111 | 	return 0;
          3112 | ü
          3113 |
          3114 | _rexxdsmf()
          3115 | ä
          3116 | 	//printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtool
          3116 | d"));
          3117 | 	jobEnv = new JOBENV(argvÄ0Ü);
          3118 | 	int rc = mvs()->LoggerOpen(argvÄ2Ü);
          3119 | 	const char * pointer = NULL;
          3120 | 	char dateÄ32Ü;
          3121 | 	char * dateP = NULL;
          3122 | 	if (argc >= 4 && argvÄ4Ü)
          3123 | 	ä
          3124 | 		char * p = strchr(argvÄ4Ü,',');
          3125 | 		if (p)
          3126 | 			*(int *)date = atoi(p+1);
          3127 | 		memcpy(date+4,argvÄ4Ü,7);
          3128 | 		dateP = date;
          3129 | 	ü
          3130 |
          3131 | 	size_t length = 0;
          3132 | 	size_t * lP   = &length;
          3133 | 	pasm PASM = NULL;
          3134 | 	REXXVAR rexx(JOBENV::debug);
          3135 | 	bool idflag = false;
          3136 | 	int index = 0;
          3137 | 	while (rc=mvs()->BrowseLogger(pointer,lP,atoi(argvÄ3Ü),0,dateP)==0)
          3138 | 	ä
          3139 | 		PASM = mvs()->getpasm();
          3140 | 		unsigned short ubl = *(unsigned short *)pointer;
          3141 | 		int bl = ubl;
          3142 | 		bl-=4;
          3143 | 		char * p = (char *)pointer+4;
          3144 | 		while(bl>0)
          3145 | 		ä
          3146 | 			unsigned short url;
          3147 | 			url = *(unsigned short *)p;
          3148 | 			int rl = url;
          3149 | 			if (rl==72)
          3150 | 			ä
          3151 | 				p+=rl;
          3152 | 				bl-=rl;
          3153 | 				length-=rl;
          3154 | 				rl = *(short *)p;
          3155 | 				if (bl >0 && rl>0 && bl>rl)
          3156 | 				ä
          3157 | 					if (rexxSMF(rexx,index,p,idflag,rl)==5)
          3158 | 					ä
          3159 | 						rexx.set(var("SMF",0),index);
          3160 | 						return 0;
          3161 | 					ü
          3162 | 					p+=rl;
          3163 | 					bl-=rl;
          3164 | 					length=-rl;
          3165 | 				ü
          3166 | 				else
          3167 | 					bl = 0;
          3168 | 			ü
          3169 | 			else
          3170 | 			ä
          3171 | 				bl = 0;
          3172 | 			ü
          3173 | 		ü
          3174 | 	ü
          3175 | 	mvs()->LoggerClose();
          3176 |
          3177 | 	if (index>0)
          3178 | 		rexx.set(var("SMF",0),index);
          3179 | 	else
          3180 | 		for(int i =0;i<255;i++)
          3181 | 			if (countersÄiÜ)
          3182 | 				printf(" SMF type:%d, records:%dÖn",i,countersÄiÜ);
          3183 | 	return 0;
          3184 | ü
          3185 |
          3186 | extern dump(FILE *,char *,char *,int);
          3187 |
          3188 | int _dumpfile()
          3189 | ä
          3190 | 	char wÄ1024Ü;
          3191 | 	char bÄ32756Ü;
          3192 | 	FILE * f =fopen(genOpenName(argvÄ1Ü,w),"rb,type=record");
          3193 | 	int l = 0;
          3194 | 	if (f)
          3195 | 	ä
          3196 | 		int count = 0;
          3197 | 		while((l = fread(b,1,sizeof(b),f))>0)
          3198 | 		ä
          3199 | 			count++;
          3200 | 			sprintf(w,"record:%d in %d length",count,l);
          3201 | 			dump(stdout,w,b,l);
          3202 | 		ü
          3203 | 		fclose(f);
          3204 | 	ü
          3205 | 	return 0;
          3206 | ü
          3207 |
          3208 |
          3209 | int _listfile()
          3210 | ä
          3211 | 	char buffÄ32760Ü;
          3212 | 	FILE * file = NULL;
          3213 | 	size_t l = 0;
          3214 | 	size_t max = argvÄ2Ü?atoi(argvÄ2Ü):99999999;
          3215 | 	if (argvÄ1Ü&&(file=fopen(genOpenName(argvÄ1Ü,buff),"rb,type=record,noseek")))
          3216 | 	ä
          3217 | 		while ((l=fread(buff,1,sizeof(buff),file))>0&&--max>0)
          3218 | 			printf("%*.*sÖn",l,l,buff);
          3219 | 		fclose(file);
          3220 | 	ü
          3221 | 	else
          3222 | 		printf("<h1>unable to open %s (%s)Ön",argvÄ1Ü,strerror(errno));
          3223 | 	return 0;
          3224 | ü
          3225 | typedef struct ensg * ENSGP;
          3226 | typedef struct enf70 * ENF70P;
          3227 | typedef struct hdlogrec * HDLOGRECP;
          3228 | typedef struct sdwa * SDWAP;
          3229 | typedef struct adsrcmps * ADSRCMPSP;
          3230 |
          3231 |
          3232 | static char *  logrec_typesÄ255Ü;
          3233 | int logrec_types_init()
          3234 | ä
          3235 | 	logrec_typesÄ0x10Ü =  "Machine Check Handler";
          3236 | 	logrec_typesÄ0x13Ü =  "Machine Check in the System";
          3237 | 	logrec_typesÄ0x23Ü =  "Subchannel Logout Handler";
          3238 | 	logrec_typesÄ0x25Ü =  "Channel Record Word";
          3239 | 	logrec_typesÄ0x30Ü =  "Outboard";
          3240 | 	logrec_typesÄ0x34Ü =  "Outboard TCAM";
          3241 | 	logrec_typesÄ0x36Ü =  "Outboard VTAM";
          3242 | 	logrec_typesÄ0x3aÜ =  "Outboard DPA";
          3243 | 	logrec_typesÄ0x40Ü =  "Software-detected software error";
          3244 | 	logrec_typesÄ0x42Ü =  "Hardware-detected software error";
          3245 | 	logrec_typesÄ0x44Ü =  "Operator-detected error";
          3246 | 	logrec_typesÄ0x48Ü =  "Hardware-detected hardware error";
          3247 | 	logrec_typesÄ0x4cÜ =  "Symptom record";
          3248 | 	logrec_typesÄ0x4FÜ =  "Lost record summary";
          3249 | 	logrec_typesÄ0x50Ü =  "IPL";
          3250 | 	logrec_typesÄ0x60Ü =  "DDR";
          3251 | 	logrec_typesÄ0x70Ü =  "MIH";
          3252 | 	logrec_typesÄ0x80Ü =  "EOD";
          3253 | 	logrec_typesÄ0x81Ü =  "System-initiated end";
          3254 | 	logrec_typesÄ0x84Ü =  "EOD from IOS";
          3255 | 	logrec_typesÄ0xA1Ü =  "ETR";
          3256 | 	logrec_typesÄ0xa2Ü =    "LMI";
          3257 | 	logrec_typesÄ0xa3Ü =  "SIM";
          3258 | 	logrec_typesÄ0xc2Ü =  "DPSV";
          3259 | 	return 1;
          3260 | ü
          3261 | int _logrec_types = logrec_types_init();
          3262 |
          3263 | static char * enf70_qualifier_listÄÜ=
          3264 | ä
          3265 | 	NULL,
          3266 | 	/* Values for field "enf70_qualifier" */
          3267 | 	"Job was selected",
          3268 | 	"Job was processed",
          3269 | 	"Job queued to new phase",
          3270 | 	"Job was purged"
          3271 | ü;
          3272 |
          3273 | static char * enf70_comp_listÄÜ =
          3274 | ä
          3275 | 	/* Values for field "enf70_comp" */
          3276 | #define enf70_cab        0x80 /* ABEND CODE                       */
          3277 | #define enf70_ccc        0x40 /* Completion code                  */
          3278 | 	"No completion info",
          3279 | 	"Job ended normally",
          3280 | 	"Job ended by cc",
          3281 | 	"Job had a JCL error",
          3282 | 	"Job was canceled",
          3283 | 	"Job ABENDed",
          3284 | 	"Converter ABENDed",
          3285 | 	"Security error",
          3286 | 	"Job ABENDed in end of"
          3287 | ü;
          3288 |
          3289 | /* Values for field "enf70_queue" */
          3290 | static char * enf70_queue_listÄ138Ü =
          3291 | ä
          3292 | 	/*'#define enf70_q_none     0   .*/ "  No previous queue (job create)  ",
          3293 | 	NULL,
          3294 | 	/*'#define enf70_q_convert  2   .*/ "  Conversion                      ",
          3295 | 	/*'#define enf70_q_pscbat   3   .*/ "  Postscan (batch)                ",
          3296 | 	/*'#define enf70_q_pscdsl   4   .*/ "  Postscan (demand select)        ",
          3297 | 	/*'#define enf70_q_fetch    5   .*/ "  Volume fetch                    ",
          3298 | 	/*'#define enf70_q_volwt    6   .*/ "  Start Setup                     ",
          3299 | 	/*'#define enf70_q_syssel   7   .*/ "  MDS system select processing    ",
          3300 | 	/*'#define enf70_q_alloc    8   .*/ "  resource allocation             ",
          3301 | 	/*'#define enf70_q_voluav   9   .*/ "  unavailable VOL(s)              ",
          3302 | 	/*'#define enf70_q_verify   10  .*/ "  volume mounts                   ",
          3303 | 	/*'#define enf70_q_sysver   11  .*/ "  MDS system verify processing    ",
          3304 | 	/*'#define enf70_q_error    12  .*/ "  Demand Select                   ",
          3305 | 	/*'#define enf70_q_select   13  .*/ "  Execution                       ",
          3306 | 	/*'#define enf70_q_onmain   14  .*/ "  Execution                       ",
          3307 | 	NULL,
          3308 | 	NULL,
          3309 | 	/*'#define enf70_q_brkdwn   17  .*/ "  Breakdown                       ",
          3310 | 	/*'#define enf70_q_restrt   18  .*/ "  MDS restart proc                ",
          3311 | 	/*'#define enf70_q_done     19  .*/ "  Main and MDS proc. complete     ",
          3312 | 	/*'#define enf70_q_output   20  .*/ "  Output service                  ",
          3313 | 	/*'#define enf70_q_outque   21  .*/ "  Output service WTR              ",
          3314 | 	/*'#define enf70_q_oswait   22  .*/ "  Awaiting rsvd services          ",
          3315 | 	/*'#define enf70_q_cmplt    23  .*/ "  Output service complete         ",
          3316 | 	/*'#define enf70_q_demsel   24  .*/ "  Demand Select                   ",
          3317 | 	/*'#define enf70_q_efwait   25  .*/ "  Ending function rq waiting      ",
          3318 | 	/*'#define enf70_q_efbad    26  .*/ "  Ending function rq not Processed"
          3319 | ü;
          3320 | int init_const()
          3321 | ä
          3322 | 	enf70_queue_listÄ128Ü=
          3323 | 		/*'#define enf70_q_input    128 .*/ "  Input queue (pre-execution)     ";
          3324 | 	enf70_queue_listÄ136Ü=
          3325 | 		/*'#define enf70_q_receiver 136 .*/ "  Input queue (post-execution)    ";
          3326 | 	enf70_queue_listÄ132Ü=
          3327 | 		/*'#define enf70_q_spin     132 .*/ "  Spin queue                      ";
          3328 | 	enf70_queue_listÄ134Ü=
          3329 | 		/*'#define enf70_q_purge    134 .*/ "  Purge queue                     ";
          3330 | 	enf70_queue_listÄ137Ü=
          3331 | 		/*'#define enf70_q_xmit     137 .*/ "  NJE transmission queue          ";
          3332 | 	return 0;
          3333 | ü
          3334 |
          3335 | int _init_const = init_const();
          3336 |
          3337 | typedef struct pfswrec PFSWREC;
          3338 | typedef struct dumpxrec DUMPXREC;
          3339 | typedef struct mpfxrec MPFXREC;
          3340 |
          3341 | char * pfswrec_typesÄ23Ü;
          3342 | int _rexxenfs()
          3343 | ä
          3344 | 	// argvÄ2Ü = logstream name
          3345 | 	// argvÄ3Ü = direction (seems 3 youngtoold)
          3346 | 	// argvÄ4Ü = recordcount (default 1000?)
          3347 | 	// argvÄ5Ü = TZ envar
          3348 | 	if (argc > 4 )
          3349 | 		setenv("TZ",argvÄ5Ü,1);
          3350 | 	char wÄ32760Ü;
          3351 | 	jobEnv = new JOBENV(argvÄ0Ü);
          3352 | 	REXXVAR rexx(JOBENV::debug);
          3353 | 	pfswrec_typesÄ1Ü = "Update";
          3354 | 	pfswrec_typesÄ2Ü = "Delete";
          3355 | 	pfswrec_typesÄ3Ü = "Rename";
          3356 | 	pfswrec_typesÄ11Ü = "Add member";
          3357 | 	pfswrec_typesÄ12Ü = "Delete_member";
          3358 | 	pfswrec_typesÄ13Ü = "Rename_member";
          3359 | 	pfswrec_typesÄ21Ü = "Update path";
          3360 | 	pfswrec_typesÄ22Ü = "Delete path";
          3361 | 	pfswrec_typesÄ23Ü = "Rename path";
 ======================================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 3361.23: CCN8907 (W) The subscript 23 is out of range. The valid range is 0 to 22.
          3362 |
          3363 | 	if (JOBENV::debug)
          3364 | 		printf(" Browse %s loggerstream %s directionÖn",argvÄ2Ü,(atoi(argvÄ3Ü)==0?"oldtoyoung":"youngtoold
          3364 | "));
          3365 | 	int rc = mvs()->LoggerOpen(argvÄ2Ü);
          3366 | 	if (rc)
          3367 | 	ä
          3368 | 		rexx.set(var("ENF",0),0);
          3369 | 		rexx.set(var("ENF_ERROR",0),sprintf(w," unable to open %s logstream",argvÄ2Ü));
          3370 | 		return 8;
          3371 | 	ü
          3372 | 	size_t length = 0;
          3373 | 	size_t * lP   = &length;
          3374 | 	pasm PASM = NULL;
          3375 | 	char * pointer = NULL;
          3376 | 	int max = (argc>3)?atoi(argvÄ4Ü):100;
          3377 |
          3378 | 	bool idflag = false;
          3379 | 	int index = 1;
          3380 | 	while (rc=mvs()->BrowseLogger((const char * &)pointer,lP,atoi(argvÄ3Ü),NULL,NULL)==0 && max>=index)
          3381 | 	ä
          3382 | 		PASM = mvs()->getpasm();
          3383 |
          3384 | 		int rl = *(int *)pointer;
          3385 | 		PFSWREC * pfswrec =(PFSWREC *)(pointer +4);
          3386 | 		if (JOBENV::debug)
          3387 | 			_dump(" logger",pointer,rl);
          3388 | 		bool need = false;
          3389 | 		ENSGP ensgP = ENSGP(pointer-8);
          3390 | 		HDLOGRECP hdlogrecP = HDLOGRECP((char *)pointer+ifbenf36_header_length+sizeof(*ensgP)-8);
          3391 | 		SDWAP sdwaP=NULL;
          3392 | 		if (JOBENV::debug)
          3393 | 		ä
          3394 | 			_dump(" ensg",(char *)ensgP,128);
          3395 | 			printf(" ENF code:%dÖn ",ensgP->ensg_event_code);
          3396 | 		ü
          3397 | 		switch(ensgP->ensg_event_code)
          3398 | 		ä
          3399 | 		case 0:
          3400 | 			ä
          3401 | 				need = true;
          3402 | 				switch(pfswrec->pfswrec_type)
          3403 | 				ä
          3404 | 				case pfswrec_type_update:
          3405 | 				case pfswrec_type_delete:
          3406 | 					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_dsn,44);
          3407 | 					break;
          3408 | 				case pfswrec_type_rename:
          3409 | 					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_newdsn,44);
          3410 | 					rexx.set(var("ENF",index,"OLD_DSN"),(char *)pfswrec->pfswrec_dsn,44);
          3411 | 					break;
          3412 | 				case pfswrec_type_add_member:
          3413 | 				case pfswrec_type_delete_member:
          3414 | 					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_dsn,44);
          3415 | 					rexx.set(var("ENF",index,"MEMBER"),(char *)pfswrec->pfswrec_member,8);
          3416 | 					break;
          3417 | 				case pfswrec_type_rename_member:
          3418 | 					rexx.set(var("ENF",index,"DSN"),(char *)pfswrec->pfswrec_newdsn,44);
          3419 | 					rexx.set(var("ENF",index,"OLD_DSN"),(char *)pfswrec->pfswrec_dsn,44);
          3420 | 					rexx.set(var("ENF",index,"MEMBER"),(char *)pfswrec->pfswrec_member,8);
          3421 | 					break;
          3422 | 				case pfswrec_type_update_path:
          3423 | 				case pfswrec_type_delete_path:
          3424 | 					rexx.set(var("ENF",index,"PATH"),(char *)pfswrec->pfswrec_path,64);
          3425 | 					break;
          3426 | 				case pfswrec_type_rename_path:
          3427 | 					rexx.set(var("ENF",index,"PATH"),(char *)pfswrec->pfswrec_newpath,64);
          3428 | 					rexx.set(var("ENF",index,"OLD_PATH"),(char *)pfswrec->pfswrec_path,64);
          3429 | 					break;
          3430 |
          3431 | 				ü
          3432 | 			ü
          3433 | 			break;
          3434 | 		case 1:
          3435 | 			ä
          3436 | 				DUMPXREC * rec =(DUMPXREC *)pointer;
          3437 | 				need = true;
          3438 | 				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(rec->dumpxrec_dumpxrec_stck)));
          3439 | 				rexx.set(var("ENF",index,"SYSTEM"),(char *)rec->dumpxrec_dumpxrec_prdsname,4);
          3440 | 				rexx.set(var("ENF",index,"JOBNAME"),(char *)rec->dumpxrec_dumpxrec_sdepljob,8);
          3441 | 				rexx.set(var("ENF",index,"CHANGE"),"Dump created");
          3442 | 				rexx.set(var("ENF",index,"DSN"),(char *)rec->dumpxrec_dumpxrec_prddsnam,40);
          3443 | 				rexx.set(var("ENF",index,"SIGNAL"),1);
          3444 |
          3445 | 			ü
          3446 | 			break;
          3447 | 		case 2:
          3448 | 			ä
          3449 | 				MPFXREC  * rec =(MPFXREC *)pointer;
          3450 | 				need = true;
          3451 | 				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(rec->mpfxrec_mpfxrec_stck)));
          3452 | 				rexx.set(var("ENF",index,"SYSTEM"),(char *)rec->mpfxrec_mpfxrec_sysname,4);
          3453 | 				rexx.set(var("ENF",index,"JOBNAME"),(char *)rec->mpfxrec_mpfxrec_jobname,8);
          3454 | 				rexx.set(var("ENF",index,"JOBID"),(char *)rec->mpfxrec_mpfxrec_jobid,8);
          3455 | 				sprintf(w,"%4.4X",*(short *)rec->mpfxrec_mpfxrec_asid);
          3456 | 				rexx.set(var("ENF",index,"ASID"),w	);
          3457 | 				rexx.set(var("ENF",index,"CHANGE"),"critical message");
          3458 | 				rexx.set(var("ENF",index,"MSG"),(char *)rec->mpfxrec_mpfxrec_ctxttmsg,126);
          3459 |
          3460 | 			ü
          3461 | 			break;
          3462 |
          3463 | 		case 36:
          3464 | 			need = true;
          3465 | 			rexx.set(var("ENF",index,"LOGRECTYPE"),logrec_typesÄhdlogrecP->hdrtypÜ);
          3466 | 			switch(hdlogrecP->hdrtyp)
          3467 | 		case 0x40:
          3468 | 		default:
          3469 | 			ä
          3470 | 				sdwaP = SDWAP((char *)hdlogrecP+sizeof(*hdlogrecP));
          3471 | 				rexx.set(var("ENF",index,"JOBNAME"),(char *)sdwaP,8);
          3472 | 				sdwaP = SDWAP((char *)sdwaP+8);
          3473 | 				unsigned int cc = *(int *)&(sdwaP->sdwafiob.sdwaabcc);
          3474 | 				if ((cc&0x00FFF000)>>12)
          3475 | 					sprintf(w,"S%3.3X",(cc&0x00FFF000)>>12);
          3476 | 				else
          3477 | 					sprintf(w,"U%3.3X",cc&0x00000FFF);
          3478 | 				rexx.set(var("ENF",index,"CMPC"),w);
          3479 | 				rexx.set(var("ENF",index,"MODULE"),(char *)sdwaP->sdwamodn,8);
          3480 | 			ü
          3481 | 			break;
          3482 | 		case 0x4c:
          3483 | 			break;
          3484 | 		case 29:
          3485 | 		case 30:
          3486 | 		case 55:
          3487 | 		case 67:
          3488 | 			need = true;
          3489 | 			break;
          3490 | 		case 70:
          3491 | 			//need = true;
          3492 | 			ENF70P enf70P = ENF70P(pointer+sizeof(*ensgP)-8);
          3493 | 			/*
          3494 | 			if (enf70P->enf70_queue == enf70_q_onmain && enf70P->enf70_qualifier == enf70_deselect &&
          3495 | 			(enf70P->enf70_comp&enf70_cab]]enf70P->enf70_comp==enf70_cabn]]enf70P->enf70_comp==enf70_ccab]]en
          3495 | f70P->enf70_comp==enf70_csec]]enf70P->enf70_comp==enf70_ceom))
          3496 | 			*/
          3497 | 			if (enf70P->enf70_comp&&enf70P->enf70_queue == enf70_q_onmain)
          3498 | 			ä
          3499 | 				need = true;
          3500 | 				rexx.set(var("ENF",index,"JOBNAME"),(char *)enf70P->enf70_jobname,sizeof(enf70P->enf70_jobname))
          3500 | ;
          3501 | 				rexx.set(var("ENF",index,"JOBID"),(char *)enf70P->enf70_jobid,sizeof(enf70P->enf70_jobid));
          3502 | 				if (isprint(*enf70P->enf70_srvclass))
          3503 | 					rexx.set(var("ENF",index,"SRVCLASS"),(char *)enf70P->enf70_srvclass,sizeof(enf70P->enf70_srvcla
          3503 | ss));
          3504 | 				else
          3505 | 					rexx.set(var("ENF",index,"SRVCLASS")," ");
          3506 | 				rexx.set(var("ENF",index,"COMP"),int(enf70P->enf70_comp));
          3507 | 				sprintf(w,"%8.8x",*(int *)&(enf70P->enf70_comp)&0x00FFFFFF);
          3508 | 				rexx.set(var("ENF",index,"CODE"),w);
          3509 | 			ü
          3510 | 			break;
          3511 | 		ü
          3512 | 		if (need)
          3513 | 		ä
          3514 | 			rexx.set(var("ENF",0),index);
          3515 | 			rexx.set(var("ENF",index,"SIGNAL"),ensgP->ensg_event_code);
          3516 | 			if (ensgP->ensg_event_code > 2)
          3517 | 			ä
          3518 | 				rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL((char *)&(ensgP->ensg_source_system_slot)+4)));
          3519 | 				sprintf(w,"%8.8X",*(int *)(ensgP->ensg_qual));
          3520 | 				rexx.set(var("ENF",index,"QUAL"),w);
          3521 | 				sprintf(w,"%8.8X",*(int *)(ensgP->ensg_bitmap_qual));
          3522 | 				rexx.set(var("ENF",index,"BITQUAL"),w);
          3523 | 				rexx.set(var("ENF",index,"SYSTEM"),(char *)ensgP->ensg_source_system_name,sizeof(ensgP->ensg_sou
          3523 | rce_system_name));
          3524 | 			ü
          3525 | 			else
          3526 | 				if (ensgP->ensg_event_code == 0)
          3527 | 				ä
          3528 | 					rexx.set(var("ENF",index,"TIME"),rexxSMFtod(pULL(pfswrec->pfswrec_stck)));
          3529 | 					rexx.set(var("ENF",index,"SYSTEM"),(char *)pfswrec->pfswrec_id_system,4);
          3530 | 					rexx.set(var("ENF",index,"JOBNAME"),(char *)pfswrec->pfswrec_id_jobname,8);
          3531 | 					rexx.set(var("ENF",index,"CHANGE"),pfswrec_typesÄpfswrec->pfswrec_typeÜ);
          3532 | 				ü
          3533 | 				index++;
          3534 | 		ü
          3535 | 	ü
          3536 | 	return 0;
          3537 | ü
          3538 |
          3539 | struct MSGXBUF_T
          3540 | ä
          3541 | 	time_t     mtime;   // Time and date message was sent
          3542 | 	uid_t      muid;    // Sender's effective user ID
          3543 | 	gid_t      mgid;    // Sender's effective group ID
          3544 | 	pid_t      mpid;    // Sender's process ID
          3545 | 	long int   mtype;   // Message type
          3546 | 	int        mtextÄ256Ü; // Message text
          3547 | ü ;
          3548 |
          3549 | typedef struct MSGXBUF_T msgxbuf_t;
          3550 |
          3551 | struct LOGSTREAM_T
          3552 | ä
          3553 | 	int length;
          3554 | 	int type;
          3555 | 	int  mtextÄ256Ü;
          3556 | ü;
          3557 |
          3558 |
          3559 |
          3560 | int _dump(char * id,char * p,int l)
          3561 | ä
          3562 | 	unsigned char ATOEÄ256Ü =
          3563 | 	ä
          3564 | 		0, 0x1, 0x2, 0x3, 0x37, 0x2d, 0x2e, 0x2f,
          3565 | 		0x16, 0x5, 0x25, 0xb, 0xc, 0xd, 0xe, 0xf,
          3566 | 		0x10, 0x11, 0x12, 0x13, 0x3c, 0x3d, 0x32, 0x26,
          3567 | 		0x18, 0x19, 0x3f, 0x27, 0x1c, 0x1d, 0x1e, 0x1f,
          3568 | 		0x40, 0x4f, 0x7f, 0x7b, 0x5b, 0x6c, 0x50, 0x7d,
          3569 | 		0x4d, 0x5d, 0x5c, 0x4e, 0x6b, 0x60, 0x4b, 0x61,
          3570 | 		0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
          3571 | 		0xf8, 0xf9, 0x7a, 0x5e, 0x4c, 0x7e, 0x6e, 0x6f,
          3572 | 		0xb5, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
          3573 | 		0xc8, 0xc9, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,
          3574 | 		0xd7, 0xd8, 0xd9, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
          3575 | 		0xe7, 0xe8, 0xe9, 0x63, 0xec, 0xfc, 0x5f, 0x6d,
          3576 | 		0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
          3577 | 		0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
          3578 | 		0x97, 0x98, 0x99, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
          3579 | 		0xa7, 0xa8, 0xa9, 0x43, 0xbb, 0xdc, 0x59, 0x7,
          3580 | 		0x68, 0xd0, 0x51, 0x42, 0xc0, 0x44, 0x47, 0x48,
          3581 | 		0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4a, 0x67,
          3582 | 		0x71, 0x9c, 0x9e, 0xcb, 0x6a, 0xcd, 0xdb, 0xdd,
          3583 | 		0xdf, 0xe0, 0x5a, 0x70, 0xb1, 0x80, 0xbf, 0xff,
          3584 | 		0x45, 0x55, 0xce, 0xde, 0x49, 0x69, 0x9a, 0x9b,
          3585 | 		0xab, 0xaf, 0xba, 0xb8, 0xb7, 0xaa, 0x8a, 0x8b,
          3586 | 		0xff, 0xff, 0xff, 0xff, 0xff, 0x65, 0x62, 0x64,
          3587 | 		0xb4, 0xff, 0xff, 0xff, 0xff, 0xb0, 0xb2, 0xff,
          3588 | 		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x46, 0x66,
          3589 | 		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f,
          3590 | 		0x8c, 0xac, 0x72, 0x73, 0x74, 0xff, 0x75, 0x76,
          3591 | 		0x77, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x78, 0xff,
          3592 | 		0xee, 0xa1, 0xeb, 0xed, 0xcf, 0xef, 0xa0, 0x8e,
          3593 | 		0xae, 0xfe, 0xfb, 0xfd, 0x8d, 0xad, 0xbc, 0xbe,
          3594 | 		0xca, 0x8f, 0xff, 0xb9, 0xb6, 0x7c, 0xe1, 0x9d,
          3595 | 		0x90, 0xbd, 0xb3, 0xda, 0xfa, 0xea, 0xff, 0x41
          3596 | 	ü;
          3597 | 	int i , o;
          3598 | 	printf("%s at:%x(%d)ÖnÖn",id,p,l);
          3599 | 	if (p)
          3600 | 		for(o = 0;o <((l/16)+1)*16;o+=16)
          3601 | 		ä
          3602 | 			printf("%4.4lx:",o);
          3603 | 			for(i = o;i<o+16;i++)
          3604 | 			ä
          3605 | 				if ( i < l )
          3606 | 				ä
          3607 | 					printf("%2.2x",pÄiÜ& 0xFF );
          3608 | 					if (i%4 == 3) printf(" ");
          3609 |
          3610 | 				ü
          3611 |
          3612 | 				else
          3613 | 				ä
          3614 | 					if ( i%4 == 3) printf(" ");
          3615 | 					printf(" ");
          3616 | 				ü
          3617 | 			ü
          3618 | 			printf(" ");
          3619 | 			for(i = o;i<o+16;i++)
          3620 | 				if ( i < l )
          3621 | 					printf("%c",isprint(pÄiÜ)? pÄiÜ:'.');
          3622 | 				else printf(" ");
          3623 | 				printf(" ");
          3624 | 				for(i = o;i<o+16;i++)
          3625 | 					if ( i < l )
          3626 | 						printf("%c",isprint(ATOEÄpÄiÜÜ)?ATOEÄpÄiÜÜ:'.');  printf("Ön");
          3627 |
          3628 | 		ü
          3629 | 		return l;
          3630 | ü
          3631 |
          3632 | static iconv_t cpconv = 0;
          3633 | char    msgbufÄ1024Ü;
          3634 |
          3635 | char* translate(char* input, char* tbl)
          3636 | ä
          3637 | 	char *outbuf = msgbuf;
          3638 | 	char *limit  = input + 1023;
          3639 | 	outbufÄ1023Ü = 'Ö0';
          3640 |
          3641 | 	if (cpconv == 0)
          3642 | 	ä
          3643 | 		size_t  i,   il, ol;
          3644 | 		char   *pe_to_a, *pa_to_e, cÄ256Ü, *pc = c;
          3645 |
          3646 | 		for (i=0; i<256; ++i) cÄiÜ = i;
          3647 |
          3648 | 		cpconv = iconv_open("ISO8859-1", "IBM-273");
          3649 | 		pc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;
          3650 | 		iconv(cpconv, &pc, &il, &pe_to_a, &ol);
          3651 |
          3652 | 		cpconv = iconv_open("IBM-273", "ISO8859-1");
          3653 | 		pc = c; pe_to_a = e_to_a; pa_to_e = a_to_e; il = ol = 256;
          3654 | 		iconv(cpconv, &pc, &il, &pa_to_e, &ol);
          3655 | 	ü
          3656 | 	while ((input < limit) && (*outbuf = tblÄ*inputÜ))
          3657 | 	ä
          3658 | 		++input; ++outbuf;
          3659 | 	ü
          3660 | 	return msgbuf;
          3661 | ü
          3662 |
          3663 |
          3664 |
          3665 |
          3666 |
          3667 |
          3668 |
          3669 |
          3670 | typedef struct r79cchnl * R79celem;
          3671 | typedef struct smf79pro * Smf79pro;
          3672 | typedef struct r79cchnl   R79cchnl;
          3673 | typedef struct r793     * R793;
          3674 | #define UINTF(n) (*(unsigned int *)(n))
          3675 | #define INTF(n) (*(signed int *)(n))
          3676 | static R79cchnl channelsÄ256Ü;
          3677 | typedef struct r792elem R792elem;
          3678 | typedef struct r79chl R79chl;
          3679 | typedef struct smf79hdr  SMF79hdr;
          3680 | typedef struct smf79pro  SMF79pro;
          3681 | typedef struct ascb * ascbP;
          3682 | typedef struct asvt * asvtP;
          3683 |
          3684 | int _rexxrmf2()
          3685 | ä
          3686 | 	char wÄ32760Ü;
          3687 | 	jobEnv = new JOBENV(argvÄ0Ü);
          3688 | 	REXXVAR rexx(JOBENV::debug);
          3689 |
          3690 | 	cvtP      cvt = *(cvtP* )0x10;
          3691 | 	asvtP    asvt = asvtP(cvt->cvtasvt);
          3692 | 	unsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);
          3693 | 	if (JOBENV::debug)
          3694 | 		_dump("ASVT",(char *)asvtEntryP,4096);
          3695 |
          3696 | 	rexx.set(var("RMF2",0),0);
          3697 |
          3698 | 	ERB2XDGS_Addr Get_SMF_Record_79 = (ERB2XDGS_Addr) NULL;
          3699 | 	/* This program's ERB2XDGS default parameters */
          3700 |
          3701 | 	AnswerAreaAddress MyDgsAnswerAreaAddress = 0;
          3702 | 	ALET             MyDgsAnswerAreaALET    = 0;
          3703 | 	unsigned long int MyDgsAnswerAreaLength = 1048576;
          3704 |
          3705 | 	SystemName       MySystemName           ;
          3706 | 	memcpy(MySystemName,"*ALL",sizeof(MySystemName));
          3707 |
          3708 | 	DataGatheringParm MyDataGatheringParm   = ä 79, 2, "" ü;
          3709 | 	DataGatheringPLen MyDataGatheringPLen   = 4;
          3710 |
          3711 | 	ExitName         MyExitName             ;
          3712 | 	memcpy(MyExitName,"ERB2XSMF",sizeof(MyExitName));
          3713 | 	ExitParm         MyExitParm             = "";
          3714 | 	ExitParmLength   MyExitParmLength       = 0;
          3715 |
          3716 | 	unsigned long int MyDgsTimeOut          = 30;
          3717 |
          3718 | 	unsigned long int MyDgsReturnCode       = 0;
          3719 | 	unsigned long int MyDgsReasonCode       = 0;
          3720 |
          3721 | 	/* Get ERB2XDGS Answer Area storage */
          3722 |
          3723 | 	if ( ( MyDgsAnswerAreaAddress
          3724 | 		= (AnswerAreaAddress) malloc( MyDgsAnswerAreaLength ) ) == (AnswerAreaAddress) NULL )
          3725 | 	ä
          3726 | 		rexx.set("RMF2_ERROR",sprintf( w,"ÖnERB2XDGS Answer Area allocation failed.Ön" ));
          3727 | 		return( 8 );
          3728 | 	ü;
          3729 |
          3730 | 	/* Load RMF callable services ... */
          3731 |
          3732 | 	if ( ( Get_SMF_Record_79 = (ERB2XDGS_Addr)fetch("ERB2XDGS")) == (ERB2XDGS_Addr) NULL )
          3733 | 	ä
          3734 | 		rexx.set("RMF2_ERROR",sprintf(w, "ÖnERB2XDGS fetch failed.Ön" ));
          3735 | 		return( 8 );
          3736 | 	ü;
          3737 |
          3738 | 	/* Now invoke RMF callable service ... */
          3739 |
          3740 |
          3741 | 	(*Get_SMF_Record_79)( &MyDgsAnswerAreaAddress,
          3742 | 		&MyDgsAnswerAreaALET,
          3743 | 		&MyDgsAnswerAreaLength,
          3744 | 		&MySystemName,
          3745 | 		&MyDataGatheringParm,
          3746 | 		&MyDataGatheringPLen,
          3747 | 		&MyExitName,
          3748 | 		MyExitParm,
          3749 | 		&MyExitParmLength,
          3750 | 		&MyDgsTimeOut,
          3751 | 		&MyDgsReturnCode,
          3752 | 		&MyDgsReasonCode );
          3753 |
          3754 |
          3755 | 	/* Work with the returned RMF Monitor II data ... */
          3756 | 	if (MyDgsReturnCode == 0)
          3757 | 	ä
          3758 |
          3759 | 		//printf(" Answer area:%pÖn",MyDgsAnswerAreaAddress);
          3760 |
          3761 | 		AnswerAreaHeader * h = (AnswerAreaHeader *)MyDgsAnswerAreaAddress;
          3762 | 		SystemListEntry * s = (SystemListEntry * )
          3763 | 			((char *)h+h->SystemListOffset);
          3764 | 		/* Release Answer Area storage */
          3765 | 		sprintf(w,"%8.8s",h->SysplexName);
          3766 | 		rexx.set("RMF2_SYSPLEX_NAME",w);
          3767 |
          3768 | 		rexx.set(var("RMF2_SYSPLEX",0),int(h->SystemListEntryNumber));
          3769 | 		for (int i =0;i <h->SystemListEntryNumber;i++)
          3770 | 		ä
          3771 | 			sprintf(w,"%8.8s",s->MVSSystemName);
          3772 | 			rexx.set(var("RMF2_SYSPLEX",i+1,"SYSTEM_NAME"),w);
          3773 | 			sprintf(w,"%4.4s",s->SMFSystemID);
          3774 | 			rexx.set(var("RMF2_SYSPLEX",i+1,"SYSTEM_SMFID"),w);
          3775 | 			s =(SystemListEntry *)((char *)s+h->SystemListEntryLength);
          3776 | 		ü
          3777 | 		Monitor2DataEntry * d = (Monitor2DataEntry *)((char *)h+h->DataOffset);
          3778 | 		SMF79hdr * hdr       =(SMF79hdr *)((char *)d+d->Monitor2HeaderLength);
          3779 |
          3780 | 		//printf(" SMF79hdr:%d SMF79pro:%d R79chl:%dÖn",
          3781 | 		//  sizeof(SMF79hdr),sizeof(SMF79pro),sizeof(R79chl));
          3782 |
          3783 | 		R792elem * r = (R792elem *)((char *)hdr+hdr->smf79ass);
          3784 | 		rexx.set("RMF2_CPU",int(d->Monitor2DataSystemCpuUtilization));
          3785 | 		/*
          3786 | 		if (argvÄ1Ü)
          3787 | 		printf(" %s (%d)Ön",argvÄ1Ü,strlen(argvÄ1Ü));
          3788 | 		*/
          3789 | 		int count = 0;
          3790 | 		for (int i =0;i<hdr->smf79asn;i++)
          3791 | 		ä
          3792 | 			//if (argvÄ1Ü==0]]memcmpi((const char *)(r->r792jbn),argvÄ1Ü,strlen(argvÄ1Ü))==0)
          3793 | 			ä
          3794 | 				count++;
          3795 | 				sprintf(w,"%4.4X",*(short *)r->r792asid);
          3796 | 				rexx.set(var("RMF2",count,"ASID"),w);
          3797 | 				rexx.set(var("RMF2",count,"JOBID"),"");
          3798 | 				//if ((unsigned char )((*asvtEntryPÄ(*(short *)r->r792asid)Ü)-1)&(unsigned char)0x80==0)
          3799 | 				ä
          3800 | 					ascbP myascb = (ascbP)asvtEntryPÄ((*(short *)r->r792asid))-1Ü;
          3801 | 					assbP myassb = (assbP)myascb->ascbassb;
          3802 | 					iazjsabP myjsab = (iazjsabP)myassb->assbjsab;
          3803 | 					if (JOBENV::debug)
          3804 | 					ä
          3805 | 						_dump("ASCB",(char *)myascb,1024);
          3806 | 						_dump("ASSB",(char *)myassb,sizeof(*myassb));
          3807 | 						_dump("JSAB",(char *)myjsab,sizeof(*myjsab));
          3808 | 					ü
          3809 |
          3810 | 					if (myjsab&&myjsab->jsabjbidÄ0Ü)
          3811 | 					ä
          3812 | 						sprintf(w,"%8.8s",myjsab->jsabjbid);
          3813 | 						rexx.set(var("RMF2",count,"JOBID"),w);
          3814 | 					ü
          3815 |
          3816 | 				ü
          3817 | 				sprintf(w,"%8.8s",r->r792jbn);
          3818 | 				rexx.set(var("RMF2",count,"JOBNAME"),w);
          3819 | 				rexx.set(var("RMF2",count,"DOMAIN"),*(short *)r->r792jbn);
          3820 | 				rexx.set(var("RMF2",count,"PERFORMANCE_GROUP"),*(short*)r->r792npg);
          3821 | 				rexx.set(var("RMF2",count,"CURRENT_LOCATION"),*(short*)r->r792cl);
          3822 | 				rexx.set(var("RMF2",count,"TRANSACTION_COUNT"),*(short *)r->r792trc);
          3823 | 				rexx.set(var("RMF2",count,"TRANSACTION_TIME"),(*(int *)r->r792trc)/1000);
          3824 | 				rexx.set(var("RMF2",count,"PRIVATE_FRAMES"),*(int *)r->r792prfx);
          3825 | 				rexx.set(var("RMF2",count,"SRM_SERVICE_RATE"),*(int *)r->r792svar);
          3826 | 				rexx.set(var("RMF2",count,"TCB_CPU"),(*(int *)r->r792tcpu)/1000);
          3827 | 				rexx.set(var("RMF2",count,"TOTAL_CPU"),(*(int *)r->r792ejst)/1000);
          3828 | 				rexx.set(var("RMF2",count,"TOTAL_SRM"),*(int *)r->r792tsrm);
          3829 | 				rexx.set(var("RMF2",count,"STEP_RESIDENT_TIME"),*(int *)r->r792rtm);
          3830 | 				rexx.set(var("RMF2",count,"EXCP_COUNT"),*(int *)r->r792excp);
          3831 |
          3832 | 				rexx.set(var("RMF2",count,"PAGES_COMMON"),*(int *)r->r792cmni);
          3833 | 				rexx.set(var("RMF2",count,"PAGES_NONVIO"),*(int *)r->r792pnv);
          3834 | 				rexx.set(var("RMF2",count,"PAGES_VIO"),*(int *)r->r792pvio);
          3835 | 				rexx.set(var("RMF2",count,"PAGES_FIXED"),*(int *)r->r792fxbl);
          3836 | 				rexx.set(var("RMF2",count,"PAGES_SWAPPED_IN"),*(int *)r->r792pswp);
          3837 | 				rexx.set(var("RMF2",count,"PAGES_LPA_SWAPPED_IN"),*(int *)r->r792lpai);
          3838 | 				rexx.set(var("RMF2",count,"PAGES_CSA_SWAPPED_IN"),*(int *)r->r792csai);
          3839 | 				rexx.set(var("RMF2",count,"PAGES_FIXED_LSQA"),*(int *)r->r792cmni);
          3840 | 				rexx.set(var("RMF2",count,"PAGES_FIXED_NONLSQA"),*(int *)r->r792cmni);
          3841 | 				rexx.set(var("RMF2",count,"DEVICE_CONNECT"),*(int *)r->r792tdev);
          3842 | 				rexx.set(var("RMF2",count,"PAGE_IN"),*(int *)r->r792pin);
          3843 | 				rexx.set(var("RMF2",count,"TRANSACTION_RESIDENCY"),(*(int *)r->r792trtm)/1000);
          3844 | 				rexx.set(var("RMF2",count,"LSQA_REAL"),*(int *)r->r792lsqr);
          3845 | 				rexx.set(var("RMF2",count,"LSQA_EXTENDED"),*(int *)r->r792lsqe);
          3846 | 				rexx.set(var("RMF2",count,"REAL_FRAME_AVERAGE"),*(int *)r->r792ars);
          3847 | 				rexx.set(var("RMF2",count,"SRM_TARGET_WORKINGSET"),*(int *)r->r792twss);
          3848 | 				rexx.set(var("RMF2",count,"HIPERSPACE_PAGES"),*(int *)r->r792phsp);
          3849 | 				rexx.set(var("RMF2",count,"PAGES_COMMONT"),*(int *)r->r792cmni);
          3850 | 				sprintf(w,"%8.8s",r->r792scl);
          3851 | 				rexx.set(var("RMF2",count,"SERVICE_CLASS"),w);
          3852 | 				rexx.set(var("RMF2",count,"SERVICE_CLASS_PERIOD"),*(short *)r->r792scp);
          3853 | 				sprintf(w,"%8.8s",r->r792wkld);
          3854 | 				rexx.set(var("RMF2",count,"WORKLOAD_NAME"),w);
          3855 | 				sprintf(w,"%8.8s",r->r792rgrp);
          3856 | 				rexx.set(var("RMF2",count,"RESOURCE_GROUP"),w);
          3857 | 			ü
          3858 | 			r =(R792elem *)((char *)r+hdr->smf79asl);
          3859 |
          3860 | 		ü
          3861 | 		rexx.set(var("RMF2",0),count);
          3862 | 	ü
          3863 | 	else
          3864 | 	ä
          3865 | 		sprintf(w," ERB2XDGS rc:%d reason:%dÖn",MyDgsReturnCode,MyDgsReasonCode);
          3866 | 		rexx.set("RMF2_ERROR",w);
          3867 | 	ü
          3868 | 	free( MyDgsAnswerAreaAddress );
          3869 |
          3870 | 	return( MyDgsReturnCode );
          3871 |
          3872 | ü;
          3873 |
          3874 | const int Mbyte = 1024*1024;
          3875 | char vsmlistÄMbyteÜ;
          3876 | cvtP      cvt = *(cvtP* )0x10;
          3877 | asvtP    asvt = asvtP(cvt->cvtasvt);
          3878 | unsigned char * *  asvtEntryP   =(unsigned char * *)&(asvt->asvtenty);
          3879 | int procVsmlist(char *);
          3880 |
          3881 | class  asData
          3882 | ä
          3883 | public:
          3884 | 	ascbP ascb;
          3885 | 	short asid;
          3886 | 	char jobnameÄ9Ü;
          3887 | 	char jobidÄ9Ü;
          3888 | 	DBLWRD cpu;
          3889 | 	DBLWRD cpuOld;
          3890 | 	DBLWRD * ejst;
          3891 | 	DBLWRD * srbt;
          3892 | 	int stor;
          3893 | 	int storDiff;
          3894 | 	DBLWRD * iosx;
          3895 | 	DBLWRD  excp;
          3896 | 	DBLWRD  excpDiff;
          3897 | 	char timeÄ30Ü;
          3898 | 	int times;
          3899 | public:
          3900 | 	asData(const char * );
          3901 | 	asData(int id)
          3902 | 	ä
          3903 | 		if ((unsigned char )(*asvtEntryPÄidÜ)&(unsigned char)0x80==0)
          3904 | 			ascb = (ascbP)asvtEntryPÄidÜ;
          3905 | 		init();
          3906 | 	ü
          3907 | 	int set();
          3908 | 	void print();
          3909 | 	int printRexx(REXXVAR *);
          3910 | 	void get();
          3911 | 	void printTitle()
          3912 | 	ä
          3913 | 		printf(" %s %sÖn",jobname,jobid);
          3914 | 		printf("    Cpu     CpuD      Stor      StorD      Excp    ExcpD Ön");
          3915 | 	ü
          3916 | private:
          3917 | 	ascbP search(const char *);
          3918 | 	void init();
          3919 | ü ;
          3920 |
          3921 | asData::asData(const char * name)
          3922 | ä
          3923 | 	if (ascb = search(name))
          3924 | 		init();
          3925 | ü
          3926 |
          3927 | ascbP asData::search(const char * name)
          3928 | ä
          3929 | 	ascbP a = NULL;
          3930 | 	unsigned char * pascb =(unsigned char *)&(asvt->asvtenty);
          3931 | 	for (int i =0;i<asvt->asvtmaxi;i++,pascb+=4)
          3932 | 	ä
          3933 | 		if ((*pascb&(unsigned char)0x80)==0)
          3934 | 		ä
          3935 | 			a = *(ascbP *)pascb;
          3936 | 			if (a)
          3937 | 			ä
          3938 | 				if (a->ascbjbni)
          3939 | 				ä
          3940 | 					if (memcmp(name,a->ascbjbni,strlen(name))==0)
          3941 | 						break;
          3942 | 				ü
          3943 | 				else
          3944 | 					if  (memcmp(name,a->ascbjbns,strlen(name))==0)
          3945 | 						break;
          3946 | 			ü
          3947 | 		ü
          3948 | 	ü
          3949 | 	if (JOBENV::debug)
          3950 | 		_dump("ASCB",(char *)a,1024);
          3951 | 	return a;
          3952 | ü
          3953 |
          3954 | void asData::init()
          3955 | ä
          3956 | 	asid  = ascb->ascbasid;
          3957 | 	if (ascb->ascbjbni)
          3958 | 		sprintf(jobname,"%8.8s",ascb->ascbjbni);
          3959 | 	else
          3960 | 		sprintf(jobname,"%8.8s",ascb->ascbjbns);
          3961 | 	for(int i =0;i<8;i++)
          3962 | 		if (jobnameÄiÜ == ' ')
          3963 | 			jobnameÄiÜ = 0;
          3964 |
          3965 | 	assbP assb = (assbP)ascb->ascbassb;
          3966 | 	iazjsabP jsab = (iazjsabP)assb->assbjsab;
          3967 | 	if (jsab->jsabjbidÄ0Ü)
          3968 | 		sprintf(jobid,"%8.8s",jsab->jsabjbid);
          3969 | 	else
          3970 | 		jobidÄ0Ü =0;
          3971 | 	ejst = (DBLWRD *)&(ascb->ascbejst);
          3972 | 	srbt = (DBLWRD *)&(ascb->ascbsrbt);
          3973 | 	cpu = *ejst+*srbt;
          3974 | 	cpuOld = cpu;
          3975 | 	iosx = (DBLWRD *)&(ascb->ascbiosx);
          3976 | 	excp = *iosx;
          3977 | 	excpDiff = excp;
          3978 | 	if (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))
          3979 | 		stor = procVsmlist(vsmlist);
          3980 | 	else
          3981 | 		stor = 0;
          3982 | 	storDiff = stor;
          3983 | 	times = 0;
          3984 | 	formatTime(time,sizeof(time),"%H:%M:%S");
          3985 | 	if (JOBENV::debug)
          3986 | 		_dump("asData",(char *)this,sizeof(asData));
          3987 | ü;
          3988 |
          3989 | int  asData::set()
          3990 | ä
          3991 | 	times +=   (argvÄ2Ü?atoi(argvÄ2Ü):60);
          3992 | 	assbP assb = (assbP)ascb->ascbassb;
          3993 | 	iazjsabP jsab = (iazjsabP)assb->assbjsab;
          3994 |
          3995 | 	if (((ascb->ascbjbni&&memcmp(jobname,ascb->ascbjbni,8)==0)]]
          3996 | 		memcmp(jobname,ascb->ascbjbns,8)==0)&&
          3997 | 		memcmp(jobid,jsab->jsabjbid,8)==0)
          3998 | 	ä
          3999 | 		cpuOld = cpu;
          4000 | 		cpu = *ejst+*srbt;
          4001 | 		excpDiff = *iosx-excp;
          4002 | 		excp = *iosx;
          4003 | 		if (mvs()->Vsmlist(ascb,vsmlist,sizeof(vsmlist)))
          4004 | 		ä
          4005 | 			int _stor = procVsmlist(vsmlist);
          4006 | 			storDiff = _stor-stor;
          4007 | 			stor = _stor;
          4008 | 		ü
          4009 | 		else
          4010 | 			stor = storDiff =0;
          4011 | 		formatTime(time,sizeof(time),"%H:%M:%S");
          4012 | 		if (JOBENV::debug)
          4013 | 			_dump("asData",(char *)this,sizeof(asData));
          4014 | 		return 1;
          4015 | 	ü
          4016 | 	else
          4017 | 		return 0;
          4018 | ü
          4019 |
          4020 | void asData::print()
          4021 | ä
          4022 | 	int _cpu = ((cpu>>12)+500)/1000;
          4023 | 	int _cpuOld = ((cpuOld>>12)+500)/1000;
          4024 | 	printf("%d %d %d %d %d %llu  %lluÖn",times,
          4025 | 		_cpu,_cpu-_cpuOld,
          4026 | 		stor,storDiff,
          4027 | 		excp,excpDiff);
          4028 | ü
          4029 |
          4030 | int asData::printRexx(REXXVAR * rexx)
          4031 | ä
          4032 | 	int _cpu = ((cpu>>12)+500)/1000;
          4033 | 	int _excp = excp/1024;
          4034 | 	/*
          4035 | 	rexx->set(var(jobname,0,"CPU"),_cpu);
          4036 | 	rexx->set(var(jobname,0,"EXCP"),_excp);
          4037 | 	rexx->set(var(jobname,0,"VSTOR"),stor);
          4038 | 	*/
          4039 | 	return stor;
          4040 | ü
          4041 |
          4042 | int procVsmlist(char * pList)
          4043 | ä
          4044 | 	if (JOBENV::debug)
          4045 | 		_dump("vsmList",pList,4096);
          4046 | 	int size = 0;
          4047 | 	int *p   = (int *)pList;
          4048 | 	int  tcbcount = *p++;
          4049 | 	while (tcbcount--)
          4050 | 	ä
          4051 | 		bool need = true;
          4052 | 		int tcb    =  *p++;
          4053 | 		int spcount = *p++;
          4054 | 		while(spcount--)
          4055 | 		ä
          4056 | 			int subpool = (*p>>8&0x000000FF);
          4057 | 			p+=1;
          4058 | 			need = (tcb == *p++);
          4059 | 			int bcount = *p++;
          4060 | 			while(bcount--)
          4061 | 			ä
          4062 | 				if ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)
          4063 | 				ä
          4064 | 					if (JOBENV::debug)
          4065 | 						printf(" %p  ",*p);
          4066 | 					p+=1;
          4067 | 					if (JOBENV::debug)
          4068 | 						printf(" %p",*p);
          4069 | 					size +=*p++;
          4070 | 					if (JOBENV::debug)
          4071 | 						printf(" size:%d subpool:%dÖn",size,subpool);
          4072 | 				ü
          4073 | 				else
          4074 | 					p+=2;
          4075 | 				int fcount = *p++;
          4076 | 				while(fcount--)
          4077 | 				ä
          4078 | 					if ((*p&0x7F000000)&&need&&subpool-229&&subpool-230&&subpool-236&&subpool-237)
          4079 | 					ä
          4080 | 						if (JOBENV::debug)
          4081 | 							printf(" %p  ",*p);
          4082 | 						p+=1;
          4083 | 						if (JOBENV::debug)
          4084 | 							printf(" %p",*p);
          4085 | 						size -=*p++;
          4086 | 						if (JOBENV::debug)
          4087 | 							printf(" size:%d subpool:%dÖn",size,subpool);
          4088 | 					ü
          4089 | 					else
          4090 | 						p+=2;
          4091 | 				ü
          4092 | 			ü
          4093 | 		ü
          4094 | 	ü
          4095 | 	return (size+512)/1024;
          4096 | ü
          4097 |
          4098 |
          4099 | int _vsmlist()
          4100 | ä
          4101 | 	jobEnv = new JOBENV(argvÄ0Ü);
          4102 | 	asData * as = new asData(argvÄ1Ü);
          4103 | 	as->printTitle();
          4104 | 	int count= argvÄ3Ü?atoi(argvÄ2Ü):10;
          4105 | 	for(int i = 0;i<count;i++)
          4106 | 	ä
          4107 | 		sleep(argvÄ2Ü?atoi(argvÄ2Ü):60);
          4108 | 		as->set();
          4109 | 		as->print();
          4110 | 	ü
          4111 | 	return 0;
          4112 | ü
          4113 |
          4114 | int _rexxvsm()
          4115 | ä
          4116 | 	REXXVAR rexx(JOBENV::debug);
          4117 | 	jobEnv = new JOBENV(argvÄ0Ü);
          4118 | 	asData * as = new asData(argvÄ1Ü);
          4119 | 	return as->printRexx(&rexx);
          4120 | ü
          4121 | #define GIM_FREE      "FREE    "
          4122 | #define GIM_QUERY     "QUERY   "
          4123 | #define GIM_VERSION   "VERSION "
          4124 | #define APILANG   "ENU"
          4125 | #define TXT_VER   "VER"
          4126 | #define LEN_ETYPE        12
          4127 | #define LEN_ENAME         8
          4128 | #define LEN_ZNAME         7
          4129 | #define LEN_VERNUM        3
          4130 | #define LEN_TXTVER        3
          4131 | #define LEN_MSG         256
          4132 | typedef void APIPGM(char *,void *,void *,char *,long *,long  *, char *);
          4133 | typedef void cfunc();
          4134 | #pragma linkage(APIPGM,OS)
 =======================================¬
 "//'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'", line 4134.24: CCN6404 (W) The parameter "OS" specified for "pragma linkage" is not valid. The
 pragma is ignored.
          4135 |
          4136 | static void errprint(char *, long, long, ITEM_LIST *,REXXVAR &);
          4137 | static char *valprint(ITEM_LIST *);
          4138 | static void resprint(ENTRY_LIST *,REXXVAR & );
          4139 |
          4140 | int _rexxgim()
          4141 | ä
          4142 | 	char wÄ32760Ü;
          4143 | 	jobEnv = new JOBENV(argvÄ0Ü);
          4144 | 	REXXVAR rexx(JOBENV::debug);
          4145 | 	long  rc,cc;
          4146 | 	QUERY_PARMS qparms;
          4147 | 	P_QUERY_PARMS pqparms = &qparms;
          4148 | 	ENTRY_LIST  *qreslt;
          4149 | 	ITEM_LIST   *msgbuff;
          4150 | 	APIPGM      *gimapi;
          4151 | 	API_VERSION pgmversion;
          4152 | 	API_VERSION *apiversion;
          4153 |
          4154 | 	char csiÄ45Ü;
          4155 | 	char zoneÄ100Ü;
          4156 | 	char entÄ100Ü;
          4157 | 	char subentÄ100Ü;
          4158 | 	char filterÄ1024Ü;
          4159 |
          4160 | 	rc = 0;
          4161 | 	cc = 0;
          4162 |
          4163 | 	/******************************************************************/
          4164 | 	/* Initialize pgmversion to API version used when program was     */
          4165 | 	/* written.  This is compared with the version returned from a    */
          4166 | 	/* call to GIMAPI with the VERSION command.                       */
          4167 | 	/******************************************************************/
          4168 |
          4169 | 	strncpy((char *)&pgmversion,"01090500",8);
          4170 |
          4171 | 	/***********************************************/
          4172 | 	/* Load the GIMAPI load module for use later   */
          4173 | 	/***********************************************/
          4174 | 	gimapi = (APIPGM *) fetch("GIMAPI");
          4175 | 	rexx.set(var("GIM",0),0);
          4176 | 	rexx.set("GIM_ERROR","");
          4177 | 	/****************************************************************/
          4178 | 	/* Call GIMAPI with VERSION to check if compatible with version */
          4179 | 	/* used when program was written.                               */
          4180 | 	/****************************************************************/
          4181 | 	gimapi(GIM_VERSION,0,(void**) &apiversion,APILANG,&rc,&cc,(char *)&msgbuff);
          4182 |
          4183 | 	if (rc|=0)
          4184 | 	ä
          4185 | 		errprint(GIM_VERSION, rc, cc, msgbuff,rexx);
          4186 | 		if (rc>4) goto EXIT;
          4187 | 	ü
          4188 |
          4189 | 	if (strncmp((const char *)&pgmversion,(const char *)apiversion,8)>0)
          4190 | 	ä
          4191 | 		printf("Incompatible Versions of the APIÖn");
          4192 | 		printf("  API Version: %.8sÖn",apiversion);
          4193 | 		printf("  Pgm Version: %.8sÖn",&pgmversion);
          4194 | 		goto EXIT;
          4195 | 	ü
          4196 | 	sprintf(w,"%.2s %.2s %.2s %.2s",apiversion->apiver,apiversion->apirel,apiversion->apimod,apiversion
          4196 | ->apiptf);
          4197 | 	rexx.set("GIM_VERSION",w);
          4198 | 	/*
          4199 | 	printf("API Version Used:Ön");
          4200 | 	printf("  Version: %.2sÖn",apiversion->apiver);
          4201 | 	printf("  Release: %.2sÖn",apiversion->apirel);
          4202 | 	printf("  Mod    : %.2sÖn",apiversion->apimod);
          4203 | 	printf("  PTF    : %.2sÖnÖn",apiversion->apiptf);
          4204 | 	*/
          4205 | 	/*****************************************************/
          4206 | 	/* Create the QUERY. Put the parameter strings into  */
          4207 | 	/* variables and put the addresses of those variables*/
          4208 | 	/* in the query parameter structure along with the   */
          4209 | 	/* length of those strings.                          */
          4210 | 	/*****************************************************/
          4211 | 	strcpy(csi,rexx.fetch("GIM_CSI"));
          4212 | 	strcpy(zone,rexx.fetch("GIM_ZONE"));
          4213 | 	strcpy(ent,rexx.fetch("GIM_ENTRY"));
          4214 | 	strcpy(subent,rexx.fetch("GIM_SUBENTRY"));
          4215 | 	strcpy(filter,rexx.fetch("GIM_FILTER"));
          4216 |
          4217 | 	qparms.csi          = csi;
          4218 | 	qparms.csilen       = strlen(csi);
          4219 | 	qparms.zone         = zone;
          4220 | 	qparms.zonelen      = strlen(zone);
          4221 | 	qparms.entrytype    = ent;
          4222 | 	qparms.entrylen     = strlen(ent);
          4223 | 	qparms.subentrytype = subent;
          4224 | 	qparms.subentrylen  = strlen(subent);
          4225 | 	qparms.filter       = filter;
          4226 | 	qparms.filterlen    = strlen(filter);
          4227 |
          4228 | 	gimapi(GIM_QUERY,&pqparms,(void**) &qreslt,APILANG,&rc,&cc,(char *)&msgbuff);
          4229 |
          4230 | 	if (rc|=0)
          4231 | 	ä
          4232 | 		errprint(GIM_QUERY, rc, cc, msgbuff,rexx);
          4233 | 		if (rc>4) goto EXIT;
          4234 | 	ü
          4235 |
          4236 | 	/******************************************/
          4237 | 	/* Call routine to print results of query */
          4238 | 	/******************************************/
          4239 | 	resprint(qreslt,rexx);
          4240 |
          4241 | EXIT:
          4242 | 	/****************************************/
          4243 | 	/* Free storage returned from the QUERY */
          4244 | 	/****************************************/
          4245 | 	gimapi(GIM_FREE,0,0,APILANG,&rc,&cc,(char *)&msgbuff);
          4246 | 	return 0;
          4247 | 	//release ((cfunc*)gimapi); ????????????????
          4248 | ü
          4249 |
          4250 | /******************************/
          4251 | /* Print results of the query */
          4252 | /******************************/
          4253 | static void resprint(ENTRY_LIST *head,REXXVAR &rexx)
          4254 | ä
          4255 | 	ENTRY_LIST  *curetype;
          4256 | 	CSI_ENTRY   *curentry;
          4257 | 	SUBENTRY    *cursubent;
          4258 | 	VER         *curver;
          4259 | 	SUBENTRY    *curversub;
          4260 | 	char        etypeÄ13Ü;
          4261 | 	char        vernumberÄ13Ü;
          4262 | 	char        versubtypeÄ13Ü;
          4263 | 	char        stEnameÄLEN_ENAME+1Ü;
          4264 | 	char        stZnameÄLEN_ZNAME+1Ü;
          4265 | 	char wÄ32760Ü;
          4266 | 	/********************************/
          4267 | 	/* Loop through each entry type */
          4268 | 	/********************************/
          4269 | 	int index = 0;
          4270 | 	for (curetype=head; curetype|=0 ; curetype=curetype->next)
          4271 | 	ä
          4272 | 		/********************************************/
          4273 | 		/* Print name of entry type being processed */
          4274 | 		/********************************************/
          4275 |
          4276 | 		strncpy(etype,curetype->type,LEN_ETYPE);
          4277 | 		etypeÄLEN_ETYPEÜ = 'Ö0';
          4278 | 		rexx.set(var("GIM",++index,"ETYPE"),etype);
          4279 |
          4280 | 		/********************************************************/
          4281 | 		/* Loop through each entry printing the ename and zone  */
          4282 | 		/* then the list of subentry values.                    */
          4283 | 		/********************************************************/
          4284 | 		for (curentry=curetype->entries;
          4285 | 			curentry|=0;
          4286 | 			curentry=curentry->next)
          4287 | 		ä
          4288 | 			strncpy(stEname,curentry->entryname,LEN_ENAME);
          4289 | 			stEnameÄLEN_ENAMEÜ='Ö0';
          4290 | 			strncpy(stZname,curentry->zonename,LEN_ZNAME);
          4291 | 			stZnameÄLEN_ZNAMEÜ='Ö0';
          4292 |
          4293 | 			rexx.set(var("GIM",index,"ENAME"),stEname);
          4294 | 			rexx.set(var("GIM",index,"ZONE"),stZname);
          4295 | 			int vindex= 0;
          4296 | 			for (cursubent=curentry->subentries;
          4297 | 				cursubent|=0;
          4298 | 				cursubent=cursubent->next)
          4299 | 			ä
          4300 | 				strncpy(etype,cursubent->type,LEN_ETYPE);
          4301 | 				etypeÄLEN_ETYPEÜ = 'Ö0';
          4302 | 				char * val ;
          4303 | 				if ((strncmp(etype,TXT_VER,LEN_TXTVER)) == 0)
          4304 | 				ä
          4305 | 					for (curver=(P_VER) cursubent->subentrydata;
          4306 | 						curver|=0;
          4307 | 						curver=curver->next)
          4308 | 					ä
          4309 | 						strncpy(vernumber,curver->vernum,LEN_VERNUM);
          4310 | 						vernumberÄLEN_VERNUMÜ='Ö0';
          4311 | 						for (curversub=curver->verdata;
          4312 | 							curversub|=0;
          4313 | 							curversub=curversub->next)
          4314 | 						ä
          4315 |
          4316 | 							/*********************************/
          4317 | 							/* Now print ver subentry values */
          4318 | 							/*********************************/
          4319 | 							strncpy(versubtype,curversub->type,LEN_ETYPE);
          4320 | 							versubtypeÄLEN_ETYPEÜ='Ö0';
          4321 | 							sprintf(w,"%.6s.%s",versubtype,vernumber);
          4322 | 							val = valprint((ITEM_LIST *)curversub->subentrydata);
          4323 | 							rexx.set(var("GIM",index,w),val);
          4324 | 							rexx.set(var("GIM",index,"VAR",++vindex,"TYPE"),w);
          4325 | 							rexx.set(var("GIM",index,"VAR",vindex,"VALUE"),val);
          4326 | 						ü
          4327 | 					ü
          4328 | 				ü
          4329 | 				else
          4330 | 				ä
          4331 | 					val = valprint((ITEM_LIST *)cursubent->subentrydata);
          4332 | 					rexx.set(var("GIM",index,etype),val);
          4333 | 					rexx.set(var("GIM",index,"VAR",++vindex,"TYPE"),etype);
          4334 | 					rexx.set(var("GIM",index,"VAR",vindex,"VALUE"),val);
          4335 | 				ü
          4336 | 			ü
          4337 | 			rexx.set(var("GIM",index,"VAR",0,"VALUE"),vindex);
          4338 | 		ü
          4339 | 	ü
          4340 | 	rexx.set(var("GIM",0),index);
          4341 | ü
          4342 |
          4343 | static char * valprint(ITEM_LIST *item1)
          4344 | ä
          4345 | 	static char wÄ1024*1024Ü;
          4346 | 	char        databuffÄ1024*128Ü;
          4347 | 	ITEM_LIST   *curitem;
          4348 | 	wÄ0Ü = 0;
          4349 | 	for (curitem=item1;
          4350 | 		curitem|=0;
          4351 | 		curitem=curitem->next)
          4352 | 	ä
          4353 | 		strncpy(databuff,curitem->data,curitem->datalen);
          4354 | 		databuffÄcuritem->datalenÜ = 'Ö0';
          4355 | 		sprintf(w+strlen(w),"%s ",databuff);
          4356 | 	ü   return w;
          4357 | ü
          4358 |
          4359 | static void errprint(char *cmd, long rc, long cc, ITEM_LIST *msgs,REXXVAR & rexx)
          4360 | ä
          4361 | 	char   msgoutÄLEN_MSG+1Ü;
          4362 | 	ITEM_LIST *curmsg;
          4363 | 	unsigned short i;
          4364 | 	char wÄ1024Ü;
          4365 | 	sprintf(w,"Error processing command: %s. RC=%d CC=%dÖn",
          4366 | 		cmd,rc,cc);
          4367 | 	rexx.set("GIM_ERROR",w);
          4368 | 	int index= 1;
          4369 | 	/*************************************************/
          4370 | 	/* Loop through a linked list of error messages  */
          4371 | 	/* printing them out.                            */
          4372 | 	/*************************************************/
          4373 | 	for (curmsg=msgs; curmsg|=0; curmsg=curmsg->next)
          4374 | 	ä
          4375 | 		strncpy(msgout,curmsg->data,curmsg->datalen);
          4376 | 		msgoutÄcurmsg->datalenÜ = 'Ö0';
          4377 | 		rexx.set(var("GIM_ERR",index),msgout);
          4378 | 	ü
          4379 | 	rexx.set(var("GIM_ERR",0),index);
          4380 | ü
          4381 |
          4382 |
          4383 | int main(int argC,char * argVÄÜ)
          4384 | ä
          4385 | 	const static char *version=ISIS_VERSION;
          4386 | 	const static char *compileDate=ISIS_VERSION_DATE;
          4387 | 	if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
          4388 | 		printf(" MVSTOOL tester %s %s Version:%s Compiled:%sÖn",ISIS_PF_SID,ISIS_PF_NAME,version,compileDa
          4388 | te);
          4389 | 	int j = 0;
          4390 | 	int count = 1;
          4391 | 	for (j= 0;testCasesÄjÜ.addr;j++)
          4392 | 		if (memcmpi(testCasesÄjÜ.name,argVÄ0Ü,strlen(argVÄ0Ü))==0)
          4393 | 			break;
          4394 | 	if (testCasesÄjÜ.addr==NULL)
          4395 | 	ä
          4396 | 		for (int i = 0;i<argC;i++)
          4397 | 		ä
          4398 | 			if (memcmpi(argVÄiÜ,"-t",2)==0)
          4399 | 			ä
          4400 | 				for (j= 0;testCasesÄjÜ.addr;j++)
          4401 | 					if (memcmpi(testCasesÄjÜ.name,argVÄiÜ+2,strlen(argVÄiÜ)-2)==0)
          4402 | 						break;
          4403 | 				if (testCasesÄjÜ.addr==NULL)
          4404 | 				ä
          4405 | 					printf("Invalid test case, %sÖn",argVÄiÜ+2);
          4406 | 					for(j=0;testCasesÄjÜ.addr;j++)
          4407 | 						printf("  %sÖn",testCasesÄjÜ.name);
          4408 | 					exit(8);
          4409 | 				ü
          4410 | 			ü
          4411 | 			/*
          4412 | 			else if (memcmpi(argVÄiÜ,"-r",2)==NULL)
          4413 | 			ä
          4414 | 			count = atoi(argVÄiÜ+2);
          4415 | 			if (count==0)
          4416 | 			count = 1;
          4417 | 			ü
          4418 | 			*/
          4419 | 			else
          4420 | 			ä
          4421 | 				argvÄargc++Ü = argVÄiÜ;
          4422 | 				if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
          4423 | 					printf("argÄ%dÜ:%sÖn",argc-1,argvÄargc-1Ü);
          4424 | 			ü
          4425 | 		ü
          4426 | 	ü
          4427 | 	else
          4428 | 	ä
          4429 | 		for (int i =0;i<argC;i++)
          4430 | 			argvÄargc++Ü = argVÄiÜ;
          4431 | 		if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
          4432 | 			printf("argÄ%dÜ:%sÖn",argc-1,argvÄargc-1Ü);
          4433 | 	ü
          4434 | 	if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
          4435 | 	ä
          4436 | 		printf(" Starting %s %d times(argc:%d)ÖnÖnÖn",testCasesÄjÜ.name,count,argc);
          4437 | 		for(;count;count--)
          4438 | 		ä
          4439 | 			if (strcmp(argVÄ0Ü,"MVSTOOL")==0)
          4440 | 				printf(" ended with %dÖn",testCasesÄjÜ.addr());
          4441 | 		ü
          4442 | 		return 0;
          4443 | 	ü
          4444 | 	else
          4445 | 		return (testCasesÄjÜ.addr());
          4446 | ü
0                                   * * * * *   E N D   O F   S O U R C E   * * * * *
-

15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'                      07.01.13 11:01:28
0                                    * * * * *   I N C L U D E S   * * * * *
     1  =  //'ESA.PRJ.CBTEXP.HPP(ISISDEF)'
     2  =  //'ESA.PRJ.CBTEXP.HPP(MVSTOOL)'
     3  =  //'CEE.SCEEH.H(STDARG)'
     4  =  //'CEE.SCEEH.H(FEATURES)'
     5  =  //'ESA.PRJ.CBTEXP.HPP(VERSINFO)'
     6  =  //'ESA.PRJ.CBTEXP.HPP(OSMFIND)'
     7  =  //'ESA.PRJ.CBTEXP.HPP(OS)'
     8  =  //'CEE.SCEEH.H(STDLIB)'
     9  =  //'CEE.SCEEH.H(BUILTINS)'
    10  =  //'CEE.SCEEH.H(STDDEF)'
    11  =  //'CEE.SCEEH.H(STRING)'
    12  =  //'ESA.PRJ.CBTEXP.HPP(MCHAIN)'
    13  =  //'ESA.PRJ.CBTEXP.HPP(MVSBASE)'
    14  =  //'ESA.PRJ.CBTEXP.HPP(MERROR)'
    15  =  //'ESA.PRJ.CBTEXP.HPP(DSNAMEUT)'
    16  =  //'CEE.SCEEH.H(ASSERT)'
    17  =  //'CEE.SCEEH.H(STDIO)'
    18  =  //'CEE.SCEEH.SYS.H(TYPES)'
    19  =  //'ESA.PRJ.CBTEXP.HPP(FILETYPE)'
    20  =  //'CEE.SCEEH.H(SIGNAL)'
    21  =  //'CEE.SCEEH.H(LOCALE)'
    22  =  //'CEE.SCEEH.H(DLL)'
    23  =  //'CEE.SCEEH.H(LIMITS)'
    24  =  //'CEE.SCEEH.H(UNISTD)'
    25  =  //'CEE.SCEEH.H(INTTYPES)'
    26  =  //'CEE.SCEEH.H(STDINT)'
    27  =  //'CEE.SCEEH.H(ICONV)'
    28  =  //'CEE.SCEEH.H(PWD)'
    29  =  //'CEE.SCEEH.H(ASSERT)'
    30  =  //'CEE.SCEEH.H(CTYPE)'
    31  =  //'CEE.SCEEH.H(STRINGS)'
    32  =  //'CEE.SCEEH.H(DIRENT)'
    33  =  //'CEE.SCEEH.H(FCNTL)'
    34  =  //'CEE.SCEEH.SYS.H(MODES)'
    35  =  //'CEE.SCEEH.SYS.H(STAT)'
    36  =  //'CEE.SCEEH.SYS.H(MNTENT)'
    37  =  //'CEE.SCEEH.SYS.H(STAT)'
    38  =  //'CEE.SCEEH.SYS.H(WAIT)'
    39  =  //'CEE.SCEEH.SYS.H(SOCKET)'
    40  =  //'CEE.SCEEH.SYS.H(UIO)'
    41  =  //'CEE.SCEEH.SYS.H(TIME)'
    42  =  //'CEE.SCEEH.SYS.H(MSG)'
    43  =  //'CEE.SCEEH.SYS.H(IPC)'
    44  =  //'CEE.SCEEH.ARPA.H(INET)'
    45  =  //'CEE.SCEEH.H(NETDB)'
    46  =  //'CEE.SCEEH.H(ERRNO)'
    47  =  //'CEE.SCEEH.H(SPAWN)'
    48  =  //'CEE.SCEEH.H(ASSERT)'
    49  =  //'ESA.PRJ.CBTEXP.HPP(IBMDEBUG)'
    50  =  //'CEE.SCEEH.H(CTEST)'
    51  =  //'ESA.PRJ.CBTEXP.HPP(MISC)'
    52  =  //'CEE.SCEEH.H(TIME)'
    53  =  //'ESA.PRJ.CBTEXP.HPP(CASMIF)'
    54  =  //'ESA.PRJ.CBTEXP.HPP(ASMIF)'
    55  =  //'ESA.PRJ.CBTEXP.HPP(MSGMGR)'
    56  =  //'ESA.PRJ.CBTEXP.HPP(JOBENV)'
    57  =  //'ESA.PRJ.CBTEXP.HPP(STRSERV)'
    58  =  //'ESA.PRJ.CBTEXP.HPP(REXXVAR)'
    59  =  //'ESA.PRJ.CBTEXP.HPP(SHVBLOCK)'
    60  =  //'ESA.PRJ.CBTEXP.HPP(IGGCSI00)'
    61  =  //'ESA.PRJ.CBTEXP.HPP(SUBTASK)'
    62  =  //'CEE.SCEEH.NETINET.H(IN)'
    63  =  //'ESA.PRJ.CBTEXP.HPP(SYMBP)'
    64  =  //'ESA.PRJ.CBTEXP.HPP(SMF)'
    65  =  //'ESA.PRJ.CBTEXP.HPP(SMF30CAS)'
    66  =  //'ESA.PRJ.CBTEXP.HPP(SMF30ID)'
    67  =  //'ESA.PRJ.CBTEXP.HPP(SMF30SAP)'
    68  =  //'ESA.PRJ.CBTEXP.HPP(SMF14)'
    69  =  //'ESA.PRJ.CBTEXP.HPP(SMF30CMP)'
    70  =  //'ESA.PRJ.CBTEXP.HPP(SMF30MSE)'
    71  =  //'ESA.PRJ.CBTEXP.HPP(SMF30PRF)'
    72  =  //'ESA.PRJ.CBTEXP.HPP(SMF30UD)'
    73  =  //'ESA.PRJ.CBTEXP.HPP(SMF30ACS)'
    74  =  //'ESA.PRJ.CBTEXP.HPP(SMF30DR)'
    75  =  //'ESA.PRJ.CBTEXP.HPP(SMF30OP)'
    76  =  //'ESA.PRJ.CBTEXP.HPP(SMF30URA)'
    77  =  //'ESA.PRJ.CBTEXP.HPP(SMF30AR)'
    78  =  //'ESA.PRJ.CBTEXP.HPP(SMF30EXP)'
    79  =  //'ESA.PRJ.CBTEXP.HPP(SMF30OPS)'
    80  =  //'ESA.PRJ.CBTEXP.HPP(SMF30RM)'
    81  =  //'ESA.PRJ.CBTEXP.HPP(SMFRCD30)'
    82  =  //'ESA.PRJ.CBTEXP.HPP(SMFRCD92)'
    83  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FCL)'
    84  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FOP)'
    85  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FSM)'
    86  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FSP)'
    87  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FSR)'
    88  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FSU)'
    89  =  //'ESA.PRJ.CBTEXP.HPP(SMF92FSV)'
    90  =  //'ESA.PRJ.CBTEXP.HPP(SMF92ID)'
    91  =  //'ESA.PRJ.CBTEXP.HPP(SMF92MMP)'
    92  =  //'ESA.PRJ.CBTEXP.HPP(SMF92MUN)'
    93  =  //'ESA.PRJ.CBTEXP.HPP(SMF92SSS)'
    94  =  //'ESA.PRJ.CBTEXP.HPP(ERMDSMP0)'
    95  =  //'ESA.PRJ.CBTEXP.HPP(R79FIRML)'
    96  =  //'ESA.PRJ.CBTEXP.HPP(R79EDS)'
    97  =  //'ESA.PRJ.CBTEXP.HPP(R79ECPD)'
    98  =  //'ESA.PRJ.CBTEXP.HPP(R79ECS)'
    99  =  //'ESA.PRJ.CBTEXP.HPP(R79EGD)'
   100  =  //'ESA.PRJ.CBTEXP.HPP(R79DDS)'
   101  =  //'ESA.PRJ.CBTEXP.HPP(R79CCHNL)'
   102  =  //'ESA.PRJ.CBTEXP.HPP(R79CCNTL)'
   103  =  //'ESA.PRJ.CBTEXP.HPP(R79BELEM)'
   104  =  //'ESA.PRJ.CBTEXP.HPP(R79BCNTL)'
   105  =  //'ESA.PRJ.CBTEXP.HPP(R79AELEM)'
   106  =  //'ESA.PRJ.CBTEXP.HPP(R799ELEM)'
   107  =  //'ESA.PRJ.CBTEXP.HPP(R798ELEM)'
   108  =  //'ESA.PRJ.CBTEXP.HPP(R797ELEM)'
   109  =  //'ESA.PRJ.CBTEXP.HPP(R796ELEM)'
   110  =  //'ESA.PRJ.CBTEXP.HPP(R795ELEM)'
   111  =  //'ESA.PRJ.CBTEXP.HPP(R794)'
   112  =  //'ESA.PRJ.CBTEXP.HPP(R793)'
   113  =  //'ESA.PRJ.CBTEXP.HPP(R792ELEM)'
   114  =  //'ESA.PRJ.CBTEXP.HPP(R791ELEM)'
   115  =  //'ESA.PRJ.CBTEXP.HPP(R79CHL)'
   116  =  //'ESA.PRJ.CBTEXP.HPP(SMF79HDR)'
   117  =  //'ESA.PRJ.CBTEXP.HPP(SMF79PRO)'
   118  =  //'ESA.PRJ.CBTEXP.HPP(OSMF)'
   119  =  //'ESA.PRJ.CBTEXP.HPP(PFSWREC)'
   120  =  //'ESA.PRJ.CBTEXP.HPP(MVSSTR)'
   121  =  //'ESA.PRJ.CBTEXP.HPP(IHAPSA)'
   122  =  //'ESA.PRJ.CBTEXP.HPP(IHACVT)'
   123  =  //'ESA.PRJ.CBTEXP.HPP(IHASCVT)'
   124  =  //'ESA.PRJ.CBTEXP.HPP(IKJTCB)'
   125  =  //'ESA.PRJ.CBTEXP.HPP(IHALDA)'
   126  =  //'ESA.PRJ.CBTEXP.HPP(IHAECVT)'
   127  =  //'ESA.PRJ.CBTEXP.HPP(IHAASCB)'
   128  =  //'ESA.PRJ.CBTEXP.HPP(IHAASSB)'
   129  =  //'ESA.PRJ.CBTEXP.HPP(CSVDLCB)'
   130  =  //'ESA.PRJ.CBTEXP.HPP(IHALLT)'
   131  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOCVT)'
   132  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOPNT)'
   133  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOCVE)'
   134  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMAR)'
   135  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARA)'
   136  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARL)'
   137  =  //'ESA.PRJ.CBTEXP.HPP(IEWPMARR)'
   138  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESB)'
   139  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESD)'
   140  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESL)'
   141  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESN)'
   142  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESP)'
   143  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESR)'
   144  =  //'ESA.PRJ.CBTEXP.HPP(IGWDESX)'
   145  =  //'ESA.PRJ.CBTEXP.HPP(IGWDST)'
   146  =  //'ESA.PRJ.CBTEXP.HPP(SMDE)'
   147  =  //'ESA.PRJ.CBTEXP.HPP(SMDEFD)'
   148  =  //'ESA.PRJ.CBTEXP.HPP(SMDENAME)'
   149  =  //'ESA.PRJ.CBTEXP.HPP(SMDENLST)'
   150  =  //'ESA.PRJ.CBTEXP.HPP(SMDEPNAM)'
   151  =  //'ESA.PRJ.CBTEXP.HPP(SMDETOKN)'
   152  =  //'ESA.PRJ.CBTEXP.HPP(TSVT)'
   153  =  //'ESA.PRJ.CBTEXP.HPP(TJDSECTD)'
   154  =  //'ESA.PRJ.CBTEXP.HPP(TVDSECTD)'
   155  =  //'ESA.PRJ.CBTEXP.HPP(DCUOUTH)'
   156  =  //'ESA.PRJ.CBTEXP.HPP(F1DSCB)'
   157  =  //'ESA.PRJ.CBTEXP.HPP(F2DSCB)'
   158  =  //'ESA.PRJ.CBTEXP.HPP(F3DSCB)'
   159  =  //'ESA.PRJ.CBTEXP.HPP(MXDT)'
   160  =  //'ESA.PRJ.CBTEXP.HPP(MXIS)'
   161  =  //'ESA.PRJ.CBTEXP.HPP(MXIREQ)'
   162  =  //'ESA.PRJ.CBTEXP.HPP(PGTHA)'
   163  =  //'ESA.PRJ.CBTEXP.HPP(PGTHB)'
   164  =  //'ESA.PRJ.CBTEXP.HPP(PGTHC)'
   165  =  //'ESA.PRJ.CBTEXP.HPP(PGTHD)'
   166  =  //'ESA.PRJ.CBTEXP.HPP(PGTHE)'
   167  =  //'ESA.PRJ.CBTEXP.HPP(PGTHF)'
   168  =  //'ESA.PRJ.CBTEXP.HPP(PGTHG)'
   169  =  //'ESA.PRJ.CBTEXP.HPP(PGTHH)'
   170  =  //'ESA.PRJ.CBTEXP.HPP(PGTHJ)'
   171  =  //'ESA.PRJ.CBTEXP.HPP(PGTHK)'
   172  =  //'ESA.PRJ.CBTEXP.HPP(PGPS)'
   173  =  //'ESA.PRJ.CBTEXP.HPP(BPXZOTCB)'
   174  =  //'ESA.PRJ.CBTEXP.HPP(BPXZTHLI)'
   175  =  //'ESA.PRJ.CBTEXP.HPP(BPXZPRLI)'
   176  =  //'ESA.PRJ.CBTEXP.HPP(BPXYOPNF)'
   177  =  //'ESA.PRJ.CBTEXP.HPP(RMCT)'
   178  =  //'ESA.PRJ.CBTEXP.HPP(CSD)'
   179  =  //'ESA.PRJ.CBTEXP.HPP(PCCA)'
   180  =  //'ESA.PRJ.CBTEXP.HPP(PCCAVT)'
   181  =  //'ESA.PRJ.CBTEXP.HPP(SMCABASE)'
   182  =  //'ESA.PRJ.CBTEXP.HPP(IHAASVT)'
   183  =  //'ESA.PRJ.CBTEXP.HPP(MNTE)'
   184  =  //'ESA.PRJ.CBTEXP.HPP(MNTEH)'
   185  =  //'ESA.PRJ.CBTEXP.HPP(TRVT)'
   186  =  //'ESA.PRJ.CBTEXP.HPP(TBVT)'
   187  =  //'ESA.PRJ.CBTEXP.HPP(TTE)'
   188  =  //'ESA.PRJ.CBTEXP.HPP(CEECAA)'
   189  =  //'ESA.PRJ.CBTEXP.HPP(CEEMCH)'
   190  =  //'ESA.PRJ.CBTEXP.HPP(CEEDSAHP)'
   191  =  //'ESA.PRJ.CBTEXP.HPP(CEEDSA)'
   192  =  //'ESA.PRJ.CBTEXP.HPP(CEEPCB)'
   193  =  //'ESA.PRJ.CBTEXP.HPP(CEECEDB)'
   194  =  //'ESA.PRJ.CBTEXP.HPP(CEECDLL)'
   195  =  //'ESA.PRJ.CBTEXP.HPP(PA1H)'
   196  =  //'ESA.PRJ.CBTEXP.HPP(PA2H)'
   197  =  //'ESA.PRJ.CBTEXP.HPP(PA1EPNM)'
   198  =  //'ESA.PRJ.CBTEXP.HPP(IHASTCB)'
   199  =  //'ESA.PRJ.CBTEXP.HPP(IHAASXB)'
   200  =  //'ESA.PRJ.CBTEXP.HPP(CCT)'
   201  =  //'ESA.PRJ.CBTEXP.HPP(ICT)'
   202  =  //'ESA.PRJ.CBTEXP.HPP(MCT)'
   203  =  //'ESA.PRJ.CBTEXP.HPP(EZBYPTHA)'
   204  =  //'ESA.PRJ.CBTEXP.HPP(EZBCTHDR)'
   205  =  //'ESA.PRJ.CBTEXP.HPP(PCOMS83)'
   206  =  //'ESA.PRJ.CBTEXP.HPP(RFIS)'
   207  =  //'ESA.PRJ.CBTEXP.HPP(RFIM)'
   208  =  //'ESA.PRJ.CBTEXP.HPP(IOCC)'
   209  =  //'ESA.PRJ.CBTEXP.HPP(IAZJSAB)'
   210  =  //'ESA.PRJ.CBTEXP.HPP(CVTXTNT1)'
   211  =  //'ESA.PRJ.CBTEXP.HPP(CVTXTNT2)'
   212  =  //'ESA.PRJ.CBTEXP.HPP(DB2STR)'
   213  =  //'ESA.PRJ.CBTEXP.HPP(QW0325)'
   214  =  //'ESA.PRJ.CBTEXP.HPP(QW0273)'
   215  =  //'ESA.PRJ.CBTEXP.HPP(QW0272)'
   216  =  //'ESA.PRJ.CBTEXP.HPP(QW0250Z)'
   217  =  //'ESA.PRJ.CBTEXP.HPP(QW0250X)'
   218  =  //'ESA.PRJ.CBTEXP.HPP(QW0250DS)'
   219  =  //'ESA.PRJ.CBTEXP.HPP(QW0250CN)'
   220  =  //'ESA.PRJ.CBTEXP.HPP(QW0250HE)'
   221  =  //'ESA.PRJ.CBTEXP.HPP(QW0237)'
   222  =  //'ESA.PRJ.CBTEXP.HPP(QW0233)'
   223  =  //'ESA.PRJ.CBTEXP.HPP(QW0177)'
   224  =  //'ESA.PRJ.CBTEXP.HPP(QW0173)'
   225  =  //'ESA.PRJ.CBTEXP.HPP(QW0112)'
   226  =  //'ESA.PRJ.CBTEXP.HPP(QW0097)'
   227  =  //'ESA.PRJ.CBTEXP.HPP(QW0096)'
   228  =  //'ESA.PRJ.CBTEXP.HPP(QW0092)'
   229  =  //'ESA.PRJ.CBTEXP.HPP(QW0066)'
   230  =  //'ESA.PRJ.CBTEXP.HPP(QW0065)'
   231  =  //'ESA.PRJ.CBTEXP.HPP(QW0064)'
   232  =  //'ESA.PRJ.CBTEXP.HPP(QW0063)'
   233  =  //'ESA.PRJ.CBTEXP.HPP(QW0062)'
   234  =  //'ESA.PRJ.CBTEXP.HPP(QW0061)'
   235  =  //'ESA.PRJ.CBTEXP.HPP(QW0060)'
   236  =  //'ESA.PRJ.CBTEXP.HPP(QW0059)'
   237  =  //'ESA.PRJ.CBTEXP.HPP(QW0058)'
   238  =  //'ESA.PRJ.CBTEXP.HPP(QW0055)'
   239  =  //'ESA.PRJ.CBTEXP.HPP(QW0053)'
   240  =  //'ESA.PRJ.CBTEXP.HPP(QW0022)'
   241  =  //'ESA.PRJ.CBTEXP.HPP(QWHD)'
   242  =  //'ESA.PRJ.CBTEXP.HPP(QWHU)'
   243  =  //'ESA.PRJ.CBTEXP.HPP(QWHT)'
   244  =  //'ESA.PRJ.CBTEXP.HPP(QWHC)'
   245  =  //'ESA.PRJ.CBTEXP.HPP(QWHA)'
   246  =  //'ESA.PRJ.CBTEXP.HPP(QWHS)'
   247  =  //'ESA.PRJ.CBTEXP.HPP(QWT0)'
   248  =  //'ESA.PRJ.CBTEXP.HPP(SM102)'
   249  =  //'ESA.PRJ.CBTEXP.HPP(ENFSERV)'
   250  =  //'ESA.PRJ.CBTEXP.HPP(AREN)'
   251  =  //'ESA.PRJ.CBTEXP.HPP(DACH)'
   252  =  //'ESA.PRJ.CBTEXP.HPP(DCCD)'
   253  =  //'ESA.PRJ.CBTEXP.HPP(DCCDARRY)'
   254  =  //'ESA.PRJ.CBTEXP.HPP(DLENF)'
   255  =  //'ESA.PRJ.CBTEXP.HPP(ENFCT)'
   256  =  //'ESA.PRJ.CBTEXP.HPP(ENFP)'
   257  =  //'ESA.PRJ.CBTEXP.HPP(ENF067)'
   258  =  //'ESA.PRJ.CBTEXP.HPP(ENF2)'
   259  =  //'ESA.PRJ.CBTEXP.HPP(ENF37)'
   260  =  //'ESA.PRJ.CBTEXP.HPP(ENF40)'
   261  =  //'ESA.PRJ.CBTEXP.HPP(ENF45)'
   262  =  //'ESA.PRJ.CBTEXP.HPP(ENF51C)'
   263  =  //'ESA.PRJ.CBTEXP.HPP(ENF55)'
   264  =  //'ESA.PRJ.CBTEXP.HPP(ENF58)'
   265  =  //'ESA.PRJ.CBTEXP.HPP(ENF58EXT)'
   266  =  //'ESA.PRJ.CBTEXP.HPP(ENF64)'
   267  =  //'ESA.PRJ.CBTEXP.HPP(ENF70)'
   268  =  //'ESA.PRJ.CBTEXP.HPP(ENF70EXT)'
   269  =  //'ESA.PRJ.CBTEXP.HPP(ENSG)'
   270  =  //'ESA.PRJ.CBTEXP.HPP(EUNLD)'
   271  =  //'ESA.PRJ.CBTEXP.HPP(E63R)'
   272  =  //'ESA.PRJ.CBTEXP.HPP(EVARY)'
   273  =  //'ESA.PRJ.CBTEXP.HPP(IFBENF36)'
   274  =  //'ESA.PRJ.CBTEXP.HPP(IFBNLOG)'
   275  =  //'ESA.PRJ.CBTEXP.HPP(IFBNTKN)'
   276  =  //'ESA.PRJ.CBTEXP.HPP(IXGENF)'
   277  =  //'ESA.PRJ.CBTEXP.HPP(IXLYCFSE)'
   278  =  //'ESA.PRJ.CBTEXP.HPP(SIV1V2V3)'
   279  =  //'ESA.PRJ.CBTEXP.HPP(SI00)'
   280  =  //'ESA.PRJ.CBTEXP.HPP(SI11V1)'
   281  =  //'ESA.PRJ.CBTEXP.HPP(SI22V1)'
   282  =  //'ESA.PRJ.CBTEXP.HPP(SI22V2)'
   283  =  //'ESA.PRJ.CBTEXP.HPP(SI22V3)'
   284  =  //'ESA.PRJ.CBTEXP.HPP(SRMENF1)'
   285  =  //'ESA.PRJ.CBTEXP.HPP(TTRENF60)'
   286  =  //'ESA.PRJ.CBTEXP.HPP(WLMENF1)'
   287  =  //'ESA.PRJ.CBTEXP.HPP(WLMENF56)'
   288  =  //'ESA.PRJ.CBTEXP.HPP(WLMENF57)'
   289  =  //'ESA.PRJ.CBTEXP.HPP(WLMENF61)'
   290  =  //'ESA.PRJ.CBTEXP.HPP(SDWA)'
   291  =  //'ESA.PRJ.CBTEXP.HPP(ADSRCMPS)'
   292  =  //'ESA.PRJ.CBTEXP.HPP(HDLOGREC)'
   293  =  //'ESA.PRJ.CBTEXP.HPP(DUMPXREC)'
   294  =  //'ESA.PRJ.CBTEXP.HPP(MPFXREC)'
   295  =  //'ESA.PRJ.CBTEXP.HPP(GIMHC370)'
   296  =  //'CEE.SCEEH.H(MATH)'
-
                                  * * * * *   E N D   O F   I N C L U D E S   * * * * *
0
15694A01 V1.12 z/OS XL C++              //'ESA.PRJ.CBTEXP.CPP(MVSTOOL)'                      07.01.13 11:01:28
-                           * * * * *   M E S S A G E   S U M M A R Y   * * * * *
0TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
                (U)       (S)         (E)        (W)          (I)
    15           0         0           0         15            0
0                    * * * * *   E N D   O F   M E S S A G E   S U M M A R Y   * * * * *
0                        * * * * *   E N D   O F   C O M P I L A T I O N   * * * * *
