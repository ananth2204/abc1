{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012635000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2410226, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE708.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2410226, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2410226, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE708.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b\"\\x00'\\x06\"", "DS1TRBAL": "b'\\xc7\\x16'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xe9\\x00\\x0b\\x04\\xec\\x00\\x05\\x00('", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x008\\x01\\x12 \\x9f\\x01\\x12 \\x9f\\x00A\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-07-27T00:00:00", "modifydate": "2012-07-27T00:41:38", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  708\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE708\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 88 MEMBERS COUNTED; CUMULATIVE SIZE IS 22,083 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/27/12    00:41:38    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x06\\x17o\\x01\\x06\\x17o\\x08\\x10\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-06-25T00:00:00", "modifydate": "2006-06-25T08:10:26", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     MPFXTALL update\nFrom:        Glenn Siegel <glennsiegel@optonline.net>\nDate:        Sat, 24 Jun 2006 21:17:50 -0400\n\nUpdate/change to the GET REPLYID.\n\nIt seems I used an @ for the reply id replacement character and\nDean happens to use an @ in his SMF dataset name causing him a\nproblem, sorry Dean.  So I have changed the @ to a & which can't\nbe used in a dataset name.  Jim from Alaska please make sure you\nmodify your replyid to use the new character;\n\nSETSWITCH IDMSV8   &,/CHE DUMPQ\n\nSince I just created this feature for Jim I figure no one else is\nusing it yet, but if you are please take note when installing the\nnew release.\n\nAnd while I was in there I added a couple a more goodies for\nDean, the IF MSGID NE and IF MSGNE+ xx FOR xx.\n\nFeed back from more of you would be nice.\n\nGlennSiegel@optonline.net\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x07\\x13\\x7f\\x01\\x07\\x13\\x7f\\x084\\x00T\\x00T\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-17T00:00:00", "modifydate": "2007-05-17T08:34:19", "lines": 84, "newlines": 84, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     Update MPFXTALL Version 5.9\nFrom:        Glenn Siegel <glennsiegel@optonline.net>\nDate:        Wed, 02 May 2007 23:36:16 -0400\nTo:          Glenn Siegel <glennsiegel@optonline.net>\n\n//*     You want colors I'll give you colors, this ones for Jason.  *\n//*       Change the color make it blink, underline and/or reverse  *\n//*       video.  The options for the DISPLAY command are BLUE,     *\n//*       PINK, RED, GREEN, TURQUOISE, YELLOW, WHITE, BLINK,        *\n//*       REVERSE and UNDERLINE.                                    *\n//*       The commands member to make it blink red would be:        *\n//*                 DISPLAY RED                                     *\n//*                 DISPLAY BLINK                                   *\n//*                                                                 *\n//*     A few very slick additions from Garry Green.  First is the  *\n//*       ASTYPE this allows you too check if the task is a TSO,    *\n//*       Batch or STC, T for TSO, J for BATCH and S for STC.       *\n//*        IF ASTYPE EQ T                                           *\n//*        IF ASTYPE EQ J                                           *\n//*        IF ASTYPE EQ S                                           *\n//*       So if you needed to reply cancel to the following message *\n//*       only for TSO Userid's                                     *\n//*        *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.         *\n//*       The Commands IEF238D member would look like this          *\n//*        IF ASTYPE EQ T                                           *\n//*        REPLY NN,CANCEL                                          *\n//*        ENDIF ASTYPE                                             *\n//*       *                                                         *\n//*     Now for the TSOROUTE command this allows a TSO user to      *\n//*       reply to there own outstanding requests WTOR's from there *\n//*       own TSO userid for WTOR's issued for there TSO userid.    *\n//*       So if you want all user's to be able to reply to message  *\n//*       *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.          *\n//*       The Commands IEF238D member would look like this          *\n//*        IF ASTYPE EQ T                                           *\n//*        TSOROUTE REPLY                                           *\n//*        ENDIF ASTYPE                                             *\n//*       This will allow only the TSO userid to reply to the       *\n//*       outstanding reply, the TSO userid will receive the        *\n//*       following message, there will be no outstanding request   *\n//*       on the master console:                                    *\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *\n//*         WTOR-CONSOLES CAN'T REPLY                               *\n//*        IEF238D GGG - REPLY DEVICE NAME OR 'CANCEL'.             *\n//*       *                                                         *\n//*       The other options for TSOROUTE are TSOROUTE which only    *\n//*       sends a message to to the TSO userid as follows:          *\n//*        MPF203I FOLLOWING WTOR FOR DISPLAY ONLY - REPLY MUST BE  *\n//*         ENTERED FROM CONSOLE                                    *\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *\n//*       *                                                         *\n//*       And the TSOROUTE SUPPRESS this will suppress the reply    *\n//*       to the outstanding request, good for password replies.    *\n//*       The message sent to the TSO userid is as follows:         *\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *\n//*         WTOR-CONSOLES CAN'T REPLY                               *\n//*        MPF202I REPLY VALUE YOU ENTER WILL BE SUPPRESSED FROM    *\n//*         CONSOLE, JOBLOG & SYSLOG                                *\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *\n//*                                                                 *\n//*     ESTAE recovery routine added by Garry GREAT addition        *\n//*       now no matter what happens MPFTXALL will stay alive.      *\n//*       If an MPF exit routine such as MPFXTALL abends, it is     *\n//*       disabled for ALL the message id's that it is associated   *\n//*       This can have several undesirable side effects:           *\n//*       1) Perhaps the exit is abending due to a bug triggered by *\n//*          only one message id that rarely occurs.                *\n//*       2) Until the disablement is noticed, many automation      *\n//*          events can be lost.                                    *\n//*       ESTAEX protection around the entire MPFXTALL code;        *\n//*       in the event that there is an abend in MPFXTALL, a WTO    *\n//*       MPF038E MPFXTALL ABENDED; ABEND WAS SUPPRESSED message    *\n//*       will be issued, no further processing will occur for the  *\n//*       message that caused the abend, but since the abend was    *\n//*       suppressed, MPFXTALL remains active.                      *\n//*                                                                 *\n\nGlenn Siegel\n631-444-5339\n516-607-4005 cell\n631-444-5364 fax\n414-434-5339 efax\nGlennSiegel@optonline.net\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE03": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00X\\x01\\x07'?\\x01\\x07'?\\x15X\\x00)\\x00)\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-09-30T00:00:00", "modifydate": "2007-09-30T15:58:58", "lines": 41, "newlines": 41, "modlines": 0, "user": "GSI"}, "text": "Subject:     Just an FYI about MPFXTALL\nFrom:        Steve W\nDate:        Thursday, August 02, 2007 12:31 PM\n\nHi Glenn,\nI'm starting to implement your MPFXTALL to take care of\nsome automation at IPL.  I had the following RACF error\non my test LPAR the first time I tried to start TCPIP\nafter \"OMVS INITIALIZATION COMPLETE\" message was generated.\nThis is the only use of MPFXTALL that has required any\nRACF (except for the MPFLOAD proc) so far.  It hasn't\ncaused any problem & may not even be worth mentioning,\nbut I thought I would drop you a note & let you know about it.\n\nPS -- Great software & easy to use!!\n\nS TCPIP\nSE 'ICH70004I USER(WCPSOMVS) GROUP(OMVSGRP) NAME(WCPS OMVS SUPERUSER)\n   ',LOGON,USER=(TECCWG)\nSE 'ICH70004I ATTEMPTED ''UPDATE'' ACCESS OF\n   ',LOGON,USER=(TECCWG)\nSE 'ICH70004I ENTITY ''MVS.START.STC.TCPIP''\n   ',LOGON,USER=(TECCWG)\nSE 'ICH70004I IN CLASS ''OPERCMDS'' AT 11:15:08 ON AUGUST 2, 2007\n   ',LOGON,USER=(TECCWG)\nIEE345I START    AUTHORITY INVALID, FAILED BY SECURITY PRODUCT\nICH408I USER(WCPSOMVS) GROUP(OMVSGRP ) NAME(WCPS OMVS SUPERUSER ) 920\n  MVS.START.STC.TCPIP CL(OPERCMDS)\n  INSUFFICIENT ACCESS AUTHORITY\n  FROM MVS.START.STC.** (G)\n  ACCESS INTENT(UPDATE )  ACCESS ALLOWED(NONE   )\n /* Issued by MPFXTALL for BPXI004I         */\nIEF196I  /* Issued by MPFXTALL for BPXI004I         */\nBPXI004I OMVS INITIALIZATION COMPLETE\n\nThanks,\nSteve W\nSr Systems Programmer\n\nI don't mind coming to work, it's the eight hour wait to go home\nthat I don't like!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE04": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x12 \\x9f\\x01\\x12 \\x9f\\x00\"\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-27T00:00:00", "modifydate": "2012-07-27T00:22:48", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  FW: MPFXDSPL new program in the MPF series\nFrom:     Glenn Siegel <glennsiegel@optonline.net>\nDate:     7/26/2012 8:15 PM\nTo:       \"Golob, Sam\" <sbgolob@cbttape.org>\n\nfyi\n\nFrom: Tom Hutchins \u00ddmailto:THutchins@METRARR.COM\u00a8\nSent: Thursday, July 26, 2012 3:34 PM\nTo: GlennSiegel@optonline.net\nSubject: MPFXDSPL new program in the MPF series\n\nDear Glenn,\n\nI love your MPFEXIT programs.  As a result of them we are able to\ndrop NetView saving us a good bit of money that we can use to\ninvest on other software.  At IPL time it takes the operator's\nerrors out of the Shutdown procedure.  I have mashed together\nMPFLOAD and MPFXTALL plus source code for a date routine to\ncreate a display of the MPF in core table.  We use MPFXDSPL to\ndocument the MPF table.  This guarantees in black and white, that\nthere is no question if a change was made and what the change is.\nI hope that you can use it.\n\nThomas G Hutchins\nSr. Systems Programmer\nNortheast Illinois Regional Commuter Railroad (METRA)\n547 W Jackson\nChicago, IL 60661\n(312) 322-6719\nthutchins@metrarr.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00(\\x01\\x05\\x02_\\x01\\x07'?\\x15%\\x02\\x96\\x00a\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2005-01-25T00:00:00", "modifydate": "2007-09-30T15:25:28", "lines": 662, "newlines": 97, "modlines": 0, "user": "GSI"}, "text": "//*                                                                 *   FILE 708\n//*     This isn't your mother's MPF exit!  It's the do all MPF     *   FILE 708\n//*       exit.  It should replace most, if not all of your         *   FILE 708\n//*       existing MPF exits.  If you are not using any MPF         *   FILE 708\n//*       exits, you should check this one out.  Version 5.9.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     The purpose of this product is to assist in automation      *   FILE 708\n//*       of your MVS operating system.  This product will work     *   FILE 708\n//*       on all system levels of ESA, OS/390 and z/OS.             *   FILE 708\n//*                                                                 *   FILE 708\n//*     The use of MPF has now become very easy.  No more recoding  *   FILE 708\n//*       or writing a new MPF exits every time you need to issue a *   FILE 708\n//*       reply or command.  No more maintaining multiple MPF exits *   FILE 708\n//*       for seperate events.                                      *   FILE 708\n//*                                                                 *   FILE 708\n//*     Ease of use, once installed all that needs to be done to    *   FILE 708\n//*       manage a new message is the following four (4) steps:     *   FILE 708\n//*             1. Create a new member in the commands dataset.     *   FILE 708\n//*             2. Make an entry into MPFLSTxx.                     *   FILE 708\n//*             3. Start MPFLOAD                                    *   FILE 708\n//*             4. SET MPF=xx                                       *   FILE 708\n//*                                                                 *   FILE 708\n//*     Manage up to 1000 different messages and 102 commands/logic *   FILE 708\n//*      per message.                                               *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit can do the following:                             *   FILE 708\n//*                                                                 *   FILE 708\n//*     Reply to outstanding messages (WTOR's).  It can reply       *   FILE 708\n//*                *                                                *   FILE 708\n//*                R 00,WARM,NOREQ                                  *   FILE 708\n//*                    to WTOR                                      *   FILE 708\n//*                01 $HASP426 SPECIFY OPTIONS - JES2               *   FILE 708\n//*                *                                                *   FILE 708\n//*       The $HASP426 commands member would look like this:        *   FILE 708\n//*                *                                                *   FILE 708\n//*                REPLY NN,WARM,NOREQ                              *   FILE 708\n//*                *                                                *   FILE 708\n//*       With an update from Dean Tesar WTOR's with an RMAX of     *   FILE 708\n//*          up to four digits is possible, if your RMAX is set to  *   FILE 708\n//*          RMAX(999) or RMAX(9999) using three or four digit      *   FILE 708\n//*          replies your commands member would look like:          *   FILE 708\n//*                *                                                *   FILE 708\n//*                REPLY NNNN,WARM,NOREQ                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     Issue; START commands, VARY commands, DISPLAY commands,     *   FILE 708\n//*       SE commands, ROUTE commands, JES commands... in other     *   FILE 708\n//*       words, any commands for any messages, i.e.                *   FILE 708\n//*                *                                                *   FILE 708\n//*                S TSO                                            *   FILE 708\n//*                    for message                                  *   FILE 708\n//*                IST020I VTAM INITIALIZATION COMPLETE             *   FILE 708\n//*                                                                 *   FILE 708\n//*     It also has IF SYSID logic built into it; so you can        *   FILE 708\n//*       issue different commands to different systems.  For       *   FILE 708\n//*       example, say you want to issue START commands for         *   FILE 708\n//*       VPS, TND and OMEGVTM on your production LPAR SSC and      *   FILE 708\n//*       only wanted to issue a START for TND on your systems      *   FILE 708\n//*       programming LPAR SYSPGM and START of TSO on both.  The    *   FILE 708\n//*       IF SYSID can also be used as an outer or inner IF, more   *   FILE 708\n//*       on that later.                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IST020I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                S VPS                                            *   FILE 708\n//*                S TND                                            *   FILE 708\n//*                S OMEGAVTM                                       *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SYSPGM                               *   FILE 708\n//*                S TND                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                S TSO                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     It can also find up to 4 separate words in a message up to  *   FILE 708\n//*       25 characters per word.  All words must appear in that    *   FILE 708\n//*       message, in any order.                                    *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF ALL EQ word1 word2 word3 word4                *   FILE 708\n//*                Do Something                                     *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*     If you wanted to start NETSPOOL after a PrintServer         *   FILE 708\n//*       Daemon has started; the MPFXTALL program is also case     *   FILE 708\n//*       sensitive, so for the following message:                  *   FILE 708\n//*                *                                                *   FILE 708\n//*    AOP075I Daemon aopd was started successfully. (program:aopd) *   FILE 708\n//*                *                                                *   FILE 708\n//*       The AOP075I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF ALL EQ Daemon aopd was started                *   FILE 708\n//*                S NETSPOOL                                       *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     Oh, it also highlights messages.  To highlight abends;      *   FILE 708\n//*       The IEF450I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                HIGHLIGHT                                        *   FILE 708\n//*                *                                                *   FILE 708\n//*      Or use the AUTO/TOKEN feature AUTO(HIGHLITE).              *   FILE 708\n//*       No commands member is necessary for this.                 *   FILE 708\n//*         IEF450I,USEREXIT(MPFXTALL),AUTO(HIGHLITE),SUP(NO)       *   FILE 708\n//*                *                                                *   FILE 708\n//*      If you need to highlight a multi-line message you will     *   FILE 708\n//*       need to use AUTO(SINGLE) this treats a multi-line as a    *   FILE 708\n//*       single line.                                              *   FILE 708\n//*         SSC111I,USEREXIT(MPFXTALL),AUTO(SINGLE),SUP(NO)         *   FILE 708\n//*                                                                 *   FILE 708\n//*     Then there's IF WORD logic check for one word up to 25      *   FILE 708\n//*       characters in one specific location from 01 to 99.  This  *   FILE 708\n//*       function can also be used with a wild card.  Also, here's *   FILE 708\n//*       the usage of the IF SYSID used as an outer if.  So, if    *   FILE 708\n//*       the system is SSC and the job that abended starts with    *   FILE 708\n//*       PROD then the IEF450I commands member would look like     *   FILE 708\n//*       this:                                                     *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                IF WORD 01 PROD*                                 *   FILE 708\n//*                HIGHLIGHT                                        *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now here's the GET and replace part of the program,     *   FILE 708\n//*       very slick if I may say so myself.  It retrieves a word   *   FILE 708\n//*       from whatever position you specify; then it replaces      *   FILE 708\n//*       any % in the commands with that word.  So, to have        *   FILE 708\n//*       MPFXTALL submit a job to dump an SMF dataset for the      *   FILE 708\n//*       following message:                                        *   FILE 708\n//*       *IEE362A SMF ENTER DUMP FOR SYS1.MAN2 ON SSCCAT           *   FILE 708\n//*       The commands member IEE362A would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                GET WORD 05                                      *   FILE 708\n//*                S SMFAUTO,SMFDSN='%'                             *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*       The resulting command issued by MPFXTALL would be:        *   FILE 708\n//*                *                                                *   FILE 708\n//*        S SMFAUTO,SMFDSN='SYS1.MAN2'                             *   FILE 708\n//*                *                                                *   FILE 708\n//*       The GET can also be used as an inner GET with all IF's.   *   FILE 708\n//*        So, you can do something fancy like this:                *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                IF WORD 06 SSCCAT                                *   FILE 708\n//*                GET WORD 05                                      *   FILE 708\n//*                S SMFAUTO,SMFDSN='%'                             *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*       Now, thanks to Peter Johnson this automation tool can     *   FILE 708\n//*        handle multi-line messages.  So, for this multi-line     *   FILE 708\n//*        SMF message:                                             *   FILE 708\n//*   IEE391A SMF ENTER DUMP FOR DATA SET ON VOLSER SSCCAT,         *   FILE 708\n//*                   DSN=SYS1.SSC.MAN1                             *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IEE391A commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                GET WORD 10                                      *   FILE 708\n//*                S SMFAUTO,%                                      *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*                *                                                *   FILE 708\n//*       The resulting command issued by MPFXTALL would be:        *   FILE 708\n//*                *                                                *   FILE 708\n//*                S SMFAUTO,DSN=SYS1.SSC.MAN1                      *   FILE 708\n//*                                                                 *   FILE 708\n//*     A new addition to the GET is the GET REPLYID this will      *   FILE 708\n//*       get the reply id number and replace any & with that       *   FILE 708\n//*       number in that commands member, see PUTSWITCH for usage.  *   FILE 708\n//*                                                                 *   FILE 708\n//*     And of course, it does write to operator, highlighted       *   FILE 708\n//*       or not.  So, if you wanted to send a WTO message for      *   FILE 708\n//*       message ID $HASP612;                                      *   FILE 708\n//*       The $HASP612 commands member would look like this:        *   FILE 708\n//*                *                                                *   FILE 708\n//*                WTO No jobs running on this system               *   FILE 708\n//*                *                                                *   FILE 708\n//*       And if you wanted it highlighted:                         *   FILE 708\n//*                *                                                *   FILE 708\n//*                WTOH No jobs running on this system              *   FILE 708\n//*                                                                 *   FILE 708\n//*     And it does suppression also.  To suppress a message like   *   FILE 708\n//*       $HASP100 from the syslog and joblog the $HASP100 member   *   FILE 708\n//*       would look like this:                                     *   FILE 708\n//*                *                                                *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*       Be cautious using SUPPRESS, once it's deletes thats it,   *   FILE 708\n//*       it's gone.                                                *   FILE 708\n//*                *                                                *   FILE 708\n//*     Now thanks to Dean Tesar we have the joblog only and syslog *   FILE 708\n//*       only suppression these modification will suppress only    *   FILE 708\n//*       the joblog or only the syslog messages:                   *   FILE 708\n//*                *                                                *   FILE 708\n//*                NOJOBLOG                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*                NOSYSLOG                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*     Or use the AUTO/TOKEN feature AUTO(SUPPRESS)                *   FILE 708\n//*       AUTO(NOJOBLOG) AUTO(NOSYSLOG).                            *   FILE 708\n//*       No commands member is necessary for these.                *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(SUPPRESS)             *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(NOJOBLOG)             *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(NOSYSLOG)             *   FILE 708\n//*                *                                                *   FILE 708\n//*     If you need to only suppress from the console an MPFLSTxx   *   FILE 708\n//*       entry like this will do the trick.                        *   FILE 708\n//*                xxxxxxxx,SUP(YES)                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     You want colors I'll give you colors, this ones for Jason.  *   FILE 708\n//*       Change the color make it blink, underline and/or reverse  *   FILE 708\n//*       video.  The options for the DISPLAY command are BLUE,     *   FILE 708\n//*       PINK, RED, GREEN, TURQUOISE, YELLOW, WHITE, BLINK,        *   FILE 708\n//*       REVERSE and UNDERLINE.                                    *   FILE 708\n//*       The commands member to make it blink red would be:        *   FILE 708\n//*                 DISPLAY RED                                     *   FILE 708\n//*                 DISPLAY BLINK                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     The AUTO/TOKEN feature allows you to SUPPRESS, NOJOBLOG,    *   FILE 708\n//*       NOSYSLOG and HIGHLITE multiple messages with one entry.   *   FILE 708\n//*       No commands member is necessary for this.                 *   FILE 708\n//*         BA*,USEREXIT(MPFXTALL),AUTO(SUPPRESS)                   *   FILE 708\n//*                *                                                *   FILE 708\n//*     Also, the AUTO/TOKEN feature has member selection, this     *   FILE 708\n//*       allows you to select a different commands member then     *   FILE 708\n//*       the messageID states.  This allows multiple messages to   *   FILE 708\n//*       point to one commands member.                             *   FILE 708\n//*         ABC1001E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)               *   FILE 708\n//*         ABC1002E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)               *   FILE 708\n//*                or                                               *   FILE 708\n//*         ABC*,USEREXIT(MPFXTALL),AUTO(ABCMSGS)                   *   FILE 708\n//*                *                                                *   FILE 708\n//*     Special character handling for message id's is now          *   FILE 708\n//*       available with the use of the AUTO/TOKEN feature.  For a  *   FILE 708\n//*       message that start with a special character like a dash - *   FILE 708\n//*       the MPFLSTxx member would contain the following:          *   FILE 708\n//*       -SSCCORP0*,SUP(NO),USEREXIT(MPFXTALL),AUTO(SSCCORP1)      *   FILE 708\n//*       And the commands member SSCCORP1 would contain whatever.  *   FILE 708\n//*                *                                                *   FILE 708\n//*     It also has a AUTO(SINGLE) which treats a multi-line as a   *   FILE 708\n//*       single line.                                              *   FILE 708\n//*                *                                                *   FILE 708\n//*     MPFXTALL normally displays the following message for any    *   FILE 708\n//*       managed message                                           *   FILE 708\n//*       /* Issued by MPFXTALL for messageID      */               *   FILE 708\n//*     If you wish not to display this use the following           *   FILE 708\n//*       AUTO/TOKEN feature NODISPLY                               *   FILE 708\n//*       SSCCORP9,USEREXIT(MPFXTALL),AUTO(NODISPLY)                *   FILE 708\n//*       or set the default for all like this:                     *   FILE 708\n//*       .DEFAULT,AUTO(NODISPLY)                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     Long message ID handling is also included, for long         *   FILE 708\n//*       message ID's such as:                                     *   FILE 708\n//*       SVT1P0001I SubTask 01 Completion - Group=22 Subgroup=L    *   FILE 708\n//*       Use the first 8 characters of the message ID for the      *   FILE 708\n//*       commands member name, so the commands member name for     *   FILE 708\n//*       the above message would be SVT1P000 and the MPFLSTxx      *   FILE 708\n//*       entry would look like this:                               *   FILE 708\n//*                *                                                *   FILE 708\n//*       SVT1P0001I,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*                *                                                *   FILE 708\n//*      In addition to the long message id handling I've added     *   FILE 708\n//*       logic testing for the message id.  So, here it is Dean    *   FILE 708\n//*       and Diana you asked for it, yes, I do requests.           *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IF MSGID EQ and IF MSGID NE for up to 25 character    *   FILE 708\n//*        message id's.                                            *   FILE 708\n//*       Say you need to handle several long messages with the     *   FILE 708\n//*       same first 8 characters like:                             *   FILE 708\n//*       SVT1P0011A Some message text                              *   FILE 708\n//*       SVT1P0011B Some other message text                        *   FILE 708\n//*       SVT1P0011C And another message text                       *   FILE 708\n//*       SVT1P0012A And the just one more                          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The MPFLSTxx member would contain the following:           *   FILE 708\n//*       SVT1P0011A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0011B,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0011C,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0012A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The commands member SVT1P001 in SYS1.MPF.COMMANDS would    *   FILE 708\n//*       contain the following:                                    *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011A                           *   FILE 708\n//*                Do something for this message                    *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011B                           *   FILE 708\n//*                Do something else for this message               *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011C                           *   FILE 708\n//*                And something different for this message         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0012A                           *   FILE 708\n//*                And something totally diferent for this message  *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*      Or you can use the AUTO/TOKEN feature for long message     *   FILE 708\n//*       handling to point to a separate commands member.          *   FILE 708\n//*      The MPFLSTxx member would contain the following:           *   FILE 708\n//*       SVT1P0011A,SUP(NO),USEREXIT(MPFXTALL),AUTO(SVT1P11A)      *   FILE 708\n//*       SVT1P0011B,SUP(NO),USEREXIT(MPFXTALL),AUTO(SVT1P11B)      *   FILE 708\n//*      And the two commands member you would have:                *   FILE 708\n//*       Do something                                              *   FILE 708\n//*         and                                                     *   FILE 708\n//*       Do something else                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*      IBM's MPF has a limitation of a max of 10 characters per   *   FILE 708\n//*       message, but MPFXTALL to the rescue, you can specify up   *   FILE 708\n//*       to 25 characters in the IF MSGID EQ section of the        *   FILE 708\n//*       product.  See the creme de la creme for details.          *   FILE 708\n//*                                                                 *   FILE 708\n//*     The IF MSGID+xx FOR xx this can be used when you have       *   FILE 708\n//*       dozens of similar messages like CSQ1234I, CSQ1234E,       *   FILE 708\n//*       CSQ1235I, CSQ1235E etc and you only want to only suppress *   FILE 708\n//*       the I level messages.                                     *   FILE 708\n//*       The MPFLSTxx member would contain:                        *   FILE 708\n//*       CSQ*,USEREXIT(MPFXTALL),AUTO(CSQMSGS)                     *   FILE 708\n//*                *                                                *   FILE 708\n//*       And the commands member CSQMSGS would look like this:     *   FILE 708\n//*                IF MSGID+07 FOR 01 I                             *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*      Also the if message id not equal can be used for checking  *   FILE 708\n//*       if part of the message not equal, coded like this.        *   FILE 708\n//*       message dosn't equal coded like this.                     *   FILE 708\n//*               IF MSGNE+07 FOR 01 I                              *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now thanks to Dean here is the MPFSUPNO, for those who  *   FILE 708\n//*       have their MPFLSTxx DEFAULT set to SUP(YES) and wish to   *   FILE 708\n//*       not suppress a specific message can do the following:     *   FILE 708\n//*                *                                                *   FILE 708\n//*                MPFLSTxx member:                                 *   FILE 708\n//*                CSQ*,USEREXIT(MPFXTALL),AUTO(CSQMSGS)            *   FILE 708\n//*                *                                                *   FILE 708\n//*                Commands member CSQMSGS:                         *   FILE 708\n//*                *DO NOT MPF SUPPRESS CSQ????E                    *   FILE 708\n//*                IF MSGID+07 FOR 01 E                             *   FILE 708\n//*                MPFSUPNO                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*        The end result would be all messages that start with     *   FILE 708\n//*        CSQ would be suppressed except for those message that    *   FILE 708\n//*        have an E in column 8.                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now for the creme de la creme.  I now present the       *   FILE 708\n//*       SWITCH/VARIABLE section of my product, consisting of the  *   FILE 708\n//*       set switch, delete switch, alter switch, if switch on,    *   FILE 708\n//*       if switch off, if switch equal and if switch not equal.   *   FILE 708\n//*       This is my way of thanking Don, Todd and Emma for         *   FILE 708\n//*       intrusting me with their OS upgrade project after only a  *   FILE 708\n//*       few conference calls.  I believe this should complete     *   FILE 708\n//*       your free automation solution.  I also believe everybody  *   FILE 708\n//*       else should thank them for inspiring me to write this     *   FILE 708\n//*       code.  With this addition to my product all of you should *   FILE 708\n//*       be armed sufficiently to totally eliminate any other      *   FILE 708\n//*       automation products at your shop.                         *   FILE 708\n//*      Now for the meat and taters:                               *   FILE 708\n//*      The SETSWITCH command will set a persistent switch with    *   FILE 708\n//*       a user defined name field up to 8 characters and a user   *   FILE 708\n//*       defined status/information field up to 16 characters.     *   FILE 708\n//*       Both fields have no other limitations; you can use any    *   FILE 708\n//*       characters, spaces, special characters and numbers.       *   FILE 708\n//*      The DELSWITCH command that's what it does, it deletes      *   FILE 708\n//*       the switch.                                               *   FILE 708\n//*      The ALTSWITCH is used to alter the status/information      *   FILE 708\n//*       part of the switch from anything to anything.             *   FILE 708\n//*      The PUTSWITCH places whatever is stored in the             *   FILE 708\n//*       status/information part of the switch to the console.     *   FILE 708\n//*      The IF SWITCH logic has four separate checks.              *   FILE 708\n//*      The IF SWITCH ON checks only to see if the switch is       *   FILE 708\n//*       on/exists, it doesn't check the status/information        *   FILE 708\n//*       section.                                                  *   FILE 708\n//*      The IF SWITCH OFF checks only to see if the switch is      *   FILE 708\n//*       off/doesn't exists.                                       *   FILE 708\n//*      The IF SWITCH EQ checks the named switch                   *   FILE 708\n//*       status/information field is equal to that of the if       *   FILE 708\n//*       statement.                                                *   FILE 708\n//*      The IF SWITCH NE checks the named switch                   *   FILE 708\n//*       status/information field to not be equal to the if        *   FILE 708\n//*       statement.  Here's all the different syntax:              *   FILE 708\n//*                *                                                *   FILE 708\n//*                * Correct positioning                            *   FILE 708\n//*          =COLS>123456789012345678901234567890123456789          *   FILE 708\n//*                *         |        |                             *   FILE 708\n//*                SETSWITCH xxxxxxxx xxxxxxxxxxxxxxxx              *   FILE 708\n//*                *         |                                      *   FILE 708\n//*                DELSWITCH xxxxxxxx                               *   FILE 708\n//*                *         |        |                             *   FILE 708\n//*                ALTSWITCH xxxxxxxx xxxxxxxxxxxxxxxx              *   FILE 708\n//*                *         |                                      *   FILE 708\n//*                PUTSWITCH xxxxxxxx                               *   FILE 708\n//*                *            |                                   *   FILE 708\n//*                IF SWITCH ON xxxxxxxx                            *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH ON                                  *   FILE 708\n//*                *             |                                  *   FILE 708\n//*                IF SWITCH OFF xxxxxxxx                           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH OFF                                 *   FILE 708\n//*                *            |        |                          *   FILE 708\n//*                IF SWITCH EQ xxxxxxxx xxxxxxxxxxxxxxxx           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH EQ                                  *   FILE 708\n//*                *            |        |                          *   FILE 708\n//*                IF SWITCH NE xxxxxxxx xxxxxxxxxxxxxxxx           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH NE                                  *   FILE 708\n//*                *                                                *   FILE 708\n//*      Here's a sample of usage for messages:                     *   FILE 708\n//*       DCOMMMP1:246:0:DB00308I - LOG AREA IS  50% FULL,          *   FILE 708\n//*       DCOMMMP1:246:0:DB00308I - LOG AREA IS  70% FULL,          *   FILE 708\n//*       DCOMMMT3:246:0:DB00308I - LOG AREA IS  50% FULL,          *   FILE 708\n//*       DCOMMMT3:246:0:DB00308I - LOG AREA IS  70% FULL,          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The MPFLSTxx entries would look like this:                 *   FILE 708\n//*       DCOMMMP1:*,USEREXIT(MPFXTALL),SUP(NO),AUTO(SPILL)         *   FILE 708\n//*       DCOMMMT3:*,USEREXIT(MPFXTALL),SUP(NO),AUTO(SPILL)         *   FILE 708\n//*       $HASP395,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)            *   FILE 708\n//*                *                                                *   FILE 708\n//*      The commands member SPILL would look like this:            *   FILE 708\n//*       IF MSGID EQ DCOMMMP1:246:0:DB00308I                       *   FILE 708\n//*       IF SWITCH OFF DCOMMMP1                                    *   FILE 708\n//*       SETSWITCH DCOMMMP1 Submitted DCOMSPLP                     *   FILE 708\n//*       S DCOMSPLP                                                *   FILE 708\n//*       WTO MPFXTALL submitted offload DCOMSPLP for DCOMMMP1      *   FILE 708\n//*       ENDIF SWITCH OFF                                          *   FILE 708\n//*       IF SWITCH ON DCOMMMP1                                     *   FILE 708\n//*       WTO DCOMSPLP active for DCOMMMP1 no offload submitted     *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF MSGID EQ DCOMMMT3:246:0:DB00308I                       *   FILE 708\n//*       IF SWITCH OFF DCOMMMT3                                    *   FILE 708\n//*       SETSWITCH DCOMMMT3 Submitted DCOMSPL3                     *   FILE 708\n//*       S DCOMSPL3                                                *   FILE 708\n//*       WTO MPFXTALL submitted offload DCOMSPL3 for DCOMMMT3      *   FILE 708\n//*       ENDIF SWITCH OFF                                          *   FILE 708\n//*       IF SWITCH ON DCOMMMT3                                     *   FILE 708\n//*       WTO DCOMSPL3 active for DCOMMMT3 no offload submitted     *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member $HASP395 would look like this:         *   FILE 708\n//*       IF WORD 01 DCOMSPLP                                       *   FILE 708\n//*       DELSWITCH DCOMMMP1                                        *   FILE 708\n//*       WTO DCOMSPLP has ended DCOMMMP1 switch has been reset     *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF WORD 01 DCOMSPL3                                       *   FILE 708\n//*       DELSWITCH DCOMMMT3                                        *   FILE 708\n//*       WTO DCOMSPL3 has ended DCOMMMT3 switch has been reset     *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Here's one usage for the PUTSWITCH and GET REPLYID this    *   FILE 708\n//*       one's for Jimmy from Alaska.                              *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Theses are the messages:                                   *   FILE 708\n//*       @32 REPLY WITH REQUEST TO IDMS V8                         *   FILE 708\n//*       @31 REPLY WITH REQUEST TO IDMS V9                         *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The MPFLSTxx entries would look like this:                 *   FILE 708\n//*       REPLY,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(NO)      *   FILE 708\n//*       SHUTIDMS,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(NO)   *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member REPLY would look like this:            *   FILE 708\n//*       IF WORD 05 V8                                             *   FILE 708\n//*       GET REPLYID                                               *   FILE 708\n//*       DELSWITCH IDMSV8                                          *   FILE 708\n//*       SETSWITCH IDMSV8   &,/CHE DUMPQ                           *   FILE 708\n//*       ENDGET ID                                                 *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF WORD 05 V9                                             *   FILE 708\n//*       GET REPLYID                                               *   FILE 708\n//*       DELSWITCH IDMSV9                                          *   FILE 708\n//*       SETSWITCH IDMSV9   &,/CHE DUMPQ                           *   FILE 708\n//*       ENDGET ID                                                 *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member SHUTIDMS would look like this:         *   FILE 708\n//*       IF SWITCH ON IDMSV8                                       *   FILE 708\n//*       PUTSWITCH IDMSV8                                          *   FILE 708\n//*       DELSWITCH IDMSV8                                          *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF SWITCH ON IDMSV9                                       *   FILE 708\n//*       PUTSWITCH IDMSV9                                          *   FILE 708\n//*       DELSWITCH IDMSV9                                          *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Then have your automation shutdown procedure issue a       *   FILE 708\n//*       SHUTIDMS and MPFXTALL will issue the following:           *   FILE 708\n//*        31,/CHE DUMPQ                                            *   FILE 708\n//*        32,/CHE DUMPQ                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     A few very slick additions from Garry Green.  First is the  *   FILE 708\n//*       ASTYPE this allows you too check if the task is a TSO,    *   FILE 708\n//*       Batch or STC, T for TSO, J for BATCH and S for STC.       *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        IF ASTYPE EQ J                                           *   FILE 708\n//*        IF ASTYPE EQ S                                           *   FILE 708\n//*       So if you needed to reply cancel to the following message *   FILE 708\n//*       only for TSO Userid's                                     *   FILE 708\n//*        *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.         *   FILE 708\n//*       The Commands IEF238D member would look like this          *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        REPLY NN,CANCEL                                          *   FILE 708\n//*        ENDIF ASTYPE                                             *   FILE 708\n//*       *                                                         *   FILE 708\n//*     Now for the TSOROUTE command this allows a TSO user to      *   FILE 708\n//*       reply to there own outstanding requests WTOR's from there *   FILE 708\n//*       own TSO userid for WTOR's issued for there TSO userid.    *   FILE 708\n//*       So if you want all user's to be able to reply to message  *   FILE 708\n//*       *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.          *   FILE 708\n//*       The Commands IEF238D member would look like this          *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        TSOROUTE REPLY                                           *   FILE 708\n//*        ENDIF ASTYPE                                             *   FILE 708\n//*       This will allow only the TSO userid to reply to the       *   FILE 708\n//*       outstanding reply, the TSO userid will receive the        *   FILE 708\n//*       following message, there will be no outstanding request   *   FILE 708\n//*       on the master console:                                    *   FILE 708\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *   FILE 708\n//*         WTOR-CONSOLES CAN'T REPLY                               *   FILE 708\n//*        IEF238D GGG - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*       *                                                         *   FILE 708\n//*       The other options for TSOROUTE are TSOROUTE which only    *   FILE 708\n//*       sends a message to to the TSO userid as follows:          *   FILE 708\n//*        MPF203I FOLLOWING WTOR FOR DISPLAY ONLY - REPLY MUST BE  *   FILE 708\n//*         ENTERED FROM CONSOLE                                    *   FILE 708\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*       *                                                         *   FILE 708\n//*       And the TSOROUTE SUPPRESS this will suppress the reply    *   FILE 708\n//*       to the outstanding request, good for password replies.    *   FILE 708\n//*       The message sent to the TSO userid is as follows:         *   FILE 708\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *   FILE 708\n//*         WTOR-CONSOLES CAN'T REPLY                               *   FILE 708\n//*        MPF202I REPLY VALUE YOU ENTER WILL BE SUPPRESSED FROM    *   FILE 708\n//*         CONSOLE, JOBLOG & SYSLOG                                *   FILE 708\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*                                                                 *   FILE 708\n//*     ESTAE recovery routine added by Garry GREAT addition        *   FILE 708\n//*       now no matter what happens MPFTXALL will stay alive.      *   FILE 708\n//*       If an MPF exit routine such as MPFXTALL abends, it is     *   FILE 708\n//*       disabled for ALL the message id's that it is associated   *   FILE 708\n//*       This can have several undesirable side effects:           *   FILE 708\n//*       1) Perhaps the exit is abending due to a bug triggered by *   FILE 708\n//*          only one message id that rarely occurs.                *   FILE 708\n//*       2) Until the disablement is noticed, many automation      *   FILE 708\n//*          events can be lost.                                    *   FILE 708\n//*       ESTAEX protection around the entire MPFXTALL code;        *   FILE 708\n//*       in the event that there is an abend in MPFXTALL, a WTO    *   FILE 708\n//*       MPF038E MPFXTALL ABENDED; ABEND WAS SUPPRESSED message    *   FILE 708\n//*       will be issued, no further processing will occur for the  *   FILE 708\n//*       message that caused the abend, but since the abend was    *   FILE 708\n//*       suppressed, MPFXTALL remains active.                      *   FILE 708\n//*                                                                 *   FILE 708\n//*     Inner and outer IF's for all, IF's any combination up to 16 *   FILE 708\n//*       deep any order, keep track of your ENDIF's and ENDGET's.  *   FILE 708\n//*                                                                 *   FILE 708\n//*     Added error handling for Sysprog's that don't RTFM.         *   FILE 708\n//*                                                                 *   FILE 708\n//*     The SETAUTO command will set the Automation flag ON, this   *   FILE 708\n//*       will pass the message to any other automation packages,   *   FILE 708\n//*       why I don't know, why would one need anything else.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     The SETAUTONO command will set the Automation flag OFF,     *   FILE 708\n//*       this will not pass the message to any other automation    *   FILE 708\n//*       packages.                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     The SETAMRF command will set the Automatic Retain on for    *   FILE 708\n//*       that message, AMRF needs to be on for this to work.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit has been tested on OS/390 2.10, z/OS 1.4 z/OS 1.5 *   FILE 708\n//*       z/OS 1.6 z/OS 1.7 z/OS 1.8.                               *   FILE 708\n//*                                                                 *   FILE 708\n//*     For existing users, if you're using a version previous to   *   FILE 708\n//*       Version 5 please see $EXISTNG for proper replacment steps.*   FILE 708\n//*                                                                 *   FILE 708\n//*     Your next stop should be $INSTALL and $USAGE                *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit was originally started from CBT FILE345           *   FILE 708\n//*       MPFXTALL courtesy of Murray Nicholas.  Thank you          *   FILE 708\n//*       Murray for a great idea.                                  *   FILE 708\n//*                                                                 *   FILE 708\n//*     Also included are the DYNAMIC ALLOCATION Macros from        *   FILE 708\n//*       CBT FILE615 courtesy of Lionel B Dyck.  Thank you         *   FILE 708\n//*       Lionel for an easy and seamless way to implement          *   FILE 708\n//*       Dynamic Allocation.                                       *   FILE 708\n//*                                                                 *   FILE 708\n//*     And also the read directory part of the MPFLOAD program     *   FILE 708\n//*       was copied from CBT FILE558 courtesy of Dick              *   FILE 708\n//*       Thornton.  Thanks Dick for the code you provided.         *   FILE 708\n//*       Lots of good code there.  You should all have a look.     *   FILE 708\n//*                                                                 *   FILE 708\n//*     I'd also like to thank Marc Reibstein for his neet parsing  *   FILE 708\n//*       routine @ http://www.marcsweb.com/mnweb_370trtparse.shtml *   FILE 708\n//*       I no longer use this thanks to Garry's SRST command       *   FILE 708\n//*       addition.                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     And I'd like to thank Dave Mesiano and Mike Wojtukiewicz    *   FILE 708\n//*       for there help with questions I've had.                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     And last but not least to Sam Golob for pointing me to      *   FILE 708\n//*       some neat HEX conversion macro and code.  Thanks Sam      *   FILE 708\n//*       for enabling me to display the address and length of      *   FILE 708\n//*       the Name/Token created and for all of your great work     *   FILE 708\n//*       with CBT.                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     I've included programs ASKOPER by Bill Godfrey and PAUSE    *   FILE 708\n//*       since I use them and made reference to them in an example *   FILE 708\n//*       of my automated shutdown see member SHUTDOWN.             *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now I'd like to thank all the new contributors.         *   FILE 708\n//*                                                                 *   FILE 708\n//*  Contributed modifications:                                     *   FILE 708\n//*                                                                 *   FILE 708\n//*   Tom Lewis:                                                    *   FILE 708\n//*       TL01 - Displays the message id causing the command/reply  *   FILE 708\n//*              to be issued ie.  Ata'boy Tom.                     *   FILE 708\n//*        /* Issued by MPFXTALL for messageID      */              *   FILE 708\n//*                                                                 *   FILE 708\n//*   Peter Johnson:                                                *   FILE 708\n//*       PJ01 - Multi-line message handling, great addition.       *   FILE 708\n//*       PJ02 - Multiple blanks allowed between words.             *   FILE 708\n//*       PJ03 - Get Word length increased to 40 chars              *   FILE 708\n//*       PJGS1 - Joint effort of AUTO/TOKEN by Peter and Glenn     *   FILE 708\n//*                                                                 *   FILE 708\n//*   Garry G. Green:                                               *   FILE 708\n//*       GG01 - Code to enable MPFLOAD to act as a subsystem,      *   FILE 708\n//*              this allows MPFLOAD to execute very early in the   *   FILE 708\n//*              IPL, another great addition.                       *   FILE 708\n//*       GG58 - IF ASTYPE and TSOROUTE                             *   FILE 708\n//*       GG59 - ESATE protection for MPFXTALL ******* Thanks Garry *   FILE 708\n//*                                                                 *   FILE 708\n//*   Dean Tesar                                                    *   FILE 708\n//*       DT01 - Code for suppressing joblog only messages NOJOBLOG *   FILE 708\n//*              and syslog only messages NOSYSLOG.                 *   FILE 708\n//*       DT02 - MPFSUPNO setting                                   *   FILE 708\n//*       DT03 - Three and four digit replies                       *   FILE 708\n//*       DT04 - Set AUTO NO setting                                *   FILE 708\n//*                                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     If you want to be on the mailing list send me an email.     *   FILE 708\n//*                                                                 *   FILE 708\n//*     All comments, suggestions or requests please send email.    *   FILE 708\n//*                                                                 *   FILE 708\n//*     Author: Glenn Siegel                                        *   FILE 708\n//*             S.S.C. Corp.                                        *   FILE 708\n//*             GlennSiegel@optonline.net                           *   FILE 708\n//*             631-444-5339                                        *   FILE 708\n//*             516-607-4005 Cell                                   *   FILE 708\n//*             We do systems right!                                *   FILE 708\n//*                                                                 *   FILE 708\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGES": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x06\\x12O\\x01\\x07\\x06\\x9f\\x13(\\x00\\x85\\x00\\x85\\x00\\x02\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-05-04T00:00:00", "modifydate": "2007-03-10T13:28:02", "lines": 133, "newlines": 133, "modlines": 2, "user": "GSI"}, "text": "Subject:     MPFXTALL Update\nFrom:        Glenn Siegel <glennsiegel@optonline.net>\nDate:        Tue, 11 Apr 2006 23:24:22 -0400\n\nChanges to MPFXTALL for Version 5.0\n\n1.Removal of dynamic allocation from program MPFXTALL.  Reasons:\nIBM does not recommend the use of dynamic allocation in an mpf\nexit and its no longer necessary as a result of Garrys Sub\nSystem addition.\n\n2.Additions to suppression are suppressing from joblog only and\nsuppressing from syslog only, by Dean.\n\n3.Change to the display /* Issued by MPFXTALL for messageID */\nthis is now done via wto, idea from Willy.\n\n4.Error handling for non-numeric conditions; this eliminates a\nproblem when user codes numeric incorrectly.\n\n5.Increased total number of commands/logic from 51 to 102.\n\n6.AUTO/TOKEN feature see below\n\n7. Special character handling for message id's is now available\nwith the use of the AUTO/TOKEN feature.  For a message that start\nwith a special character like a dash\n\nThe MPFLSTxx member would contain the following:\n  -SSCCORP01E,SUP(NO),USEREXIT(MPFXTALL),AUTO(SSCCORP1)\n  And the commands member SSCCORP1 would contain whatever.\n\n8.The IF MSGID+xx FOR xx this can be used when you have dozens of\nsimilar messages like CSQ1234I, CSQ1234E, CSQ1235I, CSQ1235E etc\nand you only want to suppress only the I level messages.  The\nMPFLSTxx member would contain:\n\nCSQ*,USEREXIT(MPFXTALL),AUTO(CSQMSGS)\n\nAnd the commands member would look like this\n\nIF MSGID+07 FOR 01 I\nSUPPRESS\nENDIF\n\n9.And now for the crme de la crme.  I now present the\nswitch/variable section of my product, consisting of the set\nswitch, delete switch, alter switch, if switch on, if switch off,\nif switch equal and if switch not equal.  This is my way of\nthanking Don, Todd and Emma for intrusting me with their OS\nupgrade project after only a few conference calls.   I believe\nthis should complete your free automation solution.  I also\nbelieve everybody else should thank them for inspiring me to\nwrite this code.  With this addition to my product all of you\nshould be armed sufficiently to totally eliminate any other\nautomation products at your shop.  Now for the meat and taters:\n\nThe SETSWITCH command will set a persistent switch with a user\ndefined name field up to 8 characters and a user defined\nstatus/information field up to 16 characters.  Both fields have\nno other limitations; you can use any characters, spaces, special\ncharacters and numbers.  The DELSWITCH command thats what it\ndoes, it deletes the switch.  The ALTSWITCH is used to alter the\nstatus/information part of the switch from anything to anything.\nThe IF SWITCH logic has four separate checks.  The IF SWITCH ON\nchecks only to see if the switch is on/exists, it doesnt check\nthe status/information section.  The IF SWITCH OFF checks only to\nsee if the switch is off/doesnt exists.\n\nThe IF SWITCH EQ checks the named switch status/information field\nis equal to that of the if statement.  The IF SWITCH NE checks\nthe named switch status/information field to not be equal to the\nif statement.  Heres all the different the syntax:\n\nSETSWITCH xxxxxxxx xxxxxxxxxxxxxxxx\nDELSWITCH xxxxxxxx\nALTSWITCH xxxxxxxx xxxxxxxxxxxxxxxx\nIF SWITCH EQ xxxxxxxx xxxxxxxxxxxxxxxx\nENDIF SWITCH EQ\nIF SWITCH NE xxxxxxxx xxxxxxxxxxxxxxxx\nENDIF SWITCH NE\nIF SWITCH ON xxxxxxxx\nENDIF SWITCH ON\nIF SWITCH OFF xxxxxxxx\nENDIF SWITCH OFF\n*\nHeres a sample of usage for messages:\nDCOMMMP1:246:0:DB00308I - LOG AREA IS  50% FULL,   44963 BLOCKS\nDCOMMMP1:246:0:DB00308I - LOG AREA IS  70% FULL,   44963 BLOCKS\nMPFLSTxx entry would look like this:\nDCOMMMP1:246:0:DB00308I,USEREXIT(MPFXTALL)\nMember DCOMMMP1 would look like this:\nIF SWITCH DCOMMMP1 OFF\nSETSWITCH DCOMMMP1 SUBMIT DCOMSPLP\nS DCOMSPLP\nWTO MPFXTALL submitted offload DCOMSPLP for DCOMMMP1\nENDIF SWITCH OFF\n*\nIF SWITCH DCOMMMP1 ON\nWTO DCOMSPLP active for DCOMMMP1 no offload submitted\nENDIF SWITCH ON\n*\nMember $HASP395 would look like this:\nIF WORD 01 DCOMMMP1\nDELSWITCH DCOMMMP1\nWTO DCOMSPLP has ended DCOMMMP1 switch has been reset\nENDIF\n\nThe AUTO/TOKEN feature allows you to SUPPRESS, NOJOBLOG,\n  NOSYSLOG and HIGHLITE multiple messages with one entry.\n  No commands member is necessary for these.\n    BA*,USEREXIT(MPFXTALL),AUTO(SUPPRESS)\n           *\nAlso, the AUTO/TOKEN feature has member selection, this\n  allows you to select a different commands member then\n  the messageID states.  This allows multiple messages to\n  point to one commands member.\n    ABC1001E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)\n    ABC1002E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)\n      or\n    ABC*,USEREXIT(MPFXTALL),AUTO(ABCMSGS)\n\nGlenn Siegel\n631-444-5339\n516-607-4005 cell\n631-444-5364 fax\n414-434-5339 efax\nGlennSiegel@optonline.net\n\nContent-Type:\n application/octet-stream\nContent-Encoding:\n base64\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ESTAE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x07\\x07\\x1f\\x01\\x07\\x07\\x1f\\x14G\\x00\\x16\\x00\\x15\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-03-12T00:00:00", "modifydate": "2007-03-12T14:47:15", "lines": 22, "newlines": 21, "modlines": 0, "user": "GSI"}, "text": "From Garry Green\n\nMPF allows specifying the same MPF Exit routine for more than one\nmessage id.  If an MPF exit routine such as MPFXTALL abends, it is\ndisabled for ALL the message id's that it is associated with.\nThis can have several undesirable side effects:\n1) Perhaps the exit is abending due to a bug triggered by only one\n message id that rarely occurs\n2) Until the disablement is noticed, many automation events can be lost\n\nGG59 adds ESTAEX protection around the entire MPFXTALL code; in the event\nthat there is an abend in MPFXTALL, a WTO MPF038E MPFXTALL ABENDED; ABEND\nWAS SUPPRESSED message will be issued, no further processing will occur\nfor the message that caused the abend, but since the abend was suppressed,\nMPFXTALL remains active.\n\nThe MPF038E message is an indication that a serious failure has occurred\nin MPFXTALL that must be addressed, however in the mean time, MPFXTALL\ncontinues to remain active.  As stated earlier, the failure could have\nbeen triggered by a obscure bug caused by a very rarely occuring WTO.\nIt is probably better to allow MPFXTALL to continue to remain active\nprocessing the bulk of (non-problematic) messages.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$EXISTNG": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\t\\x00\\x05\\x01\\x06\\x10\\x8f\\x01\\x07'?\\x15 \\x00\\x08\\x00\\x06\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.09", "flags": 0, "createdate": "2006-04-18T00:00:00", "modifydate": "2007-09-30T15:20:05", "lines": 8, "newlines": 6, "modlines": 0, "user": "GSI"}, "text": "Install for existing users previous to Version 5.9\n1. TSO RECEIVE INDA('this.dataset.name(MACROS)')\n2. Assemble programs\n3. SET MPF=NO\n4. F LLA,REFRESH\n5. S MPFLOAD\n6. SET MPF=xx\nPlease review $INSTALL also\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$EXPLAIN": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00 \\x01\\x05\\x02\\x0f\\x01\\x06\\x10\\x1f\\x17X\\x009\\x00\\x00\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2006-04-11T17:58:20", "lines": 57, "newlines": 0, "modlines": 0, "user": "GSI"}, "text": " MPFLOAD:\n  Program logic overview:\n  - Get dataset name from the PARM.\n  - Dynamic allocation of the commands datasets directory.\n  - Retrieve and save the member names and a count of the members from\n     the directory.\n  - Obtain a block of storage from ECSA subpool 241 key 0.  Size of\n     the getmain is equal to 8192 times the member count.\n  - Dynamic allocation of the commands dataset(member).\n  - Read the content of member and load it into the obtained storage.\n     Loop till member count is equal to 0.\n  - Check to see if Name/Token exists if so delete Name/Token and free\n      the storage.\n  - Create Name/Token and place the address and length of the storage\n      into the Token field.  Display status and end.\n\n Table format:\n  Each record in storage is 8192 bytes.  The first 8 is the member name,\n   the next 80 times 102 are the commands from that member.  One record\n   from the member is equal to one of the 102, 80 byte fields in the\n   table.\n\n Limitations:\n  Max of 1000 members, I think that's plenty.\n  Max of 102 commands per message/member, see above.\n  Max of 53 characters per WTO and WTOH, you can use multiple lines if\n   needed.\n  Max of 40 characters for the GET and REPLACE\n\n Calculated getmain:\n  Number of members times 8192 bytes, so for 100 messages/members that\n   would be a puny 824K of ECSA, less then one meg of ECSA.\n\n MPFLOAD Bugs:\n  I don't know of any so far.\n\n MPFXTALL:\n  Program logic overview:\n  - Obtain a block of storage below the line.\n  - Prime part of the work area with predefined data.\n  - Check for WTOR, if so adjust the end of the MSGID.\n  - Get Name/Token if the Name/Token exists find message ID.\n  - Read commands.\n  - Determine the type of command, reply, iflogic, highlight, WTO/H, switch,\n    or get.\n  - Either reply, enter command, highlight, WTO/H, get or switch.\n  - Loop read and process till end of commands.\n\n MPFLOAD Bugs:\n  I don't know of any so far.\n\n\n     Author: Glenn Siegel\n             S.S.C. Corp.\n             GlennSiegel@optonline.net\n             631-444-5339\n             516-607-4005 Cell\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$GOTABLE": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x07\\x07O\\x01\\x07\\x07O\\x18\\x11\\x00C\\x00C\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-03-15T00:00:00", "modifydate": "2007-03-15T18:11:02", "lines": 67, "newlines": 67, "modlines": 0, "user": "GSI"}, "text": "Inner and outer IF's for all, IF's any combination up to 16 deep any\n order.  This is only for IF logic, with one exception the GET also\n uses it but its a little different.\n\nAt some point while adding more IF logic I was unable to keep track of\n the inner and outer IFs using conventional logic, so I came up with an\n elegant and some what simple solution use a table and switches.\n\nUpon setting up to reading a commands member initialize all switches to\n x'40' MPFXT200\n\nIFLOGIC section picks which routine to go to.\n\nFirst time into an IF routine:\n\nSetup for GOTABLE section:\nSet R8 to the section of the routine that checks \"is it an ENDIF\" or\n \"is its switch set to NO\" or \"go do what you need to do\" all for that\n one IF, call this the \"decision section\".\nSet R2 to the start of the routine, the place where the stuff you want\n to do if everything is true, call this the \"logic section\".\nSet R6 to the place where we set the switch to NO and return via R9 what\n ever that is set to, call this the \"no section\".\nBranch MOVEGO\nSimple reference SYSIDCK\n\nThe MOVEGO section:\nThis is where we setup the table, the table is a stack of fullwords\n (16 of em) 4 bytes each.\nThe first thing is to add 4 to the GOCTR place that into R3.\n\nLoad the address of the GOTABLE to R7.\nStore the address of R8 \"decision section\" into the GOTABLE offset by\nthe GOCTR R3.\n (So if you had 4 nested IFs the GOTABLE would contain the addresses\n for all of those IFs \"decision sections\" in order)\nCheck if any other IFs are set to NO, if one is go to the address of\n R6 the \"no section\" else go to the address of R2 the \"logic section\".\n\nLogic Section:\nDo stuff\nThen return\nSimple reference SYSID\n\nNo section:\nNot much here set switch to NO and return.\nSimple reference SYSIDNO\n\nIf the next command line isnt an IF:\nCheck GOCTR\nIf its zero no outer IFs continue on.\nIf less then zero error.\nIf greater then zero outer IF's present.\nLoad R3 with the address of the last IFs \"decision section\" and go\nthere.\n\nDecision Section:\nCheck if its the end of this IFs logic.\nIf yes decrease GOCTR by 4 and reset its switch then return.\nCheck if IFs switch is set to NO if it is return if not continue.\nSimple reference CKSYSID\n\nSo a recap there are four sections per IF:\n 1. Setup for GOTABLE section.\n 2. Logic section.\n 3. NO section.\n 4. Decision section checks for ENDIF or NO or Continue processing\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HASP099": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x045o\\x01\\x045o!@\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-21T00:00:00", "modifydate": "2004-12-21T21:40:22", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "$PJES2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HASP100": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x05 \\x0f\\x01\\x05 \\x0f\\x12\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-19T00:00:00", "modifydate": "2005-07-19T12:00:32", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "SUPPRESS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HASP395": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x01\\x06\\t\\x1f\\x01\\x06\\x10\\x9f\\x19\\x13\\x00\\t\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2006-04-01T00:00:00", "modifydate": "2006-04-19T19:13:20", "lines": 9, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "IF WORD 01 DCOMSPLP\nDELSWITCH DCOMMMP1\nWTO DCOMSPLP has ended DCOMMMP1 switch has been reset\nENDIF\n*\nIF WORD 01 DCOMSPL3\nDELSWITCH DCOMMMT3\nWTO DCOMSPL3 has ended DCOMMMT3 switch has been reset\nENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$HASP426": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x045o\\x01\\x045o!8\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-12-21T00:00:00", "modifydate": "2004-12-21T21:38:54", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "*\nREPLY NN,WARM,NOREQ\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HASP441": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x045o\\x01\\x045o\"\\x12\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-21T00:00:00", "modifydate": "2004-12-21T22:12:08", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "*\nREPLY NN,Y\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HASP61A": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x06\\x01\\x045o\\x01\\x06\\x11\\x9f\\x076\\x00j\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2004-12-21T00:00:00", "modifydate": "2006-04-29T07:36:06", "lines": 106, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "* THIS WILL TEST EVERYTHING WHEN NO ACTIVE JOBS ARE RUNNING\nSETAUTO\nSETSWITCH GLENN    TO TEST FOR SW\n*\nIF SYSID EQ SSC\nIF ALL EQ JOBS ACTIVE NO\nIF WORD 01 NO\nIF SWITCH EQ GLENN    TO TEST FOR SW\nGET WORD 03\nSE 'WORD TRUE %, IFSWITCH AND MULTI IF',USER=(GSI)\nENDGET\nD R,L\nENDIF SWITCH EQ\nENDIF\nENDIF\nENDIF\n*\nIF WORD 01 NO\nGET WORD 03\nSE 'WORD TRUE %',USER=(GSI)\nENDGET\nENDIF\n*\nIF WORD 01 GSI\nGET WORD 03\nSE 'WORD FALSE %',USER=(GSI)\nENDGET\nENDIF\n*\nIF ALL EQ OBS ACTIVE NO\nGET WORD 03\nSE 'ALL FALSE %',USER=(GSI)\nENDGET\nENDIF\n*\nIF ALL EQ JOBS ACTIVE NO\nGET WORD 03\nSE 'ALL TRUE %',USER=(GSI)\nENDGET\nENDIF\n*\nIF SWITCH EQ GLENN    FALSE FOR SW\nGET WORD 03\nSE 'SWITCH EQ FALSE %',USER=(GSI)\nENDGET\nENDIF SWITCH EQ\n*\nIF SWITCH NE GLENN    TO TEST FOR SW\nGET WORD 03\nSE 'SWITCH NE FALSE %',USER=(GSI)\nENDGET\nENDIF SWITCH NE\n*\nIF SWITCH NE GLENN    TEST FOR SW\nGET WORD 03\nSE 'SWITCH NE TRUE %',USER=(GSI)\nENDGET\nENDIF SWITCH NE\n*\nIF SWITCH ON GLENN\nGET WORD 03\nSE 'SWITCH ON TRUE %',USER=(GSI)\nENDGET\nENDIF SWITCH ON\n*\nIF SWITCH OFF GLENN\nGET WORD 03\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDGET\nENDIF SWITCH OFF\n*\nIF SWITCH OFF AMY\nGET WORD 03\nSE 'SWITCH OFF TRUE %',USER=(GSI)\nENDGET\nENDIF SWITCH OFF\n*\nIF SWITCH OFF GLENN\nGET WORD 03\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDGET\nENDIF SWITCH OFF\n*\nALTSWITCH GLENN    TEST FOR SW\n*\nIF SWITCH EQ GLENN    TEST FOR SW\nGET WORD 03\nSE 'SWITCH EQ TRUE %',USER=(GSI)\nENDGET\nENDIF SWITCH EQ\n*\nDELSWITCH GLENN\n*\nIF SYSID EQ SSC\nWTOH THIS WILL SEND A HIGHLIGHTED MESSAGE TO THE OPERATOR*\nWTO THIS WILL SEND A MESSAGE TO THE OPERATOR ************\nENDIF\n*\nIF MSGID+01 FOR 02 HA\nGET WORD 03\nSE 'MSGID+ TRUE %',USER=(GSI)\nENDGET\nENDIF\n*\nHIGHLIGHT\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HASP612": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00U\\x01\\x06\\x17_\\x01\\x07\\x19\\x9f\\x18Q\\x00\\x83\\x00T\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2006-06-24T00:00:00", "modifydate": "2007-07-18T18:51:55", "lines": 131, "newlines": 84, "modlines": 0, "user": "GSI"}, "text": "* USED FOR TESTING EVERYTHING\nGET WORD 03\nSETAUTO\nSETAMRF\nSETSWITCH GLENN    TO TEST FOR SW\n*\nIF SYSID EQ SSC\nIF ALL EQ JOBS ACTIVE NO\nIF WORD 01 NO\nIF SWITCH EQ GLENN    TO TEST FOR SW\nSE 'WORD TRUE %, IFSWITCH AND MULTI IF',USER=(GSI)\nD R,L\nENDIF SWITCH EQ\nENDIF\nENDIF\nENDIF\n*\nIF WORD 02 ACT*\nSE 'WORD ACT* TRUE %',USER=(GSI)\nENDIF\n*\nIF WORD 02 OCT*\nSE 'WORD OCT* FALSE %',USER=(GSI)\nENDIF\n*\nIF WORD 01 NO\nSE 'WORD TRUE %',USER=(GSI)\nENDIF\n*\nIF WORD 01 OO\nSE 'WORD FALSE %',USER=(GSI)\nENDIF\n*\nIF ALL EQ OBS ACTIVE NO\nSE 'ALL FALSE %',USER=(GSI)\nENDIF\n*\nIF ALL EQ JOBS ACTIVE NO\nSE 'ALL TRUE %',USER=(GSI)\nENDIF\n*\nIF SWITCH EQ GLENN    FALSE FOR SW\nSE 'SWITCH EQ FALSE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nIF SWITCH NE GLENN    TO TEST FOR SW\nSE 'SWITCH NE FALSE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH NE GLENN    TEST FOR SW\nSE 'SWITCH NE TRUE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH ON GLENN\nSE 'SWITCH ON TRUE %',USER=(GSI)\nENDIF SWITCH ON\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF AMY\nSE 'SWITCH OFF TRUE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nALTSWITCH GLENN    TEST FOR SW\n*\nIF SWITCH EQ GLENN    TEST FOR SW\nSE 'SWITCH EQ TRUE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nDELSWITCH GLENN\n*\nIF SYSID EQ SSC\nWTOH THIS WILL SEND A HIGHLIGHTED MESSAGE TO THE OPERATOR*\nWTO THIS WILL SEND A MESSAGE TO THE OPERATOR ************\nENDIF\n*\nIF MSGID+01 FOR 02 HA\nSE 'MSGID+ TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID+01 FOR 02 IA\nSE 'MSGID+ FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGNE+01 FOR 02 IA\nSE 'MSGNE+ TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGNE+01 FOR 02 HA\nSE 'MSGNE+ FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGID EQ $HASP612\nSE 'MSGID EQ $HASP612 TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID EQ $HASP613\nSE 'MSGID EQ $HASP613 FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGID NE $HASP613\nSE 'MSGID NE $HASP613 TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID NE $HASP612\nSE 'MSGID NE $HASP612 FALSE %',USER=(GSI)\nENDIF\n*\nHIGHLIGHT\nDISPLAY RED\nDISPLAY BLINK\n*\nIF ASTYPE EQ S\nSE 'ASTYPE STC TRUE %',USER=(GSI)\nENDIF ASTYPE\n*\nIF ASTYPE EQ T\nSE 'ASTYPE TSO FALSE %',USER=(GSI)\nENDIF ASTYPE\n*\nIF ASTYPE EQ J\nSE 'ASTYPE BATCH FALSE %',USER=(GSI)\nENDIF ASTYPE\n*\nENDGET\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INCLUDE": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00\\x02\\x01\\x05\\x02\\x0f\\x01\\x06\\x10\\x1f\"\\x10\\x006\\x00\\x02\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2006-04-11T22:10:02", "lines": 54, "newlines": 2, "modlines": 0, "user": "GSI"}, "text": "Members Included\n$$$#DATE  CBT Date and Size\n$$README  The Readme file\n$EXPLAIN  Explains program logic etc..\n$HASP099  Example MPF commands member to bring down JES2\n$HASP100  Example MPF commands member to suppress a message\n$HASP395  Example MPF commands member\n$HASP426  Example MPF commands member to reply WARM,NOREQ\n$HASP441  Example MPF commands member to reply Y\n$HASP612  Example MPF commands member with everything\n$INCLUDE  This member, what's included\n$INSTALL  Installation instructions\n$LOG      Log\n$MODLOG   Contributed modifications log\n$USAGE    How to use please read\n@FILE708  The eye catcher for CBT Tape FILE1\nAOP075I   Example MPF commands member to start NETSPOOL\nASMACL    Assemble and Link the programs\nCADO017D  Example MPF commands member to reply N\nCAT9010P  Example MPF commands member to reply U\nCOF536I1  Example MPF commands member enter P DLF\nCSQMSGS   Example MPF commands member\nDCOMMMP1  Example MPF commands member\nDELNT     Delete Name/Token program\nDISCLAIM  Legal stuff.\nEPW0309I  Example MPF commands member to reply YES\nERB100I   Example MPF commands member to start RMFGAT\nEZAIN22I  Example MPF commands member to reply C\nIAT3011   Example MPF commands member to reply W\nIAT3012   Example MPF commands member to reply M=00\nIAT3100   Example MPF commands member to 8S JSS\nICK003D   Example MPF commands member to reply U\nIEE043I   Example MPF commands member to start a LOGWTR\nIEE362A   Example MPF commands member to dump SMF\nIEFTMS0   Example MPF commands member to reply U\nIEFTMS8   Example MPF commands member to reply HIGHDATE\nIEF176I   Example MPF commands member to stop LWTR\nIEF238D   Example MPF commands member to reply CANCEL\nIEF450I   Example MPF commands member to highlight abend messages\nIKT010D   Example MPF commands member to reply FSTOP\nIKT012D   Example MPF commands member to reply U\nIST020I   Example MPF commands member to start TSO etc..\nIST133I   Example MPF commands member to start a shutdown for comm.\nIST270I   Example MPF commands member to start stuff after NCP is loaded\nIXC418I   Example MPF commands member to send a message after joining SYSPLEX\nMACROS    XMIT'ed Macro's dataset\nMPFLOAD   The program that loads commands dataset to ECSA SP 241 KEY 0\nMPFLST00  Sample MPF list for SYS1.PARMLIB\nMPFXTALL  The program that enters commands, replies, highlights, WTO's..\nPROC      The MPFLOAD proc\nSVT1P000  Example MPF commands member with multiple IF ALL EQ\nSVT1P001  Example MPF commands member with multiple IF MSGID EQ\nTESTALL   Tests all logic\nVCS0003W  Example MPF commands member to reply U\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 1045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00(\\x01\\x05\\x02\\x0f\\x01\\x06\\x10\\x1f\\x18\\x12\\x001\\x00\\x11\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2006-04-11T18:12:28", "lines": 49, "newlines": 17, "modlines": 0, "user": "GSI"}, "text": " 1. Copy member PROC into SYS1.PROCLIB(MPFLOAD) or any PROCLIB.\n\n 2. Authorize MPFLOAD to access the commands dataset RACF facility class\n     started, the user and group fields need to be changed for your\n     site.  Below are the RACF commands that need to be entered:\n        RDEFINE STARTED MPFLOAD.* STDATA(USER(stcusr) GROUP(sys1))\n        SETROPTS RACLIST(STARTED) REFRESH\n\n 3. Place the follow into COMMNDxx in PARMLIB:\n        COM='SET MPF=00'\n     Or place the following into the INIT section of CONSOLxx in PARMLIB\n        MPF(00)\n\n 4. Place the following into IEFSSNxx in PARMLIB:\n        SUBSYS SUBNAME(MPFX) /* DEFINE DUMMY S/S FOR MPFLOAD */\n          INITRTN(MPFLOAD) INITPARM('SYS1.MPF.COMMANDS')\n\n 5. Create a PDS SYS1.MPF.COMMANDS FB 80.  Copy or create the members\n     for the messages you want to manage.  This dataset must reside in\n     the master catalog.  The member names MUST match the message ID's\n     you plan on managing with MPFLSTxx, unless your using the AUTO/TOKEN\n     feature.  If you change the dataset name (NOT RECOMMENDED) you  will\n     have to make the following modifications; dataset name in the following\n     locations proc MPFLOAD, program MPFLOAD, IEFSSNxx, it still must\n     reside in the master catalog.\n\n 6. Extract the MACRO dataset by entering:\n        TSO RECEIVE INDA('this.dataset.name(MACROS)')\n\n 7. Run member ASMACL.  Change the dataset names referenced by\n     <=== CHANGE.  The load modules (SYSLMOD) must be in your LINKLST\n     and an APF authorized dataset.\n\n 8. Issue command F LLA,REFRESH\n\n 9. Issue command S MPFLOAD\n\n10. Modify your MPFLSTxx to include messages you wish to manage.\n     Then issue command SET MPF=00 .  Make sure any entries in\n     MPFLST00 that are to be managed by MPFXTALL have a corresponding\n     member in the SYS1.MPF.COMMANDS dataset and MPFLOAD has been run.\n\n     All comments, suggestions or requests please send email.\n\n     Author: Glenn Siegel\n             S.S.C. Corp.\n             GlennSiegel@optonline.net\n             631-444-5339\n             516-607-4005 Cell\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LOG": {"ttr": 1047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x009\\x01\\x05\\x19\\x7f\\x01\\x07\\x06\\x9f\\x13(\\x00 \\x00\\x05\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2005-07-16T00:00:00", "modifydate": "2007-03-10T13:28:39", "lines": 32, "newlines": 5, "modlines": 0, "user": "GSI"}, "text": "IF MSGID NE                                                    06/24/06\nIF MSGNE+ xx FOR xx                                            06/24/06\nPUTSWITCH                                                      05/21/06\nGet reply id                                                   05/15/06\nMPFSUPNO setting                                               05/05/06\nNOSYSLOG and NOJOBLOG                                          05/05/06\nSETAUTO and SETAMRF                                            04/19/06\nInner and outer IF's for all                                   04/16/06\nMessage ID Plus For                                            04/10/06\nAUTO/TOKEN different member selection                          04/04/06\nIncreased total number of commands/logic from 51 to 102        03/25/06\nChange to the display /* Issued by MPFXTALL for messageID   */ 03/25/06\n this is now done via wto.\nError handling for not numeric conditions                      03/24/06\nAdd switch handling logic                                      03/24/06\nRemoval of dynamic allocation from program MPFXTALL, reasons;  03/23/06\n it's not recommended for an mpf exit IBM and it's no longer\n necessary since Garry's Sub System addition.\nAdded code from Dean Tesar for NOJOBLOG and NOSYSLOG           03/23/06\nAdded code from Peter Johnson for second message line support  10/01/05\n and multiple blanks between words\nAdded code from Garry Green to enable MPFLOAD as a subsystem   09/29/05\nComments changed in MPFXTALL                                   08/05/05\nAdded code from Tom Lewis to state messageid in display        08/05/05\nChanged length of GET/REPLACE to 40 from Peter Johnson         08/05/05\nAdded Suppression of messages to the SYSLOG                    07/19/05\nAdded logic for new IF MSGID EQ                                07/18/05\nComments changed                                               07/16/05\nMultiple IF ALL EQ logic fixed                                 07/16/05\nFlagged messages and RENT fixes from Tom Lewis                 07/15/05\nLong message ID handling for dynamic allocation fixed          07/15/05\nTotal rewrite of product\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MODLOG": {"ttr": 1049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x12\\x00\\x03\\x01\\x05'O\\x01\\x07\\x07\\x0f\\x16R\\x001\\x00\\x04\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.18", "flags": 0, "createdate": "2005-10-01T00:00:00", "modifydate": "2007-03-11T16:52:03", "lines": 49, "newlines": 4, "modlines": 0, "user": "GSI"}, "text": " Glenn Siegel - A total rewrite of MPFXTALL, created MPFLOAD, made use\n      of Name/Token Services.   Multiple functions added all IF logic,\n      GET logic, REPLACE logic, REPLY logic, HIGHLIGHT, SUPPRESS, etc...\n\n TL01 - States messageid issued for command/reply by, and reply\n        length modification by Tom Lewis see $$README\n\n PJ01   Support second message line by Peter Johnson\n\n PJ02 - Multiple blanks between message words by Peter Johnson\n\n PJ03 - Get Word length increased to 40 chars by Peter Johnson\n\n GG01 - Code to enable MPFLOAD to act as a subsystem by Garry G. Green\n\n DT01 - Joblog and syslog suppression by Dean Tesar\n\n PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn\n\n GS50  - AUTO/TOKEN different member selection by Glenn Siegel\n\n GS51  - Message ID Plus For by Glenn Siegel\n\n GS52  - Inner and outer IF's for all by Glenn Siegel\n\n GS53  - SETAUTO and SETAMRF on by Glenn Siegel\n\n DT02  - MPFSUPNO setting by Dean Tesar\n\n GS54  - Get reply id by Glenn Siegel\n\n GS55  - PUTSWITCH by Glenn Siegel\n\n GS56  - IF MSGID NE by Glenn Siegel\n       - IF MSGNE+ xx FOR xx by Glenn Siegel\n\n GS57  - No display /* MPFXTALL */\n       - AUTO(NODISPLY)      by Glenn Siegel\n\n DT03  - Four digit replies\n       - REPLY NNNN,         by Dean Tesar\n\n GG58  - Addition of ASTYPE code\n       - IF ASTYPE T/B/S     by Garry Green\n       - Addition of TSOROUTE code\n       - TSOROUTE            by Garry Green\n\n GS58  - Addition of message colors/highlighing\n                             by Glenn Siegel\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDSLOAD": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x11\\x01\\x026_\\x01\\x12 \\x9f\\x007\\x00#\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2012-07-27T00:37:11", "lines": 35, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    PDSLOAD JOB TO CREATE INSTALL LIBRARIES\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT485.FILE708(PDSLOAD)')\n   DSN (yourid.your.loadlib) VOL(volser)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT485.FILE708',      <=== CHANGE\n//             OPRE=SBGOLOB,                       <=== CHANGE\n//             QUAL=FILE708,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=outvol,                         <=== CHANGE\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3=DELETE,\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=yourid.your.loadlib\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2,&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S001 EXEC PDSLOAD,MEMB=MPFXDSPL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$USAGE": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1c\\x00'\\x01\\x05\\x02_\\x01\\x07\\x03\\x0f\\x124\\x00G\\x00\\x0c\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.28", "flags": 0, "createdate": "2005-01-25T00:00:00", "modifydate": "2007-01-30T12:34:27", "lines": 71, "newlines": 12, "modlines": 0, "user": "GSI"}, "text": "  The use of MPF has now become very easy.  No more recoding or\n   rewriting your MPF exits, every time you need to add a new reply or\n   issue a new command.  No more maintaining 10, 12 or even 20 separate\n   MPF exits to manage a dozen or so separate events.\n\n  Once installed, all you need to do to manage a new message is to:\n    1. Add a new member to SYS1.MPF.COMMANDS using the name of the\n       message ID you want to manage.  In that member would be the\n       replies/commands you want performed for said message.\n\n    2. Modify MPFLSTxx to add the message ID you want managed.\n       messageid,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n\n    3. Issue a S MPFLOAD command to reload the commands dataset to the\n       Name/Token.\n\n    4. Issue a SET MPF=xx command to set MPF to start managing messages.\n\n  Commands/Reply:\n    REPLY NN,xx\n    REPLY NN,xxxx\n    WTO Anything you want to say\n    WTOH Anything you want to say highlighted\n    HIGHLIGHT thats what does it highlights a message\n    SUPPRESS thats what does it suppresses a message from the SYSLOG and joblog\n    NOJOBLOG suppresses a message from the joblog only still on syslog\n    NOSYSLOG suppresses a message from the syslog only still on joblog\n    SETSWITCH sets a switch for furture checking\n    DELSWITCH deletes switch\n    ALTSWITCH alters switch\n    PUTSWITCH puts status/information to the console\n    Any commands you want up to a total of 102 lines per member\n\n  Logic Commands:\n    IF SYSID EQ sysid\n    IF ALL EQ word1 word2 word3 word4\n    IF WORD ## word\n    IF MSGID EQ messageid\n    IF MSGID+xx FOR xx xxx\n    IF SWITCH ON xxxxxxxx\n    IF SWITCH OFF xxxxxxxx\n    IF SWITCH EQ xxxxxxxx xxxxxxxxxxxxxxxx\n    IF SWITCH NQ xxxxxxxx xxxxxxxxxxxxxxxx\n    GET WORD ##\n    GET REPLYID\n\n  Usage:\n  - Format for SYS1.PARMLIB(MPFLST00) is as follows starting in column 1\n     messageid,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n  - All message id's specified in MPFLSTxx that are to be managed by\n     MPFXTALL must have an exact matching member name in SYS1.MPF.COMMANDS\n     or the first 8 characters of the messageid or whatever the AUTO/TOKEN\n     AUTO(xxxxx) states, the MPFLSTxx member in parmlib must be the\n     full messageid.\n  - All commands in the commands datset must start in column 1\n  - A * or space in column 1 is treated as a comment\n  - All IF statements must have a matching ENDIF.\n  - All IF SWITCH statements must have a matching ENDIF SWITCH ON/OFF/EQ/NE\n  - All GET's must have a matching ENDGET.\n  - The GET can be used as an inner GET with all outer IF's.\n  - If you need to shutdown this exit issue SET MPF=NO\n\n\n  Have Fun, I did writing it!\n\n     Author: Glenn Siegel\n             Siegel's Systems Consulting Corp.\n             GlennSiegel@optonline.net\n             631-444-5339\n             516-607-4005 Cell\n             We do systems right\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE708": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x003\\x01\\x12 \\x9f\\x01\\x12 \\x9f\\x00A\\x02\\x90\\x02\\x90\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-07-27T00:00:00", "modifydate": "2012-07-27T00:41:33", "lines": 656, "newlines": 656, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 708 is from Glenn Siegel and contains an extremely        *   FILE 708\n//*           versatile master MPF exit of great generality and     *   FILE 708\n//*           capability.  This program lets you issue just about   *   FILE 708\n//*           any set of commands, differently (or the same), on    *   FILE 708\n//*           any connected MVS system or LPAR.  Please see below   *   FILE 708\n//*           for some of the details.                              *   FILE 708\n//*                                                                 *   FILE 708\n//*   Added:  In PDSLOAD format:  Member MPFXDSPL package, using    *   FILE 708\n//*           this software, to display the MPF tables in storage.  *   FILE 708\n//*           (This is from Thomas Hutchins.) - See $$NOTE04        *   FILE 708\n//*           Members PDSLOAD and $PDSLOAD included in this pds.    *   FILE 708\n//*                                                                 *   FILE 708\n//*   General Description of the package:                           *   FILE 708\n//*                                                                 *   FILE 708\n//*     >>> --------------------------------------------- <<<       *   FILE 708\n//*     >>> Please look at members $EXPLAIN and $CHANGES. <<<       *   FILE 708\n//*     >>> --------------------------------------------- <<<       *   FILE 708\n//*                                                                 *   FILE 708\n//*     This isn't your mother's MPF exit!  It's the do all MPF     *   FILE 708\n//*       exit.  It should replace most, if not all of your         *   FILE 708\n//*       existing MPF exits.  If you are not using any MPF         *   FILE 708\n//*       exits, you should check this one out.  Version 5.9.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     The purpose of this product is to assist in automation      *   FILE 708\n//*       of your MVS operating system.  This product will only     *   FILE 708\n//*       work on system levels at or ABOVE ESA 4.1 because it      *   FILE 708\n//*       uses the Name/Token Services.  More on this later.        *   FILE 708\n//*       Sorry Turnkey guys/gals.                                  *   FILE 708\n//*                                                                 *   FILE 708\n//*     Manage up to 1000 different messages and 102 commands/logic *   FILE 708\n//*      per message.                                               *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit can do the following:                             *   FILE 708\n//*                                                                 *   FILE 708\n//*     Reply to outstanding messages (WTOR's).  It can reply       *   FILE 708\n//*                *                                                *   FILE 708\n//*                R 00,WARM,NOREQ                                  *   FILE 708\n//*                    to WTOR                                      *   FILE 708\n//*                01 $HASP426 SPECIFY OPTIONS - JES2               *   FILE 708\n//*                *                                                *   FILE 708\n//*       The $HASP426 commands member would look like this:        *   FILE 708\n//*                *                                                *   FILE 708\n//*                REPLY NN,WARM,NOREQ                              *   FILE 708\n//*                *                                                *   FILE 708\n//*       With an update from Dean Tesar WTOR's with an RMAX of     *   FILE 708\n//*          up to four digits is possible, if your RMAX is set to  *   FILE 708\n//*          RMAX(999) or RMAX(9999) using three or four digit      *   FILE 708\n//*          replies your commands member would look like:          *   FILE 708\n//*                *                                                *   FILE 708\n//*                REPLY NNNN,WARM,NOREQ                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     Issue; START commands, VARY commands, DISPLAY commands,     *   FILE 708\n//*       SE commands, ROUTE commands, JES commands... in other     *   FILE 708\n//*       words, any commands for any messages, i.e.                *   FILE 708\n//*                *                                                *   FILE 708\n//*                S TSO                                            *   FILE 708\n//*                    for message                                  *   FILE 708\n//*                IST020I VTAM INITIALIZATION COMPLETE             *   FILE 708\n//*                                                                 *   FILE 708\n//*     It also has IF SYSID logic built into it; so you can        *   FILE 708\n//*       issue different commands to different systems.  For       *   FILE 708\n//*       example, say you want to issue START commands for         *   FILE 708\n//*       VPS, TND and OMEGVTM on your production LPAR SSC and      *   FILE 708\n//*       only wanted to issue a START for TND on your systems      *   FILE 708\n//*       programming LPAR SYSPGM and START of TSO on both.  The    *   FILE 708\n//*       IF SYSID can also be used as an outer or inner IF, more   *   FILE 708\n//*       on that later.                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IST020I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                S VPS                                            *   FILE 708\n//*                S TND                                            *   FILE 708\n//*                S OMEGAVTM                                       *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SYSPGM                               *   FILE 708\n//*                S TND                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                S TSO                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     It can also find up to 4 separate words in a message up to  *   FILE 708\n//*       25 characters per word.  All words must appear in that    *   FILE 708\n//*       message, in any order.                                    *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF ALL EQ word1 word2 word3 word4                *   FILE 708\n//*                Do Something                                     *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*     If you wanted to start NETSPOOL after a PrintServer         *   FILE 708\n//*       Daemon has started; the MPFXTALL program is also case     *   FILE 708\n//*       sensitive, so for the following message:                  *   FILE 708\n//*                *                                                *   FILE 708\n//*    AOP075I Daemon aopd was started successfully. (program:aopd) *   FILE 708\n//*                *                                                *   FILE 708\n//*       The AOP075I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF ALL EQ Daemon aopd was started                *   FILE 708\n//*                S NETSPOOL                                       *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     Oh, it also highlights messages.  To highlight abends;      *   FILE 708\n//*       The IEF450I commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                HIGHLIGHT                                        *   FILE 708\n//*                *                                                *   FILE 708\n//*      Or use the AUTO/TOKEN feature AUTO(HIGHLITE).              *   FILE 708\n//*       No commands member is necessary for this.                 *   FILE 708\n//*         IEF450I,USEREXIT(MPFXTALL),AUTO(HIGHLITE),SUP(NO)       *   FILE 708\n//*                                                                 *   FILE 708\n//*     Then there's IF WORD logic check for one word up to 25      *   FILE 708\n//*       characters in one specific location from 01 to 99.  This  *   FILE 708\n//*       fuction can also be used with a wild card.  Also, here's  *   FILE 708\n//*       the usage of the IF SYSID used as an outer if.  So, if    *   FILE 708\n//*       the system is SSC and the job that abended starts with    *   FILE 708\n//*       PROD then the IEF450I commands member would look like     *   FILE 708\n//*       this:                                                     *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                IF WORD 01 PROD*                                 *   FILE 708\n//*                HIGHLIGHT                                        *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now here's the GET and replace part of the program,     *   FILE 708\n//*       very slick if I may say so myself.  It retrieves a word   *   FILE 708\n//*       from whatever position you specify; then it replaces      *   FILE 708\n//*       any % in the commands with that word.  So, to have        *   FILE 708\n//*       MPFXTALL submit a job to dump an SMF dataset for the      *   FILE 708\n//*       following message:                                        *   FILE 708\n//*       *IEE362A SMF ENTER DUMP FOR SYS1.MAN2 ON SSCCAT           *   FILE 708\n//*       The commands member IEE362A would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                GET WORD 05                                      *   FILE 708\n//*                S SMFAUTO,SMFDSN='%'                             *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*       The resulting command issued would be:                    *   FILE 708\n//*        S SMFAUTO,SMFDSN='SYS1.MAN2'                             *   FILE 708\n//*                *                                                *   FILE 708\n//*       The GET can also be used as an inner GET with all IF's.   *   FILE 708\n//*        So, you can do something fancy like this:                *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF SYSID EQ SSC                                  *   FILE 708\n//*                IF WORD 06 SSCCAT                                *   FILE 708\n//*                GET WORD 05                                      *   FILE 708\n//*                S SMFAUTO,SMFDSN='%'                             *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*       Now, thanks to Peter Johnson this automation tool can     *   FILE 708\n//*        handle multi-line messages.  So, for this multi-line     *   FILE 708\n//*        SMF message:                                             *   FILE 708\n//*   IEE391A SMF ENTER DUMP FOR DATA SET ON VOLSER SSCCAT,         *   FILE 708\n//*                   DSN=SYS1.MAN1                                 *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IEE391A commands member would look like this:         *   FILE 708\n//*                *                                                *   FILE 708\n//*                GET WORD 10                                      *   FILE 708\n//*                S SMFAUTO,%                                      *   FILE 708\n//*                ENDGET                                           *   FILE 708\n//*                *                                                *   FILE 708\n//*       The resulting issued command would be:                    *   FILE 708\n//*                *                                                *   FILE 708\n//*                S SMFAUTO,DSN=SYS1.MAN1                          *   FILE 708\n//*                                                                 *   FILE 708\n//*     A new addition to the GET is the GET REPLYID this will      *   FILE 708\n//*       get the reply id number and replace any & with that       *   FILE 708\n//*       number in that commands member, see PUTSWITCH for usage.  *   FILE 708\n//*                                                                 *   FILE 708\n//*     And of course, it does write to operator, highlighted       *   FILE 708\n//*       or not.  So, if you wanted to send a WTO message for      *   FILE 708\n//*       message ID $HASP612;                                      *   FILE 708\n//*       The $HASP612 commands member would look like this:        *   FILE 708\n//*                *                                                *   FILE 708\n//*                WTO No jobs running on this system               *   FILE 708\n//*                *                                                *   FILE 708\n//*       And if you wanted it highlighted:                         *   FILE 708\n//*                *                                                *   FILE 708\n//*                WTOH No jobs running on this system              *   FILE 708\n//*                                                                 *   FILE 708\n//*     And it does suppression also.  To suppress a message like   *   FILE 708\n//*       $HASP100 from the syslog and joblog the $HASP100 member   *   FILE 708\n//*       would look like this:                                     *   FILE 708\n//*                *                                                *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*       Be cautious using SUPPRESS, once it's deletes thats it,   *   FILE 708\n//*       it's gone.                                                *   FILE 708\n//*                *                                                *   FILE 708\n//*     Now thanks to Dean Tesar we have the joblog only and syslog *   FILE 708\n//*       only suppression these modification will suppress only    *   FILE 708\n//*       the joblog or only the syslog messages:                   *   FILE 708\n//*                *                                                *   FILE 708\n//*                NOJOBLOG                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*                NOSYSLOG                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*     Or use the AUTO/TOKEN feature AUTO(SUPPRESS)                *   FILE 708\n//*       AUTO(NOJOBLOG) AUTO(NOSYSLOG).                            *   FILE 708\n//*       No commands member is necessary for these.                *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(SUPPRESS)             *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(NOJOBLOG)             *   FILE 708\n//*         messageID,USEREXIT(MPFXTALL),AUTO(NOSYSLOG)             *   FILE 708\n//*                *                                                *   FILE 708\n//*     If you need to only suppress from the console an MPFLSTxx   *   FILE 708\n//*       entry like this will do the trick.                        *   FILE 708\n//*                xxxxxxxx,SUP(YES)                                *   FILE 708\n//*                                                                 *   FILE 708\n//*     You want colors I'll give you colors, this ones for Jason.  *   FILE 708\n//*       Change the color make it blink, underline and/or reverse  *   FILE 708\n//*       video.  The options for the DISPLAY command are BLUE,     *   FILE 708\n//*       PINK, RED, GREEN, TURQUOISE, YELLOW, WHITE, BLINK,        *   FILE 708\n//*       REVERSE and UNDERLINE.                                    *   FILE 708\n//*       The commands member to make it blink red would be:        *   FILE 708\n//*                 DISPLAY RED                                     *   FILE 708\n//*                 DISPLAY BLINK                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     The AUTO/TOKEN feature allows you to SUPPRESS, NOJOBLOG,    *   FILE 708\n//*       NOSYSLOG and HIGHLITE multiple messages with one entry.   *   FILE 708\n//*       No commands member is necessary for this.                 *   FILE 708\n//*         BA*,USEREXIT(MPFXTALL),AUTO(SUPPRESS)                   *   FILE 708\n//*                *                                                *   FILE 708\n//*     Also, the AUTO/TOKEN feature has member selection, this     *   FILE 708\n//*       allows you to select a different commands member then     *   FILE 708\n//*       the messageID states.  This allows multiple messages to   *   FILE 708\n//*       point to one commands member.                             *   FILE 708\n//*         ABC1001E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)               *   FILE 708\n//*         ABC1002E,USEREXIT(MPFXTALL),AUTO(ABCMSGS)               *   FILE 708\n//*                or                                               *   FILE 708\n//*         ABC*,USEREXIT(MPFXTALL),AUTO(ABCMSGS)                   *   FILE 708\n//*                *                                                *   FILE 708\n//*     Special character handling for message id's is now          *   FILE 708\n//*       available with the use of the AUTO/TOKEN feature.  For a  *   FILE 708\n//*       message that start with a special character like a dash - *   FILE 708\n//*       the MPFLSTxx member would contain the following:          *   FILE 708\n//*       -SSCCORP0*,SUP(NO),USEREXIT(MPFXTALL),AUTO(SSCCORP1)      *   FILE 708\n//*       And the commands member SSCCORP1 would contain whatever.  *   FILE 708\n//*                *                                                *   FILE 708\n//*     It also has a AUTO(SINGLE) which treats a multi-line as a   *   FILE 708\n//*       single line.                                              *   FILE 708\n//*                *                                                *   FILE 708\n//*     MPFXTALL normally displays the following message for any    *   FILE 708\n//*       managed message                                           *   FILE 708\n//*       /* Issued by MPFXTALL for messageID      */               *   FILE 708\n//*     If you wish not to display this use the following           *   FILE 708\n//*       AUTO/TOKEN feature NODISPLY                               *   FILE 708\n//*       SSCCORP9,USEREXIT(MPFXTALL),AUTO(NODISPLY)                *   FILE 708\n//*       or set the default for all like this:                     *   FILE 708\n//*       .DEFAULT,AUTO(NODISPLY)                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     Long message ID handling is also included, for long         *   FILE 708\n//*       message ID's such as:                                     *   FILE 708\n//*       SVT1P0001I SubTask 01 Completion - Group=22 Subgroup=L    *   FILE 708\n//*       Use the first 8 characters of the message ID for the      *   FILE 708\n//*       commands member name, so the commands member name for     *   FILE 708\n//*       the above message would be SVT1P000 and the MPFLSTxx      *   FILE 708\n//*       entry would look like this:                               *   FILE 708\n//*                *                                                *   FILE 708\n//*       SVT1P0001I,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*                *                                                *   FILE 708\n//*      In addition to the long message id handling I've added     *   FILE 708\n//*       logic testing for the message id.  So, here it is Dean    *   FILE 708\n//*       and Diana you asked for it, yes, I do requests.           *   FILE 708\n//*                *                                                *   FILE 708\n//*       The IF MSGID EQ and IF MSGID NE for up to 25 character    *   FILE 708\n//*        message id's.                                            *   FILE 708\n//*       Say you need to handle several long messages with the     *   FILE 708\n//*       same first 8 characters like:                             *   FILE 708\n//*       SVT1P0011A Some message text                              *   FILE 708\n//*       SVT1P0011B Some other message text                        *   FILE 708\n//*       SVT1P0011C And another message text                       *   FILE 708\n//*       SVT1P0012A And the just one more                          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The MPFLSTxx member would contain the following:           *   FILE 708\n//*       SVT1P0011A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0011B,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0011C,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*       SVT1P0012A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The commands member SVT1P001 in SYS1.MPF.COMMANDS would    *   FILE 708\n//*       contain the following:                                    *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011A                           *   FILE 708\n//*                Do something for this message                    *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011B                           *   FILE 708\n//*                Do something else for this message               *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0011C                           *   FILE 708\n//*                And something different for this message         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*                IF MSGID EQ SVT1P0012A                           *   FILE 708\n//*                And something totally diferent for this message  *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*      Or you can use the AUTO/TOKEN feature for long message     *   FILE 708\n//*       handling to point to a separate commands member.          *   FILE 708\n//*      The MPFLSTxx member would contain the following:           *   FILE 708\n//*       SVT1P0011A,SUP(NO),USEREXIT(MPFXTALL),AUTO(SVT1P11A)      *   FILE 708\n//*       SVT1P0011B,SUP(NO),USEREXIT(MPFXTALL),AUTO(SVT1P11B)      *   FILE 708\n//*      And the two commands member you would have:                *   FILE 708\n//*       Do something                                              *   FILE 708\n//*         and                                                     *   FILE 708\n//*       Do something else                                         *   FILE 708\n//*                *                                                *   FILE 708\n//*      IBM's MPF has a limitation of a max of 10 characters per   *   FILE 708\n//*       message, but MPFXTALL to the rescue, you can specify up   *   FILE 708\n//*       to 25 characters in the IF MSGID EQ section of the        *   FILE 708\n//*       product.  See the creme de la creme for details.          *   FILE 708\n//*                                                                 *   FILE 708\n//*     The IF MSGID+xx FOR xx this can be used when you have       *   FILE 708\n//*       dozens of similar messages like CSQ1234I, CSQ1234E,       *   FILE 708\n//*       CSQ1235I, CSQ1235E etc and you only want to only suppress *   FILE 708\n//*       the I level messages.                                     *   FILE 708\n//*       The MPFLSTxx member would contain:                        *   FILE 708\n//*       CSQ*,USEREXIT(MPFXTALL),AUTO(CSQMSGS)                     *   FILE 708\n//*                *                                                *   FILE 708\n//*       And the commands member CSQMSGS would look like this:     *   FILE 708\n//*                IF MSGID+07 FOR 01 I                             *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*      Also the if message id not equal can be used for checking  *   FILE 708\n//*       if part of the message not equal, coded like this.        *   FILE 708\n//*       message dosn't equal coded like this.                     *   FILE 708\n//*               IF MSGNE+07 FOR 01 I                              *   FILE 708\n//*                SUPPRESS                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now thanks to Dean here is the MPFSUPNO, for those who  *   FILE 708\n//*       have their MPFLSTxx DEFAULT set to SUP(YES) and wish to   *   FILE 708\n//*       not suppress a specific message can do the following:     *   FILE 708\n//*                *                                                *   FILE 708\n//*                MPFLSTxx member:                                 *   FILE 708\n//*                CSQ*,USEREXIT(MPFXTALL),AUTO(CSQMSGS)            *   FILE 708\n//*                *                                                *   FILE 708\n//*                Commands member CSQMSGS:                         *   FILE 708\n//*                *DO NOT MPF SUPPRESS CSQ????E                    *   FILE 708\n//*                IF MSGID+07 FOR 01 E                             *   FILE 708\n//*                MPFSUPNO                                         *   FILE 708\n//*                ENDIF                                            *   FILE 708\n//*                *                                                *   FILE 708\n//*        The end result would be all messages that start with     *   FILE 708\n//*        CSQ would be suppressed except for those message that    *   FILE 708\n//*        have an E in column 8.                                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now for the creme de la creme.  I now present the       *   FILE 708\n//*       SWITCH/VARIABLE section of my product, consisting of the  *   FILE 708\n//*       set switch, delete switch, alter switch, if switch on,    *   FILE 708\n//*       if switch off, if switch equal and if switch not equal.   *   FILE 708\n//*       This is my way of thanking Don, Todd and Emma for         *   FILE 708\n//*       intrusting me with their OS upgrade project after only a  *   FILE 708\n//*       few conference calls.  I believe this should complete     *   FILE 708\n//*       your free automation solution.  I also believe everybody  *   FILE 708\n//*       else should thank them for inspiring me to write this     *   FILE 708\n//*       code.  With this addition to my product all of you should *   FILE 708\n//*       be armed sufficiently to totally eliminate any other      *   FILE 708\n//*       automation products at your shop.                         *   FILE 708\n//*      Now for the meat and taters:                               *   FILE 708\n//*      The SETSWITCH command will set a persistent switch with    *   FILE 708\n//*       a user defined name field up to 8 characters and a user   *   FILE 708\n//*       defined status/information field up to 16 characters.     *   FILE 708\n//*       Both fields have no other limitations; you can use any    *   FILE 708\n//*       characters, spaces, special characters and numbers.       *   FILE 708\n//*      The DELSWITCH command that's what it does, it deletes      *   FILE 708\n//*       the switch.                                               *   FILE 708\n//*      The ALTSWITCH is used to alter the status/information      *   FILE 708\n//*       part of the switch from anything to anything.             *   FILE 708\n//*      The PUTSWITCH places whatever is stored in the             *   FILE 708\n//*       status/information part of the switch to the console.     *   FILE 708\n//*      The IF SWITCH logic has four separate checks.              *   FILE 708\n//*      The IF SWITCH ON checks only to see if the switch is       *   FILE 708\n//*       on/exists, it doesn't check the status/information        *   FILE 708\n//*       section.                                                  *   FILE 708\n//*      The IF SWITCH OFF checks only to see if the switch is      *   FILE 708\n//*       off/doesn't exists.                                       *   FILE 708\n//*      The IF SWITCH EQ checks the named switch                   *   FILE 708\n//*       status/information field is equal to that of the if       *   FILE 708\n//*       statement.                                                *   FILE 708\n//*      The IF SWITCH NE checks the named switch                   *   FILE 708\n//*       status/information field to not be equal to the if        *   FILE 708\n//*       statement.  Here's all the different syntax:              *   FILE 708\n//*                *                                                *   FILE 708\n//*                * Correct positioning                            *   FILE 708\n//*          =COLS>123456789012345678901234567890123456789          *   FILE 708\n//*                *         |        |                             *   FILE 708\n//*                SETSWITCH xxxxxxxx xxxxxxxxxxxxxxxx              *   FILE 708\n//*                *         |                                      *   FILE 708\n//*                DELSWITCH xxxxxxxx                               *   FILE 708\n//*                *         |        |                             *   FILE 708\n//*                ALTSWITCH xxxxxxxx xxxxxxxxxxxxxxxx              *   FILE 708\n//*                *         |                                      *   FILE 708\n//*                PUTSWITCH xxxxxxxx                               *   FILE 708\n//*                *            |                                   *   FILE 708\n//*                IF SWITCH ON xxxxxxxx                            *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH ON                                  *   FILE 708\n//*                *             |                                  *   FILE 708\n//*                IF SWITCH OFF xxxxxxxx                           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH OFF                                 *   FILE 708\n//*                *            |        |                          *   FILE 708\n//*                IF SWITCH EQ xxxxxxxx xxxxxxxxxxxxxxxx           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH EQ                                  *   FILE 708\n//*                *            |        |                          *   FILE 708\n//*                IF SWITCH NE xxxxxxxx xxxxxxxxxxxxxxxx           *   FILE 708\n//*                do something                                     *   FILE 708\n//*                ENDIF SWITCH NE                                  *   FILE 708\n//*                *                                                *   FILE 708\n//*      Here's a sample of usage for messages:                     *   FILE 708\n//*       DCOMMMP1:246:0:DB00308I - LOG AREA IS  50% FULL,          *   FILE 708\n//*       DCOMMMP1:246:0:DB00308I - LOG AREA IS  70% FULL,          *   FILE 708\n//*       DCOMMMT3:246:0:DB00308I - LOG AREA IS  50% FULL,          *   FILE 708\n//*       DCOMMMT3:246:0:DB00308I - LOG AREA IS  70% FULL,          *   FILE 708\n//*                *                                                *   FILE 708\n//*      The MPFLSTxx entries would look like this:                 *   FILE 708\n//*       DCOMMMP1:*,USEREXIT(MPFXTALL),SUP(NO),AUTO(SPILL)         *   FILE 708\n//*       DCOMMMT3:*,USEREXIT(MPFXTALL),SUP(NO),AUTO(SPILL)         *   FILE 708\n//*       $HASP395,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)            *   FILE 708\n//*                *                                                *   FILE 708\n//*      The commands member SPILL would look like this:            *   FILE 708\n//*       IF MSGID EQ DCOMMMP1:246:0:DB00308I                       *   FILE 708\n//*       IF SWITCH OFF DCOMMMP1                                    *   FILE 708\n//*       SETSWITCH DCOMMMP1 Submitted DCOMSPLP                     *   FILE 708\n//*       S DCOMSPLP                                                *   FILE 708\n//*       WTO MPFXTALL submitted offload DCOMSPLP for DCOMMMP1      *   FILE 708\n//*       ENDIF SWITCH OFF                                          *   FILE 708\n//*       IF SWITCH ON DCOMMMP1                                     *   FILE 708\n//*       WTO DCOMSPLP active for DCOMMMP1 no offload submitted     *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF MSGID EQ DCOMMMT3:246:0:DB00308I                       *   FILE 708\n//*       IF SWITCH OFF DCOMMMT3                                    *   FILE 708\n//*       SETSWITCH DCOMMMT3 Submitted DCOMSPL3                     *   FILE 708\n//*       S DCOMSPL3                                                *   FILE 708\n//*       WTO MPFXTALL submitted offload DCOMSPL3 for DCOMMMT3      *   FILE 708\n//*       ENDIF SWITCH OFF                                          *   FILE 708\n//*       IF SWITCH ON DCOMMMT3                                     *   FILE 708\n//*       WTO DCOMSPL3 active for DCOMMMT3 no offload submitted     *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member $HASP395 would look like this:         *   FILE 708\n//*       IF WORD 01 DCOMSPLP                                       *   FILE 708\n//*       DELSWITCH DCOMMMP1                                        *   FILE 708\n//*       WTO DCOMSPLP has ended DCOMMMP1 switch has been reset     *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF WORD 01 DCOMSPL3                                       *   FILE 708\n//*       DELSWITCH DCOMMMT3                                        *   FILE 708\n//*       WTO DCOMSPL3 has ended DCOMMMT3 switch has been reset     *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Here's one usage for the PUTSWITCH and GET REPLYID this    *   FILE 708\n//*       one's for Jimmy from Alaska.                              *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Theses are the messages:                                   *   FILE 708\n//*       @32 REPLY WITH REQUEST TO IDMS V8                         *   FILE 708\n//*       @31 REPLY WITH REQUEST TO IDMS V9                         *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The MPFLSTxx entries would look like this:                 *   FILE 708\n//*       REPLY,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(NO)      *   FILE 708\n//*       SHUTIDMS,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(NO)   *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member REPLY would look like this:            *   FILE 708\n//*       IF WORD 05 V8                                             *   FILE 708\n//*       GET REPLYID                                               *   FILE 708\n//*       DELSWITCH IDMSV8                                          *   FILE 708\n//*       SETSWITCH IDMSV8   &,/CHE DUMPQ                           *   FILE 708\n//*       ENDGET ID                                                 *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF WORD 05 V9                                             *   FILE 708\n//*       GET REPLYID                                               *   FILE 708\n//*       DELSWITCH IDMSV9                                          *   FILE 708\n//*       SETSWITCH IDMSV9   &,/CHE DUMPQ                           *   FILE 708\n//*       ENDGET ID                                                 *   FILE 708\n//*       ENDIF                                                     *   FILE 708\n//*       *                                                         *   FILE 708\n//*      The commands member SHUTIDMS would look like this:         *   FILE 708\n//*       IF SWITCH ON IDMSV8                                       *   FILE 708\n//*       PUTSWITCH IDMSV8                                          *   FILE 708\n//*       DELSWITCH IDMSV8                                          *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       *                                                         *   FILE 708\n//*       IF SWITCH ON IDMSV9                                       *   FILE 708\n//*       PUTSWITCH IDMSV9                                          *   FILE 708\n//*       DELSWITCH IDMSV9                                          *   FILE 708\n//*       ENDIF SWITCH ON                                           *   FILE 708\n//*       *                                                         *   FILE 708\n//*      Then have your automation shutdown procedure issue a       *   FILE 708\n//*       SHUTIDMS                                                  *   FILE 708\n//*                                                                 *   FILE 708\n//*     A few very slick additions from Garry Green.  First is the  *   FILE 708\n//*       ASTYPE this allows you too check if the task is a TSO,    *   FILE 708\n//*       Batch or STC, T for TSO, J for BATCH and S for STC.       *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        IF ASTYPE EQ J                                           *   FILE 708\n//*        IF ASTYPE EQ S                                           *   FILE 708\n//*       So if you needed to reply cancel to the following message *   FILE 708\n//*       only for TSO Userid's                                     *   FILE 708\n//*        *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.         *   FILE 708\n//*       The Commands IEF238D member would look like this          *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        REPLY NN,CANCEL                                          *   FILE 708\n//*        ENDIF ASTYPE                                             *   FILE 708\n//*       *                                                         *   FILE 708\n//*     Now for the TSOROUTE command this allows a TSO user to      *   FILE 708\n//*       reply to there own outstanding requests WTOR's from there *   FILE 708\n//*       own TSO userid for WTOR's issued for there TSO userid.    *   FILE 708\n//*       So if you want all user's to be able to reply to message  *   FILE 708\n//*       *61 IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.          *   FILE 708\n//*       The Commands IEF238D member would look like this          *   FILE 708\n//*        IF ASTYPE EQ T                                           *   FILE 708\n//*        TSOROUTE REPLY                                           *   FILE 708\n//*        ENDIF ASTYPE                                             *   FILE 708\n//*       This will allow only the TSO userid to reply to the       *   FILE 708\n//*       outstanding reply, the TSO userid will receive the        *   FILE 708\n//*       following message, there will be no outstanding request   *   FILE 708\n//*       on the master console:                                    *   FILE 708\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *   FILE 708\n//*         WTOR-CONSOLES CAN'T REPLY                               *   FILE 708\n//*        IEF238D GGG - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*       *                                                         *   FILE 708\n//*       The other options for TSOROUTE are TSOROUTE which only    *   FILE 708\n//*       sends a message to to the TSO userid as follows:          *   FILE 708\n//*        MPF203I FOLLOWING WTOR FOR DISPLAY ONLY - REPLY MUST BE  *   FILE 708\n//*         ENTERED FROM CONSOLE                                    *   FILE 708\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*       *                                                         *   FILE 708\n//*       And the TSOROUTE SUPPRESS this will suppress the reply    *   FILE 708\n//*       to the outstanding request, good for password replies.    *   FILE 708\n//*       The message sent to the TSO userid is as follows:         *   FILE 708\n//*        MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOWING    *   FILE 708\n//*         WTOR-CONSOLES CAN'T REPLY                               *   FILE 708\n//*        MPF202I REPLY VALUE YOU ENTER WILL BE SUPPRESSED FROM    *   FILE 708\n//*         CONSOLE, JOBLOG & SYSLOG                                *   FILE 708\n//*        IEF238D GSI - REPLY DEVICE NAME OR 'CANCEL'.             *   FILE 708\n//*                                                                 *   FILE 708\n//*     ESTAE recovery routine added by Garry GREAT addition        *   FILE 708\n//*       now no matter what happens MPFTXALL will stay alive.      *   FILE 708\n//*       If an MPF exit routine such as MPFXTALL abends, it is     *   FILE 708\n//*       disabled for ALL the message id's that it is associated   *   FILE 708\n//*       This can have several undesirable side effects:           *   FILE 708\n//*       1) Perhaps the exit is abending due to a bug triggered by *   FILE 708\n//*          only one message id that rarely occurs.                *   FILE 708\n//*       2) Until the disablement is noticed, many automation      *   FILE 708\n//*          events can be lost.                                    *   FILE 708\n//*       ESTAEX protection around the entire MPFXTALL code;        *   FILE 708\n//*       in the event that there is an abend in MPFXTALL, a WTO    *   FILE 708\n//*       MPF038E MPFXTALL ABENDED; ABEND WAS SUPPRESSED message    *   FILE 708\n//*       will be issued, no further processing will occur for the  *   FILE 708\n//*       message that caused the abend, but since the abend was    *   FILE 708\n//*       suppressed, MPFXTALL remains active.                      *   FILE 708\n//*                                                                 *   FILE 708\n//*     Inner and outer IF's for all, IF's any combination up to 16 *   FILE 708\n//*       deep any order, keep track of your ENDIF's and ENDGET's.  *   FILE 708\n//*                                                                 *   FILE 708\n//*     Added error handling for Sysprog's that don't RTFM.         *   FILE 708\n//*                                                                 *   FILE 708\n//*     The SETAUTO command will set the Automation flag on, this   *   FILE 708\n//*       will pass the message to any other automation packages,   *   FILE 708\n//*       why I don't know, why would one need anything else.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     The SETAMRF command will set the Automatic Retain on for    *   FILE 708\n//*       that message, AMRF needs to be on for this to work.       *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit has been tested on OS/390 2.10, z/OS 1.4 z/OS 1.5 *   FILE 708\n//*       z/OS 1.6 and z/OS 1.7                                     *   FILE 708\n//*                                                                 *   FILE 708\n//*     For existing users, if you're using a version previous to   *   FILE 708\n//*       Version 5 please see $EXISTNG for proper replacment steps.*   FILE 708\n//*                                                                 *   FILE 708\n//*     Your next stop should be $INSTALL and $USAGE                *   FILE 708\n//*                                                                 *   FILE 708\n//*     This exit was originally started from CBT FILE345           *   FILE 708\n//*       MPFXTALL courtesy of Murray Nicholas.  Thank you          *   FILE 708\n//*       Murray for a great idea.                                  *   FILE 708\n//*                                                                 *   FILE 708\n//*     Also included are the DYNAMIC ALLOCATION Macros from        *   FILE 708\n//*       CBT FILE615 courtesy of Lionel B Dyck.  Thank you         *   FILE 708\n//*       Lionel for an easy and seamless way to implement          *   FILE 708\n//*       Dynamic Allocation.                                       *   FILE 708\n//*                                                                 *   FILE 708\n//*     And also the read directory part of the MPFLOAD program     *   FILE 708\n//*       was copied from CBT FILE558 courtesy of Dick              *   FILE 708\n//*       Thornton.  Thanks Dick for the code you provided.         *   FILE 708\n//*       Lots of good code there.  You should all have a look.     *   FILE 708\n//*                                                                 *   FILE 708\n//*     I'd also like to thank Marc Reibstein for his neet parsing  *   FILE 708\n//*       routine @ http://www.marcsweb.com/mnweb_370trtparse.shtml *   FILE 708\n//*       I no longer use this thanks to Garry's SRST command       *   FILE 708\n//*       addition.                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     And I'd like to thank Dave Mesiano and Mike Wojtukiewicz    *   FILE 708\n//*       for there help with questions I've had.                   *   FILE 708\n//*                                                                 *   FILE 708\n//*     And last but not least to Sam Golob for pointing me to      *   FILE 708\n//*       some neat HEX conversion macro and code.  Thanks Sam      *   FILE 708\n//*       for enabling me to display the address and length of      *   FILE 708\n//*       the Name/Token created and for all of your great work     *   FILE 708\n//*       with CBT.                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     I've included programs ASKOPER by Bill Godfrey and PAUSE    *   FILE 708\n//*       since I use them and made reference to them in an example *   FILE 708\n//*       of my automated shutdown see member SHUTDOWN.             *   FILE 708\n//*                                                                 *   FILE 708\n//*     And now I'd like to thank all the new contributors.         *   FILE 708\n//*                                                                 *   FILE 708\n//*  Contributed modifications:                                     *   FILE 708\n//*                                                                 *   FILE 708\n//*   Tom Lewis:                                                    *   FILE 708\n//*       TL01 - Displays the message id causing the command/reply  *   FILE 708\n//*              to be issued ie.  Ata'boy Tom.                     *   FILE 708\n//*        /* Issued by MPFXTALL for messageID      */              *   FILE 708\n//*                                                                 *   FILE 708\n//*   Peter Johnson:                                                *   FILE 708\n//*       PJ01 - Multi-line message handling, great addition.       *   FILE 708\n//*       PJ02 - Multiple blanks allowed between words.             *   FILE 708\n//*       PJ03 - Get Word length increased to 40 chars              *   FILE 708\n//*       PJGS1 - Joint effort of AUTO/TOKEN by Peter and Glenn     *   FILE 708\n//*                                                                 *   FILE 708\n//*   Garry G. Green:                                               *   FILE 708\n//*       GG01 - Code to enable MPFLOAD to act as a subsystem,      *   FILE 708\n//*              this allows MPFLOAD to execute very early in the   *   FILE 708\n//*              IPL, another great addition.                       *   FILE 708\n//*       GG58 - IF ASTYPE and TSOROUTE                             *   FILE 708\n//*       GG59 - ESATE protection for MPFXTALL ******* Thanks Garry *   FILE 708\n//*                                                                 *   FILE 708\n//*   Dean Tesar                                                    *   FILE 708\n//*       DT01 - Code for suppressing joblog only messages NOJOBLOG *   FILE 708\n//*              and syslog only messages NOSYSLOG.                 *   FILE 708\n//*       DT02 - MPFSUPNO setting                                   *   FILE 708\n//*       DT03 - Three and four digit replies                       *   FILE 708\n//*                                                                 *   FILE 708\n//*                                                                 *   FILE 708\n//*     If you want to be on the mailing list send me an email.     *   FILE 708\n//*                                                                 *   FILE 708\n//*     All comments, suggestions or requests please send email.    *   FILE 708\n//*                                                                 *   FILE 708\n//*     Author: Glenn Siegel                                        *   FILE 708\n//*             S.S.C. Corp.                                        *   FILE 708\n//*             GlennSiegel@optonline.net                           *   FILE 708\n//*             631-444-5339                                        *   FILE 708\n//*             516-607-4005 Cell                                   *   FILE 708\n//*             We do systems right!                                *   FILE 708\n//*                                                                 *   FILE 708\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AOP075I": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x05\\x05O\\x01\\x05\\x05O\\x18\\t\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-23T00:00:00", "modifydate": "2005-02-23T18:09:56", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "IF ALL EQ Daemon aopd was started\nS NETSPOOL\nENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASKOPER": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x07\\x03\\x0f\\x01\\x07\\x03\\x0f\\x11\\x03\\x00\\xc1\\x00\\xc1\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-30T00:00:00", "modifydate": "2007-01-30T11:03:55", "lines": 193, "newlines": 193, "modlines": 0, "user": "GSI"}, "text": "//A EXEC ASMACL,PARM.C='OBJECT,NODECK,XREF',\n//         COND.L=(4,LT,C)\n//C.SYSIN DD *\n         TITLE '   A S K O P E R   '\n***********************************************************************\n*                                                                     *\n*        'ASKOPER'                                                    *\n*                                                                     *\n***********************************************************************\n*\n*        WRITTEN BY. BILL GODFREY.\n*        DATE WRITTEN. SEPTEMBER 25 1980.\n*        DATE UPDATED. FEBRUARY 9 1982.\n*        DESCRIPTION.\n*         THIS PROGRAM WRITES A MESSAGE ON THE OPERATOR CONSOLE,\n*         WAITS FOR EITHER OF 2 VALID REPLIES,\n*         SETS THE RETURN CODE TO 0 OR 8 BASED ON THE REPLY.     JDM1\n*\n*         THE PARM FIELD SPECIFIES THE MESSAGE AND THE VALID REPLIES.\n*         THERE ARE 3 FIELDS IN THE PARM, SEPARATED BY COMMAS.\n*\n*         THE FIRST FIELD IN THE PARM IS THE REPLY THAT WILL SET\n*         THE RETURN CODE TO 0.\n*         THE SECOND FIELD IN THE PARM IS THE REPLY THAT WILL SET\n*         THE RETURN CODE TO 8.                                  JDM1\n*         THE THIRD FIELD IN THE PARM IS THE MESSAGE.\n*\n*         FOR EXAMPLE,\n*            PARM='DAILY,WEEKLY,IS THIS THE DAILY OR WEEKLY RUN?'\n*\n*         IF THE FIRST TWO FIELDS ARE NULL (PARM=',,MESSAGE')\n*            THEN 'YES' AND 'NO' ARE THE VALID REPLIES.\n*\n         SPACE\nASKOPER  AMODE 24\nASKOPER  RMODE 24\nASKOPER  CSECT\n         SAVE  (14,12),,ASKOPER_&SYSDATE._&SYSTIME\n         LR    R12,R15             GET EP ADDR\n         USING ASKOPER,R12         ESTABLISH ADDRESSABILITY\n         LR    R15,R13             PERFORM\n         LA    R13,SAVE               SAVE\n         ST    R15,4(,R13)              CHAINING\n         ST    R13,8(,R15)               .........\n         MVC   ANS0,=CL12'YES'\n         MVC   ANS4,=CL12'NO'\n         LA    R4,WTORW+12\n         MVI   0(R4),C' '          FILL MESSAGE AREA\n         MVC   1(69,R4),0(R4)         WITH BLANKS\n         MVC   0(8,R4),WTOR1+12    MOVE DEFAULT MESSAGE 'REPLY?'\n         LA    R0,70               SET DEFAULT LENGTH TO 70\n         STH   R0,LENGTH\n         L     R2,0(,R1)           POINT TO PARM\n         LH    R3,0(,R2)           GET PARM LENGTH\n         LTR   R3,R3               IS THERE A PARM\n         BZ    PARMX               NO, USE DEFAULTS\n         LA    R2,2(,R2)           POINT TO PARM DATA\n         LA    R0,1                CONSTANT 1 FOR INCREMENTING\n         LA    R1,12               MAX LENGTH OF ANSWERS\nPARM1T   EQU   *\n         LA    R4,ANS0             POINT TO ANSWER AREA\n         CLI   0(R2),C','          IS IT NULL\n         BE    PARM2               YES, LEAVE ANSWER DEFAULT\n         MVC   ANS0,=CL12' '       PAD ANS0 WITH BLANKS\n         SR    R5,R5               INITIAL LENGTH\nPARM1L   EQU   *\n         CLI   0(R2),C','          LOOK FOR END OF STRING\n         BE    PARM2               ANS0 COMPLETE\n         AR    R5,R0               ADD 1 TO LENGTH\n         CR    R5,R1               IS IT TOO LONG\n         BH    EXIT12              YES, PARM ERROR               JDM1\n         MVC   0(1,R4),0(R2)       COPY THE CHARACTER\n         AR    R4,R0               NEXT OUTPUT CHAR\n         AR    R2,R0               NEXT INPUT CHAR\n         BCT   R3,PARM1L           BRANCH UNLESS NO MORE PARM\n         B     EXIT12              PARM ERROR                    JDM1\n         SPACE\nPARM2    EQU   *\n         AR    R2,R0               POINT PAST COMMA\n         SR    R3,R0               REDUCE LENGTH ACCORDINGLY\n         BNP   EXIT12              NOTHING AFTER COMMA, PARM ERR JDM1\nPARM2T   EQU   *\n         LA    R4,ANS4             POINT TO ANSWER AREA\n         CLI   0(R2),C','          IS IT NULL\n         BE    PARM3               YES, LEAVE ANSWER DEFAULT\n         MVC   ANS4,=CL12' '       PAD ANS4 WITH BLANKS\n         SR    R5,R5               INITIAL LENGTH\nPARM2L   EQU   *\n         CLI   0(R2),C','          LOOK FOR END OF STRING\n         BE    PARM3               ANS0 COMPLETE\n         AR    R5,R0               ADD 1 TO LENGTH\n         CR    R5,R1               IS IT TOO LONG\n         BH    EXIT12              YES, PARM ERROR               JDM1\n         MVC   0(1,R4),0(R2)       COPY THE CHARACTER\n         AR    R4,R0               NEXT OUTPUT CHAR\n         AR    R2,R0               NEXT INPUT CHAR\n         BCT   R3,PARM2L           BRANCH UNLESS NO MORE PARM\n         B     EXIT12              PARM ERROR                    JDM1\n         SPACE\nPARM3    EQU   *\n         AR    R2,R0               POINT PAST COMMA\n         SR    R3,R0               REDUCE LENGTH ACCORDINGLY\n         BNP   EXIT12              NOTHING AFTER COMMA, PARM ERR JDM1\nPARM3T   EQU   *\n         LA    R4,WTORW+12         POINT TO WTOR TEXT\n         CLI   0(R2),C','          IS IT NULL\n         BE    EXIT12              YES, PARM ERROR               JDM1\n         MVI   0(R4),C' '          PUT BLANK IN WTOR TEXT\n         MVC   1(69,R4),0(R4)      PAD TEXT WITH BLANKS\n         SR    R5,R5               INITIAL LENGTH\n         LA    R1,70               MAX LENGTH OF TEXT\nPARM3L   EQU   *\n         CLI   0(R2),C','          LOOK FOR END OF STRING\n         BE    PARM3X              TEXT COMPLETE\n         AR    R5,R0               ADD 1 TO LENGTH\n         CR    R5,R1               IS IT TOO LONG\n         BH    EXIT12              YES, PARM ERROR               JDM1\n         MVC   0(1,R4),0(R2)       COPY THE CHARACTER\n         CLI   0(R4),C'%'          COMMA SUBSTITUTE\n         BNE   *+8                 NO, SKIP NEXT INSTRUCTION\n         MVI   0(R4),C','          REPLACE WITH COMMA\n         AR    R4,R0               NEXT OUTPUT CHAR\n         AR    R2,R0               NEXT INPUT CHAR\n         BCT   R3,PARM3L           BRANCH UNLESS NO MORE PARM\nPARM3X   EQU   *\n         STH   R5,LENGTH\nPARMX    EQU   *                   PARM EXIT\n         LA    R1,WTORW\n         MVC   0(12,R1),WTOR1      COPY WTOR PREFIX\n         LH    R15,LENGTH\n         LA    R15,4(,R15)\n         STH   R15,8(,R1)\n         LA    R15,8(R15,R1)       POINT PAST TEXT\n         MVC   0(4,R1),WTOR1R      COPY DESC AND ROUTCDE\nLOOP     EQU   *\n         MVC   REPLY,=CL12' '\n         XC    ECB,ECB\n         WTOR  ,REPLY,12,ECB,MF=(E,WTORW)\n         WAIT  ECB=ECB\n         OC    REPLY,=CL12' '      UPPER CASE, CAPS\n         CLC   REPLY,ANS0\n         BE    EXIT0\n         CLC   REPLY,ANS4\n         BE    EXIT8\n         WTO   MF=(E,WTOINV)\n         B     LOOP\n         SPACE\nEXIT12   EQU   *\n         LA    R15,12\n         B     EXIT\n         SPACE\nEXIT8    EQU   *\n         LA    R15,8\n         B     EXIT\n         SPACE\nEXIT0    EQU   *\n         SR    R15,R15\nEXIT     EQU   *\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\n         SPACE\n         LTORG\n         SPACE\nWTOINV   WTO   ' REPLY IS INVALID ',ROUTCDE=(1,2,3,4,5),MF=L\n         SPACE\nWTOR1    WTOR  ' REPLY ?',                                             X\n               ROUTCDE=(1,2,3,4,5),MF=L\nWTOR1R   EQU   *-4\nWTOR1L   EQU   *-WTOR1\nECB      DS    F\nSAVE     DS    18F\nREPLY    DS    CL12\nANS0     DS    CL12\nANS4     DS    CL12\nWTORW    DS    3F,CL70,XL4\nWTORWR   EQU   *-4\nLENGTH   DS    H\n         DS    0D\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ASKOPER\n//L.SYSLMOD DD DSN=SYSP.LINKLIB(ASKOPER),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMACL": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x009\\x01\\x05\\x03\\x1f\\x01\\x07\\x06\\x9f\\x17Q\\x00^\\x000\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2005-01-31T00:00:00", "modifydate": "2007-03-10T17:51:39", "lines": 94, "newlines": 48, "modlines": 0, "user": "GSI"}, "text": "//GSIASMCL JOB ,'SIEGEL',CLASS=A,MSGCLASS=X,REGION=0M,\n//         MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//*********************************************************************\n//*                                                                   *\n//*         CHANGES BEFORE SUBMITTING                                 *\n//*                                                                   *\n//* C ALL 'CBT.FILE708.PDS' 'THIS DATASET'                            *\n//* C ALL 'CBT.FILE708.MACROS' 'THE DATASET FROM STEP 6 OF $INSTALL'  *\n//* C ALL 'SYSP.LINKLIB' 'A DATASET IN THE LINKLIST'                  *\n//*                                                                   *\n//*********************************************************************\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(TSOROUTE)    <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,COND=(4,LT,C),\n//         PARM='XREF,LET,LIST,RENT,REUS,REFR'\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,1,1)),\n//             DSN=&&TSOROUTE(TSOROUTE)\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSIN    DD *\n  NAME TSOROUTE(R)\n/*\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(MPFLOAD)     <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(4,LT,C)\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYSP.LINKLIB,DISP=SHR                 <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSIN    DD *\n  ENTRY MPFLOAD\n  SETCODE AC(1)\n  INCLUDE SYSLIB(IEANTCR)\n  INCLUDE SYSLIB(IEANTRT)\n  INCLUDE SYSLIB(IEANTDL)\n  NAME MPFLOAD(R)\n/*\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(MPFXTALL)    <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,COND=(4,LT,C),\n//         PARM='XREF,LET,LIST,RENT,REUS,REFR'\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYSP.LINKLIB,DISP=SHR                 <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//         DD DSN=&&TSOROUTE,DISP=SHR\n//SYSIN    DD *\n  ENTRY MPFXTALL\n  SETCODE AC(1)\n  INCLUDE SYSLIB(IEANTRT)\n  INCLUDE SYSLIB(TSOROUTE)\n  NAME MPFXTALL(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASTTEST": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x07\\x07O\\x01\\x07\\x07O\\x11\\x07\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-15T00:00:00", "modifydate": "2007-03-15T11:07:05", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "//GSIX     JOB ,'SIEGEL',CLASS=A,MSGCLASS=X,REGION=0M,\n//         MSGLEVEL=(1,1),NOTIFY=&SYSUID\n// EXEC PGM=ASKOPER,PARM=',,CHECKAST HI GARRY'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CADO017D": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:00:11", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,N\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CAT9010P": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:00:20", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,U\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CHECKAST": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00 \\x01\\x07\\x07O\\x01\\x07\\x07O\\x11'\\x00:\\x00:\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-03-15T00:00:00", "modifydate": "2007-03-15T11:27:20", "lines": 58, "newlines": 58, "modlines": 0, "user": "GSI"}, "text": "GET WORD 02\nSETSWITCH GLENN    TO TEST FOR SW\n*\nIF SYSID EQ SSC\nIF SWITCH EQ GLENN    FALSE FOR SW\nSE 'SWITCH EQ FALSE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nIF SWITCH NE GLENN    TO TEST FOR SW\nSE 'SWITCH NE FALSE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH NE GLENN    TEST FOR SW\nSE 'SWITCH NE TRUE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH ON GLENN\nSE 'SWITCH ON TRUE %',USER=(GSI)\nENDIF SWITCH ON\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF AMY\nSE 'SWITCH OFF TRUE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nALTSWITCH GLENN    TEST FOR SW\n*\nIF SWITCH EQ GLENN    TEST FOR SW\nSE 'SWITCH EQ TRUE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nDELSWITCH GLENN\n*\nIF ASTYPE EQ S\nSE 'ASTYPE STC FALSE %',USER=(GSI)\nREPLY NN,NO\nENDIF ASTYPE\n*\nIF ASTYPE EQ T\nSE 'ASTYPE TSO FALSE %',USER=(GSI)\nREPLY NN,NO\nENDIF ASTYPE\n*\nIF ASTYPE EQ J\nSE 'ASTYPE BATCH TRUE %',USER=(GSI)\nREPLY NN,YES\nENDIF ASTYPE\n*\nENDIF\n*\nENDGET\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COF536I": {"ttr": 1558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x05\\x12\\x0f\\x01\\x06\\x11?\\x17\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-04-30T00:00:00", "modifydate": "2006-04-23T17:00:29", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "P DLF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CSQMSGS": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x06\\x10\\x1f\\x01\\x06\\x10\\x1f\\x13\\x00\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-04-11T00:00:00", "modifydate": "2006-04-11T13:00:13", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "IF MSGID+07 FOR 01 I\nSUPPRESS\nENDIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DCOMMMP1": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x06\\t\\x1f\\x01\\x06\\x10\\x0f\\x18(\\x00\\t\\x00\\t\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-04-01T00:00:00", "modifydate": "2006-04-10T18:28:17", "lines": 9, "newlines": 9, "modlines": 0, "user": "GSI"}, "text": "IF SWITCH OFF DCOMMMP1\nSETSWITCH DCOMMMP1 Submitted DCOMSPLP\nS DCOMSPLP\nWTO MPFXTALL submitted offload DCOMSPLP for DCOMMMP1\nENDIF SWITCH OFF\n*\nIF SWITCH ON DCOMMMP1\nWTO DCOMSPLP active for DCOMMMP1 no offload submitted\nENDIF SWITCH ON\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELNT": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01\\x05\\x01\\x8f\\x01\\x05\\x19o\\x18)\\x00P\\x00P\\x00\\t\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2005-01-18T00:00:00", "modifydate": "2005-07-15T18:29:05", "lines": 80, "newlines": 80, "modlines": 9, "user": "GSI"}, "text": "DELNT    CSECT\nDELNT    AMODE 31\nDELNT    RMODE ANY\n         YREGS\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         BALR  R10,R0                  ESTABLISH MODULE BASE\nBASE     EQU   *\n         USING *,R10                   ESTABLISH ADDRESSABILITY\n         LA    R11,4095(R10)           R11 = SECOND BASE REGISTER\n         LA    R11,1(R11)\n         USING BASE+4096,R11\n         LA    R12,4095(R11)           R12 = THIRD  BASE REGISTER\n         LA    R12,1(R12)\n         USING BASE+8192,R12\n         ST    R13,SAVE+4              SET BACKWARD PTR\n         LA    R15,SAVE                GET ADDRESS OF SAVE AREA\n         ST    R15,8(R13)              SET FORWARD PTR\n         LR    R13,R15                 SET REG13 TO POINT TO STANDARD\n         B     CREATNT                 BRANCH AROUND CONSTANTS\n***********************************************************************\n         DC    C' MPFLOAD '            PROGRAM NAME IDENTIFIER\n         DC    C'&SYSDATE '            ASSEMBLY DATE\n         DC    C'&SYSTIME '            ASSEMBLY TIME\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\nSAVE     DS    18F                     MY REGISTER SAVE AREA\n***********************************************************************\n*********************************************************************\n*        NAME TOKEN SECTION                                         *\n*        CHECK FOR EXISTING NT IF, FREE STORAGE AND DELETE NAME/TOK *\n*        CREATE NEW NAME/TOKEN                                      *\n*********************************************************************\nCREATNT  EQU   *\n         MODESET MODE=SUP,KEY=ZERO     AUTHORIZE FOR GETMAIN IN ECSA\n         CALL  IEANTRT,(SYSLVL,NAME,TOKEN2,RETCODE)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF002I - NAME/TOKEN EXISTS DELETE N/T AND STORAGE'\n         L     R5,ECSA_AD2             STORE ECSA ADDRESS IN R5\n         L     R9,ECSA_LE2             STORE LENGTH OF ECSA IN R9\n         FREEMAIN RU,LV=(R9),A=(R5),SP=241,KEY=0\n         CALL  IEANTDL,(SYSLVL,NAME,RETCODE)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF003I - NAME/TOKEN AND STORAGE SUCCESSFULLY DELETED'\n         ENDIF\n         ENDIF\n*********************************************************************\n*        END OF JOB                                                 *\n*********************************************************************\nEOJ      EQU *\n         MODESET MODE=PROB,KEY=NZERO\n         L     R13,SAVE+4              RESTORE RETURN POINTER\n         LM    R14,R12,12(R13)         RESTORE CALLING PGM REGISTERS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n*********************************************************************\n*        DATA AREAS FOR NAME TOKEN                                  *\n*********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'      THE NAME OF THE TOKEN\n         DS    0D\nTOKEN    DC    XL16'00'                  THE TOKEN\n         ORG   TOKEN\nECSA_ADD DS    F                         ECSA ADDR\nECSA_LEN DS    F                         LENGTH OF ECSA\n         ORG\nTOKEN2   DC    XL16'00'                  THE TOKEN2\n         ORG   TOKEN2\nECSA_AD2 DS    F                         ECSA ADDR\nECSA_LE2 DS    F                         LENGTH OF ECSA\n         ORG\nRETCODE  DC    F'0'\nPERSOPT  DC    A(IEANT_PERSIST)       KEEP THE TOKEN AFTER JOB ENDS\n*********************************************************************\n         PRINT   GEN\n         IEANTASM                NAME TOKEN SERVICE ASSEMBLER DECLARES\n*********************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DISCLAIM": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x04\\x01_\\x01\\x05\\x05\\x7f\\x08\\x19\\x00\\x0c\\x00\\x15\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-01-15T00:00:00", "modifydate": "2005-02-26T08:19:50", "lines": 12, "newlines": 21, "modlines": 0, "user": "GSI"}, "text": " Disclaimer\n  All software in this file is freeware.  It may not be sold for profit.\n\n Limitations of Liability\n  Nothing in these documents and programs are guaranteed.  I take no\n   responsibility for any damage or misuse of these programs.\n\n     Author: Glenn Siegel\n             S.S.C. Corp.\n             GlennSiegel@optonline.net\n             631-444-5339\n             516-607-4005 Cell\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EMAILS": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x13\\x01\\x05'O\\x01\\x05'O\\x186\\x00\\xa0\\x00\\xa0\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-01T00:00:00", "modifydate": "2005-10-01T18:36:13", "lines": 160, "newlines": 160, "modlines": 0, "user": "GSI"}, "text": "Tuesday, June 28, 2005 7:27 PM\nGlenn,\n\nThank you for a superior MPFXTALL!  I have been using Murray Nicholas' for\nsome time and have written a reply interface similar to it.\n\nThe copy I have attached to this e-mail contains updates which include\ncorrections for re-entrant CALL problem caught by the assembler and\ncleaning up some other miscellaneous error messages during assembly.\n\nI have taken the 'issued by' a step further to include the message number\ncausing the command/reply to be issued.  For replies this does require\nsingle quotes to be added around the REPLY in the PDS.\n\nYour exit is replacing four MPF exit here.  Thanks again.\n\nTom Lewis\nSr. Systems Programmer\n********************************************************************************\nFriday, July 15, 2005 12:13 PM\nand here's an enhancement\n\nmany products / users issue messages using characters that are not alpha,\nnumeric or national ... therefore they cannot be member names ...\n\ncheck the first 8 positions ... if not alpha, numeric or national ... use a\ndefault membername of $$$$#### or whatever ... and allow the logic in the\ncommands member to be able to IF MSG = <CMBT004> ... type logic ....\n\nnot sure how much effort you care to put into this .... I may look at it if I\nget time (maybe mid next month)\n\nthanx Dean\n********************************************************************************\nWednesday, July 20, 2005 6:57 AM\nExcellent ..... didnt think you could get to this as quickly as you did.\n\nthanx Dean\n********************************************************************************\nMonday, August 01, 2005 12:42 PM\nHi Glenn,\n\nI have been trying your excellent MPF exit on some of my test systems. I\nneeded a mpf exit to submit SMF save jobs and so I installed your first\nversion.  I had this working fine for one of our systems but hit a snag on a\nsecond.  On this system we use SMF file longer than the normal and instead\nof IEE362A we get IEE391A. sample:-\n\nIEE391A SMF ENTER DUMP FOR DATA SET ON VOLSER KSYQUE, 640\n                DSN=SYS1.RESCUE.MAN1\n\nThis is a problem for us as it is a multi-line message and your exit only\nhandles the first line. The second line contains the DSN!\nAs an exercise I decided to try to update your code to handle a second line\nand then hit a second snag. Your exit also does not allow for extra blanks\nbetween words which appear at the start of the second line for IEE391A.\nhave spent a little time working on it and I have made the following\nchanges:-\n\n1. Support for a second message line.\n2. Multiple blanks allowed between words.\n3. Word length increased to 64 chars.\n4. Support for IF not word (coded as IF \\WORD %%).\n5. Abend command to abend exit for testing.\n\nDo you want a copy of my version?  I have reworked my version on the one\ndated \"MPFXTALL 995  2005/07/15  2005/07/20 11:05:15\"\n\nBest regards\n\nPeter Johnson\nSystem Programmer\n********************************************************************************\nTuesday, August 02, 2005 9:21 AM\nHi Glenn,\n\nI have attached my version of MPFXTALL.  The changed lines are identified\nwith **PJ#** comments.\n\nChanges as follows:-\n\nPJ1 Support second message line. CTXTTXPN is zero on initial entry but\nis filled on the next entry if the second line is requested by setting\nCTXTRPML in CTXTRFB1 and exiting from the module. I save the address of the\ndynamic area in the exit work area pointed to by CTXTIWKP.  I also increased\nthe maximum message length as I was not sure about getting two long line\nI have only tested this with message IEE391A.  I also changed the routines\nusing the message length and found I had to add 2 to the length to get the\nTRT to work when the last field required was at the end of the message.\n\nPJ2 Multiple blanks between message words.  The second line for the\nIEE391A message has 16 blanks at the start and this is the main reason for\nthis change.\n\nPJ3 Word length increased to 64 chars.  Again for the message IEE391A\nthe DSN= field was longer than your 12 characters. 64 was arbitrary choice.\n\nPJ4 Support for IF not word (coded as IF \\WORD %%).  Why did I think\nthis was useful?  I was receiving message IEE388I after IEE391A. Although I\nhad no need to process it, I used for testing and realised that this message\nwas not 2 lines but issued twice with different values.  Examples:-\n\nIEE391A SMF ENTER DUMP FOR DATA SET ON VOLSER KSYQUE, 704\n                DSN=SYS1.RESCUE.MAN2\nIEE388I SMF NOW RECORDING ON VOLSER KSYQUE, DSN=SYS1.RESCUE.MAN1 TIME=\nIEE388I         13:14:13\n\nThe time in the second line is not a keyword so I thought how could it be\nprocessed? If the \"IF WORD\" supported a not option then I could test for\nword 01 not \"SMF\".  I chose \\WORD to reduce the extra coding needed.\n\nExample of my test member for IEE388I:-\n* IEE388I SMF NOW RECORDING ON VOLSER KSYQUE, DSN=SYS1.RESCUE.MAN1\n* IEE388I         hh:mm:ss\n\nIF WORD 01 SMF\nGET WORD 01\nWTO WORD 01 |%|\nENDGET\nGET WORD 02\nWTO WORD 02 |%|\nENDGET\nENDIF\nIF \\WORD 01 SMF\nWTO -WORD 01\nGET WORD 01\nWTO WORD \\01 |%|\nENDGET\nENDIF\n\nPJ5 Abend command to abend exit for testing.  I used this to debug what\nI added and to examine some of the exit fields.\n\nYou can use my name in the readme file.  I now plan to use your exit to\nreplace the version I was using from file 597 as appropriate.  I have\nupdated the latest version from the CBTTAPE.\n\nThanks for your example code regarding the name/token processing, I intend\nto try to use this in a RACF exit to pass back an error message.\n\nPlease keep me informed regarding any ongoing changes or new facilities.\n\nBest Regards\nPeter\n********************************************************************************\nMonday, September 26, 2005 8:06 PM\nKeep up the good work, Glenn.\n\nI've modified MPFLOAD, which I'm attaching (in XMI format).\n\nThe couple of changes were made to get the MPF table loaded as quickly as\npossible during IPL.  The changes are detailed in the comment block I've\nadded to your program.  If you like the idea, by all means, go ahead and\nincorporate it in your future versions.\n\nIf you have any questions on it, feel free to email me.\n\nAppreciate your comments.\nGarry G. Green\nLead Developer\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EPW0309I": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x05\\x12\\x0f\\x01\\x06\\x11?\\x17\\x01\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-04-30T00:00:00", "modifydate": "2006-04-23T17:01:18", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "*\nREPLY NN,YES\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ERB100I": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x002\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x01\\x00\\x03\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:01:32", "lines": 3, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "IF WORD 02 ZZ\nF RMF,START III\nENDIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EZAIN22I": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x01\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:01:41", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,C\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IAT3011": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x01\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:01:50", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,W\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IAT3012": {"ttr": 1814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x02\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:02:01", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,M=00\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IAT3100": {"ttr": 1816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x05\\x17\\x8f\\x01\\x06\\x11?\\x17\\x02\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2006-04-23T17:02:08", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "8S JSS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ICK003D": {"ttr": 1818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00U\\x01\\x035\\x9f\\x01\\x05\\x03\\x7f\\x13R\\x00\\x03\\x00\\x02\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2003-12-25T00:00:00", "modifydate": "2005-02-06T13:52:55", "lines": 3, "newlines": 2, "modlines": 0, "user": "GSI"}, "text": "*\nREPLY NN,U\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEE043I": {"ttr": 1820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x19\\x8f\\x00\\x95\\x19\\x8f\\x11X\\x00\\x02\\x00\\x02\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xd4\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-07-17T00:00:00", "modifydate": "1995-07-17T11:58:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "TECHMN"}, "text": "* Issued after a syslog has been written in response to a \"W L\"\nS LOGWTR.LWTR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEE112I": {"ttr": 1822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x14\\x01\\x06\\x11\\x9f\\x01\\x06\\x17_\\x16G\\x00\\r\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2006-04-29T00:00:00", "modifydate": "2006-06-24T16:47:14", "lines": 13, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "* IEE112I TEST FOR MULTI LINE MESSAGE\nSETSWITCH XYZZY\nIF SWITCH ON XYZZY\nIF ALL EQ PENDING OUTSTANDING MESSAGES REQUESTS\nIF SYSID EQ SSC\nGET WORD 07\nWTO %\nSE 'MULTI-LINE TEST SUCCESSFUL',USER=(GSI)\nENDGET\nENDIF\nENDIF\nENDIF SWITCH ON\nDELSWITCH XYZZY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEE362A": {"ttr": 1824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x05\\x05\\x1f\\x01\\x05\\x05\\x1f\\x19\\x07\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-20T00:00:00", "modifydate": "2005-02-20T19:07:59", "lines": 5, "newlines": 5, "modlines": 0, "user": "GSI"}, "text": "* Submits a job to dump SMF for the MAN dataset in the message\n* IEE362A SMF ENTER DUMP FOR SYS1.MAN2 ON SSCCAT\nGET WORD 05\nS SMFAUTO,SMFDSN='%'\nENDGET\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFTMS0": {"ttr": 1826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x05\\x17\\x8f\\x01\\x05\\x17\\x8f\\x15\\x03\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2005-06-27T15:03:53", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,U\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFTMS8": {"ttr": 1828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x05\\x17\\x8f\\x01\\x05\\x17\\x8f\\x15\\x04\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2005-06-27T15:04:08", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,HIGHDATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEF176I": {"ttr": 1830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x19\\x8f\\x00\\x95\\x19\\x8f\\x11Y\\x00\\x02\\x00\\x02\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xd4\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-07-17T00:00:00", "modifydate": "1995-07-17T11:59:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "TECHMN"}, "text": "* Issued when LOGWTR has finished copying a SYSLOG to BACKUP.SYSLOG\nP LWTR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEF238D": {"ttr": 1832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x045\\x8f\\x01\\x07\\x07\\x0f\\x151\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-12-23T00:00:00", "modifydate": "2007-03-11T15:31:27", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "IF ASTYPE EQ T\nREPLY NN,CANCEL\nENDIF ASTYPE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEF403I": {"ttr": 1834, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x06\\x08/\\x01\\x06\\x11\\x9f\\x077\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-03-23T00:00:00", "modifydate": "2006-04-29T07:37:46", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "NOSYSLOG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEF404I": {"ttr": 1836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x06\\x08/\\x01\\x06\\x11\\x9f\\x077\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-03-23T00:00:00", "modifydate": "2006-04-29T07:37:53", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "NOJOBLOG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEF450I": {"ttr": 1838, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x046\\x1f\\x01\\x046\\x1f\\x14$\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-26T00:00:00", "modifydate": "2004-12-26T14:24:47", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "HIGHLIGHT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IKT010D": {"ttr": 1840, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x045o\\x01\\x045o\"\\x10\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-21T00:00:00", "modifydate": "2004-12-21T22:10:44", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "*\nREPLY NN,FSTOP\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IKT012D": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x05\\x17\\x8f\\x01\\x05\\x17\\x8f\\x141\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2005-06-27T14:31:19", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,U\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IST020I": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x05\\x02\\x0f\\x01\\x05\\x02\\x0f\\x16@\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2005-01-20T16:40:52", "lines": 15, "newlines": 15, "modlines": 0, "user": "GSI"}, "text": "* START VPS TND OMEGAVTM FOR SYSTEM SSC\n*\nIF SYSID EQ SSC\nS VPS\nS TND\nS OMEGAVTM\nENDIF\n* START TND FOR SYSTEM SYSPGM\n*\nIF SYSID EQ SYSPGM\nS TND\nENDIF\n* START TSO FOR ALL SYSTEMS\nS TSO\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IST133I": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x05\\x17\\x8f\\x01\\x05\\x17\\x8f\\x141\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2005-06-27T14:31:34", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "S DR,M=STOPCOM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IST270I": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x950\\x0f\\x00\\x96\\x16o\\x08X\\x00\\r\\x00\\x06\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xd4\\xd5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-27T00:00:00", "modifydate": "1996-06-14T08:58:00", "lines": 13, "newlines": 6, "modlines": 0, "user": "TECHMN"}, "text": "*IST270I NCP loaded\n* Start HALNETs and HALKEYs.\nS HALKEYP\nS HALKEYM\nS HALKEYSR\nS HALKEYIX\nS HALKEYOP\n* Start VSE RJE links.\n$SLOGON1\n$SLNE(18-23)\n* Next two lines activate IBMLink\nV NET,ACT,ID=RSCG00D\nV NET,ACT,ID=QASA01\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IXC418I": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x05\\x03o\\x01\\x05\\x03o\"\\x06\\x00\\x05\\x00\\x05\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-05T00:00:00", "modifydate": "2005-02-05T22:06:58", "lines": 5, "newlines": 5, "modlines": 0, "user": "GSI"}, "text": "IF SYSID EQ SSC\nGET WORD 02\nRO SSC,SE '% HAS JOINED THE SYSPLEX',USER=(GSI)\nENDGET\nENDIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACROS": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00#\\x01\\x05\\x02\\x0f\\x01\\x07\\x06\\x9f\\x14F\\x16]\\x15\\xcd\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2007-03-10T14:46:23", "lines": 5725, "newlines": 5581, "modlines": 0, "user": "GSI"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MPFLOAD": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x005\\x01\\x06\\x08\\x7f\\x01\\x07\\x12/#\\x12\\x01\\x86\\x01\\x83\\x00\\x08\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2006-03-28T00:00:00", "modifydate": "2007-05-02T23:12:35", "lines": 390, "newlines": 387, "modlines": 8, "user": "GSI"}, "text": "MPFLOAD  CSECT\nMPFLOAD  AMODE 31\nMPFLOAD  RMODE 24\n         YREGS\n         BAKR  R14,0                   STORE REGS & ENVIR ON LINK STACK\n         LAE   R12,00(,R15)            R12 IS THE BASE\n         LA    R11,4095(,R12)          R11 = SECOND BASE REGISTER\n         LA    R11,1(,R11)             ADD 1 MORE\n         LA    R10,4095(,R11)          R10 = THIRD BASE REGISTER\n         LA    R10,1(,R10)             ADD 1 MORE\n         USING MPFLOAD,R12,R11,R10     ADDRESS IT\n         LA    R13,SAVEAREA            ADDRESS SAVEAREA\n         MVC   SAVEAREA+4,=C'F1SA'     INDICATE STACK IN USE\n         B     GETPARM                 BRANCH AROUND CONSTANTS\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFLOAD '          PROGRAM NAME IDENTIFIER\n         DC    C'Version 5.9 '       Version\n         DC    C'&SYSDATE '          ASSEMBLY DATE\n         DC    C'&SYSTIME '          ASSEMBLY TIME\n         DC    C'Copyright (c) 1998-2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n* GG01 -    Added code to check if executing in *MASTER* asid; if so,*\n*           get @ parm via S/S INITRTN method, otherwise get @ parm  *\n*           using the standard R1 @ parms at entry method;           *\n*           Added mapping macros: IHAPSA, IHAASCB, and IEFJSIPL      *\n*           (PSA to get @ to ASCB, ASCB to determine if we are in    *\n*           *MASTER* ASID, and IEFJSIPL to map S/S INITRTN parm list *\n*            Modification by Garry G. Green                          *\n* Changed MPF004I to MPF104I for Garry G. Green                      *\n**********************************************************************\n*      GET DSN FROM PARM                                             *\n**********************************************************************\nGETPARM  DS    0H\n         L     R15,PSAAOLD-PSA(0)      GET @ ASCB                  GG01\n         LH    R15,ASCBASID-ASCB(R15)  GET ASID                    GG01\n         CH    R15,=H'1'               Q. EXECUTING IN *MASTER*    GG01\n         BNE   NOTMAST                 A. NO - BRANCH              GG01\n         L     R2,4(R1)                GET @ JSIPL                 GG01\n         XR    R1,R1                   ZERO FOR FOLLOWING          GG01\n         IC    R1,JSILGTPR-JSIPL(R2)   GET @ S/S INITPARMS         GG01\n         L     R2,JSIADRPR-JSIPL(R2)   GET @ PARM DATA             GG01\n         SH    R2,=H'2'                MAKE CONSISTENT WITH        GG01\n*                                     STD PARM FIELD HWORD LEN HDR GG01\n         B     COMMON                  BRANCH TO COMMON PARM       GG01\nNOTMAST  DS    0H                     NOT EXECUTING AS SSI INITRTN GG01\n         L     R2,0(,R1)               GET PARM FIELD ADDR\n         LH    R1,0(,R2)               GET PARM LENGTH\nCOMMON   DS    0H                      COMMON PARM PROCESSING      GG01\n         LTR   R1,R1                   ANY PARM DATA?\n         BZ    BADPARM                 NO, SAY AND BYE\n         CH    R1,MAXPARM              VALID PARM LENGTH?\n         BNH   PARMOK                  YES\nBADPARM  WTO   'MPF001E - INVALID OR MISSING PARM ON EXEC STATEMENT',  X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     EOJ                     NO PARM, BYE\nPARMOK   BCTR  R1,0                    COMPUTE LENGTH CODE\n         EX    R1,PARMVC               PUT DSN\n**********************************************************************\n*      GET DSN FROM PARM                                             *\n**********************************************************************\n         LA    R6,HOLDMEM              SET R6 TO HOLDMEM\n         SR    R7,R7                   INTIALIZE COUNT FOR MEMBERS\n*********************************************************************\n*      DYNALLOC ROUTINE FOR DIRECTORY                               *\n*********************************************************************\n         ALLOC DDN=DDNAMED,                                            X\n               DSN=DSNAMEI,                                            X\n               DISP=SHR,                                               X\n               ERROR=S99FAIL\n**********************************************************************\n*      OPEN DIRECTORY                                                *\n**********************************************************************\nOPENS    OPEN  (PDS)                    OPEN FILES\n**********************************************************************\n*      READ DIRECTORY BLOCKS, EXTRACT DIRECTORY MEMBER NAMES AND     *\n*      WRITE TO THE HOLDMEM MAX OF 1000 MEMBERS                      *\n**********************************************************************\nREAD     EQU   *             *** READ DIRECTORY ENTRY ROUTINE ***\n         LH    R2,REMBYTS              GET NBR BYTES REMAINING IN BLOCK\n         CH    R2,ELEVEN               ANY MORE ENTRIES IN BLOCK\n         BNL   GETADR                  YES\nNEXREC   GET   PDS                     READ DIRECTORY BLOCK\n         LR    R2,R1                   GET BLOCK ADDRESS\n         MVC   REMBYTS,0(R2)           MOVE NBR BYTES IN BLOCK\n         CLC   REMBYTS,ZERO            ANY BYTES IN BLOCK\n         BE    ADDRS_R6                NO, GO ADDRESS R6\n         LA    R2,2(R2)                STEP PAST BLOCK SIZE FIELD\n         ST    R2,RECADDR              STORE RECORD ADDRESS\nGETADR   L     R2,RECADDR              GET NEXT ENTRY ADDRESS\n         CLI   0(R2),X'F9'             END OF DIRECTORY?\n         BH    ADDRS_R6                YES, GO ADDRESS R6\n         BAS   R9,MOVEHLD              GO MOVE MEMBER NAME TO HOLDMEM\n         NI    11(R2),CLRBITS          CLEAR ALIAS, TTR BITS\n         SR    R8,R8                   CLEAR WORK REG\n         IC    R8,11(R2)               GET NBR USER HALFWORDS\n         SLL   R8,1                    MULTIPLY BY 2\n         LA    R8,12(R8)               CALCULATE RECORD LENGTH\n         LH    R2,REMBYTS              GET NBR BYTES REMAINING\n         SR    R2,R8                   SUBTRACT THIS ENTRY LENGTH\n         BP    STREM                   ANY LEFT\n         SR    R2,R2                   NO, SET TO ZERO\nSTREM    STH   R2,REMBYTS              STORE REMAINING BYTES\n         A     R8,RECADDR              CALCULATE NEXT ENTRY ADDRESS\n         ST    R8,RECADDR              STORE NEXT ENTRY ADDRESS\n         B     OPENS                   GET NEXT DIRECTORY ENTRY\n*********************************************************************\n*      MOVEHLD MOVES MEMBER NAME TO THE HOLD AREA ADDRESSED BY R6   *\n*      FROM DIRECTORY ENTRY ADDRESSED BY R2                         *\n*********************************************************************\nMOVEHLD  EQU   *\n         MVC   0(8,R6),0(R2)           MOVE MEMBER NAME TO HOLDMEM\n         LA    R6,8(R6)                POINT TO NEXT HOLDMEM AREA\n         LA    R7,1(R7)                ADD 1 TO MEMBER COUNT\n         BR    R9                      GET NEXT DIR MEMBER\n*********************************************************************\n*      ADDRS_R6 POINTS R6 TO BEGINING OF HOLDMEM                    *\n*********************************************************************\nADDRS_R6 EQU   *\n         CLOSE (PDS)                   CLOSE DIRECTORY\n         FREE  DDN=DDNAMED             FREE PDS\n         LA    R6,HOLDMEM              SET R6 TO START OF HOLDMEM\n         SR    R2,R2                   CLEAR SECOND MEMBER COUNT\n         LR    R8,R7                   COPY COUNT TO R8\n         SLL   R8,13                   MULTIPLY MEMBER COUNT BY 8192\n*********************************************************************\n*      GETMAIN SUBPOOL 241 KEY 0 TO STORE MEMBER NAMES AND COMMANDS *\n*********************************************************************\nCREATE   EQU   *\n         MODESET MODE=SUP,KEY=ZERO     AUTHORIZE FOR GETMAIN IN ECSA\n         GETMAIN RU,LV=(R8),SP=241,LOC=ANY,KEY=0\n         ST    R1,ECSA_ADD             STORE ECSA ADDRESS IN TOKEN\n         ST    R8,ECSA_LEN             STORE LENGTH OF ECSA IN TOKEN\n         LR    R9,R1                   COPY ADDRESS OF GETMAIN TO R9\n*********************************************************************\n*      GET NEXT MEMBER                                              *\n*********************************************************************\nGETNXMEM EQU   *\n         LR    R4,R9               START OF RECORD\n         LA    R2,1(R2)            ADD 1 TO SECOND MEMBER COUNT\n         CR    R2,R7               COMPARE MEMBER COUNT\n         BH    CREATNT             GOT EM ALL, CREATE NAME/TOKEN\n         MVC   0(8,R4),0(R6)       MOVE MEMBER NAME TO ECSA\n*********************************************************************\n*      DYNALLOC SETUP                                               *\n*********************************************************************\nDYNALLOC MVC   MEMN,0(R6)          MEMBER NAME TO DYNALLOC TU\n         LA    R6,8(R6)            POINT TO NEXT HOLDMEM AREA\n         LA    R5,4092(R4)         POINT R5 END OF USABLE RECORD\n         LA    R5,4092(R5)         POINT R5 END OF USABLE RECORD\n         LA    R4,8(R4)        INCREMENT TABLE BY 8 FOR START OF CMDS\n*********************************************************************\n*      DYNALLOC ROUTINE FOR COMMAND MEMBERS                         *\n*********************************************************************\n         ALLOC DDN=DDNAMEI,                                            X\n               DSN=DSNAMEI,                                            X\n               MEMBER=MEMBERIN,                                        X\n               DISP=SHR,                                               X\n               ERROR=S99FAIL\n*********************************************************************\n*      OPEN COMMAND FILE                                            *\n*********************************************************************\n         LA    R3,CMDS                LOAD R3 ADDRESS OF CMDS\n         OPEN  ((R3),INPUT),MODE=24   OPEN\n         USING IHADCB,R3              USING\n         TM    DCBOFLGS,X'10'         TEST GOOD OPEN?\n         BZ    OPNFAIL                NO BYE\n         DROP  R3\n*********************************************************************\n*      GET COMMANDS AND STORE EM                                    *\n*********************************************************************\nGETCMDS  EQU   *\n         CNOP  0,4                 ALIGNMENT\n         GET   CMDS,CMDTEXT        DCB MOVES INPUT RECORD TO CMDTEXT\n         CLI   CMDTEXT,C'*'        SKIP COMMENTS\n         BE    GETCMDS             GET NEXT RECORD\n         CLI   CMDTEXT,C' '        SKIP BLANK COL 1\n         BE    BLANK1              WTO\n         CR    R4,R5               END OF RECORD\n         BNL   MORE102             YUP BYE\n         MVC   0(80,R4),CMDTEXT    MOVE CMD TO TABLE\n         LA    R4,80(R4)           INCREMENT TABLE BY 80\n         B     GETCMDS             GET NEXT RECORD\n*********************************************************************\nBLANK1   WTO   'MPF006E - BLANK IN COLUMN ONE NOT ALLOWED',            X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     GETCMDS             GET NEXT RECORD\n*********************************************************************\nMORE102  WTO   'MPF007E - MORE THEN 102 COMMANDS NOT ALLOWED',         X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n*********************************************************************\nCLSCMDS  EQU   *\n         MVI   0(R4),X'FF'         PUT END OF CMDS\n         LA    R9,4095(R9)         BUMP TABLE\n         LA    R9,1(R9)            BUMP TABLE 1 MORE\n         LA    R9,4095(R9)         BUMP TABLE TO NEXT RECORD\n         LA    R9,1(R9)            BUMP TABLE 1 MORE\n         LA    R3,CMDS             POINT R3 TO CMDS\n         CLOSE ((R3))              CLOSE CMDS\n*********************************************************************\nFREEDD   EQU   *\n         FREE  DDN=DDNAMEI\n*********************************************************************\nBGETNEW  EQU   *\n         B     GETNXMEM            GET NEXT MEMBER\n*********************************************************************\nOPNFAIL  WTO   'MPF017E - DYNAMIC ALLOCATION OPEN FAILED',             X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n         FREE  DDN=DDNAMEI\n         B     EOJ\n*********************************************************************\nS99FAIL  EQU   *\n         S99FAIL\nDYNFAIL  WTO   'MPF018E - DYNAMIC ALLOCATION FAILED',                  X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     EOJ\n*********************************************************************\n*      NAME TOKEN SECTION                                           *\n*      CHECK FOR EXISTING NT IF, FREE STORAGE AND DELETE NAME/TOKEN *\n*********************************************************************\nCREATNT  EQU   *\n         CALL  IEANTRT,(SYSLVL,NAME,TOKEN2,RETCODE)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF002I - NAME/TOKEN EXISTS DELETE N/T AND STORAGE'\n         L     R5,ECSA_AD2             STORE ECSA ADDRESS IN R5\n         L     R9,ECSA_LE2             STORE LENGTH OF ECSA IN R9\n         FREEMAIN RU,LV=(R9),A=(R5),SP=241,KEY=0\n         CALL  IEANTDL,(SYSLVL,NAME,RETCODE)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF003I - NAME/TOKEN AND STORAGE SUCCESSFULLY DELETED'\n         ENDIF\n         ENDIF\n*********************************************************************\n*      CREATE THE NAME/TOKEN PAIR                                   *\n*      CHECK RETCODE FROM NAME/TOKEN CREATE                         *\n*********************************************************************\n         CALL  IEANTCR,(SYSLVL,NAME,TOKEN,PERSOPT,RETCODE)\n         IF    (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF104I - NAME/TOKEN AND STORAGE SUCCESSFULLY CREATED'\n         WTO   'MPF004I - MPFXTALL Version 5.9'\n         MVC   WTONAME,NAME                MOVE TOKEN TO DISPLAY\n         HEX   WTONTADD,4,ECSA_ADD         MOVE ADDRESS TO DISPLAY\n         HEX   WTONTLEN,4,ECSA_LEN         MOVE LENGTH TO DISPLAY\n         WTO   MF=(E,WTOA)                 WTO TOKEN NAME\n         WTO   MF=(E,WTOB)                 WTO ADDRESS NAME\n         WTO   MF=(E,WTOC)                 WTO LENGTH NAME\n         ENDIF\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF005E - NAME/TOKEN ERROR NAME/TOKEN NOT FOUND',      X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - NOTIFY SYSTEMS PROGRAMMER',                  X\n               DESC=(2),ROUTCDE=(1)\n         ENDIF\n*********************************************************************\n*      END OF JOB                                                   *\n*********************************************************************\nEOJ      EQU *\n         MODESET MODE=PROB,KEY=NZERO\n         PR                            POP THE STACK\n*********************************************************************\nPARMVC   MVC   DSNN(1),2(R2)           EXECUTED MOVE DSNAME\n*********************************************************************\n*      HEX CONVERT ROUTINE                                          *\n*********************************************************************\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\n*\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\nSAVER4B  DS    F                REGISTER SAVE FOR HEX ROUTINE\nHEXSAVE  DS    3F               SAVE FOR HEX MACRO\n*********************************************************************\n*      DATA AREAS FOR DIRECTORY READ                                *\n*********************************************************************\nREMBYTS  DC    H'0'                    BYTES REMAINING IN BLOCK\nELEVEN   DC    H'11'                   CONSTANT 11\nZERO     DC    H'0'                    CONSTANT ZERO\nRECADDR  DS    A                       BLOCK ADDRESS\nCLRBITS  EQU   X'1F'                   AND MASK\nHOLDMEM  DS    1000CL8                 DATA AREA FOR MEMBER NAMES\n*********************************************************************\n*      DATA AREAS FOR DYNAMIC ALLOCATION                            *\n*********************************************************************\n         CNOP  0,4\nDSNAMEI  DC    A(DSNN)                   ADDRESS FOR DSNN\nDSNL     DC    Y(44)                     LENGTH OF DSNN\nDSNN     DC    CL44' '                   DSNAME\n*\n         CNOP  0,4\nDDNAMEI  DC    A(DDNN)                   ADDRESS FOR DDNN\nDDNL     DC    Y(8)                      LENGTH OF DDNN\nDDNN     DC    C'MPFLOADC'               DDNAME\n*\n         CNOP  0,4\nMEMBERIN DC    A(MEMN)                   ADDRESS OF MEMN\nMEML     DC    Y(8)                      LENGTH OF MEMN\nMEMN     DC    CL8'        '             MEMBER NAME\n*\n         CNOP  0,4\nDDNAMED  DC    A(DDNNDL)                 ADDRESS FOR DDNNDL\nDDNDL    DC    Y(8)                      LENGTH OF DDNNDL\nDDNNDL   DC    C'MPFLOADP'               DDNAME\n*\nCMDTEXT  DS    CL80\n*\n         DYNSPACE\n*********************************************************************\n*        DATA AREAS FOR NAME TOKEN                                  *\n*********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'      THE NAME OF THE TOKEN\n         DS    0D\nTOKEN    DC    XL16'00'                  THE TOKEN\n         ORG   TOKEN\nECSA_ADD DS    F                         ECSA ADDR\nECSA_LEN DS    F                         LENGTH OF ECSA\n         ORG\nTOKEN2   DC    XL16'00'                  THE TOKEN2\n         ORG   TOKEN2\nECSA_AD2 DS    F                         ECSA ADDR\nECSA_LE2 DS    F                         LENGTH OF ECSA\n         ORG\nRETCODE  DC    F'0'\nPERSOPT  DC    A(IEANT_PERSIST)       KEEP THE TOKEN AFTER JOB ENDS\n*********************************************************************\n*        DATA AREAS FOR WTO                                         *\n*********************************************************************\nWTOA     DC    AL2(WTOAE-WTOA),AL2(0)\n         DC    C'MPF009I -     NAME:    '\nWTONAME  DS    CL16\nWTOAE    DS    0F\n*\nWTOB     DC    AL2(WTOBE-WTOB),AL2(0)\n         DC    C'MPF010I -     ADDRESS: '\nWTONTADD DS    XL8\nWTOBE    DS    0F\n*\nWTOC     DC    AL2(WTOCE-WTOC),AL2(0)\n         DC    C'MPF011I -     LENGTH:  '\nWTONTLEN DS    XL8\nWTOCE    EQU   *\n         DS    0F\n*********************************************************************\nSAVEAREA DS    18F                     SAVEAREA\n*********************************************************************\n*        DATA AREAS                                                 *\n*********************************************************************\nMAXPARM  DC    H'44'            MAXIMUM PARM LENGTH\n*********************************************************************\n*        FILE DEFINITIONS                                           *\n*********************************************************************\nPDS      DCB   DSORG=PS,MACRF=GL,DDNAME=MPFLOADP,RECFM=F,              X\n               LRECL=256,BLKSIZE=256,EODAD=ADDRS_R6\n*********************************************************************\nCMDS     DCB   DSORG=PS,DDNAME=MPFLOADC,EODAD=CLSCMDS,MACRF=(GM)\n*********************************************************************\n         EJECT\n         PRINT   ON,NOGEN\n         DCBD  DSORG=(QS),DEVD=DA\n*********************************************************************\n         IHAPSA   ,              MAP PSA                           GG01\n         IHAASCB  ,              MAP ASCB                          GG01\n         IEFJSIPL ,              MAP INPUT PLIST                   GG01\n         IEANTASM                NAME TOKEN SERVICE ASSEMBLER DECLARES\n         IEFZB4D0                SVC99 DSECTS\n         IEFZB4D2                SVC99 DSECTS\n*********************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFLST00": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x10\\x01\\x05\\x02\\x0f\\x01\\x06%\\x0f\\x12T\\x00\\x16\\x00\\x08\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2006-09-07T12:54:10", "lines": 22, "newlines": 8, "modlines": 0, "user": "GSI"}, "text": "$HASP099,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n$HASP100,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n$HASP400,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n$HASP426,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n$HASP441,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\n$HASP612,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(YES)\nABC,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(NO)\nBPXF024I,RETAIN(NO),USEREXIT(MPFXTALL),AUTO(SUPPRESS)\nDCOMMMP1:*,USEREXIT(MPFXTALL),AUTO(SPILL),SUP(NO)\nICK003D,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nIEF238D,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nIEF450I,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL),AUTO(HIGHLITE)\nIKT010D,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nIST020I,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nSVT1P0001I,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nSVT1P0011A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nSVT1P0011B,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nSVT1P0011C,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nSVT1P0012A,SUP(NO),RETAIN(NO),USEREXIT(MPFXTALL)\nU11D-0450*,USEREXIT(MPFXTALL),AUTO(U11D4501),SUP(NO)\nIOEZ00542D,USEREXIT(MPFXTALL),AUTO(STOPZFS),SUP(NO)\nIGD17380I,SUP(NO),USEREXIT(MPFXTALL),AUTO(SMSSGMSG)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MPFXDSPL": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12 \\x9f\\x01\\x12 \\x9f\\x00)\\x02d\\x02d\\x00\\x00\\xc8\\xe4\\xe3\\xc3\\xc8\\xd5\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-27T00:00:00", "modifydate": "2012-07-27T00:29:00", "lines": 612, "newlines": 612, "modlines": 0, "user": "HUTCHNS"}, "text": "./ ADD NAME=$NOTE01  0102-12208-12208-1027-00018-00012-00000-SYTH\n$TMPLATE  SYS1.MPF.COMMANDS member which standardizes documention of\n          MPF message responses\n          COPY the $TMPLATE member to the new message response PDS\n          member and update the comment fields\n          $TMPLATE is not shown in the MPFXDSPL output\n\nEPW0309I  SYS1.MPF.COMMANDS member demonstrates use of $TMPLATE\n\nASMACL    Updated job to include assemble and link MPFXDSPL\n\nEXECUTE   Execution JCL for MPFXDSPL\n\nMPFXDSPL  Source code for MPF message response program that displays\n          contents of MPF ECSA Table  I've taken portions of the\n          existing MPF programs plus coding of a TIMEDATE routine to\n          create this.\n\nPRINT     Example of MPF table printout\n./ ADD NAME=$TMPLATE 0101-12208-12208-1240-00008-00008-00000-SYTH\n*\n* < message id >\n*\n* MPF EXIT code <explaination>\n*\n* Written: mm/dd/yyyy <programmer name>\n*\n* Replace with the executable commands and drop the * in this line\n./ ADD NAME=ASMACL   0100-12208-12208-0940-00122-00122-00000-SYTH\n//GSIASMCL JOB ,'SIEGEL',CLASS=A,MSGCLASS=X,REGION=0M,\n//         MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//*********************************************************************\n//*                                                                   *\n//*         CHANGES BEFORE SUBMITTING                                 *\n//*                                                                   *\n//* C ALL 'CBT.FILE708.PDS' 'THIS DATASET'                            *\n//* C ALL 'CBT.FILE708.MACROS' 'THE DATASET FROM STEP 6 OF $INSTALL'  *\n//* C ALL 'SYSP.LINKLIB' 'A DATASET IN THE LINKLIST'                  *\n//*                                                                   *\n//*********************************************************************\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(TSOROUTE)    <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,COND=(4,LT,C),\n//         PARM='XREF,LET,LIST,RENT,REUS,REFR'\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,1,1)),\n//             DSN=&&TSOROUTE(TSOROUTE)\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSIN    DD *\n  NAME TSOROUTE(R)\n/*\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(MPFXDSPL)     <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(4,LT,C)\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYSP.LINKLIB,DISP=SHR                 <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSIN    DD *\n  ENTRY MPFXDSPL\n  SETCODE AC(1)\n  INCLUDE SYSLIB(IEANTCR)\n  INCLUDE SYSLIB(IEANTRT)\n  INCLUDE SYSLIB(IEANTDL)\n  NAME MPFXDSPL(R)\n/*\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(MPFLOAD)     <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(4,LT,C)\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYSP.LINKLIB,DISP=SHR                 <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSIN    DD *\n  ENTRY MPFLOAD\n  SETCODE AC(1)\n  INCLUDE SYSLIB(IEANTCR)\n  INCLUDE SYSLIB(IEANTRT)\n  INCLUDE SYSLIB(IEANTDL)\n  NAME MPFLOAD(R)\n/*\n//C        EXEC PGM=ASMA90,\n//         PARM='LIST,OBJECT,NODECK'\n//SYSIN    DD DISP=SHR,DSN=CBT.FILE708.PDS(MPFXTALL)    <=== CHANGE\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=CBT.FILE708.MACROS,DISP=SHR           <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//            UNIT=SYSALLDA,DISP=(MOD,PASS),\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,COND=(4,LT,C),\n//         PARM='XREF,LET,LIST,RENT,REUS,REFR'\n//SYSLIN   DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYSP.LINKLIB,DISP=SHR                 <=== CHANGE\n//SYSUT1   DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//            UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.CSSLIB,DISP=SHR\n//         DD DSN=&&TSOROUTE,DISP=SHR\n//SYSIN    DD *\n  ENTRY MPFXTALL\n  SETCODE AC(1)\n  INCLUDE SYSLIB(IEANTRT)\n  INCLUDE SYSLIB(TSOROUTE)\n  NAME MPFXTALL(R)\n/*\n//\n./ ADD NAME=EPW0309I 0100-12208-12208-0947-00009-00009-00000-SYTH\n*\n* EPW0309I ENTER 'YES' TO CONTINUE TERMINATION. 'NO' TO KEEP FFST ALIVE\n*\n* MPF exit code to capture system halting of FFST component and\n* automatically reply to it\n*\n* Written: 03/01/2012 Thomas Hutchins\n*\nREPLY NN,YES\n./ ADD NAME=EXECUTE  0100-12208-12208-1019-00008-00008-00000-SYTH\n//MPFXDSPL JOB (ACCNT CODE),'PROGRAMMER NAME',CLASS=X,MSGCLASS=X,       JOB05374\n//         MSGLEVEL=(1,1),REGION=0M,NOTIFY=&SYSUID\n/*JOBPARM  LINES=9999,FORMS=STD\n//* ******************************************************************\n//STEP1   EXEC PGM=MPFXDSPL\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.AUTH.PDS.LOADLIB\n//SYSOUT   DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n./ ADD NAME=MPFXDSP$ 0108-01044-12209-0008-00031-00030-00000-SBGOLOB\n//SBGOLOBM JOB (CCMVS),'HI FOLKS',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.FILE708.MACROS\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(MPFXDSPL)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//CSSLIB   DD  DISP=SHR,DSN=SYS1.CSSLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n INCLUDE CSSLIB(IEANTRT)\n SETSSI  CB485875\n SETCODE AC(1)\n NAME    MPFXDSPL(R)\n/*\n./ ADD NAME=MPFXDSPL 0100-12208-12208-0942-00389-00389-00000-SYTH\nMPFXDSPL TITLE 'MPF code to display command table in ECSA'\nMPFXDSPL CSECT\nMPFXDSPL AMODE 31\nMPFXDSPL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXDSPL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXDSPL '       Program Name Identifier\n         DC    C'Version 6.0 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright(c) 1998 2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   TH   - Strip MPFXTALL for executable logic                       *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R             Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n*\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify MPFXDSPL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\n*        OPEN SYSOUT FOR REPORT                                      *\n**********************************************************************\n         GETMAIN R,LV=DCBSZ1       Get output dcb area\n         LR    R10,R1\n         MVC   0(DCBSZ1,R10),OUTFILE\n**********************************************************************\n*        GET STORAGE FOR OUTPUT RECORD                               *\n**********************************************************************\n         GETMAIN R,LV=133          Get output record area\n         LR    R9,R1\n         USING OUT_DSECT,R9\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n**********************************************************************\n*        OPEN FILE PUT OUT TITLE LINE                                *\n**********************************************************************\n         OPEN  (OUTFILE,OUTPUT)     Open output file\n\n* ********************************************************************\n* * TIMEDATE Routine found in GOOGLE GROUPS                          *\n* * bit.listserv.ibm-main                                            *\n* * TIME Macro (getting Date MM/DD)                                  *\n* * Original post by Franklin, Boe, Wednesday, October 7, 1998       *\n* ********************************************************************\n         MVC   TSZEROS,=CL4'0'\n         TIME  DEC,TIMEDATE,DATETYPE=MMDDYYYY,LINKAGE=SYSTEM\n         MVC   DTIME,EDPATIME\n         ED    DTIME(5),TIMEDATE\n         ED    DTIME+5(8),TIMEDATE+8\n         MVC   MNTH,MN\n         MVI   MNTHSEP,C'/'\n         MVC   DAY,DD\n         MVI   DAYSEP,C'/'\n         MVC   YEAR,YYYY\n\n         MVI   OUT_CC,C'1'         Set carriage control\n         MVC   OUT_DATA,OUT_HEADER Set header in output field\n         PUT   OUTFILE,OUT_REC\n\n         MVI   OUT_REC,C' '        Skip a line\n         MVC   OUT_REC+1(132),OUT_REC\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n\n**********************************************************************\n*        OUTPUT ECSA MPFLOAD INFORMATION                             *\n**********************************************************************\n\n         MVC   SAYNAME,NAME                MOVE TOKEN TO DISPLAY\n         HEX   SAYNTADD,4,ECSA_ADD         MOVE ADDRESS TO DISPLAY\n         HEX   SAYNTLEN,4,ECSA_LEN         MOVE LENGTH TO DISPLAY\n\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+8(L'NAMETOKN),NAMETOKN\n         MVC   OUT_REC+32(L'SAYNAME),SAYNAME\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n\n         MVC   OUT_REC+8(L'NAMEADDR),NAMEADDR\n         MVC   OUT_REC+32(L'SAYNTADD),SAYNTADD\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n\n         MVC   OUT_REC+8(L'NAMELENG),NAMELENG\n         MVC   OUT_REC+32(L'SAYNTLEN),SAYNTLEN\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n*\n*  HEX INFORMATION IN OUTPUT STREAM\n*\n\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of MPFLOAD data\n         BNL   FREEMEM             Yup bye\n         CLC   TEMPLATE,0(R4)\n         BNE   MPFXT050\n         LR    R6,R4               Point R6 to first record\n         LA    R4,4095(,R6)        Bump table past template record\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\nMPFXT050 DS    0H\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(8),0(R4) Move message command to output line\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n\n         B     MPFXT200            Go get commands\nTEMPLATE DC    C'$TMPLATE'\nMPFXT100 DS    0H\n         LA    R4,4095(,R6)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LR    R6,R4               Point R6 to first record\n         LA    R4,8(R4)            Point R4 to first command\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    MPFXT100            Yup bump to next message\n         CL    R4,ENDTABLE         End of MPFLOAD data\n         BNL   LOADERR             Yup say and bye\n\n         MVC   OUT_REC+12(80),0(R4)   Move command to SYSOUT\n         PUT   OUTFILE,OUT_REC\n         MVI   OUT_REC,C' '\n         MVC   OUT_REC+1(132),OUT_REC\n\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - Memory Load Error',DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nMPF008F  DS    0H\n         WTO   'MPF008E - Notify MPFXDSPL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM             Bye\n**********************************************************************\nMPF008R  DS    0H\n         WTO   'MPF008E - Notify MPFXDSPL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         CLOSE  (OUTFILE)\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R\n         EJECT\n**********************************************************************\n*        HEX ROUTINE                                                 *\n**********************************************************************\n\n*********************************************************************\n*      HEX CONVERT ROUTINE                                          *\n*********************************************************************\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\n*\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         ESTAEX 0                  Delete MPFXTALL ESTAE         GG59\n*\n*    Linkage back to caller:\n         LGHI 15,0                 Set return code\n         PR                        Pop the stack\n*\n         SPACE 1\n         LTORG ,\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\n*\nNAMETOKN DC    CL24'   MPFXDSPL NAME TOKEN: '\nNAMEADDR DC    CL24'         TABLE ADDRESS: '\nNAMELENG DC    CL24'          TABLE LENGTH: '\n*\nEDPATIME DC    X'402020202020202020202020202020'\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nOUTFILE  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,RECFM=FBA,LRECL=133,    X\n               BLKSIZE=1330\nDCBSZ1   EQU   *-OUTFILE\n\n         EJECT\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nOHEADER  DC CL132'DATE: 07/25/2012     CONTENTS OF ECSA LOAD'\n*\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nOUT_HEADER DS 0CL132\n           DS  CL6\nMNTH       DS  CL2\nMNTHSEP    DS  CL1\nDAY        DS  CL2\nDAYSEP     DS  CL1\nYEAR       DS  CL4\n           DS  CL116\n*\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\n*\nMEMN     DS    CL8                 Member name\n*\n*\nENDTABLE DS    F                   Address for end of table\n*\n*\nMSGTXT   DS    CL133               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\n         ORG\nSAVER4B  DS    F                REGISTER SAVE FOR HEX ROUTINE\nHEXSAVE  DS    3F               SAVE FOR HEX MACRO\nSAYNAME  DS    CL16\nSAYNTADD DS    XL8\nSAYNTLEN DS    XL8\nTIMEDATE DS    0CL16            TIME AND DATE RETURNED MMDDYYYY\nH        DS    CL1\nM        DS    CL1\nS        DS    CL1\n         DS    CL5\nMO       DS    CL1\nDA       DS    CL1\nYR       DS    CL2                 4 DIGIT YEAR\nTSZEROS  DS    CL4\n         DS    0H\nDTIME    DS    0CL13\n         DS    CL1\nHH       DS    CL2                 HOUR\nMM       DS    CL2                 MINUTES\nMN       DS    CL2                 MONTH\nDD       DS    CL2                 DAY\nYYYY     DS    CL4                 YEAR\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n*                                                                    *\n**********************************************************************\nOUT_DSECT  DSECT\nOUT_REC    DS    0CL133\nOUT_CC     DS    CL1\nOUT_DATA   DS    CL132\n         LTORG\n*        PRINT   GEN                                              GG58\n         PRINT   ON,NOGEN                                         GG58\n         IHAPSA  ,                 MAP PSA                        GG58\n         IHASDWA ,                 MAP SDWA                       GG59\n         IHAASCB ,                 MAP ASCB                       GG58\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXDSPL\n./ ADD NAME=PRINT    0100-12208-12208-1025-00019-00019-00000-SYTH\nDATE:  7/26/2012     CONTENTS OF ECSA LOAD\n\n          MPFXDSPL NAME TOKEN: MPF_EXIT_TABLE\n                TABLE ADDRESS: 0EFA9000\n                 TABLE LENGTH: 00020000\n\nBPXF032D\n           REPLY NN,I\n\nBPXI078D\n           REPLY NN,Y\n\nCAS9227A\n           REPLY NN,Y\n\nCA7574\n           IF WORD 01 EQ (CA7ICOM\n           GET REPLYID\n           DELSWITCH CAICOM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTALL": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00Y\\x01\\x07\\x19\\x9f\\x01\\x07\\x19\\x9f\\x18\\x00\\x08\\x07\\x08\\x07\\x00\\x10\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2007-07-18T00:00:00", "modifydate": "2007-07-18T18:00:59", "lines": 2055, "newlines": 2055, "modlines": 16, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.9 '    Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright(c) 1998 2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite added all logic IF's etc               *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n*   GS56  - IF MSGID NE by Glenn Siegel                              *\n*         - IF MSGNE+ xx FOR xx by Glenn Siegel                      *\n*                                                                    *\n*   GS57  - No display /* MPFXTALL */                                *\n*         - AUTO(NODISPLY)      by Glenn Siegel                      *\n*                                                                    *\n*   DT03  - Four digit replies                                       *\n*         - REPLY NNNN,         by Dean Tesar                        *\n*                                                                    *\n*   GS58  - You want colors I'll give you colors                     *\n*                                                                    *\n*   GG58  - Added support for IF ASTYPE EQ J or T or S; added support*\n*           for TSOROUTE/TSOROUTE REPLY/TSOROUTE SUPPRESS including  *\n*           subroutine TSOROUTE by Garry Green                       *\n*                                                                    *\n*   GG59  - Added ESTAEX to prevent MPFXTALL from becoming           *\n*           deactivated should it abend by Garry Green               *\n*                                                                    *\n*   DT04  - Set AUTO NO setting by Dean Tesar                        *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R             Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         ESTAEX ESTAERC,           Specify abend recovery routine GG59 *\n               MF=(E,ESTAELST)     (Cont'd)                       GG59\n*DC X'00' *** Force abend *** Glenn for testing only pls remove   GG59\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\nCASE     LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    MOVEMEM             Yes move in member name        GS57\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify MPFXTALL Support',               PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n*\n*        LA    R9,RETURN                                          GS60\n*        CLC   CMDTEXT(8),=C'DISPLAY '  Change color/highlighting GS60\n*        BE    DISPLAY                    Yup go do it            GS60\n*\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     MPF008R             Return                         PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify MPFXTALL Support or S MPFLOAD',       X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGIDN,X'40'      Blank out MSGID check          GS56\n         MVI   MSGIDNE,X'40'       Blank out MSGID check          GS56\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFMSGPLN,X'40'      Blank out MSGID PLUS check     GS56\n         MVI   MSGPLNE,X'40'       Blank out MSGID PLUS check     GS56\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   IFASTYP,X'40'       Blank out IFASTYP check        GG58\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\nGOCHECK  DS    0H\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         BL    ERRORIFL                   Muck go IFLOGIC error   GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKASTYP  DS    0H                                                  GG58\n         CLC   CMDTEXT(12),=C'ENDIF ASTYPE'  End of if in CMDS     GG58\n         BNE   CKNASTYP                   No continue              GG58\n         MVI   IFASTYP,X'40'              Blank out ASTYP check    GG58\n         SP    GOCNTR,=P'4'               Reduce GOCNTR            GG58\n         BR    R9                         Return                   GG58\n         SPACE ,                                                   GG58\nCKNASTYP DS    0H                                                  GG58\n         CLI   IFASTYP,C'N'               Is SYSID EQ N            GG58\n         BER   R9                         Yup return               GG58\n         B     CONT_TYP                   Continue type check      GG58\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGPN                   No continue type check  GS56\n         MVI   IFMSGPLN,X'40'            Blank out IFMSGPLN check GS56\n         MVI   MSGPLNE,X'40'              Blank out MSGPLNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGPN DS    0H                                                 GS56\n         CLI   IFMSGPLN,C'N'              If IFMSGPL EQ N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKMSGIDN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGIN                   No continue type check  GS56\n         MVI   IFMSGIDN,X'40'            Blank out IFMSGIDN check GS56\n         MVI   MSGIDNE,X'40'              Blank out MSGIDNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGIN DS    0H                                                 GS56\n         CLI   IFMSGIDN,C'N'              If IFMSGID NE N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'TSOROUTE '   Is it a TSOROUTE cmd    GG58\n         BE    TSOROUTE                   Yup go do it            GG58\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(11),=C'REPLY NNNN,' Is it a WTOR command   DT57\n         BE    MPFWTORX                   Yup go reply to WTOR    DT57\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(8),=C'DISPLAY '   Change color/highlighting GS58\n         BE    DISPLAY                    Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(10),=C'SETAUTONO '  Set AUTO NO            DT04\n         BE    SETAUTON                   Yup go do it            DT04\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP1            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP1 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(10),=C'ASTYPE EQ '  ASTYPE check         GG58\n         BE    ASTYPCHK                      Yup go check ASTYPE  GG58\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID NE '    Parse check MSGID NE GS56\n         BE    MSGIDRNE                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(6),=C'MSGNE+'    Parse check MSGNE PLUS  GS56\n         BE    MSGIDPLN                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nDISPLAY  DS    0H                                                 GS58\n         CLC   CMDTEXT+8(4),=C'BLUE'        make it blue ?        GS58\n         BE    SETBLUE                      call blue routine     GS58\n         CLC   CMDTEXT+8(4),=C'PINK'        make it pink ?        GS58\n         BE    SETPINK                      call pink routine     GS58\n         CLC   CMDTEXT+8(3),=C'RED'         make it red ?         GS58\n         BE    SETRED                       call red routine      GS58\n         CLC   CMDTEXT+8(5),=C'GREEN'       make it green ?       GS58\n         BE    SETGREE                      call green routine    GS58\n         CLC   CMDTEXT+8(9),=C'TURQUOISE'   make it turquoise     GS58\n         BE    SETTURQ                    call turquoise routine  GS58\n         CLC   CMDTEXT+8(6),=C'YELLOW'      make it yellow ?      GS58\n         BE    SETYELO                      call yellow routine   GS58\n         CLC   CMDTEXT+8(5),=C'WHITE'       make it white ?       GS58\n         BE    SETWHIT                      call white routine    GS58\n         CLC   CMDTEXT+8(5),=C'BLINK'       make it blink ?       GS58\n         BE    SETBLNK                      call blink routine    GS58\n         CLC   CMDTEXT+8(7),=C'REVERSE' make it reverse video ?   GS58\n         BE    SETREVD                 call reverse video routine GS58\n         CLC   CMDTEXT+8(9),=C'UNDERLINE'   make it underlined ?  GS58\n         BE    SETUNDR                   call underlined routine  GS58\n         BR    R9                            Return               GS58\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nSETBLNK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTBLNK        Set to blinking           GS58\n         BR    R9                       Return                    GS58\nSETREVD  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTREVD        Set to reverse video      GS58\n         BR    R9                       Return                    GS58\nSETUNDR  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTUNDR        Set to underline          GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        CHANGE COLORS                                               *\n**********************************************************************\nSETBLUE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTBLUE        Set to blue               GS58\n         BR    R9                       Return                    GS58\nSETRED   DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTRED         Set to red                GS58\n         BR    R9                       Return                    GS58\nSETPINK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTPINK        Set to pink               GS58\n         BR    R9                       Return                    GS58\nSETGREE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTGREE        Set to green              GS58\n         BR    R9                       Return                    GS58\nSETTURQ  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTTURQ        Set to turquoise          GS58\n         BR    R9                       Return                    GS58\nSETYELO  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTYELO        Set to yellow             GS58\n         BR    R9                       Return                    GS58\nSETWHIT  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTWHIT        Set to white              GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 DT53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         DT53\n         SPACE ,\n**********************************************************************\n*        SET AUTO NO                                                 *\n**********************************************************************\nSETAUTON DS    0H                                                 DT04\n         NI    CTXTRFB3,CTXTRAYS   Set automation no              DT04\n         BR    R9                  Return                         DT04\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFASTYP,C'N'        Is ASTYP eq N                  GG58\n         BER   R6                  Yes set it and forget it       GG58\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGIDN,C'N'       Is IFMSGID NE eq N             GS56\n         BER   R6                  Yes set it and forget it       GS56\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPLN,C'N'       Is IFMSGPL eq N                GS56\n         BER   R6                  Yes set it and forget it       GS56\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF ASTYPE LOGIC                                         GG58*\n**********************************************************************\nASTYPCHK DS    0H                                                  GG58\n         LA    R8,CKASTYP                 Load address CKASTYP     GG58\n         LA    R2,ASTYP                   Load address ASTYP       GG58\n         LA    R6,ASTYPNO                 Load address ASTYPNO     GG58\n         B     MOVEGO                     Go check for no's        GG58\n*                                         and store GOTABLE addr   GG58\nASTYP    DS    0H                         Check if ASTYP match     GG58\n         L     R3,PSAAOLD-PSA(,0)         GET @ ASCB               GG58\n         L     R1,ASCBTSB-ASCB(,R3)       GET @ TSB                GG58\n         L     R3,ASCBJBNI-ASCB(,R3)      GET @ INITIATED JOB NAME GG58\n         MVI   IFASTYP,C'Y'               SET ASTYPE SATISFIED ON  GG58\n         CLI   CMDTEXT+13,C'T'            Q. IF ASTYPE EQ T        GG58\n         BE    CHKTSO                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'S'            Q. IF ASTYPE EQ S        GG58\n         BE    CHKSTC                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'J'            Q. IF ASTYPE EQ J        GG58\n         BE    CHKJOB                     A. YES - BRANCH          GG58\n         B     NOTASTYP                   Value invaid             GG58\nCHKTSO   DS    0H                         IF ASTYPE EQ T SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKJOB   DS    0H                         IF ASTYPE EQ J SPECIFIED GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKSTC   DS    0H                         IF ASTYPE EQ S SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         BR    R9                         RETURN SATISFIED         GG58\nCHKSTCNO DS    0H                         NOT AN STC               GG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\n*                                                                  GG58\nASTYPNO  DS    0H                         Set not satisfied switch GG58\n         MVI   IFASTYP,C'N'               Set switch to N          GG58\n         BR    R9                         Return                   GG58\n***********************************************************************\n*        TSOROUTE LOGIC                                           GG58*\n***********************************************************************\nTSOROUTE DS    0H                         SET UP TSOROUTE PARMS    GG58\n*                                         R10 ALREADY @ CTXT       GG58\n         ST    R10,@CTXT                  STORE @ CTXT TO PARM 1   GG58\n         LA    R1,CMDTEXT                 @ MPFXTALL COMMAND       GG58\n         ST    R1,@CMD                    STORE @ CMD  TO PARM 2   GG58\n         LA    R1,TSORPLST                @ TSOROUTE PLIST         GG58\n         L     R15,=V(TSOROUTE)           GET @ TSOROUTE SUBRTN    GG58\n         BASSM R14,R15                    CALL IT                  GG58\n         BR    R9                         RETURN                   GG58\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST1    SRST  R1,R7               Scan message for next space     GG58\n         BO    SRST1               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FGETWRD             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         LA    R1,0(R8,R7)         @ Past end of string            GG58\n         L     R0,SCANX6C          Load scan delim %               GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST2    SRST  R1,R7               SEARCH STRING FOR DELIM %       GG58\n         BO    SRST2               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FNDATPER            FOUND A % BRANCH                GG58\n         LA    R7,CMDTEXT          Start of CMDTEXT                GG58\n         LA    R8,L'CMDTEXT        Length of CMDTEXT               GG58\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX50          LOAD SCAN DELIM    &            GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST3    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST3               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAT             FOUND AN AMPERSAND              GG58\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GOCHECK             Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX5C          LOAD SCAN DELIM *               GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST4    SRST  R1,R7               SEARCH STRING FOR DELIM *       GG58\n         BO    SRST4               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAST            * FOUND - BRANCH                GS59\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM blank           GS59\nSRST5    SRST  R1,R7               SEARCH STRING FOR DELIM Blank   GG58\n         BO    SRST5               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FWRDSPC             Blank FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDAST DS    0H\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST6    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST6               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSWR             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLN DS    0H                                                 GS56\n         MVI   MSGPLNE,C'Y'        Set MSGPLNE to Y               GS56\n         LA    R8,CKPMSGPN         Load address CKPMSGPN          GS56\n         LA    R2,MSGPLUS          Load address of                GS56\n         LA    R6,MSGIDPNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL              no must be IFMSGPL            GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL  DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set IFMSGPL to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL2             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'Y'       Set IFMSGPLN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL2 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL3             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL3 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST7    SRST  R1,R7               SEARCH STRING FOR DELIM blank   GG58\n         BO    SRST7               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FCMDSPC             BLANK FOUND - BRANCH            GG58\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST8    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST8               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSPC             BLANK FOUND - BRANCH            GG58\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDRNE DS    0H\n         MVI   MSGIDNE,C'Y'        Set MSGIDNE to Y               GS56\n         LA    R8,CKMSGIDN         Load address CKMSGIDN          GS56\n         LA    R2,MSGBEGIN         Load address of                GS56\n         LA    R6,MSGBEGNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID              no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID  DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set IFMSGID to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST9    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST9               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGID              BLANK FOUND - BRANCH            GG58\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         LA    R15,CMDTEXT+12      Point to characters\n         LA    R2,MSGTXT           Point to characters\n         BCTR  R3,0                Decrement length for execute\n         EX    R3,COMP             Compare\n         BNE   NOMATCH             No seeya\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID2             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID2 DS    0H                                                 GS56\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NOMTCHID             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'Y'       Set IFMSGIDN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNOMTCHID DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         B     MPF008R9            Return                         GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP2            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP2 DS    0H\n         BR    R9                         Return\nMPFWTORX DS    0H                                                 DT03\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR          DT03\n         BNO   NOTWTOR                    No you messed up        DT03\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area     DT03\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    MOVE IN REPLY       DT03\n         MVC   MGCRTEXT+6(4),=C'    '     CLEAR NNNN              DT03\n         LH    R3,CTXTRPYL                LOAD LENGTH OF REPLY    DT03\n         BCTR  R3,0                       DECREMENT FOR MOVE      DT03\n         CH    R3,=H'2'                   WHAT LENGTH to move?    DT03\n         BE    MRPID3                     =2 MOVE 3               DT03\n         BH    MRPID4                     >2 MOVE 4               DT03\n         EX    R3,MOVERI2                 MOVE 2                  DT03\n         B     MPFW00                                             DT03\nMRPID4   EX    R3,MOVERI4                 MOVE 4                  DT03\n         B     MPFW00                                             DT03\nMRPID3   EX    R3,MOVERI3                 MOVE 3                  DT03\nMPFW00   DS    0H                                                 DT03\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address    DT03\n         STC   R3,MGCRLGTH             Set the length of the rep  DT03\n         XR    R0,R0                   Clear R0 for MGCR/SVC 34   DT03\n         MGCR  MGCRPL                     Reply to WTOR           DT03\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP3            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7                      DT03\nAFTDISP3 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nMPF008R  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\n**********************************************************************\nMPF008F  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM             Bye\n**********************************************************************\nMPF008R9 DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message not a WTPR - reply not issued',DESC=2X\n               ,ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         B     MPF008R9                                           GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nNOTASTYP DS    0H                                                 GG58\n         WTO   'MPF062E - IF ASTYPE EQ value invalid',            GG58 X\n               DESC=(2),ROUTCDE=(1)                               GG58\n         B     MPF008R9                                           GG58\n         SPACE ,                                                  GG58\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF037E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         B     MPF008R9                                           GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R\n         EJECT\n**********************************************************************\n*        ESTAE RECOVERY ROUTINE                                  GG59*\n**********************************************************************\n\nESTAERC  DS    0H                  ESTAE RECOVERY ROUTINE        GG59\n         PUSH  USING               SAVE MAINLINE USING STATE     GG59\n         DROP  R11,R12             DON'T USE MAINLINE USING      GG59\n         LR    R12,R15             COPY ESTAE REC RTN EPA TO BASEGG59\n         USING ESTAERC,R12         MAP CODE PAGE FOR ESTAE RECRTNGG59\n         C     R0,=F'12'           Q. SDWA EXIST                 GG59\n         BE    NOSDWA              A. BATMAN - THIS IS SERIOUS   GG59\n         LR    R2,R1               COPY @ SDWA                   GG59\n         USING SDWA,R2             MAP SDWA                      GG59\n         SETRP RETADDR=WTOABEND,   PREPARE TO RETURN FROM ESTAE  GG59  *\n               DUMP=NO,            RECOVERY RTN - NO DUMP REQ'D  GG59  *\n               RC=4,               WE WILL RETRY                 GG59  *\n               FRESDWA=YES,        WE WILL FREE THE SDWA STORAGE GG59  *\n               WKAREA=(R2),        SDWA @ BY R2                  GG59  *\n               RECORD=YES,         RECORD ERROR TO LOGREC        GG59  *\n               RETREGS=YES         RESTORE REGISTERS AT ENTRY TO GG59\n*                                  RETRY ROUTINE                 GG59\n         BR    R14                 RETURN FROM ESTAE RECOVERY RTNGG59\n\nNOSDWA   DS    0H                  NO SDWA - THIS IS BAD BATMAN  GG59\n         LA    R15,4               REQUEST RETRY (HOLY DREAMING) GG59\n         LA    R0,WTOABEND         SPECIFY ADDRESS OF RETRY RTN  GG59\n         BR    R14                 RETURN FROM ESTAE RECOVERY RTNGG59\n         POP   USING               RESTORE MAINLINE USING ENVIR. GG59\n\n**********************************************************************\n*        ESTAE RETRY ROUTINE                                     GG59*\n**********************************************************************\n\nWTOABEND DS    0H                  ESTAE RETRY ROUTINE           GG59\n         WTO   'MPF038E MPFXTALL ABENDED; ABEND WAS SUPPRESSED', GG59  *\n               ROUTCDE=1,          MPF0 WTO's are not allowed to GG59  *\n               DESC=2              be captured - this WTO must   GG59\n*                                  NOT be captured by MPFXTALL   GG59\n         B     FREEMEM             GOTO FREE MEMORY AND RETURN   GG59\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         ESTAEX 0                  Delete MPFXTALL ESTAE         GG59\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMOVERI2  MVC   MGCRTEXT+8(0),CTXTRPYI                             DT03\nMOVERI3  MVC   MGCRTEXT+7(0),CTXTRPYI                             DT03\nMOVERI4  MVC   MGCRTEXT+6(0),CTXTRPYI                             DT03\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\nSCANX40  DC    A(C' ')                                             GG58\nSCANX50  DC    A(C'&&')                                            GG58\nSCANX5C  DC    A(C'*')                                             GG58\nSCANX6C  DC    A(C'%')                                             GG58\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO0ST    DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\nGOATH    DS    F                                                 GS52\nGOBTH    DS    F                                                 GS52\nGOCTH    DS    F                                                 GS52\nGODTH    DS    F                                                 GS52\nGOETH    DS    F                                                 GS52\nGOFTH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFASTYP  DS    CL1                 ADDRESS SPACE check            GG58\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGIDN DS    CL1                 IF MSGID NE check              GS56\n*\nMSGIDNE  DS    CL1                 IF MSGID NE switch             GS56\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFMSGPLN DS    CL1                 IF MSGID NE PLUS check         GS56\n*\nMSGPLNE  DS    CL1                 IF MSGID PLUS NE switch        GS56\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\nTSORPLST DS    0F                  TSOROUTE PARAMETER LIST         GG58\n@CTXT    DS    F                     PARM 1 - @ CTXT               GG58\n@CMD     DS    F                     PARM 2 - @ MPFXTALL COMMAND   GG58\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\nESTAELST ESTAEX ,MF=L             ESTAE MF=L                       GG59\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT ,                                                  PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n*        PRINT   GEN                                              GG58\n         PRINT   ON,NOGEN                                         GG58\n         IHAPSA  ,                 MAP PSA                        GG58\n         IHASDWA ,                 MAP SDWA                       GG59\n         IHAASCB ,                 MAP ASCB                       GG58\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTAL5": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x08\\x01\\x06\\x14_\\x01\\x06\\x17_\\x11\\x02\\x06\\xc6\\x06\\xc4\\x00\\x11\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2006-05-25T00:00:00", "modifydate": "2006-06-24T11:02:08", "lines": 1734, "newlines": 1732, "modlines": 17, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2006 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.5 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright (c) 1998-2006 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite all logic IF's etc                     *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\n         LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     RETURN                                             PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify Systems Programmer or S MPFLOAD',     X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         CP    GOCNTR,=P'0'               Is GOCNTR less then 0   GS52\n         BL    ERRORIFL                   Yup go IFLOGIC error    GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(5),=C'ENDIF'       End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(5),=C'ENDIF'       End of if in parse CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(5),=C'ENDIF'       End of message plus     GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(5),=C'ENDIF'       End of if in parse CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(5),=C'ENDIF'       End of if in parse CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 GS53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FGETWRD           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         SR    R2,R2               Clear R2                       GS54\n         LA    R2,8(R2)            Load R2 with 8                 GS54\n         ST    R2,EIGHT            Store R2 to EIGHT              GS54\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCNPERAT         Scan CMDTEXT for next % or &   GS54\n         BC    4,FNDATPER          Found a & or %                 GS54\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     CONT_TYP            Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         CL    R2,EIGHT            CC = 8 is it a &               GS54\n         BE    FOUNDAT             Go set GETID2 id to F          GS54\n*                                  else                           GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SR    R2,R2               Clear R2\n         LA    R2,8(R2)            Load R2 with 8\n         ST    R2,EIGHT            Store R2 to EIGHT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANAST          Scan CMDTEXT for next space or *\n         BC    4,FOUNDWR           Found a asterisk or a space\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDWR  DS    0H\n         CL    R2,EIGHT            CC = 8 is it a space\n         BE    FWRDSPC             Go set switch to S\n         DS    0H                  Else\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGSWR           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         MVI   IFMSGID,C'N'        Set IFPARSE to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FCMDSPC           Found a space\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for the next space\n         BC    4,FMSGSPC           4 go process this then more data\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         MVI   IFMSGID,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FMSGID            Found a space\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDCMD,C' '                       Initial\n         MVC   MSGIDCMD+1(L'MSGIDCMD-1),MSGIDCMD   Blank out\n         LA    R6,MSGIDCMD         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDCMD\n         LA    R7,MSGTXT           Start of message\n         LA    R8,L'MSGTXT         Length of message\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGTXT           Found a space\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGTXT  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDMSG,C' '                       Initial\n         MVC   MSGIDMSG+1(L'MSGIDMSG-1),MSGIDMSG   Blank out\n         LA    R6,MSGIDMSG         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDMSG\n         CLC   MSGIDMSG,MSGIDCMD   Compare MSGIDCMD to MSGIDMSG\n         BNE   NOMATCH             No seeya\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         WTO   'MPF008E - Notify Systems Programmer',             GS55 X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         BR    R9                          Return                 GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message is a WTO not a WTOR reply not issued'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         WTO   'MPF008E - Notify Systems Programmer',             GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         BR    R9                                                 GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF031E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         WTO   'MPF008E - Notify Systems Programmer',             GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         BR    R9                                                 GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\nSCANTRT  TRT  0(0,R7),DELIMTAB     Execute TRT\n**********************************************************************\nSCANAST  TRT  0(0,R7),ASTERTAB     Execute TRT\n**********************************************************************\nSCNPERAT TRT  0(0,R7),PERATTAB     Execute TRT\n**********************************************************************\n         EJECT\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR A BLANK AND RETURN A 04        *\n**********************************************************************\nDELIMTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'04000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR AND RETURN * = 04 BLANK = 08   *\n**********************************************************************\nASTERTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'08000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000004000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR % AND & RETURN A 04 = % 08 = & *\n**********************************************************************\nPERATTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'00000000000000000000000000000000' 40\n         DC    XL16'08000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000004000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n*\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nEIGHT    DS    F                   Return code 8\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nMSGIDMSG DS    CL25                MSGID from MSG\n*\nMSGIDCMD DS    CL25                MSGID from CMD\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT                                                    PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n         PRINT   GEN\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTAL6": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00(\\x01\\x06\\x17_\\x01\\x06\\x17_\\x16H\\x07+\\x06\\xf9\\x00I\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2006-06-24T00:00:00", "modifydate": "2006-06-24T16:48:28", "lines": 1835, "newlines": 1785, "modlines": 73, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2006 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.6 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright (c) 1998-2006 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite all logic IF's etc                     *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\n         LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     RETURN                                             PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify Systems Programmer or S MPFLOAD',     X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGIDN,X'40'      Blank out MSGID check          GS56\n         MVI   MSGIDNE,X'40'       Blank out MSGID check          GS56\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFMSGPLN,X'40'      Blank out MSGID PLUS check     GS56\n         MVI   MSGPLNE,X'40'       Blank out MSGID PLUS check     GS56\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\nGOCHECK  DS    0H\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         CP    GOCNTR,=P'0'               Is GOCNTR less then 0   GS52\n         BL    ERRORIFL                   Yup go IFLOGIC error    GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGPN                   No continue type check  GS56\n         MVI   IFMSGPLN,X'40'            Blank out IFMSGPLN check GS56\n         MVI   MSGPLNE,X'40'              Blank out MSGPLNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGPN DS    0H                                                 GS56\n         CLI   IFMSGPLN,C'N'              If IFMSGPL EQ N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKMSGIDN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGIN                   No continue type check  GS56\n         MVI   IFMSGIDN,X'40'            Blank out IFMSGIDN check GS56\n         MVI   MSGIDNE,X'40'              Blank out MSGIDNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGIN DS    0H                                                 GS56\n         CLI   IFMSGIDN,C'N'              If IFMSGID NE N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID NE '    Parse check MSGID NE GS56\n         BE    MSGIDRNE                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(6),=C'MSGNE+'    Parse check MSGNE PLUS  GS56\n         BE    MSGIDPLN                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 GS53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGIDN,C'N'       Is IFMSGID NE eq N             GS56\n         BER   R6                  Yes set it and forget it       GS56\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPLN,C'N'       Is IFMSGPL eq N                GS56\n         BER   R6                  Yes set it and forget it       GS56\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FGETWRD           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         SR    R2,R2               Clear R2                       GS54\n         LA    R2,8(R2)            Load R2 with 8                 GS54\n         ST    R2,EIGHT            Store R2 to EIGHT              GS54\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCNPERAT         Scan CMDTEXT for next % or &   GS54\n         BC    4,FNDATPER          Found a & or %                 GS54\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GOCHECK             Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         CL    R2,EIGHT            CC = 8 is it a &               GS54\n         BE    FOUNDAT             Go set GETID2 id to F          GS54\n*                                  else                           GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SR    R2,R2               Clear R2\n         LA    R2,8(R2)            Load R2 with 8\n         ST    R2,EIGHT            Store R2 to EIGHT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANAST          Scan CMDTEXT for next space or *\n         BC    4,FOUNDWR           Found a asterisk or a space\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDWR  DS    0H\n         CL    R2,EIGHT            CC = 8 is it a space\n         BE    FWRDSPC             Go set switch to S\n         DS    0H                  Else\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGSWR           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLN DS    0H                                                 GS56\n         MVI   MSGPLNE,C'Y'        Set MSGPLNE to Y               GS56\n         LA    R8,CKPMSGPN         Load address CKPMSGPN          GS56\n         LA    R2,MSGPLUS          Load address of                GS56\n         LA    R6,MSGIDPNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL              no must be IFMSGPL            GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL  DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set IFMSGPL to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL2             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'Y'       Set IFMSGPLN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL2 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL3             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL3 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FCMDSPC           Found a space\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for the next space\n         BC    4,FMSGSPC           4 go process this then more data\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDRNE DS    0H\n         MVI   MSGIDNE,C'Y'        Set MSGIDNE to Y               GS56\n         LA    R8,CKMSGIDN         Load address CKMSGIDN          GS56\n         LA    R2,MSGBEGIN         Load address of                GS56\n         LA    R6,MSGBEGNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID              no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID  DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set IFMSGID to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FMSGID            Found a space\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDCMD,C' '                       Initial\n         MVC   MSGIDCMD+1(L'MSGIDCMD-1),MSGIDCMD   Blank out\n         LA    R6,MSGIDCMD         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDCMD\n         LA    R7,MSGTXT           Start of message\n         LA    R8,L'MSGTXT         Length of message\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGTXT           Found a space\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGTXT  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDMSG,C' '                       Initial\n         MVC   MSGIDMSG+1(L'MSGIDMSG-1),MSGIDMSG   Blank out\n         LA    R6,MSGIDMSG         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDMSG\n         CLC   MSGIDMSG,MSGIDCMD   Compare MSGIDCMD to MSGIDMSG\n         BNE   NOMATCH             No seeya\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID2             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID2 DS    0H                                                 GS56\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NOMTCHID             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'Y'       Set IFMSGIDN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNOMTCHID DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         WTO   'MPF008E - Notify Systems Programmer',             GS55 X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         BR    R9                          Return                 GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message is a WTO not a WTOR reply not issued'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         WTO   'MPF008E - Notify Systems Programmer',             GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         BR    R9                                                 GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF037E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         WTO   'MPF008E - Notify Systems Programmer',             GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         BR    R9                                                 GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\nSCANTRT  TRT  0(0,R7),DELIMTAB     Execute TRT\n**********************************************************************\nSCANAST  TRT  0(0,R7),ASTERTAB     Execute TRT\n**********************************************************************\nSCNPERAT TRT  0(0,R7),PERATTAB     Execute TRT\n**********************************************************************\n         EJECT\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR A BLANK AND RETURN A 04        *\n**********************************************************************\nDELIMTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'04000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR AND RETURN * = 04 BLANK = 08   *\n**********************************************************************\nASTERTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'08000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000004000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR % AND & RETURN A 04 = % 08 = & *\n**********************************************************************\nPERATTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'00000000000000000000000000000000' 40\n         DC    XL16'08000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000004000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n*\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGIDN DS    CL1                 IF MSGID NE check              GS56\n*\nMSGIDNE  DS    CL1                 IF MSGID NE switch             GS56\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFMSGPLN DS    CL1                 IF MSGID NE PLUS check         GS56\n*\nMSGPLNE  DS    CL1                 IF MSGID PLUS NE switch        GS56\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nEIGHT    DS    F                   Return code 8\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nMSGIDMSG DS    CL25                MSGID from MSG\n*\nMSGIDCMD DS    CL25                MSGID from CMD\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT                                                    PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n         PRINT   GEN\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTAL7": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00F\\x01\\x07\\x03\\x0f\\x01\\x07\\x03\\x0f\\x13S\\x07]\\x073\\x00?\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2007-01-30T00:00:00", "modifydate": "2007-01-30T13:53:46", "lines": 1885, "newlines": 1843, "modlines": 63, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.7 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright (c) 1998-2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite added all logic IF's etc               *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n*   GS56  - IF MSGID NE by Glenn Siegel                              *\n*         - IF MSGNE+ xx FOR xx by Glenn Siegel                      *\n*                                                                    *\n*   GS57  - No display /* MPFXTALL */                                *\n*         - AUTO(NODISPLY)      by Glenn Siegel                      *\n*                                                                    *\n*   DT03  - Four digit replies                                       *\n*         - REPLY NNNN,         by Dean Tesar                        *\n*                                                                    *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\nCASE     LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    MOVEMEM             Yes move in member name        GS57\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         WTO   'MPF008E - Notify Systems Programmer',             PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     RETURN                                             PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify Systems Programmer or S MPFLOAD',     X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGIDN,X'40'      Blank out MSGID check          GS56\n         MVI   MSGIDNE,X'40'       Blank out MSGID check          GS56\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFMSGPLN,X'40'      Blank out MSGID PLUS check     GS56\n         MVI   MSGPLNE,X'40'       Blank out MSGID PLUS check     GS56\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\nGOCHECK  DS    0H\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         CP    GOCNTR,=P'0'               Is GOCNTR less then 0   GS52\n         BL    ERRORIFL                   Yup go IFLOGIC error    GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGPN                   No continue type check  GS56\n         MVI   IFMSGPLN,X'40'            Blank out IFMSGPLN check GS56\n         MVI   MSGPLNE,X'40'              Blank out MSGPLNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGPN DS    0H                                                 GS56\n         CLI   IFMSGPLN,C'N'              If IFMSGPL EQ N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKMSGIDN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGIN                   No continue type check  GS56\n         MVI   IFMSGIDN,X'40'            Blank out IFMSGIDN check GS56\n         MVI   MSGIDNE,X'40'              Blank out MSGIDNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGIN DS    0H                                                 GS56\n         CLI   IFMSGIDN,C'N'              If IFMSGID NE N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(11),=C'REPLY NNNN,' Is it a WTOR command   DT57\n         BE    MPFWTORX                   Yup go reply to WTOR    DT57\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP1            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP1 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID NE '    Parse check MSGID NE GS56\n         BE    MSGIDRNE                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(6),=C'MSGNE+'    Parse check MSGNE PLUS  GS56\n         BE    MSGIDPLN                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 GS53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGIDN,C'N'       Is IFMSGID NE eq N             GS56\n         BER   R6                  Yes set it and forget it       GS56\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPLN,C'N'       Is IFMSGPL eq N                GS56\n         BER   R6                  Yes set it and forget it       GS56\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FGETWRD           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         SR    R2,R2               Clear R2                       GS54\n         LA    R2,8(R2)            Load R2 with 8                 GS54\n         ST    R2,EIGHT            Store R2 to EIGHT              GS54\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCNPERAT         Scan CMDTEXT for next % or &   GS54\n         BC    4,FNDATPER          Found a & or %                 GS54\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GOCHECK             Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         CL    R2,EIGHT            CC = 8 is it a &               GS54\n         BE    FOUNDAT             Go set GETID2 id to F          GS54\n*                                  else                           GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SR    R2,R2               Clear R2\n         LA    R2,8(R2)            Load R2 with 8\n         ST    R2,EIGHT            Store R2 to EIGHT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANAST          Scan CMDTEXT for next space or *\n         BC    4,FOUNDWR           Found a asterisk or a space\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDWR  DS    0H\n         CL    R2,EIGHT            CC = 8 is it a space\n         BE    FWRDSPC             Go set switch to S\n         DS    0H                  Else\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGSWR           4 go process then more data\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLN DS    0H                                                 GS56\n         MVI   MSGPLNE,C'Y'        Set MSGPLNE to Y               GS56\n         LA    R8,CKPMSGPN         Load address CKPMSGPN          GS56\n         LA    R2,MSGPLUS          Load address of                GS56\n         LA    R6,MSGIDPNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL              no must be IFMSGPL            GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL  DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set IFMSGPL to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL2             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'Y'       Set IFMSGPLN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL2 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL3             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL3 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FCMDSPC           Found a space\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for the next space\n         BC    4,FMSGSPC           4 go process this then more data\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDRNE DS    0H\n         MVI   MSGIDNE,C'Y'        Set MSGIDNE to Y               GS56\n         LA    R8,CKMSGIDN         Load address CKMSGIDN          GS56\n         LA    R2,MSGBEGIN         Load address of                GS56\n         LA    R6,MSGBEGNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID              no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID  DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set IFMSGID to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan CMDTEXT for next space\n         BC    4,FMSGID            Found a space\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDCMD,C' '                       Initial\n         MVC   MSGIDCMD+1(L'MSGIDCMD-1),MSGIDCMD   Blank out\n         LA    R6,MSGIDCMD         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDCMD\n         LA    R7,MSGTXT           Start of message\n         LA    R8,L'MSGTXT         Length of message\n         BCTR  R8,0                Decrement length for execute\n         EX    R8,SCANTRT          Scan message for next space\n         BC    4,FMSGTXT           Found a space\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGTXT  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDMSG,C' '                       Initial\n         MVC   MSGIDMSG+1(L'MSGIDMSG-1),MSGIDMSG   Blank out\n         LA    R6,MSGIDMSG         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDMSG\n         CLC   MSGIDMSG,MSGIDCMD   Compare MSGIDCMD to MSGIDMSG\n         BNE   NOMATCH             No seeya\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID2             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID2 DS    0H                                                 GS56\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NOMTCHID             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'Y'       Set IFMSGIDN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNOMTCHID DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         WTO   'MPF008E - Notify Systems Programmer',             GS55 X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         BR    R9                          Return                 GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP2            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP2 DS    0H\n         BR    R9                         Return\nMPFWTORX DS    0H                                                 DT03\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR          DT03\n         BNO   NOTWTOR                    No you messed up        DT03\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area     DT03\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    MOVE IN REPLY       DT03\n         MVC   MGCRTEXT+6(4),=C'    '     CLEAR NNNN              DT03\n         LH    R3,CTXTRPYL                LOAD LENGTH OF REPLY    DT03\n         BCTR  R3,0                       DECREMENT FOR MOVE      DT03\n         CH    R3,=H'2'                   WHAT LENGTH to move?    DT03\n         BE    MRPID3                     =2 MOVE 3               DT03\n         BH    MRPID4                     >2 MOVE 4               DT03\n         EX    R3,MOVERI2                 MOVE 2                  DT03\n         B     MPFW00                                             DT03\nMRPID4   EX    R3,MOVERI4                 MOVE 4                  DT03\n         B     MPFW00                                             DT03\nMRPID3   EX    R3,MOVERI3                 MOVE 3                  DT03\nMPFW00   DS    0H                                                 DT03\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address    DT03\n         STC   R3,MGCRLGTH             Set the length of the rep  DT03\n         XR    R0,R0                   Clear R0 for MGCR/SVC 34   DT03\n         MGCR  MGCRPL                     Reply to WTOR           DT03\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP3            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7                      DT03\nAFTDISP3 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message is a WTO not a WTOR reply not issued'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         WTO   'MPF008E - Notify Systems Programmer',             GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         BR    R9                                                 GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF037E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         WTO   'MPF008E - Notify Systems Programmer',             GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         BR    R9                                                 GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         WTO   'MPF008E - Notify Systems Programmer',             GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         BR    R9                                                 GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         WTO   'MPF008E - Notify Systems Programmer',                  X\n               DESC=(2),ROUTCDE=(1)\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMOVERI2  MVC   MGCRTEXT+8(0),CTXTRPYI                             DT03\nMOVERI3  MVC   MGCRTEXT+7(0),CTXTRPYI                             DT03\nMOVERI4  MVC   MGCRTEXT+6(0),CTXTRPYI                             DT03\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\nSCANTRT  TRT  0(0,R7),DELIMTAB     Execute TRT\n**********************************************************************\nSCANAST  TRT  0(0,R7),ASTERTAB     Execute TRT\n**********************************************************************\nSCNPERAT TRT  0(0,R7),PERATTAB     Execute TRT\n**********************************************************************\n         EJECT\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR A BLANK AND RETURN A 04        *\n**********************************************************************\nDELIMTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'04000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR AND RETURN * = 04 BLANK = 08   *\n**********************************************************************\nASTERTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'08000000000000000000000000000000' 40\n         DC    XL16'00000000000000000000000004000000' 50\n         DC    XL16'00000000000000000000000000000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        THIS TRT TABLE WILL SCAN FOR % AND & RETURN A 04 = % 08 = & *\n**********************************************************************\nPERATTAB DS    0F\n         DC    XL16'00000000000000000000000000000000' 00\n         DC    XL16'00000000000000000000000000000000' 10\n         DC    XL16'00000000000000000000000000000000' 20\n         DC    XL16'00000000000000000000000000000000' 30\n         DC    XL16'00000000000000000000000000000000' 40\n         DC    XL16'08000000000000000000000000000000' 50\n         DC    XL16'00000000000000000000000004000000' 60\n         DC    XL16'00000000000000000000000000000000' 70\n         DC    XL16'00000000000000000000000000000000' 80\n         DC    XL16'00000000000000000000000000000000' 90\n         DC    XL16'00000000000000000000000000000000' A0\n         DC    XL16'00000000000000000000000000000000' B0\n         DC    XL16'00000000000000000000000000000000' C0\n         DC    XL16'00000000000000000000000000000000' D0\n         DC    XL16'00000000000000000000000000000000' E0\n         DC    XL16'00000000000000000000000000000000' F0\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n*\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGIDN DS    CL1                 IF MSGID NE check              GS56\n*\nMSGIDNE  DS    CL1                 IF MSGID NE switch             GS56\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFMSGPLN DS    CL1                 IF MSGID NE PLUS check         GS56\n*\nMSGPLNE  DS    CL1                 IF MSGID PLUS NE switch        GS56\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nEIGHT    DS    F                   Return code 8\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nMSGIDMSG DS    CL25                MSGID from MSG\n*\nMSGIDCMD DS    CL25                MSGID from CMD\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT                                                    PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n         PRINT   GEN\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTAL8": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00G\\x01\\x07\\x06\\x9f\\x01\\x07\\x07\\x0f\\x15\\x15\\x07\\xd5\\x07~\\x00[\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2007-03-10T00:00:00", "modifydate": "2007-03-11T15:15:47", "lines": 2005, "newlines": 1918, "modlines": 91, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.8 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright(c) 2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite added all logic IF's etc               *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n*   GS56  - IF MSGID NE by Glenn Siegel                              *\n*         - IF MSGNE+ xx FOR xx by Glenn Siegel                      *\n*                                                                    *\n*   GS57  - No display /* MPFXTALL */                                *\n*         - AUTO(NODISPLY)      by Glenn Siegel                      *\n*                                                                    *\n*   DT03  - Four digit replies                                       *\n*         - REPLY NNNN,         by Dean Tesar                        *\n*                                                                    *\n*   GG58  - Added support for IF ASTYPE EQ J or T or S; added support*\n*           for TSOROUTE/TSOROUTE REPLY/TSOROUTE SUPPRESS including  *\n*           subroutine TSOROUTE by Garry Green                       *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R             Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\nCASE     LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    MOVEMEM             Yes move in member name        GS57\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify MPFXTALL Support',               PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     MPF008R             Return                         PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify MPFXTALL Support or S MPFLOAD',       X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGIDN,X'40'      Blank out MSGID check          GS56\n         MVI   MSGIDNE,X'40'       Blank out MSGID check          GS56\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFMSGPLN,X'40'      Blank out MSGID PLUS check     GS56\n         MVI   MSGPLNE,X'40'       Blank out MSGID PLUS check     GS56\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   IFASTYP,X'40'       Blank out IFASTYP check        GG58\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\nGOCHECK  DS    0H\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         CP    GOCNTR,=P'0'               Is GOCNTR less then 0   GS52\n         BL    ERRORIFL                   Yup go IFLOGIC error    GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKASTYP  DS    0H                                                  GG58\n         CLC   CMDTEXT(12),=C'ENDIF ASTYPE'  End of if in CMDS     GG58\n         BNE   CKNASTYP                   No continue              GG58\n         MVI   IFASTYP,X'40'              Blank out ASTYP check    GG58\n         SP    GOCNTR,=P'4'               Reduce GOCNTR            GG58\n         BR    R9                         Return                   GG58\n         SPACE ,                                                   GG58\nCKNASTYP DS    0H                                                  GG58\n         CLI   IFASTYP,C'N'               Is SYSID EQ N            GG58\n         BER   R9                         Yup return               GG58\n         B     CONT_TYP                   Continue type check      GG58\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGPN                   No continue type check  GS56\n         MVI   IFMSGPLN,X'40'            Blank out IFMSGPLN check GS56\n         MVI   MSGPLNE,X'40'              Blank out MSGPLNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGPN DS    0H                                                 GS56\n         CLI   IFMSGPLN,C'N'              If IFMSGPL EQ N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKMSGIDN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGIN                   No continue type check  GS56\n         MVI   IFMSGIDN,X'40'            Blank out IFMSGIDN check GS56\n         MVI   MSGIDNE,X'40'              Blank out MSGIDNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGIN DS    0H                                                 GS56\n         CLI   IFMSGIDN,C'N'              If IFMSGID NE N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'TSOROUTE '   Is it a TSOROUTE cmd    GG58\n         BE    TSOROUTE                   Yup go do it            GG58\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(11),=C'REPLY NNNN,' Is it a WTOR command   DT57\n         BE    MPFWTORX                   Yup go reply to WTOR    DT57\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(8),=C'DISPLAY '   Change color/highlighting GS58\n         BE    DISPLAY                    Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP1            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP1 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(10),=C'ASTYPE EQ '  ASTYPE check         GG58\n         BE    ASTYPCHK                      Yup go check ASTYPE  GG58\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID NE '    Parse check MSGID NE GS56\n         BE    MSGIDRNE                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(6),=C'MSGNE+'    Parse check MSGNE PLUS  GS56\n         BE    MSGIDPLN                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nDISPLAY  DS    0H                                                 GS58\n         CLC   CMDTEXT+8(4),=C'BLUE'        make it blue ?        GS58\n         BE    SETBLUE                      call blue routine     GS58\n         CLC   CMDTEXT+8(4),=C'PINK'        make it pink ?        GS58\n         BE    SETPINK                      call pink routine     GS58\n         CLC   CMDTEXT+8(3),=C'RED'         make it red ?         GS58\n         BE    SETRED                       call red routine      GS58\n         CLC   CMDTEXT+8(5),=C'GREEN'       make it green ?       GS58\n         BE    SETGREE                      call green routine    GS58\n         CLC   CMDTEXT+8(9),=C'TURQUOISE'   make it turquoise     GS58\n         BE    SETTURQ                    call turquoise routine  GS58\n         CLC   CMDTEXT+8(6),=C'YELLOW'      make it yellow ?      GS58\n         BE    SETYELO                      call yellow routine   GS58\n         CLC   CMDTEXT+8(5),=C'WHITE'       make it white ?       GS58\n         BE    SETWHIT                      call white routine    GS58\n         CLC   CMDTEXT+8(5),=C'BLINK'       make it blink ?       GS58\n         BE    SETBLNK                      call blink routine    GS58\n         CLC   CMDTEXT+8(7),=C'REVERSE' make it reverse video ?   GS58\n         BE    SETREVD                 call reverse video routine GS58\n         CLC   CMDTEXT+8(9),=C'UNDERLINE'   make it underlined ?  GS58\n         BE    SETUNDR                   call underlined routine  GS58\n         BR    R9                            Return               GS58\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nSETBLNK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTBLNK        Set to blinking           GS58\n         BR    R9                       Return                    GS58\nSETREVD  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTREVD        Set to reverse video      GS58\n         BR    R9                       Return                    GS58\nSETUNDR  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTUNDR        Set to underline          GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        CHANGE COLORS                                               *\n**********************************************************************\nSETBLUE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTBLUE        Set to blue               GS58\n         BR    R9                       Return                    GS58\nSETRED   DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTRED         Set to red                GS58\n         BR    R9                       Return                    GS58\nSETPINK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTPINK        Set to pink               GS58\n         BR    R9                       Return                    GS58\nSETGREE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTGREE        Set to green              GS58\n         BR    R9                       Return                    GS58\nSETTURQ  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTTURQ        Set to turquoise          GS58\n         BR    R9                       Return                    GS58\nSETYELO  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTYELO        Set to yellow             GS58\n         BR    R9                       Return                    GS58\nSETWHIT  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTWHIT        Set to white              GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 DT53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         DT53\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFASTYP,C'N'        Is ASTYP eq N                  GG58\n         BER   R6                  Yes set it and forget it       GG58\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGIDN,C'N'       Is IFMSGID NE eq N             GS56\n         BER   R6                  Yes set it and forget it       GS56\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPLN,C'N'       Is IFMSGPL eq N                GS56\n         BER   R6                  Yes set it and forget it       GS56\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF ASTYPE LOGIC                                         GG58*\n**********************************************************************\nASTYPCHK DS    0H                                                  GG58\n         LA    R8,CKASTYP                 Load address CKASTYP     GG58\n         LA    R2,ASTYP                   Load address ASTYP       GG58\n         LA    R6,ASTYPNO                 Load address ASTYPNO     GG58\n         B     MOVEGO                     Go check for no's        GG58\n*                                         and store GOTABLE addr   GG58\nASTYP    DS    0H                         Check if ASTYP match     GG58\n         L     R3,PSAAOLD-PSA(,0)         GET @ ASCB               GG58\n         L     R1,ASCBTSB-ASCB(,R3)       GET @ TSB                GG58\n         L     R3,ASCBJBNI-ASCB(,R3)      GET @ INITIATED JOB NAME GG58\n         MVI   IFASTYP,C'Y'               SET ASTYPE SATISFIED ON  GG58\n         CLI   CMDTEXT+13,C'T'            Q. IF ASTYPE EQ T        GG58\n         BE    CHKTSO                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'S'            Q. IF ASTYPE EQ S        GG58\n         BE    CHKSTC                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'J'            Q. IF ASTYPE EQ J        GG58\n         BE    CHKJOB                     A. YES - BRANCH          GG58\n         B     NOTASTYP                   Value invaid             GG58\nCHKTSO   DS    0H                         IF ASTYPE EQ T SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKJOB   DS    0H                         IF ASTYPE EQ J SPECIFIED GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKSTC   DS    0H                         IF ASTYPE EQ S SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         BR    R9                         RETURN SATISFIED         GG58\nCHKSTCNO DS    0H                         NOT AN STC               GG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\n*                                                                  GG58\nASTYPNO  DS    0H                         Set not satisfied switch GG58\n         MVI   IFASTYP,C'N'               Set switch to N          GG58\n         BR    R9                         Return                   GG58\n***********************************************************************\n*        TSOROUTE LOGIC                                           GG58*\n***********************************************************************\nTSOROUTE DS    0H                         SET UP TSOROUTE PARMS    GG58\n*                                         R10 ALREADY @ CTXT       GG58\n         ST    R10,@CTXT                  STORE @ CTXT TO PARM 1   GG58\n         LA    R1,CMDTEXT                 @ MPFXTALL COMMAND       GG58\n         ST    R1,@CMD                    STORE @ CMD  TO PARM 2   GG58\n         LA    R1,TSORPLST                @ TSOROUTE PLIST         GG58\n         L     R15,=V(TSOROUTE)           GET @ TSOROUTE SUBRTN    GG58\n         BASSM R14,R15                    CALL IT                  GG58\n         BR    R9                         RETURN                   GG58\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST1    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST1               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FGETWRD             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         LA    R1,0(R8,R7)         @ Past end of string            GG58\n         L     R0,SCANX6C          Load scan delim %               GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST2    SRST  R1,R7               SEARCH STRING FOR DELIM %       GG58\n         BO    SRST2               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FNDATPER            FOUND A % BRANCH                GG58\n         LA    R7,CMDTEXT          Start of CMDTEXT                GG58\n         LA    R8,L'CMDTEXT        Length of CMDTEXT               GG58\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX50          LOAD SCAN DELIM    &            GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST3    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST3               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAT             FOUND AN AMPERSAND              GG58\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GOCHECK             Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST4    SRST  R1,R7               SEARCH STRING FOR DELIM blank   GG58\n         BO    SRST4               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FWRDSPC             BLANK FOUND - BRANCH            GG58\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX5C          LOAD SCAN DELIM *               GG58\nSRST5    SRST  R1,R7               SEARCH STRING FOR DELIM *       GG58\n         BO    SRST5               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAST            * FOUND - BRANCH                GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDAST DS    0H\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST6    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST6               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSWR             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLN DS    0H                                                 GS56\n         MVI   MSGPLNE,C'Y'        Set MSGPLNE to Y               GS56\n         LA    R8,CKPMSGPN         Load address CKPMSGPN          GS56\n         LA    R2,MSGPLUS          Load address of                GS56\n         LA    R6,MSGIDPNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL              no must be IFMSGPL            GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL  DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set IFMSGPL to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL2             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'Y'       Set IFMSGPLN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL2 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL3             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL3 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST7    SRST  R1,R7               SEARCH STRING FOR DELIM blank   GG58\n         BO    SRST7               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FCMDSPC             BLANK FOUND - BRANCH            GG58\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST8    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST8               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSPC             BLANK FOUND - BRANCH            GG58\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDRNE DS    0H\n         MVI   MSGIDNE,C'Y'        Set MSGIDNE to Y               GS56\n         LA    R8,CKMSGIDN         Load address CKMSGIDN          GS56\n         LA    R2,MSGBEGIN         Load address of                GS56\n         LA    R6,MSGBEGNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID              no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID  DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set IFMSGID to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST9    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST9               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGID              BLANK FOUND - BRANCH            GG58\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDCMD,C' '                       Initial\n         MVC   MSGIDCMD+1(L'MSGIDCMD-1),MSGIDCMD   Blank out\n         LA    R6,MSGIDCMD         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDCMD\n         LA    R7,MSGTXT           Start of message\n         LA    R8,L'MSGTXT         Length of message\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST10   SRST  R1,R15              SEARCH STRING FOR DELIM         GG58\n         BO    SRST10              SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGTXT             BLANK FOUND - BRANCH            GG58\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGTXT  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         MVI   MSGIDMSG,C' '                       Initial\n         MVC   MSGIDMSG+1(L'MSGIDMSG-1),MSGIDMSG   Blank out\n         LA    R6,MSGIDMSG         Get address of MSGIDCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command MSGIDMSG\n         CLC   MSGIDMSG,MSGIDCMD   Compare MSGIDCMD to MSGIDMSG\n         BNE   NOMATCH             No seeya\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID2             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID2 DS    0H                                                 GS56\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NOMTCHID             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'Y'       Set IFMSGIDN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNOMTCHID DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         B     MPF008R9            Return                         GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP2            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP2 DS    0H\n         BR    R9                         Return\nMPFWTORX DS    0H                                                 DT03\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR          DT03\n         BNO   NOTWTOR                    No you messed up        DT03\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area     DT03\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    MOVE IN REPLY       DT03\n         MVC   MGCRTEXT+6(4),=C'    '     CLEAR NNNN              DT03\n         LH    R3,CTXTRPYL                LOAD LENGTH OF REPLY    DT03\n         BCTR  R3,0                       DECREMENT FOR MOVE      DT03\n         CH    R3,=H'2'                   WHAT LENGTH to move?    DT03\n         BE    MRPID3                     =2 MOVE 3               DT03\n         BH    MRPID4                     >2 MOVE 4               DT03\n         EX    R3,MOVERI2                 MOVE 2                  DT03\n         B     MPFW00                                             DT03\nMRPID4   EX    R3,MOVERI4                 MOVE 4                  DT03\n         B     MPFW00                                             DT03\nMRPID3   EX    R3,MOVERI3                 MOVE 3                  DT03\nMPFW00   DS    0H                                                 DT03\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address    DT03\n         STC   R3,MGCRLGTH             Set the length of the rep  DT03\n         XR    R0,R0                   Clear R0 for MGCR/SVC 34   DT03\n         MGCR  MGCRPL                     Reply to WTOR           DT03\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP3            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7                      DT03\nAFTDISP3 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nMPF008R  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\n**********************************************************************\nMPF008F  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM             Bye\n**********************************************************************\nMPF008R9 DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message not a WTPR - reply not issued',DESC=2X\n               ,ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         B     MPF008R9                                           GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nNOTASTYP DS    0H                                                 GG58\n         WTO   'MPF062E - IF ASTYPE EQ value invalid',            GG58 X\n               DESC=(2),ROUTCDE=(1)                               GG58\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GG58\n         B     MPF008R9                                           GG58\n         SPACE ,                                                  GG58\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF037E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         B     MPF008R9                                           GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMOVERI2  MVC   MGCRTEXT+8(0),CTXTRPYI                             DT03\nMOVERI3  MVC   MGCRTEXT+7(0),CTXTRPYI                             DT03\nMOVERI4  MVC   MGCRTEXT+6(0),CTXTRPYI                             DT03\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\nSCANX40  DC    A(C' ')                                             GG58\nSCANX50  DC    A(C'&&')                                            GG58\nSCANX5C  DC    A(C'*')                                             GG58\nSCANX6C  DC    A(C'%')                                             GG58\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\nTSORPLST DS    0F                  TSOROUTE PARAMETER LIST         GG58\n@CTXT    DS    F                     PARM 1 - @ CTXT               GG58\n@CMD     DS    F                     PARM 2 - @ MPFXTALL COMMAND   GG58\n*\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFASTYP  DS    CL1                 ADDRESS SPACE check            GG58\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGIDN DS    CL1                 IF MSGID NE check              GS56\n*\nMSGIDNE  DS    CL1                 IF MSGID NE switch             GS56\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFMSGPLN DS    CL1                 IF MSGID NE PLUS check         GS56\n*\nMSGPLNE  DS    CL1                 IF MSGID PLUS NE switch        GS56\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nMSGIDMSG DS    CL25                MSGID from MSG\n*\nMSGIDCMD DS    CL25                MSGID from CMD\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT ,                                                  PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n*        PRINT   GEN                                              GG58\n         PRINT   ON,NOGEN                                         GG58\n         IHAPSA  ,                 MAP PSA                        GG58\n         IHAASCB ,                 MAP ASCB                       GG58\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MPFXTAL9": {"ttr": 8709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00C\\x01\\x07\\x07?\\x01\\x07\\x12/#\\x14\\x07\\xf7\\x08\\x0e\\x00\\x19\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-03-14T00:00:00", "modifydate": "2007-05-02T23:14:43", "lines": 2039, "newlines": 2062, "modlines": 25, "user": "GSI"}, "text": "MPFXTALL TITLE 'MPF exit to issue commands based on message ID'\nMPFXTALL CSECT\nMPFXTALL AMODE 31\nMPFXTALL RMODE 24\n         YREGS\n         BAKR  R14,0               Store Regs & Envir on Link Stack\n         LAE   R12,00(,R15)        R12 = The Base Register\n         LA    R11,4095(,R12)      R11 = Second Base Register\n         LA    R11,1(,R11)         Add 1 more\n         USING MPFXTALL,R12,R11    Establish Addressability\n         B     START               Branch around constants\n**********************************************************************\n*    Copyright (c) 1998-2007 and Written by Glenn Siegel SSC Corp.   *\n**********************************************************************\n         DC    C' MPFXTALL '       Program Name Identifier\n         DC    C'Version 5.9 '     Version\n         DC    C'&SYSDATE '        Assembly Date\n         DC    C'&SYSTIME '        Assembly Time\n         DC    C'Copyright(c) 1998 2007 '\n         DC    C'Glenn Siegel '\n         DC    C'SSC Corp. '\n         DC    C'631-444-5339 '\n         DC    C'516-607-4005 cell '\n         DC    C'GlennSiegel@optonline.net '\n**********************************************************************\n*                                                                    *\n*   GS   - A complete rewrite added all logic IF's etc               *\n*                                                                    *\n*   TL01 - States messageid issued for command/reply by, and reply   *\n*          length modification by Tom Lewis                          *\n*                                                                    *\n*   PJ01   Support for second message line by Peter Johnson          *\n*                                                                    *\n*   PJ02 - Multiple blanks between message words by Peter Johnson    *\n*                                                                    *\n*   PJ03 - Get Word length increased to 40 chars by Peter Johnson    *\n*                                                                    *\n*   PJGS1 - Joint effort of AUTO/TOKEN by Peter Johnson and Glenn    *\n*                                                                    *\n*   GS50  - AUTO/TOKEN different member selection by Glenn Siegel    *\n*                                                                    *\n*   GS51  - Message ID Plus For by Glenn Siegel                      *\n*                                                                    *\n*   GS52  - Outer and inner IF's for all by Glenn Siegel             *\n*                                                                    *\n*   GS53  - Set AUTO and AMRF on by Glenn Siegel                     *\n*                                                                    *\n*   DT01  - NOSYSLOG and NOJOBLOG settings by Dean Tesar             *\n*                                                                    *\n*   DT02  - MPFSUPNO setting by Dean Tesar                           *\n*                                                                    *\n*   GS54  - Get reply id by Glenn Siegel                             *\n*                                                                    *\n*   GS55  - PUTSWITCH by Glenn Siegel                                *\n*                                                                    *\n*   GS56  - IF MSGID NE by Glenn Siegel                              *\n*         - IF MSGNE+ xx FOR xx by Glenn Siegel                      *\n*                                                                    *\n*   GS57  - No display /* MPFXTALL */                                *\n*         - AUTO(NODISPLY)      by Glenn Siegel                      *\n*                                                                    *\n*   DT03  - Four digit replies                                       *\n*         - REPLY NNNN,         by Dean Tesar                        *\n*                                                                    *\n*   GS58  - You want colors I'll give you colors                     *\n*                                                                    *\n*   GG58  - Added support for IF ASTYPE EQ J or T or S; added support*\n*           for TSOROUTE/TSOROUTE REPLY/TSOROUTE SUPPRESS including  *\n*           subroutine TSOROUTE by Garry Green                       *\n*                                                                    *\n*   GG59  - Added ESTAEX to prevent MPFXTALL from becoming           *\n*           deactivated should it abend by Garry Green               *\n*                                                                    *\n**********************************************************************\nSTART    DS    0H\n         L     R10,0(,R1)          Establish Addressability\n         USING CTXT,R10            To the CTXT\n         TM    CTXTSFB4,CTXTCIDA   Termination call               PJ01\n         BO    RETURN              Yes-Return                     PJ01\n         ICM   R5,15,CTXTTXPN      Have minor message?            PJ01\n         BNZ   MINOR               Yes, go use it                 PJ01\n*\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    GETM                NO-BR                          PJGS1\n         LA    R9,RETURN           Exit point for next routines   PJGS1\n         CLC   CTXTAUTT,=CL8'SUPPRESS' suppress message           PJGS1\n         BE    SUPPRESS            call suppress routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOJOBLOG' suppress message           PJGS1\n         BE    NOJOBLOG            call nojoblog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'NOSYSLOG' suppress message           PJGS1\n         BE    NOSYSLOG            call nosyslog routine          PJGS1\n         CLC   CTXTAUTT,=CL8'HIGHLITE' suppress message           PJGS1\n         BE    MPFHIGHL            call Highlight routine         PJGS1\n**********************************************************************\n*        GETMAIN SUBPOOL 230 AND INITIALIZE WORKAREA                 *\n**********************************************************************\nGETM     DS    0H\n         GETMAIN RU,LV=WORKSIZE,SP=230,LOC=(BELOW,ANY)\n         LTR   R15,R15             Test getmain\n         BZ    AFTERGM             OK continue\n         WTO   'MPF029E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R             Bye\nAFTERGM  DS    0H\n         LR    R2,R1               Point to Reentrant work area\n         LA    R3,PSETSIZE         Store length of preset constants\n         LR    R5,R3               Copy to R4 for MVCL\n         LA    R4,PSETAREA         Point to preset data area\n         MVCL  R2,R4               Prime work area with preset data\n         LR    R13,R1              Sace address of getmained storage\n         USING WORKAREA,R13        Establish Addressability\n         MVC   SAVEAREA+4,=C'F1SA' Indicate stack in use\n*\n         ESTAEX ESTAERC,           Specify abend recovery routine GG59 *\n               MF=(E,ESTAELST)     (Cont'd)                       GG59\n*DC X'00' *** Force abend *** Glenn for testing only pls remove   GG59\n*\n         MVI   MSGTXT,C' '         Initialize in case of minor    PJ01\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT clear out message txt  PJ01\n         L     R5,CTXTTXPJ         Point to message attributes\n         USING CTXTATTR,R5         Establish Addressability\n         MVC   MSGLEN,CTXTTLEN     Save 1st line message          PJ01\n         MVC   SEQNO,CTXTSEQN      Save Sequence number           PJ01\n         EJECT\n**********************************************************************\n*        DETERMINE CASE TO PROCESS                                   *\n**********************************************************************\nCASE     LA    R2,CTXTTMSG         Load start of message id to R2\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BNO   MPFXT103            No go do lengtn for WTO\n         LA    R3,CTXTTMSG+11      Add 11 to length for WTOR\n         B     MPFXT105            Go get length\n         SPACE ,\nMPFXT103 DS    0H\n         LA    R3,CTXTTMSG+8       Add 8 to length of msgid for WTO\nMPFXT105 DS    0H\n         CLI   0(R2),X'40'         Message id is delimited by blank\n         BE    MPFXT110            Yup\n         CR    R2,R3               Are we there yet\n         BE    MPFXT110            Yup reached the max length\n         LA    R2,1(,R2)           Add 1 to R2\n         B     MPFXT105            Check next character\n         SPACE ,\nMPFXT110 DS    0H\n         LA    R3,CTXTTMSG         @ Start of msgid\n         MVC   MSGTXT(126),CTXTTMSG  Move message to save area\n         LA    R4,MEMN             Load address of MEMN\n         MVI   MEMN,C' '                       Initial\n         MVC   MEMN+1(L'MEMN-1),MEMN           Blank out\n         SR    R2,R3               Get length\n         BCTR  R2,0                Decrement for executed move\n         EX    R2,MVMBR2           Move member name to message    TL01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           GS50\n         BZ    MOVEMEM             No move in member name         GS50\n         CLI   CTXTAUTT,0          Automation Empty             GSPJ50\n         BE    MOVEMEM             Yes move in member name      GSPJ50\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  GS50\n         BE    MOVEMEM             Yes move in member name        GS50\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    MOVEMEM             Yes move in member name        GS57\n         MVC   MEMN,CTXTAUTT       Move member name from AUTO     GS50\n         B     CKMEMMES            Skip move member               GS50\n         SPACE ,\nMOVEMEM  DS    0H\n         EX    R2,MVMBR            Move member name to MEMN\nCKMEMMES DS    0H\n         CLC   MEMN(4),=C'MPF0'    Check for MPF messages\n         BE    NOMPFMS             Yup go tell em that's a no no\n         TM    CTXTTFB1,CTXTTFMJ   Is this a multi line message   PJ01\n         BZ    GETNAMET            No skip minor code             PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BO    GETNAMET            YES-BR                         PJ01\n         TM    CTXTSFB2,CTXTSAUT   Automation specified           PJGS1\n         BZ    TSTMINOR            NO-BR                          PJGS1\n         CLC   CTXTAUTT,=CL8'SINGLE' Single line processing only  PJGS1\n         BE    GETNAMET            YES-BR                         PJGS1\nTSTMINOR DS    0H                                                 PJ01\n         GETMAIN RU,LV=MINORSZ,SP=241,LOC=ANY                     PJ01\n         LTR   R15,R15             minor line work area obtained  PJ01\n         BZ    AFTERGM1            yes-branch                     PJ01\n         WTO   'MPF031E - GETMAIN ERROR',DESC=(2),ROUTCDE=(1)     PJ01\n         WTO   'MPF008E - Notify MPFXTALL Support',               PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     GETNAMET                                           PJ01\nAFTERGM1 DS    0H                                                 PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         XC    MINCHAIN,MINCHAIN   Clear chain Pointer            PJ01\n         MVC   MINSEQNO,CTXTSEQN   Save Sequence number           PJ01\n         ST    R13,MINSAVE         Save work area address         PJ01\n         ST    R1,MINORWAD         Save work address              PJ01\n         L     R15,CTXTIWKP        This exits work area           PJ01\nCHAINMIN EQU   *                                                  PJ01\n         SR    R14,R14             Set operand 1 to zero          PJ01\n         CS    R14,R1,0(R15)       If Chain zero, Add new work    PJ01\n         BE    ASKMINOR            Queued ok                      PJ01\n         LR    R15,R14             No, Get Addr of next Element   PJ01\n         B     CHAINMIN            Run up the chain               PJ01\n         DROP  R1                  Release Work area base         PJ01\nASKMINOR DS    0H                                                 PJ01\n         OI    CTXTRFB1,CTXTRPML   Ask for minor message          PJ01\n         B     RETURN              Bye                            PJ01\n         SPACE ,                                                  PJ01\nMINOR    DS    0H                                                 PJ01\n         NI    CTXTRFB1,255-CTXTRPML Reset Minor request          PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK  EQU   *                                                  PJ01\n         L     R1,0(,R1)           Next Minor work area           PJ01\n         LTR   R1,R1               Any address of Work Area       PJ01\n         BNZ   MINOR1              Yes OK                         PJ01\n         WTO   'MPF032E - MINOR Chain Error',                     PJ01 X\n               DESC=(2),ROUTCDE=(1)                               PJ01\n         B     MPF008R             Return                         PJ01\nMINOR1   EQU   *                                                  PJ01\n         USING MINORWRK,R1         Minor lines param area base    PJ01\n         CLC   MINSEQNO,CTXTSEQN   Correct work area found        PJ01\n         BNE   NXTWORK             No-rescan                      PJ01\n         L     R13,MINSAVE         Reset work area address        PJ01\n         DROP  R1                  Release Work area base         PJ01\n         TM    CTXTTFB1,CTXTTFMD   IS THIS a data line            PJ01\n         BZ    NOTDATA             NO-BR                          PJ01\n         LA    R3,MSGTXT           @ Start of messageid           PJ01\n         AH    R3,MSGLEN           Bypass 1st line message        PJ01\n         LH    R2,CTXTTLEN         Minor line length              PJ01\n         LA    R15,1(,R2)          MINOR LINE LENGTH+1            PJ01\n         AH    R15,MSGLEN          PREVIOUS MSG LEN               PJ01\n         CH    R15,=Y(L'MSGTXT)    OVER MSG SIZE                  PJ01\n         BNH   SIZEOK              YES-BR                         PJ01\n         LH    R15,=Y(L'MSGTXT)    GET MAX SIZE                   PJ01\n         LR    R2,R15              FOR THIS LENGTH                PJ01\n         SH    R2,MSGLEN           MAX ALLOWED                    PJ01\n         BNP   NOTDATA             NONE FOR THIS LINE             PJ01\nSIZEOK   DS    0H                                                 PJ01\n         MVI   0(R3),X'40'         Set blank between lines        PJ01\n         BCTR  R2,0                Allow for MVC                  PJ01\n         EX    R2,SAVEMINR         Save minor data                PJ01\n         STH   R15,MSGLEN                  length                 PJ01\nNOTDATA  DS    0H                                                 PJ01\n         TM    CTXTTFB1,CTXTTFME   IS THIS THE LAST LINE          PJ01\n         BZ    ASKMINOR            NO-BR                          PJ01\nENDMINOR EQU   *                                                  PJ01\n         L     R3,MINORWAD         Minor work area                PJ01\n         USING MINORWRK,R3         Minor lines param area base    PJ01\n         L     R1,CTXTIWKP         This exits work area           PJ01\nNXTWORK1 EQU   *                                                  PJ01\n         LR    R15,R3              For CS LOOP                    PJ01\n         L     R14,MINCHAIN        Next chain pointer             PJ01\n         CS    R15,R14,0(R1)       Correct Chain entry removed.   PJ01\n         BE    ENDMINR1            Yes OK                         PJ01\n         LR    R1,R15              Next Minor work area           PJ01\n         B     NXTWORK1            Do next entry                  PJ01\nENDMINR1 EQU   *                                                  PJ01\n         DROP  R3                  Release base                   PJ01\n         LA    R1,MINORSZ          Work area size                 PJ01\n         FREEMAIN RU,LV=(R1),A=(R3),SP=241 Freeup minor work area PJ01\n**********************************************************************\n*        GET NAME TOKEN ROUTINE                                      *\n**********************************************************************\nGETNAMET DS    0H\n         LA    R3,TOKEN\n         LA    R2,RETCODE\n         CALL  IEANTRT,(SYSLVL,NAME,(R3),(R2)),MF=(E,RENTCALL)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF015E - Name/Token not found error',                 X\n               DESC=(2),ROUTCDE=(1)\n         WTO   'MPF021E - Notify MPFXTALL Support or S MPFLOAD',       X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM       Return\n         ENDIF\n**********************************************************************\n*        FIND MESSAGE ID                                             *\n**********************************************************************\n         L     R4,ECSA_ADD         Store table address in R4\n         L     R6,ECSA_ADD         Store table address in R6\n         L     R8,ECSA_LEN         Store length of table in R8\n         ALR   R6,R8               Add length to R6 for end of table\n         ST    R6,ENDTABLE         Store end of table address\n**********************************************************************\nGETNXMES DS    0H\n         CL    R4,ENDTABLE         End of data\n         BNL   MSNOTFND            Yup bye\n         CLC   0(L'MEMN,R4),MEMN   Message id ?\n         BE    MPFXT200            Yup go get commands\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,4095(,R4)        Bump table\n         LA    R4,2(,R4)           Add 2 more to next record\n         B     GETNXMES            Get next message\n         SPACE ,\n**********************************************************************\nMPFXT200 DS    0H\n         LA    R6,4092(,R4)        Point R6 at end of usable record\n         LA    R6,4092(,R6)        Point R6 at end of usable record\n         ST    R6,ENDTABLE         Store end of table address\n         LA    R4,8(R4)            Point R4 to first command\n         SP    WORDNP,WORDNP       Clear out word number\n         SP    GOCNTR,GOCNTR       Clear out Go Counter\n         MVI   IFSYSID,X'40'       Blank out SYSID check\n         MVI   IFPARSE,X'40'       Blank out PARSE check\n         MVI   IFWORD,X'40'        Blank out WORD check\n         MVI   IFMSGID,X'40'       Blank out MSGID check\n         MVI   IFMSGIDN,X'40'      Blank out MSGID check          GS56\n         MVI   MSGIDNE,X'40'       Blank out MSGID check          GS56\n         MVI   IFMSGPL,X'40'       Blank out MSGID PLUS check\n         MVI   IFMSGPLN,X'40'      Blank out MSGID PLUS check     GS56\n         MVI   MSGPLNE,X'40'       Blank out MSGID PLUS check     GS56\n         MVI   IFSWEQ,X'40'        Blank out IFSWEQ check\n         MVI   IFSWNE,X'40'        Blank out IFSWNE check\n         MVI   IFSWON,X'40'        Blank out IFSWON check\n         MVI   IFSWOFF,X'40'       Blank out IFSWOFF check\n         MVI   IFASTYP,X'40'       Blank out IFASTYP check        GG58\n         MVI   GETCK,X'40'         Blank out GETWORD check\n         MVI   GETID,X'40'         Blank out GET REPLY ID check   GS54\n**********************************************************************\nMPFXT250 DS    0H\n         CLI   0(R4),X'FF'         End of commands\n         BE    FREEMEM             Yup bye bye\n         L     R6,ENDTABLE         End of table address to R6\n         CR    R4,R6               Unexpected end of record\n         BNL   LOADERR             Yup say and bye\n         MVC   CMDTEXT,0(R4)       Move command to CMDTEXT\n         MVC   GETCK2,GETCK        Copy GETWORD check             GS54\n         MVC   GETID2,GETID        Copy GET REPLY ID check        GS54\n         BAS   R9,CHECKTYP         Go check type of command\n         LA    R4,80(,R4)          Bump up for next command\n         B     MPFXT250            Get next record\n         SPACE ,\n**********************************************************************\n*        CHECK TYPE - COMMAND, WTO/R, HIGHLIGHT, SYSID, PARSE, GET...*\n**********************************************************************\nCHECKTYP DS    0H\n         CLC   CMDTEXT(3),=C'IF '         Is it an if statment\n         BE    IFLOGIC                    Yup go to if logic\n         CLC   CMDTEXT(9),=C'GET WORD '   Is it a get statment\n         BE    GETWORD                    Yup go to get word\n         CLC   CMDTEXT(11),=C'GET REPLYID' Is it a get reply id   GS54\n         BE    GETREPLY                   Yup go to get reply     GS54\n         CLI   GETID2,X'40'               Get reply id check      GS54\n         BH    CKPGETID                   Yup getid SW is Y or N  GS54\n         CLI   GETCK2,X'40'               Get check\n         BH    CKPGET                     Yup get SW is Y or N\nGOCHECK  DS    0H\n         CP    GOCNTR,=P'0'               Is GOCNTR eq 0          GS52\n         BE    CONT_TYP                   Yes continue type check GS52\n         BL    ERRORIFL                   Muck go IFLOGIC error   GS52\n         CVB   R3,GOCNTR                  Convert to R3           GS52\n         LA    R2,GOTABLE                 Point to GOTABLE        GS52\n         L     R3,0(R3,R2)                Load Address of GO      GS52\n         BR    R3                         Go to last address GO   GS52\n         SPACE ,\n**********************************************************************\nCKSYSID  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOSYS                    No continue\n         MVI   IFSYSID,X'40'              Blank out SYSID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSYS  DS    0H\n         CLI   IFSYSID,C'N'               Is SYSID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKASTYP  DS    0H                                                  GG58\n         CLC   CMDTEXT(12),=C'ENDIF ASTYPE'  End of if in CMDS     GG58\n         BNE   CKNASTYP                   No continue              GG58\n         MVI   IFASTYP,X'40'              Blank out ASTYP check    GG58\n         SP    GOCNTR,=P'4'               Reduce GOCNTR            GG58\n         BR    R9                         Return                   GG58\n         SPACE ,                                                   GG58\nCKNASTYP DS    0H                                                  GG58\n         CLI   IFASTYP,C'N'               Is SYSID EQ N            GG58\n         BER   R9                         Yup return               GG58\n         B     CONT_TYP                   Continue type check      GG58\n**********************************************************************\nCKPGET   DS    0H\n         CLC   CMDTEXT(8),=C'ENDGET  '    End of get in parse CMDS\n         BNE   CKNOGET                    No continue type check\n         MVI   GETCK,X'40'                Blank out get check\n         BR    R9                         Return\n         SPACE ,\nCKNOGET  DS    0H\n         CLI   GETCK,C'N'                 Is get check EQ N\n         BER   R9                         Return\n         B     GETRPLAC                   Go replace % with get word\n         SPACE ,\n**********************************************************************\nCKPGETID DS    0H                                                 GS54\n         CLC   CMDTEXT(9),=C'ENDGET ID'   End of get id           GS54\n         BNE   CKNOGID                    No continue type check  GS54\n         MVI   GETID,X'40'                Blank out get check     GS54\n         BR    R9                         Return                  GS54\n         SPACE ,                                                  GS54\nCKNOGID  DS    0H                                                 GS54\n         CLI   GETID,C'N'                 Is get check id EQ N    GS54\n         BER   R9                         Return                  GS54\n         B     GETRPLAC              Go replace @ with REPLY ID   GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nCKPARSE  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOPAR                    No continue type check\n         MVI   IFPARSE,X'40'              Blank out IFPARSE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         BR    R9                         Return\n         SPACE ,\nCKNOPAR  DS    0H\n         CLI   IFPARSE,C'N'               Is IFPARSE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPMSGPN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGPN                   No continue type check  GS56\n         MVI   IFMSGPLN,X'40'            Blank out IFMSGPLN check GS56\n         MVI   MSGPLNE,X'40'              Blank out MSGPLNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGPN DS    0H                                                 GS56\n         CLI   IFMSGPLN,C'N'              If IFMSGPL EQ N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGPL DS    0H                                                 GS51\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS51\n         BNE   CKNOMSGP                   No continue type check  GS51\n         MVI   IFMSGPL,X'40'              Blank out IFMSGPL check GS51\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return                  GS51\n         SPACE ,                                                  GS51\nCKNOMSGP DS    0H                                                 GS51\n         CLI   IFMSGPL,C'N'               If IFMSGPL EQ N         GS51\n         BER   R9                         Yup return              GS51\n         B     CONT_TYP                   Continue type check     GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nCKMSGIDN DS    0H                                                 GS56\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS       GS56\n         BNE   CKNMSGIN                   No continue type check  GS56\n         MVI   IFMSGIDN,X'40'            Blank out IFMSGIDN check GS56\n         MVI   MSGIDNE,X'40'              Blank out MSGIDNE check GS56\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS56\n         BR    R9                         Return                  GS56\n         SPACE ,                                                  GS56\nCKNMSGIN DS    0H                                                 GS56\n         CLI   IFMSGIDN,C'N'              If IFMSGID NE N         GS56\n         BER   R9                         Yup return              GS56\n         B     CONT_TYP                   Continue type check     GS56\n         SPACE ,                                                  GS56\n**********************************************************************\nCKPMSGID DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOMSGI                   No continue type check\n         MVI   IFMSGID,X'40'              Blank out IFMSGID check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOMSGI DS    0H\n         CLI   IFMSGID,C'N'               If IFMSGID EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWEQ  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH EQ'   End of if for SW EQ\n         BNE   CKNOSWEQ                   No continue type check\n         MVI   IFSWEQ,X'40'               Blank out IFSWEQ check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWEQ DS    0H\n         CLI   IFSWEQ,C'N'                If IFSWEQ EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWNE  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH NE'   End of if for SW NE\n         BNE   CKNOSWNE                   No continue type check\n         MVI   IFSWNE,X'40'               Blank out IFSWNE check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWNE DS    0H\n         CLI   IFSWNE,C'N'                If IFSWNE EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWON  DS    0H\n         CLC   CMDTEXT(15),=C'ENDIF SWITCH ON'   End of if for SW ON\n         BNE   CKNOSWON                   No continue type check\n         MVI   IFSWON,X'40'               Blank out IFSWON check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWON DS    0H\n         CLI   IFSWON,C'N'                If IFSWON EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPSWOFF DS    0H\n         CLC   CMDTEXT(16),=C'ENDIF SWITCH OFF'   End of if for SW OFF\n         BNE   CKNOSWOF                   No continue type check\n         MVI   IFSWOFF,X'40'              Blank out IFSWOFF check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOSWOF DS    0H\n         CLI   IFSWOFF,C'N'               If IFSWOFF EQ N\n         BER   R9                         Yup return\n         B     CONT_TYP                   Continue type check\n         SPACE ,\n**********************************************************************\nCKPWORD  DS    0H\n         CLC   CMDTEXT(7),=C'ENDIF  '     End of if in CMDS\n         BNE   CKNOWRD                    No continue type check\n         MVI   IFWORD,X'40'               Blank out word check\n         SP    GOCNTR,=P'4'               Reduce GOCNTR           GS52\n         BR    R9                         Return\n         SPACE ,\nCKNOWRD  DS    0H\n         CLI   IFWORD,C'N'                If word EQ N\n         BER   R9                         Yup return\n**********************************************************************\nCONT_TYP DS    0H\n         CLC   CMDTEXT(9),=C'TSOROUTE '   Is it a TSOROUTE cmd    GG58\n         BE    TSOROUTE                   Yup go do it            GG58\n         CLC   CMDTEXT(9),=C'REPLY NN,'   Is it a WTOR command\n         BE    MPFWTOR                    Yup go reply to WTOR\n         CLC   CMDTEXT(11),=C'REPLY NNNN,' Is it a WTOR command   DT57\n         BE    MPFWTORX                   Yup go reply to WTOR    DT57\n         CLC   CMDTEXT(10),=C'HIGHLIGHT ' Highlight message\n         BE    MPFHIGHL                   Yup go do it\n         CLC   CMDTEXT(8),=C'DISPLAY '   Change color/highlighting GS58\n         BE    DISPLAY                    Yup go do it\n         CLC   CMDTEXT(4),=C'WTO '        WTO message\n         BE    WTOROUT                    Yup go do it\n         CLC   CMDTEXT(5),=C'WTOH '       WTO highlight message\n         BE    WTOHIGH                    Yup go do it\n         CLC   CMDTEXT(10),=C'PUTSWITCH ' Put token from switch   GS55\n         BE    PUTSWTCH                   Yup go do it            GS55\n         CLC   CMDTEXT(10),=C'SETSWITCH ' Set switch\n         BE    SETSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'DELSWITCH ' Delete switch\n         BE    DELSWTCH                   Yup go do it\n         CLC   CMDTEXT(10),=C'ALTSWITCH ' Alter switch\n         BE    ALTSWTCH                   Yup go do it\n         CLC   CMDTEXT(8),=C'SETAUTO '    Set AUTO on             GS53\n         BE    SETAUTO                    Yup go do it            GS53\n         CLC   CMDTEXT(8),=C'SETAMRF '    Set AMRF on             GS53\n         BE    SETAMRF                    Yup go do it            GS53\n         CLC   CMDTEXT(9),=C'SUPPRESS '   Suppress message\n         BE    SUPPRESS                   Yup go do it\n         CLC   CMDTEXT(9),=C'NOJOBLOG '   Suppress from joblog    DT01\n         BE    NOJOBLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'NOSYSLOG '   Suppress from syslog    DT01\n         BE    NOSYSLOG                   Yup go do it            DT01\n         CLC   CMDTEXT(9),=C'MPFSUPNO '   MPF SUP(NO)             DT02\n         BE    MPFSUPNO                   Yup go do it            DT02\n         CLC   CMDTEXT(5),=C'ENDIF'       ENDIF coding error      GS52\n         BE    ERROREND                   Yup, go tell em         GS52\n         CLC   CMDTEXT(6),=C'ENDGET'      ENDIF coding error      GS52\n         BE    ERRORGET                   Yup, go tell em         GS52\n         XR    R0,R0                      Clear for MGCR/SVC 34\n         MGCR  CMDHDR              Point to command and issue command\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP1            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP1 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        IF LOGIC                                                    *\n**********************************************************************\nIFLOGIC  DS    0H\n         CLC   CMDTEXT+3(9),=C'SYSID EQ '    SYSID check\n         BE    SYSIDCK                       Yup go SYSID check\n         CLC   CMDTEXT+3(10),=C'ASTYPE EQ '  ASTYPE check         GG58\n         BE    ASTYPCHK                      Yup go check ASTYPE  GG58\n         CLC   CMDTEXT+3(7),=C'ALL EQ '      Parse check all\n         BE    PARSEROU                      Yup go parse routine\n         CLC   CMDTEXT+3(5),=C'WORD '        Parse check work\n         BE    WORDPARS                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID EQ '    Parse check MSGID\n         BE    MSGIDROU                      Yup go parse word\n         CLC   CMDTEXT+3(9),=C'MSGID NE '    Parse check MSGID NE GS56\n         BE    MSGIDRNE                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(6),=C'MSGID+'    Parse check MSGID PLUS  GS51\n         BE    MSGIDPLU                      Yup go parse word    GS51\n         CLC   CMDTEXT+3(6),=C'MSGNE+'    Parse check MSGNE PLUS  GS56\n         BE    MSGIDPLN                      Yup go parse word    GS56\n         CLC   CMDTEXT+3(9),=C'SWITCH ON'    Is the switch ON\n         BE    SWTCHON                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH EQ'    Is the switch EQ\n         BE    SWTCHEQ                       Yup go switch routine\n         CLC   CMDTEXT+3(9),=C'SWITCH NE'    Is the switch NE\n         BE    SWTCHNE                       Yup go switch routine\n         CLC   CMDTEXT+3(10),=C'SWITCH OFF'  Is the switch OFF\n         BE    SWTCHOFF                      Yup go switch routine\n         BR    R9                            Return\n         SPACE ,\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nDISPLAY  DS    0H                                                 GS58\n         CLC   CMDTEXT+8(4),=C'BLUE'        make it blue ?        GS58\n         BE    SETBLUE                      call blue routine     GS58\n         CLC   CMDTEXT+8(4),=C'PINK'        make it pink ?        GS58\n         BE    SETPINK                      call pink routine     GS58\n         CLC   CMDTEXT+8(3),=C'RED'         make it red ?         GS58\n         BE    SETRED                       call red routine      GS58\n         CLC   CMDTEXT+8(5),=C'GREEN'       make it green ?       GS58\n         BE    SETGREE                      call green routine    GS58\n         CLC   CMDTEXT+8(9),=C'TURQUOISE'   make it turquoise     GS58\n         BE    SETTURQ                    call turquoise routine  GS58\n         CLC   CMDTEXT+8(6),=C'YELLOW'      make it yellow ?      GS58\n         BE    SETYELO                      call yellow routine   GS58\n         CLC   CMDTEXT+8(5),=C'WHITE'       make it white ?       GS58\n         BE    SETWHIT                      call white routine    GS58\n         CLC   CMDTEXT+8(5),=C'BLINK'       make it blink ?       GS58\n         BE    SETBLNK                      call blink routine    GS58\n         CLC   CMDTEXT+8(7),=C'REVERSE' make it reverse video ?   GS58\n         BE    SETREVD                 call reverse video routine GS58\n         CLC   CMDTEXT+8(9),=C'UNDERLINE'   make it underlined ?  GS58\n         BE    SETUNDR                   call underlined routine  GS58\n         BR    R9                            Return               GS58\n**********************************************************************\n*        CHANGE HIGHLIGHTING                                         *\n**********************************************************************\nSETBLNK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTBLNK        Set to blinking           GS58\n         BR    R9                       Return                    GS58\nSETREVD  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTREVD        Set to reverse video      GS58\n         BR    R9                       Return                    GS58\nSETUNDR  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMHI        Request highlight change  GS58\n         OI    CTXTERF1,CTXTEMIN        Request intensity change  GS58\n         OI    CTXTINTN,CTXTIHIG        Set to high intensity     GS58\n         OI    CTXTHILI,CTXTUNDR        Set to underline          GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        CHANGE COLORS                                               *\n**********************************************************************\nSETBLUE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTBLUE        Set to blue               GS58\n         BR    R9                       Return                    GS58\nSETRED   DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTRED         Set to red                GS58\n         BR    R9                       Return                    GS58\nSETPINK  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTPINK        Set to pink               GS58\n         BR    R9                       Return                    GS58\nSETGREE  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTGREE        Set to green              GS58\n         BR    R9                       Return                    GS58\nSETTURQ  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTTURQ        Set to turquoise          GS58\n         BR    R9                       Return                    GS58\nSETYELO  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTYELO        Set to yellow             GS58\n         BR    R9                       Return                    GS58\nSETWHIT  DS    0H                                                 GS58\n         OI    CTXTERF1,CTXTEMCO        Request color change      GS58\n         XC    CTXTCOLR(1),CTXTCOLR     Clear out current codes   GS58\n         OI    CTXTCOLR,CTXTWHIT        Set to white              GS58\n         BR    R9                       Return                    GS58\n**********************************************************************\n*        HIGHLIGHT MESSAGE                                           *\n**********************************************************************\nMPFHIGHL DS    0H\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         L     R3,CTXTDCP\n         USING CTXTDESC,R3\n         OI    CTXTRFB1,CTXTRCDC   Request to change the descodes\n         XC    CTXTDESC,CTXTDESC   Clear out the descriptor codes\n         OI    CTXTDC1,CTXTDC02    Change to descriptor code 2\n         DROP  R3\n         BR    R9                  RETURN\n         SPACE ,\n**********************************************************************\n*        SUPPRESS MESSAGE                                            *\n**********************************************************************\nSUPPRESS DS    0H\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR\n         BO    SUPPGOBK            WTOR don't want a suppress those\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog\nSUPPGOBK DS    0H\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SUPPRESS JOBLOG                                             *\n**********************************************************************\nNOJOBLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOJOGOBK          WTOR don't want a suppress those DT01\n         OI    CTXTERF3,CTXTESJL   Suppress from joblog           DT01\nNOJOGOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,                                                  DT01\n**********************************************************************\n*        SUPPRESS SYSLOG                                             *\n**********************************************************************\nNOSYSLOG DS    0H                                                 DT01\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT01\n         BO    NOSYSOBK          WTOR don't want a suppress those DT01\n         OI    CTXTRFB2,CTXTRDTM   Suppress from hardcopy syslog  DT01\nNOSYSOBK DS    0H                                                 DT01\n         BR    R9                  Return                         DT01\n         SPACE ,\n**********************************************************************\n*        MPF SUP(NO)                                                 *\n**********************************************************************\nMPFSUPNO DS    0H                                                 DT02\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 DT02\n         BO    NOMPFSUP          WTOR don't want change these     DT02\n         OI    CTXTRFB2,CTXTROMS   set MPF SUP(NO)                DT02\nNOMPFSUP DS    0H                                                 DT02\n         BR    R9                  Return                         DT02\n         SPACE ,\n**********************************************************************\n*        SET AUTO ON                                                 *\n**********************************************************************\nSETAUTO  DS    0H                                                 DT53\n         OI    CTXTRFB3,CTXTRAYS   Set automation on              DT53\n         BR    R9                  Return                         DT53\n         SPACE ,\n**********************************************************************\n*        SET AMRF ON                                                 *\n**********************************************************************\nSETAMRF  DS    0H                                                 GS53\n         OI    CTXTSFB2,CTXTSRET   Set AMRF on                    GS53\n         BR    R9                  Return                         GS53\n         SPACE ,\n**********************************************************************\n*        MOVE TO GOTABLE                                             *\n**********************************************************************\nMOVEGO   DS    0H                                                 GS52\n         AP    GOCNTR,=P'4'        Add 4 to GOCNTR                GS52\n         CVB   R3,GOCNTR           Convert to R3                  GS52\n         LA    R7,GOTABLE          Load address GOTABLE           GS52\n         ST    R8,0(R3,R7)         STORE ADDRESS TO GOTABLE       GS52\n**********************************************************************\n*        CHECK FOR OUTER IF'S EQ NO                                  *\n**********************************************************************\nCKOUTER  DS    0H                                                 GS52\n         CLI   IFSYSID,C'N'        Is SYSID eq N                  GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFASTYP,C'N'        Is ASTYP eq N                  GG58\n         BER   R6                  Yes set it and forget it       GG58\n         CLI   IFPARSE,C'N'        Is IFPARSE eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFWORD,C'N'         Is IFWORD eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWEQ,C'N'         Is IFSWEQ eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWNE,C'N'         Is IFSWNE eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWON,C'N'         Is IFSWON eq N                 GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFSWOFF,C'N'        Is IFSWOFF eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGID,C'N'        Is IFMSGID eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGIDN,C'N'       Is IFMSGID NE eq N             GS56\n         BER   R6                  Yes set it and forget it       GS56\n         CLI   IFMSGPL,C'N'        Is IFMSGPL eq N                GS52\n         BER   R6                  Yes set it and forget it       GS52\n         CLI   IFMSGPLN,C'N'       Is IFMSGPL eq N                GS56\n         BER   R6                  Yes set it and forget it       GS56\n         BR    R2                  Start that routine             GS52\n         SPACE ,\n**********************************************************************\n*        IF ASTYPE LOGIC                                         GG58*\n**********************************************************************\nASTYPCHK DS    0H                                                  GG58\n         LA    R8,CKASTYP                 Load address CKASTYP     GG58\n         LA    R2,ASTYP                   Load address ASTYP       GG58\n         LA    R6,ASTYPNO                 Load address ASTYPNO     GG58\n         B     MOVEGO                     Go check for no's        GG58\n*                                         and store GOTABLE addr   GG58\nASTYP    DS    0H                         Check if ASTYP match     GG58\n         L     R3,PSAAOLD-PSA(,0)         GET @ ASCB               GG58\n         L     R1,ASCBTSB-ASCB(,R3)       GET @ TSB                GG58\n         L     R3,ASCBJBNI-ASCB(,R3)      GET @ INITIATED JOB NAME GG58\n         MVI   IFASTYP,C'Y'               SET ASTYPE SATISFIED ON  GG58\n         CLI   CMDTEXT+13,C'T'            Q. IF ASTYPE EQ T        GG58\n         BE    CHKTSO                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'S'            Q. IF ASTYPE EQ S        GG58\n         BE    CHKSTC                     A. YES - BRANCH          GG58\n         CLI   CMDTEXT+13,C'J'            Q. IF ASTYPE EQ J        GG58\n         BE    CHKJOB                     A. YES - BRANCH          GG58\n         B     NOTASTYP                   Value invaid             GG58\nCHKTSO   DS    0H                         IF ASTYPE EQ T SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKJOB   DS    0H                         IF ASTYPE EQ J SPECIFIED GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZR  R9                         A. YES - RETURN SATISFIEDGG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\nCHKSTC   DS    0H                         IF ASTYPE EQ S SPECIFIED GG58\n         LTR   R1,R1                      Q. IS JOB A TSU          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         LTR   R3,R3                      Q. IS JOB BATCH          GG58\n         BNZ   CHKSTCNO                   A. YES - BRANCH          GG58\n         BR    R9                         RETURN SATISFIED         GG58\nCHKSTCNO DS    0H                         NOT AN STC               GG58\n         MVI   IFASTYP,C'N'               SET ASTYPE SATISFIED OFF GG58\n         BR    R9                         RETURN NOT SATISFIED     GG58\n*                                                                  GG58\nASTYPNO  DS    0H                         Set not satisfied switch GG58\n         MVI   IFASTYP,C'N'               Set switch to N          GG58\n         BR    R9                         Return                   GG58\n***********************************************************************\n*        TSOROUTE LOGIC                                           GG58*\n***********************************************************************\nTSOROUTE DS    0H                         SET UP TSOROUTE PARMS    GG58\n*                                         R10 ALREADY @ CTXT       GG58\n         ST    R10,@CTXT                  STORE @ CTXT TO PARM 1   GG58\n         LA    R1,CMDTEXT                 @ MPFXTALL COMMAND       GG58\n         ST    R1,@CMD                    STORE @ CMD  TO PARM 2   GG58\n         LA    R1,TSORPLST                @ TSOROUTE PLIST         GG58\n         L     R15,=V(TSOROUTE)           GET @ TSOROUTE SUBRTN    GG58\n         BASSM R14,R15                    CALL IT                  GG58\n         BR    R9                         RETURN                   GG58\n**********************************************************************\n*        IF SYSID LOGIC                                              *\n**********************************************************************\nSYSIDCK  DS    0H\n         LA    R8,CKSYSID          Load address CKSYSID           GS52\n         LA    R2,SYSID            Load address of                GS52\n         LA    R6,SYSIDNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSYSID    DS    0H\n         L     R3,16               Point to the CVT\n         USING CVT,R3              Cover the CVT\n*\n         MVC   CMDSID,CMDTEXT+12   Move command SYSID\n         CLC   CMDSID,CVTSNAME     Check SYSID\n         BNE   SYSIDNO             No, bye\n         MVI   IFSYSID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nSYSIDNO  DS    0H\n         MVI   IFSYSID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        GET REPLY ID                                                *\n**********************************************************************\nGETREPLY DS    0H                                                 GS54\n         LA    R2,SREPLY           Load address of                GS54\n         LA    R6,SREPLYNO         Load address of                GS54\n         B     CKOUTER             Go check for no's              GS54\nSREPLYNO DS    0H                                                 GS54\n         MVI   GETID,C'N'          Set GETID to N                 GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\nSREPLY   DS    0H                                                 GS54\n         TM    CTXTTFB1,CTXTTFWR   Is this a WTOR                 GS54\n         BNO   NOTREPLY            No you messed up               GS54\n         MVC   CMDAT,CTXTRPID      Move in reply number           GS54\n         MVI   GETID,C'Y'          Set switch to Y                GS54\n         BR    R9                  Return                         GS54\n         SPACE ,                                                  GS54\n**********************************************************************\n*        GET WORD LOGIC         %                                    *\n**********************************************************************\nGETWORD  DS    0H\n         LA    R2,STRTGET          Load address of                GS52\n         LA    R6,SETGETNO         Load address of                GS52\n         B     CKOUTER             Go check for no's              GS52\nSETGETNO DS    0H\n         MVI   GETCK,C'N'          Set GETCH to N\n         BR    R9                  Return\n         SPACE ,\nSTRTGET  DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMG             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+9(2) Pack it baby\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTGET DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST1    SRST  R1,R7               Scan message for next space     GG58\n         BO    SRST1               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FGETWRD             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFGETWRD  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPGET              No get next word\n         MVI   WORDGET,C' '                     Initial\n         MVC   WORDGET+1(L'WORDGET-1),WORDGET   Blank out\n         ST    R3,WORDLGET         Store the length to WORDLGET\n         LA    R6,WORDGET          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVI   GETCK,C'Y'          Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPGET   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\nBMPGET1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTGET            No continue TRT scan           PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPGET1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\n**********************************************************************\n*        PARSE ROUTINES                                              *\n**********************************************************************\n**********************************************************************\n*     REPLACE WORD LOGIC FOR & AND %                                 *\n**********************************************************************\nGETRPLAC DS    0H\n         LA    R7,CMDTEXT          Start of CMDTEXT\n         LA    R8,L'CMDTEXT        Length of CMDTEXT\n         LA    R1,0(R8,R7)         @ Past end of string            GG58\n         L     R0,SCANX6C          Load scan delim %               GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST2    SRST  R1,R7               SEARCH STRING FOR DELIM %       GG58\n         BO    SRST2               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FNDATPER            FOUND A % BRANCH                GG58\n         LA    R7,CMDTEXT          Start of CMDTEXT                GG58\n         LA    R8,L'CMDTEXT        Length of CMDTEXT               GG58\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX50          LOAD SCAN DELIM    &            GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST3    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST3               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAT             FOUND AN AMPERSAND              GG58\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GOCHECK             Continue type checking         GS54\n         SPACE ,                                                  GS54\nFNDATPER DS    0H                                                 GS54\n         MVI   GETCK2,C'F'         Set GETCK2 to F for %          GS54\n         B     CONTMOVE                                           GS54\n         SPACE ,                                                  GS54\nFOUNDAT  DS    0H                                                 GS54\n         MVI   GETID2,C'F'         Set GETID2 to F for &          GS54\nCONTMOVE DS    0H                                                 GS54\n         LR    R3,R1               R1 has the address of the % or &\n         SR    R3,R7               Length not including percent to R3\n         LR    R2,R3               Save length\n         LA    R6,CMDGET           Load address of CMDGET\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command words till % or &\n         LA    R7,1(R2,R7)         Start of data after percent CMDTEXT\n         LA    R6,0(R2,R6)         Start of data before percent CMDGET\n         ST    R7,SAVER7           Save address of R7\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD             Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R7,CMDAT            Load R7 with CMDAT             GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET             Go move                        GS54\nSETWORD  DS    0H                                                 GS54\n         LA    R7,WORDGET          Load R7 with get word\n         L     R3,WORDLGET         Load the length get word\nMOVEGET  DS    0H                                                 GS54\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         CLI   GETCK2,C'F'         Was it a %                     GS54\n         BE    SETWORD2            Yup, go set word               GS54\n*                                  else set &                     GS54\n         LA    R3,L'CMDAT          Load the length CMDAT          GS54\n         B     MOVEGET2            Go move                        GS54\nSETWORD2 DS    0H                                                 GS54\n         L     R3,WORDLGET         Load the length get word       GS54\nMOVEGET2 DS    0H                                                 GS54\n         LA    R6,0(R3,R6)         Add length of get word to CMDGET\n         L     R7,SAVER7           Start of data after percent CMDTEXT\n         LA    R3,CMDGET           Load address of CMDGET to R3\n         LA    R3,L'CMDGET(R3)     Add length of CMDGET to R3\n         SR    R3,R6               Get ready to move the rest\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         MVC   CMDTEXT,CMDGET      Move get command to command\n         MVI   GETCK2,X'40'        Set switch to blank            GS54\n         MVI   GETID2,X'40'        Set switch to blank            GS54\n         B     GETRPLAC            Continue checking for & and %  GS54\n         SPACE ,\n**********************************************************************\n*        IF WORD ## LOGIC                                            *\n**********************************************************************\nWORDPARS DS    0H\n         LA    R8,CKPWORD          Load address CKPWORD           GS52\n         LA    R2,STRTWORD         Load address of                GS52\n         LA    R6,STWORDNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSTWORDNO DS    0H\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         BR    R9                  Return\n         SPACE ,\nSTRTWORD DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         MVC   TESTNN,=C'00'       Move for test for not numeric\n         MVZ   TESTNN,CMDTEXT+8    Move for test for not numeric\n         CLC   TESTNN,=C'00'       Test for not numeric\n         BNE   NOTNUMW             Not numeric go tell em\n         PACK  WORDNP,CMDTEXT+8(2) Pack it baby\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM blank           GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST4    SRST  R1,R7               SEARCH STRING FOR DELIM blank   GG58\n         BO    SRST4               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FWRDSPC             BLANK FOUND - BRANCH            GG58\n         LA    R7,CMDTEXT+11       Start of CMDTEXT past IF WORD ##\n         LA    R8,L'CMDTEXT-11     Length of CMDTEXT minus IF WORD ##\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX5C          LOAD SCAN DELIM *               GG58\nSRST5    SRST  R1,R7               SEARCH STRING FOR DELIM *       GG58\n         BO    SRST5               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FOUNDAST            * FOUND - BRANCH                GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFOUNDAST DS    0H\n         MVI   IFWORD,C'A'         Set switch to A\n         B     FNDWRD\n         SPACE ,\nFWRDSPC  DS    0H\n         MVI   IFWORD,C'S'         Set switch to S\nFNDWRD   DS    0H\n         LR    R3,R1               R1 has the address of the space or *\n         SR    R3,R7               Length not including space/* to R3\n         ST    R3,WORDLCMD         Store the length to WORDLCMD\n         MVI   WORDCMD,C' '                     Initial\n         MVC   WORDCMD+1(L'WORDCMD-1),WORDCMD   Blank out\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDCMD          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command word\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\nCKTRTWRD DS    0H\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST6    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST6               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSWR             BLANK FOUND - BRANCH            GG58\n         MVI   IFWORD,C'N'         Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSWR  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         CP    MSGCNT,WORDNP       Is this the word\n         BNE   BMPWRD              No get next word\n         ST    R3,WORDLMSG         Store the length to WORDLMSG\n         LA    R6,WORDMSG          Load address of\n         CLI   IFWORD,C'A'         WILDCARD * ?\n         BE    ASTERWRD            Yup load length of command\n         DS    0H                  Else\n         L     R3,WORDLMSG         Load the length from WORDLMSG to R3\n         B     CKWRD               Go check word\n         SPACE ,\nASTERWRD DS    0H\n         L     R3,WORDLCMD         Load the length from WORDLCMD to R3\nCKWRD    DS    0H\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         LA    R6,WORDCMD          Load address of\n         CLC   WORDMSG,WORDCMD     Compare message and command word\n         BE    FWRDMAT             Found message match\n         MVI   IFWORD,C'N'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nBMPWRD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length to R8\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         SPACE ,\nBMPWRD1  DS    0H\n         CLI   0(R7),C' '          Char blank                     PJ02\n         BNE   CKTRTWRD            Continue scanning message      PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPWRD1          Check next char                PJ02\n         MVI   IFWORD,C'N'         Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFWRDMAT  DS    0H                  Message match\n         MVI   IFWORD,C'Y'         Set switch to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID PLUS FOR LOGIC                                     *\n**********************************************************************\nMSGIDPLN DS    0H                                                 GS56\n         MVI   MSGPLNE,C'Y'        Set MSGPLNE to Y               GS56\n         LA    R8,CKPMSGPN         Load address CKPMSGPN          GS56\n         LA    R2,MSGPLUS          Load address of                GS56\n         LA    R6,MSGIDPNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDPLU DS    0H                                                 GS51\n         LA    R8,CKPMSGPL         Load address CKPMSGPL          GS52\n         LA    R2,MSGPLUS          Load address of                GS52\n         LA    R6,MSGIDPNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGIDPNO DS    0H                                                 GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL              no must be IFMSGPL            GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL  DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set IFMSGPL to N               GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\nMSGPLUS  DS    0H                                                 GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+9    Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         MVC   TESTNN,=C'00'       Move for test for not numeric  GS51\n         MVZ   TESTNN,CMDTEXT+16   Move for test for not numeric  GS51\n         CLC   TESTNN,=C'00'       Test for not numeric           GS51\n         BNE   NOTNUMP             Not numeric go tell em         GS51\n         PACK  MSGNP,CMDTEXT+9(2)  Pack it baby                   GS51\n         LA    R2,MSGTXT           Start of message               GS51\n         CVB   R15,MSGNP           Convert to binary              GS51\n         AR    R2,R15              Add msg plus to start          GS51\n         LA    R15,CMDTEXT+19      Point to characters            GS51\n         PACK  MSGNP,CMDTEXT+16(2) Pack it baby                   GS51\n         CVB   R3,MSGNP            Convert to binary              GS51\n         BCTR  R3,0                Decrement length for execute   GS51\n         EX    R3,COMP             Compare                        GS51\n         BE    FOUNDPL             Yup, go set switch             GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL2             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'Y'       Set IFMSGPLN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL2 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'N'        Set switch to N                GS51\n         BR    R9                  Return                         GS51\nFOUNDPL  DS    0H                  Message match                  GS51\n         CLI   MSGPLNE,C'Y'        Is MSGPLNE Y                   GS56\n         BNE   NEMSGPL3             no must be IFMSGPLN           GS56\n         MVI   IFMSGPLN,C'N'       Set IFMSGPLN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGPL3 DS    0H                                                 GS56\n         MVI   IFMSGPL,C'Y'        Set switch to Y                GS51\n         BR    R9                  Return                         GS51\n         SPACE ,                                                  GS51\n**********************************************************************\n*        IF ALL EQ LOGIC                                             *\n**********************************************************************\nPARSEROU DS    0H\n         LA    R8,CKPARSE          Load address CKPARSE           GS52\n         LA    R2,PARBEGIN         Load address of                GS52\n         LA    R6,PARBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nPARBEGNO DS    0H\n         MVI   IFPARSE,C'N'        Set IFPARSE to N\n         BR    R9                  Return\n         SPACE ,\nPARBEGIN DS    0H\n         SP    MSGCNT,MSGCNT       Clear out MSGCNT\n         SP    CMDCNT,CMDCNT       Clear out CMDCNT\n         MVI   CMDTABLE,C' '                       Initial\n         MVC   CMDTABLE+1(L'CMDTABLE-1),CMDTABLE   Blank out\n         LA    R6,CMDTABLE         Get address of CMDTABLE\n         LA    R7,CMDTEXT+10       Start of CMDTEXT past IF ALL EQ\n         LA    R8,L'CMDTEXT-10     Length of CMDTEXT minus IF ALL EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTCMD DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST7    SRST  R1,R7               SEARCH STRING FOR DELIM blank   GG58\n         BO    SRST7               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FCMDSPC             BLANK FOUND - BRANCH            GG58\n         B     MARKEND             Go MARKEND we should never be here\n         SPACE ,\nFCMDSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move command get word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\n         AP    CMDCNT,=P'1'        Add 1 to CMDCNT\n         CP    CMDCNT,=P'4'        Max of 4 words\n         BE    MARKEND             Yup bye\n         CLI   0(R7),X'40'         Is next after the space a space\n         BNE   CKTRTCMD            Continue scanning input\nMARKEND  DS    0H\n         MVI   0(R6),X'FF'         Put end of CMDS\n**********************************************************************\n*        IF ALL COMPARE TO MESSAGE LOGIC                             *\n**********************************************************************\n         LA    R7,MSGTXT           Start of message\n         LH    R8,MSGLEN           Length of message              PJ01\n         LA    R8,2(,R8)           2 extra chars for TRT          PJ01\n*                                   since cc =1 is only           PJ01\n*                                   support in coding.            PJ01\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\nCKTRTMSG DS    0H\n         BCTR  R8,0                Decrement length                GG58\nSRST8    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST8               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGSPC             BLANK FOUND - BRANCH            GG58\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\nFMSGSPC  DS    0H\n         LR    R3,R1               R1 has the address of the space\n         CR    R7,R3               End of data\n         BE    IFPARNO             Yup bye bye\n         SR    R3,R7               Length not including space to R3\n         ST    R3,PARSLCMD         Store the length to PARSLCMD\n         MVI   WORDMSG,C' '                     Initial\n         MVC   WORDMSG+1(L'WORDMSG-1),WORDMSG   Blank out\n         LA    R6,WORDMSG          Load address of\n         BCTR  R3,0                Subtract 1 from length for exec move\n         EX    R3,MOVEIT           Move message word\n         L     R3,PARSLCMD         Load the length from PARSLCMD to R3\n         LA    R6,CMDTABLE         Get address of CMDTABLE\nCKWORD   DS    0H\n         CLC   0(L'WORDMSG,R6),WORDMSG   Check MSG = CMDTABLE\n         BE    FMSGMAT             Found message match\n         LA    R6,L'WORDMSG(R6)    Bump up to next\n         CLI   0(R6),X'FF'         End of CMDS table\n         BNE   CKWORD              Get next word from CMDTABLE\nBMPADD   DS    0H\n         LA    R7,1(R3,R7)         Start of data after space\n         SR    R8,R3               Remaining length\nBMPADD1  DS    0H                                                 PJ02\n         CLI   0(R7),C' '          CHAR BLANK                     PJ02\n         BNE   CKTRTMSG            NO CONTINUE SCAN               PJ02\n         LA    R7,1(,R7)           Start of data after space      PJ02\n         BCT   R8,BMPADD1          Check next char                PJ02\n         MVI   IFPARSE,C'N'        Set switch to N                PJ02\n         BR    R9                  Return                         PJ02\n         SPACE ,\nFMSGMAT  DS    0H                  Message match\n         AP    MSGCNT,=P'1'        Add 1 to MSGCNT\n         CP    MSGCNT,CMDCNT       Compare MSGCNT to CMTCNT\n         BL    BMPADD              Not all there yet\n         MVI   IFPARSE,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nIFPARNO  DS    0H\n         MVI   IFPARSE,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF MSGID EQ FOR LONG MESSAGEIDS                             *\n**********************************************************************\nMSGIDRNE DS    0H\n         MVI   MSGIDNE,C'Y'        Set MSGIDNE to Y               GS56\n         LA    R8,CKMSGIDN         Load address CKMSGIDN          GS56\n         LA    R2,MSGBEGIN         Load address of                GS56\n         LA    R6,MSGBEGNO         Load address of                GS56\n         B     MOVEGO              Go check for no's              GS56\n*                                   and place address for GOTABLE GS56\nMSGIDROU DS    0H\n         LA    R8,CKPMSGID         Load address CKPMSGID          GS52\n         LA    R2,MSGBEGIN         Load address of                GS52\n         LA    R6,MSGBEGNO         Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nMSGBEGNO DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID              no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID  DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set IFMSGID to N\n         BR    R9                  Return\n         SPACE ,\nMSGBEGIN DS    0H\n         LA    R7,CMDTEXT+12       Start of CMDTEXT past IF MSGID EQ\n         LA    R8,L'CMDTEXT-12     Length of CMDTEXT minus IF MSGID EQ\n         LA    R1,0(R8,R7)         @ PAST END OF STRING            GG58\n         L     R0,SCANX40          LOAD SCAN DELIM                 GG58\n         BCTR  R8,0                Decrement length                GG58\nSRST9    SRST  R1,R7               SEARCH STRING FOR DELIM         GG58\n         BO    SRST9               SRST INCOMPLETE - RESUME INSTR  GG58\n         BL    FMSGID              BLANK FOUND - BRANCH            GG58\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  We should never be here\n         SPACE ,\nFMSGID   DS    0H\n         LR    R3,R1               R1 has the address of the space\n         SR    R3,R7               Length not including space to R3\n         LA    R15,CMDTEXT+12      Point to characters\n         LA    R2,MSGTXT           Point to characters\n         BCTR  R3,0                Decrement length for execute\n         EX    R3,COMP             Compare\n         BNE   NOMATCH             No seeya\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NEMSGID2             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'N'       Set IFMSGIDN to N              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNEMSGID2 DS    0H                                                 GS56\n         MVI   IFMSGID,C'Y'        Set switch to Y\n         BR    R9                  Return\n         SPACE ,\nNOMATCH  DS    0H\n         CLI   MSGIDNE,C'Y'        Is MSGIDNE Y                   GS56\n         BNE   NOMTCHID             no must be IFMSGID            GS56\n         MVI   IFMSGIDN,C'Y'       Set IFMSGIDN to Y              GS56\n         BR    R9                  Return                         GS56\n         SPACE ,                                                  GS56\nNOMTCHID DS    0H                                                 GS56\n         MVI   IFMSGID,C'N'        Set switch to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH OFF                                               *\n**********************************************************************\nSWTCHOFF DS    0H\n         LA    R8,CKPSWOFF         Load address CKPSWOFF          GS52\n         LA    R2,SWOFFYES         Load address of                GS52\n         LA    R6,SWOFFNO          Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWOFFNO  DS    0H\n         MVI   IFSWOFF,C'N'        Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWOFFYES DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+14      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWOFF,C'N'        Set switch OFF to N\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWOFF,C'Y'        Set switch OFF to Y\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH ON                                                *\n**********************************************************************\nSWTCHON  DS    0H\n         LA    R8,CKPSWON          Load address CKPSWON           GS52\n         LA    R2,SWONYES          Load address of                GS52\n         LA    R6,SWONNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWONNO   DS    0H\n         MVI   IFSWON,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWONYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         MVI   IFSWON,C'Y'         Set switch ON to Y\n         BR    R9                  Return\n         ENDIF\n         MVI   IFSWON,C'N'         Set switch ON to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH EQ                                                *\n**********************************************************************\nSWTCHEQ  DS    0H\n         LA    R8,CKPSWEQ          Load address CKPSWEQ           GS52\n         LA    R2,SWEQYES          Load address of                GS52\n         LA    R6,SWEQNO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWEQNO   DS    0H\n         MVI   IFSWEQ,C'N'         Set IFSWOFF to N\n         BR    R9                  Return\n         SPACE ,\nSWEQYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         MVI   TOKENSW,C' '                       Initial\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22          Do tokens match\n         BNE   SETEQNO                     No\n         MVI   IFSWEQ,C'Y'                 Set switch EQ to Y\n         BR    R9                  Return\n         SPACE ,\nSETEQNO  DS    0H\n         MVI   IFSWEQ,C'N'         Set switch EQ to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        IF SWITCH NE                                                *\n**********************************************************************\nSWTCHNE  DS    0H\n         LA    R8,CKPSWNE          Load address CKPSWNE           GS52\n         LA    R2,SWNEYES          Load address of                GS52\n         LA    R6,SWNENO           Load address of                GS52\n         B     MOVEGO              Go check for no's              GS52\n*                                   and place address for GOTABLE GS52\nSWNENO   DS    0H\n         MVI   IFSWNE,C'N'         Set IFSWNE to N\n         BR    R9                  Return\n         SPACE ,\nSWNEYES  DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+13      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         CLC   TOKENSW,CMDTEXT+22  Do tokens match\n         BE    SETNENO             Yes\n         MVI   IFSWNE,C'Y'         Set switch NE to Y\n         BR    R9                  Return\n         SPACE ,\nSETNENO  DS    0H\n         MVI   IFSWNE,C'N'         Set switch NE to N\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        SET SWITCH                                                  *\n**********************************************************************\nSETSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Check if Name/Token exists\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n         WTO   'MPF020E - Switch error already exists not created',    X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))\n         WTO   'MPF022E - Switch error not created',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         ENDIF\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        PUT SWITCH                                                  *\n**********************************************************************\nPUTSWTCH DS    0H                                                 GS55\n         MVC   NAMESW(16),MPFEYE           First part of name     GS55\n         MVC   NAMESW+6(8),CMDTEXT+10 Move in second part of name GS55\n         MVI   TOKENSW,C' '                       Initial         GS55\n         MVC   TOKENSW+1(L'TOKENSW-1),TOKENSW     Blank out       GS55\n         LA    R7,NAMESW                   Load address of name   GS55\n         LA    R3,TOKENSW                  Load address of token  GS55\n         LA    R2,RETCODE             Load address of return code GS55\n*                                     Check if Name/Token exists  GS55\n         CALL  IEANTRT,(SYSLVL,(R7),(R3),(R2)),MF=(E,RENTCALR)    GS55\n         IF    (RETCODE,EQ,=A(IEANT_NOT_FOUND))                   GS55\n         WTO   'MPF035E - Name/Token not found error for PUTSWITCH',   X\n               DESC=(2),ROUTCDE=(1)                               GS55\n         B     MPF008R9            Return                         GS55\n         ENDIF                                                    GS55\n         MVI   CMDTEXT,C' '                    Initial            GS55\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT  Blank out          GS55\n         MVC   CMDTEXT(16),TOKENSW         Move in TOKEN for put  GS55\n         B     CONT_TYP                    Go put                 GS55\n         SPACE ,                                                  GS55\n**********************************************************************\n*        ALTER SWITCH                                                *\n**********************************************************************\nALTSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         MVC   TOKENSW(16),CMDTEXT+19      Move in token\n         LA    R7,NAMESW                   Load address of name\n         LA    R3,TOKENSW                  Load address of token\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         IF   (RETCODE,EQ,=A(IEANT_OK))\n*                                          Create Name/Token\n         CALL  IEANTCR,(SYSLVL,(R7),(R3),PERSOPT,(R2)),MF=(E,RENTCALC)\n         BR    R9                  Return\n         ENDIF\n         WTO   'MPF027E - Switch error not altered',                   X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\n*        DELETE SWITCH                                               *\n**********************************************************************\nDELSWTCH DS    0H\n         MVC   NAMESW(16),MPFEYE           First part of name\n         MVC   NAMESW+6(8),CMDTEXT+10      Move in second part of name\n         LA    R7,NAMESW                   Load address of name\n         LA    R2,RETCODE                  Load address of return code\n*                                          Delete Name/Token\n         CALL  IEANTDL,(SYSLVL,(R7),(R2)),MF=(E,RENTCALD)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        WTOR ROUTINE                                                *\n**********************************************************************\nMPFWTOR  DS    0H\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR\n         BNO   NOTWTOR                    No you messed up\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    Move in reply\n         MVC   MGCRTEXT+6(L'CTXTRPID),CTXTRPID  Move in reply number\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address\n         STC   R3,MGCRLGTH                Set the length of the reply\n         XR    R0,R0                      Clear R0 for MGCR/SVC 34\n         MGCR  MGCRPL                     Reply to WTOR\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP2            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7\nAFTDISP2 DS    0H\n         BR    R9                         Return\nMPFWTORX DS    0H                                                 DT03\n         TM    CTXTTFB1,CTXTTFWR          Is this a WTOR          DT03\n         BNO   NOTWTOR                    No you messed up        DT03\n         XC    MGCRPL(MGCRSIZ),MGCRPL     Clear the MGCR area     DT03\n         MVC   MGCRTEXT(L'CMDTEXT),CMDTEXT    MOVE IN REPLY       DT03\n         MVC   MGCRTEXT+6(4),=C'    '     CLEAR NNNN              DT03\n         LH    R3,CTXTRPYL                LOAD LENGTH OF REPLY    DT03\n         BCTR  R3,0                       DECREMENT FOR MOVE      DT03\n         CH    R3,=H'2'                   WHAT LENGTH to move?    DT03\n         BE    MRPID3                     =2 MOVE 3               DT03\n         BH    MRPID4                     >2 MOVE 4               DT03\n         EX    R3,MOVERI2                 MOVE 2                  DT03\n         B     MPFW00                                             DT03\nMRPID4   EX    R3,MOVERI4                 MOVE 4                  DT03\n         B     MPFW00                                             DT03\nMRPID3   EX    R3,MOVERI3                 MOVE 3                  DT03\nMPFW00   DS    0H                                                 DT03\n         LA    R3,(MGCRTEXT-MGCRPL)+L'CMDTEXT     Load address    DT03\n         STC   R3,MGCRLGTH             Set the length of the rep  DT03\n         XR    R0,R0                   Clear R0 for MGCR/SVC 34   DT03\n         MGCR  MGCRPL                     Reply to WTOR           DT03\n         CLC   CTXTAUTT,=CL8'NODISPLY' No /* MPFXTALL */ request  GS57\n         BE    AFTDISP3            yes skip display               GS57\n         WTO   MF=(E,WTOM),ROUTCDE=11,DESC=7                      DT03\nAFTDISP3 DS    0H\n         BR    R9                         Return\n         SPACE ,\n**********************************************************************\n*        WTO ROUTINES                                                *\n**********************************************************************\nWTOROUT  DS    0H\n         MVC   WTOAMSG(53),CMDTEXT+4   Move message to WTO\n         WTO   MF=(E,WTOA)\n         BR    R9                  Return\n         SPACE ,\nWTOHIGH  DS    0H\n         MVC   WTOBMSG(53),CMDTEXT+5   Move message to WTO\n         WTO   MF=(E,WTOB)\n         BR    R9                  Return\n         SPACE ,\n**********************************************************************\n*        ERROR MESSAGE ROUTINES                                      *\n**********************************************************************\nMPF008R  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     RETURN              Bye\n**********************************************************************\nMPF008F  DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         B     FREEMEM             Bye\n**********************************************************************\nMPF008R9 DS    0H\n         WTO   'MPF008E - Notify MPFXTALL Support',                    X\n               DESC=(2),ROUTCDE=(1)\n         BR    R9                  Return\n**********************************************************************\nNOTWTOR  DS    0H\n         WTO   'MPF012E - Message not a WTPR - reply not issued',DESC=2X\n               ,ROUTCDE=(1)\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nNOTREPLY DS    0H\n         WTO   'MPF036E - Message not a WTOR GET REPLYID not performed'X\n               ,DESC=(2),ROUTCDE=(1)\n         MVI   GETID,C'N'          Set switch to N                GS54\n         B     MPF008R9            Return\n         SPACE ,\n**********************************************************************\nLOADERR  DS    0H\n         WTO   'MPF014E - MPFLOAD is running',DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nNOTNUMW  DS    0H\n         WTO   'MPF025E - IF WORD Not Numeric Error',                  X\n               DESC=(2),ROUTCDE=(1)\n         MVI   IFWORD,C'N'         Set IFWORD to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMG  DS    0H\n         WTO   'MPF026E - GET WORD Not Numeric Error',                 X\n               DESC=(2),ROUTCDE=(1)\n         MVI   GETCK,C'N'          Set GETCH to N\n         B     MPF008R9\n         SPACE ,\n**********************************************************************\nNOTNUMP  DS    0H                                                 GS51\n         WTO   'MPF028E - Message ID Plus Not Numeric Error',     GS51 X\n               DESC=(2),ROUTCDE=(1)                               GS51\n         MVI   IFMSGPL,C'N'          Set IFMSGPL to N             GS51\n         B     MPF008R9                                           GS51\n         SPACE ,                                                  GS51\n**********************************************************************\nNOTASTYP DS    0H                                                 GG58\n         WTO   'MPF062E - IF ASTYPE EQ value invalid',            GG58 X\n               DESC=(2),ROUTCDE=(1)                               GG58\n         B     MPF008R9                                           GG58\n         SPACE ,                                                  GG58\n**********************************************************************\nERROREND DS    0H                                                 GS52\n         WTO   'MPF037E - Commands member coding error ENDIF',    GS52 X\n               DESC=(2),ROUTCDE=(1)                               GS52\n         B     MPF008R9                                           GS52\n         SPACE ,                                                  GS52\n**********************************************************************\nERRORIFL DS    0H                                                 GS54\n         WTO   'MPF033E - Commands member coding IFLOGIC error',  GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nERRORGET DS    0H                                                 GS54\n         WTO   'MPF034E - Commands member coding error ENDGET',   GS54 X\n               DESC=(2),ROUTCDE=(1)                               GS54\n         B     MPF008R9                                           GS54\n         SPACE ,                                                  GS54\n**********************************************************************\nNOMPFMS  DS    0H\n         WTO   'MPF019E - MPF Message use not allowed',                X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n         SPACE ,\n**********************************************************************\nMSNOTFND DS    0H\n         WTO   'MPF013E - Message ID not found in table',              X\n               DESC=(2),ROUTCDE=(1)\n         B     MPF008F\n**********************************************************************\n*        FREE MEMORY ROUTINE                                         *\n**********************************************************************\nFREEMEM  DS    0H\n         LA    R2,WORKAREA\n         LA    R1,WORKSIZE\n         FREEMAIN R,LV=(R1),A=(R2),SP=230\n         LTR   R15,R15             Test freemain\n         BZ    RETURN              Ok bye\n         WTO   'MPF030E - FREEMAIN ERROR',DESC=(2),ROUTCDE=(1)\n         B     MPF008R\n         EJECT\n**********************************************************************\n*        ESTAE RECOVERY ROUTINE                                  GG59*\n**********************************************************************\n\nESTAERC  DS    0H                  ESTAE RECOVERY ROUTINE        GG59\n         PUSH  USING               SAVE MAINLINE USING STATE     GG59\n         DROP  R11,R12             DON'T USE MAINLINE USING      GG59\n         LR    R12,R15             COPY ESTAE REC RTN EPA TO BASEGG59\n         USING ESTAERC,R12         MAP CODE PAGE FOR ESTAE RECRTNGG59\n         C     R0,=F'12'           Q. SDWA EXIST                 GG59\n         BE    NOSDWA              A. BATMAN - THIS IS SERIOUS   GG59\n         LR    R2,R1               COPY @ SDWA                   GG59\n         USING SDWA,R2             MAP SDWA                      GG59\n         SETRP RETADDR=WTOABEND,   PREPARE TO RETURN FROM ESTAE  GG59  *\n               DUMP=NO,            RECOVERY RTN - NO DUMP REQ'D  GG59  *\n               RC=4,               WE WILL RETRY                 GG59  *\n               FRESDWA=YES,        WE WILL FREE THE SDWA STORAGE GG59  *\n               WKAREA=(R2),        SDWA @ BY R2                  GG59  *\n               RECORD=YES,         RECORD ERROR TO LOGREC        GG59  *\n               RETREGS=YES         RESTORE REGISTERS AT ENTRY TO GG59\n*                                  RETRY ROUTINE                 GG59\n         BR    R14                 RETURN FROM ESTAE RECOVERY RTNGG59\n\nNOSDWA   DS    0H                  NO SDWA - THIS IS BAD BATMAN  GG59\n         LA    R15,4               REQUEST RETRY (HOLY DREAMING) GG59\n         LA    R0,WTOABEND         SPECIFY ADDRESS OF RETRY RTN  GG59\n         BR    R14                 RETURN FROM ESTAE RECOVERY RTNGG59\n         POP   USING               RESTORE MAINLINE USING ENVIR. GG59\n\n**********************************************************************\n*        ESTAE RETRY ROUTINE                                     GG59*\n**********************************************************************\n\nWTOABEND DS    0H                  ESTAE RETRY ROUTINE           GG59\n         WTO   'MPF038E MPFXTALL ABENDED; ABEND WAS SUPPRESSED', GG59  *\n               ROUTCDE=1,          MPF0 WTO's are not allowed to GG59  *\n               DESC=2              be captured - this WTO must   GG59\n*                                  NOT be captured by MPFXTALL   GG59\n         B     FREEMEM             GOTO FREE MEMORY AND RETURN   GG59\n         EJECT\n**********************************************************************\n*        END OF PROCESSING                                           *\n**********************************************************************\nRETURN   DS    0H\n         ESTAEX 0                  Delete MPFXTALL ESTAE         GG59\n         PR                        Pop the stack\n**********************************************************************\n*        EXECUTES                                                    *\n**********************************************************************\nMOVERI2  MVC   MGCRTEXT+8(0),CTXTRPYI                             DT03\nMOVERI3  MVC   MGCRTEXT+7(0),CTXTRPYI                             DT03\nMOVERI4  MVC   MGCRTEXT+6(0),CTXTRPYI                             DT03\n**********************************************************************\nMVMBR    MVC  MEMN(0),MSGTXT       Move message id to member name\n**********************************************************************\nMVMBR2   MVC  CMDMBR(0),MSGTXT     Move message ID to issued by   TL01\n**********************************************************************\nMOVEIT   MVC  0(1,R6),0(R7)\n**********************************************************************\nSAVEMINR MVC  1(1,R3),CTXTTMSG     Move in message text           PJ01\n**********************************************************************\nCOMP     CLC 0(1,R2),0(R15)                                       GS51\n**********************************************************************\n*        CONSTANT DATA                                               *\n**********************************************************************\nSYSLVL   DC    A(IEANT_SYSTEM_LEVEL)\nNAME     DC    CL16'MPF_EXIT_TABLE'     The name of the token\nPERSOPT  DC    A(IEANT_PERSIST)         Keep the token after job ends\nMPFEYE   DC    CL16'MPFXT_          '   First part of switch name\n*\nSCANX40  DC    A(C' ')                                             GG58\nSCANX50  DC    A(C'&&')                                            GG58\nSCANX5C  DC    A(C'*')                                             GG58\nSCANX6C  DC    A(C'%')                                             GG58\n         CNOP  0,4\n         SPACE 2\n         LTORG\n         EJECT\n**********************************************************************\n*        VARIABLE DATA. NOTE THAT THIS DATA IS COPIED TO A WORK AREA *\n*        AND UPDATED THERE                                           *\n**********************************************************************\n         SPACE 2\nPSETAREA DS    0D                  Preset MGCR work area\nSAVEAREX DS    18F                 SAVEAREA\nSSCMD    DC    AL2(SCMDLN)\n         DC    XL2'00'\n         DC    CL80' '\nSCMDLN   EQU   *-SSCMD\n*\nWTOMX    DC    0F\n         DC    AL2(WTOMEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nMSGENDX  DC    C' /* Issued by MPFXTALL for                  */'\nWTOMEX   EQU   *-WTOMX\n*\nWTOAX    DC    0F\n         DC    AL2(WTOAEX)              Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAEX   EQU   *-WTOAX\n*\n         DS    0H\n*\nWTOBX    DC    0F\n         DC    AL2(WTOBEX-4)            Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSGX DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBEX   EQU   *-WTOBX\n*\nCMDCNTX  DC    PL2'0'              Counters\nMSGCNTX  DC    PL2'0'              Counters\nWORDNPX  DC    PL2'0'              Counters\nGOCNTRX  DC    PL8'0'              Counters                      GS52\n*\nPSETSIZE EQU   *-PSETAREA          Size of the variable Work Area\n         EJECT\n**********************************************************************\n*        GETMAIN WORK AREA                                           *\n**********************************************************************\nWORKAREA DSECT                     Preset work area\n         DS    0D\nSAVEAREA DS    18F                 SAVEAREA\nCMDHDR   DC    XL2'20'\n         DC    XL2'00'\nCMDTEXT  DC    CL80' '\n*\nWTOM     DC    0F\n         DC    AL2(WTOME)               Text length\n         DC    B'0000000000000000'      MCSFLAGS\nCMDDESC  DC    C' /* Issued by MPFXTALL for '\nCMDMBR   DC    C'                 */'                              TL01\nWTOME    EQU   *-WTOM\n*\nWTOA     DS    0F\n         DC    AL2(WTOAE-4)             Text length\n         DC    B'0000000000000000'      MCSFLAGS\nWTOAMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\nWTOAE    EQU   *-WTOA                   LENGTH OF\n*\nWTOB     DS    0F\n         DC    AL2(WTOBE-4)             Text length\n         DC    B'1000000000000000'      MCSFLAGS\nWTOBMSG  DC    C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'\n         DC    B'0100000000000000'      Descriptor Codes\n         DC    B'1000000000000000'      Routing Codes\nWTOBE    EQU   *-WTOB                   Length of\n*\nCMDCNT   DC    PL2'0'              Counters\nMSGCNT   DC    PL2'0'              Counters\nWORDNP   DC    PL2'0'              Counters\nGOCNTR   DC    PL8'0'              Counters                      GS52\n\n**********************************************************************\n* END OF SEEDED STORAGE                                              *\n**********************************************************************\n         DS    0F                  Alignment\n*\nMSGNP    DS    D                                                 GS51\n*\nGOTABLE  DS    F                                                 GS52\nGO0ST    DS    F                                                 GS52\nGO1ST    DS    F                                                 GS52\nGO2ND    DS    F                                                 GS52\nGO3RD    DS    F                                                 GS52\nGO4TH    DS    F                                                 GS52\nGO5TH    DS    F                                                 GS52\nGO6TH    DS    F                                                 GS52\nGO7TH    DS    F                                                 GS52\nGO8TH    DS    F                                                 GS52\nGO9TH    DS    F                                                 GS52\nGOATH    DS    F                                                 GS52\nGOBTH    DS    F                                                 GS52\nGOCTH    DS    F                                                 GS52\nGODTH    DS    F                                                 GS52\nGOETH    DS    F                                                 GS52\nGOFTH    DS    F                                                 GS52\n*\nMEMN     DS    CL8                 Member name\n*\nIFSYSID  DS    CL1                 SYSID check\n*\nIFASTYP  DS    CL1                 ADDRESS SPACE check            GG58\n*\nIFPARSE  DS    CL1                 PARSE check\n*\nIFWORD   DS    CL1                 WORD check\n*\nGETCK    DS    CL1                 GET WORD check\n*\nGETCK2   DS    CL1                 GET REPLY ID  2nd check        GS54\n*\nGETID    DS    CL1                 GET REPLY ID check             GS54\n*\nGETID2   DS    CL1                 GET REPLY ID 2nd check         GS54\n*\nIFMSGID  DS    CL1                 IF MSGID check\n*\nIFMSGIDN DS    CL1                 IF MSGID NE check              GS56\n*\nMSGIDNE  DS    CL1                 IF MSGID NE switch             GS56\n*\nIFMSGPL  DS    CL1                 IF MSGID PLUS check\n*\nIFMSGPLN DS    CL1                 IF MSGID NE PLUS check         GS56\n*\nMSGPLNE  DS    CL1                 IF MSGID PLUS NE switch        GS56\n*\nIFSWEQ   DS    CL1                 IF SWTCH EQ check\n*\nIFSWNE   DS    CL1                 IF SWTCH NE check\n*\nIFSWON   DS    CL1                 IF SWTCH ON check\n*\nIFSWOFF  DS    CL1                 IF SWTCH OFF check\n*\n         DS    0F                  Alignment\n*\nSEQNO    DS    F                   Message sequence number        PJ01\n*\nMINORWAD DS    F                   Minor lines work area          PJ01\n*\nWORDLCMD DS    F                   Length of CMD word\n*\nPARSLCMD DS    F                   Length of PARSE word\n*\nWORDLMSG DS    F                   Length of MSG word\n*\nWORDLGET DS    F                   Length of GET word\n*\nSAVER7   DS    F                   Address of R7\n*\nENDTABLE DS    F                   Address for end of table\n*\nCMDTABLE DS    CL100               Commands table\n*\nWORDCMD  DS    CL25                Save for CMD word\n*\nWORDMSG  DS    CL25                Save for MSG word\n*\nWORDGET  DS    CL44                Save for GET word              PJ03\n*\nCMDGET   DS    CL80                Save area for GET command\n*\nCMDGETID DS    CL80                Save area for GET ID command\n*\nCMDAT    DS    CL2                 Save area for REPLY ID         GS54\n*\n         DS    0F                  Alignment\n*\nMSGLEN   DS    Y                   Line 1 message length          PJ01\n*\n         DS    0F                  Alignment\n*\nMSGTXT   DS    CL253               Message text     length change PJ01\n*\nCMDSID   DS    CL8                 Command SYSID\n*\nTESTNN   DS    CL2                 Test area for not numeric\n*\nTSORPLST DS    0F                  TSOROUTE PARAMETER LIST         GG58\n@CTXT    DS    F                     PARM 1 - @ CTXT               GG58\n@CMD     DS    F                     PARM 2 - @ MPFXTALL COMMAND   GG58\n*\n         DS    0D                  Alignment\nTOKENSW  DS    CL16                The token\nNAMESW   DS    CL16                The name of the token\nRENTCALR CALL  ,(SYSLVL,NAMESW,TOKENSW,RETCODE),MF=L\nRENTCALD CALL  ,(SYSLVL,NAMESW,RETCODE),MF=L\nRENTCALC CALL  ,(SYSLVL,NAMESW,TOKENSW,PERSOPT,RETCODE),MF=L\n*\n         DS    0D                  Alignment\nTOKEN    DC    XL16'00'            The token\n         ORG   TOKEN\nECSA_ADD DS    F                   ECSA address\nECSA_LEN DS    F                   Length of ECSA\n         ORG\nRETCODE  DC    F'0'                Return code from name token\n*\nRENTCALL CALL  ,(SYSLVL,NAME,TOKEN,RETCODE),MF=L\n*\nESTAELST ESTAEX ,MF=L             ESTAE MF=L                       GG59\n*\n         IEZMGCR DSECT=NO\n         ORG\n         DS    0D\nWORKSIZE EQU   *-WORKAREA          Size of the variable work area\n**********************************************************************\n         LTORG\nMINORWRK DSECT ,                                                  PJ01\nMINCHAIN DS    F                   Chain to Next Minor work area  PJ01\nMINSAVE  DS    F                   R13 Dynamic area pointer       PJ01\nMINSEQNO DS    F                   Message id for this work area  PJ01\nMINORSZ  EQU   *-MINORWRK          Length of minor work area      PJ01\n*        PRINT   GEN                                              GG58\n         PRINT   ON,NOGEN                                         GG58\n         IHAPSA  ,                 MAP PSA                        GG58\n         IHASDWA ,                 MAP SDWA                       GG59\n         IHAASCB ,                 MAP ASCB                       GG58\n         IEANTASM                  Name token service declares\n         IEZVX100\n         CVT     DSECT=YES         The CVT\n         END   MPFXTALL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PAUSE": {"ttr": 9480, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x07\\x03\\x0f\\x01\\x07\\x03\\x0f\\x12R\\x00H\\x00H\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-30T00:00:00", "modifydate": "2007-01-30T12:52:50", "lines": 72, "newlines": 72, "modlines": 0, "user": "GSI"}, "text": "//A EXEC ASMACL,PARM.C='OBJECT,NODECK,XREF',\n//         PARM.L='XREF,LET,LIST'\n//C.SYSIN DD *\n**************************************************************\n*    THIS ROUTINE READS IN THE PAUSE AMOUNT IN SECONDS AND   *\n*    WAITS FOR THAT AMOUNT OF TIME                           *\n*                -E.G.,-                                     *\n*  //A EXEC PGM=PAUSE,PARM='0010'                            *\n*                                                            *\n*    WILL PAUSE FOR 10 SECONDS  (MAX=9999 SECONDS)           *\n**************************************************************\nPAUSE    CSECT\n         LR    12,15\n         USING PAUSE,12\n         STM   R14,R12,12(R13)\n         ST    R13,SAVEAREA+4             CHAIN SAVEAREAS\n         LA    R2,SAVEAREA\n         ST    R2,8(R13)\n         LR    R13,R2\n*\n*  GET PAUSE TIME FROM PARM\n*\n         L     R2,0(R1)                  R2 = @PARM\n         LH    R3,0(R2)                  R3 = LENGTH OF PARM\n         BCTR  R3,0                            MINUS 1\n         LA    R2,2(R2)                  LEAP OVER LENGTH HALFWORD\n         EX    R3,MOVE                   MOVE PARM INTO HOLDING AREA\n*\n         PACK  PACKED,SECCHAR            TO DECIMAL\n         CVB   R5,SECPACK                TO BINARY\n         SR    R4,R4                     SET UP R4/R5 AS EVEN/ODD PAIR\n         M     R4,=F'100'                TO TENTHS OF SECONDS\n         ST    R5,SECONDS\n*\n*   NOW WAIT FOR THE SPECIFIED TIME TO EXPIRE\n*\n         STIMER WAIT,BINTVL=SECONDS\n         L     R13,SAVEAREA+4\n         SR    R15,R15\n         RETURN  (14,12),RC=(15)\n*\n*   CONSTANTS AND WORK AREAS\n*\n         DS    0D\nMOVE     MVC   CHAR(*-*),0(R2)\n         DS    0D\nSECCHAR  DC    CL8'00000000'\nCHAR     EQU   SECCHAR+4,4\n         DS    0D\nSECPACK  DC    XL4'00000000'\nPACKED   DS    XL4\nSECONDS  DS    F\n         DS    0D\nSAVEAREA DS    18F\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//L.SYSLMOD DD DSN=SYSP.LINKLIB(PAUSE),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSLOAD": {"ttr": 9483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PROC": {"ttr": 9486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x05\\x02\\x0f\\x01\\x06\\x11\\x1f!\\x19\\x00\\x04\\x00\\x07\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-01-20T00:00:00", "modifydate": "2006-04-21T21:19:02", "lines": 4, "newlines": 7, "modlines": 0, "user": "GSI"}, "text": "//MPFLOAD PROC\n//MPFLOAD EXEC PGM=MPFLOAD,TIME=1439,REGION=0M,\n// PARM='SYS1.MPF.COMMANDS'\n//* THIS DATASET MUST RESIDE IN IN THE MASTER CATALOG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REPLY": {"ttr": 9488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x06\\x14\\x1f\\x01\\x06\\x17_\\x11\\x03\\x00\\r\\x00\\r\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-05-21T00:00:00", "modifydate": "2006-06-24T11:03:29", "lines": 13, "newlines": 13, "modlines": 0, "user": "GSI"}, "text": "IF WORD 05 V8\nGET REPLYID\nDELSWITCH IDMSV8\nSETSWITCH IDMSV8   &,YES\nENDGET ID\nENDIF\n*\nIF WORD 05 V9\nGET REPLYID\nDELSWITCH IDMSV9\nSETSWITCH IDMSV9   &,YES\nENDGET ID\nENDIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHUTDOWN": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x07\\x03\\x0f\\x01\\x07\\x03\\x0f\\x13\\x07\\x00c\\x00f\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-01-30T00:00:00", "modifydate": "2007-01-30T13:07:34", "lines": 99, "newlines": 102, "modlines": 0, "user": "GSI"}, "text": "Since this is an automation package I thought I'd include my automated shutdown\n\nS SHUTDOWN\n\n//SHUTDOWN PROC\n//*\n//STEP01  EXEC PGM=ASKOPER,\n//     PARM=',,CONFIRM YOU WANT TO BRING THE SYSTEM DOWN(YES/NO)?'\n//*\n//* SHUTDOWN 1ST PART OF PRODUCTS\n//*\n//SHUTDOW1 EXEC PGM=IEBEDIT\n//SYSPRINT DD SYSOUT=Z\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,DSN=SYS1.PARMLIB(SHUTDOW1)\n//SYSUT2   DD SYSOUT=(Z,INTRDR)\n//*\n//* PAUSE 10 SECONDS\n//PAUSE  EXEC PGM=PAUSE,PARM='0010'\n//*\n//* SHUTDOWN BALANCE OF SOFTWARE\n//*\n//SHUTDOW2 EXEC PGM=IEBEDIT\n//SYSPRINT DD SYSOUT=Z\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,DSN=SYS1.PARMLIB(SHUTDOW2)\n//SYSUT2   DD SYSOUT=(Z,INTRDR)\n//*\n//* PAUSE 10 SECONDS\n//PAUSE  EXEC PGM=PAUSE,PARM='0010'\n//*\n//* SHUTDOWN BALANCE OF SOFTWARE\n//*\n//SHUTDOW2 EXEC PGM=IEBEDIT\n//SYSPRINT DD SYSOUT=Z\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,DSN=SYS1.PARMLIB(SHUTDOW3)\n//SYSUT2   DD SYSOUT=(Z,INTRDR)\n\nSYS1.PARMLIB(SHUTDOW1):\n/*$VS,'F CA7TEST,/LOGON GLENN'\n/*$VS,'= SHUTDOWN ALL'\n/*$VS,'P TSO'\n/*$VS,'F SEMAGENT,SHUTDOWN'\n/*$VS,'F MIMTAPE,SHUTDOWN FREE'\n/*$VS,'F MIMDASD,SHUTDOWN FREE'\n/*$VS,'F EMCSCF,INI,SHUTDOWN'\n/*$VS,'F JHSMAIN,Q'\n/*$VS,'P RMSCTLT'\n/*$VS,'P VTP'\n/*$VS,'P VTPTEST'\n/*$VS,'P ABNDTDCA'\n/*$VS,'P ABNDSRV2'\n/*$VS,'P ENF'\n/*$VS,'P RMF'\n/*$VS,'S STOPOM'\n/*$VS,'P VPS'\n/*$VS,'P VPSTEST'\n/*$VS,'S AD10STOP'\n/*$VS,'C FSS1'\n/*$VS,'C FSS2'\n/*$VS,'C FSS4'\n/*$VS,'P SYSVIEW'\n/*$VS,'P SYSVUSER'\n/*$VS,'P ETFA'\n/*$VS,'P DRS'\n/*$VS,'F GSSA,STOP'\n/*$VS,'F CMNP,SH,0'\n/*$VS,'F CHGMANT,SH,0'\n/*$VS,'P JHSMAIN'\n/*$VS,'P LRSSERV'\n/*$VS,'$PPRT1-1'\n/*$VS,'F SEMAGENT,SHUTDOWN,IMM'\n/*$VS,'+MQSPEPX STOP QMGR'\n/*$VS,'P BBMXP'\n/*$VS,'F XDSSPROC,SHUTDOWN'\n\nSYS1.PARMLIB(SHUTDOW2):\n/*$VS,'F CA7TEST,/SHUTDOWN'\n/*$VS,'F CA7PROD,/SHUTDOWN'\n/*$VS,'F DFHSM,STOP'\n/*$VS,'.SHUTDOWN'\n/*$VS,'P BBMCAS'\n/*$VS,'C RVRD'\n/*$VS,'P CA7ICOMT'\n/*$VS,'P CA7ICOM'\n\nSYS1.PARMLIB(SHUTDOW3):\n/*$VS,'F CA7PROD,/SHUTDOWN'\n/*$VS,'F CA7TEST,/SHUTDOWN'\n/*$VS,'F DLF,MODE=QUIESCE'\n/*$VS,'P VLF'\n/*$VS,'P LLA'\n/*$VS,'F BPXOINIT,SHUTDOWN=FORKINIT'\n/*$VS,'F OMVS,SHUTDOWN'\n/*$VS,'P FFST'\n/*$VS,'P DLF'\n/*$VS,'P TCPIP\n/*$VS,'Z NET,QUICK'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHUTIDMS": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00C\\x01\\x06\\x14\\x0f\\x01\\x06\\x14\\x1f\\x07\\x07\\x00\\t\\x00\\x02\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2006-05-20T00:00:00", "modifydate": "2006-05-21T07:07:43", "lines": 9, "newlines": 2, "modlines": 0, "user": "GSI"}, "text": "IF SWITCH ON IDMSV8\nPUTSWITCH IDMSV8\nDELSWITCH IDMSV8\nENDIF SWITCH ON\n*\nIF SWITCH ON IDMSV9\nPUTSWITCH IDMSV9\nDELSWITCH IDMSV9\nENDIF SWITCH ON\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMSMSPRC": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x06%\\x0f\\x01\\x06%\\x0f\\x12U\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-09-07T00:00:00", "modifydate": "2006-09-07T12:55:08", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "//SMSSGMSG PROC\n//STEP01  EXEC PGM=ASKOPER,\n// PARM=',,STORAGE GROUP EXCEEDS HIGH ALLOC THRESHOLD SEE IGD17380I'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMSSGMSG": {"ttr": 9736, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x06%\\x0f\\x01\\x06%\\x0f\\x12S\\x00\\x02\\x00\\x02\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-09-07T00:00:00", "modifydate": "2006-09-07T12:53:38", "lines": 2, "newlines": 2, "modlines": 0, "user": "GSI"}, "text": "* SUBMIT OPERATOR MESSAGE FOR MESSAGE IGD17380I\nS SMSSGMSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPILL": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x10\\x01\\x06\\t\\x1f\\x01\\x06\\x10\\x9f\\x19\\x12\\x00\\x1b\\x00\\t\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2006-04-01T00:00:00", "modifydate": "2006-04-19T19:12:10", "lines": 27, "newlines": 9, "modlines": 0, "user": "GSI"}, "text": "IF MSGID EQ DCOMMMP1:246:0:DB00308I\nIF SWITCH DCOMMMP1 OFF\nSETSWITCH DCOMMMP1 Submitted DCOMSPLP\nS DCOMSPLP\nWTO MPFXTALL submitted offload DCOMSPLP for DCOMMMP1\nENDIF SWITCH OFF\nENDIF\n*\nIF MSGID EQ DCOMMMP1:246:0:DB00308I\nIF SWITCH DCOMMMP1 ON\nWTO DCOMSPLP active for DCOMMMP1 no offload submitted\nENDIF SWITCH ON\nENDIF\n*\nIF MSGID EQ DCOMMMT3:246:0:DB00308I\nIF SWITCH DCOMMMT3 OFF\nSETSWITCH DCOMMMT3 Submitted DCOMSPL3\nS DCOMSPL3\nWTO MPFXTALL submitted offload DCOMSPL3 for DCOMMMT3\nENDIF SWITCH OFF\nENDIF\n*\nIF MSGID EQ DCOMMMT3:246:0:DB00308I\nIF SWITCH DCOMMMT3 ON\nWTO DCOMSPL3 active for DCOMMMT3 no offload submitted\nENDIF SWITCH ON\nENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STOPZFS": {"ttr": 9740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x06%\\x0f\\x01\\x06%\\x0f\\x12R\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-09-07T00:00:00", "modifydate": "2006-09-07T12:52:06", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "* REPLY TO MESSAGE IOEZ00542D\nREPLY NN,Y\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SVT1P000": {"ttr": 9742, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x05\\x19\\x8f\\x01\\x05\\x19\\x8f!P\\x00\\x17\\x00\\x12\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-07-17T00:00:00", "modifydate": "2005-07-17T21:50:01", "lines": 23, "newlines": 18, "modlines": 0, "user": "GSI"}, "text": "IF ALL EQ Group=12 Subgroup=L\nS JOB,M=VTSJOB1\nENDIF\n*\nIF ALL EQ Group=12 Subgroup=M\nS JOB,M=VTSJOB2\nENDIF\n*\nIF ALL EQ Group=12 Subgroup=S\nS JOB,M=VTSJOB3\nENDIF\n*\nIF ALL EQ Group=22 Subgroup=L\nS JOB,M=VTSJOB4\nENDIF\n*\nIF ALL EQ Group=22 Subgroup=M\nS JOB,M=VTSJOB5\nENDIF\n*\nIF ALL EQ Group=22 Subgroup=S\nS JOB,M=VTSJOB6\nENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVT1P001": {"ttr": 9744, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x05 \\x0f\\x01\\x05 \\x0f\\x001\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-19T00:00:00", "modifydate": "2005-07-19T00:31:10", "lines": 15, "newlines": 15, "modlines": 0, "user": "GSI"}, "text": "IF MSGID EQ SVT1P0011A\nS JOB,M=VTSJOB1\nENDIF\n*\nIF MSGID EQ SVT1P0011B\nS JOB,M=VTSJOB2\nENDIF\n*\nIF MSGID EQ SVT1P0011C\nS JOB,M=VTSJOB3\nENDIF\n*\nIF MSGID EQ SVT1P0012A\nS JOB,M=VTSJOB4\nENDIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTALL": {"ttr": 9746, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x001\\x01\\x06\\x10\\x1f\\x01\\x06\\x17_\\x16E\\x00n\\x00a\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2006-04-11T00:00:00", "modifydate": "2006-06-24T16:45:31", "lines": 110, "newlines": 97, "modlines": 0, "user": "GSI"}, "text": "*$HASP612 TEST WHEN NO JOBS ACTIVE\nGET WORD 03\nSETAUTO\nSETAMRF\nSETSWITCH GLENN    TO TEST FOR SW\n*\nIF SYSID EQ SSC\nIF ALL EQ JOBS ACTIVE NO\nIF WORD 01 NO\nIF SWITCH EQ GLENN    TO TEST FOR SW\nSE 'WORD TRUE %, IFSWITCH AND MULTI IF',USER=(GSI)\nD R,L\nENDIF SWITCH EQ\nENDIF\nENDIF\nENDIF\n*\nIF WORD 01 NO\nSE 'WORD TRUE %',USER=(GSI)\nENDIF\n*\nIF WORD 01 OO\nSE 'WORD FALSE %',USER=(GSI)\nENDIF\n*\nIF ALL EQ OBS ACTIVE NO\nSE 'ALL FALSE %',USER=(GSI)\nENDIF\n*\nIF ALL EQ JOBS ACTIVE NO\nSE 'ALL TRUE %',USER=(GSI)\nENDIF\n*\nIF SWITCH EQ GLENN    FALSE FOR SW\nSE 'SWITCH EQ FALSE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nIF SWITCH NE GLENN    TO TEST FOR SW\nSE 'SWITCH NE FALSE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH NE GLENN    TEST FOR SW\nSE 'SWITCH NE TRUE %',USER=(GSI)\nENDIF SWITCH NE\n*\nIF SWITCH ON GLENN\nSE 'SWITCH ON TRUE %',USER=(GSI)\nENDIF SWITCH ON\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF AMY\nSE 'SWITCH OFF TRUE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nIF SWITCH OFF GLENN\nSE 'SWITCH OFF FALSE %',USER=(GSI)\nENDIF SWITCH OFF\n*\nALTSWITCH GLENN    TEST FOR SW\n*\nIF SWITCH EQ GLENN    TEST FOR SW\nSE 'SWITCH EQ TRUE %',USER=(GSI)\nENDIF SWITCH EQ\n*\nDELSWITCH GLENN\n*\nIF SYSID EQ SSC\nWTOH THIS WILL SEND A HIGHLIGHTED MESSAGE TO THE OPERATOR*\nWTO THIS WILL SEND A MESSAGE TO THE OPERATOR ************\nENDIF\n*\nIF MSGID+01 FOR 02 HA\nSE 'MSGID+ TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID+01 FOR 02 IA\nSE 'MSGID+ FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGNE+01 FOR 02 IA\nSE 'MSGNE+ TRUE %',USER=(GSI)\nENDIF\n*\n*\nIF MSGNE+01 FOR 02 HA\nSE 'MSGNE+ FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGID EQ $HASP612\nSE 'MSGID TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID EQ $HASP613\nSE 'MSGID FALSE %',USER=(GSI)\nENDIF\n*\nIF MSGID NE $HASP613\nSE 'MSGID TRUE %',USER=(GSI)\nENDIF\n*\nIF MSGID NE $HASP612\nSE 'MSGID FALSE %',USER=(GSI)\nENDIF\n*\nHIGHLIGHT\n*\nENDGET\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTLONG": {"ttr": 9749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x06\\x10\\x9f\\x01\\x06\\x12o\\x19\\x01\\x00\\x03\\x00\\x03\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-04-19T00:00:00", "modifydate": "2006-05-06T19:01:41", "lines": 3, "newlines": 3, "modlines": 0, "user": "GSI"}, "text": "//GSIX     JOB ,'SIEGEL',CLASS=A,MSGCLASS=X,REGION=0M,                  JOB06468\n//         MSGLEVEL=(1,1),NOTIFY=&SYSUID\n// EXEC PGM=ASKOPER,PARM=',,ABC GLENN_SIEGEL_SEPTEMBER_14 TOP GUN'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSOROUTE": {"ttr": 9751, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x07\\x06\\x8f\\x01\\x07\\x06\\x8f\\x11X\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc7\\xc7\\xc7@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-09T00:00:00", "modifydate": "2007-03-09T11:58:40", "lines": 252, "newlines": 252, "modlines": 0, "user": "GGG"}, "text": "         ICTL      1,71,20\n\n***********************************************************************\n*                                                                     *\n*                           T S O R O U T E                           *\n*                                                                     *\n*F U T U R I T Y   S O F T W A R E   I N T E R N A T I O N A L   I N C*\n*                                                                     *\n*                   CHIEF ARCHITECT: Garry G. Green                   *\n*                                                                     *\n*                       COPYRIGHT JULY 2006 FSI                       *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*   FUNCTION                                                          *\n*                                                                     *\n*     SUBROUTINE OF MPFXTALL TO HANDLE THE TSOROUTE RULE.             *\n*                                                                     *\n*     IF THE WTO(R) ISSUER IS NOT A TSO ADDRESS SPACE, THIS ROUTINE   *\n*     IMMEDIATLY RETURNS                                              *\n*                                                                     *\n*     TSOROUTE:                                                       *\n*       CAUSES WTO(R) TO BE TPUT TO THE TSO USER'S TERMINAL           *\n*                                                                     *\n*     TSOROUTE REPLY:                                                 *\n*       SAME AS TSOROUTE, BUT IN ADDITION IF MESSAGE IS A WTOR, A TGET*\n*       IS ISSUED TO THE TSO USER'S TERMINAL; THE VALUE ENTERED IS    *\n*       PREFIXED WITH \"R nn,\"  WHERE nn IS THE REPLY ID OF THE WTOR,  *\n*       AND THEN THIS COMMAND IS ISSUED VIA MGCRE; THE MGCRE MACRO    *\n*       SPECIFIES CMDFLAG=NOHCPY, WHICH SUPPRESSES THE ECHO OF THE    *\n*       REPLY WTO FROM APPEARING ON SYSLOG/JOBLOG/HARDCOPYLOG         *\n*                                                                     *\n*     TSOROUTE SUPPRESS:                                              *\n*       SAME AS TSOROUTE REPLY, BUT IN ADDITION, ROUTE CODE 9 (THE    *\n*       SECURITY ROUTE CODE) IS ADDED TO THE ROUTE CODES FOR THE WTOR *\n*       WHICH CAUSES THE REPLY VALUE ENTERED BY THE TSO USER TO APPEAR*\n*       IN THE SYSLOG/JOBLOG AS:                                      *\n*                                                                     *\n*         IEE600I REPLY TO 07 IS;SUPPRESSED, INSTEAD OF               *\n*         IEE600I REPLY TO 07 IS;SECRET PASSWORD                      *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*   CHANGE ACTIVITY                                                   *\n*   $G00=20070304 GGG VERSION 1.0 BASE                                *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*   ATTRIBUTES:                                                       *\n*     REFRESHABLE, AMODE(31) RMODE(ANY)                               *\n*     W/S OBTAINED BELOW THE LINE DUE TO TGET/TPUT RESTRICTIONS       *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*   ENTRY/RETURN:                                                     *\n*                                                                     *\n*     PARM  1 @ CTXT                                                  *\n*     PARM  2 @ MPFXTALL COMMAND RULE = TSOROUTE <REPLY/SUPPRESS>     *\n*                                                                     *\n*     RC    0 ONLY POSSIBLE RETURN CODE                               *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*                    T E C H N I C A L   N O T E S                    *\n*                                                                     *\n*                                                                     *\n* R0,R1,R2         USED FOR COMMUNICATIONS                            *\n* R13,R14,R15      USED FOR COMMUNICATIONS                            *\n*                                                                     *\n* R3  @ CTXT       FROM PASSED PARAMETERS                             *\n*                  ACTIVE USING                                       *\n* R4  @ CMDTEXT    FROM PASSED PARAMETERS                             *\n*                  \"TSOROUTE\", \"TSOROUTE REPLY\" OR \"TSOROUTE SUPPRESS\"*\n* R5  @ ASCB                                                          *\n* R6  @ TSB                                                           *\n* R7  = FLAG       0 = WTO                                            *\n*                  1 = WTOR WITH TSOROUTE (NO PARAMETERS)             *\n*                  2 = WTOR WITH TSOROUTE REPLY                       *\n*                  3 = WTOR WITH TSOROUTE SUPPRESS                    *\n* R8  @ CTXTATTR   ACTIVE USING                                       *\n* R9  @ REPLY CMD  R nn,data-replied-to-by-tso-user                   *\n* R10 @ CONSOLE ID INTERNAL CONSOLE ID                                *\n* R11 @ W/S                                                           *\n* R12 @ CODE PAGE  BASE REGISTER                                      *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*                     R E C O R D   L A Y O U T S                     *\n*                                                                     *\n***********************************************************************\n\n         PRINT     ON,NOGEN                  SUPPRESS EXPANSION\n\n         IHAPSA    ,                         MAP PSA\n         IHAASCB   ,                         MAP ASCB\n         IEZVX100  ,                         MAP CTXT\n\n         PRINT     ON,GEN                    SHOW EXPANSION\n\nTSOROUTE ENTER     LEN=WSLEN,                WORKING STORAGE LENGTH    *\n                   LOC=BELOW,                DUE TO TGET/TPUT LIMITS.  *\n                   BRANCH=START,             BRANCH AFTER MODULE HEADER*\n                   STATS=OFF                 NO MODULE STATS\n\n***********************************************************************\n*                                                                     *\n*                    W O R K I N G   S T O R A G E                    *\n*                                                                     *\n***********************************************************************\n\n@        USING     WS,R11                    MAP WORKING STORAGE (W/S)\n\nWS       DS        0D                        START OF W/S MODEL\n\nMGCREMFL MGCRE     MF=L                      MGCRE LIST FORMAT\n\nCMDTEXT  DS        0H                        COMMAND TEXT STRING\nCMDTEXTL DS        H                         COMMAND TEXT'S LENGTH\nCMDTEXTT DS        CL126                     COMMAND TEXT\n\nWSLEN    EQU       *-WS                      CALCULATE LEN OF W/S\n\n***********************************************************************\n*                                                                     *\n*                      S T A T I C   V A L U E S                      *\n*                                                                     *\n***********************************************************************\n\nTSORMSG1 DC        C'MPF201I ONLY THIS TSO TERMINAL CAN REPLY TO FOLLOW*\n                   ING WTOR-CONSOLES CAN''T REPLY'\nTSORMSG2 DC        C'MPF202I REPLY VALUE YOU ENTER WILL BE SUPPRESSED F*\n                   ROM CONSOLE, JOBLOG && SYSLOG'\nTSORMSG3 DC        C'MPF203I FOLLOWING WTOR FOR DISPLAY ONLY - REPLY MU*\n                   ST BE ENTERED FROM CONSOLE'\n\n***********************************************************************\n*                                                                     *\n*                      L O G I C A L   S T A R T                      *\n*                                                                     *\n***********************************************************************\n\nSTART    DS        0H                        LOGICAL PROGRAM START\n\n         MVC       @.WS(WSLEN),WS            INIT WORKING STORAGE (W/S)\n\n         L         R5,PSAAOLD-PSA(,0)        GET @ ASCB\n         L         R6,ASCBTSB-ASCB(,R5)      GET @ TSB\n         LTR       R6,R6                     Q. TSO ADDRESS SPACE\n         BZ        RC0                       A. NO - RETURN RC0\n\n         LM        R3,R4,0(R1)               LOAD PARM 1 AND PARM 2\n         USING     CTXT,R3                   MAP CTXT\n         L         R8,CTXTTXPJ               GET @ CTXTATTR\n         USING     CTXTATTR,R8               MAP CTXTATTR\n         LA        R7,0                      SET FLAG TO INDICATE WTO\n         TM        CTXTTFB1,CTXTTFWR         Q. IS THIS A WTOR\n         BNO       WTOWTOR                   A. NO - BRANCH\n         LA        R7,2                      SET FLAG TO INDICATE WTOR\n*                                            WITH TSOROUTE REPLY\n         CLC       =C'REPLY',9(R4)           Q. REPLY TO WTOR REQ'D\n         BE        WTOR                      A. YES - BRANCH\n         LA        R7,3                      SET FLAG TO INDICATE WTOR\n*                                            WITH TSOROUTE SUPPRESS\n         CLC       =C'SUPPRESS',9(R4)        Q. SUPPRESS WTOR REPLY\n         BE        WTOR                      A. YES - BRANCH\n         LA        R7,1                      SET FLAG TO INDICATE WTOR\n*                                            WITH TSOROUTE (NO PARMS)\n         TPUT      TSORMSG3,L'TSORMSG3       TELL USER FOLLOWING WTOR\n*                                            CAN'T BE REPLIED TO FROM\n*                                            TSO TERMINAL-CONSOLE ONLY\n         B         WTOWTOR                   GO TO WTO/WTOR COMMON\n*                                            PROCESSING\n\nWTOR     DS        0H                        REPLY/SUPPRESS SPECIFIED\n         TPUT      TSORMSG1,L'TSORMSG1       TELL USER NO CONSOLE REPLY\n*                                            ALLOWED;THIS TSO TERM ONLY\n         CH        R7,=H'3'                  Q. SUPPRESS REPLY\n         BNE       WTOWTOR                   A. NO - BRANCH\n         TPUT      TSORMSG2,L'TSORMSG2       TELL USER REPLY WILL BE\n*                                            SUPPRESSED FROM LOGS\n\nWTOWTOR  DS        0H                        COMMON WTO/WTOR PROCESSING\n*                                            PROCESSING\n         LH        R0,CTXTTLEN               GET WTO(R) TEXT LENGTH\n         TPUT      CTXTTMSG,(0)              DISPLAY WTO(R)\n         CH        R7,=H'2'                  Q. WTO OR WTOR WITH\n*                                            TSOROUTE (NO PARAMETERS)\n         BL        RC0                       A. TRUE - RETURN RC0\n         MVC       @.CMDTEXTT(5),=CL5'R 00,' INIT PREFIX TO COMMAND\n         MVC       @.CMDTEXTT+2(L'CTXTRPID),CTXTRPID  MOVE IN REPLY ID\n         TGET      @.CMDTEXTT+5,75           GET TSO USER'S REPLY\n         LA        R1,5(,R1)                 CALC REPLY COMMAND'S LEN =\n*                                            TGET LEN + R nn,  PREFIX\n         STH       R1,@.CMDTEXTL             STORE CMD LEN INTO PREFIX\n         OC        @.CMDTEXTT+5(75),=CL75' ' UPPER CASE REPLY SAME AS\n*                                            WOULD HAVE BEEN DONE IF\n*                                            ENTERED FROM THE CONSOLE\n         LA        R9,@.CMDTEXT              @ MGCRE COMMAND STRING\n         XR        R10,R10                   USE INTERNAL CONSOLE ID\n         CH        R7,=H'3'                  Q. SUPPRESS WTOR REPLY\n         BNE       NOSUPWTO                  A. NO - BRANCH\n         L         R1,CTXTRCP                GET @ ROUTE CODES\n         USING     CTXTROUT,R1               MAP ROUTING CODES\n         OI        CTXTR002,CTXTR09          ADD SECURITY ROUTE CODE 9\n*                                            REPLIES TO SECURITY WTOR'S\n*                                            HAVE REPLY TEXT SUPPRESSED\n         OI        CTXTRFB1,CTXTRCRC         TELL MPF ROUTE CODES\n*                                            MODIFIED\n\nNOSUPWTO DS        0H                        SUPPRESS REPLY Y/N COMMON\n         MGCRE     TEXT=(R9),                ISSUE REPLY COMMAND       *\n                   CONSID=(R10),             (CONT'D)                  *\n                   CMDFLAG=NOHCPY,           (CONT'D)                  *\n                   MF=(E,@.MGCREMFL)         (CONT'D)\n\nRC0      DS        0H                        RETURN RC = 0\n         XR        R15,R15                   SET RETURN CODE TO 0\n\n***********************************************************************\n*                                                                     *\n* RELEASE WORKING STORAGE (W/S) AND RETURN                            *\n*                                                                     *\n***********************************************************************\n\n         LR        R2,R15                    SAVE RETURN CODE\n         STORAGE   RELEASE,                  RELEASE W/S               *\n                   ADDR=(R11),               CONT'D                    *\n                   LENGTH=WSLEN              CONT'D\n         LR        R15,R2                    RESTORE RETURN CODE\n         PR        ,                         RETURN TO CALLER\n\n***********************************************************************\n*                                                                     *\n* GENERATE LITERALS AND WIND UP ASSEMBLY                              *\n*                                                                     *\n***********************************************************************\n\n         LTORG     ,                         ASSEMBLE LITERALS HERE\n\n         END       TSOROUTE                  END OF PROGRAM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTLONGM": {"ttr": 9987, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x01\\x06\\x08/\\x01\\x06\\x10o#\\x17\\x00\\x03\\x00\\x03\\x00\\x01\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-03-23T00:00:00", "modifydate": "2006-04-16T23:17:39", "lines": 3, "newlines": 3, "modlines": 1, "user": "GSI"}, "text": "//GSIX     JOB ,'SIEGEL',CLASS=A,MSGCLASS=X,REGION=0M,\n//         MSGLEVEL=(1,1),NOTIFY=&SYSUID\n// EXEC PGM=ASKOPER,PARM=',,U11D-0450-123456789012345 HI '\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VCS0003W": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x05\\x17\\x8f\\x01\\x05\\x17\\x8f\\x141\\x00\\x01\\x00\\x01\\x00\\x00\\xc7\\xe2\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-27T00:00:00", "modifydate": "2005-06-27T14:31:48", "lines": 1, "newlines": 1, "modlines": 0, "user": "GSI"}, "text": "REPLY NN,U\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT708/FILE708.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT708", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}