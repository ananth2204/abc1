{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012130000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE474.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE474.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\r'", "DS1TRBAL": "b'\\x16\\x94'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03s\\x00\\x0e\\x03t\\x00\\x02\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x96\\x04?\\x01\\x00\"/\\x15G\\x00H\\x00L\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "2000-08-09T15:47:00", "lines": 72, "newlines": 76, "modlines": 0, "user": "WTS03"}, "text": "LIBCLEAN is a REXX ISPF dialog that compares the directories of two\nPDS' and display a list of matching or non-matching member names and\nstatistics. Statistics are provided for ISPF members and load modules.\n(load module stats require that FINDMEM CP be available).\n\nOperations such as browse, compare, or delete may then\nbe performed against members in the list. All listed members may\nbe mass deleted from either the OLD or NEW library. Selected members\nmay be excluded from the mass delete.\n\nThis tool can be useful for deleting duplicate copies of software when\nthe product is in a mixed library. It is a very fast way to clean up\nmessy ISPF files.  It can also be used to verify source members exist\nfor a load library.\n\nMake yourself a copy of some libraries you may want to work with\nand give it a try.\n\nInstalling LIBCLEAN\n------------------\n- Copy member LIBCLEAN to your SYSPROC or SYSEXEC library.\n- Copy members LIB@* to your ISPPLIB library.\n- Assemble the FINDMEM.BAL file to TSO STEPLIB, ISPLLIB or LNKLST lib.\n   This is only required if you want stats for load modules.\n\nInvoking LIBCLEAN\n------------------\nEnter TSO %LIBCLEAN\n\nEnter library names as directed on the initial panel. LIBCLEAN will\nthen build the matched or unmatched list.\n\nSorry...no help screens yet.\n\nLine commands\n-------------\nAny unrecognized line command, e.g. '?' will display a list of\nvalid line commands.\n\nThe following line commands are provided:\n\n- BO / BN - Browse member from the OLD lib (BO) or the NEW lib (BN).\n\n- C - Invoke IBM SuperCompare with the members from NEW and OLD libs.\n\n- DO / DN - Delete member from the OLD lib (DO) or the NEW lib (DN).\n\n- S - Show Load module stats for the member. Requires the FINDMEM CP.\n\n- X - EXclude the member from the list. Use this to exclude members\n      from the mass DELETE primary command.\n\nPrimary commands\n----------------\nThe following primary commands are provided:\n\n  - DELETE OLD\n  - DELETE NEW   Delete all members on list from OLD or NEW lib. This\n                 will be followed by a delete confirmation panel.\n\n  - Locate xxx   Position the list to member xxx.\n\nFeedback\n--------\n\nPlease let me know if you have problems making this work.\nIf you make any improvements, I would like a copy. I'm\nespecially interested in help screens.\n\n      Rob Wunderlich\n      RobWunderlich@ussposco.com\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE474": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99\\x08?\\x01\\x00#_\\x16\\x12\\x00\\n\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-08-22T16:12:00", "lines": 10, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 474 is from Rob Wunderlich and contains a system to       *   FILE 474\n//*           compare several pds'es for the purpose of eliminating *   FILE 474\n//*           redundant or unnecessary members.  This package is    *   FILE 474\n//*           called LIBCLEAN.                                      *   FILE 474\n//*                                                                 *   FILE 474\n//*                Rob Wunderlich                                   *   FILE 474\n//*                                                                 *   FILE 474\n//*        email:  RobWunderlich@ussposco.com                       *   FILE 474\n//*        phone:  (925) 439-6268                                   *   FILE 474\n//*                                                                 *   FILE 474\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDMEM": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x96\\x04?\\x01\\x00\"/\\x16\\x05\\x01a\\x01b\\x00\\x00\\xe6\\xe3\\xe2\\xf0\\xf3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "2000-08-09T16:05:00", "lines": 353, "newlines": 354, "modlines": 0, "user": "WTS03"}, "text": "         TITLE    'FINDMEM'                                             00001\n*********************************************************************** 00002\n* FUNCTION: TSO CP TO FIND FIRST OCCURANCE OF MEMBER IN A             * 00003\n*           CONCATENATION.                                            * 00004\n*                                                                     * 00004\n* INPUT: PARM1 - MEMBER NAME TO FIND                                  * 00005\n*        PARM2 - OPTIONAL - DDNAME TO SEARCH. IF NOT SPECIFIED,       * 00006\n*                LINKLIST IS SEARCHED.                                * 00007\n*                                                                     * 00008\n* OUTPUT: RETURN CODE IN R15:                                         * 00009\n*           0 = MEMBER FOUND                                          * 00010\n*           4 = MEMBER NOT FOUND                                      * 00011\n*          16 = PARM ERRROR                                           * 00012\n*          20 = DDNAME NOT ALLOCATED                                  * 00012\n*                                                                     * 00013\n*         VARIABLES TO ISPF:                                          * 00013\n*           FMCONCAT - CONCATENATION NUMBER WHERE MEMBER WAS FOUND.   * 00013\n*           FMDSNAME - DSNAME WHERE MEMBER WAS FOUND                  * 00013\n*           FMLIB    - LIBRARY TYPE WHERE MEMBER WAS FOUND            * 00013\n*                        'PRIVATE', 'LINKLIST' OR 'STEPLIB'           * 00013\n*           FMMSG    - ERROR MSG WHEN NON ZERO RC                     * 00013\n*           FMDIRENT - UNFORMATTED DIRECTORY ENTRY FROM BLDL          * 00013\n*           FMLKEDDT - LINK EDIT DATE                                 * 00013\n*                                                                     * 00013\n* WRITTEN BY: ROB WUNDERLICH                                          * 00013\n*                                                                     * 00013\n* LIMITATIONS: THE SECTION LABELED 'GETLKDAT' WAS CODED TO READ       * 00013\n*              MODULES GENERATED BY LKED. I DON'T THINK IT WILL       * 00013\n*              WORK ON BINDER FORMAT LMODS.                           * 00013\n*                                                                     * 00013\n*********************************************************************** 00014\n         MACRO\n         REGISTER\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nR10      EQU   10\nRB       EQU   11\nR11      EQU   11\nRC       EQU   12\nR12      EQU   12\nRD       EQU   13\nR13      EQU   13\nRE       EQU   14\nR14      EQU   14\nRF       EQU   15\nR15      EQU   15\n         MEND\n*\n*\n         MACRO                                                          00001\n&N       DDFIND &DDNAME=X,&LENGTH=8,&DDLABEL=                           00002\n.********************************************************************** 00003\n.*                                                                      00004\n.*        -- WRITTEN BY: ROB WUNDERLICH  12/86                          00005\n.*                                                                      00006\n.*       THE DDFIND MACRO SCANS THE TIOT FOR THE SPECIFIED DDNAME.      00007\n.*       THE ADDRESS OF THE TIOT ENTRY IS RETURNED IN REG 1. R1 = 0     00008\n.*       IF DDNAME NOT FOUND.                                           00009\n.*                                                                      00010\n.*       DDFIND  DDNAME=NAME                                            00011\n.*                                                                      00012\n.*       THE CONTENTS OF REGS 0 AND 1 ARE ALTERED BY THIS MACRO.        00013\n.*                                                                      00014\n.********************************************************************** 00015\n.*                                                                      00016\n.*                                                                      00017\n         AIF   (T'&N EQ 'O').NOLBL     IF NO LABEL SKIP AROUND          00018\n&N       EQU   *                  GENERATE LABEL                        00019\n.NOLBL   ANOP                                                           00020\n.*                                                                      00021\n         B     *+X'C'             BRANCH AROUND CONSTANT                00023\n&DDLABEL DC    CL8'&DDNAME'       CONSTANT FOR COMPARE                  00024\n         L     1,16               LOAD CVT ADDRESS                      00025\n         L     1,0(,1)            LOAD TCB WORDS ADDRESS                00026\n         L     1,4(,1)            LOAD TCB ADDRESS                      00027\n         L     1,12(,1)           LOAD ADDRESS OF TIOT                  00028\n         LA    1,24(,1)           LOAD ADDRESS OF FIRST DD ENTRY        00029\n         XR    0,0                CLEAN R0                              00030\n         ICM   0,B'0001',0(1)     GET LEN OF THIS DD ENTRY              00031\n         BZ    *+X'14'            IF ZERO, THEN END OF TIOT             00032\n         CLC   4(&LENGTH,1),*-X'26' TEST FOR DDNAME                     00033\n         BE    *+X'C'             BRANCH OUT IF FOUND                   00034\n         AR    1,0                INCREMENT TO NEXT DD ENTRY            00035\n         B     *-X'14'            GO CHECK THE NEXT ENTRY               00036\n         XR    1,1                ZERO R15 - ENTRY NOT FOUND            00037\n         MEND                                                           00038\n         EJECT                                                          00015\nFINDMEM  CSECT                                                          00016\n         SAVE  (14,12),,FINDMEM*&SYSDATE&SYSTIME                        00017\n         REGISTER                 EQUATE REGISTERS                      00018\n         LR    R12,R15                                                  00019\n         USING FINDMEM,R12                                              00020\n         ST    R13,SAV+4          STORE ADDRESS OF HIS SAVEAREA         00021\n         LR    R2,R13             SAVE ADDRESS OF HIS SAVEAREA          00022\n         LA    13,SAV             LOAD ADDRESS OF MY SAVEAREA           00023\n         ST    13,8(2)            STORE ADDRESS OF MY SAV IN HIS SAV    00024\n*                                                                       00025\n*                                                                       00026\nGETPARM  EQU   *                                                        00027\n         L     R3,0(,R1)          LOAD COMMAND BUFFER POINTER\n*\n*\n         LH    R2,0(,R3)          LOAD LENGTH OF COMMAND BUFFER\n         SH    R2,=H'4'           SUBTRACT LENGTH OF BUFFER HEADER\n         LH    R1,2(,R3)          LOAD COMMAND LENGTH\n         LA    R3,4(R1,R3)        POINT TO START OF PARMS\n         SR    R2,R1              COMPUTE PARM LENGTH\n         LTR   R2,R2              ANY PARM?\n         BP    GOTPARM            YES - BRANCH AROUND\n         MVC   RETCODE,=H'16'     SET RETURN CODE\n         MVC   FMMSG,=CL80'NO PARM SUPPLIED'\n         B     SETVARS\n*\nGOTPARM  EQU   *                  SCAN PARMS\n         LR    R15,R3             SAVE PARM START\nP1SCAN   CLI   0(R3),C' '         BLANK?\n         BE    P1FND\n         LA    R3,1(,R3)          INCREMENT POINTER\n         BCT   R2,P1SCAN          KEEP LOOKING\nP1FND    LR    R14,R3             LOAD FOUND ADDRESS\n         SR    R14,R15            GET LENGTH OF PARM\n         CH    R14,=H'8'          CHECK MAX LENGTH\n         BNH   P1FNDA             OK\n         MVC   RETCODE,=H'16'     SET RETURN CODE\n         MVC   FMMSG,=CL80'MEMBER NAME EXCEEDS 8 CHARACTERS'\n         B     SETVARS            GET OUT\nP1FNDA   BCTR  R14,0              MAKE MACHINE LENGTH\n         EX    R14,MVPARM1        MOVE THE PARM\n         OC    BLMEMBER,=8X'40'   MAKE UPPERCASE\n*\n         LTR   R2,R2              ANY MORE PARM?\n         BNP   PARMEND            NO - BRANCH AROUND\n*  GET DDNAME PARM\nP2SET    LA    R3,1(,R3)          POINT PAST BLANK\n         BCTR  R2,0               DECREMENT LENGTH FOR BLANK\n         LTR   R2,R2              ANY MORE PARM?\n         BNP   PARMEND            NO - BRANCH AROUND\n         CLI   0(R3),C' '         BLANK?\n         BE    P2SET              YES - CHECK NEXT BYTE\n         LR    R15,R3             SAVE PARM START\nP2SCAN   CLI   0(R1),C' '         BLANK?\n         BE    P2FND\n         LA    R3,1(,R3)          INCREMENT POINTER\n         BCT   R2,P2SCAN          KEEP LOOKING\nP2FND    LR    R14,R3             LOAD FOUND ADDRESS\n         SR    R14,R15            GET LENGTH OF PARM\n         CH    R14,=H'8'          CHECK MAX LENGTH\n         BNH   P2FNDA             OK\n         MVC   RETCODE,=H'16'     SET RETURN CODE\n         MVC   FMMSG,=CL80'DDNAME EXCEEDS 8 CHARACTERS'\n         B     SETVARS            GET OUT\nP2FNDA   BCTR  R14,0              MAKE MACHINE LENGTH\n         EX    R14,MVPARM2        MOVE THE PARM\n         OC    DDNAME,=8X'40'     MAKE UPPERCASE\n         MVC   FINDLIB+(DCBDDNAM-IHADCB)(8),DDNAME   MOVE DDN TO DCB\n*\nPARMEND  EQU   *\n*\n         CLC   DDNAME,=CL8' '     DDNAME SUPPLIED?\n         BE    NODDN1             NO - BRANCH AROUND\n         MVC   DDFNAME,DDNAME     SET DDNAME TO LOOK FOR\n         DDFIND DDLABEL=DDFNAME   CHECK TIOT FOR DDNAME\n         LTR   R1,R1              DDNAME IN TIOT?\n         BZ    DD_NOT_ALLOCATED   NO -GO TAKE AN ERROR\n         ST    R1,TIOTPTR         SAVE PTR INTO TIOT\n         OPEN  (FINDLIB,INPUT)\n         BLDL  FINDLIB,BLDLLIST   SEARCH USER SUPPLIED DDNAME\n         B     CHKBLDL            BRANCH AROUND\nNODDN1   BLDL  0,BLDLLIST         SEARCH LINKLIB\nCHKBLDL  LTR   R15,R15            FOUND?\n         BZ    FOUND              YES\n         MVC   FMMSG,=CL80'MEMBER NOT FOUND'\n         MVC   RETCODE,=H'4'\n         B     SETVARS\nFOUND    CLC   DDNAME,=CL8' '     DDNAME SUPPLIED?\n         BE    LLIBDSN            NO - GO CHECK FOR LINKLIB DSN\n         CLOSE (FINDLIB)                                                00033\n*  USER SUPPLIED A DDNAME - DETERMINE THE DSN OF THE LIB WHERE FOUND\n         XR    R3,R3               CLEAR R3\n         L     R2,TIOTPTR          GET SAVED PTR INTO TIOT\n         USING TIOENTRY,R2         MAP IT\n         XR    R1,R1               CLEAR R1\n         IC    R1,BLCONCAT         GET THE CONCATENATION NUMBER\n         LA    R1,1(,R1)           PLUS 1\nDDINDEX1 BCT   R1,DDINDEX2         INDEX INTO THIS CONCATENATION\n         XR    R1,R1               CLEAR R1\n         ICM   R1,B'0111',TIOEJFCB GET JFCB ADDRESS\n         LA    R1,16(,R1)          PLUS 16 - WHY DO I NEED THIS OFFSET?\n         USING INFMJFCB,R1         MAP JFCB\n         MVC   FMDSNAME,JFCBDSNM   BRANCH AROUND\n         B     GOTDSN              BRANCH AOUND\n         DROP  R1\nDDINDEX2 IC    R3,TIOELNGH         GET LENGTH OF THIS ENTRY\n         AR    R2,R3               POINT TO NEXT ENTRY\n         B     DDINDEX1            KEEP INDEXING\n         DROP  R2\n*\nGOTDSN   EQU   *\n         B     MAKEVARS            BRANCH AROUND\n*\n*\nLLIBDSN  EQU   *                   GET DSN FOR LINKLIST DATASET\n         CLI   BLLIB,1             WAS MEMBER FOUND IN LINKLIST LIB?\n         BNE   MAKEVARS            NO - BRANCH\n         L     R2,16               LOAD CVT ADDRESS\n         USING CVTMAP,R2           MAP CVT\n         L     R2,CVTLLTA          GET LINKLIST TABLE ADDR\n         DROP  R2                  DROP CVT MAPPING\n*  (CAN'T FIND IHALLT MAPPING MACRO)\n         LA    R2,8(,R2)           POINT TO FIRST ENTRY\n         XR    R1,R1               CLEAR R1\n         IC    R1,BLCONCAT         GET THE CONCATENATION NUMBER\n         MH    R1,=H'45'           TIMES THE LENGTH OF AN ENTRY\n         LA    R2,1(R1,R2)         POINT TO DSNAME\n         MVC   FMDSNAME,0(R2)      GET THE LINKLIST DSNAME\n*\n*\nMAKEVARS EQU   *\n*  CONVERT CONCATENATION NUMBER TO CHARACTER\n         XR    R1,R1               CLEAR R1\n         IC    R1,BLCONCAT         GET THE CONCATENATION NUMBER\n         CVD   R1,DWORK           CONVERT TO DECIMAL\n         UNPK  FMCONCAT,DWORK     UNPK TO CHARACTER\n         OI    FMCONCAT+(L'FMCONCAT-1),X'F0'     FIX SIGN BYTE\n*\n*  CONVERT LIBRARY TYPE TO A WORD\n         MVC   FMLIB,=CL8'PRIVATE'  ASSUME PRIVATE LIB\n         CLI   BLLIB,0              IS IT?\n         BE    EOLIBSET             YES - BRANCH OUT\n         MVC   FMLIB,=CL8'LINKLIST' ASSUME LINKLIST LIB\n         CLI   BLLIB,1              IS IT?\n         BE    EOLIBSET             YES - BRANCH OUT\n         MVC   FMLIB,=CL8'STEPLIB'  MUST BE STEPLIB/JOBLIB\nEOLIBSET EQU   *\n         MVC   FMDIRENT,BLMEMBER  MOVE DIR ENTRY TO ISPF AREA\n         XR    R1,R1              CLEAR R1\n         IC    R1,BLINDC          GET BLDL 'C' BYTE\n         N     R1,=X'0000001F'    TURN OFF ALL BUT USERDATA LEN BITS\n         SLL   R1,1               TIMES 2 TO GET ACTUAL LENGTH\n         AH    R1,=H'14'          PLUS LENGTH OF FIXED HEADER\n         ST    R1,VLDIRENT        SET LENGTH IN PARM LIST\n*\nGETLKDAT EQU   *                  GET LKED DATE FOR LOAD MODULES\n*  HAVE TO BAIL OUT HERE UNTIL DYNALLOC CODE FOR LINKLIST/STEPLIB\n         CLI   BLLIB,0            PRIVATE LIBRARY (ALEADY ALLOCATED)?\n         BNE   EOLKEDDT           NO - BRANCH AROUND\n*\n         CH    R1,=H'14'          ANY USERDATA?\n         BE    EOLKEDDT           NO - BRANCH AROUND\n         CH    R1,=H'44'          SPF LIBRARY?\n         BE    EOLKEDDT           YES - BRANCH AROUND\n*  ASSUME LOAD LIBRARY DIRECTORY\n         OPEN  (FINDLIB,INPUT)\n         FIND  FINDLIB,BLTTR,C    POINT DCB TO MEMBER                   00106\nREADLOOP EQU   *                                                        00107\n         READ  DECB1,SF,FINDLIB,IDRREC,20  READ 20 BYTES OF RECORD      00108\n         CHECK DECB1                                                    00109\n         CLI   IDRREC,X'01'       PAST THE IDR RECORDS?                 00110\n         BE    NOLKEDDT           YES - BRANCH TO ERROR                 00111\n         CLI   IDRREC,X'80'       IDR RECORD?                           00112\n         BNE   READLOOP           NO - TRY NEXT RECORD                  00113\n         TM    IDRREC+2,X'02'     LKED IDR RECORD?                      00114\n         BNO   READLOOP           NO - TRY NEXT RECORD                  00115\n         UNPK  FMLKEDDT(5),IDRREC+15(3)  UNPACK LKED DATE               00129\n         OI    FMLKEDDT+4,X'F0'   FIX SIGN                              00130\n         MVC   VLLKEDDT,=F'5'     SET LENGTH IN ARRAY\nNOLKEDDT EQU   *\n         CLOSE (FINDLIB)          CLOSE DS\nEOLKEDDT EQU   *\n*\nSETVARS  LINK  EP=ISPQRY          SEE IF ISPF IS ACTIVE\n         LTR   R15,R15            IS ISPF ACTIVE?\n         BNZ   BYE\n         CLC   VLLKEDDT,=F'0'     DID WE SET LKED DATE VARIABLE?\n         BNE   SETVAR2            YES - BRANCH AROUND\n         MVC   FMLKEDDT(L'FMDIRENT),FMDIRENT  NO LKED DATA VAR, SO MOVE\n*                                             DIRENT UP IN ARRAY\nSETVAR2  LINK  EP=ISPLINK,PARAM=(VREPLACE,VARLIST,VLENGTH,VVARS),VL\n         B     BYE                EXIT\n*                                                                       00029\n*                                                                       00031\nBYE      EQU   *                                                        00032\n         LH    R15,RETCODE\n         L     R13,SAV+4                                                00034\n         RETURN (14,12),RC=(15)                                         00035\n*\nDD_NOT_ALLOCATED   EQU  *\n         MVC   FMMSG,=CL80'DDNAME NOT ALLOCATED'\n         MVC   RETCODE,=H'20'\n         B     SETVARS\n*                                                                       00036\nMVPARM1  MVC   BLMEMBER(0),0(R15)\nMVPARM2  MVC   DDNAME(0),0(R15)\n************************ DATA AREAS AND DCB'S ************************* 00037\n*                                                                       00038\nSAV      DS    18F                                                      00039\nDWORK    DS    D\nTIOTPTR  DC    F'0'               PTR TO DDNAME ENTRY IN TIOT\nDDNAME   DC    CL8' '             DDNAME TO SEARCH\nRETCODE  DC    H'0'               RETURN CODE\nIDRREC   DS    CL20               INPUT AREA FOR LKED DATE SEARCH\n*  KEEP TOGETHER *\nBLDLLIST DS    0H\n         DC    H'1'               NUMBER OF ENTRIES IN THE LIST\n         DC    AL2(BLEND-BLMEMBER)  LENGTH OF ENTRY\nBLMEMBER DC    CL8' '             MEMBER NAME\nBLTTR    DS    XL3\nBLCONCAT DS    X                  CONCATENATION NUMBER WHERE FOUND\nBLLIB    DS    X                  FOUND IN LINKLIB, JOBLIB, ETC\nBLINDC   DS    X                  ALIAS INDICATOR/USER DATA LENGTH\n         DS    CL62               USER DATA\nBLEND    EQU   *\n* END KEEP TOGETHER *\n*\nVREPLACE DC    CL8'VREPLACE'      COMMAND TO ISPLINK\n*  VARIABLE NAMES FOR ISPF\nVARLIST  DC    C'(FMCONCAT FMDSNAME FMLIB FMMSG FMLKEDDT FMDIRENT)'\n** VARIABLE ARRAY FOR VREPLACE ***\nVVARS    EQU   *\nFMCONCAT DC    CL3' '\nFMDSNAME DC    CL44' '\nFMLIB    DC    CL8' '\nFMMSG    DC    CL80' '\nFMLKEDDT DC    CL5'*****'\nFMDIRENT DC    CL76' '\n** LENGTH ARRAY FOR VREPLACE ***\nVLENGTH  DS    0F\n         DC    AL4(L'FMCONCAT)\n         DC    AL4(L'FMDSNAME)\n         DC    AL4(L'FMLIB)\n         DC    AL4(L'FMMSG)\nVLLKEDDT DC    AL4(0)             LENGTH OF LKED DATE\nVLDIRENT DC    AL4(0)             LENGTH OF DIRECTORY ENTRY\n**\n*                                                                       00040\nFINDLIB  DCB   DDNAME=X,MACRF=R,DSORG=PO,EODAD=NOLKEDDT                 00041\n         LTORG\n         CVT   DSECT=YES\n         DCBD  DEVD=DA\n         DSECT\n         IEFTIOT1\n         DSECT\n         IEFJFCBN\n         END   FINDMEM                                                  00045\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIB@CLN1": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x12Q\\x00*\\x00*\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T12:51:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "PANELS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "LIB@CLN2": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x12Q\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T12:51:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "PANELS"}, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n    + TYPE(TEXT)  INTENS(LOW)  SKIP(ON)\n    _ TYPE(INPUT)INTENS(HIGH) CAPS(ON) JUST(LEFT)\n    @ TYPE(INPUT) INTENS(LOW)  CAPS(ON) JUST(LEFT)\n    \u001b TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) COLOR(BLUE)\n    ! TYPE(OUTPUT)  INTENS(HIGH)  CAPS(OFF)\n    $ TYPE(OUTPUT)  INTENS(HIGH)  CAPS(OFF) COLOR(RED)\n    * TYPE(OUTPUT)  INTENS(HIGH)  CAPS(OFF) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n+\\-\\%LIBCLEAN MEMBER LIST+\\-\\\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_Z   +\n+\n%New Library:\u001bnewdsn                                    !MATCHTXT   *matchcnt+\n%Old Library:\u001bolddsn                                       %Deleted:*delcount+\n%                                                                   %Flags\n%   Member  NewSize   OldSize  NewDate   OldDate   NewID    OldID    D\n+-------------------------------------------------------------------------------\n)MODEL\n_Z !MEMBER  *NEWSIZE \u001bOLDSIZE *NEWDATE  \u001bOLDDATE  *NEWID   \u001bOLDID   $Z\n)INIT\n .ZVARS='(ZSCROLLD LINECMD FLGDATE)'\n &LINECMD = '__'\n)REINIT\n REFRESH(*)\n)END\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LIB@CLN3": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x12Q\\x00\\x16\\x00\\x16\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T12:51:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "PANELS"}, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n    + TYPE(TEXT)  INTENS(LOW)  SKIP(ON)\n    _ TYPE(INPUT)INTENS(HIGH) CAPS(ON) JUST(LEFT)\n    @ TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF)\n    \u001b TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)\n    * TYPE(OUTPUT)  INTENS(HIGH)  CAPS(ON) COLOR(YELLOW)\n)BODY WINDOW(46,6)\n+                                            +\n+  Confirm delete of members from            +\n+  *DELDSN                                   +\n+                                            +\n+      Delete (Y/N)?_Z+                      +\n+                                            +\n)INIT\n  .ZVARS = '(UCONFIRM)'\n  &UCONFIRM = 'N'\n  .CURSOR = UCONFIRM\n)PROC\n VER (&UCONFIRM,LIST,Y,N)\n)END\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LIB@CLN4": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x12Q\\x00\\x18\\x00\\x18\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T12:51:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "PANELS"}, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n    + TYPE(TEXT)  INTENS(LOW)  SKIP(ON)\n    _ TYPE(INPUT)INTENS(HIGH) CAPS(ON) JUST(LEFT)\n    @ TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF)\n    \u001b TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)\n    * TYPE(OUTPUT)  INTENS(HIGH)  CAPS(ON) COLOR(YELLOW)\n)BODY WINDOW(24,09)\n%BN+Browse New member  +\n%BO+Browse Old member  +\n%C +Compare members    +\n%DN+Delete New member  +\n%DO+Delete Old member  +\n%S +Show LMOD stats    +\n%X +eXclude member     +\n+                      +\n_Z %Enter function     +\n)INIT\n .ZVARS='(LINECMD)'\n &LINECMD = '__'\n)PROC\n VER (&UCONFIRM,LIST,Y,N)\n)END\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LIB@CLN5": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x12Q\\x00\\x13\\x00\\x13\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T12:51:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "PANELS"}, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n    + TYPE(TEXT)  INTENS(LOW)  SKIP(ON)\n    _ TYPE(INPUT)INTENS(HIGH) CAPS(ON) JUST(LEFT)\n    @ TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF)\n    \u001b TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)\n    * TYPE(OUTPUT)  INTENS(HIGH)  CAPS(ON) COLOR(YELLOW)\n)BODY WINDOW(45,5)\n+                                           +\n+  Delete members from%OLD+or%NEW+library?  +\n+                                           +\n%  ==>_Z  +\n+                                           +\n)INIT\n  .ZVARS = '(OPER)'\n)PROC\n VER (&OPER,LIST,NEW,OLD)\n)END\n\u001a\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LIBCLEAN": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x96\\x04?\\x00\\x96\\x04?\\x15!\\x01\\xef\\x01\\xef\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1996-02-12T00:00:00", "modifydate": "1996-02-12T15:21:00", "lines": 495, "newlines": 495, "modlines": 0, "user": "REXX"}, "text": "/* rexx */\n/**********************************************************************/\n/*  Library clean utiltity. Compare the directories of two PDS'.      */\n/*  Optionally delete members, compare members, etc.                  */\n/*                                                                    */\n/*  Written by: Rob Wunderlich 4/93                                   */\n/*                                                                    */\n/*MM/YY VER WHO                                                       */\n/*----- --- ---                                                       */\n/*03/94 1.2 RBW Added logic to disallow commands against \"OLD\" lib    */\n/*              when using an unmatched list.                         */\n/*03/94 1.1 RBW Distributed Public Domain version 1.1.                */\n/**********************************************************************/\nlc_version = '1.2'                /* LIBCLEAN version */\n/*    *    *    *    Establish Error Traps    *    *    *    *    *   */\ncall on error name errproc\ncall on failure name errproc\nsignal on syntax name errproc\nsignal on novalue name errproc\nsignal on halt name haltproc\naddress ispexec \"control errors return\"\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n/*  if left(sysvar('SYSUID'),3) \u00ac= 'WTS'\n    then do\n      say 'You not authorized to use LIBCLEAN'\n      exit 8\n    end                       */\n\nflag = ''\nnewsize = ''; newdate = ''; newid = 'LMOD'\noldsize = ''; olddate = ''; oldid = 'LMOD'\ndisp_restore = 0\nalloc_done = 0\ndelcount = 0\nmatchcnt = 0\nsysmembers = 0\ninput_count = 0\nget_out = 0\n\naddress ispexec\n\nok='0 8';\"DISPLAY PANEL(LIB@CLN1)\"\nif rc = 8\n  then exit\nif matchopt = 'U'              /* If option unmatched, */\n  then oldid = ''              /*  then clear default id */\nif matchopt = 'M'\n  then matchtxt = '   Matches:'\n  else matchtxt = 'Nonmatches:'\nrc = LISTDSI(newdsn 'DIRECTORY')\nstatmsg = 'Member list compare in progress...'\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(  )\"            /* tell user work is in progress */\n\nok=0;\"TBCREATE MEMTBL NOWRITE KEYS(MEMBER)\" ,\n   \"NAMES(NEWSIZE OLDSIZE NEWDATE OLDDATE NEWID OLDID FLGDATE)\"\nok=0;\"LMINIT DATAID(OLDLIB) DATASET(\"olddsn\") ENQ(SHRW)\"\nok=0;\"LMINIT DATAID(NEWLIB) DATASET(\"newdsn\") ENQ(SHRW)\"\nok=0;\"LMOPEN DATAID(\"oldlib\") OPTION(INPUT) RECFM(ORECFM) ORG(OORG)\"\nok=0;\"LMOPEN DATAID(\"newlib\") OPTION(INPUT) RECFM(NRECFM) ORG(NORG)\"\nif oorg \u00ac= 'PO' | norg \u00ac= 'PO'\nthen do\n  say '*** ERROR - NewLib or OldLib not partitioned.'\n  call cleanup_after_error\nend\nif orecfm = 'U' | nrecfm = 'U'\n  then if lmodstat = 'Y'\n   then do\n     ok=0;address tso \"ALLOC FI(OLDLIBDD) DA(\"olddsn\") SHR REUSE\"\n     ok=0;address tso \"ALLOC FI(NEWLIBDD) DA(\"newdsn\") SHR REUSE\"\n     alloc_done = 1\n   end\nelse nop\n\n\nmember = ''         /*    */\nend_of_list = 0     /* Reset end of member list indicator */\ndo until end_of_list    /* Do for each member */\n  ok='0 8';\"LMMLIST DATAID(\"newlib\") MEMBER(MEMBER) STATS(YES)\"\n  mlist_rc = rc\n  input_count = input_count + 1\n  if input_count // 10 = 0\n  then do\n    statmsg2 = 'Member' input_count 'of' sysmembers ,\n               '-' strip(matchtxt,'L') matchcnt\n    \"CONTROL DISPLAY LOCK\"\n    \"DISPLAY PANEL(  )\"            /* tell user work is in progress */\n  end\n  if mlist_rc = 0\n  then do                         /* We have a member from newlib */\n    if left(nrecfm,2) = 'FB'\n    then do\n      newsize = zlcnorc\n      newdate = zlmdate\n      newid   = zluser\n    end\n\n\n    ok='0 8';\"LMMFIND DATAID(\"oldlib\") MEMBER(\"member\") STATS(YES)\"\n    if rc = 0                     /* Set flag re member found */\n      then oldmem_match = 1\n      else oldmem_match = 0\n\n    if oldmem_match & matchopt = 'M'     /* If found and looking for */\n    then do                              /*  matches */\n      if left(orecfm,2) = 'FB'           /* Get oldmem stats */\n      then do\n        oldsize = zlcnorc\n        olddate = zlmdate\n        oldid   = zluser\n      end\n      else if lmodstat = 'Y'\n        then do\n          ok=0;address tso \"FINDMEM\" member \"OLDLIBDD\"\n          oldsize = right(c2x(substr(fmdirent,25,3)),6,'0')\n          olddate = jul2greg(fmlkeddt)\n        end\n        else nop\n    end               /* End of oldmem stats */\n\n\n    /* Common actions section */\n    if oldmem_match & matchopt = 'M' |,\n       \u00acoldmem_match & matchopt = 'U'\n    then do\n      if lmodstat = 'Y' & nrecfm = 'U'\n      then do\n        ok=0;address tso \"FINDMEM\" member \"NEWLIBDD\"\n        newsize = right(c2x(substr(fmdirent,25,3)),6,'0')\n        newdate = jul2greg(fmlkeddt)\n      end\n      matchcnt = matchcnt + 1\n      if olddate = '' | newdate = ''  /* If missing old or new date */\n        then flgdate = ''             /*  then skip test */\n      else do\n        if olddate > newdate\n          then flgdate = '>'\n          else flgdate = ''\n      end\n      ok=0;\"TBADD MEMTBL\"\n\n    end     /* End of common actions section */\n\n  end\n  if mlist_rc = 8 then end_of_list = 1   /* Indicate no more members */\nend              /* End of do until end_of_list */\n\nok='0 8';\"LMMLIST DATAID(\"newlib\") OPTION(FREE)\"\nok=0;\"LMCLOSE DATAID(\"newlib\")\"\nok=0;\"LMCLOSE DATAID(\"oldlib\")\"\n\nok=0;\"LMOPEN DATAID(\"newlib\") OPTION(OUTPUT)\"\nok=0;\"LMOPEN DATAID(\"oldlib\") OPTION(OUTPUT)\"\nok=0; address ispexec \"TBTOP MEMTBL\"\ndo forever\n  ok='0 4 8';address ispexec \"TBDISPL MEMTBL PANEL(LIB@CLN2)\"\n  if rc = 8 then leave\n  i = ztdsels              /* Number of selected rows */\n  do i                     /* Do for all selected rows */\n    call process_linecmd   /* Go process entered line commands */\n    if ztdsels > 1         /* If more than one row selected */\n    then do                /*  then go fetch the next row */\n      ok='0 4 8';\"TBDISPL MEMTBL\"\n    end\n  end\n  if zcmd \u00ac= '' then call process_zcmd  /* If entry in COMMAND line */\n  if get_out\n    then leave\n  ok='0 8';\"TBSKIP MEMTBL ROW(\"ztdtop\")\"   /* Set top display row */\nend\n\nok=0;address ispexec \"TBEND MEMTBL\"\nok=0;\"LMCLOSE DATAID(\"oldlib\")\"\nok=0;\"LMFREE DATAID(\"newlib\")\"\nok=0;\"LMFREE DATAID(\"oldlib\")\"\n\nzedsmsg = delcount \"members deleted\"\nzedlmsg = ''\nok=0;\"SETMSG MSG(ISRZ000)\"\n\nexit\n\n/**********************************************************************/\n/* Line Command Routine                                               */\n/**********************************************************************/\nprocess_linecmd:\nlinecmd = strip(linecmd,'B','_')\nmember = strip(member,'B')\n\nif matchopt = 'M'\n  then valid_linecmds = 'BN BO C DN DO S X'  /* Linecmds for MATCHED */\n  else valid_linecmds = 'BN DN S X'          /* Linecmds for UNMATCHED*/\ndo while wordpos(linecmd,valid_linecmds) = 0 /* Valid line cmds */\n  ok = 0;\"ADDPOP ROW(7) COLUMN(10)\"     /* Set popup mode */\n  ok='0 8';\"DISPLAY PANEL(LIB@CLN4)\"    /* Display command selections*/\n  save_rc = rc                          /* Save return code          */\n  ok=0;\"REMPOP\"                         /* Clear popup mode */\n  if save_rc = 8                        /* If user pressed END  */\n    then return                         /*  then return to caller */\n  linecmd = strip(linecmd,'B','_')\nend\n\nselect\n\n  when linecmd = 'BO' | linecmd = 'BN'\n  then do\n    ok=0;\"CONTROL DISPLAY SAVE\"          /* save display environment */\n    disp_restore = 1                     /* restore required */\n    if linecmd = 'BO'\n      then \"BROWSE DATAID(\"oldlib\") MEMBER(\"member\")\"\n      else \"BROWSE DATAID(\"newlib\") MEMBER(\"member\")\"\n    ok=0;\"CONTROL DISPLAY RESTORE\"       /* restore display env */\n    disp_restore = 0\n  end\n\n  when linecmd = 'C'                     /* Compare members */\n  then do\n    if orecfm = 'U' | nrecfm = 'U'\n      then cp_ctype = 'BYTE'\n      else cp_ctype = 'LINE'\n    if right(olddsn,1) = \"'\"           /* If quoted dsname, */\n      then x = length(olddsn) - 1      /*  then set insert position */\n      else x = length(olddsn)          /*  else insert after dsname */\n    old_dsname = insert(\"(\"member\")\",olddsn,x)\n    ok=0; address tso,\n      \"ALLOC FI(OLDDD) DA(\"old_dsname\") SHR REUSE\"\n\n    if right(newdsn,1) = \"'\"           /* If quoted dsname, */\n      then x = length(newdsn) - 1      /*  then set insert position */\n      else x = length(newdsn)          /*  else insert after dsname */\n    new_dsname = insert(\"(\"member\")\",newdsn,x)\n    ok=0; address tso,\n      \"ALLOC FI(NEWDD) DA(\"new_dsname\") SHR REUSE\"\n\n    compare_outdd_fname = \"'\"userid()\".SUPERC.LIST'\"\n    call msg 'OFF'\n    ok='*'; address tso,\n      \"ALLOC FI(OUTDD) DA(\"compare_outdd_fname\") OLD REUSE\"\n    call msg 'ON'\n    if rc > 0\n    then do\n      ok=0; address tso,\n        \"ALLOC FI(OUTDD) DA(\"compare_outdd_fname\") NEW REUSE\",\n        \"DSORG(PS) RELEASE SPACE(50 100) BLKSIZE(3325)\"\n    end\n    ok=0; address tso,\n      \"ALLOC FI(SYSIN) DUMMY REUSE\"\n\n    /* Invoke SuperC */\n    ok='*';\"SELECT PGM(ISRSUPC) PARM(DELTAL,LINECMP,)\"\n    ok=0;\"CONTROL DISPLAY SAVE\"       /* Save display environ        */\n    disp_restore = 1                  /* Indicate RESTORE required   */\n    ok=0;\"BROWSE DATASET(\"compare_outdd_fname\")\" /* Browse output    */\n    ok=0;\"CONTROL DISPLAY RESTORE\"               /* Restore display  */\n    disp_restore = 0                  /* Reset restore flag          */\n    ok=0; address tso,\n      \"FREE FI(OUTDD,SYSIN,OLDDD,NEWDD)\"\n\n  end    /* End of Compare line command */\n\n\n  when linecmd = 'DO' | linecmd = 'DN'\n  then do\n    ok=0;\n    if linecmd = 'DO'\n      then \"LMMDEL DATAID(\"oldlib\") MEMBER(\"member\")\"\n      else \"LMMDEL DATAID(\"newlib\") MEMBER(\"member\")\"\n    delcount = delcount + 1\n    ok=0;\"TBDELETE MEMTBL\"        /* Delete the row */\n/* If the following TBSKIP is not done, the wrong row may be deleted */\n    ok='0 8';\"TBSKIP MEMTBL NUMBER(0)\"  /* Refetch the vars */\n  end\n\n  when linecmd = 'S'\n  then do\n    if \u00acalloc_done\n    then do\n      ok=0;address tso \"ALLOC FI(NEWLIBDD) DA(\"newdsn\") SHR REUSE\"\n      ok=0;address tso \"ALLOC FI(OLDLIBDD) DA(\"olddsn\") SHR REUSE\"\n      alloc_done = 1\n    end\n    if nrecfm = 'U'\n    then do\n      ok=0;address tso \"FINDMEM\" member \"NEWLIBDD\"\n      newsize = right(c2x(substr(fmdirent,25,3)),6,'0')\n      newdate = jul2greg(fmlkeddt)\n    end\n    if orecfm = 'U'\n    then do\n      ok=0;address tso \"FINDMEM\" member \"OLDLIBDD\"\n      oldsize = right(c2x(substr(fmdirent,25,3)),6,'0')\n      olddate = jul2greg(fmlkeddt)\n    end\n\n    if olddate > newdate\n      then flgdate = '>'\n      else flgdate = ''\n\n    ok=0;\"TBPUT MEMTBL\"          /* Update the row */\n\n  end\n\n  when linecmd = 'X'\n  then do\n    ok=0;\"TBDELETE MEMTBL\"        /* Delete the row */\n/* If the following TBSKIP is not done, the wrong row may be deleted */\n    ok='0 8';\"TBSKIP MEMTBL NUMBER(0)\"  /* Refetch the vars */\n  end\n\n  otherwise nop;\n\nend\nreturn\n\n/**********************************************************************/\n/* Primary Command Routine                                            */\n/**********************************************************************/\nprocess_zcmd:\nparse var zcmd zcmd oper\nupper oper\nselect\n\n  when zcmd = 'DELETE'\n  then do\n\n    if matchopt = 'U'                       /* If Unmatched list, then*/\n      then oper = 'NEW'                     /* force delete from NEW */\n    do while wordpos(oper,'NEW OLD') = 0    /* Valid operands  */\n      ok = 0;\"ADDPOP ROW(7) COLUMN(10)\"     /* Set popup mode */\n      ok='0 8';\"DISPLAY PANEL(LIB@CLN5)\"    /* Display oper prompt */\n      save_rc = rc                          /* Save return code   */\n      ok=0;\"REMPOP\"                         /* Clear popup mode */\n      if save_rc = 8                        /* If user pressed END  */\n        then return                         /*  then return to caller */\n    end\n\n    if oper = 'OLD'\n      then deldsn = olddsn\n      else deldsn = newdsn\n\n    ok=0;\"ADDPOP ROW(8) COLUMN(15)\"  /* POSITION THE POP UP */\n    ok=0;\"DISPLAY PANEL(LIB@CLN3)\"\n    save_rc = rc\n    ok=0;\"REMPOP\"               /* Remove the popup */\n    if uconfirm \u00ac= 'Y' | save_rc > 0\n    then do\n      zedsmsg = 'Delete cancelled'\n      zedlmsg = 'Delete was cancelled at your request.'\n      ok=0;\"SETMSG MSG(ISRZ001)\"\n    end\n    else do\n    if oper = 'OLD'\n      then dellib = oldlib\n      else dellib = newlib\n      ok=0;\"TBTOP MEMTBL\"                /* Set table to top */\n      do until rc = 8\n        ok='0 8';\"TBSKIP MEMTBL NUMBER(1)\"  /* Read table row */\n        if rc = 0                        /* If a row was read */\n        then do\n          ok=0;\"LMMDEL DATAID(\"dellib\") MEMBER(\"member\")\"\n          delcount = delcount + 1\n          if delcount // 10 = 0\n          then do\n            ok=0;\"CONTROL DISPLAY LOCK\"\n            ok=0;\"DISPLAY PANEL(  )\"\n          end\n        end\n      end\n      get_out = 1\n    end\n  end\n\n  when abbrev('LOCATE',zcmd,1)\n  then do\n    ok=0;\"TBTOP MEMTBL\"\n    member = oper\n    ok=0;\"TBSCAN MEMTBL ARGLIST(MEMBER)\" ,\n         \"CONDLIST(GE)\"\n  end\n\n/* 'VERsion' command. Display EXEC version number */\n  when abbrev('VERSION',zcmd)       /* If version cmd */\n  then do\n    zedsmsg = 'LIBCLEAN version' lc_version\n    zedlmsg = ''\n    ok=0;\"SETMSG MSG(ISRZ000)\"  /*  display messages */\n  end\n\n  otherwise do\n    zedsmsg = 'Invalid command'\n    zedlmsg = '\"'zcmd'\" is not a recognized primary command.' ,\n              'Valid commands are DELETE.'\n    ok=0;\"SETMSG MSG(ISRZ001)\"\n  end\n\nend\nreturn\n\n/**********************************************************************/\n/*   Halt routine                                                     */\n/**********************************************************************/\nhaltproc:\nsignal off syntax\nsignal off novalue\ncall off error\ncall off failure\ncall cleanup_after_error\nexit\n\n/**********************************************************************/\n/*   Function to convert julian date to gregorian                     */\n/**********************************************************************/\njul2greg:\nprocedure\nparse arg date\n\ndays.1 = 31\ndays.2 = 28\ndays.3 = 31\ndays.4 = 30\ndays.5 = 31\ndays.6 = 30\ndays.7 = 31\ndays.8 = 31\ndays.9 = 30\ndays.10 = 31\ndays.11 = 30\ndays.12 = 31\n\n/*** julian to gregorian conversion ***/\nyear = substr(date,1,2)\nday = substr(date,3)\njulian = day\n\n/*  validate input */\nif verify(date,'0123456789') \u00ac= 0\nthen do\n  say 'Invalid characters in julian date'\n  exit 8\nend\nif year // 4 = 0\n  then max_julday = 366\n  else max_julday = 365\nif day < 1 | day > max_julday\nthen do\n  say 'Invalid value for julian day'\n  exit 8\nend\n\n/* input is ok. Calculate gregorian */\nif year // 4 = 0 then days.2 = 29\nmonth = 1\ndo while day > days.month\n  day = day - days.month\n  month = month + 1\nend\ndate = right(year,2,'0')||'/'||right(month,2,'0')||'/'||right(day,2,'0')\nreturn date  /* return to caller */\n/**********************************************************************/\n/* Cleanup after error                                                */\n/**********************************************************************/\ncleanup_after_error:\n\"LMCLOSE DATAID(\"newlib\")\"\n\"LMCLOSE DATAID(\"oldlib\")\"\n\"LMFREE DATAID(\"newlib\")\"\n\"LMFREE DATAID(\"oldlib\")\"\n\"TBEND MEMTBL\"\nif disp_restore\n  then \"CONTROL DISPLAY RESTORE\"\nexit\n/*********************************************************************/\n/**   standard error handling routine                               **/\n/*********************************************************************/\nerrproc:\nif (condition('c') = 'ERROR' | condition('c') = 'FAILURE') ,\n   & symbol('OK') = 'VAR'\n  then if wordpos(rc,ok) > 0 | ok = '*' then return;   /* Not an error*/\n/* Cancel error traps to prevent recursion */\nsignal off syntax\nsignal off novalue\ncall off error\ncall off failure\n/* error presentation code */\nerror_type = condition('c')\nsay error_type 'at line' sigl ':' condition('d')\nif error_type = 'SYNTAX'\n  then say errortext(rc)\nif (error_type = 'ERROR' | error_type = 'FAILURE') ,\n    & symbol('zerrlm') = 'VAR'\n  then say zerrlm\nif error_type = 'ERROR' | error_type = 'FAILURE'\n  then say 'Return code = ' rc\ncall cleanup_after_error\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT474/FILE474.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT474", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}