{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012127000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE470.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE470.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x07'", "DS1TRBAL": "b'\\x9b\\xa8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03q\\x00\\x08\\x03q\\x00\\x0e\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n0        WRITTEN BY MIKE AMLING, CNA INSURANCE, CHICAGO,IL\n1\n0                     DYNAMIC ALLOCATION MACROS               PAGE 1\n0                        USAGE SPECIFICATIONS\n                      VERSION 2.8 AS OF 10/11/84\n0SUMMARY OF AMENDMENTS:  THE FOLLOWING  CHANGES BRING THIS MANUAL TO\n LEVEL 2.8:\n  THE USE OF THE @ CHARACTER FOR RUN-TIME VALUES IS STRESSED.\n  THE DYNAMIC  ALLOCATION MACROS WILL  TAKE ADDRESSES OF  VALUES NOT\n KNOWN AT ASSEMBLY  TIME.  TO INDICATE THAT  AN OPERAND OF A  DDD OR\n FREE MACRO IS AN ADDRESS OF A VALUE RATHER THAN A VALUE ITSELF, ADD\n THE CHARACTER '@' TO THE END OF AN RX-TYPE ADDRESS IN THE OPERAND.\n  THE FOLLOWING CHANGES BRING THIS MANUAL TO LEVEL 2.7:\n  MINOR ENHANCEMENTS TO THE EXPLANATION OF THE USE OF THE @ SIGN.\n  THE FOLLOWING CHANGES BRING THIS MANUAL TO LEVEL 2.6:\n  THE DCB=BUFNO KEYWORD,  THE DCB=KEYLEN KEYWORD,  THE FIRST OR ONLY\n SUBPARAMETER  OF  THE   COPIES  KEYWORD,   AND  THE   VOLUME  COUNT\n SUBPARAMETER OF THE  VOLUME KEYWORD OF THE DDD MACRO  ARE NO LONGER\n LIMITED TO VALUES LESS THAN 128.\n  THE DDD  MACRO SUPPORTS THE FOLLOWING  OPERANDS WHICH MAY  BE USED\n ONLY    WHEN   EXECUTING    UNDER    MVS/XA:    BURST=,     CHARS=,\n COPIES=(,(GROUP,VALUES)), FLASH=, MODIFY=, UNIT=(,,DEFER).\n  THE DEFAULT  ERROR EXIT  HAS BEEN  CHANGED TO  INVOKE IKJEFF18  TO\n WRITE A WTO DESCRIBING THE ERROR.\n  THE  MACROS WILL  WORK  IN 31-BIT  ADDRESSING  MODE UNDER  MVS/XA.\n (SINCE IKJEFF18  OPERATES IN 24-BIT  ADDRESSING MODE,   THE DEFAULT\n ERROR  EXIT ROUTINE  SHOULD  NOT BE  USED IF  THE  LITERAL POOL  OR\n WORKING STORAGE ARE ABOVE THE 16 MEGABYTE LINE.)\n  THE USE OF '@' FOR SPECIFYING TEXT UNIT PARAMETER VALUES NOT KNOWN\n AT ASSEMBLY TIME IS NOW DOCUMENTED.\n  THE KEYADDS KEYWORD  OF THE DDD,  DDI AND FREE  MACROS WILL ACCEPT\n ADDRESSES OF FULLWORDS POINTING TO TEXT UNITS.\n1\n0                     DYNAMIC ALLOCATION MACROS               PAGE 2\n0FUNCTION:\n0     THE DYNAMIC ALLOCATION MACROS (DDD, FREE, CONCAT, DDDD,  DDTU)\n      CONSTRUCT THE  REQUEST BLOCK  AND TEXT  UNIT ADDRESS  LIST FOR\n      DYNAMIC ALLOCATION, ISSUE THE \"DYNALLOC MACRO\" (SVC 99),  TEST\n      THE RETURN CODE,   AND IF IT IS  NOT 0,  ABEND OR  BRANCH TO A\n      USER-SPECIFIED RECOVERY ROUTINE.\n       THE DYNAMIC  ALLOCATION MACROS PERFORM  \"DYNAMIC ALLOCATION\",\n      \"DYNAMIC UNALLOCATION\" AND \"DYNAMIC CONCATENATION\".\n0      THOSE OPERANDS OF THE MACROS THAT HAVE EQUIVALENTS IN THE JCL\n      DD STATEMENT MAY ALL BE CODED THE  SAME WAY AS THEY ARE IN JCL\n      (WITH A FEW EXCEPTIONS NOTED IN THIS MANUAL).   THOSE OPERANDS\n      THAT SPECIFY  NUMERIC  VALUES  MAY  ALSO   BE  CODED  AS  NON-\n      RELOCATABLE ASSEMBLER EXPRESSIONS.\n       AS  SUPPORT  FOR TEXT  UNIT  PARAMETER  VALUES NOT  KNOWN  AT\n      ASSEMBLY  TIME,  ANY  OPERAND  WHOSE  CORRESPONDING TEXT  UNIT\n      CONTAINS A  PARAMETER VALUE  (WITH A  FEW EXCEPTIONS  NOTED IN\n      THIS MANUAL)   MAY BE CODED  AS AN RX-TYPE  ADDRESS EXPRESSION\n      FOLLOWED BY THE CHARACTER '@'.  THE RX-TYPE ADDRESS MUST POINT\n      TO STORAGE  CONTAINING THE  VALUE TO BE  PLACED INTO  THE TEXT\n      UNIT FOR THAT OPERAND.  VALUES FOR OPERANDS OF VARYING LENGTHS\n      MUST  BE PADDED  TO THE  MAXIMUM LENGTH  ALLOWED.  THE  MACROS\n      SUPPLY THE TEXT UNIT KEY, NUMBER AND LENGTH.\n       THEY USE  GLOBAL SYMBOLS  TO DETERMINE THE  LENGTH OF  A WORK\n      AREA AND WHETHER CERTAIN FEATURES HAVE BEEN USED.\n       FULL DOCUMENTATION ON  THE USE OF DYNAMIC  ALLOCATION AND SVC\n      99 IS  IN OS/VS2 SYSTEM  PROGRAMMING LIBRARY:   JOB MANAGEMENT\n      (GC28-0627-1)  OR  MVS/XA SYSTEM PROGRAMMING  LIBRARY:  SYSTEM\n      MACROS AND FACILITIES (GC28-1150-1).   JCL REFERENCE IS OS/VS2\n      MVS JCL (GC28-0692-3).\n       EXAMPLE:  ALLOCATE DDNAME SYSUT1 TO A DATASET WHOSE NAME WILL\n      NOT BE KNOWN UNTIL RUN TIME.\n0     * ALLOCATE THE DATASET WHOSE NAME IS IN THE 44 BYTES FROM MYWORK+16\n      *  THRU MYWORK+59 WITH MEMBER NAME IN THE 8 BYTES BEGINING 2 BYTES\n      *  AFTER THE ADDRESS CONTAINED IN GENERAL REGISTER RN.\n      SYSUT1   DDD   DSN=MYWORK+16@(2(RN)@),DISP=SHR\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 3\n0 DDD (DYNAMIC DATA DEFINITION) - PERFORM DYNAMIC ALLOCATION\n0     THE  DDD  MACRO,   MODELED  AFTER   THE  JCL  DD  STATEMENT,\n CONSTRUCTS A TEXT  UNIT LIST AND CALLS A SUBROUTINE  (IN THE DDDD\n MACRO EXPANSION)   TO ISSUE SVC  99.  IF  DDD IS ISSUED  DURING A\n CONCATENATION IT ALSO CONSTRUCTS PART  OF A DYNAMIC CONCATENATION\n TEXT UNIT. THE DDD MACRO EXPANSION CONTAINS ONLY EXECUTABLE CODE.\n0SYNTAX:\n0                                                                -\n\n  NAME                           'RETURN' CODED AS THE NAME\n                               INDICATES A REQUEST FOR THE RETURN\n                               OF THE DDNAME (SEE BELOW).  ANY\n                               OTHER VALUE IS INTERPRETED AS A\n                               DDNAME SPECIFICATION EXACTLY AS IN\n                               JCL.\n0 DDD                            PRECEDED AND FOLLOWED BY AT LEAST\n                               ONE BLANK.\n                                                                 -\n\n0    DUMMY                      POSITIONAL PARAMETER, OPTIONAL.\n                               IF USED, MUST BE CODED AS SHOWN.\n                               INDICATES ALLOCATION OF A DUMMY\n                               DATASET, EXACTLY AS IN JCL.\n0    KEYWORDS:                  OPTIONAL. USE KEYWORDS TO INDICATE\n                               SPECIFICS OF THE ALLOCATION.\n                                                                 -\n\n  THE KEYWORD OPERANDS OF DDD MAY BE CODED, FOR THE MOST PART,  AS\n         IF THEY WERE KEYWORDS OF THE  JCL DD STATEMENT.   THE DDD\n         OPERANDS VALUES ARE NOT ALWAYS KNOWN AT ASSEMBLY TIME AND\n         FOR THIS  REASON,   DDD  ACCEPTS   ADDRESSES  OF  DYNAMIC\n         ALLOCATION\n  DDD SUPPORTS  THE  FOLLOWING KEYWORDS  (WITH  NOTED  EXCEPTIONS)\n         EXACTLY AS IN JCL:\n0      DISP=  (EXCEPTION:   DYNAMIC  ALLOCATION DOES  NOT  SUPPORT\n              PASSED  DATASETS (DISP=(,PASS) OR DISP=(,,PASS)))\n       SPACE=  (EXCEPTION:   DYNAMIC ALLOCATION  DOES NOT  SUPPORT\n              ABSOLUTE TRACK ALLOCATION (SPACE=(ABSTR,...)))\n       UNIT=  (UNIT=(,,DEFER)   FOR EXECUTION  UNDER MVS/XA  ONLY.\n              EXCEPTON:    DYNAMIC  ALLOCATION  DOES  NOT  SUPPORT\n              UNIT=AFF=.   A  PARALLEL MOUNT UNIT=(,P)   CANNOT BE\n              SPECIFIED AS AN RX-TYPE ADDRESS FOLLOWED BY '@'.)\n       VOL=,VOLUME=   (EXCEPTION:   DYNAMIC  ALLOCATION  DOES  NOT\n              SUPPORT    THE    SECOND     POSITIONAL    PARAMETER\n              (VOL=(,RETAIN)),    OR   VOLUME   SPECIFICATION   BY\n              REFERENCE TO A DDNAME (VOL=REF=*. ))\n       MSVGP=  (EXCEPTION:  DYNAMIC ALLOCATION DOES  NOT SUPPORT A\n              DDNAME FOR VOLUME SEPARATION)\n       CHARS=  (FOR EXECUTION UNDER MVS/XA ONLY.   NOTE: IF CHARS=\n              IS SPECIFIED AS AN RX-TYPE  ADDRESS FOLLOWED BY '@',\n              ONLY  ONE CHARACTER  ARRANGEMENT TABLE  NAME MAY  BE\n              SPECIFIED)\n       COPIES= (GROUP VALUES  FOR THE  3800 PRINTER  FOR EXECUTION\n              UNDER MVS/XA ONLY. GROUP VALUES MAY NOT BE SPECIFIED\n              AS AN RX-TYPE ADDRESS FOLLOWED BY '@'.)\n       LABEL=\n       PROTECT=\n       FREE=\n       QNAME=\n       TERM=\n       SYSOUT=\n       DEST=\n       HOLD=\n       FCB=\n       OUTLIM=\n       UCS=\n       BURST= (FOR EXECUTION UNDER MVS/XA ONLY)\n       FLASH= (FOR EXECUTION UNDER MVS/XA ONLY)\n       MODIFY= (FOR EXECUTION UNDER MVS/XA ONLY)\n       SUBSYS=\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 4\n0      DDD SUPPORTS THE FOLLOWING KEYWORDS WITH LIMITED FUNCTION:\n0      DSN=,DSNAME=   (EXCEPTION:   DYNAMIC  ALLOCATION  DOES  NOT\n              SUPPORT AN AREA  NAME FOR AN ISAM  DATASET OR DSNAME\n              SPECIFICATION BY REFERENCE TO A DDNAME (DSN=*. ))\n          DDD DOES  NOT  SUPPORT  THE   SINGLE-AMPERSAND  FORM  OF\n              DSN=,DSNAME=  FOR SYSTEM-NAMED  TEMPORARY  DATASETS.\n              USE THE DOUBLE-AMPERSAND FORM.\n          IF A MEMBER NAME IS DESIRED,  SPECIFY  IT AS IN JCL,  IN\n              PARENTHESES AFTER THE DSNAME. THE ACTUAL MEMBER NAME\n              MAY BE SPECIFIED,  IF KNOWN AT ASSEMBLY TIME,  OR AN\n              RX-TYPE ADDRESS EXPRESSION FOLLOWED  BY '@' MAY GIVE\n              THE ADDRESS OF AN 8-BYTE FIELD WHERE THE MEMBER NAME\n              MAY BE FOUND (PADDED WITH BLANKS) AT RUN TIME.\n0      DCB=  (EXCEPTION:   DYNAMIC ALLOCATION DOES NOT SUPPORT DCB\n              REFERENCE  TO A  DDNAME IN  A PREVIOUS  JOB STEP  OR\n              DCB=CYLOFL= OR DCB=NTM=)\n0              DDD SUPPORTS DCB  REFERENCE TO A  CATALOGED DATASET\n                   OR DCB REFERENCE  TO A DDNAME IN  THIS JOB STEP\n                   EXACTLY AS IN JCL.\n          DDD SUPPORTS THE  FOLLOWING DCB SUB-KEYWORDS  EXACTLY AS\n              IN JCL:\n                 BLKSIZE=\n                 BUFL=\n                 BUFNO=\n                 DEN=\n                 EROPT=\n                 KEYLEN=\n                 LIMCT=\n                 LRECL=\n                 NCP=\n                 OPTCD=\n                 RECFM=\n            DDD HAS LIMITED  SUPPORT FOR  THE  FOLLOWING DCB  SUB-\n                KEYWORD:\n                 DSORG=   FOR DA, PO OR PS ONLY.\n-           DDD DOES NOT SUPPORT THE FOLLOWING DCB SUB-KEYWORDS:\n                 BFALN=,   BFTEK=,   BUFIN=,   BUFMAX=,   BUFOFF=,\n                     BUFOUT=,  BUFSIZE=,  CODE=,  CPRI=,  DIAGNS=,\n                     FRID=, FUNC=,  GNCP=,  INTVL=,  MODE=,  PCI=,\n                     PRTSP=, RESERVE=, STACK=, THRESH=, TRTCH=.\n0           DDD DOES NOT  SUPPORT THE  FOLLOWING DCB  SUB-KEYWORDS\n                THAT HAVE NO JCL COUNTERPARTS:\n                 BUFRQ=, IPLTXTID=, SOWA=.\n       DYNAMIC ALLOCATION DOES NOT SUPPORT THE FOLLOWING KEYWORDS:\n            AMP=, CHKPT=EOV, DDNAME=, DLM=, DSID=.\n0      DDD SUPPORTS THE FOLLOWING KEYWORDS NOT IN JCL:\n0      TYPE=PERM  SPECIFIES THE PERMANENTLY ALLOCATED ATTRIBUTE.\n       TYPE=CNVRT  SPECIFIES   THE  CONVERTIBLE   AND  PERMANENTLY\n       ALLOCATED ATTRIBUTES.\n       TYPE=TEMP  SPECIFIES NEITHER ATTRIBUTE.\n          DEFAULT: TYPE=PERM, AS USED BY THE ALLOC COMMAND.\n0      MOUNT=YES   SPECIFIES  THAT DYNAMIC  ALLOCATION  MAY  BRING\n       DEVICES  ONLINE  AND  MOUNT  VOLUMES  FOR  THIS  ALLOCATION\n       (UNLESS  ISSUED   BY  TIME   SHARING  USER   WITHOUT  MOUNT\n       AUTHORITY).\n       MOUNT=NO    SPECIFIES THAT  DYNAMIC  ALLOCATION  IS NOT  TO\n       BRING DEVICES ONLINE OR MOUNT VOLUMES FOR THIS ALLOCATION.\n          DEFAULT: MOUNT=NO.\n0      KEYADDS=   SPECIFIES  1  OR   MORE  RX-TYPE  ADDRESSES  (OR\n       REGISTER NUMBERS ENCLOSED IN PARENTHESES)  OF USER-SUPPLIED\n       TEXT UNITS TO BE INCLUDED WITH  THE TEXT UNITS GENERATED BY\n       THE DDD  MACRO.  DDD DOES  NOT INITIALIZE OR  INSPECT THESE\n       TEXT UNITS.   AN  RX-TYPE ADDRESS NOT FOLLOWED BY  A '@' IS\n       THE ADDRESS OF A TEXT UNIT.  AN RX-TYPE ADDRESS FOLLOWED BY\n       A '@' IS  THE ADDRESS OF A FULLWORD  CONTAINING THE ADDRESS\n       OF A TEXT UNIT.   A REGISTER (ENCLOSED IN PARENTHESES) MUST\n       CONTAIN THE ADDRESS OF A TEXT UNIT AND MUST NOT BE FOLLOWED\n       BY A '@'.\n          DEFAULT: NONE.\n0      EXIT=      SPECIFIES AN  RX-TYPE ADDRESS  OF OR  (REGISTER)\n       CONTAINING THE  ADDRESS OF  A USER  ERROR-HANDLING ROUTINE.\n       CODE IN THE  DDDD MACRO WILL BRANCH TO THIS  ROUTINE IF THE\n       RETURN CODE FROM DYNAMIC ALLOCATION IS NOT 0.  REGISTERS ON\n       ENTRY TO THE ERROR-HANDLING ROUTINE ARE:\n                REGISTER 14  - RETURN ADDRESS TO  RESUME EXECUTION\n                AS IF THE RETURN CODE FROM SVC 99 HAD BEEN 0.   IF\n                THE DDD MACRO WAS NOT PART OF A CONCATENATION THIS\n                WILL BE THE ADDRESS OF THE FIRST INSTRUCTION AFTER\n                THE DDD MACRO.\n                REGISTER  15  -  ADDRESS   OF  THE  ERROR-HANDLING\n                ROUTINE.\n                REGISTER 0  - CONTENTS OF  REGISTER 15 AS RETURNED\n                BY SVC 99.\n                REGISTER  1  -  SAME  AS WHEN  SVC  99 WAS  ISSUED\n                (POINTS TO A FULLWORD THAT CONTAINS THE ADDRESS OF\n                THE DYNAMIC ALLOCATION REQUEST BLOCK).\n                REGISTERS 2 THRU 13 -  UNCHANGED FROM ENTRY TO THE\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 5\n0               DDD MACRO.\n          DEFAULT:  A ROUTINE INTERNAL TO  THE MACROS THAT INVOKES\n       IKJEFF18  TO ISSUE  A  DIAGNOSTIC  WTO,  AND  ISSUES  ABEND\n       SPECIFYING USER ABEND  CODE 99 WITH DUMP.   ALODFAIL IS THE\n       LABEL  OF   THE  DEFAULT  ERROR-HANDLING  ROUTINE   IN  THE\n       EXPANSION OF  THE DDDD  MACRO (CODE).   YOUR ERROR-HANDLING\n       ROUTINE  MAY EXIT  TO THE  DEFAULT ERROR-HANDLING  ROUTINE,\n       WHICH WILL  ISSUE A DIAGNOSTIC WTO  AND ABEND USER  99,  BY\n       BRANCHING TO THE LABEL ALODFAIL.\n       NOTE: THE ALODFAIL ROUTINE IS GENERATED AS PART OF THE DDDD\n       CODE EXPANSION ONLY  IF SOME PREVIOUS DDD,   FREE OR CONCAT\n       MACRO LEFT THE EXIT=  PARAMETER UNSPECIFIED.  IF NECESSARY,\n       CODE A PARAMETERLESS DDD MACRO AND  ORG BACK OVER IT BEFORE\n       THE DDDD CODE MACRO.\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 6\n0      NOTES:\n0      TO REQUEST THE RETURN OF THE  DDNAME,  CODE 'RETURN' AS THE\n           DDNAME.   WHEN 'RETURN' IS SPECIFIED  IN THE LABEL OF A\n           DDD  MACRO,  DDD  DOES NOT  USE  IT AS  THE DDNAME  BUT\n           INSTEAD INCLUDES A TEXT UNIT  FOR RETURN OF THE DDNAME.\n           THE LABEL ON THE TEXT UNIT  FOR RETURN OF THE DDNAME IS\n           ALWAYS  'ALORTDDN'.     AFTER  THE  DDD   IS  EXECUTED,\n           ALORTDDN+4 CONTAINS THE HALFWORD LENGTH OF THE RETURNED\n           DDNAME  AND  ALORTDDN+6 CONTAINS  THE  RETURNED  DDNAME\n           LEFT-JUSTIFIED AND PADDED WITH BLANKS TO LENGTH 8.\n0      DDD SUPPORTS  QUOTED   OPERANDS  ONLY  FOR   THE  SUBSYSTEM\n           PARAMETERS PORTION OF THE  SUBSYS=  KEYWORD.\n0      THE EXPANSION OF THE DDD MACRO  DOES NOT INCLUDE ANY LABEL.\n           TO BRANCH TO THE DDD MACRO,  BRANCH TO A LABELED  DS 0H\n            BEFORE IT.\n0      ADDRESSABILITY: THE LITERAL POOL AND THE DDDD MACRO MUST BE\n           ADDRESSABLE FROM EVERY DDD MACRO. IF THERE ARE TWO DDDD\n           MACROS  (CODE   AND  STORAGE),    THEN  BOTH   MUST  BE\n           ADDRESSABLE FROM EVERY DDD MACRO.\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 7\n0 FREE - PERFORM DYNAMIC UNALLOCATION\n0     THE FREE MACRO PERFORMS DYNAMIC DEALLOCATION.  IT CONSTRUCTS\n A  TEXT UNIT  LIST  AND CALLS  A SUBROUTINE  (IN  THE DDDD  MACRO\n EXPANSION)   TO  ISSUE  SVC 99.    ITS  EXPANSION  CONTAINS  ONLY\n EXECUTABLE CODE.\n0SYNTAX:\n0                                                                -\n\n  NAME                           ANY VALUE IS INTERPRETED AS A\n                               DDNAME SPECIFICATION.\n0 FREE                           PRECEDED AND FOLLOWED BY AT LEAST\n                               ONE BLANK.\n                                                                 -\n\n0    KEYWORDS:                  OPTIONAL. USE KEYWORDS TO\n                                SPECIFICS OF THE DEALLOCATION.\n                                                                 -\n\n       FREE SUPPORTS THE FOLLOWING KEYWORDS WITH JCL COUNTERPARTS,\n           USING THE SAME SYNTAX AS JCL.\n0      DSN=,DSNAME=   (EXCEPTION:   DYNAMIC  ALLOCATION  DOES  NOT\n           SUPPORT  AN AREA  NAME FOR  AN ISAM  DATASET OR  DSNAME\n           SPECIFICATION BY REFERENCE TO A DDNAME (DSN=*. ))\n0      DISP=   (EXCEPTION:  DYNAMIC  ALLOCATION  DOES NOT  SUPPORT\n           PASSED    DATASETS    (DISP=(,PASS)))     THE    SECOND\n           SUBPARAMETER OF THE DISP KEYWORD BECOMES THE OVERRIDING\n           DISPOSITION.\n0      SYSOUT= SPECIFIES AN  OVERRIDING SYSOUT CLASS FOR  A SYSOUT\n           DATASET.\n0      HOLD=YES  SPECIFIES  HOLD  QUEUE PROCESSING  FOR  A  SYSOUT\n           DATASET.\n       HOLD=NO OVERRIDES A HOLD=YES ON THE ORIGINAL ALLOCATION.\n0      DEST=  SPECIFIES AN  OVERRIDING  REMOTE  WORKSTATION FOR  A\n           SYSOUT DATASET.\n-      FREE SUPPORTS   THE   FOLLOWING    KEYWORDS   WITHOUT   JCL\n           COUNTERPARTS:\n0      TYPE=EITHER  SPECIFIES REMOVAL OF THE IN-USE ATTRIBUTE FROM\n           THE DDNAME/DSNAME IF  IT HAS THE  PERMANENTLY ALLOCATED\n           ATTRIBUTE AND  UNALLOCATION OF THE DDNAME/DSNAME  IF IT\n           DOES NOT HAVE THE PERMANENTLY ALLOCATED ATTRIBUTE.\n       TYPE=UNALLOC   SPECIFIES THAT  THE DDNAME/DSNAME  IS TO  BE\n           UNALLOCATED EVEN  IF IT  HAS THE  PERMANENTLY ALLOCATED\n           ATTRIBUTE.\n       TYPE=REMOVE  SPECIFIES REMOVAL OF THE IN-USE ATTRIBUTE EVEN\n           IF  THE DDNAME/DSNAME  DOES  NOT  HAVE THE  PERMANENTLY\n           ALLOCATED ATTRIBUTE.\n          DEFAULT: TYPE=UNALLOC\n0      KEYADDS=   SPECIFIES   1  OR  MORE  RX-TYPE   ADDRESSES  OR\n           (REGISTER)  CONTAINING ADDRESSES  OF USER-SUPPLIED TEXT\n           UNITS TO BE  INCLUDED WITH THE TEXT  UNITS GENERATED BY\n           THE FREE  MACRO.  FREE DOES  NOT INITIALIZE  OR INSPECT\n           THESE TEXT UNITS.  IF AN RX-TYPE ADDRESS IS FOLLOWED BY\n           A  '@',   THE  RX-TYPE ADDRESS  POINTS  TO  A  FULLWORD\n           CONTAINING THE ADDRESS OF THE TEXT UNIT.\n          DEFAULT: NONE.\n0      EXIT=      SPECIFIES  AN  RX-TYPE   ADDRESS  OR  (REGISTER)\n           CONTAINING  THE   ADDRESS  OF  A   USER  ERROR-HANDLING\n           ROUTINE.  CODE  IN THE DDDD  MACRO WILL BRANCH  TO THIS\n           ROUTINE IF THE  RETURN CODE FROM DYNAMIC  ALLOCATION IS\n           NOT  0 (EXCEPTION:   IF  THE  ERROR CODE  FROM  DYNAMIC\n           ALLOCATION  IS X'0438'  OR X'0440'  (FREE MACRO  FAILED\n           BECAUSE SPECIFIED  DDNAME OR DSNAME WAS  NOT ALLOCATED)\n           THEN DDDD RETURNS TO THE INVOKING  FREE MACRO AS IF THE\n           RETURN CODE FROM DYNAMIC ALLOCATION HAD BEEN 0.)\n       REGISTERS  ON  ENTRY  TO  THE  ERROR-HANDLING  ROUTINE  ARE\n           EXPLAINED UNDER THE DDD MACRO.\n0      NOTES: THE EXPANSION OF THE FREE MACRO DOES NOT INCLUDE ANY\n           LABEL.   TO BRANCH TO THE FREE MACRO,  CODE A NAMED  DS\n           0H  BEFORE IT.\n       ADDRESSABILITY: THE LITERAL POOL AND THE DDDD MACRO MUST BE\n           ADDRESSABLE FROM  EVERY FREE MACRO.   IF THERE  ARE TWO\n           DDDD  MACROS (CODE  AND STORAGE),   THEN  BOTH MUST  BE\n           ADDRESSABLE FROM EVERY FREE MACRO.\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 8\n0 CONCAT - MARK BEGINNING OR END OF LIST OF DDDS FOR CONCATENATION\n0     THE  CONCAT  MACRO  PERFORMS   DYNAMIC  CONCATENATION.   THE\n DATASETS CONCATENATED ARE ON CONSECUTIVE  DDD MACROS PRECEDED AND\n FOLLOWED BY CONCAT MACROS.  THE USER MAY INTERSPERSE HIS OWN CODE\n WITH DDD MACROS  AFTER THE BEGINNING CONCAT MACRO  AND BEFORE THE\n ENDING CONCAT  MACRO PROVIDED THE USER  CODE DOES NOT  MODIFY THE\n STORAGEE RESERVED  BY THE DDDD  MACRO.  THE CONCAT  MACROS ASSUME\n THAT EACH  DDD MACRO IN THE  CONCATENATION WILL BE  EXECUTED ONCE\n AND ONLY ONCE.\n0SYNTAX:\n0                                                                -\n\n  NAME                           ANY NAME CODED IS IGNORED.\n0 CONCAT                         PRECEDED AND FOLLOWED BY AT LEAST\n                               ONE BLANK.\n                                                                 -\n\n0 B OR E                         POSITIONAL. SPECIFY B AS THE\n                               OPERAND OF THE CONCAT MACRO THAT\n                               PRECEDES THE DDD MACROS TO BE\n                               CONCATENATED.  SPECIFY E (AND,\n                               OPTIONALLY, KEYWORDS) ON THE CONCAT\n                               MACRO THAT FOLLOWS THE DDD MACROS\n                               TO BE CONCATENATED.\n0    KEYWORDS:                  OPTIONAL. USE KEYWORDS WITH THE E\n                               OPERAND TO INDICATE SPECIFICS OF\n                               THE CONCATENATION.\n                                                                 -\n\n  CONCAT SUPPORTS THE FOLLOWING KEYWORDS WITHOUT JCL COUNTERPARTS:\n- TYPE=PERM SPECIFIES THE PERMANENTLY CONCATENATED ATTRIBUTE.\n  TYPE=TEMP OMITS THE PERMANENTLY CONCATENATED ATTRIBUTE.\n     DEFAULT: TYPE=PERM, AS USED BY THE ALLOC COMMAND.\n0 EXIT=     SPECIFIES AN RX-TYPE ADDRESS OR (REGISTER)  CONTAINING\n      THE ADDRESS OF A  USER ERROR-HANDLING ROUTINE.  CODE  IN THE\n      DDDD MACRO  WILL BRANCH TO THIS  ROUTINE IF THE  RETURN CODE\n      FROM DYNAMIC ALLOCATION IS NOT 0.\n  REGISTERS ON ENTRY  TO THE ERROR-HANDLING ROUTINE  ARE EXPLAINED\n      UNDER THE DDD MACRO.\n-\n  NOTES:\n  ADDRESSABILITY:  THE  LITERAL POOL  AND THE  DDDD MACRO  MUST BE\n      ADDRESSABLE FROM EVERY CONCAT MACRO.   IF THERE ARE TWO DDDD\n      MACROS (CODE  AND STORAGE),  THEN  BOTH MUST  BE ADDRESSABLE\n      FROM EVERY CONCAT MACRO.\n1\n0                    DYNAMIC ALLOCATION MACROS              PAGE 9\n0 DDDD - DYNAMIC ALLOCATION SVC ISSUER\n0     THE  DDDD  MACRO  MUST  BE INCLUDED  IN  ANY  ASSEMBLY  THAT\n INCLUDES THE DDD OR FREE MACRO.  NO  DDD OR FREE MACRO MAY APPEAR\n PHYSICALLY AFTER ANY DDDD MACRO. THE USER SHOULD NOT MOVE, MODIFY\n OR BRANCH DIRECTLY TO A DDDD MACRO.\n      THE DDDD MACRO  EXPANDS INTO A PROTOTYPE  DYNAMIC ALLOCATION\n CONTROL BLOCK,  SUFFICIENT WORK SPACE TO CONTAIN THE LONGEST TEXT\n UNIT LIST IN THE ASSEMBLY,  AND  EXECUTABLE CODE TO ISSUE SVC 99,\n CHECK ITS RETURN CODE, AND IF THE RETURN CODE IS NOT ZERO, BRANCH\n TO A RECOVERY ROUTINE SPECIFIED ON THE DDD,  CONCAT OR FREE MACRO\n THAT BRANCHED TO THIS DDDD MACRO.\n0SYNTAX:\n0                                                                -\n\n  NAME                           ANY NAME CODED IS IGNORED.\n0 DDDD                           PRECEDED AND FOLLOWED BY AT LEAST\n                               ONE BLANK.\n                                                                 -\n\n0    CODE                       OPTIONAL. IF CODE IS SPECIFIED,\n                               EXPANSION INCLUDES ONLY EXECUTABLE\n                               CODE, TO INITIALIZE AND USE A WORK\n                               AREA RESERVED BY THE DDDD MACRO\n                               WITH STORAGE SPECIFIED.\n     STORAGE                    OPTIONAL.  IF STORAGE IS\n                               SPECIFIED, EXPANSION INCLUDES NO\n                               EXECUTABLE CODE AND NO CONSTANTS,\n                               BUT MERELY RESERVES SPACE.\n                                                                 -\n\n0 IF NEITHER  CODE NOR  STORAGE  IS  CODED,  THE  RESULTING  MACRO\n      EXPANSION IS REUSABLE BUT NOT REENTRANT.\n0 TO GET REENTRANT CODE,   ISSUE DDDD TWICE,  ONCE WITH  CODE IN A\n      CSECT AND  ONCE WITH STORAGE IN  A DSECT ADDRESSABLE  BY ALL\n      THE DDD,  FREE AND CONCAT MACROS  AND BY THE DDDD WITH CODE.\n      THE STORAGE FORM  OF DDDD RESERVES SPACE  AND DEFINES LABELS\n      FOR USE BY THE DDD,  FREE AND DDDD (CODE)  MACROS.  THE DDDD\n      (CODE)  MACRO DOES ALL INITIALIZATION  OF THE AREA RESERVED.\n      THE USER MAY REUSE THE SPACE  RESERVED BY THE DDDD (STORAGE)\n      MACRO IN  ANY WAY  PROVIDED NO  DYNAMIC ALLOCATION  MACRO IS\n      EXECUTING.\n1\n0                    DYNAMIC ALLOCATION MACROS             PAGE 10\n0 DDTU (DATA DEFINITION  TEXT UNITS)  - DEFINE  DYNAMIC ALLOCATION\n      TEXT UNITS\n0     PURPOSE: THE DDD MACRO GENERATES TEXT UNITS WHOSE VALUES ARE\n      KNOWN  AT ASSEMBLY  TIME.   THE  DDTU MACRO  AIDS IN  CODING\n      DYNAMIC ALLOCATION  TEXT UNITS  WHOSE VALUES  ARE NOT  KNOWN\n      UNTIL EXECUTION TIME.\n0     IN MANY PROGRAMS,  EVEN THOSE WHERE TEXT UNIT VALUES ARE NOT\n      KNOWN AT  ASSEMBLY TIME,  THE  DDTU MACRO IS  NOT NECESSARY.\n      THE  DYNAMIC  ALLOCATION  MACROS  DDD  AND  FREE  WILL  TAKE\n      ADDRESSES OF VALUES NOT KNOWN AT ASSEMBLY TIME.  TO INDICATE\n      THAT AN OPERAND  OF A DDD OR  FREE MACRO IS AN  ADDRESS OF A\n      VALUE RATHER THAN A VALUE ITSELF,   ADD THE CHARACTER '@' TO\n      THE END OF  AN RX-TYPE ADDRESS IN THE  KEYWORD OPERAND.  THE\n      RUN-TIME VALUE FACILITY  IS EASIER TO USE  AND MAINTAIN THAN\n      DDTU.  DDTU IS  NECESSARY ONLY FOR THOSE TEXT  UNITS THAT DO\n      NOT TAKE A VALUE,  SUCH AS TERM=TS,  AND THOSE THAT CAN TAKE\n      MORE THAN  ONE VALUE,   SUCH AS VOL=SER=  FOR MORE  THAN ONE\n      VOLUME.\n0     THE  DDTU  MACRO,   MODELED  AFTER  THE  JCL  DD  STATEMENT,\n      CONSTRUCTS DYNAMIC ALLOCATION TEXT  UNITS WITH USER-SUPPLIED\n      LABELS.\n0     CODE THE DDTU  MACRO WITH JCL KEYWORDS WHOSE  VALUE WILL NOT\n      BE KNOWN  UNTIL EXECUTION  TIME.  FOR  EACH VALUE  NOT KNOWN\n      UNTIL EXECUTION TIME,  CODE AN  ASSEMBLER SYMBOL NOT DEFINED\n      ELSEWHERE IN THE PROGRAM.\n0     THE TEXT  UNITS GENERATED  ARE A  HALFWORD KEY,   A HALFWORD\n      NUMBER-OF-FOLLOWING-PARAMETERS WHICH IS EITHER 0 OR 1,  AND,\n      IF 1, A HALFWORD LENGTH.  THE LENGTH, IF PRESENT,  IS ALWAYS\n      THE MAXIMUM LENGTH  THAT DYNAMIC ALLOCATION WILL  ACCEPT FOR\n      THE TEXT UNIT BEING CREATED.\n0     TEXT UNITS FORMED BY DDTU MAY  BE USED IN DYNAMIC ALLOCATION\n      BY SPECIFYING THEIR LABELS AS SUBPARAMETERS OF THE  KEYADDS=\n       KEYWORD ON  THE DDD OR FREE  MACROS,  OR COPYING THEM  TO A\n      WORKAREA,   MODIFYING  THEM,  AND  SPECIFYING  THE  WORKAREA\n      ADDRESSES AS SUBPARAMETERS OF THE  KEYADDS=  KEYWORD.\n0     THE DDTU MACRO EXPANSION CONTAINS NO EXECUTABLE CODE.\n0SYNTAX:\n0                                                                -\n\n  NAME                           'RETURN' CODED AS THE NAME WILL\n                               BE USED AS THE LABEL OF A TEXT UNIT\n                               FOR SPECIFYING THE RETURN OF THE\n                               DDNAME.  ANY OTHER VALUE IS USED AS\n                               THE LABEL OF A TEXT UNIT FOR\n                               SPECIFYING DDNAME.\n0 DDTU                           PRECEDED AND FOLLOWED BY AT LEAST\n                               ONE BLANK.\n                                                                 -\n\n0    SYMBOL                     POSITIONAL PARAMETER, OPTIONAL.\n                               THE SYMBOL, IF SPECIFIED WILL BE\n                               USED AS THE LABEL OF A TEXT UNIT\n                               FOR SPECIFYING A DUMMY DATASET.\n0    KEYWORDS:                  OPTIONAL. USE KEYWORDS TO INDICATE\n                               LABELS FOR ADDITIONAL TEXT UNITS.\n                                                                 -\n\n       DDTU WILL FORM DYNAMIC ALLOCATION  TEXT UNITS CORRESPONDING\n              TO THE   FOLLOWING   JCL    KEYWORDS   (WITH   NOTED\n              EXCEPTIONS)\n0      DSN=,DSNAME=   (EXCEPTION:   DYNAMIC  ALLOCATION  DOES  NOT\n              SUPPORT SPECIFICATION  BY  REFERENCE   TO  A  DDNAME\n              (DSN=*. ))\n       DISP=\n       VOL=,VOLUME=   (EXCEPTION:   DYNAMIC  ALLOCATION  DOES  NOT\n              SUPPORT    THE    SECOND     POSITIONAL    PARAMETER\n              (VOL=(,RETAIN)),    OR   VOLUME   SPECIFICATION   BY\n              REFERENCE TO A DDNAME (VOL=REF=*. ))\n       MSVGP=  (EXCEPTION:  DYNAMIC ALLOCATION DOES  NOT SUPPORT A\n              DDNAME FOR VOLUME SEPARATION)\n       LABEL=\n       SYSOUT=\n       COPIES=  (EXCEPTION:  DDTU DOES NOT  SUPPORT \"GROUP VALUES\"\n              FOR THE 3800 PRINTER)\n       DEST=\n       FCB=\n       OUTLIM=\n       UCS=\n1\n0                    DYNAMIC ALLOCATION MACROS             PAGE 11\n0 DDTU WILL FORM  DYNAMIC ALLOCATION  TEXT UNITS  CORRESPONDING TO\n         THE FOLLOWING JCL KEYWORDS (WITH NOTED EXCEPTIONS)\n0      SPACE=  (EXCEPTION:   DYNAMIC ALLOCATION  DOES NOT  SUPPORT\n              ABSOLUTE TRACK ALLOCATION)\n          THE LABEL  OF  THE  TEXT  UNIT  CREATED  FOR  SPECIFYING\n              CYLINDER  SPACE TYPE  IS  NECCESSARILY 'CYL'.    THE\n              LABEL OF THE TEXT UNIT  CREATED FOR SPECIFYING TRACK\n              SPACE TYPE IS  NECCESSARILY 'TRK'.  ANY  OTHER VALUE\n              FOR THE  FIRST SPACE OPERAND  GENERATES A  TEXT UNIT\n              FOR SPECIFYING AVERAGE BLOCK.\n0      UNIT=  (EXCEPTON:   DYNAMIC  ALLOCATION  DOES  NOT  SUPPORT\n              UNIT=(,,DEFER) OR UNIT=AFF=)\n          THE LABEL  OF  THE  TEXT  UNIT  CREATED  FOR  SPECIFYING\n              PARALLEL MOUNT IS NECCESSARILY 'P'.\n0      FREE=\n          THE TEXT UNIT CREATED IS FOR SPECIFYING FREE=CLOSE.\n0      TERM=\n          THE TEXT UNIT CREATED IS FOR SPECIFYING TERM=TS.\n0      HOLD=\n          THE TEXT UNIT CREATED IS FOR SPECIFYING HOLD=YES.\n-      DCB= (EXCEPTION:  DYNAMIC  ALLOCATION DOES NOT  SUPPORT DCB\n              REFERENCE TO A DDNAME IN A PREVIOUS JOB STEP.)\n              BLKSIZE=\n              BUFL=\n              BUFNO=\n              KEYLEN=\n              LIMCT=\n              LRECL=\n              NCP=\n              RECFM=\n              DEN=\n              DSORG=\n              EROPT=\n    EXAMPLE 1:\n-            DDTU  SPACE=(ALENGTH),FREE=SYMBOL28\n   +SYMBOL28 DC    Y(X'1C',0)              FREE=CLOSE\n   +ALENGTH  DC    Y(X'09',1,3)            SPACE=( )\n    EXAMPLE  2:  ALLOCATE  AND  OPEN  A NEW  TEMPORARY  1-CYLINDER\n        DATASET ON THE  DIRECT ACCESS VOLUME WHOSE  UCB IS POINTED\n        TO BY REGISTER 5.\n0           .\n            .\n            USING UCB,5\n   *\n   *  INITIALIZE WORK AREA FOR UNIT=;\n            MVC   WORKUNIT(3),UCBNAME     USE CHANNEL/UNIT ADDRESS AS\n   *                                      UNITNAME (E.G. JCL UNIT=4D0);\n            MVC   WORKUNIT+3(5),=CL5' '   PAD WITH BLANKS TO LENGTH 8;\n   *  ISSUE THE DDD MACRO;\n   RETURN   DDD   DSN=&&TEMP,SPACE=(CYL,1),UNIT=WORKUNIT@,VOL=SER=UCBVOLI@\n   * THE VOLUME SERIAL NUMBER IN THE UCB IS ALREADY 6 CHARACTERS,SO NO\n   *   PADDING IS NECESSARY.\n   *\n   *  USE THE RETURNED DDNAME;\n            MVC   DCBDDNAM-IHADCB+MYDCB,ALORTDDN+8\n            XC    OLIST,OLIST\n            OPEN  (MYDCB,OUTPUT),MF=(E,OLIST)\n            .\n            .\n            RETURN RC=0\n            .\n            .\n   *\n   *  INCLUDE THE DDDD (CODE) MACRO AFTER ALL DDD, FREE AND CONCAT MACROS;\n            DDDD CODE\n            .\n            .\n   WORKSTOR DSECT\n            DS    18F                     SAVE AREA;\n   OLIST    OPEN  0,MF=L\n   WORKUNIT DS    CL8                     SPACE FOR PADDED UNIT NAME;\n   *  INCLUDE THE DDDD (STORAGE) TO RESERVE WORKING STORAGE;\n            DDDD STORAGE\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHAIN": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* CHAIN AND UNCHAIN MANAGE LIFO QUEUES IN A MULTI-PROGRAMMING AND/OR\n*   MULTI-PROCESSING ENVIRONMENT.\n*  CHAIN ADDS A USER-SUPPLIED ELEMENT TO A QUEUE SPECIFIED BY ITS\n*    ANCHOR ADDRESS.\n*  UNCHAIN WILL REMOVE THE MOST RECENTLY ADDED ELEMENT FROM A QUEUE\n*    SPECIFIED BY ITS ANCHOR ADDRESS AND PLACE THE ADDRESS OF THE\n*    ELEMENT IN REGISTER 1.\n*    IF THERE ARE NO ELEMENTS IN THE QUEUE, UNCHAIN PLACES ZERO IN\n*    REGISTER 1.\n* EACH QUEUE IS DEFINED BY ITS \"ANCHOR\", WHICH MUST BE 8 BYTES ON A\n*   DOUBLEWORD BOUNDARY. THE ANCHOR MUST CONTAIN BINARY ZEROS WHEN THE\n*   FIRST CHAIN OR UNCHAIN MACRO IS ISSUED ON IT. THEREAFTER IT IS\n*   MAINTAINED ENTIRELY BY THE MACROS.\n* THE FIRST 4 BYTES OF EACH ELEMENT ARE A PREFIX. THE PREFIX IS USED\n*   BY THE MACROS AND IS NOT INITIALIZED BY THE USER.\n         MACRO\n&NAME    CHAIN &ANCHOR,&ELEMENT,&LAST=0(0,1)\n         LCLC  &A,&E,&L\n&A       SETC  '4+&ANCHOR'\n&E       SETC  '&ELEMENT'\n&L       SETC  '&LAST'\n         AIF   ('&ANCHOR'(1,1) NE '(').AX\n&A       SETC  '4&ANCHOR'\n.AX      AIF   ('&ELEMENT'(1,1) NE '(').EX\n&E       SETC  '0&ELEMENT'\n.EX      AIF   ('&LAST'(1,1)  NE '(').LX\n&L       SETC  '0&LAST'\n.LX      ANOP\n&NAME    LA    1,&E           ADDRESS OF NEW 1ST ELEMENT\n         L     0,&A           LOAD ADDRESS OF OLD 1ST ELEMENT\n         ST    0,&L           NEW ELEMENT POINTS TO OLD 1ST ELEMENT\n         CS    0,1,&A         CHAIN POINTS TO NEW 1ST ELEMENT\n         BNE   *-8            IF CONTENTION, RETRY\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCAT": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         CONCAT &POSIT,&TYPE=,&EXIT=\n         GBLA  &CONCATN,&CONCATX\n         GBLB  &CONCATB,&CONCATD,&DDDFAIL,&DDDD\n         AIF   (&DDDD).ERRDDDD\n         AIF   ('&POSIT' EQ 'E').ENDCONC\n         AIF   ('&POSIT' NE 'B').ERRPARM\n         AIF   ('&TYPE&EXIT' EQ '').CONCB\n         MNOTE 4,'TYPE AND EXIT IGNORED ON CONCAT B'\n.CONCB   AIF   (&CONCATB).ERRB\n&CONCATB SETB  1\n&CONCATX SETA  4              INITIAL DISPLACEMENT INTO DDNAME LIST\n*\n         MNOTE *,'*   BEGIN CONCATENATION'\n*\n         MEXIT\n.ENDCONC AIF   (NOT &CONCATB).ERRE\n&CONCATB SETB  0\n&CONCATD SETB  0\n&CONCATX SETA  &CONCATX/10             INITIAL 4 WILL ROUND TO 0\n         AIF   (&CONCATN GE &CONCATX).CONCT\n&CONCATN SETA  &CONCATX\n.CONCT   AIF   (&CONCATX LE 1).ERRNUMB\n         MVC   ALOCONCA(4),=Y(X'01',&CONCATX) CODE, NUMBER OF DDNAMES\n         LA    14,ALOCONCA             ADDRESS OF CONCATENATION TU\n         AIF   ('&TYPE' EQ '' OR '&TYPE' EQ 'PERM').PERM\n         AIF   ('&TYPE' NE 'TEMP').ERRTYPE\n         ST    14,ALOBLOCK+20\n         OI    ALOBLOCK+20,X'80'       SET END OF TU ADDR LIST\n         AGO   .CONCA\n.PERM    MVC   ALOBLOCK-8(4),=Y(X'04',0) PERMANENTLY CONCATENATED\n         LA    15,ALOBLOCK-8\n         STM   14,15,ALOBLOCK+20\n         OI    ALOBLOCK+24,X'80'       SET END OF TU ADDR LIST\n.CONCA   LA    0,X'0320'               DYNAMIC CONCATENATION\n         AIF   ('&EXIT' EQ '').EXITDEF\n         AIF   ('&EXIT'(1,1) EQ '(').LREXIT\n         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n         AGO   .BALDDDD\n.EXITDEF LA    15,ALODDERR             LOAD ERROR EXIT RTN ADDRESS\n&DDDFAIL SETB  1                       IN-LINE EXIT NEEDED\n         AGO   .BALDDDD\n.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO\n*\n         MNOTE *,'*   END CONCATENTATION OF &CONCATX DDNAMES'\n*\n         MEXIT\n.ERRDDDD MNOTE 12,'CONCAT MAY NOT BE ISSUED AFTER DDDD'\n         MEXIT\n.ERRB    MNOTE 12,'CONCAT E  MUST BE ISSUED BEFORE RE-ISSUING CONCAT B'\n         MEXIT\n.ERRE    MNOTE 12,'CONCAT E  MAY BE ISSUED ONLY AFTER CONCAT B'\n         MEXIT\n.ERRNUMB MNOTE 12,'AT LEAST 2 DD''S MUST BE CONCATENATED'\n         MEXIT\n.ERRTYPE MNOTE 8,'INVALID TYPE, &TYPE.. IGNORED'\n         AGO   .PERM\n.ERRPARM MNOTE 12,'INVALID POSITIONAL PARAMETER. SPECIFY B OR E'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&DDNAME  DDD   &DUMMY,&DSN=,&DSNAME=,&DISP=,&TERM=,&FREE=END,          *\n               &UNIT=,&SPACE=,&MSVGP=,&VOL=,&VOLUME=,&LABEL=,&PROTECT=,*\n               &DCB=,&SUBSYS=,                                         *\n               &SYSOUT=,&DEST=,&HOLD=,&COPIES=,&OUTLIM=,&FCB=,&UCS=,   *\n               &BURST=,&CHARS=,&FLASH=,&MODIFY=,                       *\n               &KEYADDS=,&TYPE=PERM,&MOUNT=NO,&EXIT=ALODDERR\n         GBLA  &X,&Y,&H,&N,&CONCATX,&R\n         GBLB  &CONCATB,&CONCATD,&DDDFAIL,&DDDD\n         LCLA  &A\n         LCLC  &C,&D\n         AIF   (&DDDD).ERRDDDD\n&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER\n&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA\n&R       SETA  14                      FIRST REGISTER LOADED\n         DDD5  &DDNAME,&DSN,&DSNAME,&DISP\n         AIF   ('&TERM' EQ '').TERMX\n         AIF   ('&TERM' NE 'TS').ERRTERM\n         DDD0  =Y(X'28',0),,,,'TERM=TS'\n.TERMX   AIF   ('&FREE' EQ 'END').FREEX\n         AIF   ('&FREE' NE 'CLOSE').ERRFREE\n         DDD0  =Y(X'1C',0),,,,'FREE=CLOSE'\n.FREEX   AIF   ('&UNIT&SPACE&MSVGP' EQ '').DDD1X\n         DDD1  &UNIT,&SPACE,&MSVGP\n.DDD1X   AIF   ('&VOL&VOLUME&LABEL&PROTECT' EQ '').DDD2X\n         AIF   ('&VOLUME' EQ '').DDD2V\n         AIF   ('&VOL' NE '').ERRVOL\n         DDD2  &VOLUME,&LABEL,&PROTECT\n         AGO   .DDD2X\n.DDD2V   DDD2  &VOL,&LABEL,&PROTECT\n.DDD2X   AIF   ('&DUMMY&DCB&SUBSYS' EQ '').DDD3X\n         DDD3  &DUMMY,&DCB,&SUBSYS\n.DDD3X   AIF   ('&SYSOUT&DEST&HOLD&COPIES&OUTLIM&FCB&UCS' EQ '' AND    *\n               '&BURST&CHARS&FLASH&MODIFY' EQ '').DDD4X\n         DDD4  &SYSOUT,&DEST,&HOLD,&COPIES,&OUTLIM,&FCB,&UCS,          *\n               &BURST,&CHARS,&FLASH,&MODIFY\n.DDD4X   AIF   ('&KEYADDS' EQ '').KEYADDX\n&A       SETA  0\n.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX\n&A       SETA  &A+1\n&C       SETC  '&KEYADDS(&A)'\n         AIF   ('&C' EQ '').KEYLOOP\n         AIF   ('&C'(1,1) EQ '(').KEYADDR\n         DDD0  &C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDX AIF   ('&TYPE' EQ 'PERM').TYPEP\n         AIF   ('&TYPE' EQ 'TEMP').TYPEX\n         AIF   ('&TYPE' NE 'CNVRT').ERRTYPE\n         DDD0  =Y(X'53',0),,,,'TYPE=CNVRT  CONVERTIBLE'\n.TYPEP   DDD0  =Y(X'52',0),,,,'PERMANENTLY ALLOCATED'\n.TYPEX   AIF   (&R NE 14).R14X\n&X       SETA  &X-4\n         AGO   .RX\n.R14X    AIF   (&R NE 15).R15X\n         ST    14,ALOBLOCK+&X\n         AGO   .RX\n.R15X    AIF   (&R NE 0).R0X\n         STM   14,15,ALOBLOCK+&X\n&X       SETA  &X+4\n         AGO   .RX\n.R0X     STM   14,0,ALOBLOCK+&X\n&X       SETA  &X+8\n.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST\n&C       SETC  'X''0100''+X''0020'''   ALLOC, NOMOUNT\n         AIF   ('&MOUNT' EQ 'NO').MOUNTX\n         AIF   ('&MOUNT' NE 'YES').ERRMOUN\n&C       SETC  'X''0100'''             ALLOC\n.MOUNTX  AIF   (NOT &CONCATD).CONCADX\n&C       SETC  '&C+X''0080'''          DON'T USE EXISTING UNLESS CNVRT\n.CONCADX LA    0,&C                    LOAD VERB, FLAGS1\n         AIF   ('&EXIT'(1,1) EQ '(').LREXIT\n         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n&DDDFAIL SETB  ('&EXIT' EQ 'ALODDERR' OR &DDDFAIL)\n         AGO   .BALDDDD\n.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO\n         SPACE 1\n         AIF   (NOT &CONCATB).CONCX\n&CONCATD SETB  1\n         MVC   ALOCONCA+&CONCATX.(10),ALORTDDN+4 SAVE DDNAME FOR CONCAT\n&CONCATX SETA  &CONCATX+1\n         MVI   ALOCONCA+&CONCATX,8     SET LENGTH TO 8 FOR SPACING\n&CONCATX SETA  &CONCATX+9\n         SPACE 1\n.CONCX   AIF   (&H GE &Y).HX\n&H       SETA  &Y\n.HX      AIF   (&N GE &X).MEXIT\n&N       SETA  &X\n.MEXIT   MEXIT\n.ERRDDDD MNOTE 12,'DDD MAY NOT BE ISSUED AFTER DDDD'\n         MEXIT\n.ERRFREE MNOTE 8,'FREE=&FREE INVALID. FREE=END ASSUMED.'\n         AGO   .FREEX\n.ERRVOL  MNOTE 12,'BOTH VOL= AND VOLUME= SPECIFIED. VOLUME=&VOLUME IGNO*\n               RED.'\n         AGO   .DDD2V\n.ERRTERM MNOTE 8,'INVALID VALUE, TERM=&TERM.. IGNORED.'\n         AGO   .TERMX\n.ERRTYPE MNOTE 8,'TYPE=&TYPE INVALID. TYPE IGNORED.'\n         AGO   .TYPEP\n.ERRMOUN MNOTE 8,'MOUNT=&MOUNT INVALID. IGNORED.'\n         AGO   .MOUNTX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDDD": {"ttr": 776, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDDD  &ROLE\n         GBLA  &H,&N,&CONCATN\n         GBLB  &RTDDN,&FREEB,&DDDFAIL,&DDDD\n&DDDD    SETB  1\n         AIF   ('&ROLE' EQ 'STORAGE').CODEX\n         DC    Y(X'8032'-X'10000')     CONTROL BITS FOR DAIRFAIL\nALOROUT  STCM  0,B'0011',ALOBLOCK+1    SET VERB AND FLAGS1\n         AIF   ('&ROLE' EQ '').COMMON\n         AIF   ('&ROLE' NE 'CODE').ERRROLE\n         MVI   ALOBLOCK,20             SET BLOCK LENGTH = 20\n         XC    ALOBLOCK+3(17),ALOBLOCK+3  PRESET BLOCK TO ZEROS\n         LA    0,ALOBLOCK+20           POINTER TO TEXT UNIT ADDRESSES\n         ST    0,ALOBLOCK+8            SET INTO BLOCK\n         LA    0,ALOBLOCK              ADDRESS OF REQUEST BLOCK\n         ST    0,ALOBLOCK-20           POINTER FOR SVC\n         OI    ALOBLOCK-20,X'80'       SET END OF POINTER\n.COMMON  LA    1,ALOBLOCK-20           POINT TO POINTER\n         STM   14,1,12(13)             SAVE REGS IN CASE OF ERROR\n         DYNALLOC ,                    DYNALLOC SVC\n         LTR   15,15                   IF RETURN CODE IS ZERO,\n         BZR   14                      RETURN TO MAINSTREAM\n         ST    15,20(,13)              SAVE RETURN CODE IN REG 0 AREA\n         LM    15,1,16(13)             LOAD EXIT ADDR, RC, AND POINTER\n         ST    0,ALOBLOCK-4            RETURN CODE FOR DAIRFAIL\n         BR    15                      GO TO EXIT RTN\n         AIF   (NOT &DDDFAIL).EXITX\nALODDERR DS    0H\n         AIF   (NOT &FREEB).FREEX\n         CLC   ALOBLOCK+4(2),=X'0438'  \"NOT FREED, IS NOT ALLOCATED\"\n         BER   14                      IS A PERMISSABLE ERROR\n         CLC   ALOBLOCK+4(2),=X'0440'  \"NOT FREED, IS NOT ALLOCATED\"\n         BER   14                      IS A PERMISSABLE ERROR\n.FREEX   ANOP\nALODFAIL DS    0H\n         L     15,16                   ADDRESS CVT\n         AIF   ('&ROLE' EQ '').PARAMX\n         LA    14,ALOBLOCK-4           RETURN CODE IN FULLWORD\n         LA    15,976(,15)             CVTEFF02 POINTS TO IKJEFF02\n         LA    0,ALOROUT-2             BITS TO CONTROL IKJEFF18\n         STM   14,0,ALOBLOCK-20+4\n         AGO   .STOREX\n.PARAMX  LA    15,976(,15)             CVTEFF02 POINTS TO IKJEFF02\n         ST    15,ALOBLOCK-20+8\n.STOREX  LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *\n               MF=(E,ALOBLOCK-20)\n         L     1,=A(X'80000000'+99)    ABEND CODE IS USER 99,DUMP\n         ABEND (1)                     ABEND\n.EXITX   AIF   ('&ROLE' EQ 'CODE').MEXIT\n.CODEX   ANOP\n&H       SETA  &H/2-2\n         DS    &H.H                    SPACE FOR SOME TEXT UNITS\n         DC    A(*-X'7FFFFFEC')        ADDRESS OF ALOBLOCK\n         DC    A(ALOBLOCK-4)           ADDRESS OF SVC RC FOR DAIRFAIL\n         DC    A(0)                    ADDRESS OF FULLWORD -> IKJEFF02\n         DC    A(ALOROUT-2)        ADDRESS OF CONTROL BITS FOR DAIRFAIL\n         DS    F                   RETURN CODE FROM SVC 99 FOR DAIRFAIL\nALOBLOCK DC    X'14002000'             LENGTH, VERB, FLAGS1\n         DC    A(0,*+12,0,0)   ERROR CODES, TU LIST ADDR, RESV, FLAGS2\n&N       SETA  &N/4-4\n         DS    &N.A                    TU ADDRESS LIST\n         AIF   (NOT &RTDDN).ARTDDNX\nALORTDDN DC    Y(X'55',1,8),CL8' '     TU FOR RETURN OF DDNAME\nDDDNAME  EQU   ALORTDDN+6,8,C'C'\n.ARTDDNX AIF   (&CONCATN EQ 0).MEXIT\nALOCONCA DC    Y(1,0),&CONCATN.XL10'0' TU FOR DDNAMES TO CONCATENATE\n.MEXIT   MEXIT\n.ERRROLE MNOTE 12,'&ROLE IS INVALID. USE CODE OR STORAGE.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDDMSG": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDDMSG\n         LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *\n               PARAM=(,ALOBLOCK-4,=F'0',ALOROUT-2),                    *\n               MF=(E,ALOBLOCK-20)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDDMVC": {"ttr": 780, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    DDDMVC &PARMS=,&RETURN=\n         MVC   PARMLIST,ALOBLOCK-20\n&NAME    LINK  EP=IKJEFF18,            INVOKE DAIRFAIL TO ISSUE WTP    *\n               PARAM=(,ALOBLOCK-4,=F'0',=X'C032',=F'0',&RETURN),       *\n               VL=1,MF=(E,&PARMS)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD0": {"ttr": 782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*                                                                     *\n*   MACRO DDD0                                                        *\n*                                                                     *\n*    FUNCTION: MOVE A SINGLE TEXT UNIT INTO THE TEXT UNIT AREA,       *\n*      SET ITS ADDRESS INTO A REGISTER.  STORE ADDRESSES INTO THE     *\n*      TEXT UNIT ADDRESS ARRAY.                                       *\n*                                                                     *\n*    OPERANDS: THERE ARE 5 POSITIONAL OPERANDS, P1 THRU P5.           *\n*      OPERAND P5 IS ALWAYS A QUOTED STRING THAT DDD0 EXPANDS INTO A  *\n*      COMMENT MNOTE. OPERANDS P1-P4 SPECIFY A TEXT UNIT IN ONE OF    *\n*      SEVERAL WAYS:                                                  *\n*        ADDRESS ONLY: P1 IS AN RX-TYPE ADDRESS OF A TEXT UNIT        *\n*          PREFORMATTED BY THE INVOKER. DDD0 DOES NOT COPY THE TEXT   *\n*          UNIT IN THIS CASE. THIS MODE IS SELECTED WHEN P2 IS        *\n*          OMITTED.                                                   *\n*        TWO-PART TEXT UNIT: P1 IS THE LENGTH (NON-RELOCATABLE        *\n*          EXPRESSION WHOSE FIRST CHARACTER IS NUMERIC) AND P2 IS     *\n*          THE ADDRESS (RS-TYPE) OF THE FIRST PART OF THE TEXT UNIT.  *\n*          P3 IS THE LENGTH (NON-RELOCATABLE EXPRESSION) AND P4 IS    *\n*          THE ADDRESS (RS-TYPE) OF THE SECOND PART OF THE TEXT       *\n*          UNIT. DDD0 COPIES BOTH PARTS TO THE TEXT UNIT AREA. THIS   *\n*          MODE IS SELECTED WHEN P2 IS NOT OMITTED, THE FIRST         *\n*          CHARACTER OF P1 IS NUMERIC AND P3 IS NOT OMITTED.          *\n*        ONE-PART TEXT UNIT: P1 IS THE LENGTH (NON-RELOCATABLE        *\n*          EXPRESSION WHOSE FIRST CHARACTER IS NUMERIC) AND P2 IS     *\n*          THE ADDRESS (RS-TYPE) OF THE TEXT UNIT.  DDD0 COPIES THE   *\n*          TEXT UNIT TO THE TEXT UNIT AREA. THIS MODE IS SELECTED     *\n*          WHEN P2 IS NOT OMITTED, THE FIRST CHARACTER OF P1 IS       *\n*          NUMERIC AND P3 IS OMITTED.                                 *\n*        CHARACTER-STRING VALUE: P1 (A-TYPE ADDRESS CONSTANT WHOSE    *\n*          FIRST CHARACTER IS NOT NUMERIC) IS THE KEY AND NUMBER OF   *\n*          PARAMETERS (MUST BE 1) OF THE TEXT UNIT.  P2 IS AN         *\n*          UNQUOTED STRING USED BY DDD0 AS THE VALUE OF THE FIRST     *\n*          PARAMETER. DDD0 WILL EFFECTIVELY REMOVE THE FIRST          *\n*          CHARACTER OF THE STRING IF THE FIRST TWO CHARACTERS ARE    *\n*          BOTH AMPERSANDS. DDD0 SETS THE LENGTH OF THE FIRST         *\n*          PARAMETER TO THE LENGTH OF THE P2 STRING (AFTER AMPERSAND  *\n*          REMOVAL, IF ANY). P3 IS AN UPPER LIMIT TO THE LENGTH OF    *\n*          P2 (BEFORE AMPERSAND REMOVAL). DDD0 COPIES THE TEXT UNIT   *\n*          TO THE TEXT UNIT AREA. THIS MODE IS SELECTED WHEN P2 IS    *\n*          NOT OMITTED AND P1'S FIRST CHARACTER IS NOT NUMERIC.       *\n*                                                                     *\n***********************************************************************\n         MACRO\n         DDD0  &ID,&CH,&L2,&A2,&COMMENT\n         GBLA  &X,&Y,&R\n         LCLA  &A,&K\n         LCLC  &C\n         SPACE 1\n         MNOTE *,&COMMENT\n         AIF   (T'&CH NE 'O').KEYADDX\n         AIF   ('&ID'(K'&ID,1) NE '@').PSREGX\n&C       SETC  '&ID'(1,K'&ID-1)\n         L     &R,&C\n         AGO   .CODEX\n.PSREGX  LA    &R,&ID\n         AGO   .CODEX\n.KEYADDX ANOP\n.*\n         AIF   ('&ID'(1,1) LT '0').MOVLITX\n         AIF   (T'&L2 EQ 'O').MOVVALX\n&Y       SETA  (&Y+&L2+1)/2*2\n         MVC   ALOBLOCK-&Y.(&L2),&A2\n.MOVVALX ANOP\n&Y       SETA  (&Y+&ID+1)/2*2\n         MVC   ALOBLOCK-&Y.(&ID),&CH\n         LA    &R,ALOBLOCK-&Y\n         AGO   .CODEX\n.MOVLITX ANOP\n.*\n&K       SETA  K'&CH\n         AIF   (&K GT &L2).ERRLEN\n&C       SETC  '&CH '(1,2)\n&A       SETA  3\n         AIF   ('&C' NE '&&').LOOP\n&A       SETA  4\n&C       SETC  '&CH '(1,3)\n.LOOP    AIF   (&A GT &K).SETK\n&C       SETC  '&C'',C'''.'&CH   '(&A,4)\n&A       SETA  &A+4\n         AGO   .LOOP\n.SETK    AIF   ('&CH '(1,2) NE '&&').LA\n&K       SETA  &K-1\n.LA      ANOP\n&A       SETA  &K+6\n&Y       SETA  (&Y+&A+1)/2*2\n         MVC   ALOBLOCK-&Y.(&A),=A(&ID,&K*X'10000'+C'&C')\n         LA    &R,ALOBLOCK-&Y\n.CODEX   ANOP\n.*\n         AIF   (&R NE 14).R14X\n&R       SETA  15\n         MEXIT\n.R14X    AIF   (&R NE 15).R15X\n&R       SETA  0\n         MEXIT\n.R15X    AIF   (&R NE 0).R0X\n&R       SETA  1\n         MEXIT\n.R0X     STM   14,1,ALOBLOCK+&X\n&X       SETA  &X+16\n&R       SETA  14\n         MEXIT\n.ERRLEN  MNOTE 12,'OPERAND ''&CH'' EXCEEDS &L2 CHARACTERS. OPERAND IGNO*\n               RED.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD1": {"ttr": 785, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDD1  &UNIT,&SPACE,&MSVGP\n         LCLA  &A,&K\n         LCLB  &B,&T\n         LCLC  &C,&D\n         AIF   ('&UNIT' EQ '').UNITX\n         AIF   (N'&UNIT GT 3).ERRUNI9\n&C       SETC  '&UNIT(1)'\n         AIF   ('&C' EQ '').UNIT1X\n         AIF   ('&C'(K'&C,1) NE '@').UNIT1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'15',1,8),8,&C,'UNIT=CL8 AT &C'\n         AGO   .UNIT1X\n.UNIT1@X DDD0  X'00150001',&C,8,,'UNIT=&C'\n.UNIT1X  AIF   (N'&UNIT LE 1).UNITX\n&C       SETC  '&UNIT(2)'\n         AIF   ('&C' EQ '').UNIT2X\n         AIF   ('&C' NE 'P').UNITC\n         DDD0  =Y(X'17',0),,,,'UNIT=(,P)  PARALLEL MOUNT'\n         AGO   .UNIT2X\n.UNITC   AIF   ('&C'(K'&C,1) NE '@').UNITC@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'16',1,1),1,&C,'UNIT=(,AL1 AT &C)  UNIT COUNT'\n         AGO   .UNIT2X\n.UNITC@X DDD0  7,=AL1(0,X'16',0,1,0,1,&C),,,'UNIT=(,&C)  UNIT COUNT'\n.UNIT2X  AIF   ('&UNIT(3)' EQ '').UNITX\n         AIF   ('&UNIT(3)' NE 'DEFER').ERRUNIT\n         DDD0  =Y(X'6C',0),,,,'UNIT=(,,DEFER)  DEFERRED MOUNTING'\n.UNITX   AIF   ('&SPACE' EQ '').SPACEX\n         AIF   (N'&SPACE GT 5).ERRSPA9\n&C       SETC  '&SPACE(1)'\n         AIF   ('&C' EQ '').SPACE1X\n         AIF   ('&C' NE 'TRK').SPACE1C\n         DDD0  =Y(X'07',0),,,,'SPACE=(TRK)'\n         AGO   .SPACE1X\n.SPACE1C AIF   ('&C' NE 'CYL').SPACE1A\n         DDD0  =Y(X'08',0),,,,'SPACE=(CYL)'\n         AGO   .SPACE1X\n.SPACE1A AIF   ('&C'(K'&C,1) NE '@').SPAC1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'09',1,3),3,&C,                                   *\n               'SPACE=(AL3 AT &C)  AVERAGE BLOCK SIZE'\n         AGO   .SPACE1X\n.SPAC1@X DDD0  9,=AL3(X'000900',X'010003',&C),,,                       *\n               'SPACE=(&C)  AVERAGE BLOCK SIZE'\n.SPACE1X AIF   ('&SPACE(2)' EQ '').SPACE2X\n&C       SETC  '&SPACE(2)'\n         AIF   ('&C'(1,1) NE '(').SPACE2W\n&A       SETA  2\n.SPACE2A AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).SPACE2C\n&B       SETB  ('&C'(&A,1) EQ '(')\n&T       SETB  ('&C'(&A,1) EQ ')')\n&K       SETA  &K+&B-&T\n&A       SETA  &A+1\n         AIF   (&A LT K'&C).SPACE2A\n.SPACE2C AIF   (&A EQ 2).SPAC21X\n&D       SETC  '&C'(2,&A-2)\n         AIF   ('&D'(K'&D,1) NE '@').SPA21@X\n&D       SETC  '&D'(1,K'&D-1)\n         DDD0  6,=Y(X'0A',1,3),3,&D,'SPACE=(,(AL3 AT &D))'\n         AGO   .SPAC21X\n.SPA21@X DDD0  9,=AL3(X'000A00',X'010003',&D),,,'SPACE=(,(&D))'\n.SPAC21X AIF   (&A GE K'&C).SPACE2X\n&C       SETC  '&C'(&A+1,K'&C-&A)\n&A       SETA  1\n.SPACE2D AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).SPACE2E\n&B       SETB  ('&C'(&A,1) EQ '(')\n&T       SETB  ('&C'(&A,1) EQ ')')\n&K       SETA  &K+&B-&T\n&A       SETA  &A+1\n         AIF   (&A LT K'&C).SPACE2D\n.SPACE2E AIF   (&A EQ 1).SPAC22X\n&D       SETC  '&C'(1,&A-1)\n         AIF   ('&D'(K'&D,1) NE '@').SPA22@X\n&D       SETC  '&D'(1,K'&D-1)\n         DDD0  6,=Y(X'0B',1,3),3,&D,'SPACE=(,(,AL3 AT &D))'\n         AGO   .SPAC22X\n.SPA22@X DDD0  9,=AL3(X'000B00',X'010003',&D),,,'SPACE=(,(,&D))'\n.SPAC22X AIF   (&A GE K'&C).SPACE2X\n&C       SETC  '&C'(&A+1,K'&C-&A)\n&A       SETA  1\n.SPACE2G AIF   ('&C'(&A,1) EQ ',' AND &K EQ 0).ERRSPA2\n&B       SETB  ('&C'(&A,1) EQ '(')\n&T       SETB  ('&C'(&A,1) EQ ')')\n&K       SETA  &K+&B-&T\n&A       SETA  &A+1\n         AIF   (&A LT K'&C).SPACE2G\n&D       SETC  '&C'(1,&A-1)\n         AIF   ('&D'(K'&D,1) NE '@').SPA23@X\n&D       SETC  '&D'(1,K'&D-1)\n         DDD0  6,=Y(X'0C',1,3),3,&D,'SPACE=(,(,,AL3 AT &D))'\n         AGO   .SPACE2X\n.SPA23@X DDD0  9,=AL3(X'000C00',X'010003',&D),,,'SPACE=(,(,,&D))'\n         AGO   .SPACE2X\n.SPACE2W AIF   ('&C'(K'&C,1) NE '@').SPAC2@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'0A',1,3),3,&C,'SPACE=(,AL3 AT &C)'\n         AGO   .SPACE2X\n.SPAC2@X DDD0  9,=AL3(X'000A00',X'010003',&C),,,'SPACE=(,&C)'\n.SPACE2X AIF   (N'&SPACE LE 3).SPACE3\n         AIF   ('&SPACE(5)' EQ '').SPACE4\n         AIF   ('&SPACE(5)' NE 'ROUND').ERRSPA5\n         DDD0  =Y(X'0F',0),,,,'SPACE=(,,,,ROUND)'\n.SPACE4  ANOP\n&C       SETC  '&SPACE(4)'\n         AIF   ('&C' EQ '').SPACE3\n         AIF   ('&C' NE 'CONTIG').SPACE4A\n         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'08'),,,'SPACE=(,,,CONTIG)'\n         AGO   .SPACE3\n.SPACE4A AIF   ('&C' NE 'ALX').SPACE4M\n         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'02'),,,'SPACE=(,,,ALX)'\n         AGO   .SPACE3\n.SPACE4M AIF   ('&C' NE 'MXIG').SPACE4@\n         DDD0  7,=AL1(0,X'0E',0,1,0,1,X'04'),,,'SPACE=(,,,MXIG)'\n         AGO   .SPACE3\n.SPACE4@ AIF   ('&C'(K'&C,1) NE '@').ERRSPA4\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'0E',1,1),1,&C,'SPACE=(,,,XL1 AT &C)'\n.SPACE3  AIF   ('&SPACE(3)' EQ '').SPACEX\n         AIF   ('&SPACE(3)' NE 'RLSE').ERRRLSE\n         DDD0  =Y(X'0D',0),,,,'SPACE=(,,RLSE)'\n.SPACEX  AIF   ('&MSVGP' EQ '').MSVGPX\n         AIF   (N'&MSVGP GT 2).ERRMSV9\n         AIF   (N'&MSVGP LE 1).MSVDDX\n         MNOTE 8,'SECOND SUBPARAMETER OF MSVGP NOT SUPPORTED BY DYNAMIC*\n                ALLOCATION.'\n.MSVDDX  ANOP\n&C       SETC  '&MSVGP(1)'\n         AIF   ('&C' EQ '').MSVGPX\n         AIF   ('&C'(K'&C,1) NE '@').MSVGP@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'5E',1,8),8,&C,'MSVGP=CL8 AT &C'\n         AGO   .MSVGPX\n.MSVGP@X DDD0  X'005E0001',&C,8,,'MSVGP=&C'\n.MSVGPX  MEXIT\n.ERRUNI9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN UNIT=&UNIT.. UNIT*\n                IGNORED.'\n         AGO   .UNITX\n.ERRUNIT MNOTE 8,'UNIT=(,,&UNIT(3)) IS INVALID. IGNORED.'\n         AGO   .UNITX\n.ERRSPA9 MNOTE 8,'ONLY FIVE SUBPARAMETERS ALLOWED IN SPACE=&SPACE.. SPA*\n               CE IGNORED.'\n         AGO   .SPACEX\n.ERRSPA2 MNOTE 8,'TOO MAY SUBPARAMETERS IN SECOND SPACE PARAMETER, &SPA*\n               CE(2)'\n         AGO   .SPACE2X\n.ERRRLSE MNOTE 8,'INVALID THIRD SPACE PARAMETER, &SPACE(3)'\n         AGO   .SPACEX\n.ERRSPA4 MNOTE 8,'INVALID FOURTH SPACE PARAMETER, &C'\n         AGO   .SPACE3\n.ERRSPA5 MNOTE 8,'INVALID FIFTH SPACE PARAMETER, &SPACE(5)'\n         AGO   .SPACE4\n.ERRMSV9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN MSVGP=&MSVGP.. MSVG*\n               P IGNORED.'\n         AGO   .MSVGPX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD2": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDD2  &VOL,&LABEL,&PROTECT\n         LCLA  &A\n         LCLC  &C,&D\n         AIF   ('&VOL' EQ '').VOLX\n&C       SETC  '&VOL(N'&VOL)'\n         AIF   ('&C'(1,4) NE 'SER=').VOLREF\n         AIF   ('&C'(5,1) EQ '(').VOLMULT\n         AIF   ('&C'(K'&C,1) NE '@').VOLS1@X\n&C       SETC  '&C'(5,K'&C-5)\n         DDD0  6,=Y(X'10',1,6),6,&C,'VOL=SER=CL6 AT &C'\n         AGO   .VOLKEYX\n.VOLS1@X AIF   (K'&C NE 10).ERRVOS1\n&C       SETC  '&C'(5,6)\n         DDD0  X'00100001',&C,6,,'VOL=SER=&C'\n         AGO   .VOLKEYX\n.VOLMULT AIF   ('&C'(K'&C-1,1) NE '@').VOLMU@X\n&C       SETC  '&C'(6,K'&C-7)\n         DDD0  6,=Y(X'10',1,6),6,&C,'VOL=SER=CL6 AT &C'\n         AGO   .VOLKEYX\n.VOLMU@X ANOP\n&D       SETC  'X''00060000''+C'''.'&C'(6,2).''',C'''.'&C'(8,4).''''\n&A       SETA  12\n.VOLLOOP AIF   ('&C'(&A,1) NE ',').ERRVOLS\n&D       SETC  '&D,X''00060000''+C'''.'&C'(&A+1,2).''',C'''.'&C'(&A+3,4*\n               ).''''\n&A       SETA  &A+7\n         AIF   (&A LT K'&C).VOLLOOP\n&A       SETA  &A/7\n&D       SETC  'X''00100000''+&A,&D'\n&A       SETA  &A*8+4\n         DDD0  &A,=A(&D),,,'VOL=&C'\n         AGO   .VOLKEYX\n.VOLREF  AIF   ('&C'(1,4) NE 'REF=').VOL4\n         AIF   ('&C'(5,1) EQ '*').ERRVOLR\n         AIF   ('&C'(K'&C,1) NE '@').VOLRE@X\n&C       SETC  '&C'(5,K'&C-5)\n         DDD0  6,=Y(X'14',1,44),44,&C,'VOL=REF=CL44 AT &C'\n         AGO   .VOLKEYX\n.VOLRE@X ANOP\n&C       SETC  '&C'(5,K'&C-4)\n         DDD0  X'00140001',&C,44,,'VOL=REF=&C'\n.VOLKEYX AIF   (N'&VOL LE 1).VOLX\n         AIF   (N'&VOL LE 2).VOL2X\n         AIF   (N'&VOL LE 3).VOL3X\n         AIF   (N'&VOL LE 4).VOL4X\n         AIF   (N'&VOL LE 5).VOL5X\n.VOL4    AIF   (N'&VOL GT 4).ERRVOL9\n.VOL5X   ANOP\n&C       SETC  '&VOL(4)'\n         AIF   ('&C' EQ '').VOL4X\n         AIF   ('&C'(K'&C,1) NE '@').VOL4@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'13',1,1),1,&C,'VOL=(,,,AL1 AT &C)  VOLUME COUNT'\n         AGO   .VOL4X\n.VOL4@X  DDD0  7,=AL1(0,X'13',0,1,0,1,&C),,,'VOL=(,,,&C)  VOLUME COUNT'\n.VOL4X   ANOP\n&C       SETC  '&VOL(3)'\n         AIF   ('&C' EQ '').VOL3X\n         AIF   ('&C'(K'&C,1) NE '@').VOL3@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'12',1,2),2,&C,'VOL=(,,AL2 AT &C)  VOLUME SEQUENCE*\n                NUMBER'\n         AGO   .VOL3X\n.VOL3@X  DDD0  8,=Y(X'12',1,2,&C),,,'VOL=(,,&C)  VOLUME SEQUENCE NUMBER*\n               '\n.VOL3X   AIF   ('&VOL(2)' EQ '').VOL2X\n         AIF   ('&VOL(2)' NE 'RETAIN').ERRVOL2\n         MNOTE 8,'VOL=(,RETAIN) NOT SUPPORTED BY DYNAMIC ALLOCATION'\n.VOL2X   AIF   ('&VOL(1)' EQ '').VOLX\n         AIF   ('&VOL(1)' NE 'PRIVATE').ERRVOL1\n         DDD0  =Y(X'11',0),,,,'VOL=(PRIVATE)'\n.VOLX    AIF   ('&LABEL' EQ '').LABELX\n&C       SETC  '&LABEL(N'&LABEL)'\n         AIF   ('&C'(1,6) NE 'EXPDT=').LABELEX\n         AIF   ('&C'(K'&C,1) NE '@').LABE@X\n&C       SETC  '&C'(7,K'&C-7)\n         DDD0  6,=Y(X'22',1,5),5,&C,'LABEL=EXPDT=CL5 AT &C'\n         AGO   .LABKEYX\n.LABE@X  AIF   (K'&C NE 11).ERREXPD\n&C       SETC  '&C'(7,5)\n         DDD0  X'00220001',&C,5,,'LABEL=EXPDT=&C'\n         AGO   .LABKEYX\n.LABELEX AIF   ('&C'(1,6) NE 'RETPD=').LABELRX\n         AIF   ('&C'(K'&C,1) NE '@').LABR@X\n&C       SETC  '&C'(7,K'&C-7)\n         DDD0  6,=Y(X'23',1,2),2,&C,'LABEL=RETPD=AL2 AT &C'\n         AGO   .LABKEYX\n.LABR@X  ANOP\n&C       SETC  '&C'(7,K'&C-6)\n         DDD0  8,=Y(X'23',1,2,&C),,,'LABEL=RETPD=&C'\n.LABKEYX AIF   (N'&LABEL LE 1).LABELX\n         AIF   (N'&LABEL LE 2).LABEL2X\n         AIF   (N'&LABEL LE 3).LABEL3X\n         AIF   (N'&LABEL LE 4).LABEL4X\n         AIF   (N'&LABEL LE 5).LABEL5X\n.LABELRX AIF   (N'&LABEL GT 4).ERRLAB9\n.LABEL5X ANOP\n&C       SETC  '&LABEL(4)'\n         AIF   ('&C' EQ '').LABEL4X\n         AIF   ('&C' NE 'IN').LABEL4A\n         DDD0  7,=AL1(0,X'21',0,1,0,1,X'80'),,,'LABEL=(,,,IN)'\n         AGO   .LABEL4X\n.LABEL4A AIF   ('&C' NE 'OUT').LABEL4@\n         DDD0  7,=AL1(0,X'21',0,1,0,1,X'40'),,,'LABEL=(,,,OUT)'\n         AGO   .LABEL4X\n.LABEL4@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB4\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'21',1,1),1,&C,'LABEL=(,,,XL1 AT &C)  INPUT ONLY O*\n               R OUTPUT ONLY'\n.LABEL4X ANOP\n&C       SETC  '&LABEL(3)'\n         AIF   ('&C' EQ '').LABEL3X\n         AIF   ('&C' NE 'PASSWORD').LABEL3A\n         DDD0  7,=AL1(0,X'20',0,1,0,1,X'10'),,,'LABEL=(,,PASSWORD)'\n         AGO   .LABEL3X\n.LABEL3A AIF   ('&C' NE 'NOPWREAD').LABEL3@\n         DDD0  7,=AL1(0,X'20',0,1,0,1,X'30'),,,'LABEL=(,,NOPWREAD)'\n         AGO   .LABEL3X\n.LABEL3@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB3\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'20',1,1),1,&C,'LABEL=(,,XL1 AT &C)  PASSWORD PROT*\n               ECTION'\n.LABEL3X ANOP\n&C       SETC  '&LABEL(2)'\n         AIF   ('&C' EQ '').LABEL2X\n         AIF   ('&C' NE 'NSL').LABEL2A\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'04'),,,'LABEL=(,NSL)'\n         AGO   .LABEL2X\n.LABEL2A AIF   ('&C' NE 'SL').LABEL2B\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'02'),,,'LABEL=(,SL)'\n         AGO   .LABEL2X\n.LABEL2B AIF   ('&C' NE 'NL').LABEL2C\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'01'),,,'LABEL=(,NL)'\n         AGO   .LABEL2X\n.LABEL2C AIF   ('&C' NE 'BLP').LABEL2D\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'10'),,,'LABEL=(,BLP)'\n         AGO   .LABEL2X\n.LABEL2D AIF   ('&C' NE 'SUL').LABEL2E\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'08'),,,'LABEL=(,SUL)'\n         AGO   .LABEL2X\n.LABEL2E AIF   ('&C' NE 'AL').LABEL2F\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'40'),,,'LABEL=(,AL)'\n         AGO   .LABEL2X\n.LABEL2F AIF   ('&C' NE 'AUL').LABEL2G\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'48'),,,'LABEL=(,AUL)'\n         AGO   .LABEL2X\n.LABEL2G AIF   ('&C' NE 'LTM').LABEL2@\n         DDD0  7,=AL1(0,X'1E',0,1,0,1,X'21'),,,'LABEL=(,LTM)'\n         AGO   .LABEL2X\n.LABEL2@ AIF   ('&C'(K'&C,1) NE '@').ERRLAB2\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'1E',1,1),1,&C,'LABEL=(,XL1 AT &C)  LABEL TYPE'\n.LABEL2X ANOP\n&C       SETC  '&LABEL(1)'\n         AIF   ('&C' EQ '').LABELX\n         AIF   ('&C'(K'&C,1) NE '@').LABE1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'1F',1,2),2,&C,'LABEL=(AL2 AT &C)  DATASET SEQUENC*\n               E NUMBER'\n         AGO   .LABELX\n.LABE1@X DDD0  8,=Y(X'1F',1,2,&C),,,'LABEL=(&C)  DATASET SEQUENCE NUMBE*\n               R'\n.LABELX  AIF   ('&PROTECT' EQ '').PROTECX\n         AIF   ('&PROTECT' NE 'YES').ERRPROT\n         DDD0  =Y(X'61',0),,,,'PROTECT=YES'\n.PROTECX MEXIT\n.ERRVOL9 MNOTE 8,'ONLY FOUR POSITIONAL SUBPARAMETERS ALLOWED IN VOL=&VO*\n               L.. POSITIONAL SUBPARAMETERS OF VOL IGNORED'\n         AGO   .VOLX\n.ERRVOS1 ANOP\n&A       SETA  12\n.ERRVOLS ANOP\n&A       SETA  &A/7\n         MNOTE 8,'VOLUME &A IN VOL=&C DOES NOT HAVE 6 CHARACTERS. VOL=S*\n               ER IGNORED.'\n         AGO   .VOLKEYX\n.ERRVOLR MNOTE 8,'VOLUME REFERENCE BY DDNAME IN VOL=&C NOT SUPPORTED BY*\n                DYNAMIC ALLOCATION. IGNORED.'\n         AGO   .VOLKEYX\n.ERRVOL2 MNOTE 8,'VOL=(,&VOL(2)) INVALID. IGNORED.'\n         AGO   .VOL2X\n.ERRVOL1 MNOTE 8,'VOL=(&VOL(1)) INVALID. IGNORED.'\n         AGO   .VOLX\n.ERRLAB9 MNOTE 8,'ONLY FOUR POSITIONAL SUBPARAMETERS ALLOWED IN LABEL=&*\n               LABEL.. POSITIONAL SUBPARAMETERS OF LABEL IGNORED'\n         AGO   .LABELX\n.ERREXPD MNOTE 8,'LABEL=&C INVALID. IGNORED.'\n         AGO   .LABKEYX\n.ERRLAB2 MNOTE 8,'LABEL=(,&C) INVALID. IGNORED.'\n         AGO   .LABEL2X\n.ERRLAB3 MNOTE 8,'LABEL=(,,&LABEL(3)) INVALID. IGNORED.'\n         AGO   .LABEL3X\n.ERRLAB4 MNOTE 8,'LABEL=(,,,&C) INVALID. IGNORED.'\n         AGO   .LABEL4X\n.ERRPROT MNOTE 8,'PROTECT=&PROTECT INVALID. PROTECT IGNORED'\n         AGO   .PROTECX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD3": {"ttr": 1029, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDD3  &DUMMY,&DCB,&SUBSYS\n         GBLA  &Y\n         LCLA  &A,&K,&L,&M1,&M2\n         LCLB  &@,&B0,&B1,&B2,&B3,&B4,&B5,&B6\n         LCLB  &O0,&O1,&O2,&O3,&O4,&O5,&O6,&O7\n         LCLC  &C,&D\n         AIF   ('&DUMMY' EQ '').DUMMYX\n         AIF   ('&DUMMY' NE 'DUMMY').ERRDUMM\n         DDD0  =Y(X'24',0),,,,'DUMMY'\n.DUMMYX  AIF   ('&DCB' EQ '').DCBX\n&A       SETA  N'&DCB+1\n.DCBLOOP AIF   (&A LE 1).DCBX\n&A       SETA  &A-1\n&C       SETC  '&DCB(&A)'\n&@       SETB  0\n         AIF   ('&C'(K'&C,1) NE '@').@X\n&@       SETB  1\n&C       SETC  '&C'(1,K'&C-1)\n.@X      AIF   (K'&C LE 5).DCB4\n         AIF   ('&C'(1,8) NE 'BLKSIZE=').BLKSIZX\n&C       SETC  '&C'(9,K'&C-8)\n         AIF   (&@).BLKSIZ@\n         DDD0  8,=Y(X'30',1,2,&C),,,'DCB=BLKSIZE=&C'\n         AGO   .DCBLOOP\n.BLKSIZ@ DDD0  6,=Y(X'30',1,2),2,&C,'DCB=BLKSIZE=AL2 AT &C'\n         AGO   .DCBLOOP\n.BLKSIZX AIF   ('&C'(6,1) NE '=').DCB7\n&D       SETC  '&C'(1,5)\n&C       SETC  '&C'(7,K'&C-6)\n         AIF   ('&D' NE 'BUFNO').BUFNOX\n         AIF   (&@).BUFNO@\n         DDD0  7,=AL1(0,X'34',0,1,0,1,&C),,,'DCB=BUFNO=&C'\n         AGO   .DCBLOOP\n.BUFNO@  DDD0  6,=Y(X'34',1,1),1,&C,'DCB=BUFNO=AL1 AT &C'\n         AGO   .DCBLOOP\n.BUFNOX  AIF   ('&D' NE 'RECFM').RECFMX\n         AIF   (&@).RECFM@\n&K       SETA  K'&C+1\n.RECFMA  AIF   (&K LE 1).RECFMW\n&K       SETA  &K-1\n&D       SETC  '&C'(&K,1)\n         AIF   ('&D' NE 'F' AND '&D' NE 'U' AND '&D' NE 'V').RECFMB\n&B0      SETB  ('&D' EQ 'F' OR '&D' EQ 'U')\n&B1      SETB  ('&D' EQ 'V' OR '&D' EQ 'U')\n         AGO   .RECFMA\n.RECFMB  AIF   ('&D' NE 'B').RECFMC\n&B3      SETB  1\n         AGO   .RECFMA\n.RECFMC  AIF   ('&D' NE 'S').RECFMD\n&B4      SETB  1\n         AGO   .RECFMA\n.RECFMD  AIF   ('&D' NE 'A').RECFME\n&B5      SETB  1\n         AGO   .RECFMA\n.RECFME  AIF   ('&D' NE 'M').RECFMF\n&B6      SETB  1\n         AGO   .RECFMA\n.RECFMF  AIF   ('&D' NE 'T').RECFMG\n&B2      SETB  1\n         AGO   .RECFMA\n.RECFMG  AIF   ('&D' NE 'D').RECFMH\n&B2      SETB  1\n         AGO   .RECFMA\n.RECFMH  AIF   ('&D' NE 'G').RECFMI\n&B5      SETB  1\n         AGO   .RECFMA\n.RECFMI  AIF   ('&D' NE 'R').ERRRECF\n&B6      SETB  1\n         AGO   .RECFMA\n.RECFMW  DDD0  7,=AL1(0,X'49',0,1,0,1,B'&B0&B1&B2&B3&B4&B5&B6.0'),,,   *\n               'DCB=RECFM=&C'\n         AGO   .DCBLOOP\n.RECFM@  DDD0  6,=Y(X'49',1,1),1,&C,'DCB=RECFM=XL1 AT &C'\n         AGO   .DCBLOOP\n.RECFMX  AIF   ('&D' NE 'OPTCD').OPTCDX\n         AIF   (&@).OPTCD@\n&K       SETA  K'&C+1\n.OPTCDA  AIF   (&K LE 1).OPTCDW\n&K       SETA  &K-1\n&D       SETC  '&C'(&K,1)\n         AIF   ('&D' NE 'W').OPTCDWX\n&O0      SETB  1\n         AGO   .OPTCDA\n.OPTCDWX AIF   ('&D' NE 'B' AND '&D' NE 'U').OPTCBUX\n&O1      SETB  1\n         AGO   .OPTCDA\n.OPTCBUX AIF   ('&D' NE 'C' AND '&D' NE 'E').OPTCCEX\n&O2      SETB  1\n         AGO   .OPTCDA\n.OPTCCEX AIF   ('&D' NE 'F' AND '&D' NE 'H' AND '&D' NE 'O').OPTFHOX\n&O3      SETB  1\n         AGO   .OPTCDA\n.OPTFHOX AIF   ('&D' NE 'A' AND '&D' NE 'Q').OPTCAQX\n&O4      SETB  1\n         AGO   .OPTCDA\n.OPTCAQX AIF   ('&D' NE 'Z').OPTCDZX\n&O5      SETB  1\n         AGO   .OPTCDA\n.OPTCDZX AIF   ('&D' NE 'T').OPTCDTX\n&O6      SETB  1\n         AGO   .OPTCDA\n.OPTCDTX AIF   ('&D' NE 'R' AND '&D' NE 'J').ERROPTC\n&O7      SETB  1\n         AGO   .OPTCDA\n.OPTCDW  DDD0  7,=AL1(0,X'45',0,1,0,1,B'&O0&O1&O2&O3&O4&O5&O6&O7'),,,  *\n               'DCB=OPTCD=&C'\n         AGO   .DCBLOOP\n.OPTCD@  DDD0  6,=Y(X'45',1,1),1,&C,'DCB=OPTCD=XL1 AT &C'\n         AGO   .DCBLOOP\n.OPTCDX  AIF   ('&D' NE 'LRECL').LRECLX\n         AIF   (&@).LRECL@\n         AIF   ('&C' EQ 'X').LRECLA\n         DDD0  8,=Y(X'42',1,2,&C),,,'DCB=LRECL=&C'\n         AGO   .DCBLOOP\n.LRECL@  DDD0  6,=Y(X'42',1,2),2,&C,'DCB=LRECL=AL2 AT &C'\n         AGO   .DCBLOOP\n.LRECLA  DDD0  8,=Y(X'42',1,2,-X'8000'),'DCB=LRECL=X  VBS ONLY'\n         AGO   .DCBLOOP\n.LRECLX  AIF   ('&D' NE 'DSORG').DSORGX\n         AIF   (&@).DSORG@\n         AIF   ('&C' NE 'PO').DSORGS\n         DDD0  8,=Y(X'3C',1,2,X'0200'),,,'DCB=DSORG=PO'\n         AGO   .DCBLOOP\n.DSORGS  AIF   ('&C' NE 'PS').DSORGD\n         DDD0  8,=Y(X'3C',1,2,X'4000'),,,'DCB=DSORG=PS'\n         AGO   .DCBLOOP\n.DSORGD  AIF   ('&C' NE 'DA').ERRDSOR\n         DDD0  8,=Y(X'3C',1,2,X'2000'),,,'DCB=DSORG=DA'\n         AGO   .DCBLOOP\n.DSORG@  DDD0  6,=Y(X'3C',1,2),2,&C,'DCB=DSORG=XL2 AT &C'\n         AGO   .DCBLOOP\n.DSORGX  AIF   ('&D' NE 'EROPT').EROPTX\n         AIF   (&@).EROPT@\n         AIF   ('&C' NE 'ACC').EROPTA\n         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'80'),,,'DCB=EROPT=ACC'\n         AGO   .DCBLOOP\n.EROPTA  AIF   ('&C' NE 'SKP').EROPTB\n         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'40'),,,'DCB=EROPT=SKP'\n         AGO   .DCBLOOP\n.EROPTB  AIF   ('&C' NE 'ABE').EROPTC\n         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'20'),,,'DCB=EROPT=ABE'\n         AGO   .DCBLOOP\n.EROPTC  AIF   ('&C' NE 'T').ERREROP\n         DDD0  7,=AL1(0,X'3D',0,1,0,1,X'10'),,,'DCB=EROPT=T'\n         AGO   .DCBLOOP\n.EROPT@  DDD0  6,=Y(X'3D',1,1),1,&C,'DCB=EROPT=XL1 AT &C'\n         AGO   .DCBLOOP\n.EROPTX  AIF   ('&D' NE 'LIMCT').ERRDCB\n         AIF   (&@).LIMCT@\n         DDD0  9,=AL3(X'004100',X'010003',&C),,,'DCB=LIMCT=&C'\n         AGO   .DCBLOOP\n.LIMCT@  DDD0  6,=Y(X'41',1,3),3,&C,'DCB=LIMCT=AL3 AT &C'\n         AGO   .DCBLOOP\n.DCB7    AIF   ('&C'(1,7) NE 'KEYLEN=').DCB5\n&C       SETC  '&C'(8,K'&C-7)\n         AIF   (&@).KEYLEN@\n         DDD0  7,=AL1(0,X'40',0,1,0,1,&C),,,'DCB=KEYLEN=&C'\n         AGO   .DCBLOOP\n.KEYLEN@ DDD0  6,=Y(X'40',1,1),1,&C,'DCB=KEYLEN=AL1 AT &C'\n         AGO   .DCBLOOP\n.DCB5    AIF   ('&C'(1,5) NE 'BUFL=').DCB4\n&C       SETC  '&C'(6,K'&C-5)\n         AIF   (&@).BUFL@\n         DDD0  8,=Y(X'32',1,2,&C),,,'DCB=BUFL=&C'\n         AGO   .DCBLOOP\n.BUFL@   DDD0  6,=Y(X'32',1,2),2,&C,'DCB=BUFL=AL2 AT &C'\n         AGO   .DCBLOOP\n.DCB4    AIF   ('&C'(4,1) NE '=').DCBREF\n&D       SETC  '&C'(1,3)\n&C       SETC  '&C'(5,K'&C-4)\n         AIF   ('&D' NE 'DEN').DCBDENX\n         AIF   (&@).DEN@\n         AIF   ('&C' NE '4').DEN3\n         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'D3'),,,'DCB=DEN=4'\n         AGO   .DCBLOOP\n.DEN3    AIF   ('&C' NE '3').DEN2\n         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'C3'),,,'DCB=DEN=3'\n         AGO   .DCBLOOP\n.DEN2    AIF   ('&C' NE '2').DEN1\n         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'83'),,,'DCB=DEN=2'\n         AGO   .DCBLOOP\n.DEN1    AIF   ('&C' NE '1').DEN0\n         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'43'),,,'DCB=DEN=1'\n         AGO   .DCBLOOP\n.DEN0    AIF   ('&C' NE '0').ERRDEN\n         DDD0  7,=AL1(0,X'3B',0,1,0,1,X'03'),,,'DCB=DEN=0'\n         AGO   .DCBLOOP\n.DEN@    DDD0  6,=Y(X'3B',1,1),1,&C,'DCB=DEN=XL1 AT &C'\n         AGO   .DCBLOOP\n.DCBDENX AIF   ('&D' NE 'NCP').ERRDCB\n         AIF   (&@).NCP@\n         DDD0  7,=AL1(0,X'44',0,1,0,1,&C),,,'DCB=NCP=&C'\n         AGO   .DCBLOOP\n.NCP@    DDD0  6,=Y(X'44',1,1),1,&C,'DCB=NCP=AL1 AT &C'\n         AGO   .DCBLOOP\n.DCBREF  AIF   (&A NE 1).ERRDCB2  POSITIONAL PARAMETER\n         AIF   ('&C'(1,2) NE '*.').REFDSN\n&C       SETC  '&C'(3,K'&C-2)\n         AIF   (&@).DCBDDN@\n         DDD0  X'002D0001',&C,8,,'DCB=*.&C'\n         AGO   .DCBLOOP\n.DCBDDN@ DDD0  6,=Y(X'2D',1,8),8,&C,'DCB=*.CL8 AT &C'\n         AGO   .DCBLOOP\n.REFDSN  MNOTE *,'*,* DATASET REFERENCE ASSUMED IN DCB=&C'\n         AIF   (&@).DCBDSN@\n         DDD0  X'002C0001',&C,44,,'DSNAME REFERENCE  DCB=&C'\n         AGO   .DCBLOOP\n.DCBDSN@ DDD0  6,=Y(X'2C',1,44),44,&C,'DSNAME REFERENCE  DCB=CL44 AT &C*\n               '\n         AGO   .DCBLOOP\n.DCBX    AIF   ('&SUBSYS' EQ '').SUBSYSX\n&C       SETC  '&SUBSYS(1)'\n&K       SETA  K'&C\n         AIF   ('&C' EQ '').SUB1X\n         AIF   ('&C'(&K,1) NE '@').SUB1@X\n&C       SETC  '&C'(1,&K-1)\n         DDD0  6,=Y(X'5F',1,4),4,&C,'SUBSYS=(CL4 AT &C)'\n         AGO   .SUB1X\n.SUB1@X  DDD0  X'005F0001',&C,4,,'SUBSYS=(&C)'\n.SUB1X   ANOP\n&A       SETA  N'&SUBSYS+1\n         AIF   (&A LE 2).SUBSYSX\n         SPACE 1\n.ALOOP   AIF   (&A LE 2).AX\n&A       SETA  &A-1\n&D       SETC  '&SUBSYS(&A)   '\n         AIF   ('&D'(1,1) NE '''').DX\n&D       SETC  '&D'(2,K'&D-5).'   '\n.DX      ANOP\n&K       SETA  K'&D-3\n         AIF   ('&D'(&K,1) EQ '@').ERRSUB@\n.ERRSUBX ANOP\n&M       SETA  0\n&M1      SETA  0\n.M2LOOP  AIF   (&M1 GE 2).M2X\n&M1      SETA  &M1+1\n&M       SETA  &M+1\n         AIF   ('&D'(&M,2) NE '''''' AND '&D'(&M,2) NE '&&').M2LOOP\n&K       SETA  &K-1\n&M       SETA  &M+1\n         AGO   .M2LOOP\n.M2X     ANOP\n&C       SETC  '&D'(1,&M)\n.LLOOP   AIF   (&M GE K'&D-3).LX\n&L       SETA  &M+1\n&M1      SETA  0\n.M4LOOP  AIF   (&M1 GE 4).M4X\n&M1      SETA  &M1+1\n&M       SETA  &M+1\n         AIF   ('&D'(&M,2) NE '''''' AND '&D'(&M,2) NE '&&').M4LOOP\n&K       SETA  &K-1\n&M       SETA  &M+1\n         AGO   .M4LOOP\n.M4X     ANOP\n&C       SETC  '&C'',C'''.'&D'(&L,&M-&L+1)\n         AGO   .LLOOP\n.LX      AIF   (&K GT 67).ERRK67\n.K67X    ANOP\n&L       SETA  &K+2\n&Y       SETA  &Y+&L\n         MVC   ALOBLOCK-&Y.(&L),=A(&K*X'10000'+C'&C')\n         AGO   .ALOOP\n.AX      ANOP\n&A       SETA  N'&SUBSYS-1\n&Y       SETA  &Y+4\n         MVC   ALOBLOCK-&Y.(4),=Y(X'60',&A)\n         DDD0  ALOBLOCK-&Y,,,,'SUBSYS=(, )'\n.SUBSYSX MEXIT\n.ERRDUMM MNOTE 8,'INVALID POSITIONAL PARAMETER, &DUMMY.. IGNORED.'\n         AGO   .DUMMYX\n.ERREROP MNOTE 8,'INVALID EROPT, &C.. IGNORED.'\n         AGO   .DCBLOOP\n.ERRRECF MNOTE 8,'INVALID CHAR &D IN RECFM=&C.. RECFM IGNORED.'\n         AGO   .DCBLOOP\n.ERROPTC MNOTE 8,'INVALID CHAR &D IN OPTCD=&C.. OPTCD IGNORED.'\n         AGO   .DCBLOOP\n.ERRDCB2 MNOTE 8,'INVALID DCB PARAMETER, &C.. IGNORED.'\n         AGO   .DCBLOOP\n.ERRDCB  MNOTE 8,'INVALID DCB PARAMETER, &D=&C.. IGNORED.'\n         AGO   .DCBLOOP\n.ERRDSOR MNOTE 8,'DSORG=&C NOT SUPPORTED. IGNORED.'\n         AGO   .DCBLOOP\n.ERRDEN  MNOTE 8,'DEN=&C INVALID. IGNORED.'\n         AGO   .DCBLOOP\n.ERRSUB@ ANOP\n&C       SETC  '&D'(1,&K)\n         MNOTE *,'*,* SUBSYSTEM PARAMETER, ''&C'', TAKEN AS LITERAL'\n         AGO   .ERRSUBX\n.ERRK67  ANOP\n&D       SETC  '&D'(1,K'&D-3)\n         MNOTE 8,'SUBSYSTEM SUBPARAMETER, ''&D'', EXCEEDS 67 CHARACTERS*\n               . TRUNCATED.'\n&K       SETA  67\n         AGO   .K67X\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD4": {"ttr": 1035, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDD4  &SYSOUT,&DEST,&HOLD,&COPIES,&OUTLIM,&FCB,&UCS,          *\n               &BURST,&CHARS,&FLASH,&MODIFY\n         LCLA  &A,&K\n         LCLC  &C,&D\n         AIF   ('&SYSOUT' EQ '').SYSOUTX\n         AIF   (N'&SYSOUT GT 3).ERRSYS9\n&C       SETC  '&SYSOUT(1)'\n         AIF   ('&C' EQ '').SYSOU1X\n         AIF   ('&C' NE '*').SYSOUT1\n         DDD0  =Y(X'18',0),,,,'SYSOUT=*'\n         AGO   .SYSOU1X\n.SYSOUT1 AIF   ('&C'(K'&C,1) NE '@').SYSO1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'18',1,1),1,&C,'SYSOUT=CL1 AT &C'\n         AGO   .SYSOU1X\n.SYSO1@X DDD0  X'00180001',&C,1,,'SYSOUT=&C'\n.SYSOU1X AIF   (N'&SYSOUT LT 2).SYSOUTX\n&C       SETC  '&SYSOUT(2)'\n         AIF   ('&C' EQ '').SYSOU2X\n         AIF   ('&C'(K'&C,1) NE '@').SYSO2@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'19',1,8),8,&C,'SYSOUT=(,CL8 AT &C)'\n         AGO   .SYSOU2X\n.SYSO2@X DDD0  X'00190001',&C,8,,'SYSOUT=(,&C)'\n.SYSOU2X AIF   ('&SYSOUT(3)' EQ '').SYSOUTX\n&C       SETC  '&SYSOUT(3)'\n         AIF   ('&C'(K'&C,1) NE '@').SYSO3@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'1A',1,4),4,&C,'SYSOUT=(,,CL4 AT &C)'\n         AGO   .SYSOUTX\n.SYSO3@X DDD0  X'001A0001',&C,4,,'SYSOUT=(,,&C)'\n.SYSOUTX AIF   ('&DEST' EQ '').DESTX\n&C       SETC  '&DEST'\n         AIF   ('&C'(K'&C,1) NE '@').DEST@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'58',1,7),7,&C,'DEST=CL7 AT &C'\n         AGO   .DESTX\n.DEST@X  DDD0  X'00580001',&C,7,,'DEST=&C'\n.DESTX   AIF   ('&HOLD' EQ '' OR '&HOLD' EQ 'NO').HOLDX\n         AIF   ('&HOLD' NE 'YES').ERRHOLD\n         DDD0  =Y(X'59',0),,,,'HOLD=YES'\n.HOLDX   AIF   ('&COPIES' EQ '').COPIESX\n         AIF   (N'&COPIES GT 2).ERRCOP9\n&C       SETC  '&COPIES(1)'\n         AIF   ('&C' EQ '').COPIE1X\n         AIF   ('&C'(K'&C,1) NE '@').COPIE@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'1D',1,1),1,&C,'COPIES=AL1 AT &C'\n         AGO   .COPIE1X\n.COPIE@X DDD0  7,=AL1(0,X'1D',0,1,0,1,&C),,,'COPIES=&C'\n.COPIE1X AIF   (N'&COPIES LT 2).COPIESX\n&C       SETC  '&COPIES(2)'\n         AIF   ('&C'(1,1) EQ '(').COPIES2\n         DDD0  7,=AL1(0,X'66',0,1,0,1,&C),,,'COPIES=(,&C)  GROUP VALUE'\n         AGO   .COPIESX\n.COPIES2 ANOP\n&A       SETA  2\n.COPLOOP AIF   ('&C'(&A,1) EQ ',').COPLOPX\n&A       SETA  &A+1\n         AIF   (&A LT K'&C).COPLOOP\n.COPLOPX ANOP\n&D       SETC  '&D,0,1,'.'&C'(2,&A-2)\n&C       SETC  '&C'(&A,K'&C-&A+1)\n&K       SETA  &K+1\n         AIF   (K'&C GT 1).COPIES2\n&A       SETA  &K*3+4\n         DDD0  &A,=AL1(0,X'66',0,&K&D),,,'COPIES=(,&COPIES(2))  GROUP V*\n               ALUES'\n.COPIESX AIF   ('&OUTLIM' EQ '').OUTLIMX\n         AIF   ('&OUTLIM'(K'&OUTLIM,1) NE '@').OUTLI@X\n&C       SETC  '&OUTLIM'(1,K'&OUTLIM-1)\n         DDD0  6,=Y(X'1B',1,3),3,&C,'OUTLIM=AL3 AT &C'\n         AGO   .OUTLIMX\n.OUTLI@X DDD0  9,=AL3(X'001B00',X'010003',&OUTLIM),,,'OUTLIM=&OUTLIM'\n.OUTLIMX AIF   ('&FCB' EQ '').FCBX\n         AIF   (N'&FCB GT 2).ERRFCB9\n&C       SETC  '&FCB(1)'\n         AIF   ('&C' EQ '').FCB1X\n         AIF   ('&C'(K'&C,1) NE '@').FCB1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'25',1,4),4,&C,'FCB=(CL4 AT &C)'\n         AGO   .FCB1X\n.FCB1@X  DDD0  X'00250001',&FCB(1),4,,'FCB=(&FCB(1))'\n.FCB1X   AIF   ('&FCB(2)' EQ '').FCBX\n&C       SETC  '&FCB(2)'\n         AIF   ('&C' NE 'VERIFY').FCB2A\n         DDD0  7,=AL1(0,X'26',0,1,0,1,X'04'),,,'FCB=(,VERIFY)'\n         AGO   .FCBX\n.FCB2A   AIF   ('&C' NE 'ALIGN').FCB2@\n         DDD0  7,=AL1(0,X'26',0,1,0,1,X'08'),,,'FCB=(,ALIGN)'\n         AGO   .FCBX\n.FCB2@   AIF   ('&C'(K'&C,1) NE '@').ERRFCB\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'26',1,1),1,&C,'FCB=(,XL1 AT &C)'\n.FCBX    AIF   ('&UCS' EQ '').UCSX\n         AIF   (N'&UCS GT 3).ERRUCS9\n&C       SETC  '&UCS(1)'\n         AIF   ('&C' EQ '').UCS1X\n         AIF   ('&C'(K'&C,1) NE '@').UCS1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'29',1,4),4,&C,'UCS=(CL4 AT &C)'\n         AGO   .UCS1X\n.UCS1@X  DDD0  X'00290001',&C,4,,'UCS=(&C)'\n.UCS1X   AIF   ('&UCS(2)' EQ '').UCS2X\n         AIF   ('&UCS(2)' NE 'FOLD').ERRUCS2\n         DDD0  =Y(X'2A',0),,,,'UCS=(,FOLD)'\n.UCS2X   AIF   ('&UCS(3)' EQ '').UCSX\n         AIF   ('&UCS(3)' NE 'VERIFY').ERRUCS3\n         DDD0  =Y(X'2B',0),,,,'UCS=(,,VERIFY)'\n.UCSX    AIF   ('&BURST' EQ '').BURSTX\n         AIF   ('&BURST' NE 'YES' AND '&BURST' NE 'Y').BURSTYX\n         DDD0  7,=AL1(0,X'64',0,1,0,1,X'02'),,,'BURST=&BURST'\n         AGO   .BURSTX\n.BURSTYX AIF   ('&BURST' NE 'NO' AND '&BURST' NE 'N').BURSTNX\n         DDD0  7,=AL1(0,X'64',0,1,0,1,X'04'),,,'BURST=&BURST'\n         AGO   .BURSTX\n.BURSTNX AIF   ('&BURST'(K'&BURST,1) NE '@').ERRBURS\n&C       SETC  '&BURST'(1,K'&BURST-1)\n         DDD0  6,=Y(X'64',1,1),1,&C,'BURST=XL1 AT &C'\n.BURSTX  AIF   ('&CHARS' EQ '').CHARSX\n         AIF   (N'&CHARS GT 1).CHARMUL\n&C       SETC  '&CHARS(1)'\n         AIF   ('&C'(K'&C,1) NE '@').CHARS@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'65',1,4),4,&C,'CHARS=CL4 AT &C'\n         AGO   .CHARSX\n.CHARS@X DDD0  X'00650001',&C,4,,'CHARS=&CHARS'\n         AGO   .CHARSX\n.CHARMUL AIF   (N'&CHARS GT 4).ERRCHA9\n&C       SETC  ''\n.CHLOOP  ANOP\n&A       SETA  &A+1\n         AIF   (K'&CHARS(&A) LT 1).ERRCHA1\n         AIF   ('&CHARS(&A)'(K'&CHARS(&A),1) EQ '@').ERRCHA@\n         AIF   (K'&CHARS(&A) GT 4).ERRCHA4\n&C       SETC  '&C,4,C'''.'&CHARS(&A) '(1,2).''',C'''.'&CHARS(&A)   '(3*\n               ,2).''''\n         AIF   (&A LT N'&CHARS).CHLOOP\n&C       SETC  '&A&C'\n&A       SETA  &A*6+4\n         DDD0  &A,=AL2(X'65',&C),,,'CHARS=&CHARS'\n.CHARSX  AIF   ('&FLASH' EQ '').FLASHX\n         AIF   (N'&FLASH GT 2).ERRFLS9\n&C       SETC  '&FLASH(1)'\n         AIF   ('&C' EQ '').FLASH1X\n         AIF   ('&C'(K'&C,1) NE '@').FLAS1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'67',1,4),4,&C,'UCS=(CL4 AT &C)'\n         AGO   .FLASH1X\n.FLAS1@X DDD0  X'00670001',&C,4,,'FLASH=(&C)'\n.FLASH1X AIF   (N'&FLASH LT 2).FLASHX\n&C       SETC  '&FLASH(2)'\n         AIF   ('&C'(K'&C,1) NE '@').FLSH2@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'68',1,1),1,&C,'FLASH=(,AL1 AT &C)  FORMS OVERLAY *\n               COUNT'\n         AGO   .FLASHX\n.FLSH2@X DDD0  7,=AL1(0,X'68',0,1,0,1,&C),,,'FLASH=(,&C)  FORMS OVERLAY*\n                COUNT'\n.FLASHX  AIF   ('&MODIFY' EQ '').MODIFYX\n         AIF   (N'&MODIFY GT 2).ERRMOD9\n&C       SETC  '&MODIFY(1)'\n         AIF   ('&C' EQ '').MODIF1X\n         AIF   ('&C'(K'&C,1) NE '@').MODI1@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'69',1,4),4,&C,'MODIFY=(CL4 AT &C)'\n         AGO   .MODIF1X\n.MODI1@X DDD0  X'00690001',&C,4,,'MODIFY=(&C)'\n.MODIF1X AIF   (N'&MODIFY LT 2).MODIFYX\n&C       SETC  '&MODIFY(2)'\n         AIF   ('&C'(K'&C,1) NE '@').MODI2@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'6A',1,1),1,&C,'MODIFY=(,XL1 AT &C)  TABLE REFEREN*\n               CE CHARACTER'\n         AGO   .MODIFYX\n.MODI2@X DDD0  7,=AL1(0,X'6A',0,1,0,1,&C),,,'MODIFY=(,&C)  TABLE REFERE*\n               NCE CHARACTER'\n.MODIFYX MEXIT\n.ERRSYS9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN SYSOUT=&SYSOUT.. *\n               SYSOUT IGNORED.'\n         AGO   .SYSOUTX\n.ERRHOLD MNOTE 8,'HOLD=&HOLD INVALID. HOLD IGNORED.'\n         AGO   .HOLDX\n.ERRCOP9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN COPIES=&COPIES.. CO*\n               PIES IGNORED.'\n         AGO   .COPIESX\n.ERRFCB9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN FCB=&FCB.. FCB IGNO*\n               RED.'\n         AGO   .FCBX\n.ERRFCB  MNOTE 8,'INVALID VALUE, FCB=(,&C). IGNORED.'\n         AGO   .FCBX\n.ERRUCS9 MNOTE 8,'ONLY THREE SUBPARAMETERS ALLOWED IN UCS=&UCS.. UCS IG*\n               NORED.'\n         AGO   .UCSX\n.ERRUCS2 MNOTE 8,'INVALID VALUE, UCS=(,&UCS(2)). IGNORED.'\n         AGO   .UCS2X\n.ERRUCS3 MNOTE 8,'INVALID VALUE, UCS=(,,&UCS(3)). IGNORED.'\n         AGO   .UCSX\n.ERRBURS MNOTE 8,'BURST=&BURST INVALID. BURST IGNORED.'\n         AGO   .BURSTX\n.ERRCHA1 MNOTE 8,'NULL SUBPARAMETER IN CHARS=&CHARS NOT ALLOWED. CHARS *\n               IGNORED.'\n         AGO   .CHARSX\n.ERRCHA@ MNOTE 8,'ONLY ONE CHARACTER ARRANGEMENT TABLE NAME MAY BE SPEC*\n               IFIED WHEN USING ''@''. CHARS=&CHARS IGNORED.'\n         AGO   .CHARSX\n.ERRCHA4 MNOTE 8,'CHARACTER ARRANGEMENT TABLE NAMES MUST BE ONE TO FOUR*\n                CHARACTERS LONG. CHARS=&CHARS IGNORED.'\n         AGO   .CHARSX\n.ERRCHA9 MNOTE 8,'ONLY FOUR SUBPARAMETERS ALLOWED IN CHARS=&CHARS.. CHA*\n               RS IGNORED.'\n         AGO   .CHARSX\n.ERRFLS9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN FLASH=&FLASH.. FLAS*\n               H IGNORED.'\n         AGO   .FLASHX\n.ERRMOD9 MNOTE 8,'ONLY TWO SUBPARAMETERS ALLOWED IN MODIFY=&MODIFY.. MO*\n               DIFY IGNORED.'\n         AGO   .MODIFYX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDD5": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DDD5  &DDNAME,&DSN,&DSNAME,&DISP\n         GBLB  &RTDDN,&CONCATB\n         LCLA  &A,&X\n         LCLC  &C,&D\n         AIF   ('&DDNAME' EQ '' OR '&DDNAME' EQ 'RETURN').DDNAMEQ\n         AIF   ('&DDNAME'(K'&DDNAME,1) NE '@').DDNAM@X\n&C       SETC  '&DDNAME'(1,K'&DDNAME-1)\n         DDD0  6,=Y(X'01',1,8),8,&C,'DDNAME CL8 AT &C'\n         AGO   .DDNAMEQ\n.DDNAM@X DDD0  X'00010001',&DDNAME,8,,'DDNAME IS &DDNAME'\n.DDNAMEQ AIF   (NOT &CONCATB AND '&DDNAME' NE 'RETURN').DDNAMEX\n         MVC   ALORTDDN(14),=Y(X'55',1,8,C'  ',C'  ',C'  ',C'  ')\n         DDD0  ALORTDDN,,,,'RETURN THE DDNAME'\n&RTDDN   SETB  1\n.DDNAMEX AIF   ('&DSN&DSNAME' EQ '').DSNAMEX\n&C       SETC  '&DSN'\n         AIF   ('&DSNAME' EQ '').DSNAMEB\n         AIF   ('&DSN' NE '').ERRDSN\n&C       SETC  '&DSNAME'\n.DSNAMEB AIF   ('&C'(1,1) EQ '*').ERRDREF\n&A       SETA  K'&C\n         AIF   ('&C'(&A,1) NE ')').DSNAME\n.MEMLOOP AIF   (&A LE 1).ERRMEM\n&A       SETA  &A-1\n         AIF   ('&C'(&A,1) NE ')').PARENX\n&X       SETA  &X+1\n.PARENX  AIF   ('&C'(&A,1) NE '(').MEMLOOP\n&X       SETA  &X-1\n         AIF   (&X GE 0).MEMLOOP\n&D       SETC  '&C'(&A+1,K'&C-&A-1)\n         AIF   ('&D'(K'&D,1) NE '@').MEMBE@X\n&D       SETC  '&D'(1,K'&D-1)\n         DDD0  6,=Y(X'03',1,8),8,&D,'DSN=...(CL8 AT &D)'\n         AGO   .MEMBERX\n.MEMBE@X DDD0  X'00030001',&D,8,,'DSN=...(&D)'\n.MEMBERX AIF   (&A  EQ 1).DSNAMEX\n&C       SETC  '&C'(1,&A-1)\n.DSNAME  AIF   ('&C'(K'&C,1) NE '@').DSNAM@X\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'02',1,44),44,&C,'DSNAME=CL44 AT &C'\n         AGO   .DSNAMEX\n.DSNAM@X DDD0  X'00020001',&C,44,,'DSN=&C'\n.DSNAMEX AIF   ('&DISP' EQ '').DISPX\n&C       SETC  '&DISP(1)'\n         AIF   ('&C' EQ '').STATUSX\n         AIF   ('&C' NE 'SHR' AND '&C' NE 'SHARE').STATUSA\n         DDD0  7,=AL1(0,X'04',0,1,0,1,X'08'),,,'DISP=(&C)'\n         AGO   .STATUSX\n.STATUSA AIF   ('&C' NE 'OLD').STATUSB\n         DDD0  7,=AL1(0,X'04',0,1,0,1,X'01'),,,'DISP=(OLD)'\n         AGO   .STATUSX\n.STATUSB AIF   ('&C' NE 'NEW').STATUSC\n         DDD0  7,=AL1(0,X'04',0,1,0,1,X'04'),,,'DISP=(NEW)'\n         AGO   .STATUSX\n.STATUSC AIF   ('&C' NE 'MOD').STATUSD\n         DDD0  7,=AL1(0,X'04',0,1,0,1,X'02'),,,'DISP=(MOD)'\n         AGO   .STATUSX\n.STATUSD AIF   ('&C'(K'&C,1) NE '@').ERRSTA\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'04',1,1),1,&C,'DISP=(XL1 AT &C)'\n.STATUSX AIF   ('&DISP(2)' EQ '').NDISPX\n&C       SETC  '&DISP(2)'\n         AIF   ('&C' NE 'CATLG').NDISPA\n         DDD0  7,=AL1(0,X'05',0,1,0,1,X'02'),,,'DISP=(,CATLG)'\n         AGO   .NDISPX\n.NDISPA  AIF   ('&C' NE 'DELETE').NDISPK\n         DDD0  7,=AL1(0,X'05',0,1,0,1,X'04'),,,'DISP=(,DELETE)'\n         AGO   .NDISPX\n.NDISPK  AIF   ('&C' NE 'KEEP').NDISPU\n         DDD0  7,=AL1(0,X'05',0,1,0,1,X'08'),,,'DISP=(,KEEP)'\n         AGO   .NDISPX\n.NDISPU  AIF   ('&C' NE 'UNCATLG').NDISP@\n         DDD0  7,=AL1(0,X'05',0,1,0,1,X'01'),,,'DISP=(,UNCATLG)'\n         AGO   .NDISPX\n.NDISP@  AIF   ('&C'(K'&C,1) NE '@').ERRNDIS\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'05',1,1),1,&C,'DISP=(,XL1 AT &C)'\n.NDISPX  AIF   ('&DISP(3)' EQ '').DISPX\n&C       SETC  '&DISP(3)'\n         AIF   ('&C' NE 'CATLG').CDISPA\n         DDD0  7,=AL1(0,X'06',0,1,0,1,X'02'),,,'DISP=(,,CATLG)'\n         AGO   .DISPX\n.CDISPA  AIF   ('&C' NE 'DELETE').CDISPB\n         DDD0  7,=AL1(0,X'06',0,1,0,1,X'04'),,,'DISP=(,,DELETE)'\n         AGO   .DISPX\n.CDISPB  AIF   ('&C' NE 'KEEP').CDISPU\n         DDD0  7,=AL1(0,X'06',0,1,0,1,X'08'),,,'DISP=(,,KEEP)'\n         AGO   .DISPX\n.CDISPU  AIF   ('&C' NE 'UNCATLG').CDISP@\n         DDD0  7,=AL1(0,X'06',0,1,0,1,X'01'),,,'DISP=(,,UNCATLG)'\n         AGO   .DISPX\n.CDISP@  AIF   ('&C'(K'&C,1) NE '@').ERRCDIS\n&C       SETC  '&C'(1,K'&C-1)\n         DDD0  6,=Y(X'06',1,1),1,&C,'DISP=(,,XL1 AT &C)'\n.DISPX   MEXIT\n.ERRDSN  MNOTE 12,'BOTH DSN= AND DSNAME= SPECIFIED. BOTH IGNORED.'\n         AGO   .DSNAMEX\n.ERRDREF MNOTE 8,'DSNAME BY DDNAME REFERENCE IN DSN=&C NOT SUPPORTED BY*\n                DYNAMIC ALLOCATION. DSN IGNORED.'\n         AGO   .DSNAMEX\n.ERRMEM  MNOTE 12,'INVALID DSNAME, &C'\n         AGO   .DSNAMEX\n.ERRSTA  MNOTE 12,'INVALID FIRST DISP PARAMETER, &C'\n         AGO   .STATUSX\n.ERRNDIS MNOTE 12,'INVALID SECOND DISP PARAMETER, &C'\n         AGO   .NDISPX\n.ERRCDIS MNOTE 12,'INVALID THIRD DISP VALUE, &C'\n         AGO   .DISPX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDI": {"ttr": 1288, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&DDNAME  DDI   &DISP=,                                                 *\n               &KEYADDS=,&EXIT=ALODFAIL\n         GBLA  &X,&Y,&H,&N,&R\n         GBLB  &DDDFAIL,&DDDD\n         LCLA  &A,&AD1,&AD2,&AD3\n         LCLC  &C,&CD1,&CD2,&CD3\n         AIF   (&DDDD).ERRDDDD\n&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER\n&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA\n&R       SETA  14                      FIRST REGISTER LOADED\n         DDD5  &DDNAME\n         AIF   ('&DISP' EQ '').DISPX\n&C       SETC  '&DISP(1)'\n         AIF   ('&C' EQ '').DISP1X\n         AIF   ('&C'(K'&C,1) EQ '@').DISP1@\n         MNOTE 8,'DISP=( ) MUST BE INDIRECT ADDRESS. DISP=(&C) IGNORED.*\n               '\n         AGO   .DISP1X\n.DISP1@  ANOP\n&CD1     SETC  '&C'(1,K'&C-1)\n         DDD0  7,=AL1(0,X'07',0,1,0,1,0),,,                            *\n               'DISP=(XL1 RETURNED AT &CD1)'\n&AD1     SETA  &Y-6\n.DISP1X  ANOP\n&C       SETC  '&DISP(2)'\n         AIF   ('&C' EQ '').DISP2X\n         AIF   ('&C'(K'&C,1) EQ '@').DISP2@\n         MNOTE 8,'DISP=(, ) MUST BE INDIRECT ADDRESS. DISP=(,&C) IGNORE*\n               D.'\n         AGO   .DISP2X\n.DISP2@  ANOP\n&CD2     SETC  '&C'(1,K'&C-1)\n         DDD0  7,=AL1(0,X'08',0,1,0,1,0),,,                            *\n               'DISP=(,XL1 RETURNED AT &CD2)'\n&AD2     SETA  &Y-6\n.DISP2X  ANOP\n&C       SETC  '&DISP(3)'\n         AIF   ('&C' EQ '').DISPX\n         AIF   ('&C'(K'&C,1) EQ '@').DISP3@\n         MNOTE 8,'DISP=(,, ) MUST BE INDIRECT ADDRESS. DISP=(,,&C) IGNO*\n               RED.'\n         AGO   .DISPX\n.DISP3@  ANOP\n&CD3     SETC  '&C'(1,K'&C-1)\n         DDD0  7,=AL1(0,X'09',0,1,0,1,0),,,                            *\n               'DISP=(,,XL1 RETURNED AT &CD3)'\n&AD3     SETA  &Y-6\n.DISPX   AIF   ('&KEYADDS' EQ '').KEYADDX\n&A       SETA  0\n.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX\n&A       SETA  &A+1\n&C       SETC  '&KEYADDS(&A)'\n         AIF   ('&C' EQ '').KEYLOOP\n         AIF   ('&C'(1,1) EQ '(').KEYADDR\n         DDD0  &C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDX AIF   (&R NE 14).R14X\n&X       SETA  &X-4\n         AGO   .RX\n.R14X    AIF   (&R NE 15).R15X\n         ST    14,ALOBLOCK+&X\n         AGO   .RX\n.R15X    AIF   (&R NE 0).R0X\n         STM   14,15,ALOBLOCK+&X\n&X       SETA  &X+4\n         AGO   .RX\n.R0X     STM   14,0,ALOBLOCK+&X\n&X       SETA  &X+8\n.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST\n         LA    0,X'0700'                LOAD VERB, FLAGS1\n         AIF   ('&EXIT'(1,1) EQ '(').LREXIT\n&DDDFAIL SETB  ('&EXIT' EQ 'ALODFAIL' OR &DDDFAIL)\n         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n         AGO   .BALDDDD\n.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO\n         SPACE 1\n         AIF   (&AD1 EQ 0).D1X\n         MVC   &CD1.(1),ALOBLOCK-&AD1\n.D1X     AIF   (&AD2 EQ 0).D2X\n         MVC   &CD2.(1),ALOBLOCK-&AD2\n.D2X     AIF   (&AD3 EQ 0).D3X\n         MVC   &CD3.(1),ALOBLOCK-&AD3\n.D3X     AIF   (&H GE &Y).HX\n&H       SETA  &Y\n.HX      AIF   (&N GE &X).NX\n&N       SETA  &X\n.NX      MEXIT\n.ERRDDDD MNOTE 12,'DDI MAY NOT BE ISSUED AFTER DDDD'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDTU": {"ttr": 1291, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO                                                          01675\n&DDNAME  DDTU  &DUMMY,&DSN=,&DSNAME=,&DISP=,&TERM=,&FREE=,             *01676*92\n               &UNIT=,&SPACE=,&MSVGP=,&VOL=,&LABEL=,&PROTECT=,         *01677*92\n               &DCB=,&SUBSYS=,                                         *01678*92\n               &SYSOUT=,&DEST=,&HOLD=,&COPIES=,&OUTLIM=,&FCB=,&UCS=,   *01679*90\n               &PASWORD=                                                01680*90\n         LCLA  &K,&A                                                    01681*53\n         LCLB  &B0,&B1,&B2,&B3,&B4,&B5,&B6                              01682*90\n         LCLC  &C,&D                                                    01683\n         AIF   ('&DDNAME' EQ '' OR '&DDNAME' EQ 'RETURN').DDNAMEQ       01684*90\n&DDNAME  DC    Y(X'01',1,8)            DDNAME                           01685*92\n.DDNAMEQ AIF   ('&DDNAME' NE 'RETURN').DDNAMEX                          01686*90\nRETURN   DC    Y(X'55',1,8)            RETURN THE DDNAME                01687*90\n.DDNAMEX AIF   ('&DSN&DSNAME' EQ '').DSNAMEX                            01688*90\n&C       SETC  '&DSN'                                                   01689*90\n         AIF   ('&DSNAME' EQ '').DSNAMEB                                01690*90\n         AIF   ('&DSN' NE '').ERRDSN                                    01691*90\n&C       SETC  '&DSNAME'                                                01692*90\n.DSNAMEB ANOP                                                           01693*90\n&A       SETA  K'&C                                                     01694*90\n         AIF   ('&C'(&A,1) NE ')').DSNAME                               01695*90\n.MEMLOOP AIF   (&A LE 1).ERRMEM                                         01696*92\n&A       SETA  &A-1                                                     01697*90\n         AIF   ('&C'(&A,1) NE '(').MEMLOOP                              01698*90\n&D       SETC  '&C'(&A+1,K'&C-&A-1)                                     01699*92\n&D       DC    Y(X'03',1,8)            DSN=...( )                       01700*92\n&C       SETC  '&C'(1,&A-1)                                             01701*92\n.DSNAME  AIF   ('&C' EQ '').DSNAMEX                                     01702*90\n&C       DC    Y(X'02',1,44)           DSN=                             01703*92\n.DSNAMEX AIF   ('&DISP' EQ '').DISPX                                    01704*90\n         AIF   ('&DISP(1)' EQ '').STATUSX                               01705*90\n&DISP(1) DC    Y(X'04',1,1)             DISP=( )                        01706*92\n.STATUSX AIF   ('&DISP(2)' EQ '').NDISPX                                01707*90\n&DISP(2) DC    Y(X'05',1,1)             DISP=(, )                       01708*92\n.NDISPX  AIF   (N'&DISP LT 3).DISPX                                     01709*90\n&DISP(3) DC    Y(X'06',1,1)             DISP=(,, )                      01710*92\n.DISPX   AIF   ('&TERM' EQ '').TERMX                                    01711*90\n&TERM    DC    Y(X'28',0)              TERM=TS                          01712*90\n.TERMX   AIF   ('&FREE' EQ '').FREEX                                    01713*90\n&FREE    DC    Y(X'1C',0)              FREE=CLOSE                       01714*90\n.FREEX   AIF   ('&UNIT&SPACE&MSVGP' EQ '').DDD1X                        01715*90\n         AIF   ('&UNIT' EQ '').UNITX                                    01716*90\n         AIF   ('&UNIT(1)' EQ '').UNIT1X                                01717*90\n&UNIT(1) DC    Y(X'15',1,8)            UNIT=( )                         01718*90\n.UNIT1X  AIF   ('&UNIT(2)' EQ '').UNIT2X                                01719*90\n         AIF   ('&UNIT(2)' NE 'P').UNITC                                01720*90\nP        DC    Y(X'17',0)              UNIT=(,P)  PARALLEL MOUNT        01721*90\n         AGO   .UNIT2X                                                  01722*90\n.UNITC   ANOP                                                           01723*90\n&UNIT(2) DC    Y(X'16',1,1)            UNIT=(, )  UNIT COUNT            01724*90\n.UNIT2X  AIF   ('&UNIT(3)' EQ '').UNITX                                 01725*90\n         MNOTE 8,'UNIT=(,,DEFER) NOT SUPPORTED BY DYNAMIC ALLOCATION.'  01726*90\n.UNITX   AIF   ('&SPACE' EQ '').SPACEX                                  01727*90\n&C       SETC  '&SPACE(1)'                                              01728*90\n         AIF   ('&C' EQ '').SPACE2                                      01729*90\n         AIF   ('&C' NE 'TRK').SPACE1C                                  01730*90\nTRK      DC    Y(X'07',0)              SPACE=(TRK)                      01731*92\n         AGO   .SPACE2                                                  01732*90\n.SPACE1C AIF   ('&C' NE 'CYL').SPACE1A                                  01733*90\nCYL      DC    Y(X'08',0)              SPACE=(CYL)                      01734*92\n         AGO   .SPACE2                                                  01735*90\n.SPACE1A ANOP                                                           01736*90\n&C       DC    Y(X'09',1,3)            SPACE=( )                        01737*92\n.SPACE2  AIF   ('&SPACE(2)' EQ '').SPACE2X                              01738*90\n&C       SETC  '&SPACE(2)'                                              01739*90\n         AIF   ('&C'(1,1) NE '(').SPACE2W                               01740*90\n&K       SETA  2                                                        01741*90\n.SPACE2A AIF   ('&C'(&K,1) EQ ',').SPACE2B                              01742*90\n&K       SETA  &K+1                                                     01743*90\n         AIF   (&K LT K'&C).SPACE2A                                     01744*90\n.SPACE2B AIF   (&K EQ 2).SPACE2C                                        01745*92\n&D       SETC  '&C'(2,&K-2)                                             01746*92\n&D       DC    Y(X'0A',1,3)            SPACE=(,( ))                     01747*90\n.SPACE2C AIF   (&K GE K'&C).SPACE2X                                     01748*90\n&K       SETA  &K+1                                                     01749*90\n&A       SETA  &K                                                       01750*90\n.SPACE2D AIF   ('&C'(&K,1) EQ ',').SPACE2E                              01751*90\n&K       SETA  &K+1                                                     01752*90\n         AIF   (&K LT K'&C).SPACE2D                                     01753*90\n.SPACE2E AIF   (&K EQ &A).SPACE2F                                       01754*90\n&D       SETC  '&C'(&A,&K-&A)                                           01755*90\n&D       DC    Y(X'0B',1,3)            SPACE=(,(, ))                    01756*90\n.SPACE2F AIF   (&K GE K'&C).SPACE2X                                     01757*90\n&K       SETA  &K+1                                                     01758*90\n         AIF   (&K GE K'&C).SPACE2X                                     01759*90\n&A       SETA  &K                                                       01760*90\n.SPACE2G AIF   ('&C'(&K,1) EQ ',').ERRSPA2                              01761*90\n&K       SETA  &K+1                                                     01762*90\n         AIF   (&K LT K'&C).SPACE2G                                     01763*90\n&D       SETC  '&C'(&A,&K-&A)                                           01764*90\n&D       DC    Y(X'0C',1,3)            SPACE=(,(,, ))                   01765*90\n         AGO   .SPACE2X                                                 01766*90\n.SPACE2W ANOP                                                           01767*90\n&C       DC    Y(X'0A',1,3)            SPACE=(,( ))                     01768*90\n.SPACE2X AIF   (N'&SPACE LE 3).SPACE3                                   01769*90\n&C       SETC  '&SPACE(5)'                                              01770*90\n&D       SETC  '&SPACE(4)'                                              01771*90\n         AIF   ('&C' EQ '').SPACE4                                      01772*90\n&C       DC    Y(X'0F',0)              SPACE=(,,,,ROUND)                01773*90\n.SPACE4  AIF   ('&D' EQ '').SPACE3                                      01774*90\n&D       DC    Y(X'0E',1,1)            SPACE=(,,, )                     01775*90\n.SPACE3  AIF   ('&SPACE(3)' EQ '').SPACEX                               01776*90\n&C       SETC  '&SPACE(3)'                                              01777*90\n&C       DC    Y(X'0D',0)              SPACE=(,,RLSE)                   01778*90\n.SPACEX  AIF   ('&MSVGP' EQ '').MSVGPX                                  01779*90\n&MSVGP   DC    Y(X'5E',1,8)            MSVGP=                           01780*90\n.MSVGPX  ANOP                                                           01781*90\n.DDD1X   AIF   ('&VOL&LABEL&PROTECT' EQ '').DDD2X                       01782*92\n         AIF   ('&VOL' EQ '').VOLX                                      01783*90\n&C       SETC  '&VOL(N'&VOL)'                                           01784*90\n         AIF   ('&C'(1,4) NE 'SER=').VOLREF                             01785*90\n&C       SETC  '&C'(5,K'&C-4)                                           01786*90\n&C       DC    Y(X'10',1,6)            VOL=SER=                         01787*90\n         AGO   .VOLKEYX                                                 01788*90\n.VOLREF  AIF   ('&C'(1,4) NE 'REF=').VOL4                               01789*90\n&C       SETC  '&C'(5,K'&C-4)                                           01790*90\n&C       DC    Y(X'14',1,44)           VOL=REF=                         01791*90\n.VOLKEYX AIF   (N'&VOL LE 1).VOLX                                       01792*90\n         AIF   (N'&VOL LE 2).VOL2X                                      01793*90\n         AIF   (N'&VOL LE 3).VOL3X                                      01794*90\n         AIF   (N'&VOL LE 4).VOL4X                                      01795*90\n.VOL4    AIF   ('&VOL(4)' EQ '').VOL4X                                  01796*90\n&VOL(4)  DC    Y(X'13',1,1)            VOL=(,,, )                       01797*90\n.VOL4X   AIF   ('&VOL(3)' EQ '').VOL3X                                  01798*90\n&VOL(3)  DC    Y(X'12',1,2)            VOL=(,, )                        01799*90\n.VOL3X   AIF   ('&VOL(2)' EQ '').VOL2X                                  01800*90\n         MNOTE 8,'VOL=(,RETAIN) NOT SUPPORTED BY DYNAMIC ALLOCATION'    01801*90\n.VOL2X   AIF   ('&VOL(1)' EQ '').VOLX                                   01802*90\n&VOL(1)  DC    Y(X'11',0)              VOL=(PRIVATE)                    01803*90\n.VOLX    AIF   ('&LABEL' EQ '').LABELX                                  01804*90\n&C       SETC  '&LABEL(N'&LABEL)'                                       01805*90\n         AIF   ('&C'(1,6) NE 'EXPDT=').LABELEX                          01806*90\n&C       SETC  '&C'(7,K'&C-6)                                           01807*90\n&C       DC    Y(X'22',1,5)            LABEL=EXPDT=                     01808*90\n         AGO   .LABKEYX                                                 01809*90\n.LABELEX AIF   ('&C'(1,6) NE 'RETPD=').LABELRX                          01810*90\n&C       SETC  '&C'(7,K'&C-6)                                           01811*90\n&C       DC    Y(X'23',1,2)            LABEL=RETPD=                     01812*90\n.LABKEYX AIF   (N'&LABEL LE 1).LABELX                                   01813*90\n         AIF   (N'&LABEL LE 2).LABEL2X                                  01814*90\n         AIF   (N'&LABEL LE 3).LABEL3X                                  01815*90\n         AIF   (N'&LABEL LE 4).LABEL4X                                  01816*90\n.LABELRX AIF   ('&LABEL(4)' EQ '').LABEL4X                              01817*90\n&C       SETC  '&LABEL(4)'                                              01818*90\n&C       DC    Y(X'21',1,1)            LABEL=(,,, )                     01819*90\n.LABEL4X AIF   ('&LABEL(3)' EQ '').LABEL3X                              01820*90\n&C       SETC  '&LABEL(3)'                                              01821*90\n&C       DC    Y(X'20',1,1)            LABEL=(,, )                      01822*90\n.LABEL3X AIF   ('&LABEL(2)' EQ '').LABEL2X                              01823*90\n&C       SETC  '&LABEL(2)'                                              01824*90\n&C       DC    Y(X'1E',1,1)            LABEL=(, )                       01825*90\n.LABEL2X AIF   ('&LABEL(1)' EQ '').LABELX                               01826*90\n&C       SETC  '&LABEL(1)'                                              01827*90\n&C       DC    Y(X'1F',1,2)            LABEL=( )                        01828*90\n.LABELX  AIF   ('&PROTECT' EQ '').PROTECX                               01829*92\n&PROTECT DC    Y(X'61',0)              PROTECT=YES                      01830*92\n.PROTECX ANOP                                                           01831*92\n.DDD2X   AIF   ('&DUMMY&DCB&SUBSYS' EQ '').DDD3X                        01832*92\n         AIF   ('&DUMMY' EQ '').DUMMYX                                  01833*90\n&DUMMY   DC    Y(X'24',0)              DUMMY                            01834*90\n.DUMMYX  AIF   ('&DCB' EQ '').DCBX                                      01835*90\n&A       SETA  N'&DCB+1                                                 01836*90\n.DCBLOOP AIF   (&A LE 1).DCBX                                           01837*90\n&A       SETA  &A-1                                                     01838*90\n&C       SETC  '&DCB(&A)'                                               01839*90\n         AIF   (K'&C LE 5).DCB4                                         01840*90\n         AIF   ('&C'(1,8) NE 'BLKSIZE=').BLKSIZX                        01841*90\n&C       SETC  '&C'(9,K'&C-8)                                           01842*90\n&C       DC    Y(X'30',1,2)            DCB=BLKSIZE=                     01843*92\n         AGO   .DCBLOOP                                                 01844*90\n.BLKSIZX AIF   ('&C'(6,1) NE '=').DCB7                                  01845*90\n&D       SETC  '&C'(7,K'&C-6)                                           01846*90\n&C       SETC  '&C'(1,5)                                                01847*90\n         AIF   ('&C' NE 'BUFNO').BUFNOX                                 01848*90\n&D       DC    Y(X'34',1,1)            DCB=BUFNO=                       01849*90\n         AGO   .DCBLOOP                                                 01850*90\n.BUFNOX  AIF   ('&C' NE 'RECFM').RECFMX                                 01851*90\n&D       DC    Y(X'49',1,1)            DCB=RECFM=                       01852*90\n         AGO   .DCBLOOP                                                 01853*90\n.RECFMX  AIF   ('&C' NE 'LRECL').LRECLX                                 01854*90\n&D       DC    Y(X'42',1,2)            DCB=LRECL=                       01855*90\n         AGO   .DCBLOOP                                                 01856*90\n.LRECLX  AIF   ('&C' NE 'DSORG').DSORGX                                 01857*90\n&D       DC    Y(X'3C',1,2)            DCB=DSORG=                       01858*92\n         AGO   .DCBLOOP                                                 01859*90\n.DSORGX  AIF   ('&C' NE 'EROPT').EROPTX                                 01860*90\n&D       DC    Y(X'3D',1,1)            DCB=EROPT=                       01861*90\n         AGO   .DCBLOOP                                                 01862*90\n.EROPTX  AIF   ('&C' NE 'LIMCT').ERRDCB                                 01863*90\n&D       DC    Y(X'41',1,3)            DCB=LIMCT=                       01864*90\n         AGO   .DCBLOOP                                                 01865*90\n.DCB7    AIF   ('&C'(1,7) NE 'KEYLEN=').DCB5                            01866*90\n&C       SETC  '&C'(8,K'&C-7)                                           01867*90\n&C       DC    Y(X'40',1,1)            DCB=KEYLEN=                      01868*90\n         AGO   .DCBLOOP                                                 01869*90\n.DCB5    AIF   ('&C'(1,5) NE 'BUFL=').DCB4                              01870*90\n&C       SETC  '&C'(6,K'&C-5)                                           01871*90\n&C       DC    Y(X'32',1,2)            DCB=BUFL=                        01872*90\n         AGO   .DCBLOOP                                                 01873*90\n.DCB4    AIF   ('&C'(4,1) NE '=').DCBREF                                01874*90\n&D       SETC  '&C'(5,K'&C-4)                                           01875*90\n&C       SETC  '&C'(1,3)                                                01876*90\n         AIF   ('&C' NE 'DEN').DCBDENX                                  01877*90\n&D       DC    Y(X'3B',1,1)            DCB=DEN=                         01878*90\n         AGO   .DCBLOOP                                                 01879*90\n.DCBDENX AIF   ('&C' NE 'NCP').ERRDCB                                   01880*90\n&D       DC    Y(X'44',1,1)            DCB=NCP=                         01881*90\n         AGO   .DCBLOOP                                                 01882*90\n.DCBREF  AIF   (&A NE 1).ERRDCB2  POSITIONAL PARAMETER                  01883*90\n         AIF   ('&C'(1,2) NE '*.').REFDSN                               01884*90\n&C       SETC  '&C'(3,K'&C-2)                                           01885*90\n&C       DC    Y(X'2D',1,8)            DCB=*. DDNAME REFERENCE          01886*90\n         AGO   .DCBLOOP                                                 01887*90\n.REFDSN  MNOTE 0,'DATASET REFERENCE ASSUMED IN DCB=&C'                  01888*90\n&C       DC    Y(X'2C',1,44)           DCB= DSNAME REFERENCE            01889*90\n         AGO   .DCBLOOP                                                 01890*90\n.DCBX    AIF   ('&SUBSYS' EQ '').SUBSYSX                                01891*92\n&C       SETC  '&SUBSYS(1)'                                             01892*92\n         AIF   ('&C' EQ '').SUB1X                                       01893*92\n&C       DC    Y(X'5F',1,4)            SUBSYS=( )                       01894*92\n.SUB1X   AIF   ('&SUBSYS(2)' EQ '').SUBSYSX                             01895*92\n&C       SETC  '&SUBSYS(2)'                                             01896*92\n&C       DC    Y(X'60',1,256)          SUBSYS=(, )                      01897*92\n.SUBSYSX ANOP                                                           01898*92\n.DDD3X   AIF   ('&SYSOUT&DEST&HOLD&COPIES&OUTLIM&FCB&UCS' EQ '').DDD4X  01899*90\n         AIF   ('&SYSOUT' EQ '').SYSOUTX                                01900*90\n         AIF   ('&SYSOUT(1)' EQ '').SYSOU1X                             01901*90\n&C       SETC  '&SYSOUT(1)'                                             01902*90\n&C       DC    Y(X'18',1,1)            SYSOUT=( )                       01903*90\n.SYSOU1X AIF   (N'&SYSOUT LE 1).SYSOUTX                                 01904*90\n&C       SETC  '&SYSOUT(2)'                                             01905*90\n         AIF   ('&C' EQ '').SYSOU2X                                     01906*90\n&C       DC    Y(X'19',1,8)            SYSOUT=(, )                      01907*90\n.SYSOU2X AIF   ('&SYSOUT(3)' EQ '').SYSOUTX                             01908*90\n&C       SETC  '&SYSOUT(3)'                                             01909*90\n&C       DC    Y(X'1A',1,4)            SYSOUT=(,, )                     01910*90\n.SYSOUTX AIF   ('&DEST' EQ '').DESTX                                    01911*90\n&DEST    DC    Y(X'58',1,7)            DEST=                            01912*92\n.DESTX   AIF   ('&HOLD' EQ '').HOLDX                                    01913*90\n&HOLD    DC    Y(X'59',0)              HOLD=YES                         01914*90\n.HOLDX   AIF   ('&COPIES' EQ '').COPIESX                                01915*90\n&COPIES  DC    Y(X'1D',1,1)            COPIES=                          01916*90\n.COPIESX AIF   ('&OUTLIM' EQ '').OUTLIMX                                01917*90\n&OUTLIM  DC    Y(X'1B',1,3)            OUTLIM=                          01918*90\n.OUTLIMX AIF   ('&FCB' EQ '').FCBX                                      01919*90\n         AIF   ('&FCB(1)' EQ '').FCB1X                                  01920*90\n&FCB(1)  DC    Y(X'25',1,4)            FCB=( )                          01921*90\n.FCB1X   AIF   ('&FCB(2)' EQ '').FCBX                                   01922*90\n&FCB(2)  DC    Y(X'26',1,1)            FCB=(, )                         01923*90\n.FCBX    AIF   ('&UCS' EQ '').UCSX                                      01924*90\n         AIF   ('&UCS(1)' EQ '').UCS1X                                  01925*90\n&UCS(1)  DC    Y(X'29',1,4)            UCS=( )                          01926*90\n.UCS1X   AIF   ('&UCS(2)' EQ '').UCS2X                                  01927*90\n&UCS(2)  DC    Y(X'2A',0)              UCS=(,FOLD)                      01928*90\n.UCS2X   AIF   ('&UCS(3)' EQ '').UCSX                                   01929*90\n&UCS(3)  DC    Y(X'2B',0)              UCS=(,,VERIFY)                   01930*90\n.UCSX    ANOP                                                           01931*90\n.DDD4X   AIF   ('&PASWORD' EQ '').PASWORX                               01932*90\n&PASWORD DC    Y(X'50',1,8)            PASWORD=                         01933*90\n.PASWORX MEXIT                                                          01934*90\n.ERRDSN  MNOTE 12,'BOTH DSN= AND DSNAME= SPECIFIED. BOTH IGNORED.'      01935*90\n         AGO   .DSNAMEX                                                 01936*90\n.ERRMEM  MNOTE 12,'INVALID DSNAME, &C'                                  01937*90\n         AGO   .DSNAMEX                                                 01938*90\n.ERRSPA2 MNOTE 8,'TOO MAY SUBPARAMETERS IN SECOND SPACE PARAMETER, &C'  01939*90\n         AGO   .SPACE2X                                                 01940*90\n.ERRDCB2 MNOTE 8,'INVALID DCB PARAMETER, &C.. IGNORING.'                01941*90\n         AGO   .DCBLOOP                                                 01942*90\n.ERRDCB  MNOTE 8,'INVALID DCB PARAMETER, &C=&D.. IGNORED.'              01943*90\n         AGO   .DCBLOOP                                                 01944*90\n         MEND                                                           01945\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FREE": {"ttr": 1539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&DDNAME  FREE  &DSN=,&DSNAME=,&DISP=,&SYSOUT=,&DEST=,&HOLD=,           *\n               &KEYADDS=,&TYPE=UNALLOC,&EXIT=ALODDERR\n         GBLA  &X,&Y,&H,&N,&R\n         GBLB  &CONCATB,&FREEB,&DDDFAIL,&DDDD\n         LCLA  &A\n         LCLC  &C,&D\n         AIF   (&DDDD).ERRDDDD\n         AIF   (&CONCATB).ERRCONC\n&X       SETA  20 DISPLACEMENT FROM ALOBLOCK TO FIRST TEXT UNIT POINTER\n&Y       SETA  20         NEGATIVE DISTANCE FROM ALOBLOCK TO FIRST DATA\n&R       SETA  14                      FIRST REGISTER LOADED\n&FREEB   SETB  1\n         AIF   ('&DDNAME&DSN&DSNAME&DISP' EQ '').DDD5X\n         AIF   ('&DDNAME' EQ 'RETURN').ERRRET\n.DDNAMEX AIF   ('&DISP(1)' NE '').ERRDIS1\n.DISP1X  AIF   ('&DISP(3)' NE '').ERRDIS3\n.DISP3X  DDD5  &DDNAME,&DSN,&DSNAME,&DISP\n.DDD5X   AIF   ('&SYSOUT&DEST&HOLD' EQ '').DDD4X\n         AIF   (N'&SYSOUT GT 1).ERRSYSO\n.SYSOUTX DDD4  &SYSOUT,&DEST,&HOLD\n         AIF   ('&HOLD' NE 'NO').DDD4X\n         DDD0  =Y(X'0A',0),,,,'HOLD=NO'\n.DDD4X   AIF   ('&KEYADDS' EQ '').KEYADDX\n&A       SETA  0\n.KEYLOOP AIF   (&A GE N'&KEYADDS).KEYADDX\n&A       SETA  &A+1\n&C       SETC  '&KEYADDS(&A)'\n         AIF   ('&C' EQ '').KEYLOOP\n         AIF   ('&C'(1,1) EQ '(').KEYADDR\n         DDD0  &C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDR DDD0  0&C,,,,'KEYADDS=&C'\n         AGO   .KEYLOOP\n.KEYADDX AIF   ('&TYPE' EQ 'EITHER' OR '&TYPE' EQ '').TYPEX\n         AIF   ('&TYPE' NE 'UNALLOC').TYPER\n.TYPEU   DDD0  =Y(X'07',0),,,,                                         *\n               'TYPE=UNALLOC  EVEN IF PERMANENTLY ALLOCATED'\n         AGO   .TYPEX\n.TYPER   AIF   ('&TYPE' NE 'REMOVE').ERRTYPE\n         DDD0  =Y(X'08',0),,,,'TYPE=REMOVE  IN-USE ATTRIBUTE'\n.TYPEX   AIF   (&R NE 14).R14X\n&X       SETA  &X-4\n         AGO   .RX\n.R14X    AIF   (&R NE 15).R15X\n         ST    14,ALOBLOCK+&X\n         AGO   .RX\n.R15X    AIF   (&R NE 0).R0X\n         STM   14,15,ALOBLOCK+&X\n&X       SETA  &X+4\n         AGO   .RX\n.R0X     STM   14,0,ALOBLOCK+&X\n&X       SETA  &X+8\n.RX      OI    ALOBLOCK+&X,X'80'        SET END OF TEXT UNIT ADDR LIST\n         LA    0,X'0220'               LOAD VERB, FLAGS1\n         AIF   ('&EXIT'(1,1) EQ '(').LREXIT\n&DDDFAIL SETB  ('&EXIT' EQ 'ALODDERR' OR &DDDFAIL)\n         LA    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n         AGO   .BALDDDD\n.LREXIT  LR    15,&EXIT                LOAD ERROR EXIT RTN ADDRESS\n.BALDDDD BAL   14,ALOROUT              LINK TO DDDD MACRO\n         AIF   (&H GE &Y).HX\n&H       SETA  &Y\n.HX      AIF   (&N GE &X).NX\n&N       SETA  &X\n.NX      MEXIT\n.ERRDDDD MNOTE 12,'FREE MAY NOT BE ISSUED AFTER DDDD'\n         MEXIT\n.ERRCONC MNOTE 12,'FREE MAY NOT BE ISSUED DURING CONCATENATION.'\n         MEXIT\n.ERRRET  MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT RETURN OF THE *\n               DDNAME.'\n         AGO   .DDNAMEX\n.ERRDIS1 MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT DISP=(&DISP(1)*\n               ).'\n         AGO   .DISP1X\n.ERRDIS3 MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT DISP=(,,&DISP(*\n               3)).'\n         AGO   .DISP3X\n.ERRSYSO MNOTE 12,'DYNAMIC UNALLOCATION DOES NOT SUPPORT SYSOUT=(,&SYSO*\n               UT(2),&SYSOUT(3)).'\n         AGO   .SYSOUTX\n.ERRTYPE MNOTE 8,'TYPE=&TYPE INVALID. TYPE IGNORED.'\n         AGO   .TYPEU\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNCHAIN": {"ttr": 1542, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    UNCHAIN &ANCHOR,&SCOPE=\n         LCLC  &C\n&C       SETC  '&ANCHOR'\n         AIF   ('&ANCHOR'(1,1) NE '(').GO\n&C       SETC  '0&ANCHOR'\n.GO      ANOP\n&NAME    LM    0,1,&C         LOAD POINTER TO OLD 1ST ELEMENT\n         LTR   1,1            IF NO ELEMENTS,\n         AIF   (T'&SCOPE EQ 'O').SCOPE1\n         AIF   ('&SCOPE' NE 'ALL').ERRSCOP\n         BZ    *+18           THEN SKIP UPDATE\n         SR    15,15          INDICATE NO ELEMENTS IN QUEUE\n         AGO   .SCOPEX\n.SCOPE1  BZ    *+20           THEN SKIP UPDATE\n         L     15,0(0,1)      OLD 2ND ELEMENT BECOMES NEW 1ST ELEMENT\n.SCOPEX  LR    14,0           CHANGE COUNT FIELD IN ORDER TO\n         BCTR  14,0           SERIALIZE WITH OTHER UNCHAINS\n         CDS   0,14,&C        POINT CHAIN TO NEW 1ST ELEMENT\n         AIF   ('&SCOPE' EQ 'ALL').ALL\n         BNE   *-18           IF CONTENTION, RETRY\n         MEXIT\n.ALL     BNE   *-16           IF CONTENTION, RETRY\n         MEXIT\n.ERRSCOP MNOTE 8,'SCOPE=&SCOPE INVALID. SCOPE IGNORED.'\n         AGO   .SCOPE1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT470/FILE470.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT470", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}