{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012226000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE503.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE503.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x16'", "DS1TRBAL": "b'\\x00\\xaa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xd2\\x00\\x01\\x03\\xd2\\x00\\x03\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\t/\\x01\\x01\\t/\\x15\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-04-02T00:00:00", "modifydate": "2001-04-02T15:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 433    FILE:  503\n\n    ORIGINAL DSNAME:  WSBG.CBT433.FILE503\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n\n   PDS117I 7 MEMBERS COUNTED; CUMULATIVE SIZE IS 517 RECORDS\n\nTIME THIS PDS WAS SHIPPED:   04/02/01    15:00:39    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INTRO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x04O\\x01\\x01\\x04O\\tG\\x00)\\x00)\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-13T00:00:00", "modifydate": "2001-02-13T09:47:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "WSBG"}, "text": "\nSubject: Member list\nDate: Tue, 13 Feb 2001 12:44 +0100\nFrom: \"ADRIAN STERN, WM-DATA        +\" <DGA.ZADST001@MEMO.POSTEN.SE>\nTo: sbgolob@attglobal.net\n\n--- Inkommet fr\u00e5n DGA.ADST001  08-781 2657          01-02-13 12.44\n  -> sbgolob(a)attglobal.net\nHi Sam\n\nSome answers:\n\n1 MbrList is for use on-line whereas MbrListB is a batch version.\n\n2 MbrList can be run interpreted, but I use it compiled and\n  linked with the CPPL/EFPL stub.\n\n3 MbrListC is the jcl for demonstrating MbrListB which must be\n  compiled and linked with the MVS stub.\n\n4 The idea behind MbrList was the recurrent need to produce very\n  quickly a list of PDS members. Altho' this can be done with the\n  library routines they require both ISPF and TSO, MbrList works\n  in native MVS.\n\n  As it happens I use it almost exclusively on-line as I am\n  developing a Windows-like interface in ISPF. As I said earlier,\n  the batch version is just to demonstrate that neither TSO nor\n  ISPF services are required.\n\n5 The output can be stacked (option not null) or written to a\n  sequential dataset (option is null) called prefix.MEMBER.LIST.\n\n6 The copyright notice is only there in case somebody else tries\n  to make money from the code. The programs may be copied and\n  distributed freely but not by way of trade. I hope that's okay!\n\n\nRegards\nAdrian\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x04\\x9f\\x01\\x01\\x04\\x9f\\x08B\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-02-18T00:00:00", "modifydate": "2001-02-18T08:42:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "WSBG"}, "text": "Subject: Re: Member list\nDate: Fri, 16 Feb 2001 17:16 +0100\nFrom: \"ADRIAN STERN, WM-DATA +\" <DGA.ZADST001@MEMO.POSTEN.SE>\nTo: sbgolob@attglobal.net\n\n--- Inkommet fr\u00e5n DGA.ADST001  08-781 2657          01-02-16 17.16\n  -> sbgolob(a)attglobal.net\nFrom: sbgolob@attglobal.net\nHi Sam,\n\n1  I don't have any JCL as I use an on-line routine to compile execs.\n   There are so many possible combinations etc it was too messy having\n   to edit jcl. And why not compile on-line?\n   However I'm sure I could produce some specifically for these programs\n   if required.\n\n2  To run the jcl:\n\n   (a) replace \"yourHlq.SPF.LOAD\" with the name of your load module\n       library.\n\n   (b) replace \"pds to be listed\" with the name of the pds for which\n       you require a member list.\n\n   (c) add a jobcard.\n\n   (d) submit for execution.\n\nRegards\nAdrian\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE503": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x02_\\x01\\x01\\x04O\\x11R\\x00\\t\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2001-02-13T11:52:00", "lines": 9, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 503 is from Adrian Stern and contains two REXX execs      *   FILE 503\n//*           that run under Native TSO, to produce a partitioned   *   FILE 503\n//*           dataset member list, very quickly.                    *   FILE 503\n//*                                                                 *   FILE 503\n//*           With this file, the result is important, but the      *   FILE 503\n//*           method of obtaining the result is as important.       *   FILE 503\n//*                                                                 *   FILE 503\n//*           email:  DGA.ZADST001@MEMO.POSTEN.SE                   *   FILE 503\n//*                                                                 *   FILE 503\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MBRLIST": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x105\\x00\\xd3\\x00\\xd3\\x00\\x00\\xc1\\xc4\\xe2\\xe3\\xf0\\xf0\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T10:35:00", "lines": 211, "newlines": 211, "modlines": 0, "user": "ADST001"}, "text": "/*- MBRLIST, a Rexx proc to list the member names in a PDS\n    The results are written to a dataset MEMBER.LIST\n    Can be called with with a stack (FIFO/LIFO) parameter\n    which causes the result to be placed in the program stack\n    instead.\n    (c) 2000-02-24 - Adrian Stern - ADST001 at MVSF\n     -*/\nTRACE (\"Normal\")\nAddress \"TSO\"\nExecName =\"MBRLIST\"\nTrue     = 1\nFalse    = 0\n\narg Arguments\nparse value Arguments with InputDataset MemberPattern \"(\" Option\nOption        = strip(Option)\nMemberPattern = strip(MemberPattern)\n\n/* allocate dataset with directory attributes */\n\"ALLOCATE FILE(INPUT) DSN(\"InputDataset\") SHR REUSE\",\n\"DSORG(PS) RECFM(F) BLKSIZE(256) LRECL(256)\"\n/* read the directory */\nMemberCount  = 0\nMemberStack. =\"\"\nDo forever\n    Execio 1 diskr input\n    if Rc<>0 then leave\n\n    parse pull line\n    Call HandleLine\n    if Result>1 then leave\nEnd\nCall Exit ( 0 )\n/*------------------------------( end )-------------------------------*/\nHandleLine:\nblock = c2x(substr(line,1,2))            /* get block length (hex)    */\nblock = x2d(block)                       /* make it decimal           */\nline = substr(line,3)                    /* drop block length         */\nblock = block - 2                        /* decrease remaining block  */\nDo forever\n    Call ExamineBlocks\n    if Result <> 0 then leave\nEnd\nReturn ( Result )\n/*------------------------------( end )-------------------------------*/\nExamineBlocks:\n/* test for end of block */\nif block < 1 then Return ( 1 )\n\nMemberName = substr(line,1,8)           /* pick off member MemberName */\n/* test for last entry mark   */\nif MemberName = 'FFFFFFFFFFFFFFFF'x then Return ( 4 )\n\nMemberCount            = MemberCount + 1\nMemberStack.0          = MemberCount\nMemberStack.MemberCount= strip(MemberName)\n\nline  = substr(line,12)                 /* drop name and ttr         */\nblock = block - 11                      /* decrease remaining block  */\nlen   = c2x(substr(line,1,1))           /* get user data length (hex)*/\nlen   = x2d(len) // 32 + 1              /* make it decimal           */\nlen   = len * 2                         /* allow for half word count */\nline  = substr(line,len)                /* and drop user data        */\nblock = block - len + 1                 /* decrease remaining block  */\nReturn ( 0 )\n/*----------------------------( end )--------------------------------*/\nExit:\nArg  Return_code\nExecio 0 diskr input \"(finis\"\n\"FREE     FILE(INPUT)\"\nif   Return_code<>0 then Exit Return_code\n\nif MemberCount < 1\nthen\n    Do\n/* ISRU212 The PDS specified contains no members.  */\n        eMsg=\"The PDS specified contains no members.\"\n        if Option = \"\" then say   eMsg\n                       else queue eMsg\n        Exit ( 8 )\n    End\n/* now try and match the pattern argument */\nSelect\n    when         MemberPattern =\"*\" then nop\n    when         MemberPattern =\" \" then nop\n    when         MemberPattern =\"\"  then nop\n    when Pos(\"%\",MemberPattern)>0   then Call ListFromMember\n    otherwise                            Call MatchMemberPattern\nEnd\n\nif MemberCount < 1\nthen\n    Do\n/* ISRM018 The specified pattern produced no matching members.  */\n        eMsg=\"The specified pattern produced no matching members.\"\n        if Option = \"\" then say   eMsg\n                       else queue eMsg\n        Exit ( 8 )\n    End\n\nSelect\n    when Option = \"\"\n    then Call WriteToDataset\n    when Option = \"STACK\",\n    |    Option = \"FIFO\"\n    then\n        Do i=1 to MemberStack.0\n            queue MemberStack.i\n        End\n    when Option = \"LIFO\"\n    then\n        Do i=1 to MemberStack.0\n            push  MemberStack.i\n        End\n    otherwise nop\nEnd\n\nExit Return_code\n/*------------------------------( end )-------------------------------*/\nWriteToDataset:\nx=msg(\"Off\")\n\"DELETE\"                     MEMBER.LIST\nx=msg(\"On\" )\n\"ALLOCATE FILE($MEMBER$) DSN(MEMBER.LIST) NEW REUSE\"\nExecio MemberStack.0 \"DISKW $MEMBER$ (FINIS STEM MemberStack.\"\n\"FREE     FILE($MEMBER$)\"\nsay MemberStack.0 \"Member names written to dataset '\",\n|| userid()\".MEMBER.LIST'.\"\nReturn\n/*------------------------------( end )-------------------------------*/\nListFromMember:\nSearchPattern=substr(MemberPattern,1,Pos(\"%\",MemberPattern)-1)\n/* extract the members that match */\nTempStack.   =\"\"\nj            =0\nDo i=1 to MemberStack.0\n\n    if     MemberStack.i >= SearchPattern\n    then\n        Do\n                      j = j+1\n            TempStack.0 = j\n            TempStack.j = MemberStack.i\n        End\nEnd\nCall CopyStack\nReturn\n/*------------------------------( end )-------------------------------*/\nMatchMemberPattern:\n/* determine position of asterisks */\nPreAsterix =False\nif     pos(\"*\",MemberPattern) = 1\nthen PreAsterix =True\n\nPostAsterix=False\nif lastpos(\"*\",MemberPattern) = length(MemberPattern)\nthen PostAsterix=True\n\nSearchPattern=strip(MemberPattern,Both,\"*\")\n/* create dynamic code */\nSelect\n    when  PostAsterix,\n    &     PreAsterix  then PosRequired= \">0\"\n    when \u00acPostAsterix,\n    &    \u00acPreAsterix  then PosRequired= \"=1\"\n    when  PostAsterix then PosRequired= \"=1\"\n    when  PreAsterix  then PosRequired= \"=(length(MemberStack.i)-\",\n                                          \"length(SearchPattern))+1\"\n    otherwise nop\nEnd\n/* say 'SearchPattern' SearchPattern , */\n/*    'PosRequired' PosRequired */\n/* extract the members that match */\nTempStack.   =\"\"\nj            =0\nDo i=1 to MemberStack.0\n    PatternMatched=False\n/*  don't even bother to examine member names\n    shorter than the pattern entered */\n    if length(MemberStack.i)<length(SearchPattern) then iterate\n\n/*  sorry, but dynamic code is the only solution */\n    DynaCode=\"if pos(SearchPattern,MemberStack.i)\",\n    PosRequired \"then PatternMatched=True\"\n    interpret DynaCode\n    if   PatternMatched\n    then\n        Do\n                      j = j+1\n            TempStack.0 = j\n            TempStack.j = MemberStack.i\n        End\nEnd\nCall CopyStack\nReturn\n/*------------------------------( end )-------------------------------*/\nCopyStack:\n/* overwrite the original stack\n   but don't bother if no matches found */\n   MemberCount = TempStack.0\nif MemberCount < 1 then Return\n\n/* ok, now overwrite the original stack */\nMemberStack.=\"\"\nj           =0\nDo i=1 to TempStack.0\n                j = j+1\n    MemberStack.0 = j\n    MemberStack.j = TempStack.i\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MBRLISTB": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x105\\x00\\xcb\\x00\\xcb\\x00\\x00\\xc1\\xc4\\xe2\\xe3\\xf0\\xf0\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T10:35:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "ADST001"}, "text": "/*- MBRLIST, a Rexx proc to list the member names in a PDS\n    The results are written to a dataset MEMBER.LIST\n    Can be called with with a stack (FIFO/LIFO) parameter\n    which causes the result to be placed in the program stack\n    instead.\n    (c) 2000-02-24 - Adrian Stern - ADST001 at MVSF\n     -*/\nTRACE (\"Normal\")\nAddress \"MVS\"\nExecName =\"MBRLISTB\"\nTrue     = 1\nFalse    = 0\n\narg Arguments\nparse value Arguments with MemberPattern \"(\" Option\nOption        = strip(Option)\nMemberPattern = strip(MemberPattern)\n\n\"DSORG(PS) RECFM(F) BLKSIZE(256) LRECL(256)\"\n/* read the vtoc */\nMemberCount  = 0\nMemberStack. =\"\"\nDo forever\n    Execio 1 diskr input\n    if Rc<>0 then leave\n\n    parse pull line\n    Call HandleLine\n    if Result>1 then leave\nEnd\nCall Exit ( 0 )\n/*------------------------------( end )-------------------------------*/\nHandleLine:\nblock = c2x(substr(line,1,2))            /* get block length (hex)    */\nblock = x2d(block)                       /* make it decimal           */\nline = substr(line,3)                    /* drop block length         */\nblock = block - 2                        /* decrease remaining block  */\nDo forever\n    Call ExamineBlocks\n    if Result <> 0 then leave\nEnd\nReturn ( Result )\n/*------------------------------( end )-------------------------------*/\nExamineBlocks:\n/* test for end of block */\nif block < 1 then Return ( 1 )\n\nMemberName = substr(line,1,8)           /* pick off member MemberName */\n/* test for last entry mark   */\nif MemberName = 'FFFFFFFFFFFFFFFF'x then Return ( 4 )\n\nMemberCount            = MemberCount + 1\nMemberStack.0          = MemberCount\nMemberStack.MemberCount= strip(MemberName)\n\nline  = substr(line,12)                 /* drop name and ttr         */\nblock = block - 11                      /* decrease remaining block  */\nlen   = c2x(substr(line,1,1))           /* get user data length (hex)*/\nlen   = x2d(len) // 32 + 1              /* make it decimal           */\nlen   = len * 2                         /* allow for half word count */\nline  = substr(line,len)                /* and drop user data        */\nblock = block - len + 1                 /* decrease remaining block  */\nReturn ( 0 )\n/*----------------------------( end )--------------------------------*/\nExit:\nArg  Return_code\nExecio 0 diskr input \"(finis\"\nif   Return_code<>0 then Exit Return_code\n\nif MemberCount < 1\nthen\n    Do\n/* ISRU212 The PDS specified contains no members.  */\n        eMsg=\"The PDS specified contains no members.\"\n        if Option = \"\" then say   eMsg\n                       else queue eMsg\n        Exit ( 8 )\n    End\n/* now try and match the pattern argument */\nSelect\n    when         MemberPattern =\"*\" then nop\n    when         MemberPattern =\" \" then nop\n    when         MemberPattern =\"\"  then nop\n    when Pos(\"%\",MemberPattern)>0   then Call ListFromMember\n    otherwise                            Call MatchMemberPattern\nEnd\n\nif MemberCount < 1\nthen\n    Do\n/* ISRM018 The specified pattern produced no matching members.  */\n        eMsg=\"The specified pattern produced no matching members.\"\n        if Option = \"\" then say   eMsg\n                       else queue eMsg\n        Exit ( 8 )\n    End\n\nSelect\n    when Option = \"\"\n    then Call WriteToDataset\n    when Option = \"STACK\",\n    |    Option = \"FIFO\"\n    then\n        Do i=1 to MemberStack.0\n            queue MemberStack.i\n        End\n    when Option = \"LIFO\"\n    then\n        Do i=1 to MemberStack.0\n            push  MemberStack.i\n        End\n    otherwise nop\nEnd\n\nExit Return_code\n/*------------------------------( end )-------------------------------*/\nWriteToDataset:\nExecio MemberStack.0 \"DISKW MEMBERS (FINIS STEM MemberStack.\"\nsay MemberStack.0 \"Member names written to dataset '\",\n|| userid()\".MEMBER.LIST'.\"\nReturn\n/*------------------------------( end )-------------------------------*/\nListFromMember:\nSearchPattern=substr(MemberPattern,1,Pos(\"%\",MemberPattern)-1)\n/* extract the members that match */\nTempStack.   =\"\"\nj            =0\nDo i=1 to MemberStack.0\n\n    if     MemberStack.i >= SearchPattern\n    then\n        Do\n                      j = j+1\n            TempStack.0 = j\n            TempStack.j = MemberStack.i\n        End\nEnd\nCall CopyStack\nReturn\n/*------------------------------( end )-------------------------------*/\nMatchMemberPattern:\n/* determine position of asterisks */\nPreAsterix =False\nif     pos(\"*\",MemberPattern) = 1\nthen PreAsterix =True\n\nPostAsterix=False\nif lastpos(\"*\",MemberPattern) = length(MemberPattern)\nthen PostAsterix=True\n\nSearchPattern=strip(MemberPattern,Both,\"*\")\n/* create dynamic code */\nSelect\n    when  PostAsterix,\n    &     PreAsterix  then PosRequired= \">0\"\n    when \u00acPostAsterix,\n    &    \u00acPreAsterix  then PosRequired= \"=1\"\n    when  PostAsterix then PosRequired= \"=1\"\n    when  PreAsterix  then PosRequired= \"=(length(MemberStack.i)-\",\n                                          \"length(SearchPattern))+1\"\n    otherwise nop\nEnd\n/* say 'SearchPattern' SearchPattern , */\n/*    'PosRequired' PosRequired */\n/* extract the members that match */\nTempStack.   =\"\"\nj            =0\nDo i=1 to MemberStack.0\n    PatternMatched=False\n/*  don't even bother to examine member names\n    shorter than the pattern entered */\n    if length(MemberStack.i)<length(SearchPattern) then iterate\n\n/*  sorry, but dynamic code is the only solution */\n    DynaCode=\"if pos(SearchPattern,MemberStack.i)\",\n    PosRequired \"then PatternMatched=True\"\n    interpret DynaCode\n    if   PatternMatched\n    then\n        Do\n                      j = j+1\n            TempStack.0 = j\n            TempStack.j = MemberStack.i\n        End\nEnd\nCall CopyStack\nReturn\n/*------------------------------( end )-------------------------------*/\nCopyStack:\n/* overwrite the original stack\n   but don't bother if no matches found */\n   MemberCount = TempStack.0\nif MemberCount < 1 then Return\n\n/* ok, now overwrite the original stack */\nMemberStack.=\"\"\nj           =0\nDo i=1 to TempStack.0\n                j = j+1\n    MemberStack.0 = j\n    MemberStack.j = TempStack.i\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MBRLISTC": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x183\\x00\\n\\x00\\n\\x00\\n\\xc1\\xc4\\xe2\\xe3\\xf0\\xf0\\xf1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T18:33:00", "lines": 10, "newlines": 10, "modlines": 10, "user": "ADST001"}, "text": "//MBRLISTB EXEC PGM=MBRLISTB,\n//             PARM=('*')\n//STEPLIB  DD  DISP=SHR,\n//             DSN=yourHlq.SPF.LOAD\n//INPUT    DD  DCB=(BLKSIZE=256,DSORG=PS,LRECL=256,RECFM=F), do not\n//             DISP=SHR,                                     change|\n//             DSN=pds to be listed\n//MEMBERS  DD  SYSOUT=*\n//SYSTSPRT DD  SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT503/FILE503.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT503", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}