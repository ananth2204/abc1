{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011623000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE268.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE268.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x03'", "DS1TRBAL": "b'\\xbb\\xaa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xdf\\x00\\x01\\x01\\xdf\\x00\\n\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x008\\x01\\x10\\x18?\\x01\\x10\\x18?\\x19I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-07-02T00:00:00", "modifydate": "2010-07-02T19:49:38", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  268\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE268\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,263 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/02/10    19:49:38    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00P\\x00\\x98$\\x8f\\x01\\x10\\x18/\\x14\\t\\x01H\\x01\\x1d\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1998-09-05T00:00:00", "modifydate": "2010-07-01T14:09:50", "lines": 328, "newlines": 285, "modlines": 0, "user": "PFARLEY"}, "text": "RXVSAM\n\nMark Winges           (Original implementation up to V2.2)\n415-752-8291\nwingnotes@att.net\n\nPeter J. Farley III   (V2.3 updates)\npjfarley3@yahoo.com\n\nRXVSAM is a REXX function to access VSAM files in an MVS, TSO or\nISPF environment.  You can access VSAM ESDS, KSDS or RRDS files\nusing RXVSAM, and its syntax is like any other REXX function.\nRXVSAM consists of two assembler CSECTS, supplied in source code\nformat.\n\nInstallation test scripts are provided in Rexx:\n\n        RXVSET   will delete and allocate three files, USERID.VSAMESDS,\n                 USERID.VSAMRRDS and USERID.VSAMKSDS (where USERID is\n                 is your userid). \"RXVSET userid\" will use the supplied\n                 userid instead.\n                 RXVSET will interactively ask for the allocation\n                 method to be used ((S)torclas or (V)olume) and the\n                 value of that method to use for allocating the files.\n                 Running RXVSET in batch will cause it to use the\n                 STORCLAS (if available) or VOLUME of the SYSEXEC DD\n                 (or more specifically, the STORCLAS or VOLUME of the\n                 DDName returned in the fourth word of PARSE SOURCE).\n        RXVTESTE tests ESDS functions using the USERID.VSAMESDS file.\n                 Also accepts a \"userid\" argument that must match the\n                 one used to execute RXVSET.\n        RXVTESTR tests RRDS functions using the USERID.VSAMRRDS file.\n                 Also accepts a \"userid\" argument that must match the\n                 one used to execute RXVSET.\n        RXVTESTK tests KSDS functions using the USERID.VSAMKSDS file.\n                 Also accepts a \"userid\" argument that must match the\n                 one used to execute RXVSET.\n\nModel JCL for assembling and linking RXVSAM is provided in member\nASMRXVS.  Model JCL for executing the test scripts in batch is provided\nin member RUNTESTS.  These model JCL members must be changed to match\nyour installation environment, and will not execute as provided.\n\nSyntax\n\nAll calls to the RXVSAM function take the form:\n        RXVSAM(request,ddname,key/filetype,recordarea)\n\nThe first two arguments are always required, arguments 3 and 4 are\nsometimes optional.  Argument definitions:\n\n        request - what you want to do, for example:  read a record,\n                begin browsing a file in a forward direction, and so\n                on.\n        ddname - the MVS ddname for the VSAM file that contains your\n                data.  The ddname may come from an allocate\n                statement when in TSO or ISPF, or a ddname in your\n                JCL if you are running your REXX program in batch.\n        key / filetype - the key or relative record number or relative\n                byte address (key/RRN/RBA) for your data or the type\n                of VSAM file (ESDS, KSDS or RRDS).  The filetype\n                indication is only required for OPEN-type requests.\n                For other requests, you will usually indicate a key.\n                For some requests, this argument may be omitted, and\n                its absence should be indicated by a comma when the\n                next argument is present (see below for more\n                information).\n                NOTE: RBA for any record beyond the first control\n                interval will require adding the CI control information\n                length.  This is left as an exercise for the user,\n                and no example of such a calculation is provided.\n        recordarea - the REXX variable name that contains your data.\n                You can omit this argument too, and RXVSAM will use\n                the default variable name RXVSAM_RECORD.\n\nRequest Values\n\nThere are 5 types of requests:  opens, closes, reads, writes and\nstarts.  The values for request may be coded as a literal (within\nquotes) or as a REXX variable set to the  desired request value.\nThe request, whether it is a REXX variable or a literal, must be in\nuppercase, coded exactly as shown below:\n\n                OPENINPUT OPENOUTPUT OPENIO\n                CLOSE\n                READ READGENERIC READNEXT READPREV READLAST\n                WRITE REWRITE DELETE\n                STARTFWD STARTBWD\n\nThe above values are self-explanatory, mirroring the actions you\nwould perform from a COBOL program, or in a CICS EXEC\nstatement.  There are the usual restrictions:  you must read a record\nbefore attempting to rewrite or delete it, you must have established\npositioning within a file using STARTFWD (for reading forward in a\nfile) or STARTBWD (for reading backward in a file) before a READNEXT\nor READPREV request, you must have a file open for input (or I/O) if\nyou are going to read records, and you must have a file open for\noutput (or I/O) if you are going to write records.\n\nDDNAME Values\n\nThere are no restrictions on the ddname other than those imposed by\nMVS.  It must be 1 to 8 uppercase or national characters.  If you\nare executing in a TSO or ISPF session, the file must be allocated\nprior to any RXVSAM calls.  If you are executing in batch, the\nddname must be present in your JCL.\n\nKey / Filetype Values\n\nFiletype must be in uppercase.  Indicate either 'ESDS', 'KSDS', or\n'RRDS' depending on the type of your VSAM file.  Filetype is only\nvalid with one of the open requests.  For other requests you will\nmost often code a key.  This key may be either a REXX variable or a\nliteral.  For RRN datasets, code the key as a normal REXX numeric\n(for example '24' to read record number 24).  For keys that contain\npacked decimal data, you must construct the components of the key\ncarefully.  REXX does not recognize packed decimal (other than as a\nstring of characters), and you may need to \"build\" your key using a\ncombination of hexadecimal and character literals.\n\nThe key should be null for the following cases:\n        READNEXT, READPREV and READLAST requests\n        Writing sequentially to an RRDS for the first time\n            (initialization)\n        Writing to an ESDS\nNote that direct reads on an ESDS are possible, using the RBA as the\n\"key\".  This is given in decimal just as a \"key\" for an RRDS.\nHowever, if your RBA is not an address that is on a record boundry,\nyou will get an error.\n\nRecordarea Values\n\nThis is the name of the variable that contains record data.  It is\nimportant to note that this is the NAME of the variable. Most often,\nthis will be a literal.  If you code a variable, its value will be\nthe name used as the record area.  Of course, since an uninitialized\nREXX variable's value is the uppercase version of the variable name,\nif you accidently omit the surrounding quotes when you mean to use a\nliteral, you may get the desired result.  This is not clear REXX\ncoding, however.\n\nIf you omit this argument, RXVSAM will use a default name of\nRXVSAM_RECORD.  For simple programs that read / write only one file,\nit might be easier to use this default.\n\nExamples:\nThe following example will open a KSDS file, perform a direct read\non a record with a key of \"AAA001\", then close the file.\n\n        rxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')\n        IF rxvsam_result \\= 0 THEN SAY 'Open Failed'\n        keyaaaa = 'AAA001'          /* set value of key data */\n        rxvsam_result = RXVSAM('READ','VSAMFILE','KEYAAAA','MY_REC')\n        IF rxvsam_result \\= 0 THEN SAY 'Read Failed'\n        ELSE SAY 'The record is:' my_rec\n        rxvsam_result = RXVSAM('CLOSE','VSAMFILE')\n\n\nThe following example will open an RRDS file, and write two records\nto it.\n\n        rxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','RRDS')\n        IF rxvsam_result \\= 0 THEN SAY 'Open Failed'\n        my_rec = 'AAAAAAAAAAAAAAAAAAAA'\n        rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\n        IF rxvsam_result \\= 0 THEN SAY 'First write Failed'\n        my_rec = 'BBBBBBBBBBBBBBBBBBBB'\n        rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\n        IF rxvsam_result \\= 0 THEN SAY 'Second write Failed'\n        rxvsam_result = RXVSAM('CLOSE','VSAMFILE')\n\nError Messages\n\nRXVSAM always returns a result, which is a decimal number.  In\naddition, it sets the REXX variable RXVSAM_RETURNMSG with an\nexplanatory text.  All messages are in the form:  nnnns \"text\" where\nnnnn is the message number, s is the severity level (I -\ninformation, W - warning, E - error), and  text is a short\nexplanation of the problem.  In some cases, VSAM raised a condition\nthat RXVSAM is not prepared to handle (this may indicate a problem\nwith RXVSAM).  In that case, an additional variable,\nRXVSAM_VSAMERRORMSG is set with the return and reason codes from\nVSAM, and the location (label) in RXVSAM where the error occurred.\n\nFollowing is a list of all messages:\n\n0000I Request successfully processed\n        no further action necessary\n\n0001E Invalid argument passed\n        a keyword or request is probably misspelled\n\n0002E Open failed\n        RXVSAM could not generate an ACB - check RXVSAM_VSAMERRORMSG\n        for a return code from VSAM and check to see the DDNAME is\n        correct\n\n0003E Close failed\n        check RXVSAM_VSAMERRORMSG for the VSAM return code and check\n        to see the DDNAME is correct\n\n0004W End of File\n        perform end of file logic in your REXX program\n\n0005E File is already open\n        A previous OPEN was done for this DDNAME - ensure the DDNAME\n        is correct\n\n0007E REXX record variable could not be accessed or was undefined\n        This error can occur on a WRITE or REWRITE request and\n        usually indicates the variable that contains record data is\n        an undefined variable.\n\n0008E Duplicate record\n        VSAM indicates this is a duplicate record\n\n0010E Unable to save VSAM error data\n        This is an internal RXVSAM error\n\n0011E Unable to set return message text\n        This is an internal RXVSAM error\n\n0012E ACB was not available to perform CLOSE request - file may not\n        be open. No ACB could be found for the DDNAME you specified -\n        ensure the DDNAME is for the correct file, and that the file\n        has been opened\n\n0014E ACB was not available to perform request - file may not be\n        open. No ACB could be found for the DDNAME you specified -\n        ensure the DDNAME is for  the correct file, and that the\n        file has been opened\n\n0015E Unable to obtain max record length for this file\n        This is probably an internal RXVSAM error (a SHOWCB macro\n        failed), check RXVSAM_VSAMERRORMSG for the VSAM return code\n\n0016W Record not found\n        Perform not found logic in your REXX program\n\n0016E Record not found - a FULL KEY must be specified when issuing a\n        STARTBWD request.  For STARTBWD only: if you specified a full\n        key, perform not found logic in your REXX program.  You\n        cannot specify a partial (generic) key for a STARTBWD\n        request.\n\n0017E Cannot determine length of record\n        This is probably an internal RXVSAM error (a SHOWCB macro\n        failed), check RXVSAM_VSAMERRORMSG for the VSAM return code\n\n0018E Unable to modify RPL for \"UPDate\"\n        This is probably an internal RXVSAM error (a MODCB macro\n        failed), check RXVSAM_VSAMERRORMSG for the VSAM return code\n\n0019E Function failed\n        This is probably an internal RXVSAM error,\n        RXVSAM_VSAMERRORMSG may give additional information\n\n0020E Unable to update RECORD variable\n        This may indicate a storage constraint if you are running in\n        a TSO or ISPF session, or an internal error in RXVSAM\n\n0021E File is not open for INPUT\n        You are trying to perform a READ function, but the file is\n        only open for output\n\n0022E File is not open for OUTPUT\n        You are trying to perform a WRITE, REWRITE or DELETE\n        function, but the file is only open for input\n\n0023E Unable to switch to DIR processing\n        This is probably an internal RXVSAM error,\n        RXVSAM_VSAMERRORMSG may give additional information\n\n0024E READGENERIC only allowed for KSDS\n        You are attempting a READGENERIC function on an ESDS or RRDS\n\n0025E Non-numeric key specified for an RRDS\n        The key you passed for an RRDS is not numeric.  If you are\n        passing a REXX variable, ensure the variable contains a\n        valid numeric string, and not a binary or packed number\n\n0026E This function is not allowed for an ESDS\n        DELETE is not allowed for an ESDS\n\n0088E READPREV attempted without a previous STARTBWD\n        You must first issue a STARTBWD for positioning before\n        READPREV request\n\n0092E REWRITE or DELETE attempted without a previous READ\n        You must first read a record before attempting to rewrite or\n        delete it\n\n0108E Record length = 0, > max, < key length (KSDS) or not equal to\n        slot size (fixed length RRDS). This is a catchall record\n        length error.  For a KSDS, a record must be at least the\n        size of the key, and may not be greater than the maximum\n        record size defined for the file when it was created.  For a\n        fixed-length RRDS, all records must be equal to the record\n        slot size.  In all cases, ensure the record variable you\n        pass RXVSAM is not set to a null string as this will be a\n        \"zero length\" record.\n\n\nInstallation\n\nRXVSAM consists of two CSECTs: RXVSAM and RXVSAMSG.  RXVSAM contains\nexecutable code, and RXVSAMSG contains texts for error messages.  A\nVCON in RXVSAM points to RXVSAMSG, so the two CSECTs should be\nlink-edited together as one load module.  Total module size is a\nlittle over 10K (29C8).  RXVSAM is reentrant, and runs in 31-bit\nmode (AMODE=31, RMODE=ANY).\n\nIn addition to the VSAM and REXX macros, name / token services and a\nfew \"standard\" MVS control block macros are used in RXVSAM.  These\nmacros are found in SYS1.MACLIB in most installations.  Primary\ntesting was done using HLASM 5696-234, release 2.0.  Release 2.3\ntesting was done using HLASM 5696-234, release 6.0.\n\nTo install, assemble the CSECTs and link.  TSO/ISPF users: make sure\nthe load library into which RXVSAM is linked is either a common one\nin the link list, or specifically allocated via the ISPLLIB dd in\nyour TSO session.  Similarly, for batch users, RXVSAM must be in one\nof the link list libraries, or allocated via a JOBLIB or STEPLIB\ncard.\n\nModel assemble and link JCL is provided in member ASMRXVS.\nModel installation test JCL is provided in member RUNTESTS.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE22": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x01\\x01\\x02\\x11o\\x01\\x03\\x05_\\tU\\x00\"\\x00\"\\x00\\x00\\xd4\\xe6\\xc9\\xd5\\xc7\\xc5\\xe2@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "2002-04-26T00:00:00", "modifydate": "2003-02-24T09:55:01", "lines": 34, "newlines": 34, "modlines": 0, "user": "MWINGES"}, "text": "Subject: Re: RXVSAM\nDate: Thu, 25 Apr 2002 13:20:08 -0700\nFrom: LynMark <WingNotes@earthlink.net>\nTo: Sam Golob <sbgolob@attglobal.net>\n\nThanks a lot Sam. Attached are two files, a very small\ninstallation instruction file and the source itself. I've rolled\ntwo separate CSECTS into one, which I think is easier. Earlier\nversions had the two CSECTS as separate files, which were to be\ncombined at link time. There are the improvements that Rob Van\nRiel made and a few minor changes that I've made subsequent to\nhis.\n\nAs I said, I don't have mainframe access (or Hercules / MVS)\nright now, so it's straight ASCII text. I don't think it has any\nfunky characters that would cause a problem if uploaded straight\nfrom a PC.  Sorry to cause you more work.\n\nAnd thanks for all your efforts in the CBT. It's a great\n'project' [for lack of a better word]\n\nMark Winges\nWingNotes@earthlink.net\n\n    ---------------------------------------------------------------------\n\n   Install_2.2.txtName: Install_2.2.txt\n                  Type: Plain Text (text/plain)\n\n   Rxvsam22.asmName: Rxvsam22.asm\n               Type: Plain Text (text/plain)\n\n    ---------------------------------------------------------------------\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE3": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x01\\x10\\x18/\\x01\\x10\\x18?\\x13\\x00\\x00\\x1a\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-07-01T00:00:00", "modifydate": "2010-07-02T13:00:06", "lines": 26, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  New version of file 268\nFrom:     \"Peter Farley\" <pjfarley3@yahoo.com>\nDate:     Thu, 1 Jul 2010 14:31:56 -0400\nTo:       <sbgolob@cbttape.org>\n\nHi Sam,\n\nAttached is a zip of a new version 2.3 of file 268 (RXVSAM, Rexx\naccess to VSAM files).  I have sent a copy to Mark Winges, the\noriginal author, and he told me to send the new version to you\ndirectly.\n\nThere are a number of updates, documented in the new member\n$CHNGLOG.  The $$DOC file has also been updated to reflect the\nchanges.\n\nThe new file expands to this pds.\nFormat is FB/80/27960.\n\nPlease let me know if there is anything else I need to change or\ndo for this submission.\n\nRegards,\n\nPeter Farley\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHNGLOG": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x10\\x18/\\x01\\x10\\x18/\\x13$\\x003\\x002\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-01T00:00:00", "modifydate": "2010-07-01T13:24:13", "lines": 51, "newlines": 50, "modlines": 0, "user": "PFARLEY"}, "text": "Changelog for RXVSAM\n\n2.1 -- add DELETE macros for routines that have been LOADed\n(IRXEXCOM and various name / token routines).\n\n2.2 -- locate IEANTxx services by bumping through storage rather\nthan doing a LOAD. Remove associated DELETEs. Add RXVSAMSG CSECT\nat end of this assembly; revise GENMSGS macro. Get IRXEXCOM address\nby bumping thru ENVBLOCK (environemnt block) to IRXEXTE (external\naddress table), rather than doing a LOAD. Remove associated DELETE.\nAdd required ENVBLOCK & IRXEXTE macros (dsects). Allow rewrite for\nan ESDS. (Special thanks to Rob Van Riel for these changes)\n\n2.3 -- Convert to baseless programming (J not B, JNE not BNE,\netc.).  Added SYSTATE ARCHLVL=2 and COPY IEABRC and\nCALL ...,LINKINST=BASR in support of baseless structure.\nR12 now points to label CONSTANT for LTORG and true constants,\nR11 and R10 are no longer used for any purpose.\nExecuted instructions moved to CONSTANT section for\naddressibility.   Hardware pipeline delays may result from this\ndue to executed instruction not being in the instruction cache.\nNow allows both STARTFWD and STARTBWD for ESDS files.\nHLASM system variable &SYSDATC used instead of &SYSDATE for\neyecatcher constant.\nLA and ST instructions using explicit displ(indexreg) for their\nsecond argument changed to use displ(,basereg) format to avoid\nunnecessary index register activity.\nSAVE macro added with eyecatcher string to both preserve the\nsavearea chain and to use standard eyecatcher placement for\nmodule identification.  BAKR and PR are still used to perform\nentry and exit from module.\nCorrected roundup of record length to next doubleword at label\nOPEN310.\nIHASTCB macro used to map STCB instead of hard-coded definition.\nIFGACB and IFGRPL macros added for ACB and RPL mapping.\n\nAll 2.3 changed lines are marked with the string \"@PJF\" on the right.\n\nChangelog for Other Members\n\nCreated change log (this member).\nSupplied model assemble and link JCL (ASMRXVS) and model test JCL\n(RUNTESTS).\nUpdated RXVSET EXEC to allocate by either SMS STORCLAS or VOLUME\nand take defaults from SYSEXEC in batch (no interactive questions).\nUpdated RXVTEST? test EXEC's to default to displaying all log\nmessages in batch.\nUpdated all EXEC's to exit with RC=16 for IRXJCL execution or for\nexecution in an OpenMVS shell because TSO ALLOC is not supported\nin those environments.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NOTEINS": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x17\\x01\\x02\\x11o\\x01\\x03\\x05_\\tU\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd4\\xe6\\xc9\\xd5\\xc7\\xc5\\xe2@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "2002-04-26T00:00:00", "modifydate": "2003-02-24T09:55:17", "lines": 31, "newlines": 31, "modlines": 0, "user": "MWINGES"}, "text": "RXVSAM is the main CSECT. RXVSAMSG, which contains error message\ntexts, is a separate CSECT. Both CSECTS are in the same source\nfile.\n\nOnly one entry pont is needed as RXVSAM has a V-con for RXVSAMSG.\nThe load module can be called RXVSAM, which will then be the\nfunction name called by REXX execs. If it's linked under another\nname, that name will become the function name.\n\nRXVSAM requires the VSAM macros, as well as IEANT name / token\nservices.  A few other macros / dsects are required. In most\ninstallations, any copy / macro code will be found in SYS1.MACLIB.\nBe sure to include this in your assembly step.\n\nThis version is reentrant, and runs in 31-bit mode (AMODE=31,\nRMODE=ANY).  Note that different REXX execs can operate against\nthe same VSAM file (i.e. one exec can open the file, and a different\n[called] exec can do reads or writes).\n\nPlease let me know any problems, suggestions, feedback, etc. I\ncan also provide sample execs illustrating the various functions,\njust e-mail me.\n\nI hope this proves useful in your work.\n\nMark Winges\nMuPro, Inc.\nWingNotes@earthlink.net\n\n2049 Fulton St.\nSF, CA 94117\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00I\\x00\\x96'o\\x01\\x03\\x05_\\tU\\x00)\\x00)\\x00\\x00\\xd4\\xe6\\xc9\\xd5\\xc7\\xc5\\xe2@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-10-02T00:00:00", "modifydate": "2003-02-24T09:55:49", "lines": 41, "newlines": 41, "modlines": 0, "user": "MWINGES"}, "text": "TO:  Those interested in the REXX function to access VSAM files\n\nI have created several files as part of this \"package\":\n   RXVSAM.ASM is the actual function (assembler source code)\n   RXVSDOC.TXT contains documentation\n   RXVSET.CMD contains a \"setup\" exec to allocate 3 VSAM files and\n        enable you to run the following 3 demo/sample execs:\n   RXVTESTE.CMD using RXVSAM with an ESDS\n   RXVTESTK.CMD using RXVSAM with a KSDS\n   RXVTESTR.CMD using RXVSAM with an RRDS\n\nSince not everyone can receive a binary file, I've not ZIPPED anything,\nit's all straight ASCII text.\n\nIf you upload the sample REXX execs, be forwarned that some file\ntransfer utilities don't handle the vertical bar (concatenation\ncharacter in REXX) very well.  It usually gets translated as a square\nbracket.  So you may need to manually edit them before running them.\n\nThe load library into which you assemble and link RXVSAM M-U-S-T be\n\"available\" to your TSO session (as per the documentation).  This may\nrequire an ISPLLIB allocation, if the library isn't one of the \"system\"\nones that are automatically available.\n\nIf you really want the documentation (5 big pages) printed in a spiffy\nformat, I can snail-mail it to you.  The postscript file is a little\nlarge, and I'd rather not incur the communication charges in sending\nit, even if you are able to receive a binary file.\n\nFor additional background, you might be interested in\n   TSO/E:  Procedures Language MVS/REXX Reference  SC28-1883-4\n(I have the 5th edition, August 1991, there may be a newer one).\nChapter 12 covers external functions in different languages.\n\nMark Winges 415-752-8291\nWingNotes@earthlink.net\n\nP.S.  If I've been cumbersome in my method of getting the files to you,\nand you have any suggestions, please let me know.  I'm a little\nreluctant to just throw all this stuff up on a server.  Thanks.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE268": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x001\\x01\\x10\\x18?\\x01\\x10\\x18?\\x19I\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-07-02T00:00:00", "modifydate": "2010-07-02T19:49:31", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 268 is from Mark Winges of San Francisco, California      *   FILE 268\n//*           and contains a package of REXX functions to access    *   FILE 268\n//*           VSAM files.  This is his second version.              *   FILE 268\n//*                                                                 *   FILE 268\n//*           This file was fixed by Rob Van Riel, to solve         *   FILE 268\n//*           several problems.  Details are in member RXVSAM$.     *   FILE 268\n//*                                                                 *   FILE 268\n//*           Revised again by Peter Farley (07/2010).  Details     *   FILE 268\n//*           can be found in new member $CHNGLOG.                  *   FILE 268\n//*                                                                 *   FILE 268\n//*         This file was revised by Mark Winges, to Release 2.2.   *   FILE 268\n//*         Please note that csect RXVSAMSG was combined with       *   FILE 268\n//*         the main csect RXVSAM in Release 2.2.  Mark included    *   FILE 268\n//*         Rob Van Riel's fixes in this latest release, as well    *   FILE 268\n//*         as some more of his own.  (SG 04/02)                    *   FILE 268\n//*                                                                 *   FILE 268\n//*         email:   Mark Winges <WingNotes@earthlink.net>          *   FILE 268\n//*         phone:   415-752-8291                                   *   FILE 268\n//*                                                                 *   FILE 268\n//*         email: \"Van Riel, Rob\" <vanrielr@anz.com>               *   FILE 268\n//*                                                                 *   FILE 268\n//*         email: \"Peter Farley\" <pjfarley3@yahoo.com>             *   FILE 268\n//*                                                                 *   FILE 268\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMRXVS": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x10\\x18/\\x01\\x10\\x18/\\x13\\x02\\x00!\\x00\\x1b\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-01T00:00:00", "modifydate": "2010-07-01T13:02:02", "lines": 33, "newlines": 27, "modlines": 0, "user": "PFARLEY"}, "text": "//TSOUSERX JOB (ACCT,INFO),'PROGRAMMER NAME',   <==== USE THE NECESSARY\n//        CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID     <==== JOB CARD SETUP\n//*\n//* LINES MARKED LIKE THIS TELL YOU:         <==== WHAT YOU MUST CHANGE\n//*\n//* JCLLIB IS NOT NEEDED IF YOUR SYSTEM PROCLIB(S) CONTAIN THE STANDARD\n//* IBM-SUPPLIED HLASM PROC ASMCL, USUALLY FOUND IN SYS1.SASMSAM1\n//*\n// SET ASMHLQ=SYS1                           <==== SASMSAM1 LIBRARY HLQ\n//*\n//PROC     JCLLIB ORDER=(&ASMHLQ..SASMSAM1)\n//*\n//ASMACL   EXEC ASMACL,PARM.C='USING(NOLIMIT,MAP,WARN(11))',\n//             PARM.L='MAP,LET,LIST'\n//C.SYSLIB  DD\n//          DD DISP=SHR,DSN=SYS1.MODGEN              <==== MODGEN NAME\n//C.SYSIN   DD DISP=SHR,\n//             DSN=&SYSUID..CBT268.PDS(RXVSAM)       <==== CBT268 NAME\n//L.SYSLMOD DD DSN=&SYSUID..TEST.LOAD,               <==== LOADLIB NAME\n//             UNIT=,DISP=SHR,SPACE=\n//L.SYSIN   DD *\n ENTRY RXVSAM\n NAME RXVSAM(R)\n//*\n//* COMPRESS LOAD LIB AFTER UPDATE\n//*\n//CMPRLOAD EXEC PGM=IEBCOPY,PARM=COMPRESS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DISP=SHR,DSN=&SYSUID..TEST.LOAD       <==== LOADLIB NAME\n//SYSUT2    DD DISP=SHR,DSN=&SYSUID..TEST.LOAD       <==== LOADLIB NAME\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUNTESTS": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00B\\x01\\x10\\x18/\\x01\\x10\\x18/\\x13\\t\\x00\\x1f\\x00\\x16\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-07-01T00:00:00", "modifydate": "2010-07-01T13:09:42", "lines": 31, "newlines": 22, "modlines": 0, "user": "PFARLEY"}, "text": "//TSOUSERX JOB (ACCT,INFO),'PROGRAMMER NAME',   <==== USE THE NECESSARY\n//        CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID     <==== JOB CARD SETUP\n//*\n//* LINES MARKED LIKE THIS TELL YOU:         <==== WHAT YOU MUST CHANGE\n//*\n//**********************************************************************\n//* INVOKE REXX SCRIPTS TO TEST RXVSAM SUBROUTINE\n//*\n//* NOTE THAT WITH NO ARGUMENTS, RXVSET WILL ALLOCATE THE THREE VSAM\n//* FILES WITH THE SMS STORCLAS VALUE OF THE SYSEXEC PDS\n//*\n//* TO ALLOCATE WITH A DIFFERENT STORCLAS VALUE USE THE FOLLOWING:\n//*\n//* RXVSET S YOURSTORCLASSNAME\n//*\n//* TO ALLOCATE BY VOLUME INSTEAD OF BY STORCLASS USE THE FOLLOWING:\n//* (NOTE: VOLUME NAME MUST BE 6 CHARACTERS!)\n//*\n//* RXVSET V YOURVOLUMENAME\n//*\n//**********************************************************************\n//RXVSTEST EXEC PGM=IKJEFT01\n//STEPLIB  DD  DISP=SHR,DSN=&SYSUID..TEST.LOAD       <==== LOADLIB NAME\n//SYSEXEC  DD  DISP=SHR,DSN=&SYSUID..CBT268.PDS      <==== CBT268 NAME\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n RXVSET\n RXVTESTE\n RXVTESTK\n RXVTESTR\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXVSAM": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x03\\x01\\x06\"?\\x01\\x10\\x18/\\x10\\x17\\x08Q\\x088\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2006-08-11T00:00:00", "modifydate": "2010-07-01T10:17:03", "lines": 2129, "newlines": 2104, "modlines": 0, "user": "PFARLEY"}, "text": "  TITLE 'RXVSAM - REXX Function To Perform VSAM Requests'\n         PUSH  PRINT\n         PRINT OFF\n         MACRO\n&LABEL   GENMSGS &GEN=DSECT\n         AIF   ('&GEN' EQ 'DSECT').OK\n         AIF   ('&GEN' EQ 'CSECT').OK\n         MNOTE 8,'GENMSGS MACRO STATEMENT HAD AN INVALID VALUE'\n         AGO   .ENDMAC\n.OK      ANOP\n&LABEL   &GEN\n         AIF   ('&GEN' EQ 'CSECT').SKP0000\nM$ALLOK  DS      0CL38\n.SKP0000 ANOP\n         DC      CL4'0000'\n         DC      CL4'I'\n         DC      CL30'Request successfully processed'\n         AIF   ('&GEN' EQ 'CSECT').SKP0001\nM$BADARG DS      0CL31\n.SKP0001 ANOP\n         DC      CL4'0001'\n         DC      CL4'E'\n         DC      CL23'Invalid argument passed'\n         AIF   ('&GEN' EQ 'CSECT').SKP0002\nM$BADOPN DS      0CL19\n.SKP0002 ANOP\n         DC      CL4'0002'\n         DC      CL4'E'\n         DC      CL11'Open failed'\n         AIF   ('&GEN' EQ 'CSECT').SKP0003\nM$BADCLO DS      0CL20\n.SKP0003 ANOP\n         DC      CL4'0003'\n         DC      CL4'E'\n         DC      CL12'Close failed'\n         AIF   ('&GEN' EQ 'CSECT').SKP0004\nM$EOF    DS      0CL19\n.SKP0004 ANOP\n         DC      CL4'0004'\n         DC      CL4'W'\n         DC      CL11'End of File'\n         AIF   ('&GEN' EQ 'CSECT').SKP0005\nM$PREVOP DS      0CL28\n.SKP0005 ANOP\n         DC      CL4'0005'\n         DC      CL4'E'\n         DC      CL20'File is already open'\n         AIF   ('&GEN' EQ 'CSECT').SKP0006\nM$NOBLK  DS      0CL46\n.SKP0006 ANOP\n         DC      CL4'0006'\n         DC      CL4'E'\n         DC      CL38'Unable to access RXVSAM BLOCK variable'\n         AIF   ('&GEN' EQ 'CSECT').SKP0007\nM$NORECV DS      0CL67\n.SKP0007 ANOP\n         DC      CL4'0007'\n         DC      CL4'E'\n         DC      CL46'REXX record variable could not be accessed or '\n         DC      CL13'was undefined'\n         AIF   ('&GEN' EQ 'CSECT').SKP0008\nM$DUPL   DS      0CL24\n.SKP0008 ANOP\n         DC      CL4'0008'\n         DC      CL4'E'\n         DC      CL16'Duplicate record'\n         AIF   ('&GEN' EQ 'CSECT').SKP0010\nM$VMSG   DS      0CL38\n.SKP0010 ANOP\n         DC      CL4'0010'\n         DC      CL4'E'\n         DC      CL30'Unable to save VSAM error data'\n         AIF   ('&GEN' EQ 'CSECT').SKP0011\nM$RMSG   DS      0CL41\n.SKP0011 ANOP\n         DC      CL4'0011'\n         DC      CL4'E'\n         DC      CL33'Unable to set return message text'\n         AIF   ('&GEN' EQ 'CSECT').SKP0012\nM$CLOSAC DS      0CL77\n.SKP0012 ANOP\n         DC      CL4'0012'\n         DC      CL4'E'\n         DC      CL46'ACB was not available to perform CLOSE request'\n         DC      CL23' - file may not be open'\n         AIF   ('&GEN' EQ 'CSECT').SKP0014\nM$NOACB  DS      0CL71\n.SKP0014 ANOP\n         DC      CL4'0014'\n         DC      CL4'E'\n         DC      CL41'ACB was not available to perform request '\n         DC      CL22'- file may not be open'\n         AIF   ('&GEN' EQ 'CSECT').SKP0015\nM$BADSCB DS      0CL56\n.SKP0015 ANOP\n         DC      CL4'0015'\n         DC      CL4'E'\n         DC      CL48'Unable to obtain max record length for this file'\n         AIF   ('&GEN' EQ 'CSECT').SKP0016\nM$NOTFND DS      0CL24\n.SKP0016 ANOP\n         DC      CL4'0016'\n         DC      CL4'W'\n         DC      CL16'Record not found'\n         AIF   ('&GEN' EQ 'CSECT').SKP016A\nM$BWDNF  DS      0CL87\n.SKP016A ANOP\n         DC      CL4'0016'\n         DC      CL4'W'\n         DC      CL47'Record not found - a FULL KEY must be specified'\n         DC      CL32' when issuing a STARTBWD request'\n         AIF   ('&GEN' EQ 'CSECT').SKP0017\nM$NORLEN DS      0CL41\n.SKP0017 ANOP\n         DC      CL4'0017'\n         DC      CL4'E'\n         DC      CL33'Cannot determine length of record'\n         AIF   ('&GEN' EQ 'CSECT').SKP0018\nM$BADUPD DS      0CL41\n.SKP0018 ANOP\n         DC      CL4'0018'\n         DC      CL4'E'\n         DC      CL33'Unable to modify RPL for \"UPDate\"'\n         AIF   ('&GEN' EQ 'CSECT').SKP0019\nM$BADFUN DS      0CL23\n.SKP0019 ANOP\n         DC      CL4'0019'\n         DC      CL4'E'\n         DC      CL15'Function failed'\n         AIF   ('&GEN' EQ 'CSECT').SKP0020\nM$NOREC  DS      0CL40\n.SKP0020 ANOP\n         DC      CL4'0020'\n         DC      CL4'E'\n         DC      CL32'Unable to update RECORD variable'\n         AIF   ('&GEN' EQ 'CSECT').SKP0021\nM$NOIN   DS      0CL34\n.SKP0021 ANOP\n         DC      CL4'0021'\n         DC      CL4'E'\n         DC      CL26'File is not open for INPUT'\n         AIF   ('&GEN' EQ 'CSECT').SKP0022\nM$NOOUT  DS      0CL35\n.SKP0022 ANOP\n         DC      CL4'0022'\n         DC      CL4'E'\n         DC      CL26'File is not open for OUTPUT'\n         AIF   ('&GEN' EQ 'CSECT').SKP0023\nM$BADDSW DS      0CL42\n.SKP0023 ANOP\n         DC      CL4'0023'\n         DC      CL4'E'\n         DC      CL34'Unable to switch to DIR processing'\n         AIF   ('&GEN' EQ 'CSECT').SKP0024\nM$NOGEN  DS      0CL41\n.SKP0024 ANOP\n         DC      CL4'0024'\n         DC      CL4'E'\n         DC      CL33'READGENERIC only allowed for KSDS'\n         AIF   ('&GEN' EQ 'CSECT').SKP0025\nM$NONNUM DS      0CL45\n.SKP0025 ANOP\n         DC      CL4'0025'\n         DC      CL4'E'\n         DC      CL37'Non-numeric key specified for an RRDS'\n         AIF   ('&GEN' EQ 'CSECT').SKP0026\nM$NOESDS DS      0CL48\n.SKP0026 ANOP\n         DC      CL4'0026'\n         DC      CL4'E'\n         DC      CL40'This function is not allowed for an ESDS'\n         AIF   ('&GEN' EQ 'CSECT').SKP0027\nM$NORRN  DS      0CL33\n.SKP0027 ANOP\n         DC      CL4'0027'\n         DC      CL4'E'\n         DC      CL25'Unable to set RXVSAM_RRN#'\n         AIF   ('&GEN' EQ 'CSECT').SKP0028\nM$KEYZER DS      0CL63\n.SKP0028 ANOP\n         DC      CL4'0028'\n         DC      CL4'E'\n         DC      CL48'A zero length (omitted) key is only allowed for '\n         DC      CL7'an ESDS'\n         AIF   ('&GEN' EQ 'CSECT').SKP0088\nM$NOPOS  DS      0CL55\n.SKP0088 ANOP\n         DC      CL4'0088'\n         DC      CL4'E'\n         DC      CL47'READPREV attempted without a previous STARTBWD '\n         AIF   ('&GEN' EQ 'CSECT').SKP0092\nM$NOGET  DS      0CL59\n.SKP0092 ANOP\n         DC      CL4'0092'\n         DC      CL4'E'\n         DC      CL47'REWRITE or DELETE attempted without a previous '\n         DC      CL4'READ'\n         AIF   ('&GEN' EQ 'CSECT').SKP0108\nM$BADRL  DS      0CL99\n.SKP0108 ANOP\n         DC      CL4'0108'\n         DC      CL4'E'\n         DC      CL48'Record length = 0, > max, < key length (KSDS) or'\n         DC      CL43' not equal to slot size (fixed length RRDS)'\n.ENDMAC  ANOP\n         MEND\n*        POP PRINT                HIDE MACRO SOURCE, NOT NEEDED    @PJF\n         MACRO\n&LABEL   SETMSG &MSG=\n         AIF   ('&MSG' NE '').OK\n         MNOTE 8,'NO MESSAGE SPECIFIED'\n         AGO   .ENDMAC\n.OK      ANOP\n         L     14,RXVSMSG@        GET EPA FOR RXVSAM MSG CSECT\n         USING MSGDSECT,14\n         LA    15,&MSG\n         ST    15,MSG@            SAVE -> MESSAGE TEXT\n         LA    15,L'&MSG\n         STH   15,MSGLEN          SAVE MESSAGE LENGTH\n         DROP  14\n.ENDMAC  ANOP\n         MEND\n         SPACE\n         MACRO\n&LABEL   NTERROR &REQ=,&SYM=,&GOTO=\n         AIF   ('&REQ' NE '').CHKSYM\n         MNOTE 8,'NO REQUEST TYPE SPECIFIED'\n         AGO   .ENDMAC\n.CHKSYM  ANOP\n         AIF   ('&SYM' NE '').OK\n         MNOTE 8,'NO SYMBOL (LABEL) SPECIFIED'\n         AGO   .ENDMAC\n.OK      ANOP\n         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT MESSAGE AREA\n         ST    R15,NAMTOKRC                SAVE RETURN CODE\n         CVD   R15,DBLWRK\n         OI    BYTEWRK2,X'F0'\n         MVC   NTMSGR15,HALFWRK2\n         MVC   NTREQ,=CL8'&REQ'            SAVE REQUEST TYPE\n         MVC   NTLABEL,=CL8'&SYM'          AND RXVSAM LABEL\n         AIF   ('&GOTO' EQ '').ENDMAC\n         J     &GOTO                                               @PJF\n.ENDMAC  ANOP\n         MEND\n         EJECT\n         MACRO\n&LABEL   ADDTRACE &ENTRY=\n         OC    TRACE@B,TRACE@B             DO WE HAVE A TRACE AREA?\n         JNZ   YY&SYSNDX                   YES, ADD ENTRY TO IT    @PJF\n         STORAGE OBTAIN,LENGTH=4096000     NO GET A 4 MEG AREA\n         ST    R1,TRACE@B                  SAVE BEGINNING ADDR\n         LR    R0,R1                       CLEAR AREA\n         L     R1,=F'4096000'\n         SR    R15,R15\n         MVCL  R0,R14\n         L     R1,TRACE@B                  GET -> TO AREA\n         MVC   0(8,R1),=CL8'TR@CET@B'      STICK EYECATCHER IN IT\n         LA    R15,8(,R1)                                          @PJF\n         ST    R15,TRACE@C                 POSITION FOR NEXT ENTRY\n         LR    R15,R1\n         A     R15,=F'4096000'\n         ST    R15,TRACE@M                 ENDING ADDRESS OF AREA\nYY&SYSNDX  L   R1,TRACE@C\n         LA    R15,L'&ENTRY                MAKE SURE THIS ENTRY\n         AR    R15,R1                      WON'T GO OFF THE END\n         C     R15,TRACE@M\n         JNL   ZZ&SYSNDX                                           @PJF\n         MVC   0(L'&ENTRY,R1),&ENTRY\n         ST    R15,TRACE@C\nZZ&SYSNDX  DS  0H\n         MEND\n         COPY  IEABRC                                              @PJF\n         POP   PRINT                                               @PJF\n         EJECT\n*---------------------------------------------------------------------\n*  This function will provide access to a VSAM file from a REXX exec.\n* It is designed to be called as an external function in the MVS/ESA\n* environment.  The function call should take the form:\n*    RXVSAM(<request>,<ddname>,{<key>|<filetype>,<recordarea>})\n* The first 2 arguments are required, 3 and 4 are optional.  Argument\n* definitions/values:\n*  1. request: OPENINPUT OPENOUTPUT OPENIO\n*              CLOSE\n*              READ READGENERIC READNEXT READPREV READLAST\n*              WRITE REWRITE DELETE\n*              STARTFWD STARTBWD\n*  2. ddname: must be 1 - 8 uppercase or national characters\n*  3. key: the key or RRN or RBA (for requests other than OPEN)    @PJF\n*     filetype: either KSDS, ESDS or RRDS (one of the three must be\n*               specified in uppercase for OPEN requests)\n*     This argument may be null in some cases (READNEXT, READPREV,\n*     READLAST, WRITE, DELETE).  A null key for WRITE requests\n*     is designed for use in writing to an RRDS for the first time\n*     (initialization), and should always be used when writing to\n*     an ESDS.  To make the argument 3 null, code an extra comma\n*     before argument 4, for example:\n*         result = RXVSAM('READNEXT','MYFILE',,'MY_RECORD_AREA')\n*     If the key is an RRN or RBA, it must be given in decimal.    @PJF\n*     Direct READs are possible for an ESDS, using RBAs as the key.@PJF\n*  4. recordarea: the REXX VARIABLE name that contains record data\n*     this argument is always ignored for OPEN or CLOSE requests.\n*     If this argument is omitted, the variable name RXVSAM_RECORD is\n*     used (for READ requests) or assumed (for WRITE|REWRITE requets).\n*\n*  2.1 -- add DELETE macros for routines that have been LOADed\n*  (IRXEXCOM and various name / token routines).\n*\n*  2.2 -- locate IEANTxx services by bumping through storage rather\n*  than doing a LOAD. Remove associated DELETEs. Add RXVSAMSG CSECT\n*  at end of this assembly; revise GENMSGS macro. Get IRXEXCOM address\n*  by bumping thru ENVBLOCK (environemnt block) to IRXEXTE (external\n*  address table), rather than doing a LOAD. Remove associated DELETE.\n*  Add required ENVBLOCK & IRXEXTE macros (dsects). Allow rewrite for\n*  an ESDS. (Special thanks to Rob Van Riel for these changes)\n*\n*  2.3 -- Convert to baseless programming (J not B, JNE not BNE,   @PJF\n*  etc.).  Added SYSTATE ARCHLVL=2 and COPY IEABRC and             @PJF\n*  CALL ...,LINKINST=BASR in support of baseless structure.        @PJF\n*  R12 now points to label CONSTANT for LTORG and true constants,  @PJF\n*  R11 and R10 are no longer used for any purpose.                 @PJF\n*  Executed instructions moved to CONSTANT section for             @PJF\n*  addressibility.   Hardware pipeline delays may result from this @PJF\n*  due to executed instruction not being in the instruction cache. @PJF\n*  Now allows both STARTFWD and STARTBWD for ESDS files.           @PJF\n*  HLASM system variable &SYSDATC used instead of &SYSDATE for     @PJF\n*  eyecatcher constant.                                            @PJF\n*  LA and ST instructions using explicit displ(indexreg) for their @PJF\n*  second argument changed to use displ(,basereg) format to avoid  @PJF\n*  unnecessary index register activity.                            @PJF\n*  SAVE macro added with eyecatcher string to both preserve the    @PJF\n*  savearea chain and to use standard eyecatcher placement for     @PJF\n*  module identification.  BAKR and PR are still used to perform   @PJF\n*  entry and exit from module.                                     @PJF\n*  Corrected roundup of record length to next doubleword at label  @PJF\n*  OPEN310.                                                        @PJF\n*  IHASTCB macro used to map STCB instead of hard-coded definition.@PJF\n*  IFGACB and IFGRPL macros added for ACB and RPL mapping.         @PJF\n*\n*----------------------------------------------------------------------\n         EJECT\n         SYSSTATE ARCHLVL=2       ADDED TO USE RELATIVE BRANCHING  @PJF\nRXVSAM   CSECT\nRXVSAM   AMODE 31\nRXVSAM   RMODE ANY\n         SPACE\nR0       EQU   0                  REGISTER EQUATES\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6                  -> SHVBLOCK (also used as a work reg)\nR7       EQU   7                  -> FILE WORK AREA\nR8       EQU   8                  -> ARGUMENT LIST\nR9       EQU   9                  -> LOCAL WORK AREA\nR10      EQU   10                                                  @PJF\nR11      EQU   11                                                  @PJF\nR12      EQU   12                 BASE for CONSTANT area only      @PJF\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nMSGDSECT GENMSGS GEN=DSECT\n         SPACE 2\n         IEANTASM\n*        PRINT NOGEN              I LIKE SEEING ALL GENERATED CODE @PJF\n         EJECT\nRXVSAM   CSECT ,                  RESUME CSECT\n         SPACE\n*        SAVE REGS IN THE STD WAY TO PRESERVE THE SAVEAREA CHAIN   @PJF\n         SAVE  (14,12),,'RXVSAM  ,&SYSDATC,&SYSTIME,RELEASE 2.3'   @PJF\n*        BAKR AND PR ACTUALLY USED FOR REGISTER SAVE AND RETURN    @PJF\n         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC\n         LARL  R12,CONSTANT       ADDRESS FOR LTORG+CONSTANT AREA  @PJF\n         USING CONSTANT,R12       AND TELL ASSEMBLER ABOUT IT      @PJF\n         LR    R4,R1              PARK PARM POINTER (R1) IN R4\n         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ\n         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA\n         STORAGE OBTAIN,LENGTH=(R2)    GET LOCAL WORK AREA\n         SPACE\n         LR    R9,R1              SET BASE REGISTER FOR LOCAL WORK AREA\n         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY\n         LR    R2,R9\n         LA    R3,LOCAL_WORKAREA_LENGTH\n         SR    R15,R15            PAD OF X'00' & ZERO LENGTH\n         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO\n         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA\n         ST    R13,4(,R15)        CHAIN BACKWARD ->                @PJF\n         ST    R15,8(,R13)        CHAIN FORWARD ->                 @PJF\n         LR    R13,R15\n         EJECT\nMAIN100  DS    0H\n         IAZXJSAB READ,JOBID=MYJOBID\n         SPACE\n         LR    R1,R4              RESTORE PARM (R1) FROM SAVED REG\n         USING EFPL,R1            SET ADDRESSABILITY\n         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE\n         LA    R6,OURSHVBL        INIT -> TO OUR SHARED VAR BLK\n         USING SHVBLOCK,R6        SET ADDRESSABILITY\n         L     R8,EFPLARG         GET -> TO ARGUMENT LIST\n         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY\n         DROP  R1                 DROP EFPL ADDRESSABILITY\n         SPACE\n         MVC   VSAMEMSG(VMSGLEN),VMSGINIT  INIT VSAM ERROR MSG AREA\n         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT NAME/TOKEN MSG AREA\n         SPACE\n         SETMSG MSG=M$ALLOK       INITIALIZE RETURN MESSAGE\n         MVC   VSAMER15,=CL2'00'  INITIALIZE VSAM REG 15 RC\n         SPACE\n*R5 already -> environment block -- loaded from R0 at entry to RXVSAM\n         SPACE\n         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ\n         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ\n         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ\n         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ\n         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ\n         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE\n         DROP  R5                 DROP ENVBLOCK ADDRESSABILITY     @ANZ\n         SPACE\n         L     R5,ARGTABLE_ARGSTRING_PTR  GET ADDR OF REQUEST ARG\n         C     R5,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'\n         JE    MAIN400            NO ARG PASSED,ERROR              @PJF\n         SPACE\n         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT (DDNAME)\n         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG\n         C     R3,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'\n         JE    MAIN400            NO ARG PASSED,ERROR              @PJF\n         SPACE\n         CH    R4,=H'8'           IF DDNAME LONGER THAN 8 CHARACTERS\n         JH    MAIN400            IT'S AN ERROR                    @PJF\n         LA    R8,ARGTABLE_NEXT   BUMP TO \"NEXT\" ARGUMENT\n         SPACE\n         MVC   DDNAME,SPACES      INIT BLANK PADDED DDNAME\n         BCTR  R4,0               DECR IN PREPARATION FOR EXECUTED MVC\n         EX    R4,MOVEDDNM        SET OUR COPY OF THE DDNAME\n         SPACE\n         MVC   IEANTNA1,MYJOBID   CREATE \"NAME\" FOR NAME / TOKEN\n         MVI   IEANTNA1,C'X'      SERVICES: JOBID (1ST CHAR ALWAYS \"X\")\n         MVC   IEANTNA2,DDNAME    PLUS DDNAME\n         XC    IEANTTOK,IEANTTOK  CLEAR OUT \"TOKEN\"\n         MVC   IEANTLVL,=AL4(IEANT_TASK_LEVEL)  TASK LVL FOR ALL REQ\n         EJECT\nMAIN200  DS    0H\n*\n* THE FOLLOWING USING IS GLOBAL (FOR THE REST OF THE CSECT).  IT IS THE\n* INDIVIDUAL ROUTINE'S RESPONSIBILITY TO ENSURE R7 CONTAINS A VALID\n* ADDRESS WHEN A FILE WORK AREA IS \"ACTIVE\"\n*\n         USING FWABLOCK,R7\n*\n* PERFORM CORRECT ROUTINE BASED ON FUNCTION REQUEST - SET R14 AS A\n* \"RETURN\" ADDRESS\n*\n         LARL  R14,MAIN500        SERVES AS A \"RETURN\" POINT       @PJF\n         CLC   =CL4'OPEN',0(R5)\n         JE    OPEN000                                             @PJF\n         CLC   =CL4'CLOS',0(R5)\n         JE    CLOS000                                             @PJF\n         CLC   =CL4'READ',0(R5)\n         JE    READ000                                             @PJF\n         CLC   =CL4'WRIT',0(R5)\n         JE    WRIT000                                             @PJF\n         CLC   =CL4'REWR',0(R5)\n         JE    REWR000                                             @PJF\n         CLC   =CL4'DELE',0(R5)\n         JE    DELE000                                             @PJF\n         CLC   =CL4'STAR',0(R5)\n         JE    STAR000                                             @PJF\n         SPACE\nMAIN400  DS    0H\n         SETMSG MSG=M$BADARG      SET BAD RESULT CODE\n         J     MAIN900            EXIT                             @PJF\n         EJECT\nMAIN500  DS    0H\n         SPACE\n*+*+*+\n*  NEED TO CHECK FOR AN INVALID NAME / TOKEN REQUEST & PUT ERROR\n*  MESSAGE IN A REXX VARIABLE IF NECESSARY\n*+*+\n         LA    R2,VMSGVAR         ELSE, SET MESSAGE: GET -> TO MESSAGE\n         LA    R3,L'VMSGVAR       VARIABLE NAME & LENGTH OF VAR NAME\n         STM   R2,R3,SHVNAMA      STORE IN SHV PARM LIST (2 FULLWORDS)\n         CLC   VSAMER15,=CL2'00'  IS VSAM REG 15 RC ZERO?\n         JE    MAIN520            YES, RESET VARIABLE TO ITS DEFAUL@PJF\n         SPACE\n         MVC   SHVVALL,=A(VSAMELEN)   ELSE, SET IT TO OUR \"REAL\"\n         LA    R0,VSAMEMSG        VARIABLE\n         ST    R0,SHVVALA\n         J     MAIN530                                             @PJF\n         SPACE\nMAIN520  DS    0H\n         SPACE\n         MVC   SHVVALL,SHVNAML    NAME LENGTH & VAR LENGTH ARE EQUAL\n         MVC   SHVVALA,SHVNAMA    NAME AND VALUE ARE THE SAME TOO\n         SPACE\nMAIN530  DS    0H\n         SPACE\n         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE\n         L     R15,IRXEXCO@       GET EPA TO IRXEXCOM ROUTINE\n         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS\n         JZ    MAIN900            IF ALL OK, CONTINUE              @PJF\n         SPACE\n         SETMSG MSG=M$VMSG        ELSE, SET MESSAGE THEN FALL THRU\n         SPACE\nMAIN900  DS    0H\n         LA    R0,L'RMSGVAR       LENGTH OF RET MSG VARIABLE NAME\n         ST    R0,SHVNAML         SET LENGTH IN SHARED VARIABLE BLOCK\n         LA    R0,RMSGVAR         -> TO VARIABLE NAME\n         ST    R0,SHVNAMA\n         LH    R0,MSGLEN          LENGTH OF VARIABLE\n         ST    R0,SHVVALL\n         L     R0,MSG@            GET -> TO MESSAGE\n         ST    R0,SHVVALA\n         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE\n         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE\n         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS\n         JZ    MAIN950            IF ALL OK, CONTINUE              @PJF\n         SPACE\n         SETMSG MSG=M$RMSG        REVISE RETURN MESSAGE\n         EJECT\nMAIN950  DS    0H\n         L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST\n         USING EFPL,R1            SET ADDRESSABILITY\n         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK\n         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK\n         USING EVALBLOCK,R2       SET ADDRESSABILITY\n         L     R14,MSG@           1ST 4 BYTES OF MSG ARE THE RESULT\n         MVC   EVALBLOCK_EVLEN,=F'4'          PASS RESULT BACK IN THE\n         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK\n         DROP  R2,R1\n         SPACE\nGOBACK   DS    0H\n         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA\n         STORAGE RELEASE,LENGTH=(R2),ADDR=(R9)    RELEASE WORK AREA\n         SPACE\n         SLR   R15,R15            MAKE SURE RETURN CODE IS ZERO\n         PR                       RETURN TO CALLER\n         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY\n         EJECT\nOPEN000  DS    0H\n*\n* UPON ENTRY, R8 -> ARGUMENT LIST 3 SLOT (FILE TYPE), R5 STILL -> TO\n* TYPE OF REQUEST\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         L     R4,ARGTABLE_ARGSTRING_PTR\n         C     R4,=X'FFFFFFFF'    IS ADDRESS ALL X'FF' ?\n         JNE   OPEN010            NO, CONTINUE                     @PJF\n         SPACE\n         SETMSG MSG=M$BADARG      SET BAD RESULT CODE\n         J     OPEN999                                             @PJF\n         SPACE\nOPEN010  DS    0H    -- SEE IF THERE'S A NAME / TOKEN FOR THIS FILE --\n         BRAS  R14,RTRVTOK0\n         SPACE\n         CH    R15,=AL2(IEANT_NOT_FOUND)   IF NO TOKEN EXISTS\n         JE    OPEN020                     IT'S OK TO CONTINUE     @PJF\n         SPACE\n         LTR   R15,R15                     IF A TOKEN EXISTS\n         JZ    OPEN015                     FILE IS ALREADY OPEN    @PJF\n         SPACE\n         NTERROR REQ=RETRIEVE,SYM=OPEN010,GOTO=OPEN999\n         SPACE\nOPEN015  DS    0H\n         SETMSG MSG=M$PREVOP\n         J     OPEN999          THE FILE IS ALREADY OPEN - EXIT    @PJF\n         SPACE\nOPEN020  DS    0H\n         LA    R2,FWALEN        LENGTH OF FILE WORK AREA\n         STORAGE OBTAIN,LENGTH=(R2)    GET A NEW FILE WORK AREA\n         SPACE\n         LR    R7,R1            -> TO FWA (ADDRESSABILITY ALREADY SET)\n         LR    R2,R7\n         LA    R3,FWALEN\n         SR    R15,R15\n         MVCL  R2,R14           INIT AREA TO X'00'\n*\n* NOTE: R3 REMAINS AS A POINTER TO THE ACB THROUGHOUT THE REST OF THE\n*       OPEN LOGIC\n*\n         LA    R3,FWAACB          -> TO OUR ACB\n         EJECT\n         CLC   =CL4'KSDS',0(R4)   KSDS?\n         JNE   OPEN030            NO, TRY NEXT POSSIBLITY          @PJF\n         SPACE\n         OI    F@OPENFL,F@OSEQ+F@ODIR+F@OKSDS     SET OUR FLAGS\n         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X\n               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X\n               MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            GENCB SUCCESSFUL?\n         JZ    OPEN100            YES - CONTINUE                   @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         SPACE\nOPEN030  DS    0H\n         CLC   =CL4'ESDS',0(R4)   ESDS?\n         JNE   OPEN040            NO, TRY NEXT POSSIBLITY          @PJF\n         SPACE\n         OI    F@OPENFL,F@OSEQ+F@OESDS          SET FLAGS\n         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(ADR,SEQ),              X\n               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X\n               MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            GENCB SUCCESSFUL?\n         JZ    OPEN100            YES - CONTINUE                   @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         SPACE\nOPEN040  DS    0H\n         CLC   =CL4'RRDS',0(R4)   RRDS?\n         JNE   OPEN050            NO, DO ERROR PROCESSING          @PJF\n         SPACE\n         OI    F@OPENFL,F@OSEQ+F@ODIR+F@ORRDS         SET FLAGS\n         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X\n               LENGTH=FWAACBL,WAREA=(R3),RMODE31=ALL,                  X\n               MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            GENCB SUCCESSFUL?\n         JZ    OPEN100            YES - CONTINUE                   @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         SPACE\nOPEN050  DS    0H\n         SETMSG MSG=M$BADARG      SET BAD RESULT CODE\n         J     OPEN999                                             @PJF\n         EJECT\nOPEN100  DS    0H\n         CLC   =CL9'OPENINPUT',0(R5)    OPEN INPUT?\n         JNE   OPEN110            NO, TRY NEXT POSSIBILITY         @PJF\n         SPACE\n         OI    F@OPENFL,F@OIN           SET FLAG\n         MODCB ACB=(R3),MACRF=(IN),RMODE31=ALL,MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         SPACE\nOPEN110  DS    0H\n         CLC   =CL6'OPENIO',0(R5) INPUT & OUTPUT?\n         JNE   OPEN120            NO, TRY NEXT POSSIBILITY         @PJF\n         SPACE\n         OI    F@OPENFL,F@OIN+F@OOUT    SET FLAGS\n         MODCB ACB=(R3),MACRF=(IN,OUT),RMODE31=ALL,                    X\n               MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         EJECT\nOPEN120  DS    0H\n         CLC   =CL10'OPENOUTPUT',0(R5)   ONLY OUTPUT?\n         JNE   OPEN130            NO, BAD ARGUMENT                 @PJF\n         SPACE\n         OI    F@OPENFL,F@OOUT           SET FLAG\n         MODCB ACB=(R3),MACRF=(OUT),RMODE31=ALL,MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    OPEN200            YES - READY TO ISSUE OPEN        @PJF\n         J     OPEN900            NO - DO ERROR HANDLING           @PJF\n         SPACE\nOPEN130  DS    0H\n         SETMSG MSG=M$BADARG     SET BAD RESULT CODE\n         J     OPEN999                                             @PJF\n         EJECT\nOPEN200  DS    0H\n         XC    OPEN_PARMLIST,OPEN_PARMLIST   INIT AREA\n         OI    OPEN_PARMLIST,X'80'           HI-ORDER ON = 31 BIT FORM\n         ST    R3,OPEN_PARMLIST+4            STORE ACB -> IN 2ND WORD\n         OPEN  MODE=31,MF=(E,OPEN_PARMLIST)  OPEN DATASET\n         SPACE\n         LTR   R15,R15            WAS OPEN SUCCESSFUL?\n         JNZ   OPEN210            NO - DO ERROR PROCESSING         @PJF\n         SPACE\n         J     OPEN300            READY TO GENERATE RPL            @PJF\n         SPACE\nOPEN210  DS    0H\n         MVC   VSAMELAB,=CL8'OPEN210'   SET UP ERROR MESSAGE FIELDS\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         LA    R2,FULLWRK2\n         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X\n               MF=(G,SHOWCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            DID SHOWCB WORK?\n         JZ    OPEN230            YES - GO PICK UP ERROR MESSAGE   @PJF\n         SPACE\nOPEN220  DS    0H\n         MVC   VSAMELAB,=CL8'OPEN220'   SET UP ERROR MESSAGE FIELDS\n         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         CVD   R0,DBLWRK          SET REASON CODE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         J     OPEN990            AND EXIT ROUTINE                 @PJF\n         SPACE\nOPEN230  DS    0H\n         LH    R0,HALFWRK2\n         CVD   R0,DBLWRK\n         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE\n         OI    VSAMEREA+3,X'F0'\n         J     OPEN990            AND EXIT ROUTINE                 @PJF\n         EJECT\nOPEN300  DS    0H      -- GET MAX RECORD LENGTH & GENERATE RPL --\n         LA    R2,F@LRECL\n         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,                           X\n               FIELDS=LRECL,MF=(G,SHOWCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            DID SHOWCB WORK?\n         JZ    OPEN310            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'OPEN300'\n         MVC   VSAMEREA,=CL4'0000'\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         CH    R15,=H'4'          IF R15 ISN'T 4, REASON CODE ISN'T\n         JNE   OPEN999            IN R0                            @PJF\n         SPACE\n         CVD   R0,DBLWRK          SET REASON CODE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         SETMSG MSG=M$BADSCB      SET BAD RESULT CODE\n         SPACE\n         J     OPEN999                                             @PJF\n         SPACE\nOPEN310  DS    0H\n         L     R2,F@LRECL         GET MAX LRECL FROM SHOWCB\n         LA    R2,7(,R2)          ROUND UP TO NEXT DOUBLEWORD      @PJF\n         SRL   R2,3               DIVIDE BY 8, TRUNCATE REMAINDER  @PJF\n         SLL   R2,3               MULTIPLY BY 8                    @PJF\n         ST    R2,F@BUFLEN        SAVE LENGTH FOR LATER USE\n         STORAGE OBTAIN,LENGTH=(R2)\n         SPACE\n         ST    R1,F@RECBUF        SAVE ADDRESS OF STORAGE\n         SPACE\nOPEN320  DS    0H            -- READY TO GENERATE RPL --\n         LA    R2,FWARPL          -> TO WHERE RPL WILL BE BUILT\n         CLC   =CL4'KSDS',0(R4)   KSDS?\n         JE    OPEN400                                             @PJF\n         CLC   =CL4'RRDS',0(R4)   RRDS?\n         JE    OPEN410                                             @PJF\n         CLC   =CL4'ESDS',0(R4)   ESDS?\n         JE    OPEN420                                             @PJF\n         EJECT\nOPEN400  DS    0H                        -- KSDS --\n         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS\n         L     R4,F@RECBUF        -> RECORD BUFFER\n         L     R5,F@BUFLEN        SIZE OF BUFFER\n         LA    R6,F@RPLARG        -> KEY (ARGUMENT)\n         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X\n               LENGTH=FWARPLL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),         X\n               ARG=(R6),MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            ALL OK?\n         JZ    OPEN500            YES, CONTINUE                    @PJF\n         J     OPEN910            NO, DO ERROR HANDLING            @PJF\n         SPACE\nOPEN410  DS    0H                        -- RRDS --\n         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS\n         L     R4,F@RECBUF        -> RECORD BUFFER\n         L     R5,F@BUFLEN        SIZE OF BUFFER\n         LA    R6,F@RPLARG        -> KEY (ARGUMENT)\n         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X\n               LENGTH=FWARPLL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),         X\n               ARG=(R6),MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            ALL OK?\n         JZ    OPEN500            YES, CONTINUE                    @PJF\n         J     OPEN910            NO, DO ERROR HANDLING            @PJF\n         SPACE\nOPEN420  DS    0H                        -- ESDS --\n         OI    F@RPLFL,F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS\n         L     R4,F@RECBUF        -> RECORD BUFFER\n         L     R5,F@BUFLEN        SIZE OF BUFFER\n         LA    R6,F@RPLARG        -> KEY (ARGUMENT)\n         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X\n               LENGTH=FWARPLL,OPTCD=(ADR,ARD,SEQ,FWD,KEQ,FKS),         X\n               ARG=(R6),MF=(G,GENCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            ALL OK?\n         JZ    OPEN500            YES, CONTINUE                    @PJF\n         J     OPEN910            NO, DO ERROR HANDLING            @PJF\n         EJECT\nOPEN500  DS    0H\n         XC    IEANTTOK,IEANTTOK  CLEAR OUT TOKEN AREA\n         ST    R7,IEANTTOK        SAVE -> TO FILE WORK AREA\n         MVC   IEANTPOP,=AL4(IEANT_NOPERSIST)\n*\n* CREATE A NAME / TOKEN SO WE CAN FIND THE FILE WORK AREA NEXT TIME\n* RXVSAM IS CALLED. REL 2.2: BUMP THRU CONTROL BLOCKS TO FIND IEANTCR.\n*\n         L     R15,X'10'\n         L     R15,X'220'(R15,0)\n         L     R15,X'14'(R15,0)\n         L     R15,X'04'(R15,0)\n         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTPOP,IEANTRC),     X\n               LINKINST=BASR,                                      @PJFX\n               MF=(E,IEANTLST)\n         SPACE\n         LTR   R15,R15\n         JZ    OPEN999            IF CREATE SUCCEEDED, ALL DONE    @PJF\n         SPACE\n         NTERROR REQ=CREATE,SYM=OPEN500,GOTO=OPEN999\n         SPACE 3\nOPEN900  DS    0H      -- GENERAL ERROR GENERATING THE ACB --\n         MVC   VSAMELAB,=CL8'OPEN900'\n         J     OPEN920                                             @PJF\n         SPACE\nOPEN910  DS    0H      -- GENERAL ERROR GENERATING THE RPL --\n         MVC   VSAMELAB,=CL8'OPEN910'  SET LABEL & FALL THRU\n         SPACE\nOPEN920  DS    0H\n         MVC   VSAMEREA,=CL2'00'\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         BRAS  R14,GETREG0        CHECK FOR REASON CODE IN R0\n         SPACE\nOPEN990  DS    0H\n         SETMSG MSG=M$BADOPN      SET BAD RESULT CODE & FALL-THRU\n         SPACE\nOPEN999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         EJECT\nCLOS000  DS    0H\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    CLOS100            FILE IS OPEN                     @PJF\n         SPACE\n         CH    R15,=AL2(IEANT_NOT_FOUND) FOR ANYTHING OTHER THAN \"NOT\n         JNE   CLOS050            FOUND\" GENERATE A NAME / TOKEN ER@PJF\n         SPACE\n         SETMSG MSG=M$CLOSAC      ASSUME FILE ISN'T OPEN\n         J     CLOS999                                             @PJF\n         SPACE\nCLOS050  DS    0H\n         NTERROR REQ=RETRIEVE,SYM=CLOS000,GOTO=CLOS999\n         SPACE\nCLOS100  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         OC    FWAACB,FWAACB      ACB AREA SHOULD BE NON-ZERO\n         JNZ   CLOS150            IF IT IS, CONTINUE               @PJF\n         SPACE\n         SETMSG MSG=M$CLOSAC      IF ACB IS ZERO, ASSUME FILE ISN'T\n         J     CLOS999            OPEN - GENERATE MESSAGE & EXIT   @PJF\n         SPACE\nCLOS150  DS    0H\n         XC    CLOSE_PARMLIST,CLOSE_PARMLIST INIT AREA\n         OI    CLOSE_PARMLIST,X'80'          HI-ORDER ON = 31 BIT FORM\n         LA    R3,FWAACB                     STORE POINTER TO ACB\n         ST    R3,CLOSE_PARMLIST+4           IN 2ND WORD OF LIST\n         CLOSE MODE=31,MF=(E,CLOSE_PARMLIST)\n         SPACE\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    CLOS500            YES - GO DELETE ACB VARIABLE     @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'CLOS000'   SET UP ERROR MESSAGE FIELDS\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         LA    R2,FULLWRK2\n         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X\n               MF=(G,SHOWCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            DID SHOWCB WORK?\n         JZ    CLOS300            YES - GO PICK UP ERROR MESSAGE   @PJF\n         EJECT\nCLOS200  DS    0H\n         MVC   VSAMELAB,=CL8'CLOS200'   SET UP ERROR MESSAGE FIELDS\n         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         CVD   R0,DBLWRK          SET REASON CODE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         J     CLOS990            AND EXIT ROUTINE                 @PJF\n         SPACE\nCLOS300  DS    0H\n         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE\n         OI    VSAMEREA+3,X'F0'\n         J     CLOS990                                             @PJF\n         SPACE\nCLOS500  DS    0H      -- CLEANUP STUFF --\n         OC    F@RECBUF,F@RECBUF    DO WE HAVE A RECORD BUFFER?\n         JZ    CLOS510              NO, JUST DO FWA CLEANUP        @PJF\n         SPACE\n         L     R2,F@BUFLEN          LENGTH OF RECORD BUFFER\n         L     R3,F@RECBUF          ADDRESS OF RECORD BUFFER\n         STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)    RELEASE REC BUFFER\n         SPACE\nCLOS510  DS    0H\n         LA    R2,FWALEN            LENGTH OF FILE WORK AREA\n         STORAGE RELEASE,LENGTH=(R2),ADDR=(R7)    RELEASE FWA\n         SPACE\n         L     R15,X'10'            BUMP THRU STORAGE TO FIND\n         L     R15,X'220'(R15,0)    IEANTDL STUB / POINTER\n         L     R15,X'14'(R15,0)\n         L     R15,X'0C'(R15,0)\n         CALL  (15),(IEANTLVL,IEANTNAM,IEANTRC),MF=(E,IEANTLST),   @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         LTR   R15,R15              IF NAME / TOKEN DELETE WAS OK\n         JZ    CLOS999              ALL DONE                       @PJF\n         SPACE\n         NTERROR REQ=DELETE,SYM=CLOS510,GOTO=CLOS999\n         SPACE\nCLOS990  DS    0H\n         SETMSG MSG=M$BADCLO      SET MESSAGE & FALL-THRU\n         SPACE\nCLOS999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         EJECT\nREAD000  DS    0H\n*\n* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    READ010            READY TO GO                      @PJF\n         SPACE\n         SETMSG MSG=M$NOACB\n         NTERROR REQ=RETRIEVE,SYM=READ000,GOTO=READ999\n         SPACE\nREAD010  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         TM    F@OPENFL,F@OIN     FILE OPEN FOR INPUT?\n         JO    READ020            YES                              @PJF\n         SPACE\n         SETMSG MSG=M$NOIN        NO, SET MESSAGE\n         J     READ999            AND EXIT                         @PJF\n         SPACE\nREAD020  DS    0H\n*\n* FROM THIS POINT THRU THE REST OF THE READ LOGIC, R4 -> FWARPL\n*\n         LA    R4,FWARPL\n*\n*  FOR ANY READ TYPE, IF THE FILE IS OPEN FOR OUTPUT, ALLOW FOR THE\n*  POSSIBILITY OF UPDATE (ENSURE RPL IS SET UP TO ALLOW UPDATE)\n*\n         TM    F@OPENFL,F@OOUT    IS FILE OPEN FOR OUTPUT?\n         JZ    READ040            NO, LET RPL STAND AS IS          @PJF\n         SPACE\n         TM    F@RPLFL,F@RUPD     ALREADY SET UP FOR UPDATE?\n         JNZ   READ040            YES, NO CHANGE TO RPL NEEDED     @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(UPD),MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            DID MODCB WORK?\n         JZ    READ030            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ020'\n         MVC   VSAMEREA,=CL2'00'\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         BRAS  R14,GETREG0        CHECK FOR REASON CODE IN REGISTER 0\n         SETMSG MSG=M$BADUPD\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD030  DS    0H\n         OI    F@RPLFL,F@RUPD     RESET FLAG TO INDICATE UPDATE\n         EJECT\nREAD040  DS    0H        -- BRANCH TABLE FOR READ REQUEST TYPE --\n         CLC   =CL11'READGENERIC',0(R5)\n         JE    READ100                                             @PJF\n         CLC   =CL8'READNEXT',0(R5)\n         JE    READ200                                             @PJF\n         CLC   =CL8'READPREV',0(R5)\n         JE    READ300                                             @PJF\n         CLC   =CL8'READLAST',0(R5)\n         JE    READ400                                             @PJF\n         J     READ500                                             @PJF\n         EJECT\nREAD100  DS    0H         -- GENERIC READ --\n         TM    F@OPENFL,F@OKSDS   IS FILE A KSDS?\n         JO    READ102            YES, GENERIC READ IS ALLOWED     @PJF\n         SETMSG MSG=M$NOGEN       OTHERWISE, SET ERROR MESSAGE\n         J     READ999            AND EXIT ROUTINE                 @PJF\n         SPACE\nREAD102  DS    0H\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?\n         JE    READ104            NO, DO ERROR STUFF               @PJF\n         LTR   R3,R3              WAS ARG LENGTH ZERO?\n         JZ    READ104            YES, DO ERROR STUFF              @PJF\n         J     READ106            KEY IS OK, CONTINUE PROCESSING   @PJF\n         SPACE\nREAD104  DS    0H\n         SETMSG MSG=M$BADARG      INVALID ARGUMENT\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD106  DS    0H\n         TM    F@RPLFL,F@RDIR     IS RPL SET UP FOR DIRECT READ?\n         JO    READ108            YES, GO SET UP GENERIC KEY       @PJF\n         BRAS  R14,TODIR          CHANGE TO DIRECT READ\n         LTR   R15,R15            IF R15 IS ZERO\n         JZ    READ108            RESET WAS SUCCESSFUL             @PJF\n         J     READ999            ELSE, EXIT IMMEDIATELY           @PJF\n         SPACE\nREAD108  DS    0H\n         XC    F@RPLARG,F@RPLARG  CLEAR OUR ARGUMENT/KEY AREA\n         ST    R3,F@ARGLEN        SAVE LENGTH OF ARGUMENT\n         BCTR  R3,0               DECREMENT FOR EXECUTED MVC\n         EX    R3,ARGMVC          COPY KEY TO OUR AREA\n         TM    F@RPLFL,F@RFKS+F@RKEQ   RPL SET UP FOR FULL KEY?\n         JZ    READ600            NO, ALREADY SET FOR GENERIC, GET @PJF\n         SPACE\n         L     R2,F@ARGLEN        ACTUAL LENGTH OF GENERIC KEY\n         MODCB RPL=(R4),OPTCD=(KGE,GEN),KEYLEN=(R2),                   X\n               MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    READ110            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ102'      SET LABEL IN ERROR MSG\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD110  DS    0H\n         NI    F@RPLFL,X'FF'-(F@RFKS+F@RKEQ)    RESET OUR FLAG BITS\n         J     READ600            GO GET RECORD                    @PJF\n         EJECT\nREAD200  DS    0H         -- READ NEXT RECORD --\n*\n*  A \"KEY\" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL\n*\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?\n         JNE   READ202            YES, CONTINUE                    @PJF\n         SPACE\n         SETMSG MSG=M$BADARG      INVALID ARGUMENT\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD202  DS    0H\n         TM    F@RPLFL,F@RSEQ+F@RFWD  SET FOR SEQ / FWD ?\n         JO    READ600            YES, READY TO GET RECORD         @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(SEQ,FWD),                               X\n               MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            IF MODCB WORKED (RPL IS RESET)\n         JZ    READ204            RESET OUR FLAG AND GO GET RECORD @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ204'   ELSE, SET ERROR MSG\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD204  DS    0H\n         OI    F@RPLFL,F@RSEQ+F@RFWD     RESET FLAG\n         NI    F@RPLFL,X'FF'-F@RDIR\n         J     READ600            GO GET RECORD                    @PJF\n         EJECT\nREAD300  DS    0H         -- READ PREVIOUS RECORD --\n*\n*  A \"KEY\" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL\n*\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?\n         JNE   READ302            YES, CONTINUE                    @PJF\n         SPACE\n         SETMSG MSG=M$BADARG      INVALID ARGUMENT\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD302  DS    0H\n         CLI   F@POINT,F@POINTY   HAS FILE POSITIONING BEEN DONE?\n         JE    READ304            YES, CONTINUE                    @PJF\n         SPACE\n         SETMSG MSG=M$NOPOS       SET MESSAGE - NO PREVIOUS \"STARTBWD\"\n         J     READ999                                             @PJF\n         SPACE\nREAD304  DS    0H\n         TM    F@RPLFL,F@RSEQ     SET FOR SEQUENTIAL ACCESS?\n         JZ    READ306            NO, NEED TO ISSUE THE MODCB      @PJF\n         TM    F@RPLFL,F@RFWD     SET UP FOR FORWARD PROCESSING?\n         JZ    READ600            NO, CAN PROCEED DIRECTLY TO GET R@PJF\n         SPACE\nREAD306  DS    0H\n         MODCB RPL=(R4),OPTCD=(SEQ,BWD),                               X\n               MF=(G,MODCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            IF MODCB WORKED\n         JZ    READ308            RESET OUR FLAG AND GO GET RECORD @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ306'   ELSE, SET ERROR MSG\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD308  DS    0H\n         NI    F@RPLFL,X'FF'-(F@RFWD+F@RDIR)  NOW BACKWARD & NOT DIR\n         OI    F@RPLFL,F@RSEQ           IS NOW SEQUENTIAL PROCESSING\n         J     READ600            GO GET RECORD                    @PJF\n         EJECT\nREAD400  DS    0H           -- READ LAST RECORD --\n*\n*  NOTE: THE NORMAL \"GET\" PROCESSING (AT LABEL READ600) IS NOT DONE\n*        FOR THIS REQUEST SINCE THE RPL NEEDS TO BE SWITCHED BACK TO\n*        ARD (USER'S ARGUMENT GOVERNS REQUEST) AFTER THE GET IS DONE.\n*  A \"KEY\" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL\n*\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?\n         JNE   READ402            YES, CONTINUE                    @PJF\n         SPACE\n         SETMSG MSG=M$BADARG      INVALID ARGUMENT\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD402  DS    0H\n         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?\n         JO    READ404            YES, CONTINUE                    @PJF\n         SPACE\n         BRAS  R14,TODIR          NO, CHANGE TO DIRECT PROCESSING\n         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL\n         JZ    READ404                                             @PJF\n         J     READ999            ELSE, JUST GIVE UP               @PJF\n         SPACE\nREAD404  DS    0H\n         MODCB RPL=(R4),OPTCD=(BWD,LRD),                               X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    READ406            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ404'      NO, SET ERROR MESSAGE LABEL\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD406  DS    0H\n         NI    F@RPLFL,X'FF'-F@RFWD   RESET OUR FLAG\n         GET   RPL=(R4)\n         SPACE\n         LTR   R15,R15            SUCCESSFUL GET?\n         JZ    READ408                                             @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ406'\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD408  DS    0H\n         MODCB RPL=(R4),OPTCD=(ARD),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    READ800            YES, GO SET RECORD AS A REXX VARI@PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ408'      NO, SET ERROR MESSAGE LABEL\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         EJECT\nREAD500  DS    0H           -- DIRECT READ --\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?\n         JE    READ502            NO, DO ERROR STUFF               @PJF\n         LTR   R3,R3              WAS KEY LENGTH ZERO?\n         JZ    READ502            YES, DO ERROR STUFF              @PJF\n         J     READ504            KEY ARGUMENT OK, CONTINUE        @PJF\n         SPACE\nREAD502  DS    0H\n         SETMSG MSG=M$BADARG      INVALID ARGUMENT\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD504  DS    0H\n         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?\n         JO    READ506            YES, CONTINUE                    @PJF\n         SPACE\n         BRAS  R14,TODIR          NO, GO CHANGE TO DIRECT PROCESSING\n         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL\n         JZ    READ506                                             @PJF\n         J     READ999            OTHERWISE, QUIT                  @PJF\n         SPACE\nREAD506  DS    0H\n         XC    F@RPLARG,F@RPLARG  CLEAR KEY AREA\n         ST    R3,F@ARGLEN        SAVE KEY (ARGUMENT) LENGTH\n         BCTR  R3,0               DECR LENGTH FOR EXECUTE\n         EX    R3,ARGMVC          COPY KEY\n         TM    F@RPLFL,F@RFKS+F@RKEY   SET UP FOR FULL/EQUAL KEY?\n         JO    READ510            YES, CHECK FOR DATASET TYPE      @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(KEQ,FKS),                               X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    READ508            YES, RESET OUR FLAG & GET RECORD @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ506'   NO, SET ERROR MESSAGE LABEL\n         J     READ990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nREAD508  DS    0H\n         OI    F@RPLFL,F@RFKS+F@RKEQ   RESET OUR FLAG BITS\n         SPACE\nREAD510  DS    0H\n         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS\n         JO    READ600            READY TO GET RECORD              @PJF\n         SPACE\n         BRAS  R14,CONVKEY        ELSE, CONVERT \"KEY\"\n         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE\n         JNZ   READ999            ELSE, FALL-THRU TO READ600       @PJF\n         EJECT\nREAD600  DS    0H   -- PERFORM GET MACRO & CHECK RESULT --\n         GET   RPL=(R4)\n         SPACE\n         LTR   R15,R15            SUCCESSFUL GET?\n         JZ    READ800            YES, SET RECORD AS A REXX VARIABL@PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ600'\n         BRAS  R14,GETFDBK        GO GET FEEDBACK WORD\n         SPACE\n         CLC   VSAMEREA,FDBKNF    NOT FOUND?\n         JNE   READ602            NO, TRY NEXT POSSIBILITY         @PJF\n         SETMSG MSG=M$NOTFND      YES, SET MESSAGE\n         J     READ999            AND CONSIDER READ \"SUCCESSFUL\"   @PJF\n         SPACE\nREAD602  DS    0H\n         CLC   VSAMEREA,FDBKEOF   END OF FILE\n         JNE   READ604            NO, MUST BE SOME HOSEUP          @PJF\n         SETMSG MSG=M$EOF         YES, SET MESSAGE\n         J     READ999            AND CONSIDER READ \"SUCCESSFUL\"   @PJF\n         SPACE\nREAD604  DS    0H\n         SETMSG MSG=M$BADFUN      READ FAILED\n         J     READ999            EXIT ROUTINE                     @PJF\n         EJECT\nREAD800  DS    0H      -- RECORD OBTAINED, SET REXX VARIABLE --\n         LA    R2,FULLWRK1\n         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(RECLEN),           X\n               MF=(G,SHOWCB_PARMLIST)\n         LTR   R15,R15            SHOWCB WORKED?\n         JZ    READ802            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'READ800'\n         CVD   R15,DBLWRK         SET R.C. FROM SHOWCB\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         CVD   R0,DBLWRK          SET REASON CODE FROM SHOWCB\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         SETMSG MSG=M$NORLEN\n         J     READ999                                             @PJF\n         SPACE\nREAD802  DS    0H\n         LA    R8,ARGTABLE_NEXT   GET LAST ARGUMENT\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR\n         C     R2,=X'FFFFFFFF'    WAS RECORD VARIABLE NAME SUPPLIED?\n         JNE   READ804            YES, GO SET VARIABLE             @PJF\n         SPACE\n         LA    R2,RECVARDF        NO, USE OUR DEFAULT\n         LA    R3,L'RECVARDF\n         SPACE\nREAD804  DS    0H\n         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK\n         USING SHVBLOCK,R6        SET ADDRESSABILITY\n         STM   R2,R3,SHVNAMA      STORE -> & LENGTH OF VARIABLE NAME\n         MVC   SHVVALL,FULLWRK1   LENGTH OF RECORD AREA\n         MVC   SHVVALA,F@RECBUF   ADDRESS OF RECORD AREA\n         MVI   SHVCODE,SHVSTORE   NEED TO STORE THIS VARIABLE\n         L     R15,IRXEXCO@       ADDRESS OF REXX VARIABLE ROUTINE\n         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF    CHECK ERROR BITS\n         JZ    READ999            IF VAR STORED SUCCESSFULLY, DONE @PJF\n         SPACE\n         SETMSG MSG=M$NOREC       SET ERROR MESSAGE\n         J     READ999            EXIT ROUTINE                     @PJF\n         SPACE\nREAD990  DS    0H     -- GENERAL ERROR LOGIC FOR MODCB FAILURE --\n         BRAS  R14,GETREG0        GET REASON CODE\n         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT\n         SPACE\nREAD999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY\n         EJECT\nSTAR000  DS    0H\n*\n* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    STAR010            READY TO GO                      @PJF\n         SPACE\n         SETMSG MSG=M$NOACB\n         NTERROR REQ=RETRIEVE,SYM=STAR000,GOTO=STAR999\n         SPACE\nSTAR010  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         SPACE\nSTAR020  DS    0H\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR     WAS KEY SUPPLIED?\n         C     R2,=X'FFFFFFFF'\n         JE    STAR030            NO, DO ERROR STUFF               @PJF\n         LTR   R3,R3              WAS IT'S LENGTH ZERO?\n         JZ    STAR030            YES, DO ERROR STUFF              @PJF\n         J     STAR040            KEY WAS OK, CONTINUE             @PJF\n         SPACE\nSTAR030  DS    0H\n         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE\n         J     STAR999            AND EXIT ROUTINE                 @PJF\n         SPACE\nSTAR040  DS    0H\n         XC    F@RPLARG,F@RPLARG  CLEAR OUT ARGUMENT AREA\n         ST    R3,F@ARGLEN        SAVE KEY LENGTH\n         BCTR  R3,0               DECREMENT FOR EXECUTE\n         EX    R3,ARGMVC          COPY KEY\n         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS\n         JO    STAR050            GO CHECK REQUEST                 @PJF\n         SPACE\n         BRAS  R14,CONVKEY        ELSE, CONVERT \"KEY\"\n         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE\n         JNZ   STAR999            ELSE, FALL-THRU TO STAR050       @PJF\n         EJECT\nSTAR050  DS    0H\n*\n* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> FWARPL\n*\n         LA    R4,FWARPL\n         CLC   =CL8'STARTFWD',0(R5)\n         JE    STAR100                                             @PJF\n         CLC   =CL8'STARTBWD',0(R5)\n         JE    STAR200                                             @PJF\n         SPACE\n         SETMSG MSG=M$BADARG\n         J     STAR999                                             @PJF\n         SPACE\nSTAR100  DS    0H           -- POSITION FOR FORWARD READING --\n         TM    F@RPLFL,F@RSEQ+F@RFWD    SET FOR SEQUENTIAL/FWD?\n         JNO   STAR102            NO, NEED TO ISSUE MODCB          @PJF\n         TM    F@RPLFL,F@RKEQ+F@RFKS    SET FOR KEY = / FULL KEY?\n         JNZ   STAR102            YES, NEED TO ISSUE MODCB         @PJF\n         J     STAR600            READY TO ISSUE POINT MACRO       @PJF\n         SPACE\nSTAR102  DS    0H\n         L     R2,F@ARGLEN        ARGUMENT (KEY LENGTH)\n         MODCB RPL=(R4),OPTCD=(SEQ,FWD,KGE,GEN),KEYLEN=(R2),           X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    STAR104            YES, RESET OUR FLAGS & DO POINT  @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL\n         BRAS  R14,GETREG0        OBTAIN REASON CODE\n         SETMSG MSG=M$BADFUN      FUNCTION FAILED\n         J     STAR999                                             @PJF\n         SPACE\nSTAR104  DS    0H\n         OI    F@RPLFL,F@RSEQ+F@RFWD     SET OUR FLAGS\n         NI    F@RPLFL,X'FF'-(F@RDIR+F@RKEQ+F@RFKS)\n         J     STAR600            READY TO ISSUE POINT MACRO       @PJF\n         EJECT\nSTAR200  DS    0H      -- POSITION FOR BACKWARD READING --\n         TM    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS  SEQ / KEY = / FULL KEY?\n         JNO   STAR202            NO, NEED TO ISSUE MODCB          @PJF\n         TM    F@RPLFL,F@RFWD     FORWARD?\n         JO    STAR202            YES, NEED TO ISSUE MODCB         @PJF\n         J     STAR600            READY TO ISSUE POINT MACRO       @PJF\n         SPACE\nSTAR202  DS    0H\n         MODCB RPL=(R4),OPTCD=(SEQ,BWD,KEQ,FKS),                       X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB SUCCESSFUL?\n         JZ    STAR204            YES, RESET OUR FLAGS & DO POINT  @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL\n         BRAS  R14,GETREG0        OBTAIN REASON CODE\n         SETMSG MSG=M$BADFUN      FUNCTION FAILED\n         J     STAR999                                             @PJF\n         SPACE\nSTAR204  DS    0H\n         OI    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS     SET OUR FLAGS\n         NI    F@RPLFL,X'FF'-(F@RDIR+F@RFWD)\n         J     STAR600            READY TO ISSUE POINT MACRO       @PJF\n         EJECT\nSTAR600  DS    0H     -- ISSUE POINT FOR FILE POSITIONING --\n         POINT RPL=(R4)\n         SPACE\n         LTR   R15,R15            POINT SUCCESSFUL?\n         JZ    STAR900            YES, ALL DONE                    @PJF\n         SPACE\n         MVI   F@POINT,F@POINTN   NO FILE POSITIONING\n         BRAS  R14,GETFDBK        GO GET FEEDBACK WORD\n         SPACE\n         CLC   VSAMEREA,FDBKEOF   WAS IT AN \"END OF FILE\"?\n         JNE   STAR602            NO, TRY NEXT POSSIBILITY         @PJF\n         SPACE\n         SETMSG MSG=M$EOF         YES, SET MESSAGE\n         J      STAR999           CONSIDER START \"SUCCESSFUL\"      @PJF\n         SPACE\nSTAR602  DS    0H\n         CLC   VSAMEREA,FDBKNF    WAS IT A \"NOT FOUND\"?\n         JNE   STAR604            NO, MUST BE SOME GENUINE HOSEUP  @PJF\n         SPACE\n         SETMSG MSG=M$BWDNF       YES, SET MESSAGE\n         J      STAR999           CONSIDER START \"SUCCESSFUL\"      @PJF\n         SPACE\nSTAR604  DS    0H\n         MVC   VSAMELAB,=CL8'STAR604'   POINT GOT AN UNEXPECTED ERROR\n         SETMSG MSG=M$BADFUN      SET MESSAGE\n         J     STAR999            EXIT                             @PJF\n         SPACE\nSTAR900  DS    0H\n         MVI   F@POINT,F@POINTY   FILE POSITIONING HAS BEEN DONE\n         SPACE 2\nSTAR999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         EJECT\nWRIT000  DS    0H\n*\n* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    WRIT010            READY TO GO                      @PJF\n         SPACE\n         SETMSG MSG=M$NOACB\n         NTERROR REQ=RETRIEVE,SYM=WRIT000,GOTO=WRIT999\n         SPACE\nWRIT010  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?\n         JO    WRIT020            YES                              @PJF\n         SPACE\n         SETMSG MSG=M$NOOUT       NO, SET MESSAGE\n         J     WRIT999            AND EXIT                         @PJF\n         SPACE\nWRIT020  DS    0H\n*\n* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> FWARPL\n*\n         LA    R4,FWARPL\n         TM    F@RPLFL,F@RUPD     SET FOR UPDATE?\n         JZ    WRIT100            NO, READY TO DO RECORD STUFF     @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(NUP),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    WRIT030            YES, RESET OUR FLAGS, ETC.       @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'WRIT020'\n         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nWRIT030  DS    0H\n         NI    F@RPLFL,X'FF'-F@RUPD     RESET FLAG & FALL-THRU\n         EJECT\nWRIT100  DS    0H\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT\n         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?\n         JNE   WRIT110            YES, CONTINUE                    @PJF\n         SPACE\n         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE\n         J     WRIT999            EXIT ROUTINE                     @PJF\n         SPACE\nWRIT110  DS    0H\n         LTR   R3,R3              IF ARG IS NONNULL,\n         JNZ   WRIT130            COPY \"KEY\" INTO OUR AREA         @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(SEQ),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    WRIT120            YES, RESET OUR FLAGS, ETC.       @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'WRIT110'\n         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nWRIT120  DS    0H\n         OI    F@RPLFL,F@RSEQ     NOW SET FOR SEQUENTIAL ACCESS\n         NI    F@RPLFL,X'FF'-F@RDIR   NO LONGER SET FOR DIRECT\n         J     WRIT140            SKIP OVER KEY COPY               @PJF\n         SPACE\nWRIT130  DS    0H\n         XC    F@RPLARG,F@RPLARG  ELSE CLEAR OUT OUR COPY OF THE \"KEY\"\n         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER\n         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE\n         EX    R3,ARGMVC          COPY ARGUMENT TO OUR \"KEY\" AREA\n         TM    F@RPLFL,F@RDIR     SET FOR DIRECT ACCESS?\n         JO    WRIT140            YES, CONTINUE                    @PJF\n         SPACE\n         BRAS  R14,TODIR          NO, SWITCH TO DIRECT\n         LTR   R15,R15            IF THAT FAILED\n         JNZ   WRIT999            JUST GIVE UP                     @PJF\n         SPACE\nWRIT140  DS    0H\n         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH\n         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?\n         JNE   WRIT150            NO, PICK UP REC AREA VARIABLE NAM@PJF\n         SPACE\n         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC\n         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH\n         EJECT\nWRIT150  DS    0H\n         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK\n         USING SHVBLOCK,R6        SET ADDRESSABILITY\n         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME\n         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE\n         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA\n         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE\n         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE\n         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV\n         JZ    WRIT160            DID WE GET THE VARIABLE OK?      @PJF\n         SPACE\n         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT\n         J     WRIT999                                             @PJF\n         SPACE\nWRIT160  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -\n         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?\n         JZ    WRIT170            NO, READY TO PUT RECORD          @PJF\n         SPACE\n         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE\n         J     WRIT999            AND EXIT ROUTINE                 @PJF\n         SPACE\nWRIT170  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --\n         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)\n         MODCB RPL=(R4),RECLEN=(R2),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB WORKED?\n         JZ    WRIT180            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'WRIT170'   NO, SET LABEL IN ERROR MSG\n         J     WRIT990            DO GENERAL MODCB FAILURE LOGIC   @PJF\n         SPACE\nWRIT180  DS    0H\n         TM    F@OPENFL,F@ORRDS   IS FILE AN RRDS?\n         JZ    WRIT190            NO, READY TO PUT RECORD          @PJF\n         TM    F@RPLFL,F@RSEQ     SEQUENTIAL ACCESS?\n         JO    WRIT190            YES, NO KEY TO CONVERT           @PJF\n         SPACE\n         BRAS  R14,CONVKEY        ELSE, CONVERT KEY\n         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE\n         JNZ   WRIT999            ELSE, FALL-THRU & PUT RECORD     @PJF\n         EJECT\nWRIT190  DS    0H\n         PUT   RPL=(R4)           WRITE THE RECORD\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    WRIT999            ALL DONE                         @PJF\n         SPACE\n         BRAS  R14,GETFDBK        GET FEEDBACK WORD\n         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE\n         JNE   WRIT200            NO, TRY NEXT POSSIBILITY         @PJF\n         SETMSG MSG=M$DUPL        YES, SET MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nWRIT200  DS    0H\n         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?\n         JNE   WRIT210            NO, TRY NEXT POSSIBILITY         @PJF\n         SETMSG MSG=M$BADRL       YES, SET MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nWRIT210  DS    0H\n         MVC   VSAMELAB,=CL8'WRIT210'   SET LABEL IN ERROR MSG\n         SETMSG MSG=M$BADFUN      BAD FUNCTION\n         J     WRIT999            EXIT ROUTINE                     @PJF\n         SPACE\nWRIT990  DS    0H        -- GENERAL LOGIC FOR MODCB FAILURE --\n         BRAS  R14,GETREG0        OBTAIN FEEDBACK\n         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT\n         SPACE\nWRIT999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY\n         EJECT\nREWR000  DS    0H\n*\n* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    REWR010            READY TO GO                      @PJF\n         SPACE\n         SETMSG MSG=M$NOACB\n         NTERROR REQ=RETRIEVE,SYM=REWR000,GOTO=REWR999\n         SPACE\nREWR010  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?\n         JO    REWR020            YES                              @PJF\n         SPACE\n         SETMSG MSG=M$NOOUT       NO, SET MESSAGE\n         J     REWR999            AND EXIT                         @PJF\n         SPACE\nREWR020  DS    0H\n*\n* FROM THIS POINT THRU THE REST OF THE REWRITE LOGIC, R4 -> FWARPL\n* AND R6 -> SHARED VARIABLE BLOCK\n*\n         LA    R4,FWARPL\n         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK\n         USING SHVBLOCK,R6        SET ADDRESSABILITY\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT\n         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?\n         JE    REWR030            NO, DO ERROR STUFF               @PJF\n         LTR   R3,R3              IS KEY ARGUMENT LENGTH ZERO?\n         JZ    REWR040            YES, ENSURE IT'S AN ESDS         @PJF\n         J     REWR050            KEY IS OK, CONTINUE              @PJF\n         SPACE\nREWR030  DS    0H\n         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         EJECT\nREWR040  DS    0H        -- ZERO LENGTH ONLY ALLOWED FOR AN ESDS --\n         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?\n         JO    REWR060            YES - IT'S OK - SKIP KEY STUFF   @PJF\n         SPACE\n         SETMSG MSG=M$KEYZER      SET ZERO KEY LENGTH MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nREWR050  DS    0H\n         XC    F@RPLARG,F@RPLARG  CLEAR OUT OUR COPY OF THE \"KEY\"\n         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER\n         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE\n         EX    R3,ARGMVC          COPY ARGUMENT TO OUR \"KEY\" AREA\n         SPACE\nREWR060  DS    0H        -- CHECK FOR RECORD VARIABLE NAME --\n         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH\n         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?\n         JNE   REWR070            NO, PICK UP REC AREA VARIABLE NAM@PJF\n         SPACE\n         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC\n         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH\n         SPACE\nREWR070  DS    0H\n         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME\n         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE\n         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA\n         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE\n         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE\n         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST),    @PJFX\n               LINKINST=BASR                                       @PJF\n         SPACE\n         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV\n         JZ    REWR080            DID WE GET THE VARIABLE OK?      @PJF\n         SPACE\n         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT\n         J     REWR999                                             @PJF\n         SPACE\nREWR080  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -\n         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?\n         JZ    REWR100            NO, READY TO PUT RECORD          @PJF\n         SPACE\n         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE\n         J     REWR999            AND EXIT ROUTINE                 @PJF\n         EJECT\nREWR100  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --\n         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)\n         MODCB RPL=(R4),RECLEN=(R2),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            MODCB WORKED?\n         JZ    REWR110            YES, CONTINUE                    @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'REWR100'   NO, SET LABEL IN ERROR MSG\n         BRAS  R14,GETREG0        GET FEEDBACK FROM REGISTER 0\n         SETMSG MSG=M$BADFUN      INDICATE FAILURE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nREWR110  DS    0H\n         PUT   RPL=(R4)           WRITE THE RECORD\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    REWR999            CONTINUE                         @PJF\n         SPACE\n         BRAS  R14,GETFDBK        GET FEEDBACK WORD\n         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE\n         JNE   REWR120            NO, TRY NEXT POSSIBILITY         @PJF\n         SETMSG MSG=M$DUPL        YES, SET MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nREWR120  DS    0H\n         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?\n         JNE   REWR130            NO, TRY NEXT POSSIBILITY         @PJF\n         SETMSG MSG=M$BADRL       YES, SET MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE\nREWR130  DS    0H\n         MVC   VSAMELAB,=CL8'REWR130'   SET LABEL IN ERROR MSG\n         SETMSG MSG=M$BADFUN      BAD FUNCTION\n         J     REWR999            EXIT ROUTINE                     @PJF\n         SPACE 2\nREWR999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY\n         EJECT\nDELE000  DS    0H\n*\n* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)\n*\n         ST    R14,RETURNTO       SAVE RETURN POINT\n         BRAS  R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN\n         SPACE\n         LTR   R15,R15            IF TOKEN EXISTS\n         JZ    DELE010            READY TO GO                      @PJF\n         SPACE\n         SETMSG MSG=M$NOACB\n         NTERROR REQ=RETRIEVE,SYM=DELE000,GOTO=DELE999\n         SPACE\nDELE010  DS    0H\n         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA\n         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?\n         JO    DELE020            YES                              @PJF\n         SPACE\n         SETMSG MSG=M$NOOUT       NO, SET MESSAGE\n         J     DELE999            AND EXIT                         @PJF\n         SPACE\nDELE020  DS    0H\n         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?\n         JZ    DELE030            NO, OK TO CONTINUE               @PJF\n         SPACE\n         SETMSG MSG=M$NOESDS      YES, IT IS - THIS FUNCTION NOT\n         J     REWR999            ALLOWED FOR AN ESDS, SET MSG&EXIT@PJF\n         SPACE\nDELE030  DS    0H\n         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT\n         C     R2,=X'FFFFFFFF'    IF KEY ARGUMENT EXISTS, DO ERASE\n         JNE   DELE100            (RECORD AREA ARGUMENT IS IGNORED)@PJF\n         SPACE\n         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE\n         J     REWR999            EXIT ROUTINE                     @PJF\n         EJECT\nDELE100  DS    0H\n         LA    R4,FWARPL\n         ERASE RPL=(R4)           ERASE THE RECORD\n         LTR   R15,R15            IF ERASE WAS SUCCESSFUL\n         JZ    DELE999            EXIT ROUTINE                     @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'DELE100'   ERASE FAILED, SET LABEL\n         BRAS  R14,GETFDBK        GET FEEDBACK WORD\n         CLC   VSAMEREA,FDBKNOGE  ERROR WAS \"NO PREVIOUS GET\"?\n         JNE   DELE110            NO, INDICATE GEN FUNCTION FAILURE@PJF\n         SPACE\n         SETMSG MSG=M$NOGET       SET NO PREVIOUS GET MESSAGE\n         J     DELE999            EXIT ROUTINE                     @PJF\n         SPACE\nDELE110  DS    0H\n         SETMSG MSG=M$BADFUN      FUNCTION FAILED\n         SPACE 2\nDELE999  DS    0H\n         L     R14,RETURNTO       GET RETURN POINT\n         BR    R14                EXIT & RETURN TO MAINLINE\n         EJECT\nTODIR    DS    0H         -- CHANGE RPL TO DIRECT READ --\n*\n* ANY NON-ZERO VALUE IN R15 UPON EXIT INDICATES TO THE CALLER THAT\n* THIS ROUTINE DETECTED A PROBLEM, AND FURTHER PROCESSING IS PROBABLY\n* NOT A GOOD IDEA\n*\n* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!\n*\n         ST    R14,LVL1R14        SAVE RETURN POINT\n         SR    R15,R15            CLEAR R15\n         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?\n         JO    TODIR100           YES, MODIFY ONLY PROCESSING TYPE @PJF\n         SPACE\n         MODCB RPL=(R4),OPTCD=(DIR,NSP),                               X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    TODIR200           YES, RESET OUR FLAGS             @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'TODIR'\n         J     TODIR900           DO REST OF ERROR PROCESSING      @PJF\n         SPACE\nTODIR100 DS    0H\n         MODCB RPL=(R4),OPTCD=(DIR),                                   X\n               MF=(G,MODCB_PARMLIST)\n         LTR   R15,R15            SUCCESSFUL?\n         JZ    TODIR200           YES, GO RESET OUR FLAG           @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'TODIR200'\n         J     TODIR900           DO REST OF ERROR PROCESSING      @PJF\n         SPACE\nTODIR200 DS    0H\n         OI    F@RPLFL,F@RDIR     RESET OUR FLAG - DIRECT PROCESSING\n         NI    F@RPLFL,X'FF'-F@RSEQ       TURN OFF SEQUENTIAL FLAG\n         J     TODIR999           ALL DONE, EXIT ROUTINE           @PJF\n         SPACE\nTODIR900 DS    0H         -- ERROR MODIFYING A CONTROL BLOCK --\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         BRAS  R14,GETREG0        GET REASON CODE FROM REGISTER 0\n         SETMSG MSG=M$BADDSW      SET BAD RESULT CODE & FALL-THRU\n         SPACE\nTODIR999 DS    0H\n         L     R14,LVL1R14        GET RETURN POINT\n         BSM   0,R14              EXIT & RETURN TO CALLER\n         EJECT\nRTRVTOK0 DS    0H\n*\n*  RETRIEVES THE NAME / TOKEN PAIR.  CALLER MUST CHECK FOR ERRORS -\n*  R15 IS LEFT INTACT. REL 2.2: BUMP THRU STORAGE TO FIND IEANTRT\n*\n         ST    R14,LVL1R14        SAVE RETURN POINT\n         L     R15,X'10'\n         L     R15,X'220'(R15,0)\n         L     R15,X'14'(R15,0)\n         L     R15,X'08'(R15,0)\n         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTRC),              X\n               LINKINST=BASR,                                      @PJFX\n               MF=(E,IEANTLST)\n         SPACE\n         L     R14,LVL1R14        GET RETURN POINT\n         BSM   0,R14              EXIT & RETURN TO CALLER\n         EJECT\nCONVKEY  DS    0H    -- CONVERT AN RRN KEY TO BINARY --\n*\n*  A NON-ZERO VALUE IN R15 INDICATES THAT THE ARGUMENT (KEY) WAS\n*  NOT NUMERIC.  THIS ROUTINE SETS THE ERROR MESSAGE.\n*\n         ST    R14,LVL1R14        SAVE RETURN POINT\n         SR    R15,R15            SET ROUTINE RETURN CODE TO ZERO\n         L     R14,F@ARGLEN       GET KEY LENGTH\n         BCTR  R14,0              DECREMENT FOR EXECUTE\n         EX    R14,ARGTRT         TEST TO ENSURE IT'S NUMERIC\n         JZ    CONVK100           IF IT WAS, CONTINUE              @PJF\n         SPACE\n         SETMSG MSG=M$NONNUM      ELSE, SET MSG (WHICH PUTS A NON-ZERO\n         J     CONVK999           VALUE IN R15 ALSO), AND EXIT ROUT@PJF\n         SPACE\nCONVK100 DS    0H\n         EX    R14,ARGPACK        PACK KEY\n         CVB   R14,DBLWRK         CONVERT TO BINARY\n         ST    R14,F@RPLARG       REPLACE ARGUMENT, THEN EXIT\n         SPACE\nCONVK999 DS    0H\n         L     R14,LVL1R14        GET RETURN POINT\n         BSM   0,R14              RETURN TO CALLER\n         EJECT\nGETFDBK  DS    0H          -- GET FDBK / SET REASON CODE --\n*\n* This routine will issue a SHOWCB to obtain the feedback fullword\n* so the reason code can be added to the error message.  This routine\n* assumes that R15 still contains the VSAM return code (probably 8).\n* The caller of this routine is responsible for setting the value of\n* VSAMELAB before the call and issuing the SETMSG macro upon return\n* from the routine.\n*\n* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!\n*\n         ST    R14,LVL1R14        SAVE RETURN POINT\n         CVD   R15,DBLWRK\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         LA    R2,FULLWRK2\n         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(FDBK),             X\n               MF=(G,SHOWCB_PARMLIST)\n         SPACE\n         LTR   R15,R15            DID SHOWCB WORK?\n         JZ    GETFDBK1           YES - GO PICK UP ERROR MESSAGE   @PJF\n         SPACE\n         MVC   VSAMELAB,=CL8'GETFDBK'   SET UP ERROR MESSAGE FIELDS\n         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB\n         UNPK  VSAMER15,HALFWRK2\n         OI    VSAMER15+1,X'F0'\n         CVD   R0,DBLWRK          SET REASON CODE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         J     GETFDBK9           EXIT SUBROUTINE                  @PJF\n         SPACE\nGETFDBK1 DS    0H\n*\n*  TO CONSIDER:  SAVE FDBK WORD IN A DISPLAYABLE FORMAT SOMEWHERE\n*\n         SR    R14,R14\n         IC    R14,BYTEWRK2       LAST BYTE OF FEEDBACK WORD\n         CVD   R14,DBLWRK         IS THE REASON CODE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         SPACE\nGETFDBK9 DS    0H\n         L     R14,LVL1R14        GET RETURN POINT\n         BSM   0,R14              EXIT & RETURN TO CALLER\n         EJECT\nGETREG0  DS    0H\n*\n* Put reason code into VSAMEMSG - this routine assumes the return code\n* from a VSAM SHOWCB, MODCB, etc., has been left intact in R15.  No\n* registers are altered by this routine, can be called from anywhere\n*\n         CH    R15,=H'4'          REASON CODE IS ONLY IN R0 WHEN THE\n         JNE   GETREG0X           VSAM R.C. IS 4                   @PJF\n         SPACE\n         CVD   R0,DBLWRK          PUT REASON CODE IN VSAM ERROR MESSAGE\n         UNPK  VSAMEREA,HALFWRK2\n         OI    VSAMEREA+3,X'F0'\n         SPACE\nGETREG0X DS    0H\n         BSM   0,R14              RETURN TO CALLER\n         SPACE\n         TITLE 'RXVSAM - L T O R G'\nCONSTANT DS    0D                 BASE FOR LTORG + CONSTANTS\n         LTORG\n         TITLE 'RXVSAM - Constants'\n         DS    0D\nNUMTAB   DC    256X'FF'           TRT TABLE FOR NUMERIC CLASS TEST\n         ORG   NUMTAB+C'0'\n         DC    10X'00'\n         ORG\n*                                                                  @PJF\n* MOVEDDNM - EXecuted MVC to copy the DDNAME argument to local stg.@PJF\n*                                                                  @PJF\n         SPACE ,                                                   @PJF\nMOVEDDNM MVC   DDNAME(0),0(R3)    EXECUTED INSTRUCTION             @PJF\n         SPACE 3                                                   @PJF\n*                                                                  @PJF\n* ARGMVC - EXecuted MVC to copy argument (key / RRN / RBA) to the  @PJF\n*          area where the RPL expects to find it.  R2 must point   @PJF\n*          to the argument source.                                 @PJF\n*                                                                  @PJF\n         SPACE ,                                                   @PJF\nARGMVC   MVC   F@RPLARG(0),0(R2)  EXECUTED INSTRUCTION             @PJF\n         SPACE 3                                                   @PJF\n*                                                                  @PJF\n* ARGTRT - EXecuted TRT to check for numeric bytes in an RRN / RBA @PJF\n*          key.                                                    @PJF\n*                                                                  @PJF\n         SPACE ,                                                   @PJF\nARGTRT   TRT   F@RPLARG(0),NUMTAB EXECUTED INSTRUCTION             @PJF\n         SPACE 3                                                   @PJF\n*                                                                  @PJF\n* ARGPACK - EXecuted PACK for converting RRN / RBA key to packed   @PJF\n*           decimal.                                               @PJF\n*                                                                  @PJF\n         SPACE ,                                                   @PJF\nARGPACK  PACK  DBLWRK,F@RPLARG(0) EXECUTED INSTRUCTION             @PJF\n*\n* COMMON FDBK REASON CODES IN CHARACTER (DECIMAL) FORMAT\n*\nFDBKEOF  DC    CL4'0004'               END OF FILE\nFDBKDUPL DC    CL4'0008'               DUPLICATE RECORD\nFDBKSEQE DC    CL4'0012'               SEQUENCE ERROR\nFDBKNF   DC    CL4'0016'               RECORD NOT FOUND\nFDBKNOGE DC    CL4'0092'               PUT OR ERASE, NO PREVIOUS GET\nFDBKBADL DC    CL4'0108'               BAD RECORD LENGTH\n*\n* MISCELLANEOUS CONSTANTS\n*\nUSCORE   DC    8C'_'              UNDERSCORES CONSTANT\nSPACES   DC    CL8' '             SPACES CONSTANT\nIRXEXLIT DC    CL8'IRXEXCOM'      PROGRAM NAME CONSTANT\nRXVSMSG@ DC    V(RXVSAMSG)        -> TO RXVSAMSG CSECT\nVMSGVAR  DC    CL19'RXVSAM_VSAMERRORMSG'     VSAM ERR MSG VAR NAME\nRMSGVAR  DC    CL16'RXVSAM_RETURNMSG'  RETURN MESSAGE VARIABLE NAME\nRECVARDF DC    CL13'RXVSAM_RECORD'     DEFAULT RECORD VARIABLE NAME\n         SPACE\nVMSGINIT DS    0X\n         DC    CL43'VSAM error, return code in register 15 was '\n         DC    CL2'00'\n         DC    CL18', reason code was '\n         DC    CL4'0000'\n         DC    CL23' (label in RXVSAM was: '\n         DC    CL8' '\n         DC    CL1')'\nVMSGLEN  EQU   *-VMSGINIT\n         SPACE\nNTMSGINI DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE\n         DC    CL44'NAME / TOKEN service error, register 15 was '\n         DC    CL2'00'\n         DC    CL14', request was '\n         DC    CL8' '\n         DC    CL23' (label in RXVSAM was: '\n         DC    CL8' '\n         DC    CL1')'\n         SPACE\n         TITLE 'RXVSAM - Local Work Area'\n*\n* This area is initialized to X'00'\n*\nLOCAL_WORKAREA DSECT\nDBLWRK   DS    0D\nFULLWRK1 DS    F\nFULLWRK2 DS    0F\nHALFWRK1 DS    H\nHALFWRK2 DS    0H\nBYTEWRK1 DS    X\nBYTEWRK2 DS    X\n         SPACE\n         DS    0D                 ALIGN ON A DOUBLEWORD\nIEANTNAM DS    0CL16              NAME FOR NAME / TOKEN PAIR\nIEANTNA1 DS    CL8                 - 1ST PART (BASED ON JOB ID)\nIEANTNA2 DS    CL8                 - 2ND PART (BASED ON FILE DD)\nIEANTTOK DS    XL16               TOKEN FOR NAME / TOKEN PAIR\n*        The 1st fullword of the token is a -> to this file's FWA\nIEANTLVL DS    A                  LEVEL FOR IEANT SERVICE\nIEANTPOP DS    A                  PERSIST OPTION FOR IEANT SERVICE\nIEANTRC  DS    F                  RETURN CODE FROM IEANT SERVICE\nIEANTLST DS    5F                 ADDR LIST FOR ABOVE 5 PARMS (CALL)\n         SPACE\nSAVEAREA DS    18F\n         SPACE\nEXCOPLST DS    4F                 PARM LIST AREA FOR IREXCOM CALL\nGENCB_PARMLIST DS  20F            PARM LIST FOR GENCB MACRO\nMODCB_PARMLIST DS  20F            PARM LIST FOR MODCB MACRO\nSHOWCB_PARMLIST DS 20F            PARM LIST FOR SHOWCB MACRO\nOPEN_PARMLIST  DS  2F             PARM LIST FOR OPEN MACRO\nCLOSE_PARMLIST DS  2F             PARM LIST FOR CLOSE MACRO\n         SPACE\nMSG@     DC    F'0'               -> TO ERROR MSG TEXT\nEFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)\nENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ\nIRXEXCO@ DC    F'0'               -> IRXEXCOM ENTRY ADDRESS\nRECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA\nRETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC\nLVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES\nNAMTOKRC DC    F'0'               R15 (R.C.) FROM NAME / TOKEN SERVICES\nTRACE@B  DC    F'0'               -> TO TRACE AREA\nTRACE@C  DC    F'0'               -> TO \"NEXT\" SLOT IN TRACE AREA\nTRACE@M  DC    F'0'               -> TO END OF TRACE AREA\nMSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)\nRECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)\nMYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH \"X\")\nDDNAME   DS    CL8                SPACE PADDED DDNAME\n         SPACE\nVSAMEMSG DS    0X                 VSAM ERROR MESSAGE\n         DS    CL43\nVSAMER15 DS    CL2\n         DS    CL18\nVSAMEREA DS    CL4\n         DS    CL23\nVSAMELAB DS    CL8\n         DS    CL1\nVSAMELEN EQU   *-VSAMEMSG\n         SPACE\nNTMSG    DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE\n         DS    CL44\nNTMSGR15 DS    CL2\n         DS    CL14\nNTREQ    DS    CL8\n         DS    CL23\nNTLABEL  DS    CL8\n         DS    CL1\nNTMSGLEN EQU   *-NTMSG\n         SPACE\n         DS    0F\nOURSHVBL DC  XL(SHVBLEN)'00'           OUR SHARED VARIABLE BLK STORAGE\n         SPACE\nLOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA\n         TITLE 'RXVSAM - File Work Area  '\nFWABLOCK DSECT\n*\n* FWABLOCK - THERE WILL BE ONE OF THESE FOR EACH OPEN VSAM DATASET.\n* The OPEN routine obtains the storage, and the CLOSE routine releases\n* it.  NAME / TOKEN services are used to manage (keep track) of this\n* block between invocations of RXVSAM.\n*\nFWA      DS    0F   --- BEGINNING OF FILE WORK AREA ---\nFWAACB   DS    XL(LEN_ACB)        OUR COPY OF CURRENT ACB\nFWAACBL  EQU   *-FWAACB           LENGTH OF AREA\n         SPACE\nFWARPL   DS    XL(LEN_RPL)        OUR COPY OF CURRENT RPL\nFWARPLL  EQU   *-FWARPL           LENGTH OF AREA\n         SPACE\nFWAFLAGS DS    0F                 FLAGS\nF@RECBUF DC    F'0'                - OUR RECORD BUFFER ADDRESS\nF@BUFLEN DC    F'0'                - LENGTH OF OUR RECORD BUFFER\nF@LRECL  DC    F'0'                - MAX RECORD LENGTH FOR THIS FILE\nF@ARGLEN DC    F'0'                - LENGTH OF KEY (ARGUMENT)\nF@OPENFL DC    X'0'                - ACB FLAGS\nF@OIN    EQU   X'80'                 - OPEN FOR INPUT   | Both flags on\nF@OOUT   EQU   X'40'                 - OPEN FOR OUTPUT  | if open I-O\nF@OSEQ   EQU   X'20'                 - FILE SET FOR SEQUENTIAL ACCESS\nF@ODIR   EQU   X'10'                 - FILE SET FOR DIRECT ACCESS\nF@O###   EQU   X'08'                 - (UNUSED BIT SETTING)\nF@OKSDS  EQU   X'04'                 - FILE IS A KSDS\nF@ORRDS  EQU   X'02'                 - FILE IS AN RRDS\nF@OESDS  EQU   X'01'                 - FILE IS AN ESDS\nF@RPLFL  DC    X'0'                - RPL FLAGS\nF@RKEY   EQU   X'80'                 - USE KEY (RRN) ARGS (OFF = ADR)\nF@RARD   EQU   X'40'                 - USE USER'S ARGS (OFF = LRD)\nF@RSEQ   EQU   X'20'                 - SEQUENTIAL ACCESS\nF@RDIR   EQU   X'10'                 - DIRECT ACCESS (MAY ALSO SET NSP)\nF@RUPD   EQU   X'08'                 - UPD (OFF = NUP {UNLESS F@RDIR})\nF@RFWD   EQU   X'04'                 - FORWARD (OFF = BWD) PROCESSING\nF@RKEQ   EQU   X'02'                 - EQUAL KEY (OFF = KGE)\nF@RFKS   EQU   X'01'                 - FULL KEY SUPPLIED (OFF = GEN)\nF@POINT  DS    X                  FILE POSITIONING IS SET\nF@POINTN EQU   X'00'                - NO\nF@POINTY EQU   X'FF'                - YES\n         DS    X\nF@RPLARG DC    XL255'00'          ARGUMENT (KEY) AREA FOR RPL\n         SPACE\n         DS    XL1\nFWALEN   EQU   *-FWA              LENGTH OF FILE WORK AREA BLOCK\nFWAEND   DS    0X                 END OF BLOCK MARKER\n*\n* End of FILE WORK AREA block\n*\n         TITLE 'RXVSAM - IRXEFPL Dsect'\n         PRINT GEN\n         IRXEFPL\n         TITLE 'RXVSAM - IRXEVALB Dsect'\n         IRXEVALB\n         TITLE 'RXVSAM - IRXARGTB Dsect'\n         IRXARGTB\n         TITLE 'RXVSAM - IRXSHVB Dsect'\n         IRXSHVB\n         TITLE 'RXVSAM - IRXENVB Dsect'                            @ANZ\n         IRXENVB                                                   @ANZ\n         TITLE 'RXVSAM - IRXEXTE Dsect'                            @ANZ\n         IRXEXTE                                                   @ANZ\n         TITLE 'RXVSAM - MISC SYSTEM DESCTS'\n         IAZJSAB DSECT=YES\n         IHAASCB\n         IHAASSB\n         IHAPSA\n         IKJTCB\n         IHASTCB ,                                                 @PJF\n         IFGRPL   DSECT=YES,AM=VSAM\nLEN_RPL  EQU   *-IFGRPL\n         IFGACB   DSECT=YES,AM=VSAM\nLEN_ACB  EQU   *-IFGACB\n         EJECT\n TITLE 'RXVSAMSG - Error Messages for RXVSAM'\n         PRINT GEN\nRXVSAMSG AMODE 31\nRXVSAMSG RMODE ANY\nRXVSAMSG GENMSGS GEN=CSECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVSAM$": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x006\\x00\\x99)\\x7f\\x01\\x03\\x05_\\tX\\x00\\x81\\x00\\x81\\x00\\x00\\xd4\\xe6\\xc9\\xd5\\xc7\\xc5\\xe2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-10-24T00:00:00", "modifydate": "2003-02-24T09:58:36", "lines": 129, "newlines": 129, "modlines": 0, "user": "MWINGES"}, "text": "Subject: RXVSAM\nDate: Mon, 25 Oct 1999 11:37:03 +1000\nFrom: \"Van Riel, Rob\" <vanrielr@anz.com>\nTo: \"'WingNotes@earthlink.net'\" <WingNotes@earthlink.net>\nCC: \"'sbgolob@attglobal.net'\" <sbgolob@attglobal.net>\n\nHi, Mark,\n\nI've changed your RXVSAM REXX function, attached below, in three ways:\n\n(1) To allow REWRITE to an ESDS (to accommodate George), I've\nchanged the code around label REWR020 more or less as you suggested.\n\n(2) We experienced S906-04 abends when doing a large number of\nwrites because the load count for module IRXEXCOM exceeded 32767.\nThis is because the code LOADed IRXEXCOM but did not DELETE it.\nI've changed the code to follow the chain\n        R0 at entry --> REXX environment block --> REXX external entry\nvector\nthinking that this would be more efficient than repeatedly LOADing\nand DELETE-ing IRXEXCOM.\n\n(3) Similarly, the name/token service routines IEANTCR, IEANTRT and\nIEANTDL were LOADed but not DELETEd. It's my impression that these\nroutines are little more than stubs for the underlying system\nservice, and therefore unlikely to change much from release to\nrelease of the operating system.  Accordingly I've changed the LOADs\nto CALLs (effectively), and resolved the references from SYS1.CSSLIB\nat program bind.\n\nChanged lines contain the identifier @ANZ in columns 68-71.\n\nLet me take this opportunity to compliment you on your code. It's\nnicely structured, which makes it very easy to change. I'm hoping\nyou can incorporate these changes, or something like them, for a\nlater CBT tape in your next incarnation as a sysprog. How's\ncomposing going?\n\nRegards, Rob\n\nRob van Riel\nSoftware Installation & Support\n1/227 Toorak Rd\nSouth Yarra VIC 3141\n* Tel   +61 3 9869 2657\n> *        Fax  +61 3 9869 3447\n* Email vanrielr@anz.com\n\n-----Original Message-----\nFrom: LynMark \"mailto:WingNotes@earthlink.net\"\nSent: Monday, October 04, 1999 12:59 PM\nTo: Levendakis, George\nSubject: Re: RXVSAM Function\n\nDear George:\n\nLooks like you caught me on that one.  It's a bug in the design.\nThere are two possible workarounds:\n\n        1. try changing the code in RXVSAM near label REWR020 -\nreplace the test under mask and branch when zero instruction (TM . .\n. BZ . . .) with just an unconditional branch to label REWR030.\n\n        2. tell RXVSAM that the file is an RRDS rather than an ESDS\n(at open), then read the records using the RBA as the \"key\", rewrite\nthe same way (supply RBA as the key) - you can try random (direct)\nread and rewrite or read next and rewrite, according to your taste.\nI believe you could even calculate the RBA of a record, since it\nshould be something like record number * length of record (or RBA of\nprevious record + record length if you're bumping thru the dataset).\nOf course, they are all zero-relative numbers (i.e. RBA of record #1\nwill be 0000), so you may have to \"adjust\" the RBA.\n\nSorry about that, really.  I've tried to think of everything, but\nobviously missed something.  I don't have access to a mainframe at\nthis time. I'm away from computer work now, following my other\ncareer as a composer.  So I won't be back in the computer world\nuntil mid-January.\n\nDo let me know how that works, I'd be curious.  Since I have a\ncouple of other improvements I'd like to incorporate, I'll add your\nrequest to my list.  Hopefully, I can do some rewriting next year\nsometime.\n\nMark Winges\nMuPro, Inc.\nWingNotes@earthlink.net\n\nAt 12:11 PM 10/4/99 +1000, you wrote:\n\nMark,\n\nI recently had the RXVSAM function installed on our system and have\nstarted using it.\n\nWhile browsing through the documentation, I noticed that error\nmessage 0026E states that REWRITE is not allowed for an ESDS.  I had\nintended to convert one of my PL/I programs which does a rewrite of\nan ESDS and of course IMS/ESA has been doing rewrites of VSAM ESDS's\nsince VSAM was invented!\n\nSo I was wondering whether the message text is accurate, since the\nonly VSAM restriction to the REWRITE of an ESDS record is that the\nLENGTH of the record MUST BE IDENTICAL to the length of the READ\nrecord.\n\nCan you please confirm that the RXVSAM function does not BLOCK the\nESDS rewrite and only returns the 0026E message if the user CHANGES\nthe record length between the READ and REWRITE requests!!\n\nThanks\n\nGeorge Levendakis\n\nDatabase Services Group\nANZ Banking Group Ltd\nMelbourne\nAustralia\n\nPhone: +61 3 9869 2311\ne-mail: levendag@anz.com\n\n\n\n    ---------------------------------------------------------------------\n                 Name: rxvsam.dat\n   rxvsam.dat    Type: DAT File\n                       (application/x-unknown-content-type-DAT_auto_file)\n             Encoding: quoted-printable\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVSET": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00S\\x01\\x06\"?\\x01\\x10\\x18?\\x12U\\x00\\xd7\\x00\\x91\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2006-08-11T00:00:00", "modifydate": "2010-07-02T12:55:53", "lines": 215, "newlines": 145, "modlines": 0, "user": "PFARLEY"}, "text": "/* REXX */\n\n/*\nThis exec will set up an ESDS VSAM file for use by the other execs that\ntest the RXVSAM function.\n*/\n\nARG user allocmethod allocvalue .\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'BACK' THEN DO\n  alloc = GetAlloc(allocmethod, allocvalue)\n  IF alloc = '?' THEN alloc = AskAlloc()\nEND\nELSE DO\n  alloc = AskAlloc()\nEND\n\ndsn = user || '.VSAMESDS'\n\nxmsg = msg('OFF')\naddress TSO \"DELETE '\"dsn\"' PURGE\"   /* ignore r.c. */\nxmsg = msg(xmsg)\n\nSAY         \"DEFINE CLUSTER (NAME('\"dsn\"') NONINDEXED RECSZ(80 80) \",\n    \"REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(5 2))\"\n\naddress TSO \"DEFINE CLUSTER (NAME('\"dsn\"') NONINDEXED RECSZ(80 80) \",\n    \"REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(5 2))\"\n\nSAY \"Return code after ESDS DEFINE was\" rc\n\n/*\nThis exec will set up a KSDS VSAM file for use by the other execs that\ntest the RXVSAM function.\n*/\n\nARG user allocmethod allocvalue .\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'BACK' THEN DO\n  alloc = GetAlloc(allocmethod, allocvalue)\n  IF alloc = '?' THEN alloc = AskAlloc()\nEND\n\ndsn = user || '.VSAMKSDS'\n\nxmsg = msg('OFF')\naddress TSO \"DELETE '\"dsn\"' PURGE\"   /* ignore r.c. */\nxmsg = msg(xmsg)\n\nSAY         \"DEFINE CLUSTER (NAME('\"dsn\"') INDEXED RECSZ(40 200) \",\n    \"KEYS(8 0) REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(3 1))\",\n    \"INDEX (NAME('\"dsn\".INDEX') TRACKS(2 1))\"\n\naddress TSO \"DEFINE CLUSTER (NAME('\"dsn\"') INDEXED RECSZ(40 200) \",\n    \"KEYS(8 0) REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(3 1))\",\n    \"INDEX (NAME('\"dsn\".INDEX') TRACKS(2 1))\"\n\nSAY \"Return code after KSDS DEFINE was\" rc\n\n/*\nThis exec will set up an RRDS VSAM file for use by the other execs that\ntest the RXVSAM function.\n*/\n\nARG user allocmethod allocvalue .\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'BACK' THEN DO\n  alloc = GetAlloc(allocmethod, allocvalue)\n  IF alloc = '?' THEN alloc = AskAlloc()\nEND\n\ndsn = user || '.VSAMRRDS'\n\nxmsg = msg('OFF')\naddress TSO \"DELETE '\"dsn\"' PURGE\"   /* ignore r.c. */\nxmsg = msg(xmsg)\n\nSAY         \"DEFINE CLUSTER (NAME('\"dsn\"') NUMBERED RECSZ(80 80) \",\n    \"REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(3 1))\"\n\naddress TSO \"DEFINE CLUSTER (NAME('\"dsn\"') NUMBERED RECSZ(80 80) \",\n    \"REUSE\" alloc \"SHAREOPTIONS(2 3)) \",\n    \"DATA (NAME('\"dsn\".DATA') CYLINDERS(3 1))\"\n\nSAY \"Return code after RRDS DEFINE was\" rc\n\nexit\n\n/* Called subroutine to get background allocation type and value */\nGetAlloc:\n  ARG argmethod, argvalue\n  IF (argmethod = '') | (argvalue = '') THEN DO\n    myddname = WORD(mysource, 4)\n    ddlegal = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@'\n    IF myddname = '?' THEN DO\n      SAY 'Allocation method and/or value not supplied and SOURCE' ,\n          'DDName = ?, expecting interactive answers'\n      allocstr = '?'\n    END\n    ELSE IF (LENGTH(myddname) > 8) | ,\n            (VERIFY(myddname, ddlegal) > 0) THEN DO\n      IF (VERIFY(myddname, '00'X, 'M') > 0) THEN DO\n        mydsname = TRANSLATE(myddname, ' ', '00'X)\n      END\n      RC = LISTDSI(\"'\"mydsname\"'\" 'SMSINFO')\n    END\n    ELSE DO\n      RC = LISTDSI(myddname 'FILE SMSINFO')\n    END\n    IF RC = 0 THEN DO\n      IF (SYSSTORCLASS = '') | ,\n         (SYMBOL('SYSSTORCLASS') <> 'VAR') THEN DO\n        argmethod = 'V'\n        argvalue = SYSVOLUME\n        SAY 'Dynamically selected (V)olume method' ,\n            'and value =' argvalue 'for file allocation'\n        allocstr = 'VOLUME('argvalue')'\n      END\n      ELSE DO\n        argmethod = 'S'\n        argvalue = SYSSTORCLASS\n        SAY 'Dynamically selected (S)torclas method' ,\n            'and value =' argvalue 'for file allocation'\n        allocstr = 'STORCLAS('argvalue')'\n      END\n    END\n    ELSE DO\n      SAY 'LISTDSI failed, RC =' RC\n      SAY 'SYSMSGLVL1 =' SYSMSGLVL1\n      SAY 'SYSMSGLVL2 =' SYSMSGLVL2\n      allocstr = '?'\n    END\n  END\n  ELSE DO\n    IF      argmethod = 'S' THEN allocstr = 'STORCLAS('argvalue')'\n    ELSE IF argmethod = 'V' THEN allocstr = 'VOLUME('argvalue')'\n    ELSE DO\n      SAY 'Please use V or S to select allocation method'\n      EXIT 8\n    END\n  END\n\n  RETURN allocstr\n\n/* Called subroutine to ask foreground allocation type and value */\nAskAlloc:\n  SAY 'Allocate files by (V)olume or by (S)torclas?'\n  PARSE UPPER PULL alctyp\n  IF LENGTH(alctyp) < 1 THEN\n    DO\n      SAY 'Please reply V or S to select allocation method'\n      EXIT 8\n    END\n\n  IF (alctyp = 'V') THEN\n    DO\n      SAY 'Please enter a 6 character volume id for definition of an ESDS'\n      PARSE UPPER PULL vol\n      IF LENGTH(vol) \\= 6 THEN\n        DO\n          SAY vol 'is not 6 characters'\n          EXIT 8\n        END\n      defval = vol\n      allocstr = \"VOLUMES(\"vol\")\"\n    END\n  ELSE\n    DO\n      SAY 'Please enter a 1-8 character STORCLAS name for ESDS definition'\n      PARSE UPPER PULL scl\n      IF (LENGTH(scl) < 1) | (LENGTH(scl) > 8) THEN\n        DO\n          SAY scl 'is not 1-8 characters'\n          EXIT 8\n        END\n      defval = scl\n      allocstr = \"STORCLAS(\"scl\")\"\n    END\n\n  RETURN allocstr\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVTESTE": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x14\\x00@\\x00\\x96'o\\x01\\x10\\x18?\\x12U\\x01\\x8d\\x00\\xaa\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@\"", "ispf": {"version": "01.20", "flags": 0, "createdate": "1996-10-02T00:00:00", "modifydate": "2010-07-02T12:55:40", "lines": 397, "newlines": 170, "modlines": 0, "user": "PFARLEY"}, "text": "/* REXX */\n\n/*\nExec to test various RXVSAM functions with an ESDS.  Assumes the ESDS\nhas already been defined by exec RXVSETE\n*/\n\nARG user\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\ndsn = user || '.VSAMESDS'\nlog# = 1                    /* log record number */\n\n/*\nADDRESS TSO \"ALLOCATE FILE(SNAPDBUG) DSNAME('\"user\".SNAPDBUG') MOD\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for SNAPDBUG with a return code of' rc\n    EXIT rc\n  END\n*/\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nADDRESS TSO \"ALLOCATE FILE(VSAMFILE) DSNAME('\"dsn\"') SHR\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for VSAMFILE with a return code of' rc\n    EXIT rc\n  END\n\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','ESDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENOUTPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nSAY LEFT('   ... working', 17) TIME('L')\n/*1*/\nchartab = 'abcdefghijk'\nrecs_written = 0\ntoday = DATE('W') DATE('N')\nDO i = 1 to 10\n  char = SUBSTR(chartab,i,1)\n  id = RIGHT(i,4,'0')\n  fillchar = COPIES(char,8)\n  my_rec = 'Record' id '   ' fillchar '   ' today TIME('L')\n  my_rec = LEFT(my_rec,80)\n  rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\n  IF rxvsam_result = 0 THEN\n    DO\n      recs_written = recs_written + 1\n    END\n  ELSE\n    DO\n      log.log# = 'WRITE failed:'\n      log# = log# + 1\n      CALL log_errors\n      SIGNAL close_and_exit\n    END\nEND\n\nlog.log# =  recs_written 'records written successfully to' dsn\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after WRITE loop) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after writing records was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\nrxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','ESDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENINPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n/*1*/\nrxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = '1st record:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'First READNEXT failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 1\nDO i = 1 to 5\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (within loop) failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nrxvsam_result = RXVSAM('READLAST','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'Last record from READLAST:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'READLAST failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nesds_RBA = calc_RBA(5, my_rec)\nrxvsam_result = RXVSAM('STARTBWD','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTBWD from record number 5 was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTBWD failed:'\n    log# = log# + 1\n    call log_errors\n  /*SIGNAL close_and_exit*/\n  END\n\nrecs_read = 0\nIF rxvsam_result = 0 THEN DO 3\n  rxvsam_result = RXVSAM('READPREV','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READPREV failed:'\n        log# = log# + 1\n        call log_errors\n        /*SIGNAL close_and_exit*/\n      END\nEND\n\nlog.log# = 'Last record read in READPREV loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READPREV test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nesds_RBA = calc_RBA(7, my_rec)\nrxvsam_result = RXVSAM('STARTFWD','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTFWD from record number 7 was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTFWD failed:'\n    log# = log# + 1\n    call log_errors\n  /*SIGNAL close_and_exit*/\n  END\n\nrecs_read = 0\nIF rxvsam_result = 0 THEN DO 3\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (after STARTFWD) failed:'\n        log# = log# + 1\n        call log_errors\n        /*SIGNAL close_and_exit*/\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT (after STARTFWD) test'\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after READ tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after read tests was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nrxvsam_result = RXVSAM('OPENIO','VSAMFILE','ESDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENIO failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nesds_RBA = calc_RBA(7, my_rec)\nrxvsam_result = RXVSAM('READ','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'READ failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('DELETE','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'DELETE failed:'\n    log# = log# + 1\n    CALL log_errors\n  /*SIGNAL close_and_exit  We expect this failure, keep going! */\n  END\nELSE\n  DO\n    log.log# = 'Record 7 successfully erased via READ + DELETE'\n    log# = log# + 1\n  END\n\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nesds_RBA = calc_RBA(2, my_rec)\nrxvsam_result = RXVSAM('READ','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'Read of record 2 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nmy_rec = SUBSTR(my_rec,1,28) today TIME('L') 'direct updated'\nmy_rec = LEFT(my_rec,80)\nrxvsam_result = RXVSAM('REWRITE','VSAMFILE',esds_RBA,'MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'REWRITE of record 2 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'Update of record 2 via READ + REWRITE was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after I-O tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\nSAY '   ... continuing' TIME('L')\n/*1*/\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','ESDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final OPENOUTPUT failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nmy_rec = 'Record 0011 was added via WRITE at' TIME('L')\nmy_rec = LEFT(my_rec,80)\nrxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'WRITE of record 11 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'WRITE of record 11 was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nSAY LEFT('   ... finishing', 17) TIME('L')\n\n/*1*/\n\nclose_and_exit: NOP\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final CLOSE failed:'\n    log# = log# + 1\n    CALL log_errors\n  END\n\nwrite_log_and_exit: NOP\nlog.log# = '   ... End of LOG'\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'FORE' THEN DO\n  SAY 'Display log? (Y/N)'\n  PULL answer\nEND\nELSE answer = 'Y'\nIF answer = 'Y' THEN\n  DO i = 1 TO log#\n    SAY log.i\n  END\n\nADDRESS TSO \"FREE FILE(VSAMFILE)\"\n/*\nADDRESS TSO \"FREE FILE(SNAPDBUG)\"\n*/\n\nEXIT\n/*1*/\nlog_errors: nop\n\nlog.log# =  '  Return msg -->  ' rxvsam_returnmsg\nlog# = log# + 1\nif rxvsam_vsamerrormsg = \"RXVSAM_VSAMERRORMSG\" then ,\n  log.log# =  '  Error msg -->    (None)'\nelse ,\n  log.log# =  '  Error msg -->   ' rxvsam_vsamerrormsg\nlog# = log# + 1\n\nRETURN\n\ncalc_RBA: nop\n\nrecno = arg(1) + 0\nrecln = length(arg(2))\n\nRETURN (recno - 1) * recln\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVTESTK": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x005\\x00\\x96'o\\x01\\x10\\x18?\\x12U\\x01\\x8d\\x01x\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "1996-10-02T00:00:00", "modifydate": "2010-07-02T12:55:35", "lines": 397, "newlines": 376, "modlines": 0, "user": "PFARLEY"}, "text": "/* REXX */\n\n/*\nExec to test various RXVSAM functions with a KSDS.  Assumes the KSDS\nhas already been defined by exec RXVSETR\n*/\n\nARG user\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\ndsn = user || '.VSAMKSDS'\nlog# = 1                    /* log record number */\n\n/*\nADDRESS TSO \"ALLOCATE FILE(SNAPDBUG) DSNAME('ZMXW009.SNAPDBUG') MOD\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for SNAPDBUG with a return code of' rc\n    EXIT rc\n  END\n*/\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nADDRESS TSO \"ALLOCATE FILE(VSAMFILE) DSNAME('\"dsn\"') SHR\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for VSAMFILE with a return code of' rc\n    EXIT rc\n  END\n\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','KSDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENOUTPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nSAY LEFT('   ... working', 17) TIME('L')\n/*1*/\nchartab = 'abcdefghijklmnopqrst'\nrecs_written = 0\ntoday = DATE('W') DATE('N')\nDO i = 1 to 20\n  char = SUBSTR(chartab,i,1)\n  fillchar = COPIES(char,4)\n  key = 'KEY:' || fillchar\n  rec_body = 'Record#' i 'was created: ' today TIME('L')\n  every5 = i // 5\n  IF every5 = 0 THEN\n    DO\n      fillchar = COPIES('+',50)\n      rec_body = rec_body 'LONG (100 bytes) RECORD' fillchar\n      rec_body = LEFT(rec_body,92)\n    END\n  ELSE\n    DO\n      rec_body = LEFT(rec_body,62)\n    END\n  my_rec = key || rec_body\n  rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\n  IF rxvsam_result = 0 THEN\n    DO\n      recs_written = recs_written + 1\n    END\n  ELSE\n    DO\n      log.log# = 'WRITE failed attempting to write record #' i ':'\n      log# = log# + 1\n      CALL log_errors\n      SIGNAL close_and_exit\n    END\nEND\n\nlog.log# =  recs_written 'records written successfully to' dsn\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after WRITE loop) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after writing records was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\nrxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENINPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n/*1*/\nrxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = '1st record:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'First READNEXT failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 1\nDO i = 1 to 5\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (within loop) failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nrxvsam_result = RXVSAM('READLAST','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'Last record:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'READLAST failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('STARTBWD','VSAMFILE','KEY:pppp','MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTBWD from key \"KEY:pppp\" was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTBWD failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 0\nDO 3\n  rxvsam_result = RXVSAM('READPREV','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READPREV failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READPREV loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READPREV test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nrxvsam_result = RXVSAM('STARTFWD','VSAMFILE','KEY:cccc','MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTFWD from key \"KEY:cccc\" was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTFWD failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 0\nDO 3\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (after STARTFWD) failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT (after STARTFWD) test'\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after READ tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after read tests was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nrxvsam_result = RXVSAM('OPENIO','VSAMFILE','KSDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENIO failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('READ','VSAMFILE','KEY:mmmm','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'READ for \"KEY:mmmm\" failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('DELETE','VSAMFILE','KEY:mmmm','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'DELETE for \"KEY:mmmm\" failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'Record \"KEY:mmmm\" successfully erased via READ + DELETE'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nrxvsam_result = RXVSAM('READ','VSAMFILE','KEY:bbbb','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'Read of \"KEY:bbbb\" failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nmy_rec = SUBSTR(my_rec,1,67) 'was updated at' TIME('L')\nmy_rec = LEFT(my_rec,100)\nrxvsam_result = RXVSAM('REWRITE','VSAMFILE','KEY:bbbb','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'REWRITE of \"KEY:bbbb\" failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'Update of \"KEY:bbbb\" via READ + REWRITE was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after I-O tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\nSAY '   ... continuing' TIME('L')\n/*1*/\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','KSDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final OPENOUTPUT failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nmy_rec = 'KEY:ffaa was added via WRITE at' TIME('L')\nmy_rec = LEFT(my_rec,50)\nrxvsam_result = RXVSAM('WRITE','VSAMFILE','KEY:ffaa','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'WRITE of \"KEY:ffaa\" failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'WRITE of \"KEY:ffaa\" was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nSAY LEFT('   ... finishing', 17) TIME('L')\n\n/*1*/\n\nclose_and_exit: NOP\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final CLOSE failed:'\n    log# = log# + 1\n    CALL log_errors\n  END\n\nwrite_log_and_exit: NOP\nlog.log# = '   ... End of LOG'\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'FORE' THEN DO\n  SAY 'Display log? (Y/N)'\n  PULL answer\nEND\nELSE answer = 'Y'\nIF answer = 'Y' THEN\n  DO i = 1 TO log#\n    SAY log.i\n  END\n\nADDRESS TSO \"FREE FILE(VSAMFILE)\"\n/*\nADDRESS TSO \"FREE FILE(SNAPDBUG)\"\n*/\n\nEXIT\n/*1*/\nlog_errors: nop\n\nlog.log# =  '  Return msg -->  ' rxvsam_returnmsg\nlog# = log# + 1\nif rxvsam_vsamerrormsg = \"RXVSAM_VSAMERRORMSG\" then ,\n  log.log# =  '  Error msg -->    (None)'\nelse ,\n  log.log# =  '  Error msg -->   ' rxvsam_vsamerrormsg\nlog# = log# + 1\n\nRETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVTESTR": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\r\\x00&\\x00\\x96'o\\x01\\x10\\x18?\\x12U\\x01\\x82\\x01m\\x00\\x00\\xd7\\xc6\\xc1\\xd9\\xd3\\xc5\\xe8@@@\"", "ispf": {"version": "01.13", "flags": 0, "createdate": "1996-10-02T00:00:00", "modifydate": "2010-07-02T12:55:26", "lines": 386, "newlines": 365, "modlines": 0, "user": "PFARLEY"}, "text": "/* REXX */\n\n/*\nExec to test various RXVSAM functions with an RRDS.  Assumes the RRDS\nhas already been defined by exec RXVSETR\n*/\n\nARG user\nIF (user = '') | (user = '*') | (user = '.') THEN user = USERID()\n\ndsn = user || '.VSAMRRDS'\nlog# = 1                    /* log record number */\n\n/*\nADDRESS TSO \"ALLOCATE FILE(SNAPDBUG) DSNAME('ZMXW009.SNAPDBUG') MOD\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for SNAPDBUG with a return code of' rc\n    EXIT rc\n  END\n*/\n\nparse source mysource\n/* SAY 'Source=\"'mysource'\"' */\nmyaddrsp = WORD(mysource, 8)\nIF (myaddrsp = 'MVS') | (myaddrsp = 'OMVS') THEN DO\n  SAY 'Execution under' myaddrsp 'is not supported, please use IKJEFT01'\n  EXIT 16\nEND\n\nADDRESS TSO \"ALLOCATE FILE(VSAMFILE) DSNAME('\"dsn\"') SHR\"\nIF rc \\= 0 THEN\n  DO\n    SAY 'Allocate failed for VSAMFILE with a return code of' rc\n    EXIT rc\n  END\n\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','RRDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENOUTPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nSAY LEFT('   ... working', 17) TIME('L')\n/*1*/\nchartab = 'abcdefghijk'\nrecs_written = 0\ntoday = DATE('W') DATE('N')\nDO i = 1 to 10\n  char = SUBSTR(chartab,i,1)\n  id = RIGHT(i,4,'0')\n  fillchar = COPIES(char,8)\n  my_rec = 'Record' id'  'fillchar'  'today TIME('L')\n  my_rec = LEFT(my_rec,80)\n  rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')\n  IF rxvsam_result = 0 THEN\n    DO\n      recs_written = recs_written + 1\n    END\n  ELSE\n    DO\n      log.log# = 'WRITE failed:'\n      log# = log# + 1\n      CALL log_errors\n      SIGNAL close_and_exit\n    END\nEND\n\nlog.log# =  recs_written 'records written successfully to' dsn\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after WRITE loop) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after writing records was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\nrxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','RRDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENINPUT failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n/*1*/\nrxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = '1st record:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'First READNEXT failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 1\nDO i = 1 to 5\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (within loop) failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nrxvsam_result = RXVSAM('READLAST','VSAMFILE',,'MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'Last record:'\n    log# = log# + 1\n    log.log# = '    ' my_rec\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'READLAST failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('STARTBWD','VSAMFILE','5','MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTBWD from record number 5 was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTBWD failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 0\nDO 3\n  rxvsam_result = RXVSAM('READPREV','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READPREV failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READPREV loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READPREV test'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n\n/*1*/\nrxvsam_result = RXVSAM('STARTFWD','VSAMFILE','7','MY_REC')\nIF rxvsam_result = 0 THEN\n  DO\n    log.log# = 'STARTFWD from record number 7 was successful'\n    log# = log# + 1\n  END\nELSE\n  DO\n    log.log# = 'STARTFWD failed:'\n    log# = log# + 1\n    call log_errors\n    SIGNAL close_and_exit\n  END\n\nrecs_read = 0\nDO 3\n  rxvsam_result = RXVSAM('READNEXT','VSAMFILE',,'MY_REC')\n    IF rxvsam_result = 0 THEN\n      DO\n        recs_read = recs_read + 1\n        ITERATE\n      END\n    ELSE\n      DO\n        log.log# = 'READNEXT (after STARTFWD) failed:'\n        log# = log# + 1\n        call log_errors\n        SIGNAL close_and_exit\n      END\nEND\n\nlog.log# = 'Last record read in READNEXT loop:'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\nlog.log# = recs_read 'records read for READNEXT (after STARTFWD) test'\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after READ tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nlog.log# = 'CLOSE after read tests was successful'\nlog# = log# + 1\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nrxvsam_result = RXVSAM('OPENIO','VSAMFILE','RRDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'OPENIO failed: '\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('READ','VSAMFILE','7','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'READ failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nrxvsam_result = RXVSAM('DELETE','VSAMFILE','7','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'DELETE failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'Record 7 successfully erased via READ + DELETE'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nSAY '   ... continuing' TIME('L')\n/*1*/\n\nrxvsam_result = RXVSAM('READ','VSAMFILE','2','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'Read of record 2 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nmy_rec = SUBSTR(my_rec,1,60) 'upd' TIME('L')\nmy_rec = LEFT(my_rec,80)\nrxvsam_result = RXVSAM('REWRITE','VSAMFILE','2','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'REWRITE of record 2 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'Update of record 2 via READ + REWRITE was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'CLOSE (after I-O tests) failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\nSAY '   ... continuing' TIME('L')\n/*1*/\nrxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','RRDS')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final OPENOUTPUT failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL write_log_and_exit\n  END\n\nmy_rec = 'Record 0012 was added via WRITE at' TIME('L')\nmy_rec = LEFT(my_rec,80)\nrxvsam_result = RXVSAM('WRITE','VSAMFILE','12','MY_REC')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# = 'WRITE of record 12 failed:'\n    log# = log# + 1\n    CALL log_errors\n    SIGNAL close_and_exit\n  END\n\nlog.log# = 'WRITE of record 12 was successful'\nlog# = log# + 1\nlog.log# = '    ' my_rec\nlog# = log# + 1\n\nSAY LEFT('   ... finishing', 17) TIME('L')\n\n/*1*/\n\nclose_and_exit: NOP\nrxvsam_result = RXVSAM('CLOSE','VSAMFILE')\nIF rxvsam_result /= 0 THEN\n  DO\n    log.log# =  'Final CLOSE failed:'\n    log# = log# + 1\n    CALL log_errors\n  END\n\nwrite_log_and_exit: NOP\nlog.log# = '   ... End of LOG'\nmyenv = SYSVAR('SYSENV')\nIF myenv = 'FORE' THEN DO\n  SAY 'Display log? (Y/N)'\n  PULL answer\nEND\nELSE answer = 'Y'\nIF answer = 'Y' THEN\n  DO i = 1 TO log#\n    SAY log.i\n  END\n\nADDRESS TSO \"FREE FILE(VSAMFILE)\"\n/*\nADDRESS TSO \"FREE FILE(SNAPDBUG)\"\n*/\n\nEXIT\n/*1*/\nlog_errors: nop\n\nlog.log# =  '  Return msg -->  ' rxvsam_returnmsg\nlog# = log# + 1\nif rxvsam_vsamerrormsg = \"RXVSAM_VSAMERRORMSG\" then ,\n  log.log# =  '  Error msg -->    (None)'\nelse ,\n  log.log# =  '  Error msg -->   ' rxvsam_vsamerrormsg\nlog# = log# + 1\n\nRETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT268/FILE268.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT268", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}