{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011508000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE206.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE206.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x06'", "DS1TRBAL": "b'p\\x18'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x8e\\x00\\x03\\x01\\x8e\\x00\\n\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$CBTDOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x8f\\x12F\\x00\\x91\\x00\\x8b\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-17T12:46:00", "lines": 145, "newlines": 139, "modlines": 0, "user": "SBGCSC"}, "text": "DCOLLECT REXX Routines    (File 206 Documentation for the CBT Tape)\n\nLinnea Nichols\nFairfax County Govt\n12000 Govt Cntr Pkwy\nFairfax, VA 22035\n703/324-2708\n\nThis file contains the following files:\n\n$$PCDOC       You are reading it\n\nREXXRTN       Contains all REXX programs. Needs to be uploaded\n              to a PS file (LRECL=80) and then unloaded to a PDS\n              using IEBUPDTE.  Sample JCL to unload is in $UPDJCL.\n              You will need to allocate a DSORG=PS, LRECL=80,\n              RECFM=FB file on MVS to upload REXXRTN to.  Then run\n              the REXUPD job, being sure to put in your own SYSIN\n              and SYSUT2 data set names.  The beginning of each\n              program includes the following: Purpose of the REXX\n              program, Input files needed, Output files created,\n              and Presort requirements.\n\nPARSRTN       Contains routines that can be used to parse record\n              types D, M, C, V, T, and B as well as the standard\n              header. Needs to be uploaded to a PS (LRECL=80) file\n              and then unloaded to a PDS using IEBUPDTE. Sample\n              JCL to unload it is in $UPDJCL.  Use the same\n              procedure as documented for REXXRTN.\n\n$UPDJCL       Sample JCL to create a PDS from the PS file you\n              uploaded.\n\nDCOLJCL       Sample JCL to run DCOLLECT collection, and create\n              most of the files used for input into the REXX\n              programs.\n\n     If you need help, have suggestions, or just want to talk\n     about DCOLLECT, please feel free to call me at 703/324-2708\n     or contact me via IBMMAIL at US5RNFRN or via INTERNET at\n     US5RNFRN@ibmmail.com\n\nThe routines included are as follows:\n\n/*                                                                    */\n/* DASDVOLS                                                           */\n/*    PURPOSE: READS TYPE V AND C RECORDS FOR VOLUME DETAIL REPORT    */\n/*             AND STORAGE GROUP SUMMARY REPORT, READS TYPE T RECORDS */\n/*             FOR DFHSM TAPE SUMMARY REPORT                          */\n/*                                                                    */\n\n/*                                                                    */\n/* DATERFSM                                                           */\n/*    PURPOSE: READS TYPE D AND M RECORDS AND PRODUCES REPORTS OF     */\n/*             DAYS FROM LAST REFERENCE FOR THE FOLLOWING:            */\n/*                L0, ML1 AND ML2 DATA COMBINED                       */\n/*                ALL L0 DATA                                         */\n/*                L0 SMS ONLY                                         */\n/*                L0 NONSMS ONLY                                      */\n/*                                                                    */\n/*             A DETAIL REPORT IS PRODUCED THAT LISTS OUT ALL         */\n/*             DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,   */\n/*             VTOCS, VVDS, PAGE AND TEMPORARY DSNS                   */\n/*                                                                    */\n\n/*                                                                    */\n/* DB2                                                                */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT ALL DB2             */\n/*             DSNS, INCLUDING VOLSER, CREATION DATE AND              */\n/*             ALLOCATED KBYTES. TOTALS ALLOCATED KBYTES.             */\n/*                                                                    */\n\n/*                                                                    */\n/* DCOLDREC                                                           */\n/*     PURPOSE: PRINTS OUT DETAIL INFORMATION FOR EVERY               */\n/*              \"D\" AND \"M\" RECORD INPUT                              */\n/*                                                                    */\n\n/*                                                                    */\n/* DSORG                                                              */\n/*    PURPOSE: BREAKOUT OF DATA SETS BY DSORG. DONE BY DSN COUNT AND  */\n/*             BY KBYTES WITH PERCENTAGES                             */\n/*                                                                    */\n\n/*                                                                    */\n/* ERRORS                                                             */\n/*    PURPOSE: LISTS EVERY D RECORD THAT HAS ERROR BITS SET           */\n/*                                                                    */\n\n/*                                                                    */\n/* EXPDT                                                              */\n/*    PURPOSE: READS TYPE D AND M RECORDS FOR ALL DSNS THAT           */\n/*             HAVE AN EXPDT > 0. (VSAM IS EXCLUDED SINCE IT          */\n/*             ALWAYS HAS AN EXPDT = 1999365)                         */\n/*                                                                    */\n\n/*                                                                    */\n/* HLQSUM                                                             */\n/*    PURPOSE: READS DCOLLECT \"D\" \"M\" AND \"B\" RECORDS AND PRODUCES    */\n/*             A REPORT SUMMARIZED BY HLQ OF BYTES ALLOCATED AT EACH  */\n/*             LEVEL (L0, ML1, AND ML2) AS WELL AS BACKUP BYTES       */\n/*                                                                    */\n/*             PRODUCES A SUMMARY REPORT OF THE FOLLOWING:            */\n/*                                                                    */\n/*                TOTAL FROM VOLUME (V) RECORDS:                      */\n/*                   TOTAL AVAILABLE KBYTES                           */\n/*                   TOTAL ALLOCATED KBYTES                           */\n/*                   SMS AVAILABLE KBYTES                             */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                                                                    */\n/*                TOTAL FROM D, M AND B RECORDS:                      */\n/*                   L0+ML1+ML2 DSN COUNT                             */\n/*                   TOTAL L0 + ML1 +ML2 ALLOCATED                    */\n/*                   TOTAL BACKUP KBYTES                              */\n/*                   L0 DSN COUNT                                     */\n/*                   L0 ALLOCATED KBYTES                              */\n/*                   L0 USED KBYTES                                   */\n/*                   SMS DSN COUNT                                    */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                   ML1 DSN COUNT                                    */\n/*                   ML1 ALLOCATED KBYTES                             */\n/*                   ML1 ORIGINAL KBYTES                              */\n/*                   ML2 DSN COUNT                                    */\n/*                   ML2 ALLOCATED KBYTES                             */\n/*                   ML2 ORIGINAL KBYTES                              */\n/*                                                                    */\n\n/*                                                                    */\n/* MULTIVOL                                                           */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             THE VOLSER AND DSN FOR ALL RECORDS                     */\n/*             THAT HAVE A VOLUME SEQUENCE NUMBER > 1                 */\n/*                                                                    */\n\n/*                                                                    */\n/* NONSMS                                                             */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             NON-SMS DSNS AND THE VOLSER THEY ARE ON.               */\n/*             FOR EACH HLQ, LISTS OUT NUMBER OF DATASETS,            */\n/*             SIZE IN KBYTES, SIZE FOR PRIME POOL (OURS IS           */\n/*             DEFINED AS <102400 KBYTES), SIZE FOR LARGE POOL        */\n/*             (ANY DSN >1024000 KBYTES), AND KYBTES NOT              */\n/*             REFERENCED IN THE LAST 30 DAYS.                        */\n/*                                                                    */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$PCDOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x0f\\x12D\\x00\\x8b\\x00\\x8b\\x00\\x00\\xd3\\xd5\\xc9\\xc3\\xc8\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-09T12:44:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "LNICHO"}, "text": "DCOLLECT REXX Routines\n\nLinnea Nichols\nFairfax County Govt\n12000 Govt Cntr Pkwy\nFairfax, VA 22035\n703/324-2708\n\nThis diskette contains the following files:\n\nREADME.TXT    You are reading it\n\nLNICHO.REX    Contains all REXX programs. Needs to be uploaded to a PS\nfile (LRECL=80) and then unloaded to a PDS using IEBUPDTE. Sample JCL to\nunload is in REXUPD.JCL. You will need to allocate a DSORG=PS, LRECL=80,\nRECFM=FB file on MVS to upload LNICHO.REX to. Then run the REXUPD job,\nbeing sure to put in your own SYSIN and SYSUT2 data set names.  The\nbeginning of each program includes the following: Purpose of the REXX\nprogram, Input files needed, Output files created, and Presort\nrequirements.\n\nLNICHO.PAR     Contains routines that can be used to parse record types\nD, M, C, V, T, and B as well as the standard header. Needs to be\nuploaded to a PS (LRECL=80) file and then unloaded to a PDS using\nIEBUPDTE. Sample JCL to unload it is in REXUPD.JCL. Use the same\nprocedure as documented for LNICHO.REX.\n\nREXUPD.JCL     Sample JCL to create a PDS from the PS file you uploaded.\n\nDCOLLECT.JCL   Sample JCL to run DCOLLECT collection, and create most of\nthe files used for input into the REXX programs.\n\nIf you need help, have suggestions, or just want to talk about\nDCOLLECT, please feel free to call me at 703/324-2708 or contact\nme via IBMMAIL at US5RNFRN or via INTERNET at US5RNFRN@ibmmail.com\n\nThe routines included are as follows:\n\n/*                                                                    */\n/* DASDVOLS                                                           */\n/*    PURPOSE: READS TYPE V AND C RECORDS FOR VOLUME DETAIL REPORT    */\n/*             AND STORAGE GROUP SUMMARY REPORT, READS TYPE T RECORDS */\n/*             FOR DFHSM TAPE SUMMARY REPORT                          */\n/*                                                                    */\n\n/*                                                                    */\n/* DATERFSM                                                           */\n/*    PURPOSE: READS TYPE D AND M RECORDS AND PRODUCES REPORTS OF     */\n/*             DAYS FROM LAST REFERENCE FOR THE FOLLOWING:            */\n/*                L0, ML1 AND ML2 DATA COMBINED                       */\n/*                ALL L0 DATA                                         */\n/*                L0 SMS ONLY                                         */\n/*                L0 NONSMS ONLY                                      */\n/*                                                                    */\n/*             A DETAIL REPORT IS PRODUCED THAT LISTS OUT ALL         */\n/*             DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,   */\n/*             VTOCS, VVDS, PAGE AND TEMPORARY DSNS                   */\n/*                                                                    */\n\n/*                                                                    */\n/* DB2                                                                */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT ALL DB2             */\n/*             DSNS, INCLUDING VOLSER, CREATION DATE AND              */\n/*             ALLOCATED KBYTES. TOTALS ALLOCATED KBYTES.             */\n/*                                                                    */\n\n/*                                                         */\n/*  DCOLDREC                                               */\n/*     PURPOSE: PRINTS OUT DETAIL INFORMATION FOR EVERY    */\n/*              \"D\" AND \"M\" RECORD INPUT                   */\n/*                                                         */\n\n/*                                                                    */\n/* DSORG                                                              */\n/*    PURPOSE: BREAKOUT OF DATA SETS BY DSORG. DONE BY DSN COUNT AND  */\n/*             BY KBYTES WITH PERCENTAGES                             */\n/*                                                                    */\n\n/*                                                                    */\n/* ERRORS                                                             */\n/*    PURPOSE: LISTS EVERY D RECORD THAT HAS ERROR BITS SET           */\n/*                                                                    */\n\n/*                                                                    */\n/* EXPDT                                                              */\n/*    PURPOSE: READS TYPE D AND M RECORDS FOR ALL DSNS THAT           */\n/*             HAVE AN EXPDT > 0. (VSAM IS EXCLUDED SINCE IT          */\n/*             ALWAYS HAS AN EXPDT = 1999365)                         */\n/*                                                                    */\n\n/*                                                                    */\n/* HLQSUM                                                             */\n/*    PURPOSE: READS DCOLLECT \"D\" \"M\" AND \"B\" RECORDS AND PRODUCES    */\n/*             A REPORT SUMMARIZED BY HLQ OF BYTES ALLOCATED AT EACH  */\n/*             LEVEL (L0, ML1, AND ML2) AS WELL AS BACKUP BYTES       */\n/*                                                                    */\n/*             PRODUCES A SUMMARY REPORT OF THE FOLLOWING:            */\n/*                                                                    */\n/*                TOTAL FROM VOLUME (V) RECORDS:                      */\n/*                   TOTAL AVAILABLE KBYTES                           */\n/*                   TOTAL ALLOCATED KBYTES                           */\n/*                   SMS AVAILABLE KBYTES                             */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                                                                    */\n/*                TOTAL FROM D, M AND B RECORDS:                      */\n/*                   L0+ML1+ML2 DSN COUNT                             */\n/*                   TOTAL L0 + ML1 +ML2 ALLOCATED                    */\n/*                   TOTAL BACKUP KBYTES                              */\n/*                   L0 DSN COUNT                                     */\n/*                   L0 ALLOCATED KBYTES                              */\n/*                   L0 USED KBYTES                                   */\n/*                   SMS DSN COUNT                                    */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                   ML1 DSN COUNT                                    */\n/*                   ML1 ALLOCATED KBYTES                             */\n/*                   ML1 ORIGINAL KBYTES                              */\n/*                   ML2 DSN COUNT                                    */\n/*                   ML2 ALLOCATED KBYTES                             */\n/*                   ML2 ORIGINAL KBYTES                              */\n/*                                                                    */\n\n/*                                                                    */\n/* MULTIVOL                                                           */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             THE VOLSER AND DSN FOR ALL RECORDS                     */\n/*             THAT HAVE A VOLUME SEQUENCE NUMBER > 1                 */\n/*                                                                    */\n\n/*                                                                    */\n/* NONSMS                                                             */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             NON-SMS DSNS AND THE VOLSER THEY ARE ON.               */\n/*             FOR EACH HLQ, LISTS OUT NUMBER OF DATASETS,            */\n/*             SIZE IN KBYTES, SIZE FOR PRIME POOL (OURS IS           */\n/*             DEFINED AS <102400 KBYTES), SIZE FOR LARGE POOL        */\n/*             (ANY DSN >1024000 KBYTES), AND KYBTES NOT              */\n/*             REFERENCED IN THE LAST 30 DAYS.                        */\n/*                                                                    */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$UPDJCL": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x0f\\x12D\\x00\\x10\\x00\\x10\\x00\\x00\\xd3\\xd5\\xc9\\xc3\\xc8\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-09T12:44:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "LNICHO"}, "text": "//   JOB\n//*_________________________________________________________________\n//IEBUPDT1 EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DSN=hlq.SAMP.REXX,\n//            DISP=(NEW,CATLG),\n//            AVGREC=K,SPACE=(80,(10,5,20),RLSE),\n//            LRECL=80,RECFM=FB\n//SYSIN    DD DSN=your_uploaded_LNICHO.REX_file,DISP=SHR\n//IEBUPDT2 EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DSN=hlq.SAMP.PARSE,\n//            DISP=(NEW,CATLG),\n//            AVGREC=K,SPACE=(80,(10,5,20),RLSE),\n//            LRECL=80,RECFM=FB\n//SYSIN    DD DSN=your_uploaded_LNICHO.PAR_file,DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DCOLJCL": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x0f\\x12D\\x00v\\x00v\\x00\\x00\\xd3\\xd5\\xc9\\xc3\\xc8\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-09T12:44:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "LNICHO"}, "text": "//DCOLLECT  JOB\n//*\n//*___________________________________________________________\n//*\n//*  THIS JOB RUNS DCOLLECT THEN SORTS THE DATA AND PUTS IT INTO 4\n//*  DIFFERENT FILES. IT THEN RUNS %DCOLDLY FOUND IN\n//*  LNICHO.SAMP.REXX\n//*\n//*___________________________________________________________\n//*\n//IDCAMS EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//*-----------------------------------------------------------\n//* THE NAMES OF YOUR DFHSM MCDS AND BCDS\n//* GO ON THE NEXT TWO CARDS\n//*-----------------------------------------------------------\n//MCDS     DD  DSN=HSM.SMA.MCDS,DISP=SHR\n//BCDS     DD  DSN=HSM.SMA.BCDS,DISP=SHR\n//DCOUT    DD  DSN=CCC.DCOLLECT,\n//             DISP=(,CATLG),SPACE=(264,(150,50),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=K\n//SYSIN    DD *\n DCOLLECT  -\n      OUTFILE(DCOUT)  -\n      MIGD -\n      CAPD -\n      BACD -\n      SMSDATA(ACTIVE) -\n      VOLUMES(*)\n//*\n//*___________________________________________________________\n//*\n//SORTD   EXEC PGM=SORT\n//SORTIN    DD DSN=CCC.DCOLLECT,DISP=SHR\n//SORTOUT   DD DSN=SMS.UMB.DCOLLECT.RECTYPDM,\n//             DISP=(,CATLG),SPACE=(264,(150,50),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=K\n//SYSOUT    DD SYSOUT=*\n//SORTMSG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\n SORT FIELDS=(29,44,CH,A),DYNALLOC=(SYSDA,4),FILSZ=E120000\n INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))\n/*\n//*\n//*___________________________________________________________\n//*\n//SORTV   EXEC PGM=SORT\n//SORTIN    DD DSN=CCC.DCOLLECT,DISP=SHR\n//SORTOUT   DD DSN=SMS.UMB.DCOLLECT.RECTYPV,\n//             DISP=(,CATLG),SPACE=(264,(1,1),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=K\n//SYSOUT    DD SYSOUT=*\n//SORTMSG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\n SORT FIELDS=(87,8,CH,A,29,6,CH,A),DYNALLOC=(SYSDA,4),FILSZ=E120000\n INCLUDE COND=(9,2,CH,EQ,C'V ')\n/*\n//*\n//*___________________________________________________________\n//*\n//SORTC   EXEC PGM=SORT\n//SORTIN    DD DSN=CCC.DCOLLECT,DISP=SHR\n//SORTOUT   DD DSN=SMS.UMB.DCOLLECT.RECTYPC,\n//             DISP=(,CATLG),SPACE=(264,(1,1),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=K\n//SYSOUT    DD SYSOUT=*\n//SORTMSG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\n SORT FIELDS=(29,6,CH,A,35,4,CH,D),DYNALLOC=(SYSDA,4),FILSZ=E120000\n INCLUDE COND=(9,2,CH,EQ,C'C ')\n/*\n//*\n//*___________________________________________________________\n//*\n//SORTT   EXEC PGM=SORT\n//SORTIN    DD DSN=CCC.DCOLLECT,DISP=SHR\n//SORTOUT   DD DSN=SMS.UMB.DCOLLECT.RECTYPT,\n//             DISP=(,CATLG),SPACE=(264,(10,10),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=U\n//SYSOUT    DD SYSOUT=*\n//SORTMSG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\n SORT FIELDS=(29,6,CH,A,35,4,CH,D),DYNALLOC=(SYSDA,4),FILSZ=E120000\n INCLUDE COND=(9,2,CH,EQ,C'T ')\n/*\n//*\n//*___________________________________________________________\n//*\n//SORTT   EXEC PGM=SORT\n//SORTIN    DD DSN=CCC.DCOLLECT,DISP=SHR\n//SORTOUT   DD DSN=SMS.UMB.DCOLLECT.DMB,\n//             DISP=(,CATLG),SPACE=(264,(150,50),RLSE),\n//             DSORG=PS,RECFM=VB,LRECL=600,AVGREC=K\n//SYSOUT    DD SYSOUT=*\n//SORTMSG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD *\n SORT FIELDS=(29,44,CH,A),DYNALLOC=(SYSDA,4),FILSZ=E120000\n INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '),OR,\n               (9,2,CH,EQ,C'B '))\n/*\n//*\n//*___________________________________________________________\n//*\n//DCOLREXX EXEC PGM=IKJEFT01,DYNAMNBR=100,\n//         REGION=6096K,TIME=15\n//SYSPRINT  DD SYSOUT=R\n//SYSTERM   DD SYSOUT=R\n//SYSUDUMP  DD SYSOUT=R\n//SYSTSPRT  DD SYSOUT=R\n//SYSEXEC   DD DSN=LNICHO.SAMP.REXX,DISP=SHR\n//SYSTSIN   DD *\n %DCOLDLY\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PARSRTN": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x0f\\x12D\\x00P\\x00P\\x00\\x00\\xd3\\xd5\\xc9\\xc3\\xc8\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-09T12:44:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "LNICHO"}, "text": "./   ADD NAME=DCBRECP\n/***********************************************************/\n/* PARSE   BACKUP   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCBRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 UBDSNAM 69 UBFLAG1 70 UBDEVCL,\n      71 UBDSORG 73 UBDSIZE 77 UBTIME 81 UBDATE 85 . 87 UBDATCL,\n      117 . 119 UBSTGCL 149 . 151 UBMGTCL 181 UBRECRD 182 UBRECOR,\n      183 UBBKLNG 185 UBFLAG2 186 . 187 UBNMIG 189 UBALLSP,\n      193 UBUSESP 197 UBRECSP 200\n RETURN\n./   ADD NAME=DCCRECP\n/***********************************************************/\n/* PARSE  CAPACITY INFORMATION RECORD -                    */\n/***********************************************************/\n DCCRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 UCVOLSR 31 UCCOLDT 35 UCFLAG1,\n     36 . 37 UCTOTAL 41 UCTGOCC 42 UCTROCC 43 UCBFOCC,\n     44 UCAFOCC 45 UCNOMIG 46 UCNINTV 47 UCINTVM 48\n\n RETURN\n./   ADD NAME=DCDRECP\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n RETURN\n./   ADD NAME=DCMRECP\n/***********************************************************/\n/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCMRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,\n      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,\n      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,\n      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,\n      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,\n      217 UMLRFDT\n RETURN\n./   ADD NAME=DCURECP\n/***********************************************************/\n/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */\n/***********************************************************/\n DCURECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n      13 DCUTIME 17 DCUDATE 21 .\n RETURN\n./   ADD NAME=DCTRECP\n/***********************************************************/\n/* PARSE   TAPE CAPACITY PLANNING RECORD                   */\n/***********************************************************/\n DCTRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 UTSTYPE 26 . ,\n      29 UTFULL 33 UTPART 37 UTEMPTY 41\n RETURN\n./   ADD NAME=DCVRECP\n/***********************************************************/\n/* PARSE   VOLUME INFORMATION RECORD -                     */\n/***********************************************************/\n DCVRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 DCVVOLSR 31 DCVFLAG1,\n      32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,\n      45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,\n      65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .\n RETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXXRTN": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x0f\\x00\\x94\\x04\\x0f\\x12D\\x0b\\x15\\x0b\\x15\\x00\\x00\\xd3\\xd5\\xc9\\xc3\\xc8\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-09T00:00:00", "modifydate": "1994-02-09T12:44:00", "lines": 2837, "newlines": 2837, "modlines": 0, "user": "LNICHO"}, "text": "./   ADD   NAME=DASDVOLS\n/* REXX                                                               */\n/*                                                                    */\n/*                                                                    */\n/*                                                                    */\n/* DASDVOLS                                                           */\n/*    PURPOSE: READS TYPE V AND C RECORDS FOR VOLUME DETAIL REPORT    */\n/*             AND STORAGE GROUP SUMMARY REPORT, READS TYPE T RECORDS */\n/*             FOR DFHSM TAPE SUMMARY REPORT                          */\n/*                                                                    */\n/*             DETAIL REPORT BY VOLSER CONTAINS THE FOLLOWING:        */\n/*                DATE DCOLLECT RUN                                   */\n/*                DATE DFHSM DATA COLLECT                             */\n/*                VOLSER                                              */\n/*                VOLUME CAPACITY IN KB                               */\n/*                KB ALLOCATED ON VOLUME                              */\n/*                FRAGMENTATION INDEX                                 */\n/*                TARGET THRESHOLD                                    */\n/*                TRIGGER THRESHOLD                                   */\n/*                BEFORE OCCUPANCY                                    */\n/*                AFTER OCCUPANCY                                     */\n/*                PERCENT ELGIBLE TO MIGRATE                          */\n/*             SUMMARY TOTALS BY STORAGE GROUP, SMS AND NON-SMS:      */\n/*                CAPACITY IN KB                                      */\n/*                KB ALLOCATED                                        */\n/*                PERCENT ALLOCATED                                   */\n/*                TARGET THRESHOLD (IF STORAGE GROUP)                 */\n/*                TRIGGER THRESHOLD (IF STORAGE GROUP)                */\n/*             SUMMARY TOTALS FOR DFHSM TAPE:                         */\n/*                BACKUP: TOTAL, FULL, PARTIAL AND EMPTY              */\n/*                DUMP: TOTAL, FULL, PARTIAL AND EMPTY                */\n/*                MIGRATE: TOTAL, FULL, PARTIAL AND EMPTY             */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPC                                */\n/*             TYPE C RECORDS                                         */\n/*             SMS.UMB.DCOLLECT.RECTYPV                               */\n/*             TYPE V RECORDS                                         */\n/*             SMS.UMB.DCOLLECT.RECTYPT                               */\n/*             TYPE T RECORDS                                         */\n/*    OUTPUT:  SMS.PMB.DCOLLECT.CAPACITY.DCCYYDDD                     */\n/*    PRESORT: FOR TYPE C RECORDS                                     */\n/*             SORT FIELDS=(29,6,CH,A,35,4,CH,D)                      */\n/*             INCLUDE COND=(9,2,CH,EQ,C'C ')                         */\n/*             RECORD TYPE=V,LENGTH=(264,,264)                        */\n/*                                                                    */\n/*             FOR TYPE V RECORDS                                     */\n/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */\n/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */\n/*             RECORD TYPE=V,LENGTH=(264,,264)                        */\n/*                                                                    */\n/*             FOR TYPE T RECORDS                                     */\n/*             SORT FIELDS=(29,6,CH,A)                                */\n/*             INCLUDE COND=(9,2,CH,EQ,C'T ')                         */\n/*             RECORD TYPE=V,LENGTH=(264,,264)                        */\n/*                                                                    */\n/**********************************************************************/\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT V RECORDS)     */\n/***********************************************************/\n TRACE N\n INNAME = \"'SMS.UMB.DCOLLECT.RECTYPV'\"\n \"ALLOC DD(INFILE) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT C RECORDS)     */\n/***********************************************************/\n INNAME2 = \"'SMS.UMB.DCOLLECT.RECTYPC'\"\n \"ALLOC DD(INFILE2) DA(\"INNAME2\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME2') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT T RECORDS)     */\n/***********************************************************/\n INNAME = \"'SMS.UMB.DCOLLECT.RECTYPT'\"\n \"ALLOC F(INFILE3) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* INITIALIZE VARIABLES                                    */\n/***********************************************************/\n OUT_COUNT = 0\n TOT_ALLOC_KB = 0\n SMS_ALLOC_KB = 0\n TOT_AVAIL_KB = 0\n SMS_AVAIL_KB = 0\n STG_ALLOC_KB. = 0\n STG_AVAIL_KB. = 0\n NONSMS_ALLOC_KB = 0\n NONSMS_AVAIL_KB = 0\n VOLSER = '      '\n COL_DATE. = '      '\n TARGET.  = '   '\n TRIGGER. = '   '\n TARGET_STG.  = '   '\n TRIGGER_STG. = '   '\n B4.      = '  '\n AFTER.   = '  '\n MIGELG.  = '  '\n STGRP_NAMES    = ' '\n\n/***********************************************************/\n/* READ IN INPUT FILE WITH TYPE C RECORDS                  */\n/***********************************************************/\n \"EXECIO * DISKR INFILE2 (FINIS STEM RECORD.\"\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n DO K = 1 TO RECORD.0\n    PARSE VAR RECORD.K 1 . 25 UCVOLSR 31 UCCOLDT 35 UCFLAG1,\n      36 . 37 UCTOTAL 41 UCTGOCC 42 UCTROCC 43 UCBFOCC,\n      44 UCAFOCC 45 UCNOMIG 46 UCNINTV 47 UCINTVM 48\n    IF UCVOLSR \\= VOLSER THEN DO\n       VOLSER = UCVOLSR\n       COL_DATE.VOLSER = LEFT(C2X(UCCOLDT),7)\n       TARGET.VOLSER  = C2D(UCTGOCC)\n       TRIGGER.VOLSER = C2D(UCTROCC)\n       B4.VOLSER      = C2D(UCBFOCC)\n       AFTER.VOLSER   = C2D(UCAFOCC)\n       MIGELG.VOLSER  = C2D(UCNOMIG)\n       END\n END\n\n/***********************************************************/\n/* READ IN INPUT FILE WITH TYPE V RECORDS                  */\n/***********************************************************/\n \"EXECIO * DISKR INFILE (FINIS STEM RECORD.\"\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n DO K = 1 TO RECORD.0\n    PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n       13 DCUTIME 17 DCUDATE 21 .\n    PARSE VAR RECORD.K 1 . 25 DCVVOLSR 31 DCVFLAG1,\n       32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,\n       45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,\n       65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .\n    DATE = LEFT(C2X(DCUDATE),7)\n    IF K=1 THEN DO\n       OUT_COUNT = OUT_COUNT + 1\n       OUT_LINE.OUT_COUNT = \"DCOLLECT RUN ON:\" DATE\n       CALL OUTHEAD\n       END\n    VOLSER = DCVVOLSR\n    IF BITAND(DCVFLAG1,'03'X) = '03'X  THEN DO  /* IS IT SMS?         */\n       SMS_ALLOC_KB = SMS_ALLOC_KB + C2D(DCVALLOC)\n       SMS_AVAIL_KB = SMS_AVAIL_KB + C2D(DCVVLCAP)\n       IF DCVSGTCL = '        ' THEN DCVSGTCL = 'NO_GROUP'\n       END\n    SELECT\n       WHEN SUBSTR(VOLSER,1,2) = 'ML' THEN\n         TARGTRIG = (TARGET.VOLSER||\"/\"||TRIGGER.VOLSER)\n       WHEN DCVSGTCL = '      ' | DCVSGTCL = 'NO_GROUP' THEN\n         TARGTRIG = '  '\n       OTHERWISE\n         TARGTRIG = (TARGET.VOLSER||\"/\"||TRIGGER.VOLSER)\n    END\n/***********************************************************/\n/* BUILD LIST OF STORAGE GROUP NAMES                       */\n/*  AND PROCESS KBYTES INFORMATION BY STORAGE GROUP        */\n/***********************************************************/\n\n    IF DCVSGTCL \\= '      ' THEN DO\n       IF WORDPOS(DCVSGTCL,STGRP_NAMES,1) = 0 THEN DO\n          STGRP_NAMES = STGRP_NAMES DCVSGTCL\n          L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)\n          TARGET_STG.L = TARGET.DCVVOLSR\n          TRIGGER_STG.L = TRIGGER.DCVVOLSR\n          END\n       L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)\n       STG_ALLOC_KB.L = STG_ALLOC_KB.L + C2D(DCVALLOC)\n       STG_AVAIL_KB.L = STG_AVAIL_KB.L + C2D(DCVVLCAP)\n       END\n    ELSE DO\n       NONSMS_ALLOC_KB = NONSMS_ALLOC_KB + C2D(DCVALLOC)\n       NONSMS_AVAIL_KB = NONSMS_AVAIL_KB + C2D(DCVVLCAP)\n       END\n\n/***********************************************************/\n/* BUILD TOTALS                                            */\n/***********************************************************/\n\n    TOT_ALLOC_KB = TOT_ALLOC_KB + C2D(DCVALLOC)\n    TOT_AVAIL_KB = TOT_AVAIL_KB + C2D(DCVVLCAP)\n\n/***********************************************************/\n/* PUT OUT VOLUME DETAIL RECORD                            */\n/***********************************************************/\n\n    OUT_COUNT = OUT_COUNT + 1\n    OUT_LINE.OUT_COUNT = CENTER(COL_DATE.VOLSER,7),\n        LEFT(DCVSGTCL,8),\n        RIGHT(DCVVOLSR,6),\n        RIGHT(C2D(DCVVLCAP),10),\n        RIGHT(C2D(DCVALLOC),10),\n        RIGHT(C2D(DCVFRAGI),6),\n        CENTER(TARGTRIG,7),\n        RIGHT(B4.VOLSER,6),\n        RIGHT(AFTER.VOLSER,6),\n        RIGHT(MIGELG.VOLSER,4)\n END\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */\n/***********************************************************/\n OUTNAME = \"'SMS.PMB.DCOLLECT.CAPACITY.D\"||DATE||\"'\"\n \"ALLOC DSNAME(\"||OUTNAME||\")\",\n     \"DSORG(PS) LRECL(80) RECFM(F B) \",\n     \"TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)\"\n  IF RC\u00ac= 0 THEN DO\n     SAY  'ALLOC OF ('||OUTNAME||') FAILED'\n     EXIT 12\n     END\n\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"++++\",80,\"+\")\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = CENTER(\"    \",7),\n    LEFT(\"      \",8),\n    RIGHT(\"     \",6),\n    RIGHT(\"CAPACITY\",12),\n    RIGHT(\"ALLOCATED\",12),\n    CENTER(\"PERCENT\",9),\n    CENTER(\"TARGET/\",7)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = CENTER(\"    \",7),\n    LEFT(\"      \",8),\n    RIGHT(\"     \",6),\n    RIGHT(\"IN KBYTES\",12),\n    RIGHT(\"IN KBYTES\",12),\n    CENTER(\"ALLOCATED\",9),\n    CENTER(\"TRIGGER\",7)\n\n/***********************************************************/\n/* PUT OUT TOTALS BY STORAGE GROUP, SMS AND GRAND TOTAL    */\n/***********************************************************/\n\nL = WORDS(STGRP_NAMES)\nDO K = 1 TO L\n   PRCNT_ALC = FORMAT(((STG_ALLOC_KB.K/STG_AVAIL_KB.K)*100),3,1)\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = CENTER('  ',7),\n       RIGHT(WORD(STGRP_NAMES,K),8),\n       LEFT(\"   \",6),\n       RIGHT(STG_AVAIL_KB.K,12),\n       RIGHT(STG_ALLOC_KB.K,12),\n       RIGHT(PRCNT_ALC,9),\n       CENTER(TARGET_STG.K||\"/\"||TRIGGER_STG.K,7)\nEND\n\nPRCNT_ALC = FORMAT(((SMS_ALLOC_KB/SMS_AVAIL_KB)*100),3,1)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = CENTER('  ',7),\n    RIGHT(\"SMS\",8),\n    LEFT(\"    \",6),\n    RIGHT(SMS_AVAIL_KB,12),\n    RIGHT(SMS_ALLOC_KB,12),\n    RIGHT(PRCNT_ALC,9)\n\nPRCNT_ALC = FORMAT(((NONSMS_ALLOC_KB/NONSMS_AVAIL_KB)*100),3,1)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = CENTER('  ',7),\n    RIGHT(\"NON-SMS\",8),\n    LEFT(\"    \",6),\n    RIGHT(NONSMS_AVAIL_KB,12),\n    RIGHT(NONSMS_ALLOC_KB,12),\n    RIGHT(PRCNT_ALC,9)\n\nPRCNT_ALC = FORMAT(((TOT_ALLOC_KB/TOT_AVAIL_KB)*100),3,1)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = CENTER('  ',7),\n    RIGHT(\"TOTAL\",8),\n    LEFT(\"     \",6),\n    RIGHT(TOT_AVAIL_KB,12),\n    RIGHT(TOT_ALLOC_KB,12),\n    RIGHT(PRCNT_ALC,9)\n\n/***********************************************************/\n/* PROCESS EACH T RECORD UNTIL END-OF-FILE REACHED         */\n/***********************************************************/\n UTALL = 0\n UTTOT = 0\n UTTOTFULL = 0\n UTTOTPART = 0\n UTTOTEMP = 0\n EOF = 'NO'\n CALL OUTHEADT\n TRACE N\n DO WHILE EOF='NO'\n   \"EXECIO 1 DISKR INFILE3\"\n   IF RC\u00ac= 0 THEN\n      EOF = 'YES'\n   ELSE DO\n      PARSE PULL RECORD\n/***********************************************************/\n/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */\n/***********************************************************/\n      DCURCTYP=SUBSTR(RECORD,5,2)\n         SELECT\n/***********************************************************/\n/* PROCESS TAPE     DATA SET INFORMATION RECORD            */\n/***********************************************************/\n         WHEN(DCURCTYP='T ') THEN DO\n                             CALL DCTRECP\n                             IF UTSTYPE = B THEN TYPE = \"BACKUP \"\n                             IF UTSTYPE = M THEN TYPE = \"MIGRATE\"\n                             IF UTSTYPE = D THEN TYPE = \"DUMP   \"\n                             UTALL = UTFULL + UTPART + UTEMPTY\n                             UTTOT = UTALL + UTTOT\n                             UTTOTFULL = UTFULL + UTTOTFULL\n                             UTTOTPART = UTPART + UTTOTPART\n                             UTTOTEMP= UTEMPTY + UTTOTEMP\n                             CALL OUTDET\n                             END\n         OTHERWISE\n         END\n      END\n END\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"TOTAL\",9),\n    RIGHT(UTTOT,7),\n    RIGHT(UTTOTFULL,7),\n    RIGHT(UTTOTPART,7),\n    RIGHT(UTTOTEMP,7)\n\n\"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE.\"\n\"FREE ALL\"\nEXIT\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE                                   */\n/***********************************************************/\n OUTHEAD:\n/*                                                                    */\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = CENTER(\"    \",7),\n       LEFT(\"      \",8),\n       RIGHT(\"      \",6),\n       RIGHT(\"VOLUME\",10),\n       RIGHT(\"VOLUME\",10),\n       RIGHT(\"      \",6),\n       RIGHT(\"       \",7),\n       CENTER(\"      \",6),\n       CENTER(\"     \",6),\n       CENTER(\"%\",4)\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = CENTER(\"COLLECT\",7),\n       LEFT(\"STORAGE\",8),\n       RIGHT(\"      \",6),\n       RIGHT(\"CAPACITY\",10),\n       RIGHT(\"ALLOCATED\",10),\n       CENTER(\"FRAG\",6),\n       CENTER(\"TARGET/\",7),\n       CENTER(\"BEFORE\",6),\n       CENTER(\"AFTER\",6),\n       CENTER(\"MIGR\",4)\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = CENTER(\"DATE\",7),\n       LEFT(\"GROUP\",8),\n       RIGHT(\"VOLSER\",6),\n       RIGHT(\"IN KBYTES\",10),\n       RIGHT(\"IN KBYTES\",10),\n       CENTER(\"INDEX\",6),\n       CENTER(\"TRIGGER\",7),\n       CENTER(\"OCCUPY\",6),\n       CENTER(\"OCCUPY\",6),\n       CENTER(\"ELG\",4)\n   RETURN\n\n/***********************************************************/\n/* PARSE   TAPE CAPACITY PLANNING RECORD                   */\n/***********************************************************/\n DCTRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n      13 DCUTIME 17 DCUDATE 21 . ,\n      25 UTSTYPE 26 . ,\n      29 UTFULL 33 UTPART 37 UTEMPTY 41\n       UTFULL = C2D(UTFULL)\n       UTPART = C2D(UTPART)\n       UTEMPTY = C2D(UTEMPTY)\n RETURN\n\n/***********************************************************/\n/*   PRINT OUT TAPE HEADINGS                               */\n/***********************************************************/\nOUTHEADT:\n  OUT_COUNT = OUT_COUNT + 1\n  OUT_LINE.OUT_COUNT = LEFT(\"++++\",80,\"+\")\n  OUT_COUNT = OUT_COUNT + 1\n  OUT_LINE.OUT_COUNT = LEFT(\"HSM TAPES\",9),\n      RIGHT(\"TOTAL\",7),\n      RIGHT(\"FULL\",7),\n      RIGHT(\"PARTIAL\",7),\n      RIGHT(\"EMPTY\",7)\n  OUT_COUNT = OUT_COUNT + 1\n  OUT_LINE.OUT_COUNT = LEFT(\"---------\",9),\n      RIGHT(\"-------\",7),\n      RIGHT(\"-------\",7),\n      RIGHT(\"-------\",7),\n      RIGHT(\"-------\",7)\n  RETURN\n\n/***********************************************************/\n/*   PRINT OUT TAPE TYPES                                  */\n/***********************************************************/\nOUTDET:\n  OUT_COUNT = OUT_COUNT + 1\n  OUT_LINE.OUT_COUNT = LEFT(TYPE,9),\n      RIGHT(UTALL,7),\n      RIGHT(UTFULL,7),\n      RIGHT(UTPART,7),\n      RIGHT(UTEMPTY,7)\n  RETURN\n\n./   ADD   NAME=DATERFSM\n/* REXX                                                               */\n/*                                                                    */\n/* DATERFSM                                                           */\n/*    PURPOSE: READS TYPE D AND M RECORDS AND PRODUCES REPORTS OF     */\n/*             DAYS FROM LAST REFERENCE FOR THE FOLLOWING:            */\n/*                L0, ML1 AND ML2 DATA COMBINED                       */\n/*                ALL L0 DATA                                         */\n/*                L0 SMS ONLY                                         */\n/*                L0 NONSMS ONLY                                      */\n/*                                                                    */\n/*             A DETAIL REPORT IS PRODUCED THAT LISTS OUT ALL         */\n/*             DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,   */\n/*             VTOCS, VVDS, PAGE AND TEMPORARY DSNS                   */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*    OUTPUT:  SMS.UMB.DCOLLECT.DATE.LRF                              */\n/*             SMS.UMB.DCOLLECT.DETAIL.LRF                            */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D AND M RECORDS                               */\n/*             SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/**********************************************************************/\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */\n/***********************************************************/\nTRACE N\nINNAME = \"'SMS.UMB.DCOLLECT.RECTYPDM'\"\n \"ALLOC F(INFILE) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */\n/***********************************************************/\n OUTNAME = \"'SMS.UMB.DCOLLECT.DATE.LRF'\"\n\"ALLOC DSNAME(\"OUTNAME\")\",\n  \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n  \"SPACE(50,20) RELEASE DDNAME(OUTFILE)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE DETAIL BY DSN REPORT       */\n/***********************************************************/\n OUTNAME = \"'SMS.UMB.DCOLLECT.DATE.DETAIL.LRF'\"\n\"ALLOC DSNAME(\"OUTNAME\")\",\n  \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n  \"SPACE(7000,3500) RELEASE DDNAME(OUTDET)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n/***********************************************************/\n/* INITIALIZE VARIABLES                                    */\n/***********************************************************/\n DAYS.1   = '0-15'\n DAYS.2   = '16-30'\n DAYS.3   = '31-60'\n DAYS.4   = '61-120'\n DAYS.5   = '121-365'\n DAYS.6   = '>365'\n DAYS.7   = 'VS INDX'\n DAYS.8   = 'SYSTEM'\n DAYS.TOT = 'TOTAL'\n DAYS.ERR = 'ERRORS'\n DAYST = 8\n DSN#.    = 0\n MBALLOC. = 0\n MBORG.   = 0\n DSNPER.  = 0\n MBORGPER. = 0\n K        = 0\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n EOF = 'NO'\n FIRST_REC = 'YES'\n DO WHILE EOF='NO'\n   \"EXECIO 1 DISKR INFILE\"\n   IF RC\u00ac= 0 THEN EOF = 'YES'\n   ELSE DO\n      PARSE PULL RECORD\n      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,\n         25 RECDSN 69 .\n      VSINDX = 'NO'\n      VS = 'NO'\n      SYS = 'NO'\n\n      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/\n         COLDATE  = RIGHT(LEFT(C2X(DCUDATE),7),5) /*FOR FIRST RECORD  */\n         COLYY = LEFT(COLDATE,2)\n         COLDDD = RIGHT(COLDATE,3)\n         OUT_LINE = \"DATA COLLECTED ON:\" COLDATE\n         PUSH OUT_LINE\n         \"EXECIO 1 DISKW OUTFILE\"\n         OUT_LINE2 = OUT_LINE\n         PUSH OUT_LINE2\n         \"EXECIO 1 DISKW OUTDET\"\n         CALL OUTHEAD2\n         FIRST_REC = 'NO'\n         END\n\n      SELECT\n         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */\n                          CALL DCDRECP\n                          DSN = DCDDSNAM\n                          REFYY = LEFT(DCDLSTRF,2)\n                          REFDDD = RIGHT(DCDLSTRF,3)\n                          CREYY = LEFT(DCDCREDT,2)\n                          CREDDD = RIGHT(DCDCREDT,3)\n                          CREATED = DCDCREDT\n                          CURRSIZE = DCDALLSP\n                          ORGSIZE = DCDALLSP\n                          DSORG = DCDDSORG\n                          END\n         WHEN(DCURCTYP='M ') THEN DO             /* MIGRATED DATA     */\n                          CALL DCMRECP\n                          DSN = UMDSNAM\n                          REFYY = LEFT(UMLRFDT,2)\n                          REFDDD = RIGHT(UMLRFDT,3)\n                          CREYY = LEFT(UMCREDT,2)\n                          CREDDD = RIGHT(UMCREDT,3)\n                          CREATED = UMCREDT\n                          CURRSIZE = UMDSIZE\n                          ORGSIZE = UMALLSP\n                          DSORG = UMDSORG\n                          END\n         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */\n         END\n\n/***********************************************************/\n/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */\n/* ALL DATA, BOTH SMS AND NON-SMS                          */\n/* BASED ON COLLECTION DATE OF DATA                        */\n/***********************************************************/\n\n      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */\n         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */\n         REFDDD = CREDDD               /*  CREATION DATE              */\n         END\n      IF COLDDD <= REFDDD THEN DO\n         REFYY = REFYY - 1\n         REFDDD = REFDDD + 365\n         END\n      REFDAYS = COLDDD - REFDDD\n      REFYRS = COLYY - REFYY\n      REFDAYS = REFDAYS + (REFYRS * 365)\n\n      IF SUBSTR(DSN,1,9) = \"SYS1.VVDS\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,9) = \"SYS1.VTOC\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,9) = \"BHSM.VTOC\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,6) = \"PAGE.V\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,4) = \"SYS9\" THEN SYS = 'YES'\n      IF INDEX(DSN,'DUMYDSCB') >0 THEN SYS = 'YES'\n      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO\n         VS = 'YES'\n         IF INDEX(DSN,'INDEX') >0 THEN VSINDX = 'YES'\n         END\n\n      SELECT\n         WHEN SYS = 'YES' THEN K=8\n         WHEN VSINDX = 'YES' THEN K=7\n         WHEN REFDAYS <=15 THEN K=1\n         WHEN REFDAYS > 15 & REFDAYS <= 30 THEN K=2\n         WHEN REFDAYS > 30 & REFDAYS <= 60 THEN K=3\n         WHEN REFDAYS > 60 & REFDAYS <= 120 THEN K=4\n         WHEN REFDAYS > 120 & REFDAYS <= 365 THEN K=5\n         WHEN REFDAYS > 365  THEN K=6\n      OTHERWISE K = 'ERR'  /* DO NOT PROCESS OTHER RECORD TYPES */\n      END                                        /* END OF SELECT     */\n\n/***********************************************************/\n/* TOTAL UP STATS FOR ALL DATA - SMS AND NON-SMS           */\n/* ACTIVE AND MIGRATED                                     */\n/***********************************************************/\n\n      DSN#.DM.REF.K    = DSN#.DM.REF.K + 1\n      MBALLOC.DM.REF.K = MBALLOC.DM.REF.K + CURRSIZE\n      MBORG.DM.REF.K   = MBORG.DM.REF.K + ORGSIZE\n      DSN#.DM.REF.TOT    = DSN#.DM.REF.TOT + 1\n      MBALLOC.DM.REF.TOT = MBALLOC.DM.REF.TOT + CURRSIZE\n      MBORG.DM.REF.TOT   = MBORG.DM.REF.TOT + ORGSIZE\n\n/***********************************************************/\n/* TOTAL UP STATS FOR ACTIVE (L0) ONLY                     */\n/***********************************************************/\n\n      IF DCURCTYP='D ' THEN DO\n         DSN#.L0.REF.K    = DSN#.L0.REF.K + 1\n         MBALLOC.L0.REF.K = MBALLOC.L0.REF.K + CURRSIZE\n         MBORG.L0.REF.K   = MBORG.L0.REF.K + ORGSIZE\n         DSN#.L0.REF.TOT    = DSN#.L0.REF.TOT + 1\n         MBALLOC.L0.REF.TOT = MBALLOC.L0.REF.TOT + CURRSIZE\n         MBORG.L0.REF.TOT   = MBORG.L0.REF.TOT + ORGSIZE\n         IF K>2 & K<7 THEN CALL OUTLINE2\n         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO\n            DSN#.SMS.REF.K   = DSN#.SMS.REF.K + 1\n            MBALLOC.SMS.REF.K = MBALLOC.SMS.REF.K + CURRSIZE\n            MBORG.SMS.REF.K  = MBORG.SMS.REF.K + ORGSIZE\n            DSN#.SMS.REF.TOT   = DSN#.SMS.REF.TOT + 1\n            MBALLOC.SMS.REF.TOT = MBALLOC.SMS.REF.TOT + CURRSIZE\n            MBORG.SMS.REF.TOT  = MBORG.SMS.REF.TOT + ORGSIZE\n            END\n         ELSE DO\n            DSN#.NONSMS.REF.K = DSN#.NONSMS.REF.K + 1\n            MBALLOC.NONSMS.REF.K = MBALLOC.NONSMS.REF.K + CURRSIZE\n            MBORG.NONSMS.REF.K = MBORG.NONSMS.REF.K + ORGSIZE\n            DSN#.NONSMS.REF.TOT = DSN#.NONSMS.REF.TOT + 1\n            MBALLOC.NONSMS.REF.TOT = MBALLOC.NONSMS.REF.TOT + CURRSIZE\n            MBORG.NONSMS.REF.TOT = MBORG.NONSMS.REF.TOT + ORGSIZE\n            END\n         END\n\n   END\n END                                             /* END OF DOWHILE EOF*/\n\"EXECIO 0 DISKR INFILE (FINIS\"\n\"FREE DDNAME(INFILE)\"\n\n/***********************************************************/\n/* TOTAL IT ALL UP                                         */\n/* PUT REPORT OUT TO DATASET                               */\n/***********************************************************/\n\n CALL OUTLEG\n TYP = \"DM.REF\"\n CALL PERCENT\n REP = \"LAST REFERENCE DATE - L0, ML1, AND ML2 DATA\"\n CALL OUTHEAD\n DO J = 1 TO DAYST\n    CALL OUTLINE\n END\n J = 'TOT'\n CALL OUTLINE\n/* J = 'ERR'                                                          */\n/* CALL OUTLINE                                                       */\n\n TYP = \"L0.REF\"\n CALL PERCENT\n REP = \"LAST REFERENCE DATE - L0\"\n CALL OUTHEAD\n DO J = 1 TO DAYST\n    CALL OUTLINE\n END\n J = 'TOT'\n CALL OUTLINE\n/* J = 'ERR'                                                          */\n/* CALL OUTLINE                                                       */\n\n TYP = \"SMS.REF\"\n CALL PERCENT\n REP = \"LAST REFERENCE DATE - L0 SMS ONLY\"\n CALL OUTHEAD\n DO J = 1 TO DAYST\n    CALL OUTLINE\n END\n J = 'TOT'\n CALL OUTLINE\n/* J = 'ERR'                                                          */\n/* CALL OUTLINE                                                       */\n\n TYP = \"NONSMS.REF\"\n CALL PERCENT\n REP = \"LAST REFERENCE DATE - L0 NONSMS ONLY\"\n CALL OUTHEAD\n DO J = 1 TO DAYST\n    CALL OUTLINE\n END\n J = 'TOT'\n CALL OUTLINE\n/* J = 'ERR'                                                          */\n/* CALL OUTLINE                                                       */\n\"EXECIO 0 DISKW OUTFILE (FINIS\"\n\"EXECIO 0 DISKW OUTDET (FINIS\"\n\"FREE DDNAME(OUTFILE)\"\n\"FREE DDNAME(OUTDET)\"\n\n EXIT\n\n\n/***********************************************************/\n/* ROUTINE TO FIGURE OUT PERCENTAGES OF TOTALS             */\n/*  AND                                                    */\n/* CHANGE THE ALLOC AND ORG DATA TO MB INSTEAD OF KB       */\n/***********************************************************/\n\n PERCENT:\n\n    DO J = 1 TO DAYST\n       DSN1 = DSN#.TYP.J/DSN#.TYP.TOT\n       MBORG1 = MBORG.TYP.J/MBORG.TYP.TOT\n       DSNPER.TYP.J   = FORMAT(((DSN1)*100),3,1)\n       MBORGPER.TYP.J = FORMAT(((MBORG1)*100),3,1)\n       MBALLOC.TYP.J = FORMAT((MBALLOC.TYP.J/1024),,0)\n       MBORG.TYP.J   = FORMAT((MBORG.TYP.J /1024),,0)\n    END\n    MBALLOC.TYP.TOT = FORMAT((MBALLOC.TYP.TOT/1024),,0)\n    MBORG.TYP.TOT   = FORMAT((MBORG.TYP.TOT /1024),,0)\n    DSNPER.TYP.TOT = ' '\n    MBORGPER.TYP.TOT = ' '\n RETURN\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE                                   */\n/***********************************************************/\n OUTHEAD:\n/*                                                          */\n   OUT_LINE = \"   \"\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = REP\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = CENTER(\"DAYS\",9),\n      CENTER(\"# BY DSN\",9),\n      CENTER(\"MB ALLOC\",10),\n      CENTER(\"ORG MB\",10),\n      CENTER(\"% DSN\",8),\n      CENTER(\"% ORG MB\",8)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT OUT A LEGEND LINE                                   */\n/***********************************************************/\n OUTLEG:\n/*                                                          */\n   OUT_LINE = \"   \"\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = \"VS INDX = VSAM INDEXES\"\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = \"SYSTEM = VTOCS, VVDS, PAGE AND TEMPORARY DSNS\"\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = \"   \"\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */\n/***********************************************************/\nOUTLINE:\n/*                                                          */\n   OUT_LINE = LEFT(DAYS.J,9),\n      RIGHT(DSN#.TYP.J,9),\n      RIGHT(MBALLOC.TYP.J,10),\n      RIGHT(MBORG.TYP.J,10),\n      RIGHT(DSNPER.TYP.J,8),\n      RIGHT(MBORGPER.TYP.J,8)\n/* SAY OUT_LINE                                             */\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE FOR DETAIL REPORT                 */\n/***********************************************************/\n OUTHEAD2:\n/*                                                          */\n   OUT_LINE2 = \"   \"\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n   OUT_LINE2 = \"DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,\"\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n   OUT_LINE2 = \"VTOCS, VVDS, PAGE AND TEMPORARY DSNS\"\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n   OUT_LINE2 = \"   \"\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n   OUT_LINE2 = LEFT(\"DSN\",44),\n      CENTER(\"REF DAYS\",9),\n      CENTER(\"MGMTCL\",8),\n      CENTER(\"STOGRP\",8)\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n RETURN\n\n/***********************************************************/\n/* PUT DETAIL INFO OUT TO NEW FILE                         */\n/***********************************************************/\nOUTLINE2:\n/*                                                          */\n   OUT_LINE2 = LEFT(DCDDSNAM,44),\n      RIGHT(REFDAYS,9),\n      RIGHT(DCDMGTCL,8),\n      RIGHT(DCDSTGRP,8)\n/* SAY OUT_LINE2                                             */\n   PUSH OUT_LINE2\n   \"EXECIO 1 DISKW OUTDET\"\n RETURN\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n\n   DCDALLSP = C2D(DCDALLSP)\n   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)\n   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)\n RETURN\n\n/***********************************************************/\n/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCMRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,\n      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,\n      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,\n      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,\n      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,\n      217 UMLRFDT\n   UMALLSP = C2D(UMALLSP)\n   UMDSIZE = C2D(UMDSIZE)\n   UMCREDT = RIGHT(LEFT(C2X(UMCREDT),7),5)\n   UMLRFDT = RIGHT(LEFT(C2X(UMLRFDT),7),5)\n   UMLBKDT = C2X(UMLBKDT)\n RETURN\n\n./   ADD   NAME=DB2\n/* REXX                                                               */\n/*                                                                    */\n/* DB2                                                                */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT ALL DB2             */\n/*             DSNS, INCLUDING VOLSER, CREATION DATE AND              */\n/*             ALLOCATED KBYTES. TOTALS ALLOCATED KBYTES.             */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*    OUTPUT:  SMS.UMB.DCOLLECT.DB2.DCCYYDDD                          */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D AND M RECORDS                               */\n/*             SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/**********************************************************************/\n\nTRACE N\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */\n/***********************************************************/\n\nINDD1 = \"'SMS.UMB.DCOLLECT.RECTYPDM'\"\n\"ALLOC DSNAME(\"||INDD1||\") DDNAME(FILEA) SHR\"\n\n/****************************************************************/\n/*  INITIALIZE VARIABLES                                        */\n/****************************************************************/\nDSNCOUNT = 0\nSTD_DSNCOUNT = 0\nOUT_COUNT = 0\nHLQ_SMS_DSNCT = 0\nHLQ_DSNCT = 0\nHLQ_STDDSN = 0\nTOT_HLQ = 0\nALLOC = 0\nFIRST_REC = \"YES\"\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n\n\"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\nDO WHILE IN_REC.0 > 0\n   DO J = 1 TO IN_REC.0\n      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n         13 DCUTIME 17 DCUDATE 21 .\n      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/\n         COLDATE  = LEFT(C2X(DCUDATE),7)         /* FOR FIRST RECORD  */\n         OUT_COUNT = OUT_COUNT + 1\n         OUT_LINE.OUT_COUNT = \"DATA COLLECTED ON:\" COLDATE\n         OUT_COUNT = OUT_COUNT + 1\n         OUT_LINE.OUT_COUNT = \"  \"\n         FIRST_REC = 'NO'\n         OUT_COUNT = OUT_COUNT + 1\n         OUT_LINE.OUT_COUNT = LEFT(\"DSN\",44),\n             RIGHT(\"VOLSER\",6),\n             RIGHT(\"CREATED\",7),\n             RIGHT(\"ALLOC_KB\",10)\n         OUT_COUNT = OUT_COUNT + 1\n         OUT_LINE.OUT_COUNT = LEFT(\"-\",44,\"-\"),\n            RIGHT(\"------\",6),\n            RIGHT(\"-------\",7),\n            LEFT(\"----------\",10)\n         END\n      IF DCURCTYP = \"D \" THEN DO\n         CALL DCDRECP\n         CREDT = LEFT(C2X(DCDCREDT),7)\n         PARSE VAR IN_REC.J 1 . 25 HLQ.J \".\" HLQ2.J \".\" HLQ3.J \".\" .\n         IF LENGTH(HLQ.J) > 8 THEN HLQ.J = LEFT(HLQ.J,8)\n         IF LENGTH(HLQ2.J) > 8 THEN HLQ2.J = LEFT(HLQ2.J,8)\n         IF LENGTH(HLQ3.J) > 8 THEN HLQ2.J = LEFT(HLQ3.J,8)\n         IF LEFT(HLQ2.J,5) = \"DSNDB\" THEN DO\n            ALLOC = ALLOC + C2D(DCDALLSP)\n            OUT_COUNT = OUT_COUNT + 1\n            OUT_LINE.OUT_COUNT = LEFT(DCDDSNAM,44),\n            LEFT(DCDVOLSR,6),\n            RIGHT(CREDT,7),\n            RIGHT(C2D(DCDALLSP),10)\n            END\n         END\n   END\n   \"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\nEND\n\n/****************************************************************/\n/*  PUT OUT TOTAL COUNTS                                        */\n/****************************************************************/\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"  \",44)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"-\",44,\"-\"),\n   RIGHT(\"------\",6),\n   RIGHT(\"-------\",7),\n   LEFT(\"==========\",10)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"  \",44)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"TOTAL ALLOCATED KBYTES\",44),\n    RIGHT(\"     \",6),\n    RIGHT(\"     \",7),\n    RIGHT(ALLOC,10)\n\n/****************************************************************/\n/*  FREE INPUT FILE AND CREATE OUTPUT FILE                      */\n/****************************************************************/\n\"EXECIO 0 DISKR FILEA (FINIS\"\n\"FREE DDNAME(FILEA)\"\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.DB2.D\"||COLDATE||\"')\",\n    \"DSORG(PS) LRECL(80) RECFM(F B) \",\n    \"TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)\"\n\"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE.\"\n\"FREE DDNAME(OUTDD)\"\nEXIT\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n RETURN\n\n./   ADD   NAME=DCOLDLY\n/* REXX                                                               */\n\"%NONSMS\"\n\"%HLQSUM\"\n\"%DSNCONV\"\n\"%DASDVOLS\"\nEXIT\n./   ADD   NAME=DCOLDREC\n/* REXX                                                    */\n/*                                                         */\n/*                                                         */\n/*  DCOLDREC                                               */\n/*     PURPOSE: PRINTS OUT DETAIL INFORMATION FOR EVERY    */\n/*              \"D\" AND \"M\" RECORD INPUT                   */\n/*     INPUT:   LNICHO.DCOLLECT.D                          */\n/*              TYPE D AND M RECORDS                       */\n/*     OUTPUT:  SMS.UMB.DCOLLECT.DMREC.DETAIL              */\n/*     PRESORT: NONE REQUIRED                              */\n/*                                                         */\n/***********************************************************/\n/*                                                         */\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */\n/***********************************************************/\n \"ALLOC F(INFILE) DA('LNICHO.DCOLLECT.D') SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */\n/***********************************************************/\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.DMREC.DETAIL')\",\n  \"DSORG(PS) LRECL(100) RECFM(F B) \",\n  \"TRACKS SPACE(1,5) RELEASE DDNAME(OUTFILE)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n EOF = 'NO'\n DO WHILE EOF='NO'\n   \"EXECIO 1 DISKR INFILE\"\n   IF RC\u00ac= 0 THEN\n      EOF = 'YES'\n   ELSE DO\n      PARSE PULL RECORD\n/***********************************************************/\n/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */\n/***********************************************************/\n      DCURCTYP=SUBSTR(RECORD,5,2)\n         SELECT\n/***********************************************************/\n/* PROCESS ACTIVE   DATA SET INFORMATION RECORD            */\n/***********************************************************/\n         WHEN(DCURCTYP='D ') THEN DO\n                             CALL DCRECORD\n                             CALL DISPLAYDC\n                             END\n/***********************************************************/\n/* PROCESS MIGRATED DATA SET INFORMATION RECORD            */\n/***********************************************************/\n         WHEN(DCURCTYP='M ') THEN DO\n                             CALL UMRECORD\n                             CALL DISPLAYUM\n                             END\n/***********************************************************/\n/* DO NOT PROCESS OTHER RECORD TYPES                       */\n/***********************************************************/\n         OTHERWISE\n         END\n      END\n END\n EXIT\n/***********************************************************/\n/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */\n/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */\n/***********************************************************/\n DCRECORD:\n/*                                                          */\n       DCDDSNAM = SUBSTR(RECORD,25,44)\n       DCDERROR = BITSTR(SUBSTR(RECORD,69,1))\n       DCDFLAG1 = BITSTR(SUBSTR(RECORD,70,1))\n       DCDFLAG2 = BITSTR(SUBSTR(RECORD,71,1))\n       DCDDSORG = C2X(SUBSTR(RECORD,75,2))\n       DCDRECRD = C2X(SUBSTR(RECORD,77,1))\n       DCDNMEXT = C2X(SUBSTR(RECORD,78,1))\n       DCDVOLSR = SUBSTR(RECORD,79,6)\n       DCDBKLNG = C2D(SUBSTR(RECORD,85,2))\n       DCDLRECL = C2D(SUBSTR(RECORD,87,2))\n       DCDALLSP = C2D(SUBSTR(RECORD,89,4))\n       DCDUSESP = C2D(SUBSTR(RECORD,93,4))\n       DCDSCALL = C2D(SUBSTR(RECORD,97,4))\n       DCDNMBLK = C2D(SUBSTR(RECORD,101,4))\n       DCDCREDT = STRIP(C2X(SUBSTR(RECORD,105,4)),T,'F')\n       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD,109,4)),T,'F')\n       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD,113,4)),T,'F')\n       DCDDSSER = SUBSTR(RECORD,117,6)\n       DCDVOLSQ = C2X(SUBSTR(RECORD,123,2))\n       DCDLBKDT = C2X(SUBSTR(RECORD,125,8))\n       DCDDATCL = SUBSTR(RECORD,135,8)\n       DCDSTGCL = SUBSTR(RECORD,167,8)\n       DCDMGTCL = SUBSTR(RECORD,199,8)\n       DCDSTGRP = SUBSTR(RECORD,231,8)\n RETURN\n\n /***********************************************************/\n /* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */\n /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */\n /***********************************************************/\n  UMRECORD:\n        UMDSNAM = SUBSTR(RECORD,25,44)\n        UMFLAG1 = BITSTR(SUBSTR(RECORD,69,1))\n        UMLEVEL = SUBSTR(UMFLAG1,1,2)\n        UMCHIND = SUBSTR(UMFLAG1,3,1)\n        UMDEVCL = SUBSTR(RECORD,70,1)\n        UMDSORG = C2X(SUBSTR(RECORD,71,2))\n        UMDSIZE = C2D(SUBSTR(RECORD,73,4))\n        UMTIME  = C2X(SUBSTR(RECORD,77,4))\n        UMDATE  = STRIP(C2X(SUBSTR(RECORD,81,4)),T,'F')\n        UMDATCL = SUBSTR(RECORD,87,30)\n        UMSTGCL = SUBSTR(RECORD,119,30)\n        UMMGTCL = SUBSTR(RECORD,151,30)\n        UMRECRD = C2X(SUBSTR(RECORD,181,1))\n        UMRECOR = C2X(SUBSTR(RECORD,182,1))\n        UMBKLNG = C2D(SUBSTR(RECORD,183,2))\n        UMFLAG2 = BITSTR(SUBSTR(RECORD,185,1))\n        UMRACFD = SUBSTR(UMFLAG2,1,1)\n        UMGDS   = SUBSTR(UMFLAG2,2,1)\n        UMREBLK = SUBSTR(UMFLAG2,3,1)\n        UMPDSE  = SUBSTR(UMFLAG2,4,1)\n        UMSMSM  = SUBSTR(UMFLAG2,5,1)\n        UMNMIG  = C2D(SUBSTR(RECORD,187,2))\n        UMALLSP = C2D(SUBSTR(RECORD,189,4))\n        UMUSESP = C2D(SUBSTR(RECORD,193,4))\n        UMRECSP = C2D(SUBSTR(RECORD,197,4))\n        UMCREDT = STRIP(C2X(SUBSTR(RECORD,201,4)),T,'F')\n        UMEXPDT = STRIP(C2X(SUBSTR(RECORD,205,4)),T,'F')\n        UMLBKDT = C2X(SUBSTR(RECORD,209,8))\n        UMLRFDT = STRIP(C2X(SUBSTR(RECORD,217,4)),T,'F')\n  RETURN\n\n/***********************************************************/\n/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */\n/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */\n/***********************************************************/\n DISPLAYDC:\n PUSH \"DCDDSNAM=\"   DCDDSNAM\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDERROR=\"   DCDERROR\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDFLAG1=\"   DCDFLAG1\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDFLAG2=\"   DCDFLAG2\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDSORG=\"   DCDDSORG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDRECRD=\"   DCDRECRD\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDNMEXT=\"   DCDNMEXT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDVOLSR=\"   DCDVOLSR\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDBKLNG=\"   DCDBKLNG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLRECL=\"   DCDLRECL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDALLSP=\"   DCDALLSP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDUSESP=\"   DCDUSESP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSCALL=\"   DCDSCALL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDNMBLK=\"   DCDNMBLK\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDCREDT=\"   DCDCREDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDEXPDT=\"   DCDEXPDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLSTRF=\"   DCDLSTRF\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDSSER=\"   DCDDSSER\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDVOLSQ=\"   DCDVOLSQ\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLBKDT=\"   DCDLBKDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDATCL=\"   DCDDATCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSTGCL=\"   DCDSTGCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDMGTCL=\"   DCDMGTCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSTGRP=\"   DCDSTGRP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"*******************************************************\"\n \"EXECIO 1  DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */\n/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */\n/***********************************************************/\n DISPLAYUM:\n PUSH  \"UMDSNAM =\"  UMDSNAM\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMFLAG1 =\"  UMFLAG1\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMLEVEL =\"  UMLEVEL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMCHIND =\"  UMCHIND\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMDEVCL =\"  UMDEVCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMDSORG =\"  UMDSORG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMDSIZE =\"  UMDSIZE\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMTIME  =\"  UMTIME\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMDATE  =\"  UMDATE\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMDATCL =\"  UMDATCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMSTGCL =\"  UMSTGCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMMGTCL =\"  UMMGTCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMRECRD =\"  UMRECRD\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMRECOR =\"  UMRECOR\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMBKLNG =\"  UMBKLNG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMFLAG2 =\"  UMFLAG2\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMRACFD =\"  UMRACFD\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMGDS   =\"  UMGDS\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMREBLK =\"  UMREBLK\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMPDSE  =\"  UMPDSE\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMSMSM  =\"  UMSMSM\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMNMIG  =\"  UMNMIG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMALLSP =\"  UMALLSP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMUSESP =\"  UMUSESP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMRECSP =\"  UMRECSP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMCREDT =\"  UMCREDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMEXPDT =\"  UMEXPDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMLBKDT =\"  UMLBKDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH  \"UMLRFDT =\"  UMLRFDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"*******************************************************\"\n \"EXECIO 1  DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */\n/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */\n/***********************************************************/\n BITSTR:\n       IF BIT.F \u00ac= \"1111\"  THEN DO\n          BIT.0=\"0000\"\n          BIT.1=\"0001\"\n          BIT.2=\"0010\"\n          BIT.3=\"0011\"\n          BIT.4=\"0100\"\n          BIT.5=\"0101\"\n          BIT.6=\"0110\"\n          BIT.7=\"0111\"\n          BIT.8=\"1000\"\n          BIT.9=\"1001\"\n          BIT.A=\"1010\"\n          BIT.B=\"1011\"\n          BIT.C=\"1100\"\n          BIT.D=\"1101\"\n          BIT.E=\"1110\"\n          BIT.F=\"1111\"\n       END\n       CH=C2X(ARG(1))\n       BS=''\n       DO I=1 TO LENGTH(CH)\n          Q=SUBSTR(CH,I,1)\n          BS=BS||BIT.Q\n       END\nRETURN BS\n\n./   ADD   NAME=DSORG\n/* REXX                                                               */\n/*                                                                    */\n/*                                                                    */\n/*                                                                    */\n/* DSORG                                                              */\n/*    PURPOSE: BREAKOUT OF DATA SETS BY DSORG. DONE BY DSN COUNT AND  */\n/*             BY KBYTES WITH PERCENTAGES                             */\n/*    INPUT:   SMS.UMB.DCOLLECT.RECTYPDM                              */\n/*             TYPE D AND M RECORDS                                   */\n/*    OUTPUT:  SMS.PMB.DCOLLECT.DSORG.DCCYYDDD                        */\n/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/*                                                                    */\n/*    DCDDSORG XL2 MAPS AS FOLLOWS:                                   */\n/*                                                                    */\n/*             8000  IS - INDEXED SEQUENTIAL                          */\n/*             4000  PS - PHYSICAL SEQUENTIAL                         */\n/*             2000  DA - DIRECT                                      */\n/*             0200  PO - PARTITIONED                                 */\n/*             0100  U  - UNMOVEABLE                                  */\n/*             0080  GS - GRAPHICS                                    */\n/*             0008  VS - VSAM                                        */\n/*                                                                    */\n/**********************************************************************/\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/\n/***********************************************************/\n TRACE N\n \"ALLOC DD(INFILE) DA('SMS.UMB.DCOLLECT.RECTYPDM') SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* INITIALIZE VARIABLES                                    */\n/***********************************************************/\n OUT_COUNT = 0\n DSORG_TYPES    = ' '\n DSORG_CNT.  = 0\n DSORG_KB.  = 0\n TOT_CNT  = 0\n TOT_KB  = 0\n\n/***********************************************************/\n/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */\n/***********************************************************/\n\n \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n K=1\n CALL DCURECP\n DATE = LEFT(C2X(DCUDATE),7)\n OUT_COUNT = OUT_COUNT + 1\n OUT_LINE.OUT_COUNT = \"DCOLLECT RUN ON:\" DATE\n OUT_COUNT = OUT_COUNT + 1\n OUT_LINE.OUT_COUNT = \" \"\n CALL OUTHEAD\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n\n/***********************************************************/\n/* NOTE: THE DSORG BIT STRING IS CONVERTED TO CHARACTERS   */\n/* TO BE STORED IN A VARIABLE AND THEN CONVERTED BACK TO   */\n/* A BIT-STRING FOR FINAL PROCESSING. SEEMS WHEN A         */\n/* X'4000' GETS STORED AND TREATED AS A WORD, THE X'40'    */\n/* GETS CONVERTED TO A BLANK.                              */\n/***********************************************************/\n\n DO WHILE RECORD.0 > 0\n    DO K = 1 TO RECORD.0\n       CALL DCURECP\n       IF DCURCTYP = \"D \" THEN DO\n          CALL DCDRECP\n          DSN = DCDDSNAM\n          DSORG = C2X(DCDDSORG)\n          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO\n             DSORG_TYPES = DSORG_TYPES DSORG\n             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)\n             END\n          ELSE NOP\n          L = WORDPOS(DSORG,DSORG_TYPES,1)\n          DSORG_CNT.L = DSORG_CNT.L + 1\n          DSORG_KB.L = DSORG_KB.L + C2D(DCDALLSP)\n          TOT_CNT = TOT_CNT + 1\n          TOT_KB = TOT_KB + C2D(DCDALLSP)\n          END\n\n       IF DCURCTYP = \"M \" THEN DO\n          CALL DCMRECP\n          DSN = UMDSNAM\n          DSORG = C2X(UMDSORG)\n          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO\n             DSORG_TYPES = DSORG_TYPES DSORG\n             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)\n             END\n          ELSE NOP\n          L = WORDPOS(DSORG,DSORG_TYPES,1)\n          DSORG_CNT.L = DSORG_CNT.L + 1\n          DSORG_KB.L = DSORG_KB.L + C2D(UMALLSP)\n          TOT_CNT = TOT_CNT + 1\n          TOT_KB = TOT_KB + C2D(UMALLSP)\n          END\n\n    END\n    \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n END\n \"EXECIO 0 DISKR INFILE (FINIS\"\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */\n/***********************************************************/\n OUTNAME = \"'SMS.PMB.DCOLLECT.DSORG.D\"||DATE||\"'\"\n \"ALLOC DSNAME(\"||OUTNAME||\")\",\n     \"DSORG(PS) LRECL(80) RECFM(F B) \",\n     \"TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)\"\n  IF RC\u00ac= 0 THEN DO\n     SAY  'ALLOC OF ('||OUTNAME||') FAILED'\n     EXIT 12\n     END\n\n\n/***********************************************************/\n/* PUT OUT TOTALS BY DSORG                                 */\n/***********************************************************/\n\nL = WORDS(DSORG_TYPES)\nDO K = 1 TO L\n   DSORG = 'ERROR'         /* PRESET TO ERROR IF NO MATCHES ARE FOUND */\n   DSORG_TYPES_BITS = X2C(WORD(DSORG_TYPES,K))\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'01'X) = '01'X THEN\n      UNMOVE = 'U'\n      ELSE UNMOVE = ''\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'40'X) = '40'X THEN\n      DSORG = 'PS'||UNMOVE\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'20'X) = '20'X THEN\n      DSORG = 'DA'||UNMOVE\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'02'X) = '02'X THEN\n      DSORG = 'PO'||UNMOVE\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'80'X) = '80'X THEN\n      DSORG = 'IS'||UNMOVE\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'08'X) = '08'X THEN\n      DSORG = 'VS'||UNMOVE\n   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'80'X) = '80'X THEN\n      DSORG = 'GS'||UNMOVE\n   IF DSORG_TYPES_BITS = '0000'X THEN\n      DSORG = 'UNKNOWN'\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = ,\n       RIGHT(DSORG,8),\n       RIGHT(DSORG_CNT.K,6),\n       RIGHT(DSORG_KB.K,10),\n       (WORD(DSORG_TYPES,K))\nEND\n\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = ,\n    RIGHT(\"TOTAL\",8),\n    RIGHT(TOT_CNT,6),\n    RIGHT(TOT_KB,10)\n\"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE.\"\n\"FREE ALL\"\nEXIT\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE                                   */\n/***********************************************************/\n OUTHEAD:\n/*                                                                    */\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = ,\n       CENTER(\"DSORG\",8),\n       CENTER(\"     \",6),\n       CENTER(\"     \",10),\n       CENTER(\"DSORG\",5)\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = ,\n       CENTER(\"TYPE\",8),\n       CENTER(\"COUNT\",6),\n       CENTER(\"KBYTES\",10),\n       CENTER(\"BITS\",5)\n   OUT_COUNT = OUT_COUNT + 1\n   OUT_LINE.OUT_COUNT = ,\n       CENTER(\"-\",8,\"-\"),\n       CENTER(\"-\",6,\"-\"),\n       CENTER(\"-\",10,\"-\"),\n       CENTER(\"-\",5,\"-\")\n   RETURN\n\n/***********************************************************/\n/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */\n/***********************************************************/\n DCURECP:\n/*                                                          */\n   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n      13 DCUTIME 17 DCUDATE 21 .\n RETURN\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n RETURN\n\n/***********************************************************/\n/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCMRECP:\n/*                                                          */\n   PARSE VAR RECORD.K 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,\n      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,\n      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,\n      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,\n      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,\n      217 UMLRFDT\n RETURN\n./   ADD   NAME=ERRORS\n/* REXX                                                               */\n/*                                                                    */\n/* ERRORS                                                             */\n/*    PURPOSE: LISTS EVERY D RECORD THAT HAS ERROR BITS SET           */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.DCOLLECT.RECTYPDM                              */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*    OUTPUT:  SMS.UMB.DCOLLECT.ERRORS                                */\n/*                                                                    */\n/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/*                                                                    */\n/*    DCDERROR XL1 MAPS AS FOLLOWS:                                   */\n/*                                                                    */\n/*             80  SMS MANAGED INCONSISTENCY                          */\n/*             40  DUPLICATE VVR FOUND                                */\n/*             20  NO SPACE INFORMATION PROVIDED                      */\n/*             10  VSAM INDICATORS INCONSISTENT                       */\n/*             08  NO FMT 1 DSCB FOR THIS DATA SET                    */\n/*                                                                    */\n/**********************************************************************/\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/\n/***********************************************************/\n TRACE N\n INNAME = \"'SMS.UMB.DCOLLECT.RECTYPDM'\"\n \"ALLOC DD(INFILE) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n\n/***********************************************************/\n/* INITIALIZE VARIABLES                                    */\n/***********************************************************/\n OUT_COUNT = 0\n\n/***********************************************************/\n/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */\n/***********************************************************/\n\n \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */\n/***********************************************************/\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.ERRORS')\",\n  \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n  \"SPACE(200,200) RELEASE DDNAME(OUTFILE)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n/***********************************************************/\n/* PROCESS FIRST RECORD FOR DATE COLLECTED INFORMATION     */\n/***********************************************************/\n\n K = 1\n CALL DCURECP\n DATE = LEFT(C2X(DCUDATE),7)\n PUSH \"DCOLLECT RUN ON:\" DATE\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \" \"\n \"EXECIO 1  DISKW OUTFILE\"\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n\n DO WHILE RECORD.0 > 0\n    DO K = 1 TO RECORD.0\n       CALL DCURECP\n       IF DCURCTYP = \"D\" THEN DO\n          CALL DCDRECP\n          IF DCDERROR = '00'X THEN ITERATE\n          IF BITAND(DCDERROR,'80'X) = '80'X THEN DO\n             ERROR = \"SMS MANAGED INCONSISTENCY\"\n             PUSH \"ERROR=\" ERROR\n             \"EXECIO 1  DISKW OUTFILE\"\n             END\n          IF BITAND(DCDERROR,'40'X) = '40'X THEN DO\n             ERROR = \"DUPLICATE VVR FOUND\"\n             PUSH \"ERROR=\" ERROR\n             \"EXECIO 1  DISKW OUTFILE\"\n             END\n          IF BITAND(DCDERROR,'20'X) = '20'X THEN DO\n             ERROR = \"NO SPACE INFORMATION PROVIDED\"\n             PUSH \"ERROR=\" ERROR\n             \"EXECIO 1  DISKW OUTFILE\"\n             END\n          IF BITAND(DCDERROR,'10'X) = '10'X THEN DO\n             ERROR = \"VSAM INDICATORS INCONSISTEN\"\n             PUSH \"ERROR=\" ERROR\n             \"EXECIO 1  DISKW OUTFILE\"\n             END\n          IF BITAND(DCDERROR,'08'X) = '08'X THEN DO\n             ERROR = \"NO FMT 1 DSCB FOR THIS DATA SET\"\n             PUSH \"ERROR=\" ERROR\n             \"EXECIO 1  DISKW OUTFILE\"\n             END\n          CALL DCRECORD\n          CALL DISPLAYDC\n          END\n\n       IF DCURCTYP = \"M\" THEN ITERATE\n\n    END\n    \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n END\n\n\n/***********************************************************/\n/* PUT OUT TOTALS BY DSORG                                 */\n/***********************************************************/\n\n\"EXECIO 0 DISKR INFILE (FINIS\"\n\"EXECIO * DISKW OUTFILE (FINIS\"\n\"FREE ALL\"\nEXIT\n\n\n/***********************************************************/\n/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */\n/***********************************************************/\n DCURECP:\n/*                                                          */\n   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n      13 DCUTIME 17 DCUDATE 21 .\n RETURN\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      142 . 167 DCDSTGCL 174 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 238 .\n RETURN\n\n/***********************************************************/\n/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */\n/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */\n/***********************************************************/\n DCRECORD:\n/*                                                          */\n       DCDDSNAM = SUBSTR(RECORD.K,25,44)\n       DCDERROR = BITSTR(SUBSTR(RECORD.K,69,1))\n       DCDFLAG1 = BITSTR(SUBSTR(RECORD.K,70,1))\n       DCDFLAG2 = BITSTR(SUBSTR(RECORD.K,71,1))\n       DCDDSORG = C2X(SUBSTR(RECORD.K,75,2))\n       DCDRECRD = C2X(SUBSTR(RECORD.K,77,1))\n       DCDNMEXT = C2X(SUBSTR(RECORD.K,78,1))\n       DCDVOLSR = SUBSTR(RECORD.K,79,6)\n       DCDBKLNG = C2D(SUBSTR(RECORD.K,85,2))\n       DCDLRECL = C2D(SUBSTR(RECORD.K,87,2))\n       DCDALLSP = C2D(SUBSTR(RECORD.K,89,4))\n       DCDUSESP = C2D(SUBSTR(RECORD.K,93,4))\n       DCDSCALL = C2D(SUBSTR(RECORD.K,97,4))\n       DCDNMBLK = C2D(SUBSTR(RECORD.K,101,4))\n       DCDCREDT = STRIP(C2X(SUBSTR(RECORD.K,105,4)),T,'F')\n       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD.K,109,4)),T,'F')\n       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD.K,113,4)),T,'F')\n       DCDDSSER = SUBSTR(RECORD.K,117,6)\n       DCDVOLSQ = C2X(SUBSTR(RECORD.K,123,2))\n       DCDLBKDT = C2X(SUBSTR(RECORD.K,125,8))\n       DCDDATCL = SUBSTR(RECORD.K,135,8)\n       DCDSTGCL = SUBSTR(RECORD.K,167,8)\n       DCDMGTCL = SUBSTR(RECORD.K,199,8)\n       DCDSTGRP = SUBSTR(RECORD.K,231,8)\n RETURN\n\n\n/***********************************************************/\n/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */\n/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */\n/***********************************************************/\n DISPLAYDC:\n PUSH \"DCDDSNAM=\"   DCDDSNAM\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDERROR=\"   DCDERROR\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDFLAG1=\"   DCDFLAG1\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDFLAG2=\"   DCDFLAG2\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDSORG=\"   DCDDSORG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDRECRD=\"   DCDRECRD\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDNMEXT=\"   DCDNMEXT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDVOLSR=\"   DCDVOLSR\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDBKLNG=\"   DCDBKLNG\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLRECL=\"   DCDLRECL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDALLSP=\"   DCDALLSP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDUSESP=\"   DCDUSESP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSCALL=\"   DCDSCALL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDNMBLK=\"   DCDNMBLK\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDCREDT=\"   DCDCREDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDEXPDT=\"   DCDEXPDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLSTRF=\"   DCDLSTRF\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDSSER=\"   DCDDSSER\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDVOLSQ=\"   DCDVOLSQ\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDLBKDT=\"   DCDLBKDT\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDDATCL=\"   DCDDATCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSTGCL=\"   DCDSTGCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDMGTCL=\"   DCDMGTCL\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"DCDSTGRP=\"   DCDSTGRP\n \"EXECIO 1  DISKW OUTFILE\"\n PUSH \"*******************************************************\"\n \"EXECIO 1  DISKW OUTFILE\"\n RETURN\n\n\n/***********************************************************/\n/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */\n/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */\n/***********************************************************/\n BITSTR:\n       IF BIT.F \u00ac= \"1111\"  THEN DO\n          BIT.0=\"0000\"\n          BIT.1=\"0001\"\n          BIT.2=\"0010\"\n          BIT.3=\"0011\"\n          BIT.4=\"0100\"\n          BIT.5=\"0101\"\n          BIT.6=\"0110\"\n          BIT.7=\"0111\"\n          BIT.8=\"1000\"\n          BIT.9=\"1001\"\n          BIT.A=\"1010\"\n          BIT.B=\"1011\"\n          BIT.C=\"1100\"\n          BIT.D=\"1101\"\n          BIT.E=\"1110\"\n          BIT.F=\"1111\"\n       END\n       CH=C2X(ARG(1))\n       BS=''\n       DO I=1 TO LENGTH(CH)\n          Q=SUBSTR(CH,I,1)\n          BS=BS||BIT.Q\n       END\nRETURN BS\n./   ADD   NAME=EXPDT\n/* REXX                                                               */\n/*                                                                    */\n/* EXPDT                                                              */\n/*    PURPOSE: READS TYPE D AND M RECORDS FOR ALL DSNS THAT           */\n/*             HAVE AN EXPDT > 0. (VSAM IS EXCLUDED SINCE IT          */\n/*             ALWAYS HAS AN EXPDT = 1999365)                         */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*    OUTPUT:  SMS.UMB.DCOLLECT.EXPDT                                 */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D AND M RECORDS                               */\n/*             SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n\n\nTRACE N\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */\n/***********************************************************/\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR\"\n\n/***********************************************************/\n/* INITIALIZE VARIABLES                                    */\n/***********************************************************/\nOUT_COUNT = 0\nHLQ_STDDSN = 0\nTOT_HLQ = 0\nALLOC = 0\n\n/***********************************************************/\n/* SPECIAL PROCESSING FOR FIRST RECORD                     */\n/***********************************************************/\n\"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\nJ=1\nPARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n   13 DCUTIME 17 DCUDATE 21 .\nCOLDATE  = LEFT(C2X(DCUDATE),7)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = \"DATA COLLECTED ON:\" COLDATE\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = \" \"\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"DSN\",44),\n    LEFT(\"EXPDT\",7)\nOUT_COUNT = OUT_COUNT + 1\nOUT_LINE.OUT_COUNT = LEFT(\"-\",44,\"-\"),\n    RIGHT(\"-\",7,\"-\")\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\nDO WHILE IN_REC.0 > 0\n   DO J = 1 TO IN_REC.0\n      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n         13 DCUTIME 17 DCUDATE 21 .\n      SELECT\n         WHEN DCURCTYP = 'D ' THEN CALL DCDRECP\n         WHEN DCURCTYP = 'M ' THEN CALL DCMRECP\n         OTHERWISE ITERATE\n         END\n      IF EXPDT \u00ac= 0 THEN DO\n          IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN ITERATE\n             /* IGNORE VSAM DATA           */\n             /* SINCE EXPDT = 99365        */\n          OUT_COUNT = OUT_COUNT + 1\n          OUT_LINE.OUT_COUNT = LEFT(DSNAME,44),\n          RIGHT(EXPDT,7),\n          MIGRATE\n          END\n      END\n      \"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\n   END\n\n/***********************************************************/\n/*  FREE INPUT FILE AND CREATE OUTPUT FILE                 */\n/***********************************************************/\n\"EXECIO 0 DISKR FILEA (FINIS\"\n\"FREE DDNAME(FILEA)\"\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.EXPDT')\",\n    \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n    \"SPACE(100,50) RELEASE DDNAME(OUTDD)\"\n\"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE.\"\n\"FREE DDNAME(OUTDD)\"\nEXIT\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n   EXPDT = LEFT(C2X(DCDEXPDT),7)\n   DSNAME = DCDDSNAM\n   DSORG = DCDDSORG\n   MIGRATE = \" \"\n RETURN\n\n/***********************************************************/\n/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCMRECP:\n/*                                                          */\n   PARSE VAR IN_REC.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,\n      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,\n      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,\n      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,\n      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,\n      217 UMLRFDT\n   EXPDT = LEFT(C2X(UMEXPDT),7)\n   DSNAME = UMDSNAM\n   DSORG = UMDSORG\n   MIGRATE = \"MIGRATED\"\n RETURN\n./   ADD   NAME=HLQSUM\n/* REXX                                                               */\n/*                                                                    */\n/* HLQSUM                                                             */\n/*    PURPOSE: READS DCOLLECT \"D\" \"M\" AND \"B\" RECORDS AND PRODUCES    */\n/*             A REPORT SUMMARIZED BY HLQ OF BYTES ALLOCATED AT EACH  */\n/*             LEVEL (L0, ML1, AND ML2) AS WELL AS BACKUP BYTES       */\n/*                                                                    */\n/*             PRODUCES A SUMMARY REPORT OF THE FOLLOWING:            */\n/*                                                                    */\n/*                TOTAL FROM VOLUME (V) RECORDS:                      */\n/*                   TOTAL AVAILABLE KBYTES                           */\n/*                   TOTAL ALLOCATED KBYTES                           */\n/*                   SMS AVAILABLE KBYTES                             */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                                                                    */\n/*                TOTAL FROM D, M AND B RECORDS:                      */\n/*                   L0+ML1+ML2 DSN COUNT                             */\n/*                   TOTAL L0 + ML1 +ML2 ALLOCATED                    */\n/*                   TOTAL BACKUP KBYTES                              */\n/*                   L0 DSN COUNT                                     */\n/*                   L0 ALLOCATED KBYTES                              */\n/*                   L0 USED KBYTES                                   */\n/*                   SMS DSN COUNT                                    */\n/*                   SMS ALLOCATED KBYTES                             */\n/*                   ML1 DSN COUNT                                    */\n/*                   ML1 ALLOCATED KBYTES                             */\n/*                   ML1 ORIGINAL KBYTES                              */\n/*                   ML2 DSN COUNT                                    */\n/*                   ML2 ALLOCATED KBYTES                             */\n/*                   ML2 ORIGINAL KBYTES                              */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.DMB                                    */\n/*             TYPE D, M AND B RECORDS                                */\n/*                                                                    */\n/*             SMS.UMB.DCOLLECT.RECTYPV                               */\n/*             TYPE V RECORDS                                         */\n/*                                                                    */\n/*    OUTPUT:  SMS.PMB.DCOLLECT.SUMMARY.DCCYYDDD                      */\n/*             SMS.PMB.DCOLLECT.HLQ.DETAIL.DCCYYDDD                   */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D, M AND B RECORDS                            */\n/*             SORT FIELDS=(29,44,CH,A),                              */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,                    */\n/*                           (9,2,CH,EQ,C'M '),OR,                    */\n/*                           (9,2,CH,EQ,C'B '))                       */\n/*                                                                    */\n/*             FOR TYPE V RECORDS                                     */\n/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */\n/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M,B RECORDS) */\n/***********************************************************/\nTRACE N\n INNAME = \"'SMS.UMB.DCOLLECT.DMB'\"\n \"ALLOC F(INFILE) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n/***********************************************************/\n/* SPECIAL PROCESSING FOR FIRST RECORD                     */\n/***********************************************************/\n \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n CALL INITHLQ\n CALL INITTOT\n J = 1\n PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,\n    13 DCUTIME 17 DCUDATE 21 . 25 DCDDSNAM 69 .\n DATE  = LEFT(C2X(DCUDATE),7)\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY HLQ REPORT   */\n/***********************************************************/\n \"ALLOC DSNAME('SMS.PMB.DCOLLECT.HLQ.DETAIL.D\"||DATE||\"')\",\n  \"DSORG(PS) LRECL(172) RECFM(F B) AVGREC(U)\",\n  \"SPACE(2000,1000) RELEASE DDNAME(OUTFILE)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n PARSE VAR DCDDSNAM RECHLQ \".\" .\n IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)\n HLQ=RECHLQ\n OUT_LINE = \"DATA COLLECTED ON:\" DATE\n PUSH OUT_LINE\n \"EXECIO 1 DISKW OUTFILE\"\n OUT_LINE = \" \"\n PUSH OUT_LINE\n \"EXECIO 1 DISKW OUTFILE\"\n CALL OUTHEAD\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n DO WHILE RECORD.0 > 0\n    DO J = 1 TO RECORD.0\n      PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 . 25 DCDDSNAM 69 .\n      PARSE VAR DCDDSNAM RECHLQ \".\" .\n      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)\n      IF RECHLQ \u00ac= HLQ THEN DO\n         CALL OUTHLQ\n         HLQ = RECHLQ\n         END\n      SELECT\n         WHEN(DCURCTYP='D ') THEN DO               /* ACTIVE DATA  */\n            CALL DCDRECP\n            CALL DNEWINFO\n            END\n         WHEN(DCURCTYP='M ') THEN DO               /* MIGRATED DATA*/\n            CALL DCMRECP\n            CALL MNEWINFO\n            END\n         WHEN(DCURCTYP='B ') THEN DO               /* BACKUP DATA  */\n            CALL DCBRECP\n            CALL BNEWINFO\n            END\n         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */\n         END\n      END\n      \"EXECIO 10000 DISKR INFILE (STEM RECORD.\"\n END\n CALL OUTHLQ\n \"EXECIO 0 DISKR INFILE (FINIS\"\n \"EXECIO 0 DISKW OUTFILE (FINIS\"\n \"FREE DDNAME(INFILE)\"\n \"FREE DDNAME(OUTFILE)\"\n\n/***********************************************************/\n/*   ALLOCATE NEW SUMMARY DATA SET                         */\n/***********************************************************/\n\n\"ALLOC DSNAME('SMS.PMB.DCOLLECT.SUMMARY.D\"||DATE||\"')\",\n   \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n   \"SPACE(10,5) RELEASE DDNAME(OUTSUM)\"\n\n/***********************************************************/\n/*   PROCESS TYPE 'V' VOLUME INFORMATION RECORDS           */\n/***********************************************************/\n\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPV') DDNAME(FILEV) SHR\"\n\"EXECIO * DISKR FILEV (FINIS STEM IN_RECV.\"\n\"FREE DDNAME(FILEV)\"\nTOT_AVAIL_ALLOC_KBYTES = 0\nSMS_AVAIL_ALLOC_KBYTES = 0\nTOT_AVAIL_KBYTES       = 0\nSMS_AVAIL_KBYTES       = 0\nL = 0\nDO K = 1 TO IN_RECV.0\n   PARSE VAR IN_RECV.K 1 . 25 DCVVOLSR 31 DCVFLAG1,\n      32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,\n      45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,\n      65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .\n   TOT_AVAIL_ALLOC_KBYTES = TOT_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)\n   TOT_AVAIL_KBYTES = TOT_AVAIL_KBYTES + C2D(DCVVLCAP)\n   IF BITAND(DCVFLAG1,'03'X) = '03'X THEN DO           /* IS IT SMS?  */\n      SMS_AVAIL_ALLOC_KBYTES = SMS_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)\n      SMS_AVAIL_KBYTES = SMS_AVAIL_KBYTES + C2D(DCVVLCAP)\n   END\nEND\nL = L + 1\nOUT_LINE2.L = \"DATA COLLECTED ON:\" DATE\nL = L + 1\nOUT_LINE2.L= \" \"\nL = L + 1\nOUT_LINE2.L = \"TOTAL FROM VOLUME (V) RECORDS:\"\nL = L + 1\nOUT_LINE2.L = \" \"\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"TOTAL AVAILABLE KBYTES\",30),\n    RIGHT(TOT_AVAIL_KBYTES,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"TOTAL ALLOCATED KBYTES\",30),\n    RIGHT(TOT_AVAIL_ALLOC_KBYTES,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"SMS AVAILABLE KBYTES\",30),\n    RIGHT(SMS_AVAIL_KBYTES,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"SMS ALLOCATED KBYTES\",30),\n    RIGHT(SMS_AVAIL_ALLOC_KBYTES,11)\nL = L + 1\nOUT_LINE2.L = \" \"\nL = L + 1\nOUT_LINE2.L = \" \"\nL = L + 1\nOUT_LINE2.L = \"TOTAL FROM D, M AND B RECORDS:\"\nL = L + 1\nOUT_LINE2.L = \" \"\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"L0+ML1+ML2 DSN COUNT\",30),\n    RIGHT(TOT_ALL_DSN_CTR,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"TOTAL L0 + ML1 +ML2 ALLOCATED KBYTES\",30),\n    RIGHT(TOT_KB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"TOTAL BACKUP KBYTES\",30),\n    RIGHT(TOT_BKKB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"L0 DSN COUNT\",30),\n    RIGHT(TOT_L0_DSN_CTR,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"L0 ALLOCATED KBYTES\",30),\n    RIGHT(TOT_L0KB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"L0 USED KBYTES\",30),\n    RIGHT(TOT_L0USEKB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"SMS DSN COUNT\",30),\n    RIGHT(TOT_SMS_DSN_CTR,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"SMS ALLOCATED KBYTES\",30),\n    RIGHT(TOT_SMS_L0KB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML1 DSN COUNT\",30),\n    RIGHT(TOT_ML1_DSN_CTR,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML1 ALLOCATED KBYTES\",30),\n    RIGHT(TOT_ML1KB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML1 ORIGINAL KBYTES\",30),\n    RIGHT(TOT_ML1_ORGKB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML2 DSN COUNT\",30),\n    RIGHT(TOT_ML2_DSN_CTR,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML2 ALLOCATED KBYTES\",30),\n    RIGHT(TOT_ML2KB,11)\nL = L + 1\nOUT_LINE2.L = \"  \" LEFT(\"ML2 ORIGINAL KBYTES\",30),\n    RIGHT(TOT_ML2_ORGKB,11)\n/*                                                                    */\n/**********************************************************************/\n/*   WRITE OUT HLQ SUMMARY AND VOLUME SUMMARY RECORDS TO DASD         */\n/**********************************************************************/\n/*                                                                    */\n\"EXECIO * DISKW OUTSUM (FINIS STEM OUT_LINE2.\"\n\"FREE DDNAME(OUTSUM)\"\n\n EXIT\n\n\n/***********************************************************/\n/*         R O U T I N E S                                 */\n/***********************************************************/\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE                                   */\n/***********************************************************/\n OUTHEAD:\n/*                                                          */\n   OUT_LINE = LEFT(\"    \",8),\n      RIGHT(\"L0+ML1+ML2\",10),\n      RIGHT(\"L0 \",10),\n      RIGHT(\"L0\",11),\n      RIGHT(\"L0\",11),\n      RIGHT(\"SMS\",10),\n      RIGHT(\"SMS L0\",11),\n      RIGHT(\"ML1\",10),\n      RIGHT(\"ML1\",11),\n      RIGHT(\"   \",11),\n      RIGHT(\"ML2\",10),\n      RIGHT(\"ML2\",11),\n      RIGHT(\"   \",11),\n      RIGHT(\"   \",11),\n      RIGHT(\"   \",11)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = LEFT(\"    \",8),\n      RIGHT(\"DSN\",10),\n      RIGHT(\"DSN\",10),\n      RIGHT(\"ALLOCATED\",11),\n      RIGHT(\"USED\",11),\n      RIGHT(\"DSN\",10),\n      RIGHT(\"ALLOCATED\",11),\n      RIGHT(\"DSN\",10),\n      RIGHT(\"ORGINAL\",11),\n      RIGHT(\"ML1\",11),\n      RIGHT(\"DSN\",10),\n      RIGHT(\"ORGINAL\",11),\n      RIGHT(\"ML2\",11),\n      RIGHT(\"L0+ML1+ML2\",11),\n      RIGHT(\"BACKUP\",11)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = LEFT(\"HLQ\",8),\n      RIGHT(\"COUNT\",10),\n      RIGHT(\"COUNT\",10),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"COUNT\",10),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"COUNT\",10),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"COUNT\",10),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"KBYTES\",11),\n      RIGHT(\"KBYTES\",11)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   OUT_LINE = LEFT(\"-\",8,\"-\"),\n      RIGHT(\"-\",10,\"-\"),\n      RIGHT(\"-\",10,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",10,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",10,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",10,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",11,\"-\"),\n      RIGHT(\"-\",11,\"-\")\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */\n/***********************************************************/\nOUTHLQ:\n/*                                                          */\n   OUT_LINE = LEFT(HLQ,8),\n      RIGHT(HLQ_ALL_DSN_CTR,10),\n      RIGHT(HLQ_L0_DSN_CTR,10),\n      RIGHT(HLQ_L0KB,11),\n      RIGHT(HLQ_L0USEKB,11),\n      RIGHT(HLQ_SMS_DSN_CTR,10),\n      RIGHT(HLQ_SMS_L0KB,11),\n      RIGHT(HLQ_ML1_DSN_CTR,10),\n      RIGHT(HLQ_ML1_ORGKB,11),\n      RIGHT(HLQ_ML1KB,11),\n      RIGHT(HLQ_ML2_DSN_CTR,10),\n      RIGHT(HLQ_ML2_ORGKB,11),\n      RIGHT(HLQ_ML2KB,11),\n      RIGHT(HLQ_KB,11),\n      RIGHT(HLQ_BKKB,11)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   CALL INITHLQ\n RETURN\n\n/***********************************************************/\n/* PUT IN \"D\" INFO FOR NEW DATASET                         */\n/***********************************************************/\n DNEWINFO:\n/*                                                          */\n   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1\n   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1\n   HLQ_L0_DSN_CTR  = HLQ_L0_DSN_CTR + 1\n   TOT_L0_DSN_CTR  = TOT_L0_DSN_CTR + 1\n   IF DCDUSESP > DCDALLSP THEN DCDUSESP = DCDALLSP   /* BAD DATA      */\n   IF SUBSTR(DCDDSORG,2,1) = '08'X THEN DCDUSESP = DCDALLSP\n                                                   /*  VSAM DATA      */\n   HLQ_L0KB = HLQ_L0KB + DCDALLSP\n   HLQ_L0USEKB = HLQ_L0USEKB + DCDUSESP\n   HLQ_KB = HLQ_KB + DCDALLSP\n   TOT_L0KB = TOT_L0KB + DCDALLSP\n   TOT_L0USEKB = TOT_L0USEKB + DCDUSESP\n   TOT_KB = TOT_KB + DCDALLSP\n   IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO           /* IS IT SMS?  */\n      TOT_SMS_L0KB = TOT_SMS_L0KB + DCDALLSP\n      TOT_SMS_DSN_CTR = TOT_SMS_DSN_CTR + 1\n      HLQ_SMS_L0KB = HLQ_SMS_L0KB + DCDALLSP\n      HLQ_SMS_DSN_CTR = HLQ_SMS_DSN_CTR + 1\n      END\n RETURN\n\n/***********************************************************/\n/* PUT IN \"M\" INFO FOR NEW DATASET                         */\n/***********************************************************/\n MNEWINFO:\n/*                                                          */\n   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1\n   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1\n   IF BITAND(UMFLAG1,'40'X) = '40'X THEN DO\n      HLQ_ML1_DSN_CTR = HLQ_ML1_DSN_CTR + 1\n      TOT_ML1_DSN_CTR = TOT_ML1_DSN_CTR + 1\n      HLQ_ML1_ORGKB = HLQ_ML1_ORGKB + UMALLSP\n      HLQ_KB = HLQ_KB + UMALLSP\n      HLQ_ML1KB = HLQ_ML1KB + UMDSIZE\n      TOT_ML1_ORGKB = TOT_ML1_ORGKB + UMALLSP\n      TOT_KB = TOT_KB + UMALLSP\n      TOT_ML1KB = TOT_ML1KB + UMDSIZE\n      END\n     ELSE DO\n      HLQ_ML2_DSN_CTR = HLQ_ML2_DSN_CTR + 1\n      TOT_ML2_DSN_CTR = TOT_ML2_DSN_CTR + 1\n      HLQ_ML2_ORGKB = HLQ_ML2_ORGKB + UMALLSP\n      HLQ_KB = HLQ_KB + UMALLSP\n      HLQ_ML2KB = HLQ_ML2KB + UMDSIZE\n      TOT_ML2_ORGKB = TOT_ML2_ORGKB + UMALLSP\n      TOT_KB = TOT_KB + UMALLSP\n      TOT_ML2KB = TOT_ML2KB + UMDSIZE\n      END\n RETURN\n\n/***********************************************************/\n/* PUT IN \"B\" INFO FOR NEW DATASET                         */\n/***********************************************************/\n BNEWINFO:\n/*                                                          */\n   HLQ_BKKB = HLQ_BKKB+UBDSIZE\n   TOT_BKKB = TOT_BKKB+UBDSIZE\n RETURN\n\n/***********************************************************/\n/* INIT ALL HLQ SUMMARY FIELDS                             */\n/***********************************************************/\n INITHLQ:\n/*                                                          */\n   HLQ_L0KB = 0\n   HLQ_L0USEKB = 0\n   HLQ_ML1_DSN_CTR = 0\n   HLQ_ML1_ORGKB = 0\n   HLQ_ML1KB = 0\n   HLQ_ML2_DSN_CTR = 0\n   HLQ_ML2_ORGKB = 0\n   HLQ_ML2KB = 0\n   HLQ_KB = 0\n   HLQ_BKKB = 0\n   HLQ_L0_DSN_CTR = 0\n   HLQ_ALL_DSN_CTR = 0\n   HLQ_SMS_L0KB = 0\n   HLQ_SMS_DSN_CTR = 0\n RETURN\n\n/***********************************************************/\n/* INIT ALL TOT SUMMARY FIELDS                             */\n/***********************************************************/\n INITTOT:\n/*                                                          */\n   TOT_L0KB = 0\n   TOT_L0USEKB = 0\n   TOT_ML1_DSN_CTR = 0\n   TOT_ML1_ORGKB = 0\n   TOT_ML1KB = 0\n   TOT_ML2_DSN_CTR = 0\n   TOT_ML2_ORGKB = 0\n   TOT_ML2KB = 0\n   TOT_KB = 0\n   TOT_BKKB = 0\n   TOT_L0_DSN_CTR = 0\n   TOT_ALL_DSN_CTR = 0\n   TOT_SMS_L0KB = 0\n   TOT_SMS_DSN_CTR = 0\n RETURN\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD.J 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n   DCDALLSP = C2D(DCDALLSP)\n   DCDUSESP = C2D(DCDUSESP)\n RETURN\n\n/***********************************************************/\n/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCMRECP:\n/*                                                          */\n   PARSE VAR RECORD.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,\n      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,\n      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,\n      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,\n      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,\n      217 UMLRFDT\n   UMALLSP = C2D(UMALLSP)\n   UMDSIZE = C2D(UMDSIZE)\n RETURN\n\n/***********************************************************/\n/* PARSE   BACKUP   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCBRECP:\n/*                                                          */\n   PARSE VAR RECORD.J 1 . 25 UBDSNAM 69 UBFLAG1 70 UBDEVCL,\n      71 UBDSORG 73 UBDSIZE 77 UBTIME 81 UBDATE 85 . 87 UBDATCL,\n      117 . 119 UBSTGCL 149 . 151 UBMGTCL 181 UBRECRD 182 UBRECOR,\n      183 UBBKLNG 185 UBFLAG2 186 . 187 UBNMIG 189 UBALLSP,\n      193 UBUSESP 197 UBRECSP 200\n   UBDSIZE = C2D(UBDSIZE)\n RETURN\n./   ADD   NAME=MULTIVOL\n/* REXX                                                               */\n/*                                                                    */\n/* MULTIVOL                                                           */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             THE VOLSER AND DSN FOR ALL RECORDS                     */\n/*             THAT HAVE A VOLUME SEQUENCE NUMBER > 1                 */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*    OUTPUT:  REXX SAY TO DEFAULT OUTPUT STREAM                      */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D AND M RECORDS                               */\n/*             SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n\nTRACE N\n\"FREE DDNAME(FILEA)\"\n\"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR\"\n\"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\nDO WHILE IN_REC.0 > 0\n   DO J = 1 TO IN_REC.0\n      PARSE VAR IN_REC.J S1 5 DCURCTYP 7\n      IF DCURCTYP \u00ac= 'D ' THEN ITERATE J\n      PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 .  79 DCDVOLSR,\n         85 . 123 DCDVOLSQ 125 .\n      IF DCDVOLSQ > '0001'X THEN SAY DCDVOLSR DCDDSNAM\n   END\n   \"EXECIO 10000 DISKR FILEA (STEM IN_REC.\"\nEND\n\"EXECIO 0 DISKR FILEA (FINIS\"\n\"FREE DDNAME(FILEA)\"\nEXIT\n./   ADD   NAME=NONSMS\n/* REXX                                                               */\n/*                                                                    */\n/* NONSMS                                                             */\n/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */\n/*             NON-SMS DSNS AND THE VOLSER THEY ARE ON.               */\n/*             FOR EACH HLQ, LISTS OUT NUMBER OF DATASETS,            */\n/*             SIZE IN KBYTES, SIZE FOR PRIME POOL (OURS IS           */\n/*             DEFINED AS <102400 KBYTES), SIZE FOR LARGE POOL        */\n/*             (ANY DSN >1024000 KBYTES), AND KYBTES NOT              */\n/*             REFERENCED IN THE LAST 30 DAYS.                        */\n/*                                                                    */\n/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */\n/*             TYPE D AND M RECORDS                                   */\n/*                                                                    */\n/*             (NOTE: EVEN THOUGH D AND M ARE BOTH INPUT, ONLY        */\n/*              D IS USED)                                            */\n/*                                                                    */\n/*    OUTPUT:  SMS.PMB.DCOLLECT.NONSMS.DCCYYDDD                       */\n/*                                                                    */\n/*    PRESORT: FOR TYPE D AND M RECORDS                               */\n/*             SORT FIELDS=(29,44,CH,A)                               */\n/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */\n/*                                                                    */\n/*                                                                    */\n/**********************************************************************/\n\n/***********************************************************/\n/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */\n/***********************************************************/\nTRACE N\n INNAME = \"'SMS.UMB.DCOLLECT.RECTYPDM'\"\n \"ALLOC DDNAME(INFILE) DA(\"INNAME\") SHR\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('INNAME') FAILED'\n    EXIT 8\n    END\n\n EXCLUDES = 'HSM BHSM'\n EXCL = 'HSM BHS'\n\n/***********************************************************/\n/* SPECIAL PROCESSING FOR FIRST RECORD                     */\n/***********************************************************/\n EOF = 'NO'\n FIRST = 'NO'\n DO UNTIL FIRST = 'YES'\n    \"EXECIO 1 DISKR INFILE\"\n    IF RC\u00ac= 0 THEN\n       EOF = 'YES'\n    ELSE DO\n       PARSE PULL RECORD\n       PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,\n          25 RECDSN 69 . 70 DCDFLAG1 71 . 231 DCDSTGRP 239 .\n       IF BITAND(DCDFLAG1,'40'X) \u00ac= '40'X THEN FIRST = 'YES'\n       IF DCURCTYP \u00ac= 'D ' THEN FIRST = 'NO'\n       END\n END\n CALL INITDSN\n CALL INITHLQ\n CALL INITTOT\n DATE  = LEFT(C2X(DCUDATE),7)\n DSNAME=RECDSN\n PARSE VAR RECDSN RECHLQ \".\" .\n IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)\n HLQ=RECHLQ\n\n/***********************************************************/\n/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */\n/***********************************************************/\nOUTNAME =\"SMS.PMB.DCOLLECT.NONSMS.D\"||DATE\n\"ALLOC DSNAME('SMS.PMB.DCOLLECT.NONSMS.D\"||DATE||\"')\",\n  \"DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)\",\n  \"SPACE(5000,5000) RELEASE DDNAME(OUTFILE)\"\n IF RC\u00ac= 0 THEN DO\n    SAY  'ALLOCATION OF ('OUTNAME') FAILED'\n    EXIT 12\n    END\n\n COLDATE  = RIGHT(LEFT(C2X(DCUDATE),7),5)\n COLYY = LEFT(COLDATE,2)\n COLDDD = RIGHT(COLDATE,3)\n OUT_LINE = \"DATA COLLECTED ON:\" LEFT(C2X(DCUDATE),7)\n PUSH OUT_LINE\n \"EXECIO 1 DISKW OUTFILE\"\n CALL OUTHEAD\n HLQ_DSN_CTR=1\n TOT_DSN_CTR=1\n CALL DCDRECP\n CALL DNEWINFO\n\n/***********************************************************/\n/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */\n/***********************************************************/\n EOF = 'NO'\n DO WHILE EOF='NO'\n   \"EXECIO 1 DISKR INFILE\"\n   IF RC\u00ac= 0 THEN DO\n      EOF = 'YES'\n      CALL OUTLINE\n      CALL OUTHLQ\n      CALL OUTTOT\n      END\n   ELSE DO\n      PARSE PULL RECORD\n      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 25 RECDSN 69 .\n      PARSE VAR RECDSN RECHLQ \".\" .\n      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)\n      SELECT\n         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */\n                         CALL DCDRECP\n                         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN ITERATE\n                         END\n         WHEN(DCURCTYP='M ') THEN ITERATE        /* MIGRATED DATA     */\n         OTHERWISE ITERATE    /* DO NOT PROCESS OTHER RECORD TYPES */\n         END\n\n/***********************************************************/\n/*        OUTPUT OUTLINE TO FILE AND STORE NEW INFO        */\n/***********************************************************/\n      CALL OUTLINE\n      DSNAME=RECDSN\n      PARSE VAR RECDSN RECHLQ \".\" .\n      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)\n         IF RECHLQ \u00ac= HLQ THEN CALL OUTHLQ\n      IF WORDPOS(RECHLQ,EXCLUDES) = 0 THEN DO\n         HLQ_DSN_CTR = HLQ_DSN_CTR + 1\n         TOT_DSN_CTR = TOT_DSN_CTR + 1\n         END\n      HLQ = RECHLQ\n      SELECT\n         WHEN(DCURCTYP='D ') THEN DO         /* ACTIVE DATA       */\n                          CALL DNEWINFO\n                          END\n         WHEN(DCURCTYP='M ') THEN NOP         /* MIGRATED DATA     */\n         WHEN(DCURCTYP='B ') THEN NOP         /* BACKUP DATA       */\n         OTHERWISE NOP        /* DO NOT PROCESS OTHER RECORD TYPES */\n         END\n      END\n END\n \"EXECIO 0 DISKW OUTFILE (FINIS\"\n \"EXECIO * DISKR INFILE (FINIS\"\n \"FREE DDNAME(INFILE)\"\n \"FREE DDNAME(OUTFILE)\"\n EXIT\n\n\n/***********************************************************/\n/* PUT OUT A HEADER LINE                                   */\n/***********************************************************/\n OUTHEAD:\n/*                                                          */\n    OUT_LINE = \"  \"\n    PUSH OUT_LINE\n    \"EXECIO 1 DISKW OUTFILE\"\n    OUT_LINE = LEFT(\" \",17),\n       RIGHT(\"DSN\",7),\n       RIGHT(\"L0\",9),\n       RIGHT(\"PRIME\",9),\n       RIGHT(\"LARGE\",9),\n       RIGHT(\">30DAYS\",9)\n    PUSH OUT_LINE\n    \"EXECIO 1 DISKW OUTFILE\"\n    OUT_LINE = LEFT(\"HLQ/DSN\",17),\n       RIGHT(\"COUNT\",7),\n       RIGHT(\"KBYTES\",9),\n       RIGHT(\"POOL\",9),\n       RIGHT(\"POOL\",9),\n       RIGHT(\"LASTREF\",9)\n    PUSH OUT_LINE\n    \"EXECIO 1 DISKW OUTFILE\"\n    OUT_LINE = LEFT(\"-\",17,\"-\"),\n       RIGHT(\"-\",7,\"-\"),\n       RIGHT(\"-\",9,\"-\"),\n       RIGHT(\"-\",9,\"-\"),\n       RIGHT(\"-\",9,\"-\"),\n       RIGHT(\"-\",9,\"-\")\n    PUSH OUT_LINE\n    \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT OUT A DETAIL LINE                                   */\n/***********************************************************/\n OUTDET:\n/*                                                          */\n   OUT_LINE = LEFT(\"  \",2),\n      LEFT(DCDDSNAM,62),\n      LEFT(DCDVOLSR,8)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */\n/***********************************************************/\nOUTLINE:\n   CALL INITDSN\n RETURN\n\n/***********************************************************/\n/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */\n/***********************************************************/\nOUTHLQ:\n/*                                                          */\n   OUT_LINE = '*',\n      LEFT(HLQ,8),\n      '      ',\n      RIGHT(HLQ_DSN_CTR,7),\n      RIGHT(HLQ_L0KB,9),\n      RIGHT(HLQ_PRKB,9),\n      RIGHT(HLQ_LGKB,9),\n      RIGHT(HLQ_GT30,9)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n   CALL INITHLQ\n RETURN\n\n/***********************************************************/\n/* PUT SUMMARIZED TOTAL INFO OUT TO NEW FILE               */\n/***********************************************************/\nOUTTOT:\n/*                                                          */\n   OUT_LINE = '* TOTAL  ',\n      '       ',\n      RIGHT(TOT_DSN_CTR,7),\n      RIGHT(TOT_L0KB,9),\n      RIGHT(TOT_PRKB,9),\n      RIGHT(TOT_LGKB,9),\n      RIGHT(TOT_GT30,9)\n   PUSH OUT_LINE\n   \"EXECIO 1 DISKW OUTFILE\"\n RETURN\n\n/***********************************************************/\n/* PUT IN \"D\" INFO FOR NEW DATASET                         */\n/***********************************************************/\n DNEWINFO:\n/*                                                          */\n   IF WORDPOS(SUBSTR(DCDDSNAM,1,3),EXCL) = 0 THEN DO\n      L0KBYTES = DCDALLSP\n      HLQ_L0KB = HLQ_L0KB+DCDALLSP\n      TOT_L0KB = TOT_L0KB+DCDALLSP\n      CALL REF\n      IF L0KBYTES < 102400 THEN DO\n            PRKBYTES = PRKBYTES\n            HLQ_PRKB = HLQ_PRKB + DCDALLSP\n            TOT_PRKB = TOT_PRKB + DCDALLSP\n         END\n         ELSE DO\n            LGKBYTES = LGKBYTES\n            HLQ_LGKB = HLQ_LGKB + DCDALLSP\n            TOT_LGKB = TOT_LGKB + DCDALLSP\n         END\n      CALL OUTDET\n      END\n RETURN\n\n\n/***********************************************************/\n/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */\n/* ALL DATA, BOTH SMS AND NON-SMS                          */\n/* BASED ON COLLECTION DATE OF DATA                        */\n/***********************************************************/\n\n REF:\n      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */\n         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */\n         REFDDD = CREDDD               /*  CREATION DATE              */\n         END\n      IF COLDDD <= REFDDD THEN DO\n         REFYY = REFYY - 1\n         REFDDD = REFDDD + 365\n         END\n      REFDAYS = COLDDD - REFDDD\n      REFYRS = COLYY - REFYY\n      REFDAYS = REFDAYS + (REFYRS * 365)\n\n      SYS = 'NO'\n      VSINDX = 'NO'\n      IF SUBSTR(DSN,1,9) = \"SYS1.VVDS\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,9) = \"SYS1.VTOC\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,9) = \"BHSM.VTOC\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,6) = \"PAGE.V\" THEN SYS = 'YES'\n      IF SUBSTR(DSN,1,4) = \"SYS9\" THEN SYS = 'YES'\n      IF INDEX(DSN,'DUMYDSCB') >0 THEN SYS = 'YES'\n      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO\n         VS = 'YES'\n         IF INDEX(DSN,'INDEX') >0 THEN VSINDX = 'YES'\n         END\n\n      SELECT\n         WHEN SYS = 'YES' THEN NOP\n         WHEN VSINDX = 'YES' THEN NOP\n         WHEN REFDAYS > 30 THEN DO\n            GT30YTES = DCDALLSP\n            HLQ_GT30 = HLQ_GT30 + DCDALLSP\n            TOT_GT30 = TOT_GT30 + DCDALLSP\n            END\n      OTHERWISE\n      END                                        /* END OF SELECT     */\n RETURN\n\n/***********************************************************/\n/* INIT ALL DSN SUMMARY FIELDS                             */\n/***********************************************************/\n INITDSN:\n/*                                                          */\n   L0KBYTES = 0\n   PRKBYTES = 0\n   LGKBYTES = 0\n   GT30YTES = 0\n RETURN\n\n/***********************************************************/\n/* INIT ALL HLQ SUMMARY FIELDS                             */\n/***********************************************************/\n INITHLQ:\n/*                                                          */\n   HLQ_L0KB = 0\n   HLQ_PRKB = 0\n   HLQ_LGKB = 0\n   HLQ_GT30 = 0\n   HLQ_DSN_CTR = 0\n   HLQ_TOT = 0\n RETURN\n\n/***********************************************************/\n/* INIT ALL TOT SUMMARY FIELDS                             */\n/***********************************************************/\n INITTOT:\n/*                                                          */\n   TOT_L0KB = 0\n   TOT_PRKB = 0\n   TOT_LGKB = 0\n   TOT_GT30 = 0\n   TOT_DSN_CTR = 0\n   TOT_TOT = 0\n RETURN\n\n/***********************************************************/\n/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */\n/***********************************************************/\n DCDRECP:\n/*                                                          */\n   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,\n      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,\n      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,\n      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,\n      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,\n      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,\n      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,\n      207 . 231 DCDSTGRP 239 .\n   DSN = DCDDSNAM\n   DCDALLSP = C2D(DCDALLSP)\n   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)\n   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)\n   REFYY = LEFT(DCDLSTRF,2)\n   REFDDD = RIGHT(DCDLSTRF,3)\n   CREYY = LEFT(DCDCREDT,2)\n   CREDDD = RIGHT(DCDCREDT,3)\n   CREATED = DCDCREDT\n   DSORG = DCDDSORG\n RETURN\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT206/FILE206.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT206", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}