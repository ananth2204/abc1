{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011933000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 12580204, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 30, "INMDSNAM": "CBT.V500.FILE404.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 12580204, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 12580204, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE404.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\xc2\\t'", "DS1TRBAL": "b'\\x1cl'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xc8'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xc8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xdd\\x00\\x0c\\x02\\xea\\x00\\x06\\x00\\xbe'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xea\\x00\\x07\\x02\\xea\\x00\\x0b\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x00\\x01 !?\\x01 !?\\x00\\x18\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T00:18:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  404\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE404\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 149 MEMBERS COUNTED; CUMULATIVE SIZE IS 118,688 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/31/20    00:18:00    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99&\\x7f\\x00\\x99&\\x7f\\x08R\\x00\\x89\\x00\\x89\\x00\\x1b\\xc1\\xc7\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "1999-09-24T08:52:00", "lines": 137, "newlines": 137, "modlines": 27, "user": "AGCO"}, "text": "\n             INDEX to MEMBERS in the TSSO.VERS43.ASM dataset\n\n\n\n$ENDOFDA -->  SAMPLE IEFBR14 JOB: AOF CAN TRAP THE END OF JOB MESSAGE\n$PAYROLL -->  DITTO\nAGCOASM  -->  PROC to ASSEMBLE most TSSO subsystem modules\nALOCCACH -->  SAMPLE CLIST TO ALLOCATE FILES NEEDED TO RUN THE CACHE\n              COMMAND FROM A TSO USERID\nALTAOF   -->  ALTAOF command:  Change MLIM dynamically for tsso/aof\nAOFIVP   -->  Sample AOF table - shows all forms of TABENTRY macro\nAOFSEAG  -->  *SPRECHER AUTOMATION TABLE.29OCT92. USES MLWTO SUPPORT\nASMALL   -->  PROC to ASSEMBLE ALL TSSO processing modules\nASMONE   -->  PROC to ASSEMBLE ONE processing module\nASMTABLE -->  PROC to ASSEMBLE an AOF table\nASMTSSO  -->  PROC to ASSEMBLE all TSSO subsystem modules - needed if\n              the TSSOCVT or TSSODATD macros are altered\nCACHE    -->  CACHE command: Controls a 3880 CACHE control unit\nCOPYPROC -->  PROC to copy the sample TSSO START PROC into SYS1.PROCLIB\nCPCMD    -->  CPCMD command: Issue a CP command if running under VM\nDATAAREA -->  A non-comprehensive list of the major tsso data areas...\nDISPAOF  -->  DISPAOF command: Displays an active or inactive AOF table\nEF       -->  EF command: Allows a file to be edited under TSSO\nEQUATES  -->  Standard R0-R15 equate macro\nEXASK    -->  EXAMPLE CLIST using the OSASK command\nEXCHKSPL -->  EXAMPLE CLIST using OSCMD command with manipulate of\n              the response\nEXJOBS   -->  Another EXAMPLE using OSCMD\nEXSTVTAM -->  An example of OSCMD without response retrievel\nFORMAT   -->  Macro to format numbers from assembler programs\nGENTAPE  -->  PROC to generate the TSSO distribution tape\nGETCVT   -->  MACRO to find the TSSO CVT (SSCTSUSE field in TSSO SSCT)\nISXA     -->  MACRO to determine if running under MVS/XA\nJCECVT   -->  Subroutine to do decimal/hex conversions\nLINKLIST -->  LINKLIST command: Displays MVS LNKLST concatentation\nLIONRPLY -->  Csect to extract buffers from Console A/S for REPLYLOA\nMENTER   -->  MACRO for beginning subroutine linkage\nMLEAVE   -->  MACRO for closing subgroutine linkage\nMPFLSTSE -->  *SPRECHER MPF LIST FROM SYS1.PARMLIB - VERY AGGRESSIVE\nMULT     -->  Bill Godfrey's MULT command: Enter multiple commands on\n              a line - great for commands that have subcommands\nNCFOSATH -->  The NCCF user authorization exit.\nNCFOSCMD -->  The NCCF version of the OSCMD command processor.\nOPCMDMSG -->  A message CSECT for callers of TSSOPCMD.\nOSASK    -->  OSASK command: Ask the operator a question.\n\nOSCMD    -->  OSCMD command: Issue MVS command and get response\n\nOSCMDATH -->  The user exit for the OSCMD TSO facility.\nOSCMDICB -->  OSCMD Interface Control Block - for communication\n              between TSSOPCMD and TSSOSS09\nOSPAUSE  -->  OSPAUSE command: Delay a CLIST\nOSWAIT   -->  The OSWAIT command processor.\nOSWAITRC -->  The recovery and cleanup routine for oswait.\nOSWTO    -->  OSWTO command: Issue message to the operator\nPTFS     -->  A summary of the PTFS to TSSO 4.2 that are in 4.3.\nRELGDE41 -->  TSSO 4.1 release guide\nRELGDE42 -->  TSSO 4.2 release guide\nRELGDE43 -->  TSSO 4.3 release guide\nREPLY    -->  REPLY command: Issue a REPLY command by message id\nREPLYLOA -->  REPLYLOA module: check outstanding replies\nREPLYLOB -->  REPLYLOA from Guy Albertelli.\nRUNASM   -->  RUNASM PROC for assembling TSSO modules.\nSAMPPARM -->  SAMPLE parameters for SYS1.PARMLIB(TSSOPARM)\nSEAGUGIP -->  *UOW SCRIPT OF TSSO USER MANUAL FOR SEAG MODS\nSEAGUGOP -->  *DOCUMENTATION ON SPRECHER MODS TO TSSO FOR MLWTO\nSETMODE  -->  SETMODE MACRO for changing mode (24 bit - 31 bit)\nSETPARSE -->  SETPARSE MACRO for setting up IKJPARS control blocks\nSPMON    -->  SPMON command for performance monitoring\nSSCONCB  -->  Subsystem Control Control Block DSECT.\nSSCOBCBH -->  DSECT for the SSCONCB header.\nSSID     -->  SSID macro for obtaining SMF system id\nTABEND   -->  TABEND macro for defining END of AOF table\nTABENTRY -->  TABENTRY macro for defining AOF table entries\nTABSTART -->  TABSTART macro for defining START of AOF entry\nTLINE    -->  TLINE MACRO for doing TPUT of character string\nTSSLRACF -->  TSSLRACF subroutine for doing RACINITS in #.LOGON cmd\nTSSO     -->  TSSO mainline initialization handler.\nTSSOCCMD -->  TSSOCCMD subroutine for handling TSSO control commands\nTSSOCMND -->  TSSOCMND macro for defining control block to interface\n              between TSSO and TSSOSS10 (CMDRING DSECT)\nTSSOCVT  -->  Mapping MACRO for TSSO's CVT\nTSSODATD -->  Mapping MACRO for TSSO's private data area\nTSSODOCM -->  TSSODOCM subroutine for handling TSO commands under TSSO\nTSSOESTA -->  TSSOESTA subroutine for handling TSSO errors\nTSSOGAPF -->  TSSO cross memory services routine to get APF authorizied.\nTSSOGSSC -->  TSSOGSSC for interface for subsystem allocatable consoles\nTSSOINIT -->  TSSO routine for IPL time initialization.\nTSSOINI1 -->  TSSOINI1: TSSO initialization- part 1 (init datd)\nTSSOINI2 -->  TSSOINI2: TSSO initialization- part 2 (process parmlib)\nTSSOINI3 -->  TSSOINI3: TSSO initialization- part 3 (default security)\nTSSOINI4 -->  TSSOINI4: TSSO initialization- part 4 (ss consoles)\nTSSOINI5 -->  TSSOINI5: TSSO initialization- part 5 (xmem services)\nTSSOMAIN -->  TSSO mainline routine for processing TSO commands\nTSSONDSA -->  TSSO NON DISRUPTABLE SYSTEM AREA DSECT.\nTSSOPARS -->  TSSOPARS subroutine for parsing just about anything\nTSSOPCMD -->  Routine to process operating system cmds and return\n              The responses to a buffer.\nTSSOPREC -->  Recovery routine for TSSOPCMD.\nTSSOPROC -->  A sample proc for use in starting TSSO (S TSSO)\nTSSOSECR -->  TSSOSECR mapping macro to map the TSSO security control\n              block\n\nTSSOSS09 -->  TSSO WTO intercept routine (subsys code 9)\n\nTSSOSS10 -->  TSSO Command intercept routine (subsys code 10)\n\nTSSOTERM -->  TSSOTERM module for handling TSSO termination\nTSSOWTO  -->  TSSOWTO module for copying SYSTSPRT file to console after\n              commands\nUNDERTSO -->  UNDERTSO MACRO to determine if your running under TSO\nUSEGDESC -->  The TSSO Users Guide - complete with SCRIPT control\n              words\nUSEGDE41 -->  The Users Guide for TSSO 4.1\nUSEGDE42 -->  The Users Guide for TSSO 4.2\nUG43TERM -->  The Users Guide for TSSO 4.3 (Current Version)\nVALLOC   -->  VALLOC command for displaying MVS allocation information\nVOLSER   -->  VOLSER command for displaying MVS UCB information\n\nXSSOSS09 -->  Old version of TSSO WTO intercept routine (subsys code 9)\n\nItems in member CLISTS from SPRECHER ENERGIE AG\n\nCLISTS / HSMCYCLE*CLIST STOPS AND RESTARTS DF/HSM.....................*/\nCLISTS / HSMSTOP *CLIST STOPS DF/HSM AND WAITS FOR THE JES2 ENDED MSG.*/\nCLISTS / HSMTAPE *CLIST CHECKS AVAILABILITY OF TAPES FOR DF/HSM.......*/\nCLISTS / NOPAPER *CLIST DISABLES JES328X PRINTERS WITH INTVN REQUIRED */\nCLISTS / PRIME   *CLIST TO TEST FOR PRIME SHIFT. RETURN RC(0) IF YES. */\nCLISTS / RESTART *RESTART A JES328X PRINTER STOPPED BY NOPAPER....... */\nCLISTS / RMTGO   *AUTOMATICALLY START RMT PRINTER ON FORM CHANGE..... */\n\nItems in member CLISTS from AGCO UK Ltd.\n\nCLISTS / DOWN    *Generalised shutdown routine........................*/\nCLISTS / ONLYTSO *Example of a shutdown clist, uses DOWN and SURE.....*/\nCLISTS / SURE    *Get Operator confirmation...........................*/\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$NOTE0": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x07\\x07\\x1f\\x01\\x07\\x07\\x1f#4\\x00\\x16\\x00.\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-03-12T00:00:00", "modifydate": "2007-03-12T23:34:02", "lines": 22, "newlines": 46, "modlines": 0, "user": "SBGOLOB"}, "text": "                    Packaging of this PDS\n                    --------- -- ---- ---\n\nElimination of the Master Console in z/OS 1.8 has made for some\nincompatible changes to TSSO.  Therefore, I didn't want to mix up\nthe old, pre-z/OS 1.8 code, with the TSSO code that was fixed for\nz/OS 1.8 (by Larry Lawler, aka Dr. CICS).\n\nTherefore, I have done an extreme bit of packaging, by lumping up\nthe entire File 404, as it existed previously, into one pds member\ncalled $$PREZ18.  If you have a z/OS system at 1.7 or lower, then\nyou are welcome to run the $PDSLOAD job member, to create an install\npds to install the previous TSSO 4.4 code.  Otherwise, this entire\npds is tailored for z/OS 1.8 and higher.\n\nMuch thanks to Larry Lawler for doing the latest work.\n\nAll the best to all of you......\n\nSam Golob   (sbgolob@attglobal.net  or  sbgolob@cbttape.org)\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$NOTE1": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x08\\x13\\x9f\\x01\\x08\\x13\\x9f\\x192\\x00S\\x00S\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-05-18T00:00:00", "modifydate": "2008-05-18T19:32:41", "lines": 83, "newlines": 83, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    RE: TSSO on 1.9\nFrom:       \"Morris, Carey\" <Carey.Morris@fortworthgov.org>\nDate:       Sun, 18 May 2008 12:45:45 -0500\nTo:         'Sam Golob' <sbgolob@cbttape.org>\n\nHello,\n\nI changed two lines in TSSOSS09.\n\nAt line 10130004 after the AFTECHO1 label, I changed \"LH\nR0,MASTCONS\" to \"SR R0,R0\".  I made the same change at line\n11140006 after label ISSUERPL.\n\nI don't claim to be an SVC 34 expert.  I based this change on the\nfact that, according to the 1.9 \"Authorized Assembler Reference\",\nthe MGCR macro requires register 0 be set to low values.  Since\nit was 3:55 PM on Friday and we planned on implementing z/OS 1.9\nthe following Sunday (today), I didn't delve into why register 0\nis supposed to be cleared I just cleared it and it worked.\nObviously, it has something to do with the console ID, but I'm\nnot sure what.  Hopefully, z/OS 1.9 will behave and I'll have\ntime to play with this more next week.\n\nThanks again for your help,\nCarey\n\n-----Original Message-----\nFrom: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\nSent: Sunday, May 18, 2008 11:45 AM\nTo: Morris, Carey\nSubject: Re: TSSO on 1.9\n\nHi Carey,\n\n   Would you please send your correction to me, so that I can post it\nwith the source code for TSSO on File 404?  Thanks much, in advance.\nI'd like to correct this on the collection, so the \"next guy\" won't have\nany problems.  Again, thanks......\n\n   All the best of everything to you and your family.\n\nSincerely,    Sam\n\nMorris, Carey wrote:\n\n\nThanks for your reply.  I posted a reply to the list this morning.\n\nThe latest version corrected all the problems with the exception\nof the AOF facility.  All responses to WTORs failed with the\nmessage:\n\nIEE703I REPLY 12 NOT REQUESTED FROM THIS CONSOLE\nI ended up making a slight modification to TSSOSS09.  I cleared\nregister 0 prior to the SVC 34 call.  This seemed to correct the\nproblem for us.\n\nThanks again,\nCarey\n\n-----Original Message-----\nFrom: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\nSent: Saturday, May 17, 2008 10:02 PM\nTo: Morris, Carey\nSubject: TSSO on 1.9\n\nHi Carey,\n\n   Did you try the latest TSSO on File 404 on the Updates page of\nwww.cbttape.org?  It required quite a few changes to be able to run on\nz/OS 1.8, with the elimination of the \"master console concept\" there,\nand with a few other system changes necessary.\n\n   I haven't tried it on 1.9 yet, but I'd start with the version that\nworks for 1.8.\n\n   Please stay in touch.\n\n   All the best of everything to all of you.\n\nSincerely,    Sam Golob\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$ENHANC": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\x07\\x07\\x1f\\x01\\x07\\x07\\x1f#E\\x00E\\x00C\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-03-12T00:00:00", "modifydate": "2007-03-12T23:45:33", "lines": 69, "newlines": 67, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob\n\nThe following is an enhancement suggestion for TSSO which I have\nchosen NOT to introduce into the main source code.  However, it is\nhere for the picking, and if you want it, you can use it.....\n\nThe code comes from Larry Lawler, who has fixed TSSO for z/OS 1.8.\n\nSubject:  RE: FW: These are the changes to make TSSO support z/OS 1.8\nFrom:     \"Larry Lawler\" <ljlawler@sbcglobal.net>\nDate:     Mon, 12 Mar 2007 10:27:32 -0800\nTo:       \"'Sam Golob'\" <sbgolob@cbttape.org>\n\nJust found another thing I changed back in November, that I used\nto figure out was was going wrong.  It is not needed for\nsuccessful execution, but was very useful for debugging, the\nmessages look like this:\n\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON0\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON1\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON2\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON3\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON4\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON5\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON6\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON7\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON8\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON9\n\nThe code by the way violates \"rent\" check in assembly (rc=04), but works.\nIt is 2 statements right after label REQOK in module TSSOGSSC:\n\n         ST    R11,WORKAREA             PUT PARM LIST AWAY\nGET_NEXT_CNSL  EQU *                                         11/19/2006\n         LA    R1,WORKAREA              LOAD ADDRESS OF WHERE IT IS.\n         LINK  EP=IEAVG700              ** DO IT **\n         LTR   R15,R15\n         BZ    REQOK\n\n\n\n\nREQOK    DS    0H\n         L     R2,SCSCONID            GET CONSOLE ID         02/08/2007\n         ST    R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n*\n         CLC   =C'TSSO',SCSONAME       IS THIS OUR PREFIX ?  11/19/2006\n         BNE   GET_NEXT_CNSL           NO, THEN GET NEXT ONE 11/19/2006\n         MVC   WTO_CNSL+4+4+35(8),SCSONAME CNSL NAME RETURNED11/19/2006\nWTO_CNSL WTO   'TSSG000I CONSOLE NAME RETURNED IS: 12345678',\n               ROUTCDE=11,MCSFLAG=HRDCPY                     11/19/2006\n\n\n\nIt is your call, if you want to use it or not.  I was having\nproblems because my MVS sysprog, fat fingered the TSSO subsystem\nconsole definitions in sys1.parmlib, and had two TSSOCON8(S) and\nno TSSOCON9.  So mvs threw out the duplicate at IPL time, and\nTSSO complained there were NO subsystem consoles defined for its\nuse.  Yup, the message was NO, not something more useful, such as\none is missing or something like that.  This made me think it was\nyet another IBM changed to the console interface in zos 1.7, and\nI never thought it might be my sysprog mistake.  Any way the\nmessages helped me pinpoint his parmlib mistake.\n\nThank You,\n\nLarry Lawler\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x033\\x0f\\x01\\x033\\x0f\\x07V\\x00l\\x00l\\x00\\x00\\xd4\\xd4\\xc1\\xe8\\xd5\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-26T00:00:00", "modifydate": "2003-11-26T07:56:39", "lines": 108, "newlines": 108, "modlines": 0, "user": "MMAYNE"}, "text": "Sam, some recent history to accompany the (attached) updated\nTSSOSS09 module (for file 404).\n\nThanks.\n-Mike Mayne\n\n-------- Original Message --------\nSubject: Re: TSSO and Abend 0C4 during MLWTO processing\nDate: Tue, 18 Nov 2003 17:06:35 -0500\nFrom: Peter Vander Woude <pwoude@harristeeter.com>\nTo: <mmayne@chattanooga.net>, <edjaffe@phoenixsoftware.com>\nCC: <mmayne@hhsys.org>\n\nMike,\n\n  As a side benefit, it appears that this change also corrects a\n\"small\" problem with the #.RELOAD.  After I had submitted my\nchanges to correct the RELOAD processing so it actually loaded\nthe new AOF table, I had noticed that issuing a #.RELOAD command\nwas forcing me to re-ipl the system due to, if I recall, abend\n0c4's at various places that were not nice!\n\n  Just tested the reload command and I did not have to ipl my\ntest system.\n\nPeter I. Vander Woude\n\nSr. Mainframe Engineer\nHarris Teeter, Inc.\n\n\n\n\"Cathie M. Mayne\" <mmayne@chattanooga.net> 11/17/2003 9:35:00 PM\n\n\nI will do so ASAP.  At the present time, I'm still in the throes\nof OS/390 V2R10 -> z/OS V1R4 (goes into Application test in 2\nweeks, and if all's well it goes production the second Sunday in\nDecember (cross your fingers)).  I'm embarrassed to say it, but I\nknew about this, and I think it may have been a bug that *I*\nintroduced when I created the change to fix the SDSF problem.  It\nkind of highlights my point about the code needing rework,\nthough.\n\nThanks, Peter and Ed.  I'll keep you posted...\n\n-Mike\n\n\"Edward E. Jaffe\" wrote:\n\nPeter,\n\nThanks for finding and fixing this.  Mike Mayne is currently doing\nsome work on TSSO, so I've copied him on this note. It sounds as\nif he should probably retrofit your fix into his version. Eh\nMike?\n\nRegards, Ed Jaffe\n\nPeter Vander Woude wrote:\n\nEd,\n\n     Not sure if you're the right person to be e-mailing about a\nsmall TSSO issue, and the correction I found, but here goes.\n\n     Since I put TSSO into production, I have been having a small\nissue with it in the fact that I have the message IEA611I in my\nTSSO AOF table to 1) suppress the message from the console, and\n2) start a STC that will notify tech services that the svc dump\nwas taken.\n\nThe issue was that during the processing, a ABEND0C4 was being\ngenerated in the IEFJRASP processing.  I finally got around to\nlooking at the svcdump from the ABEND0C4 in IEFJRASP.  In looking\nat the TSSOSS09 code, I found that the abend was occurring on the\nTM WMNMML1,WMNMML1C instruction (right after the SEDOLM1 label).\n\nFurther analysis showed that the ICM R15,B'1111',WMNMNX2\ninstruction, right below the SEDOLMXX label was using R10 as it's\nbase.  This confused me because R5 is established previously as\nthe base for the WMNM dsect.     That was until I spotted the POP\nUSING statement about6 or 7 lines above the SEDOLMXX label.  When\nI move the POP USING down below the last reference to any WMNM\nfields, then the logic no longer generates the ABEND0C4.\n\nAll the analysis was done with the most recent file 404 from the\nCBT tape site.\n\nIf you have any questions, or want me to ship you the slightly\nmodified TSSOSS09 code, just drop me a note.\n\nThanks,\n\nPeter I. Vander Woude\n\nSr. Mainframe Engineer\nHarris Teeter, Inc.\n\n--\n\nMichael R. Mayne\nSystems Programmer III\nHuntsville Hospital System\n101 Sivley Rd. SW\nHuntsville, AL 35801-4470\n(256) 265-9012\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x05\\x07\\x7f\\x01\\x05\\x07\\x7f\\tY\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xe3\\xe3\\xc9\\xd5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-18T00:00:00", "modifydate": "2005-03-18T09:59:47", "lines": 24, "newlines": 24, "modlines": 0, "user": "CATTIN"}, "text": "Hi Sam\n\nI heard about your contact with John Howlett. He reported a\nproblem with TSSO and consoles.\n\nThe problem is located in TSSOSS09 (TSSO CBT 463) when\nmulit-line WQE processing occurs under zOS 1.6.  I attached my\ncorrected version.\n\nHope this fix can help others.\n\nWith kind regards - Freundliche Gruesse\n-------------------------------------------\nDaniel Cattin\nSenior Systems Engineer z/Series\nOsys AG, Hofwiesenstrasse 350\nCH-8050 Zuerich, Switzerland\nTel +41 44 317 18 19\nMobile +41 79 639 74 87\nmailto://cattin@osys.ch\nhttp://www.osys.ch\n-------------------------------------------\nIBM Advanced Business Partner\n-------------------------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE3": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x06$\\x9f\\x01\\x06$\\x9f\\t!\\x00g\\x00g\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-09-06T00:00:00", "modifydate": "2006-09-06T09:21:44", "lines": 103, "newlines": 103, "modlines": 0, "user": "SBGOLOB"}, "text": "From: IBM Mainframe Discussion List \u00ddmailto:IBM-MAIN@BAMA.UA.EDU\u00a8 On\nBehalf Of Hal Merritt  HMerritt@JACKHENRY.COM\nSent: Monday, September 04, 2006 2:12 PM\nTo: IBM-MAIN@BAMA.UA.EDU\nSubject: Re: Help with TSSO Install\n\nThanks all!\n\nI dug around and found the answer in TSSORATH (sp?). One, this program\nwas not in the 'all assembly' list which drew my attention in the first\nplace.\n\nThere I found a RACF check for a facility. I don't recall seeing that in\nthe instructions anywhere. Anyway, I added the FACILITY and the problem\nwent away. The root problem was a poorly worded error message.\n\nThis was one of two modules not included in the 'all assembly' member.\nThe other was LION something.\n\nAnother question: where might I find doc on the variables passed to the\nCLIST?\n\nYet another: I saw a fleeting reference to REXX. Is REXX supported? How\nabout the variables?\n\n  Note from Sam Golob:  I tried running Mark Zelden's IPLINFO REXX\n       under TSSO and it produced console output.  So a REXX exec\n       can indeed be run under TSSO.  I think the reason is that\n       TSSO invokes \"real TSO\" for command execution, so any command\n       that \"real TSO\" can execute, will also be OK under TSO, as\n       long as the output is in line mode, and not fullscreen mode.\n       And also, you will see the output on the console if it was\n       produced by TSO PUTLINE processing, as opposed to TPUT.  REXX\n       and CLIST outputs are produced by PUTLINE.\n\n       Also please note that if no output is produced by a TSO\n       command, as when you use the TSO RENAME command, the command\n       will still do its job under TSSO, the same way it will do its\n       job under TSO.  The dataset will be renamed, even though there\n       will be no output produced.\n\n       (All this is \"very cool\" since it must be remembered that TSSO\n       in its present form, was written in 1986, and as modified by\n       Ed Jaffe and others, it runs nicely under z/OS.  I tested TSSO\n       at the z/OS 1.7 level.)\n\nBy the way, the product went from download to operational in a day and a\nhalf (I was allowed a prime time IPL on that LPAR). That LPAR is now\nserving a critical DR mission and TSSO is a key to accomplishing that\nmission. Awesome tool!!\n\n-----Original Message-----\nFrom: IBM Mainframe Discussion List \u00ddmailto:IBM-MAIN@BAMA.UA.EDU\u00a8 On\nBehalf Of Brian Westerman\nSent: Saturday, September 02, 2006 1:05 AM\nTo: IBM-MAIN@BAMA.UA.EDU\nSubject: Re: Help with TSSO Install\n\nHi,\n\nAssuming you are using the default JCL delivered with file 404 to\nassemble/link it, you have to make sure that the library you linked it\ninto is APF authorized.  You can temporarily authorize it with the\nSETPROG command, but make sure that you also place it in your PROGxx\nmember for the next time you IPL.\n\nI've had a couple of people contact me offline about this same problem\nrecently, and it has always been (so far) that they either didn't\nauthorize the library in the first place, or they only used SETPROG and\nthen when they IPLed, the authorization was lost because they forgot to\nupdate the correct PROGxx member.\n\nIf you have concatenated the STEPLIB that TSSO is using, you must make\nsure that all of the libraries in the concatenation are authorized.\n\nBrian\n\n\n-----Original Message-----\nFrom: IBM Mainframe Discussion List \u00ddmailto:IBM-MAIN@BAMA.UA.EDU\u00a8 On\nBehalf Of Hal Merritt\nSent: Thursday, August 31, 2006 3:29 PM\nTo: IBM-MAIN@BAMA.UA.EDU\nSubject: Help with TSSO Install\nI have the latest version of TSSO installed on a z/os 1.7 system.\nTesting is going well, but I am a bit baffled by the error message:\n\n\n\nALTAOF IS TERMINATING BECAUSE IT WAS NOT INVOKED AUTHORIZED\n\n\n\n\n\nThe entry is in IKJTSO01. Other TSSO commands/functions seem to be\nworking just fine. What am I missing?\n\n\n\nThanks!!!\n\n\n", "mimetype": "message/rfc822", "datatype": "ebcdic", "extension": ".eml"}, "$$NOTE4": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x07\\x17_\\x01\\x07\\x17_\\tC\\x01Y\\x01Y\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-06-24T00:00:00", "modifydate": "2007-06-24T09:43:09", "lines": 345, "newlines": 345, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     Additional changes to make TSSO support for zOS 1.8,\n             to handle \"UNKNOWN\" consoles in TSSOSS09\nFrom:        \"Larry Lawler\" <ljlawler@sbcglobal.net>\nDate:        Fri, 22 Jun 2007 15:38:34 -0700\nTo:          \"'Sam Golob'\" <sbgolob@cbttape.org>\n\nHello Sam:\n\n    Sorry to \"Bother\" you but, a user of TSSO contacted me with a\nproblem using TSSO's OS2CMD facility, not displaying the response\nmessages, although the command was working.  Seems the fullword\nconsole IDs in the WQE contained x'00FFFFFF' instead of a valid\nSUBSYS CNSL ID!\n\nIn the process I found one Mistake in my previous Changes\n(another line was supposed to be commented out) The problem he\nwas having is the output from the OS2CMD was not being return\ncorrectly by TSSOSS09 (JES subsystem module)\n\nAnyway while trying to debug the code, I also Improved upon my\nprevious WTO logic in TSSOGSSC, to add the Console id Numbers to\nthe WTO Message.  This was so I could tell what was wrong between\nTSSOSS09 and OS2CMD.  Any way here are the source changes to the\nthree TSSO modules:\n\n\nIn Module: TSSO I had to comment out one more line, in this code:\n\n\n         XR    R15,R15\n* drcics ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTC 11/19/2006\n* drcics BZ    HRDCONS              IF NONE THEN USE MASTCON 11/19/2006\n         USING UCMLIST,R14                                      29OCT92\n         IC    R15,UCMID            GET THE CONSOLE ID\nHRDCONS  DS    0H                                               29OCT92\n\nto look like this:\n\n         XR    R15,R15\n* drcics ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTC 11/19/2006\n* drcics BZ    HRDCONS              IF NONE THEN USE MASTCON 11/19/2006\n         USING UCMLIST,R14                                      29OCT92\n* drcics IC    R15,UCMID            GET THE CONSOLE ID       06/20/2007\nHRDCONS  DS    0H                                               29OCT92\n\n\n\nIN TSSOGSSC I changed my previous WTO code that looked like this:\n\n         MVC   WTO_CNSL+4+4+35(8),SCSONAME CNSL NAME RETURNED11/19/2006\nWTO_CNSL WTO   'TSSG000I CONSOLE NAME RETURNED IS: 12345678',           +\n               ROUTCDE=11,MCSFLAG=HRDCPY                     11/19/2006\n\n\nto this code, to see the subsystem console ID Numbers, to aid in\ndebugging TSSOSS09\n\n         MVC   WTO_CNSL+4+4+35(8),SCSONAME CNSL NAME RETURNED06/20/2007\n         UNPK  WTO_CNSL+4+4+48(9),SCSCONID(5)   CNSL ID#     06/20/2007\n         XC    WTO_CNSL+4+4+48(8),=8XL1'F0'     REMOVE SIGNS 06/20/2007\n         TR    WTO_CNSL+4+4+48(8),=CL16'0123456789ABCDEF'    06/20/2007\n         MVI   WTO_CNSL+4+4+48+8,C' ' BLANK OUT UNPACKED SIGN06/20/2007\nWTO_CNSL WTO   'TSSG000I CONSOLE NAME RETURNED IS: 12345678, ID=1234567+\n               8 ',ROUTCDE=11,MCSFLAG=HRDCPY                 06/20/2007\n\n\nthen is TSSOSS09, right after this old code:\n\n         L     R10,SSCONNUM        GET SUBSYSTEM CONSOLE ID\n         CR    R6,R10              IS IT OURS ?\n         BE    FNDSSCON            BY GOLLY, IT SURE IS...\n\nbut before the label: SSCLOOPE, to handle \"unknown\" subsystem console ids,\nThese get used internally by TSSO's OS2CMD processing.\n         L     R10,SSCONNUM        GET SUBSYSTEM CONSOLE ID\n         CR    R6,R10              IS IT OURS ?\n         BE    FNDSSCON            BY GOLLY, IT SURE IS...\n*                                                            06/20/2007\n         CLM   R6,15,=XL4'00FFFFFF'    IS IT UNKNOWN ?       06/20/2007\n         BNE   SSCLOOPE            NO, TRY NEXT CONSOLE ENTRY06/20/2007\n         CLC   =C'UNKNOWN ',WQECNNME   YES, REALLY UNKNOWN ? 06/20/2007\n         BE    FNDSSCON            YES, TREAT IT LIKE OURS   06/20/2007\n*                                                            06/20/2007\nSSCLOOPE DS    0H\n\nAnd that's was it, to get him up and running with OS2CMD:\n\n\nThank You,\n\nLarry Lawler\nA.K.A. (Dr.CICS)\n\nAuthor: Cics/Manager, Cics/Comet, Cics/Fastpath, Cics/Vortex,\nVsam/Hipercache, Xa/Relo, Cics/Insight, VSAM/Optimizer.\n\n\n\n\nFrom: Larry Lawler \u00ddmailto:ljlawler@sbcglobal.net\u00a8\nSent: Monday, March 12, 2007 10:28 AM\nTo: 'Sam Golob'\nSubject: RE: FW: These are the changes to make TSSO support zOS 1.8\nImportance: High\n\nJust found another thing I changed back in November, that I\nused to figure out was was going wrong.  It is not needed for\nsuccessful execution, but was very useful for debugging, the\nmessages look like this:\n\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON0\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON1\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON2\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON3\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON4\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON5\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON6\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON7\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON8\nTSSG000I CONSOLE NAME RETURNED IS: TSSOCON9\n\nThe code by the way violates \"rent\" check in assembly (rc=04),\nbut works fine, it is 2 statements right after label REQOK in\nmodule TSSOGSSC:\n\n         ST    R11,WORKAREA             PUT PARM LIST AWAY\nGET_NEXT_CNSL  EQU *                                         11/19/2006\n         LA    R1,WORKAREA              LOAD ADDRESS OF WHERE IT IS.\n         LINK  EP=IEAVG700              ** DO IT **\n         LTR   R15,R15\n         BZ    REQOK\n\n\nREQOK    DS    0H\n         L     R2,SCSCONID            GET CONSOLE ID         02/08/2007\n         ST    R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n*\n         CLC   =C'TSSO',SCSONAME       IS THIS OUR PREFIX ?  11/19/2006\n         BNE   GET_NEXT_CNSL           NO, THEN GET NEXT ONE 11/19/2006\n         MVC   WTO_CNSL+4+4+35(8),SCSONAME CNSL NAME RETURNED11/19/2006\nWTO_CNSL WTO   'TSSG000I CONSOLE NAME RETURNED IS: 12345678',           +\n               ROUTCDE=11,MCSFLAG=HRDCPY                     11/19/2006\n\n\n\nIt is your call, if you want to use it or not.  I was having\nproblems because my MVS sysprog, fat fingered the TSSO subsystem\nconsole definitions in sys1.parmlib, and had two TSSOCON8(S) and\nno TSSOCON9.  So mvs threw out the duplicate at IPL time, and\nTSSO complained there were NO subsystem consoles defined for its\nuse.  Yup, the message was NO, not something more useful, such as\none is missing or something like that.  This made me think it was\nyet another IBM changed to the console interface in zos 1.7, and\nI never thought it might be my sysprog's mistake.  Any way the\nmessages helped me pinpoint his parmlib mistake.\n\nThank You,\n\nLarry Lawler\n\n\n\n\nFrom: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\nSent: Sunday, March 11, 2007 5:14 AM\nTo: Larry Lawler\nSubject: Re: FW: These are the changes to make TSSO support zOS 1.8\n\nHi Larry,\n\n   When I applied your changes and assembled, I noticed that you\n   didn't have a change to TSSOSS09, which reflected the\n   elimination of the symbol WQEUCMID.  Did you have some logic\n   that handled this change correctly?  How did the assembly work\n   on your system?\n\n   Thanks in advance.\n\n   All the best........\n\nSam (Golob)\n\nLarry Lawler wrote:\n\n> Oh!\n>\n> The changes I made will not work on a system, that still does\n> the master console \"concept\" I think that includes os390 r2.10\n  thru zos 1.6\n>\n> I know that cics TS 3.x which requires zos 1.7 also requires\n  the fullword console id #, and no longer supports the one byte,\n  or two byte version.\n>\n>\n>\n> From: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\n> Sent: Friday, March 09, 2007 2:15 PM\n> To: Larry Lawler\n> Subject: Re: FW: These are the changes to make TSSO support zOS 1.8\n>\n> Hi Larry,\n>\n>    I'll try to apply your changes over the weekend, to my own\n     1.8 system, but since I'm also the custodian of the CBT Tape\n     collection, I have to \"regression test\" the changes on the\n     older releases of MVS to make sure that they still work, and\n     if they don't work, I have to repackage as two separate\n     sources.  I'll try and let you know how it comes out.\n     Thanks for finding and making the fixes.\n>\n>    All the best of everything to you and your family.  Have a\n     wonderful weekend.\n>\n> Sincerely,    Sam\n>\n> Larry Lawler wrote:\n>\n>> ok, thanks!\n>>\n>> All the best to you and you family too!\n>> I guess you already know that the concept of a \"master'\n   console no longer exists,\n>> hence the label UCMMCENT was deleted.\n>>\n>>\n>> Thank You,\n>>\n>> Larry Lawler\n>>\n>> (DR.CICS)\n>>\n>>\n>>\n>>\n>> From: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\n>> Sent: Friday, March 09, 2007 7:03 AM\n>> To: Larry Lawler\n>> Subject: Re: FW: These are the changes to make TSSO support zOS 1.8\n>>\n>> Hi Larry,\n>>\n>>    Uh sorry.  Seems I have them......\n>>\n>>    All the best.......\n>>\n>> Sam G\n>>\n>> Larry Lawler wrote:\n>>\n>>> Dear Sam and Sam:\n>>>\n>>>         I missed one module in my previous email, sorry!\n>>> I have included it here:\n>>>\n>>>\nEDIT       LJL.TSSO.ASM(TSSO) - 01.04                      Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   530 Line(s) not Displayed\n050610 * drcics ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTCONS 29OCT92\n050620 * drcics BZ    HRDCONS              IF NONE THEN USE MASTCONS=0 29OCT92\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   396 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n>>>\n>>> Larry...\n>>>\n>>>\n>>> ______________________________________________\n>>> From:   Larry Lawler \u00ddmailto:ljlawler@sbcglobal.net\u00a8\n    On Behalf Of ljlawler@unicomsi.com\n>>> Sent:   Thursday, February 08, 2007 3:26 PM\n>>> To:     'sknutson@cbttape.org'\n>>> Cc:     'sbgolob@cbttape.org'\n>>> Subject:        These are the changes to make TSSO support zOS 1.8\n>>> Importance:     High\n>>> Sensitivity:    Private\n>>>\n>>> Dear Sam and Sam:\n>>>\n>>>         These are the changes to make TSSO (File # 404 TSSO\n>>> for OS/390 and z/OS ) support zOS 1.8, with its required 4\n    byte console ids.\n>>>\n>>> The IEZVG100 PARM LIST grew by 16 bytes for the CALL to IEAVG700,\n>>> so a simple reassembly of TSSOGSSC fixes that.\n>>>\n>>> It also has a comment in it to use the four byte field SCSCONID,\n>>> instead of SCSCNID which is 2 bytes. Hence the following changes.\n>>> The original Statements have *DRCICS* to comment them out,\n>>> Followed by the new statements with the date of 02/08/2007\n>>>\n>>> Three modules were affected: TSSOGSSC, TSSOINIT, and TSSOTERM.\n>>> Please fell free to email me with any questions.\n>>>\n>>>  Thank You,\n>>>\n>>> Larry Lawler\n>>> A.K.A. (Dr.CICS)\n>>>\n>>>\nEDIT       LJL.TSSO.ASM(TSSOGSSC) - 01.06                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 95 Line(s) not Displayed\n009400 *DRCICS* LH    R2,SCSCNID             GET CONSOLE ID         02/08/2007\n009600          L     R2,SCSCONID            GET CONSOLE ID         02/08/2007\n009610 *DRCICS* STH   R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n009700          ST    R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 17 Line(s) not Displayed\n011500 *DRCICS* CLC   UCMID(1),TSSCONID+1    COMPARE UCM IDS        02/08/2007\n011600          CLC   UCMID(1),TSSCONID+3    COMPARE UCM IDS        02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 50 Line(s) not Displayed\n016700 *DRCICS* MVC   SCSCNID(2),TSSCONID    INDICATE THE CONSOLE TO02/08/2007\n016800          MVC   SCSCONID,TSSCONID      INDICATE CNSL TO RELEAS02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 53 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n>>>\n>>>\n>>>\nEDIT       LJL.TSSO.ASM(TSSOINI4) - 01.02                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 71 Line(s) not Displayed\n007000 *DRCICS* LH    R2,TSSCONID         GET THE CONSOLE ID\n007010          L     R2,TSSCONID         GET THE CONSOLE ID\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 86 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n>>>\n>>>\n>>>\n>>>\nEDIT       LJL.TSSO.ASM(TSSOTERM) - 01.02                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   296 Line(s) not Displayed\n028600 *DRCICS* STH   R1,TSSCONID       STICK IN TSSCONID.\n028610          ST    R1,TSSCONID       STICK IN TSSCONID.\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   115 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n>>>\n>>>\n>>>\n>>>\n>>>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE5": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\t)_\\x01\\t)_!\\x06\\x002\\x002\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-10-22T00:00:00", "modifydate": "2009-10-22T21:06:43", "lines": 50, "newlines": 50, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   Update to FILE404\nFrom:      dmitche@shazam.net\nDate:      22 Oct 2009 15:27:49 -0500\nTo:        sbgolob@cbttape.org\n\nHi Sam,\n\nI have another small update for the CBTTAPE file 404, the wonderful\nTSSO system.  I have modifed TSSOSS09 program to allow the\ninsertion of the system ID of the system that issued the message,\nwhen running in a sysplex.\n\nI have attached both versions,  $$PREZ18 and post 1.8.  But\nunfortunately I only have this on a pre-1.8 system.  You might\nwant to have someone test out the  post 1.8 version just to make\nsure it works before publishing it.\n\nHere is a small update to the user guide under the TEXT operand:\n------------------------------------------------------------------------\nTo insert the system ID of the issuing system in a SYSPLEX, use\nthe format:\n\n   \\Iabcdnn\\\n     ______\n\n where abcdnn are optional and ignored.  The trailing '\\' must be\nspecified.\n\n For example, to route a command to the system that issued a\nmessage, you need to insert the SYSTEM ID into the ROUTE command,\nThe TABENTRY macro would look like this:\n\n   entry-id TABENTRY MSG=IEF176I,ACTION=OSCMD,\n   ________\n                  TEXT='RO \\I001,01\\P \\W    03\\'\n\n\n Multiple \"I\" \"S\" and \"W\" options can be used in one TEXT operand.\nIf AOF  detects an error in the TEXT parameter as a result of a S\nor W option, a message is issued and processing is terminated.\n\n---------------------------------------------------------------------\n\nI hope someone can find this useful, please let me know if you have\nany questions.\n\nRegards,\nDana\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE6": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x10\\x01\\x8f\\x01\\x10\\x01\\x9f\\x085\\x00;\\x008\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-01-18T00:00:00", "modifydate": "2010-01-19T08:35:03", "lines": 59, "newlines": 56, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   Another small update to file 404\nFrom:      \"Mitchell, Dana\" <dmitche@Shazam.net>\nDate:      Mon, 18 Jan 2010 12:04:05 -0600\nTo:        <sbgolob@cbttape.org>\n\nHi Sam,\n\nI came across another small problem during implementing TSSO when\nusing the MLWTO Line test:   TEST=((L,9),  in the AOFTable.\nRunning on z/OS 1.4 I was getting messages:  TSS9208E ERROR\nPROCESSING L DIRECTIVE- ENTRY IGNORED     and on z/OS 1.11, it\nwould generate a S0C4:\n\nDUMP TITLE=COMPON=SSI,COMPID=5752SC1B6,ISSUER=IEFJSARR,MODULE=IEFJRASP,\n           ABEND=S0C4,REASON=00000011,SNAME=TSSO\n\nThe problem seems to be in TSSOSS09, after label SEDOLMXX the\nreference to WMNMNX2 is using R5 as it s base, due to the USING\nWMNM,R5 statement even though it branches around the load of it s\naddress into R5.  By moving the POP USING to directly after\nSEDOLMXX, R10 is still used for the ICM  R15,B1111,WMNMNX2\ncorrectly:\n\nSEDOLMXX DS    0H                  CONTINUE PROCESSING\n         POP   USING               Moved here                      RPS\n         ICM   R15,B'1111',WMNMNX2 IS THERE ANOTHER MINOR?\n         BZ    SEDOLMX2            NO, A REAL EXIT\n         LR    R5,R15              YES, UPDATE POINTER\n         B     SEDOLM1             GO ROUND THE LIST OF MINOR WQE'S\n*        POP   USING               Move up                         RPS\n         SPACE 1\n\nInterestingly enough, this jumped out at me, mostly due to the\nlist of the active usings, across the top of the page of the\nHLASM output, showing WMJM going from R10 to R5.   Thanks to the\nSLAC mods,    I remember discussing the SLAC mods at a SHARE BOF\nwith you many years ago ..\n\nIf you have any questions please let me know.\n\nThank you\nDana\n\nDana N. Mitchell |  Sr. Systems Programmer\n(O) 515-288-2828, ext. 2953\n(F) 515-248-5828 | dmitche@shazam.net\n6700 Pioneer Parkway | Johnston, IA 50131-1605\n\n   Note from Sam Golob:  I made this change in both the new TSSO\n             and the old TSSO.\n\n   Note from Sam Golob:  HLASM was created because of the SLAC\n   (Stanford Linear Accelerator Center) mods to Assembler H\n   (written by Greg Mushial).  Greg invented the concepts of\n   Labeled Usings and all the other extra concepts and features\n   (more than what IEV90 had) which were initially incorporated\n   into HLASM after IBM took over support of the SLAC mods (in\n   1992).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$PREZ18": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\t)_\\x01\\x10\\x01\\x9f\\x083\\xd3\\xbe\\xd3\\xbd\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2009-10-22T00:00:00", "modifydate": "2010-01-19T08:33:09", "lines": 54206, "newlines": 54205, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$SPMON": {"ttr": 22795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x05\\x01O\\x01\\x05\\x01O\\t\\x01\\x00\\x18\\x00\\x18\\x00\\x00\\xe6\\xc5\\xe2\\xe3\\xd9\\xd4\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-01-14T00:00:00", "modifydate": "2005-01-14T09:01:46", "lines": 24, "newlines": 24, "modlines": 0, "user": "WESTRMN"}, "text": "Hi Sam/Sam,\n\nI have attached a copy of the SPMON program from File 404 (TSSO),\nthat allows it to work (and not get an 0C4).  The newer versions\nof the operating system can't rely on LOCASCB always returning a\nvalid ASCB just because there is something in R1.  You are\nsupposed to test R15 to make sure that a valid and used ASCB was\nreturned.  In the case of the old SPMON program, it just checked\nhow many ASIDs were possible and then just asked for the first\nthrough the last, assuming that if R1 came back with a non-zero\naddress, that everything was fine, but that bypasses the\npossibility of a address space that had abended or had been\nreused.  There is still a small problem where the address spaces\nthat are started via OMVS (SYSLOGD1 and FTPD1 etc.) have the\nASCBJBNI field with a name in it instead of the ASCBJBNS field,\nbut IBM claims that this is because they are truly \"initiated\"\naddress spaces and not \"true\" STC's, so I'll have to add some\ncode to look into the initiation method at some future date, but\nI thought that it might be good to have a version of the module\nthat doesn't get an 0C4, so I have attached it.\n\nBrian Westerman\nBrian_Westerman@SyzygyInc.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$43AGCO": {"ttr": 23041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00T\\x01\\x022?\\x01\\x022?\\x13\\x00\\x00K\\x00K\\x00\\x00\\xc1\\xc7\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2002-11-19T00:00:00", "modifydate": "2002-11-19T13:00:54", "lines": 75, "newlines": 75, "modlines": 0, "user": "AGCO"}, "text": "                              TSSO 4.3++\n                         A further upgraded version.\n                         Read member $$43P$GD first.\n\n\nDave Cartwright\nAGCO UK Ltd.\n\n++44 024 7685 1991\n\nWhen I finally settled down to a permanent job in Blighty it was at a\ngreenfield MVS site (OS/390 2.6) to replace a VM network machine.\nAlthough Netview(TM) was in use for network automation there was no\nproduct doing MVS console automation.  As a quick and dirty fix I\ninstalled TSSO as modified by Guy Albertelli to run under OS/390.  I\nknew and loved TSSO of old.  I liked what Guy had done to the AOF table\nbut I eventually discovered that there was a downside; the Boolean logic\nI had added while at Sprecher Energie had been deliberately excised.\nThis was fine for simplicity, but the AOF processing that I had built\nfor IEF238D now resulted in replies of both WAIT and CANCEL, with the\nsame reply id.  Fortunately it was fairly easy to change TSSOSS09 to   -\nreinstate the SEAG logic, Guy's version is retained as member XSSOSS09.\n\n\n*****   AOF Table Processing.\n\n\nTSSO 4.3++ processing of the AOF table is as follows:\n  -When table is loaded (or reloaded) a binary search index is\n   created based on the MSG= parameter. All identical entries are\n   chained together. All MSG=* entries are chained together.\n  -Major and minor WQEs processed.\n  -For each message processed, the binary index is searched and if\n   found, the chained entries are processed until a matching entry\n   is found with no entry id.\n  -All messages are also passed to all MSG=* entries.\n\n\nThe MSG=* entries are still  processed after all other entries are\nprocessed.\n\nI have added eXclusion tests to Word and Substring processing, giving\noptions WX and SX. That is, if the specified Word or Substring is found\nthe test is deemed to have failed. This was prompted by jobs failing\nat End of Memory causing two error messages - one for the job, one for\nthe Initiator. I was not interested in the message for the Initiator,\nas this example shows;\n\n********************************************************************\n* HIGHLIGHT JOBS THAT TERMINATE AT END OF MEMORY\n* 17OCT02 DHC   CAN HAPPEN AFTER MANY MANY WAIT/NOHOLD MESSAGES\n********************************************************************\n         TABENTRY MSG=$HASP310,ACTION=HILIGHT,\n               TEST=((WX,2,4,'INIT',''''))\n\n\n\n****    Other Modifications\n\nREPLY, REPLYLOA\nI didn't see how REPLYLOA could work, so I gave up trying and looked\nfor another way to get the CMB chains.  In file 19 of the CBT tape I\nfound another reply type program which contained a csect called REPLY.\nThis did what I wanted, so I grafted it in.  To avoid confusion I kept\nthe name REPLY for the TSSO version, John Hooper's code was renamed\nLIONRPLY. Guy's REPLYLOA is there as REPLYLOB.\n\nCLIST\nI added a couple of CLISTS that I find useful plus an example of their\nusage.  I put these at the end of the CLISTS member, out of alphabetic\nsequence.  I think IEBUPDTE etc. can handle this, if not I'm sorry.\n\nThe sterling work of Guy Albertelli, Jim Lane and John Hooper is\ngratefully acknowledged, as is the most recent contribution by a\nNew England site.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$43P$GD": {"ttr": 23044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x03\\x00l\\x00l\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:03:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "TSSO403"}, "text": "                              TSSO 4.3+\n                         An upgraded version.\n\n\nGuy Albertelli\nBFGoodrich SP&C\n9911 Brecksville Rd.\nBrecksville, OH  44141-3247\n\n216-447-5543\n\n\n\nThis is the result of the combination of different sets of changes to\nthe base TSSO 4.3 that have been made at a number of sites. The main\nmodifications are from Mr. Dave Cartwright of SPRECHER ENERGIE AG. His\nmodifications deal with additional capabilities for the AOF table,\nmainly the processing of Multi-line WTOs.  These changes allow the\nprocessing of secondary lines of any MLWTO.  At BFGoodrich we have\nincluded that code with other small modifications brought forward from\nTSSO 4.2. This document represents the current state of the TSSO 4.3+\nproduct.\n\nThis document supersedes both the original 4.3 user guide (US43xxxx)\nand the SPRECHER document (SEAGUGxx) in how messages are processed via\nthe AOF table.\n\n\n*****   AOF Table Processing.\n\nThe original 4.3 processing of the AOF table was as follows:\n  -Sequential search of the table processing any matches as found.\n  -Entire table searched for each message.\n  -Minor WQEs ignored (second and following lines in MLWTO).\n\nSEAG processing of the AOF table was as follows:\n  -Sequential search of the table till a match was found with no\n   entry ID. All matches were processed as found.\n  -Major and minor WQEs processed.\n\nTSSO 4.3+ processing of the AOF table is as follows:\n  -When table is loaded (or reloaded) a binary search index is\n   created based on the MSG= parameter. All identical entries are\n   changed together. All MSG=* entries are changed together.\n  -Major and minor WQEs processed.\n  -For each message processed, the binary index is searched and if\n   found, the chained entries are all processed. All messages are\n   also passed to all MSG=* entries.\n\nThe advantage that SEAG gained in speed is preserved in 4.3+ and the\noriginal processing order from 4.3 is preserved in 4.3+ without\nmodification of the AOF table.\n\nThe only apparent difference is that the MSG=* entries are not\nprocessed in the physical order of the source table. They are processed\nafter all matching entries are processed.\n\n\n****    Other Modifications\n\nOSCMD\n1.  Added preliminary support for REXX execs (SYSAUTH_MAXCMDOUT,\n    SYSAUTH_CMDWAIT).\n2.  Support hardware system console (CONSID=100).\n\nREPLY, REPLYLOA\n1.  Added return code to indicate results of REPLY command\n      0 = reply successful\n      4 = reply not outstanding\n      8 = error in command processing\n2.  Add support for IDMS processing (like IMS). Current syntax is\n             IMS(cccccccc)\n      REPLY  MSG(mmmmmmmm)    TEXT(tttttttt...)\n             IDMS(vvvvvvvv)\n\n    where vvvvvvvv is the IDMS CV string (usually V1, or V18, etc.)\n3.  Support hardware system console (CONSID=100).\n\nTSSO\n1.  Cancel ESTAE when terminating.\n2.  Support hardware system console (CONSID=100).\n3.  Support binary search index creation.\n\nTSSOCCMD\n1.  Support hardware system console (CONSID=100).\n2.  Support binary search index recreation.\n\nTSSO, TSSOINI2\n1.  Add new PARMLIB statement:\n      MPFSUPP = Y/N\n    To indicate whether MPF suppressed messages should be ignored by\n    TSSO. The default is No. This results in operation compatible\n    with previous versions of TSSO.\n\nTSSOLAOF\n1.  New module. Responsible for loading AOF table and building binary\n    search index.\n\nTSSOSS09\n1.  Correctly clear output token array.\n2.  Correctly lowlight eventual action messages.\n3.  Support the MPFSUPP parameter statement.\n\nTSSOSS10\n1.  Support hardware support console (CONSID=100).\n\nNumerous modules\n1.  Change access to AOF table entries to use new DSECTS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$EEJNOTE": {"ttr": 23047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00Q\\x01\\x022\\x1f\\x01\\x022/\\x10)\\x00D\\x00\\x17\\x00\\x00\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-18T10:29:51", "lines": 68, "newlines": 23, "modlines": 0, "user": "EDJXADM"}, "text": "$EEJNOTE as of November, 2002                                   EEJ1102\n                                                                EEJ1102\nTSSO is a useful program. It also provides numerous examples    EEJ1102\nof extremely poor assembler programming techniques. It uses     EEJ1102\nhard-coded offsets, redundant list/execute macro parameters,    EEJ1102\nsparse comments, multiple base registers, hard-coded lengths    EEJ1102\nfor dynamically-acquired storage, etc., etc.                    EEJ1102\n                                                                EEJ1102\nIf I was responsible for this program and/or getting paid to    EEJ1102\nmaintain it, I would clean all of this up (it would probably    EEJ1102\ntake weeks to do so). Instead, I implemented my modifications   EEJ1102\nattempting to change as little of the underlying source as      EEJ1102\npossible. In some cases, that means I replaced one hard-coded   EEJ1102\noffset with another. (Yuck!)                                    EEJ1102\n                                                                EEJ1102\nI have included member $EEJSUPC to show what source changes     EEJ1102\nwere made by me. It is a SuperC comparison of all modules       EEJ1102\nbefore and after my changes. I used the TSO/E XMIT command      EEJ1102\nto make it fit in an LRECL=80 member.                           EEJ1102\n                                                                EEJ1102\nMy changes include the following:                               EEJ1102\n                                                                EEJ1102\n1) Support for MCS Extended and SMCS consoles.                  EEJ1102\n                                                                EEJ1102\n o TSSO relied heavily on looking up the console UCM to get     EEJ1102\n   its authority. I now obtain the authority from the SSCM      EEJ1102\n   and have removed most (but not all) access to the console    EEJ1102\n   UCM. EMCS consoles do not have UCM entries.                  EEJ1102\n                                                                EEJ1102\n o I changed all console-related messages to display the        EEJ1102\n   console name rather than the console ID (except for the      EEJ1102\n   subsystem allocatable consoles). Usually, EMCS consoles      EEJ1102\n   do not have 1-byte IDs associated with them.                 EEJ1102\n                                                                EEJ1102\n o I reworked all WTOs destined to a specific console to use    EEJ1102\n   the CONSID= parameter rather than MCSFLAG=REG0 (which does   EEJ1102\n   not support 4-byte console IDs).                             EEJ1102\n                                                                EEJ1102\n o I reworked all routines that issue commands from specific    EEJ1102\n   consoles to use MGCRE with the CONSID= parameter. This       EEJ1102\n   provides command support for the 4-byte console IDs.         EEJ1102\n                                                                EEJ1102\n o I removed the requirement that consoles be logged on to      EEJ1102\n   TSSO to issue non-TSSO commands with SECLEVEL=MAXIMAL. MCS   EEJ1102\n   already has a logon facility for consoles (but it didn't     EEJ1102\n   when TSSO was first written) and the TSSO behavior           EEJ1102\n   prevented consoles from logging on via MCS. Since SMCS       EEJ1102\n   consoles *must* logon, TSSO prevented them from being used   EEJ1102\n   in a z/OS environment. With SECLEVEL=MAXIMAL, consoles must  EEJ1102\n   still logon to TSSO to use TSSO facilities, but the use of   EEJ1102\n   other facilities is now unaffected.                          EEJ1102\n                                                                EEJ1102\n2) Support for 4-byte reply IDs. The program assumed all reply  EEJ1102\n   IDs were two bytes long and could not process messages with  EEJ1102\n   3- or 4-byte reply IDs.                                      EEJ1102\n                                                                EEJ1102\n3) A new TMPNAME= startup parameter to allow a TMP other than   EEJ1102\n   IKJEFT01 to be used when issuing TSO commands via TSSO.      EEJ1102\n                                                                EEJ1102\n4) Some minor bug fixes. The original version I obtained in     EEJ1102\n   1998 had lots of problems. Before putting my changes on      EEJ1102\n   the CBT tape, I extracted the \"current\" version which had    EEJ1102\n   many of those problems solved by others. I retrofitted my    EEJ1102\n   changes as necessary to the current version. Any coding I    EEJ1102\n   performed in 1998 to solve problems that no longer exist     EEJ1102\n   was discarded.                                               EEJ1102\n                                                                EEJ1102\nEnjoy!                                                          EEJ1102\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EEJSUPC": {"ttr": 23049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x022/\\x01\\x022/\\x10\\x15\\r}\\r}\\x00\\x00\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-18T00:00:00", "modifydate": "2002-11-18T10:15:52", "lines": 3453, "newlines": 3453, "modlines": 0, "user": "EDJXADM"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "$ENDOFDA": {"ttr": 24331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x03\\x00\\n\\x00\\n\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:03:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "TSSO403"}, "text": "//ENDOFDAY  JOB (3225,P136),'TSSO/AOF TEST JOB',CLASS=X,MSGCLASS=F,\n// REGION=100K\n//********************************************************************\n//* THIS IS A TEST JOB TO BE USED WITH THE TSSO/AOF FACILITY. IT IS  *\n//* USED IN CONJUNCTION WITH THE SAMPLE TSSO/AOF SAMPLE TABLE        *\n//* \"AOFIVP\"                                                         *\n//********************************************************************\n/*ROUTE XEQ PYR4PROD\n/*ROUTE PRINT PYR4PROD\n//S2 EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FIXZ18": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x08\\x01\\x07\\x06\\x8f\\x01\\x07\\x17_\\tD\\x00\\x18\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-03-09T00:00:00", "modifydate": "2007-06-24T09:44:08", "lines": 24, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "This note was posted on IBM-Main, Mar 8, 2007 by a member of\nIBM's z/OS development staff.\n\nNote:  Please see member $$NOTE4 for Larry Lawler's comments\n       and changes.\n\n             ---------------------\nSubject:     Re: TSSO and z/OS 1.8\n             ---------------------\n\nFrom:        \"W. Kevin Kelley\" <wkkelley@OPTONLINE.NET>\nDate:        Thu, 8 Mar 2007 20:26:40 -0600\n\n\nThe basic problem is that TSSO has not been updated for changes\ncaused by the z/OS Console Restructure.  Specifically, in z/OS R8\nthe Master Console function was removed.  As a result, the symbol\nUCMMCENT no longer exists.  The TSSO logic needs to be reworked\nso that it no longer depends on the presence of the Master\nConsole.  As I recall, the WQEUCMID field was a 1-byte console ID\nfield.  That too has gone away. TSSO needs to be updated to use\n4-byte console IDs exclusively.\n\nW. Kevin Kelley  IBM POK Lab -- z/OS Core Technical Development\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FXZOS18": {"ttr": 24579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00%\\x01\\x07\\x06\\x8f\\x01\\x07\\x17_\\tE\\x00i\\x00e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-03-09T00:00:00", "modifydate": "2007-06-24T09:45:25", "lines": 105, "newlines": 101, "modlines": 0, "user": "SBGOLOB"}, "text": "Note:  Please see member $$NOTE4 in this pds for Larry Lawler's\n       further updates.  (SBG June 24, 2007.)\n\n\nSubject:     FW: These are the changes to make TSSO support zOS 1.8\nFrom:        \"Larry Lawler\" <ljlawler@sbcglobal.net>\nDate:        Fri, 9 Feb 2007 08:42:26 -0800\nTo:          <sknutson@cbttape.org>, <sbgolob@cbttape.org>\n\nDear Sam and Sam:\n\n        I missed one module in my previous email, sorry!\nI have included it here:\n\n\nEDIT       LJL.TSSO.ASM(TSSO) - 01.04                      Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   530 Line(s) not Displayed\n050610 * drcics ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTCONS 29OCT92\n050620 * drcics BZ    HRDCONS              IF NONE THEN USE MASTCONS=0 29OCT92\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   396 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n\nLarry...\n\n\n______________________________________________\nFrom:   Larry Lawler \u00ddmailto:ljlawler@sbcglobal.net\u00a8\n         On Behalf Of ljlawler@unicomsi.com\nSent:   Thursday, February 08, 2007 3:26 PM\nTo:     'sknutson@cbttape.org'\nCc:     'sbgolob@cbttape.org'\nSubject:        These are the changes to make TSSO support zOS 1.8\nImportance:     High\nSensitivity:    Private\n\nDear Sam and Sam:\n\n        These are the changes to make TSSO (File # 404 TSSO for\nOS/390 and z/OS ) support zOS 1.8, with its required 4 byte\nconsole ids.\n\nThe IEZVG100 PARM LIST grew by 16 bytes for the CALL to IEAVG700,\nso a simple reassembly of TSSOGSSC fixes that.\n\nIt also has a comment in it to use the four byte field SCSCONID,\ninstead of SCSCNID which is 2 bytes. Hence the following changes.\nThe original Statements have *DRCICS* to comment them out,\nFollowed by the new statements with the date of 02/08/2007\n\nThree modules were affected: TSSOGSSC, TSSOINIT, and TSSOTERM.\nPlease feel free to email me with any questions.\n\n Thank You,\n\nLarry Lawler\nA.K.A. (Dr.CICS)\n\n\nEDIT       LJL.TSSO.ASM(TSSOGSSC) - 01.06                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 95 Line(s) not Displayed\n009400 *DRCICS* LH    R2,SCSCNID             GET CONSOLE ID         02/08/2007\n009600          L     R2,SCSCONID            GET CONSOLE ID         02/08/2007\n009610 *DRCICS* STH   R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n009700          ST    R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 17 Line(s) not Displayed\n011500 *DRCICS* CLC   UCMID(1),TSSCONID+1    COMPARE UCM IDS        02/08/2007\n011600          CLC   UCMID(1),TSSCONID+3    COMPARE UCM IDS        02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 50 Line(s) not Displayed\n016700 *DRCICS* MVC   SCSCNID(2),TSSCONID    INDICATE THE CONSOLE TO02/08/2007\n016800          MVC   SCSCONID,TSSCONID      INDICATE CNSL TO RELEAS02/08/2007\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 53 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n\n\n\nEDIT       LJL.TSSO.ASM(TSSOINI4) - 01.02                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 71 Line(s) not Displayed\n007000 *DRCICS* LH    R2,TSSCONID         GET THE CONSOLE ID\n007010          L     R2,TSSCONID         GET THE CONSOLE ID\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 86 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n\n\n\n\nEDIT       LJL.TSSO.ASM(TSSOTERM) - 01.02                  Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   296 Line(s) not Displayed\n028600 *DRCICS* STH   R1,TSSCONID       STICK IN TSSCONID.\n028610          ST    R1,TSSCONID       STICK IN TSSCONID.\n- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   115 Line(s) not Displayed\n****** **************************** Bottom of Data ****************************\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PAYROLL": {"ttr": 24582, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x03\\x00\\n\\x00\\n\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:03:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "TSSO403"}, "text": "//PAYROLL1  JOB (3225,P136),'TSSO/AOF TEST JOB',CLASS=X,MSGCLASS=F,\n// REGION=100K\n//********************************************************************\n//* THIS IS A TEST JOB TO BE USED WITH THE TSSO/AOF FACILITY. IT IS  *\n//* USED IN CONJUNCTION WITH THE SAMPLE TSSO/AOF SAMPLE TABLE        *\n//* \"AOFIVP\"                                                         *\n//********************************************************************\n/*ROUTE XEQ PYR4PROD\n/*ROUTE PRINT PYR4PROD\n//S2 EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 24584, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x07\\x07\\x1f\\x01\\x07\\x07\\x1f#\\x12\\x00%\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-03-12T00:00:00", "modifydate": "2007-03-12T23:12:48", "lines": 37, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*      THIS JOB RECONSTITUTES THE OLD TSSO INSTALL LIBRARY\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT474.FILE404',   /* THIS PDS */\n//             OPRE=SBGOLOB,\n//             QUAL=TSPRE18,\n//             MEMB=$$PREZ18,\n//             OUNT=SYSALLDA,\n//             OVL=WORK04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=105,S=30,D=89\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.PDSLOAD.TEMPLIB\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//*  CREATE THE LOADLIB WITH THE PDSLOAD PROGRAM IN IT, FIRST.\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n  RECEIVE INDS('SBGOLOB.CBT474.FILE404(PDSLOAD)')\n  DSN('SBGOLOB.PDSLOAD.TEMPLIB') VOL(WORK05) UNIT(SYSALLDA)\n/*\n//*\n//S001 EXEC PDSLOAD,MEMB=$$PREZ18\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PVWNOTE": {"ttr": 24586, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x07\\x01\\x026\\x1f\\x01\\x026O\\x10'\\x00\\x19\\x00\\x16\\x00\\x00\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-12-27T00:00:00", "modifydate": "2002-12-30T10:27:07", "lines": 25, "newlines": 22, "modlines": 0, "user": "CTEC004"}, "text": "$PVWNOTE as of December, 2002                                   PVW1202\n                                                                PVW1202\n                                                                PVW1202\nMy changes include the following:                               PVW1202\n                                                                PVW1202\n1) Updated TSSOCCMD to correct a problem of the RELOAD command. PVW1202\n   TSSOCCMD has been updated to change back into a non-zero     PVW1202\n   key before issuing the DELETE of the old AOF table.  When    PVW1202\n   done, TSSOCCMD will change back to key zero.                 PVW1202\n   TSSO now will properly delete the previous table from        PVW1202\n   global storage before attempting to load the new table in.   PVW1202\n                                                                PVW1202\n2) Added program TSSORATH (and updated programs ALTAOF and      PVW1202\n   CACHE) to call this program.  TSSORATH will call SAF to      PVW1202\n   verify access to the FACILITY class profile TSSO.CMD.AUTH.   PVW1202\n   If found, and the userid has READ access to the profile,     PVW1202\n   skip around the logic to check the userdata field in uads.   PVW1202\n   If the profile is not found, continue and check the uads     PVW1202\n   field (as it currently works).                               PVW1202\n                                                                PVW1202\n3) Update TABENTRY and TSSOSS09 to allow for another action     PVW1202\n   specification of MSGRED.  When MSGRED is specified, the      PVW1202\n   message will be hilighted in red on the console.             PVW1202\n                                                                PVW1202\n                                                                PVW1202\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TSSODOC": {"ttr": 24588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x03\\x00@\\x01 !/\\x01 !/\"!\\x0eG\\x0eG\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "04.03", "flags": 0, "createdate": "2020-07-30T00:00:00", "modifydate": "2020-07-30T22:21:40", "lines": 3655, "newlines": 3655, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "@FILE404": {"ttr": 26117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00R\\x01 !?\\x01 !?\\x00\\x17\\x00|\\x00|\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T00:17:52", "lines": 124, "newlines": 124, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 404 is source for TSSO to be run under OS/390 and z/OS.   *   FILE 404\n//*                                                                 *   FILE 404\n//*       Updated by John McKown to no longer require that the      *   FILE 404\n//*       TSSOPARM member be in SYS1.PARMLIB, but it uses the       *   FILE 404\n//*       IEFPRMLB service to search the PARMLIB concatenation      *   FILE 404\n//*       of libraries.  Optionally, you can include a //PARMLIB    *   FILE 404\n//*       DD card in the TSSO proc, to point to the library of      *   FILE 404\n//*       your choice.                                              *   FILE 404\n//*                                                                 *   FILE 404\n//*    A WORD-format version of the TSSO 4.3 doc is included here   *   FILE 404\n//*    courtesy of John Kalinich, as member $TSSODOC.               *   FILE 404\n//*                                                                 *   FILE 404\n//*    ---------------------------------------------------------    *   FILE 404\n//*                                                                 *   FILE 404\n//*    Fixed for z/OS 1.8 elimination of the Master Console,        *   FILE 404\n//*    and to accommodate only 4-byte console ids.  Fix is by       *   FILE 404\n//*    Larry Lawler (aka Dr CICS).                                  *   FILE 404\n//*                                                                 *   FILE 404\n//*    Old version (z/OS 1.7 and before) has been packaged in       *   FILE 404\n//*    PDSLOAD format, as member $$PREZ18.  To reconstitute the     *   FILE 404\n//*    old install pds, just run job $PDSLOAD in this pds, which    *   FILE 404\n//*    is self-contained, and will yield the old pds for File 404.  *   FILE 404\n//*                                                                 *   FILE 404\n//*    Also added were newer versions of the \"assemble all\" and     *   FILE 404\n//*    \"assemble one module\" JCL streams.  These are members:       *   FILE 404\n//*                                                                 *   FILE 404\n//*    ASMA9ALL and ASMA9ONE                                        *   FILE 404\n//*                                                                 *   FILE 404\n//*    A suggested enhancement which shows (at TSSO initialization  *   FILE 404\n//*    time) which subsystem consoles are present, is included      *   FILE 404\n//*    as member $$ENHANC.  You can use this extra source for       *   FILE 404\n//*    this enhancement, if you want to.  It also comes from        *   FILE 404\n//*    Larry Lawler.                                                *   FILE 404\n//*                                                                 *   FILE 404\n//*    ---------------------------------------------------------    *   FILE 404\n//*                                                                 *   FILE 404\n//*    Major modifications have been made to this version by        *   FILE 404\n//*    Ed Jaffe.  Fixes were also added by Dave Cartwright.         *   FILE 404\n//*    This version now should run on the z/OS releases which       *   FILE 404\n//*    are available now (11/02).  Dependencies are on ESA 4.1      *   FILE 404\n//*    and higher.                                                  *   FILE 404\n//*                                                                 *   FILE 404\n//*    Some fixes were made by Peter Vander Woude.  Please check    *   FILE 404\n//*    over member $PVWNOTE.                                        *   FILE 404\n//*                                                                 *   FILE 404\n//*        email: \"Peter Vander Woude\" <pwoude@harristeeter.com>    *   FILE 404\n//*                                                                 *   FILE 404\n//*    Fixes made to TSSOSS09 by Michael Mayne and Daniel Cattin.   *   FILE 404\n//*                                                                 *   FILE 404\n//*        email:  mmayne@chattanooga.net    mmayne@hhsys.org       *   FILE 404\n//*                Cattin@osys.ch                                   *   FILE 404\n//*                                                                 *   FILE 404\n//*    This version contains a fix to SPMON from Brian Westerman,   *   FILE 404\n//*    so it doesn't get an 0C4.  See member $$SPMON for details.   *   FILE 404\n//*                                                                 *   FILE 404\n//*        email:  Brian_Westerman@SyzygyInc.com                    *   FILE 404\n//*                                                                 *   FILE 404\n//*    Note.  For older versions of TSSO (Bellcore version),        *   FILE 404\n//*           please see Files 247, 248, 249 of the CBT Overflow    *   FILE 404\n//*           Tape.  The mapping from the former files on this      *   FILE 404\n//*           tape is as follows:                                   *   FILE 404\n//*                                                                 *   FILE 404\n//*   File 401 - Original Bellcore version ---> File 247 (Overflow) *   FILE 404\n//*   File 402 - Dave Cartwright's updates ---> File 248 (Overflow) *   FILE 404\n//*   File 403 - DC updates fitted to F401 ---> File 249 (Overflow) *   FILE 404\n//*   File 404 - Previous version on File 404 > File 250 (Overflow) *   FILE 404\n//*                                                                 *   FILE 404\n//*           Bill Godfrey's original version of TSSO is still      *   FILE 404\n//*           on File 306 of the CBT MVS Utilities Tape.            *   FILE 404\n//*                                                                 *   FILE 404\n//*           The Time Sharing Subsystem Option (TSSO) is a         *   FILE 404\n//*           package designed to increase operator productivity    *   FILE 404\n//*           by automating tasks which need not be performed       *   FILE 404\n//*           manually.  TSSO performs its function through three   *   FILE 404\n//*           integrated components.  The Operator Productivity     *   FILE 404\n//*           Facility (OPF) extends the power of TSO to the        *   FILE 404\n//*           MVS operator's console.  The Automated Operations     *   FILE 404\n//*           Facility (AOF) enhances an installation's             *   FILE 404\n//*           ability to control system events based on console     *   FILE 404\n//*           message traffic.  An interface to the Network         *   FILE 404\n//*           Communication Control Facility (NCCF) allows the      *   FILE 404\n//*           network operator to use TSSO as a command processor,  *   FILE 404\n//*           issuing and receiving operating system commands at    *   FILE 404\n//*           the NCCF terminal.  Note that NCCF is now an inte-    *   FILE 404\n//*           grated part of Netview.  TSSO also enhances end-user  *   FILE 404\n//*           productivity by allowing end-user access to the MVS   *   FILE 404\n//*           Command Subsystem.  A complete User's Guide,          *   FILE 404\n//*           including detailed installation instructions exists   *   FILE 404\n//*           in member UG43TERM in this file.                      *   FILE 404\n//*                                                                 *   FILE 404\n//*           A guide to the new features of TSSO Version 4,        *   FILE 404\n//*           Release 3 is in the member RELGDE43 in this file.     *   FILE 404\n//*                                                                 *   FILE 404\n//*           Anyone with an interest in automated operations is    *   FILE 404\n//*           invited to look at TSSO as a software tool providing  *   FILE 404\n//*           many of the primitives required for common automated  *   FILE 404\n//*           operations tasks.  These primitives include the       *   FILE 404\n//*           hilighting, lowlighting, replying and reacting to     *   FILE 404\n//*           operating system messages.  This is in addition to    *   FILE 404\n//*           the ability to issue a command and retrieve the       *   FILE 404\n//*           response in CLIST variables.                          *   FILE 404\n//*                                                                 *   FILE 404\n//* --------------------------------------------------------------  *   FILE 404\n//*                                                                 *   FILE 404\n//*      Note on Dave Cartwright's modifications:                   *   FILE 404\n//*                                                                 *   FILE 404\n//*         The purpose of these modifications is to allow TSSO     *   FILE 404\n//*         to handle automated message processing with multi-      *   FILE 404\n//*         line WTO's and to do other new functions.  File 402     *   FILE 404\n//*         has been merged into TSSO 4.3 by Guy Albertelli.  So    *   FILE 404\n//*         it's probably best to ignore File 402 and install       *   FILE 404\n//*         File 404 instead, which is an OS/390 upgrade of the     *   FILE 404\n//*         former File 403.  As noted above, the former Files      *   FILE 404\n//*         401 thru 403 have been moved to the CBT Overflow Tape.  *   FILE 404\n//*                                                                 *   FILE 404\n//* --------------------------------------------------------------  *   FILE 404\n//*      Small change to TSSOWTO to fix a vulnerability.            *   FILE 404\n//* --------------------------------------------------------------  *   FILE 404\n//*                                                                 *   FILE 404\n//*           THIS FILE IS IN IEBUPDTE SYSIN FORMAT.                *   FILE 404\n//*                                                                 *   FILE 404\n//*           QUESTIONS, PLEASE CONTACT Sam Golob:                  *   FILE 404\n//*                      sbgolob@cbttape.org                        *   FILE 404\n//*                                                                 *   FILE 404\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AGCOASM": {"ttr": 26120, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\"\\x00\\x99&\\x7f\\x01\\x172O\\x10\\x06\\x00\\x80\\x00w\\x00\\x13\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "2017-11-20T10:06:22", "lines": 128, "newlines": 119, "modlines": 19, "user": "JOARMC"}, "text": "//JOARMCTS  JOB  (ACCNT,01),'TSSO................',CLASS=F,\n//          MSGCLASS=H,NOTIFY=&SYSUID,REGION=0M\n//*\n//*      PDSDOC *ASSEMBLE TSSO (ALL MODULES)..........................*\n//*\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD DUMMY\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=JOARMC.TSSO431.SOURCE\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT DD DISP=(NEW,PASS),\n//         UNIT=SYSDA,RECFM=VBA,LRECL=137,BLKSIZE=0,DSORG=PS\n//SYSIN    DD DSN=JOARMC.TSSO431.SOURCE(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD DSN=*.ASM.SYSPRINT,DISP=(MOD,PASS)\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=JOARMC.TSSO431.APFLIB\n//SYSIN DD DUMMY\n//*\n//LISTING EXEC PGM=ICEGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DSN=*.ASM.SYSPRINT,DISP=(OLD,DELETE,DELETE)\n//SYSUT2   DD  DISP=OLD,DSN=JOARMC.TSSO431.LISTING(&MEMBER)\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//RESTART  EXEC PGM=IEFBR14\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//TSSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//TSSORATH EXEC ASMTSSO,MEMBER=TSSORATH,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//LIONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALOCCACH": {"ttr": 26123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x03\\x00\\x12\\x00\\x12\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:03:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "TSSO403"}, "text": "           PROC 0\n         /*************************************************************/\n         /* THIS CLIST WILL PROVIDE THE DATASETS NECCESSARY FOR THE   */\n         /* TSO CACHE COMMAND TO OPERATE. IF THE CACHE COMMAND IS     */\n         /* INVOKED FROM A TSO SESSION, THIS CLIST MUST BE RUN PRIOR  */\n         /* TO IT'S INVOCATION.                                       */\n         /*************************************************************/\n           FREE FI(IDCOUT IDCAMSDD) ATTR(ID1 IDC)\n\n           ATTRIB ID1 LRECL(80) BLKSIZE(6400) RECFM(F B)\n\n           ALLOC FI(IDCAMSDD) SPACE(1 1) TRACKS UNIT(SYSDA) USING(ID1)\n\n           ATTRIB IDC LRECL(125) BLKSIZE(625) RECFM(V B A)\n\n           ALLOC FI(IDCOUT) USING(IDC) SPACE(2 2) TRACKS UNIT(SYSDA)\n\n           WRITE CACHE ALLOCATIONS COMPLETE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALTAOF": {"ttr": 26125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x966o\\x01\\x026\\x1f\\x16\"\\x01\\x02\\x00\\xf1\\x00\\x12\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-12-31T00:00:00", "modifydate": "2002-12-27T16:22:00", "lines": 258, "newlines": 241, "modlines": 18, "user": "CTEC004"}, "text": "ALTAOF   MENTER 12,EQU,COM=ALTAOF,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n***********************************************************************\n* THIS IS THE TSSO ALTAOF COMMAND. IT WILL SEEK OUT THE SPECIFIED     *\n* ENTRY ID IN THE ACTIVE AOF TABLE, AND CHANGE ITS MATCHLIM VALUE     *\n* TO THE VALUE SPECIFIED ON THE COMMAND LINE.                         *\n*                                                                     *\n*\n* SYNTAX:\n*\n*      ALTAOF ENTRY(ENTRY-IDENTIFIER) MATCHLIM(MLIM-NUMBER)\n* WHERE:\n*    ENTRY  -  THE TSSO/AOF TABLE ENTRY ID.\n*    MATCHLIM- THE NEW MATCHLIM VALUE FOR THE ENTRY.\n***********************************************************************\n*\n* VERSION IDENTIFIER:  TSSO VERSION 4.2\n* AUTHOR. MARC SCHARE\n*\n*\n* VERSION IDENTIFIER:  TSSO VERSION 4.3\n* IN TSSO 4.3, THE ALTAOF COMMAND ENTRYID PARAMETER IS THE LABEL\n* OF THE TABENTRY MACRO. IN PREVIOUS RELEASES, IT WAS THE NUMBER.\n*\n*\n*\n***********************************************************************\n*\n* MODIFIED\n*   20OCT92  GLA  USE NEW DSECTS FOR AOF ENTRIES\n*\n*   DEC 2002 PVW  ADD CALL TO TSSORATH TO CHECK AUTHORIZATION IN\n*                 RACF TO USE THIS COMMAND.  IF NO RACF PROFILE FOUND,\n*                 CONTINUE AND CHECK THE UADS USERDATA FIELD.  IF\n*                 RACF PROFILE FOUND, SKIP CHECK OF UADS FIELD AND GO\n*                 BASED ON AUTHORIZATION FOUND IN RACF.\n*\n***********************************************************************\n* THE FIRST STEP IS TO PARSE THE INPUT, AND DETERMINE WHAT THE USER IS\n* AFTER.\n***********************************************************************\n         TESTAUTH FCTN=1\n         LTR   R15,R15\n         BNZ   ERROR6\n*\n         LINK  EP=TSSORATH                  LINK TO PGM TO CHECK AUTH\n*                                           TO TSSO.CMD.AUTH PROFILE\n*                                           IN RACF FOR PERMISSION TO\n*                                           USE THE POWERFUL ALTAOF\n*                                           COMMAND\n         LTR   R15,R15                      AUTHORIZED?\n         BZ    AUTHZD                       YES, CONTINUE\n         C     R15,=F'8'                    NOT AUTHORIZED?\n         BE    ERROR6                       CORRECT, ISSUE MESSAGE\n*\n         EXTRACT PSCBADDR,'S',FIELDS=PSB    CHECK THE C0 BITS IN\n         L     R9,PSCBADDR                  SYS1.UADS FOR PERMISSION\n         USING PSCB,R9                      TO USE THE POWERFUL ALTAOF\n         TM    PSCBATR2,X'C0'               COMMAND\n         BNO   ERROR6\n         DROP  R9\n*\nAUTHZD   DS    0H\n         SETPARSE PCL=ALTPARSE\n         LA    R10,CORE\n         LINK  EP=IKJPARS\n         L     R9,MYANS\n         USING IKJPARMD,R9\n*\nCHEKENTR DS    0H\n         MVI   ENTSPEC,C' '\n         MVC   ENTSPEC+1(7),ENTSPEC\n*\n         LH    R2,ENTRY              CHECK IF SPECIFIED\n         CH    R2,=H'1'              WELL? WAS IT?\n         BNE   ERROR1                GUESS NOT...  FORGET WHOLE THING\n         LH    R3,ENTSUBID+4         GET THE PDL FOR THE SPECIFIED ENT\n         L     R2,ENTSUBID           GET THE PDL FOR THE ENTRY.\n         BCTR  R3,0                  FOR EXECUTE,\n         EX    R3,MOVEENT            AND MOVE IT.\n         B     ARD1\nMOVEENT  MVC   ENTSPEC(0),0(R2)\nARD1     DS    0H\n*\nCHEKMLIM DS    0H\n         LH    R2,MLIM\n         LTR   R2,R2                 WELL? WAS IT?\n         BZ    ERROR2                GUESS NOT...  FORGET WHOLE THING\n         L     R2,MLIMSBID           GET THE PDL FOR THE SPECIFIED ENT\n         L     R2,0(R2)              GET ACTUAL VALUE\n         ST    R2,MLIMSPEC           AND PUT IT AWAY...\n*\n         DROP  R9\n***********************************************************************\n* NOW THAT WE HAVE THE PARAMETERS, WE WILL EITHER USE THE CURRENT     *\n* TABLE ID, IN STORAGE.                                               *\n* WE WILL WALK THROUGH THE TABLE UNTIL WE FIND THE SPECIFIED ENTRY ID.*\n***********************************************************************\n         GETCVT (R9)                 START WITH TSSO CVT           RPS\n         LTR   R9,R9\n         BZ    ERROR3\n         USING TSSOCVT,R9\n         L     R9,TSSOTABL           GET TSSO TABLE ADDRESS\n         LTR   R9,R9\n         BZ    ERROR4                GET TSSO CURRENT TABLE ADDR.\n         DROP  R9\n***********************************************************************\n* WE NOW HAVE A TSSO TABLE, POINTED TO BY THE ADDRESS IN TABADDR      *\n* WE CAN (FINALLY) LOCATE THE SPECIFIED ENTRY ID.                     *\n***********************************************************************\n         L     R9,0(R9)                 POINT TO THE FIRST RECORD IN\n*                                       THE TSSO AOF.\n         USING AOFNTRY,R9               SETUP ADDRESSABILITY\nENTLOOP  DS    0H\n         CLC   AOFMSGID,=CL8'ZZZZZZZZ'  IS THIS THE LAST RECORD ?\n         BE    ENDRECS\n         CLC   AOFENTR,ENTSPEC          GET ENTRY IDENTIFIER..\n         BE    GOTENTR                  YUP, ON OUR WAY...\n         L     R9,AOFNXT\n         B     ENTLOOP\nENDRECS  DS    0H\n         B     ERROR5\nGOTENTR  DS    0H\n***********************************************************************\n* HERE, R9 POINTS TO THE SPECIFIED ENTRY IN THE AOF TABLE. WE WILL    *\n* FORMAT A MESSAGE, AND ZAP THE AOF TABLE.                            *\n***********************************************************************\n*\n         LR    R1,R8\n         CALL  JCECVTBD\n         MVC   MSG1T+22(8),ENTSPEC      MOVE SPECIFIED ENTRY TO MSG\n*\n         L     R7,AOFMLIM               GET PREVIOUS MATCHLIM VALUE.\n         C     R7,=F'999999'            ANY THERE ?\n         BE    NOPREVAL                 NO, MATCHLIM WAS NONE\n         LR    R1,R7\n         CALL  JCECVTBD                 CONVERT TO DECMIAL\n         STCM  R1,B'1111',MSG1T+44\n         B     ZAPVAL\nNOPREVAL DS    0H\n         MVC   MSG1T+44(4),=CL4'NONE'\nZAPVAL   DS    0H\n         L     R7,MLIMSPEC              GET SPECIFIED MLIM.\n         C     R7,=F'999999'            NO MATCHLIM DESIRED ?\n         BE    NOZAPVAL\n         LR    R1,R7\n         CALL  JCECVTBD\n         STCM  R1,B'1111',MSG1T+52\n         B     ZAPVAL2\nNOZAPVAL DS    0H\n         MVC   MSG1T+52(4),=CL4'NONE'\nZAPVAL2  DS    0H\n         MODESET KEY=ZERO              POWER REQUIRED FOR THIS COMMAND\n         ST    R7,AOFMLIM              ** DONE **\n         MODESET KEY=NZERO             NO MORE POWER.\n         DROP  R9\nPRTMSG   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(MSG1H,TERM,SINGLE,DATA),         X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\n*\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR1H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR2H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR3   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR3H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR4H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR5H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR6H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nENDPROG  DS    0H\n         MLEAVE\nENTSPEC  DS    CL8              ENTRY ID SPECIFIED BY USER\nMLIMSPEC DS    F                MATCHLIM SPECIFIED BY USER.\nPSCBADDR DS    F\nMSG1H    DC    H'80',H'0'\nMSG1T    DC    CL80'MATCHLIM FOR ENTRY ID XXXXXXXX CHANGED FROM XXXX TOC\n                XXXX'\n*\nERROR1H  DC    H'80',H'0'\nERROR1T  DC    CL80'A ENTRY ID MUST BE SPECIFIED - REQUEST ABORTED'\n*\nERROR2H  DC    H'80',H'0'\nERROR2T  DC    CL80'A NEW MATCHLIM VALUE MUST BE SPECIFIED - REQUEST ABX\n               ORTED'\n*\nERROR3H  DC    H'80',H'0'\nERROR3T  DC    CL80'TSSO DOES NOT APPEAR TO BE ACTIVE IN THE SYSTEM - RX\n               EQUEST DENIED'\n*\n*\nERROR4H  DC    H'80',H'0'\nERROR4T  DC    CL80'THE AUTOMATED OPERATIONS FACILITY IS NOT ACTIVE - RX\n               EQUEST DENIED'\n*\n*\nERROR5H  DC    H'80',H'0'\nERROR5T  DC    CL80'THE SPECIFIED ENTRY IDENTIFIER IS NOT PRESENT IN THX\n               E ACTIVE AOF TABLE'\n*\n*\nERROR6H  DC    H'80',H'0'\nERROR6T  DC    CL80'ALTAOF IS TERMINATING BECAUSE IT WAS NOT INVOKED AUX\n               THORIZED'\n*\nCORE     DS    CL200\n********************************************************************\n* THIS IS THE DESCRIPTION OF THE COMMAND SYNTAX, AS PARSE WANTS IT *\n********************************************************************\nALTPARSE IKJPARM\nENTRY    IKJKEYWD\n         IKJNAME 'ENTRY',SUBFLD=ENTSUB\nMLIM     IKJKEYWD\n         IKJNAME 'MATCHLIM',SUBFLD=MLIMSUB\n         IKJNAME 'MLIM',SUBFLD=MLIMSUB\nENTSUB   IKJSUBF\nENTSUBID IKJIDENT 'ENT',PROMPT='ENTRY IDENTIFIER',FIRST=ALPHANUM,      X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE ENTRY IDENTIFIER',                X\n               'IDENTIFIER THAT WAS SPECIFIED AS A LABLE ON THE TABENTRX\n               Y MACRO')\nMLIMSUB  IKJSUBF\nMLIMSBID IKJIDENT 'ENT',PROMPT='MATCH LIMIT',INTEG,                    X\n               HELP=('MATCH LIMIT FOR THIS ENTRY ID')\n         IKJENDP\n         IKJIOPL\n         IKJPSCB\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         CVT   DSECT=YES\n         TSSOCVT\n         TAOFNTRY\n         END   ALTAOF\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY ALTAOF(''TSSO V 4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    ALTAOF'\n PUNCH ' NAME     ALTAOF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AOFBATH": {"ttr": 26372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x03\\x00\\xf1\\x00\\xf1\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:03:00", "lines": 241, "newlines": 241, "modlines": 0, "user": "TSSO403"}, "text": "***********************************************************************\n* THIS IS A AUTOMATED OPERATIONS FACILITY TABLE FOR USE AT THE BATH   *\n* DATACENTER. IT SHOULD HELP AUTOMATE THE DATACENTER OPERATION.       *\n*                                                                     *\n*   CREATED - GLA 10/27/86                                            *\n*   UPDATED - GLA 11/13/86  ADD SUPPORT FOR TMS INITIALIZATION        *\n*                 11/26/86  ADD SUPPORT FOR UCC1 INIT                 *\n*                 12/2/86   ADD SUPPORT FOR ALL SHUTDOWN AND STARTUP  *\n*                 12/4/86   ADD SUPPORT FOR ACTIVATING HOST3          *\n*                 12/08/86  REORGANIZED FOR READABILITY               *\n*                 02/02/87  ADD SUPPORT FOR ICOM STARTUP (RDT TBL)    *\n*                 02/23/87  ADD SUPPORT FOR VTAM NETWORKING           *\n*                 02/26/87  AUTOMATE TAPE WAIT/NOHOLD                 *\n*                 04/20/87  AUTOMATE CLASS E OFFLOAD                  *\n*                 07/17/87  AUTOMATE CLASS F OFFLOAD                  *\n*                 11/20/87  LOWLIGHT \"ENDED ABNORMALLY\" FOR WEEKEND   *\n*                 11/20/87  IGNORE MESSAGE RPTM9106I                  *\n*                 06/10/88  HILIGHT MESSAGE IST129I FOR PERM FAILED   *\n*                 09/27/88  START CICS SUPPORT                        *\n*                 09/14/89  IPL SUPPORT FOR TMSINIT COMPLETE          *\n*                 09/24/89  MAKE ONLY 1 MODULE FOR BOTH WEEK AND WKEND*\n*                 01/14/90  SUPPORT P4230 AS PEP MODULE FOR 3725      *\n*                 05/21/90  LOWLIGHT INT REQ MESSAGE FOR B28          *\n*                 06/27/90  SUPRESS DUMB IDMS MESSAGE DC075102        *\n*                 10/16/90  AUTO FORM CHANGE NETWORK PRTS ON PCS.     *\n*                 11/19/90  RESTART PRINTER AFTER DISCONNECT          *\n*                 11/20/90  DONT ROLL $HASP625                        *\n*                 12/10/90  AUTO CICS STARTUP W/ DEAD TMON            *\n*                 08/11/91  SUPPORT NEW LEVEL OF CA-11                *\n*                           AUTO ANSWER V FORCE DURING SHUTDOWN       *\n*                 05/11/92  SUPPORT P4330 AS PEP MODULE FOR 3725      *\n*                 07/19/92  SUPPORT NEW LEVEL OF CA-7 FOR SHUTDOWN    *\n*                 08/17/92  SUPPORT STARTUP OF VCSS                   *\n*                 09/19/92  CHANGE MESSAGE FOR B28 TO A28             *\n*                 10/30/92  ADD AUTOMATED REPLY FOR FDR EXERCISE OF   *\n*                           STK DRIVES.                               *\n*                 10/30/92  CLEAN UP OBSOLETE ENTRIES.                *\n*                                                                     *\n***********************************************************************\n         PRINT GEN\nAOFIVP   TABSTART ID=IVPTABLE\n***********************************************************************\n*                                                                     *\n*  ----->  GENERAL SECTION                                            *\n*                            GENERAL MESSAGE HANDLING                 *\n*=====================================================================*\n* 1.  HIGHLIGHT RESPONSE FOR WRONG REPLY MESSAGE.                     *\n         TABENTRY MSG=IEE704I,ACTION=HILIGHT\n*=====================================================================*\n* 2.  SUPPRESS INACTIVE INITIATOR MESSAGE FROM JES.                   *\n         TABENTRY MSG=$HASP309,ACTION=SUPPRESS\n*=====================================================================*\n* 3.  TERMINATE ANY EXTERNAL WRITER WHEN IT IS \"WAITING FOR WORK\",    *\n*     NOTE HOW IT USES THE DDD FROM THE MESSAGE TO FIGURE OUT WHAT TO *\n*     PURGE. NOTE THAT THIS WILL WORK FOR ANY EXTERNAL WRITER.        *\n         TABENTRY MSG=IEF176I,ACTION=OSCMD,ECHO=YES,                   X\n               TEXT='P \\W    03\\'\n*=====================================================================*\n* 4.  DSI802A CAN BE ALLOWED TO ROLL OFF SCREEN, SINCE OPERATOR RARELY*\n*     NEEDS TO REPLY.                                                 *\n         TABENTRY MSG=DSI802A,ACTION=LOWLIGHT\n*=====================================================================*\n* 5.  ** OBSOLETE **                                                  *\n*=====================================================================*\n* 6.  ISSUE COMMAND FOR PEP30 COMING ACTIVE                           *\n         TABENTRY MSG=IST093I,ACTION=OSCMD,TEXT='|PEP30 ACTIVE',       X\n               TEST=((W,2,5,'P4330','    '))\n         TABENTRY MSG=IST093I,ACTION=OSCMD,TEXT='|PEP30 ACTIVE',       X\n               TEST=((W,2,5,'P4230','    '))\n*=====================================================================*\n* 7.  ISSUE COMMAND FOR PEP30 GOING INACTIVE                          *\n         TABENTRY MSG=IST105I,ACTION=OSCMD,TEXT='|PEP30 INACTIVE',     X\n               TEST=((W,2,5,'P4330','    '))\n         TABENTRY MSG=IST105I,ACTION=OSCMD,TEXT='|PEP30 INACTIVE',     X\n               TEST=((W,2,5,'P4230','    '))\n*=====================================================================*\n* 8.  ISSUE COMMAND FOR CTL3006 COMING ACTIVE                         *\n         TABENTRY MSG=IST093I,ACTION=OSCMD,TEXT='|CTL3006 ACTIVE',     X\n               TEST=((W,2,5,'CTL3006','    '))\n*          ERROR RECOVERY SUCCESSFUL MESSAGE\n         TABENTRY MSG=IST621I,ACTION=OSCMD,TEXT='|CTL3006 ACTIVE',     X\n               TEST=((W,7,5,'CTL3006','    '))\n*=====================================================================*\n* 9.  ISSUE COMMAND FOR CTL3006 GOING INACTIVE                        *\n         TABENTRY MSG=IST105I,ACTION=OSCMD,TEXT='|CTL3006 INACTIVE',   X\n               TEST=((W,2,5,'CTL3006','    '))\n*=====================================================================*\n* 10. REPLY 'WAIT' TO ALLOCATION MESSAGE                              *\n         TABENTRY MSG=IEF238D,ACTION=REPLY,ECHO=YES,                   X\n               TEST=((W,6,4,'WAIT',' - ''')),                          X\n               TEXT='WAIT'\n*=====================================================================*\n* 11. REPLY 'NOHOLD' TO ALLOCATION MESSAGE                            *\n         TABENTRY MSG=IEF433D,ACTION=REPLY,ECHO=YES,                   X\n               TEXT='NOHOLD'\n*=====================================================================*\n* 12. DETECT OFFLOAD INACTIVE MESSAGE AND INVOKE A CLIST              *\n         TABENTRY MSG=$HASP534,ACTION=OSCMD,                           X\n               TEST=((W,2,7,'OFF1.ST','    ')),                        X\n               TEXT='|DOCLSE'\n*=====================================================================*\n* 13. DETECT OFFLOAD INACTIVE MESSAGE AND INVOKE A CLIST              *\n         TABENTRY MSG=$HASP534,ACTION=OSCMD,                           X\n               TEST=((W,2,7,'OFF3.ST','    ')),                        X\n               TEXT='|DOCLSF'\n         AIF   ('&SYSPARM' EQ 'WEEKEND').WK1\n*=====================================================================*\n* 14. LOWLIGHT \"ENDED ABNORMALLY\" MESSAGE   <==== DUMMY FOR WEEKDAY   *\n*        TABENTRY MSG=*,ACTION=LOWLIGHT,\n*              TEST=((W,2,3,'HAS','    '),(W,3,5,'ENDED','    '),\n*              (W,4,10,'ABNORMALLY','    '))\n         AGO   .EWK1\n.WK1     ANOP\n*=====================================================================*\n* 14. LOWLIGHT \"ENDED ABNORMALLY\" MESSAGE   <==== DUMMY FOR WEEKDAY   *\n         TABENTRY MSG=*,ACTION=LOWLIGHT,                               X\n               TEST=((W,2,3,'HAS','    '),(W,3,5,'ENDED','    '),      X\n               (W,4,10,'ABNORMALLY','    '))\n.EWK1    ANOP\n*=====================================================================*\n* 15. ** OBSOLETE                                                     *\n*=====================================================================*\n* 16. HIGHLIGHT MESSAGE OF UNRECOVERABLE VTAM FAILURE                 *\n         TABENTRY MSG=IST129I,ACTION=HILIGHT\n*=====================================================================*\n* 17. HANDLE CICS JOURNAL OFFLOAD REQUEST                             *\n         TABENTRY MSG=DFH4583,ACTION=OSCMD,ECHO=YES,                   X\n               TEXT='|CICSO \\W    03\\ \\W    17\\'\n*=====================================================================*\n* 18. LOWLIGHT INTERVENTION REQUIRED MESSAGE FOR BATH PRINTER         *\n         TABENTRY MSG=IOS003A,ACTION=LOWLIGHT,                         X\n               TEST=((W,2,3,'A28',',   '))\n*=====================================================================*\n* 19. SUPPRESS REPORT PRINTING MESSAGE FROM IDMS (DC075102)           *\n         TABENTRY MSG='+IDMS DC',                                      X\n               ACTION=SUPPRESS,                                        X\n               TEST=((W,2,8,'DC075102','    '))\n*=====================================================================*\n* 20. ** OBSOLETE **                                                  *\n*=====================================================================*\n* 21. ** OBSOLETE **                                                  *\n*=====================================================================*\n* 22. ** OBSOLETE **                                                  *\n*=====================================================================*\n* 23. ** OBSOLETE **                                                  *\n*=====================================================================*\n* 24. HILIGHT $HASP625 FOR AIW PROBLEM INVESTIGATION                  *\n         TABENTRY MSG='$HASP625',                                      X\n               ACTION=HILIGHT\n*=====================================================================*\n* 25. AUTO CICS STARTUP W/ MISSING TMON                               *\n         TABENTRY MSG=TMON6043,ACTION=REPLY,ECHO=YES,                  X\n               TEST=((W,1,10,'TMON60432D','   ''')),                   X\n               TEXT='IGNORE'\n*=====================================================================*\n* 26. AUTO FDR COPIES FOR STK DRIVE TESTING                           *\n         TABENTRY MSG='FDRW01 C',ACTION=REPLY,ECHO=YES,                X\n               TEXT='YES'\n         EJECT\n***********************************************************************\n*                                                                     *\n*  ----->  IPL STARTUP SECTION                                        *\n*                            HANDLE NECESSARY CONDITIONS AT IPL       *\n*=====================================================================*\n* 1.  ISSUE STARTUP COMMAND AFTER TSSO IS UP  *\n         TABENTRY MSG=TSST060I,ACTION=OSCMD,TEXT='|TSST060'\n*=====================================================================*\n* 2.  WHEN VTAM IS INITIALIZED (VIA IST020I) THEN HIGHLIGHT IT FOR    *\n*     THE OPERATORS AND ISSUE THE NETWORK STARTUP PROCEDURE.          *\n         TABENTRY MSG=IST020I,ACTION=HILIGHT\n         TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT='|SVTAM'\n*=====================================================================*\n* 3.  REPLY 'U' TO TMS INITIALIZATION MESSAGE                         *\n*     AND LIMIT REPLY TO ONE PER IPL.                                 *\n         TABENTRY MSG=IEFTMS0,ACTION=REPLY,TEXT='U',ECHO=YES,          X\n               MATCHLIM=1\n*=====================================================================*\n* 4.  REPLY 'U' TO TMS DATE INITIALIZATION MESSAGE                    *\n*     AND LIMIT TO THREE REPLIES. IF REQUEST IS STILL OUTSTANDING     *\n*     THEN THE OPERATOR MAY HAVE TO REPLY 'HIGHDATE'                  *\n         TABENTRY MSG=IEFTMS4,ACTION=REPLY,TEXT='U',ECHO=YES,          X\n               MATCHLIM=3\n*=====================================================================*\n* 5.  REPLY 'U' TO UCC11 INITIALIZATION MESSAGE                       *\n         TABENTRY MSG=U11-601,ACTION=REPLY,TEXT='U',ECHO=YES\n*=====================================================================*\n* 6.  REPLY '' TO VTAM INITIALIZATION MESSAGE                         *\n         TABENTRY MSG=IST051A,ACTION=REPLY,TEXT=' '\n*=====================================================================*\n* 7.  FIND COMPLETION OF TMSINIT STARTUP                              *\n         TABENTRY MSG=+IEFTMS1,ACTION=OSCMD,TEXT='|TMS010',ECHO=LOG\n*=====================================================================*\n* 8.  INITIALIZATION OF CA-11 LOGGING                                 *\n         TABENTRY MSG=U11D-531,ACTION=REPLY,TEXT='R',ECHO=YES\n*=====================================================================*\n* 9.  INITIALIZATION OF VCSS                                          *\n         TABENTRY MSG=VCS0003W,ACTION=REPLY,TEXT='U',ECHO=YES\n         EJECT\n***********************************************************************\n*                                                                     *\n*  ----->  SHUTDOWN SECTION                                           *\n*                            KEEP TRACK OF SHUTDOWN PROGRESS AND      *\n*                            ISSUE REPLIES TO NECESSARY MESSAGES      *\n*                            (ALL MESSAGE GENERATED COMMANDS SHOULD   *\n*                             TEST IF IN SHUTDOWN MODE (%ISSHUT))     *\n*=====================================================================*\n* 1.  REPLY 'SIC' TO TCAS TERMINATION MESSAGE                         *\n         TABENTRY MSG=IKT010D,ACTION=REPLY,TEXT='SIC',ECHO=YES\n*=====================================================================*\n* 2.  REPLY 'U' TO TCAS TERMINATION MESSAGE, AND ONLY REPLY ONCE      *\n         TABENTRY MSG=IKT012D,ACTION=REPLY,TEXT='U',ECHO=YES\n*=====================================================================*\n* 3.  HANDLE TSS DURING SHUTDOWN                                      *\n         TABENTRY MSG=TSS072A,ACTION=OSCMD,TEXT='|TSS072A'\n         TABENTRY MSG=TSS102A,ACTION=OSCMD,TEXT='|TSS102A'\n*=====================================================================*\n* 4.  HANDLE JES2 DURING SHUTDOWN                                     *\n         TABENTRY MSG=$HASP099,ACTION=OSCMD,TEXT='|HASP099'\n*=====================================================================*\n*  5. HANDLE SHUTDOWN OF CA-11 DATABASE SYSTEM                        *\n         TABENTRY MSG=U11D-045,ACTION=REPLY,                           X\n               TEXT='Y',ECHO=YES,                                      X\n               TEST=((W,2,6,'VERIFY','    '))\n*=====================================================================*\n* 6.  HANDLE VARY FORCE DURING SHUTDOWN                               *\n         TABENTRY MSG=IEE800D,ACTION=OSCMD,TEXT='|IEE800D'\n*=====================================================================*\n*  7. HANDLE SHUTDOWN OF CA-7 SYSTEM (VER 3.0) PHASE I                *\n         TABENTRY MSG=CA-7.023,ACTION=OSCMD,                           X\n               TEXT='|ZCA71'\n*=====================================================================*\n*  8. HANDLE SHUTDOWN OF CA-7 SYSTEM (VER 3.0) PHASE II               *\n         TABENTRY MSG=SCM2-30,ACTION=OSCMD,                            X\n               TEXT='|ZCA72'\n         EJECT\n***********************************************************************\n*                                                                     *\n* DO NOT LEAVE THE TABEND MACRO OUT OF THIS ASSEMBLY.                 *\n*                                                                     *\n***********************************************************************\n         TABEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFIVP": {"ttr": 26377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\xbf\\x00\\xbf\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "TSSO403"}, "text": "***********************************************************************\n* THIS IS A SAMPLE AUTOMATED OPERATIONS FACILITY TABLE. IT IS USED AS *\n* PART OF THE TSSO INSTALLATION VERIFICATION PROCEDURE. IT CONSISTS   *\n* OF A SUBSET OF ALL POSSIBLE ENTRIES IN A TSSO/AOF TABLE.            *\n*                                                                     *\n* THIS AOF TABLE CAN BE USED IN CONJUNCTION WITH THE AOF/IVP,         *\n* DISTRIBUTED WITH TSSO.                                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nAOFIVP   TABSTART ID=IVPTABLE\n***********************************************************************\n* FIRST, A COUPLE OF REPLIES TO STANDARD ANNOYING MVS   MESSAGES.     *\n***********************************************************************\n*\n***********************************************************************\n* REPLY '' TO VTAM INITIALIZATION MESSAGE\n***********************************************************************\nVTAMUP   TABENTRY MSG=IST051A,ACTION=REPLY,TEXT=' '\n*\n***********************************************************************\n* REPLY 'SIC' TO TCAS TERMINATION MESSAGE\n***********************************************************************\nREPSIC   TABENTRY MSG=IKT010D,ACTION=REPLY,TEXT='SIC'\n*\n***********************************************************************\n* REPLY 'U' TO TCAS TERMINATION MESSAGE\n* AND ECHO THE REPLY OUT TO THE MVS CONSOLE. ALSO, ENSURE THAT WE ONLY\n* MAKE THE REPLY ONE TIME THROUGH THE MATCHLIM FACILITY.\n***********************************************************************\n*\nTCASDOWN TABENTRY MSG=IKT012D,ACTION=REPLY,TEXT='U',ECHO=YES,          X\n               MATCHLIM=1\n***********************************************************************\n* REPLY 'POST' TO IMS BRINGUP ON UCB MESSAGE\n***********************************************************************\n*\nIMSPOST  TABENTRY MSG=IEC804A,ACTION=REPLY,TEXT='POST'\n*\n***********************************************************************\n* THE NEXT ENTRY POINTS OUT THE HILIGHTING FEATURE. IEE704I IS THE    *\n* MESSAGE ID FOR   REPLY XX IS NOT OUTSTANDING.                       *\n***********************************************************************\nRPLYWRNG TABENTRY MSG=IEE704I,ACTION=HILIGHT\n*\n***********************************************************************\n* THE NEXT ENTRY DEMONSTRATES A POSSIBLE USE FOR THE OSCMD FEATURE.   *\n* IEE043I IS THE MESSAGE YOU GET WHEN A SYSTEM LOG DATASET IS QUEUE   *\n* TO A GIVEN OUTPUT CLASS. THE #LOGWTRR4 PROGRAM (OR CLIST) CAN BE    *\n* USED TO PROCESS THE LOG DATASET. THE XWTR PROC    CAN ALSO BE USED. *\n* YOU CAN CAUSE THIS TO OCCUR BY ISSUING THE \"W Z\" COMMAND.           *\n* PERFORM THIS ACTION AT MOST 7 TIMES, AND, EACH TIME, ECHO THE       *\n* GENERATED COMMAND OUT TO THE MVS CONSOLE.\n***********************************************************************\nLOGWTR   TABENTRY MSG=IEE043I,ACTION=OSCMD,MATCHLIM=7,ECHO=YES,        X\n               TEXT='#LOGWTRR4'\n*\n***********************************************************************\n* WHEN THE LOGWTR PROGRAM TERMINATES, MESSAGE IEF176I IS ISSUED,      *\n* INDICATING THE LOGWTR IS LOOKING FOR WORK. HAVE TSSO PURGE IT OUT.  *\n* NOTE HOW IT USES THE DDD FROM THE MESSAGE TO FIGURE OUT WHAT TO     *\n* PURGE. NOTE THAT THIS WILL WORK FOR ANY EXTERNAL WRITER.            *\n* THIS IS AN EXAMPLE OF \"WORD\" FORMATTING IN THE TEXT= PARM.          *\n* NOTE THAT THE COMMAND GENERATED IS ECHOED TO THE MVS CONSOLE\n***********************************************************************\nPURGEWTR TABENTRY MSG=IEF176I,ACTION=OSCMD,ECHO=YES,                   X\n               TEXT='P \\W    03\\'\n*\n***********************************************************************\n* THE NEXT EXAMPLE SHOWS POSITIONAL FORMATTING IN THE COMMAND TEXT.   *\n* THE $HASP104 MESSAGE IS ISSUED WHENEVER A //*MESSAGE CARD IS        *\n* ENCOUNTERED IN THE JOB STREAM. THE #RECMSG CLIST MEARLY RECORDS IN  *\n* A DATASET (USING CLIST OPENFILE/PUTFILE/CLOSFILE TECHNIQUES) THE    *\n* TEXT OF THE MESSAGE.                                                *\n***********************************************************************\nRECMSG   TABENTRY MSG=$HASP104,ACTION=OSCMD,                           X\n               TEXT='#RECMSG JOB(''\\P001,72\\'')'\n*\n***********************************************************************\n* ANOTHER EXAMPLE OF THE USE OF THE HILIGHTING FEATURE. HILIGHT THE   *\n* MESSAGE INDICATING THAT VTAM IS UP.                                 *\n***********************************************************************\n         TABENTRY MSG=IST020I,ACTION=HILIGHT\n*\n***********************************************************************\n* IN ADDITION TO  HILIGHTING THE VTAM INITIALIZATION MESSAGE, ISSUE   *\n* THE #VTAMR4 CLIST. THIS CLIST IS A OPERATOR CLIST THAT ISSUES       *\n* MVS START COMMANDS FOR VTAM DEPENDANT PROGRAM PRODUCT, LIKE NCCF    *\n* AND TSO.                                                            *\n*                                                                     *\n***********************************************************************\nSTRTVTAM TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT='#VTAMR4'\n*\n***********************************************************************\n* DSI802A IS THE NCCF MESSAGE SAYING THAT YOU CAN ISSUE A VALID NCCF  *\n* OPERATOR COMMAND. YOU DO NOT NEED TO KNOW THE MESSAGE NUMBER FOR    *\n* THIS COMMAND, BECAUSE YOU CAN REPLY TO IT USING THE REPLY COMMAND   *\n* SO WE LOWLIGHT THE MESSAGE, AND ALLOW IT TO ROLL OFF THE SCREEN.    *\n* THIS IS AN EXMAPLE OF THE LOWLIGHTING FEATURE.\n***********************************************************************\n         TABENTRY MSG=DSI802A,ACTION=LOWLIGHT\n*\n***********************************************************************\n* THIS IS AN EXAMPLE OF A SUPPRESS CONDITION. $HASP309 IS A MESSAGE   *\n* THAT JES2 ISSUES EVERY TIME AN INITIATOR GOES INACTIVE. THIS MESSAGE*\n* IS NOW SUPPRESSED.                                                  *\n***********************************************************************\n         TABENTRY MSG=$HASP309,ACTION=SUPPRESS\n***********************************************************************\n* WE WILL NOW DISPLAY SOME OF THE POWER OF THE TEST CONDITIONS. THE   *\n* FOLLOWING DEMONSTRATIONS ALL TRAP THE $HASP395 JOB ENDED MESSAGE,   *\n* HOWEVER, THE ACTION= PARAMETER IS EXECUTED ONLY IF ALL CONDITIONS   *\n* FOR THE TESTS ARE MET. FOR EXAMPLE, OUR FIRST CASE WILL ONLY        *\n* HILIGHT THE MESSAGE IF THE JOB THAT HAS ENDED IS NAMED \"PAYROLL\".   *\n* THIS TEST CASE SPECIFIES THAT (1) WORDS ARE BEING TESTED, (2), THAT\n* IT IS THE SECONDWORD WE ARE INTERESTED IN, (3), WE ARE INTERESTED IN\n* THE FIRST SEVEN CHARACTERS OF THAT WORD, (4), WE WISH TO MATCH THE\n* STRING 'PAYROLL', AND      (5), WE WILL USE FOUR BLANKS AS THE\n* SEPARATOR CHARACTORS WHEN DEFINING A WORD.\n* NOTE THAT THE DOUBLE PARENTHESIS ARE REQUIRED.\n***********************************************************************\n         TABENTRY  MSG=$HASP395,ACTION=HILIGHT,                        X\n               TEST=((W,2,7,'PAYROLL','    '))\n*\n***********************************************************************\n* THE NEXT ENTRY IS AN EXAMPLE OF A TEST CONDITION BASED ON SUBSTRING,*\n* OR COLUMNS. THE MESSAGE WILL THE JES2 $HAS648 MESSAGE, WHICH IS     *\n* THE RESPONSE TO A $DU,STA. THIS ENTRY WILL SUPPRESS ALL LINES FROM  *\n* THE JES2 RESPONSE THAT ARE SNA LINES (COLS 20 THROUGH 22 = 'SNA'    *\n*                                                                     *\n***********************************************************************\n         TABENTRY  MSG=$HASP628,ACTION=SUPPRESS,                       X\n               TEST=((S,20,3,'SNA'))\n*\n***********************************************************************\n* THE NEXT ENTRY IS AN EXAMPLE OF A LOGICAL AND CONDITION BETWEEN TEST*\n* CASES. BOTH CRITERIA MUST BE SATISIFED FOR THE TESTS TO PASS.       *\n* THE TEST CASE WILL AN MVS/JES2 JOB AWAITING EXECUTION IN A CERTAIN  *\n* JOB CLASS. THIS ENTRY WILL TAKE A $DN COMMAND, AND ISSUE AN OSCMD   *\n* TO RAISE THE PRIORITY OF JOBS AWAITING EXECUTION IN CLASS 9 TO \"15\" *\n* (YES, I REALIZE THIS DOESNT MAKE MUCH SENSE, BUT ITS GOOD FOR DEMO  *\n* PURPOSES).\n* NOTE THAT THE THIRD WORD IS CHECKED FOR \"AWAITING\" AND THE FOURTH   *\n* WORD IS CHECK FOR EXECUTION, AND THE FIFTH WORD IS THE JOB CLASS.   *\n* ALSO NOTE HOW THE SECOND WORD OF THE MESSAGE (THE JOB NAME) IS USED *\n* IN FORMING THE TEXT= OPERAND. OSCMDT WILL BE USED SO THE COMMAND    *\n* DOESNT ACTUALLY GET ISSUED.\n* NOTE ALSO THAT YOU DONT NEED TO SPECIFY FOUR BLANKS- ONE IS         *\n* SUFFICIENT WHEN GENERATING TEST CASES.\n***********************************************************************\n         TABENTRY MSG=$HASP608,ACTION=OSCMDT,                          X\n               TEXT='$T''\\W    02\\'',P=15',                            X\n               TEST=((W,3,8,'AWAITING','  '),(W,4,9,'EXECUTION','    ')X\n               ,(W,5,1,'9',' '))\n*\n***********************************************************************\n* THE NEXT CASE IS A GENERIC MESSAGE. THIS MESSAGE IS MATCHED BY      *\n* EVERY SINGLE WTO OR WTOR THAT COME ACROSS, EXCEPT IT MUST STILL     *\n* PASS THE TEST CONDITIONS. THIS EXAMPLE I WILL GIVE HILIGHTS ALL JES *\n* MESSAGES CONCERNING JOB ENDOFDAY.THESE MESSAGES ALL START WITH      *\n* $HASP (WORD 1) AND CONTAIN THE JOBNAME IN WORD 2.                   *\n*                                                                     *\n***********************************************************************\n         TABENTRY MSG=*,ACTION=HILIGHT,                                X\n               TEST=((W,1,5,'$HASP',' '),(W,2,8,'ENDOFDAY',' '))\n*\n***********************************************************************\n* THE NEXT CASE IS AN EXAMPLE OF THE ACTION=POST FACILITY OF THE TSSO *\n* AOF TABLES. THE BELOW MESSAGE CAN BE USED TO POST A CLIST WAITING   *\n* FOR A GIVEN CTC TO BE VARIED OFFLINE.                               *\n*                                                                     *\n***********************************************************************\nCTCOFF   TABENTRY MSG=IEF281I,ACTION=POST\n*\n*\n***********************************************************************\n* THE NEXT CASE IS AN EXAMPLE OF THE ACTION=POST FACILITY OF THE TSSO *\n* AOF TABLES. THE BELOW MESSAGE CAN BE USED TO POST A CLIST WAITING   *\n* FOR A SPECIFIC CTC TO BE VARIED OFFLINE.                            *\n*                                                                     *\n***********************************************************************\nCTC980OF TABENTRY MSG=IEF281I,ACTION=POST,TEST=((W,2,3,'980',' '))\n*\n***********************************************************************\n* THIS TABEND MACRO DEFINES THE END OF THE AUTOMATED OPERATIONS       *\n* FACILITY TABLE.                                                     *\n*                                                                     *\n* DO NOT LEAVE THE TABEND MACRO OUT OF THIS ASSEMBLY.                 *\n*                                                                     *\n***********************************************************************\n         TABEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AOFSEAG": {"ttr": 26625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01+\\x01+\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 299, "newlines": 299, "modlines": 0, "user": "TSSO403"}, "text": "***********************************************************************\n*\n*        PDSDOC *SPRECHER AUTOMATION TABLE.29OCT92. USES MPF SUPPORT  *\n*\n***********************************************************************\n*\nAOFSEAG  TABSTART ID=AOFSEAG\n*\n***********************************************************************\n* SHOW STOPPERS. NONPROCESS ENTRIES FOR COMMON MESSAGES WHICH ARE\n* NOT SUPPRESSED BY STANDARD MPF PROCESSING.\n***********************************************************************\n*\n         TABENTRY MSG=*,ACTION=NONE,TEST=((S,001,01,'-')) IEFACTRT\n         TABENTRY MSG=SSCRI001,ACTION=NONE\n         TABENTRY MSG=SSCRW005,ACTION=NONE\n*\n***********************************************************************\n* JES2 JOB ENDED MESSAGE. MOST ARE SUPPRESSED, BUT WE LOOK FOR\n* CERTAIN JOBNAMES. THE TESTS ARE PUT AT THE BEGINNING OF THE TABLE\n* TO SAVE CPU TIME PROCESSING A FREQUENT MESSAGE.\n* 29OCT92 CART1 TELL ANYONE WAITING THAT HSM ENDED\n***********************************************************************\n*\nHSMEND   TABENTRY MSG=$HASP395,ACTION=POST,TEST=((W,2,4,'HSM ','    '))\n         TABENTRY MSG=$HASP395,ACTION=SUPPRESS\n*\n***********************************************************************\n* PROCESS VTAM MESSAGES\n* 14SEP92 CART1 NOT CHANGED MUCH, NEEDS CAREFUL STUDY\n* 15SEP92 CART1 SUPPRESS 'NORMAL' MULTITERM FAILURE TYPE MESSAGES\n***********************************************************************\n*\n*        THESE ENTRIES REQUIRE MLWTO SUPPORT\n*\n*\n* 1) UNCONDITIONAL BIND REJECT\n*\n         TABENTRY MSG=IST663I,ACTION=OSCMD,                            X\n               TEST=((W,02,04,'INIT',' '),(W,07,08,'080A0000','=. '),  X\n               (L,2)),                                                 X\n               TEXT='V NET,INACT,ID=\\S028,08\\,F'\n*\n* 2) MESSAGES GENERATED AT MULTITERM FAILURE -\n*             WHICH OCCURS MUCH TOO FREQUENTLY, BLUELINE.\n*\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS, NO SESSION              X\n               TEST=((W,02,05,'CINIT',' '),(W,07,04,'8005','=. '))\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS, NO ROUTING INFO.        X\n               TEST=((W,02,04,'BIND',' '),(W,07,04,'8004','=. '))\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS, SESSION NOT ACTIVE      X\n               TEST=((W,02,04,'INIT',' '),(W,07,04,'0857','=. '))\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS,  BIND POSTPONE          X\n               TEST=((W,02,04,'BIND',' '),(W,07,04,'0845','=. '))\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS,  RESOURCE UNKNOWN       X\n               TEST=((W,02,04,'INIT',' '),(W,07,04,'0806','=. '))\n         TABENTRY MSG=IST663I,ACTION=SUPPRESS,  LU NOT ENABLED         X\n               TEST=((W,03,06,'RESUME',' '),(W,07,04,'083A','=. '))\n*\n* END) STOP PROCESSING ANY OTHER IST663I MAJOR OR MINOR WQE\n*\n         TABENTRY MSG=IST663I,ACTION=NONE\n*\n         TABENTRY MSG=IST197I,ACTION=SUPPRESS\n         TABENTRY MSG=IST462I,ACTION=SUPPRESS\n         TABENTRY MSG=IST530I,ACTION=SUPPRESS\n         TABENTRY MSG=IST890I,ACTION=SUPPRESS\n         TABENTRY MSG=IST400I,ACTION=SUPPRESS,                         X\n               TEST=((S,044,04,'MULT'))\n         TABENTRY MSG=IST400I,ACTION=SUPPRESS,                         X\n               TEST=((S,044,03,'RMT'))\n         TABENTRY MSG=IST804I,ACTION=SUPPRESS,                         X\n               TEST=((W,09,08,'MULTTERM',' '))\n         TABENTRY MSG=IST804I,ACTION=SUPPRESS,                         X\n               TEST=((W,09,07,'JES328X',' '))\n         TABENTRY MSG=IST805I,ACTION=SUPPRESS,                         X\n               TEST=((S,033,04,'MULT'))\n         TABENTRY MSG=IST805I,ACTION=SUPPRESS,                         X\n               TEST=((S,033,03,'RMT'))\n         TABENTRY MSG=IST962I,ACTION=SUPPRESS,                         X\n               TEST=((W,08,08,'SWITCHED',' '),                         X\n               (W,10,04,'SE3B',' '))\n*\n***********************************************************************\n* REPLY 'U' TO EXPIRY DATE PROTECTION. LET RACF HANDLE IT.\n***********************************************************************\n*\n         TABENTRY MSG=IEC507D,ACTION=REPLY,TEXT='U'\n*\n***********************************************************************\n* ALWAYS UNLOAD FILE PROTECTED TAPES\n***********************************************************************\n         TABENTRY MSG=IEC510D,ACTION=REPLY,TEXT='F'\n*\n***********************************************************************\n* HILIGHT CERTAIN IO ERROR MESSAGES\n***********************************************************************\n*\n         TABENTRY MSG=IEC512I,ACTION=HILIGHT\n         TABENTRY MSG=IOS000I,ACTION=HILIGHT,                          X\n               TEST=((S,009,02,'FA'))\n         TABENTRY MSG=IOS000I,ACTION=HILIGHT,                          X\n               TEST=((S,009,02,'BC'))\n         TABENTRY MSG=IEA480E,ACTION=LOWLIGHT,                         X\n               TEST=((W,09,08,'REPEATED',',   ')) CACHE ALERT\n*\n***********************************************************************\n* SUPPRESS CERTAIN MESSAGES WHICH CANNOT BE SUPPRESSED WITH MPF\n***********************************************************************\n*\n         TABENTRY MSG=$HASP000,ACTION=SUPPRESS\n         TABENTRY MSG=IEA989I,ACTION=SUPPRESS\n         TABENTRY MSG=IEE301I,ACTION=SUPPRESS\n         TABENTRY MSG=IEE600I,ACTION=SUPPRESS\n         TABENTRY MSG=IEE704I,ACTION=SUPPRESS\n         TABENTRY MSG=IEE727I,ACTION=SUPPRESS\n         TABENTRY MSG=IEF196I,ACTION=SUPPRESS\n         TABENTRY MSG=IKJ56644,ACTION=SUPPRESS\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,04,'+CBT'))\n*\n***********************************************************************\n* REPLY 'WAIT' TO 'DEVICE NAME, WAIT OR CANCEL'\n* 04SEP92 CART1 ADDED 'CANCEL' IF 'WAIT' IS NOT AN OPTION.\n***********************************************************************\n*\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,4,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,5,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,6,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,7,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='CANCEL'\n*\n***********************************************************************\n* REPLY 'NOHOLD' TO 'HOLD OR NOHOLD'\n***********************************************************************\n*\n         TABENTRY MSG=IEF433D,ACTION=REPLY,TEXT='NOHOLD'\n*\n***********************************************************************\n* REPLY 'REFRESH' TO LLA UNKNOWN OPTION.\n* 06APR92 CART1 ADDED.\n***********************************************************************\n*\n         TABENTRY MSG=CSV223A,ACTION=REPLY,TEXT='REFRESH'\n*\n***********************************************************************\n* PROCESS SYSTEM DUMP MESSAGES\n***********************************************************************\n*\nCLRDUMP  TABENTRY MSG=IEA994A,ACTION=OSCMD,                            X\n               TEXT='DD CLEAR,DSN=(01-02)'\n         TABENTRY MSG=IEA994A,ACTION=LOWLIGHT\n*\n*\n***********************************************************************\n* PROCESS JES2 MESSAGES\n***********************************************************************\n*\n         TABENTRY MSG=$HASP454,ACTION=REPLY,TEXT='Y'  BYPASS CHKPT LOCK\n*\n* PROCESS JES2 MESSAGES RELATED TO REMOTES\n*\n         TABENTRY MSG=$HASP200,ACTION=SUPPRESS,                        X\n               TEST=((W,2,3,'RMT',' '))\n         TABENTRY MSG=$HASP150,ACTION=SUPPRESS,                        X\n               TEST=((W,5,1,'R',' '))\nRMTGO    TABENTRY MSG=$HASP190,ACTION=OSCMD,ECHO=YES,                  X\n               TEST=((S,027,01,'R')),                                  X\n               TEXT='.RMTGO \\W    05\\'\n         TABENTRY MSG=$HASP190,ACTION=SUPPRESS,                        X\n               TEST=((S,027,01,'R'))\n*\n* PROCESS JES328X MESSAGES RELATED TO REMOTES\n*\n         TABENTRY MSG=+JSX092,ACTION=OSCMD,ECHO=YES,                   X\n               TEST=((S,042,04,'0802')),                               X\n               TEXT='.NOPAPER \\S025,02\\'\nJSXOK    TABENTRY MSG=+JSX255,ACTION=POST     * OK *\n         TABENTRY MSG=+JSX092,ACTION=NONE\n         TABENTRY MSG=+JSX255,ACTION=NONE\n*\n* SUPPRESS SOME FPAC GENERATED MESSAGES.\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,06,'+START'),(S,008,04,'FPAC'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,06,'+FPAC:'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,09,'+END-FPAC'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,20,'+                   '))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,10,'+***      '))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,01,'+'),                                   X\n               (W,02,06,'ERRORS',' '),(W,03,08,'DETECTED',' '))\n*\n* SUPPRESS SOME TSSO GENERATED MESSAGES.\n*\n         TABENTRY MSG=IDC0550I,ACTION=SUPPRESS     TSO DELETE (CLISTS)\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,05,'# OK '))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,06,'READY '))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,04,'END '))\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,01,'+'),(S,018,11,' ) PRINTING'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,01,'+'),(S,018,14,' ) WAITING FOR'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,01,'+'),(S,036,14,' INTERVENTION '))\n*\n* SUPPRESS SOME OPC/A GENERATED MESSAGES.\n*\n         TABENTRY MSG=CSYE036I,ACTION=SUPPRESS,                        X\n               TEST=((W,09,04,'X002',' ()'))\n*\n***********************************************************************\n* PROCESS DF/HSM MESSAGES\n* 10JUL91 CART1 SUPPRESS ALL HSM INFORMATION MESSAGES\n***********************************************************************\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((S,001,01,'ARC'),(S,008,01,'I'))\n*\n***********************************************************************\n* REPLY 'Y' TO HSM TAPE QUERY\n* 01JUL91 CART1 SUPPRESS RECALL RESPONSE AT OP. REQUEST\n* 21OCT92 CART1 FOR RECALLS CHECK IF WE JUST USED THE TAPE\n***********************************************************************\n*\n         TABENTRY MSG=ARC0313A,ACTION=OSCMD,                           X\n               TEXT='.HSMTAPE \\W    04\\'\n         TABENTRY MSG=ARC0314A,ACTION=REPLY,TEXT='Y'\n*        TABENTRY MSG=ARC0366A,ACTION=REPLY,TEXT='Y'\n*\n***********************************************************************\n* START DFHSM CDS BACKUP WHEN CONTROL DATASETS FULL THRESHOLD REACHED\n* 06APR92 CART1 SUPPRESS MESSAGE AFTER PROCESSING\n***********************************************************************\n*\nARC0909  TABENTRY MSG=ARC0909E,ACTION=OSCMD,                           X\n               TEXT='F HSM,BACKVOL CDS'\n         TABENTRY MSG=ARC0909E,ACTION=SUPPRESS\n*\n***********************************************************************\n* WHEN THE LOGWTR PROGRAM TERMINATES, MESSAGE IEF176I IS ISSUED,      *\n* INDICATING THE LOGWTR IS LOOKING FOR WORK. HAVE TSSO PURGE IT OUT.  *\n* NOTE HOW IT USES THE DDD FROM THE MESSAGE TO FIGURE OUT WHAT TO     *\n* PURGE. NOTE THAT THIS WILL WORK FOR ANY EXTERNAL WRITER.            *\n* THIS IS AN EXAMPLE OF \"WORD\" FORMATTING IN THE TEXT= PARM.          *\n* NOTE THAT THE COMMAND GENERATED IS ECHOED TO THE MVS CONSOLE\n***********************************************************************\n         TABENTRY MSG=IEF176I,ACTION=OSCMD,ECHO=YES,                   X\n               TEXT='P \\W    03\\'\n*\n*\n***********************************************************************\n* THE NEXT CASE IS A GENERIC MESSAGE. THIS MESSAGE IS MATCHED BY      *\n* EVERY SINGLE WTO OR WTOR THAT COME ACROSS, EXCEPT IT MUST STILL     *\n* PASS THE TEST CONDITIONS. THIS EXAMPLE I WILL GIVE HILIGHTS ALL JES *\n* MESSAGES CONCERNING JOB ENDOFDAY.THESE MESSAGES ALL START WITH      *\n* $HASP (WORD 1) AND CONTAIN THE JOBNAME IN WORD 2.                   *\n*                                                                     *\n***********************************************************************\n         TABENTRY MSG=*,ACTION=HILIGHT,                                X\n               TEST=((W,1,5,'$HASP',' '),(W,2,8,'ENDOFDAY',' '))\n*\n***********************************************************************\n* USE TSSO MESSAGE SUPPRESSION INSTEAD OF MPF FOR CICS WTL'S\n* 14SEP92 CART1 NOT CHANGED MUCH, NEEDS CAREFUL STUDY\n***********************************************************************\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,TEST=((S,001,09,'+DFH0970I'),  X\n               (W,05,07,'TZ88881',',   '))\n*\n***********************************************************************\n* USE TSSO MESSAGE SUPPRESSION INSTEAD OF MPF FOR USER WTL'S\n***********************************************************************\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,TEST=((S,001,01,'+'),          X\n               (S,002,04,'TMON'),(S,011,01,'I')) TMON INFORMATION\n         TABENTRY MSG=*,ACTION=SUPPRESS,TEST=((S,001,05,'+DASE'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,TEST=((S,001,07,'+KFS39I'))\n         TABENTRY MSG=*,ACTION=SUPPRESS,TEST=((S,001,02,'+*'))\n*\n* SUPPRESS SCMOD GENERATED MESSAGES.\n*\n         TABENTRY MSG=*,ACTION=SUPPRESS,                               X\n               TEST=((W,01,01,'+',' '),(W,05,05,'SCMOD',' '))\n*\n*\n         TABEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APFLIB": {"ttr": 26631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x172\\x0f\\x01\\x172o\\x08E\\x12n\\x12n\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-11-16T00:00:00", "modifydate": "2017-11-22T08:45:19", "lines": 4718, "newlines": 4718, "modlines": 0, "user": "JOARMC"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "ASMALL": {"ttr": 28675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x00\\x97&\\x9f\\x01\\x06$\\x9f\\t\\x06\\x00\\x82\\x00\\x80\\x00\\r\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2006-09-06T09:06:31", "lines": 130, "newlines": 128, "modlines": 13, "user": "SALBERT"}, "text": "//TSSOALL JOB (U32048,DCSG),GUY,CLASS=A,MSGCLASS=T,NOTIFY=SALBERT\n//*********************************************************************\n//* THIS IS THE JCL STREAM NEEDED TO ASSEMBLE AND LINK ALL THE LOAD   *\n//* MODULES THAT COMPRISE THE TSSO SUBSYSTEM. THIS PROC IS SET TO     *\n//* ASSEMBLE USING ASSEMBLER H. IT IS NOT POSSIBLE TO ASSEMBLE TSSO   *\n//* AS DISTRIBUTED USING ASSEMBLER F BECAUSE IT DOES NOT SUPPORT THE  *\n//* BATCH OPTION. TO ASSEMBLE USING ASSEMBLER F, THE LINKAGE EDITOR   *\n//* CONTROL STATEMENTS THAT EXIST AT THE END OF EACH SOURCE MODULE    *\n//* MUST BE MOVED, AND LINKAGE EDITOR CONTROL CARDS MUST BE ADDED TO  *\n//* PROPERLY ASSEMBLE TSSO.                                           *\n//* NOTE: THE EXPECTED CONDITION CODE FOR ALL STEPS IS ZERO, EXCEPT   *\n//* FOR THE ASSEMBLY OF THE REPLYLOA MODULE, WHICH WILL YIELD A COND  *\n//* CODE OF FOUR. THIS IS NOT A CONCERN.                              *\n//*                                                                   *\n//*********************************************************************\n//ASMTSSO PROC DSNPRFX='SFTB.TSSO43',MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=IEV90,REGION=3500K,\n//    PARM=(LOAD,NODECK,'XREF(SHORT)','MSGLEVEL=0',TERM,BATCH,&RENT)\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&LOADSET,DISP=(MOD,PASS,DELETE),UNIT=VIO,\n//            SPACE=(3520,(40,40),,,ROUND),DCB=BLKSIZE=400\n//SYSLIB   DD DSN=&DSNPRFX..ASM,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=&DSNPRFX..ASM(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=2000K,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=&DSNPRFX..LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//TSSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//TSSORATH EXEC ASMTSSO,MEMBER=TSSORATH,RENT=RENT /*RACF FACILITY CLASS\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=RENT\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//LIONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMA9ALL": {"ttr": 28678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\t\\x00\\x99&\\x7f\\x01\\x07\\x07\\x0f\\x06$\\x00x\\x00w\\x00\\x0b\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "2007-03-11T06:24:09", "lines": 120, "newlines": 119, "modlines": 11, "user": "SBGOLOB"}, "text": "//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*      PDSDOC *ASSEMBLE TSSO (ALL MODULES)..........................*\n//*\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.TSSOZ18.INSTALL\n//         DD DISP=SHR,DSN=SBGOLOB.R18.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R18.MODGEN\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=SBGOLOB.TSSOZ18.INSTALL(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=SYSALLDA,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SBGOLOB.TSSOZ18.LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//TSSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//TSSORATH EXEC ASMTSSO,MEMBER=TSSORATH,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//LIONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMA9ONE": {"ttr": 28681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x04\\x00\\x99&\\x7f\\x01 \\x13\\x8f\\x15\\x10\\x00x\\x00w\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "2020-05-17T15:10:04", "lines": 120, "newlines": 119, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*      PDSDOC *ASSEMBLE TSSO (ALL MODULES)..........................*\n//*\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.CBT499.FILE404\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=SBGOLOB.CBT499.FILE404(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=SYSALLDA,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SBGOLOB.TSSO404.LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//*CECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//*SSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//*SSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//*SSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//*SSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//*SSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//*SSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//*SSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//*SSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//*SSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//*SSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//*SSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//*SSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//*SSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//*SSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//*SSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//*SSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//*SSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//*SSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//*SSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//*SCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//*PCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//*SCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//*SWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//*SPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//*SWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//*SSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//*ISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//*LTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*SSORATH EXEC ASMTSSO,MEMBER=TSSORATH,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//*EPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//*IONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//*EPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//*ACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//*PCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//*PMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//*ALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//*OLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//*F       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//*ULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMA9ONN": {"ttr": 28684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00&\\x00\\x99&\\x7f\\x01\\x10\\x01\\x8f @\\x00x\\x00w\\x003\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "2010-01-18T20:40:26", "lines": 120, "newlines": 119, "modlines": 51, "user": "SBGOLOB"}, "text": "//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*      PDSDOC *ASSEMBLE TSSO (ALL MODULES)..........................*\n//*\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.TSSOZ18.INSTALL\n//         DD DISP=SHR,DSN=SBGOLOB.R18.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R18.MODGEN\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=SBGOLOB.CBT479.FILE404(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=SYSALLDA,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SBGOLOB.TSSOZ18.LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//*CECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//*SSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//*SSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//*SSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//*SSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//*SSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//*SSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//*SSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//*SSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//*SSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//*SSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//*SSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//*SSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//*SSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//*SSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//*SSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//*SSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//*SSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//*SSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//*SSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//*SCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//*PCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//*SCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//*SWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//*SASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//*SPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//*SWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//*SSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//*ISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//*LTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*SSORATH EXEC ASMTSSO,MEMBER=TSSORATH,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//*EPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//*IONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//*EPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//*ACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//*PCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//*PMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//*ALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//*OLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//*F       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//*ULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMONE": {"ttr": 28687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x005\\x00\\x97&\\x9f\\x01\\x022/\\t\\x03\\x00\\x83\\x00\\x84\\x00\\x83\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2002-11-18T09:03:35", "lines": 131, "newlines": 132, "modlines": 131, "user": "EDJXADM"}, "text": "//TSSOONE JOB (U32048,DCSG),GUY,CLASS=A,MSGCLASS=T,NOTIFY=&SYSUID\n//*********************************************************************\n//* THIS IS THE JCL STREAM NEEDED TO ASSEMBLE AND LINK ALL THE LOAD   *\n//* MODULES THAT COMPRISE THE TSSO SUBSYSTEM. THIS PROC IS SET TO     *\n//* ASSEMBLE USING ASSEMBLER H. IT IS NOT POSSIBLE TO ASSEMBLE TSSO   *\n//* AS DISTRIBUTED USING ASSEMBLER F BECAUSE IT DOES NOT SUPPORT THE  *\n//* BATCH OPTION. TO ASSEMBLE USING ASSEMBLER F, THE LINKAGE EDITOR   *\n//* CONTROL STATEMENTS THAT EXIST AT THE END OF EACH SOURCE MODULE    *\n//* MUST BE MOVED, AND LINKAGE EDITOR CONTROL CARDS MUST BE ADDED TO  *\n//* PROPERLY ASSEMBLE TSSO.                                           *\n//* NOTE: THE EXPECTED CONDITION CODE FOR ALL STEPS IS ZERO, EXCEPT   *\n//* FOR THE ASSEMBLY OF THE REPLYLOA MODULE, WHICH WILL YIELD A COND  *\n//* CODE OF FOUR. THIS IS NOT A CONCERN.                              *\n//*                                                                   *\n//*********************************************************************\n//ASMTSSO PROC DSNPRFX='TSSO.VERS43',MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=3500K,\n//    PARM=(OBJECT,NODECK,'XREF(SHORT)',TERM,BATCH,&RENT)\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&LOADSET,DISP=(MOD,PASS,DELETE),UNIT=VIO,\n//            SPACE=(3520,(40,40),,,ROUND),DCB=BLKSIZE=400\n//SYSLIB   DD DSN=&DSNPRFX..ASM,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=&DSNPRFX..ASM(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=2000K,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=&DSNPRFX..LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//\n//\n//\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=RENT\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMTAB": {"ttr": 28931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00<\\x00<\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "TSSO403"}, "text": "        PROC 1 &TABNAME TSSOLIB('TSSO.VERS43') RELOAD\n        /*************************************************************/\n        /* THIS CLIST WILL ASSEMBLE A TSSO AOF TABLE, AND INSTALL IT */\n        /* INTO TSSO.VERS43.LOAD.                                    */\n        /*************************************************************/\n        CONTROL NOMSG\n        FREE FI(SYSIN SYSPRINT SYSTERM SYSLIB SYSPUNCH SYSUT1 SYSLIN SYSIN)\n        CONTROL MSG\n        ALLOC FI(SYSIN) DSN('&TSSOLIB..AOFTABS(&TABNAME)') REUSE SHR\n        ALLOC FI(SYSPRINT) DA(*)\n        ALLOC FI(SYSTERM) DA(*)\n        ALLOC FI(SYSLIB) DSN('&TSSOLIB..ASM' 'SYS1.AMODGEN' +\n              'SYS1.MACLIB') SHR\n        ALLOC FI(SYSPUNCH) DUMMY\n        ALLOC FI(SYSUT1) NEW SPACE(1 1) CYL DELETE\n        ALLOC FI(SYSLIN) NEW SPACE(1 1) CYL DELETE\n        CALL  'SYS1.LINKLIB(IEV90)' +\n         'RENT,NOALIGN,NOLIST'\n        SET RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n        DO\n           OSWTO ASSEMBLER H FAILED - RETURN CODE &RC\n           OSWTO LOAD MODULE NOT GENERATED\n           EXIT\n        END\n        ELSE +\n        DO\n           OSWTO ASMT001I ASSEMBLY FOR TABLE &TABNAME SUCCESSFULL\n        END\n        CONTROL NOMSG\n        FREE FI(SYSUT1 SYSLMOD)\n        CONTROL MSG\n        ALLOC FI(SYSUT1) NEW SPACE(1 1) CYL DELETE\n        ALLOC FI(SYSLMOD) DSN('&TSSOLIB..LOAD(&TABNAME)') SHR\n        CALL 'SYS1.LINKLIB(IEWL)' 'RENT,AC'\n        SET RC = &LASTCC\n        FREE FI(SYSIN SYSPRINT SYSTERM SYSLIB SYSPUNCH SYSUT1 SYSLIN)\n        FREE FI(SYSLMOD)\n        IF &RC \u00ac= 0 THEN +\n        DO\n           OSWTO ERROR IN LINKEDIT - RETURN CODE &RC\n           OSWTO POSSIBLE PROBLEM WITH AOF TABLE &TABNAME\n           EXIT\n        END\n        ELSE +\n        DO\n           OSWTO ASMT002I LINK EDIT FOR TABLE &TABNAME SUCCESSFULL\n        END\n        IF &RELOAD = RELOAD THEN +\n        DO\n           OSWTO ASMT003I RELOAD COMMAND BEING ISSUED.\n           PDS  '&TSSOLIB..LOAD' COPY &TABNAME  'SYS1.TSSOLOAD' SHR REP\n           SET RC = &LASTCC\n           IF &RC = 0 THEN +\n           DO\n             OSCMD #.RELOAD &TABNAME\n             OSCMD #.Q T\n           END\n        END\n        EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMTABLE": {"ttr": 28933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00%\\x00%\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "TSSO403"}, "text": "//TSSOTBL JOB (U32048,17F),'GUY ALBERTELLI',CLASS=E,MSGCLASS=G,\n// NOTIFY=SALBERT,COND=(0,NE)\n//***************************************************************\n//* THIS JCL IS USED TO ASSEMBLE A TSSO AUTOMATED OPERATIONS    *\n//* FACILITY TABLE.                                             *\n//***************************************************************\n//ASM EXEC ASMHCL,REGION=3000K,\n//   PARM.ASM='OBJECT,NODECK,RENT,NOALIGN,SYSPARM(WEEK)',\n//   PARM.LKED='LET,LIST,XREF,RENT,AC'\n//*****************************************************************\n//* I M P O R T A N T              I M P O R T A N T              *\n//*                                                               *\n//* THE ASSEMBLER PARAMETER \"NOALIGN\" MUST BE SPECIFIED WHEN      *\n//* ASSEMBLING A TSSO AOF TABLE. THE INTERNAL STRUCTURE OF THE    *\n//* TSSO TABLE DEPENDS ON THE ASSEMBLER NOT ALIGNING VARIABLES!   *\n//* I M P O R T A N T              I M P O R T A N T              *\n//*                                                               *\n//*****************************************************************\n//* \"RENT\" IS REQUIRED BECAUSE TSSO WILL BE PERFORMING A LOAD TO  *\n//* GLOBAL ON THE TSSO/AOF TABLE.                                 *\n//*****************************************************************\n//ASM.SYSLIB DD DSN=SFTB.TSSO43.ASM,DISP=SHR,DCB=BUFNO=10\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DSN=SFTB.TSSO43.ASM(AOFBATH),DISP=SHR\n//LKED.SYSLMOD DD DSN=SFTB.TSSO43.LOAD(AOFBATH),DISP=SHR\n//LKED.SYSPRINT DD SYSOUT=*\n//*\n//*   COMPILE THE WEEKEND TABLE\n//*\n//ASM EXEC ASMHCL,REGION=3000K,\n//   PARM.ASM='OBJECT,NODECK,RENT,NOALIGN,SYSPARM(WEEKEND)',\n//   PARM.LKED='LET,LIST,XREF,RENT,AC'\n//ASM.SYSLIB DD DSN=SFTB.TSSO43.ASM,DISP=SHR,DCB=BUFNO=10\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DSN=SFTB.TSSO43.ASM(AOFBATH),DISP=SHR\n//LKED.SYSLMOD DD DSN=SFTB.TSSO43.LOAD(AOFBATH1),DISP=SHR\n//LKED.SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMTSSO": {"ttr": 28935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00t\\x00t\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "TSSO403"}, "text": "//ASMTSSO JOB (3225,P136,99,99,9998),'ASSEMBLE TSSO',CLASS=L,\n// MSGCLASS=F,NOTIFY=TSO67\n/*XEQ N13\n/*ROUTE PRINT PYSPROD\n//*********************************************************************\n//* THIS IS THE JCL STREAM NEEDED TO ASSEMBLE AND LINK ALL THE LOAD   *\n//* MODULES THAT COMPRISE THE TSSO SUBSYSTEM. THIS PROC IS SET TO     *\n//* ASSEMBLE USING ASSEMBLER H. IT IS NOT POSSIBLE TO ASSEMBLE TSSO   *\n//* AS DISTRIBUTED USING ASSEMBLER F BECAUSE IT DOES NOT SUPPORT THE  *\n//* BATCH OPTION. TO ASSEMBLE USING ASSEMBLER F, THE LINKAGE EDITOR   *\n//* CONTROL STATEMENTS THAT EXIST AT THE END OF EACH SOURCE MODULE    *\n//* MUST BE MOVED, AND LINKAGE EDITOR CONTROL CARDS MUST BE ADDED TO  *\n//* PROPERLY ASSEMBLE TSSO.                                           *\n//* NOTE: THE EXPECTED CONDITION CODE FOR ALL STEPS IS ZERO, EXCEPT   *\n//* FOR THE ASSEMBLY OF THE REPLYLOA MODULE, WHICH WILL YIELD A COND  *\n//* CODE OF FOUR. THIS IS NOT A CONCERN.                              *\n//*                                                                   *\n//* NOTE THAT UNLIKE THE ASMALL PROC, THIS PROCEDURE ONLY ASSEMBLES   *\n//* THOSE MODULES THAT REQUIRE REASSEMBLY AFTER THE TSSOCVT OR        *\n//* TSSODATD DSECTS ARE ALTERED.                                      *\n//*                                                                   *\n//*                                                                   *\n//*********************************************************************\n//ASMTSSO PROC DSNPRFX='TSSO.VERS43',MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=IEV90,REGION=3500K,\n//    PARM=(LOAD,NODECK,'XREF(SHORT)','MSGLEVEL=0',TERM,BATCH,&RENT)\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&LOADSET,DISP=(MOD,PASS,DELETE),UNIT=VIO,\n//            SPACE=(3520,(40,40),,,ROUND),DCB=BLKSIZE=400\n//SYSLIB   DD DSN=&DSNPRFX..ASM,DISP=SHR,DCB=(BLKSIZE=9600)\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSPRINT DD DUMMY\n//SYSIN    DD DSN=&DSNPRFX..ASM(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=2000K,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=&DSNPRFX..LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=RENT\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BSCAN": {"ttr": 28938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x006\\x006\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE 'LOCATE LINE NUMBER IN MULTI-LINE WTO'\n***********************************************************************\n*                                                                     *\n* BINARY SEARCH ROUTINE - GENERALIZED                                 *\n*                                                                     *\n* THIS ROUTINE WILL SCAN THE INDEX TABLE BUILD WHEN THE AOF TABLE     *\n* WAS LOADED. THE INDEX TABLE HAS THE MESSAGE IDS IN ALPHABETICAL     *\n* ORDER (STD COLLATING SEQ.). THIS ALLOWS THE TABLE TO BE SEARCHED    *\n* VIA THE BINARY SEARCH METHOD.                                       *\n*                                                                     *\n* INPUT                                                               *\n*   R2  --  ADDRESS OF COMPARE INSTRUCTION                            *\n*   R4  --  START ADDRESS OF TABLE                                    *\n*   R5  --  END ADDRESS OF TABLE                                      *\n*   R6  --  LENGTH OF TABLE ENTRY (MUST BE POWER OF 2)                *\n*   R14 --  RETURN ADDRESS                                            *\n* DESTROYS                                                            *\n*   R1  --  WORK                                                      *\n*   R7  --  MOVING POINTER FOR COMPARE (SHOULD BE USED IN CMP INSTR)  *\n* RETURNS                                                             *\n*   +0  --  NOT FOUND                                                 *\n*             R7 POINTS TO ITEM TO INSERT AFTER                       *\n*   +4  --  FOUND                                                     *\n*             R7 POINTS TO MATCH                                      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nBSCAN    DS    0H\n         LNR   R1,R6                    GET -LENGTH FOR ANDING\nBSLOOP   LR    R7,R5                    GET END ADDRESS\n         SR    R7,R4                    GET DIFFERENCE\n         SRL   R7,1                     DIVIDE BY 2\n         NR    R7,R1                    ROUND DOWN TO ENTRY BOUNDARY\n         AR    R7,R4                    ADD IN BASE OF TABLE\n         EX    0,0(,R2)                 DO THE COMPARE\n         BE    4(,R14)                  IF EQUAL THEN ALL DONE\n         BH    BSHIGH                   GO HANDLE HIGH CASE\n*    LOW - NEED TO GO CLOSER TO START\n         CR    R7,R4                    ARE WE ALREADY AT START OF TBL\n         BE    BSNF1                    NOT FOUND, BUT NEED TO ADJ R7\n         LR    R5,R7                    SET NEW HIGH TO CURRENT\n         SR    R5,R6                    SET NEW HIGH TO BELOW CURRENT\n         B     BSLOOP                   TRY AGAIN\n*    HIGH - NEED TO GO CLOSER TO END\nBSHIGH   DS    0H\n         CR    R7,R5                    ARE WE ALREADY AT END OF TABLE\n         BE    BSNF2                    NOT FOUND, R7 IS OK\n         LR    R4,R7                    SET NEW LOW TO CURRENT\n         AR    R4,R6                    SET NEW LOW ABOVE CURRENT\n         B     BSLOOP                   TRY AGAIN\nBSNF1    DS    0H                       NOT FOUND - LOW\n         SR    R7,R6                    SET POINTER TO ONE BEFORE\n*                                       CANIDATE\nBSNF2    BR    R14                      EXIT NOT FOUND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CACHE": {"ttr": 28940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x966_\\x01\\x026\\x1f\\x16\\x07\\x01\\xed\\x01\\xd5\\x00\\x19\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "2002-12-27T16:07:00", "lines": 493, "newlines": 469, "modlines": 25, "user": "CTEC004"}, "text": "CACHE    MENTER 12,EQU,COM=CACHE,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n********************************************************************\n* CACHE IS A TSO COMMAND DESIGNED TO BE RUN UNDER THE TSSO\n* SUBSYSTEM. ITS PURPOSE IS TO PROVIDE DATA ABOUT THE\n* 3880-11 AND 3880-13 CACHE SUBSYSTEMS.\n*\n* SYNTAX:\n*\n*                ON\n*     CACHE XXX  OFF SUBSYS  LEGEND\n*                LIST\n*                STATUS\n*\n*          O       R\n*\n*\n*     CACHE * CMD('CACHE COMMAND')\n*\n*\n* WHERE XXX IS A VALID UCB ADDRESS OF A 3350 OR 3380 DEVICE.\n* OR A VOLUME SERIAL NUMBER.\n*\n* THE SUBSYS KEYWORD WILL GENERATE AN IDCAMS COMMAND TO\n* WORK FOR THE ENTIRE CONTROL UNIT. THE NOSUBSYS  KEYWORD (BLANK)\n* WILL GENERATE IDCAMS STATEMENTS TO WORK FOR THE DEVICE SPECIFIED.\n*\n* THE LEGEND OPERAND WILL INFORM IDCAMS TO GENERATE A LEGEND KEYWORD\n*\n* THE CMD OPERAND IS PROVIDED AS A WAY OF ENTERING ANY VALID IDCAMS\n* COMMAND THROUGH THIS PROGRAM AND HAVING IT EXECUTED.\n\n*       +---------+\n*       + CHANGES +\n*       +---------+\n* 30DEC96 RPS FIXED ADDRESSABILITY ERRORS WITH HLASM\n*   DEC 2002 PVW  ADD CALL TO TSSORATH TO CHECK AUTHORIZATION IN\n*                 RACF TO USE THIS COMMAND.  IF NO RACF PROFILE FOUND,\n*                 CONTINUE AND CHECK THE UADS USERDATA FIELD.  IF\n*                 RACF PROFILE FOUND, SKIP CHECK OF UADS FIELD AND GO\n*                 BASED ON AUTHORIZATION FOUND IN RACF.\n********************************************************************\n         UNDERTSO NO=NOTTSO\n*\n         LINK  EP=TSSORATH                  LINK TO PGM TO CHECK AUTH\n*                                           TO TSSO.CMD.AUTH PROFILE\n*                                           IN RACF FOR PERMISSION TO\n*                                           USE THE POWERFUL ALTAOF\n*                                           COMMAND\n         LTR   R15,R15                      AUTHORIZED?\n         BZ    NOTTSO                       YES, CONTINUE\n         C     R15,=F'8'                    NOT AUTHORIZED?\n         BL    CHKUADS                      NO, PROF NOT DEFD. CHK UADS\n         TLINE 'CACHE COMMAND ONLY AVAILABLE UNDER TSSO'\n         B     ENDPROG1\n*\nCHKUADS  DS    0H\n         EXTRACT  PSCBADDR,'S',FIELDS=PSB\n         L     R2,PSCBADDR\n         USING PSCB,R2\n         TM    PSCBATR2,X'C0'    AUTHORIZATION\n         BO    NOTTSO\n         TLINE 'CACHE COMMAND ONLY AVAILABLE UNDER TSSO'\n         B     ENDPROG1\nNOTTSO   DS    0H\n         SETPARSE PCL=CHPARSE\n         LINK  EP=IKJPARS         GET THE STRING PARSED\n         CH    R15,=H'4'          HOW DID WE DO\n         BNL   ENDPROG           NOT SO GOOD, ERRORS\nPARSEEND DS    0H\n         L     R4,MYANS           POINT TO DSECT CONTAINING STRING\n         USING IKJPARMD,R4\n         LH    R5,CMD             WAS COMMAND SPECIFIED?\n         CH    R5,=H'1'           CHECK VALUE\n         BE    GETCHCMD           YUP, COMMAND SPECIFIED, BYPASS\n*\n         LH    R5,UNITID+4        GET ACTUAL LENGTH OF STRING\n         CH    R5,=H'3'           UNIT SPECIFIED, USE IT.\n         BNE   GETVOL             OTHERWISE, GET A VOLSER\n*\n         L     R6,UNITID          POINT TO STRING\n         MVC   UCBADDR(3),0(R6)   AND MOVE IT TO SEARCH PLACE\n         B     FINDVOL\nGETVOL   DS    0H\n         CH    R5,=H'6'           EXACTLY 3 BYTES\n         BNE   ERROR9             MUST HAVE LET EVERYTHING DEFAULT.\n         L     R6,UNITID\n         MVC   STRVOL(6),0(R6)\n         B     FINDVOL\n********************************************************************\n* WE NOW HAVE THE UCB ADDRESS DESIRED, WE MUST GO OUT AND FIND\n* THE UNIT AND VOLSER. FIRST, LOCALTE THE UCB AND GET THE INFO\n********************************************************************\nFINDVOL  DS    0H\n         L     R3,16              GET CVT\n         USING CVTMAP,R3                 ADDRESS IT\n         XC    WORKAREA(100),WORKAREA    CLEAR WORKAREA REQUIRED FOR\n         LA    R1,WORKAREA               UCBSCAN AND STORE ADDRESS IN\n         ST    R1,PARM1                  PARM LIST\n         LA    R1,DEVCLASS               SEARCHING FOR ALL DEVICES\n         ST    R1,PARM2                  STORE IN PARM LIST\n         LA    R1,UCBPLACE               TELL UCBSCAN WHERE TO PUT\n         ST    R1,PARM3                  THE RESULTS\n         OI    PARM3,X'80'               INDICATE END OF LIST\nSRCHIT   DS    0H                        START THE SEARCH\n         LA    R1,PARMLIST               LOAD UP PARMLIST\n         L     R15,CVTUCBSC              CALL UCBSCAB\n         BALR  R14,R15                   AND HOPE\n         LTR   R15,R15                   CHECK RC\n         BNZ   ENDLIST                   IF \u00ac=0 END OF LIST, NOT FOUND\n         L     R5,UCBPLACE               GET RETURNED UCB\n         CLC   UCBADDR(3),=CL3' '        UCBADDR BLANK ?\n         BE    SRCHUCBA                  YUP, SEARCHING FOR A UCB ADDR\n* HERE, WE HAVE A UCB ADDR, AND WE ARE LOOKING TO FILL IN THE VOLSER\n         CLC   13(3,R5),UCBADDR     IS THIS THE CORRECT UCB?\n         BE    FOUNDUCB            YUP\nSRCHUCBA DS    0H\n* HERE, WE HAVE A VOLSER, AND ARE LOOKING TO FILL IN THE UCB ADDRESS.\n         CLC   28(6,R5),STRVOL      IS THIS THE CORRECT UCB ?\n         BE    FOUNDUCB\n         B     SRCHIT                    KEEP ON LOOKING\nENDLIST  DS    0H                        END OF LIST, UCB NOT FOUND\n         B     ERROR0                    GO TELL THE USER.\nFOUNDUCB DS    0H\n********************************************************************\n* TO SEARCH FOR ADDITION DEVICE TYPES IF AND WHEN IBM CHANGES\n* CACHE, REFER TO DEBUGGING HANDBOOK FOR UCB DEVICE TYPES.\n********************************************************************\n         MVC   UCBADDR(3),13(R5)     MOVE IN THE UCB\n         MVC   STRVOL(6),28(R5)      MOVE IN THE VOLUME\n********************************************************************\n* NOTE, ONE OF THE ABOVE VARIABLES, WE ALREADY HAD\n********************************************************************\n         CLI   19(5),X'0B'           TEST FOR 3350\n         BNE   TRY3380\n         MVC   STRUNIT(4),=CL4'3350'\n         B     GETREQ\nTRY3380  DS    0H\n         CLI   19(5),X'0E'           TEST FOR 3380\n         BNE   TRYFAIL               NO, BAD UNIT\n         MVC   STRUNIT(4),=CL4'3380'\n         B     GETREQ\nTRYFAIL  DS    0H\n********************************************************************\n* HERE, THE UCB WAS FOUND, BUT WAS NOT A 3350 OR 3380 TYPE DEVICE.\n* INFORM THE USER AND EXIT IMMEDIATELY !\n********************************************************************\n         B     ERROR3\nGETREQ   DS    0H\n* THE LAST CHECK WE MAKE ON THE UCB IS ONLINE/OFFLINE...\n* R5 STILL POINTS TO THE UCB\n         TM    3(R5),X'80'          DEVICE ONLINE\n         BO    GETTYPE\n         B     ERROR7\nGETTYPE  DS    0H\n********************************************************************\n* NEXT, WE CHECK IF THE COMMAND WAS ON, OFF OR LIST. IF THE\n* COMMAND WAS LIST, WE SUBSTITUE LISTDATA INTO THE STRCMD FIELD,\n* OTHERWISE, WE SUBSTITUE SETCACHE, AND SET THE ON/OFF FIELD\n* ACCORDINGLY.\n* IF THE COMMAND WAS STATUS, WE SUBSTITUTE LISTDATA INTO THE\n* COMMAND FIELD, PUT STATUS INTO THE ON/OFF FIELD, AND ISSUE THE\n* COMMAND. NOTE THAT WE IGNORE OTHER LINES\n********************************************************************\n         LH    R5,TYPE             LOAD VALUE OF KEYWORD 'TYPE'\n         CH    R5,=H'1'            WAS IT ON?\n         BE    ONREQ\n         CH    R5,=H'2'            WAS IT OFF?\n         BE    OFFREQ\n         CH    R5,=H'3'            WAS IT LIST?\n         BE    LISTREQ             YUP\n         CH    R5,=H'4'            WAS IT STATUS ?\n         BE    STATREQ             YUP\n         B     ERROR4              ON, OFF OR LIST WAS NOT SPECIFIED,\n*                                  STATUS SHOULD BE THE DEFAULT.\n*                                  AND ERROR4 SHOULD NEVER BE TAKEN\nONREQ    DS    0H\n         MVC   STRCMD(8),=CL8'SETCACHE'\n         MVC   ONOFF(3),=CL3'ON '\n         B     GETSUBDV\nOFFREQ   DS    0H\n         MVC   STRCMD(8),=CL8'SETCACHE'\n         MVC   ONOFF(3),=CL3'OFF'\n         B     GETSUBDV\nLISTREQ  DS    0H\n         MVC   STRCMD(8),=CL8'LISTDATA'\n         LH    R5,LEGENKEY\n         CH    R5,=H'1'\n         BNE   NOLEGEN\n         MVC   ONOFF(8),=CL8'LEGEND'\nNOLEGEN  DS    0H\n         MVC   COUNTS(8),=CL8'COUNTS'\n         B     GETSUBDV\nSTATREQ  DS    0H\n***********************************************************************\n* PROCESS STATUS REQUEST\n* NOTE: ONLY VALID PARAMETER IS STATUS- THE COUNTS, DEVICE AND        *\n* SUBSYSTEM PARMS ARE MUTUALLY EXCLUSIVE                              *\n***********************************************************************\n         MVC   STRCMD(8),=CL8'LISTDATA'\n         LH    R5,LEGENKEY\n         CH    R5,=H'1'\n         BNE   NOLEGEN2\n         MVC   ONOFF(8),=CL8'LEGEND'\nNOLEGEN2 DS    0H\n         MVC   COUNTS(8),=CL8'STATUS'\n         B     ISSUECMD\n********************************************************************\n* THE ONLY REMAINING THING TO CHECK IS IF SUBSYS WAS SPECIFIED.\n* IF YES, INSERT IT ON THE COMMAND LINE, IF NOT, OH WELL\n********************************************************************\nGETSUBDV DS    0H\n         LH    R5,SUBSYSDV\n         CH    R5,=H'1'            SUBSYS SPECIFIED?\n         BNE   DEVICE\n         MVC   STRSUBSY(8),=CL8'SUBSYS  '\n         B     ISSUECMD            ISSUE THE COMMAND\nDEVICE   DS    0H\n         MVC   STRSUBSY(8),=CL8'DEVICE  '\n         B     ISSUECMD\nGETCHCMD DS    0H\n* WE COME HERE IF THE CMD KEYWORD WAS SPECIFIED. SIMPLY PLACE THE\n* STRING SPECIFIED IN THE OUTPUT BUFFER AND HAND THE COMMAND\n* TO IDCAMS\n         MVI   STRING,X'40'\n         MVC   STRING+1(79),STRING\n         L     R5,CACHECMD\n         LH    R6,CACHECMD+4\n         BCTR  R6,0\n         EX    R6,MOVECMD\n         B     AROUND1\nMOVECMD  MVC   STRING+1(0),0(R5)      ** EXECUTED **\nAROUND1  DS    0H\n         B     ISSUECMD\nNOSUBSYS DS    0H\nISSUECMD DS    0H\n* TEST\n*        TPUT  STRING,80\n*        B     ENDPROG\n********************************************************************\n* NOW THAT WE HAVE INPUT THE STRING, WE WILL OPEN THE OUTPUT FILE\n* AND PLACE THE STRING OUT THERE\n********************************************************************\n         TESTAUTH FCTN=1           APF AUTHORIZED ?\n         LTR   R15,R15             CHECK IT OUT\n         BNZ   NOAPF               NOPE.\n         OPEN  (IDCAMSD1,OUTPUT)\n         TM    IDCAMSD1+48,X'10'   SUCCESSFULLY OPENED?\n         BNO   ERROR1              NO, SHUCKS\n         PUT   IDCAMSD1,STRING     WRITE THE RECORD\n         CLOSE (IDCAMSD1)          CLOSE THE FILE\n* WE HAVE NOW CUT THE RECORD, SO WE WILL GIVE THE COMMAND TO IDCAMS\n* AND SEE WHAT HAPPENS\n         LINK  EP=IDCAMS,PARAM=(OPTIONS,DNAMES),VL=1\n         LTR   R15,R15\n         BNZ   ERROR2\n* NOW, ALL PROCESSING IS COMPLETED, WE MUST TAKE THE RESULTS, AND\n* SIMILAR TO TSSOWTO, READ THE RESULTS, AND PUTLINE THEM OUT.\nIDCOPEN  DS    0H\n         OPEN  (IDCOUT,(INPUT))\n         TM    IDCOUT+48,X'10'       OPEN SUCCESSFULL?\n         BNO   ERROR5                NO, GIVE IT UP\nIDCLOOP  DS    0H\n         GET   IDCOUT\n         MVI   4(R1),X'40'\n         LR    R2,R1\n         PUTLINE PARM=PUTBLOK,OUTPUT=((R2),TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\n         B     IDCLOOP\nEIDCOUT  DS    0H\n         CLOSE (IDCOUT)\nENDPROG  DS    0H\nENDPROG1 DS    0H\n         MLEAVE\nERROR0   DS    0H\n         CLC   STRVOL(6),=CL6' '     BLANK SPECIFIED ?\n         BNE   ERROR0V\nERROR0U  DS    0H\n         MVC   LINE0+22(3),UCBADDR\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE0H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR0V  DS    0H\n         MVC   LINE0V+22(6),STRVOL\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE0VH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nNOAPF    DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE8H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR2   DS    0H\n         ST    R15,IDCAMSRC\n         FORMAT (IDCAMSRC,4,XXXXXXXX),TO=LINE2+29,WKA=WKA\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     IDCOPEN\nERROR3   DS    0H\n********************************************************************\n* ERROR3 IS REACHED IN THE CASE OF A VALID UCB ADDRESS THAT DOES\n* NOT CORESSPOND TO A 3350 OR 3380 TYPE DEVICE.\n********************************************************************\n         MVC   LINE3+22(3),UCBADDR\n         MVC   LINE3+27(6),STRVOL\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR4   DS    0H\n         B     ENDPROG\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR7   DS    0H\n         MVC   LINE7+22(3),UCBADDR\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR9   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE9H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n         TITLE 'UNITCHK ROUTINE'                                   RPS\nUNITCHK  DS    0H\n********************************************************************\n* THIS IS THE VALIDITY CHECK ROUTINE FOR THE UNIT ADDRESS\n****************************** *************************************\n         PUSH  USING                                               RPS\n         DROP  R12                                                 RPS\n         STM   R14,R12,12(R13)  SAVE REGISTERS\n         LR    R6,R15           GET ADDRESSIBILITY\n         USING UNITCHK,R6\n         L     R4,0(R1)         GET ADDRESS OF PDE FOR UNITID\n         L     R2,0(R4)         GET ADDRESS OF STRING, TO CHECK DEFAULT\n         CLC   0(1,R2),=CL1'*'  NO UNIT ADDRESS ?\n         BNE   CHECKVOL         CHECK IF VOLSER.\n         B     UNITCK00\nCHECKVOL DS    0H\n         LH    R2,4(R4)         POINT TO LENGTH CHARACTER STRING\n         CH    R2,=H'6'         LENGTH 6 ==> VOLSER\n         BNE   CHECKUNT         NOPE, CHECK FOR UNIT.\n         B     UNITCK00\nCHECKUNT DS    0H\n         CH    R2,=H'3'         EXACTLY THREE BYTES?\n         BNE   UNITCK04         NO, EXIT AND REPROMPT\n         L     R2,0(R4)         POINT TO ACTUAL STRING ENTERED\n         LA    R5,3             SET LOOP FOR BCT\nUNITCKLP DS    0H\n         CLI   0(R2),C'A'\n         BE    UNITCKLE         IF AN 'A', BRANCH TO LOOP END\n         CLI   0(R2),C'B'\n         BE    UNITCKLE         IF AN 'B', BRANCH TO LOOP END\n         CLI   0(R2),C'C'\n         BE    UNITCKLE         IF AN 'C', BRANCH TO LOOP END\n         CLI   0(R2),C'D'\n         BE    UNITCKLE         IF AN 'D', BRANCH TO LOOP END\n         CLI   0(R2),C'E'\n         BE    UNITCKLE         IF AN 'E', BRANCH TO LOOP END\n         CLI   0(R2),C'F'\n         BE    UNITCKLE         IF AN 'F', BRANCH TO LOOP END\n         CLI   0(R2),C'0'       CHECK AGAINST 0\n         BL    UNITCK04\n         CLI   0(R2),C'9'       CHECK AGAIN 9\n         BH    UNITCK04\nUNITCKLE DS    0H\n         LA    R2,1(R2)\n         BCT   R5,UNITCKLP      LOOP BACK\n* IF WE GET HERE, THE PARM IS OK\nUNITCK00 DS    0H\n         LM    R14,R12,12(R13)\n         XR    R15,R15\n         BR    R14\nUNITCK04 DS    0H\n* IF GET HERE, THE PARM IS SYNTACTLY INVALID, AND PARSE SHOULD\n* REPROMPT.\n         LM    R14,R12,12(R13)\n         LA    R15,4\n         BR    R14\n         DROP  R6\n         POP   USING                                               RPS\n         TITLE 'CACHE DATA CONSTANTS AND WORKAREAS'\nIDCAMSD1 DCB   DDNAME=IDCAMSDD,RECFM=FB,LRECL=80,BLKSIZE=6400,         X\n               MACRF=PM,DSORG=PS\nIDCOUT   DCB   DDNAME=IDCOUT,RECFM=VBA,LRECL=125,BLKSIZE=629,          X\n               MACRF=GL,DSORG=PS,EODAD=EIDCOUT\nCACHEFLG DS    H\n* BYTE 1\n* X'80'  * ENTERED\n* X'40'  VOLSER ENTERED\n* X'20'  UNIT ENTERED\nPSCBADDR DS    F\nPARMLIST DS    0D\nPARM1    DS    F\nPARM2    DS    F\nPARM3    DS    F\nUCBADDR  DS    CL4\nUCBVOL   DS    CL6\nWKA      DS    2D\nIDCAMSRC DS    F\nINAREAH  DC    H'133',H'0'\nINAREA   DC    CL133' '\nOPADDR   DC    A(OPTIONS)\nOPTIONS  DC    H'0'\nDNAMADDR DC    A(DNAMES)\nDNAMES   DC    H'48'\n         DC    32X'00'\n         DC    CL8'IDCAMSDD'      ALTERNATE NAME FOR SYSIN\n         DC    CL8'IDCOUT  '      ALTERNATE NAME FOR SYSTSPRT\nLINE0H   DC    H'80',H'0'\nLINE0    DC    CL80'ERROR: UCB SPECIFIED (XXX) IS NOT GENNED'\nLINE0VH  DC    H'80',H'0'\nLINE0V   DC    CL80'ERROR: VOL SPECIFIED (XXXXXX) IS NOT FOUND'\nLINE1H   DC    H'80',H'0'\nLINE1    DC    CL80'ERROR: CACHE COMMAND NOT INITIALIZED'\nLINE2H   DC    H'80',H'0'\nLINE2    DC    CL80'ERROR: IDCAMS RETURN CODE IS XXXXXXXX'\nLINE3H   DC    H'80',H'0'\nLINE3    DC    CL80'ERROR: UCB SPECIFIED (XXX- XXXXXX) IS NOT ON A 3350X\n                OR 3380 DEVICE'\nLINE5H   DC    H'80',H'0'\nLINE5    DC    CL80'ERROR: IDCOUT DD STATEMENT MISSING'\nLINE7H   DC    H'80',H'0'\nLINE7    DC    CL80'ERROR: UCB SPECIFIED (XXX) IS OFFLINE'\nLINE8H   DC    H'80',H'0'\nLINE8    DC    CL80'THE CACHE COMMAND WAS NOT INVOKED AUTHORIZED'\nLINE9H   DC    H'80',H'0'\nLINE9    DC    CL80'EITHER A UCB MUST BE SPECIFIED, OR THE CMD KEYWORD X\n               BE USED'\nSTRING   DS    0D\n********************************************************************\n* THIS IS THE STRING THAT WE BUILD TO PASS THE COMMAND TO IDCAMS   *\n********************************************************************\n         DC    CL3' '\nSTRCMD   DC    CL8' '             8 BYTES FOR THE COMMAND\n         DC    CL2' '             3 BYTES FOR BLANKS\n         DC    C'VOLUME('         VOLUME LITERAL\nSTRVOL   DC    CL6' '             FILL IN THE VOLUME\n         DC    C')'\n         DC    CL2' '\n         DC    C'UNIT('\nSTRUNIT  DC    CL4' '\n         DC    C')'\n         DC    CL4' '\nONOFF    DC    CL6' '            ON, OFF, OR LEGEND\n         DC    CL2' '\nCOUNTS   DC    CL8' '            POSSIBLE COUNTS OPTION IF LISTDATA\n         DC    CL2' '\nSTRSUBSY DC    CL8' '            SUBSYS OPTION\n         DC    CL80' '\nDEVCLASS DC    X'00'\nWORKAREA DC    XL100'00'\nUCBPLACE DS    F\n********************************************************************\n* THIS IS THE DESCRIPTION OF THE COMMAND SYNTAX, AS PARSE WANTS IT *\n********************************************************************\nCHPARSE  IKJPARM\nUNITID   IKJIDENT 'UNIT ADDRESS',VALIDCK=UNITCHK,PROMPT='UNIT ADDRESS',X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=6,ASTERISK,       X\n               HELP=('UNIT ADDRESS OR VOLUME SERIAL',                  X\n               'UNIT ADDRESS OR VOLSER MUST BE A 3350 OR 3380 DEVICE')\nTYPE     IKJKEYWD DEFAULT='STATUS'\n         IKJNAME 'ON'\n         IKJNAME 'OFF'\n         IKJNAME 'LIST'\n         IKJNAME 'STATUS'\nSUBSYSDV IKJKEYWD DEFAULT='DEVICE'\n         IKJNAME 'SUBSYS'\n         IKJNAME 'DEVICE'\nLEGENKEY IKJKEYWD DEFAULT='NOLEGEND'\n         IKJNAME 'LEGEND'\n         IKJNAME 'NOLEGEND'\nCMD      IKJKEYWD\n         IKJNAME 'CMD',SUBFLD=CMDSUB\nCMDSUB   IKJSUBF\nCACHECMD IKJIDENT 'CMD',PROMPT='CACHE COMMAND',FIRST=ALPHA,CHAR,       X\n               OTHER=ALPHANUM,HELP='IDCAMS COMMAND FOR CACHE'\n         IKJENDP\n         IKJIOPL\n         IEZJSCB\n         IKJPSCB\n         CVT   DSECT=YES\n         END CHPARSE\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY CACHE(''V 2.1 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    CACHE'\n PUNCH ' NAME     CACHE(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLISTS": {"ttr": 29191, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99&\\x7f\\x00\\x99&\\x7f\\x08E\\x00\\xf5\\x00\\xf5\\x00\\x00\\xc1\\xc7\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "1999-09-24T08:45:00", "lines": 245, "newlines": 245, "modlines": 0, "user": "AGCO"}, "text": "./ ADD NAME=HSMCYCLE 0102-92295-92303-1101-00012-00013-00000-CART1\nPROC 0\n /*                                                                  */\n /*      PDSDOC *CLIST TO STOP AND RESTART DF/HSM                    */\n /*                                                                  */\n EXEC 'SYS2.TSSOR43.CLIST(HSMSTOP)'\n SET &ENDOK = &LASTCC\n IF &ENDOK NE 0 THEN EXIT CODE(8)\n /*                                                                  */\n /* NOW RESTART HSM.                                                 */\n /*                                                                  */\n OSCMD S HSM.HSM\nEND\n./ ADD NAME=HSMSTOP  0101-92303-92303-1103-00011-00009-00000-CART1\nPROC 0\n /*                                                                  */\n /*      PDSDOC *CLIST TO DO A SYNCHRONISED STOP OF DF/HSM           */\n /*                                                                  */\n OSCMD F HSM,STOP\n OSWAIT ENTRY(HSMEND) TIMEOUT(3600)\n SET ENDOK = &LASTCC\n IF &ENDOK EQ 0 THEN EXIT CODE(0)\n    ELSE WTOH '*** CHECK HSM STATUS ***'\n    EXIT CODE(8)\nEND\n./ ADD NAME=HSMTAPE  0102-92295-92295-1429-00012-00014-00000-CART1\nPROC 1 VOLSER\n /*                                                                  */\n /*      PDSDOC *CLIST TO TEST FOR TAPE AVAILABILITY AND REPLY 'Y'   */\n /*                                                                  */\n CALL 'SYS2.LINKLIB(MPFTAPEQ)' '&VOLSER'\n SET TAPEOK = &LASTCC\n IF &TAPEOK NE 0 THEN EXIT CODE(0)\n /*                                                                  */\n /* THE TAPE HAS RECENTLY BEEN USED. WE CAN SAY IT IS AVAILABLE.     */\n /*                                                                  */\n REPLY MSG(ARC0366A) TEXT('Y')\nEND\n./ ADD NAME=NOPAPER  0113-92240-92268-1311-00051-00018-00000-CART1\nPROC 1 RMT\n /*                                                                  */\n /*      PDSDOC *CLIST DISABLES JES328X PRINTERS WITH INTVN REQUIRED */\n /*                                                                  */\n /* FIRST CHECK IF IN PRIME SHIFT - LET OPERATOR FIX IT              */\n     EXEC SYS2.TSSOR43.CLIST(PRIME)\n     SET SHIFT = &LASTCC\n /*  IF &SHIFT = 0 THEN EXIT CODE(0)                                 */\n /*                                                                  */\n /* AS OPERATORS ARE NOTORIOUSLY SLOW WE PREFER TO GIVE THEM SOME    */\n /* TIME TO RELOAD THE PAPER.                                        */\n /*                                                                  */\n /* SCHEDULE A COMMAND TO RESTART THE PRINTER IN THE FUTURE          */\n /*                                                                  */\n     SET HOURS = &SUBSTR(1:2,&SYSSTIME)\n     SET MINS  = &SUBSTR(4:5,&SYSSTIME)\n     IF &SHIFT = 0 THEN DO\n                    SELECT (&MINS)\n                     WHEN (30:44) SET STIME = &STR(&HOURS..45)\n                     WHEN (15:29) SET STIME = &STR(&HOURS..30)\n                     WHEN (00:14) SET STIME = &STR(&HOURS..15)\n                     OTHERWISE DO\n                               SET HOURS = &HOURS+1\n                               SET STIME = &STR(&HOURS..00)\n                               END\n                    END\n                   END\n /*                                                                  */\n /* OVERNIGHT WE JUST SHUT IT DOWN. DUE TO DEFICIENCIES IN JES2      */\n /* AUTOMATIC COMMAND SCHEDULING WE HAVE A LITTLE FLURRY OF ACTIVITY */\n /* AT MIDNIGHT.                                                     */\n /*                                                                  */\n     ELSE DO\n                    SELECT (&HOURS)\n                     WHEN (17:23) SET STIME = &STR(23.59)\n                     WHEN (00:06) SET STIME = &STR(07.00)\n                     OTHERWISE DO\n                               SET HOURS = &HOURS+1\n                               SET STIME = &STR(&HOURS..00)\n                               END\n                    END\n          END\n    SET START1 = &STR($TA,T=&STIME,'$VS,''.RESTART &RMT.''')\n /*                                                                  */\n     SET PPRT = &STR($PLNE&RMT)\n     SET LINE = &STR($ELNE&RMT)\n /* DISABLE THE PRINTER                                              */\n     WRITE *COM001 &PPRT\n     WRITE *COM    &LINE\n     WRITE *COM    &START1\nEND\n./ ADD NAME=PRIME    0103-92240-92248-0911-00016-00010-00000-CART1\nPROC 0\n /*                                                                  */\n /*      PDSDOC *CLIST TO TEST FOR PRIME SHIFT. RETURN RC(0) IF YES. */\n /*                                                                  */\n /* THE FIRST PART IS VALID IF 'DAYOWEEK' HAS BEEN INSTALLED.        */\n /* SEE CBT FILE 172                                                 */\n DAYOWEEK\n SET DAYNUM = &LASTCC\n IF &DAYNUM GT 5 THEN EXIT CODE(8)\n /*                                                                  */\n SET HOURS = &SUBSTR(1:2,&SYSSTIME)\n SELECT\n   WHEN (&HOURS GT 17) EXIT CODE(8)\n   WHEN (&HOURS LT 07) EXIT CODE(8)\n END\nEND\n./ ADD NAME=RESTART  0104-92268-92268-1308-00018-00018-00000-CART1\nPROC 1 RMT\n /*                                                                  */\n /*      PDSDOC *CLIST RE-ENABLES JES328X PRINTERS STOPPED BY NOPAPER*/\n /*                                                                  */\n /*                                                                  */\n /*                                                                  */\n    SET START1 = &STR($SLNE&RMT.)\n    SET START2 = &STR(F JES328X,S,RMT&RMT.)\n /*                                                                  */\n     OSCMD &START1\nRETRY: +\n     OSPAUSE 1\n     OSCMD &START2\n     OSWAIT ENTRY(JSXOK) TIMEOUT(5)\n     SET RESPOND = &LASTCC\n     IF &RESPOND = 8 THEN EXIT CODE(0)\n        ELSE GOTO RETRY\nEND\n./ ADD NAME=RMTGO    0109-91199-92241-0748-00008-00003-00000-CART1\n /*                                                                  */\n /*      PDSDOC *AUTOMATICALL START RMT PRINTER ON FORM CHANGE...... */\n /*                                                                  */\nPROC 1 DEVICE\n SET UNIT = &STR($S&DEVICE)\n DELAY 2\n WRITE *COM &UNIT\nEND\n./ ADD NAME=DOWN\nPROC 0 DEBUG TASK()\n\n /*                                                                  */\n /*      PDSDOC *GENERALISED SHUTDOWN CLIST..........................*/\n /*                                                                  */\n /*  23APR99 DHC CREATED USING CODE FROM JIM LANE'S \"HOTSTART\"       */\n\n  IF &DEBUG = DEBUG THEN CONTROL  MSG LIST CONLIST SYMLIST FLUSH\n                    ELSE CONTROL  NOMSG NOLIST FLUSH\n /*                                                                  */\n\n        /*************************************************************/\n        /* THE FIRST STEP IS DIRECTING THE OSCMD COMMAND PROCESSOR   */\n        /* TO SEND THE RESPONSE OF THE COMMAND TO CLIST VARIABLES,   */\n        /* TO SET THE EXPECTED COMMAND RESPONSE COUNT AND            */\n        /* TO DECIDE HOW LONG THE CLIST SHOULD WAIT FOR THE RESPONSE */\n        /*************************************************************/\n        SET CMDRESP = CLIST\n        SET MAXCMDOUT = 20\n        SET CMDWAIT = 5\n\n /*                                                                  */\n  OSCMD P &TASK\n/* WAIT FOR TASK TO END                          */\n  SET I = 1                                                               004200\n  DO WHILE (&I <= 180)                                                    004400\n    OSCMD D J,&TASK                                                       004500\n    SET STATUS1 = &CMDOUT5W2                                              004600\n    SET STATUS2 = &CMDOUT5W3                                              004700\n    IF &STATUS1 = NOT AND &STATUS2 = FOUND THEN GOTO NOTASK               004800\n    OSPAUSE 10                                                            004900\n    SET I = &I + 1                                                        005000\n  END                                                                     005100\n  OSWTOH &TASK DID NOT COME DOWN IN EXPECTED TIME                         005200\n  OSCMD C &TASK                                                           004500\n  EXIT CODE (4)                                                           005400\n/*                                                           */\nNOTASK: +\n  OSWTO TASK &TASK IS DOWN\n  EXIT CODE(0)\n./ ADD NAME=ONLYTSO\nPROC 0\n /*                                                                  */\n /*      PDSDOC *TSSO CLIST TO SHUT SYSTEM DOWN TO JUST TSO..........*/\n /*                                                                  */\n /*                                                                 */\n   CONTROL LIST NOPROMPT NOFLUSH MSG NOSYMLIST NOCONLIST\n /*                                                                  */\n %SURE\n SET &ENDOK = &LASTCC\n IF &ENDOK NE 0 THEN EXIT CODE(8)\n /*                                                                  */\n   OSCMD P JSX1\n   OSCMD P JRP\n   OSCMD P IOAOSASF\n   OSCMD P NETSPY\n   OSCMD P NETVIEW\n   OSCMD P XPE\n   OSCMD P ADSM\n   OSCMD F CA7ICOM,STOP\n   OSCMD F CAL7,SHUTDOWN,ALL\n   OSCMD C INETD4\n   %DOWN TASK(TCPIP1)\n   OSCMD $PLGN1\n   OSCMD C ASCH\n   OSCMD C APPC\n   OSCMD P JESXCF\n   OSCMD C IMWEBSRV\n   OSCMD P NETVSSI\n   OSCMD P DFSMSHSM\n   OSCMD P HSM\n   OSCMD C JCA7PROD\n   OSCMD C CAL7\n   OSCMD P RMF\n./ ADD NAME=SURE\nPROC 0 DEBUG\n\n /*                                                                  */\n /*      PDSDOC *TSSO CLIST TO CONFIRM ACTION........................*/\n /*                                                                  */\n\n  IF &DEBUG = DEBUG THEN CONTROL  MSG LIST CONLIST SYMLIST FLUSH\n                    ELSE CONTROL  NOMSG NOLIST FLUSH\n /*                                                                  */\n\n         /* FIRST, FIND OUT IF THE OPERATOR IS READY TO PROCEED */\n         /* SET TIME LIMIT TO WAIT (IN SECONDS)                 */\n         SET REPLYWAIT = 60\n\n         STARTAGN: +\n         OSASK REPLY YES OR NO TO CONFIRM REQUEST\n\n         IF &REPLY = NOREPLY THEN GOTO TIMEDOUT\n         IF &REPLY = NO THEN GOTO BADEND\n         IF &REPLY = YES THEN GOTO ENDPROG\n\n         CONFUSED: +\n           OSWTOH ANSWER YES OR NO...\n           GOTO STARTAGN\n\n         TIMEDOUT: +\n           OSWTO FUNCTION TIMING OUT - REINVOKE WHEN YOU HAVE MORE TIME\n\n         BADEND: +\n           OSWTO FUNCTION TERMINATED\n           EXIT CODE(8)\n\n         ENDPROG: +\n           EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYPROC": {"ttr": 29196, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00 \\x00 \\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "TSSO403"}, "text": "//COPYPROC JOB (3225,P136),'COPY TO PROCLIB',CLASS=X,MSGCLASS=F,\n// NOTIFY=TSO67\n/*XEQ N13\n/*ROUTE PRINT N13\n//*********************************************************************\n//* THIS PROC WILL COPY THE SAMPLE TSSO STARTED PROCEDURE ENTRY INTO  *\n//* SYS1.PROCLIB. IT WILL ALSO COPY THE TSSO INITIALIZATION MEMBER    *\n//* INTO SYS1.LINKLIB.                                                *\n//*                                                                   *\n//*                                                                   *\n//*                                                                   *\n//*********************************************************************\n//COPY1    EXEC PGM=IEBCOPY\n//TSSOLIB  DD DSN=TSSO.VERS43.ASM,DISP=SHR\n//PROCLIB  DD DSN=SYS1.PROCLIB,DISP=SHR\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSIN    DD *\n    COPY INDD=((TSSOLIB,R)),OUTDD=PROCLIB\n    SELECT MEMBER=TSSOPROC\n//*\n//*\n//COPY2    EXEC PGM=IEBCOPY\n//TSSOLIB  DD DSN=TSSO.VERS43.LOAD,DISP=SHR\n//LINKLIB  DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(5,5))\n//SYSIN    DD *\n    COPY INDD=((TSSOLIB,R)),OUTDD=LINKLIB\n    SELECT MEMBER=TSSOINIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPCMD": {"ttr": 29441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\xb7\\x00\\xb7\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 183, "newlines": 183, "modlines": 0, "user": "TSSO403"}, "text": "CPCMD    MENTER 12,EQU,CP=CP,COM=CPCMD\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         PRINT NOGEN\n***********************************************************************\n* THIS COMMAND IS USEFUL FOR ISSUING VM/CP COMMANDS FROM AN MVS       *\n* MACHINE. THE COMMAND SYNTAX IS:\n*\n* CPCMD ANY-COMMAND\n*\n* WHEN RUN WITH THE TSSO SUBSYSTEM, THE OPERATOR HAS COMPLETE ACCESS\n* TO CP FACILITIES. THIS COMMAND IS ALSO AVAILABLE TO TSO USERS.\n***********************************************************************\n* THIS COMMAND WAS WRITTEN BY CHERYL RAHN, BELLCORE AND ADAPTED TO TSO*\n* AND THE TSSO SUBSYSTEM BY MARC SCHARE                               *\n***********************************************************************\n         TESTAUTH FCTN=1\n         LTR   R15,R15\n         BNZ   NOTAUTH1\n         MODESET KEY=NZERO,MODE=SUP\n         STIDP CPUID\n         CLI   CPUID,X'FF'         ARE WE RUNNING UNDER VM?\n         BE    GETSTOR             IF SO, PROGRAM CAN BE EXECUTED...\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\n*\n*\n*        GET STORAGE FOR OUTPUT BUFFER\nGETSTOR  DS    0H\n         GETMAIN R,LV=4096,SP=228\n         LR    R8,R1\n         USING AREA,R8\n**************************************************************\n*\n         MVC   REPLY(119),=CL119' '\n         L     R2,CPPLCBUF         GET TSO COMMAND BUFFER\n         LH    R3,2(R2)            GET OFFSET TO FIRST OPERAND\n         LH    R4,0(R2)            GET TOTAL LENGTH OF BUFFER\n         LA    R5,4(R3,R2)         R5 POINTS TO CP COMMAND\n         LA    R3,0(R2,R4)         POINT TO END OF BUFFER.\n         SR    R3,R5               R3 NOW HAS LENGTH OF OPERAND\n         CH    R3,=H'1'\n         BL    NOCOMM\n         BCTR  R3,0\n         EX    R3,MOVECMD\n         OC    REPLY(119),=CL119' '\n         TPUT  REPLY,119\n*                                  R3 NOW HAS ADDR OF FIRST NONBLANK\n*\n*        ISSUE DIAGNOSE COMMAND TO TALK TO CP\n*\n*        R6   ADDR OF BEGINNING OF CP COMMAND   (RX)\n*        R7   ADDR OF BUFFER FOR COMMAND RESPONSE\n*        R10  LENGTH OF COMMAND FIELD   (RY)\n*        R11  LENGTH OF RESPONSE BUFFER\n*        R8   ADDRESS OF GETMAINED AREA (REPLY; RESPONSE)\n*\n*\n         L     R11,LNGTHBUF\n         L     R10,LNGTHREP\n         O     R10,=XL4'40000000'\n         LRA   R7,RESPONSE        ADDR OF RESPONSE BUFFER\n         LRA   R6,REPLY           LOAD REAL ADDR (IN MVS'S VIEWPOINT)\n*                                 OF BEGINNING OF CP COMMAND FIELD.\n         SPACE 1\n         DC    X'83',X'6A',XL2'0008'    ISSUE DIAGNOSE.\n*\n*        CHECK TO SEE IF CP COMMAND WAS SUCCESSFUL\n         BNZ   TOOSMALL                 IS BUFFER TOO SMALL?\n         LTR   R11,R11                  IS THERE A RESPONSE?\n         BNZ   SUCCESS                  YES.  (MAY BE ERROR RESPONSE)\n         LTR   R10,R10                  RETURN CODE IS IN REG 10\n         BNZ   UNSUCC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     FREESTOR\nTOOSMALL DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         L     R11,LNGTHBUF             FULL SIZE OF RESPONSE BUFFER\n*\n*        R9    WILL CONTAIN START OF NEW LINE BEING EXAMINED\n*        R4    INDEX REG--WILL CONTAIN ADDRESS IN LINE TO PRINT OUT\n*        R2    INCREMENT REGISTER\n*        R3    COMPAREND--FIRST BYTE PAST BUFFER DATA\n*\nSUCCESS  LA    R4,RESPONSE              ADDRESS OF RESPONSE BUFFER\n         LA    R2,1                     INCREMENT\n         LA    R3,0(R11,R4)             FIRST BYTE PAST DATA\n         BCTR  R3,0                     LAST BYTE OF DATA (MINUS 1)\nNEWLINE  LR    R9,R4                    SAVE START OF THIS LINE\nSCANLOOP CLI   0(R4),X'15'              END-OF-LINE MARKER?\n         BE    ENDLINE                  YES\n         BXLE  R4,R2,SCANLOOP           EVERY LINE WILL END UNLESS\n         B     FREESTOR                 RESPONSE WAS TOO LARGE FOR BUF\nENDLINE  LR    R5,R4                    COPY END\n         SR    R5,R9                    COMPUTE LENGTH\n         BCTR  R5,0                     SUBTRACT 1 FROM LENGTH (FOR EX)\n         EX    R5,MOVEIN                MOVE DATA INTO PRINT\n         LA    R5,5(R5)                 ADD 4+1 BYTES TO LENGTH OF LINE\n         STH   R5,LINE5H                LENGTH OF MESSAGE\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         LA    R4,1(,R4)                POINT PAST END OF LINE\n         CR    R4,R3                    ARE WE DONE WITH RESPONSE?\n         BH    FREESTOR                 TERMINATE\n         B     NEWLINE\nMOVEIN   MVC   LINE5(0),0(R9)\nMOVECMD  MVC   REPLY(0),0(R5)      ** EXECUTED TO MOVE COMMAND ***\nFREESTOR DS    0H\n         FREEMAIN R,LV=4096,A=(R8),SP=228\nENDPROG  DS    0H\n         MLEAVE\n*\n*\n*        ERROR CONDITIONS:\n*\n*        UNSUCCESSFUL--RETURN CODE FROM CP IS NOT ZERO\n*\nUNSUCC   CVD   R10,RETCP                CHANGE RETURN CODE TO EBCDIC\n         UNPK  LINE3+30(4),RETCP         SO THAT IT CAN BE PRINTED IN\n         OI    LINE3+33,X'F0'            MESSAGE TO CONSOLE.\nWTOE     DS    0H                       CLEAR REGISTER 0\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     FREESTOR\nNOTAUTH1 DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nNOCOMM   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     FREESTOR\n         SPACE 2\n*        DATA AREA\nCPUID    DS    1D\nRETCP    DS    1D                       RETURN CODE FROM CP\nLNGTHBUF DC    F'3976'                  SIZE OF OUTPUT BUFFER\nLNGTHREP DC    F'119'                   SIZE OF OUTPUT BUFFER\nCONS     DS    1C\nTRTTABNB DC    64X'99'\n         DC    X'00'                    TO BYPASS BLANK\n         DC    191X'99'\nLINE1H   DC    H'80',H'0'\nLINE1    DC    CL80'CP COMMAND TERMINATED, YOU ARE NOT RUNNING UNDER VMX\n               '\nLINE2H   DC    H'80',H'0'\nLINE2    DC    CL80'CP COMMAND TERMINATED, IT WAS NOT INVOKED AUTHORIZEX\n               D'\nLINE3H   DC    H'80',H'0'\nLINE3    DC    CL80'CP COMMAND ERROR: RETURN CODE XXXX'\n*\nLINE4H   DC    H'80',H'0'\nLINE4    DC    CL80'CP COMMAND COMPLETED WITH RETURN CODE 0'\n*\nLINE5H   DC    H'0',H'0'\nLINE5    DC    CL120' '\n*\nLINE6H   DC    H'80',H'0'\nLINE6    DC    CL80'CP COMMAND COMPLETED OK, BUT BUFFER TO SHORT'\n*\nLINE7H   DC    H'80',H'0'\nLINE7    DC    CL80'INVALID COMMAND OR NO COMMAND SPECIFIED'\n*\n*\n*\nAREA     DSECT\nREPLY    DS  CL119\n         DS  0D\nRESPONSE DS  CL3976\n*\n         IKJIOPL\n         IEZJSCB\n         END   CPCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY CPCMD(''V 1.1 (TSSO V 4.3) &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    CPCMD'\n PUNCH ' NAME     CPCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATAAREA": {"ttr": 29445, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00 \\x00 \\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "TSSO403"}, "text": "THE FOLLOWING IS A LISTING OF TSSO DATA AREAS...\n\n\nWHERE GOT     DSECT NAME     SUBPOOL   KEY    SCOPE          COMMENTS\n(HOW MUCH)\n-----------------------------------------------------------------------\n\nTSSO (1024)   TSSOVARS         0       USER   TSSO MAINLINE\n\nTSSO (1024)   DATD             0       USER   TSSO ADDRESS\n                                              SPACE\n\nTSSO (NOTE1)  TSSOCMND        241       0     GLOBAL       TSSO COMMAND\n                                                             RING\n\nTSSO (1024)   TSSOCVT         228       0     GLOBAL       TSSO'S CVT\n\n\nTSSO (1284)   TSSOSSVT        241       0     GLOBAL       TSSO'S SSVT\n\nTSSO (1024)   SSCONCBH        241       0     GLOBAL       TSSO SUBSYS\n                                                        CONSOLE CONTROL\n                                                        BLOCK\n\n\nTSSO (1024)   TSSOSECR        241       0     GLOBAL    TSSO SECURITY\n                                                        ARRAY\n\n\nNOTES:\n1) THE TSSO COMMAND RING IS DEFINED AS 8*MAXCMD WHERE MAXCMD IS A\n   TSSO INITIALIZATION PARAMETER.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISPAOF": {"ttr": 29447, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00)\\x01\\x022O\\x01\\x022O\\tI\\x02`\\x02`\\x00\\x00\\xc1\\xc7\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-11-20T00:00:00", "modifydate": "2002-11-20T09:49:29", "lines": 608, "newlines": 608, "modlines": 0, "user": "AGCO"}, "text": "DISPAOF  TITLE  'TSSO COMMAND TO DISPALY AOF TABLE ENTRIES'\nDISPAOF  MENTER 12,EQU,COM=DISPAOF,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n***********************************************************************\n* THIS IS THE TSSO DISPLAY AOF COMMAND. THE COMMAND WILL OPERATE ON   *\n* EITHER THE CURRENT TSSO AOF TABLE, LOCATED OFF THE TSSO CVT, OR     *\n* A TABLE THAT IS LOCATED IN A LOAD LIBRARY ACCESSABLE TO THE         *\n* PROGRAM.                                                            *\n*                                                                     *\n*\n* SYNTAX:\n*\n*      DISPAOF  MSGID(MSG-IDENTIFIER) TABLE(TABLE-NAME) TEST\n*                                     ALTTAB\n*\n*      DISPAOF  ENTRYID(ENTRY-IDENTIFIER) TABLE(TABLE-NAME) TEST\n* WHERE:\n*    MSGID- THE OS MESSAGE IDENTIFIER THAT YOU WANT INFORMATION ABOUT\n*    ENTID- THE ENTRY IDENTIFIER YOU WANT INFO ABOUT.\n*    TABNAME-  THE TSSO AOF TO LOAD PRIOR TO PROCESSING\n*    TEST -    INCLUDE INFORMATION ON THE TESTS TO PERFORM FOR EACH\n*              MESSAGE ID.\n***********************************************************************\n*\n* VERSION IDENTIFIER:  TSSO VERSION 4.3\n* AUTHOR. MARC SCHARE\n*\n* MODIFIED FOR TSSO 4.3\n*    1) SUPPORT THE ENTRYID FIELD IN AOF TABLE ENTRIES.\n*\n* 28AUG92 CART1 MODIFIED AT SPRECHER ENERGIE TO HANDLE MULTI-LINE WTO\n*\n* 20OCT92  GLA  USE NEW DSECT FOR AOF ENTRIES\n*\n* 24OCT02  DHC  SHOW EXCLUSION TESTS\n*\n***********************************************************************\n* THE FIRST STEP IS TO PARSE THE INPUT, AND DETERMINE WHAT THE USER IS\n* AFTER.\n***********************************************************************\n         LA    R11,4095(R12)\n         LA    R11,1(R11)\n         USING DISPAOF+4096,R11\n         SETPARSE PCL=DISPARSE\n         LA    R10,CORE\n         LINK  EP=IKJPARS\n         L     R9,MYANS\n         USING IKJPARMD,R9\n*\n         LH    R2,MSGID              OBTAIN THE MESSAGE ID PARM\n         CH    R2,=H'1'              SPECIFIED ?\n         BNE   NOMSGSPE              WE NEED A MESSAGEID\n         LH    R3,MSGSUBID+4            PICK UP THE LENGTH\n         ST    R3,LMSGID             REMEMBER LENGTH OF MESSAGE ID\n         L     R4,MSGSUBID\n         BCTR  R3,0                  SUBTRACT ONE FOR EXECUTE\n         MVC   MSGSPEC(8),BLANK      BLANK MSGSPEC TO BEGIN WITH.\n         EX    R3,MOVEMSG\n         B     ARD1\nMOVEMSG  MVC   MSGSPEC(0),0(R4)      ** EXECUTED **\nARD1     DS    0H\n         OI    FLAGS,X'80'           FLAG MESSAGE AS SPECIFIED.\n         B     CHEKTBL\nNOMSGSPE DS    0H\n         MVC   MSGSPEC(8),BLANK      NO MESSAGE SPECIFIED- PRT EM ALL.\n*\nCHEKTBL  DS    0H\n         LH    R2,TABLEID            OBTAIN THE TABLE ID SPECIFIED\n         LTR   R2,R2                 SPECIFIED ?\n         BZ    NOTABLE               WE NEED A MESSAGEID\n         LH    R3,TABSUBID+4            PICK UP THE LENGTH\n         L     R4,TABSUBID\n         BCTR  R3,0                  SUBTRACT ONE FOR EXECUTE\n         EX    R3,MOVETAB\n         OI    FLAGS,X'40'           INDICATE TABLE NAME WAS SPECIFIED\n         B     ARD2\nMOVETAB  MVC   TABSPEC(0),0(R4)      ** EXECUTED **\nARD2     DS    0H\n         B     CHEKTEST\n*\nNOTABLE  DS    0H\n         MVC   TABSPEC(8),=CL8' '\n         B     CHEKTEST\n*\nCHEKTEST DS    0H\n         LH    R2,TEST               OBTAIN THE TABLE ID SPECIFIED\n         CH    R2,=H'1'              SPECIFIED ?\n         BNE   NOTEST                TEST WAS NOT SPECIFIED...\n         OI    FLAGS,X'10'\nNOTEST   DS    0H\n         B     CHEKENTR              CHECK IF ENTRY PARM SPECIFIED..\n*\nCHEKENTR DS    0H\n         LH    R2,ENTRY              CHECK IF SPECIFIED\n         CH    R2,=H'1'              WELL? WAS IT?\n         BNE   NOENTRY               GUESS NOT...\n         LH    R3,ENTSUBID+4         GET THE PDL FOR THE SPECIFIED ENT\n         ST    R3,LENTID             FOR COMPARES LATER ON\n         L     R4,ENTSUBID           POINT TO THE STRING\n         OI    FLAGS,X'20'           FLAG ENTRY AS SPECIFIED\n         BCTR  R3,0\n         EX    R3,MOVEENT\n         B     ARD3\nMOVEENT  MVC   ENTSPEC(0),0(R4)\nARD3     DS    0H\n         B     ENDENTRY\nNOENTRY  DS    0H\n         MVC   ENTSPEC(8),=CL8'ALL'\n         B     ENDENTRY\nENDENTRY DS    0H\n*\n         DROP  R9\nHAVEPARM DS    0H\n***********************************************************************\n* NOW THAT WE HAVE THE PARAMETERS, WE WILL EITHER USE THE CURRENT     *\n* TABLE ID, IN STORAGE, OR LOAD THE TABLE THAT WAS SPECIFIED... IN    *\n* EITHER CASE, WE WILL FORMAT THE ENTRIES BY WALKING THROUGH THE TABLE*\n***********************************************************************\n         TM    FLAGS,X'40'           WAS TABLE SPECIFIED ?\n         BO    LOADTABL              NO, GO LOAD THE TABLE.\n         GETCVT (R2)                 START WITH TSSO CVT           RPS\n         LTR   R2,R2\n         BZ    ERROR2\n         USING TSSOCVT,R2\n         L     R2,TSSOTABL           GET TSSO TABLE ADDRESS\n         LTR   R2,R2\n         BZ    ERROR6                GET TSSO CURRENT TABLE ADDR.\n         ST    R2,TABADDR\n         DROP  R2\n         B     GOTTABL\nLOADTABL DS    0H\n         LOAD  EPLOC=TABSPEC,ERRET=TABERROR\n         ST    R0,TABADDR\n         B     GOTTABL\nTABERROR DS    0H\n         B     ERROR3\nGOTTABL  DS    0H\n***********************************************************************\n* WE NOW HAVE A TSSO TABLE, POINTED TO BY THE ADDRESS IN TABADDR      *\n* WE CAN (FINALLY) START PROCESSING THE TABLE                         *\n***********************************************************************\n         L     R2,TABADDR            LOAD ADDRESS OF TABLE\n         CLC   4(8,R2),=CL8'TSSOTABL'   VALID TSSO TABLE ?\n         BNE   ERROR4\n         CLC   44(8,R2),=CL8'TSSO 4.3'  CURRENT LEVEL OF TSSO TABLE ?\n         BNE   ERROR5\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD0H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   HEAD1+12(8),20(R2)       MOVE IN TABLE NAME\n         MVC   HEAD1+28(8),28(R2)       MOVE IN DATE ASSEMBLED\n         MVC   HEAD1+44(8),36(R2)       MOVE IN TIME ASSEMBLED\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   HEAD2+12(8),12(R2)       MOVE IN TABLE ID\n         MVC   HEAD2+31(8),44(R2)       MOVE IN VERSION IDENTIFIER\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         L     R2,0(R2)                 POINT TO THE FIRST RECORD IN\n*                                       THE TSSO AOF.\n         USING AOFNTRY,R2\n         XC    RECCOUNT(4),RECCOUNT     BLANK IT OUT...\nMSGLOOP  DS    0H\n***********************************************************************\n* HERE, WE HAVE THE ADDRESS OF A MSGID RECORD. WE MUST FORMAT THE\n* RECORD, AND LOOP DOWN. R2 WILL POINT TO THE RECORD\n***********************************************************************\n         LTR   R2,R2                 IS THIS A RECORD ?\n         BZ    ENDRECS               NOPE, NO MORE RECORDS !\n*\n         CLC   AOFMSGID,=CL8'ZZZZZZZZ'  END OF RECORD INDICATOR\n         BE    ENDRECS                  YUP, THIS IS IT.\n*\n         L     R1,RECCOUNT\n         LA    R1,1(R1)\n         ST    R1,RECCOUNT\n*\n***********************************************************************\n* BEFORE WE ACTUALLY GO AND PRINT A MESSAGE ID, WE WILL CHECK IF      *\n* THE ENTRY ID, OR MESSAGE ID WAS SPECIFIED. THE MESSAGE MUST PASS    *\n* ALL TESTS BEFORE ACTUALLY BEING PRINTED.                            *\n***********************************************************************\nPRETEST1 DS    0H\n         TM    FLAGS,X'80'            WAS MESSAGE SPECIFIED ?\n         BNO   PRETEST2               NO, GO AND CHECK ENTRY ID.\n*\nCHECKMSG DS    0H\n         L     R1,LMSGID              GET LENGTH OF MESSAGE ID\n         BCTR  R1,0\n         EX    R1,COMMSGID\n         BE    PRETEST2\n         OI    FLAGS,X'04'            REMEMBER MSGID SPOTTED\n         B     AR7\nCOMMSGID CLC   AOFMSGID(0),MSGSPEC   IS THIS THE MESSAGE DESIRED ?\nAR7      DS    0H\n         BNE   NEXTREC                NO, GO SEEK NEXT RECORD.\n*\nPRETEST2 DS    0H\n         TM    FLAGS,X'20'            WAS ENTRY SPECIFIED ?\n         BNO   PRETEST3\n         L     R1,LENTID              GET LENGTH OF ENTRY ID\n         BCTR  R1,0\n         EX    R1,COMPEID\n         BNE   NEXTREC\n         OI    FLAGS,X'08'\n         B     ARD6\nCOMPEID  CLC   AOFENTR(0),ENTSPEC     IS THIS THE RIGHT ENTRY ?\nARD6     DS    0H\n*\nPRETEST3 DS    0H\n*\n         B     PRTMSG                 GO GET NEXT RECORD\nPRTMSG   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         LH    R1,AOFNTRCT           PICK UP RECORD ID.\n         CALL  JCECVTBD\n         STCM  R1,B'1111',LINE0+14\n*\n         MVC   LINE0+32(8),AOFENTR  AND GET THE ENTRY NAME.\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE0H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         MVC   LINE1+12(8),AOFMSGID  MOVE IN MESSAGE ID.\n         MVC   LINE1+30(8),AOFACTN   MOVE IN ACTION CODE.\n         CLC   AOFECHO,=CL2'YE'      ECHO= YES SPECIFIED ?\n         BE    ECHOYES\n         CLC   AOFECHO,=CL2'NO'      ECHO= NO SPECIFIED ?\n         BE    ECHONO\n         CLC   AOFECHO,=CL2'LO'      ECHO=LOG SPECIFIED ?\n         BE    ECHOLOG\nECHOYES  DS    0H\n         MVC   LINE1+46(3),=CL3'YES'\n         B     ENDECHO\nECHONO   DS    0H\n         MVC   LINE1+46(3),=CL3'NO'\n         B     ENDECHO\nECHOLOG  DS    0H\n         MVC   LINE1+46(3),=CL3'LOG'\n         B     ENDECHO\nENDECHO  DS    0H\nPROCMTCH DS    0H\n         L     R1,AOFMLIM            PICK UP MATCHLIM VALUE...\n         C     R1,=F'999999'         ANY SPECIFIED ?\n         BE    DEFMLIM               DEFAULT MATCHLIM USED.\n         CALL  JCECVTBD\n         STCM  R1,B'1111',LINE1+60   PUT LIMIT OUT ...\n         B     ENDMLIM\nDEFMLIM  DS    0H\n         MVC   LINE1+60(4),=CL4'NONE'\n         B     ENDMLIM\nENDMLIM  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   LINE2+13(67),BLANK       BLANK OUT ACTION TEXT\n         LH    R3,AOFACTL            LOAD UP ACTION TEXT LENGTH\n         LTR   R3,R3                 IS THERE ANY ?\n         BNZ   LOADATEX              YUP, LOAD UP ACTION TEXT\n         MVC   LINE2+13(22),=CL22'*** NO ACTION TEXT ***'\n         B     GOTATEXT\nLOADATEX DS    0H\n         BCTR  R3,0                  FOR EXECUTE\n         EX    R3,MOVATEXT           MOVE THE ACTION TEXT\n         B     ARD5\nMOVATEXT MVC   LINE2+13(0),AOFACT    ** EXECUTED **\nARD5     DS    0H\nGOTATEXT DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS),TERMPUT=(EDIT)\n         L     R3,AOFTESTP\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nCHKPOST  DS    0H\n***********************************************************************\n* SINCE THE ACTION=POST FUNCTION MAY OCCASIONALLY SEE DYNAMIC         *\n* ALTERATION OF THE AOF TABLE OCCURING, LETS CHECK ITS STATUS, AND    *\n* DISPLAY IF ANYONE IS USING IT.                                      *\n***********************************************************************\n         CLC   AOFACTN,=CL8'POST'     ACTION=POST SPECIFIED ?\n         BNE   PSTPOST\n         TM    AOFPFLG,AOFP1WT        IS THIS ENTRY ACTIVE ?\n         BNO   PSTPOST\n*\n         MVC   LINE6+9(8),AOFENTR     MOVE IN THE ENTRY ID\n*\n         L     R1,AOFPASCB            GET THE ASCB.\n         CALL  JCECVTBH\n         STCM  R0,B'1111',LINE6+46\n         STCM  R1,B'1111',LINE6+50\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nPSTPOST  DS    0H\n***********************************************************************\n* NOW, WE MUST START HANDLING THE TEST ENTRY CASES. ANY NUMBER OF\n* TEST ENTRIES MAY HAVE BEEN SPECIFIED. THE FIRST IS POINTED TO BY\n* 20(R2) IN THE MSGID MAIN CONTROL BLOCK. SUBSEQUENT TEST PARMS ARE\n* POINTED TO BY THE FIRST WORD IN EACH TEST PARAMETER CONTROL BLOCK.\n* R3 WILL POINT TO THE TEST CONTROL BLOCK\n********************************************************************\n         USING ATSNTRY,R3\n         TM    FLAGS,X'10'       TEST SPECIFIED ?\n         BNO   NEXTREC           NOPE, FORGET ALL TEST CONDITIONS\nTLOOP    DS    0H\n         LTR   R3,R3             ANY ADDITIONAL TEST ENTRIES ?\n         BZ    ENDTESTS\n         L     R1,ATSWORD        LOAD SUBSTR OR WORD NUMBER\n         ST    R1,WORD1          TUCK AWAY\n         L     R1,ATSLNGTH       LOAD LENGTH\n         ST    R1,WORD2          TUCK AWAY\n         MVC   WORDSEPS(4),14(R3) TUCK SEPARATORS AWAY, JUST IN CASE.\n         CLI   ATSTYPE,C'W'      WORD TYPE ?\n         BE    WORDTYPE          HANDLE IT\n         CLI   ATSTYPE,C'S'      SUBSTRING TYPE ?\n         BE    SUBSTYPE          HANDLE IT\n         CLC   ATSTYPE,=CL2'L'   LINE NUMBER TYPE?\n         BE    LINETYPE          HANDLE IT\n********************************************************************\n* HERE, IT IS OF UNKNOWN TYPE. BEAR UP UNDER THE PRESSURE, AND\n* INFORM USER. THIS SHOULD NEVER HAPPEN.\n********************************************************************\n         MVC   LINE3W(80),=CL80'*** UNKNOWN TEST TYPE ***'\n         B     WORDTYPE          PRINT THE ERROR MESSAGE.\n         EJECT ,\nLINETYPE DS    0H                  SHOW LINE NUMBER TEST\n         L     R1,WORD1            GET LINE NUMBER\n         CALL  JCECVTBD            CONVERT\n         STCM  R1,B'0111',LINE3L+21 PUT INTO TEXT\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3LH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         L     R3,ATSNXT           POINT TO NEXT TEST\n         B     TLOOP               GO AROUND FOR MORE TESTS\n         SPACE 1\nWORDTYPE DS    0H\n         L     R1,WORD1          GET WORD NUMBER\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3W+12\n         L     R1,WORD2          LOAD LENGTH\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3W+27\n         MVC   LINE3W+44(4),WORDSEPS     MOVE IN SEPARATORS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3WH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     MATCHTEX\nSUBSTYPE DS    0H\n         L     R1,WORD1          GET SUBSTRING START\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0111',LINE3S+22\n         L     R1,WORD2          LOAD LENGTH\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3S+38\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3SH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     MATCHTEX\n********************************************************************\n* NEXT, GO AND FORMAT THE MATCH STRING- IE THE STRING THAT TSSO/AOF\n* WILL BE MATCHING AGAINST.\n********************************************************************\nMATCHTEX DS    0H\n         MVC   LINE4+12(80),BLANK       BLANK OUT MATCHING TEXT.\n         MVC   LINE4(12),LINE4M      USUALLY WE MATCH\n         CLI   ATSTYPE+1,C'X'        BUT DO WE WANT TO EXCLUDE?\n         BNE   *+4+6                 NO, LEAVE IT AS A MATCH\n         MVC   LINE4(12),LINE4X      YES, MODIFY TEXT\n         LH    R4,ATSTXTL            GET LENGTH OF MATCHING TEXT\n         BCTR  R4,0\n         EX    R4,MOVEMTEX           MOVE THE MATCHING TEXT\n         B     ARD4\nMOVEMTEX MVC   LINE4+12(0),ATSTXT    ** EXECUTED **\nARD4     DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n********************************************************************\n* NOW, LOOP BACK TO GET THE NEXT TEST ENTRY.\n********************************************************************\n         MVI   LINE4+12,X'40'\n         MVC   LINE4+13(117),LINE4+12\n         L     R3,ATSNXT             GET ADDRESS OF NEXT ENTRY\n         MVC   LINE4(12),=CL12'MATCH TEXT:'\n         MVI   STARS,C'-'\n         MVC   STARS+1(79),STARS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(STARSH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     TLOOP\n         DROP  R3\nENDTESTS DS    0H\n********************************************************************\n* WE GET HERE WHEN THERE ARE NO MORE TEST ENTRIES TO PROCESS.\n* WE MUST PICK UP THE NEXT MESSAGE ID ENTRY, AND WORK ON THAT.\n********************************************************************\n         MVI   STARS,C'*'\n         MVC   STARS+1(79),STARS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(STARSH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nNEXTREC  DS    0H\n         L     R2,AOFNXT             GET NEXT RECORD\n         B     MSGLOOP\n         DROP  R2\n*\nENDRECS  DS    0H\n         TM    FLAGS,X'80'           WAS AN ENTRY ID SPECIFIED ?\n         BNO   NOMSGIDS              NO, DONT WORRY ABOUT IT\n*\n         TM    FLAGS,X'04'           WAS IT FOUND ?\n         BO    MSGSPFND              YUP, DONT WORRY ABOUT IT.\n*\n         MVC   LINE7+11(8),MSGSPEC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nNOMSGIDS DS    0H\nMSGSPFND DS    0H\n*\nCHKENTID DS    0H\n         TM    FLAGS,X'20'           WAS AN ENTRY ID SPECIFIED ?\n         BNO   NOENTID               NO, DONT WORRY ABOUT IT\n*\n         TM    FLAGS,X'08'           WAS IT FOUND ?\n         BO    ENTSPFND              YUP, DONT WORRY ABOUT IT.\n*\n         MVC   LINE5+9(8),ENTSPEC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nENTSPFND DS    0H\nNOENTID  DS    0H\n         L     R1,RECCOUNT\n         CALL  JCECVTBD\n         STCM  R1,B'1111',TRAIL+31\n         PUTLINE PARM=PUTBLOK,OUTPUT=(TRAILH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR1H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR2H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR3   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR3H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR4H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR5H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR6H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nENDPROG  DS    0H\n         MLEAVE\nCORE     DS    CL200            USED BY PARSE ROUTINE\nMSGSPEC  DS    CL8              MESSAGE ID AS SPECIFIED BY USER\nTABSPEC  DC    CL8' '           TABLE NAME SPECIFIED FOR LOAD\nENTSPEC  DS    CL8              ENTRY ID SPECIFIED BY USER\nTABADDR  DS    A                ADDRESS OF AOF TABLE FOR THIS RUN\nLENTID   DS    F                LENGTH OF THE SPECIFIED ENTRY ID\nLMSGID   DS    F                LENGTH OF THE SPECIFIED MSG ID\nWORD1    DS    F                FOR TEST CASES: SUBSTR START, OR WORD\nWORD2    DS    F                FOR TEST CASES: LENGTH\nWORDSEPS DS    CL4              FOR TEST CASES: SEPARATOR CHARS\nRECCOUNT DS    F                TOTAL NUMBER OF MSGID RECORDS\nFLAGS    DC    H'0'\n* FIRST BYTE:\n* X'80' - A MSGID WAS SPECIFIED\n* X'40' - A TABLE NAME WAS SPECIFIED.\n* X'20' - A ENTRY ID WAS SPECIFIED ...\n* X'10' - TEST WAS SPECIFIED...\n* X'08' - ENTRY ID WAS SPECIFIED, AND ACTUALLY FOUND IN THE TABLE.\n* X'04' - MSG   ID WAS SPECIFIED, AND ACTUALLY FOUND IN THE TABLE.\nBLANKH   DC    H'80',H'0'\nBLANK    DC    CL80' '\n*\nSTARSH   DC    H'80',H'0'\nSTARS    DC    80C'*'\n*\nERROR1H  DC    H'80',H'0'\nERROR1T  DC    CL80'A MESSAGE ID MUST BE SPECIFIED- REQUEST ABORTED'\n*\nERROR2H  DC    H'80',H'0'\nERROR2T  DC    CL80'TSSO IS UNABLE TO LOAD THE INSTORAGE VERSION OF THEX\n                TABLE'\n*\nERROR3H  DC    H'80',H'0'\nERROR3T  DC    CL80'LOAD ERROR TRYING TO LOAD THE TSSO TABLE           X\n                     '\n*\nERROR4H  DC    H'80',H'0'\nERROR4T  DC    CL80'THE TABLE LOADED IS NOT A VALID TSSO TABLE         X\n               '\nERROR5H  DC    H'80',H'0'\nERROR5T  DC    CL80'THE TABLE LOADED IS AT AN INCORRECT LEVEL AND MUST X\n               BE REASSEMBLED'\n*\nERROR6H  DC    H'80',H'0'\nERROR6T  DC    CL80'THE TSSO AUTOMATED OPERATIONS FACILITY IS NOT ACTIVX\n               E'\n*\nHEAD0H   DC    H'80',H'0'\nHEAD0    DC    CL80'T S S O  AUTOMATED OPERATIONS FACILITY TABLE DISPLAX\n               Y (VERSION 4.3)'\n*\nHEAD1H   DC    H'80',H'0'\nHEAD1    DC    CL80'TABLE NAME: XXXXXXXX, DATE: XXXXXXXX, TIME: XXXXXXXC\n               X'\n*\nHEAD2H   DC    H'80',H'0'\nHEAD2    DC    CL80'TABLE ID  : XXXXXXXX, VERSION: XXXXXXXX            C\n               '\n*\nLINE0H   DC    H'80',H'0'\nLINE0    DC    CL80'ENTRY NUMBER: XXXX, ENTRY NAME: XXXXXXXX'\n*\nLINE1H   DC    H'80',H'0'\nLINE1    DC    CL80'MESSAGE ID: XXXXXXXX, ACTION: XXXXXXXX, ECHO: XXX ,C\n               MATCHLIM XXXX'\n*\nLINE2H   DC    H'80',H'0'\nLINE2    DC    CL80'ACTION TEXT:                                       C\n                   '\n*\nLINE3LH  DC    H'80',H'0'\nLINE3L   DC    CL80'REQUIRES LINE NUMBER XXX'\n*\nLINE3SH  DC    H'80',H'0'\nLINE3S   DC    CL80'SUBSTRING STARTING AT XXX, FOR LENGTH XX'\n*\nLINE3WH  DC    H'80',H'0'\nLINE3W   DC    CL80'WORD NUMBER XX, FOR LENGTH XX, SEPARATORS: \"XXXX\"'\n*\nLINE4H   DC    H'80',H'0'\nLINE4    DC    CL133'MATCH TEXT:'\nLINE4M   DC    CL12'MATCH TEXT:'\nLINE4X   DC    CL12'NOT MATCH: '\n*\nLINE5H   DC    H'80',H'0'\nLINE5    DC    CL133'ENTRY ID XXXXXXXX IS NOT FOUND IN THE TABLE'\n*\nLINE6H   DC    H'80',H'0'\nLINE6    DC    CL133'ENTRY ID XXXXXXXX IS BEING WAITED FOR BY ASCB XXXXX\n               XXXX'\n*\nLINE7H   DC    H'80',H'0'\nLINE7    DC    CL133'MESSAGE ID XXXXXXXX IS NOT FOUND IN THE TABLE'\n*\nTRAILH   DC    H'80',H'0'\nTRAIL    DC    CL133'TOTAL NUMBER OF TABLE ENTRIES: XXXX'\n*\n*\n********************************************************************\n* THIS IS THE DESCRIPTION OF THE COMMAND SYNTAX, AS PARSE WANTS IT *\n********************************************************************\nDISPARSE IKJPARM\nMSGID    IKJKEYWD\n         IKJNAME 'MSGID',SUBFLD=MSGSUB\nTABLEID  IKJKEYWD\n         IKJNAME 'ALTTAB',SUBFLD=TABSUB\n         IKJNAME 'TABLE',SUBFLD=TABSUB\nTEST     IKJKEYWD\n         IKJNAME 'TEST'\nENTRY    IKJKEYWD\n         IKJNAME 'ENTRY',SUBFLD=ENTSUB\nMSGSUB   IKJSUBF\nMSGSUBID IKJIDENT 'MSG',PROMPT='MSG NUMBER',FIRST=ALPHANUM,            X\n               OTHER=ALPHANUM,ASTERISK,                                X\n               HELP=('AN OS MESSAGE IDENTIFIER - 1-8 CHARACTERS '),    X\n               MAXLNTH=8\nTABSUB   IKJSUBF\nTABSUBID IKJIDENT 'TAB',PROMPT='TABLE NAME',FIRST=ALPHANUM,            X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE TO LOAD BEFORE PROCESSING  '),    X\n               MAXLNTH=8\nENTSUB   IKJSUBF\nENTSUBID IKJIDENT 'ENT',PROMPT='ENTRY IDENTIFIER',FIRST=ALPHANUM,      X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE ENTRY ID')\n         IKJENDP\n         IKJIOPL\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         CVT   DSECT=YES\n         TSSOCVT\n         TAOFNTRY\n         END   DISPAOF\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY DISPAOF(''TSSO V 4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    DISPAOF'\n PUNCH ' NAME     DISPAOF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EF": {"ttr": 29702, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01\\xa2\\x01\\xa2\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 418, "newlines": 418, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE '     E D I T F I L E   ( E F )                '\n************************************************************\n*                                                          *\n*           'EF' TSO COMMAND                               *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN BY. BILL GODFREY, PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. APRIL 26 1977.\n*        DATE UPDATED. SEPTEMBER 10 1980.\n*        DESCRIPTION.\n*            THIS COMMAND STACKS A LIST OF EDIT SUBCOMMANDS TO BE\n*            EXECUTED AGAINST THE DATASET ALLOCATED TO F(EDITFILE).\n*\n*            THE SUBCOMMANDS ARE SPECIFIED AS A LIST IN PARENTHESES,\n*            WITH THE FIRST CHARACTER DEFINING THE DELIMITER THAT\n*            SEPARATES THE SUBCOMMANDS IN THE LIST.\n*\n*            EXAMPLE: ALLOC FI(EDITFILE) DA(ABC.DEF.GHI.DATA) OLD\n*                     EF (,V,FIND /LOAD/ 10,DOWN)\n*                     EF (.V.BOTTOM.INSERT END.SAVE)\n*\n*            IT WAS DESIGNED FOR A SUBSYSTEM THAT ALLOWS TSO COMMANDS\n*            TO BE ENTERED ON A CONSOLE, BUT THE SUBSYSTEM'S DESIGN\n*            REQUIRED ALL SUBCOMMANDS TO BE ON THE SAME LINE AS THE\n*            COMMAND.  THIS REQUIRED RE-TYPING THE EDIT COMMAND AND\n*            THE DATA SET NAME FOR EACH LINE, WHICH WAS TIRESOME AND\n*            DIDN'T LEAVE MUCH ROOM FOR THE SUBCOMMANDS.  THIS COMMAND\n*            BUILDS AN EDIT COMMAND FROM THE DATA SET NAME ALLOCATED\n*            TO THE FILENAME 'EDITFILE', STACKS IT, THEN STACKS THE\n*            SPECIFIED SUBCOMMANDS.\n*\n*            NOTE - INSTALLATIONS THAT HAVE THE PCF PRODUCT CANNOT\n*            USE THE SEMICOLON IN THIS COMMAND, BECAUSE PCF WILL\n*            SEE IT AND STRIP IT OUT BEFORE THIS COMMAND SEES IT.\n         SPACE\n         GBLB  &MVS\n&MVS     SETB  1                   1 - MVS   0 - SVS,MVT\n         SPACE\nEF       START\n         USING *,12\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'EF'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL) SUBPOOL AND LENGTH\n@PROLOG  STM   14,12,12(13)\n         LR    12,15\n         LR    R2,R1\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)\n         ST    1,8(,13)\n         LR    13,1\n         LR    R1,R2               RESTORE CPPL POINTER\n         USING @DATA,R13\n         SPACE 1\n*              IOPL --> STPB --> LSD --> LIST\n         SPACE\n$CPPL    EQU   1\n$IOPL    EQU   7\n$LSD     EQU   9\n         SPACE\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         ST    R15,PTRSTCK         ZERO IKJSTCK ADDRESS\n         LA    $IOPL,MYIOPL\n         LA    R8,MYSTPB\n         SPACE\n         USING CPPL,$CPPL\n         USING IOPL,$IOPL\n         USING LSD,$LSD\n         SPACE\n*                             INITIALIZE THE IOPL\n         L     R2,CPPLUPT\n         ST    R2,IOPLUPT\n         L     R2,CPPLECT\n         ST    R2,IOPLECT\n         LA    R2,MYECB\n         ST    R2,IOPLECB\n*              IOPLIOPB WILL BE INITIALIZED BY THE STACK MACRO\n         SPACE\n*        STPB WILL BE INITIALIZED BY THE STACK MACRO\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n*        L     R0,=A(EFPCL)\n         LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R13,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         AIF   (NOT &MVS).SKIP1\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n.SKIP1   ANOP\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    OKPARSE\n         LA    R15,12\n         B     EXIT\nOKPARSE  EQU   *\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         LA    R2,EFDCBW\n         MVC   0(EFDCBL,R2),EFDCB\n         LA    R15,EXLEF\n         ST    R15,EXLST(,R2)\n         LA    R0,JFCB\n         ST    R0,0(,R15)\n         MVI   0(R15),X'87'\n         SPACE\n         LA    R1,OPEN\n         MVI   0(R1),X'80'\n         SPACE\n         RDJFCB ((R2)),MF=(E,(1))\n         SPACE\n         LTR   R15,R15\n         BZ    OKJFCB\n         LA    R15,12\n         B     EXIT\nOKJFCB   EQU   *\n         SPACE\n*\n*              BUILD THE EDIT COMMAND\n*\n         LA    R15,EDITLINE\n         MVI   0(R15),C' '\n         MVC   1(L'EDITLINE-1,R15),0(R15)\n         MVC   0(4,R15),=C'EDIT'\n         MVI   5(R15),X'7D'\n         MVC   6(44,R15),JFCB\n         LA    R1,6(,R15)\n         LA    R0,44\nDSNLOOP  CLI   0(R1),X'40'\n         BE    DSNEND\n         LA    R1,1(,R1)\n         BCT   R0,DSNLOOP\nDSNEND   CLI   JFCB+44,X'40'       MEMBER NAME PRESENT?\n         BNH   QUOTEND             NO - BRANCH\n         MVI   0(R1),C'('          PARENS AROUND MEMBER\n         LA    R1,1(,R1)\n         LA    R0,44\n         MVC   0(8,R1),JFCB+44     MOVE MEMBER NAME\nMEMLOOP  CLI   0(R1),X'40'\n         BE    MEMEND\n         LA    R1,1(,R1)\n         BCT   R0,MEMLOOP\nMEMEND   MVI   0(R1),C')'          CLOSE PARENS\n         LA    R1,1(,R1)\nQUOTEND  MVI   0(R1),X'7D'\n*                       =C'DATA  OLD NUM   CAPS'\n         MVC   2(20,R1),=C'DATA  OLD           '\n         CLI   NEWKW+1,2\n         BNE   *+10\n         MVC   8(3,R1),=C'NEW'\n         CLI   NONKW+1,2\n         BNE   *+10\n         MVC   12(5,R1),=C'NONUM'\n         CLI   ASISKW+1,2\n         BNE   *+10\n         MVC   18(4,R1),=C'ASIS'\n         LA    R1,22(,R1)\n         SLR   R1,R15              LENGTH IN R1\n         LA    R1,4(,R1)           PLUS PREFIX LENGTH\n         STH   R1,TOTALL           INITIALIZE TOTALL\n         STH   R1,LIST             SET FIRST RECORD PREFIX\n         SLR   R0,R0\n         STH   R0,LIST+2\n         LA    R1,LIST(R1)         POINT TO NEXT RECORD\n         ST    R1,NEXTPTR          SAVE NEXT RECORD ADDRESS\n         SPACE\n*\n*              ISOLATE SUBCOMMANDS\n*\n         LA    R2,SUBCHAIN\n         TM    6(R2),X'80'         PRESENT?\n         BZ    SCX                 NO - BRANCH\n         LH    R5,4(,R2)           GET LENGTH\n         CH    R5,=H'2'            LENGTH AT LEAST 2?\n         BL    SCX                 NO - BRANCH\n         L     R4,0(,R2)           POINT TO STRING\n         MVC   DELIMITR(1),0(R4)   SAVE THE DELIMITER\n         LA    R4,1(,R4)           POINT PAST THE DELIMITER\n         BCTR  R5,0                REDUCE THE LENGTH BY 1\nSCNEXT   L     R6,NEXTPTR\n         LA    R6,4(,R6)\n         SLR   R1,R1\nSCLOOP   CLC   0(1,R4),DELIMITR    DELIMITER?\n         BE    SCSEMI              YES - BRANCH\n         IC    R0,0(,R4)\n         STC   R0,0(,R6)\n         LA    R4,1(,R4)\n         LA    R6,1(,R6)\n         LA    R1,1(,R1)\n         BCT   R5,SCLOOP\nSCSEMI   LTR   R1,R1\n         BZ    SCNULL\n         LA    R1,4(,R1)\n         L     R15,NEXTPTR\n         STH   R1,HALF\n         MVC   0(2,R15),HALF\n         XC    2(2,R15),2(R15)\n         LA    R15,0(R1,R15)\n         ST    R15,NEXTPTR\nSCNULL   LA    R4,1(,R4)\n         LTR   R5,R5\n         BZ    SCX\n         BCT   R5,SCNEXT\nSCX      LA    R14,LIST\n         L     R15,NEXTPTR\n         SLR   R15,R14             GET LENGTH\n         STH   R15,LISTOTLN\n         IKJRLSA MYANS\n         SPACE\n*                             GET AND INITIALIZE THE LSD\n         LH    0,LISTOTLN          GETMAIN FOR LIST\n         A     0,SP78                          AND LSD (16 BYTES)\n         GETMAIN R,LV=(0)\n         LR    $LSD,1\n         LA    R14,16(,1)          REG 14 --> LIST\n         ST    R14,LSDADATA\n         ST    R14,LSDANEXT\n         SR    R14,R14\n         STH   R14,LSDRCLEN\n         LH    R14,LISTOTLN\n         STH   R14,LSDTOTLN\n         SPACE\n         BCTR  R14,0               LENGTH FOR EX\n         EX    R14,MVLIST          MOVE LIST INTO SUBPOOL 78\n         LR    R1,$IOPL\n         SPACE\n         AIF   (NOT &MVS).SKIP2\n         L     R15,16              CVTPTR\n         TM    472(R15),X'80'      IS IKJSTCK IN LPA\n         BNO   *+12                NO, BRANCH TO LOAD\n         L     R15,472(,R15)       YES, LOAD CVTSTCK\n         B     SETSTCK             BRANCH AROUND LOAD\n.SKIP2   ANOP\n         LA    R0,=CL8'IKJSTCK'\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY POINT ADDRESS\n         LA    R15,0(,R15)         ZERO HIGH ORDER BYTE\nSETSTCK  ST    R15,PTRSTCK         SAVE ADDRESS OF IKJSTCK\n         LR    R1,$IOPL            (PTF13) - RESTORE REG1\n         SPACE\n         STACK PARM=(R8),STORAGE=(($LSD),PROCL),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LTR   R15,R15\n         BZ    EXIT0\n         L     R15,PTRSTCK\n         LR    R1,$IOPL\n         STACK PARM=(R8),DELETE=ALL,ENTRY=(15),MF=(E,(1))\n         SPACE\n         LA    0,L'STACKMSG\n         LA    1,STACKMSG\n         TPUT (1),(0),R\n         LA    R15,16\n         B     EXIT\nEXIT0    LA    15,0\nEXIT     LR    R2,R15\n         L     R15,PTRSTCK\n         LTR   R15,R15             WAS IKJSTCK LOADED\n         BNP   EXITX               NO, BRANCH\n         LA    R0,=CL8'IKJSTCK'\n         DELETE EPLOC=(0)\nEXITX    LR    R15,R2              RESTORE RETURN CODE\n         LR    1,13\n         L     0,@SIZE\n         L     13,4(,13)\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE 1\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMVLIST   MVC   16(0,1),LIST        MOVE LIST TO SUBPOOL 78 AFTER LSD\nSTACKMSG DC    CL28'STACK ERROR'\nSP78     DC    0F'0',AL1(78),AL3(16) SUBPOOL 78\nLYSTOTLN DC    0H'0',AL2(LYSTLEN)  T O T A L    L E N G T H\nLYST     DC   AL2(39+4,0),CL39'TERM LINES(26) LINESIZE(73) INPUT(ATTN)'\n*        DC   AL2(XX+4,0),CLXX'ANOTHER COMMAND CAN BE PLACED HERE'\n*        DC   AL2(YY+4,0),CLYY'AND OTHERS. LISTOTLN MAX IS 256'\nLYSTLEN  EQU   *-LYST\n         SPACE\n         PRINT NOGEN\nEFDCB    DCB   DDNAME=EDITFILE,MACRF=(GL),DSORG=PS,EXLST=0\nEFDCBL   EQU   *-EFDCB\n         PRINT GEN\n         SPACE\n         LTORG\nPATCH    DC    4D'0'               PATCH AREA\n         SPACE\nDDNAM    EQU   40                  DCB OFFSET\nEXLST    EQU   36                  DCB OFFSET\nPCLADDR  DC    0D'0'               END MAIN CSECT, BEGIN PCL CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nEFPCL    IKJPARM\nSUBCHAIN IKJPOSIT PSTRING\nNEWKW    IKJKEYWD\n         IKJNAME 'OLD'\n         IKJNAME 'NEW'\nNONKW    IKJKEYWD\n         IKJNAME 'NUM'\n         IKJNAME 'NONUM'\nASISKW   IKJKEYWD\n         IKJNAME 'CAPS'\n         IKJNAME 'ASIS'\n         IKJENDP\n         SPACE\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F\nDOUBLE   DS    D\nHALF     EQU   DOUBLE,2\nLINKAREA DS    2F\nPTRSTCK  DS    F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F\nOPEN     DS    F\nEFDCBW   DS    0D,(EFDCBL)X\nEXLEF    DS    F\nJFCB     DS    0D,176X\nMYIOPL   DS    4F\nMYSTPB   DS    8F\nTOTALL   DS    H\nLISTOTLN DS    H\nDELIMITR DS    C\nNEXTPTR  DS    F\nLIST     DS    0D,F\nEDITLINE DS    CL82       4+1+1+44+10+1+1+5+1+3+1+5+1+4\n         DS    256X\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n         IKJCPPL\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJPPL\n         SPACE 2\n         IKJLSD\n         SPACE 2\n         IKJSTPB\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END EF\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY EF(''V 1.0 (PTF13) &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    EF'\n PUNCH ' NAME     EF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EQUATES": {"ttr": 29955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXASK": {"ttr": 29957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x006\\x006\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "TSSO403"}, "text": "         PROC 0\n         /****************************************************/\n         /* THIS CLIST WILL PROVIDE AN EXAMPLE OF THE OSASK  */\n         /* FACILITY OF TSSO.                                */\n         /****************************************************/\n\n         /* FIRST, FIND OUT IF THE OPERATOR IS READY TO PROCEED */\n         /* SET A TIME LIMIT OF 30 SECONDS...                   */\n         SET REPLYWAIT = 30\n\n         STARTAGN: +\n         OSASK ARE YOU READY TO PROCEED\n\n         IF &REPLY = NOREPLY THEN GOTO TIMEDOUT\n         IF &REPLY = NO THEN GOTO ENDPROG\n         IF &REPLY \u00ac= YES THEN GOTO CONFUSED\n\n         OSASK GREAT ! WHAT TASK(S) ARE YOU TRYING TO PERFORM ?\n\n         /* UP TO 6 ITEMS MAY BE ENTERED ON THE RESPONSE LINE. THE */\n         /* OSASK COMMAND PARSES THE OPERATOR RESPONSE INTO CLIST  */\n         /* VARIABLES. WE WILL LOOP THROUGH, SUPPLYING THE OPERATOR*/\n         /* WITH THE NEEDED ANSWERS.                               */\n\n         IF &REPLY = NOREPLY THEN GOTO TIMEDOUT\n         SET COUNT = &REPLYW\n\n         SET I = 1\n         DO WHILE (&I <= &COUNT)\n\n           SET VAR = &&REPLYW&I       /* GET THE I'TH WORD */\n\n           IF &VAR = IPL THEN LIST 'SYS1.HELPOPER(IPL)'\n           ELSE IF &VAR = SHUTDOWN THEN LIST 'SYS1.HELPOPER(SHUTDOWN)'\n           ELSE IF &VAR = STARTNET THEN LIST 'SYS1.HELPOPER(STARTNET)'\n           /* MANY OTHER ENTRIES MAY BE PLACED HERE ...    */\n           ELSE OSWTO   THERE IS NOT HELP FOR \"&VAR\"\n\n           SET I = &I + 1\n         END\n         GOTO  ENDPROG\n\n         CONFUSED: +\n           OSWTOH ANSWER YES OR NO...\n           GOTO STARTAGN\n\n         TIMEDOUT: +\n           OSWTO HELP FACILITY TIMING OUT - REINVOKE WHEN YOU HAVE MORE\n           OSWTO TIME.\n           GOTO  ENDPROG\n\n         ENDPROG: +\n           OSWTO GOODBYE.\n           EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXCHKSPL": {"ttr": 29959, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00P\\x00P\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 80, "newlines": 80, "modlines": 0, "user": "TSSO403"}, "text": "        PROC 0\n        /***********************************************************/\n        /* THIS CLIST WILL ISSUE A JES2 COMMAND TO DISPLAY TO      */\n        /* SPOOL UTILIZATION. IF THE SPOOL UTILIZATION IS          */\n        /* ABOVE 80%, THE CLIST WILL ISSUE A HILIGHTED MESSAGE     */\n        /* TO THE OPERATOR. OTHERWISE, IT WILL ISSUE AN ORDINARY   */\n        /* MESSAGE INDICATING HOW BUSY THE SPOOL IS. IT UTILIZES   */\n        /* THE COMMAND TRAPPING FACILITIES IN TSSO 4.2             */\n        /*                                                         */\n        /***********************************************************/\n\n        /*************************************************************/\n        /* THE FIRST STEP IS DIRECTING THE OSCMD COMMAND PROCESSOR   */\n        /* TO SEND THE RESPONSE OF THE COMMAND TO CLIST VARIABLES.   */\n        /*************************************************************/\n        SET CMDRESP = CLIST\n\n        /*************************************************************/\n        /* THE NEXT  STEP IS THE SETTING OF MAXCMDOUT. SINCE THE     */\n        /* EXPECTED COMMAND RESPONSE IS 3 LINES, WE SET MAXCMDOUT = 3*/\n        /*************************************************************/\n        SET MAXCMDOUT = 3\n\n\n        /*************************************************************/\n        /* NEXT, WE DECIDE HOW LONG THE CLIST SHOULD WAIT FOR THE    */\n        /* COMMAND. 1 SECOND IS PLENTY FOR THIS JES COMMAND.         */\n        /*************************************************************/\n        SET CMDWAIT = 1\n\n\n        /*************************************************************/\n        /* NOW THAT THE TWO INPUT VARIABLES ARE SET UP, WE WILL      */\n        /* ISSUE THE OSCMD COMMAND. THE RESPONSE WILL BE PLACED IN   */\n        /* CLIST VARIABLES.                                          */\n        /*************************************************************/\n           OSCMD $DSPOOL\n\n        /*************************************************************/\n        /* THE EXPECTED COMMAND RESPONSE LOOKS LIKE THIS.            */\n        /* $DSPOOL                                                   */\n        /* $HASP646 XX PERCENT SPOOL UTILIZATION.\n        /*                                                           */\n        /* NOTE THAT LINE1 IS ALWAYS AN ECHO OF THE ORIGINAL COMMAND */\n        /*************************************************************/\n\n        /*************************************************************/\n        /* IF WE DO NOT GET BACK AT LEAST 2 LINES OF RESPONSE, THEN  */\n        /* AN ERROR HAS OCCURRED. WRITE A MESSAGE TO THE OPERATOR    */\n        /* AND TERMINATE.                                            */\n        /*************************************************************/\n           IF &CMDOUT < 2 THEN +\n           DO\n             OSWTOH PROBLEM WITH THE CHKSPL COMMAND - CONTACT SUPPORT\n             EXIT CODE(12)\n           END\n\n        /*************************************************************/\n        /* ASSUMING EVERYTHING WENT OK WITH THE COMMAND, THE RESPONSE*/\n        /* IS RETURNED IN THE SECOND WORD OF THE SECOND LINE OF THE  */\n        /* MESSAGE. TSSO HAS ALREADY PARSED THE MESSAGE. WE PICK UP  */\n        /* THE UTILIZATION.                                          */\n        /*                                                           */\n        /*************************************************************/\n           SET UTIL = &CMDOUT2W2\n\n\n        /*************************************************************/\n        /* NOW, WE LOOK AT THE SPOOL UTILIZATION, AND DETERMINE IF   */\n        /* IT IS GREATER THE 80%. IF SO, SEND A HILIGHTED MESSAGE.   */\n        /*                                                           */\n        /*************************************************************/\n           IF &UTIL > 80 THEN +\n           DO\n              OSWTOH SPOOL UTILIZATION IS &UTIL - CONTACT JES2 SUPPORT\n           END\n           ELSE +\n           DO\n              OSWTO  SPOOL UTILIZATION IS &UTIL PERCENT.\n           END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXJOBS": {"ttr": 29962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00C\\x00C\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "TSSO403"}, "text": "         PROC 1 JNAME\n        /*************************************************************/\n        /* THIS CLIST WILL DISPLAY ALL JOBS THAT START WITH A GIVEN  */\n        /* CHARACTER STRING. THE STRING IS PASSED TO THE CLIST AS A  */\n        /* PARAMETER. THE CLIST WILL ISSUE A OSCMD $DN, AND SCAN THE */\n        /* OUTPUT FOR JOBS THAT START WITH THE GIVEN STRING.         */\n        /*************************************************************/\n        SET CMDRESP = CLIST\n        SET MAXCMDOUT = 200\n        /*************************************************************/\n        /* WE WISH TO TRAP AS MANY LINES OF OUTPUT AS JES WOULD CARE */\n        /* TO PROVIDE, THEREFORE, SET MAXCMDOUT TO THE MAX - 200     */\n        /*************************************************************/\n\n        SET CMDWAIT = 1\n        /*************************************************************/\n        /* THE JES COMMAND SHOULD ONLY TAKE 1 SECOND OR LESS, SO     */\n        /* SET THE CMDWAIT VARIABLE TO 1.                            */\n        /*************************************************************/\n\n        OSCMD $DN\n        /*************************************************************/\n        /* ISSUE THE $DN JES COMMAND. THIS WILL POPULATE CLIST VARS  */\n        /* WITH THE OUTPUT FROM THIS COMMAND.                        */\n        /*************************************************************/\n\n        /*************************************************************/\n        /* SINCE THE OSCMD COMMAND ALWAYS RETURNS AN ECHO OF THE     */\n        /* COMMAND AS THE FIRST LINE, START WITH THE SECOND LINE.    */\n        /*************************************************************/\n        SET I = 2\n        SET COUNT = 0\n\n        /*************************************************************/\n        /* WE NEED TO LOOP BETWEEN THE SECOND LINE, AND THE \"LAST\"   */\n        /* LINE, CONVIENTLY STORED IN &CMDOUT VARIABLE.              */\n        /*************************************************************/\n        DO WHILE (&I <= &CMDOUT - 1)\n        /*************************************************************/\n        /* NOTE THAT THE $DN RESPONSE INCLUDES THE SPOOL UTILIZATION */\n        /* AS THE LAST LINE. WE WILL IGNORE IT.                      */\n        /*************************************************************/\n\n        SET LJNAME = &LENGTH(&JNAME)\n\n        /*************************************************************/\n        /* THE JOBNAME IS RETURNED IN THE SECOND WORD OF EACH LINE.  */\n        /*************************************************************/\n        SET JESJOB = &&CMDOUT&I.W2\n\n\n        IF &SUBSTR(1:&LJNAME,&JESJOB) = &JNAME THEN +\n        DO\n        /*************************************************************/\n        /* WE HAVE FOUND A JOBNAME THAT STARTS WITH THE JOB. WE WILL */\n        /* DISPLAY THE ENTIRE LINE.                                  */\n        /*************************************************************/\n           SET OUT = &STR(&&CMDOUT&I)\n           WRITE &STR(&OUT)\n           SET COUNT = &COUNT + 1\n        END\n\n        SET I = &I + 1\n        END\n\n        WRITE &COUNT JOBS FOUND.\n        EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXSTVTAM": {"ttr": 29964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00#\\x00#\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "TSSO403"}, "text": "            PROC 0\n        /*************************************************************/\n        /* THIS CLIST WILL START THE ADDRESS SPACES RELATING TO      */\n        /* VTAM. THESE INCLUDE NCCF, VPS AND OMEGAMON. THIS CLIST    */\n        /* IS NORMALLY KICKED OFF AT IPL TIME BY AN AOF TABLE ENTRY  */\n        /* SUCH AS THE FOLLOWING                                     */\n        /*                                                           */\n        /*  TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT=#STRTVTAM         */\n        /*                                                           */\n        /* THE IST020I MESSAGE IS FOR VTAM INITIALIZATION COMPLETED. */\n        /*                                                           */\n        /*                                                           */\n        /*************************************************************/\n        /*************************************************************/\n        /* NOTE THAT WE ARE NOT INTERESTED IN GETTING THE RESPONSE   */\n        /* BACK TO ANY OF THESE MVS COMMANDS. THEREFORE, WE DO NOT   */\n        /* SET THE MAXCMDOUT OR CMDWAIT VARIABLES.                   */\n        /*************************************************************/\n            OSCMD SET CMDRESP = NOWHERE\n            OSCMD $SLOGON1       /* START JES/VTAM CONNECT */\n\n            OSCMD START TSO      /* START TSO              */\n\n            OSCMD START NCCF     /* START NCCF             */\n\n            OSCMD S OMVTAM,PREFIX='OMEGA.V652',APPL=OMR4\n\n\n            OSCMD START GDDMPRT     /* START ADMPRT ADDRESS SPC */\n\n            OSCMD START VPS         /* AND START VPS AS WELL    */\n            OSPAUSE 5                     /* DELAY 5 SECONDS          */\n            OSCMD VARY NET,ACT,ID=VPS     /* AND VARY IN TO VTAM      */\n            OSWTOH IPL0004I NETWORKING ADDRESS SPACES HAVE BEEN\n            OSWTOH IPL0004I (CONT) STARTED.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EYE": {"ttr": 29966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x03\\x00\\x03\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "TSSO403"}, "text": "         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EYECATCH": {"ttr": 29968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         EYECATCH\n***********************************************************************\n* THIS CODE REPRESENTS THE EYECATCHER FOR TSSO MDOULES, AND IS COPIED *\n* INTO EACH EXECUTABLE MODULE.                                        *\n***********************************************************************\n         DC    CL8'&SYSECT'\n         DC    CL8'ASSEMED'\n         DC    CL8'&SYSDATE'\n         DC    CL4' AT '\n         DC    CL8'&SYSTIME'\n         DC    C' TSSO VERSION 4.3 -  '\n         DC    C' COPYRIGHT (C) 1986 BELL COMMUNICATIONS RESEARCH'\n         MEND\n         EYECATCH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FORMAT": {"ttr": 29970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x95\\x00\\x95\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&LAB     FORMAT &STUFF,&TO=,&WKA=\n.* MACRO 'FORMAT' WRITTEN MAY,1975 BY HOWARD GILBERT\n.* FUNCTION -- GENERATE MESSAGE WITH INSERTS FOR OUTPUT\n.* CODE GENERATED IS INLINE AND POTENTIALLY REENTRANT\n.* REGISTER 0 IS USED BY THE EXPANSION OF THIS MACRO\n.* THERE ARE A VARIABLE NUMBER OF POSITONAL OPERANDS, EACH A SUBLIST OF\n.*     THREE ELEMENTS:\n.*          1) THE DATA ELEMENT OR LITERAL. MUST BE A RELOCATABLE\n.*             EXPRESSION OR CHARACTER STRING ENCLOSED IN QUOTES,\n.*             OR A SELF-DEFINING COLUMN SPECIFICATION.\n.*          2) THE DATA TYPE OF THE ELEMENT. MUST BE EXPLICITLY\n.*             DECLARED SO AS TO BE AVAILABEL AT PRE-ASSEMBLY TIME.\n.*               VALID VALUES ARE '1','2','3','4' FOR 1-4 BYTE FIX BIN\n.*                  'A' FOR SYMBOLIC TAG OF CHARACTER DATA.\n.*                  'P' FOR PACKED DECIMAL\n.*                  ''  (NULL) FOR CHARACTER LITERAL AS FIRST ELEMENT\n.*          3) FORMAT OF OUTPUT. OPTIONS INCLUDE:\n.*                  A PICTURE SPECIFICATION OF 'Z','9','$', AND STATIC\n.*                     EDITING CAHRACTERS LIKE '/' AND '.'. VALID FOR\n.*                     1,2,3,4, AND P TYPES.\n.*                  A STRING OF 'X'S SIGNIFYING A HEX FIELD. ONE 'X'\n.*                     FOR EACH HEX DIGIT. VALID TYPES ARE 1,2,3,4.\n.*                  THE CONSTANT LENGTH OF THE REMOTE CHARACTER FIELD\n.*                     FOR TYPE 'A'.\n.*                  (OMITTED FOR LITERAL CONSTANT)\n.* TWO KEYWORD ARGUMENTS ARE REQUIRED.\n.* TO=  SPECIFIES THE TARGET MESSAGE BUFFER. MAY BE A SUBLIST\n.* AND IF IT IS THE SECOND ELEMENT MUST BE A SELF-DEFINING\n.* TERM GIVING THE LENGTHSO THE BUFFER CAN BE CLEARED WITH\n.* BLANKS.\n.* WKA=  SPECIFIES THE WORK AREA. IT MUST BE A 12  BYTE FIELD\n.* STARTING ON A DOUBLE WORD BOUNDARY. IF HEX CONVERSION IS\n.* NOT REQUESTED, AN 8 BYTE FIELD WILL DO. AFTER THE FIRST\n.* MACRO CALL TO FORMAT, THIS KEYWORD MAY BE OMITTED.\n         GBLC  &FMTWKA\n         LCLA  &ARGN,&POSIT,&DIG,&LP\n         LCLC  &CHR\n&ARGN    SETA  1\n&POSIT   SETA  0\n&LAB     DS    0H\n.* CHECK ENTRY CONDITIONS\n         AIF   ('&TO(1)' EQ '').ERROR1\n         AIF   ('&WKA' EQ '' AND '&FMTWKA' EQ '').ERROR2\n         AIF   ('&WKA' EQ '').N0\n&FMTWKA  SETC  '&WKA'         SAVE WORK AREA NAME\n.* NOW WE DECIDE IF THE BUFFER MUST BE BLANKED AND\n.* GENERATE A MVI,MVC COMBINATION TO BLANK IT\n.N0      ANOP\n&CHR     SETC  T'&TO(2)\n         AIF   ('&CHR' EQ 'O').N1\n         MVI   &TO(1),C' '\n         MVC   &TO(1)+1(&TO(2)-1),&TO(1)\n.N1      AIF   ('&SYSLIST(&ARGN,1)' EQ '').ENDER\n.* NOW BASED ON THE TYPE DECLARATION WE PROVIDE UNIFORM\n.* STATUS FOR VARIOUS VALUES. FOR 1,2,3 OR 4 THE VALUE IS\n.* LOADED IN R0 BY IC,ICM,LH,L.\n         AIF   ('&SYSLIST(&ARGN,2)' NE '1').N2\n         SR    0,0\n         IC    0,&SYSLIST(&ARGN,1)\n         AGO   .CVD\n.N2      AIF   ('&SYSLIST(&ARGN,2)' NE '2').N3\n         AIF   ('&SYSLIST(&ARGN,3)'(1,1) NE 'X').N25\n         SR    0,0\n         ICM   0,B'0011',&SYSLIST(&ARGN,1)\n         AGO   .CVD\n.N25     LH    0,&SYSLIST(&ARGN,1)\n         AGO   .CVD\n.N3      AIF   ('&SYSLIST(&ARGN,2)' NE '3').N4\n         SR    0,0\n         ICM   0,B'0111',&SYSLIST(&ARGN,1)\n         AGO   .CVD\n.N4      AIF   ('&SYSLIST(&ARGN,2)' NE '4').N5\n         ICM   0,15,&SYSLIST(&ARGN,1)\n         AGO   .CVD\n.* PACKED DECIMAL FIELDS ARE PROCESSED SEPARATELY.\n.N5      AIF   ('&SYSLIST(&ARGN,2)' NE 'P').N6\n         EDIT  FROM=&SYSLIST(&ARGN,1),TO=&TO(1)+&POSIT,MASK=' &SYSLIST(X\n               &ARGN,3)'\n&POSIT   SETA  &POSIT+K'&SYSLIST(&ARGN,3)+1\n         AGO   .NXT\n.* REMOTE CHARACTER DATA IS MOVED INTO THE BUFFER WITH A MVC\n.N6      AIF   ('&SYSLIST(&ARGN,2)' NE 'A').N7\n         MVC   &TO(1)+&POSIT.(&SYSLIST(&ARGN,3)),&SYSLIST(&ARGN,1)\n&POSIT   SETA  &POSIT+&SYSLIST(&ARGN,3)\n         AGO   .NXT\n.* THE NEXT BLOCK HANDLES THE NON SUBLIST ELEMENTS, EITHER\n.* QUOTED TEXT OR COLUMN TAB SPECIFICATIONS\n.N7      AIF   ('&SYSLIST(&ARGN,2)' NE '').ERROR3\n         AIF   (T'&SYSLIST(&ARGN,1) NE 'N').N75\n.* TAB SPECIFICATION SIMPLY BUMP THE CURRENT VALUE OF POSIT,\n.* THE POSITION-REMEMBERING VARIABLE\n&POSIT   SETA  &SYSLIST(&ARGN,1)\n         AGO   .NXT\n.N75     ANOP\n.* CHARACTER LITERAL DATA IS CONVERTED TO AN ASSEMBLER LITERAL\n.* NOTATION AMD MOVED INTO THE BUFFER\n         AIF   (K'&SYSLIST(&ARGN,1) NE 3).N8\n         MVI   &TO(1)+&POSIT,C&SYSLIST(&ARGN,1)\n&POSIT   SETA  &POSIT+1\n         AGO   .NXT\n.N8      ANOP\n&LP      SETA  K'&SYSLIST(&ARGN,1)-2\n         MVC   &TO(1)+&POSIT.(&LP),=C&SYSLIST(&ARGN,1)\n&POSIT   SETA  &POSIT+K'&SYSLIST(&ARGN,1)-2\n         AGO   .NXT\n.CVD     AIF   ('&SYSLIST(&ARGN,3)'(1,1) EQ 'X').HEX\n.* THE FOLLOWING  CODE HANDLES THE OUTPUT OF 1,2,3 OR 4 TYPE\n.* DATA ACCORDING TO A PICTURE FORMAT.\n         CVD   0,&FMTWKA\n.* THE EDIT MACRO WILL CONVERT DATA FROM LEFT TO RIGHT.\n.* TO GET GOOD OUTPUT, AN OFFSET MUST BE ADDED TO THE\n.* ADDRESS OF &WKA SO THE OUTPUT WILL CONTAIN THE RIGHTMOST\n.* DIGITS. THIS LOOP COUNTS UP DIGIT SELECTORS IN THE FORMAT\n.* TO CALCULATE THE OFFSET.\n&DIG     SETA  0\n&LP      SETA  1\n.LOP     ANOP\n&CHR     SETC  '&SYSLIST(&ARGN,3)'(&LP,1)\n         AIF   ('&CHR' NE '9' AND '&CHR' NE 'Z' AND '&CHR' NE '$').N10\n&DIG     SETA  &DIG+1\n.N10     ANOP\n&LP      SETA  &LP+1\n         AIF   (&LP LE K'&SYSLIST(&ARGN,3)).LOP\n.* END OF LOOP\n&DIG     SETA  &DIG/2+1\n         EDIT  TO=&TO(1)+&POSIT,FROM=&FMTWKA+8-&DIG,MASK=' &SYSLIST(&ARX\n               GN,3)'\n&POSIT   SETA  &POSIT+K'&SYSLIST(&ARGN,3)+1\n         AGO   .NXT\n.* THE FOLLOWING CODE HANDLES THE CONVERSION TO HEX.\n.* IT FOLLOWS THE USUAL SORT OF CUTE TIRCKS\n.HEX     ST    0,&FMTWKA+8\n         UNPK  &FMTWKA.(7),&FMTWKA+8(4)\n         MVC   &FMTWKA+7(1),&FMTWKA+11\n         NC    &FMTWKA.(8),=X'0F0F0F0F0F0F0F0F'\n         TR    &FMTWKA.(8),=C'0123456789ABCDEF'\n&LP      SETA  K'&SYSLIST(&ARGN,3)\n         MVC   &TO(1)+&POSIT.(&LP),&FMTWKA+8-&LP\n&POSIT   SETA  &POSIT+K'&SYSLIST(&ARGN,3)\n.NXT     ANOP\n&ARGN    SETA  &ARGN+1\n         AGO   .N1\n.ERROR1  MNOTE 8,'NO ''TO'' STRING'\n         MEXIT\n.ERROR2  MNOTE 8,'NO WORK AREA PROVIDED'\n         MEXIT\n.ERROR3  MNOTE 8,'INVALID ITEM FORMAT &SYSLIST(&ARGN,2)'\n.ENDER   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GENMTAPE": {"ttr": 29974, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x12\\x00\\x12\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "TSSO403"}, "text": "//COPYTSSO JOB (3225,P136),'M. SCHARE',CLASS=S,\n// NOTIFY=TSO67,MSGCLASS=F\n/*XEQ PYFPROD\n/*ROUTE PRINT PYFPROD\n//********************************************************************//\n//*                                                                  *//\n//*  THIS JOB WILL COPY THE TSSO SUBSYSTEM TO TAPE.                  *//\n//*  IT USES THE BELLCORE MASTER DISTRIBUTION LIBRARY.               *//\n//********************************************************************//\n//IEBCOPY EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//INDD     DD DSN=TSSO.DISTRIB.VERS43.ASM,DISP=SHR\n//OUTDD    DD DSN=TSSO.VERS43.ASM,DISP=(NEW,KEEP,DELETE),\n//         UNIT=TAPE3420,LABEL=(1,NL,EXPDT=98000),\n//         VOL=SER=TSSO43\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n  COPY OUTDD=OUTDD,INDD=INDD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GENTAPE": {"ttr": 30209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x12\\x00\\x12\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "TSSO403"}, "text": "//COPYTSSO JOB (3225,P136),'M. SCHARE',CLASS=S,\n// NOTIFY=TSO67,MSGCLASS=F\n/*XEQ PYSPROD\n/*ROUTE PRINT PYSPROD\n//********************************************************************//\n//*                                                                  *//\n//*  THIS JOB WILL COPY THE TSSO SUBSYSTEM TO TAPE.                  *//\n//*                                                                  *//\n//********************************************************************//\n//IEBCOPY EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//INDD     DD DSN=TSSO.VERS43.ASM,DISP=SHR\n//OUTDD    DD DSN=TSSO.VERS43.ASM,DISP=(NEW,KEEP,DELETE),\n//         UNIT=3480,LABEL=(1,NL,EXPDT=98000),\n//         VOL=SER=TSSO43\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(10,10))\n  COPY OUTDD=OUTDD,INDD=INDD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETCVT": {"ttr": 30211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x966_\\x00\\x97\\x00?\\t5\\x00@\\x00@\\x00\\x03\\xd9\\xd7\\xe2\\xf1@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1997-01-03T09:35:00", "lines": 64, "newlines": 64, "modlines": 3, "user": "RPS1"}, "text": "**********************************************************************\n* THIS MACRO WILL RETURN THE TSSO COMMUNICIATIONS VECTOR TABLE\n* METHOD OF OPERATION:\n*  1) SCAN THE SUBSYSTEM VECTOR TABLE FOR TSSO\n*  2) IF NOT FOUND, RC = 12 AND EXIT\n*  3) IF FOUND, RETURN IN SPECIFIED REGISTER AND EXIT WITH RC = 0\n*\n*  NOTE THAT THE ADDRESS OF THE TSSO CVT IS STORE IN THE SSCTSUSE\n*  FIELD FOR THE TSSO SSUBSYSTEM\n*\n*\n* CHANGE LOG:\n*\n* 1/3/86 - DELETE USING STATEMENT - TSSO MODULES MUST ISSUE OWN USING\n* 2/21/86 - AND SSCT PARAMETER TO GET ADDRESSABILITY TO SSCT IF\n*           DESIRED, AND NDSA PARAMETER FOR SAME REASON\n**********************************************************************\n         MACRO\n&LABEL   GETCVT &R,&TSSOCVT=YES,&POINTER=NO,&SSCT=NO,&NDSA=NO\n         L     &R,16(0,0)                                       RPS\n         L     &R,CVTJESCT-CVT&R                                RPS\n         L     &R,JESSSCT-JESCT&R   POINT TO HEAD OF SSCT       RPS\n         USING SSCT,&R\nSRCH&SYSNDX DS 0H\n         L     &R,SSCTSCTA                 POINT TO NEXT ONE\n         LTR   &R,&R\n         BZ    NOTF&SYSNDX\n         CLC   SSCTSNAM-SSCT(4,&R),=CL4'TSSO'   IS THIS ONE TSSO RPS\n         BE    FOUND&SYSNDX\n         B     SRCH&SYSNDX\nNOTF&SYSNDX DS  0H\n         XR    R15,R15\n         LA    R15,12             SET BAD RETURN CODE\n         B     DONE&SYSNDX\nFOUND&SYSNDX DS  0H\n         AIF   ('&SSCT' EQ 'YES').GOTOSSCT\n         AIF   ('&POINTER' EQ 'YES').CVTPTR\n         AIF   ('&NDSA' EQ 'YES').GETNDSA\n         AIF   ('&TSSOCVT' EQ 'YES').GETCVT\n         AGO   .BADPARM\n.*\n.GETCVT  ANOP\n         L     &R,SSCTSUSE        LOAD UP TSSO CVT FIELD\n         AGO   .SETRC\n.*\n.GETNDSA ANOP\n         L     &R,SSCTSUS2        LOAD UP TSSO NDSA ...\n         AGO   .SETRC\n.*\n.CVTPTR  ANOP\n         LA    &R,SSCTSUSE        POINT TO TSSO CVT FIELD\n         AGO   .SETRC\n.GOTOSSCT ANOP\n.* WE HAVE RETRIVED THE SSCT - LET US EXIT.\n         AGO   .SETRC\n.SETRC   ANOP\n         XR    R15,R15            SET RETURN CODE\n         B     DONE&SYSNDX\nDONE&SYSNDX DS  0H\n         AGO   .MACEND\n.BADPARM ANOP\n         MNOTE 12,'BAD PARAMETER ON GETCVT MACRO'\n.MACEND  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISXA": {"ttr": 30213, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x17\\x00\\x17\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&LOCLBL  ISXA &XA=,&S370=\n.*                                                                   *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n.*                                                                   *.\n.*  ISXA           IDENTIFY WHETHER OR NOT MVS/SP2 IS BEING USED     *.\n.*                                                                   *.\n.*                 TAKES A BRANCH DEPENDING ON WHICH PARMS ARE       *.\n.*                 SPECIFIED                                         *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n         AIF   ('&XA' EQ '' AND '&S370' EQ '').ERR\n&LOCLBL  L     14,16                   REG &R --> REAL CVT\n         TM    116(14),X'80'       TEST THE BIT\n         AIF   ('&XA' EQ '').GEN370\n         BO    &XA\n.GEN370  ANOP\n         AIF   ('&S370' EQ '').EXIT\n         BZ    &S370\n         AGO   .EXIT\n.EXIT    ANOP\n         MEXIT\n.ERR     MNOTE 8,'*** ISXA ERROR, MUST SPECIFY XA OR S370 '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCECVT": {"ttr": 30215, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01\\xbe\\x01\\xbe\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 446, "newlines": 446, "modlines": 0, "user": "TSSO403"}, "text": "JCECVT    TITLE 'TSSO CONVERT ROUTINES'\n*.\n* MODULE NAME -\n*\n*         JCECVT\n*\n* CONTENTS -\n*\n*         JCECVTBH - BINARY TO EBCDIC HEX\n*         JCECVTHB - EBCDIC HEX TO BINARY\n*         JCECVTDB - EBCDIC DECIMAL TO BINARY\n*         JCECVTBD - BINARY TO EBCDIC DECIMAL\n*         JCECVTGT - EXTRACT SYSTEM TIME IN PRINTABLE FORMAT\n*         JCECVTGD - EXTRACT SYSTEM DATE IN JULIAN   FORMAT\n*.\n*. ***************************************************************\n*. ON ENTRY TO THIS ROUTINE, REGISTER 10 MUST POINT TO A 200 BYTE*\n*. WORKAREA, WHICH MUST BE PROVIDED BY THE CALLER !              *\n*. ***************************************************************\n          EJECT\nJCECVT    CSECT\n          SPACE 2\n          ENTRY JCECVTBH\n          ENTRY JCECVTHB\n          ENTRY JCECVTBD\n          ENTRY JCECVTDB\n          ENTRY JCECVTGT\n          ENTRY JCECVTGD\n          SPACE 3\n          EQUATES\n          EJECT\n*.\n* SUBROUTINE NAME -\n*\n*         JCECVTBH\n*\n* FUNCTION -\n*\n*         CONVERTS A WORD OF BINARY INFORMATION INTO A DOUBLE-\n*         WORD OF EBCDIC HEX DIGITS\n*\n* ATTRIBUTES -\n*\n*         SERIALLY REUSABLE, RESIDENT, CALLED VIA BALR\n*\n* ENTRY POINT -\n*\n*         JCECVTBH - CONVERT BINARY TO EBCDIC HEX\n*\n* ENTRY CONDITIONS -\n*\n*         GPR1 = WORD OF BINARY INFORMATION TO BE CONVERTED\n*         GPR15 = BASE ADDRESS\n*\n* EXIT CONDITIONS -\n*\n*         GPR0, GPR1 = DOUBLEWORD OF EBCDIC HEX DIGITS\n*\n* CALLS TO OTHER ROUTINES -\n*\n*         NONE\n*\n* EXTERNAL REFERENCES -\n*\n*         NONE\n*\n* TABLES / WORK AREAS -\n*\n*         TEMPSAVE\n*\n* REGISTER USAGE -\n*\n*         GPR14 = RETURN REGISTER\n*         GPR15 = BASE REGISTER\n*\n*         GPR0, GPR1 = WORK REGISTERS\n*\n*         ALL OTHER REGISTERS ARE NOT USED\n*\n* NOTES -\n*\n*         NONE\n*\n          EJECT\n* OPERATION -\n*\n*         1. UNPACK BINARY INFORMATION.\n*         2. TRANSLATE TO HEX EBCDIC DIGITS.\n*\n*.\n          SPACE 3\nJCECVTBH DS     0H\n          USING *,R15\n          USING DATD,R10\n          ST    R1,TEMPSAVE    BINARY\n          UNPK  TEMPSAVE+8(9),TEMPSAVE(5)     UNPACK\n          TR    TEMPSAVE+8(8),TRTAB\n          LM    R0,R1,TEMPSAVE+8    RETURN VALUE IN R0 AND R1\n          BR    R14            RETURN\n          DROP  R15,R10\n          EJECT\n*.\n* SUBROUTINE NAME -\n*\n*         JCECVTHB\n*\n* FUNCTION -\n*\n*         CONVERTS THE EBCDIC HEX FIELD DESIGNATED TO A FULL WORD\n*         OF BINARY\n*\n* ATTRIBUTES -\n*\n*         SERIALLY REUSABLE, RESIDENT, CALLED VIA BALR\n*\n* ENTRY POINTS -\n*\n*         JCECVTHB - CONVERT EBCDIC HEX TO BINARY\n*\n* ENTRY CONDITIONS -\n*\n*         GPR0 = LENGTH OF FIELD\n*         GPR1 = ADDRESS OF THE FIRST BYTE OF THE FIELD\n*\n* EXIT CONDITIONS -\n*\n*         GPR1 = FULL WORD OF BINARY; IF ERROR GPR1 = 0\n*\n*         CC = 0; IF ERROR CC \u00ac= 0\n*\n* CALLS TO OTHER ROUTINES -\n*\n*         NONE\n*\n* EXTERNAL REFERENCES -\n*\n*         NONE\n*\n* TABLES / WORK AREAS -\n*\n*         BALRSAVE\n*\n* REGISTER USAGE -\n*\n*         GPR14 = RETURN REGISTER\n*         GPR15 = BASE REGISTER\n*\n*         GPR0, GPR1, GPR2, GPR3 = WORK REGISTERS\n*\n*         ALL OTHER REGISTERS ARE NOT USED\n*\n* NOTES -\n*\n*         NONE\n*\n          EJECT\n* OPERATION -\n*\n*         1. SAVE REGISTERS.\n*         2. GET NEXT EBCDIC HEX DIGIT.\n*         3. IF DIGIT GREATER THAN \"0\" AND LESS THAN \"9\" SUBTRACT X'F0'\n*            OTHERWISE IF GREATER THAN \"A\" SUBTRACT X'B7';\n*            OTHERWISE INDICATE CHARACTER ERROR IN FIELD.\n*         4. ACCUMULATE BINARY DIGITS IN GPR0.\n*         5. LOOP THROUGH ENTIRE FIELD.\n*         6. RESTORE REGISTERS.\n*\n*.\n          SPACE 3\nJCECVTHB  DS     0H\n          USING *,R15\n          USING DATD,R10\n          STM   R0,R3,BALRSAVE SAVE REGISTERS\n          LR    R3,R0          SAVE FIELD LENGTH\n          SR    R2,R2          CLEAR REG\n          LR    R0,R2          ...\nLOOP1     EQU   *\n          IC    R2,0(,R1)      GET DIGIT\n          CLI   0(R1),C'0'     GREATER THAN ZERO?\n          BL    LOOP3          NO  TRY A-F\n          CLI   0(R1),C'9'     GREATER THAN NINE?\n          BH    ERR2           YES  ERROR\n          S     R2,=F'240' (=A(C'0'))  MAKE DIGIT A HEX NUMBER\n          B     LOOP2          CONTINUE\nLOOP3     EQU   *\n          CLI   0(R1),C'A'     LESS THAN \"A\"?\n          BL    ERR2           YES  ERROR\n          CLI   0(R1),C'F'     GREATER THAN \"F\"?\n          BH    ERR2           YES  ERROR\n          SH    R2,=AL2(C'A'-10)    MAKE CHAR A HEX NUMBER\nLOOP2     EQU   *\n          SLL   R0,4           ASSEMBLE NEXT DIGIT\n          AR    R0,R2          ...\n          LA    R1,1(,R1)      BUMP PTR\n          BCT   R3,LOOP1       LOOP THROUGH ENTIRE FIELD\n          ST    R0,BALR1       RETURN RESULT IN R1\n          SR    R0,R0          SET CC=0\n          LM    R0,R3,BALRSAVE RESTORE REGISTERS\n          BR    R14            RETURN\n*\nERR2      DS    0H\n          LM    R0,R3,BALRSAVE RESTORE REGISTERS\n          LA    R1,0           RETURN ZERO WITHOUT DISTURBING CC\n          BR    R14\n          DROP  R15,R10\n        EJECT\n*.\n* SUBROUTINE NAME -\n*\n*         JCECVTDB\n*\n* FUNCTION -\n*\n*         CONVERTS THE EBCDIC DECIMAL FIELD DESIGNATED TO A FULL WORD\n*         OF BINARY\n*\n* ATTRIBUTES -\n*\n*         SERIALLY REUSABLE, RESIDENT, CALLED VIA BALR\n*\n* ENTRY POINTS -\n*\n*         JCECVTDB - CONVERT EBCDIC DECIMAL TO BINARY\n*\n* ENTRY CONDITIONS -\n*\n*         GPR0 = LENGTH OF FIELD\n*         GPR1 = ADDRESS OF THE FIRST BYTE OF THE FIELD\n*\n* EXIT CONDITIONS -\n*\n*         GPR1 = FULL WORD OF BINARY; IF ERROR GPR1 = 0\n*\n*         CC = 0; IF ERROR CC \u00ac= 0\n*\n* CALLS TO OTHER ROUTINES -\n*\n*         NONE\n*\n* EXTERNAL REFERENCES -\n*\n*         NONE\n*\n* TABLES / WORK AREAS -\n*\n*         TEMPSAVE\n*\n* REGISTER USAGE -\n*\n*         GPR14 = RETURN REGISTER\n*         GPR15 = BASE REGISTER\n*\n*         GPR0, GPR1, GPR2 = WORK REGISTERS\n*\n          EJECT\n*         ALL OTHER REGISTERS ARE NOT USED\n*\n* NOTES -\n*\n*         NONE\n*\n* OPERATION -\n*\n*         1. SAVE REGISTERS.\n*         2. IF GPR0 GREATER THAN 10 DIGITS INDICATE ERROR.\n*         3. VALIDITY CHECK ALL EBCDIC DECIMAL DIGITS.\n*         4. PACK FIELD.\n*         5. IF RESULT IS GREATER THAN 2**31-1 INDICATE ERROR.\n*         6. CONVERT RESULT TO BINARY.\n*         7. RESTORE REGISTERS.\n*\n*.\n          SPACE 3\nJCECVTDB  DS     0H\n          USING *,R15\n          USING DATD,R10\n          STM   R1,R2,BALR1    SAVE REGS R1 AND R2\n          C     R0,=F'10'      GREATER THAN 10 DIGITS ?\n          BH    ERR3\n          LR    R2,R0          GET LENGTH OF FIELD\n          BCTR  R2,0           DECREMENT FOR EX\nDECCHK    CLI   0(1),C'0'\n          BL    ERR3\n          CLI   0(1),C'9'\n          BH    ERR3\n          LA    R1,1(,R1)\n          BCT   R0,DECCHK\n          L     R1,BALR1       RESTORE R1\n          EX    R2,PACK        ...\n          CP    TEMPSAVE(8),=PL8'2147483647'  GREATER THAN 2**31-1 ?\n          BH    ERR3           BRANCH IF YES\n          CVB   R1,TEMPSAVE    CONVERT TO BINARY\n          SR    R2,R2          SET CONDITION CODE 0\nERR3      EQU   *\n          L     R2,BALR2       RESTORE R2\n          BR    R14            RETURN\n          SPACE 1\nPACK      PACK  TEMPSAVE(8),0(0,R1) EXECUTED PACK INSTRUCTION\n          SPACE 1\n          DROP  R15,R10\n          EJECT\n*.\n* SUBROUTINE NAME -\n*\n*         JCECVTBD\n*\n* FUNCTION -\n*\n*         CONVERT A WORD OF BINARY INFORMATION INTO A DOUBLE-\n*         WORD OF EBCDIC DECIMAL DIGITS\n*\n* ATTRIBUTES -\n*\n*         SERIALLY REUSABLE, RESIDENT, CALLED VIA BALR\n*\n* ENTRY POINT -\n*\n*         JCECVTBD - CONVERT BINARY TO EBCDIC DECIMAL\n*\n* ENTRY CONDITIONS -\n*\n*         GPR1 = WORD OF BINARY INFORMATION TO BE CONVERTED\n*         GPR0 = 1 IF ZEROES ARE TO BE CONVERTED TO BLANKS\n*\n* EXIT CONDITIONS -\n*\n*         GPR0, GPR1 = DOUBLEWORD OF EBCDIC DECIMAL DIGITS\n*\n* CALLS TO OTHER ROUTINES -\n*\n*         NONE\n*\n* EXTERNAL REFERENCES -\n*\n*         NONE\n*\n* TABLES / WORK AREAS -\n*\n*         TEMPSAVE\n*\n* REGISTER USAGE -\n*\n*         GPR14 = RETURN REGISTER\n*         GPR15 = BASE REGISTER\n*\n*         GPR0, GPR1 = WORK REGISTERS\n*\n*         ALL OTHER REGISTERS ARE NOT USED\n*\n* NOTES -\n*\n*         NONE\n*\n          EJECT\n* OPERATION -\n*\n*         1. CONVERT BINARY INFORMATION TO DECIMAL.\n*         2. UNPACK DECIMAL INFORMATION.\n*         3. SET SIGN TO POSITIVE.\n*\n*.\n          SPACE 3\nJCECVTBD  DS     0H\n          USING *,R15\n          USING DATD,R10\n          STM   R2,R3,BALRSAVE\n          CVD   R1,TEMPSAVE    BINARY TO PACKED DECIMAL\n          UNPK  TEMPSAVE+8(8),TEMPSAVE+3(5)   UNPACK\n          OI    TEMPSAVE+15,X'F0'   MAKE UP FOR HARDWARE DEFICIENCIES\n          C     R0,=F'1'\n          BE    LOADIT\n          LA    R2,7\n          LA    R3,TEMPSAVE+8\nBDLOOP    DS    0H\n          CLI   0(R3),C'0'\n          BNE   BDNEXT\n          MVI   0(R3),C' '\n          LA    R3,1(R3)\nBDNEXT    BCT   R2,BDLOOP\nLOADIT    DS    0H\n          LM    R0,R1,TEMPSAVE+8    RETURN VALUE IN R0 AND R1\n          LM    R2,R3,BALRSAVE\n          BR    R14            RETURN\n          DROP  R15,R10\n*\n*\nJCECVTGT DS    0H\n***********************************************************************\n* THIS ROUTINE WILL RETURN THE TIME IN EBCIDIC FORMAT IN REGISTERS\n* R0 AND R1. THE CALLING SEQUENCE IS SIMPLY A CALL JCECVTGT\n***********************************************************************\n         USING *,R15\n         USING DATD,R10\n         ST    R15,SAVE15\n         TIME  DEC\n         L     R15,SAVE15              RELOAD R15\n         ST    R0,PDATA                STORE THE TIME\n         MVI   RETTIME,C' '            BLANK OUT RETURN\n         MVC   RETTIME+1(7),RETTIME        FIELD\n         MVC   RETTIME(8),TIMEPAT      MOVE IN PATTERN FOR TIME\n         ED    RETTIME(8),PDATA        AND EDIT THE TIME\n         LM    R0,R1,RETTIME           RETURN RESULTS\n         BR    14                      RETURN\n         DROP  R15,R10\nJCECVTGD DS    0H\n***********************************************************************\n* THIS ROUTINE WILL RETURN THE DATE AS AN 8 BYTE EBCIDIC FIELD\n* IN REGISTERS R0 AND R1.\n***********************************************************************\n         USING *,R15                   ADDRESS THE ROUTINE\n         USING DATD,R10\n         ST    R15,SAVE15              SAVE BASE\n         TIME  DEC                     GET TIME\n         L     R15,SAVE15              RELOAD BASE\n         ST    R1,PDATA                SAVE RESULTS\n         MVI   RETDATE,C' '             BLANK OUT DATE FIELD\n         MVC   RETDATE+1(7),RETDATE\n         MVC   RETDATE(9),DATEPAT       MOVE IN PATTERN\n         ED    RETDATE(9),PDATA         EDIT DATE INTO PATTERN\n         MVI   RETDATE,C' '             BLANK OUT BYTE 1 OF RESULTS\n         MVI   RETDATE+1,C' '             \"    \"    \"  2 OF RESULTS\n         LM    R0,R1,RETDATE            RETURN WITH ANSWER\n         BR    R14\n         DROP  R15,R10\n          LTORG\n          EJECT\nTRTAB     DC    CL240' '\n          DC    CL16'0123456789ABCDEF'      FOR TRANSLATES\nTIMEPAT   DC    XL8'20207A20207A2020'\nDATEPAT   DC    XL9'202021204B20202040'\nDATD      DSECT\nBALR1     EQU   BALRSAVE+4\nBALR2     EQU   BALRSAVE+8\nTEMPSAVE  DS    2D\nBALRSAVE  DS    18F\nSAVE15   DS    F\nPDATA    DS    D\nRETTIME  DS    CL8\nRETDATE  DS    CL8\nWKA      DS    2D\n          END\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY JCECVT(''V 2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    JCECVT'\n PUNCH ' NAME     JCECVT(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINKLIST": {"ttr": 30465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x004\\x004\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "TSSO403"}, "text": "LINKLIST MENTER 12,EQU,CP=CP,COM=LINKLIST\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n********************************************************************\n* THIS IS THE LINKLIST COMMAND PROCESSOR. AS OF MVS/XA 2.1.1, THE  *\n* MVS LINKLIST LIBRARIES HAVE BEEN CHAINED OFF THE CVT. THIS       *\n* COMMAND SIMPLY RUNS DOWN THE CHAIN...                            *\n********************************************************************\n         L     R2,16\n         USING CVT,R2\n         L     R3,X'4DC'(R2)      GET ADDRESS OF CVTLLTA\n*                                 ON NON-XA, WOULD BE GARBAGE\n         CLC   0(4,R3),=CL4'LLT '\n         BNE   NONXA\n         L     R5,4(R3)           # OF ENTRIES IN LLT\n         LA    R6,8(R3)           STARTING ENTRY\n         SSID\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD,TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\nLOOP     DS    0H\n         MVC   LINE+4(44),1(R6)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE,TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\n         LA    R6,45(R6)\n         BCT   R5,LOOP\n         B     ENDPROG\nNONXA    DS    0H\n* WE COME HERE IF THE CVTLLTA FIELD IS TRASH, OR WE ARE ON AN SP1\n* SYSTEM.\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nENDPROG  DS    0H\n         MLEAVE\nX        DS    F\nWKA      DS    2D\nLINE     DC    H'80',H'0'\n         DC    CL80' '\nHEAD     DC    H'80',H'0'\n         DC    C'LINKLIST DATASETS FOR SYSTEM:'\nSSID    DC    CL80' '\nLINE2H   DC    H'80',H'0'\nLINE2    DC    CL80'CVTLLTA FIELD IS INVALID- YOU ARE PROBABLY RUNNING X\n               ON A NON-XA SYSTEM'\n         IKJIOPL\n         CVT   DSECT=YES\n         END   LINKLIST\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY LINKLIST(''V 2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    LINKLIST'\n PUNCH ' NAME     LINKLIST(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIONRPLY": {"ttr": 30467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x000\\x00\\x99&\\x7f\\x01\\x022\\x1f\\x19S\\x01\\t\\x00\\xff\\x00\\x19\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "2002-11-17T19:53:30", "lines": 265, "newlines": 255, "modlines": 25, "user": "EDJXADM"}, "text": "***********************************************************************\n*                                                                     *\n*                           R E P L Y                                 *\n*                                                                     *\n*        RETURN A LIST OF THE OUTSTANDING REPLIES IN A TABLE          *\n*        POINTED TO BY REGISTER 1 ON ENTRY.  THERE IS ROOM FOR        *\n*        100 OUTSTANDING REPLIES IN THE TABLE.  AN ENTRY WHICH        *\n*        STARTS WITH X'FF' WILL FLAG THE END OF THE REPLIES.          *\n*                                                                     *\n*        BECAUSE SOME OF THE STORAGE AREAS ARE ABOVE THE 16           *\n*        MEG LINE, THE ROUTINE WILL SWITCH TO AMODE31 IN THE          *\n*        BEGINNING AND SWITCH BACK TO AMODE 24 WHEN FINISHED.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           R1  - ADDRESS OF THE REPLY TABLE                          *\n*           R13 - ADDRESS OF A SAVE AREA                              *\n*           R15 - ENTRY POINT ADDRESS                                 *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           SAME AS ON ENTRY                                          *\n*                                                                     *\n*        WRITTEN BY:                                                  *\n*                   JOHN V. HOOPER                                    *\n*                   FOOD LION, INC.                                   *\n*                   2110 EXECUTIVE DRIVE                              *\n*                   SALISBURY, N.C.  28145-1330                       *\n*                                                                     *\n*        STRIPPED OUT OF THE 'COMMAND' PROGRAM IN FILE 19 OF CBT 417  *\n*        BY DAVE CARTWRIGHT, AGCO LTD., DESFORD ENGLAND  31AUG99      *\n*                                                                     *\n*                                                                     *\n*                           DISCLAIMER                                *\n*                                                                     *\n*      THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,                 *\n*      DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR             *\n*      WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT            *\n*      LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR          *\n*      IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,       *\n*      ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,             *\n*      DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR            *\n*      FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED             *\n*      MATERIALS; THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY          *\n*      KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,                 *\n*      DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR        *\n*      APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING       *\n*      THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,             *\n*      WARRANTY, OR KNOWLEDGE; NOR DO THE AUTHORS ASSUME ANY          *\n*      LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM          *\n*      THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,       *\n*      DOCUMENTATION, OR RELATED MATERIALS.                           *\n*                                                               EEJ1102\n****************************************************************EEJ1102\n*                                                               EEJ1102\n* Change Activity:                                              EEJ1102\n*                                                               EEJ1102\n*   NOV 2002 EEJ Support 4-byte reply IDs                       EEJ1102\n*                                                                     *\n***********************************************************************\n         EQUATES ,\nLIONRPLY CSECT ,                   NAMED 'REPLY' AT FOOD LION *DHC*\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             INITIALIZE FIRST BASE REGISTER\n         USING LIONRPLY,R12        SET PROGRAM ADDRESSABILITY\n         LR    R15,R13             SAVE CALLING'S SAVE AREA ADDR\n         LA    R13,REPSAVE         LOAD ADDR OF NEW SAVE AREA\n         ST    R13,8(R15)          STORE NEW SAVE ADDR IN OLD\n         ST    R15,4(R13)          STORE OLD SAVE ADDR IN NEW\n         LA    R15,*+10            SET BRANCH ADDRESS\n         O     R15,=X'80000000'    SET AMODE31 BIT ON\n         BASSM R14,R15             GO TO AMODE 31\n***********************************************************************\n*                                                                     *\n*        FLAG END OF REPLY TABLE                                      *\n*                                                                     *\n***********************************************************************\n         MVI   0(R1),X'FF'         SET END OF TABLE INDICATOR\n         ST    R1,TBLADDR          SAVE REPLY TABLE ADDRESS\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE ASID NUMBER OF THE CONSOLE ADDRESS SPACE       *\n*                                                                     *\n***********************************************************************\nREPLY01  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R4,ASVTMAXU         LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R2,1                SET ADDRESS SPACE NUMBER TO ONE\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\nREPLY02  ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   REPLY03             ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF JOBNAME FIELD.\n         BZ    REPLY03             ZERO, BYPASS THIS ONE\n         CLC   0(8,R15),=C'CONSOLE ' IS THIS THE CONSOLE ADDRESS SPACE?\n         BE    REPLY04             YES, EXIT FROM LOOP.\nREPLY03  LA    R2,1(R2)            ADD 1 TO THE ASID\n         LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R4,REPLY02          LOOP\n         B     REPLY13             ERROR, GET OUT\nREPLY04  ST    R2,CONSASID         SAVE ASID OF CONSOLE ADDRESS SPACE.\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SET UP CROSS MEMORY SERVICES                                 *\n*                                                                     *\n***********************************************************************\nREPLY05  L     R10,TBLADDR         GET START OF REPLY TABLE\n         USING MSGDSECT,R10        SET ADDRESSABILITY TO REPLY ENTRY\n         SLR   R7,R7               SET MESSAGE COUNT TO ZERO\n         MODESET MODE=SUP,KEY=ZERO AUTHORIZE OURSELVES\n         ESAR  R9                  GET SECONDARY ASID\n         ST    R9,SASID            AND SAVE IT\n         AXSET AX=ONE              SET AX TO ALLOW SSAR\n         L     R9,CONSASID         GET 'CONSOLE' ASID\n         SSAR  R9                  SET 'CONSOLE' AS SECONDARY ASID\n***********************************************************************\n*                                                                     *\n*        GET THE CMS LOCK SO THAT THE OUTSTANDING REPLY               *\n*        ELEMENT (ORE) CHAIN WILL NOT BE ALTERED DURING               *\n*        OUR PROCESSING.                                              *\n*                                                                     *\n***********************************************************************\nREPLY06  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE\n         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*          GET THE ADDRESS OF THE FIRST OUTSTANDING REPLY             *\n*          ELEMENT (ORE)                                              *\n*                                                                     *\n***********************************************************************\nREPLY07  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R4,CVTCUCB          R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         USING UCM,R4              SET ADDRESSABILITY TO UCM BASE\n         L     R2,UCMRPYQ          LOAD ADDRESS OF FIRST ORE\n         LTR   R2,R2               TEST ORE ADDRESS\n         BZ    REPLY12             ZERO, NO OUTSTANDING REPLIES\n         DROP  R4                  DROP ADDRESSABILITY TO UCM BASE\n         USING OREF,R2             SET ADDRESSABILITY TO ORE\n***********************************************************************\n*                                                                     *\n*          COPY THE WTO QUEUE ELEMENT (WQE) FROM THE CONSOLE          *\n*          ADDRESS SPACE FOR THE CURRENT ORE                          *\n*                                                                     *\n***********************************************************************\nREPLY08  L     R8,ORERWQE          R8 = ADDR OF WQE\n         LA    R4,WQECOPY          R4 = ADDR OF COPY OF WQE\n         LA    R5,WQESIZE          R5 = SET LENGTH OF WQE\n         SLR   R15,R15             SET 'FROM' KEY TO ZERO\nREPLY09  MVCP  0(R5,R4),0(R8),R15  MOVE UP TO 256 BYTES\n         BZ    REPLY10             CC=0 - DONE\n         LA    R4,256(,R4)         INCREMENT 'TO' ADDRESS\n         LA    R8,256(,R8)         INCREMENT 'FROM' ADDRESS\n         SH    R5,=H'256'          SUBTRACT LENGTH OF LAST MOVE\n         B     REPLY09             GO GET REST OF AREA\nREPLY10  LA    R4,WQECOPY          RESTORE ADDRESS OF COPY OF WQE\n         USING WQE,R4              SET ADDRESSABILITY TO WQE\n***********************************************************************\n*                                                                     *\n*          SAVE THE REPLY JOBNAME, MSGID, AND ACTUAL MESSAGE          *\n*          FROM THE WQE                                               *\n*                                                                     *\n***********************************************************************\nREPLY11  MVI   MSGENT,C' '         BLANK THE ENTIRE\n         MVC   MSGENT+1(L'MSGENT-1),MSGENT   MESSAGE AREA\n         MVC   JNAME,WQEOJBNM      SAVE JOB NAME\n         L     R0,WQERPYIB         Load binary reply ID         EEJ1102\n         CVD   R0,WORKD            Convert to decimal           EEJ1102\n         OI    WORKD+7,X'0F'       Ensure printable numerics    EEJ1102\n         UNPK  RID,WORKD           Unpack reply ID              EEJ1102\n         MVC   MSG,WQETXT          SAVE MESSAGE TEXT\n         LA    R10,L'MSGENT(,R10)  INCREMENT TO NEXT MESSAGE AREA\n         MVI   0(R10),X'FF'        SET END OF TABLE INDICATOR\n         LA    R7,1(,R7)           ADD 1 TO MESSAGE COUNT\n         CH    R7,=H'100'          SEE IF REACHED MAXIMUM\n         BNL   REPLY12             YES, GET OUT\n         L     R2,ORELKP           LOAD ADDRESS OF NEXT ORE\n         LTR   R2,R2               SEE IF ANY MORE ORE'S\n         BNZ   REPLY08             YES, LOOP\n         DROP  R2                  DROP ADDRESSABILITY TO ORE\n         DROP  R4                  DROP ADDRESSABILITY TO WQE\n         DROP  R10                 DROP ADDRESSABILITY TO REPLY TABLE\n***********************************************************************\n*                                                                     *\n*        FREE THE CMS LOCK SO THAT NORMAL CONSOLE MESSAGE             *\n*        PROCESSING CAN CONTINUE                                      *\n*                                                                     *\n***********************************************************************\nREPLY12  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK RELEASE,TYPE=CMS,REGS=SAVE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*        GET OUT OF CROSS MEMORY MODE                                 *\n*                                                                     *\n***********************************************************************\n         L     R9,SASID            RESTORE PREVIOUS SECONDARY ASID\n         SSAR  R9                  SHOULD BE SAME AS PRIMARY\n         AXSET AX=ZERO             SET AUTHORIZATION INDEX BACK TO ZERO\n         MODESET MODE=PROB,KEY=NZERO UNAUTHORIZE OURSELVES\n***********************************************************************\n*                                                                     *\n*        RETURN TO THE CALLER                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nREPLY13  LA    R15,*+6             SET BRANCH ADDRESS\n         BASSM R14,R15             GO TO AMODE 24\n         L     R13,4(R13)          RESTORE ORIG SAVE AREA ADDRESS\n         RETURN (14,12)            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n         LTORG\nREPSAVE  DS    18F                 PROGRAM SAVE AREA\nCONSASID DC    F'0'                ASID OF CONSOLE ADDRESS SPACE\nTBLADDR  DS    F                   ADDRESS OF REPLY TABLE\nSASID    DS    F                   SAVE PREVIOUS SECONDARY ASID\nONE      DC    H'1'                TO SET AX 1\nZERO     DC    H'0'                TO SET AX 0\nWORKD    DC    D'0'                Doubleword work area         EEJ1102\n         DS    0F\nWQECOPY  DS    CL512               LOCAL COPY OF WQE\n         EJECT\nMSGDSECT DSECT\nMSGENT   DS   0CL140                                            EEJ1102\nJNAME    DS    CL8\nRID      DS    CL4                 Reply ID                     EEJ1102\nMSG      DS    CL128\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IEECUCM DSECT=YES,FORMAT=NEW,LIST=YES\n         EJECT\n         IHAASVT DSECT=YES\n         EJECT\n         IHAASCB DSECT=YES\n         EJECT\n         IHAORE DSECT=YES\n         EJECT\n         IHAWQE DSECT=YES,FORMAT=OLD\n         EJECT\n         IHAPSA DSECT=YES,LIST=YES\n         EJECT\nTIOT     DSECT\n         IEFTIOT1\n         END    LIONRPLY\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY LIONRPLY(''V 1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    LIONRPLY'\n PUNCH ' NAME     LIONRPLY(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MENTER": {"ttr": 30472, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00Y\\x00Y\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&NAME    MENTER  &REG,&EQU,&COM=,&CP=NO\n&NAME    CSECT\n         GBLC    &USE\n         GBLC    &GBCP\n         LCLC    &COMMENT\n         LCLC    &BASE\n         LCLA    &REGNO\n&GBCP    SETC    '&CP'\n&USE     SETC    'USE'\n&COMMENT SETC    '&COM'\n         AIF     ('&COMMENT' NE '').NOCOMM\n&COMMENT SETC    '&NAME'\n.NOCOMM  ANOP\n         AIF     ('&EQU' EQ 'NOEQU').NOEQU\n***********************************************************************\n*                REGISTER EQUATES                                     *\n***********************************************************************\n*\nR0       EQU     0\nR1       EQU     1\nR2       EQU     2\nR3       EQU     3\nR4       EQU     4\nR5       EQU     5\nR6       EQU     6\nR7       EQU     7\nR8       EQU     8\nR9       EQU     9\nR10      EQU     10\nR11      EQU     11\nR12      EQU     12\nR13      EQU     13\nR14      EQU     14\nR15      EQU     15\n.*\n.NOEQU   ANOP\n&REGNO   SETA    &REG\n         AIF     (&REGNO GT 12).NOWAY\n         AIF     (&REGNO LT 2).NOWAY\n.*\n.*       INITIALIZE BASE REGISTER TO USER SPECIFICATIONS\n.*\n&BASE    SETC    '&REG'\n         AGO     .START\n.NOWAY   ANOP\n*\n         MNOTE   0,'INCORRECT REGISTER SPECIFIED ...USING 12'\n*\n&BASE    SETC    '12'\n.START   ANOP\n***********************************************************************\n*                SET UP THE SAVE AREA                                 *\n***********************************************************************\n*        SAVE    (14,12)\n         DS      0H\n         STM     14,12,12(13)          SAVE REGISTERS\n         LR      &BASE,15              LOAD BASE REGISTER\n         USING   &NAME,&BASE           TELL ASSEMBLER\n         B       MENT&SYSNDX\n         DC      CL8'&SYSDATE'\n         DC      CL8'&SYSTIME'\n         DC      CL8'&COMMENT'\nMENT&SYSNDX DS 0H\n         ST      13,SAVE+4             STORE OLD SAVE AREA\n         LA      3,SAVE                AND PREPARE TO STORE NEW\n         ST      3,8(13)               STORE IT\n         LR      13,3                  AND LOAD R13\n         AIF     ('&CP' EQ 'NOCP').NOPPL\n         LA      R2,IOPLADS\n         USING   IOPL,R2\n         L       R3,0(1)\n         ST      R3,CPPLCBUF\n         L       R3,4(1)\n         ST      R3,CPPLUPT\n         ST      R3,IOPLUPT\n         L       R3,8(1)\n         ST      R3,CPPLPSCB\n         L       R3,12(1)\n         ST      R3,CPPLECT\n         ST      R3,IOPLECT\n         L       R3,ECBADS\n         ST      R3,IOPLECB\n         DROP    R2\n.NOPPL   ANOP\n*\n*\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MLEAVE": {"ttr": 30475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x16\\x00\\x16\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&NAME    MLEAVE\n         GBLC    &GBCP\n         LH      R15,EXITRC\n         L       13,SAVE+4\n*        RETURN  (14,12),T,RC=0\n         L       14,12(13)          RESTORE THE REGISTERS\n         LM      0,12,20(13)          RESTORE THE REGISTERS\n         MVI     12(13),X'FF'          SET RETURN INDICATION\n         BR      14                    RETURN\nEXITRC   DC      H'0'             RETURN CODE FROM COMMAND PROCESSOR\n         AIF     ('&GBCP' EQ 'NOCP').NOPPL\nCPPLCBUF DS      A\nCPPLUPT  DS      A\nCPPLPSCB DS      A\nCPPLECT  DS      A\nIOPLADS  DS      4F               SPACE FOR IO PARM LIST\nECBADS   DC      F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\n.NOPPL   ANOP\nSAVE     DS      18F\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MPFLSTSE": {"ttr": 30477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01\\x17\\x01\\x17\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 279, "newlines": 279, "modlines": 0, "user": "TSSO403"}, "text": "GVB999I,SUP(YES),RETAIN(NO)  DCM/HYPERBUF\nGVB*,SUP(YES),RETAIN(NO)     DCM/HYPERBUF\nACTRT,SUP(YES),RETAIN(NO)    PSEUDO IEFACTRT MESSAGES FOR LOGAN\nADM*   ,SUP(YES),RETAIN(NO) ALL ADMPRINT MSGS INTERVENTION REQUIRED\nAMTRP* ,SUP(YES),RETAIN(NO)  RESOLVE OUTSTANDING REPLIES\nARC0016I,SUP(YES),RETAIN(NO) HSM SHUTDOWN REQUESTED\nARC0027I,SUP(YES),RETAIN(NO) HSM LOG SWITCHED SUCCESSFULLY\nARC0100I,SUP(YES),RETAIN(NO) HSM SETSYS COMMAND COMPLETED\nARC0170I,SUP(YES),RETAIN(NO) HSM SETMIG DSN = PROCESSED\nARC0171I,SUP(YES),RETAIN(NO) HSM SETMIG LEVEL = PROCESSED\nARC0120I,SUP(YES),RETAIN(NO) HSM BACKUP VOLUME ADDED\nARC0229I,SUP(YES),RETAIN(NO) HSM DATASET POOL DEFINED FOR DSN\nARC0260I,SUP(YES),RETAIN(NO) HSM BACKUP VOLUME ENTRY DELETED\nARC0270I,SUP(YES),RETAIN(NO) HSM MIGRATION CLEANUP CYCLE DEFINITION\nARC0353I,SUP(YES),RETAIN(NO) HSM VOLUME ADDED TO TAPE VOLUME SET\nARC0365I,SUP(YES),RETAIN(NO) HSM BACKUP VOLUME AVAILABLE FOR RECYCLE\nARC0520I,SUP(YES),RETAIN(NO) HSM DAILY SPACE MANAGEMENT STARTING\nARC0521I,SUP(YES),RETAIN(NO) HSM SPACE MANAGEMENT ENDED SUCCESSFULLY\nARC0522I,SUP(YES),RETAIN(NO) HSM SPACE MANAGEMENT STARTING\nARC0526I,SUP(YES),RETAIN(NO) HSM MIGRATION CLEANUP STARTING\nARC0527I,SUP(YES),RETAIN(NO) HSM MIGRATION CLEANUP ENDING\nARC0523I,SUP(YES),RETAIN(NO) HSM SPACE MANAGEMENT ENDING\nARC0530I,SUP(YES),RETAIN(NO) HSM LEVEL 1 MIGRATION STARTING\nARC0531I,SUP(YES),RETAIN(NO) HSM LEVEL 1 MIGRATION ENDING\nARC0570I,SUP(YES),RETAIN(NO) HSM DAILY SPACE MANAGEMENT STARTING SMS\nARC0620I,SUP(YES),RETAIN(NO) HSM AUTOMATIC DUMP STARTING\nARC0621I,SUP(YES),RETAIN(NO) HSM AUTOMATIC DUMP ENDING\nARC0622I,SUP(YES),RETAIN(NO) HSM FULL VOLUME DUMP STARTING\nARC0623I,SUP(YES),RETAIN(NO) HSM FULL VOLUME DUMP ENDING\nARC0628I,SUP(YES),RETAIN(NO) HSM EXPIRATION OF DUMP VOLUMES STARTING\nARC0629I,SUP(YES),RETAIN(NO) HSM EXPIRATION OF DUMP VOLUMES ENDING\nARC0637I,SUP(YES),RETAIN(NO) HSM DUMP COPY COMPLETE\nARC0718I,SUP(YES),RETAIN(NO) HSM MOVEMENT OF BACKUP VERSIONS STARTING\nARC0719I,SUP(YES),RETAIN(NO) HSM MOVEMENT OF BACKUP VERSIONS ENDING\nARC0720I,SUP(YES),RETAIN(NO) HSM AUTOMATIC BACKUP STARTING\nARC0721I,SUP(YES),RETAIN(NO) HSM AUTOMATIC BACKUP ENDING\nARC0722I,SUP(YES),RETAIN(NO) HSM BACKUP STARTING\nARC0723I,SUP(YES),RETAIN(NO) HSM BACKUP ENDED\nARC0728I,SUP(YES),RETAIN(NO) HSM VTOC COPIED\nARC0735I,SUP(YES),RETAIN(NO) HSM BACKUP OF MIGRATED DATASETS STARTING\nARC0736I,SUP(YES),RETAIN(NO) HSM BACKUP OF MIGRATED DATASETS ENDINGNG\nARC0740I,SUP(YES),RETAIN(NO) HSM CDS BACKUP STARTING\nARC0741I,SUP(YES),RETAIN(NO) HSM CDS BACKUP ENDING\nARC0742I,SUP(YES),RETAIN(NO) HSM BACKUP FOR MCDS STARTING\nARC0743I,SUP(YES),RETAIN(NO) HSM MCDS SUCCESSFULLY BACKED UP\nARC0832I,SUP(YES),RETAIN(NO) HSM RECYCLE STARTING\nARC0833I,SUP(YES),RETAIN(NO) HSM RECYCLE ENDED\nARC6001E,SUP(YES),RETAIN(NO) HSM DFP NOT AT PROPER LEVEL (SMS)\nCADO008D,SUP(YES),USEREXIT(REPLYU) TLMS SUBSYSTEM START\nCAT9006I,SUP(YES),RETAIN(NO) TLMS FOREIGN VSN\nCAT9007I,SUP(YES),RETAIN(NO) TLMS INFO TO SYSLOG\nCNM039I,SUP(YES),RETAIN(NO) A MESSAGE HAS BEEN LOGGED ...\nCNM104I,SUP(YES),RETAIN(NO) STATUS MONITOR HAS STARTED\nCNM106I,SUP(YES),RETAIN(NO) STATUS MONITOR HAS REACTIVATED RESOURCE\nCNOS,SUP(YES),RETAIN(NO)     VTAMPRINT CONNECTION STATISTICS\nCSV003I,SUP(YES),RETAIN(NO) MODULE NOT FOUND\nCSV011I,SUP(YES),RETAIN(NO) FETCH FAILED\nCSV019I,SUP(YES),RETAIN(NO) NOT ACCESSED, NON APF LIBRARY\nCSV028I,SUP(YES),RETAIN(NO) FETCH FAILED\nDFH0710,SUP(YES),RETAIN(NO)\nDFH0951I,SUP(YES),RETAIN(NO) CICS OPEN OF DSN FAILED\nDFH1280,SUP(YES),RETAIN(NO)  CICS TRANSIENT DATA INITIALISATION\nDFH1281,SUP(YES),RETAIN(NO)  CICS TRANSIENT DATA INITIALISATION\nDFH1532,SUP(YES),RETAIN(NO)  CICS DUPLICATE ENTRY IN PPT IGNORED\nDFH1500,SUP(YES),RETAIN(NO)  CICS START UP MESSAGES\nDFH1501,SUP(YES),RETAIN(NO)  CICS SIT NAME\nDFH1567,SUP(YES),RETAIN(NO)  CICS TCT ADD/REPLACE\nDFH1562I,SUP(YES),RETAIN(NO) CICS LINK TO PLT\nDFH1591I,SUP(YES),RETAIN(NO) CICS RETURN FROM PLT\nDFH3504I,SUP(YES),RETAIN(NO) CICS USER SIGN-ON\nDFH2800I,SUP(YES),RETAIN(NO) CICS\nDFH3506I,SUP(YES),RETAIN(NO) CICS USER SIGN-OFF\nDFH3532I,SUP(YES),RETAIN(NO) CICS EXTERNAL SECURITY ACTIVE\nDFH4500,SUP(YES),RETAIN(NO)  CICS JOURNALS OPENED\nDFH4508,SUP(YES),RETAIN(NO)  CICS LOG RECORDING ON VOLUME\nDFH5731,SUP(YES),RETAIN(NO)  CICS\nDFS035I,SUP(YES),RETAIN(NO)  DL/1 INITIALISATION COMPLETE\nDFS092I,SUP(YES),RETAIN(NO)  DL/1 LOG TERMINATED\nDFS2207I,SUP(YES),RETAIN(NO) DL/1 LOG CHARACTERISTICS\nDFS2208I,SUP(YES),RETAIN(NO) DL/1 SINGLE LOGGING\nDFS627I,SUP(YES),RETAIN(NO)  DL/1 RESOURCE CLEANUP COMPLETE\nDFS627I,SUP(YES),RETAIN(NO)  DL/1 RESOURCE CLEANUP COMPLETE\nDFS826I,SUP(YES),RETAIN(NO)  DL/1 DBD BLDL FAILED\nDFS830I,SUP(YES),RETAIN(NO)  DL/1 PSB BLDL FAILED\nDSI090 ,SUP(YES),RETAIN(NO)  NCCF LOAD FAILED\nDSI208I,SUP(YES),RETAIN(NO)  NLDM TIME EXPIRATION\nERB*,SUP(YES),RETAIN(NO)     RMF MESSAGES\nFQS*,SUP(YES),RETAIN(NO)     FQS MESSAGES\nFNM200I,SUP(YES),RETAIN(NO) NPM STATUS\nIBM*,SUP(YES),RETAIN(NO)    ALL PLI MESSAGES TO PROGRAMMER\nICE*,SUP(YES),RETAIN(NO)    ALL SORT ERROR MESSAGES\nICH408I,SUP(YES),RETAIN(NO) LOGON WITH INVALID PASSWORD\nICH410I,SUP(YES),RETAIN(NO) RACF UNABLE TO BACKUP UPDATE ...\nICH70001I,SUP(YES),RETAIN(NO) LAST ACCESS AT HH.MM.SS ON YY.DDD\nIEA459I,SUP(NO),USEREXIT(SSCFWMPF) CACHING REINSTATED\nIEA848I,SUP(YES),RETAIN(NO) NO DUMP PRODUCED FOR THIS ABEND ...\nIEA989I,SUP(YES),RETAIN(NO) SLIP TRAP MATCHED\nIEA995I,SUP(YES),RETAIN(NO) SYMPTOM DUMP OUTPUT\nIEC020I,SUP(YES),RETAIN(NO) ABEND S001\nIEC022I,SUP(YES),RETAIN(NO) ABEND S137\nIEC031I,SUP(YES),RETAIN(NO) ABEND SD37\nIEC032I,SUP(YES),RETAIN(NO) ABEND SE37\nIEC070I,SUP(YES),RETAIN(NO) (VSAM EOB ERROR)\nIEC130I,SUP(YES),RETAIN(NO) DD STATEMENT MISSING\nIEC161I,SUP(YES),RETAIN(NO) VSAM OPEN ERROR MESSAGES.\nIEC331I,SUP(YES),RETAIN(NO) ABEND MESSAGES\nIEC501A,SUP(NO),USEREXIT(MPFTAPEM)  MOUNT TAPE\nIEC502E,SUP(YES),RETAIN(NO),USEREXIT(MPFTAPEK)  KEEP TAPE\nIEC705I,SUP(YES),RETAIN(NO) TAPE LABEL\nIEC706I,SUP(YES),RETAIN(NO) TAPE DENSITY IGNORED\nIEC801I,SUP(YES),RETAIN(NO) LNA THRESHOLD TRANS= ...\nIEC999I,SUP(YES),RETAIN(NO) IFG0TC0A...\nIEE043I,SUP(YES),RETAIN(NO) SYSTEM LOG DATSET QUEUED TO SYSOUT\nIEE362A,SUP(YES),RETAIN(NO) ENTER DUMP FOR SMF DATASET\nIEE301I,SUP(YES),RETAIN(NO) CANCEL COMMAND ACCEPTED\nIEE400I,SUP(YES),RETAIN(NO) THESE MESSAGES CANCELLED - XX\nIEE600I,SUP(YES),RETAIN(NO) REPLY TO NN IS;XX\nIEE734I,SUP(YES),RETAIN(NO) UNIT UNLOADED\nIEF097I,SUP(YES),RETAIN(NO) USERID ASSIGNED\nIEF125I,SUP(YES),RETAIN(NO) LOGGED ON\nIEF126I,SUP(YES),RETAIN(NO) LOGGED OFF\nIEF170I,SUP(YES),RETAIN(NO) (53 BYTES OF WTP TEXT)\nIEF188I,SUP(YES),RETAIN(NO) PROBLEM PROGRAM ATTRIBUTES ASSIGNED\nIEF196I,SUP(YES),RETAIN(NO) ALLOCATION\nIEF233A,SUP(NO),USEREXIT(MPFTAPEM)  MOUNT TAPE\nIEF234E,SUP(YES),RETAIN(NO),USEREXIT(MPFTAPEK)  TAPE DISPOSITION\nIEF236I,SUP(YES),RETAIN(NO) ALLOCATION FOR JOB\nIEF237I,SUP(YES),RETAIN(NO) ALLOCATED TO\nIEF251I,SUP(YES),RETAIN(NO) JOB CANCELLED\nIEF285I,SUP(YES),RETAIN(NO)  D/S STATUS\nIEF287I,SUP(YES),RETAIN(NO) DSN DISP VOL SER NOS =\nIEF403I,SUP(YES),RETAIN(NO) JOB STARTED\nIEF404I,SUP(YES),RETAIN(NO) JOB ENDED\nIEF430I,SUP(YES),RETAIN(NO) RESTART STEP NOT FOUND\nIEF433D,SUP(YES),USEREXIT(IDL433D)        REPLY HOLD OR NOHOLD\nIEF450I,SUP(YES),RETAIN(NO) JOB ABEND\nIEF452I,SUP(YES),RETAIN(NO) JOB NOT RUN JCL ERROR\nIEF453I,SUP(YES),RETAIN(NO) JOB FAILED JCL ERROR\nIEF471I,SUP(YES),RETAIN(NO) RETAINED VOLUMES NOT REQUIRED\nIEF471E,SUP(YES),RETAIN(NO) RETAINED VOLUMES NOT REQUIRED\nIEF677I,SUP(YES),RETAIN(NO) WARNING MESSAGE(S) FOR JOB JOBNAME ISSUED\nIFO*,SUP(YES),RETAIN(NO)    ALL ASSEMBLER F MESSAGES\nIFC001I,SUP(YES),RETAIN(NO) LOGREC INITIALISED\nISF015I,SUP(YES),RETAIN(NO) SDSF COMMAND ATTEMPTED\nIFY*,SUP(YES),RETAIN(NO)    ALL VS FORTRAN MESSAGES\nIKJ144I,SUP(YES),RETAIN(NO) UNDEFINED USER(S) XXX\nIKJ572I,SUP(YES),RETAIN(NO) USER(S) XXX NOT LOGGED ON\nIKJ605I,SUP(YES),RETAIN(NO) USER(S) XXX NOT LOGGED ON\nIKJ606I,SUP(YES),RETAIN(NO) USERID ALREADY LOGGED ON\nIKJ56644,SUP(YES),RETAIN(NO) NO VALID TSO USERID, DEFAULT USED\nIKT100I,SUP(YES),RETAIN(NO) USERID CANCELLED DUE TO UNCONDITIONAL LOGOFF\nIKT108I,SUP(YES),RETAIN(NO) USERID RECEIVE ERROR,RPLRTNCD=XX ETC.\nIOS050I,SUP(YES),RETAIN(NO) CHANNEL DETECTED ERROR\nIOS071I,SUP(YES),RETAIN(NO) (MIH MESSAGE)\nIST093I,SUP(YES),RETAIN(NO) XXX ACTIVE (RESOURCE)\nIST105I,SUP(YES),USEREXIT(SEIST105)  VARY DIAL-UP LINE ACTIVE AGAIN\nIST234I,SUP(YES),RETAIN(NO) I/O ERROR ON TERMINAL XXX\nIST259I,SUP(YES),RETAIN(NO) INOP RECEIVED FOR NODENAME\nIST314I,SUP(YES),RETAIN(NO)  VTAM INFOS\nIST400I,SUP(YES),RETAIN(NO) VTAM TERMINATION IN PROGRESS FOR APPLID\nIST440I,SUP(YES),RETAIN(NO)  VTAM INFOS\nIST441I,SUP(YES),RETAIN(NO)  VTAM INFOS\nIST442I,SUP(YES),RETAIN(NO)  VTAM INFOS\nIST443I,SUP(YES),RETAIN(NO)  VTAM INFOS\nIST521I,SUP(YES),RETAIN(NO) GBIND QUEUED FOR COS ETC\nIST522I,SUP(YES),RETAIN(NO) ERNN ACTIVATION FAILED ...\nIST523I,SUP(YES),RETAIN(NO) REASON =\nIST530I,SUP(YES),RETAIN(NO)  VTAM GBIND PENDING\nIST532I,SUP(YES),RETAIN(NO) EVENT ID MESSAGE\nIST590I,SUP(YES),RETAIN(NO) CONNECTION ESTABLISHED/ENDED\nIST619I,SUP(YES),RETAIN(NO) ID FAILED - RECOVERY IN PROGRESS\nIST621I,SUP(YES),RETAIN(NO) RECOVERY SUCCESSFUL FOR NETWORK NODE\nIST804I,SUP(YES),RETAIN(NO) VTAM CLOSE IN PROGRESS FOR APPLID\nIST805I,SUP(YES),RETAIN(NO) VTAM CLOSE COMPLETE FOR APPLID\nIST813I,SUP(YES),RETAIN(NO) USERVAR CHANGED\nIST814I,SUP(YES),RETAIN(NO) END\nIST889I,SUP(YES),RETAIN(NO) SID\nIST902I,SUP(YES),RETAIN(NO) CONNECTION ESTABLISHED\nIST931I,SUP(YES),RETAIN(NO) SYMPTOM STRING\nJSX137,SUP(YES),RETAIN(NO)   JES328X TLU INACTIVATED\nJSX200,SUP(YES),RETAIN(NO)   JES328X DEVICE START\nJSX201,SUP(YES),RETAIN(NO)   JES328X DEVICE STOP\nJSX202,SUP(YES),RETAIN(NO)   JES328X MESSAGE\nJSX210,SUP(YES),RETAIN(NO)   JES328X MESSAGE\nJSX247,SUP(YES),RETAIN(NO)   JES328X GDDM MODULE NOT SPECIFIED\nJSX254,SUP(YES),RETAIN(NO)   JES328X NSEXIT MESSAGE\nJSX255,SUP(YES),RETAIN(NO)   JES328X JES2 MESSAGE\nJSX257,SUP(YES),RETAIN(NO)   JES328X CONSOLE MESSAGE\nLMRK01701E,SUP(YES),RETAIN(NO)   TMON/CICS PROGRAM NOT IN TABLE\nNSY0002,SUP(YES),RETAIN(NO)  MULTITERM SESSION LOST\nNSY0005,SUP(YES),RETAIN(NO)  MULTITERM SESSION TERMINATED\nNSY0006,SUP(YES),RETAIN(NO)  MULTITERM LOGOFF IN PROGRESS\nMESSAGE,SUP(YES),RETAIN(NO) ... MULTI LINE WTO IN ERROR\nOMV006I,SUP(YES),RETAIN(NO) OMVTAM OPNDST\nOMV981I,SUP(YES),RETAIN(NO) OMVTAM DETACH\nOMV996I,SUP(YES),RETAIN(NO) OMVTAM CLSDST\nQFS302I,SUP(YES),RETAIN(NO)  QUICK FETCH ACTIVITY LIST ENTRIES RESET\nQFS312I,SUP(YES),RETAIN(NO)  QUICK FETCH PEAK STATISTICS RESET\nQFS453I,SUP(YES),RETAIN(NO)  QUICK FETCH STORAGE UTILISATION\nQFS820I,SUP(YES),RETAIN(NO)  QUICK FETCH CICS INTERFACE ESTABLISHED\nQFS840I,SUP(YES),RETAIN(NO)  QUICK FETCH CICS INTERFACE TERMINATED\nSSDC*,SUP(YES),RETAIN(NO)    DATA COMPRESSION UTILITY MESSAGES\nTMON0317,SUP(YES),RETAIN(NO) DATA COLLECTION INITIALIZED\nTMON0714,SUP(YES),RETAIN(NO) DATA COLLECTION OPENED\nTMON6400,SUP(YES),RETAIN(NO) TMON INTERVAL RECORDING ACTIVE\nTMON6463,SUP(YES),RETAIN(NO) TMON DLS CONNECTION ESTABLISHED\nTMON6464,SUP(YES),RETAIN(NO) TMON DCS INITIALISATION\nTMON6510,SUP(YES),RETAIN(NO) TMON SAMPLING ACTIVE\nVAOUSE01,SUP(YES),RETAIN(NO) VTAMPRINT LOGON\nXCOM*,SUP(YES),RETAIN(NO)    ALL XCOM MESSAGES\n$HASP000,SUP(YES),RETAIN(NO) OK ... WELL, IT IS AN AGGRESIVE LIST\n$HASP001,SUP(YES),RETAIN(NO) R,TEXT VIA $DM\n$HASP002,SUP(YES),RETAIN(NO) AUTOMATIC COMMANDS HALTED\n$HASP094,SUP(YES),RETAIN(NO) I/O ERRORS ON LINE XX\n$HASP100,SUP(YES),RETAIN(NO) ON TSORDR/INTRDR/ETC..... RDR\n$HASP101,SUP(YES),RETAIN(NO) JOBNAME HELD\n$HASP110,SUP(YES),RETAIN(NO) JOBNAME -- ILLEGAL JOB CARD\n$HASP111,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*ROUTE CARD\n$HASP112,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*JOBPARM CARD\n$HASP113,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*OUTPUT CARD\n$HASP114,SUP(YES),RETAIN(NO) JOBNAME -- INVALID EXECUTION MODE\n$HASP115,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*NETACCT CARD\n$HASP116,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*NOTIFY CARD\n$HASP117,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*XMIT CARD\n$HASP118,SUP(YES),RETAIN(NO) JOBNAME -- INVALID /*CONTROL STATEMENT\n$HASP119,SUP(YES),RETAIN(NO) JOBNAME -- JOB DELETED\n$HASP120,SUP(YES),RETAIN(NO) DEVNAME COMMAND (E.G. INTRDR $VS,'CMD')\n$HASP125,SUP(YES),RETAIN(NO) JOB ON READER\n$HASP150,SUP(YES),RETAIN(NO) OUTGRP ON DEVICE\n$HASP160,SUP(YES),RETAIN(NO) DEVICE XXX INACTIVE\n$HASP165,SUP(YES),RETAIN(NO) ENDED ...\n$HASP200,SUP(YES),RETAIN(NO) XX STARTED ON LINEX\n$HASP203,SUP(YES),RETAIN(NO) XX DISCONNECTED FROM LINEX\n$HASP208,SUP(YES),RETAIN(NO) LSTRM SCHEDULED FOR RMTXX\n$HASP209,SUP(YES),RETAIN(NO) SESSION RMTXX STARTED ON LINEXX\n$HASP210,SUP(YES),RETAIN(NO) SESSION LOGGED OFF\n$HASP240,SUP(YES),RETAIN(NO) MESSAGES TO INACTIVE SPOOL MEMBER DISCARDED\n$HASP244,SUP(YES),RETAIN(NO) XX INVALID COMMAND\n$HASP249,SUP(YES),RETAIN(NO) NX $D CMD\n$HASP250,SUP(YES),RETAIN(NO) JOB XXXXXXXX PURGED\n$HASP301,SUP(YES),RETAIN(NO) JOBNAME - DUPLICATE JOB NAME - JOB DELAYED\n$HASP308,SUP(YES),RETAIN(NO) JOBNAME - ESTIMATED TIME EXCEEDED\n$HASP309,SUP(YES),RETAIN(NO) INIT XX INACTIVE\n$HASP310,SUP(YES),RETAIN(NO) XXX TERMINATED AT END OF MEMORY\n$HASP317,SUP(YES),RETAIN(NO) XXX NNN DATASETS RELEASED\n$HASP373,SUP(YES),RETAIN(NO) STARTING OF TASKS/JOBS/USERS\n$HASP375,SUP(YES),RETAIN(NO)\n$HASP395,SUP(NO),RETAIN(NO)  JOB ENDED\n$HASP396,SUP(YES),RETAIN(NO) XXX TERMINATED\n$HASP406,SUP(YES),RETAIN(NO) JOB WAS EXECUTING\n$HASP503,SUP(YES),RETAIN(NO) CONNECTION CONTROL...INVALID NODE NAME\n$HASP520,SUP(YES),RETAIN(NO) XXX ON JOB TRANSMITTER\n$HASP524,SUP(YES),RETAIN(NO) DEVICE INACTIVE\n$HASP530,SUP(YES),RETAIN(NO) XXX JOBNAME ON DEVICE\n$HASP532,SUP(YES),RETAIN(NO) XXX JOBNAME RESTARTED\n$HASP534,SUP(YES),RETAIN(NO) DEVICE INACTIVE\n$HASP540,SUP(YES),RETAIN(NO) XXX JOBNAME ON DEVICE\n$HASP543,SUP(YES),RETAIN(NO) XXX JOBNAME DEVICE DELETED\n$HASP608,SUP(YES),RETAIN(NO) XXX AWAITING PURGE\n$HASP610,SUP(YES),RETAIN(NO)\n$HASP628,SUP(YES),RETAIN(NO) DEVICE INACTIVE\n$HASP632,SUP(YES),RETAIN(NO) XXX NO HELD  DATASETS\n$HASP633,SUP(YES),RETAIN(NO) XXX NO READY DATASETS\n$HASP656,SUP(YES),RETAIN(NO) XXX OUTPUT GROUPS CANCELLED\n$HASP688,SUP(YES),RETAIN(NO) XXX OUTGRP CHARACTERISTICS\n$HASP907,SUP(YES),RETAIN(NO)\n.MSGCOLR ENTRYARA(P,N,H)     ENTRY AREA\n.MSGCOLR EVETACTN(Y,N,H)     EVENTUAL ACTION DC 3\n.MSGCOLR GENMSG(B,N,N)       GENERAL SYSTEM BY AUTHORIZED PROG DC 1,2,3\n.MSGCOLR IMEDACTN(W,R,N)     IMMEDIATE ACTION RC2 WTOR\n.MSGCOLR INSTRERR(R,R,N)     ERROR ON INSTRUCTION LINE\n.MSGCOLR OOLCNTL(W,R,N)      CONTROL LINE TEXT\n.MSGCOLR OOLDATA(W,R,N)      CONTROL LINE DATA\n.MSGCOLR OOLLABEL(W,R,N)     CONTROL LINE LABEL\n.MSGCOLR PPMSG(P,R,H)        NON-ACTION MESSAGES PROBLEM PROG\n.MSGCOLR SELPEN(B,R,N)       SELECTOR PEN DETECTABLE FIELDS\n.MSGCOLR URGATTN(Y,R,N)      URGENT ATTENTION MESSAGES RC 1,11\n.MSGCOLR WARNLGEN(Y,N,H)     GENEARAL WARNING LEFT\n.MSGCOLR WARNRURG(R,R,N)     URGENT WARNING LEFT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MULT": {"ttr": 30724, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01I\\x01I\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 329, "newlines": 329, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE '     S T A C K                '\n************************************************************\n*                                                          *\n*           'STACK' TSO COMMAND                            *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. APRIL 27 1977.\n*        DATE UPDATED. SEPTEMBER 10 1980.\n*        DESCRIPTION.\n*            THIS COMMAND STACKS A LIST OF COMMANDS.\n*            THE LIST OF COMMANDS IS WITHIN PARENTHESES.\n*            THE FIRST CHARACTER AFTER THE OPEN PARENTHESES\n*            WILL BE USED AS THE DELIMITER TO SEPARATE THE\n*            COMMANDS IN THE LIST.  FOR EXAMPLE, THE FOLLOWING\n*            TWO COMMANDS WILL GIVE THE SAME RESULTS.\n*               STACK (;EDIT X DATA;V;FIND /ABC/;FIND /WXY/;END)\n*               STACK (ZEDIT X DATAZVZFIND /ABC/ZFIND /WXY/ZEND)\n*            NOTE: INSTALLATIONS THAT HAVE THE PCF PRODUCT CANNOT\n*            USE THE SEMICOLON AS THE DELIMITER IN THIS COMMAND,\n*            BECAUSE PCF SEES IT AND STRIPS IT OUT BEFORE THIS COMMAND\n*            GETS CONTROL.  BUT THOSE WHO HAVE PCF HAVE NO NEED FOR\n*            THIS COMMAND ANYWAY, BECAUSE PCF INCLUDES THIS FUNCTION.\n         SPACE\n         GBLB  &MVS\n&MVS     SETB  1                   1 - MVS   0 - SVS,MVT\n         SPACE\nMULT     START\n         USING *,R12\n         B     @PROLOG-*(,15)\n         DC    AL1(11),CL11'MULT   '\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         ST    13,4(,1)\n         ST    1,8(,13)\n         LR    13,1\n         LR    R1,R2               RESTORE CPPL PTR\n         USING @DATA,R13\n         SPACE 1\n*              IOPL --> STPB --> LSD --> LIST\n         SPACE\n$CPPL    EQU   1\n$IOPL    EQU   7\n$LSD     EQU   9\n         SPACE\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         ST    R15,PTRSTCK         ZERO IKJSTCK ADDRESS\n         LA    $IOPL,MYIOPL\n         LA    R8,MYSTPB\n         SPACE\n         USING CPPL,$CPPL\n         USING IOPL,$IOPL\n         USING LSD,$LSD\n         SPACE\n*                             INITIALIZE THE IOPL\n         L     R2,CPPLUPT\n         ST    R2,IOPLUPT\n         L     R2,CPPLECT\n         ST    R2,IOPLECT\n         LA    R2,MYECB\n         ST    R2,IOPLECB\n*              IOPLIOPB WILL BE INITIALIZED BY THE STACK MACRO\n         SPACE\n*        STPB WILL BE INITIALIZED BY THE STACK MACRO\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n*        L     R0,=A(STACKPCL)\n         LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R13,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         AIF   (NOT &MVS).SKIP1\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n.SKIP1   ANOP\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    OKPARSE\n         LA    R15,12\n         B     EXIT\nOKPARSE  EQU   *\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         LA    R1,LIST             POINT TO IN-STORAGE LIST\n         ST    R1,NEXTPTR          SAVE NEXT RECORD ADDRESS\n         SPACE\n*\n*              ISOLATE SUBCOMMANDS\n*\n         LA    R2,SUBCHAIN\n         TM    6(R2),X'80'         PRESENT?\n         BZ    SCX                 NO - BRANCH\n         LH    R5,4(,R2)           GET LENGTH\n         CH    R5,=H'2'            LENGTH AT LEAST 2\n         BL    SCX                 NO - BRANCH\n         L     R4,0(,R2)           POINT TO STRING\n         MVC   DELIMITR(1),0(R4)   USE FIRST BYTE AS DELIMITER\n         LA    R4,1(,R4)           POINT PAST DELIMITER\n         BCTR  R5,0                REDUCE LENGTH BY 1\nSCNEXT   L     R6,NEXTPTR\n         LA    R6,4(,R6)\n         SLR   R1,R1\nSCLOOP   CLC   0(1,R4),DELIMITR    DELIMITER?\n         BE    SCSEMI              YES - BRANCH\n         IC    R0,0(,R4)\n         STC   R0,0(,R6)\n         LA    R4,1(,R4)\n         LA    R6,1(,R6)\n         LA    R1,1(,R1)\n         BCT   R5,SCLOOP\nSCSEMI   LTR   R1,R1\n         BZ    SCNULL\n         LA    R1,4(,R1)\n         L     R15,NEXTPTR\n         STH   R1,HALF\n         MVC   0(2,R15),HALF\n         XC    2(2,R15),2(R15)\n         LA    R15,0(R1,R15)\n         ST    R15,NEXTPTR\nSCNULL   LA    R4,1(,R4)\n         LTR   R5,R5\n         BZ    SCX\n         BCT   R5,SCNEXT\nSCX      LA    R14,LIST\n         C     R14,NEXTPTR         ANYTHING TO STACK?\n         BNE   OKSTRING            YES - BRANCH\n         LA    R15,12              NO - EXIT\n         B     EXIT\nOKSTRING EQU   *\n         L     R15,NEXTPTR\n         SLR   R15,R14             GET LENGTH\n         STH   R15,LISTOTLN\n         SPACE\n*                             GET AND INITIALIZE THE LSD\n         LH    0,LISTOTLN          GETMAIN FOR LIST\n         A     0,SP78                          AND LSD (16 BYTES)\n         GETMAIN R,LV=(0)\n         LR    $LSD,1\n         LA    R14,16(,1)          REG 14 --> LIST\n         ST    R14,LSDADATA\n         ST    R14,LSDANEXT\n         SR    R14,R14\n         STH   R14,LSDRCLEN\n         LH    R14,LISTOTLN\n         STH   R14,LSDTOTLN\n         SPACE\n         BCTR  R14,0               LENGTH FOR EX\n         EX    R14,MVLIST          MOVE LIST INTO SUBPOOL 78\n         SPACE\n         AIF   (NOT &MVS).SKIP2\n         L     R15,16              CVTPTR\n         TM    472(R15),X'80'      IS IKJSTCK IN LPA\n         BNO   *+12                NO, BRANCH TO LOAD\n         L     R15,472(,R15)       YES, LOAD CVTSTCK\n         B     SETSTCK             BRANCH AROUND LOAD\n.SKIP2   ANOP\n         LA    R0,=CL8'IKJSTCK'\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY POINT ADDRESS\n         LA    R15,0(,R15)         ZERO HIGH ORDER BYTE\nSETSTCK  ST    R15,PTRSTCK         SAVE ADDRESS OF IKJSTCK\n         SPACE\n         LR    R1,$IOPL\n         CLI   LISTKW+1,1          'LIST' SPECIFIED?\n         BE    LISTEM              YES - BRANCH\n         SPACE\n         STACK PARM=(R8),STORAGE=(($LSD),PROCN),ENTRY=(15),MF=(E,(1))\n         SPACE\n         B     STACKED\nLISTEM   EQU   *\n         SPACE\n         STACK PARM=(R8),STORAGE=(($LSD),PROCL),ENTRY=(15),MF=(E,(1))\n         SPACE\nSTACKED  LTR   R15,R15\n         BZ    EXIT0\n         L     R15,PTRSTCK\n         LR    R1,$IOPL\n         STACK PARM=(R8),DELETE=ALL,ENTRY=(15),MF=(E,(1))\n         SPACE\n         LA    0,L'STACKMSG\n         LA    1,STACKMSG\n         TPUT (1),(0),R\n         LA    R15,16\n         B     EXIT\nEXIT0    LA    15,0\nEXIT     LR    R2,R15              SAVE RETURN CODE\n         L     R15,PTRSTCK\n         LTR   R15,R15             WAS IKJSTCK LOADED\n         BNP   EXITX               NO, BRANCH\n         LA    R0,=CL8'IKJSTCK'\n         DELETE EPLOC=(0)\nEXITX    LR    R15,R2              RESTORE RETURN CODE\n         LR    1,13\n         L     R0,@SIZE\n         L     13,4(,13)\n         LR    R2,R15\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(13)\n         L     R14,12(,13)\n         BR    R14\n         SPACE 1\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMVLIST   MVC   16(0,1),LIST        MOVE LIST TO SUBPOOL 78 AFTER LSD\nSTACKMSG DC    CL28'STACK ERROR'\nSP78     DC    0F'0',AL1(78),AL3(16) SUBPOOL 78\n         LTORG\nPATCH    DC    4D'0'               PATCH AREA\n         SPACE\nDDNAM    EQU   40                  DCB OFFSET\nEXLST    EQU   36                  DCB OFFSET\nPCLADDR  DC    0D'0'               END MAIN CSECT, BEGIN PCL CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSTACKPCL IKJPARM\nSUBCHAIN IKJPOSIT PSTRING\nLISTKW   IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F\nDOUBLE   DS    D\nHALF     EQU   DOUBLE,2\nLINKAREA DS    2F\nPTRSTCK  DS    F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F\nMYIOPL   DS    4F\nMYSTPB   DS    8F\nDELIMITR DS    C\nLISTOTLN DS    H\nNEXTPTR  DS    F\nLIST     DS    0D,F\n         DS    256X\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n         IKJCPPL\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJPPL\n         SPACE 2\n         IKJLSD\n         SPACE 2\n         IKJSTPB\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY MULT(''V 2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    MULT'\n PUNCH ' NAME     MULT(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NCFOSATH": {"ttr": 30730, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00o\\x00o\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE ' N C C F   A U T H O R I Z A T I O N   R O U T I N E'\nNCFOSATH CSECT\n***********************************************************************\n* THIS IS THE TSSO AUTHORIZATION ROUTINE. IT IS CALLED BY THE NCCF    *\n* VERSION OF OSCMD TO                                                 *\n* DETERMINE THE AUTHORITY LEVEL OF THE NCCF USER TO ISSUE MVS COMMANDS*\n*                                                                     *\n* THE AUTHORIZATION BYTE RETURNED BY THIS MODULE SHOULD BE IN THE FORM*\n* REQUIRED BY THE TSSOPCMD ROUTINE. TO ALLOW FOR THE CASE WHERE NO    *\n* ACCESS IS RETURNED, A RETURN CODE 4 ISRETURNED TO OSCMD. THIS MODULE*\n* CAN BE REPLACED, AND THEN RELINKED INTO NCFOSCMD AS DESIRED BY THE  *\n* INSTALLATION.                                                       *\n*                                                                     *\n*                                                                     *\n* ARGUMENTS: 0(R1) - ADDRESS OF A 8 BYTE FIELD CONTAINING THE USERID  *\n* ARGUMENTS: 4(R1) - ADDRESS OF A 1 BYTE FIELD CONTAINING THE AUTH BYTE\n*\n* RETURN CODES:\n*\n* 0: NCFOSATH SUCCESSFULL: AUTHORITY BYTE RETURNED IN PARM LIST.      *\n* 4: NCFOSATH SUCCESSFULL: NO ACCESS TO NCFOSCMD IS PERMITTED.        *\n*\n* ANYTHING ELSE: NCFOSATH UNSUCCESSFULL - ABORT COMMAND.\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF NCFOSATH\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING NCFOSATH,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING AUTHDATD,R11\n***********************************************************************\n* PROCESS PARAMETERS...                                               *\n*                                                                     *\n***********************************************************************\n         L     R2,0(R8)              GET ADDRESS OF USERID\n         MVC   USERID(8),0(R2)       AND PUT THAT AWAY, ALSO\n*\n         L     R2,4(R8)              GET ADDRESS OF AUTHBYTE\n         ST    R2,AAUTH              PUT IT AWAY.\n*\nFULLAUTH DS    0H\n         CLC   USERID(8),=CL8'CONSINFO'   INFO ONLY USER ?\n         BE    INFOAUTH\n         CLC   USERID(8),=CL8'CONSNOAT'   INFO ONLY USER ?\n         BE    NOAUTH\n         MVI   AUTHBYTE,B'11100001'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nPARTAUTH DS    0H\n***********************************************************************\n* IN OUR CASE, PART AUTHORITY MEANS I/O ONLY                          *\n***********************************************************************\n         MVI   AUTHBYTE,B'01000000'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nINFOAUTH DS    0H\n         MVI   AUTHBYTE,B'00000000'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nNOAUTH   DS    0H\n         MVI   AUTHBYTE,B'00000000'  AS DEFINED BY TSSOPCMD\n         MVC   RETCODE(2),=H'4'\n         B     PASTAUTH\nPASTAUTH DS    0H\n         L     R2,AAUTH              GET ADDRESS OF OSCMD AUTHBYTE\n         MVC   0(1,R2),AUTHBYTE      AND PUT IT IN CALLER PARM LIST\n         B     ENDPROG\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n***********************************************************************\n* DATA AREA FOR NCFOSATH CONSTANTS.                                   *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n* DSECT AREA FOR NCFOSATH                                             *\n*                                                                     *\n***********************************************************************\nAUTHDATD DSECT\nAAUTH    DS    A                  ADDRESS OF AUTH BYTE PASSED TO US\nUSERID   DS    CL8\nRETCODE  DS    H                  RETURN CODE FROM NCFOSATH\nAUTHBYTE DS    XL1                LOCAL COPY OF AUTHBYTE\n         IKJPSCB\n         END   NCFOSATH\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY NCFOSATH(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    NCFOSATH'\n PUNCH ' NAME     NCFOSATH(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NCFOSCMD": {"ttr": 30977, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x02@\\x02@\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 576, "newlines": 576, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE ' N C C F   I N T E R F A C E   TO T S S O '\n***********************************************************************\n* THIS MODULE IS THE NCCF INTERFACE TO THE TSSO PRODUCT. THE INTERFACE*\n* IS IN THE FORM OF A COMMAND PROCESSOR THAT WILL CALL THE TSSOPCMD   *\n* INTERFACE. THIS INTERFACE WILL RETURN THE RESPONSE TO AN OPERATOR   *\n* COMMAND, WHICH WILL THEN BE DISPLAYED AT THE NCCF OPERATORS CONSOLE *\n*                                                                     *\n* NOTE THAT THE NCCF OPERATOR HAS THE ABILITY TO ROUTE THESE OSCMDS   *\n* AROUND THE VTAM NETWORK.                                            *\n*                                                                     *\n*                                                                     *\n* COMMAND SYNTAX:                                                     *\n*                                                                     *\n*       OSCMD MVS-CMD                                                 *\n*                                                                     *\n* WHERE: MVS-CMD IS THE MVS, JES2 OR OTHER SUBSYSTEM COMMAND          *\n*        TO BE ISSUED.                                                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         DSICBS DSICWB,DSITIB,DSITVB,DSIMVT,DSIPDB,DSICBH,DSISVL,      *\n               DSISWB,PRINT=NO\nNCFOSCMD CSECT\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSCMD\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING NCFOSCMD,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         USING DSICWB,R8          GET ADDRESSABILITY TO DSICWB\n         LA    R9,CWBSAVEA\n         ST    R9,8(R13)          SAVE OUR SAVE AREA IN HIS  SAVE AREA\n         ST    R13,4(R9)          SAVE HIS SAVE AREA ADDRESS\n         LR    R13,R9             POINT TO SAVE AREA AND USE IT\n         USING CWBSAVEA,R13       AS WORK AREA BASE REG TO.\n         DROP  R8\n         L     R11,CWBTIB         ADDRESS THE TIB\n         USING DSITIB,R11\n         L     R10,TIBTVB\n         USING DSITVB,R10\n         L     R9,TVBMVT\n         USING DSIMVT,R9\n*\n         LA    R8,CWBADATD         POINT TO AUTOMATIC OSWRKARA\n         DSIGET LV=4096,A=(8)     ** GET SOME STORAGE **\n         LTR   R15,R15\n         BNZ   GETMERR\n         L     R8,CWBADATD\n         USING OSCMDATD,R8         AT LAST !\n         XC    0(256,R8),0(R8)            ZERO OUT DYNAMIC STORAGE\n         XC    256(256,R8),256(R8)\n         XC    512(256,R8),512(R8)\n         XC    768(256,R8),768(R8)\n         MVI   BUFMSGA,X'40'\n         MVC   BUFMSGA+1(149),BUFMSGA\n         MVC   ERROR1D(80),ERROR1C\n         MVC   ERROR2D(80),ERROR2C\n         MVC   ERROR3D(80),ERROR3C\n         MVC   ERROR4D(80),ERROR4C\n         MVC   ERROR5D(80),ERROR5C\n         MVC   NCFWTO1D(NCFWTO1E-NCFWTO1C),NCFWTO1C\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n*\n         LA    R2,MVSCMD\n         ST    R2,PARMCMD          SET UP PARMS TO TSSOPCMD\n         LA    R2,MVSCMDL\n         ST    R2,PARMCMDL\n         LA    R2,USERID\n         ST    R2,PARMUSER         SET UP ANOTHER PARM TO TSSOPCMD\n         LA    R2,ERRORCDE\n         ST    R2,PARMERR          AND ANOTHER\n         LA    R2,AUTHBYTE\n         ST    R2,PARMAUTH         AND ANOTHER\n         LA    R2,WAITTIME\n         ST    R2,PARMWTME         YET ANOTHER.\n         LA    R2,MAXLINES\n         ST    R2,PARMLINE         AND ANOTHER...\n*\n         L     R3,CWBBUF           POINT TO NCCF COMMAND BUFFER\n         USING BUFHDR,R3\n         LH    R1,HDRMLENG         GET LENGTH OF THE MESSAGE\n*                                  NOTE THAT THIS INCLUDES (OSCMD)\n         LH    R2,HDRTDISP         GET DISPLACEMENT FROM BUFFER TO\n*                                  START OF MESSAGE\n         LA    R5,0(R3,R2)         R5 NOW POINTS TO THE START OF THE\n*                                  COMMAND TEXT\n         LH    R6,HDRMLENG         LENGTH OF MESSAGE FOR LOOP CONTROL.\nLOOP1    DS    0H\n         CLI   0(R5),X'40'         SCAN FOR FIRST BLANK TO GET PAST\n         BE    ELOOP1              COMMAND NAME (OSCMD).\n         BCTR  R1,0                SUBTRACT 1 FROM TOTAL LENGTH\n*                                  OF COMMANDF\n         LA    R5,1(R5)            CONTINUE SEARCHING FOR BLANK\n         BCT   R6,LOOP1            CONTINUE TILL END OF COMMAND\n         MVC   RETCODE(4),=F'8'\n         LA    R15,1\n         B     ERRORRTN            ** ERROR 1 - INVALID MVS COMMAND **\nELOOP1   DS    0H\n***********************************************************************\n* WHEN WE GET HERE, R5 POINTS TO THE FIRST BLANK CHARACTER IN THE     *\n* BUFFER, AND R1 HAS THE LENGTH OF THE BUFFER EXCLUDING THE COMMAND   *\n* WE MUST NOW SEARCH FOR THE FIRST NON BLANK CHARACTER, AS THIS WILL  *\n* MARK THE START OF THE MVS COMMAND TO BE ISSUED.                     *\n***********************************************************************\nLOOP2    DS    0H\n         CLI   0(R5),C' '           FOUND ANOTHER BLANK ?\n         BNE   ELOOP2               NO, STOP LOOKING\n         LA    R5,1(R5)             NEXT CHARACTER\n         BCTR  R1,0                 AND 1 OFF FROM LENGTH\n         BCT   R6,LOOP2\n         MVC   RETCODE(4),=F'8'\n         LA    R15,1\n         B     ERRORRTN            ** ERROR 1 - INVALID MVS COMMAND **\nELOOP2   DS    0H\n         ST    R1,MVSCMDL\n***********************************************************************\n* WHEN WE COME HERE, R5 POINTS TO THE START OF THE MVS COMMAND TO BE  *\n* ISSUED, AND R1 HAS ITS LENGTH.                                      *\n***********************************************************************\n         L     R4,MVSCMDL\n         BCTR  R4,0\n         EX    R4,MOVECMD\n         B     AR2\nMOVECMD  MVC   MVSCMD(0),0(R5)\nAR2      DS    0H\n*\n         DROP  R3                ** BUFHDR **\n***********************************************************************\n* WE NOW HAVE THE MVS COMMAND, AND ITS LENGTH. WE MUST OBTAIN OR      *\n* FABRICATE THE OTHER PARAMETERS REQUIRED BY THE TSSOPCMD ROUTINE. WE *\n* WILL DO THESE ONE AT A TIME.                                        *\n***********************************************************************\n* THE NEXT STEP IS TO CHECK IF TSSO IS UP AND RUNNING. WE DO THIS BY  *\n* EXAMINING THE TSSO CVT.                                             *\n***********************************************************************\n         GETCVT (R6)\n         LTR   R6,R6           IS TSSO EVEN THERE ?\n         BZ    ERROR3           NO, BLOW HIM AWAY\n         USING TSSOCVT,R6\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR3\n         TM    TSSOFLG2,TSSOPLOA WAS OPCMD LOADED ?\n         BNO   ERROR3            BAD NEWS...\n         L     R2,OPCMDADR       GET OPCMD ADDRESS\n         ST    R2,AOPCMD         AND PUT IT AWAY FOR LATER\n         DROP  R6\n***********************************************************************\n         TESTAUTH FCTN=1         ARE WE ALREADY APF AUTHORIZED ?\n         LTR   R15,R15\n         BZ    AUTHOK\nNEEDAUTH DS    0H\n         GETCVT (R6),NDSA=YES    GET THE NDSA\n         USING TSSONDSA,R6\n         L     R2,TSSOLX        GET TSSO LINKAGE INDEX\n         DROP  R6\n         O     R2,=X'00000001'  OBTAIN PC SERVICE NUMBER\n         STM   R14,R12,12(R13)   REMEMBER REGS\n         L     R15,=CL4'TAPF'   WHATEVER\n         LA    R0,20            WHAT EVER\n         PC    0(R2)            GET AUTHORIZED\n         LM    R14,R12,12(R13)\n         OI    FLAGS,X'80'      MARK AUTHORIZATION AS REQUIRED.\n         TESTAUTH FCTN=1\n         LTR   R15,R15\n         BZ    AUTHOK\n         LA    R15,2\n         B     ERRORRTN\n*\nAUTHOK   DS    0H\n***********************************************************************\n* SET UP THE \"LINES\" PARAMETER.                                       *\n*                                                                     *\n***********************************************************************\n         MVC   MAXLINES(4),=F'200'     LINES IS ALWAYS 200 MAX\n*\n***********************************************************************\n* SET UP THE \"TIME\" PARAMETER                                         *\n*                                                                     *\n***********************************************************************\n*\n         MVC   WAITTIME(4),=F'150'      MAX WAIT IS 1.5 SECOND\n***********************************************************************\n* SET UP THE \"USERID\" PARAMETER                                       *\n*                                                                     *\n***********************************************************************\n*\n         MVC   USERID(8),TVBOPID      USE THE OPID FIELD\n*\n***********************************************************************\n* SET UP THE AUTHBYTE FIELD, BY CALLING THE USER EXIT - IF PRESENT    *\n*                                                                     *\n***********************************************************************\n         L     R15,=V(NCFOSATH)      GET ADDRESS OF EXIT\n         LTR   R15,R15\n         BZ    DEFAUTH\n         CALL  (15),(USERID,AUTHBYTE),MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR5\n         B     GOTAUTH\nDEFAUTH  DS    0H\n         MVI   AUTHBYTE,B'11100001'  *********FOR NOW ***********\n         B     GOTAUTH\nGOTAUTH  DS    0H\n***********************************************************************\n* GETMAIN THE NCCF 40K BUFFER IN WHICH THE COMMAND RESPONSE IS TO     *\n* BE PLACED. RETURN THE STORAGE TO FIELD NCCF40K                      *\n***********************************************************************\n         LA    R7,NCCF40K          POINT TO AUTOMATIC OSWRKARA\n         L     R6,=F'40000'\n         DSIGET LV=(6),A=(7)     ** GET SOME STORAGE **\n         LTR   R15,R15\n         BNZ   ERROR4\n         L     R7,NCCF40K\n         ST    R7,PARMSTOR\n*\n***********************************************************************\n* WE ARE AT LAST READY FOR THE CALL TO TSSOPCMD. WE WILL              *\n* LOAD THE ADDRESS OF ROUTINE, AND THE PARAMETERS, AND AWAY WE GO     *\n***********************************************************************\n         L     R15,AOPCMD          GET ADDRESS OF TSSOPCMD\n         LA    R1,OPCMDPRM         GET ADDRESS OF OPCMD PARMS\n         BALR  R14,R15             ** AND AWAY WE GO **\n*\n***********************************************************************\n* FOLLOWING THE RETURN FROM TSSOPCMD, WE WILL EXAMINE AND DISPLAY     *\n* ANY ERROR MESSAGE CODES WE MIGHT HAVE RECEIVED                      *\n***********************************************************************\n         LTR   R15,R15\n         BNZ   OPCMDERR\n*\n         BAL   R14,DEAUTH\n***********************************************************************\n***********************************************************************\n* THE OPERATOR COMMAND COMPLETED SUCESSFULLY. NOW, WE WILL            *\n* DISPLAY THE RESULTS FOR THE NCCF OPERATOR                           *\n***********************************************************************\n         L     R4,PARMSTOR          GET ADDRESS OF STORAGE\n         L     R1,0(R4)             GET NUMBER OF LINES RETURNED\n         ST    R1,NUMLINES          AND KEEP FOR LATER\n         LA    R4,4(R4)             START AT BEGINNING OF BUFFER\n*\n         L     R3,NUMLINES          LOOP CONTROL\n         XR    R6,R6                LINES PRINTED SO FAR\nPLOOP    DS    0H\n*\n         C     R3,NUMLINES          ANOTHER LINE PRINTED?\n         BE    FIRST                NOPE...\n*\n         CH    R3,=H'1'             INDICATE TITLE LINE\n         BE    LAST\n*\nMIDDLE   DS    0H\n         OI    BUFFLAGS,X'40'       INDICATE MIDDLE LINE\n         B     PUTMSGIT\n*\nFIRST    DS    0H\n         OI    BUFFLAGS,X'80'       INDICATE FIRST  LINE\n         B     PUTMSGIT\n*\nLAST     DS    0H\n         OI    BUFFLAGS,X'20'       INDICATE LAST.  LINE\n         B     PUTMSGIT\n*\nPUTMSGIT DS    0H\n         MVC   BUFMSGA(150),0(R4)\n         BAL   R14,PUTMSG\n         LA    R4,150(R4)\n         BCT   R3,PLOOP\n*\n         B     ENDPROG\nPUTMSG   DS    0H\n***********************************************************************\n* THIS SERVICE ROUTINE WILL PUT A 150 BYTE MESSAGE OUT TO THE NCCF    *\n* OPERATOR. THE MESSAGE MUST HAVE PREVIOUSLY BEEN SET UP IN VARIABLE  *\n* BUFMSGA.                                                            *\n***********************************************************************\n         ST    R14,SAVE14B\n         LA    R2,BUFFER\n         USING BUFHDR,R2\n*\n*\n         LA    R0,BUFHDRND-BUFHDR\n         STH   R0,HDRTDISP\n*\n         MVI   HDRMTYPE,C'U'\n*\n         LA    R0,BUFFEND-BUFFER\n         STH   R0,HDRBLENG\n*\n         MVC   HDRDOMID(8),MVTCURAN\n*\n         LA    R0,100\n         STH   R0,HDRMLENG\n*\n         BAL   R14,GETTIME\n         ST    R1,HDRTSTMP\n         L     R1,CWBSWB\n         TM    BUFFLAGS,X'80'                  OPTIONS=FIRST REQUESTED?\n         BO    TYPEF\n         TM    BUFFLAGS,X'40'               OPTIONS=MIDDLE?\n         BO    TYPEM\n         TM    BUFFLAGS,X'20'               OPTIONS=END?\n         BO    TYPEL\n         TM    BUFFLAGS,X'10'\n         BO    TYPEMSG\n         TM    BUFFLAGS,X'08'\n         BO    TYPESEG\n*\n***********************************************************************\n* NO SPECIAL NCCF PROCESSING IS REQUIRED...                           *\n*                                                                     *\n***********************************************************************\nTYPEORD  DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2)\n         B     PSSEND\nTYPEF    DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2),OPTIONS=FIRST\n         B     PSSEND\nTYPEM    DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2),OPTIONS=MIDDLE\n         B     PSSEND\nTYPEL    DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2),OPTIONS=LAST\n         B     PSSEND\nTYPESEG  DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2),OPTIONS=SEG\n         B     PSSEND\nTYPEMSG  DS    0H\n         DSIPSS SWB=(1),TYPE=OUTPUT,BFR=(2),OPTIONS=MSG\n         B     PSSEND\n*\nPSSEND   DS    0H\n         CH    R15,=H'16'         RC 16 - SCREEN FILLED UP....\n         BE    PSSOK              THIS IS NOT A PROBLEM\n         CH    R15,=H'24'         RC 24 - FIRST, MIDDLE AND END IN\n*                                 WRONG ORDER ...\n         BE    PSSOK              ALSO NOT A PROBLEM\n         LTR   R15,R15\n         BNZ   PSSERR\n*\nPSSOK    DS    0H\n         L     R14,SAVE14B\n         MVI   BUFMSGA,X'40'\n         MVC   BUFMSGA+1(149),BUFMSGA\n         XC    BUFFLAGS(2),BUFFLAGS\n         BR    R14\nPSSERR   DS    0H\n***********************************************************************\n* WE COME HERE IN CASE OF AN ERROR PROCESSING THE NCCF MESSAGE. THE   *\n* RETURN CODE IS (IN LIEU OF A BETTER PLACE) WRITTEN TO THE MVS       *\n* OPERATORS CONSOLE.                                                  *\n***********************************************************************\n         ST    R10,SAVER10\n         LA    R10,OSWRKARA\n         LR    R1,R15\n         CALL  JCECVTBD\n         ST    R1,NCFWTO1D+32\n         L     R10,SAVER10\n         WTO   MF=(E,NCFWTO1D)\n         B     ENDPROG\n         XC    RETCODE(2),RETCODE\n         B     ENDPROG\n*\nDEAUTH   DS    0H\n         TM    FLAGS,X'80'            DID WE USE TSSO TO GET AUTH ?\n         BNO   DEAUTHE                NO, DONT DEAUTH...\n         MODESET KEY=ZERO\n         L     R1,X'21C'               TCB\n         USING TCB,R1\n         L     R1,TCBJSCB             GET TCBJSCB\n         USING IEZJSCB,R1             BASE ON JSCB\n         NI     JSCBOPTS,255-JSCBAUTH FLIP BIT\n         DROP  R1\n         MODESET KEY=NZERO,MODE=PROB\nDEAUTHE  DS    0H\n         BR    R14\n*\nOPCMDERR DS    0H\n***********************************************************************\n* WE COME HERE IN CASE OF A NON ZERO RETURN CODE FROM THE TSSOPCMD    *\n* MODULE. IF THIS IS THE CASE, WE WILL DISPLAY AN APPROPRIATE ERROR   *\n* MESSAGE. NOTE THE THE ERROR MESSAGES ARE KEPT IN THE OPCMDMSG CSECT *\n***********************************************************************\n         L     R5,=V(OPCMDMSG)\n         LR    R3,R15                 COPY THE RETURN CODE\n*\n         BAL   R14,DEAUTH\n*\n         BCTR  R3,0                   MULTIPLICATION WORKS BETTER\n         SRL   R3,2                   DIVIDE BY 4\n         M     R2,=F'80'              AND MULTIPLY BY 80\n         AR    R5,R3                  R5  NOW POINTS TO THE MSG TO\n*                                     BE DISPLAYED.\n         LA    R5,4(R5)               POINT PAST TSO NONSENSE\n         MVC   BUFMSGA(76),0(R5)\n         BAL   R14,PUTMSG\n         B     ENDPROG\n*\nENDPROG  DS    0H\n         L     R7,RETCODE\n         DSIFRE R,LV=4096,A=(8)   FREEMAIN THE PRIVATE STORAGE\n         L     R13,4(R13)          RESTORE R13\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R7              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nERROR3   DS    0H\n*\n         LA    R15,3\n         XC    RETCODE(4),RETCODE  NO SENSE IN RETRYING...\n         B     ERRORRTN\n*\nERROR4   DS    0H\n*\n         LA    R15,4\n         XC    RETCODE(4),RETCODE  NO SENSE IN RETRYING...\n         B     ERRORRTN\n*\nERROR5   DS    0H\n*\n         BAL   R14,DEAUTH\n*\n         LA    R15,5\n         XC    RETCODE(4),RETCODE  NO SENSE IN RETRYING...\n         B     ERRORRTN\n*\nGETTIME  DS    0H\n         ST    R14,SAVE14\n         DSIDATIM AREA=PACKAREA,FORMAT=BINARY\n         L     R1,PACKAREA+4\n         L     R14,SAVE14\n         BR    R14\nGETMERR  DS    0H\n         WTO   'NCFOSC01 GETMAIN FAILURE IN NCCF OSCMD MODULE',DESC=1\n         LA    R7,8\n         B     ENDPROG1\nERRORRTN DS    0H\n***********************************************************************\n* THIS IS THE ERROR HANDLER FOR THE NCFOSCMD MODULE. STANDARD PROCEDUR*\n* IS TO TAKE THE ERROR CODE IN R15, AND PUT A MESSAGE OUT THE NCCF    *\n* CONSOLE. THE RETURN CODE TO BE SET IS PLACED IN VARIABLE RETCODE    *\n* BY THE CALLER.                                                      *\n***********************************************************************\n         BCTR  R15,0\n         M     R14,=F'80'\n         LA    R14,ERRTAB\n         AR    R14,R15\n         MVC   BUFMSGA(80),0(R14)\n         BAL   R14,PUTMSG\n         B     ENDPROG\n***********************************************************************\n* CONSTANTS FOR THE NCFOSCMD PROGRAM                                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nNCFWTO1C WTO   'DSIPSS                                        ',MF=L\nNCFWTO1E EQU   *\nTESTMSG  DC    CL150'THIS IS A TEST OF THE EMERGENCY BROADCAST SYSTEM'\nWTO1C    WTO   'DSIPSS                                        ',MF=L\nWTO1CE   EQU   *\nERROR1C  DC    CL80'OSCMD TERMINATING - MISSING OR INVALID MVS COMMAND'\nERROR2C  DC    CL80'OSCMD TERMINATING - FUNCTION IS LACKING APF AUTHORIX\n               ZATION'\nERROR3C  DC    CL80'OSCMD TERMINATING - TSSO IS UNAVAILABLE TO PROCESS X\n               THE COMMAND'\nERROR4C  DC    CL80'OSCMD TERMINATING - NCCF WAS UNABLE TO FIND A 40K  X\n               BUFFER'\nERROR5C  DC    CL80'OSCMD TERMINATING - YOU ARE NOT AUTHORIZED TO USE IX\n               T'\nOSCALL1C CALL  ,(0,0),MF=L\nOSCALL1E EQU   *\n         LTORG\n***********************************************************************\n* DSECT AREA FOR THE NCFOSCMD PROGRAM                                 *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nOSCMDATD DSECT\nFLAGS    DS    F\n* X'80' WE USED THE TSSO ROUTINE TO OBTAIN APF AUTHORIZATION\nOURJSCB  DS    F\nNUMLINES DS    F\nSAVE14   DS    F\nSAVE14B  DS    F\nTVBADDR  DS    F\nRETCODE  DS    F\nPACKAREA DS    D\nBUFFER   DS    0D\n         DS    XL(BUFHDRND-BUFHDR)    BUFFER HEADER FOR OUTPUT\nBUFMSGA  DS    CL150\nBUFFEND  EQU   *\nOSWRKARA DS    CL200\n*\nMVSCMD   DS    CL150\n*\nMVSCMDL  DS    F                LENGTH OF THE MVS COMMAND\n*\nMAXLINES DS    F                MAXIMUM NUMBER OF LINES IN CMD RESP.\n*\nWAITTIME DS    F                MAXIMUM WAIT TIME, IN .01 SECS\n*\nAOPCMD   DS    A                ADDRESS OF THE TSSOPCMD ROUTINE\n*\nERRORCDE DS    F                ERROR  CODE FROM THE TSSOPCMD MODULE\n*\nAUTHBYTE DS    XL2              AUTHORIZATION BYTE TO PASS TO TSSOPCMD\n*\nUSERID   DS    CL8              USERID TO PASS TO THE TSSOPCMD ROUTINE\n*\nNCCF40K  DS    F                ADDRESS OF THE 40K BUFFER.\n*\nNCFWTO1D WTO   'DSIPSS                                        ',MF=L\n*\n*\nBUFFLAGS DS    H\n* X'80' - SPECIAL NCCF PROCESSING REQUIRED - OPTIONS=FIRST\n* X'40' - SPECIAL NCCF PROCESSING REQUIRED - OPTIONS=MIDDLE\n* X'20' - SPECIAL NCCF PROCESSING REQUIRED - OPTIONS=LAST\nSAVER10  DS    F\nOPCMDPRM DS    0D                 PARAMETER LIST FOR TSSOPCMD\nPARMCMD  DS    A   0(R1)          ADDRESS OF THE MVS COMMAND\nPARMCMDL DS    F   4(R1)          LENGTH OF THE MVS COMMAND\nPARMWTME DS    F   8(R1)          MAXIMUM WAIT TIME - IN SECONDS\nPARMLINE DS    F  12(R1)          MAXIMUM LINES FOR COMMAND\nPARMAUTH DS    A  16(R1)          AUTHORIZATION BYTE FOR COMMAND\nPARMUSER DS    A  20(R1)          A(USERID OF THE OSCMD FACILITY)\nPARMSTOR DS    A  24(R1)          ADDRESS OF A 40K BUFFER\nPARMERR  DS    A  28(R1)          ADDRESS OF A REASON CODE.\nPARMREAS DS    A  32(R1)          ADDRESS OF THE REASON CODE.\nERRTAB   DS    0D\nERROR1D  DC    CL80'OSCMD TERMINATING - MISSING OR INVALID MVS COMMAND'\nERROR2D  DC    CL80'OSCMD TERMINATING - FUNCTION IS LACKING APF AUTHORIX\n               ZATION'\nERROR3D  DC    CL80'OSCMD TERMINATING - TSSO IS UNAVAILABLE TO PROCESS X\n               THE COMMAND'\nERROR4D  DC    CL80'OSCMD TERMINATING - NCCF WAS UNABLE TO FIND A 40K  X\n               BUFFER'\nERROR5D  DC    CL80'OSCMD TERMINATING - YOU ARE NOT AUTHORIZED TO USE IX\n               T'\nOSCALL1D CALL  ,(0,0),MF=L\n         TSSOCVT\n         TSSONDSA\n         OSCMDICB\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\n         IEZJSCB\n         IKJTCB\n         END   NCFOSCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY NCFOSCMD(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(NCFOSATH)'\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(OPCMDMSG)'\n PUNCH ' ENTRY    NCFOSCMD'\n PUNCH ' NAME     NCFOSCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPCMDMSG": {"ttr": 30987, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00/\\x00/\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "TSSO403"}, "text": "OPCMDMSG CSECT\n***********************************************************************\n* THIS IS THE ERROR MESSAGE CSECT FOR THE TSSOPCMD MODULE. TO OBTAIN  *\n* AN ERROR MESSAGE, SIMPLY LOAD THIS CSECT, THE USING THE RETURN      *\n* CODE FROM TSSOPCMD, DIVIDE BY 4, SUBTRACT 1, MULTIPLY BY 80 AND     *\n* THE NEXT 80 BYTES PERTAIN TO THE ERROR.                             *\n*                                                                     *\n***********************************************************************\nLINE1HC  DC    H'80',H'0'\nLINE1H   DC    CL76'TSSOPCMD FAILED BECAUSE IT WAS NOT INVOKED AUTHORIZX\n               ED'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'TSSOPCMD FAILED BECAUSE THE MVS COMMAND TO BE ISSUEX\n               D WAS INVALID'\n*\nLINE3HC  DC    H'80',H'0'\nLINE3H   DC    CL76'TSSOPCMD FAILED BECAUSE THE TIME PARAMETER WAS INVAX\n               LID'\n*\nLINE4HC  DC    H'80',H'0'\nLINE4H   DC    CL76'TSSOPCMD FAILED BECAUSE THE LINES PARAMETER WAS INVX\n               ALID'\n*\nLINE5HC  DC    H'80',H'0'\nLINE5H   DC    CL76'TSSOPCMD FAILED BECAUSE THE AUTHORIZATION PARAMETERX\n                WAS INVALID'\n*\nLINE6HC  DC    H'80',H'0'\nLINE6H   DC    CL76'TSSOPCMD FAILED BECAUSE ALL SUBSYSTEM CONSOLES ARE X\n               BUSY'\n*\nLINE7HC  DC    H'80',H'0'\nLINE7H   DC    CL76'TSSOPCMD FAILED BECAUSE STORAGE IN THE COMMON SERVIX\n               CE AREA IS UNAVAILABLE'\n*\nLINE8HC  DC    H'80',H'0'\nLINE8H   DC    CL76'TSSOPCMD FAILED - TSSO IS NOT ACTIVE IN THE SYSTEM'\n*\nLINE9HC  DC    H'80',H'0'\nLINE9H   DC    CL76'TSSOPCMD FAILED - RETURN CODE 36'\n         END   OPCMDMSG\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY OPCMDMSG(''TSSO VERSION 4.3  &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    OPCMDMSG'\n PUNCH ' NAME     OPCMDMSG(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ORIGAOF": {"ttr": 31234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x02C\\x02C\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 579, "newlines": 579, "modlines": 0, "user": "TSSO403"}, "text": "DISPAOF  MENTER 12,EQU,COM=DISPAOF,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n***********************************************************************\n* THIS IS THE TSSO DISPLAY AOF COMMAND. THE COMMAND WILL OPERATE ON   *\n* EITHER THE CURRENT TSSO AOF TABLE, LOCATED OFF THE TSSO CVT, OR     *\n* A TABLE THAT IS LOCATED IN A LOAD LIBRARY ACCESSABLE TO THE         *\n* PROGRAM.                                                            *\n*                                                                     *\n*\n* SYNTAX:\n*\n*      DISPAOF  MSGID(MSG-IDENTIFIER) TABLE(TABLE-NAME) TEST\n*                                     ALTTAB\n*\n*      DISPAOF  ENTRYID(ENTRY-IDENTIFIER) TABLE(TABLE-NAME) TEST\n* WHERE:\n*    MSGID- THE OS MESSAGE IDENTIFIER THAT YOU WANT INFORMATION ABOUT\n*    ENTID- THE ENTRY IDENTIFIER YOU WANT INFO ABOUT.\n*    TABNAME-  THE TSSO AOF TO LOAD PRIOR TO PROCESSING\n*    TEST -    INCLUDE INFORMATION ON THE TESTS TO PERFORM FOR EACH\n*              MESSAGE ID.\n***********************************************************************\n*\n* VERSION IDENTIFIER:  TSSO VERSION 4.3\n* AUTHOR. MARC SCHARE\n*\n* MODIFIED FOR TSSO 4.3\n*    1) SUPPORT THE ENTRYID FIELD IN AOF TABLE ENTRIES.\n*\n*\n*\n***********************************************************************\n* THE FIRST STEP IS TO PARSE THE INPUT, AND DETERMINE WHAT THE USER IS\n* AFTER.\n***********************************************************************\n         LA    R11,4095(R12)\n         LA    R11,1(R11)\n         USING DISPAOF+4096,R11\n         SETPARSE PCL=DISPARSE\n         LA    R10,CORE\n         LINK  EP=IKJPARS\n         L     R9,MYANS\n         USING IKJPARMD,R9\n*\n         LH    R2,MSGID              OBTAIN THE MESSAGE ID PARM\n         CH    R2,=H'1'              SPECIFIED ?\n         BNE   NOMSGSPE              WE NEED A MESSAGEID\n         LH    R3,MSGSUBID+4            PICK UP THE LENGTH\n         ST    R3,LMSGID             REMEMBER LENGTH OF MESSAGE ID\n         L     R4,MSGSUBID\n         BCTR  R3,0                  SUBTRACT ONE FOR EXECUTE\n         MVC   MSGSPEC(8),BLANK      BLANK MSGSPEC TO BEGIN WITH.\n         EX    R3,MOVEMSG\n         B     ARD1\nMOVEMSG  MVC   MSGSPEC(0),0(R4)      ** EXECUTED **\nARD1     DS    0H\n         OI    FLAGS,X'80'           FLAG MESSAGE AS SPECIFIED.\n         B     CHEKTBL\nNOMSGSPE DS    0H\n         MVC   MSGSPEC(8),BLANK      NO MESSAGE SPECIFIED- PRT EM ALL.\n*\nCHEKTBL  DS    0H\n         LH    R2,TABLEID            OBTAIN THE TABLE ID SPECIFIED\n         LTR   R2,R2                 SPECIFIED ?\n         BZ    NOTABLE               WE NEED A MESSAGEID\n         LH    R3,TABSUBID+4            PICK UP THE LENGTH\n         L     R4,TABSUBID\n         BCTR  R3,0                  SUBTRACT ONE FOR EXECUTE\n         EX    R3,MOVETAB\n         OI    FLAGS,X'40'           INDICATE TABLE NAME WAS SPECIFIED\n         B     ARD2\nMOVETAB  MVC   TABSPEC(0),0(R4)      ** EXECUTED **\nARD2     DS    0H\n         B     CHEKTEST\n*\nNOTABLE  DS    0H\n         MVC   TABSPEC(8),=CL8' '\n         B     CHEKTEST\n*\nCHEKTEST DS    0H\n         LH    R2,TEST               OBTAIN THE TABLE ID SPECIFIED\n         CH    R2,=H'1'              SPECIFIED ?\n         BNE   NOTEST                TEST WAS NOT SPECIFIED...\n         OI    FLAGS,X'10'\nNOTEST   DS    0H\n         B     CHEKENTR              CHECK IF ENTRY PARM SPECIFIED..\n*\nCHEKENTR DS    0H\n         LH    R2,ENTRY              CHECK IF SPECIFIED\n         CH    R2,=H'1'              WELL? WAS IT?\n         BNE   NOENTRY               GUESS NOT...\n         LH    R3,ENTSUBID+4         GET THE PDL FOR THE SPECIFIED ENT\n         ST    R3,LENTID             FOR COMPARES LATER ON\n         L     R4,ENTSUBID           POINT TO THE STRING\n         OI    FLAGS,X'20'           FLAG ENTRY AS SPECIFIED\n         BCTR  R3,0\n         EX    R3,MOVEENT\n         B     ARD3\nMOVEENT  MVC   ENTSPEC(0),0(R4)\nARD3     DS    0H\n         B     ENDENTRY\nNOENTRY  DS    0H\n         MVC   ENTSPEC(8),=CL8'ALL'\n         B     ENDENTRY\nENDENTRY DS    0H\n*\n         DROP  R9\nHAVEPARM DS    0H\n***********************************************************************\n* NOW THAT WE HAVE THE PARAMETERS, WE WILL EITHER USE THE CURRENT     *\n* TABLE ID, IN STORAGE, OR LOAD THE TABLE THAT WAS SPECIFIED... IN    *\n* EITHER CASE, WE WILL FORMAT THE ENTRIES BY WALKING THROUGH THE TABLE*\n***********************************************************************\n         TM    FLAGS,X'40'           WAS TABLE SPECIFIED ?\n         BO    LOADTABL              NO, GO LOAD THE TABLE.\n         GETCVT  R2                  START WITH TSSO CVT\n         LTR   R2,R2\n         BZ    ERROR2\n         USING TSSOCVT,R2\n         L     R2,TSSOTABL           GET TSSO TABLE ADDRESS\n         LTR   R2,R2\n         BZ    ERROR6                GET TSSO CURRENT TABLE ADDR.\n         ST    R2,TABADDR\n         DROP  R2\n         B     GOTTABL\nLOADTABL DS    0H\n         LOAD  EPLOC=TABSPEC,ERRET=TABERROR\n         ST    R0,TABADDR\n         B     GOTTABL\nTABERROR DS    0H\n         B     ERROR3\nGOTTABL  DS    0H\n***********************************************************************\n* WE NOW HAVE A TSSO TABLE, POINTED TO BY THE ADDRESS IN TABADDR      *\n* WE CAN (FINALLY) START PROCESSING THE TABLE                         *\n***********************************************************************\n         L     R2,TABADDR            LOAD ADDRESS OF TABLE\n         CLC   4(8,R2),=CL8'TSSOTABL'   VALID TSSO TABLE ?\n         BNE   ERROR4\n         CLC   44(8,R2),=CL8'TSSO 4.3'  CURRENT LEVEL OF TSSO TABLE ?\n         BNE   ERROR5\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD0H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   HEAD1+12(8),20(R2)       MOVE IN TABLE NAME\n         MVC   HEAD1+28(8),28(R2)       MOVE IN DATE ASSEMBLED\n         MVC   HEAD1+44(8),36(R2)       MOVE IN TIME ASSEMBLED\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   HEAD2+12(8),12(R2)       MOVE IN TABLE ID\n         MVC   HEAD2+31(8),44(R2)       MOVE IN VERSION IDENTIFIER\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEAD2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         L     R2,0(R2)                 POINT TO THE FIRST RECORD IN\n*                                       THE TSSO AOF.\n         XC    RECCOUNT(4),RECCOUNT     BLANK IT OUT...\nMSGLOOP  DS    0H\n***********************************************************************\n* HERE, WE HAVE THE ADDRESS OF A MSGID RECORD. WE MUST FORMAT THE\n* RECORD, AND LOOP DOWN. R2 WILL POINT TO THE RECORD\n***********************************************************************\n         LTR   R2,R2                 IS THIS A RECORD ?\n         BZ    ENDRECS               NOPE, NO MORE RECORDS !\n*\n         CLC   4(8,R2),=CL8'ZZZZZZZZ'   END OF RECORD INDICATOR\n         BE    ENDRECS                  YUP, THIS IS IT.\n*\n         L     R1,RECCOUNT\n         LA    R1,1(R1)\n         ST    R1,RECCOUNT\n*\n***********************************************************************\n* BEFORE WE ACTUALLY GO AND PRINT A MESSAGE ID, WE WILL CHECK IF      *\n* THE ENTRY ID, OR MESSAGE ID WAS SPECIFIED. THE MESSAGE MUST PASS    *\n* ALL TESTS BEFORE ACTUALLY BEING PRINTED.                            *\n***********************************************************************\nPRETEST1 DS    0H\n         TM    FLAGS,X'80'            WAS MESSAGE SPECIFIED ?\n         BNO   PRETEST2               NO, GO AND CHECK ENTRY ID.\n*\nCHECKMSG DS    0H\n         L     R1,LMSGID              GET LENGTH OF MESSAGE ID\n         BCTR  R1,0\n         EX    R1,COMMSGID\n         BE    PRETEST2\n         OI    FLAGS,X'04'            REMEMBER MSGID SPOTTED\n         B     AR7\nCOMMSGID CLC   4(0,R2),MSGSPEC        IS THIS THE MESSAGE DESIRED ?\nAR7      DS    0H\n         BNE   NEXTREC                NO, GO SEEK NEXT RECORD.\n*\nPRETEST2 DS    0H\n         TM    FLAGS,X'20'            WAS ENTRY SPECIFIED ?\n         BNO   PRETEST3\n         L     R1,LENTID              GET LENGTH OF ENTRY ID\n         BCTR  R1,0\n         EX    R1,COMPEID\n         BNE   NEXTREC\n         OI    FLAGS,X'08'\n         B     ARD6\nCOMPEID  CLC   32(0,R2),ENTSPEC       IS THIS THE RIGHT ENTRY ?\nARD6     DS    0H\n*\nPRETEST3 DS    0H\n*\n         B     PRTMSG                 GO GET NEXT RECORD\nPRTMSG   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         LH    R1,24(R2)             PICK UP RECORD ID.\n         CALL  JCECVTBD\n         STCM  R1,B'1111',LINE0+14\n*\n         MVC   LINE0+32(8),32(R2)  AND GET THE ENTRY NAME.\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE0H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         MVC   LINE1+12(8),4(R2)     MOVE IN MESSAGE ID.\n         MVC   LINE1+30(8),12(R2)    MOVE IN ACTION CODE.\n         CLC   26(2,R2),=CL2'YE'     ECHO= YES SPECIFIED ?\n         BE    ECHOYES\n         CLC   26(2,R2),=CL2'NO'     ECHO= NO SPECIFIED ?\n         BE    ECHONO\n         CLC   26(2,R2),=CL2'LO'     ECHO=LOG SPECIFIED ?\n         BE    ECHOLOG\nECHOYES  DS    0H\n         MVC   LINE1+46(3),=CL3'YES'\n         B     ENDECHO\nECHONO   DS    0H\n         MVC   LINE1+46(3),=CL3'NO'\n         B     ENDECHO\nECHOLOG  DS    0H\n         MVC   LINE1+46(3),=CL3'LOG'\n         B     ENDECHO\nENDECHO  DS    0H\nPROCMTCH DS    0H\n         L     R1,28(R2)             PICK UP MATCHLIM VALUE...\n         C     R1,=F'999999'         ANY SPECIFIED ?\n         BE    DEFMLIM               DEFAULT MATCHLIM USED.\n         CALL  JCECVTBD\n         STCM  R1,B'1111',LINE1+60   PUT LIMIT OUT ...\n         B     ENDMLIM\nDEFMLIM  DS    0H\n         MVC   LINE1+60(4),=CL4'NONE'\n         B     ENDMLIM\nENDMLIM  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         MVC   LINE2+13(67),BLANK       BLANK OUT ACTION TEXT\n         LH    R3,40(R2)             LOAD UP ACTION TEXT LENGTH\n         LTR   R3,R3                 IS THERE ANY ?\n         BNZ   LOADATEX              YUP, LOAD UP ACTION TEXT\n         MVC   LINE2+13(22),=CL22'*** NO ACTION TEXT ***'\n         B     GOTATEXT\nLOADATEX DS    0H\n         BCTR  R3,0                  FOR EXECUTE\n         EX    R3,MOVATEXT           MOVE THE ACTION TEXT\n         B     ARD5\nMOVATEXT MVC   LINE2+13(0),42(R2)    ** EXECUTED **\nARD5     DS    0H\nGOTATEXT DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS),TERMPUT=(EDIT)\n         L     R3,20(R2)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nCHKPOST  DS    0H\n***********************************************************************\n* SINCE THE ACTION=POST FUNCTION MAY OCCASIONALLY SEE DYNAMIC         *\n* ALTERATION OF THE AOF TABLE OCCURING, LETS CHECK ITS STATUS, AND    *\n* DISPLAY IF ANYONE IS USING IT.                                      *\n***********************************************************************\n         CLC   12(8,R2),=CL8'POST'    ACTION=POST SPECIFIED ?\n         BNE   PSTPOST\n         TM    42(R2),X'80'           IS THIS ENTRY ACTIVE ?\n         BNO   PSTPOST\n*\n         MVC   LINE6+9(8),32(R2)      MOVE IN THE ENTRY ID\n*\n         L     R1,50(R2)              GET THE ASCB.\n         CALL  JCECVTBH\n         STCM  R0,B'1111',LINE6+46\n         STCM  R1,B'1111',LINE6+50\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nPSTPOST  DS    0H\n***********************************************************************\n* NOW, WE MUST START HANDLING THE TEST ENTRY CASES. ANY NUMBER OF\n* TEST ENTRIES MAY HAVE BEEN SPECIFIED. THE FIRST IS POINTED TO BY\n* 20(R2) IN THE MSGID MAIN CONTROL BLOCK. SUBSEQUENT TEST PARMS ARE\n* POINTED TO BY THE FIRST WORD IN EACH TEST PARAMETER CONTROL BLOCK.\n* R3 WILL POINT TO THE TEST CONTROL BLOCK\n********************************************************************\n         TM    FLAGS,X'10'       TEST SPECIFIED ?\n         BNO   NEXTREC           NOPE, FORGET ALL TEST CONDITIONS\nTLOOP    DS    0H\n         LTR   R3,R3             ANY ADDITIONAL TEST ENTRIES ?\n         BZ    ENDTESTS\n         L     R1,6(R3)          LOAD SUBSTR OR WORD NUMBER\n         ST    R1,WORD1          TUCK AWAY\n         L     R1,10(R3)         LOAD LENGTH\n         ST    R1,WORD2          TUCK AWAY\n         MVC   WORDSEPS(4),14(R3) TUCK SEPARATORS AWAY, JUST IN CASE.\n         CLC   4(2,R3),=CL2'W'   WORD TYPE ?\n         BE    WORDTYPE          HANDLE IT\n         CLC   4(2,R3),=CL2'S'   SUBSTRING TYPE ?\n         BE    SUBSTYPE          HANDLE IT\n         CLC   4(2,R3),=CL2'P'   SUBSTRING TYPE ?\n         BE    SUBSTYPE          HANDLE IT\n********************************************************************\n* HERE, IT IS OF UNKNOWN TYPE. BEAR UP UNDER THE PRESSURE, AND\n* INFORM USER. THIS SHOULD NEVER HAPPEN.\n********************************************************************\n         MVC   LINE3W(80),=CL80'*** UNKNOWN TEST TYPE ***'\n         B     WORDTYPE          PRINT THE ERROR MESSAGE.\nWORDTYPE DS    0H\n         L     R1,WORD1          GET WORD NUMBER\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3W+12\n         L     R1,WORD2          LOAD LENGTH\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3W+27\n         MVC   LINE3W+44(4),WORDSEPS     MOVE IN SEPARATORS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3WH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     MATCHTEX\nSUBSTYPE DS    0H\n         L     R1,WORD1          GET SUBSTRING START\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0111',LINE3S+22\n         L     R1,WORD2          LOAD LENGTH\n         CALL  JCECVTBD          CONVERT\n         STCM  R1,B'0011',LINE3S+38\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3SH,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     MATCHTEX\n********************************************************************\n* NEXT, GO AND FORMAT THE MATCH STRING- IE THE STRING THAT TSSO/AOF\n* WILL BE MATCHING AGAINST.\n********************************************************************\nMATCHTEX DS    0H\n         MVC   LINE4+12(80),BLANK       BLANK OUT MATCHING TEXT.\n         LH    R4,18(R3)             GET LENGTH OF MATCHING TEXT\n         BCTR  R4,0\n         EX    R4,MOVEMTEX           MOVE THE MATCHING TEXT\n         B     ARD4\nMOVEMTEX MVC   LINE4+12(0),20(R3)    ** EXECUTED **\nARD4     DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n********************************************************************\n* NOW, LOOP BACK TO GET THE NEXT TEST ENTRY.\n********************************************************************\n         MVI   LINE4+12,X'40'\n         MVC   LINE4+13(117),LINE4+12\n         L     R3,0(R3)              GET ADDRESS OF NEXT ENTRY\n         MVC   LINE4(12),=CL12'MATCH TEXT:'\n         MVI   STARS,C'-'\n         MVC   STARS+1(79),STARS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(STARSH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     TLOOP\nENDTESTS DS    0H\n********************************************************************\n* WE GET HERE WHEN THERE ARE NO MORE TEST ENTRIES TO PROCESS.\n* WE MUST PICK UP THE NEXT MESSAGE ID ENTRY, AND WORK ON THAT.\n********************************************************************\n         MVI   STARS,C'*'\n         MVC   STARS+1(79),STARS\n         PUTLINE PARM=PUTBLOK,OUTPUT=(STARSH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nNEXTREC  DS    0H\n         L     R2,0(R2)              GET NEXT RECORD\n         B     MSGLOOP\n*\nENDRECS  DS    0H\n         TM    FLAGS,X'80'           WAS AN ENTRY ID SPECIFIED ?\n         BNO   NOMSGIDS              NO, DONT WORRY ABOUT IT\n*\n         TM    FLAGS,X'04'           WAS IT FOUND ?\n         BO    MSGSPFND              YUP, DONT WORRY ABOUT IT.\n*\n         MVC   LINE7+11(8),MSGSPEC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nNOMSGIDS DS    0H\nMSGSPFND DS    0H\n*\nCHKENTID DS    0H\n         TM    FLAGS,X'20'           WAS AN ENTRY ID SPECIFIED ?\n         BNO   NOENTID               NO, DONT WORRY ABOUT IT\n*\n         TM    FLAGS,X'08'           WAS IT FOUND ?\n         BO    ENTSPFND              YUP, DONT WORRY ABOUT IT.\n*\n         MVC   LINE5+9(8),ENTSPEC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5H,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(BLANKH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nENTSPFND DS    0H\nNOENTID  DS    0H\n         L     R1,RECCOUNT\n         CALL  JCECVTBD\n         STCM  R1,B'1111',TRAIL+31\n         PUTLINE PARM=PUTBLOK,OUTPUT=(TRAILH,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR1H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR2H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR3   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR3H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR4H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR5H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR6H,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nENDPROG  DS    0H\n         MLEAVE\nCORE     DS    CL200            USED BY PARSE ROUTINE\nMSGSPEC  DS    CL8              MESSAGE ID AS SPECIFIED BY USER\nTABSPEC  DC    CL8' '           TABLE NAME SPECIFIED FOR LOAD\nENTSPEC  DS    CL8              ENTRY ID SPECIFIED BY USER\nTABADDR  DS    A                ADDRESS OF AOF TABLE FOR THIS RUN\nLENTID   DS    F                LENGTH OF THE SPECIFIED ENTRY ID\nLMSGID   DS    F                LENGTH OF THE SPECIFIED MSG ID\nWORD1    DS    F                FOR TEST CASES: SUBSTR START, OR WORD\nWORD2    DS    F                FOR TEST CASES: LENGTH\nWORDSEPS DS    CL4              FOR TEST CASES: SEPARATOR CHARS\nRECCOUNT DS    F                TOTAL NUMBER OF MSGID RECORDS\nFLAGS    DC    H'0'\n* FIRST BYTE:\n* X'80' - A MSGID WAS SPECIFIED\n* X'40' - A TABLE NAME WAS SPECIFIED.\n* X'20' - A ENTRY ID WAS SPECIFIED ...\n* X'10' - TEST WAS SPECIFIED...\n* X'08' - ENTRY ID WAS SPECIFIED, AND ACTUALLY FOUND IN THE TABLE.\n* X'04' - MSG   ID WAS SPECIFIED, AND ACTUALLY FOUND IN THE TABLE.\nBLANKH   DC    H'80',H'0'\nBLANK    DC    CL80' '\n*\nSTARSH   DC    H'80',H'0'\nSTARS    DC    80C'*'\n*\nERROR1H  DC    H'80',H'0'\nERROR1T  DC    CL80'A MESSAGE ID MUST BE SPECIFIED- REQUEST ABORTED'\n*\nERROR2H  DC    H'80',H'0'\nERROR2T  DC    CL80'TSSO IS UNABLE TO LOAD THE INSTORAGE VERSION OF THEX\n                TABLE'\n*\nERROR3H  DC    H'80',H'0'\nERROR3T  DC    CL80'LOAD ERROR TRYING TO LOAD THE TSSO TABLE           X\n                     '\n*\nERROR4H  DC    H'80',H'0'\nERROR4T  DC    CL80'THE TABLE LOADED IS NOT A VALID TSSO TABLE         X\n               '\nERROR5H  DC    H'80',H'0'\nERROR5T  DC    CL80'THE TABLE LOADED IS AT AN INCORRECT LEVEL AND MUST X\n               BE REASSEMBLED'\n*\nERROR6H  DC    H'80',H'0'\nERROR6T  DC    CL80'THE TSSO AUTOMATED OPERATIONS FACILITY IS NOT ACTIVX\n               E'\n*\nHEAD0H   DC    H'80',H'0'\nHEAD0    DC    CL80'T S S O  AUTOMATED OPERATIONS FACILITY TABLE DISPLAX\n               Y (VERSION 4.3)'\n*\nHEAD1H   DC    H'80',H'0'\nHEAD1    DC    CL80'TABLE NAME: XXXXXXXX, DATE: XXXXXXXX, TIME: XXXXXXXC\n               X'\n*\nHEAD2H   DC    H'80',H'0'\nHEAD2    DC    CL80'TABLE ID  : XXXXXXXX, VERSION: XXXXXXXX            C\n               '\n*\nLINE0H   DC    H'80',H'0'\nLINE0    DC    CL80'ENTRY NUMBER: XXXX, ENTRY NAME: XXXXXXXX'\n*\nLINE1H   DC    H'80',H'0'\nLINE1    DC    CL80'MESSAGE ID: XXXXXXXX, ACTION: XXXXXXXX, ECHO: XXX ,C\n               MATCHLIM XXXX'\n*\nLINE2H   DC    H'80',H'0'\nLINE2    DC    CL80'ACTION TEXT:                                       C\n                   '\n*\nLINE3SH  DC    H'80',H'0'\nLINE3S   DC    CL80'SUBSTRING STARTING AT XXX, FOR LENGTH XX'\n*\nLINE3WH  DC    H'80',H'0'\nLINE3W   DC    CL80'WORD NUMBER XX, FOR LENGTH XX, SEPARATORS: \"XXXX\"'\n*\nLINE4H   DC    H'80',H'0'\nLINE4    DC    CL133'MATCH TEXT:'\n*\nLINE5H   DC    H'80',H'0'\nLINE5    DC    CL133'ENTRY ID XXXXXXXX IS NOT FOUND IN THE TABLE'\n*\nLINE6H   DC    H'80',H'0'\nLINE6    DC    CL133'ENTRY ID XXXXXXXX IS BEING WAITED FOR BY ASCB XXXXX\n               XXXX'\n*\nLINE7H   DC    H'80',H'0'\nLINE7    DC    CL133'MESSAGE ID XXXXXXXX IS NOT FOUND IN THE TABLE'\n*\nTRAILH   DC    H'80',H'0'\nTRAIL    DC    CL133'TOTAL NUMBER OF TABLE ENTRIES: XXXX'\n*\n*\n********************************************************************\n* THIS IS THE DESCRIPTION OF THE COMMAND SYNTAX, AS PARSE WANTS IT *\n********************************************************************\nDISPARSE IKJPARM\nMSGID    IKJKEYWD\n         IKJNAME 'MSGID',SUBFLD=MSGSUB\nTABLEID  IKJKEYWD\n         IKJNAME 'ALTTAB',SUBFLD=TABSUB\n         IKJNAME 'TABLE',SUBFLD=TABSUB\nTEST     IKJKEYWD\n         IKJNAME 'TEST'\nENTRY    IKJKEYWD\n         IKJNAME 'ENTRY',SUBFLD=ENTSUB\nMSGSUB   IKJSUBF\nMSGSUBID IKJIDENT 'MSG',PROMPT='MSG NUMBER',FIRST=ALPHANUM,            X\n               OTHER=ALPHANUM,ASTERISK,                                X\n               HELP=('AN OS MESSAGE IDENTIFIER - 1-8 CHARACTERS '),    X\n               MAXLNTH=8\nTABSUB   IKJSUBF\nTABSUBID IKJIDENT 'TAB',PROMPT='TABLE NAME',FIRST=ALPHANUM,            X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE TO LOAD BEFORE PROCESSING  '),    X\n               MAXLNTH=8\nENTSUB   IKJSUBF\nENTSUBID IKJIDENT 'ENT',PROMPT='ENTRY IDENTIFIER',FIRST=ALPHANUM,      X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE ENTRY ID')\n         IKJENDP\n         IKJIOPL\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         CVT   DSECT=YES\n         TSSOCVT\n         END   DISPAOF\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY DISPAOF(''TSSO V 4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    DISPAOF'\n PUNCH ' NAME     DISPAOF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSASK": {"ttr": 31489, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x004\\x01\\x022\\x0f\\x01\\x022\\x1f\\x14G\\x035\\x03/\\x00\\n\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-11-16T00:00:00", "modifydate": "2002-11-17T14:47:34", "lines": 821, "newlines": 815, "modlines": 10, "user": "EDJXADM"}, "text": "         TITLE ' T S S O  WTOR TSO INTERFACE'\nOSASK    CSECT\n         EQUATES\n***********************************************************************\n* THIS IS THE OSASK COMMAND PROCESSOR. IT IS A TSO COMMAND PROCESSOR  *\n* DESIGNED TO RUN UNDER THE TSSO SUBSYSTEM, OR FROM A TSO ADDRESS     *\n* SPACE. THE COMMAND WILL BEHAVE DIFFERENTLY DEPENDING ON THE         *\n* ENVIRONMENT IN WHICH IT IS INVOKED. THE COMMAND CAN BE RUN FROM     *\n* EITHER TSSO, OR ANY AUTHORIZED TSO ADDRESS SPACE.                   *\n*                                                                     *\n* IF UNDER TSSO.                                                      *\n*                                                                     *\n* 1) CHECKS TO SEE IF THE COMMAND IS RUNNING UNDER A CLIST. IF NOT    *\n*    TERMINATE.                                                       *\n*                                                                     *\n* 2) OBTAIN VALUES FOR REPLYWAIT.                                     *\n*                                                                     *\n* 3) ISSUE A WTOR CONTAINING THE MESSAGE TO THE CONSOLE THAT ISSUED   *\n*    THE COMMAND.                                                     *\n*                                                                     *\n* 4) OBTAIN RESPONSE FROM WTOR AND PLACE IN CLIST VARIABLES... OR     *\n*    PUT A DUMMY RESPONSE INTO CLIST VARIABLES.                       *\n*                                                                     *\n* 5) TERMINATE.                                                       *\n*                                                                     *\n*                                                                     *\n* IF UNDER TSO:                                                       *\n*                                                                     *\n* 1) CHECK TO SEE IF RUNNING UNDER A CLIST. IF YES, OBTAIN VALUE FOR  *\n*    COMMAND REPLYWAIT. IF NOT, DEFAULT REPLYWAIT TO 60 SECONDS...    *\n*\n* 2) ISSUES A WTOR CONTAINING THE MESSAGE THE MASTER CONSOLE, AND WAIT*\n*                                                                     *\n* 3) IF INVOKED FROM A CLIST, THE COMMAND CREATES CLIST VARIABLES.    *\n*    IF INVOKED FROM THE COMMAND LINE, THE COMMAND WILL PUTLINE       *\n*    THE RESPONSE TO THE TERMINAL.                                    *\n*                                                                     *\n* 4) TERMINATE.                                                       *\n*                                                                     *\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ Support Extended MCS Consoles                 *EEJ1102\n*                                                              *EEJ1102\n*                                                                     *\n***********************************************************************\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSASK\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSASK,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSASDATD,R11\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n***********************************************************************\n* SINCE OSASK IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *\n* THE VARIABLE WORK AREA.                                             *\n***********************************************************************\n*\n         XC    FLAGS(4),FLAGS\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         MVC   MESSAGED(MESSAGEE-MESSAGEC),MESSAGEC\n         MVC   LINE1HD(80),LINE1HC\n         MVC   LINE2HD(80),LINE2HC\n         MVC   LINE3HD(80),LINE3HC\n         MVC   LINE4HD(80),LINE4HC\n         MVC   LINE6HD(80),LINE6HC\n         MVC   LINE12HD(80),LINE12HC\n         LA    R2,OSASDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         LA    R2,STIMEREX         GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n***********************************************************************\n* WE MUST CHECK TO SEE IF THE ENVIRONMENT IS AMENIABLE TO RUNNING THE *\n* COMMAND. LETS CHECK IF THIS IS THE TSSO ADDRESS SPACE.              *\n*                                                                     *\n***********************************************************************\n         L     R2,X'224'         GET OUR ASCB\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         LTR   R10,R10           IS TSSO EVEN THERE ?\n         BZ    ERROR12           NO, BLOW HIM AWAY\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR12           YUP- SORRY GUY.\n         C     R2,TSSOASCB\n         BNE   NOTUNDSS          NO, NOT UNDER TSSO...\n         L     R10,TSSODSEC\n         USING DATD,R10\n***********************************************************************\n* YES, WE ARE UNDER THE TSSO ADDRESS SPACE.                           *\n* THIS MEANS THAT A PARTICULAR CONSOLE HAS ISSUED THIS COMMAND. LETS  *\n* SAVE THE CONSOLE ID, AND USE IT WHEN ISSUING THE WTOR.              *\n***********************************************************************\n         L     R2,CURRCONS       GET CONSOLE ID OF GUY WITH CLIST\n         ST    R2,CONSOLE\n         OI    FLAGS,X'10'       INDICATE WITH FLAG THAT TSSO IS THE\n*                                CURRENT USER.\n         B     GETMSG\nNOTUNDSS DS    0H\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE MVS COMMAND TO BE EXECUTED FROM THE *\n* BUFFER. WE WILL USE THE CPPLCBUF FIELD PREVIOUSLY SET UP.           *\n***********************************************************************\n         XR    R2,R2\n         ST    R2,CONSOLE\n*\nGETMSG   DS    0H\n         L     R2,CPPLCBUF         GET THE COMMAND BUFFER.\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS AT THE MESSAGE\n         LA    R3,0(R2,R4)         R3 NOW POINTS AT THE END OF THE MSG\n         SR    R3,R5               R3 NOW HAS LENGTH OF THE MESSAGE\n         LTR   R3,R3\n         CH    R3,=H'1'\n         BL    ERROR1\n         CH    R3,=H'120'\n         BH    ERROR1\n         MVI   MESSAGED+4,C' '     Blank out message            EEJ1102\n         MVC   MESSAGED+5(124),MESSAGED+4     (same)            EEJ1102\n         BCTR  R3,0\n         EX    R3,MOVEMSG\n         B     AR1\nMOVEMSG  MVC   MESSAGED+4(*-*),0(R5) Dummy for execute          EEJ1102\nAR1      DS    0H\n*\n*\n***********************************************************************\n* LET US CHECK TO SEE IF WE WERE INVOKED USING TSO/E RELEASE 2. IF NOT*\n* WE WILL TERMINATE.                                                  *\n***********************************************************************\n         L     R9,16               GET CVT\n         USING CVT,R9\n         L     R9,CVTTVT           GET TIME SHARING VECTOR TABLE\n         USING TSVT,R9\n         LTR   R9,R9               IS THIS A TSO/E R2 SYSTEM ?\n         BZ    ERROR2\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE VALUE OF THE REPLYWAIT CLIST        *\n* VARIABLE, IF ONE EXISTS...                                          *\n***********************************************************************\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*                                  ACCESS PROGRAM VARIABLES.\n         LA    R2,TSVERETR         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n*\n*\n*\n*\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               REPVARA,            PTR TO VAR NAME                     X\n               REPVARL,            PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         DROP  R9\n         LTR   R15,R15\n         BZ    WAITOK              YUP, COMMAND OUT WAS OK\n         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?\n         BE    NOTUNDCL            NO, WE ARE NOT UNDER A CLIST...\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?\n         BNE   ERROR3              NO, WE HAVE REAL PROBLEMS.\nDEFCMDOT DS    0H\n         L     R15,=F'6000'\n         ST    R15,REPLYWTT        SELECT DEFAULT TIME OF SIXTY SECONDS\n         B     PROCWTOR            GO AND PROCESS THE WTOR.\n*\nWAITOK   DS    0H\n         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE\n         L     R0,VALLENGT         AND ITS LENGTH\n         LTR   R0,R0\n         BZ    DEFCMDOT\n         LA    R10,OSWKAREA\n         CALL  JCECVTDB            GET SOMETHING IN BINARY.\n         BNZ   ERROR4\n         CH    R1,=H'600'\n         BH    ERROR4\n         OI    FLAGS,X'80'         INDICATE REPLYWAIT SPECIFIED...\n         M     R0,=F'100'\n         ST    R1,REPLYWTT         MAXIMUM NUMBER OF LINE TO ALLOW.\n         B     PROCWTOR            GET THE MVS WAIT TIME FROM THE CLIST\n*                                  IF NOT SPECIFIED, ASSUME 2 SECONDS.\nNOTUNDCL DS    0H\n***********************************************************************\n* HERE, WE HAVE DISCOVERED WE ARE NOT RUNNING UNDER A CLIST. THIS IS  *\n* BRANCHED TO FROM THE SECTION OF CODE THAT TRIES TO OBTAIN THE       *\n* REPLYWAIT VARIABLE VALUE. THIS IS PERMISSIBLE ONLY IF NOT RUNNING   *\n* UNDER THE TSSO ADDRESS SPACE.                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'10'         TSSO ADDRESS SPACE ?\n         BO    ERROR6              YUP, ILLEGAL (AND IMMORAL)\n         OI    FLAGS,X'20'         INDICATE WE ARE NOT UNDER A CLIST\n         MVC   REPLYWTT(4),=F'6000' DEFAULT COMMAND WAIT TIME\n*                                  IN  .01 SECONDS...\n         OI    FLAGS,X'80'         INDICATE REPLYWTT SPECIFIED...\n         B     PROCWTOR\nPROCWTOR DS    0H\n***********************************************************************\n* FINALLY, WE ARE READY TO ISSUE THE MVS WTOR.                        *\n***********************************************************************\n* FIRST, LET US ISSUE THE STIMER SO WE CAN AWAKE FROM THE WTOR IS THE *\n* OPERATOR IS OUT FOR COFFEE...                                       *\n***********************************************************************\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=REPLYWTT\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. THIS MEANS THAT*\n* THE OPERATOR DID NOT REPLY TO THE WTOR IN TIME, AND THEREFORE, WE   *\n* WILL DUMMY UP THE RESPONSE, CANCEL THE WTOR, AND PROCEED TO PARSE   *\n* THE WTOR. IF THE OPERATOR DOES RESPOND, WE WILL WAKE UP, CANCEL THE *\n* STIMER, AND PARSE THE RESULTS...                                    *\n***********************************************************************\n         MVI   REPLYADD,C' '\n         MVC   REPLYADD+1(132),REPLYADD\n         XC    OSASKECB(4),OSASKECB\n         XC    STIMRECB(4),STIMRECB\n         LA    R2,OSASKECB            GET ADDRESS OF OSASKECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n*\n         LA    R3,REPLYADD            GET REPLY ADDRESS\n         LA    R4,OSASKECB            GET ECB ADDRESS\n*\n         WTOR  ,(R3),125,(R4),        Issue WTOR                EEJ1102+\n               CONSID=CONSOLE,        (same)                    EEJ1102+\n               MF=(E,MESSAGED)        (same)                    EEJ1102\n         ST    R1,WTORMSGN\n*\n         WAIT  ECBLIST=LISTECBS\n*\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM THE WTOR BEING POSTED, OR FROM THE *\n* STIMER POPPING...        IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE WTOR ECB , WE SHOULD CANCEL THE STIMER    *\n***********************************************************************\n         TM    OSASKECB,X'40'              POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n         B     PUTRESP\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* HERE, THE STIMER EXIT HAS POPPED, AND POSTED THE STIMERECB, MEANING *\n* THAT THE OPERATOR HAS GONE OUT FOR COFFEE...                        *\n* WE WILL DUMMY UP A RESPONSE FOR THE OPERATOR, AS IF A  RESPONSE WAS *\n* RETURNED.                                                           *\n***********************************************************************\n         MVC   REPLYADD(7),=CL7'NOREPLY'\n         L     R0,CONSOLE\n         WTO   'OSASK01 OSASK COMMAND TIMING OUT -> REQUEST DELETED'\n         L     R2,WTORMSGN         GET WTOR MESSAGE NUMBER\n         DOM   MSG=(R2),REPLY=YES\n         B     PUTRESP\n*\nPUTRESP  DS    0H\n***********************************************************************\n* NEXT, WE MUST GO ABOUT THE BUSINESS OF CONVERTING THE RESPONSE OF   *\n* THE MESSAGE INTO CLIST VARIABLES, SO THE CLIST CAN ACCESS THEM.     *\n* THIS IS, OF COURSE, ONLY NECCESARY IF THE OSASK COMMAND WAS INVOKED *\n* FROM A CLIST.IFNOWE WILL SIMPLY TAKE THE RESPONSE, AND PUTLINE IT   *\n* OUT TO THE TSO TERMINAL.                                            *\n***********************************************************************\n         TM    FLAGS,X'20'     NOT INVOKED FROM A CLIST ?\n         BNO   PUTCLSTV        YES, PUTLINE THE RESPONSE TO THE TUBE.\n***********************************************************************\n* HERE, WE WILL SIMPLY RETURN THE COMMAND RESPONSE TO THE TERMINAL.   *\n* THE PUTLINE MACRO WILL BE USED.                                     *\n***********************************************************************\n         MVC   PUTRESPD(2),=H'125'       LENGTH IS ALWAYS 130\n         XC    PUTRESPD+2(2),PUTRESPD+2  CLEAR OUT BUFFER\nPUTRLOOP DS    0H\n         MVC   PUTRESPD+4(125),REPLYADD\n         PUTLINE PARM=PUTBLOK,OUTPUT=(PUTRESPD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDCMD\n*\nPUTCLSTV DS    0H\n*\n         LA    R4,TSVEUPDT         WE WISH TO UPDATE CLIST VARS..\n         ST    R4,ECODE\n*\n         LA    R4,CLVARNME         GET VARNAME PTR\n         ST    R4,NAMEPTR          TELL IKJCT441\n         MVC   CLVARNME(5),=CL5'REPLY'\n*\n         LA    R4,5\n         ST    R4,NAMELEN\n*\nGOTNAME  DS    0H\n         LA    R2,REPLYADD        POINT TO REPLY ADDRESS\n         ST    R2,VALUEPTR\n*\n         LA    R3,REPLYADD\n         LA    R4,REPLYADD+132    START AT LAST CHARACTER\nLLOOP    DS    0H\n         CLI   0(R4),C' '\n         BNE   NBLNKFND           FOUND A NON  BLANK\n         BCTR  R4,0\n         CR    R4,R3              ARE WE DONE\n         BL    NULLVAR            YUP, PITTY...   (PTF 2)\n         B     LLOOP\n*\nNULLVAR  DS    0H\n         XR    R4,R4\n         ST    R4,VALUELEN\n         B     CALLTSV\n*\nNBLNKFND DS    0H\n         SR    R4,R3              GOT THE LENGTH IN R4\n         LA    R4,1(R4)\n         ST    R4,VALUELEN\n*\nCALLTSV  DS    0H\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*\n* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *\n* AND PUT THE WORDS INTO CLIST VARIABLES.                             *\n* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *\n***********************************************************************\n         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE\n*\n         MVC   OSPARS2(4),=F'125' SECOND PARM -> LENGTH OF STRING\n*\n         MVI   OSPARARR,X'40'\n         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY\n         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB\n         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...\n         LA    R4,OSPARARR                GET ADDRESS\n         ST    R4,OSPARS3                 AND PASS TO TSSOPARS\n*\n         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE\n         ST    R4,OSPARS4             SEPARATOR CHARACTERS.\n         MVC   WORDSEPS(4),=CL4' ,= '\n*\n         LA    R1,OSPARSPM\n         CALL  TSSOPARS              ** PARSE IT **\n         LH    R8,OSPARARR\n         ST    R8,WORDLINE\n***********************************************************************\n* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *\n* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *\n***********************************************************************\n         LA    R4,CLVARNME           GET VARIABLE NAME\n         ST    R4,NAMEPTR\n         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...\n         MVI   0(R4),C'W'            MOVE IN A \"W\"\n*\n*\n         L     R4,NAMELEN\n         LA    R4,1(R4)\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         STCM  R1,B'1111',EBCCOUNT\n*\n         LA    R4,4\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* THE NEXT STEP IS TO CREATE THE REPLYWN   VARIABLES, WHERE \"N\" IS    *\n* THE CURRENT WORD THAT WE ARE WORKING ON...                          *\n* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *\n* CLIST VARIABLES.                                                    *\n***********************************************************************\n*\n*\n         LA    R4,1\n         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD\n         LA    R4,OSPARARR+2\n         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN\n*                                        THE PARSE ARRAY\n*\nWORDLOOP DS    0H\n         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR\n         ST    R4,NAMELENW              AND KEEP A COPY\n         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?\n         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?\n         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON\n*\n         LA    R4,CLVARNME               GET THE VARIABLE NAME\n         ST    R4,NAMEPTR                TELL CLIST ROUTINE\n*\n         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM\n         LR    R1,R4\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R4,=H'10'\n         BL    WOR1BYTE\nWOR2BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,2(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nWOR1BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,1(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nGOTNAME2 DS    0H\n***********************************************************************\n* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *\n*                                                                     *\n***********************************************************************\n         L     R4,CURRWPOS\n         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..\n         XR    R6,R6\nWLENLOOP DS    0H\n         CLI   0(R4),C' '    BLANK FOUND ?\n         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6\n         LA    R6,1(R6)\n         LA    R4,1(R4)\n         BCT   R5,WLENLOOP\nWLENELOP DS    0H\n         ST    R6,VALUELEN\n*\n         L     R4,CURRWPOS\n         ST    R4,VALUEPTR\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELENW,           PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n         L     R4,CURRWPOS\n         LA    R4,16(R4)\n         ST    R4,CURRWPOS\n*\n         L     R4,CURRWNUM\n         LA    R4,1(R4)\n         ST    R4,CURRWNUM\n         B     WORDLOOP\n*\nENDWORDS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE ARE COMPLETED PROCESSING THE LINE... WE SHOULD *\n* NOW BE FINISHED...                                                  *\n***********************************************************************\nENDCMD   DS    0H\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* E R R O R   C O N D I T I O N S ...                                 *\n*                                                                     *\n***********************************************************************\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR3   DS    0H\n         CH    R15,=H'40'             INCORRECT ENVIRONMENT\n         BE    ERROR6                 JUST IN CASE\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR12  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE12HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nSTIMEREX DS    0H\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSASK DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSASK DSECT AREA\n         USING OSASDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n         DROP  R11\n         DROP  R12\n         POP   USING\n*\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\nSTIMRPRE DS    0D\n         PUSH  USING                                               RPS\n         DROP  R12                                                 RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nSTIMER_CODEL   EQU  *-STIMRPRE   LENGTH OF CODE\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n         DROP  R15                                                 RPS\n         POP   USING                                               RPS\n*\n*\n*\nREPVARA  DC    A(REPVAR)\nREPVAR   DC    CL9'REPLYWAIT'\nREPVARL  DC    F'9'\n*\nOSCALL1C CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL1E EQU  *\n*\nMESSAGEC WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\n*\nMESSAGEE EQU   *\nLINE1HC  DC    H'80',H'0'\nLINE1H   DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >120 CHX\n               ARACTERS'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HC  DC    H'80',H'0'\nLINE3H   DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HC  DC    H'80',H'0'\nLINE4H   DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HC  DC    H'80',H'0'\nLINE6H   DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HC DC    H'80',H'0'\nLINE12H  DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n************************************************************\n*                                                          *\n*        VARIABLE WORK AREAS, COVERED BY BASE REG R11.     *\n*                                                          *\n************************************************************\nOSASDATD DSECT\nOSWKAREA DS    CL200\n*\nSTIMERD  DS    0D\n         DS    CL(STIMER_CODEL)   LENGTH OF CODE COPIED HERE       RPS\nR15SAVED DS    A\nR1SAVED  DS    A\nSTIMREAL DS    A\nSTIMPARM DS    F\n*\nFLAGS    DS    4X\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\nOSCALL1D CALL  ,(0,0,0,0,0,0),MF=L\n*\n***********************************************************************\n* THE FOLLOWING SECTION DENOTES THE ECB LIST THAT OSASK WILL WAIT ON  *\n*                                                                     *\n***********************************************************************\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSASKECB\n         DC    X'80'\n         DC    A(0)\n*\nOSASKECB DS    F\nSTIMRECB DS    F\n*\n***********************************************************************\n* THE VARIABLES ARE NEEDED FOR THE CLIST VARIABLE ACCESS ROUTINE      *\n* IKJCT441.                                                           *\n***********************************************************************\nVACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.\nVALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.\nVALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nTOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nECODE    DS    F\n*\nNAMEPTR  DS    F                FOR UPDATE ROUTINE\nNAMELEN  DS    F                FOR UPDATE ROUTINE\nVALUEPTR DS    F                FOR UPDATE ROUTINE\nVALUELEN DS    F                FOR UPDATE ROUTINE\nNAMELENW DS    F                FOR UPDATE ROUTINE FROM \"CMDOUTNWM\"\nCLVARNME DS    CL12\nEBCCOUNT DS    CL4\nCONSOLE  DS    F\n***********************************************************************\n* THESE VARIABLES ARE USED TO KEEP TRACK OF WHICH LINES AND WORDS WE  *\n* ARE USING WHEN STUFFING RESULTS IN CLIST VARIABLES.                 *\n***********************************************************************\nCURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE\nCURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN\n*                               TSSOPARS\nWORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE\nNUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND\n***********************************************************************\n* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *\n* ROUTINE.                                                            *\n***********************************************************************\nOSPARSPM DS    0H\nOSPARS1  DS    F\nOSPARS2  DS    F\nOSPARS3  DS    F\nOSPARS4  DS    F\nWORDSEPS DS    CL4           PROBABLY CL4' ,= '\nOSPARARR DS    20CL16\n***********************************************************************\n* THESE VARIABLES ARE THE BINARY REPRESENTATIONS OF STUFF DERIVED FROM*\n* THE INVOKING CLIST.                                                 *\n***********************************************************************\nWTORMSGN DS    F\nREPLYADD DS    CL133\nREPLYWTT DS    F                MAXIMUM WAIT TIME (IN .01 SECONDS)\n*\nMESSAGED WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\n*\nPUTRESPD DC    H'130',H'0'      FOR PUTTING COMMAND RESPONSE TO TUBE\n         DC    CL130' '\n*\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >125 CHX\n               ARACTERS'\n*\nLINE2HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HD DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n         IKJTSVT\n         IKJIOPL\n         TSSOCVT\n         COPY  TSSODATD\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\n         END   OSASK\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSASK(''TSSO V 4.2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    OSASK'\n PUNCH ' NAME     OSASK(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSASKX": {"ttr": 31749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x966_\\x00\\x966o\\tD\\x03?\\x032\\x00^\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-31T09:44:00", "lines": 831, "newlines": 818, "modlines": 94, "user": "RPS"}, "text": "         TITLE ' T S S O  WTOR TSO INTERFACE'\nOSASK    CSECT\n         EQUATES\n***********************************************************************\n* THIS IS THE OSASK COMMAND PROCESSOR. IT IS A TSO COMMAND PROCESSOR  *\n* DESIGNED TO RUN UNDER THE TSSO SUBSYSTEM, OR FROM A TSO ADDRESS     *\n* SPACE. THE COMMAND WILL BEHAVE DIFFERENTLY DEPENDING ON THE         *\n* ENVIRONMENT IN WHICH IT IS INVOKED. THE COMMAND CAN BE RUN FROM     *\n* EITHER TSSO, OR ANY AUTHORIZED TSO ADDRESS SPACE.                   *\n*                                                                     *\n* IF UNDER TSSO.                                                      *\n*                                                                     *\n* 1) CHECKS TO SEE IF THE COMMAND IS RUNNING UNDER A CLIST. IF NOT    *\n*    TERMINATE.                                                       *\n*                                                                     *\n* 2) OBTAIN VALUES FOR REPLYWAIT.                                     *\n*                                                                     *\n* 3) ISSUE A WTOR CONTAINING THE MESSAGE TO THE CONSOLE THAT ISSUED   *\n*    THE COMMAND.                                                     *\n*                                                                     *\n* 4) OBTAIN RESPONSE FROM WTOR AND PLACE IN CLIST VARIABLES... OR     *\n*    PUT A DUMMY RESPONSE INTO CLIST VARIABLES.                       *\n*                                                                     *\n* 5) TERMINATE.                                                       *\n*                                                                     *\n*                                                                     *\n* IF UNDER TSO:                                                       *\n*                                                                     *\n* 1) CHECK TO SEE IF RUNNING UNDER A CLIST. IF YES, OBTAIN VALUE FOR  *\n*    COMMAND REPLYWAIT. IF NOT, DEFAULT REPLYWAIT TO 60 SECONDS...    *\n*\n* 2) ISSUES A WTOR CONTAINING THE MESSAGE THE MASTER CONSOLE, AND WAIT*\n*                                                                     *\n* 3) IF INVOKED FROM A CLIST, THE COMMAND CREATES CLIST VARIABLES.    *\n*    IF INVOKED FROM THE COMMAND LINE, THE COMMAND WILL PUTLINE       *\n*    THE RESPONSE TO THE TERMINAL.                                    *\n*                                                                     *\n* 4) TERMINATE.                                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSASK\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSASK,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSASDATD,R11\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n***********************************************************************\n* SINCE OSASK IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *\n* THE VARIABLE WORK AREA.                                             *\n***********************************************************************\n*\n         XC    FLAGS(4),FLAGS\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         MVC   MESSAGED(MESSAGEE-MESSAGEC),MESSAGEC\n         MVC   LINE1HD(80),LINE1HC\n         MVC   LINE2HD(80),LINE2HC\n         MVC   LINE3HD(80),LINE3HC\n         MVC   LINE4HD(80),LINE4HC\n         MVC   LINE6HD(80),LINE6HC\n         MVC   LINE12HD(80),LINE12HC\n         LA    R2,OSASDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         L     R2,STIMEREX_ADDR    GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n***********************************************************************\n* WE MUST CHECK TO SEE IF THE ENVIRONMENT IS AMENIABLE TO RUNNING THE *\n* COMMAND. LETS CHECK IF THIS IS THE TSSO ADDRESS SPACE.              *\n*                                                                     *\n***********************************************************************\n         L     R2,X'224'         GET OUR ASCB\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         LTR   R10,R10           IS TSSO EVEN THERE ?\n         BZ    ERROR12           NO, BLOW HIM AWAY\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR12           YUP- SORRY GUY.\n         C     R2,TSSOASCB\n         BNE   NOTUNDSS          NO, NOT UNDER TSSO...\n         L     R10,TSSODSEC\n         USING DATD,R10\n***********************************************************************\n* YES, WE ARE UNDER THE TSSO ADDRESS SPACE.                           *\n* THIS MEANS THAT A PARTICULAR CONSOLE HAS ISSUED THIS COMMAND. LETS  *\n* SAVE THE CONSOLE ID, AND USE IT WHEN ISSUING THE WTOR.              *\n***********************************************************************\n         L     R2,CURRCONS       GET CONSOLE ID OF GUY WITH CLIST\n         ST    R2,CONSOLE\n         OI    FLAGS,X'10'       INDICATE WITH FLAG THAT TSSO IS THE\n*                                CURRENT USER.\n         B     GETMSG\nNOTUNDSS DS    0H\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE MVS COMMAND TO BE EXECUTED FROM THE *\n* BUFFER. WE WILL USE THE CPPLCBUF FIELD PREVIOUSLY SET UP.           *\n***********************************************************************\n         XR    R2,R2\n         ST    R2,CONSOLE\n*\nGETMSG   DS    0H\n         L     R2,CPPLCBUF         GET THE COMMAND BUFFER.\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS AT THE MESSAGE\n         LA    R3,0(R2,R4)         R3 NOW POINTS AT THE END OF THE MSG\n         SR    R3,R5               R3 NOW HAS LENGTH OF THE MESSAGE\n         LTR   R3,R3\n         CH    R3,=H'1'\n         BL    ERROR1\n         CH    R3,=H'120'\n         BH    ERROR1\n         MVI   MESSAGED+12,X'40'\n         MVC   MESSAGED+13(124),MESSAGED+12\n         BCTR  R3,0\n         EX    R3,MOVEMSG\n         B     AR1\nMOVEMSG  MVC   MESSAGED+12(0),0(R5)\nAR1      DS    0H\n*\n*\n***********************************************************************\n* LET US CHECK TO SEE IF WE WERE INVOKED USING TSO/E RELEASE 2. IF NOT*\n* WE WILL TERMINATE.                                                  *\n***********************************************************************\n         L     R9,16               GET CVT\n         USING CVT,R9\n         L     R9,CVTTVT           GET TIME SHARING VECTOR TABLE\n         USING TSVT,R9\n         LTR   R9,R9               IS THIS A TSO/E R2 SYSTEM ?\n         BZ    ERROR2\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE VALUE OF THE REPLYWAIT CLIST        *\n* VARIABLE, IF ONE EXISTS...                                          *\n***********************************************************************\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*                                  ACCESS PROGRAM VARIABLES.\n         LA    R2,TSVERETR         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n*\n*\n*\n*\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               REPVARA,            PTR TO VAR NAME                     X\n               REPVARL,            PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         DROP  R9\n         LTR   R15,R15\n         BZ    WAITOK              YUP, COMMAND OUT WAS OK\n         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?\n         BE    NOTUNDCL            NO, WE ARE NOT UNDER A CLIST...\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?\n         BNE   ERROR3              NO, WE HAVE REAL PROBLEMS.\nDEFCMDOT DS    0H\n         L     R15,=F'6000'\n         ST    R15,REPLYWTT        SELECT DEFAULT TIME OF SIXTY SECONDS\n         B     PROCWTOR            GO AND PROCESS THE WTOR.\n*\nWAITOK   DS    0H\n         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE\n         L     R0,VALLENGT         AND ITS LENGTH\n         LTR   R0,R0\n         BZ    DEFCMDOT\n         LA    R10,OSWKAREA\n         CALL  JCECVTDB            GET SOMETHING IN BINARY.\n         BNZ   ERROR4\n         CH    R1,=H'600'\n         BH    ERROR4\n         OI    FLAGS,X'80'         INDICATE REPLYWAIT SPECIFIED...\n         M     R0,=F'100'\n         ST    R1,REPLYWTT         MAXIMUM NUMBER OF LINE TO ALLOW.\n         B     PROCWTOR            GET THE MVS WAIT TIME FROM THE CLIST\n*                                  IF NOT SPECIFIED, ASSUME 2 SECONDS.\nNOTUNDCL DS    0H\n***********************************************************************\n* HERE, WE HAVE DISCOVERED WE ARE NOT RUNNING UNDER A CLIST. THIS IS  *\n* BRANCHED TO FROM THE SECTION OF CODE THAT TRIES TO OBTAIN THE       *\n* REPLYWAIT VARIABLE VALUE. THIS IS PERMISSIBLE ONLY IF NOT RUNNING   *\n* UNDER THE TSSO ADDRESS SPACE.                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'10'         TSSO ADDRESS SPACE ?\n         BO    ERROR6              YUP, ILLEGAL (AND IMMORAL)\n         OI    FLAGS,X'20'         INDICATE WE ARE NOT UNDER A CLIST\n         MVC   REPLYWTT(4),=F'6000' DEFAULT COMMAND WAIT TIME\n*                                  IN  .01 SECONDS...\n         OI    FLAGS,X'80'         INDICATE REPLYWTT SPECIFIED...\n         B     PROCWTOR\nPROCWTOR DS    0H\n***********************************************************************\n* FINALLY, WE ARE READY TO ISSUE THE MVS WTOR.                        *\n***********************************************************************\n* FIRST, LET US ISSUE THE STIMER SO WE CAN AWAKE FROM THE WTOR IS THE *\n* OPERATOR IS OUT FOR COFFEE...                                       *\n***********************************************************************\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=REPLYWTT\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. THIS MEANS THAT*\n* THE OPERATOR DID NOT REPLY TO THE WTOR IN TIME, AND THEREFORE, WE   *\n* WILL DUMMY UP THE RESPONSE, CANCEL THE WTOR, AND PROCEED TO PARSE   *\n* THE WTOR. IF THE OPERATOR DOES RESPOND, WE WILL WAKE UP, CANCEL THE *\n* STIMER, AND PARSE THE RESULTS...                                    *\n***********************************************************************\n         MVI   REPLYADD,C' '\n         MVC   REPLYADD+1(132),REPLYADD\n         XC    OSASKECB(4),OSASKECB\n         XC    STIMRECB(4),STIMRECB\n         LA    R2,OSASKECB            GET ADDRESS OF OSASKECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n*\n         LA    R3,REPLYADD            GET REPLY ADDRESS\n         LA    R4,OSASKECB            GET ECB ADDRESS\n*\n         L     R0,CONSOLE\n         WTOR  ,(R3),125,(R4),MF=(E,MESSAGED)\n         ST    R1,WTORMSGN\n*\n         WAIT  ECBLIST=LISTECBS\n*\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM THE WTOR BEING POSTED, OR FROM THE *\n* STIMER POPPING...        IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE WTOR ECB , WE SHOULD CANCEL THE STIMER    *\n***********************************************************************\n         TM    OSASKECB,X'40'              POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n         B     PUTRESP\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* HERE, THE STIMER EXIT HAS POPPED, AND POSTED THE STIMERECB, MEANING *\n* THAT THE OPERATOR HAS GONE OUT FOR COFFEE...                        *\n* WE WILL DUMMY UP A RESPONSE FOR THE OPERATOR, AS IF A  RESPONSE WAS *\n* RETURNED.                                                           *\n***********************************************************************\n         MVC   REPLYADD(7),=CL7'NOREPLY'\n         L     R0,CONSOLE\n         WTO   'OSASK01 OSASK COMMAND TIMING OUT -> REQUEST DELETED'\n         L     R2,WTORMSGN         GET WTOR MESSAGE NUMBER\n         DOM   MSG=(R2),REPLY=YES\n         B     PUTRESP\n*\nPUTRESP  DS    0H\n***********************************************************************\n* NEXT, WE MUST GO ABOUT THE BUSINESS OF CONVERTING THE RESPONSE OF   *\n* THE MESSAGE INTO CLIST VARIABLES, SO THE CLIST CAN ACCESS THEM.     *\n* THIS IS, OF COURSE, ONLY NECCESARY IF THE OSASK COMMAND WAS INVOKED *\n* FROM A CLIST.IFNOWE WILL SIMPLY TAKE THE RESPONSE, AND PUTLINE IT   *\n* OUT TO THE TSO TERMINAL.                                            *\n***********************************************************************\n         TM    FLAGS,X'20'     NOT INVOKED FROM A CLIST ?\n         BNO   PUTCLSTV        YES, PUTLINE THE RESPONSE TO THE TUBE.\n***********************************************************************\n* HERE, WE WILL SIMPLY RETURN THE COMMAND RESPONSE TO THE TERMINAL.   *\n* THE PUTLINE MACRO WILL BE USED.                                     *\n***********************************************************************\n         MVC   PUTRESPD(2),=H'125'       LENGTH IS ALWAYS 130\n         XC    PUTRESPD+2(2),PUTRESPD+2  CLEAR OUT BUFFER\nPUTRLOOP DS    0H\n         MVC   PUTRESPD+4(125),REPLYADD\n         PUTLINE PARM=PUTBLOK,OUTPUT=(PUTRESPD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDCMD\n*\nPUTCLSTV DS    0H\n*\n         LA    R4,TSVEUPDT         WE WISH TO UPDATE CLIST VARS..\n         ST    R4,ECODE\n*\n         LA    R4,CLVARNME         GET VARNAME PTR\n         ST    R4,NAMEPTR          TELL IKJCT441\n         MVC   CLVARNME(5),=CL5'REPLY'\n*\n         LA    R4,5\n         ST    R4,NAMELEN\n*\nGOTNAME  DS    0H\n         LA    R2,REPLYADD        POINT TO REPLY ADDRESS\n         ST    R2,VALUEPTR\n*\n         LA    R3,REPLYADD\n         LA    R4,REPLYADD+132    START AT LAST CHARACTER\nLLOOP    DS    0H\n         CLI   0(R4),C' '\n         BNE   NBLNKFND           FOUND A NON  BLANK\n         BCTR  R4,0\n         CR    R4,R3              ARE WE DONE\n         BL    NULLVAR            YUP, PITTY...   (PTF 2)\n         B     LLOOP\n*\nNULLVAR  DS    0H\n         XR    R4,R4\n         ST    R4,VALUELEN\n         B     CALLTSV\n*\nNBLNKFND DS    0H\n         SR    R4,R3              GOT THE LENGTH IN R4\n         LA    R4,1(R4)\n         ST    R4,VALUELEN\n*\nCALLTSV  DS    0H\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*\n* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *\n* AND PUT THE WORDS INTO CLIST VARIABLES.                             *\n* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *\n***********************************************************************\n         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE\n*\n         MVC   OSPARS2(4),=F'125' SECOND PARM -> LENGTH OF STRING\n*\n         MVI   OSPARARR,X'40'\n         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY\n         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB\n         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...\n         LA    R4,OSPARARR                GET ADDRESS\n         ST    R4,OSPARS3                 AND PASS TO TSSOPARS\n*\n         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE\n         ST    R4,OSPARS4             SEPARATOR CHARACTERS.\n         MVC   WORDSEPS(4),=CL4' ,= '\n*\n         LA    R1,OSPARSPM\n         CALL  TSSOPARS              ** PARSE IT **\n         LH    R8,OSPARARR\n         ST    R8,WORDLINE\n***********************************************************************\n* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *\n* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *\n***********************************************************************\n         LA    R4,CLVARNME           GET VARIABLE NAME\n         ST    R4,NAMEPTR\n         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...\n         MVI   0(R4),C'W'            MOVE IN A \"W\"\n*\n*\n         L     R4,NAMELEN\n         LA    R4,1(R4)\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         STCM  R1,B'1111',EBCCOUNT\n*\n         LA    R4,4\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* THE NEXT STEP IS TO CREATE THE REPLYWN   VARIABLES, WHERE \"N\" IS    *\n* THE CURRENT WORD THAT WE ARE WORKING ON...                          *\n* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *\n* CLIST VARIABLES.                                                    *\n***********************************************************************\n*\n*\n         LA    R4,1\n         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD\n         LA    R4,OSPARARR+2\n         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN\n*                                        THE PARSE ARRAY\n*\nWORDLOOP DS    0H\n         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR\n         ST    R4,NAMELENW              AND KEEP A COPY\n         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?\n         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?\n         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON\n*\n         LA    R4,CLVARNME               GET THE VARIABLE NAME\n         ST    R4,NAMEPTR                TELL CLIST ROUTINE\n*\n         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM\n         LR    R1,R4\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R4,=H'10'\n         BL    WOR1BYTE\nWOR2BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,2(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nWOR1BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,1(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nGOTNAME2 DS    0H\n***********************************************************************\n* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *\n*                                                                     *\n***********************************************************************\n         L     R4,CURRWPOS\n         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..\n         XR    R6,R6\nWLENLOOP DS    0H\n         CLI   0(R4),C' '    BLANK FOUND ?\n         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6\n         LA    R6,1(R6)\n         LA    R4,1(R4)\n         BCT   R5,WLENLOOP\nWLENELOP DS    0H\n         ST    R6,VALUELEN\n*\n         L     R4,CURRWPOS\n         ST    R4,VALUEPTR\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELENW,           PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n         L     R4,CURRWPOS\n         LA    R4,16(R4)\n         ST    R4,CURRWPOS\n*\n         L     R4,CURRWNUM\n         LA    R4,1(R4)\n         ST    R4,CURRWNUM\n         B     WORDLOOP\n*\nENDWORDS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE ARE COMPLETED PROCESSING THE LINE... WE SHOULD *\n* NOW BE FINISHED...                                                  *\n***********************************************************************\nENDCMD   DS    0H\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* E R R O R   C O N D I T I O N S ...                                 *\n*                                                                     *\n***********************************************************************\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR3   DS    0H\n         CH    R15,=H'40'             INCORRECT ENVIRONMENT\n         BE    ERROR6                 JUST IN CASE\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR12  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE12HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n\n\n*\nSTIMEREX_ADDR  DC A(STIMEREX)\n*\nREPVARA  DC    A(REPVAR)\nREPVAR   DC    CL9'REPLYWAIT'\nREPVARL  DC    F'9'\n*\nOSCALL1C CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL1E EQU  *\n*\nMESSAGEC WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(REG0,RESP),DESC=(6),MF=L\n*\nMESSAGEE EQU   *\nLINE1HC  DC    H'80',H'0'\nLINE1H   DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >120 CHX\n               ARACTERS'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HC  DC    H'80',H'0'\nLINE3H   DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HC  DC    H'80',H'0'\nLINE4H   DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HC  DC    H'80',H'0'\nLINE6H   DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HC DC    H'80',H'0'\nLINE12H  DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n************************************************************\n*                                                          *\n*        VARIABLE WORK AREAS, COVERED BY BASE REG R11.     *\n*                                                          *\n************************************************************\nOSASDATD DSECT\nOSWKAREA DS    CL200\n*\n         TITLE 'STIMRPRE'                                          RPS\n*\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n*\nFLAGS    DS    4X\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\nOSCALL1D CALL  ,(0,0,0,0,0,0),MF=L\n*\n***********************************************************************\n* THE FOLLOWING SECTION DENOTES THE ECB LIST THAT OSASK WILL WAIT ON  *\n*                                                                     *\n***********************************************************************\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSASKECB\n         DC    X'80'\n         DC    A(0)\n*\nOSASKECB DS    F\nSTIMRECB DS    F\n*\n***********************************************************************\n* THE VARIABLES ARE NEEDED FOR THE CLIST VARIABLE ACCESS ROUTINE      *\n* IKJCT441.                                                           *\n***********************************************************************\nVACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.\nVALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.\nVALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nTOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nECODE    DS    F\n*\nNAMEPTR  DS    F                FOR UPDATE ROUTINE\nNAMELEN  DS    F                FOR UPDATE ROUTINE\nVALUEPTR DS    F                FOR UPDATE ROUTINE\nVALUELEN DS    F                FOR UPDATE ROUTINE\nNAMELENW DS    F                FOR UPDATE ROUTINE FROM \"CMDOUTNWM\"\nCLVARNME DS    CL12\nEBCCOUNT DS    CL4\nCONSOLE  DS    F\n***********************************************************************\n* THESE VARIABLES ARE USED TO KEEP TRACK OF WHICH LINES AND WORDS WE  *\n* ARE USING WHEN STUFFING RESULTS IN CLIST VARIABLES.                 *\n***********************************************************************\nCURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE\nCURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN\n*                               TSSOPARS\nWORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE\nNUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND\n***********************************************************************\n* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *\n* ROUTINE.                                                            *\n***********************************************************************\nOSPARSPM DS    0H\nOSPARS1  DS    F\nOSPARS2  DS    F\nOSPARS3  DS    F\nOSPARS4  DS    F\nWORDSEPS DS    CL4           PROBABLY CL4' ,= '\nOSPARARR DS    20CL16\n***********************************************************************\n* THESE VARIABLES ARE THE BINARY REPRESENTATIONS OF STUFF DERIVED FROM*\n* THE INVOKING CLIST.                                                 *\n***********************************************************************\nWTORMSGN DS    F\nREPLYADD DS    CL133\nREPLYWTT DS    F                MAXIMUM WAIT TIME (IN .01 SECONDS)\n*\nMESSAGED WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(REG0,RESP),DESC=(6),MF=L\n*\nPUTRESPD DC    H'130',H'0'      FOR PUTTING COMMAND RESPONSE TO TUBE\n         DC    CL130' '\n*\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >125 CHX\n               ARACTERS'\n*\nLINE2HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HD DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n\n        TITLE 'STIMERPRE'\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\n         DS    0H                                                  RPS\nSTIMRPRE CSECT                                                     RPS\n         PUSH  USING                                               RPS\n         DROP  R15                                                 RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n         DROP  R15\n         POP   USING                                               RPS\n\n         TITLE 'STRMERD'                                           RPS\n         DS    0H                                                  RPS\nSTIMERD  CSECT\n         PUSH  USING                                               RPS\n         DROP  R12                                                 RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,R15SAVED +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,R1SAVED   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVED DS    A            +20: ROOM FOR R15\nR1SAVED  DS    A            +24: ROOM FOR R1\nSTIMREAL DS    A            +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nSTIMPARM DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMERDE DS    0H\n         DROP  R15                                                RPS\n         POP   USING                                              RPS\n         TITLE 'STIMEREX'                                           RPS\n         DS    0H                                                   RPS\nSTIMEREX CSECT\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSASK DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         DROP  R12                                           RPS\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSASK DSECT AREA\n         USING OSASDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n         IKJTSVT\n         IKJIOPL\n         TSSOCVT\n         COPY  TSSODATD\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\n         END   OSASK\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSASK(''TSSO V 4.2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    OSASK'\n PUNCH ' NAME     OSASK(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSASKY": {"ttr": 32008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x966o\\x00\\x966o\\x08\\x11\\x03;\\x03;\\x00\\x00\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-31T00:00:00", "modifydate": "1996-12-31T08:11:00", "lines": 827, "newlines": 827, "modlines": 0, "user": "RPS"}, "text": "         TITLE ' T S S O  WTOR TSO INTERFACE'\nOSASK    CSECT\n         EQUATES\n***********************************************************************\n* THIS IS THE OSASK COMMAND PROCESSOR. IT IS A TSO COMMAND PROCESSOR  *\n* DESIGNED TO RUN UNDER THE TSSO SUBSYSTEM, OR FROM A TSO ADDRESS     *\n* SPACE. THE COMMAND WILL BEHAVE DIFFERENTLY DEPENDING ON THE         *\n* ENVIRONMENT IN WHICH IT IS INVOKED. THE COMMAND CAN BE RUN FROM     *\n* EITHER TSSO, OR ANY AUTHORIZED TSO ADDRESS SPACE.                   *\n*                                                                     *\n* IF UNDER TSSO.                                                      *\n*                                                                     *\n* 1) CHECKS TO SEE IF THE COMMAND IS RUNNING UNDER A CLIST. IF NOT    *\n*    TERMINATE.                                                       *\n*                                                                     *\n* 2) OBTAIN VALUES FOR REPLYWAIT.                                     *\n*                                                                     *\n* 3) ISSUE A WTOR CONTAINING THE MESSAGE TO THE CONSOLE THAT ISSUED   *\n*    THE COMMAND.                                                     *\n*                                                                     *\n* 4) OBTAIN RESPONSE FROM WTOR AND PLACE IN CLIST VARIABLES... OR     *\n*    PUT A DUMMY RESPONSE INTO CLIST VARIABLES.                       *\n*                                                                     *\n* 5) TERMINATE.                                                       *\n*                                                                     *\n*                                                                     *\n* IF UNDER TSO:                                                       *\n*                                                                     *\n* 1) CHECK TO SEE IF RUNNING UNDER A CLIST. IF YES, OBTAIN VALUE FOR  *\n*    COMMAND REPLYWAIT. IF NOT, DEFAULT REPLYWAIT TO 60 SECONDS...    *\n*\n* 2) ISSUES A WTOR CONTAINING THE MESSAGE THE MASTER CONSOLE, AND WAIT*\n*                                                                     *\n* 3) IF INVOKED FROM A CLIST, THE COMMAND CREATES CLIST VARIABLES.    *\n*    IF INVOKED FROM THE COMMAND LINE, THE COMMAND WILL PUTLINE       *\n*    THE RESPONSE TO THE TERMINAL.                                    *\n*                                                                     *\n* 4) TERMINATE.                                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSASK\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSASK,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSASDATD,R11\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n***********************************************************************\n* SINCE OSASK IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *\n* THE VARIABLE WORK AREA.                                             *\n***********************************************************************\n*\n         XC    FLAGS(4),FLAGS\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         MVC   MESSAGED(MESSAGEE-MESSAGEC),MESSAGEC\n         MVC   LINE1HD(80),LINE1HC\n         MVC   LINE2HD(80),LINE2HC\n         MVC   LINE3HD(80),LINE3HC\n         MVC   LINE4HD(80),LINE4HC\n         MVC   LINE6HD(80),LINE6HC\n         MVC   LINE12HD(80),LINE12HC\n         LA    R2,OSASDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         LA    R2,STIMEREX         GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n***********************************************************************\n* WE MUST CHECK TO SEE IF THE ENVIRONMENT IS AMENIABLE TO RUNNING THE *\n* COMMAND. LETS CHECK IF THIS IS THE TSSO ADDRESS SPACE.              *\n*                                                                     *\n***********************************************************************\n         L     R2,X'224'         GET OUR ASCB\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         LTR   R10,R10           IS TSSO EVEN THERE ?\n         BZ    ERROR12           NO, BLOW HIM AWAY\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR12           YUP- SORRY GUY.\n         C     R2,TSSOASCB\n         BNE   NOTUNDSS          NO, NOT UNDER TSSO...\n         L     R10,TSSODSEC\n         USING DATD,R10\n***********************************************************************\n* YES, WE ARE UNDER THE TSSO ADDRESS SPACE.                           *\n* THIS MEANS THAT A PARTICULAR CONSOLE HAS ISSUED THIS COMMAND. LETS  *\n* SAVE THE CONSOLE ID, AND USE IT WHEN ISSUING THE WTOR.              *\n***********************************************************************\n         L     R2,CURRCONS       GET CONSOLE ID OF GUY WITH CLIST\n         ST    R2,CONSOLE\n         OI    FLAGS,X'10'       INDICATE WITH FLAG THAT TSSO IS THE\n*                                CURRENT USER.\n         B     GETMSG\nNOTUNDSS DS    0H\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE MVS COMMAND TO BE EXECUTED FROM THE *\n* BUFFER. WE WILL USE THE CPPLCBUF FIELD PREVIOUSLY SET UP.           *\n***********************************************************************\n         XR    R2,R2\n         ST    R2,CONSOLE\n*\nGETMSG   DS    0H\n         L     R2,CPPLCBUF         GET THE COMMAND BUFFER.\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS AT THE MESSAGE\n         LA    R3,0(R2,R4)         R3 NOW POINTS AT THE END OF THE MSG\n         SR    R3,R5               R3 NOW HAS LENGTH OF THE MESSAGE\n         LTR   R3,R3\n         CH    R3,=H'1'\n         BL    ERROR1\n         CH    R3,=H'120'\n         BH    ERROR1\n         MVI   MESSAGED+12,X'40'\n         MVC   MESSAGED+13(124),MESSAGED+12\n         BCTR  R3,0\n         EX    R3,MOVEMSG\n         B     AR1\nMOVEMSG  MVC   MESSAGED+12(0),0(R5)\nAR1      DS    0H\n*\n*\n***********************************************************************\n* LET US CHECK TO SEE IF WE WERE INVOKED USING TSO/E RELEASE 2. IF NOT*\n* WE WILL TERMINATE.                                                  *\n***********************************************************************\n         L     R9,16               GET CVT\n         USING CVT,R9\n         L     R9,CVTTVT           GET TIME SHARING VECTOR TABLE\n         USING TSVT,R9\n         LTR   R9,R9               IS THIS A TSO/E R2 SYSTEM ?\n         BZ    ERROR2\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE VALUE OF THE REPLYWAIT CLIST        *\n* VARIABLE, IF ONE EXISTS...                                          *\n***********************************************************************\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*                                  ACCESS PROGRAM VARIABLES.\n         LA    R2,TSVERETR         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n*\n*\n*\n*\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               REPVARA,            PTR TO VAR NAME                     X\n               REPVARL,            PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         DROP  R9\n         LTR   R15,R15\n         BZ    WAITOK              YUP, COMMAND OUT WAS OK\n         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?\n         BE    NOTUNDCL            NO, WE ARE NOT UNDER A CLIST...\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?\n         BNE   ERROR3              NO, WE HAVE REAL PROBLEMS.\nDEFCMDOT DS    0H\n         L     R15,=F'6000'\n         ST    R15,REPLYWTT        SELECT DEFAULT TIME OF SIXTY SECONDS\n         B     PROCWTOR            GO AND PROCESS THE WTOR.\n*\nWAITOK   DS    0H\n         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE\n         L     R0,VALLENGT         AND ITS LENGTH\n         LTR   R0,R0\n         BZ    DEFCMDOT\n         LA    R10,OSWKAREA\n         CALL  JCECVTDB            GET SOMETHING IN BINARY.\n         BNZ   ERROR4\n         CH    R1,=H'600'\n         BH    ERROR4\n         OI    FLAGS,X'80'         INDICATE REPLYWAIT SPECIFIED...\n         M     R0,=F'100'\n         ST    R1,REPLYWTT         MAXIMUM NUMBER OF LINE TO ALLOW.\n         B     PROCWTOR            GET THE MVS WAIT TIME FROM THE CLIST\n*                                  IF NOT SPECIFIED, ASSUME 2 SECONDS.\nNOTUNDCL DS    0H\n***********************************************************************\n* HERE, WE HAVE DISCOVERED WE ARE NOT RUNNING UNDER A CLIST. THIS IS  *\n* BRANCHED TO FROM THE SECTION OF CODE THAT TRIES TO OBTAIN THE       *\n* REPLYWAIT VARIABLE VALUE. THIS IS PERMISSIBLE ONLY IF NOT RUNNING   *\n* UNDER THE TSSO ADDRESS SPACE.                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'10'         TSSO ADDRESS SPACE ?\n         BO    ERROR6              YUP, ILLEGAL (AND IMMORAL)\n         OI    FLAGS,X'20'         INDICATE WE ARE NOT UNDER A CLIST\n         MVC   REPLYWTT(4),=F'6000' DEFAULT COMMAND WAIT TIME\n*                                  IN  .01 SECONDS...\n         OI    FLAGS,X'80'         INDICATE REPLYWTT SPECIFIED...\n         B     PROCWTOR\nPROCWTOR DS    0H\n***********************************************************************\n* FINALLY, WE ARE READY TO ISSUE THE MVS WTOR.                        *\n***********************************************************************\n* FIRST, LET US ISSUE THE STIMER SO WE CAN AWAKE FROM THE WTOR IS THE *\n* OPERATOR IS OUT FOR COFFEE...                                       *\n***********************************************************************\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=REPLYWTT\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. THIS MEANS THAT*\n* THE OPERATOR DID NOT REPLY TO THE WTOR IN TIME, AND THEREFORE, WE   *\n* WILL DUMMY UP THE RESPONSE, CANCEL THE WTOR, AND PROCEED TO PARSE   *\n* THE WTOR. IF THE OPERATOR DOES RESPOND, WE WILL WAKE UP, CANCEL THE *\n* STIMER, AND PARSE THE RESULTS...                                    *\n***********************************************************************\n         MVI   REPLYADD,C' '\n         MVC   REPLYADD+1(132),REPLYADD\n         XC    OSASKECB(4),OSASKECB\n         XC    STIMRECB(4),STIMRECB\n         LA    R2,OSASKECB            GET ADDRESS OF OSASKECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n*\n         LA    R3,REPLYADD            GET REPLY ADDRESS\n         LA    R4,OSASKECB            GET ECB ADDRESS\n*\n         L     R0,CONSOLE\n         WTOR  ,(R3),125,(R4),MF=(E,MESSAGED)\n         ST    R1,WTORMSGN\n*\n         WAIT  ECBLIST=LISTECBS\n*\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM THE WTOR BEING POSTED, OR FROM THE *\n* STIMER POPPING...        IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE WTOR ECB , WE SHOULD CANCEL THE STIMER    *\n***********************************************************************\n         TM    OSASKECB,X'40'              POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n         B     PUTRESP\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* HERE, THE STIMER EXIT HAS POPPED, AND POSTED THE STIMERECB, MEANING *\n* THAT THE OPERATOR HAS GONE OUT FOR COFFEE...                        *\n* WE WILL DUMMY UP A RESPONSE FOR THE OPERATOR, AS IF A  RESPONSE WAS *\n* RETURNED.                                                           *\n***********************************************************************\n         MVC   REPLYADD(7),=CL7'NOREPLY'\n         L     R0,CONSOLE\n         WTO   'OSASK01 OSASK COMMAND TIMING OUT -> REQUEST DELETED'\n         L     R2,WTORMSGN         GET WTOR MESSAGE NUMBER\n         DOM   MSG=(R2),REPLY=YES\n         B     PUTRESP\n*\nPUTRESP  DS    0H\n***********************************************************************\n* NEXT, WE MUST GO ABOUT THE BUSINESS OF CONVERTING THE RESPONSE OF   *\n* THE MESSAGE INTO CLIST VARIABLES, SO THE CLIST CAN ACCESS THEM.     *\n* THIS IS, OF COURSE, ONLY NECCESARY IF THE OSASK COMMAND WAS INVOKED *\n* FROM A CLIST.IFNOWE WILL SIMPLY TAKE THE RESPONSE, AND PUTLINE IT   *\n* OUT TO THE TSO TERMINAL.                                            *\n***********************************************************************\n         TM    FLAGS,X'20'     NOT INVOKED FROM A CLIST ?\n         BNO   PUTCLSTV        YES, PUTLINE THE RESPONSE TO THE TUBE.\n***********************************************************************\n* HERE, WE WILL SIMPLY RETURN THE COMMAND RESPONSE TO THE TERMINAL.   *\n* THE PUTLINE MACRO WILL BE USED.                                     *\n***********************************************************************\n         MVC   PUTRESPD(2),=H'125'       LENGTH IS ALWAYS 130\n         XC    PUTRESPD+2(2),PUTRESPD+2  CLEAR OUT BUFFER\nPUTRLOOP DS    0H\n         MVC   PUTRESPD+4(125),REPLYADD\n         PUTLINE PARM=PUTBLOK,OUTPUT=(PUTRESPD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDCMD\n*\nPUTCLSTV DS    0H\n*\n         LA    R4,TSVEUPDT         WE WISH TO UPDATE CLIST VARS..\n         ST    R4,ECODE\n*\n         LA    R4,CLVARNME         GET VARNAME PTR\n         ST    R4,NAMEPTR          TELL IKJCT441\n         MVC   CLVARNME(5),=CL5'REPLY'\n*\n         LA    R4,5\n         ST    R4,NAMELEN\n*\nGOTNAME  DS    0H\n         LA    R2,REPLYADD        POINT TO REPLY ADDRESS\n         ST    R2,VALUEPTR\n*\n         LA    R3,REPLYADD\n         LA    R4,REPLYADD+132    START AT LAST CHARACTER\nLLOOP    DS    0H\n         CLI   0(R4),C' '\n         BNE   NBLNKFND           FOUND A NON  BLANK\n         BCTR  R4,0\n         CR    R4,R3              ARE WE DONE\n         BL    NULLVAR            YUP, PITTY...   (PTF 2)\n         B     LLOOP\n*\nNULLVAR  DS    0H\n         XR    R4,R4\n         ST    R4,VALUELEN\n         B     CALLTSV\n*\nNBLNKFND DS    0H\n         SR    R4,R3              GOT THE LENGTH IN R4\n         LA    R4,1(R4)\n         ST    R4,VALUELEN\n*\nCALLTSV  DS    0H\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*\n* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *\n* AND PUT THE WORDS INTO CLIST VARIABLES.                             *\n* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *\n***********************************************************************\n         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE\n*\n         MVC   OSPARS2(4),=F'125' SECOND PARM -> LENGTH OF STRING\n*\n         MVI   OSPARARR,X'40'\n         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY\n         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB\n         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...\n         LA    R4,OSPARARR                GET ADDRESS\n         ST    R4,OSPARS3                 AND PASS TO TSSOPARS\n*\n         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE\n         ST    R4,OSPARS4             SEPARATOR CHARACTERS.\n         MVC   WORDSEPS(4),=CL4' ,= '\n*\n         LA    R1,OSPARSPM\n         CALL  TSSOPARS              ** PARSE IT **\n         LH    R8,OSPARARR\n         ST    R8,WORDLINE\n***********************************************************************\n* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *\n* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *\n***********************************************************************\n         LA    R4,CLVARNME           GET VARIABLE NAME\n         ST    R4,NAMEPTR\n         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...\n         MVI   0(R4),C'W'            MOVE IN A \"W\"\n*\n*\n         L     R4,NAMELEN\n         LA    R4,1(R4)\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         STCM  R1,B'1111',EBCCOUNT\n*\n         LA    R4,4\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n***********************************************************************\n* THE NEXT STEP IS TO CREATE THE REPLYWN   VARIABLES, WHERE \"N\" IS    *\n* THE CURRENT WORD THAT WE ARE WORKING ON...                          *\n* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *\n* CLIST VARIABLES.                                                    *\n***********************************************************************\n*\n*\n         LA    R4,1\n         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD\n         LA    R4,OSPARARR+2\n         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN\n*                                        THE PARSE ARRAY\n*\nWORDLOOP DS    0H\n         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR\n         ST    R4,NAMELENW              AND KEEP A COPY\n         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?\n         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?\n         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON\n*\n         LA    R4,CLVARNME               GET THE VARIABLE NAME\n         ST    R4,NAMEPTR                TELL CLIST ROUTINE\n*\n         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM\n         LR    R1,R4\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R4,=H'10'\n         BL    WOR1BYTE\nWOR2BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,2(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nWOR1BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,1(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nGOTNAME2 DS    0H\n***********************************************************************\n* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *\n*                                                                     *\n***********************************************************************\n         L     R4,CURRWPOS\n         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..\n         XR    R6,R6\nWLENLOOP DS    0H\n         CLI   0(R4),C' '    BLANK FOUND ?\n         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6\n         LA    R6,1(R6)\n         LA    R4,1(R4)\n         BCT   R5,WLENLOOP\nWLENELOP DS    0H\n         ST    R6,VALUELEN\n*\n         L     R4,CURRWPOS\n         ST    R4,VALUEPTR\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELENW,           PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR3\n*\n         L     R4,CURRWPOS\n         LA    R4,16(R4)\n         ST    R4,CURRWPOS\n*\n         L     R4,CURRWNUM\n         LA    R4,1(R4)\n         ST    R4,CURRWNUM\n         B     WORDLOOP\n*\nENDWORDS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE ARE COMPLETED PROCESSING THE LINE... WE SHOULD *\n* NOW BE FINISHED...                                                  *\n***********************************************************************\nENDCMD   DS    0H\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* E R R O R   C O N D I T I O N S ...                                 *\n*                                                                     *\n***********************************************************************\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR3   DS    0H\n         CH    R15,=H'40'             INCORRECT ENVIRONMENT\n         BE    ERROR6                 JUST IN CASE\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR12  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE12HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n\n         TITLE 'STIMEREX'                                           RPS\nSTIMEREX DS    0H\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSASK DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         DROP  R12                                           RPS\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSASK DSECT AREA\n         USING OSASDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n         DROP  R11\n         DROP  R12\n         POP   USING\n         TITLE 'STIMRPRE'                                          RPS\n*\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\nSTIMRPRE DS    0D\n         PUSH  USING                                          RPS\n         DROP  R15                                            RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n         DROP  R15\n         POP   USING                                        RPS\n         TITLE 'OSASK MAINLINE'                             RPS\n*\n*\nREPVARA  DC    A(REPVAR)\nREPVAR   DC    CL9'REPLYWAIT'\nREPVARL  DC    F'9'\n*\nOSCALL1C CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL1E EQU  *\n*\nMESSAGEC WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(REG0,RESP),DESC=(6),MF=L\n*\nMESSAGEE EQU   *\nLINE1HC  DC    H'80',H'0'\nLINE1H   DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >120 CHX\n               ARACTERS'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HC  DC    H'80',H'0'\nLINE3H   DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HC  DC    H'80',H'0'\nLINE4H   DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HC  DC    H'80',H'0'\nLINE6H   DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HC DC    H'80',H'0'\nLINE12H  DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n************************************************************\n*                                                          *\n*        VARIABLE WORK AREAS, COVERED BY BASE REG R11.     *\n*                                                          *\n************************************************************\nOSASDATD DSECT\nOSWKAREA DS    CL200\n*\n         TITLE 'STRMERD'                                        RPS\nSTIMERD  DS    0D\n         PUSH  USING                                            RPS\n         DROP  R12                                              RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,R15SAVED +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,R1SAVED   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVED DS    A            +20: ROOM FOR R15\nR1SAVED  DS    A            +24: ROOM FOR R1\nSTIMREAL DS    A            +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nSTIMPARM DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMERDE DS    0H\n         DROP  R15                                                RPS\n         POP   USING                                              RPS\n*\nFLAGS    DS    4X\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\nOSCALL1D CALL  ,(0,0,0,0,0,0),MF=L\n*\n***********************************************************************\n* THE FOLLOWING SECTION DENOTES THE ECB LIST THAT OSASK WILL WAIT ON  *\n*                                                                     *\n***********************************************************************\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSASKECB\n         DC    X'80'\n         DC    A(0)\n*\nOSASKECB DS    F\nSTIMRECB DS    F\n*\n***********************************************************************\n* THE VARIABLES ARE NEEDED FOR THE CLIST VARIABLE ACCESS ROUTINE      *\n* IKJCT441.                                                           *\n***********************************************************************\nVACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.\nVALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.\nVALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nTOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nECODE    DS    F\n*\nNAMEPTR  DS    F                FOR UPDATE ROUTINE\nNAMELEN  DS    F                FOR UPDATE ROUTINE\nVALUEPTR DS    F                FOR UPDATE ROUTINE\nVALUELEN DS    F                FOR UPDATE ROUTINE\nNAMELENW DS    F                FOR UPDATE ROUTINE FROM \"CMDOUTNWM\"\nCLVARNME DS    CL12\nEBCCOUNT DS    CL4\nCONSOLE  DS    F\n***********************************************************************\n* THESE VARIABLES ARE USED TO KEEP TRACK OF WHICH LINES AND WORDS WE  *\n* ARE USING WHEN STUFFING RESULTS IN CLIST VARIABLES.                 *\n***********************************************************************\nCURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE\nCURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN\n*                               TSSOPARS\nWORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE\nNUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND\n***********************************************************************\n* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *\n* ROUTINE.                                                            *\n***********************************************************************\nOSPARSPM DS    0H\nOSPARS1  DS    F\nOSPARS2  DS    F\nOSPARS3  DS    F\nOSPARS4  DS    F\nWORDSEPS DS    CL4           PROBABLY CL4' ,= '\nOSPARARR DS    20CL16\n***********************************************************************\n* THESE VARIABLES ARE THE BINARY REPRESENTATIONS OF STUFF DERIVED FROM*\n* THE INVOKING CLIST.                                                 *\n***********************************************************************\nWTORMSGN DS    F\nREPLYADD DS    CL133\nREPLYWTT DS    F                MAXIMUM WAIT TIME (IN .01 SECONDS)\n*\nMESSAGED WTOR  '                                                       X\n                                                                       X\n                             ',MCSFLAG=(REG0,RESP),DESC=(6),MF=L\n*\nPUTRESPD DC    H'130',H'0'      FOR PUTTING COMMAND RESPONSE TO TUBE\n         DC    CL130' '\n*\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'THE MESSAGE TO BE ISSUED IS INVALID ( <1 OR >125 CHX\n               ARACTERS'\n*\nLINE2HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> VALUE FOR REPLYWAIT NOT BETWEX\n               EN 10 AND 600'\n*\nLINE6HD  DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> IT MUST BE ISSUED FROM A CLISX\n               T ENVIRONMENT'\n*\nLINE12HD DC    H'80',H'0'\n         DC    CL76'OSASK TERMINATING --> TSSO IS NOT AVAILABLE'\n         IKJTSVT\n         IKJIOPL\n         TSSOCVT\n         COPY  TSSODATD\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\n         END   OSASK\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSASK(''TSSO V 4.2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    OSASK'\n PUNCH ' NAME     OSASK(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSCMD": {"ttr": 32513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x15\\x01\\x021\\x9f\\x01\\x022/\\x08T\\x05\\x93\\x05\\xa5\\x00%\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-18T08:54:15", "lines": 1427, "newlines": 1445, "modlines": 37, "user": "EDJXADM"}, "text": "         TITLE ' T S O   I N T E R F A C E  TO  T S S O / TSSOPCMD'\nOSCMD    CSECT\n***********************************************************************\n* THIS IS THE OSCMD TSO COMMAND PROCESSOR. IT IS THE PRIMARY INTERFACE*\n* TO TSSO FROM A TSO CLIST. IT IS DESIGNED TO ISSUE MVS COMMANDS, AND *\n* OPTIONALLY (THROUGH TSSOPCMD) RETRIEVE THE OUTPUT AND PLACE IT INTO *\n* CLIST VARIABLES. OSCMD WILL BEHAVE DIFFERENTLY DEPENDING ON HOW IT  *\n* IS CALLED. THE FOLLOWING TABLE DEPICTS OSCMD COMMAND BEHAVIOR.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n*         OSCMD IS CALLED FROM A CLIST                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                TSO ADDRESS SPACE              TSSO ADDRESS SPACE    *\n*                -----------------              ------------------    *\n*                                                                     *\n*                                                                     *\n*                MAXCMDOUT DEFAULT - 200        MAXCMDOUT DEFAULT     *\n*                CMDWAIT   DEFAULT - 1 SEC      IS 200.               *\n*                                                                     *\n*                CMDRESP VARIABLE DETERMINES    CMDWAIT DEFAULT IS 1  *\n*                WHERE COMMAND RESPONSE SHOULD  SECOND                *\n*                GO                                                   *\n*                                                                     *\n*                CMDRESP = 'CLIST' -                                  *\n*                  CLIST VARIABLES CONTAINING   CMDRESP VARIABLE      *\n*                  COMMAND RESPONSE ARE         DETERMINES WHERE      *\n*                  GENERATED                    RESPONSE GOES.        *\n*                                                                     *\n*                CMDRESP = 'TERMINAL'                                 *\n*                  OUTPUT IS DISPLAYED ON       CMDRESP = 'CLIST'     *\n*                  TERMINAL.                     CLIST VARIABLES      *\n*                                                CONTAINING RESPONSE  *\n*                                                ARE GENERATED.       *\n*                AUTHORITY IS BASED ON OSCMDATH                       *\n*                HOWEVER, IF USER IS NOT                              *\n*                AUTHORIZED, THEN THE CMDRESP   CMDRESP = 'NOWHERE'   *\n*                MUST BE RETURNED TO THE USER    COMMAND IS ISSUED -  *\n*                OR THE CLIST.                   RESPONSE NOT RETURNED*\n*                                                                     *\n*                                                                     *\n*                                               CMDRESP DEFAULT =     *\n*                                                'CLIST' IF MAXCMDOUT *\n*                                                IS SPECIFIED.        *\n*                                                                     *\n*                                                                     *\n*                                               AUTHORITY BASED ON    *\n*                                               INVOKING CONSOLE      *\n*---------------------------------------------------------------------*\n*         OSCMD IS NOT CALLED FROM A CLIST                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                TSO ADDRESS SPACE              TSSO ADDRESS SPACE    *\n*                -----------------              ------------------    *\n*                                                                     *\n*                                                                     *\n*                MAXCMDOUT DEFAULT IS                ILLEGAL          *\n*                200                                                  *\n*                                                                     *\n*                                                                     *\n*                CMDWAIT DEFAULT IS 1 SECOND                          *\n*                                                                     *\n*                                                                     *\n*                RESPONSE IS RETURNED TO THE                          *\n*                TERMINAL                                             *\n*                                                                     *\n*                                                                     *\n*                AUTHORITY IS BASED ON OSCMDATH                       *\n*                MODULE.                                              *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  FIXES                                                              *\n*     15OCT92  GLA  PUT IN CHANGES FROM 4.2 VERSION                   *\n*                   A. ADD SUPPORT FOR REXX EXECS TO USE VIA          *\n*                      VARIABLES SYSAUTH_MAXCMDOUT AND SYSAUTH_CMDWAIT*\n*                   B. WITH ES/9000 PROCESSORS THE HARDWARE SYSTEM    *\n*                      CONSOLE IS CONID=100, BUT DOESN'T HAVE A UCME  *\n*                      THEREFORE HANDLE AS SPECIAL CASE. NOTE,        *\n*                      NO MVS SYSTEM CAN HAVE MORE THAN 99 CONSOLES   *\n*                      (SYSTEM OR SYSPLEX!!).                         *\n*                                                                     *\n*     NOV 2002 EEJ  Support MCS extended consoles               EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSCMD\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSCMD,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LA    R7,4095(R12)       I HATE TO USE R7 AS A SECOND BASE\n         LA    R7,1(R7)           BUT I REALLY DIDNT HAVE A CHOICE..\n         USING OSCMD+4096,R7\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSCMDATD,R11\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n         DROP  R2\n         XC    FLAGS(4),FLAGS\n***********************************************************************\n* SINCE OSCMD IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *\n* THE VARIABLE WORK AREA.                                             *\n***********************************************************************\n         MVC   LINE1HD(80),LINE1HC\n         MVC   LINE2HD(80),LINE2HC\n         MVC   LINE3HD(80),LINE3HC\n         MVC   LINE4HD(80),LINE4HC\n         MVC   LINE5HD(80),LINE5HC\n         MVC   LINE6HD(80),LINE6HC\n         MVC   LINE7HD(80),LINE7HC\n         MVC   LINE8HD(80),LINE8HC\n         MVC   LINE9HD(80),LINE9HC\n         MVC   LINE10HD(80),LINE10HC\n         MVC   LINE11HD(80),LINE11HC\n         MVC   LINE12HD(80),LINE12HC\n         MVC   LINE13HD(80),LINE13HC\n         MVC   LINE14HD(80),LINE14HC\n         MVC   LINE15HD(80),LINE15HC\n         MVC   LINE16HD(80),LINE16HC\n*        MVC   LINE17HD(80),LINE17HC\n*\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n         MVC   OSCALL2D(OSCALL2E-OSCALL2C),OSCALL2C\n         MVC   PUTBLOK(PUTBLOKE-PUTBLOKC),PUTBLOKC\n*\n         LA    R2,MVSCMD+4\n         ST    R2,PARMCMD          SET UP PARMS TO TSSOPCMD\n         LA    R2,MVSCMDL\n         ST    R2,PARMCMDL\n         LA    R2,USERID\n         ST    R2,PARMUSER         SET UP ANOTHER PARM TO TSSOPCMD\n         LA    R2,ERRORCDE\n         ST    R2,PARMERR          AND ANOTHER\n         LA    R2,AUTHBYTE\n         ST    R2,PARMAUTH         AND ANOTHER\n         LA    R2,WAITTIME\n         ST    R2,PARMWTME         YET ANOTHER.\n         LA    R2,MAXLINES\n         ST    R2,PARMLINE         AND ANOTHER...\n*\nEXTCMD   DS    0H\n         L     R2,CPPLCBUF         POINT TO THE COMMAND BUFFER\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS TO THE MVS COMMAND\n         LA    R3,0(R2,R4)         R3 NOW POINTS TO THE END OF THE\n*                                  BUFFER\n         SR    R3,R5               R3 NOW HAS THE LENGTH OF THE COMMAND\n         LTR   R3,R3\n         CH    R3,=H'1'            AT LEAST ONE CHARACTER LONG\n         BL    ERROR7\n         MVI   MVSCMD+4,X'40'\n         MVC   MVSCMD+5(125),MVSCMD+4   BLANK OUT THE PREVIOUS MVS\n*                                     COMMAND\n         MVI   CMDRESPV,X'40'\n         MVC   CMDRESPV+1(7),CMDRESPV\n*\n         MVC   MVSCMD(2),=H'127'\n         MVC   MVSCMD+2(2),=H'0'\n         ST    R3,MVSCMDL          STORE AWAY LENGTH\n         BCTR  R3,0\n         EX    R3,MOVECMD\n         B     AR1\nMOVECMD  MVC   MVSCMD+4(0),0(R5)     ** EXECUTED **\nAR1      DS    0H\n*\n         L     R2,CPPLPSCB\n         USING PSCB,R2\n         MVC   USERID(8),=CL8' '\n         MVC   USERID(7),PSCBUSER\n         DROP  R2\n*\n***********************************************************************\n* MVS AUTHORIZATION IS REQUIRED TO RUN THIS MODULE, LETS CHECK.       *\n*                                                                     *\n***********************************************************************\n         TESTAUTH FCTN=1           ARE WE AUTHORIZED ?\n         LTR   R15,R15\n         BNZ   ERROR1             NOT EVEN AUTHORIZED...\n*\n***********************************************************************\n* WE MUST CHECK TO SEE IF THE ENVIRONMENT IS AMENIABLE TO RUNNING THE *\n* COMMAND. LETS CHECK IF TSSO WILL BE AVAILABLE TO PROCESS THIS       *\n* COMMAND.                                                            *\n***********************************************************************\n         GETCVT (R10)\n         LTR   R10,R10           IS TSSO EVEN THERE ?\n         BZ    ERROR12          NO, BLOW HIM AWAY\n         USING TSSOCVT,R10\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR12\n         TM    TSSOFLG2,TSSOPLOA WAS OPCMD LOADED ?\n         BNO   ERROR12           BAD NEWS...\n         L     R2,OPCMDADR       GET OPCMD ADDRESS\n         ST    R2,AOPCMD         AND PUT IT AWAY FOR LATER\n         L     R2,X'224'         GET OUR ASCB\n         C     R2,TSSOASCB       IS THIS THE TSSO ADDRESS SPACE ?\n         BNE   NOTTSSO\n         OI    FLAGS,X'40'       YES, IT IS THE TSSO ADDRESS SPACE\n         DROP  R10\nNOTTSSO  DS    0H\n*\n***********************************************************************\n* NEXT, CHECK THE VALUE OF THE CLIST VARIABLES... ALSO, CHECK TO SEE  *\n* IF WE ARE RUNNING UNDER A CLIST. SINCE THIS IS EASILY DONE BY TRYING*\n* TO OBTAIN THE VALUE OF A CLIST VARIABLE, LETS HAVE AT IT.           *\n*                                                                     *\n***********************************************************************\n         L     R9,16               GET CVT\n         USING CVT,R9\n         L     R9,CVTTVT           GET TIME SHARING VECTOR TABLE\n         USING TSVT,R9\n         LTR   R9,R9               IS THIS A TSO/E R2 SYSTEM ?\n         BZ    NOCLIST             FAKE NO CLIST...\n***********************************************************************\n* THE NEXT STEP IS TO EXTRACT THE VALUE OF THE CMDRESP CLIST VARIABLE,*\n* IF ONE EXISTS..                                                     *\n***********************************************************************\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*\n         LA    R2,TSVNOIMP         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n***********************************************************************\n* EXTRACT CLIST VARIABLE  \"CMDRESP\"                                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               CMDRESPA,           PTR TO VAR NAME                     X\n               CMDRESPL,           PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BZ    CMDRESPF            YUP, COMMAND RESPONSE VARIABLE\n*                                  WAS FOUND ... PROCESS.\n         CH    R15,=H'40'          INCORRECT ENVIRONMENT ?\n         BE    NOCLIST             YUP - CLIST ENVIRONMENT NOT ACTIVE\n         OI    FLAGS,X'80'         SET CLIST BIT.\n         CH    R15,=H'52'          CMDRESP NOT FOUND\n         BE    CMDRESNF            COMMAND RESPONSE NOT FOUND\n         B     ERROR3              UNKNOWN ERROR\nCMDRESPF DS    0H\n         OI    FLAGS,X'80'         INDICATE CLIST IS ACTIVE\n         L     R2,VALPTR           POINT TO CMDRESP VARIABLE\n         L     R3,VALLENGT         GET ITS LENGTH\n         LTR   R3,R3\n         BZ    CMDRESNF            SIMULATE THIS VARIABLE NOT FOUND\n         BCTR  R3,0\n         CH    R3,=H'7'            CHECK OUT LENGTH\n         BH    ERROR5              BAD NEWS... INVALID CMDRESP VAR\n         EX    R3,MOVERESP         MOVE THE RESPONSE\n         B     AR2\nMOVERESP MVC   CMDRESPV(0),0(R2)    ** EXECUTED **\nAR2      DS    0H\n         CLC   CMDRESPV(8),=CL8'TERMINAL'\n         BE    PASTRESP\n         CLC   CMDRESPV(8),=CL8'CLIST'\n         BE    PASTRESP\n         CLC   CMDRESPV(8),=CL8'NOWHERE'\n         BE    PASTRESP\n         B     ERROR5              GO PAST THE RESPONSE...\nCMDRESNF DS    0H\n***********************************************************************\n* DEFAULT VALUE OF COMMAND RESPONSE MUST BE DELAYED UNTIL AFTER WE\n* HAVE THE MAXCMDOUT VALUE.\n***********************************************************************\n         MVC   CMDRESPV(8),=CL8'NOTSPEC'  PUT IN DUMMY VALUE FOR NOW\n         B     PASTRESP\nNOCLIST  DS    0H\n***********************************************************************\n* WE COME HERE IF THE ATTEMPT TO OBTAIN THE CMDRESP VARIABLE FAILED   *\n* BECAUSE WE ARE NOT RUNNING UNDER A CLIST. WE WILL SET THE NOCLIST   *\n* BIT, WHICH WILL SIGNAL MAXCMDOUT AND CMDWAIT DEFAULTS...            *\n***********************************************************************\n         NI    FLAGS,255-X'80'      SET NO CLIST FLAG\nPASTRESP DS    0H\n***********************************************************************\n* THE NEXT STEP IS TO DETERMINE THE VALIDITY OF THE ENVIRONMENT. WE   *\n* HAVE THE FOLLOWING VARIABLES: CMDRESP, TSSO/NOTSSO AND CLIST/NOCLIST*\n* THE FOLLOWING PSEUDOCODE REPRESENTS THE PROCESS                     *\n*                                                                     *\n* IF CLIST=YES THEN                                                   *\n*    IF TSSO=YES THEN                                                 *\n*      IF CMDRESP=' ' AND MAXCMDOUT IS DEFINED THEN                   *\n*       CMDRESP='CLIST'                                               *\n*      IF CMDRESP=' ' AND MAXCMDOUT NOT DEFINED THEN                  *\n*       CMDRESP='NOWHERE'                                             *\n*                                                                     *\n*      IF CMDRESP='TERM' INVALID    AUTHORITY BASED ON INVOKING       *\n*      IF CMDRESP='CLIST' VALID    CONSOLE. SS CONSOLE USED           *\n*      IF CMDRESP='NOWHERE' VALID           SS CONSOLE NOT USED       *\n*                                                                     *\n* IF CLIST=YES THEN                                                   *\n*    IF TSSO=NO THEN                                                  *\n*      IF CMDRESP=' ' THEN CMDRESP='NOWHERE'                          *\n*                                                                     *\n*    CMDRESP='TERM'    VALID                                          *\n*    CMDRESP='CLIST'   VALID     SS CONSOLE WILL ALWAYS BE USED       *\n*    CMDRESP='NOWHERE' VALID     AUTHORITY BASED ON CALL TO OSCMDATH  *\n*                                                                     *\n*                                                                     *\n* IF CLIST=NO THEN\n*    IF TSSO=YES THEN COMMAND IS INVALID\n*\n*    IF TSSO=NO THEN                                                  *\n*       CMDRESP='TERM'  DEFAULT... SS CONSOLE USED AUTH BASED ON CALL *\n*                                  TO OSCMDATH                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*    MAXCMDOUT AND CMDWAIT CLIST VARS WILL BE USED IF AVAILABLE, ELSE *\n*    THE DEFAULTS ARE TAKEN: MAXCMDOUT-200    CMDRESP-1 SECOND        *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'80'        IS THIS A CLIST ?\n         BNO   PROCNCLS           NO - PROCESS NON CLIST ACTIVITY\nPROCCLST DS    0H\n***********************************************************************\n* WE COME HERE TO PROCESS THE VARIABLES IF WE ARE RUNNING UNDER A     *\n* CLIST                                                               *\n***********************************************************************\n         TM    FLAGS,X'40'        UNDER CLIST AND UNDER TSSO ?\n         BO    PROCCTSS           YUP - GOTTA TO PROCESS UT\n*\n***********************************************************************\n* WE COME HERE TO PROCESS THE CASE WHERE WE ARE UNDER A CLIST BUT     *\n* NOT USING TSSO. ALL VALUES OF CMDRESP ARE VALID, BUT WE NEED TO     *\n* CHECK IF ONE WAS SPECIFIED.                                         *\n***********************************************************************\nGTCMDVAR DS    0H\n         CALL  OSCMDATH,(AUTHBYTE),MF=(E,OSCALL2D)\n         LTR   R15,R15\n         BNZ   ERROR11\n         B     GETVARS\n*\nPROCCTSS DS    0H\n***********************************************************************\n* WE COME HERE TO PROCESS THE CASE WHERE WE ARE IN A CLIST, AND USING *\n* TSSO.    THE DEFAULT FOR CMDRESP WILL BE SET BASED ON THE VALUE OF  *\n* THE MAXCMDOUT VARIABLE. IN THIS CASE, WE MUST GET THIS VALUE BEFORE *\n* PROCEEDING. WHILE WE ARE HERE, LETS CHECK FOR INVALID REQUESTS OF   *\n* CMDRESP VARIABLE.\n***********************************************************************\n         CLC   CMDRESPV(8),=CL8'TERMINAL' TSSO TERMINAL - DOESNT MAKE\n*                                         SENSE\n         BE    ERROR4\n         B     GETVARS            GET THE REST OF THE VARIABLES\nPROCNCLS DS    0H\n***********************************************************************\n* WE COME HERE IF WE ARE NOT OPERATING UNDER A CLIST                  *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'40'        NOT UNDER CLIST AND UNDER TSSO\n         BO    PRONCTSS           YUP - GOTTA PROCESS IT.\nPROCNCNT DS    0H\n***********************************************************************\n* WE COME HERE IF WE ARE NOT RUNNING A CLIST, AND WE ARE NOT UNDER    *\n* TSSO. THIS IS THE CASE OF A STRAIGHT OSCMD COMING FROM A TSO USER.  *\n***********************************************************************\n         MVC   CMDRESPV(8),=CL8'TERMINAL'  ASSIGN DEFAULT TO CMDRESPV\n         CALL  OSCMDATH,(AUTHBYTE),MF=(E,OSCALL2D)\n         LTR   R15,R15\n         BNZ   ERROR11\n         B     GETVARS                     AND GET REST OF VARS\n*\nPRONCTSS DS    0H\n***********************************************************************\n* WE COME HERE IF WE ARE NOT RUNNING A CLIST, AND WE ARE UNDER TSSO.  *\n* THIS IS AN ERROR, AS AN OPERATING WOULD NOT NEED OSCMD TO ISSUE MVS *\n* COMMANDS.                                                           *\n***********************************************************************\n         B     ERROR4\n*\nGETVARS  DS    0H\n***********************************************************************\n* METHOD OF OPERATION:                                                *\n*                                                                     *\n* NOW THAT WE HAVE VALUE FOR THE KEY \"CLIST\" \"CMDRESP\" AND \"TSSO\"     *\n* VARIABLES, AND THEY ARE VALID, LET US GET THE VALUES OF THE         *\n* MAXCMDOUT AND CMDWAIT VARIABLES. THESE MAY BE OBTAINED FROM THE     *\n* CLIST, OR DEFAULTED TO IF NOT PRESENT IN THE CLIST, OR IF OSCMD     *\n* IS NOT RUNNING UNDER A CLIST. NOTE THAT THE AUTHORITY BYTE IS       *\n* ALSO FILLED IN, IF NOT RUNNING UNDER TSSO. IF OSCMD IS RUNNING      *\n* UNDER TSSO, THE AUTHORITY BYTE WILL WAIT UNTIL WE FIGURE OUT THE    *\n* CMDRESP VARIABLE.                                                   *\n***********************************************************************\n*\n***********************************************************************\n* STEP 1: OBTAIN THE VALUE OF MAXCMDOUT.                              *\n***********************************************************************\n         TM    FLAGS,X'80'         RUNNING UNDER CLIST?\n         BNO   DEFCMDOT            YUP, GO DEFAULT MAXCMDOUT\n         CLC   CMDRESPV(8),=CL8'NOWHERE'   RESPONSE GOING NOWHERE ?\n         BE    DEFCMDOT                    YUP - DONT BOTHER.\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*\n         LA    R2,TSVNOIMP         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               CMDOUTA,            PTR TO VAR NAME                     X\n               CMDOUTL,            PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BZ    CMDOUTF             YUP, COMMAND OUT WAS OK\n***********************************************************************\n* WE COME HERE IF THERE WAS A PROBLEM OBTAINING MAXCMDOUT FROM THE    *\n* CLIST                                                               *\n***********************************************************************\n         MVC   LINE13+52(8),=CL8'DEFCMDOT' JUST IN CASE\n         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?\n         BE    ERROR13             NO, A LOGIC PROBLEM EXISTS... .\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?\n         BNE   ERROR13             REAL PROBLEMS                15OCT92\n****************************************************************15OCT92\n**       TRY INSTEAD THE REXX AUTH CMD VARIABLE NAME            15OCT92\n****************************************************************15OCT92\n         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE   15OCT92\n         LA    R2,TSVNOIMP         \"ENTRY CODE\" = RETRIEVE ONLY 15OCT92\n         ST    R2,ECODE            SET PARM 1                   15OCT92\n*                                                               15OCT92\n         CALL  (15),                                            15OCT92X\n               (ECODE,             ENTRY CODE                   15OCT92X\n               REXOUTA,            PTR TO VAR NAME              15OCT92X\n               REXOUTL,            PTR TO VAR LENGTH            15OCT92X\n               VALPTR,             PTR TO VALUE                 15OCT92X\n               VALLENGT,           PTR TO VALUE LENGTH          15OCT92X\n               TOKEN),             TOKEN                        15OCT92X\n               VL,MF=(E,OSCALL1D)                               15OCT92\n         LTR   R15,R15                                          15OCT92\n         BZ    CMDOUTF             YUP, COMMAND OUT WAS OK      15OCT92\n         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?   15OCT92\n         BE    DEFCMDOT            NO, WE ARE NOT UNDER A REXX..15OCT92\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?           15OCT92\n         BNE   ERROR13             NO, WE HAVE REAL PROBLEMS.   15OCT92\n         B     DEFCMDOT            GO USE DEFAULT               15OCT92\nDEFCMDOT DS    0H\n         CLC   CMDRESPV(8),=CL8'NOTSPEC'   CMDRESP NOT SPECIFIED ?\n         BNE   PSTACMD1\n         MVC   CMDRESPV(8),=CL8'NOWHERE'   FUDGE DEFAULT IF UNDER\n*                                          TSSO AND IN CLIST\nPSTACMD1 DS    0H\n         LA    R15,200             DEFAULT IS 200 LINES\n         ST    R15,MAXLINES        DOESN'T WANT COMMAND RESPONSE\n*                                  RETURNED.\n         B     CLVARWT             GO AND PROCESS THE WAIT VARIABLE\n*\nCMDOUTF  DS    0H\n         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE\n         L     R0,VALLENGT         AND ITS LENGTH\n         LTR   R0,R0\n         BZ    ERROR6              INVALID MAXCMDOUT VALUE\n         LA    R10,OSWKAREA\n         CALL  JCECVTDB            GET SOMETHING IN BINARY.\n         BNZ   ERROR6\n         LTR   R1,R1\n         BNP   ERROR6              ASSURE THIS IS A POSITIVE NUMBER\n         CH    R1,=H'200'\n         BH    ERROR6\n         ST    R1,MAXLINES         MAXIMUM NUMBER OF LINE TO ALLOW.\n         TM    FLAGS,X'40'         UNDER TSSO ?\n         BNO   PSTACMD2            NO, DONT CHANGE DEFAULT\n         CLC   CMDRESPV(8),=CL8'NOTSPEC'   CMDRESP NOT SPECIFIED ?\n         BNE   PSTACMD2\n         MVC   CMDRESPV(8),=CL8'CLIST'     FUDGE DEFAULT IF UNDER\n*                                          TSSO AND IN CLIST\nPSTACMD2 DS    0H\n         B     CLVARWT             GET THE MVS WAIT TIME FROM THE CLIST\n*\n*\nCLVARWT  DS    0H\n***********************************************************************\n* YET ANOTHER USE OF THE CLIST EXTRACT ROUTINE. THIS TIME, WE NEED    *\n* THE ADDRESS OF THE CMDWAIT CLIST VARIABLE.                          *\n***********************************************************************\n         TM    FLAGS,X'80'         RUNNING UNDER CLIST ?\n         BNO   DEFCMDWT            NO - ASSIGN DEFAULT TO CMD WAIT TIME\n*\n         CLC   CMDRESPV(8),=CL8'NOWHERE'   RESPONSE GOING NOWHERE ?\n         BE    DEFCMDWT                    YUP - DONT BOTHER.\n*\n         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE\n         LA    R2,TSVNOIMP         \"ENTRY CODE\" = RETRIEVE\n         ST    R2,ECODE            SET PARM 1\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               CMDWAITA,           PTR TO VAR NAME                     X\n               CMDWAITL,           PTR TO VAR LENGTH                   X\n               VALPTR,             PTR TO VALUE                        X\n               VALLENGT,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n*\n         LTR   R15,R15\n         BZ    CMDWAITF            YUP, COMMAND OUT WAS OK\n         MVC   LINE13+52(8),=CL8'CLVARWT'\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?\n         BNE   ERROR13             NO, WE HAVE REAL PROBLEMS.\n****************************************************************15OCT92\n**       TRY INSTEAD THE REXX AUTH CMD VARIABLE NAME            15OCT92\n****************************************************************15OCT92\n         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE   15OCT92\n         LA    R2,TSVNOIMP         \"ENTRY CODE\" = RETRIEVE      15OCT92\n         ST    R2,ECODE            SET PARM 1                   15OCT92\n         CALL  (15),                                            15OCT92X\n               (ECODE,             ENTRY CODE                   15OCT92X\n               REXWAITA,           PTR TO VAR NAME              15OCT92X\n               REXWAITL,           PTR TO VAR LENGTH            15OCT92X\n               VALPTR,             PTR TO VALUE                 15OCT92X\n               VALLENGT,           PTR TO VALUE LENGTH          15OCT92X\n               TOKEN),             TOKEN                        15OCT92X\n               VL,MF=(E,OSCALL1D)                               15OCT92\n*                                                               15OCT92\n*                                                               15OCT92\n         LTR   R15,R15                                          15OCT92\n         BZ    CMDWAITF            YUP, COMMAND OUT WAS OK      15OCT92\n         CH    R15,=H'52'          UNDEFINED SYMBOL ?           15OCT92\n         BNE   ERROR3              NO, WE HAVE REAL PROBLEMS.   15OCT92\n         B     DEFCMDWT            GO AND DEFAULT THE COMMAND WAIT\n*                                  PARM.\n*\nCMDWAITF DS    0H\n         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE\n         L     R0,VALLENGT         AND ITS LENGTH\n         LTR   R0,R0\n         BZ    ERROR14             NOT DEFINED.\n         LA    R10,OSWKAREA\n         CALL  JCECVTDB            GET SOMETHING IN BINARY.\n         BNZ   ERROR14\n         LTR   R1,R1               LETS DO SOME TESTS.\n         BNP   ERROR14             NEGATIVE OR ZERO, SKIP IT.\n         CH    R1,=H'60'           ABOVE SIXTY SECONDS ?\n         BH    ERROR14\n         M     R0,=F'100'          MAKE UP FOR LOST TIME\n         ST    R1,WAITTIME         STORE IT AWAY\n         B     PASTCMWT            GO ON AND DO THE COMMAND.\nDEFCMDWT DS    0H\n***********************************************************************\n* WE COME HERE TO ASSIGN THE DEFAULT COMMAND WAIT TIME. THIS OCCURS   *\n* IF WE ARE NOT RUNNING IN A CLIST, OR IF THE CMDWAIT CLIST VARIABLE  *\n* IS NOT FOUND.                                                       *\n***********************************************************************\n         LA    R1,150\n         ST    R1,WAITTIME          ASSIGN THE DEFAULT.\n*\nPASTCMWT DS    0H\n***********************************************************************\n* THE FINAL PIECE OF BUSINESS BEFORE CALLING TSSOPCMD IS TO           *\n* DETERMINE THE AUTHORITY OF THE INVOKING CONSOLE, IF THE COMMAND IS  *\n* BEING ISSUED FROM THE TSSO ADDRESS SPACE. TO ACCOMPLISH THIS, WE    *\n* LOOK IT UP IN THE TSSO CVT, WHICH WE HAVE ACCESS TO IFF WE ARE IN   *\n* THE TSSO ADDRESS SPACE.                                             *\n***********************************************************************\n         TM    FLAGS,X'40'         ARE WE UNDER TSSO ?\n         BNO   SETUPPRM            NO, AUTHORITY HAS BEEN SET UP\n*                                                               EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* TSSO used to get the console authorization by searching the  *EEJ1102\n* UCM entries. This technique is incompatible with the use of  *EEJ1102\n* MCS extended consoles since they don't have UCM entries.     *EEJ1102\n* All of this logic has been removed. Instead, console auth-   *EEJ1102\n* orization is obtained from the SSCM when the command enters  *EEJ1102\n* the TSSO environment.                                        *EEJ1102\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                               EEJ1102\n         GETCVT (10)\n         USING TSSOCVT,R10\n*\n         L     R10,TSSODSEC\n         USING DATD,R10\n         MVC   CONSID,CURRCONS     Copy console ID              EEJ1102\n         MVC   CONSNAME,CURRCNAM   Copy console name            EEJ1102\n         MVC   AUTHBYTE,CURRCATH   Copy console auth bits       EEJ1102\n         DROP  R10\n*                                                               EEJ1102\n         NI    AUTHBYTE,255-X'01'     LAST BYTE ALWAYS TURNED OFF...\n*\nSETUPPRM DS    0H\n*\n***********************************************************************\n* THE SUBSYSTEM CONSOLE, AND THE CALL TO TSSOPCMD WILL BE MADE UNLESS *\n* THE FOLLOWING IS TRUE:                                              *\n*                                                                     *\n* 1) OSCMD IS RUNNING IN A CLIST                                      *\n* 2) OSCMD IS RUNNING FROM THE TSSO ADDRESS SPACE                     *\n* 3) CMDRESP IS SET TO \"NOWHERE\". IF THIS IS THE CASE, WE WILL        *\n*    ISSUE THE COMMAND DIRECTLY FROM THIS MODULE, USING THE CONSOLE   *\n*    ID OF THE INVOKER OF OSCMD.                                      *\n*                                                                     *\n***********************************************************************\n         TM    FLAGS,X'80'            UNDER A CLIST ?\n         BNO   USEOPCMD               NO, USE TSSOPCMD\n         TM    FLAGS,X'40'            USING TSSO ?\n         BNO   USEOPCMD\n         CLC   CMDRESPV(8),=CL8'NOWHERE'  RESPONSE GOING NOWHERE ?\n         BNE   USEOPCMD                   NO, USE TSSOPCMD\n*                                                               EEJ1102\n         LH    R0,MVSCMD           Get command buffer length    EEJ1102\n         SH    R0,=H'4'            Decrement for MGCR prefix    EEJ1102\n         STH   R0,MVSCMD+2         Store true command text len  EEJ1102\n         MVC   OSWKAREA(MGCREL),MGCRE Copy MGCRE parm list      EEJ1102\n         LA    R2,MVSCMD+2         Point to command text        EEJ1102\n         MODESET KEY=ZERO,MODE=SUP        ** WOW **\n         MGCRE TEXT=(2),           Issue the command            EEJ1102+\n               CONSID=CONSID,      (same)                       EEJ1102+\n               MF=(E,OSWKAREA)     (same)                       EEJ1102\n         MODESET KEY=NZERO,MODE=PROB      ** UNWOW **\n*\n         B     ENDPROG                    GET OUT FAST\n*                                                               EEJ1102\nMGCRE    MGCRE MF=L                MGCRE parameter list         EEJ1102\nMGCREL   EQU   *-MGCRE             (same)                       EEJ1102\n*\n*\nUSEOPCMD DS    0H\n***********************************************************************\n***********************************************************************\n* WE NEED TO GETMAIN A HEFTY 40K CHUNK OF STORAGE TO PASS TO TSSOPCMD.*\n* THIS STORAGE IS IN PRIVATE.                                         *\n***********************************************************************\n         L     R2,=F'40000'           WE NEED 40,000 BYTES\n         GETMAIN RC,LV=(R2)\n         LTR   R15,R15\n         BNZ   ERROR15\n         ST    R1,PARMSTOR            AND PASS ADDRESS TO PARM LIST\n         OI    FLAGS,X'20'            MARK STORAGE AS OBTAINED.\n***********************************************************************\n* WE NOW HAVE ALL THE PARAMETERS NECCESARY FOR THE CALL TO TSSOPCMD.  *\n* WE NEED TO SET UP THE CALL, ISSUE IT, AND PROCESS THE RESULTS.      *\n***********************************************************************\n***********************************************************************\n* THE TSSOPCMD MODULE IS LOADED INTO GLOBAL STORAGE AT TSSO           *\n* INITIALIZATION, AND ITS ADDRESS IS CHAINED OFF THE TSSO CVT. WE WILL*\n* GET THIS ADDRESS, AND CALL THE MODULE.                              *\n***********************************************************************\n         L     R15,AOPCMD             LOAD UP OPCMD ADDRESS\n         LA    R1,OPCMDPRM            AND THE PARAMETER LIST...\n         BALR  R14,R15                ISSUE THE CALL TO TSSOPCMD\n         LTR   R15,R15\n         BNZ   OPCMDERR               PROBLEM WITH TSSO OPCMD\n*\n***********************************************************************\n* WE NOW HAVE THE 40,000 BYTE BUFFER RETURNED FROM TSSOPCMD. WE WILL  *\n* DISPLAY THIS, OF FORMAT IT, BASED ON THE USER REQUEST.              *\n***********************************************************************\nAFTOPCMD DS    0H\n***********************************************************************\n* NEXT, WE MUST GO ABOUT THE BUSINESS OF CONVERTING THE RESULTS OF    *\n* THE COMMAND INTO CLIST VARIABLES, SO THE CLIST CAN ACCESS THEM.     *\n* THIS IS, OF COURSE, ONLY NECCESARY IF THE COMMAND WAS INVOKED FROM  *\n* A CLIST. IF NOT, WE WILL SIMPLY TAKE THE RESPONSE, AND PUTLINE IT   *\n* OUT TO THE TSO TERMINAL.                                            *\n***********************************************************************\n         L     R1,PARMSTOR     GET COUNT OF LINES RETURNED\n         L     R1,0(R1)\n         ST    R1,NUMLINES     AND STORE IN SAFE PLACE\n         CLC   CMDRESPV(8),=CL8'NOWHERE'   REPSONSE GOING NOWHERE ?\n         BE    ENDCMD                      NUKE IT ALL\n         CLC   CMDRESPV(8),=CL8'TERMINAL'  RESPONSE TO TERMINAL ?\n         BNE   PUTCLSTV        YES, PUTLINE THE RESPONSE TO THE TUBE.\nPUTRESP  DS    0H\n***********************************************************************\n* HERE, WE WILL SIMPLY RETURN THE COMMAND RESPONSE TO THE TERMINAL.   *\n* THE PUTLINE MACRO WILL BE USED.                                     *\n***********************************************************************\n         L     R3,NUMLINES\n         LTR   R3,R3\n         BZ    ERROR16         FOR SOME REASONS, NO LINES WERE RETURNED\n         L     R2,PARMSTOR\n         LA    R2,4(R2)        GET TO BEGINNING OF BUFFER\n         MVC   PUTRESPD(2),=H'150' (PTF1)LENGTH IS ALWAYS 150\n         XC    PUTRESPD+2(2),PUTRESPD+2  CLEAR OUT BUFFER\nPUTRLOOP DS    0H\n         MVC   PUTRESPD+4(150),0(R2)        (PTF1)\n         PUTLINE PARM=PUTBLOK,OUTPUT=(PUTRESPD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         LA    R2,150(R2)           (PTF1)\n         BCT   R3,PUTRLOOP\n         B     ENDCMD\nPUTCLSTV DS    0H\n***********************************************************************\n* FIRST, WE WILL CONVERT THE COUNT INTO A CLIST VARIABLE. THIS IS DONE*\n* EVEN IF NO DATA WAS RETURNED...                                     *\n***********************************************************************\n         LA    R4,TSVEUPDT\n         ST    R4,ECODE\n*\n         LA    R4,CLVARNME         GET VARNAME PTR\n         ST    R4,NAMEPTR          TELL IKJCT441\n         MVC   CLVARNME(6),=CL6'CMDOUT'\n*\n         LA    R4,6\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT         GET ADDRESS OF EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,NUMLINES\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         ST    R1,EBCCOUNT\n*\n         LA    R4,4                LENGTH WILL BE FOUR...\n         ST    R4,VALUELEN\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR9\n         L     R2,PARMSTOR\n         LA    R2,4(R2)            POINT TO BEGINNING OF BUFFER\n         ST    R2,CURRLPOS\n         LA    R3,1\n         ST    R3,CURRLNUM\nCLISTLP  DS    0H\n***********************************************************************\n* NOTE, NAMEPTR SET UP FROM PREVIOUS CALL TO IKJCT441.                *\n***********************************************************************\n         L     R2,CURRLPOS         GET CURRENT LINE POSTION\n         L     R3,CURRLNUM         GET CURRENT LINE NUMBER\n         C     R3,NUMLINES         ARE THERE ANY MORE LINES ?\n         BH    OUTOFVRS            NOPE, ALL OUT OF VARIABLES...\nGETNAME  DS    0H\n***********************************************************************\n* NEXT, WE MUST EXTRACT THE NAME AND LENGTH OF THE \"CMDOUT\" VARIABLES.*\n* THE PROBLEM IS THAT THE NAME CAN BE 7 8 OR 9 CHARACTERS.. WE WILL   *\n* CONSTRUCT THE NAME BASED ON THE NUMBER OF THE LINE WE ARE PROCESSING*\n* E.G. 1-9 10-99 OR HIGHER -> CMDOUT1-CMDOUT9  CMDOUT10-CMDOUT99 ETC..*\n***********************************************************************\n         LR    R1,R3\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R3,=H'10'\n         BL    CPY1BYTE\n         CH    R3,=H'100'\n         BL    CPY2BYTE\nCPY3BYTE DS    0H\n         LA    R4,9\n         ST    R4,NAMELEN\n         STCM  R1,B'0111',CLVARNME+6\n         B     GOTNAME\n*\nCPY2BYTE DS    0H\n         LA    R4,8\n         ST    R4,NAMELEN\n         STCM  R1,B'0011',CLVARNME+6\n         B     GOTNAME\n*\nCPY1BYTE DS    0H\n         LA    R4,7\n         ST    R4,NAMELEN\n         STCM  R1,B'0001',CLVARNME+6\n         B     GOTNAME\n*\nGOTNAME  DS    0H\n         ST    R2,VALUEPTR        R2 WILL POINT TO THE CURRENT LINE\n*                                 ENTRY IN THE OSCMDICB.\n         LA    R15,150\n         LA    R4,149(R2)         POINT AT END OF STRING\nLLOOP4   DS    0H\n         CLI   0(R4),C' '         FOUND THE LAST NON BLANK ?\n         BE    DLLOOP4            YUP - TRUE LENGTH IS IN R15\n         CLI   0(R4),X'00'        MAYBE THIS IS THE LAST NONBLANK\n         BE    DLLOOP4\n         B     ELLOOP4\nDLLOOP4  DS    0H\n         BCTR  R15,0              DECREMENT LENGTH\n         BCTR  R4,0               POINT TO PRECEEDING CHARACTER\n         B     LLOOP4\nELLOOP4  DS    0H\n* R15 SHOULD HAVE REAL LENGTH OF LINE\n         ST    R15,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR9\n*\n***********************************************************************\n* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*\n* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *\n* AND PUT THE WORDS INTO CLIST VARIABLES.                             *\n* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *\n***********************************************************************\n         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE\n*\n         MVC   OSPARS2(4),=F'150' SECOND PARM -> LENGTH OF STRING (PTF1\n*\n         MVI   OSPARARR,X'40'\n         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY\n         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB\n         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...\n         LA    R4,OSPARARR                GET ADDRESS\n         ST    R4,OSPARS3                 AND PASS TO TSSOPARS\n*\n         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE\n         ST    R4,OSPARS4             SEPARATOR CHARACTERS.\n         MVC   WORDSEPS(4),=CL4' ,= '\n*\n         LA    R1,OSPARSPM\n         CALL  TSSOPARS              ** PARSE IT **\n         LH    R8,OSPARARR\n         ST    R8,WORDLINE\n***********************************************************************\n* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *\n* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *\n***********************************************************************\n         LA    R4,CLVARNME           GET VARIABLE NAME\n         ST    R4,NAMEPTR\n         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...\n         MVI   0(R4),C'W'            MOVE IN A \"W\"\n*\n*\n         L     R4,NAMELEN\n         LA    R4,1(R4)\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         STCM  R1,B'1111',EBCCOUNT\n*\n         LA    R4,4\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR9\n*\n***********************************************************************\n* THE NEXT STEP IS TO CREATE THE CMDOUTXWN VARIABLES, WHERE \"N\" IS    *\n* THE CURRENT WORD THAT WE ARE WORKING ON...                          *\n* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *\n* CLIST VARIABLES.                                                    *\n***********************************************************************\n*\n*\n         LA    R4,1\n         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD\n         LA    R4,OSPARARR+2\n         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN\n*                                        THE PARSE ARRAY\n*\nWORDLOOP DS    0H\n         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR\n         ST    R4,NAMELENW              AND KEEP A COPY\n         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?\n         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?\n         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON\n*\n         LA    R4,CLVARNME               GET THE VARIABLE NAME\n         ST    R4,NAMEPTR                TELL CLIST ROUTINE\n*\n         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM\n         LR    R1,R4\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R4,=H'10'\n         BL    WOR1BYTE\nWOR2BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,2(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nWOR1BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,1(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nGOTNAME2 DS    0H\n***********************************************************************\n* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *\n*                                                                     *\n***********************************************************************\n         L     R4,CURRWPOS\n         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..\n         XR    R6,R6\nWLENLOOP DS    0H\n         CLI   0(R4),C' '    BLANK FOUND ?\n         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6\n         LA    R6,1(R6)\n         LA    R4,1(R4)\n         BCT   R5,WLENLOOP\nWLENELOP DS    0H\n         ST    R6,VALUELEN\n*\n         L     R4,CURRWPOS\n         ST    R4,VALUEPTR\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELENW,           PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR9\n*\n         L     R4,CURRWPOS\n         LA    R4,16(R4)\n         ST    R4,CURRWPOS\n*\n         L     R4,CURRWNUM\n         LA    R4,1(R4)\n         ST    R4,CURRWNUM\n         B     WORDLOOP\n*\nENDWORDS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE ARE COMPLETED PROCESSING A WORD.. STANDARD     *\n* PROCEDURE IS TO GO ONTO THE NEXT WORD...                            *\n***********************************************************************\n         L     R2,CURRLPOS\n         LA    R2,150(R2)                (PTF1)\n         ST    R2,CURRLPOS               RESTORE CURRENT LINE\n*\n         L     R3,CURRLNUM\n         LA    R3,1(R3)\n         ST    R3,CURRLNUM               CURRENT LINE NUMBER\n*\n         B     CLISTLP\n*\nOUTOFVRS DS    0H\n         B     ENDCMD\nOPCMDERR DS    0H\n***********************************************************************\n* WE COME HERE IN CASE OF A NON ZERO RETURN CODE FROM THE TSSOPCMD    *\n* MODULE. IF THIS IS THE CASE, WE WILL DISPLAY AN APPROPRIATE ERROR   *\n* MESSAGE. NOTE THE THE ERROR MESSAGES ARE KEPT IN THE OPCMDMSG CSECT *\n***********************************************************************\n         L     R10,=V(OPCMDMSG)\n         LR    R3,R15                 COPY THE RETURN CODE\n         BCTR  R3,0                   MULTIPLICATION WORKS BETTER\n         SRL   R3,2                   DIVIDE BY 4\n         M     R2,=F'80'              AND MULTIPLY BY 80\n         AR    R10,R3                 R10 NOW POINTS TO THE MSG TO\n*                                     BE DISPLAYED.\n         PUTLINE PARM=PUTBLOK,OUTPUT=((10),TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\n         B     ENDCMD                 END OF COMMAND PROCESSING\nENDCMD   DS    0H\n         L     R10,PARMSTOR           GET BUFFER STORAGE\n         L     R2,=F'40000'\n         FREEMAIN R,LV=(R2),A=(R10)\n         B     ENDPROG\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* E R R O R   C O N D I T I O N S ...                                 *\n*                                                                     *\n***********************************************************************\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR3   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR7   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR8   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE8HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR9   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE9HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR10  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE10HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR11  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE11HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR12  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE12HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR13  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE13HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR14  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE14HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR15  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE15HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR16  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE16HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*RROR17  DS    0H\n*        PUTLINE PARM=PUTBLOK,OUTPUT=(LINE17HD,TERM,SINGLE,DATA),     X\n*              MF=(E,IOPLADS)\n*        B     ENDPROG\n*\nOSCALL1C CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL1E EQU  *\n*\nOSCALL2C CALL  ,(0),MF=L\nOSCALL2E EQU  *\n*\n*\nPUTBLOKC PUTLINE MF=L\nPUTBLOKE EQU   *\n*\nLINE1HC  DC    H'80',H'0'\nLINE1H   DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT INVOKED AUTHORX\n               IZED'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HC  DC    H'80',H'0'\nLINE3H   DC    CL76'OSCMD TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HC  DC    H'80',H'0'\nLINE4H   DC    CL76'OSCMD TERMINATING --> ACCESS FROM TSSO TO OSCMD MUSX\n               T BE FROM A CLIST'\n*\nLINE5HC  DC    H'80',H'0'\nLINE5H   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"CMDRESP\" VX\n               ARIABLE'\n*\nLINE6HC  DC    H'80',H'0'\nLINE6H   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"MAXCMDOUT\"X\n                VARIABLE'\n*\nLINE7HC  DC    H'80',H'0'\nLINE7H   DC    CL76'OSCMD TERMINATING --> THE MVS COMMAND TO BE ISSUED X\n               IS MISSING'\n*\nLINE8HC  DC    H'80',H'0'\nLINE8H   DC    CL76'OSCMD TERMINATING --> TSSO HAS NOT ACQUIRED A SUBSYX\n               STEM CONSOLE'\n*\nLINE9HC  DC    H'80',H'0'\nLINE9H   DC    CL76'OSCMD TERMINATING --> ERROR IN UPDATING A \"CMDOUT\" X\n               VARIABLE'\n*\nLINE10HC DC    H'80',H'0'\nLINE10H  DC    CL76'OSCMD TERMINATING --> OSCMD INTERFACE IS ALREADY INX\n                USE'\n*\nLINE11HC DC    H'80',H'0'\nLINE11H  DC    CL76'OSCMD TERMINATING --> YOU ARE NOT AUTHORIZED TO USEX\n                IT'\n*\nLINE12HC DC    H'80',H'0'\nLINE12H  DC    CL76'OSCMD TERMINATING --> TSSO IS UNAVAILABLE TO PROCESX\n               S THE COMMAND'\n*\n*\nLINE13HC DC    H'80',H'0'\nLINE13H  DC    CL76'OSCMD TERMINATING --> LOGIC ERROR IN OSCMD -- LABELX\n                XXXXXXXX'\n*\n*\nLINE14HC DC    H'80',H'0'\nLINE14H  DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"CMDWAIT\" VX\n               ARIABLE'\n*\nLINE15HC DC    H'80',H'0'\nLINE15H  DC    CL76'OSCMD TERMINATING --> UNABLE TO OBTAIN 40,000 BYTE X\n               BUFFER'\n*\nLINE16HC DC    H'80',H'0'\nLINE16H  DC    CL76'OSCMD TERMINATING --> NO LINES WERE RETURNED IN RESX\n               PONSE TO THE COMMAND'\n***********************************************************************\n* THESE ARE CONSTANTS REQUIRED FOR THE RETRIEVAL FUNCTION OF THE      *\n* TSO/E CLIST FEATURE.                                                *\n***********************************************************************\nCMDOUTA  DC    A(CMDOUT)\nCMDOUT   DC    CL9'MAXCMDOUT'\nCMDOUTL  DC    F'9'\n*\nCMDWAITA DC    A(CMDWAIT)\nCMDWAIT  DC    CL7'CMDWAIT'\nCMDWAITL DC    F'7'\n*\nCMDRESPA DC    A(CMDRESP)\nCMDRESP  DC    CL7'CMDRESP'\nCMDRESPL DC    F'7'\n*                                                               15OCT92\nREXOUTA  DC    A(REXOUT)                AUTHORIZED REX SUPPORT  15OCT92\nREXOUT   DC    CL17'SYSAUTH_MAXCMDOUT'                          15OCT92\nREXOUTL  DC    F'17'                                            15OCT92\n*                                                               15OCT92\nREXWAITA DC    A(REXWAIT)               AUTHORIZED REX SUPPORT  15OCT92\nREXWAIT  DC    CL15'SYSAUTH_CMDWAIT'                            15OCT92\nREXWAITL DC    F'15'                                            15OCT92\n***********************************************************************\n* DSECT AREA FOR THE OSCMD TSO COMMAND PROCESSOR                      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nOSCMDATD DSECT\nOSWKAREA DS    CL200\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\n*\nOSCALL1D CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL2D CALL  ,(0),MF=L\n*\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\n*\nFLAGS    DS    F\n* BYTE 1\n* X'80' - OSCMD IS RUNNING FROM A CLIST\n* X'40' - OSCMD IS RUNNING FROM THE TSSO ADDRESS SPACE\n* X'20' - STORAGE HAS BEEN OBTAINED FOR THE 40K BUFFER.\n***********************************************************************\n* VARIABLES TO USE FOR THE TSO/E SERVICE ROUTINES...                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCMDRESPV DS    CL8              VALUE OF COMMAND RESPONSE VAR.\n*\n*\n*\nVACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.\nVALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.\nVALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nTOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nECODE    DS    F\n*\n***********************************************************************\n* THESE ARE THE VARIABLES THAT ARE REQUIRED FOR THE CLIST VARIABLE    *\n* UPDATE ROUTINE.                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCURRLNUM DS    F                CURRENT LINE NUMBER FROM ALL LINES RET\nCURRLPOS DS    F        (PTF1)  POINTER TO 150 BYTES OF DATA FOR THE\n*                               LINE\nCURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE\nCURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN\n*                               TSSOPARS\nWORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE\nNUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND\nNAMEPTR  DS    F                FOR UPDATE ROUTINE\nNAMELEN  DS    F                FOR UPDATE ROUTINE\nVALUEPTR DS    F                FOR UPDATE ROUTINE\nVALUELEN DS    F                FOR UPDATE ROUTINE\nNAMELENW DS    F                FOR UPDATE ROUTINE FROM \"CMDOUTNWM\"\nCLVARNME DS    CL12\nEBCCOUNT DS    CL4\n*\n*\n***********************************************************************\n* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *\n* ROUTINE.                                                            *\n***********************************************************************\nOSPARSPM DS    0H\nOSPARS1  DS    F\nOSPARS2  DS    F\nOSPARS3  DS    F\nOSPARS4  DS    F\nWORDSEPS DS    CL4           PROBABLY CL4' ,= '\nOSPARARR DS    20CL16\nUSERID   DS    CL8              USERID OF OSCMD FACILITY.\nERRORID  DS    CL2              ERROR ID (NOT USED IN TSSO 4.3)\n*\nWAITTIME DS    F                WAIT TIME, IN SECONDS FOR COMMAND\nCONSID   DS    F                CONSOLE ID IF COMMAND ISSUED FROM TSSO\nCONSNAME DS    CL8              Console name                    EEJ1102\n*\nMVSCMD   DS    CL132            2 BYTES LENGTH, 2 BYTES TRASH, 127 FOR\n*                               THE MVS COMMAND\n*\nMVSCMDL  DS    F                LENGTH OF THE MVS COMMAND\n*\nMAXLINES DS    F                MAXIMUM NUMBER OF LINES IN CMD RESP.\n*\nAOPCMD   DS    A                ADDRESS OF THE TSSOPCMD ROUTINE\n*\nERRORCDE DS    F                ERROR  CODE FROM THE TSSOPCMD MODULE\n*\nAUTHBYTE DS    XL2              AUTHORIZATION BYTE TO PASS TO TSSOPCMD\n*\nPUTRESPD DC    H'150',H'0' PTF1 FOR PUTTING COMMAND RESPONSE TO TUBE\n         DC    CL150' '    PTF1\n*\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT INVOKED AUTHORX\n               IZED'\n*\nLINE2HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX\n               LEASE 2 OR HIGHER'\n*\nLINE3HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> ERROR IN CLIST VARIABLE ACCESX\n               S ROUTINE'\n*\nLINE4HD  DC    H'80',H'0'\nLINE4    DC    CL76'OSCMD TERMINATING --> ACCESS FROM TSSO TO OSCMD MUSX\n               T BE FROM A CLIST'\n*\nLINE5HD  DC    H'80',H'0'\nLINE5    DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"CMDRESP\" VX\n               ARIABLE'\n*\nLINE6HD  DC    H'80',H'0'\nLINE6    DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"MAXCMDOUT\"X\n               VARIABLE'\n*\nLINE7HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> THE MVS COMMAND TO BE ISSUED X\n               IS MISSING'\n*\nLINE8HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> TSSO HAS NOT ACQUIRED A SUBSYX\n               STEM CONSOLE'\n*\nLINE9HD  DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> ERROR IN UPDATING A \"CMDOUT\" X\n               VARIABLE'\n*\nLINE10HD DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> OSCMD INTERFACE IS ALREADY INX\n                USE'\nLINE11HD DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> YOU ARE NOT AUTHORIZED TO USEX\n                IT'\n*\nLINE12HD DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> TSSO IS UNAVAILABLE TO PROCESX\n               S THE COMMAND'\nLINE13HD DC    H'80',H'0'\nLINE13   DC    CL76'OSCMD TERMINATING --> YOU MAY NOT ISSUE TSSO COMMANX\n               DS USING THIS INTERFACE'\n*\nLINE14HD DC    H'80',H'0'\nLINE14   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR \"CMDWAIT\" VX\n               ARIABLE'\n*\nLINE15HD DC    H'80',H'0'\nLINE15   DC    CL76'OSCMD TERMINATING --> UNABLE TO OBTAIN 40,000 BYTE X\n               BUFFER'\n*\nLINE16HD DC    H'80',H'0'\n         DC    CL76'OSCMD TERMINATING --> NO LINES WERE RETURNED IN RESX\n               PONSE TO THE COMMAND'\n***********************************************************************\n* THESE ARE THE VARIABLES REQUIRED BY THE CALL TO TSSOPCMD.           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nOPCMDPRM DS    0D                 PARAMETER LIST FOR TSSOPCMD\nPARMCMD  DS    A   0(R1)          ADDRESS OF THE MVS COMMAND\nPARMCMDL DS    F   4(R1)          LENGTH OF THE MVS COMMAND\nPARMWTME DS    F   8(R1)          MAXIMUM WAIT TIME - IN SECONDS\nPARMLINE DS    F  12(R1)          MAXIMUM LINES FOR COMMAND\nPARMAUTH DS    A  16(R1)          AUTHORIZATION BYTE FOR COMMAND\nPARMUSER DS    A  20(R1)          A(USERID OF THE OSCMD FACILITY)\nPARMSTOR DS    A  24(R1)          ADDRESS OF A 40K BUFFER\nPARMERR  DS    A  28(R1)          ADDRESS OF A REASON CODE.\nPARMREAS DS    A  32(R1)          ADDRESS OF THE REASON CODE.\n         IKJTSVT\n         IKJIOPL\n         IKJPSCB\n         TSSOCVT\n         COPY  TSSODATD\n         OSCMDICB\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\nUCM      DSECT\n         IEECUCM\n         END   OSCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSCMD(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' INCLUDE  SYSLMOD(OSCMDATH)'\n PUNCH ' INCLUDE  SYSLMOD(OPCMDMSG)'\n PUNCH ' ENTRY    OSCMD'\n PUNCH ' NAME     OSCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSCMDATH": {"ttr": 33029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00y\\x00y\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 121, "newlines": 121, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE ' T S O   A U T H O R I Z A T I O N   R O U T I N E'\nOSCMDATH CSECT\n***********************************************************************\n* THIS IS THE TSSO AUTHORIZATION ROUTINE. IT IS CALLED BY OSCMD    TO *\n* DETERMINE THE AUTHORITY LEVEL OF THE TSO USER TO ISSUE MVS COMMANDS.*\n*                                                                     *\n* THE AUTHORIZATION BYTE RETURNED BY THIS MODULE SHOULD BE IN THE FORM*\n* REQUIRED BY THE TSSOPCMD ROUTINE. TO ALLOW FOR THE CASE WHERE NO    *\n* ACCESS IS RETURNED, A RETURN CODE 4 ISRETURNED TO OSCMD. THIS MODULE*\n* CAN BE REPLACED, AND THEN RELINKED INTO OSCMD    AS DESIRED BY THE  *\n* INSTALLATION.                                                       *\n*                                                                     *\n*                                                                     *\n* ARGUMENTS: 0(R1) - ADDRESS OF A 1 BYTE FIELD CONTAINING AUTH BYTE   *\n*\n* RETURN CODES:\n*\n* 0: OSCMDATH SUCCESSFULL: AUTHORITY BYTE RETURNED IN PARM LIST.      *\n* 4: OSCMDATH SUCCESSFULL: NO ACCESS TO OSCMDATH IS PERMITTED.        *\n*\n* ANYTHING ELSE: OSCMDATH UNSUCCESSFULL - ABORT COMMAND.\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSCMDATH\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSCMDATH,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING AUTHDATD,R11\n         MVC   EXTRACTD(EXTRACTE-EXTRACTC),EXTRACTC\n*\n***********************************************************************\n* THE ALGORITHM WE USE AT BELL COMMUNICATIONS RESEARCH IS VERY EASY.  *\n* WE CHECK THE PSCB BYTES, AND IF THE FIRST TWO BITS OF BYTE 1 ARE ON,*\n* YOUR AUTHORIZED FOR EVERYTHING. IF JUST THE FIRST BIT IS ON, YOU    *\n* GET I/O AUTHORITY, AND IF NO BITS ARE ON, YOU GET DISPLAY ONLY      *\n***********************************************************************\n         LA    R10,PSCBADDR\n         EXTRACT (10),'S',FIELDS=PSB,MF=(E,EXTRACTD)\n         L     R10,PSCBADDR\n         USING PSCB,R10\n         L     R2,0(R8)              GET FIRST PARM ADDR\n         ST    R2,AAUTH               STORE IT AWAY\n*\n         CLC   PSCBUSER(7),=CL7'CONSINF'\n         BE    NOAUTH\n         TM    PSCBATR2,X'C0'        BOTH BITS ON ?\n         BO    FULLAUTH              YUP, GOOD NEWS\n         TM    PSCBATR2,X'80'        ONE BIT ON, AT LEAST ?\n         BO    PARTAUTH              ALMOST GOOD NEWS.\n         B     INFOAUTH              INFO ONLY - BAD NEWS\n*\nFULLAUTH DS    0H\n         MVI   AUTHBYTE,B'11100001'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nPARTAUTH DS    0H\n***********************************************************************\n* IN OUR CASE, PART AUTHORITY MEANS I/O ONLY                          *\n***********************************************************************\n         MVI   AUTHBYTE,B'01000000'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nINFOAUTH DS    0H\n         MVI   AUTHBYTE,B'00000000'  AS DEFINED BY TSSOPCMD\n         XC    RETCODE(2),RETCODE\n         B     PASTAUTH\nPASTAUTH DS    0H\n         L     R2,AAUTH              GET ADDRESS OF OSCMD AUTHBYTE\n         MVC   0(1,R2),AUTHBYTE      AND PUT IT IN CALLER PARM LIST\n         B     ENDPROG\nNOAUTH   DS    0H\n         MVC   RETCODE(2),=H'4'\n         B     ENDPROG\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n***********************************************************************\n* DATA AREA FOR OSCMDATH CONSTANTS.                                   *\n*                                                                     *\n***********************************************************************\nEXTRACTC EXTRACT 0,'S',FIELDS=PSB\nEXTRACTE EQU   *\n*\n*\n***********************************************************************\n* DSECT AREA FOR OSCMDATH                                             *\n*                                                                     *\n***********************************************************************\nAUTHDATD DSECT\nEXTRACTD EXTRACT 0,'S',FIELDS=PSB\nAAUTH    DS    A                  ADDRESS OF AUTH BYTE PASSED TO US\nPSCBADDR DS    A\nRETCODE  DS    H                  RETURN CODE FROM OSCMDATH\nAUTHBYTE DS    XL1                LOCAL COPY OF AUTHBYTE\n         IKJPSCB\n         END   OSCMDATH\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSCMDATH(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    OSCMDATH'\n PUNCH ' NAME     OSCMDATH(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OSCMDICB": {"ttr": 33032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         OSCMDICB\nOSCMDICB DSECT\n***********************************************************************\n* THIS IS THE OSCMD INTERFACE CONTROL BLOCK. IT'S PURPOSE IS TO       *\n* PROVIDE A SHARED STORAGE AREA FOR COMMUNICATION BETWEEN THE OSCMD   *\n* AND THE TSSOSS09 SUBSYSTEM INTERFACE ROUTINE.                       *\n***********************************************************************\nOSCMDFIR DS    A                   ADDRESS OF FIRST BUFFER.\n*\nOSCMDECB DS    F                   THE ALL IMPORTANT ECB TO WAIT ON\n*\nOSCMDACB DS    A                   ASCB OF THE ADDRESS SPACE OF THE\n*                                  ABOVE ECB\n*\nOSCMDFLG DS    F\n*\nOSCMDMAX DS    F                   MAXIMUM NUMBER OF MESSAGES TO\n*                                  INTERCEPT\n*\nOSCMDCNT DS    F                   COUNT OF INTERCEPTED MESSAGES IN\n*                                  BUFFER.\n*\nOSCMDNEX DS    A                   ADDRESS OF NEXT BUFFER AREA.\n*\nOSCMDBUF DS    200CL150            ENOUGH SPACE FOR TWO HUNDRED TRAPPED\n*                                  MESSAGES\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OSPAUSE": {"ttr": 33034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00u\\x00u\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE ' T S S O  OSPAUSE COMMAND'\nOSPAUSE  CSECT\n***********************************************************************\n* THIS IS THE OSPAUSE COMMAND PROCESSOR. IT'S PURPOSE IS TO PROVIDE   *\n* A MECHANISM FOR CLISTS TO SLEEP FOR \"N\" SECONDS, WHERE \"N\" IS       *\n* PASSED ON THE COMMAND LINE. FOR EXAMPLE:                            *\n*                                                                     *\n* OSPAUSE 10                                                          *\n*                                                                     *\n* WILL PUT THE CLIST INTO A WAIT FOR 10 SECONDS. THIS IS USEFUL WHEN  *\n* GIVING TASKS TIME TO INITIALIZE, OR ANY OTHER TIME IT IS DESIRABLE  *\n* TO WAIT FOR SOME TASK.                                              *\n*                                                                     *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSPAUSE\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSPAUSE,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSPADATD,R11\n         MVC   LINE1HD(80),LINE1HC   COPY LINE\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n         L     R2,CPPLCBUF         GET THE COMMAND BUFFER.\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS AT THE NUMBER\n         LA    R3,0(R2,R4)         R3 NOW POINTS AT THE END OF THE NUM\n         SR    R3,R5               R3 NOW HAS LENGTH OF THE NUMBER\n         LTR   R3,R3\n         CH    R3,=H'1'\n         BL    ERROR1\n         CH    R3,=H'3'\n         BH    ERROR1\n*\n         LA    R10,OSPAAREA        POINT TO WORKAREA.\n         LR    R0,R3               PUT LENGTH IN R0\n         LR    R1,R5               PUT ADDRESS IN R1\n         CALL  JCECVTDB            CONVERT IT !\n         BNZ   ERROR1              CHECK FOR NUMERIC\n         M     R0,=F'100'          TIMES NUMBER BY 100\n         ST    R1,OSPINTVL         PUT VALUE AWAY.\n         STIMER WAIT,BINTVL=OSPINTVL   ** DO IT **\n         B     ENDPROG\n*\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nENDCMD   DS    0H\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nLINE1HC  DC    H'80',H'0'\n         DC    CL76'OSPAUSE TERMINATING -> INVALID PAUSE TIME'\n*\n*\n*\nOSPADATD DSECT\nOSPAAREA DS    CL200\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F\nECBADS   DS    F\nPUTBLOK  PUTLINE MF=L\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'OSPAUSE TERMINATING -> INVALID PAUSE TIME'\n*\nOSPINTVL DS    F\n         IKJIOPL\n         END   OSPAUSE\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY OSPAUSE(''TSSO V 4.2.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    OSPAUSE'\n PUNCH ' NAME     OSPAUSE(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSWAIT": {"ttr": 33037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x01\\x022\\x1f\\x01\\x022\\x1f\\x16B\\x03\\x97\\x03\\x95\\x00\\x02\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T16:42:33", "lines": 919, "newlines": 917, "modlines": 2, "user": "EDJXADM"}, "text": "         TITLE 'OSWAIT TSO COMMAND PROCESSOR'\nOSWAIT   CSECT\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSCMD\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSWAIT,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n*\n         LA    R7,4095(R12)       MORE ADDRESSABILITY\n         LA    R7,1(R7)\n         USING OSWAIT+4096,R7     WELL... R7 WAS THE ONLY ONE LEFT.\n*\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSWTDATD,R11\n***********************************************************************\n* THIS IS THE OSWAIT COMMAND PROCESSOR.                               *\n***********************************************************************\n* COMMAND SYNTAX:                                                     *\n*                                                                     *\n* OSWAIT ENTRYID() TIMEOUT()                                          *\n*                                                                     *\n* WHERE ENTRYID IS THE AN ENTRYID IN THE CURRENT AOF TABLE AND        *\n*       TIMEOUT IS THE AMOUNT OF SECONDS YOU ARE WILLING TO WAIT      *\n*       FOR THE MESSAGE TO APPEAR.                                    *\n*                                                                     *\n*                                                                     *\n* THIS COMMAND IS DESIGNED TO BE USED UNDER THE TSSO SUBSYSTEM. IT IS *\n* INTENDED TO PROVIDE A TSSO AUTOMATION CLIST WITH THE CAPABILITY OF  *\n* WAITING UNTIL A GIVEN MESSAGE APPEARS, BEFORE CONTINUING. WHEN      *\n* THE MESSAGE APPEARS ON THE MVS CONSOLE, THIS COMMAND PROCESSOR      *\n* WILL BE POSTED. IF THE MESSAGE DOES NOT APPEAR BEFORE THE           *\n* TIMEOUT VALUE IS REACHED, THE COMMAND WILL RETURN THE APPROPRIATE   *\n* RETURN CODE (8).                                                    *\n*                                                                     *\n* IF THE MESSAGE DOES APPEAR, THE TEXT OF THE MESSAGE THAT CAUSED THE *\n* CLIST TO BE INVOKED WILL BE AVAILABLE TO THE CLIST IN CLIST         *\n* VARIABLES. THE FOLLOWING VARIABLES ARE CREATED.                     *\n*                                                                     *\n* W0 - NUMBER OF WORDS IN THE WTO                                     *\n* W1-WN  WORD 1 THROUGH WORD N                                        *\n* NOTE THAT THE FIRST WORD IN THE MESSAGE IN THE TIMESTAMP IN THE WTO.*\n***********************************************************************\n*\n* VERSION IDENTIFIER:  TSSO VERSION 4.3\n* AUTHOR. MARC SCHARE\n***********************************************************************\n*\n* MODIFIED\n*   20OCT92  GLA  USE NEW DSECT FOR AOF TABLE ENTRIES\n*\n*   NOV 2002 EEJ  Remove extraneous PUSH USING added by RPS     EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C\n         MVC   ERROR1HD(82),ERROR1HC\n         MVC   ERROR2HD(82),ERROR2HC\n         MVC   ERROR3HD(82),ERROR3HC\n         MVC   ERROR4HD(82),ERROR4HC\n         MVC   ERROR6HD(82),ERROR6HC\n         MVC   ERROR7HD(82),ERROR7HC\n         MVC   ERROR8HD(82),ERROR8HC\n         MVC   ERROR9HD(82),ERROR9HC\n         MVC   ERRORAHD(82),ERRORAHC\n         MVC   ERRORBHD(82),ERRORBHC\n         MVC   ERRORCHD(82),ERRORCHC\n         MVC   MESSAGED(152),MESSAGEC\n         MVC   OPESTAED(ESTAECE-ESTAEC),ESTAEC\n         L     R2,16               GET CVT\n         USING CVT,R2\n         L     R2,CVTTVT           GET TIME SHARING VECTOR TABLE\n         USING TSVT,R2\n         LTR   R2,R2               IS THIS A TSO/E R2 SYSTEM ?\n         BZ    ERRORA              FAKE NO CLIST...\n         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO\n         ST    R15,VACCRTN         STORE THIS SUCKER AWAY\n*\n*\n         LA    R2,OSWTDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         LA    R2,STIMEREX         GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n         TESTAUTH FCTN=1\n         LTR   R15,R15\n         BNZ   ERROR4\n*\n         MVC   PPLUPT(4),CPPLUPT       MOVE IN UPT\n         MVC   PPLCBUF(4),CPPLCBUF     MOVE IN CBUF/\n         MVC   PPLECT(4),CPPLECT       MOVE IN ECT\n         L     R1,=V(OSWPARSE)         GET ADDRESS OF PARM CONTROL\n         ST    R1,PPLPCL               MOVE IT IN\n         LA    R1,MYECB                GET ADDRESS OF AN ECB\n         ST    R1,PPLECB               MOVE IT IN\n         XC    PPLUWA(4),PPLUWA        ZERO OUT THE WORK AREA\n         LA    R1,MYANS                GET ADDRESS OF AN ANSWER\n*                                      PLACE\n         ST    R1,PPLANS\n         LA    R1,PPL                  FINALLY, LOAD R1 WITH A(PPL)\n***********************************************************************\n* THE FIRST STEP IS TO PARSE THE INPUT, AND DETERMINE WHAT THE USER IS\n* AFTER.\n***********************************************************************\n         LINK  EP=IKJPARS\n         L     R9,MYANS\n         USING IKJPARMD,R9\n*\n         LH    R3,ENTRY\n         LTR   R3,R3                 WAS ONE SPECIFIED ?\n         BZ    ERROR8                NO, KICK HIM OUT.\n         LH    R3,ENTSUBID+4         PICK UP THE LENGTH\n         L     R4,ENTSUBID\n         BCTR  R3,0\n         MVI   ENTSPEC,C' '\n         MVC   ENTSPEC+1(7),ENTSPEC\n         EX    R3,MOVEMSG\n         B     ARD1\nMOVEMSG  MVC   ENTSPEC(0),0(R4)      ** EXECUTED **\nARD1     DS    0H\n*\n*\nCHEKTMEO DS    0H\n         LH    R2,TIMEOUT\n         LTR   R2,R2\n         BZ    DEFTIMEO              DID NOT SPECIFY TIME.\n         L     R2,TMESUBID           OBTAIN THE TIMEOUT VALUE\n         L     R3,0(R2)              PICK UP THE ACTUAL VALUE\n         C     R3,=F'1'\n         BL    ERROR7\n         C     R3,=F'10000'          MANY HOURS\n         BH    ERROR7\n         M     R2,=F'100'            GET .01 SECONDS\n         ST    R3,TIMEOVAL           GOT IT !\n         B     TIMEOK\nDEFTIMEO DS    0H\n         MVC   TIMEOVAL,=F'1000'     DEFAULT 10 SECONDS\n*\nTIMEOK   DS    0H\n         DROP  R9\n*\n***********************************************************************\n* WE NOW HAVE THE VALUES FOR ENTRYID AND TIMEOUT. WE NEXT OBTAIN THE  *\n* ACTIVE TSSO AOF TABLE, AND SCAN FOR THE APPROPRIATE ENTRYID.        *\n* AS IS CUSTOMARY, WE WILL CHECK IF TSSO IS ACTIVE.                   *\n***********************************************************************\n         GETCVT (R10)\n         LTR   R15,R15\n         BNZ   ERROR1\n         USING TSSOCVT,R10\n         LTR   R10,R10           IS TSSO EVEN THERE ?\n         BZ    ERROR1            NO, BLOW HIM AWAY\n         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?\n         BO    ERROR1            YUP- SORRY GUY.\n         L     R9,TSSOTABL       GET CURRENT TSSO TABLE ADDRESS\n         LTR   R9,R9             IS AOF ACTIVE ?\n         BZ    ERROR2\n***********************************************************************\n* R9 WILL SERVE AS THE BASE WHEN WE GO TRAMPING THROUGH THE AOF TABLE.*\n*                                                                     *\n***********************************************************************\n*\n*\n         CLC   44(8,R9),=CL8'TSSO 4.3'\n         BNE   ERROR3\n*\n         L     R9,0(R9)          POINT TO FIRST RECORD IN TABLE.\n         USING AOFNTRY,R9        SETUP ADDRESSABILITY\nAOFLOOP  DS    0H\n         LTR   R9,R9             IS THIS A VALID RECORD ?\n         BZ    ENDRECS           NO, NO MORE RECORDS\n         CLC   AOFMSGID,=CL8'ZZZZZZZZ' END OF RECORDS INDICATOR ?\n         BE    ENDRECS\n*\n         CLC   AOFENTR,ENTSPEC   IS THIS THE SPECIFIED ENTRY ?\n         BNE   NEXTREC           NO, FORGET IT...\n*\n***********************************************************************\n* HERE, WE HAVE FOUND A MATCHING ENTRY ID IN THE TSSO AOF TABLE. WE   *\n* WILL CHECK IF ACTION=POST WAS SPECIFIED...                          *\n*                                                                     *\n***********************************************************************\n         CLC   AOFACTN,=CL8'POST'    WAS ACTION=POST SPECIFIED?\n         BNE   NEXTREC               NO, FORGET IT.\n***********************************************************************\n* HERE, ACTION=POST WAS SPECIFIED...                                  *\n***********************************************************************\n         TM    AOFPFLG,AOFP1WT      IS THIS RECORD ALREADY ACTIVE ?\n         BO    ERROR3\n         B     FOUNDREC\n*\nNEXTREC  DS    0H\n         L     R9,AOFNXT\n         B     AOFLOOP\n*\nENDRECS  DS    0H\n         MVC   ERROR6HD+13(8),ENTSPEC\n         B     ERROR6\n*\n***********************************************************************\n* WE NOW NEED TO MOVE IN VARIOUS FIELDS INTO THE AOF TABLE... WE WILL *\n* ACCOMPLISH THIS NOW.                                                *\n***********************************************************************\nFOUNDREC DS    0H\n         MODESET KEY=ZERO\n         LA    R2,OSWTECB\n         ST    R2,AOFPECB          DEPOSIT ECB INTO TABLE\n         L     R2,X'224'\n         ST    R2,AOFPASCB         DEPOSIT ASCB INTO TABLE.\n         MVI   AOFWQE,C' '\n         MVC   AOFWQE+1(146),AOFWQE BLANK OUT WTO ENTRY.\n         MODESET KEY=NZERO\n***********************************************************************\n* NEXT, WE PREPARE TO AWAIT THE MESSAGE. WE WILL WAIT FOR ONE OF TWO  *\n* EVENTS. EITHER THE MESSAGE WILL APPEAR, AND POST OUR ADDRESS SPACE  *\n* OR THE TIMER WILL POP, BECAUSE THE MESSAGE DID NOT APPEAR.          *\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=TIMEOVAL\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. THIS MEANS THAT*\n* THE EXPECTED MESSAGE NEVER DID MATERIALIZE, AND     THEREFORE, WE   *\n* WILL DUMMY UP THE RESPONSE, SET A CONDITION CODE AND GIVE UP.       *\n* ON THE OTHER HAND, IF THE MESSAGE DID MATERIALIZE, WE WILL CANCEL   *\n* STIMER, AND PARSE THE RESULTS...                                    *\n***********************************************************************\n         XC    OSWTECB(4),OSWTECB\n         XC    STIMRECB(4),STIMRECB\n         LA    R2,OSWTECB             GET ADDRESS OF OSWTECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n***********************************************************************\n* BECAUSE AN ADDRESS SPACE MAY BE CANCELLED WHILE WAITING FOR TSSO    *\n* SERVICES, WE MUST PROVIDE AN ESTAE ROUTINE TO RECOVER...            *\n***********************************************************************\n         L     R6,=V(OSWAITRC)\n         LTR   R6,R6              SAVE ENTRY POINT\n         BZ    BADESTAE\n*\n         ESTAE (R6),TERM=YES,PARAM=(R9),MF=(E,OPESTAED)\n*\n         LTR   R15,R15\n         BNZ   BADESTAE\n         B     OKESTAE\nBADESTAE DS    0H\n         MVC   MESSAGED(2),=H'50'\n         MVC   MESSAGED+4(50),=CL50'OSWAIT ESTAE NOT IN EFFECT'\n         PUTLINE PARM=PUTBLOK,OUTPUT=(MESSAGED,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nOKESTAE  DS    0H\n*\n***********************************************************************\n* FINALLY, LETS SET THE BIT INDICATING THIS MESSAGE IS ACTIVE.        *\n*                                                                     *\n***********************************************************************\n         MODESET KEY=ZERO\n         OI    AOFPFLG,AOFP1WT        THE BIT IS SET.\n         MODESET KEY=NZERO\n*\n         WAIT  ECBLIST=LISTECBS\n*\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM THE WTOR BEING POSTED, OR FROM THE *\n* STIMER POPPING...        IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE TSSOSS09 XMEM POST, WE SHOULD CANCEL THE  *\n* STIMER.                                                             *\n***********************************************************************\n         TM    OSWTECB,X'40'          POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n*\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(149),BUFFER\n         MVC   BUFFER(147),AOFWQE   COPY THE WTO CAUSING THE EVENT.\n         MODESET KEY=ZERO\n         NI    AOFPFLG,255-AOFP1WT    THE BIT IS UNSET.\n         MODESET KEY=NZERO\n         ESTAE 0\n         CLC   OSWTECB+1(3),=XL3'000FFF'\n         BE    ERRORC\n*\n         B     PUTRESP\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* HERE, THE STIMER EXIT HAS POPPED, AND POSTED THE STIMERECB, MEANING *\n* THAT THE MESSAGE HAS NOT APPEARED. WE WILL SET A BAD RETURN CODE,   *\n* AND TERMINATE.                                                      *\n***********************************************************************\n         MODESET KEY=ZERO\n         NI    AOFPFLG,255-AOFP1WT    THE BIT IS UNSET.\n         MODESET KEY=NZERO\n         ESTAE 0\n         DROP  R9\n*\n         MVC   RETCODE(2),=H'8'       SET BAD RETURN CODE\n         B     ENDPROG\nPUTRESP  DS    0H\n***********************************************************************\n* HERE, WE HAVE THE MESSAGE THAT CAUSED THE POST TO OCCUR. WE WILL    *\n* PARSE THE MESSAGE AND CREATE CLIST VARIABLES.                       *\n***********************************************************************\n*\nPUTCLSTV DS    0H\n*\n         LA    R4,TSVEUPDT         WE WISH TO UPDATE CLIST VARS..\n         ST    R4,ECODE\n*\n         LA    R4,CLVARNME         GET VARNAME PTR\n         ST    R4,NAMEPTR          TELL IKJCT441\n         MVC   CLVARNME(3),=CL3'WTO'\n*\n         LA    R4,3\n         ST    R4,NAMELEN\n*\nGOTNAME  DS    0H\n         LA    R2,BUFFER          POINT TO WTO...\n         ST    R2,VALUEPTR\n*\n         LA    R3,BUFFER\n         LA    R4,BUFFER+132      START AT LAST CHARACTER\nLLOOP    DS    0H\n         CLI   0(R4),C' '\n         BNE   NBLNKFND           FOUND A NONE BLANK\n         BCTR  R4,0\n         CR    R4,R3              ARE WE DONE\n         BL    NULLVAR            YUP, PITTY...\n         B     LLOOP\n*\nNULLVAR  DS    0H\n         XR    R4,R4\n         ST    R4,VALUELEN\n*\nNBLNKFND DS    0H\n         SR    R4,R3              GOT THE LENGTH IN R4\n         LA    R4,1(R4)\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERRORB\n*\n***********************************************************************\n* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*\n* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *\n* AND PUT THE WORDS INTO CLIST VARIABLES.                             *\n* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *\n***********************************************************************\n         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE\n*\n         MVC   OSPARS2(4),=F'150' SECOND PARM -> LENGTH OF STRING\n*\n         MVI   OSPARARR,X'40'\n         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY\n         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB\n         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...\n         LA    R4,OSPARARR                GET ADDRESS\n         ST    R4,OSPARS3                 AND PASS TO TSSOPARS\n*\n         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE\n         ST    R4,OSPARS4             SEPARATOR CHARACTERS.\n         MVC   WORDSEPS(4),=CL4' ,= '\n*\n         LA    R1,OSPARSPM\n         CALL  TSSOPARS              ** PARSE IT **\n         LH    R8,OSPARARR\n         ST    R8,WORDLINE\n***********************************************************************\n* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *\n* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *\n***********************************************************************\n         LA    R4,CLVARNME           GET VARIABLE NAME\n         ST    R4,NAMEPTR\n         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...\n         MVI   0(R4),C'W'            MOVE IN A \"W\"\n*\n*\n         L     R4,NAMELEN\n         LA    R4,1(R4)\n         ST    R4,NAMELEN\n*\n         LA    R4,EBCCOUNT\n         ST    R4,VALUEPTR\n         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         STCM  R1,B'1111',EBCCOUNT\n*\n         LA    R4,4\n         ST    R4,VALUELEN\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELEN,            PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n         LTR   R15,R15\n         BNZ   ERROR5\n*\n***********************************************************************\n* THE NEXT STEP IS TO CREATE THE WTOWN     VARIABLES, WHERE \"N\" IS    *\n* THE CURRENT WORD THAT WE ARE WORKING ON...                          *\n* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *\n* CLIST VARIABLES.                                                    *\n***********************************************************************\n*\n*\n         LA    R4,1\n         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD\n         LA    R4,OSPARARR+2\n         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN\n*                                        THE PARSE ARRAY\n*\nWORDLOOP DS    0H\n         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR\n         ST    R4,NAMELENW              AND KEEP A COPY\n         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?\n         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?\n         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON\n*\n         LA    R4,CLVARNME               GET THE VARIABLE NAME\n         ST    R4,NAMEPTR                TELL CLIST ROUTINE\n*\n         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM\n         LR    R1,R4\n         XR    R0,R0\n         LA    R10,OSWKAREA\n         CALL  JCECVTBD\n         CH    R4,=H'10'\n         BL    WOR1BYTE\nWOR2BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,2(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nWOR1BYTE DS    0H\n         LA    R3,CLVARNME\n         A     R3,NAMELENW               START OF VARIABLE PLUS\n*                                        LENGTH = A(END OF VARIABLE)\n         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER\n         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING\n*                                        THE LEADING \"W\")\n         LA    R3,1(R3)                  INCREMENT BY TWO BYTES\n         ST    R3,NAMELENW               RESTORE LENGTH OF NAME\n         B     GOTNAME2\nGOTNAME2 DS    0H\n***********************************************************************\n* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *\n*                                                                     *\n***********************************************************************\n         L     R4,CURRWPOS\n         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..\n         XR    R6,R6\nWLENLOOP DS    0H\n         CLI   0(R4),C' '    BLANK FOUND ?\n         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6\n         LA    R6,1(R6)\n         LA    R4,1(R4)\n         BCT   R5,WLENLOOP\nWLENELOP DS    0H\n         ST    R6,VALUELEN\n*\n         L     R4,CURRWPOS\n         ST    R4,VALUEPTR\n*\n         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE\n         CALL  (15),                                                   X\n               (ECODE,             ENTRY CODE                          X\n               NAMEPTR,            PTR TO VAR NAME                     X\n               NAMELENW,           PTR TO VAR LENGTH                   X\n               VALUEPTR,           PTR TO VALUE                        X\n               VALUELEN,           PTR TO VALUE LENGTH                 X\n               TOKEN),             TOKEN                               X\n               VL,MF=(E,OSCALL1D)\n*\n         LTR   R15,R15\n         BNZ   ERROR5\n*\n         L     R4,CURRWPOS\n         LA    R4,16(R4)\n         ST    R4,CURRWPOS\n*\n         L     R4,CURRWNUM\n         LA    R4,1(R4)\n         ST    R4,CURRWNUM\n         B     WORDLOOP\n*\nENDWORDS DS    0H\n         XC    RETCODE(2),RETCODE\n         B     ENDPROG\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR1HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR2HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR3   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR3HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR4   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR4HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR5   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR5HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERROR6   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR6HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR7   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR7HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR8   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR8HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR9   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR9HD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERRORA   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERRORAHD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERRORB   DS    0H\n         CH    R15,=H'40'             CLIST ENVIRONMENT NOT ACTIVE ?\n         BE    NOCLIST                YUP...\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERRORBHD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERRORC   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERRORCHD,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n         MVC   RETCODE(2),=H'8'\n         B     ENDPROG\n*\nNOCLIST  DS    0H\n         MVC   MESSAGED+4(150),BUFFER\n         PUTLINE PARM=PUTBLOK,OUTPUT=(MESSAGED,TERM,SINGLE,DATA),      X\n               MF=(E,IOPLADS)\n*\n         B     ENDPROG\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\nSTIMEREX DS    0H\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSASK DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         DROP  R12,R7                                               RPS\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSASK DSECT AREA\n         USING OSWTDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n         DROP  R11\n         DROP  R12\n         POP   USING\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\nSTIMRPRE DS    0D\n         DROP  R12,R7                                              RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nSTIMER_CODEL   EQU  *-STIMRPRE   LENGTH OF CODE                   RPS\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n*\nOSCALL1C CALL  ,(0,0,0,0,0,0),MF=L\nOSCALL1E EQU  *\n*\n*\nERROR1HC DC    H'80',H'0'\n         DC    CL80'TSSO IS NOT INSTALLED, OR NOT ACTIVE - REQUEST ABORX\n               TED'\n*\nERROR2HC DC    H'80',H'0'\n         DC    CL80'THE TSSO AOF FACILITY IS NOT ACTIVE  - REQUEST ABORX\n               TED'\n*\nERROR3HC DC    H'80',H'0'\n         DC    CL80'THE SPECIFIED ENTRY IS ALREADY AWAITING POST FROM AX\n               NOTHER ADDRESS SPACE'\n*\n*\nERROR4HC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT WAS NOT INVOKED AUTHORIZED'\n*\n*\nERROR5HC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - THE CLIST VARIABLE ACCESS ROUTX\n               INE FAILED'\n*\nERROR6HC DC    H'80',H'0'\n         DC    CL80'ENTRY ID XXXXXXXX IS NOT IN THE CURRENT AOF TABLE -X\n               WITH ACTION=\"POST\"'\n*\nERROR7HC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - TIMEOUT VALUE NOT > 1 AND <  1X\n               0000 (OR MISSING)'\n*\nERROR8HC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - THE ENTRY ID TO BE WAITED ON IX\n               S MISSING'\n*\nERROR9HC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT WAS NOT INVOKED FROM A CLISX\n               T'\n*\nERRORAHC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT REQUIRES TSO/E RELEASE 2 ORX\n                HIGHER'\n*\nERRORBHC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - AN ERROR OCCURRED IN THE CLISTX\n               VARIABLE ACCESS ROUTINE'\n*\nERRORCHC DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - TSSO WAS TERMINATED, OR A NEW X\n               AOF TABLE WAS LOADED'\n*\nMESSAGEC DC    H'150',H'0',CL150' '\n*\nESTAEC   ESTAE 0,MF=L\nESTAECE  EQU   *\n*\nOSWPARSE IKJPARM\nENTRY    IKJKEYWD\n         IKJNAME 'ENTRY',SUBFLD=ENTSUB\nTIMEOUT  IKJKEYWD\n         IKJNAME 'TIMEOUT',SUBFLD=TIMEOSUB\nENTSUB   IKJSUBF\nENTSUBID IKJIDENT 'ENT',PROMPT='ENTRY IDENTIFIER',FIRST=ALPHANUM,      X\n               OTHER=ALPHANUM,                                         X\n               HELP=('TSSO AOF TABLE ENTRY ID')\n*\nTIMEOSUB IKJSUBF\nTMESUBID IKJIDENT 'TIMEOUT',PROMPT='TIMEOUT VALUE',INTEG,              X\n               HELP=('TIMEOUT VALUE FOR OSWAIT COMMAND','NUMBER OF SECOX\n               NDS TO WAIT FOR MESSAGE BEFORE TIMING OUT')\n*\n         IKJENDP\nOSWTDATD DSECT\nOSWKAREA DS    CL200            USED BY PARSE ROUTINE\n*\nSTIMERD  DS    0D\n         DS    CL(STIMER_CODEL)   LENGTH OF CODE COPIED HERE       RPS\nR15SAVED DS    A\nR1SAVED  DS    A\nSTIMREAL DS    A\nSTIMPARM DS    F\n*\n*\nENTSPEC  DS    CL8              ENTRY ID SPECIFIED BY USER\nTIMEOVAL DS    F                TIMEOUT VALUE, IN SECONDS.\nLENTID   DS    F                LENGTH OF THE SPECIFIED ENTRY ID\nRETCODE  DS    H\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSWTECB\n         DC    X'80'\n         DC    A(0)\n*\nOSWTECB  DS    F                ECB FOR THE OSWAIT COMMAND\nSTIMRECB DS    F                ECB FOR THE STIMER.\nBUFFER   DS    CL150            THE WTO CAUSING THE POST TO OCCUR.\nFLAGS    DC    H'0'\n* FIRST BYTE:\n* X'80' - A ENTRY ID WAS SPECIFIED\n* X'40' - A TIMEOUT VALUE WAS SPECIFIED.\nBLANKH   DC    H'80',H'0'\nBLANK    DC    CL80' '\nERROR1HD DC    H'80',H'0'\n         DC    CL80'TSSO IS NOT INSTALLED, OR NOT ACTIVE - REQUEST ABORX\n               TED'\n*\n*\nERROR2HD DC    H'80',H'0'\n         DC    CL80'THE TSSO AOF FACILITY IS NOT ACTIVE  - REQUEST ABORX\n               TED'\n*\nERROR3HD DC    H'80',H'0'\n         DC    CL80'THE SPECIFIED ENTRY IS ALREADY AWAITING POST FROM AX\n               NOTHER ADDRESS SPACE'\n*\nERROR4HD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT WAS NOT INVOKED AUTHORIZED'\n*\nERROR5HD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - THE CLIST VARIABLE ACCESS ROUTX\n               INE FAILED'\n*\nERROR6HD DC    H'80',H'0'\n         DC    CL80'ENTRY ID XXXXXXXX IS NOT IN THE CURRENT AOF TABLE -X\n               WITH ACTION=\"POST\"'\n*\nERROR7HD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - TIMEOUT VALUE NOT > 1 AND <  1X\n               0000 (OR MISSING)'\n*\nERROR8HD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - THE ENTRY ID TO BE WAITED ON IX\n               S MISSING'\n*\nERROR9HD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT WAS NOT INVOKED FROM A CLISX\n               T'\n*\nERRORAHD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - IT REQUIRES TSO/E RELEASE 2 ORX\n                HIGHER'\n*\nERRORBHD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - AN ERROR OCCURRED IN THE CLISTX\n               VARIABLE ACCESS ROUTINE'\n*\nERRORCHD DC    H'80',H'0'\n         DC    CL80'OSWAIT TERMINATING - TSSO WAS TERMINATED, OR A NEW X\n               AOF TABLE WAS LOADED'\n*\nMESSAGED DC    H'150',H'0',CL150' '\n*\nOSCALL1D CALL  ,(0,0,0,0,0,0),MF=L\nOPESTAED ESTAE 0,MF=L\n***********************************************************************\n* THE VARIABLES ARE NEEDED FOR THE CLIST VARIABLE ACCESS ROUTINE      *\n* IKJCT441.                                                           *\n***********************************************************************\nVACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.\nVALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.\nVALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nTOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.\nECODE    DS    F\n*\nNAMEPTR  DS    F                FOR UPDATE ROUTINE\nNAMELEN  DS    F                FOR UPDATE ROUTINE\nVALUEPTR DS    F                FOR UPDATE ROUTINE\nVALUELEN DS    F                FOR UPDATE ROUTINE\nNAMELENW DS    F                FOR UPDATE ROUTINE FROM \"CMDOUTNWM\"\nCLVARNME DS    CL12\nEBCCOUNT DS    CL4\nCONSOLE  DS    F\n***********************************************************************\n* THESE VARIABLES ARE USED TO KEEP TRACK OF WHICH LINES AND WORDS WE  *\n* ARE USING WHEN STUFFING RESULTS IN CLIST VARIABLES.                 *\n***********************************************************************\nCURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE\nCURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN\n*                               TSSOPARS\nWORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE\nNUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND\n***********************************************************************\n* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *\n* ROUTINE.                                                            *\n***********************************************************************\nOSPARSPM DS    0H\nOSPARS1  DS    F\nOSPARS2  DS    F\nOSPARS3  DS    F\nOSPARS4  DS    F\nWORDSEPS DS    CL4           PROBABLY CL4' ,= '\nOSPARARR DS    20CL16\n*\nMYECB    DC    F'0'\nMYANS    DC    F'0'\nPPL      DS    0D                       START OF PARM CONTROL LIST\nPPLUPT   DS    A\nPPLECT   DS    A\nPPLECB   DS    A\nPPLPCL   DS    A\nPPLANS   DS    A\nPPLCBUF  DS    A\nPPLUWA   DS    A\n*\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L           DEFAULT PUTLINE MACRO, LIST FORM\n********************************************************************\n* THIS IS THE DESCRIPTION OF THE COMMAND SYNTAX, AS PARSE WANTS IT *\n********************************************************************\n         IKJIOPL\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         IKJTSVT\n         CVT   DSECT=YES\n         TSSOCVT\n         TAOFNTRY\n         END   OSWAIT\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSWAIT(''TSSO V 4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' INCLUDE  SYSLMOD(OSWAITRC)'\n PUNCH ' ENTRY    OSWAIT'\n PUNCH ' NAME     OSWAIT(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSWAITRC": {"ttr": 33541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00-\\x00-\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "TSSO403"}, "text": "OSWAITRC CSECT\n         EQUATES\n**********************************************************************\n* THIS MODULE IS THE ESTAE ROUTINE FOR THE OSWAIT COMMAND. ITS PURPOSE\n* FREE THE RESOURCES OBTAINED BY OSWAIT IN TERMS OF THE AOF ACTION\n* = POST FLAGS.\n* NOTE THAT THE PARAMETER PASSED INTO THE ESTAE ROUTINE IS THE AOF\n* TABLE ADDRESS OF THE EFFECTED ENTRY.\n**********************************************************************\n*\n         LR    R12,R15\n         USING OSWAITRC,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R7,R14           SAVE RETURN POINT\n         CH    R0,=H'12'\n         BE    NOSDWA\n         LR    R9,R1            SAVE ADDRESS OF THE SDWA.\n         USING SDWA,R9\n         L     R3,SDWAPARM      OBTAIN PARAMETER. THIS IS THE\n*                               SSCON ENTRY FOR THE FAILED TASK\n         WTO   'TSSE998S OSWAITRC ESTAE IS IN CONTROL',ROUTCDE=(11)\n*\n         LTR   R3,R3\n         BZ    FORGETIT\n         MODESET KEY=ZERO\n         NI    42(R3),255-X'80'     FLIP OFF BIT INDICATING WAIT\n         MODESET KEY=NZERO\nFORGETIT DS    0H\n         SETRP WKAREA=(R9),DUMP=YES,RC=0\n         BR    R7\n*\nNOSDWA   DS    0H\n         XR    R15,R15\n         BR    R7\n*\n         IHASDWA\n         CVT  DSECT=YES\n         END  OSWAITRC\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSWAITRC(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    OSWAITRC'\n PUNCH ' NAME     OSWAITRC(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OSWTO": {"ttr": 33543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00'\\x01\\x021\\x9f\\x01\\x022\\x0f!\\x07\\x00\\xe0\\x00\\xdc\\x00\\x0e\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-16T21:07:27", "lines": 224, "newlines": 220, "modlines": 14, "user": "EDJXADM"}, "text": "         TITLE ' T S S O   WRITE TO OPERATOR C O M M A N D '\nOSWTO    CSECT\n***********************************************************************\n* THIS IS THE OSWTO COMMAND PROCESSOR. IT'S PURPOSE IS TO SUPPLY      *\n* A REAL TIME MECHANISM FOR A TSSO CLIST TO SEND A MESSAGE TO THE     *\n* MVS OPERATOR.                                                       *\n*                                                                     *\n* COMMAND SYNTAX:                                                     *\n*                                                                     *\n* OSWTO ANY-TEXT                                                      *\n* OSWTOH ANY-TEXT                                                     *\n*                                                                     *\n*                                                                     *\n* IF OSWTOH IS THE COMMAND USED, THE MESSAGE IS HILIGHTED TO THE      *\n* MVS OPERATOR. OTHERWISE, THE MESSAGE IS SIMPLY ISSUED. THE CONSOLE  *\n* UTILIZED WILL BE THE IN THE CURRCONS VARIABLE IN THE TSSO DATA      *\n* AREA, THEREFORE, THIS COMMAND IS ONLY USABLE UNDER TSSO. NOTE THAT  *\n* THE TSO SEND COMMAND MAY BE USED UNDER REGULAR TSO TO SEND A        *\n* MESSAGE TO THE MVS OPERATOR.                                        *\n*                                                                     *\n*                                                                     *\n****************************************************************EEJ1102\n*                                                               EEJ1102\n* Change Activity:                                              EEJ1102\n*                                                               EEJ1102\n*     NOV 2002 EEJ  Support MCS extended consoles               EEJ1102\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF OSCMD\n         LR    R8,R1              SAVE INPUT PARMS.\n         USING OSWTO,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n*                                 THEN I EXPECTED.\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSWRDATD,R11\n***********************************************************************\n* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *\n* AND PUTLINE.                                                        *\n***********************************************************************\n         LA    R2,IOPLADS\n         USING IOPL,R2\n         L     R3,0(8)\n         ST    R3,CPPLCBUF\n         L     R3,4(8)\n         ST    R3,CPPLUPT\n         ST    R3,IOPLUPT\n         L     R3,8(8)\n         ST    R3,CPPLPSCB\n         L     R3,12(8)\n         ST    R3,CPPLECT\n         ST    R3,IOPLECT\n         L     R3,ECBADS\n         ST    R3,IOPLECB\n*\n***********************************************************************\n* SINCE OSWTO IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *\n* THE VARIABLE WORK AREA.                                             *\n***********************************************************************\n*\n         MVC   LINE1HD(80),LINE1HC\n         MVC   LINE2HD(80),LINE2HC\n         MVC   MESSAGED(MESSAGEE-MESSAGEC),MESSAGEC\n***********************************************************************\n* STEP ONE IS TO GET THE MESSAGE AND MOVE IT INTO A BUFFER.           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R2,CPPLCBUF         GET THE COMMAND BUFFER.\n         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND\n         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER\n         LA    R5,4(R3,R2)         R5 NOW POINTS AT THE MESSAGE\n         LA    R3,0(R2,R4)         R3 NOW POINTS AT THE END OF THE MSG\n         SR    R3,R5               R3 NOW HAS LENGTH OF THE MESSAGE\n         LTR   R3,R3\n         CH    R3,=H'1'\n         BL    ERROR1\n         CH    R3,=H'125'\n         BH    ERROR1\n         MVI   MESSAGED+4,X'40'\n         MVC   MESSAGED+5(124),MESSAGED+4\n         BCTR  R3,0\n         EX    R3,MOVEMSG\n         B     AR1\nMOVEMSG  MVC   MESSAGED+4(0),0(R5)\nAR1      DS    0H\n***********************************************************************\n* THE MESSAGE HAS BEEN SAFELY MOVED TO MESSAGED. NOW, WE MUST PICK UP *\n* THE CONSOLE ID TO WRITE THE MESSAGE OUT TO. THIS IS IN THE TSSODATD *\n* DATA AREA                                                           *\n*                                                                     *\n***********************************************************************\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         L     R9,TSSODSEC\n         USING DATD,R9\n         L     R2,TSSOASCB             GET TSSO ASCB\n         C     R2,X'224'               SAMES AS OURS ?\n         BNE   UNDERTSO\n         L     R2,CURRCONS\n         ST    R2,CONSOLE          Save console ID              EEJ1102\n         B     PROCCMD\nUNDERTSO DS    0H\n         XC    CONSOLE,CONSOLE     Zero console ID              EEJ1102\n         DROP  R9,R10\n*\n***********************************************************************\n* FINALLY, WE NEED TO DETERMINE IF THE MESSAGE IS TO BE HILIGHTED...  *\n* IF YES, WE NEED TO TURN ON DESCRIPTOR CODE 1 IN THE MESSAGE.        *\n***********************************************************************\nPROCCMD  DS    0H\n         L     R2,CPPLCBUF\n         CLC   4(6,R2),=CL6'OSWTOH'   SPECIAL OSWTOH ?\n         BE    HILIGHT\n         CLC   4(5,R2),=CL5'OSWTO'\n         BE    NOHIGH\n         WTO   'OSWTO01S LOGIC ERROR -> CONTACT TSSO SUPPORT'\n         B     ENDCMD\nHILIGHT  DS    0H\n         OI    MESSAGED+149,X'80'  Set descriptor code 1        EEJ1102\n         B     ISSUEMSG\nNOHIGH   DS    0H\n         B     ISSUEMSG\nISSUEMSG DS    0H\n         WTO   CONSID=CONSOLE,MF=(E,MESSAGED)                   EEJ1102\n         B     ENDCMD\nENDCMD   DS    0H\nENDPROG  DS    0H\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR    R8,R8\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* E R R O R   C O N D I T I O N S ...                                 *\n*                                                                     *\n***********************************************************************\nERROR1   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\nERROR2   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         B     ENDPROG\n*\n***********************************************************************\n*                                                                     *\n* CONSTANTS TO BE USED FOR THE OSWTO MODULE                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nLINE1HC  DC    H'80',H'0'\nLINE1    DC    CL76'OSWTO TERMINATING -> INVALID MESSAGE LENGTH < 1 OR X\n               > 125'\n*\nLINE2HC  DC    H'80',H'0'\nLINE2H   DC    CL76'OSWTO TERMINATING -> IT WAS NOT ISSUED FROM THE TSSX\n               O ADDRESS SPACE'\n*\nMESSAGEC WTO   '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMESSAGEE EQU   *\n************************************************************\n*                                                          *\n*        VARIABLE WORK AREAS, COVERED BY BASE REG R11.     *\n*                                                          *\n************************************************************\nOSWRDATD DSECT\nOSWKAREA DS    CL200\nCPPLCBUF DS    A\nCPPLUPT  DS    A\nCPPLPSCB DS    A\nCPPLECT  DS    A\nIOPLADS  DS    4F               SPACE FOR IO PARM LIST\nECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE\nPUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM\nCONSOLE  DS    F                   Console ID                   EEJ1102\nMESSAGED WTO   '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nLINE1HD  DC    H'80',H'0'\n         DC    CL76'OSWTO TERMINATING -> INVALID MESSAGE LENGTH < 1 OR X\n               > 125'\n*\nLINE2HD  DC    H'80',H'0'\n         DC    CL76'OSWTO TERMINATING -> IT WAS NOT ISSUED FROM THE TSSX\n               O ADDRESS SPACE'\n         IKJIOPL\n         IKJPSCB\n         IEFJSCVT\n         IEFJESCT\n         TSSOCVT\n         COPY  TSSODATD\n         CVT   DSECT=YES\n         END   OSWTO\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY OSWTO(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ALIAS    OSWTOH'\n PUNCH ' ENTRY    OSWTO'\n PUNCH ' NAME     OSWTO(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSLOAD": {"ttr": 33548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PSIASM": {"ttr": 33551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x022\\x1f\\x01\\x022\\x1f\\x165\\x00w\\x00w\\x00\\x00\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T16:35:40", "lines": 119, "newlines": 119, "modlines": 0, "user": "EDJXADM"}, "text": "//TSSOASM   JOB  1,'TSSO................',CLASS=A,\n//          MSGCLASS=T,NOTIFY=&SYSUID,REGION=0M\n//*\n//*      PDSDOC *ASSEMBLE TSSO (ALL MODULES)..........................*\n//*\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=TSSO.VERS43.ASM\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=TSSO.VERS43.ASM(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=TSSO.VERS43.LOAD,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//TSSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//LIONRPLY EXEC ASMTSSO,MEMBER=LIONRPLY,RENT=NORENT\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PTFS42": {"ttr": 33795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x007\\x007\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "TSSO403"}, "text": "PTF NUMBER    PTF TYPE             DESCRIPTION\n----------    --------             -----------\n\nPTF1          ENHANCEMENT          PROVIDE SUPPORT FOR OSCMD RETURNING\n                                   THE JOB NUMBER AND TIME OF COMMAND.\n                                   THIS PTF HITS TWO MODULES - TSSOSS09\n                                   AND OSCMD, BASICALLY CHANGING 130 TO\n                                   150 WHEREVER IT APPEARS...\n\nPTF2          FIX                  PROBLEM WITH THE OSASK COMMAND WHERE\n                                   ONE BYTE RESPONSES WERE NOT BEING\n                                   RETURNED\n\nPTF3          FIX                  TO TSSOSS09 WHERE LOWLIGHT WAS NON\n                                   OPERATIONAL...\n\n\nPTF4          ENHANCEMENT          CHANGE ECHO DEFAULT TO \"YES\" IN AOF\n\n\nPTF5          FIX                  IN TSSOTERM, CHANGE BALR TO BCTR WHEN\n                                   DECREMENTING UCMBRDST.\n\nPTF6          FIX                  TO THE TABENTRY MACRO TO ALLOW\n                                   EITHER \"P\" FOR POSITIONAL OR \"S\"\n                                   FOR SUBSTRING.\n\nPTF7          FIX                  ALLOW ANY CHARACTER TO BE SPECIFIED\n                                   IN THE SECOND-EIGHT POSITIONS OF THE\n                                   REPLY COMMAND\n\nPTF8          ENHANCEMENT (REPLY)  ALLOW GREATER THEN 3 CHARACTERS IN\n                                   THE NAME OF THE IMS COPY\n\nPTF9          FIX(ALL)             REMOVE STORES INTO LOW STORAGE\n                                   ADDRESS \"A00\"\n\nPTF10        FIX (TSSOINI2)        ABEND0C4 ON THE WAY DOWN WHEN RUNNING\n                                   WITH A BLOCKED PARMLIB.\n\n\n\nPTF11        DOCUMENTATION         ON PAGE 11 OF THE USERS GUIDE,\n                                   CMDOUTNW0 SHOULD BE CMDOUTNW\n                                   (CLIFFORD TOM)\n\nPTF12        FIX                   EF COMMAND - LOAD CLOBBERS R1\n\nPTF13        FIX                   EF COMMAND - IKJPARSE SPELLED WRONG\n\nPTF14        FIX   TSSOINI3        RACINIT DELETE IN TSSOINI3\n\nPTF15        FIX                   FYI - JES AND SECLEVEL MAX.\n\nPTF16        FIX   TSSOSS09        #.LOGON HARDCODED...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PTFS43": {"ttr": 33797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00:\\x00:\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "TSSO403"}, "text": "-----------------------------------------------------------------------\nTHIS FILE IS A LIST OF ALL PTFS THAT ARE APPLIED TO THE 4.3 RELEASE\nOF TSSO. THESE PTFS ARE INCLUDED IN YOUR SOURCE, AND THIS FILE\nIS FOR YOUR INFORMATION ONLY.\n----------------------------------------------------------------------\n\n\nPTF NUMBER: PTF1\n\nMODULES AFFECTED: TSSODOCM\n\nUSERS AFFECTED: THOSE ISSUING LARGE AMOUNTS OF TSO COMMANDS THROUGHOUT\n                THE DAY.\n\nSYMPTOMS:\n   TSSO ABENDING ON AN 80A OR 40D. SINCE THE ESTAE ROUTINE IS NOT\n   INVOKED FOR THESE ABENDS, MVS WILL START TAKING RECURSIVE\n   SUBSYSTEM ERRORS IN MASTER SUBSYSTEM BROADCAST FUNCTION.\n\nCAUSE:\n   THE PROBLEM IS CAUSED BY THE TERMINAL MONITOR PROGRAM NOT FREEING\n   ALL STORAGE THAT IT OBTAINS. IT OBTAINS ABOUT 8K OF STORAGE AT THE\n   JOB STEP LEVEL. IT DEPENDS ON MVS TASK TERMINATION TO FREE THIS\n   STORAGE. SINCE TSSO WAS NOT INVOKING THE TMP AS A JOB STEP, 8K\n   OF STORAGE WOULD DISAPPEAR WITH EACH INVOCATION OF THE TMP.\n\nFIX:\n   TSSODOCM WAS CHANGED TO ATTACH IKJEFT01 AS A JOB STEP RATHER THEN\n   A NORMAL TASK.\n----------------------------------------------------------------------\n----------------------------------------------------------------------\n\n\nPTF NUMBER: PTF2\n\nMODULES AFFECTED: TSSOESTA\n\nUSERS AFFECTED: THOSE CANCELLING TSSO WHILE THE TMP HAS CONTROL.\n\nSYMPTOMS:\n   TSSO ABENDING ON AN S222 WITH THE ESTAE GETTING CONTROL IN A\n   DEAUTHORIZED STATE. MESSAGE TSSE451I IS PRECEDED BY A '+' SIGN\n   INDICATING THIS CONDITION. SINCE THE ESTAE IS NOT ABLE TO CLEAN\n   UP, THE SUBSYSTEM INTERFACE HOOKS DO NOT GET DELETED, BUT THE\n   MODULES THEMSELVES DO. MVS WILL THEN START TAKING RECURSIVE\n   SUBSYSTEM ABENDS IN THE MASTER SUBSYSTEM BROADCAST\n   FUNCTIONS.\n\nCAUSE:\n   THE PROBLEM IS CAUSED BY THE TERMINAL MONITOR PROGRAM DEAUTHORIZING\n   THE ADDRESS SPACE UPON ENTRY. SINCE THE TMP PERCOLATES THE ABEND\n   CAUSED BY THE MVS CANCEL COMMAND, THE AUTHORIZATION IS NEVER RESET.\n   THIS CAUSED THE ESTAE ROUTINE TO GET CONTROL UNAUTHORIZED.\n\nFIX:\n   TSSOESTA IS MODIFIED TO CHECK IF IT WAS INVOKED AUTHORIZED. IF IT\n   IS NOT, TSSOESTA DOES A PC TO TSSO CROSS MEMORY SERVICES ROUTINE TO\n   ALLOW IT TO GAIN APF AUTHORIZATION.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RELGDE41": {"ttr": 33799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01M\\x01M\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 333, "newlines": 333, "modlines": 0, "user": "TSSO403"}, "text": "\n\n\n\n\n\n       SUBJECT: TSSO RELEASE 4.1 PRODUCT      DATE: JANUARY 22, 1985\n                CONTENT\n                - CASE 25820-I0200            FROM: M. A. SCHARE\n                                                    PY 25821\n                                                    2C-209 X2796\n\n\n\n       INTRODUCTION\n\n       THE TIME  SHARING  SUBSYSTEM  OPTION  (TSSO)  IS  A  PACKAGE\n       DESIGNED  TO  INCREASE OPERATIONS PRODUCTIVITY BY AUTOMATING\n       OPERATIONAL TASKS WHICH  ARE  NORMALLY  PERFORMED  MANUALLY.\n       THIS  DOCUMENT DESCRIBES THE CHANGES TO TSSO IN RELEASE 4.1.\n       KNOWLEDGE OF TSSO CONCEPTS IS ASSUMED.1\n\n       ENHANCEMENTS_TO_THE_OPERATOR_PRODUCTIVITY_FACILITY_(OPF)\n\n       THE FOLLOWING IMPROVEMENTS WERE MADE TO THE OPF COMPONENT OF\n       TSSO.\n\n         1.  THE  \"*COM\"  FACILITY  FOR  ISSUING  MVS  COMMANDS  IS\n             IMPROVED  WITH  THE ABILITY TO SPECIFY A DELAY TIME OF\n             BETWEEN 1 AND 999 SECONDS. THE PREVIOUS  LIMIT  WAS  9\n             SECONDS.  THIS  SHOULD  ASSIST  INSTALLATIONS WITH THE\n             TIMING OF TSSO TASKS.\n\n** NOTE: TSSO WILL NOW PAUSE BEFORE EXECUTION OF THE COMMAND, NOT\n** AFTER THE COMMAND AS IN PREVIOUS RELEASES. THIS IS AN\n** INCOMPATABILITY.\n\n         2.  A  \"*HI\"  FACILITY  HAS  BEEN  ADDED   TO   ALLOW   AN\n             INSTALLATION  TO HIGHLIGHT MESSAGES PRODUCED BY A TSSO\n             CLIST OR COMMAND ON THE MVS OPERATOR'S  CONSOLE.  TSSO\n             WILL  HIGHLIGHT  ANY LINE THAT BEGINS WITH THE KEYWORD\n             \"*HI\".\n\n         3.  A  MAXWTO  PARAMETER  HAS  BEEN  ADDED  TO  THE   TSSO\n             INITIALIZATION  DECK  TO  ALLOW  THE  INSTALLATION  TO\n             SPECIFY THE MAXIMUM NUMBER OF WTOS TO  BE  ISSUED  PER\n             TSSO/OPF  COMMAND.  THE PREVIOUS VALUE WAS ARBITRARILY\n             SET  AT  250.  THIS  NEW   PARAMETER   SHOULD   ASSIST\n             INSTALLATIONS  EXPERIENCING  WTO BUFFER SHORTAGES AS A\n             RESULT OF TSSO PROCESSING.\n\n         4.  THE LENGTH OF RECORDS PRODUCED BY TSSO AND  COPIED  TO\n             THE  OPERATOR'S  CONSOLE  IS  INCREASED  TO  125. THIS\n             REPRESENTS THE MVS LIMIT FOR LENGTH OF A WTO  MESSAGE.\n\n\n       __________\n\n       1.  M. A. SCHARE, TIME SHARING SUBSYSTEM OPTION (TSSO)  SYS-\n           TEMS PROGRAMMING REFERENCE GUIDE, 8/29/84\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 2 -\n\n\n\n             THE PREVIOUS VALUE WAS SET AT 80.\n\n         5.  THE \"#.L\" FACILITY WILL NO  LONGER  RE-ISSUE  COMMANDS\n             THAT  WERE IN THE SYSTSPRT OUTPUT STREAM. INSTEAD, THE\n             LINE WILL BE WRITTEN  TO  THE  MVS  CONSOLE  WITH  THE\n             \"*COM\"   REPLACED  WITH  \"*DUP\".  NOTE  THAT  MESSAGES\n             PREFIXED  WITH  THE   \"*HI\"   VERB   WILL   STILL   BE\n             HIGHLIGHTED.  THIS  ENHANCEMENT  ALLOWS AN OPERATOR TO\n             ISSUE THE \"#.L\" COMMAND TO DETERMINE WHAT MVS COMMANDS\n             WERE  ISSUED  AS  A  RESULT  OF  THE LAST TSSO COMMAND\n             EXECUTED.\n\n         6.  THE TSSO RACF SUPPORT IS IMPROVED WITH THE ABILITY FOR\n             TSSO TO EXECUTE TSO COMMANDS WITH THE AUTHORITY OF THE\n             USERID  SPECIFIED   IN   THE   RACFID   INITIALIZATION\n             PARAMETER. PREVIOUSLY, THIS PARAMETER HAD NO EFFECT.\n\n         7.  THE RACFID PARAMETER CAN NO LONGER BE SPECIFIED BY THE\n             CONSOLE  OPERATOR AT TSSO INITIALIZATION TIME. THIS IS\n             TO INCREASE SECURITY OF THE TSSO SUBSYSTEM.\n\n       ENHANCEMENTS_TO_THE_AUTOMATED_OPERATIONS_FACILITY_(TSSO/AOF)\n\n       THE  FOLLOWING  IMPROVEMENTS  WERE  MADE  TO  THE  AUTOMATED\n       OPERATIONS FACILITY (AOF) COMPONENT OF TSSO.\n\n         1.  THE SINGLE BIGGEST CHANGE MADE TO TSSO IN THIS RELEASE\n             IS  THE  ADDITION OF A \"TEST\" KEYWORD IN THE AOF TABLE\n             TABENTRY MACRO. THIS ALLOWS THE INSTALLATION TO DIRECT\n             TSSO  TO TEST CERTAIN WORDS OR COLUMN POSITIONS OF THE\n             MVS MESSAGE BEFORE DECIDING TO EXECUTE  THE  DIRECTIVE\n             SPECIFIED IN THE ACTION= PARAMETER. FOR EXAMPLE,\n\n TABENTRY  MSG=$HASP395,ACTION=HILIGHT,TEST=(('W',3,7,'PAYROLL',' '))\n\n             WILL DIRECT TSSO/AOF TO HIGHLIGHT THE $HASP395 MESSAGE\n             (JOB  XXXXXXXX  ENDED)  ONLY  IF THE THIRD WORD IN THE\n             MESSAGE  (THE  XXXXXXXX)  IS  'PAYROLL'.  THIS  VASTLY\n             IMPROVES  THE  POTENTIAL OF TSSO/AOF TO ELIMINATE MANY\n             OPERATIONAL  PROCEDURES  THAT   ARE   DEPENDENT   UPON\n             WATCHING THE MVS OPERATOR'S CONSOLE FOR MESSAGES.  THE\n             TEST  CAPABILITY  CAN  BE  USED   WITH   ANY   ACTION=\n             DIRECTIVE.  CURRENTLY,  THIS  INCLUDES  OSCMD, OSCMDT,\n             REPLY, HILIGHT, LOWLIGHT AND SUPPRESS.  IF  MORE  THEN\n             ONE  TEST  CONDITION  IS SPECIFIED ON A GIVEN TABENTRY\n             MACRO, ALL CONDITIONS MUST BE  MET  BEFORE  TSSO  WILL\n             PERFORM  THE  INSTRUCTION  SPECIFIED  IN  THE  ACTION=\n             PARAMETER. THIS REPRESENTS A LOGICAL \"AND\"  CONDITION.\n             TO  ACHIEVE  A  LOGICAL \"OR\" CONDITION FOR TWO OR MORE\n             TESTS, AN  INSTALLATION  MAY  CODE  MULTIPLE  TABENTRY\n             MACROS  SPECIFYING  THE  SAME  MSG,  ACTION  AND  TEXT\n\n\n\n\n\n\n\n\n\n\n\n                                  - 3 -\n\n\n\n             PARAMETERS, BUT WITH DIFFERENT TEST CONDITIONS.\n\n         2.  A NEW CAPABILITY WAS ADDED TO THE  MSG=  KEYWORD.  THE\n             MSG=*   SPECIFICATION  CAUSES  TSSO  TO  SELECT  EVERY\n             MESSAGE FOR PROCESSING. BY ITSELF, THIS CAPABILITY  IS\n             NOT  THAT  USEFUL,  BUT  IN CONJUNCTION WITH THE TEST=\n             KEYWORD, THIS CAPABILITY ALLOWS FOR MESSAGE  SELECTION\n             BASED NOT ONLY ON SPECIFIC MESSAGE IDENTIFIERS, BUT ON\n             GENERIC IDENTIFIERS AS WELL. BY SPECIFYING MSG=*  WITH\n             TEST=  OPERANDS THAT TEST CHARACTERS IN THE MESSAGE ID\n             ITSELF (I.E. THE FIRST \"WORD\" OR THE FIRST 8 CHARACTER\n             POSITIONS), GENERIC MESSAGE IDS CAN BE SELECTED.\n\n         3.  AN ACTION=SUPPRESS  KEYWORD  HAS  BEEN  ADDED  TO  THE\n             TSSO/AOF  TABENTRY  MACRO. THIS ACTION= DIRECTIVE WILL\n             CAUSE TSSO/AOF TO SUPPRESS ALL WTO MESSAGES  WITH  THE\n             MESSAGE ID SPECIFIED IN THE MSG PARAMETER OF THE MACRO\n             (PROVIDED  ALL  CONDITIONS  SPECIFIED  IN  THE   TEST=\n             KEYWORD ARE MET).\n\n         4.  AN  ACTION=LOWLIGHT  PARAMETER  HAS  BEEN  ADDED.  THE\n             PARAMETER WILL CAUSE TSSO/AOF TO CHANGE THE DESCRIPTOR\n             CODES  OF   HIGHLIGHTED   MESSAGES   SUCH   THAT   THE\n             HIGHLIGHTING  DOES NOT OCCUR. IT IS POSSIBLE TO CHANGE\n             WTOR MESSAGES IN  THIS  WAY  SO  THEY  ARE  NO  LONGER\n             HIGHLIGHTED,  AND  DO  NOT  STAY  ON  THE SCREEN. THIS\n             PARAMETER CAN BE OF ASSISTANCE  TO  INSTALLATIONS  WHO\n             RUN   MANY   PRODUCTS  THAT  LEAVE  OUTSTANDING  WTORS\n             THROUGHOUT THE DAY. THE TSSO REPLY COMMAND CAN BE USED\n             TO REPLY TO THESE OUTSTANDING WTORS.\n\n         5.  A NEW TSSO COMMAND, DISPAOF ALLOWS THE INSTALLATION TO\n             QUERY  INFORMATION  ABOUT TSSO/AOF TABLES. INFORMATION\n             CAN BE OBTAINED FOR EITHER THE RUNNING TSSO/AOF TABLE,\n             OR  A  NEW TSSO/AOF TABLE RESIDING ON DISK. THE SYNTAX\n             OF THE DISPAOF COMMAND IS:\n\n                DISPAOF  MSG(MSG-ID) TABLE(TABLE-ID) TEST\n\n\n         6.  LASTLY, A NEW TSSO/AOF TABLE STRUCTURE  WAS  PUT  INTO\n             PLACE, WHICH INCLUDES THE TSSO VERSION IDENTIFIER, AND\n             A USER SPECIFIABLE ID THAT APPEARS ON THE OUTPUT  FROM\n             THE \"#.QT\" COMMAND.\n\n       TSO_COMMAND_ENHANCEMENTS_UNDER_TSSO\n\n       SOME CHANGES AND ADDITIONS WERE MADE  TO  THE  TSO  COMMANDS\n       DISTRIBUTED WITH TSSO.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 4 -\n\n\n\n         1.  THE CACHE COMMAND WILL NOW ALLOW THE SPECIFICATION  OF\n             THE  VOLSER,  IN  ADDITION  TO  THE UCB, FOR THE CACHE\n             DEVICE BEING ACCESSED.\n\n         2.  A  NEW  COMMAND,  \"CPCMD\",  ALLOWS  THE  MVS   CONSOLE\n             OPERATOR  RUNNING  UNDER VM/SP, VM/SP HPO, OR VM/XA TO\n             ISSUE CP COMMANDS, AND GET  THE  RESPONSE  BACK.  THIS\n             COMMAND IS USEFUL TO INSTALLATIONS WISHING TO MINIMIZE\n             THE OPERATIONAL IMPACT OF RUNNING  MVS  IN  A  VIRTUAL\n             MACHINE.\n\n         3.  THE SPMON COMMAND IS NOW COMPATIBLE WITH MVS/XA 2.1.2.\n             THIS  RELEASE  CHANGED  THE MVS ASVT/ASCB STRUCTURE TO\n             SUPPORT THE RSVNONR AND  RSVSTRT  PARAMETERS  SO  THAT\n             SOME   PROGRAMS   THAT  SCANNED  THESE  CONTROL  BLOCK\n             STRUCTURES FAILED TO OPERATE. THE SPMON  COMMAND  WILL\n             ALSO DISPLAY THE NUMBER OF INACTIVE INITIATORS.\n\n       MISCELLANEOUS_ENHANCEMENTS\n\n       FINALLY, MISCELLANEOUS CHANGES WERE  MADE  TO  TSSO  IN  THE\n       FOLLOWING AREAS.\n\n         1.  THE TSSOWTO MODULE WAS COMPLETELY REWRITTEN.  THE  RE-\n             WRITE  SHOULD  PROVIDE  FOR EASE OF ABILITY TO PROCESS\n             INFORMATION IN THE TSSO SYSTSPRT  INPUT  STREAM.  NOTE\n             THAT  THE  REWRITE  IMPOSES A TSSO RESTRICTION IN THAT\n             THE DCB CHARACTERISTICS OF THE SYSTSPRT FILE  MUST  BE\n             LRECL=137,  DSORG=PS,  RECFM=FBA.  ANY  DEVIATION FROM\n             THIS WILL CAUSE A TSSO ABEND.\n\n         2.  THE INSTALLATION DOCUMENTATION FOR TSSO  IS  IMPROVED.\n             SAMPLE   JOBS   ARE   PROVIDED   TO   ASSIST   IN  THE\n             INSTALLATION.\n\n         3.  THE TSSO SYSTEM PROGRAMMER  GUIDE  IS  MUCH  IMPROVED.\n             EXAMPLES  OF  HOW  TO  CONSTRUCT  TSSO CLISTS, AND AOF\n             TABLES ARE PROVIDED, AND  DOCUMENTATION  FOR  THE  TSO\n             COMMANDS SUPPLIED WITH TSSO IS GIVEN.\n\n         4.  TSSO PERFORMANCE WAS IMPROVED WITH THE RE-WRITE OF THE\n             TSSOWTO  MODULE.  TSSO  NOW  OBTAINS 1 SECOND RESPONSE\n             TIME FOR MOST TSO COMMANDS.\n\n         5.  TSSO  HAS  BEEN  VERIFIED  TO  RUN  PROPERLY  ON   THE\n             FOLLOWING SYSTEMS:\n\n               A.  MVS/SP 1.3.3 WITHOUT TSO/E\n\n               B.  MVS/SP 2.1.1 WITH TSO/E RELEASE 1\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 5 -\n\n\n\n               C.  MVS/SP 2.1.2 WITH TSO/E RELEASE 1\n\n               D.  MVS/SP 2.1.2 WITH TSO/E RELEASE 2\n\n               E.  MVS/SP 2.1.2 WITH TSO/E RELEASE 2.1\n\n       THE READER IS S T R O N G L Y  URGED TO READ THE  TSSO  4.1  SYSTEMS\n       PROGRAMMER  REFERENCE GUIDE, FOR INFORMATION ON USAGE OF THE\n       NEW FACILITIES.\n\n       CONCLUSION\n\n       THIS DOCUMENT PROVIDES INFORMATION ON THE  ENHANCEMENTS  AND\n       CHANGES  INCORPORATED  INTO RELEASE 4.1 OF THE TSSO PACKAGE.\n       ANY QUESTIONS ABOUT TSSO MAY BE DIRECTED TO  THE  AUTHOR  AT\n       (201) 981-2796.\n\n\n\n       PY-25821-MAS-MAS              M. A. SCHARE\n\n       COPY TO\n       B. CLAIR\n       J. GANCI\n       C. P. LEWIS\n       W. J. LUNDY\n       S. P. NATHAN\n       L. M. SZAZY\n       25820 DISTRICT MANAGERS\n       25850 DISTRICT MANAGERS\n       25821 DISTRICT MEMBERS\n       25827 DISTRICT MEMBERS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RELGDE42": {"ttr": 33805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01\\xa7\\x01\\xa7\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 423, "newlines": 423, "modlines": 0, "user": "TSSO403"}, "text": "\n\n       Bell Communications Research\n\n\n\n       subject: TSSO Release 4.2 Product      date: July 1, 1985\n                Content\n                                              from: M. A. Schare\n                                                    (201) 981-2796\n\n\n\n\n       INTRODUCTION\n\n       The Time  Sharing  Subsystem  Option  (TSSO)  is  a  package\n       designed to increase operations and end user productivity by\n       providing TSO-like services to the  MVS  operator,  and  MVS\n       console  services  to the TSO user. TSSO can greatly enhance\n       an installations efforts to efficiently control and  operate\n       MVS   by   automating  most  operational  procedures.   This\n       document describes the  changes  to  TSSO  in  Release  4.2.\n       Knowledge of TSSO concepts is assumed.1\n\n       Version 4.2 of the Time Sharing  Subsystem  Option  provides\n       enhancements  over  the previous release in five main areas.\n       They are:\n\n         1.  The TSSO Operator Productivity Facility (OPF) has been\n             enhanced  by  providing a facility whereby a CLIST can\n             invoke an MVS, JES2 or VTAM command,  and  obtain  the\n             response to the command in CLIST variables. Many other\n             enhancements were made to OPF, and  are  described  in\n             detail below.\n\n         2.  TSSO now interfaces with the RACF  and  ACF2  security\n             packages.  By  requiring  operators  to  \"logon\" using\n             these  interfaces,  TSSO  provides  several   security\n             enhancements.  Access  control  for MVS consoles using\n             TSSO  commands  are   implemented.   The   appropriate\n             security  system  is  called  to verify the userid and\n             password. At the highest level of security, TSSO  will\n             block  all  operator  commands  until  the console has\n             identified  itself  to   TSSO.   This   will   provide\n             operations  accountability.  Details  of  the security\n             interface are provided below.\n\n         3.  TSSO 4.2 is the first version of TSSO to provide  end-\n             user  capabilities.  A  subset of the OPF enhancements\n\n\n       __________\n\n       1.  M.  A. Schare, Time Sharing Subsystem Option (TSSO) Sys-\n           tems Programming Reference Guide, August 29, 1984\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 2 -\n\n\n\n             documented below are  available  to  TSO  users.  This\n             provides a TSO user with the ability to issue any MVS,\n             JES2 or  subsystem  operator  command.  The  scope  of\n             commands  is  controlled  through  bits  in  the  User\n             Attributes Data Set (UADS).\n\n         4.  TSSO 4.2 supports version  7.1  of  the  PDS  command.\n             These  two  public domain facilities work in tandem to\n             provide tools for  recovering  MVS  systems  in  cases\n             where  a  major  subsystem fails. PDS 7.1 provides the\n             capability  to   replace   strings   in   members   of\n             partitioned  datasets. TSSO provides the capability to\n             accomplish this replacement from an MVS console,  even\n             if  JES  or  VTAM  will  not initialize. This can be a\n             life-saver for single CPU shops.\n\n         5.  Lastly,  TSSO  4.2  provides   enhancements   to   the\n             Automated  Operator Facility (AOF). Two new parameters\n             on the  AOF  TABENTRY  macro  provide  for  additional\n             flexibility.\n\n       ENHANCEMENTS_TO_THE_OPERATOR_PRODUCTIVITY_FACILITY_(OPF)\n\n       In  previous  versions  of  TSSO,   all   operator   command\n       processing  occurred after execution of the command or CLIST\n       concluded. Queueing of  operator  commands  in  this  manner\n       restricted  CLIST  functionality  by  preventing  them  from\n       reacting to the results of operating system commands.   TSSO\n       4.2  provides  new  interface  to the MVS command subsystem.\n       Five new TSO commands exploit these  interfaces  and  expand\n       CLIST  capabilities  by  providing synchronous access to the\n       MVS command subsystem.\n\n         1.  The OSCMD provides the ability to issue an MVS command\n             from  an  executing CLIST. The response to the command\n             is  optionally  returned  to  CLIST  variables.  These\n             variables  may  then  be interrogated by the CLIST and\n             appropriate   action   taken.    Details   of    OSCMD\n             processing,  and  the input and output CLIST variables\n             it uses, are in the TSSO users guide.\n\n         2.  The OSWTO command may be used to send a message to the\n             MVS operator. This is useful to provide instruction to\n             the console operator during execution of the CLIST (as\n             opposed  to  the  CLIST  WRITE  statement,  which will\n             display a line AFTER the CLIST terminates).\n\n         3.  The OSWTOH command is the same as  OSWTO,  except  the\n             message is hilighted on the MVS console.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 3 -\n\n\n\n         4.  The OSASK command is  used  in  a  CLIST  to  ask  the\n             operator  a question (via WTOR) and place the response\n             into CLIST variables. The CLIST variables may then  be\n             interrogated.   This   command  allows  the  CLIST  to\n             establish a dialog with the MVS operator.\n\n         5.  The OSPAUSE command is used to delay  CLIST  execution\n             for  a  specified number of seconds. This is useful if\n             the CLIST initiates a started task, and must wait  for\n             it to initialize.\n\n       These 5 commands, together with the OPF component  of  TSSO,\n       provide an installation with a tremendous range of tools for\n       automating  almost  any   operational   task.   A   complete\n       description of these commands may be found in the TSSO users\n       guide.\n\n       TSSO_SECURITY_ENHANCEMENTS\n\n       In previous versions of TSSO, any MVS console could use  the\n       TSSO  subsystem  to  issue potentially hazardous TSO or TSSO\n       commands. For example,  a  console  defined  as  \"INFO-ONLY\"\n       could  issue  TSO commands through TSSO, or reload a new AOF\n       table.  TSSO  Version  4.2  contains  numerous  enhancements\n       designed  to  alleviate these problems, and optionally add a\n       level of security and  accountability  to  the  MVS  command\n       subsystem.    The    following    section   summarizes   the\n       enhancements.\n\n         1.  The TSSO subsystem provides three levels of  security.\n             These are:\n\n               a.  MINIMAL - TSSO functions as it did  in  previous\n                   versions.  For installations with RACF security,\n                   a default user id can be specified  through  the\n                   RACFID  parameter  at  TSSO startup. Any console\n                   may issue  any  TSO  command  through  the  TSSO\n                   subsystem.  Lastly,  no ACF2 support is provided\n                   at this level.\n\n               b.  MEDIAL  -  TSSO  requires  an  MVS  operator  to\n                   \"LOGON\" to TSSO using the new \"#.LOGON\" command.\n                   TSSO will then associate that console  with  the\n                   user  id.  Any commands or datasets accessed via\n                   TSSO by  that  console  are  executed  with  the\n                   authority  associated  with  that  user  id. The\n                   MEDIAL   security   level    is    useful    for\n                   installations  wishing  to  protect MVS datasets\n                   from access through  the  TSSO  subsystem.  Note\n                   that  the userid and password required for LOGON\n                   are  checked  via  the  RACF  or  ACF2  security\n\n\n\n\n\n\n\n\n\n\n\n                                  - 4 -\n\n\n\n                   system.  Under  this level, no controls over MVS\n                   commands are enforced.\n\n               c.  MAXIMAL - At the highest level of security, TSSO\n                   will  block  all  operator  commands  at a given\n                   console until the operator logs on  to  TSSO  as\n                   described above. This forces each MVS command to\n                   be accountable down to a  unique  RACF  or  ACF2\n                   user  id. In addition, if this level of security\n                   is selected, consoles will \"time out\"  (e.g.  be\n                   logged  off)  after  an  installation  specified\n                   number of minutes of inactivity. This  level  of\n                   security  is intended for installations who wish\n                   to maintain a high level  of  control  over  MVS\n                   operations.\n\n         2.  Regardless of the security level selected above,  TSSO\n             Version  4.2  provides a facility to protect sensitive\n             TSSO control commands (e.g.  #.P)  from  execution  by\n             unauthorized   consoles.   TSSO   will   not  allow  a\n             \"sensitive\"  command  to  be  issued  from  a  console\n             without  \"system\" authority, as defined in MVS: System\n             Commands.\n\n         3.  The OSCMD facility is secure in that  consoles  cannot\n             use  OSCMD  to  issue a command with a higher level of\n             authority then the original console.\n\n       END-USER_PRODUCTIVITY_BENEFITS\n\n       Many of the commands mentioned under  OPF  improvements  are\n       available  to  TSO users. An \"authorized\" TSO user may issue\n       any MVS, JES2 or subsystem  command.  An  unauthorized  user\n       will  be  able  to  issue  any command which is valid from a\n       \"display  only\"  console.  These  facilities  are   provided\n       through  the  OSCMD  command. If the OSCMD command is issued\n       from the TSO command line, the  response  from  the  command\n       will  be  returned  to  the terminal through TSO PUTLINE. If\n       OSCMD is invoked from  a  CLIST,  the  command  response  is\n       returned through CLIST variables.\n\n       The OSASK command is also available  to  the  TSO  end-user.\n       This  command  allows  the  end-user to \"ask\" the operator a\n       question, and retrieve the response, either at the  terminal\n       through PUTLINE, or into a CLIST variable.\n\n       The  reader  is  referred  to  the  TSSO  users  guide   for\n       information  concerning  these  facilities.  The  OSCMD is a\n       safe, powerful alternative to the TSO  status  command,  and\n       provides  a  state of the art interface between the TSO user\n       and the MVS command subsystem.\n\n\n\n\n\n\n\n\n\n\n\n                                  - 5 -\n\n\n\n       TSSO_RECOVERY_ENHANCEMENTS\n\n       TSSO Version 4.2 does not  contain  additional  facility  to\n       allow  for recovery of MVS systems in the case where JES2 or\n       VTAM has failed. The \"enhancements\" are realized through the\n       interfaces  with  the  PDS command, a public domain facility\n       written by Bruce Leland. The PDS command has the  capability\n       to  replace  one  string  with  another  in  any member of a\n       partitioned data set. This command ,like  any  TSO  command,\n       executes   under   the   TSSO   subsystem,   providing   the\n       installation a powerful utility  in  the  case  of  a  major\n       subsystem  failure.  The PDS command provides numerous other\n       facilities for recovery in these situations. The  reader  is\n       urged to obtain a copy of the PDS command (Version 7.1) from\n       the Connecticut Bank and Trust (CBT) mods tape.\n\n       ENHANCEMENTS_TO_THE_AUTOMATED_OPERATIONS_FACILITY_(AOF)\n\n       Two new parameters are available on  the  TSSO/AOF  TABENTRY\n       macro.  The  ECHO parameter provides a facility whereby TSSO\n       will display or log commands as they are  being  trapped  or\n       executed, and the MATCHLIM parameter allows the installation\n       to specify the maximum number of times a TSSO ACTION  should\n       be taken.\n\n         1.  The ECHO parameter enables the installation to  record\n             TSSO  ACTIONS  on  the MVS console, or the MVS SYSLOG.\n             This provides a degree of  accountability  within  the\n             TSSO  subsystem.  The MVS command or reply is directed\n             to the MVS master console (or optionally, the hardcopy\n             log).\n\n         2.  The MATCHLIM  parameter  supports  environments  where\n             TSSO   is   used   to  automatically  restart  failing\n             subsystems (such as VTAM) by trapping the  termination\n             messages  and  issuing the appropriate start commands.\n             The MATCHLIM parameter dictates the  number  of  times\n             that  TSSO  should perform the ACTION specified in the\n             TABENTRY macro. Once the MATCHLIM  has  been  reached,\n             TSSO will ignore the AOF table entry.\n\n         3.  The final enhancement to the AOF is  the  addition  of\n             the  ALTAOF command. ALTAOF will dynamically reset the\n             MATCHLIM value for a given AOF table entry to a  value\n             specified  in the ALTAOF command line. This provides a\n             good deal of flexibility for installations  attempting\n             to   duplicate   the  recovery  efforts  of  the  High\n             Availability Systems Lab (HASL) as documented  in  IBM\n             manual  ZZ05-0413-00:  Improving  IMS  Availability  -\n             Techniques for Automating  the  Recovery  Process  for\n             Selected  System  Failures.   Note  that resetting the\n\n\n\n\n\n\n\n\n\n\n\n                                  - 6 -\n\n\n\n             MATCHLIM value to zero effectively deletes the entry.\n\n       MISCELLANEOUS_and_SUNDRY_ENHANCEMENTS\n\n       As can be imagined, TSSO has undergone a considerable amount\n       of  change  since  the  previous  release.  This  effort has\n       brought about many enhancements that do  not  fit  into  the\n       above categories. These are summarized here.\n\n         1.  TSSO has been restructured. The number  of  processing\n             modules  has  doubled. This should provide for orderly\n             growth in future versions.\n\n         2.  The Subsystem Support Module (TSSOSSSM) has been split\n             into two modules, one for handling subsystem interface\n             code 10 (operator commands) and one for handling  code\n             9   (WTO  messages).  The  new  SUBSYS  initialization\n             statement allows an installation to specify these, and\n             other  subsystem  interface  codes.  This  removes the\n             burden of establishing subsystem entry points from the\n             programmer.\n\n         3.  TSSO messages are now more uniform. The general format\n             of message is\n\n             TSS a nnn s\n\n             where \"a\" is the TSSO module issuing the message,  nnn\n             is  a  unique  message  identifier,  and  \"s\"  is  the\n             severity of the message.\n\n         4.  TSSO control commands are now parsed,  providing  more\n             flexibility  in  command  syntax. As a result of this,\n             the syntax of all QUERY  commands  has  been  slightly\n             altered.\n\n       TSSO_4.2_PLANNING\n\n       A design philosophy prevalent throughout TSSO is a desire to\n       use  only standard MVS interfaces. Because of this, TSSO 4.2\n       has  additional   software   pre-requisites   and   planning\n       considerations.  These are summarized here:\n\n         1.  TSSO uses a  subsystem  allocatable  console  for  the\n             OSCMD interface. This console is \"virtual\" in a sense,\n             but must be added to the MVS IOGEN stage 1 input deck,\n             and  a  gen must be performed. Refer to the \"PLANNING\"\n             section in the TSSO users guide.\n\n         2.  The OSCMD and  OSASK  commands  place  responses  into\n             CLIST  variables.  These  commands use a new interface\n\n\n\n\n\n\n\n\n\n\n\n                                  - 7 -\n\n\n\n             provided with TSO/E  Release  2  to  accomplish  this.\n             Therefore, TSO/E Release 2 is a pre-requisite to using\n             these commands.\n\n         3.  MVS/SP 1.3.2 or above  is  still  a  prerequisite  for\n             TSSO. The minimum level of MVS/XA is 2.1.1.\n\n         4.  The RACF interface requires RACF Version 1, Release 6.\n             The minimum ACF2 level is 4.0.\n\n       CONCLUSION\n\n       This document summarizes the enhancements made  to  TSSO  in\n       Version  4.2.  Any and all comments, complaints, suggestions\n       or requests may be directed to the author at (201) 981-2796.\n\n\n\n                                     M. A. Schare\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RELGDE43": {"ttr": 34056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01\\xbf\\x01\\xbf\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 447, "newlines": 447, "modlines": 0, "user": "TSSO403"}, "text": "          DATE:     SEPTEMBER 16, 1986                FROM: M. A. SCHARE\n                                                      (201) 981-2796.\n          SUBJECT:  TSSO RELEASE 4.3 PRODUCT\n                    CONTENT\n\n\n\n\n          INTRODUCTION\n\n          THE TIME SHARING SUBSYSTEM OPTION (TSSO) IS A PACKAGE DESIGNED TO\n          INCREASE  OPERATIONS  AND END USER PRODUCTIVITY BY PROVIDING TSO-\n          LIKE SERVICES TO THE MVS OPERATOR, AND MVS  CONSOLE  SERVICES  TO\n          THE TSO AND NCCF USER. TSSO CAN GREATLY ENHANCE AN INSTALLATION'S\n          EFFORTS TO EFFICIENTLY CONTROL AND OPERATE MVS BY AUTOMATING MOST\n          OPERATIONAL  PROCEDURES.   THIS DOCUMENT DESCRIBES THE CHANGES TO\n          TSSO IN VERSION 4, RELEASE  3.  KNOWLEDGE  OF  TSSO  CONCEPTS  IS\n          ASSUMED.1\n\n          VERSION  4.3  OF  THE  TIME  SHARING  SUBSYSTEM  OPTION  PROVIDES\n          ENHANCEMENTS  OVER  THE PREVIOUS RELEASE IN FIVE MAIN AREAS. THEY\n          ARE:\n\n            1.  ENHANCEMENTS  TO  THE  OPERATIONS   PRODUCTIVITY   FACILITY\n                (TSSO/OPF). THESE ENHANCEMENTS ARE SPECIFICALLY IN THE AREA\n                OF INCREASED AUTOMATION CAPABILITY THROUGH  EXPANDED  CLIST\n                ORIENTED  TSSO COMMANDS, AND THE REMOVAL OF THE RESTRICTION\n                OF ONLY ONE OUTSTANDING OSCMD IN THE SYSTEM.\n\n            2.  ENHANCEMENTS   TO   THE   AUTOMATED   OPERATIONS   FACILITY\n                (TSSO/AOF). THESE ENHANCEMENTS PROVIDE EASE OF USE FEATURES\n                FOR SYSTEM  PROGRAMMERS  AND  OPERATORS  DEALING  WITH  THE\n                TSSO/AOF COMPONENT.\n\n            3.  THE ADDITION OF AN INTERFACE TO THE NETWORK  COMMUNICATIONS\n                CONTROL  FACILITY (NCCF). THIS INTERFACE ALLOWS THE NETWORK\n                OPERATOR TO ISSUE MVS, JES2 OR  OTHER  SUBSYSTEM  COMMANDS,\n                AND RETRIEVE THE RESPONSE AT THE NCCF TERMINAL.\n\n            4.  THE TSSO CONSOLE SECURITY FEATURE HAS BEEN UPGRADED TO  USE\n                THE  SYSTEM  ACCESS  FACILITY FOR ITS INTERFACE TO SECURITY\n                SYSTEMS.\n\n\n\n\n          __________\n\n          1.  M.  A.  SCHARE,  ____  _______  _________ ______ (____) _____\n              _____, ______, ____\n\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 2                        SEPTEMBER 16, 1986\n\n\n\n\n            5.  NUMEROUS RAS (RELIABILITY, AVAILABILITY AND SERVICEABILITY)\n                ENHANCEMENTS, TO PROVIDE GREATER TSSO STABILITY.\n\n          EACH OF THESE ENHANCEMENTS WILL NOW BE DISCUSSED SEPARATELY.\n\n          ENHANCEMENTS TO THE OPERATOR PRODUCTIVITY FACILITY\n\n          THE FOLLOWING ENHANCEMENTS WERE MADE TO THE OPERATOR PRODUCTIVITY\n          FACILITY:\n\n            1.  TSSO NOW ALLOWS MORE THAN ONE SIMULTANEOUS  CALLER  OF  THE\n                OSCMD  TSO  COMMAND. THE INSTALLATION DEFINES THE NUMBER OF\n                SIMULTANEOUS CALLERS IN THE NEW NUMCONS  PARAMETER  IN  THE\n                TSSO  INITIALIZATION  DECK.  INSTALLATIONS  MUST DEFINE ONE\n                SUBSYSTEM CONSOLE TO MVS FOR EVERY SIMULTANEOUS  CALLER  OF\n                OSCMD.  IN ADDITION, AN INSTALLATION MAY CHOOSE TO DEDICATE\n                ONE SUBSYSTEM CONSOLE FOR THE TSSO ADDRESS SPACE.  THIS  IS\n                ACCOMPLISHED  THROUGH  A  DEDICATE PARAMETER ON THE NUMCONS\n                STATEMENT. TSSO 4.3 PROVIDES AN EXPANDED  OPERATOR  COMMAND\n                (#.Q SCON) TO MONITOR THE STATUS OF THE SUBSYSTEM CONSOLES.\n                THIS WILL ALLOW AN INSTALLATION TO DETERMINE WHO  IS  USING\n                THE SUBSYSTEM CONSOLES, AND HOW MANY ARE NEEDED.\n\n            2.  THE OSCMD COMMAND HAS BEEN REWRITTEN FOR TSSO 4.3.  IT  NOW\n                SUPPORTS  THE  CAPABILITY  TO  DIRECT  THE  RESPONSE  OF AN\n                OPERATING SYSTEM, JES2 OR SUBSYSTEM COMMAND TO\n\n                  1.  A TSO TERMINAL - IF  OSCMD  WAS  ISSUED  FROM  A  TSO\n                      ADDRESS SPACE.\n\n                  2.  THE MVS CONSOLE -  IF  OSCMD  WAS  PART  OF  A  CLIST\n                      INITIATED FROM THE TSSO ADDRESS SPACE.\n\n                  3.  CLIST VARIABLES - IF OSCMD WAS ISSUED FROM A CLIST.\n\n                THE REDIRECTION  OF  MVS  COMMAND  OUTPUT  IS  ACCOMPLISHED\n                THROUGH  A CLIST VARIABLE (CMDRESP), WHICH IS USED AS INPUT\n                TO OSCMD.\n\n                OSCMD NOW SUPPORTS A USER EXIT, TO ALLOW AN INSTALLATION TO\n                CODE  A  ROUTINE  TO  DETERMINE THE MVS COMMAND GROUP LEVEL\n                (E.G. SYSTEM, I/O, MASTER OR INFO) THE TSO USER IS  ALLOWED\n                TO  ISSUE.  THE  DEFAULT  VERSION OF THE OSCMDATH USER EXIT\n                ALLOWS THE TSO USER THE AUTHORITY  OF  AN  MVS  INFORMATION\n                ONLY  CONSOLE,  UNLESS  THE X'C0' BITS ARE TURNED ON IN THE\n                USERDATA FIELD OF THE TSO USER'S UADS ENTRY.  THIS  MAY  BE\n                DONE   THROUGH   THE   USERDATA  PARAMETER  OF  THE  CHANGE\n                SUBCOMMAND IN TSO ACCOUNT.\n\n\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 3                        SEPTEMBER 16, 1986\n\n\n\n\n            3.  A NEW COMMAND, OSWAIT, IS INCLUDED IN TSSO 4.3.  OSWAIT  IS\n                INTENDED  TO  BE  ISSUED  FROM  THE  CLIST ENVIRONMENT, AND\n                ALLOWS THE CLIST TO WAIT FOR A SPECIFIED MESSAGE TO  APPEAR\n                ON  THE MVS CONSOLE. THE MESSAGE IS DEFINED IN THE TSSO/AOF\n                TABLE. FOR EXAMPLE, THE FOLLOWING CLIST WILL START  A  JOB,\n                WAIT FOR THE JOB TO COMPLETE, AND PURGE THE JOB.\n\n                     PROC 0\n                     /***************************************/\n                     /* THIS CLIST WILL START A JOB, WAIT   */\n                     /* FOR ITS COMPLETION, AND PURGE THE   */\n                     /* JOB.                                */\n                     /***************************************/\n\n                     OSCMD S MYJOB\n                     OSWAIT ENTRY(MYJOBEND)   TIMEOUT(60)\n                     OSWTO MYJOB HAS ENDED...\n                     OSCMD $P'MYJOB'\n                     EXIT\n\n                NOTE THAT THE TIMEOUT PARAMETER ALLOWS THE CLIST  DEVELOPER\n                TO  SPECIFY  HOW  MANY  SECONDS  TO WAIT FOR THE MESSAGE TO\n                APPEAR.  THE  FOLLOWING  TSSO/AOF  TABLE  DEFINITION  ENTRY\n                SUPPORTS  THE ABOVE CLIST (NOTE THAT IEF404I IS THE MVS JOB\n                ENDED MESSAGE).\n\n                   TABENTRY MSG=IEF404I,ACTION=POST,TEST=((W,2,5,'MYJOB',' '))\n\n\n                THE OSWAIT  COMMAND  PROVIDES  FOR  SIGNIFICANT  AUTOMATION\n                OPPORTUNITIES  THAT WERE (IN PREVIOUS VERSIONS OF TSSO) TOO\n                CUMBERSOME TO JUSTIFY DEVELOPMENT.\n\n                OSWAIT DOES NOT NEED TO RUN FROM THE TSSO ADDRESS SPACE. IN\n                THEORY,   AN  INSTALLATION  MAY  HAVE  MANY  OSWAIT  EVENTS\n                OUTSTANDING AT ANY ONE TIME,  IN  DIFFERENT  TSO  OR  BATCH\n                ADDRESS  SPACES. FOR EXAMPLE, A SIMPLE JOB SCHEDULER CAN BE\n                CODED AS A CLIST USING THE  OSWAIT  AND  OSCMD  FACILITIES.\n                THIS  CLIST CAN THEN BE RUN UNDER CONTROL OF A BATCH TMP IN\n                A SEPARATE ADDRESS SPACE.\n\n                IT SHOULD BE NOTED THAT ALTHOUGH TSSO  DOES  NOT  HAVE  ANY\n                FACILITY  FOR  TIMER  DEPENDENT  COMMANDS,  IT  MAY UTILIZE\n                EITHER THE JES2 AUTOMATIC COMMAND  FACILITY,  OR  THE  NCCF\n                \"AT\"  AND  \"EVERY\"  COMMANDS  TO  START  CLISTS AT SPECIFIC\n                TIMES, OR AT SPECIFIED INTERVALS.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 4                        SEPTEMBER 16, 1986\n\n\n\n\n          ENHANCEMENTS TO THE AUTOMATED OPERATIONS FACILITY\n\n          THE FOLLOWING ENHANCEMENTS WERE MADE TO THE AUTOMATED  OPERATIONS\n          FACILITY (AOF) COMPONENT OF TSSO.\n\n            1.  TSSO 4.3 SUPPORTS A  LABEL  ON  THE  TABENTRY  MACRO.  THIS\n                PARAMETER  ALLOWS THE CODER OF THE AOF TABLE TO ASSOCIATE A\n                1-8 CHARACTER IDENTIFIER WITH  EACH  TABENTRY  MACRO.  THIS\n                IDENTIFIER  CAN  THE BE USED AS A PARAMETER TO THE DISPAOF,\n                ALTAOF OR OSWAIT COMMANDS.\n\n            2.  THE DISPAOF COMMAND IS ENHANCED TO DISPLAY  THE  NEW  LABEL\n                ASSOCIATED  WITH  THE TABENTRY MACRO.  IT CAN ALSO USE THIS\n                LABEL AS AN OPERAND TO THE ENTRYID PARAMETER.  DISPAOF WILL\n                DISPLAY  ALL  ENTRIES  THAT  START  WITH  THE  GIVEN  ENTRY\n                IDENTIFIER. IN ADDITION, THE MSG PARAMETER OF  THE  DISPAOF\n                COMMAND  IS ENHANCED TO DISPLAY ALL ENTRIES THAT START WITH\n                THE GIVEN MESSAGE IDENTIFIER, INSTEAD OF THE REQUIREMENT OF\n                AN EXACT MATCH. FOR EXAMPLE, THE COMMAND\n\n                   DISPAOF ENTRY(VTAMUP)\n\n\n                WILL DISPLAY ALL TSSO/AOF TABLE  ENTRIES  THAT  HAVE  ENTRY\n                IDENTIFIER STARTING WITH \"VTAMUP\". THE COMMAND\n\n\n                   DISPAOF MSG($HASP)\n\n\n                WILL DISPLAY ALL TSSO/AOF TABLE ENTRIES WITH A  MESSAGE  ID\n                STARTING WITH $HASP (E.G. ALL JES2 RELATED ENTRIES).\n\n            3.  A NEW CLIST (ASMTAB) IS PROVIDED TO ASSEMBLE AND  LINK-EDIT\n                THE  TSSO AOF TABLE. THIS CLIST REDUCES THE CUMBERSOME TASK\n                OF PLACING A NEW AOF TABLE INTO PRODUCTION. IT IS  INTENDED\n                AS  AN  EXAMPLE,  AND WILL PROBABLY HAVE TO BE MODIFIED FOR\n                USE  IN  YOUR  INSTALLATION.   THE  CLIST  CAN  ASSEMBLE  A\n                MODERATELY  SIZED TABLE, LINK EDIT THE RESULT, AND COPY THE\n                RESULTING  LOAD  MODULE  INTO  SYS1.TSSOLOAD  IN  ABOUT  10\n                SECONDS.   THE  CLIST  HAS  A RELOAD PARAMETER TO ISSUE THE\n                TSSO #.RELOAD COMMAND UPON SUCCESSFUL  ASSEMBLY  AND  LINK-\n                EDIT.\n\n            4.  TSSO/AOF SUPPORTS THE OSWAIT  COMMAND  BY  RECOGNIZING  THE\n                SPECIFICATION OF ACTION=POST ON THE TABENTRY MACRO.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 5                        SEPTEMBER 16, 1986\n\n\n\n\n          ADDITION OF AN INTERFACE TO NCCF\n\n          THE NETWORK COMMUNICATION CONTROL  FACILITY  IS  AN  IBM  PROGRAM\n          PRODUCT THAT PROVIDES FOR NETWORK CONTROL IN ACF/VTAM OR ACF/TCAM\n          ENVIRONMENTS. THROUGH THE ADDITION OF AN OSCMD COMMAND PROCESSOR,\n          NCCF  NOW  SUPPORTS  CONTROL  OF  MVS,  JES2 OR OTHER SUBSYSTEMS.\n          SPECIFICALLY, THE NCCF VERSION OF OSCMD ALLOWS A NETWORK OPERATOR\n          TO  ISSUE MVS, JES2 OR SUBSYSTEM COMMANDS, AND RETRIEVE RESPONSES\n          AT THE NCCF TERMINAL.  THE NCCF VERSION OF OSCMD IS A  COMPLETELY\n          SEPARATE ENTITY FROM THE TSO VERSION. THIS COMMAND PROCESSOR USES\n          STANDARD NCCF AND TSSO FACILITIES TO ALLOW AN  NCCF  OPERATOR  TO\n          ISSUE  OPERATING  SYSTEM  COMMANDS  AND  RETRIEVE  RESPONSES. THE\n          COMMAND INSTALLS DIRECTLY  INTO  THE  NCCF  LOAD  LIBRARY,  OR  A\n          CONCATENATED DATASET, AND IS DEFINED TO NCCF IN THE DSICMD MEMBER\n          OF THE NCCF PARAMETER DATA SET.\n\n          IT IS IMPORTANT TO NOTE THAT FOLLOWING POINTS:\n\n            A.  THE NCCF AND TSO VERSIONS OF OSCMD SHARE THE SAME  POOL  OF\n                SUBSYSTEM CONSOLES. WHEN DEFINING THE NUMCONS PARAMETER, IT\n                IS IMPORTANT TO CONSIDER THE NUMBER  OF  SIMULTANEOUS  NCCF\n                USERS THAT WILL BE USING TSSO FACILITIES.\n\n            B.  NCCF DOES NOT REQUIRE APF  AUTHORIZATION  BECAUSE  OF  THIS\n                FACILITY.  THIS  IS DESPITE THE FACT THAT OSCMD DOES INDEED\n                RUN WITH APF AUTHORIZATION. TSSO GRANTS  APF  AUTHORIZATION\n                TO  THE  NCCF VERSION OF OSCMD THROUGH THE USE OF MVS CROSS\n                MEMORY SERVICES. TSSO PROVIDES A NEW OPERATOR COMMAND  (#.Q\n                XMEM) TO MONITOR THE CROSS MEMORY ENVIRONMENT, AS WELL AS A\n                DEBUG OPTION TO DISPLAY WHEN THE NCCF VERSION OF OSCMD  HAS\n                CALLED THE TSSO CROSS MEMORY SERVICES ROUTINE.\n\n                THIS AUTHORIZATION METHOD IS  CONTRASTED  WITH  IBM'S  OCCF\n                PRODUCT,  WHICH  REQUIRES  ALL DATASETS IN THE NCCF STEPLIB\n                CONCATENATION TO BE IN THE APF AUTHORIZATION LIST.\n\n            C.  TSSO ASSUMES THAT ALL NCCF USERS ARE  AUTHORIZED  TO  ISSUE\n                MVS  MASTER CONSOLE COMMANDS. A USER EXIT IS PROVIDED IF AN\n                INSTALLATION WISHES TO ALTER  THIS  DEFAULT.  THE  EXIT  IS\n                PASSED THE NCCF USER IDENTIFIER.\n\n            D.  THE TSSO/NCCF OSCMD FACILITY FULLY SUPPORTS THE USE OF  THE\n                NCCF  ROUTE  COMMAND.  THIS ALLOWS REMOTE OPERATOR TO ROUTE\n                MVS, JES2 OR SUBSYSTEM  COMMANDS  TO  REMOTE  SYSTEMS,  AND\n                RETRIEVE THE RESPONSES. THIS FACILITY MAKES IT POSSIBLE FOR\n                AN OPERATOR TO CONTROL (OR AT LEAST MONITOR) MANY MVS HOSTS\n                FROM ONE NCCF CONSOLE.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 6                        SEPTEMBER 16, 1986\n\n\n\n\n          TSSO CONSOLE SECURITY SAF INTERFACE\n\n          THE TSSO CONSOLE SECURITY COMPONENT IS ENHANCED TO USE THE SYSTEM\n          ACCESS  FACILITY  (SAF)  INTERFACE. ALL CALLS MADE BY TSSO TO THE\n          RACF SECURITY SYSTEM WERE  REPLACED  BY  SAF  CALLS.  RACF  USERS\n          SHOULD  NOTICE  NO  DIFFERENCES  BECAUSE OF THIS ENHANCEMENT. TOP\n          SECRET USERS SHOULD ALSO BE UNAFFECTED.  THE  ENHANCEMENT  ALLOWS\n          FOR  ACF2  SUPPORT  TO BE PROVIDED USING STANDARD MVS FACILITIES.\n          ACF2 USERS WILL  NEED  ACF2  VERSION  4.1  TO  SUPPORT  THIS  NEW\n          FEATURE.  NOTE  THAT ACF2 SUPPORT IS CURRENTLY UNDER DEVELOPMENT,\n          AND IS NOT AVAILABLE IN THE BASE TSSO 4.3 CODE.\n\n          RELIABILITY, AVAILABILITY AND SERVICEABILITY\n\n          THE FOLLOWING ENHANCEMENTS HAVE BEEN MADE TO TSSO TO ENHANCE IT'S\n          RELIABILITY, AVAILABILITY AND SERVICEABILITY (RAS).\n\n            1.  TSSO NO LONGER ALLOWS THE OPERATOR TO START TSSO IF  IT  IS\n                ALREADY  UP. PREVIOUS RELEASES OF TSSO WOULD ALLOW NUMEROUS\n                \"INCARNATIONS\" OF TSSO  ADDRESS  SPACES  TO  EXIST  IN  THE\n                SYSTEM.\n\n            2.  SINCE IT MAY OCCASIONALLY BECOME NECESSARY TO  FORCE  START\n                TSSO  (E.G.   DEFEAT THE ABOVE FEATURE), A NEW PARAMETER IS\n                AVAILABLE IN THE PARM FIELD OF THE START  COMMAND  USED  TO\n                START  TSSO.  IF  THE  PARAMETER BEGINS WITH A SLASH ('/'),\n                TSSO WILL RESTART OVER ITSELF.\n\n            3.  TSSO ALLOWS AN OPERATOR TO SPECIFY INITIALIZATION  \"PROMPT\"\n                MODE  AS AN OPERAND ON THE START COMMAND. TSSO WILL GO INTO\n                \"PROMPT\" MODE IF AN \"*\" IS DETECTED  IMMEDIATELY  PRIOR  TO\n                THE  PARMLIB MEMBER SPECIFICATION ON THE START COMMAND. FOR\n                EXAMPLE, THE COMMAND\n\n                   S TSSO,PARM='*TSSODECK'\n\n\n                WILL     START     TSSO     USING      PARAMETERS      FROM\n                'SYS1.PARMLIB(TSSODECK)',  AND  PLACE TSSO IN \"PROMPT\" MODE\n                FOLLOWING THE READING OF THE PARAMETER INPUT. THE COMMAND\n\n\n                  S TSSO,PARM='*'\n\n\n                WILL FORCE TSSO INTO PROMPT MODE AFTER  READING  PARAMETERS\n                FROM THE DEFAULT INITIALIZATION DECK (TSSOPARM).  NOTE THAT\n                IF BOTH NEW OPERANDS (PROMPT  MODE  AND  FORCE  START)  ARE\n                REQUIRED,  THE '/' MUST BE SPECIFIED FIRST, FOLLOWED BY THE\n                '*', FOLLOWED  BY  THE  NAME  OF  THE  SYS1.PARMLIB  MEMBER\n\n\n\n\n\n\n\n\n\n\n\n          MEMORANDUM FOR FILE - 7                        SEPTEMBER 16, 1986\n\n\n\n\n                SPECIFYING TSSO PARAMETERS.\n\n            4.  TSSO NOW CONTAINS A MODULE THAT WILL GET CONTROL AT MVS IPL\n                TIME,  AND OBTAIN STORAGE FOR A NEW CONTROL BLOCK, THE TSSO\n                NON DISRUPTABLE SYSTEM AREA (TSSONDSA). THIS CONTROL  BLOCK\n                KEEPS STATUS FLAGS ACROSS TSSO RESTARTS. INSTALLATIONS MUST\n                MAKE A SMALL CHANGE TO THE IEFSSNXX MEMBER OF  SYS1.PARMLIB\n                TO SUPPORT THIS CHANGE.\n\n                IF THIS CHANGE IS NOT MADE, TSSO WILL INITIALIZE THIS FIELD\n                WHEN STARTED, HOWEVER, THE BENEFITS FROM THE NEXT FEATURE\n                (#5) WILL NOT BE REALIZED.\n\n            5.  TSSO WILL NOW DEFAULT TO USE THE PRIMARY SUBSYSTEM (JES2 OR\n                JES3)  FOR  SERVICES.  IN  PREVIOUS  RELEASES  OF TSSO, THE\n                SUB=JES2 COMMAND NEEDED TO BE INCLUDED ON THE START COMMAND\n                FOR THIS TO HAPPEN. THE COMMAND\n\n\n                   S TSSO,SUB=MSTR\n\n\n                WILL  ALLOW  TSSO  TO  INITIALIZE   WITHOUT   THE   PRIMARY\n                SUBSYSTEM.\n\n            6.  TSSO  4.3  NOW  SUPPORTS  RESTART  PROCESSING.  IF  IT   IS\n                NECESSARY  TO  FORCE  START  TSSO (AS DESCRIBED ABOVE), THE\n                INACTIVE TSSO ADDRESS SPACE MAY BE CANCELLED. NOTE THAT THE\n                INACTIVE  TSSO  DOES NOT RELINQUISH ITS SUBSYSTEM CONSOLES,\n                AND THEREFORE, IT IS NOT ADVISABLE TO  FORCE  START  UNLESS\n                ABSOLUTELY NECESSARY.\n\n            7.  THE TSSO INITIALIZATION ROUTINE IS COMPLETELY REWRITTEN FOR\n                TSSO  4.3.  THE  NEW  ROUTINE  ONLY  ACCESSES KEY ZERO WHEN\n                ABSOLUTELY REQUIRED.\n\n          CONCLUSION\n\n          THIS DOCUMENT SUMMARIZES THE ENHANCEMENTS MADE TO TSSO IN VERSION\n          4.3.  ANY  AND  ALL COMMENTS, COMPLAINTS, SUGGESTIONS OR REQUESTS\n          MAY BE DIRECTED TO THE AUTHOR AT (201) 981-2796.\n\n\n\n          M. A. SCHARE\n\n\n          MAS-MAS\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPLY": {"ttr": 34310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99&\\x7f\\x00\\x99&\\x7f\\x08E\\x00\\xf7\\x00\\xf7\\x00B\\xc1\\xc7\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-09-24T00:00:00", "modifydate": "1999-09-24T08:45:00", "lines": 247, "newlines": 247, "modlines": 66, "user": "AGCO"}, "text": "REPLY    MENTER 12,EQU,CP=CP,COM=REPLYLOADER\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n********************************************************************\n* THIS COMMAND WILL SERVE AS THE LOADING PROGRAM FOR THE REPLY     *\n* COMMAND FUNCTION OF TSSO. THIS MODULE WILL LOCATE, AND LOAD THE  *\n* REPLY COMMAND MODULE INTO GLOBAL STORAGE, AND THEN ISSUE A LINK  *\n* TO IT, AFTER PARSING THE COMMAND USING THE TSO SERVICE ROUTINES  *\n*\n* METHOD OF OPERATION\n*\n* 1) OBTAIN COMMAND BUFFER\n* 2) USING IKJPARSE TO DETERMINE SYNTAX OF COMMAND: EXPECTED SYNTAX\n*    IS:\n*\n*    REPLY MESSAGE(XXXXXXXX) TEXT(' ')\n*    IF THE MESSAGE ID IS THE IMS MESSAGE ID FOR OUTSTANDING WTORS\n*    THEN THE COMMAND WILL TAKE ON THE FOLLOWING SYNTAX:\n*\n*\n*    REPLY IMS(IMS COPY) TEXT('IMS COMMAND')\n*\n*\n*\n* 3) THE REPLY COMMAND WILL THEN BUILD A PARM LIST TO BE PASSED TO\n*    THE REPLYLOA LOAD MODULE. THE PARM LIST IS AS FOLLOWS\n*\n*    IMS NOT SPECIFIED              IMS SPECIFIED\n*\n*    MSGNUM DC CL8' '               MSGNUM DC CL8'DFS999I'\n*    PARMIMS DC CL9'NONE'           PARMIMS DC CL9' '\n*    REPTXT DC CL100' '             REPTXT DC  CL100' '\n*\n* 4) THE REPLY COMMAND WILL LOAD THE REPLYLOA LOAD MODULE, AND\n*    AND BRANCH TO IT, WAITING PATIENTLY UNTIL IT RETURNS.\n*    FOR COMMENTS ON HOW THE REPLYLOA MODULE WILL DO ITS MAGIC,\n*    READ THE COMMENTS FOR THAT MDOULE.\n*\n* 5) THE REPLY COMMAND WILL DELETE THE REPLYLOA LOAD MODULE, AND\n*    TERMINATE.\n*\n*\n* MODIFIED:\n*\n*  24AUG99   DHC  BYPASS SUSPECT AUTHORITY CHECKING            *AGCO*\n*\n*  15OCT92   GLA  INCLUDE MAINTENANCE TO 4.2\n*                 A.  ADD RETURN CODE TO ALLOW DETECTION OF NO\n*                     OUTSTANDING REPLY\n*                        LASTCC = 0    GOOD REPLY\n*                                 4    REPLY NOT OUTSTANDING\n*                                 8    ERROR IN COMMAND\n*\n*                 B.  ADD SUPPORT FOR IDMS\n*                 C.  CHANGE CHECK FOR JOBNAME TO KEEP BELOW LINE\n*                     FOR ESA 4.2\n*\n********************************************************************\n         L     R2,CPPLPSCB\n         USING PSCB,R2\n         B     PROCEED             SKIP AUTHORITY TESTS        *AGCO*\n         TM    PSCBATR2,X'C0'           WELL ?\n         BO    PROCEED\n         L     R9,X'224'               GET ASCB INTO R9\n         USING ASCB,R9\n         L     R9,ASCBJBNS         GET STARTED TASK NAME       15OCT92\n         CLC   0(4,R9),=CL4'TSSO'  ALLOW TSSO TO REPLY TO ANY  15OCT92\n         BE    PROCEED\n         B     IMPLEXEC\nIMPLEXEC DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR8,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nPROCEED  DS    0H\n         SETPARSE  PCL=REPLYPCL\n         CALLTSSR EP=IKJPARS\n         LTR   R15,R15\n         BZ    PARSEOK\n         B     PARSERR\n         B     ENDPROG\nPARSEOK  DS    0H\n         L     R9,MYANS                 GET RESULTS OF PARSE\n         USING IKJPARMD,R9\n         CLC   MSGID,=H'1'              WAS MESSAGE ID RQSTED?  15OCT92\n         BE    MSGIDOK                  YES SO HANDLE IT        15OCT92\n         BH    TESTIMS                  SEE IF IMS SPECIFIED    15OCT92\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR3,TERM,SINGLE,DATA), 15OCT92X\n               MF=(E,IOPLADS)           ISSUE ERROR             15OCT92\n         B     PARSERR                                          15OCT92\nMSGIDOK  DS    0H\n* GO AND MOVE THE MSGID INTO THE REPLYLOA PARM LIST.\n         LH    R2,MSGIDFLD+4            GET LENGTH OF MESSAGE ID\n         BCTR  R2,0                     SUBTRACT 1 FOR EXECUTE\n         L     R3,MSGIDFLD              GET ADDRESS\n         EX    R2,MOVEMSG               AND MOVE IT\n         MVC   PARMIMS(9),=CL9' '       INDICATE NO IMS SPECIFIED\n         B     EX1                      PROCEED\nMOVEMSG  MVC   PARMMSG(0),0(R3)         ** EXECUTED **\nEX1      DS    0H\n         B     GETTEXT                  GET THE TEXT\nTESTIMS  DS    0H                                               15OCT92\n         CLC   MSGID,=H'2'               WAS IMS SPECIFIED ?    15OCT92\n         BH    TESTIDMS                 NO.. TRY IDMS           15OCT92\nIMSOK    DS    0H\n         L     R3,IMSFLD\n         LH    R2,IMSFLD+4              GET LENGTH OF IMS FIELD\n         MVI   PARMIMS,C'I'             INDICATE IMS REQUESTED  15OCT92\nIMSIDMS  BCTR  R2,0                     GET MACHINE LENGTH      15OCT92\n         MVC   PARMIMS+1(8),=CL8' '     CLEAR AREA              15OCT92\n         EX    R2,MOVEIMS               MOVE IN DATA            15OCT92\n         B     GETTEXT                                          15OCT92\nMOVEIMS  MVC   PARMIMS+1(0),0(R3)       **EXECUTED ONLY**       15OCT92\nTESTIDMS DS    0H                                               15OCT92\n* INSERT OTHER TESTS HERE                                       15OCT92\nIDMSOK   L     R3,IDMSFLD               GET ADDRESS             15OCT92\n         LH    R2,IDMSFLD+4             GET GET LENGTH          15OCT92\n         MVI   PARMIMS,C'D'             INDICATE IDMS REQUESTED 15OCT92\n         B     IMSIDMS                                          15OCT92\nGETTEXT  DS    0H\n* HERE, IMS WAS NOT SPECIFIED  SO WE GET THE REPLY TEXT.\n* NOW MOVE IN THE REPLY TEXT\n         TM    REPLYFLD+6,X'80'\n         BO    REPTXTOK\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR5,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     PARSERR\nREPTXTOK DS    0H\n         LH    R2,REPLYFLD+4\n         L     R3,REPLYFLD\n         BCTR  R2,0\n         EX    R2,MOVETXT\n         B     EX2\nMOVETXT  MVC   PARMTEXT(0),0(R3)\nEX2      DS    0H\n         TESTAUTH FCTN=1\n         LTR   R15,R15\n         BNZ   NOAPF\n         MODESET KEY=ZERO\n         LOAD  EP=REPLYLOA,ERRET=NOLOAD    ,GLOBAL=(YES,P)     *DHC*\n         L     R1,PARMADDR       LOAD UP PARM ADDRESS\n         LR    R15,R0                   GET ADDRESS OF REPLYLOA\n         OI    FLAGS,X'80'              SET FLAG TO INDICATE LOAD\n*        BALR  R14,R15                  BRANCH TO REPLYLOA\n         BASSM R14,R15                  BRANCH TO REPLYLOA      23AUG99\n         BASSM R14,0                    RETURN TO 24 BIT MODE   23AUG99\n         LTR   R15,R15           WAS REPLY MADE ?\n         BZ    REPLIED                  DIAGNOSE RETURN CODE\n         MVC   EXITRC,=H'4'         GIVE ERROR                  15OCT92\n         CLC   PARMIMS(9),=CL9' '   ATTEMPTING TO REPLY TO IMS ?\n         BE    ERRNOIMS             NOPE !\n         MVC   ERRLNE1(8),PARMIMS+1\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR1,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ENDPROG\nERRNOIMS DS    0H\n         MVC   ERRLNE2+38(8),PARMMSG\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR2,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nREPLIED  DS    0H\n         B     ENDPROG\nERRPROG  DS    0H                                               15OCT92\n         MVC   EXITRC,=H'8'      SET ERROR OCCURED              15OCT92\nENDPROG  DS    0H\n         TM    FLAGS,X'80'       WAS REPLYLOA LOADED ?\n         BZ    NODELETE          NO, DONT BOTHER DELETING\n         DELETE EP=REPLYLOA\nNODELETE DS    0H\n         MLEAVE\nNOLOAD   DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR6,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ERRPROG                                          15OCT92\nPARSERR  DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR7,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ERRPROG                                          15OCT92\nNOAPF    DS    0H\n         PUTLINE PARM=PUTBLOK,OUTPUT=(ERROR9,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\n         B     ERRPROG                                          15OCT92\nERROR1   DC    H'80',H'0'\nERRLNE1  DC    CL80'XXXXXXXX DOES NOT HAVE AN OUTSTANDING REPLY'\nERROR2   DC    H'80',H'0'\nERRLNE2  DC    CL80'THERE ARE NO OUTSTANDING REPLIES FOR \"XXXXXXXX\"'\nERROR3   DC    H'80',H'0'\nERRLNE3  DC    CL80'YOU MUST SPECIFY EITHER AN IMS COPY, OR A MESSAGE IX\n               D TO REPLY TO'\nERROR5   DC    H'80',H'0'\nERRLNE5  DC    CL80'REPLY TEXT MISSING- RE-ENTER THE COMMAND WITH TEXT X\n               FOR THE REPLY'\nERROR6   DC    H'80',H'0'\nERRLNE6  DC    CL80'SEVERE ERROR LOADING THE REPLYLOA MODULE- CONTACT  X\n               A SYSTEMS PROGRAMMER'\nERROR7   DC    H'80',H'0'\nERRLNE7  DC    CL80'REPLY COMMAND TERMINATING DUE TO PARSE ERROR'\nERROR8   DC    H'80',H'0'\nERRLNE8  DC    CL80'IKJ56500I COMMAND REPLY NOT FOUND'\nERROR9   DC    H'80',H'0'\nERRLNE9  DC    CL80'REPLY WAS CALLED IN AN UNAUTHORIZED ENVIRONMENT- REX\n               QUEST ABORTED'\nFLAGS    DS    H\n* BYTE 1:\n* X'80' = REPLYLOA WAS LOADED.\nWKA      DS    2D\nPRINTOCC DS    F\nPARMADDR DC    A(PARMS)\nPARMS    DS    0D\nPARMMSG  DC    CL8' '\nPARMIMS  DC    CL9' '\nPARMTEXT DC    CL120' '\nREPLYPCL IKJPARM\nMSGID    IKJKEYWD\n         IKJNAME 'MESSAGE',SUBFLD=MSGIDSUB,                     15OCT92X\n               ALIAS=('MSGID','MSG')                            15OCT92\n         IKJNAME 'IMS',SUBFLD=IMSSUB                            15OCT92\n         IKJNAME 'IDMS',SUBFLD=IDMSSUB                          15OCT92\nREPTXT   IKJKEYWD\n         IKJNAME 'REPLYTXT',SUBFLD=REPLYSUB\n         IKJNAME 'TEXT',SUBFLD=REPLYSUB\nMSGIDSUB IKJSUBF\nMSGIDFLD IKJIDENT 'MSGID',PROMPT='MESSAGE ID',CHAR,             15OCT92X\n               HELP=('MESSAGE NUMBER TO REPLY TO'),             15OCT92X\n               MAXLNTH=8                                        15OCT92\nREPLYSUB IKJSUBF\nREPLYFLD IKJIDENT 'REPLY',PROMPT='REPLY TEXT',FIRST=ALPHANUM,          X\n               OTHER=ALPHANUM,HELP=('TEXT OF REPLY'),                  X\n               MAXLNTH=120,CHAR\nIMSSUB   IKJSUBF\nIMSFLD   IKJIDENT 'IMS',FIRST=ALPHANUM,                                X\n               OTHER=ALPHANUM,HELP=('IMS COPY TO REPLY TO'),           X\n               MAXLNTH=8\nIDMSSUB  IKJSUBF ,                                              15OCT92\nIDMSFLD  IKJIDENT 'IDMS',FIRST=ALPHANUM,                        15OCT92X\n               OTHER=ALPHANUM,HELP=('IDMS CV TO REPLY TO'),     15OCT92X\n               MAXLNTH=8                                        15OCT92\n         IKJENDP\n         CVT DSECT=YES\n         IKJIOPL\n         IKJPSCB\n         IHAASCB\n         END REPLY\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY REPLY(''TSSO  4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    REPLY'\n PUNCH ' NAME     REPLY(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPLYLOA": {"ttr": 34315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x013\\x00\\x17\\x01\\x022?\\x01\\x022?\\x14\\x16\\x01-\\x01&\\x00\\xbe\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@'", "ispf": {"version": "01.51", "flags": 0, "createdate": "2002-11-19T00:00:00", "modifydate": "2002-11-19T14:16:17", "lines": 301, "newlines": 294, "modlines": 190, "user": "MMSMAK"}, "text": "REPLYLOA CSECT                                                    RPS\n         EQUATES                                                  RPS\n         STM   R14,R12,12(R13)          SAVE CALLER'S REGS        RPS\n         LAE   R12,0(R15,0)             ESTABISH R11 AS BASE REG  RPS\n         USING REPLYLOA,R12             ESTABLISH ADDRESSABILITY  RPS\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n********************************************************************\n* THIS COMMAND WILL SERVE AS THE REPLYING MODULE FOR THE REPLY     *\n* COMMAND FUNCTION OF TSSO. THIS MODULE ACCEPT PARAMTERS FROM THE  *\n* APPLY PROMPTER, DUE A SPACE SWITCH INTO THE CONSOLE ADDRESS SPACE*\n* AND ATTEMPT TO REPLY TO THE COMMAND.                             *\n*                                                                  *\n* METHOD OF OPERATION                                              *\n*                                                                  *\n* 1) OBTAIN PARAMETER LIST IN THE FORM:                            *\n*                                                                  *\n*                                                                  *\n* R1==> PARMS                                                      *\n* PARMS                                                            *\n* MSGID FOR 8 BYTES                                                *\n* IMS COPY FOR 9 BYTES                                             *\n* REPLY TEXT FOR 120 BYTES                                         *\n*                                                                  *\n* 2) OBTAIN INFORMATION ABOUT THE CONSOLE ADDRESS SPACE, SUCH AS   *\n*    ASID, ASCB AND CONSOLE ID OF MASTER.                          *\n*                                                                  *\n* 3) SSAR TO CONSOLE ASID                                          *\n*                                                                  *\n* 4) SAC TO CONSOLE ASID                                           *\n*                                                                  *\n* 5) SEARCH THE ORE AND  WQE CONTROL BLOCKS UNTIL EITHER THE IMS   *\n*    COPY, OR MESSAGE ID IS LOCATED...                             *\n*                                                                  *\n* 6) FORMAT AND ISSUE THE REPLY COMMAND, OR SET RETURN CODE SAYING *\n*    THIS COULD NOT BE DONE.                                       *\n*                                                                  *\n*                                                                  *\n* 7) RETURN TO THE SAFETY OF THE REPLY MODULE, AFTER RETURNING TO  *\n*    KEY OF EIGHT.                                                 *\n*                                                                  *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*                                                                     *\n*   31AUG99  DHC   REPLACE THE CROSS MEMORY STUFF WITH LIONRPLY       *\n*                  AKA 'REPLY' OF THE 'COMMAND' PROCESSOR  IN FILE 19 *\n*                  OF THE CBT TAPE AT RELEASE 417                     *\n*                  NOTE: THIS PROGRAM IS NO LONGER RE-ENTRANT         *\n*                                                                     *\n*   29OCT92  GLA   SET MASTCONS OF ZERO IF NO UCMLIST (HARDWARE       *\n*                  SYSCONS AS MASTER)                                 *\n*                                                                     *\n*   15OCT92  GLA  INCORPORATE CHANGES FROM VERSION 4.2                *\n*              A.  ADD SUPPORT FOR IDMS                               *\n*              B.  ADD SUPPORT FOR CADISPATCH AS IDMS                 *\n*              C.  ADD SUPPORT FOR 31BIT ORE ELEMENTS.                *\n*                                                                     *\n*   NOV 2002 EEJ   1) Fix workarea clearing problem.            EEJ1102\n*            EEJ   2) Support 4-byte reply IDs                  EEJ1102\n*            DHC   Check for LIONRPLY table end mark            *AGCO*\n***********************************************************************\n         LR    R5,R1                    SAVE PARM POINTER          RPS\n         LA    R1,WORKAREA_LEN          GET WORKAREA LENGTH FOR GM RPS\n\n         STORAGE OBTAIN,                + OBTAIN A WORKAREA        RPS X\n               LENGTH=(R1),             + R1 = LENGTH              RPS X\n               ADDR=(R2),               + RETURN ADDR IN R2        RPS X\n               COND=NO                  + ABEND IF WE CAN'T GET IT RPS\n\n         USING WORKAREA,R2              R2 ---> SAVEAREA/WORKAREA  RPS\n         LR    R0,R2                    Zero the work area      EEJ1102\n         LA    R1,WORKAREA_LEN          (same)                  EEJ1102\n         XR    R15,R15                  (same)                  EEJ1102\n         MVCL  R0,R14                   (same)                  EEJ1102\n         ST    R2,8(R13)                FORWARD CHAIN POINTER      RPS\n         ST    R13,SAVEAREA+4           BACKWARD CHAIN POINTER     RPS\n         LR    R13,R2                   SAVE/WORKAREA ADDR IN R13  RPS\n         LR    R10,R2                   AND IN A BASE REGISTER    *DHC*\n         DROP  R2                                                  RPS\n         USING WORKAREA,R10             R10---> SAVEAREA/WORKAREA *DHC*\n         MVC   REPLYMSG(8),0(R5)\n         MVC   IMSCOPY(9),8(R5)\n         MVC   REPLYTXT(90),17(R5)\n********************************************************************\n* THE PARAMETERS ARE NOW SAFELY STORED AWAY.                       *\n* FIRST, WE MUST DETERMINE THE ASID OF THE COMMTASK ADDRESS SPACE. *\n********************************************************************\n         L     R2,16              CVT\n         USING CVT,R2\n         L     R3,CVTCUCB         UCMBASE\n         USING UCM,R3\n         LH    R4,UCMCTID         CONSOLE ADDRESS SPACE\n         STH   R4,CONSASID        PUT AWAY\n         LR    R4,R3\n         AH    R4,=H'-4'          GO BACK 4 SPACES\n         L     R4,0(R4)           UCM PREFIX\n         USING UCMPRFX,R4\n         XR    R15,R15\n*DHC*    ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTCONS 29OCT92\n*DHC*    BZ    HRDCONS              IF NONE THEN USE MASTCONS=0 29OCT92\n         USING UCMLIST,R14                                      29OCT92\n         IC    R15,UCMID            GET THE CONSOLE ID\nHRDCONS  DS    0H                                               29OCT92\n         STH   R15,MASTCONS\n         DROP  R3                 END MAPPING\n         DROP  R4                 END MAPPING\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*        GET STORAGE FOR AN OUTSTANDING REPLY TABLE                   *\n*                                                                     *\n***********************************************************************\n         L     R2,=A(100*L'MSGENT) Get table size               EEJ1102\n         GETMAIN R,LV=(2)          Acquite the table            EEJ1102\n         ST    R1,GETADDR          SAVE TABLE ADDRESS\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        GO GET A LIST OF OUTSTANDING REPLIES                         *\n*                                                                     *\n***********************************************************************\n         CALL  LIONRPLY            CALL THE SUBROUTINE\n***********************************************************************\n* IN THE AGCO VERSION ALL FURTHER CHECKS ARE AGAINST THE COPY OF THE  *\n* WQE PULLED IN BY 'LIONRPLY'. THESE ARE ADDRESSED VIA THE 'MSGDSECT' *\n* MAPPING.                                                            *\n***********************************************************************\n         L     R6,GETADDR          POINT TO REPLY TABLE\n         USING MSGENT,R6           ESTABLISH ADDRESSABILITY\n         LA    R4,99               SET NUMBER OF LOOPS\n         SPACE 2\n********************************************************************\n* WE WILL DETERMINE IF THE REQUIREMENT IS FOR A SPECIFIC\n* IMS COPY. IF IT IS, CHECK FOR DFS996I IN THE MESSAGE TEXT AND\n* CHECK POSITION 25 FOR THE IMS IDENTIFIER. IF NOT, WE CHECK\n* FOR DFS810A IN THE MESSAGE TEXT AND CHECK THE 120 POSITION\n* FOR THE IMS INDENTIFIER. IF NEITHER OF THESE WORK OUT, WE\n* GO TO THE NEXT WQE.\n********************************************************************\nMSGCHECK DS    0H                  CHECK EACH OUTSTANDING REPLY\n         CLI   0(R6),X'FF'         END OF TABLE FLAG?           *AGCO*\n         BE    NOTMSG              YES, SO NOT FOUND            *AGCO*\n         MVC   MSGID,=CL8' '       Blank out message ID         EEJ1102\n         LA    R1,MSGID            Point to message ID          EEJ1102\n         LA    R2,MSG              Point to message text        EEJ1102\n         LA    R0,L'MSGID          Prevent 0C4 if bad data      EEJ1102\nMSGCHK1  DS    0H                                               EEJ1102\n         CLI   0(R2),C' '          Blank separator ?            EEJ1102\n         BNH   MSGCHK2             Branch if yes                EEJ1102\n         LA    R2,1(,R2)           Advance pointer              EEJ1102\n         BCT   R0,MSGCHK1          Loop until blank found       EEJ1102\nMSGCHK2  DS    0H                                               EEJ1102\n         LA    R0,L'MSGID          Prevent 0C4 if bad data      EEJ1102\n         LA    R2,1(,R2)           Point to message ID          EEJ1102\nMSGCHK3  DS    0H                                               EEJ1102\n         CLI   0(R2),C' '          Blank separator ?            EEJ1102\n         BNH   MSGCHK4             Branch if yes                EEJ1102\n         MVC   0(1,R1),0(R2)       Copy byte from msg ID        EEJ1102\n         LA    R2,1(,R2)           Advance pointers             EEJ1102\n         LA    R1,1(,R1)           Advance pointers             EEJ1102\n         BCT   R0,MSGCHK3          Loop until blank found       EEJ1102\nMSGCHK4  DS    0H                                               EEJ1102\n         CLC   IMSCOPY(9),=CL9' '  IS THIS AN IMS REQUEST ?\n         BE    LOOKMSG             NO IMS REQUEST- LOOK AT MSGID\n         CLI   IMSCOPY,C'I'            IS THIS IMS REQUEST      15OCT92\n         BNE   CHKIDMS                 NO SO TRY IDMS           15OCT92\n         CLC   MSGID,=CL8'DFS996I'        IS THIS AN IMS WQE ?\n         BE    CHKCOPY                    YUP, CHECK WHICH COPY.\n         CLC   MSGID,=CL8'DFS810A'        IS THIS A FIRST IMS WQE ?\n         BE    CHKCOPY2                   YUP, IMS COPY IS IN\n         CLC   MSGID,=CL8'DFS3139'        IS THIS A FIRST IMS WQE ?\n         BE    CHKCOPY3                   YUP, IMS COPY IS IN\nCHKCOPY  DS    0H\n********************************************************************\n* HERE, WE ARE CHECKING THE IMS COPY IN THE WQE FOR THE IMS SHORT\n* MESSAGE, I.E. DFS999I. THE MESSAGE APPEARS AFTER DFS810A HAS BEEN\n* REPLIED TO ONCE.\n********************************************************************\n         CLC   MSG+25(8),IMSCOPY+1        CORRECT IMS COPY ?\n         BE    GOTMSG                     YES !!\n         B     TRYNEXT\nCHKCOPY2 DS    0H\n         CLC   MSG+79(8),IMSCOPY+1        CORRECT IMS COPY ?\n         BE    GOTMSG                     YES !!\n         B     TRYNEXT\nCHKCOPY3 DS    0H\n         CLC   MSG+67(8),IMSCOPY+1        CORRECT IMS COPY ?\n         BE    GOTMSG                     YES !!\n         B     TRYNEXT\n*                                         A DIFFERENT PLACE THOUGH\nCHKIDMS  DS    0H                                               15OCT92\n****************************************************************15OCT92\n* HERE, WE ARE CHECKING THE IDMS CV NUMBER IN THE WQE           15OCT92\n****************************************************************15OCT92\n         CLC   =C'REPLY WITH REQUEST TO DS50',MSG+4 DISPATCH?   15OCT92\n         BE    CHKIDMS2                   WAS NOT IDMS REPLY!!  15OCT92\n         CLC   =C'REPLY WITH REQUEST TO IDMS',MSG+4      IDMS?? 15OCT92\n         BNE   TRYNEXT                    WAS NOT IDMS REPLY!!  15OCT92\nCHKIDMS2 CLC   MSG+31(8),IMSCOPY+1        CORRECT IDMS COPY?    15OCT92\n         BE    GOTMSG                     YES !!                15OCT92\n         B     TRYNEXT\n********************************************************************\n* HERE WE KNOW WE ARE LOOKING FOR MESSAGE TEXT\n********************************************************************\nLOOKMSG  DS    0H\n         CLC   MSGID,REPLYMSG     IS THIS THE CORRECT MESSAGE\n         BE    GOTMSG             GOT THE MESSAGE\nTRYNEXT  DS    0H\n         LA    R6,L'MSGENT(,R6)   TRY NEXT MESSAGE TABLE ENTRY\n         BCT   R4,MSGCHECK        GO ROUND EACH MESSAGE\nNOTMSG   DS    0H                 Message not found             *AGCO*\n         LA    R9,8                SET ERROR CODE\n*        DC    A(0)                ABEND S0C1       *DEBUG*\n         STH   R9,EXITRC           REMEMBER IT\n         B     ENDPROG             GO FINISH\n         EJECT ,\nGOTMSG   DS    0H\n* HERE, WE PERCEIVE WE HAVE A REPLY TO MAKE, SO WE ISSUE THE\n* REPLY COMMAND USING SVC 34. THE MESSAGE NUMBER FOR THE REPLY IS\n* IN THE ORE.\n         MVC   REPLYCMD(2),=Y(REPLYLEN) Set length              EEJ1102\n         MVC   REPLYCMD+2(2),=H'0'\n         MVC   REPLYNUM,RID        Copy reply ID                EEJ1102\n         CLI   REPLYNUM,C'0'       LEADING ZERO?                 *AGCO*\n         BNE   GOTMSG2             NO, USE THAT NUMBER           *AGCO*\n         MVI   REPLYNUM,C' '       YES, USE BLANKS               *AGCO*\n         CLI   REPLYNUM+1,C'0'     LEADING ZERO?                 *AGCO*\n         BNE   GOTMSG2             NO, USE THAT NUMBER           *AGCO*\n         MVI   REPLYNUM+1,C' '     YES, USE BLANKS               *AGCO*\nGOTMSG2  DS    0H\n         MVC   REPLYLNE(90),REPLYTXT     COPY REPLY TEXT\n         MVI   REPLYCOM,C','\n         MODESET MODE=SUP,KEY=ZERO\n         LH    R0,MASTCONS               GET MASTER CONSOLE     EEJ1102\n         MGCR  REPLYCMD                  ISSUE COMMAND\n         MODESET KEY=NZERO,MODE=PROB\n         MVC   EXITRC(2),=H'0'\nENDPROG  DS    0H\n         LH    R9,EXITRC                SAVE RC                    RPS\n         L     R1,GETADDR               GET WORKAREA LEN FOR FREE\n         L     R2,=A(100*L'MSGENT) Get table size               EEJ1102\n         STORAGE RELEASE,          Free the table               EEJ1102+\n               LENGTH=(2),         (same)                       EEJ1102+\n               ADDR=(1)            (same)                       EEJ1102\n         L     R13,4(,R13)         RESTORE SA POINTER\n         LA    R1,WORKAREA_LEN          GET WORKAREA LEN FOR FREE  RPS\n         STORAGE RELEASE,LENGTH=(R1),ADDR=(R10)   FREE STORAGE     RPS\n         LR    R15,R9                   SET RC                     RPS\n         RETURN (14,12),RC=(15)         RETURN                     RPS\n\n         TITLE 'DATA CONSTANT'\nONE      DC    H'1'\n\n         TITLE 'SAVEAREA/WORKAREA'\n         DSECT\nWORKAREA DS    0F\nSAVEAREA DS    18F\nR13SAVE  DS    F             SAVE R13 FOR SETLOCK\nGETADDR  DS    F             REPLY TABLE ADDRESS\nSASID    DS    F\nCONSASID DS    H\nEXITRC   DS    H\nMASTCONS DS    H\nCOMMASCB DS    F\nMSGID    DC    CL8' '              Message ID work field        EEJ1102\nREPLYMSG DC    CL8' '\nIMSCOPY  DC    CL9' '\nREPLYTXT DC    CL90' '\nREPLYCMD DC    H'0',H'0'     REAL LENGTH, ZERO\nREPLYNUM DC    CL4' '              Reply ID                     EEJ1102\nREPLYCOM DC    C','          COMMA\nREPLYLNE DC    CL90' '\nREPLYLEN EQU   *-REPLYCMD          Length of command buffer     EEJ1102\nDOUBLEWD DC    D'0'                WORKAREA\nWORKAREA_LEN   EQU  *-WORKAREA\n         TITLE 'DSECTS'\nMSGDSECT DSECT\nMSGENT   DS   0CL140                                            EEJ1102\nJNAME    DS    CL8\nRID      DS    CL4                 Reply ID                     EEJ1102\nMSG      DS    0CL128\n         DS    CL128\n         SPACE 3\n         IEZMGCR DSECT=YES         MGCR MAPPING\n         EJECT ,\n         PRINT NOGEN               SUPPRESS MACRO EXPANSION\n         CVT   DSECT=YES,LIST=NO\n         IHAORE\nUCM      DSECT\n         IEECUCM LIST=NO\n         IHAWQE\n         IHAPSA\n         END   REPLYLOA\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY REPLYLOA(''V 1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE SYSLMOD(LIONRPLY)'\n PUNCH ' ENTRY    REPLYLOA'\n PUNCH ' NAME     REPLYLOA(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REPLYLOB": {"ttr": 34566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x966o\\x00\\x966o\\x14\\x15\\x01\\x1d\\x01\\x1b\\x00\\x1d\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1996-12-31T00:00:00", "modifydate": "1996-12-31T14:15:00", "lines": 285, "newlines": 283, "modlines": 29, "user": "RPS"}, "text": "\nREPLYLOA CSECT                                                    RPS\nREPLYLOA AMODE 31                                                 RPS\nREPLYLOA RMODE ANY                                                RPS\n         EQUATES                                                  RPS\n         SPLEVEL SET=5                                            RPS\n         SAC   0                        A/S MODE                  RPS\n         SYSSTATE ASCENV=P              INDICATE PRIMARY A/S      RPS\n         STM   R14,R12,12(R13)          SAVE CALLER'S REGS        RPS\n         LAE   R12,0(R15,0)             ESTABISH R11 AS BASE REG  RPS\n         USING REPLYLOA,R12             ESTABLISH ADDRESSABILITY  RPS\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n********************************************************************\n* THIS COMMAND WILL SERVE AS THE REPLYING MODULE FOR THE REPLY     *\n* COMMAND FUNCTION OF TSSO. THIS MODULE ACCEPT PARAMTERS FROM THE  *\n* APPLY PROMPTER, DUE A SPACE SWITCH INTO THE CONSOLE ADDRESS SPACE*\n* AND ATTEMPT TO REPLY TO THE COMMAND.                             *\n*                                                                  *\n* METHOD OF OPERATION                                              *\n*                                                                  *\n* 1) OBTAIN PARAMETER LIST IN THE FORM:                            *\n*                                                                  *\n*                                                                  *\n* R1==> PARMS                                                      *\n* PARMS                                                            *\n* MSGID FOR 8 BYTES                                                *\n* IMS COPY FOR 9 BYTES                                             *\n* REPLY TEXT FOR 120 BYTES                                         *\n*                                                                  *\n* 2) OBTAIN INFORMATION ABOUT THE CONSOLE ADDRESS SPACE, SUCH AS   *\n*    ASID, ASCB AND CONSOLE ID OF MASTER.                          *\n*                                                                  *\n* 3) SSAR TO CONSOLE ASID                                          *\n*                                                                  *\n* 4) SAC TO CONSOLE ASID                                           *\n*                                                                  *\n* 5) SEARCH THE ORE AND  WQE CONTROL BLOCKS UNTIL EITHER THE IMS   *\n*    COPY, OR MESSAGE ID IS LOCATED...                             *\n*                                                                  *\n* 6) FORMAT AND ISSUE THE REPLY COMMAND, OR SET RETURN CODE SAYING *\n*    THIS COULD NOT BE DONE.                                       *\n*                                                                  *\n*                                                                  *\n* 7) RETURN TO THE SAFETY OF THE REPLY MODULE, AFTER RETURNING TO  *\n*    KEY OF EIGHT.                                                 *\n*                                                                  *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*   15OCT92  GLA  INCORPORATE CHANGES FROM VERSION 4.2                *\n*              A.  ADD SUPPORT FOR IDMS                               *\n*              B.  ADD SUPPORT FOR CADISPATCH AS IDMS                 *\n*              C.  ADD SUPPORT FOR 31BIT ORE ELEMENTS.                *\n*                                                                     *\n*   29OCT92  GLA   SET MASTCONS OF ZERO IF NO UCMLIST (HARDWARE       *\n*                  SYSCONS AS MASTER)                                 *\n*                                                                     *\n***********************************************************************\n         LR    R5,R1                    SAVE PARM POINTER          RPS\n         LA    R1,WORKAREA_LEN          GET WORKAREA LENGTH FOR GM RPS\n\n         STORAGE OBTAIN,                + OBTAIN A WORKAREA        RPS X\n               LENGTH=(R1),             + R1 = LENGTH              RPS X\n               ADDR=(R2),               + RETURN ADDR IN R2        RPS X\n               LOC=(ANY,ANY),           + ANYWHERE I DON'T CARE    RPS X\n               COND=NO                  + ABEND IF WE CAN'T GET IT RPS\n\n         USING WORKAREA,R2              R2 ---> SAVEAREA/WORKAREA  RPS\n         XC    WORKAREA(L'WORKAREA_LEN),WORKAREA  CLEAR WORKAREA   RPS\n         ST    R2,8(R13)                FORWARD CHAIN POINTER      RPS\n         ST    R13,SAVEAREA+4           BACKWARD CHAIN POINTER     RPS\n         LR    R13,R2                   SAVE/WORKAREA ADDR IN R13  RPS\n         DROP  R2                                                  RPS\n         USING WORKAREA,R13             R2 ---> SAVEAREA/WORKAREA  RPS\n\n         LR    R2,R5              COPY PARM ADDRESS\n         MVC   REPLYMSG(8),0(R2)\n         MVC   IMSCOPY(9),8(R2)\n         MVC   REPLYTXT(120),17(R2)\n********************************************************************\n*                                                                  *\n* THE PARAMETERS ARE NOW SAFELY STORED AWAY, THE REST OF THIS CODE *\n* MUST RUN IN THE CONSOLE ADDRESS SPACE. WE WILL SSAR AND SAC TO   *\n* ACHIEVE THIS.                                                    *\n* FIRST, WE MUST DETERMINE THE ASID OF THE COMMTASK ADDRESS SPACE. *\n********************************************************************\n         L     R2,16              CVT\n         USING CVT,R2\n         L     R3,CVTCUCB         UCMBASE\n         USING UCM,R3\n         LH    R4,UCMCTID         CONSOLE ADDRESS SPACE\n         STH   R4,CONSASID        PUT AWAY\n         LR    R4,R3\n         AH    R4,=H'-4'          GO BACK 4 SPACES\n         L     R4,0(R4)           UCM PREFIX\n         USING UCMPRFX,R4\n         XR    R15,R15\n         ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTCONS 29OCT92\n         BZ    HRDCONS              IF NONE THEN USE MASTCONS=0 29OCT92\n         USING UCMLIST,R14                                      29OCT92\n         IC    R15,UCMID            GET THE CONSOLE ID\nHRDCONS  DS    0H                                               29OCT92\n         STH   R15,MASTCONS\n         L     R15,UCMASCB        GET ASCB OF COMMTASK ADDRESS SPACE\n         ST    R15,COMMASCB       AND PUT IT AWAY\n         DROP  R2,R14\n         MODESET MODE=SUP,KEY=ZERO\n         ESAR  R2                 GET SECONDARY ADDRESS SPACE\n         ST    R2,SASID           STORE IT AWAY FOR LATER\n         AXSET AX=ONE             GET AUTHORIZATION ANYWHERE\n         LH    R2,CONSASID        LOAD UP ASID OF CONSOLE ADDRESS SPACE\n         SSAR  R2\n* GET CONSOLE ADDRESS SPACE LOCAL LOCK FOR REPLY FUNCTION.\n         L     R11,COMMASCB       GET ASCB OF COMMTASK\n         ST    R13,R13SAVE        SAVE REG 13\n         LA    R13,LOCKSAVE       PROVIDE SETLOCK WITH SAVEAREA\nGETLOCK  SETLOCK OBTAIN,TYPE=CML,ASCB=(11),REGS=USE,MODE=UNCOND,       X\n               RELATED=(CONASCB,RELLOCK)\n         SAC   X'100'             GO INTO SECONDARY ADDRESS SPACE\n*                                 MODE (CONSOLE ASID)\nREPLYIT  DS    0H\n* WE NOW ENTER THE PART OF THE PROGRAM WHERE WE ACTUALLY TO THE REPLY\n* AS REQUESTED IN THE COMMAND.\n* WE WILL SEARCH THE CHAIN OF ORE ELEMENTS, LOOKING FOR ONE WITH A\n* WQE TO MATCH WHAT WE WANT.\n         L     R15,TO31A1         IN ESA 4.2 ORES               15OCT92\n         BSM   0,R15                  ARE ABOVE                 15OCT92\nTO31A1   DC    A(X'80000000'+O31A1)        THE LINE             15OCT92\nO31A1    DS    0H                                               15OCT92\n         L     R4,UCMRPYQ         LOAD ADDRESS OF FIRST ORE ENTRY\n         LA    R4,0(R4)           ** CLEAR HIGH ORDER BYTE **\n         LTR   R4,R4              IF NO OUTSTANDING WTORS\n         BZ    ENDLOOP            THEN GET TO END OF LOOP\n         LA    R7,20              OTHERWISE, ASSUME AT MOST 20.\nORELOOP  DS    0H\n         USING OREF,R4\n         L     R5,ORERWQE         GET ASSOCIATED WQE\n         USING WQE,R5             ADDRESS IT\n********************************************************************\n* NOW WE ARE LOOKING AT A WQE ASSOCIATED WITH SOME OUTSTANDING\n* REPLY. WE WILL DETERMINE IF THE REQUIREMENT IS FOR A SPECIFIC\n* IMS COPY. IF IT IS, WE INSERT DFS996I INTO THE MESSAGE TEXT AND\n* CHECK POSITION 25 FOR THE IMS IDENTIFIER. IF NOT, WE\n* INSERT DFS810A INTO THE MESSAGE TEXT AND CHECK THE 120 POSITION\n* FOR THE IMS INDENTIFIER. IF NEITHER OF THESE WORK OUT, WE\n* GO TO THE NEXT WQE.\n********************************************************************\n         CLC   IMSCOPY(9),=CL9' '  IS THIS AN IMS REQUEST ?\n         BE    LOOKMSG             NO IMS REQUEST- LOOK AT MSGID\n         CLI   IMSCOPY,C'I'            IS THIS IMS REQUEST      15OCT92\n         BNE   CHKIDMS                 NO SO TRY IDMS           15OCT92\n         CLC   WQETXT+4(8),=CL8'DFS996I'  IS THIS AN IMS WQE ?\n         BE    CHKCOPY                    YUP, CHECK WHICH COPY.\n         CLC   WQETXT+4(8),=CL8'DFS810A'  IS THIS A FIRST IMS WQE ?\n         BE    CHKCOPY2                   YUP, IMS COPY IS IN\nCHKCOPY  DS    0H\n********************************************************************\n* HERE, WE ARE CHECKING THE IMS COPY IN THE WQE FOR THE IMS SHORT\n* MESSAGE, I.E. DFS999I. THE MESSAGE APPEARS AFTER DFS810A HAS BEEN\n* REPLIED TO ONCE.\n********************************************************************\n         CLC   WQETXT+25(8),IMSCOPY+1     CORRECT IMS COPY ?\n         BE    GOTMSG                     YES !!\n         B     TRYNEXT\nCHKCOPY2 DS    0H\n         CLC   WQETXT+79(8),IMSCOPY+1     CORRECT IMS COPY ?\n         BE    GOTMSG                     YES !!\n         B     TRYNEXT\n*                                         A DIFFERENT PLACE THOUGH\nCHKIDMS  DS    0H                                               15OCT92\n****************************************************************15OCT92\n* HERE, WE ARE CHECKING THE IDMS CV NUMBER IN THE WQE           15OCT92\n****************************************************************15OCT92\n         CLC   =C'REPLY WITH REQUEST TO DS50',WQETXT+4 DISPATCH?15OCT92\n         BE    CHKIDMS2                   WAS NOT IDMS REPLY!!  15OCT92\n         CLC   =C'REPLY WITH REQUEST TO IDMS',WQETXT+4   IDMS?? 15OCT92\n         BNE   TRYNEXT                    WAS NOT IDMS REPLY!!  15OCT92\nCHKIDMS2 CLC   WQETXT+31(8),IMSCOPY+1     CORRECT IDMS COPY?    15OCT92\n         BE    GOTMSG                     YES !!                15OCT92\n         B     TRYNEXT\n********************************************************************\n* HERE WE KNOW WE ARE LOOKING FOR MESSAGE TEXT\n********************************************************************\nLOOKMSG  DS    0H\n         CLC   WQETXT+4(8),REPLYMSG  IS THIS THE CORRECT MESSAGE\n         BE    GOTMSG             GOT THE MESSAGE\nTRYNEXT  DS    0H\n         L     R4,ORELKP          TRY NEXT ORE\n         LA    R4,0(R4)           ** CLEAR HIGH ORDER BYTE **\n         LTR   R4,R4\n         BZ    ENDLOOP\n         BCT   R7,ORELOOP\n         MVC   EXITRC(2),=H'8'    SET RETURN CODE FROM LOOP\n         B     XMEMOFF            AND GET OUT OF CROSS MEM LOOP\nENDLOOP  DS    0H\n         MVC   EXITRC(2),=H'8'\n         B     XMEMOFF\nGOTMSG   DS    0H\n* HERE, WE PERCEIVE WE HAVE A REPLY TO MAKE, SO WE ISSUE THE\n* REPLY COMMAND USING SVC 34. THE MESSAGE NUMBER FOR THE REPLY IS\n* IN THE ORE.\n         MVC   REPLYCMD(2),=H'90'\n         MVC   REPLYCMD+2(2),=H'0'\n         MVC   REPLYCMD+4(6),=CL6'REPLY '\n         MVC   REPLYNUM(2),OREID\n         MVC   REPLYLNE(90),REPLYTXT     COPY REPLY TEXT\n         MVI   REPLYCOM,C','\n         L     R15,TO24A1                NOW GO                 15OCT92\n         BSM   0,R15                       BACK TO              15OCT92\nTO24A1   DC    A(O24A1)                      REGULAR 24         15OCT92\nO24A1    DS    0H                              BIT MODE         15OCT92\n         SAC   X'000'                    OUT OF XMEM MODE\n         L     R2,SASID                  GET BACK ID OF SAVED ASID\n         SSAR  R2\n         L     R11,COMMASCB              GET COMTASK ASCB\nRELLOCK  SETLOCK RELEASE,TYPE=CML,ASCB=(11),                           X\n               RELATED=(CONASCB,GETLOCK)\n         L     R13,R13SAVE\n         LH    R0,MASTCONS               GET MASTER CONSOLE\n         LA    R1,REPLYCMD               GET ADDRESS OF REPLYCOMAND\n         SVC   34\n         MVC   EXITRC(2),=H'0'\n         B     KEYEIGHT\n         DROP  R3,R4\nXMEMOFF  DS    0H\n         L     R15,TO24A2                NOW GO                 15OCT92\n         BSM   0,R15                       BACK TO              15OCT92\nTO24A2   DC    A(O24A2)                      REGULAR 24         15OCT92\nO24A2    DS    0H                              BIT MODE         15OCT92\n         L     R11,COMMASCB              GET COMTASK ASCB\n         SETLOCK RELEASE,TYPE=CML,ASCB=(11),                           X\n               RELATED=(CONASCB,GETLOCK)\n* HERE, IF EXITRC=0 THEN WE HAVE REPLIED, OTHERWISE, THE MESSAGE\n* WAS NOT OUTSTANDING.\n         SAC   X'000'                   GO BACK TO HOME ADDRESS SPACE\n         L     R2,SASID                 GET ID OF SAVED ASID\n         SSAR  R2\n         L     R13,R13SAVE\nKEYEIGHT DS    0H\n         MODESET KEY=NZERO,MODE=PROB\nENDPROG  DS    0H\n         LH    R9,EXITRC                SAVE RC                    RPS\n         LA    R1,WORKAREA_LEN          GET WORKAREA LEN FOR FREE  RPS\n         STORAGE RELEASE,LENGTH=(R1),ADDR=(R13)   FREE STORAGE     RPS\n         LR    R15,R9                   SET RC                     RPS\n         RETURN (14,12),T,RC=0          RETURN                     RPS\n\n         TITLE 'DATA CONSTANT'\nONE      DC    H'1'\n\n         TITLE 'SAVEAREA/WORKAREA'\n         DSECT\nWORKAREA DS    0F\nSAVEAREA DS    18F\nLOCKSAVE DS    6F            SAVE AREA FOR SETLOCK\nR13SAVE  DS    F             SAVE R13 FOR SETLOCK\nSASID    DS    F\nCONSASID DS    H\nEXITRC   DS    H\nMASTCONS DS    H\nCOMMASCB DS    F\nREPLYMSG DC    CL8' '\nIMSCOPY  DC    CL9' '\nREPLYTXT DC    CL90' '\nREPLYCMD DC    H'0',H'0'     REAL LENGTH, ZERO\n         DC    CL6'REPLY '   MVS COMMAND \"REPLY\"\nREPLYNUM DC    CL2' '\nREPLYCOM DC    C','          COMMA\nREPLYLNE DC    CL90' '\nWORKAREA_LEN   EQU  *-WORKAREA\n         TITLE 'DSECTS'\n         CVT   DSECT=YES\n         IHAORE\nUCM      DSECT\n         IEECUCM\n         IHAWQE\n         IHAPSA\n         END   REPLYLOA\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY REPLYLOA(''V 1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    REPLYLOA'\n PUNCH ' NAME     REPLYLOA(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RPSASM": {"ttr": 34572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x966_\\x00\\x97\\x00/\\x089\\x00s\\x00s\\x00\\x03\\xd9\\xd7\\xe2\\xf1@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1997-01-02T08:39:00", "lines": 115, "newlines": 115, "modlines": 3, "user": "RPS1"}, "text": "//RPSTSSO  JOB (WPARZS,WPA0SMSMD),'SHANNON',\n//             CLASS=A,MSGCLASS=H,NOTIFY=RPS,REGION=4096K\n//ASMTSSO PROC MEMBER=,RENT=NORENT\n//ASM    EXEC  PGM=ASMA90,REGION=6M,\n//         PARM=('&RENT,OBJECT,NODECK,SIZE(MAX,ABOVE),BATCH')\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT2   DD DSN=&&SYSUT2,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSUT3   DD DSN=&&SYSUT3,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSPUNCH DD SYSOUT=B\n//SYSLIN   DD DSN=&&OBJECT,DISP=(,PASS,DELETE),\n//         UNIT=VIO,SPACE=(CYL,(1,1))\n//SYSLIB   DD DISP=SHR,DSN=RPS1.CBT.FILE403\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DSN=RPS1.CBT.FILE403(&MEMBER),DISP=SHR\n//SYSTERM  DD SYSOUT=*\n//LKED     EXEC PGM=IEWL,REGION=6M,COND=(4,LT,ASM),\n//         PARM=(XREF,LIST,MAP,LET,NCAL,&RENT)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&&SYSUT1,UNIT=VIO,SPACE=(CYL,(20,20))\n//SYSLIN   DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DSN=SYS3.TSSO.LOADLIB,DISP=SHR\n//SYSIN DD DUMMY\n// PEND\n//*********************************************************************\n//* THE FIRST TWO MODULES ARE SUBROUTINES REQUIRED BY THE REST OF THE *\n//* MODULES.                                                          *\n//*********************************************************************\n//JCECVT   EXEC ASMTSSO,MEMBER=JCECVT,RENT=RENT\n//TSSOPARS EXEC ASMTSSO,MEMBER=TSSOPARS,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES HANDLE TSSO INITILIZATION.              *\n//*********************************************************************\n//TSSO     EXEC ASMTSSO,MEMBER=TSSO,RENT=RENT\n//TSSOINIT EXEC ASMTSSO,MEMBER=TSSOINIT,RENT=RENT\n//TSSOINI1 EXEC ASMTSSO,MEMBER=TSSOINI1,RENT=RENT\n//TSSOINI2 EXEC ASMTSSO,MEMBER=TSSOINI2,RENT=RENT\n//TSSOINI3 EXEC ASMTSSO,MEMBER=TSSOINI3,RENT=RENT\n//TSSOINI4 EXEC ASMTSSO,MEMBER=TSSOINI4,RENT=RENT\n//TSSOINI5 EXEC ASMTSSO,MEMBER=TSSOINI5,RENT=RENT\n//TSSOGSSC EXEC ASMTSSO,MEMBER=TSSOGSSC,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE TSSO MAINLINE CODE AND SUBS         *\n//*********************************************************************\n//TSSOMAIN EXEC ASMTSSO,MEMBER=TSSOMAIN,RENT=RENT\n//TSSOWTO  EXEC ASMTSSO,MEMBER=TSSOWTO,RENT=RENT\n//TSSOSS09 EXEC ASMTSSO,MEMBER=TSSOSS09,RENT=RENT\n//TSSOSS10 EXEC ASMTSSO,MEMBER=TSSOSS10,RENT=RENT\n//TSSOTERM EXEC ASMTSSO,MEMBER=TSSOTERM,RENT=RENT\n//TSSOESTA EXEC ASMTSSO,MEMBER=TSSOESTA,RENT=RENT\n//TSSODOCM EXEC ASMTSSO,MEMBER=TSSODOCM,RENT=RENT\n//TSSOCCMD EXEC ASMTSSO,MEMBER=TSSOCCMD,RENT=RENT\n//TSSLRACF EXEC ASMTSSO,MEMBER=TSSLRACF,RENT=RENT\n//TSSOLAOF EXEC ASMTSSO,MEMBER=TSSOLAOF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSO AND NCCF VERSION OF     *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//TSSOPREC EXEC ASMTSSO,MEMBER=TSSOPREC,RENT=RENT\n//TSSOPCMD EXEC ASMTSSO,MEMBER=TSSOPCMD,RENT=RENT\n//OSCMDATH EXEC ASMTSSO,MEMBER=OSCMDATH,RENT=RENT\n//OPCMDMSG EXEC ASMTSSO,MEMBER=OPCMDMSG,RENT=RENT\n//OSCMD    EXEC ASMTSSO,MEMBER=OSCMD,RENT=RENT\n//*  //NCFOSATH EXEC ASMTSSO,MEMBER=NCFOSATH,RENT=RENT\n//*  //NCFOSCMD EXEC ASMTSSO,MEMBER=NCFOSCMD,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES MAKE UP THE TSSO/OPF OSWAIT FACILITY.   *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSWAITRC EXEC ASMTSSO,MEMBER=OSWAITRC,RENT=RENT\n//OSWAIT   EXEC ASMTSSO,MEMBER=OSWAIT,RENT=RENT\n//*********************************************************************\n//* THE NEXT GROUP OF MODULES ARE THE TSSO/OPF OS FAMILY OF COMMANDS  *\n//* THE OSCMD FACILITY.                                               *\n//*********************************************************************\n//OSASK    EXEC ASMTSSO,MEMBER=OSASK,RENT=RENT\n//OSPAUSE  EXEC ASMTSSO,MEMBER=OSPAUSE,RENT=RENT\n//OSWTO    EXEC ASMTSSO,MEMBER=OSWTO,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULE IS THE TSSO CROSS MEMORY SERVICES ROUTINE.        *\n//*********************************************************************\n//TSSOGAPF EXEC ASMTSSO,MEMBER=TSSOGAPF,RENT=RENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE THE COMMANDS TO CONTROL TSSO/AOF.            *\n//*********************************************************************\n//DISPAOF  EXEC ASMTSSO,MEMBER=DISPAOF,RENT=NORENT\n//ALTAOF   EXEC ASMTSSO,MEMBER=ALTAOF,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES MAKE UP THE TSSO REPLY COMMAND PROCESSOR.        *\n//*********************************************************************\n//REPLYLOA EXEC ASMTSSO,MEMBER=REPLYLOA,RENT=RENT\n//REPLY    EXEC ASMTSSO,MEMBER=REPLY,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES ARE UTILITY COMMANDS THAT WORK WELL UNDER TSSO.  *\n//*********************************************************************\n//CACHE    EXEC ASMTSSO,MEMBER=CACHE,RENT=NORENT\n//CPCMD    EXEC ASMTSSO,MEMBER=CPCMD,RENT=NORENT\n//SPMON    EXEC ASMTSSO,MEMBER=SPMON,RENT=NORENT\n//VALLOC   EXEC ASMTSSO,MEMBER=VALLOC,RENT=NORENT\n//VOLSER   EXEC ASMTSSO,MEMBER=VOLSER,RENT=NORENT\n//*\n//*********************************************************************\n//* THE NEXT MODULES WERE WRITTEN BY BILL GODFREY...                  *\n//*********************************************************************\n//EF       EXEC ASMTSSO,MEMBER=EF,RENT=RENT\n//MULT     EXEC ASMTSSO,MEMBER=MULT,RENT=RENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUNASM": {"ttr": 34819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x11\\x00\\x11\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "TSSO403"}, "text": "//JJJJJJJJ JOB (3225,P136,99,99,9999),MSCHARE,CLASS=K,MSGCLASS=F,\n// NOTIFY=TSO67,REGION=2000K\n/*XEQ PYSPROD\n/*ROUTE PRINT PYSPROD\n//ASM EXEC ASMHCL,APARM='ZZZRENT,BATCH,TERM',LPARM='ZZZRENT',\n// XREF='''XREF(SHORT)'''\n//ASM.SYSLIB DD DSN=ISP.DUMMY.MACLIB,DISP=SHR,DCB=BUFNO=10\n//           DD DSN=TSSO.VERS43.ASM,DISP=SHR\n//           DD DSN=SYS1.MACLIB,DISP=SHR,VOL=SER=CSSRES,UNIT=3380\n//           DD DSN=SYS1.AMODGEN,DISP=SHR,VOL=SER=SMPGBL,UNIT=3380\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DSN=TSSO.VERS43.ASM(XXXXXXXX),DISP=SHR\n//ASM.SYSTERM DD SYSOUT=*\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSLMOD DD DSN=TSSO.VERS43.LOAD,DISP=SHR,\n//  UNIT=3380,VOL=SER=TSOXX1\n//LKED.SYSIN DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAMPPARM": {"ttr": 34821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00W\\x00W\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "TSSO403"}, "text": "***********************************************************************\n* THIS IS A TYPICAL TSSO PARAMETER DECK FOR A TYPICAL SYSTEM. THE     *\n* DOCUMENTATION IS   IN \"TSSO SYSTEM PROGRAMMERS GUIDE- RELEASE 4.3   *\n* THESE VALUES SHOULD WORK AS DEFAULTS.                               *\n* NOTE THAT THE ONLY NEW PARAMETER IN TSSO 4.3 IS THE NUMCONS PARM.   *\n* NOTE IN TSSO 4.3+   NEW PARAMETER OF MPFSUPP                        *\n***********************************************************************\nNONSWAP=Y\n************************************************************\n* TSSO WILL BE RUNNING NON-SWAPABBLE                       *\n************************************************************\n*\nTABLE=AOFIVP\n************************************************************\n* THE TABLE NAME FOR TSSO AOF WILL BE AOFIVP               *\n************************************************************\n*\nRACFID=TSSO\n************************************************************\n* TSSO WILL ASSUME A RACF USERID OF \"TSSO\" ON STARTUP      *\n************************************************************\n*\nSRC=#\n************************************************************\n* THE COMMAND RECOGNITION CHARACTER IS A POUND SIGN ('#')  *\n************************************************************\n*\nMAXCMDS=15\n************************************************************\n* TSSO WILL HANDLE AT MOST 15 SIMULTANEOUS COMMANDS        *\n************************************************************\n*\nMAXWTO=250\n************************************************************\n* TSSO WILL ISSUE AT MOST 250 WTOS FOR ANY ONE COMMAND     *\n************************************************************\n*\nPROMPT=NO\n************************************************************\n* DO NOT PROMPT THE MVS OPERATOR FOR ADDITIONAL TSSO       *\n* PARAMETERS                                               *\n************************************************************\n*\nSECSYS=RACF\n***********************************************************************\n* THE SECURITY SYSTEM IN USE WILL BE THE RESOURCE ACCESS CONTROL      *\n* FACILITY.                                                           *\n***********************************************************************\n*\nSECLEVEL=MINIMAL\n***********************************************************************\n* WE WILL BE USING THE \"MINIMAL\" LEVEL OF SECURITY, SO YOU CAN PHASE  *\n* IN CONSOLE SECURITY AT A LATER DATE.                                *\n***********************************************************************\n*\nSUBSYS 9 = TSSOSS09\n***********************************************************************\n* THE \"TSSOSS09\" ROUTINE, SUPPLIED WITH TSSO, WILL BE PROCESSING      *\n* THE WTO AND WTOR MESSAGES WHEN AOF IS ACTIVE. ANY OTHER SELECTION   *\n* MAY CAUSE TSSO TO FAIL.                                             *\n***********************************************************************\n*\nSUBSYS 10 = TSSOSS10\n***********************************************************************\n* THE \"TSSOSS10\" ROUTINE, SUPPLIED WITH TSSO, WILL BE PROCESSING      *\n* THE MVS AND SUBSYSTEM COMMANDS. ANY OTHER SELECTION MAY MAKE TSSO   *\n* FAIL.                                                               *\n***********************************************************************\n*\nTIMEOUT = 30\n***********************************************************************\n* IF THE SECLEVEL PARAMETER IS EVER SET TO \"MAX\", CONSOLES WILL TIME  *\n* OUT AFTER THIRTY MINUTES OF INACTIVITY...                           *\n***********************************************************************\n*\nNUMCONS = 10 DEDICATE\n***********************************************************************\n* TSSO WILL HAVE 10 SUBSYSTEM CONSOLES AT ITS DISPOSAL. ONE OF THESE  *\n* CONSOLES WILL BE DEDICATED TO THE TSSO ADDRESS SPACE.               *\n***********************************************************************\n*\nMPFSUPP = N\n***********************************************************************\n* TSSO WILL PROCESS ALL MESSAGES INCLUDING THOSE THAT MPF HAS         *\n* SUPPRESSED.                                                         *\n***********************************************************************\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEAGUGIP": {"ttr": 34824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01(\\x01(\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 296, "newlines": 296, "modlines": 0, "user": "TSSO403"}, "text": ".cm\n.CM      PDSDOC *UOW SCRIPT INPUT FOR DOCUMENTATION OF SEAG MODS......*\n.cm\n.co yes\n.sr pubMYhs = 1\n.ef set close\n.TT 1 ///\n.tm +2\n.ss\n.im syspub layout=manual ju=no hy=no ll=76\n.pl 70\n.point set 1 1 1\n.sr pubFNsup = nosup\n.sr pubSWinc = 4\n.sr pubSWpch = 0\n.cm .sr pubFIhdr = 'EXAMPLE'\n.major PART\n.ll 76\n.ad 0\n.CM      PDSDOC *DOCUMENTATION ON SPRECHER MODS TO TSSO FOR MLWTO.....*\n.titlepage\nTSSO Release 4.3\n.sp 5\nAOF PROCESSING\n.sp\nOF\n.sp\nMULTI LINE\n.sp\nWTO MESSAGES\n.sp 30\nDavid Cartwright\nSprecher Energie AG\nCH-5036 OBERENTFELDEN\nSwitzerland\n.prelim 'Abstract'\nThis paper describes the changes made to TSSO AOF processing at the\nSprecher Energie computer centre in Switzerland to handle Multi-Line WTO\nmessages such as the VTAM error message IST663I.\n.chapter 'TEXT'\n.sr pubCHrom = 0\n.section 'BACKGROUND'\nSprecher Energie AG only run two shifts, the night work is handled by\nOPC/A without an Operator being present. If Production jobs fail\novernight our OPC/A exit (see CBT File 172) will 'BLEEP' the duty\nAnalyst who dials into TSO with a portable PC and tries to fix the\nproblem. Thus if we don't hear an alarm, we think that everything is OK.\nOn the night of 3-4 July 1992 nobody heard an alarm, but things were\ndefinitely not OK. One of our non-IBM 3174 compatible controllers\nsuffered some sort of aberration, and refused all BIND requests. VTAM\nissued the message set IST663I, IST664I, IST889I and IST314I describing\nthe BIND FAILURE with SENSE=080A0000, an unconditional BIND Reject. VTAM\nimmediately re-tried the BIND which was immediately refused in a\nsequence which went on throughout the night. Because VTAM runs at a high\ndispatching priority it tied up one hundred percent of the CPU and\nnothing else ran. Our online systems were three hours late starting the\nnext morning. Although this was the first time this failure had occured\nin four years of processing, it was so severe that we had to find some\nway to handle it. There may well be some VTAM parameter to define the\nretry time, but our VTAM expertise was not great enough to find it. We\nthought we could automate the handling of IST663I to forestall a\nrepetition of this problem. The console automation tool we run is\n'TSSO' Release 4.3 from File 401 of the CBT Tape Level 321. When we\nlooked at the automation of messages IST663I and IST664I we ran into a\nbasic problem; these messages are both data lines of a Multi-Line WTO,\nand TSSO cannot handle Multi-Line WTO's. We have modified TSSO to be\nable to process these messages, and this paper documents the new\nprocessing options.\n.section 'TSSO AUTOMATED OPERATIONS FACILITY'\nThe User should be familiar with the basic operation of TSSO AOF as\ndocumented in the User's Guide provided by Bellcore Inc. on file 401 of\nthe CBT tape. This paper will only document the new and changed operands\nprovided by these modifications.\n.subsection 'TABENTRY OPERANDS'\nThe TABENTRY macro, and the AOF processing of the table, have been\nchanged significantly, although a reasonable degree of downwards\ncompatibility has been maintained.\n.subsub 'The Entry-Id Operand'\nA significant change which can trap the unwary has nothing to do with\nMLWTO processing, but is designed to reduce the overhead of running\nTSSO. Previously TSSO would scan the entire AOF table for every message,\neven after a match had been found. We have changed this logic such that\n.ud set ]\nif a match is found,\n.ul and_no_Entry_Id_is_provided],\nAOF processing for that message will end without scanning the rest of\nthe table. Note that this logic only works when a match is found,\nincluding any TEST operands. Several entries can be created for the same\nmessage with different TEST operands, and each will be processed\nuntil the TEST is matched. If there is no Entry-Id processing will stop\nat that point. Thus if the User wants more than one action to be\nperformed on a message, Entry-Ids must be provided on each TABENTRY\nmacro except\n.fignum entryid\n.ur the last. Example &entryid shows this processing applied to the\nIEF238D allocation recovery message. Only one of these entries will be\nprocessed, depending on if and when the 'WAIT' option\nappears. Conversely\n.fignum clrdump\n.ur Example &clrdump shows two entries for a message which will both\nbe processed when IEA994A appears.\n.sp\nUsers installing these mods to TSSO should check their existing AOF\ntables to ensure that this condition is met, because it is a change\nwhich is not downwards compatible.\n.subsub 'The TEXT Operand'\nIn vanilla TSSO it is legal to code a 'TEXT=' operand where it makes no\nsense, even when ACTION=POST is coded. An entry with this combination\nwill overwrite the AOF table in storage when triggered, the results of\nwhich are unpredictable. We encountered this problem during testing when\nwe changed an AOF table entry to 'ACTION=POST' without deleting all the\nprevious operands. Therefore logic has been added to the TABENTRY macro\nto generate an MNOTE for this error and to ignore the TEXT operand.\n.subsub 'The TEST Operand'\nSprecher Energie have added a new test with the form 'L,nn' where 'nn'\nis the Line Number which must match the count of the current\nline of a Multi-Line WTO. Any tests previous to the 'L,nn' operand will\nonly be performed on the first line. If this operand is specified for\nmessages which are not Multi-Line WTO's an error message will be\ngenerated when the Table entry is triggered. If this test is satisfied\nit has important consequencies. All subsequent processing for this AOF\nTable entry will be performed on the specified Line Number of the\nMulti-Line WTO. This means that data from the previous line(s) cannot be\nincorporated in TEXT specifications, only data from the specified line.\nIf further tests are specified they only be applied to the specified\nline, not to any previous line, including the first. Because the line\nnumber being processed is an operand of TEST, it does not make sense to\nhave more than one 'L,nn' operand - such tests will always\n.fignum nobind\n.ur\nfail. Example &nobind shows an entry for the multi line VTAM error\nmessage IST663I. In this case the first line will be tested for\nparticular Status indicators, then processing will be switched to the\nsecond line to pick up the LU Name for the TEXT.\n.subsub 'The ACTION Operand'\nSprecher Energie have introduced the option 'ACTION=NONE', which is\nanalogous to IEFBR14 for batch jobs. As it suggests, it terminates\nprocessing for the entry at that point without actually doing anything.\nHowever, in conjunction with the new Entry-Id processing it may be used\nto restrict the processing performed on frequently occurring messages\nto conserve resource\n.fignum stopit\n.ur utilisation. Example &stopit shows the entry for IST663I previously\n.ur shown in Example &nobind, but with an additional entry that will\nprevent TSSO from running through the entire AOF Table for every line of\nthe multi-line message IST663I. Unconditional BIND failure messages will\nbe handled by the first entry, every other error will stop at the second\nentry.\n.subsection 'DISPAOF Command'\nThe DISPAOF command has been changed to display the 'L,nn' operand\nintroduced by Sprecher Energie.\n.section 'MPF SUPPRESSION'\nAs documented above, we did some work to reduce the overhead of running\nTSSO by defining common message with ACTION=NONE. We then found that you\ncould reproduce most of the MPF list with this parameter. It seemed\nillogical to have two points of control for message suppression, so we\nadded a small check in AOF processing for MPF suppressed messages. If\ntrue, AOF stopped at that point. Now the MPF list becomes the most\nimportant message suppression mechanism, as it should be. If you want to\nprocess a message with TSSO, remove it from the MPF list (if you use\nLOGAN from CBT file270 you may want to leave it in with SUP(NO)). The\nmessage is then eligible for AOF processing, which may itself suppress\nthe message.\n.pa\n.section 'THEORY OF OPERATION'\nTo get the most from the Sprecher Energie mods it helps to understand\nhow AOF works. The Communications Task builds a copy of each WQE in CSA\nbefore branching to the Sub-System Exit (HASPEXIT). The Sub-System\nInterface passes each eligible Sub-System via SSI Code 09 (WTO\nCommunication) the address of the normal WQE for single line WTO's. For\nmulti-line WTO's it may pass the address of the Major WQE with no Minor\nWQE on the first call, or both a Major and Minor WQE address on\nsubsequent calls. However, it is important to remember that these\naddresses are those of the dummy WQE in CSA, not the real WQE in the\nComms Task address space. This may change in MVS/ESA 4.2.2, where\nWTL's at least are created in ECSA. They may still be copied to CSA for\nthe Sub-System Interface, that information is not available\nat the time of writing.\n.sp\nOne eligible Sub-System is TSSO, and the module TSSOSS09 handles this\nfunction. It has three distinct segments, but we are only concerned with\nthe last one, which is WQE processing. After checking that MPF has not\nsuppressed this message, it separates the message number, or at least\nthe first eight characters of the data. This in itself can cause\nproblems, because the Comms Task shuffles the message about a bit to put\nin various flags depending on whether it is issued by an Authorised\nprogram or not. Assuming it has got the right message identifier, it\nstarts to scan the AOF table for this message, or for a generic message\nprocessing entry with '*' specified as the message identifier. If a\nmatch is found for one of these two tests, it goes on to process the\n'TEST=' operands. If the tests are satisfied it tests that MATCHLIM has\nnot been reached and then performs the 'ACTION' specified. Standard TSSO\nRelease 4.3 will then go round to test the remaining entries in the AOF\ntable. However, it will only perform WQE processing for Normal WQE's and\nfor Major WQE's with no Minor. It will ignore subsequent calls for each\nMinor WQE of the Major.\n.sp\nA fundamental change is that the Sprecher Energie version will process\neach and every non MPF-suppressed WQE, whether it is Normal, Major or\nMinor. Normal WQE processing is much as before, therefore I will\nconcentrate on Multi-Line WTO's. The message number is always extracted\nfrom the Major WQE, so for example it is not possible to define\nprocessing for the specific message number IST664I because that number\nappears in a Minor WQE. If a specific or generic entry is found in the\nAOF table processing continues with the TEST operands, if any. If there\nare none there is a danger that the ACTION specified will be performed\nfor every line of the multi-line WTO, which is probably not required -\nbe careful. Tests are carried out on the Major WQE until the 'L,nn'\noperand is detected. It would be nice to run the chain of Minor WQE's,\nbut unless you care to write the code to go cross memory into the Comms\nTask address space you cannot do that, so our code uses data areas in\nthe AOF table to keep a count of the number of times it has been entered\nfor this Major WQE. When this count matches the Line Number specified as\na TEST, all subsequent processing switches to the text in the Minor WQE.\nThis includes any further tests and all ACTION processing. This does\nmean that you cannot mix data from the Major and the Minor WQE's in any\nTEXT specification. If this is\n.ul not] the Line Number required the TEST fails and TSSO will continue\nto run up the AOF table looking for a match on the message number (of\nthe Major WQE) or for generic ('*') entries. It is to handle this\nsituation that we added the 'ACTION=NONE' operand.\n.chapter 'Examples'\n.pa\n.ss\n.figbegin\n.boxon\n*\n* REPLY 'WAIT' TO 'DEVICE NAME, WAIT OR CANCEL'\n* 04SEP92 CART1 ADDED 'CANCEL' IF 'WAIT' IS NOT AN OPTION.\n*\n*\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,4,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,5,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,6,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X\n               TEST=((W,7,4,'WAIT',''''))\n         TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='CANCEL'\n*\n.figure entryid 'MULTIPLE CHOICE ENTRIES'\n.figend\n.sp 3\n.figbegin\n.boxon\n*\n*\n* PROCESS SYSTEM DUMP MESSAGES\n*\n*\nCLRDUMP  TABENTRY MSG=IEA994A,ACTION=OSCMD,                            X\n               TEXT='DD CLEAR,DSN=(01-02)'\n         TABENTRY MSG=IEA994A,ACTION=LOWLIGHT\n*\n*\n.figure clrdump 'MULTIPLE ACTION ENTRIES'\n.figend\n.figbegin\n.boxon\n*\n* UNCONDITIONAL BIND REJECT\n* THIS ENTRY REQUIRES MLWTO SUPPORT\n*\n         TABENTRY MSG=IST663I,ACTION=OSCMD,                            X\n               TEST=((W,02,04,'INIT',' '),(W,07,08,'080A0000','=. '),  X\n               (L,2)),                                                 X\n               TEXT='V NET,INACT,ID=\\S028,08\\,F'\n*\n.figure nobind 'MULTI-LINE WTO TESTS'\n.figend\n.figbegin\n.boxon\n*\n* THESE ENTRIES REQUIRE MLWTO SUPPORT\n*\n* 1) UNCONDITIONAL BIND REJECT\n*\n         TABENTRY MSG=IST663I,ACTION=OSCMD,                            X\n               TEST=((W,02,04,'INIT',' '),(W,07,08,'080A0000','=. '),  X\n               (L,02)),                                                X\n               TEXT='V NET,INACT,ID=\\S028,08\\,F'\n*\n* 2) STOP PROCESSING ANY OTHER IST663I MAJOR OR MINOR WQE\n*\n         TABENTRY MSG=IST663I,ACTION=NONE\n*\n.figure stopit 'RESOURCE CONSUMPTION LIMITATION'\n.figend\n.br\n.pa\n.sp 10\n.ce on\n*** END ***\n.ce off\n.qu\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SEAGUGJC": {"ttr": 34830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x07\\x00\\x07\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "TSSO403"}, "text": "//SALBERTA  JOB  (U32048,DCSG),GUY,CLASS=R,MSGCLASS=T\n//  EXEC PGM=IEBGENER\n//SYSPRINT  DD  SYSOUT=Z\n//SYSIN   DD  DUMMY\n//SYSUT1  DD  DSN=SFTB.TSSO43.ASM1(SEAGUGOP),DISP=SHR,\n//   DCB=RECFM=FBA\n//SYSUT2  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEAGUGOP": {"ttr": 34832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x01x\\x01x\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 376, "newlines": 376, "modlines": 0, "user": "TSSO403"}, "text": "1\n-\n-\n-\n0                              TSSO Release 4.3\n-\n-                               AOF PROCESSING\n0                                     OF\n0                                 MULTI LINE\n0                                WTO MESSAGES\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n                               David Cartwright\n                             Sprecher Energie AG\n                            CH-5036 OBERENTFELDEN\n                                 Switzerland\n1\n-\n-\n-\n0                                  ABSTRACT\n+                                  ABSTRACT\n-This paper describes the changes made to TSSO AOF processing at the Sprecher\n Energie computer centre in Switzerland to handle Multi-Line WTO messages\n such as the VTAM error message IST663I.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0                                   - ii -\n1\n-\n-\n-\n0                                   PART 1\n+                                   PART 1\n0                                    TEXT\n+                                    TEXT\n-\n 1.   BACKGROUND\n+1.   BACKGROUND\n+     __________\n0Sprecher Energie AG only run two shifts, the night work is handled by OPC/A\n without an Operator being present. If Production jobs fail overnight our\n OPC/A exit (see CBT File 172) will 'BLEEP' the duty Analyst who dials into\n TSO with a portable PC and tries to fix the problem. Thus if we don't hear\n an alarm, we think that everything is OK.  On the night of 3-4 July 1992\n nobody heard an alarm, but things were definitely not OK. One of our non-IBM\n 3174 compatible controllers suffered some sort of aberration, and refused\n all BIND requests. VTAM issued the message set IST663I, IST664I, IST889I and\n IST314I describing the BIND FAILURE with SENSE=080A0000, an unconditional\n BIND Reject. VTAM immediately re-tried the BIND which was immediately\n refused in a sequence which went on throughout the night. Because VTAM runs\n at a high dispatching priority it tied up one hundred percent of the CPU and\n nothing else ran. Our online systems were three hours late starting the next\n morning. Although this was the first time this failure had occured in four\n years of processing, it was so severe that we had to find some way to handle\n it. There may well be some VTAM parameter to define the retry time, but our\n VTAM expertise was not great enough to find it. We thought we could automate\n the handling of IST663I to forestall a repetition of this problem. The\n console automation tool we run is 'TSSO' Release 4.3 from File 401 of the\n CBT Tape Level 321. When we looked at the automation of messages IST663I and\n IST664I we ran into a basic problem; these messages are both data lines of a\n Multi-Line WTO, and TSSO cannot handle Multi-Line WTO's. We have modified\n TSSO to be able to process these messages, and this paper documents the new\n processing options.\n-\n 2.   TSSO AUTOMATED OPERATIONS FACILITY\n+2.   TSSO AUTOMATED OPERATIONS FACILITY\n+     ____ _________ __________ ________\n0The User should be familiar with the basic operation of TSSO AOF as\n documented in the User's Guide provided by Bellcore Inc. on file 401 of the\n CBT tape. This paper will only document the new and changed operands\n provided by these modifications.\n-\n-\n-\n-                                   - 1 -\n1\n-\n-2.1   TABENTRY OPERANDS\n+2.1   TABENTRY OPERANDS\n+      ________ ________\n0The TABENTRY macro, and the AOF processing of the table, have been changed\n significantly, although a reasonable degree of downwards compatibility has\n been maintained.\n-\n 2.1.1   The Entry-Id Operand\n+2.1.1   The Entry-Id Operand\n0A significant change which can trap the unwary has nothing to do with MLWTO\n processing, but is designed to reduce the overhead of running TSSO.\n Previously TSSO would scan the entire AOF table for every message, even\n after a match had been found. We have changed this logic such that if a\n match is found, and_no_Entry_Id_is_provided, AOF processing for that message\n+                ___ __ _____ __ __ ________\n will end without scanning the rest of the table. Note that this logic only\n works when a match is found, including any TEST operands. Several entries\n can be created for the same message with different TEST operands, and each\n will be processed until the TEST is matched. If there is no Entry-Id\n processing will stop at that point. Thus if the User wants more than one\n action to be performed on a message, Entry-Ids must be provided on each\n TABENTRY macro except the last. Example 1 shows this processing applied to\n the IEF238D allocation recovery message. Only one of these entries will be\n processed, depending on if and when the 'WAIT' option appears. Conversely\n Example 2 shows two entries for a message which will both be processed when\n IEA994A appears.\n0Users installing these mods to TSSO should check their existing AOF tables\n to ensure that this condition is met, because it is a change which is not\n downwards compatible.\n-\n 2.1.2   The TEXT Operand\n+2.1.2   The TEXT Operand\n0In vanilla TSSO it is legal to code a 'TEXT=' operand where it makes no\n sense, even when ACTION=POST is coded. An entry with this combination will\n overwrite the AOF table in storage when triggered, the results of which are\n unpredictable. We encountered this problem during testing when we changed an\n AOF table entry to 'ACTION=POST' without deleting all the previous operands.\n Therefore logic has been added to the TABENTRY macro to generate an MNOTE\n for this error and to ignore the TEXT operand.\n-\n 2.1.3   The TEST Operand\n+2.1.3   The TEST Operand\n0Sprecher Energie have added a new test with the form 'L,nn' where 'nn' is\n the Line Number which must match the count of the current line of a\n Multi-Line WTO. Any tests previous to the 'L,nn' operand will only be\n performed on the first line. If this operand is specified for messages which\n are not Multi-Line WTO's an error message will be generated when the Table\n entry is triggered. If this test is satisfied it has important\n consequencies. All subsequent processing for this AOF Table entry will be\n performed on the specified Line Number of the Multi-Line WTO. This means\n-                                   - 2 -\n1\n-\n-that data from the previous line(s) cannot be incorporated in TEXT\n specifications, only data from the specified line.  If further tests are\n specified they only be applied to the specified line, not to any previous\n line, including the first. Because the line number being processed is an\n operand of TEST, it does not make sense to have more than one 'L,nn' operand\n - such tests will always fail. Example 3 shows an entry for the multi line\n VTAM error message IST663I. In this case the first line will be tested for\n particular Status indicators, then processing will be switched to the second\n line to pick up the LU Name for the TEXT.\n-\n 2.1.4   The ACTION Operand\n+2.1.4   The ACTION Operand\n0Sprecher Energie have introduced the option 'ACTION=NONE', which is\n analogous to IEFBR14 for batch jobs. As it suggests, it terminates\n processing for the entry at that point without actually doing anything.\n However, in conjunction with the new Entry-Id processing it may be used to\n restrict the processing performed on frequently occurring messages to\n conserve resource utilisation. Example 4 shows the entry for IST663I\n previously shown in Example 3, but with an additional entry that will\n prevent TSSO from running through the entire AOF Table for every line of the\n multi-line message IST663I. Unconditional BIND failure messages will be\n handled by the first entry, every other error will stop at the second entry.\n-\n 2.2   DISPAOF Command\n+2.2   DISPAOF Command\n+      _______ _______\n0The DISPAOF command has been changed to display the 'L,nn' operand\n introduced by Sprecher Energie.\n-\n 3.   MPF SUPPRESSION\n+3.   MPF SUPPRESSION\n+     ___ ___________\n0As documented above, we did some work to reduce the overhead of running TSSO\n by defining common message with ACTION=NONE. We then found that you could\n reproduce most of the MPF list with this parameter. It seemed illogical to\n have two points of control for message suppression, so we added a small\n check in AOF processing for MPF suppressed messages. If true, AOF stopped at\n that point. Now the MPF list becomes the most important message suppression\n mechanism, as it should be. If you want to process a message with TSSO,\n remove it from the MPF list (if you use LOGAN from CBT file270 you may want\n to leave it in with SUP(NO)). The message is then eligible for AOF\n processing, which may itself suppress the message.\n-\n-\n-\n-                                   - 3 -\n1\n-\n-4.   THEORY OF OPERATION\n+4.   THEORY OF OPERATION\n+     ______ __ _________\n0To get the most from the Sprecher Energie mods it helps to understand how\n AOF works. The Communications Task builds a copy of each WQE in CSA before\n branching to the Sub-System Exit (HASPEXIT). The Sub-System Interface passes\n each eligible Sub-System via SSI Code 09 (WTO Communication) the address of\n the normal WQE for single line WTO's. For multi-line WTO's it may pass the\n address of the Major WQE with no Minor WQE on the first call, or both a\n Major and Minor WQE address on subsequent calls. However, it is important to\n remember that these addresses are those of the dummy WQE in CSA, not the\n real WQE in the Comms Task address space. This may change in MVS/ESA 4.2.2,\n where WTL's at least are created in ECSA. They may still be copied to CSA\n for the Sub-System Interface, that information is not available at the time\n of writing.\n0One eligible Sub-System is TSSO, and the module TSSOSS09 handles this\n function. It has three distinct segments, but we are only concerned with the\n last one, which is WQE processing. After checking that MPF has not\n suppressed this message, it separates the message number, or at least the\n first eight characters of the data. This in itself can cause problems,\n because the Comms Task shuffles the message about a bit to put in various\n flags depending on whether it is issued by an Authorised program or not.\n Assuming it has got the right message identifier, it starts to scan the AOF\n table for this message, or for a generic message processing entry with '*'\n specified as the message identifier. If a match is found for one of these\n two tests, it goes on to process the 'TEST=' operands. If the tests are\n satisfied it tests that MATCHLIM has not been reached and then performs the\n 'ACTION' specified. Standard TSSO Release 4.3 will then go round to test the\n remaining entries in the AOF table. However, it will only perform WQE\n processing for Normal WQE's and for Major WQE's with no Minor. It will\n ignore subsequent calls for each Minor WQE of the Major.\n0A fundamental change is that the Sprecher Energie version will process each\n and every non MPF-suppressed WQE, whether it is Normal, Major or Minor.\n Normal WQE processing is much as before, therefore I will concentrate on\n Multi-Line WTO's. The message number is always extracted from the Major WQE,\n so for example it is not possible to define processing for the specific\n message number IST664I because that number appears in a Minor WQE. If a\n specific or generic entry is found in the AOF table processing continues\n with the TEST operands, if any. If there are none there is a danger that the\n ACTION specified will be performed for every line of the multi-line WTO,\n which is probably not required - be careful. Tests are carried out on the\n Major WQE until the 'L,nn' operand is detected. It would be nice to run the\n chain of Minor WQE's, but unless you care to write the code to go cross\n memory into the Comms Task address space you cannot do that, so our code\n uses data areas in the AOF table to keep a count of the number of times it\n has been entered for this Major WQE. When this count matches the Line Number\n specified as a TEST, all subsequent processing switches to the text in the\n Minor WQE.  This includes any further tests and all ACTION processing. This\n does mean that you cannot mix data from the Major and the Minor WQE's in any\n TEXT specification. If this is not the Line Number required the TEST fails\n+                               ___\n and TSSO will continue to run up the AOF table looking for a match on the\n message number (of the Major WQE) or for generic ('*') entries. It is to\n handle this situation that we added the 'ACTION=NONE' operand.\n-\n                                    - 4 -\n1\n-\n-\n-\n0                                   PART 2\n+                                   PART 2\n0                                  EXAMPLES\n+                                  EXAMPLES\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0                                   - 5 -\n1\n-\n-\u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n |                                                                          |\n |  *                                                                       |\n |  * REPLY 'WAIT' TO 'DEVICE NAME, WAIT OR CANCEL'                         |\n |  * 04SEP92 CART1 ADDED 'CANCEL' IF 'WAIT' IS NOT AN OPTION.              |\n |  *                                                                       |\n |  *                                                                       |\n |           TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X|\n |                 TEST=((W,4,4,'WAIT',''''))                               |\n |           TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X|\n |                 TEST=((W,5,4,'WAIT',''''))                               |\n |           TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X|\n |                 TEST=((W,6,4,'WAIT',''''))                               |\n |           TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='WAIT',                X|\n |                 TEST=((W,7,4,'WAIT',''''))                               |\n |           TABENTRY MSG=IEF238D,ACTION=REPLY,TEXT='CANCEL'                |\n |  *                                                                       |\n |                                                                          |\n |                                                                          |\n |                    Figure 1:  MULTIPLE CHOICE ENTRIES                    |\n |                                                                          |\n \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-\n-\n \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n |                                                                          |\n |  *                                                                       |\n |  *                                                                       |\n |  * PROCESS SYSTEM DUMP MESSAGES                                          |\n |  *                                                                       |\n |  *                                                                       |\n |  CLRDUMP  TABENTRY MSG=IEA994A,ACTION=OSCMD,                            X|\n |                 TEXT='DD CLEAR,DSN=(01-02)'                              |\n |           TABENTRY MSG=IEA994A,ACTION=LOWLIGHT                           |\n |  *                                                                       |\n |  *                                                                       |\n |                                                                          |\n |                                                                          |\n |                    Figure 2:  MULTIPLE ACTION ENTRIES                    |\n |                                                                          |\n \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-\n-\n-\n-\n                                    - 6 -\n1\n-\n-\u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n |                                                                          |\n |  *                                                                       |\n |  * UNCONDITIONAL BIND REJECT                                             |\n |  * THIS ENTRY REQUIRES MLWTO SUPPORT                                     |\n |  *                                                                       |\n |           TABENTRY MSG=IST663I,ACTION=OSCMD,                            X|\n |                 TEST=((W,02,04,'INIT',' '),(W,07,08,'080A0000','=. '),  X|\n |                 (L,2)),                                                 X|\n |                 TEXT='V NET,INACT,ID=\\S028,08\\,F'                        |\n |  *                                                                       |\n |                                                                          |\n |                                                                          |\n |                     Figure 3:  MULTI-LINE WTO TESTS                      |\n |                                                                          |\n \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-\n \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n |                                                                          |\n |  *                                                                       |\n |  * THESE ENTRIES REQUIRE MLWTO SUPPORT                                   |\n |  *                                                                       |\n |  * 1) UNCONDITIONAL BIND REJECT                                          |\n |  *                                                                       |\n |           TABENTRY MSG=IST663I,ACTION=OSCMD,                            X|\n |                 TEST=((W,02,04,'INIT',' '),(W,07,08,'080A0000','=. '),  X|\n |                 (L,02)),                                                X|\n |                 TEXT='V NET,INACT,ID=\\S028,08\\,F'                        |\n |  *                                                                       |\n |  * 2) STOP PROCESSING ANY OTHER IST663I MAJOR OR MINOR WQE               |\n |  *                                                                       |\n |           TABENTRY MSG=IST663I,ACTION=NONE                               |\n |  *                                                                       |\n |                                                                          |\n |                                                                          |\n |                Figure 4:  RESOURCE CONSUMPTION LIMITATION                |\n |                                                                          |\n \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-\n-\n-\n0                                *** END ***\n-\n-\n                                    - 7 -\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETMODE": {"ttr": 35079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\xac\\x00\\xac\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 172, "newlines": 172, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&SETLBL  SETMODE  &MODE=,&MODESV=\n.*                                                                   *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n.*                                                                   *.\n.*  SETMODE        SET THE PSW AMODE BIT, SAVING THE CURRENT AMODE   *.\n.*                                                                   *.\n.* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *.\n.*                                                                   *.\n.*  OPERANDS       NAME       VALUE         MEANING                  *.\n.*                 ----       -----         -------                  *.\n.*                                                                   *.\n.*                 MODE       24            SET AMODE TO 24          *.\n.*                                                                   *.\n.*                            31            SET AMODE TO 31          *.\n.*                                                                   *.\n.*                            RX-ADDRESS    ADDRESS OF A FULLWORD    *.\n.*                                          SAVE AREA FOR AMODE; IT  *.\n.*                                          IS SAVED IN THE LEFTMOST *.\n.*                                          BIT, WITH THE REMAINING  *.\n.*                                          BITS SET TO BINARY ZEROES*.\n.*                                                                   *.\n.*                            REGISTER IN   REGISTER NUMBER OTHER    *.\n.*                            PARENTHESES   THAN R14 TO BE USED AS   *.\n.*                                          A SAVE AREA FOR AMODE;   *.\n.*                                          IT IS SET AS FOR THE     *.\n.*                                          RX-ADDRESS               *.\n.*                                                                   *.\n.*                 MODESV     RX-ADDRESS    ADDRESS OF A FULLWORD    *.\n.*                                          SAVE AREA FOR AMODE; IT  *.\n.*                                          IS SAVED IN THE LEFTMOST *.\n.*                                          BIT, WITH THE REMAINING  *.\n.*                                          BITS SET TO BINARY ZEROES*.\n.*                                                                   *.\n.*                            REGISTER IN   REGISTER NUMBER TO BE    *.\n.*                            PARENTHESES   USED AS A SAVE AREA FOR  *.\n.*                                          AMODE; IT IS SET AS FOR  *.\n.*                                          THE RX-ADDRESS           *.\n.*                                                                   *.\n.*                 SETLBL     VALID LABEL   USED TO ASSOCIATE LABEL  *.\n.*                                          WITH MACRO EXPANSION     *.\n.*                                                                   *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n         SPACE 3\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n.*                                                                   *.\n.*  NOTES:         1.  IF MVS/SP 1 IS THE ACTIVE OPERATING SYSTEM,   *.\n.*                     NOTHING IS DONE                               *.\n.*                                                                   *.\n.*                 2.  THE MACRO ALTERS REGISTER 14 IN ALL CASES     *.\n.*                                                                   *.\n.*                                                                   *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n.*\n.*\n.*\n         LCLC  &NDX                                SHORTENED &SYSNDX\n.*\n.*\n.*\n&NDX     SETC  '&SYSNDX'                           GET &SYSNDX\n.*\n.*  VALIDATE OPERANDS: ARE BOTH OMITTED?\n.*\n         AIF   (T'&MODE EQ 'O' AND T'&MODESV EQ 'O').BERR      OMITTED?\n.*\n.*  VALIDATE MODE\n.*\n         AIF   (T'&MODE EQ 'O').NOMODE                         NO MODE?\n         AIF   ('&MODE' EQ '24').MOK                           AMODE 24\n         AIF   ('&MODE' EQ '31').MOK                           AMODE 31\n         AIF   ('&MODE'(1,1) EQ '(').MOK                       (REG)\n         AIF   ('&MODE'(K'&MODE,1) EQ ')').MOK                 RX ADDR\n         AIF   ('&MODE'(1,1) EQ '0').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '1').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '2').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '3').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '4').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '5').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '6').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '7').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '8').MERR                      ERROR\n         AIF   ('&MODE'(1,1) EQ '9').MERR                      ERROR\n.*\n.MOK     AGO   .GENCODE                                        GEN CODE\n.*\n.*  GENERATE CODE TO SAVE CURRENT AMODE WITHOUT SETTING A NEW AMODE\n.*\n.NOMODE  ANOP\n&SETLBL  LA    R14,1                  R14 = 1\n         SLL   R14,30                 MOVE TO BIT 1\n         LA    R14,0(R14)             CLEAR HIGH ORDER BIT/BYTE\n         SLL   R14,1                  MOVE TO BIT 0; BIT 0 = AMODE\n         AIF   ('&MODESV'(1,1) EQ '(').MSVR1                  REGISTER\n         ST    R14,&MODESV            SAVE CURRENT AMODE IN STORAGE\n         AGO   .DONE                                          FINISHED\n.MSVR1   LR    &MODESV(1),R14         SAVE CURRENT AMODE IN REGISTER\n         AGO   .DONE                                          FINISHED\n.*\n.*  GENERATE CODE TO SET NEW AMODE\n.*\n.GENCODE ANOP\n&SETLBL  L     R14,16                 R14 --> CVT\n         L     R14,116(R14)           R14 --> CVTDCB FIELD\n         SRL   R14,31                 ISOLATE BIT 0 -- THE MVS/SP BIT\n         LTR   R14,R14                IS OPERATING SYSTEM MVS/SP 2?\n         AIF   (T'&MODESV EQ 'O').NMSV1                       NO MODESV\n         BZ    ##E&NDX                IF NOT, ZERO MODE SAVE AREA\n         AGO   .GEN1                                          CONTINUE\n.NMSV1   BZ    ##F&NDX                IF NOT, DO NOTHING\n.GEN1    AIF   ('&MODE' EQ '24').GEN24                        MODE 24\n         AIF   ('&MODE' EQ '31').GEN31                        MODE 31\n         AIF   ('&MODE'(1,1) EQ '(').MR                       REGISTER\n         L     R14,&MODE              R14  =  NEW AMODE\n         LTR   R14,R14                TEST FOR NEW AMODE\n         AGO   .GEN1A                                         CONTINUE\n.MR      LTR   R14,&MODE(1)           R14  =  NEW AMODE\n.GEN1A   CNOP  0,4                    ALIGN ON FULLWORD\n         BM    *+16                   SET FOR NEW AMODE = 31\n         L     R14,*+8                R14  =  AMODE 24 \u00a6\u00a6 AFTER BSM\n         B     *+20                   ISSUE BSM\n         AIF   (T'&MODESV EQ 'O').NMSV3                       NO MODESV\n         DC    A(##G&NDX)             SET FOR NEW AMODE = 24\n         AGO   .GEN1B                                         CONTINUE\n.NMSV3   DC    A(##F&NDX)             SET FOR NEW AMODE = 24\n.GEN1B   L     R14,*+8                R14  =  AMODE 31 \u00a6\u00a6 AFTER BSM\n         B     *+8                    ISSUE BSM\n         AIF   (T'&MODESV EQ 'O').NMSV4                       NO MODESV\n         DC    A(##G&NDX+X'80000000') SET FOR NEW AMODE = 31\n         AGO   .GENBSM                                        CONTINUE\n.NMSV4   DC    A(##F&NDX+X'80000000') SET FOR NEW AMODE = 31\n         AGO   .GENBSM                                        CONTINUE\n.GEN24   CNOP  0,4                    ALIGN ON FULLWORD\n         L     R14,*+8                R14  =  AMODE \u00a6\u00a6 AFTER BSM\n         B     *+8                    ISSUE BSM\n         AIF   (T'&MODESV EQ 'O').NMSV5                       NO MODESV\n         DC    A(##G&NDX)             SET FOR NEW AMODE = 24\n         AGO   .GENBSM                                        CONTINUE\n.NMSV5   DC    A(##F&NDX)             SET FOR NEW AMODE = 24\n         AGO   .GENBSM                                        CONTINUE\n.GEN31   CNOP  0,4                    ALIGN ON FULLWORD\n         L     R14,*+8                R14  =  AMODE \u00a6\u00a6 AFTER BSM\n         B     *+8                    ISSUE BSM\n         AIF   (T'&MODESV EQ 'O').NMSV6                       NO MODESV\n         DC    A(##G&NDX+X'80000000') SET FOR NEW AMODE = 31\n         AGO   .GENBSM                                        CONTINUE\n.NMSV6   DC    A(##F&NDX+X'80000000') SET FOR NEW AMODE = 31\n         AGO   .GENBSM                                        CONTINUE\n.GENBSM  AIF   (T'&MODESV NE 'O').GBSM54                      MODESV\n         BSM   R0,R14                 SET AMODE, DON'T SAVE OLD AMODE\n         AGO   .NMSV2                                         NO MODESV\n.GBSM54  BSM   R14,R14                SET AMODE AND SAVE OLD AMODE\n##E&NDX  SR    R14,R14                ZERO R14 -- OLD AMODE\n         AIF   ('&MODESV'(1,1) EQ '(').MSVR2                 REGISTER\n##G&NDX  ST    R14,&MODESV            SET MODE SAVE AREA\n         AGO   .NMSV2                                        CONTINUE\n.MSVR2   ANOP\n##G&NDX  LR    &MODESV(1),R14         SET MODE SAVE REGISTER\n.NMSV2   ANOP\n##F&NDX  DS    0H                     ENDIF\n         AGO   .DONE\n.*\n.*  MNOTES\n.*\n.BERR    MNOTE 8,'*** SETMODE ERROR *** -- BOTH OPERANDS MISSING'\n         AGO   .DONE\n.MERR    MNOTE 8,'*** SETMODE ERROR *** -- INVALID/MISSING MODE'\n         AGO   .DONE\n.MSERR   MNOTE 8,'*** SETMODE ERROR *** -- INVALID/MISSING MODESV'\n         AGO   .DONE\n.DONE    SPACE 3\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETPARSE": {"ttr": 35083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00$\\x00$\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         SETPARSE &PCL=,&ECB=MYECB,&ANS=MYANS\n         GBLC  &SETBEF\n         GBLC  &USE\n         AIF   ('&USE' EQ '').ERROR\n         MVC   PPLUPT(4),CPPLUPT       MOVE IN UPT\n         MVC   PPLCBUF(4),CPPLCBUF     MOVE IN CBUF/\n         MVC   PPLECT(4),CPPLECT       MOVE IN ECT\n         L     R1,=V(&PCL)             GET ADDRESS OF PARM CONTROL\n         ST    R1,PPLPCL               MOVE IT IN\n         LA    R1,&ECB                 GET ADDRESS OF AN ECB\n         ST    R1,PPLECB               MOVE IT IN\n         XC    PPLUWA(4),PPLUWA        ZERO OUT THE WORK AREA\n         LA    R1,&ANS                 GET ADDRESS OF AN ANSWER\n*                                      PLACE\n         ST    R1,PPLANS\n         LA    R1,PPL                  FINALLY, LOAD R1 WITH A(PPL)\n         AIF   ('&SETBEF' EQ 'SET').NOSYM\n&SETBEF   SETC  'SET'\n         B     SETP&SYSNDX\nMYECB    DC    F'0'\nMYANS    DC    F'0'\nPPL      DS    0D                       START OF PARM CONTROL LIST\nPPLUPT   DS    A\nPPLECT   DS    A\nPPLECB   DS    A\nPPLPCL   DS    A\nPPLANS   DS    A\nPPLCBUF  DS    A\nPPLUWA   DS    A\nSETP&SYSNDX DS  0H\n.NOSYM   ANOP\n         MEND\n.ERROR   ANOP\n         MNOTE  12,'ERROR, MENTER MACRO MUST BE USED PREVIOSLY'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPMON": {"ttr": 35085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x05\\x01O\\x01\\x05\\x01O\\x08W\\x013\\x013\\x00\\x00\\xe6\\xc5\\xe2\\xe3\\xd9\\xd4\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-01-14T00:00:00", "modifydate": "2005-01-14T08:57:34", "lines": 307, "newlines": 307, "modlines": 0, "user": "WESTRMN"}, "text": "         MACRO\n&LABEL   UPDATEF &COUNT\n&LABEL   L      R14,&COUNT\n         LA     R14,1(R14)\n         ST     R14,&COUNT\n         MEND\nSPMON    MENTER 12,EQU,CP=CP,COM=TSSOSPMON\n***********************************************************************\n*  REGISTERS USED:                                                    *\n*    R1 - BUFFER ADDRESS         R6 - PTR TO OUCB                     *\n*    R2 - PTR TO ASVT ENTRY      R7 - R11  WORKING REGS               *\n*    R3 - COUNT OF ASCBS         R12 - BASE REGISTER                  *\n*    R4 - PTR TO OUXB                                                 *\n*    R5 - PTR TO ASCB                                                 *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*                        LOCATE CVT AND ASVT POINTERS                 *\n*                                                                     *\n***********************************************************************\n         B     AR7\n         COPY EYECATCH\nAR7      DS    0H\nFINDUTIL DS    0H                 FIRST, WE FIND THE UTILIZATION\n         SETPARSE PCL=SPMONPCL\n         CALLTSSR EP=IKJPARS\n         USING IKJPARMD,R9\n         L     R9,MYANS\n         TM    REQPARM+6,X'80'      ANY OPERANDS ?\n         BZ    AROUND             NOPE, ASSUME DEFAULTS.\n         L     R2,REQPARM\n         LH    R3,REQPARM+4\n         BCTR  R3,0\n         STH   R3,LJOBNAME        REMEMBER FOR COMPARES\n         MVC   JOBNAME(8),=CL8' '\n         EX    R3,MOVEOPER\n         B     AROUND\nMOVEOPER MVC   JOBNAME(0),0(R2)\nAROUND   DS    0H\n         TM    REQTYPE+6,X'80'\n         BZ    AROUND2            NO REQUESTED TYPE, DEFAULT=ALL\n         L     R2,REQTYPE\n         LH    R3,REQTYPE+4\n         CH    R3,=H'3'           JOBTYPE HAS GOT TO BE THREE CHARS.\n         BNE   AROUND2            INVALID, ASSUME OMITTED.\n         MVC   PARMTYPE(4),=CL8' '\n         MVC   PARMTYPE(3),0(R2)\nAROUND2  DS    0H\n         DROP  R9\n         L     R2,16\n         USING CVT,R2\n         SETMODE MODE=31\n         L     R2,CVTOPCTP\n         L     R2,228(R2)         RCT\n         CLC   0(3,R2),=CL3'RCT'  IS THIS THE RCT?\n         BNE   FINDCVT\n         ISXA  XA=XAUTIL\n         LH    R3,64(R2)\n         ST    R3,CPUUTIL         ** CPU UTILIZATION **\n         LH    R3,62(R2)\n         ST    R3,UIC             ** UIC **\n         LH    R3,76(R2)\n         ST    R3,PAGERATE        ** PAGING RATE **\n         B     GOTUTIL\nXAUTIL   DS    0H\n         LH    R3,56(R2)\n         ST    R3,CPUUTIL\n         LH    R3,54(R2)         ** UIC/XA **\n         ST    R3,UIC\n         LH    R3,68(R2)         ** PAGERATE/XA **\n         ST    R3,PAGERATE\n         SETMODE MODE=24\nGOTUTIL  DS    0H\n         L     R3,CPUUTIL         GET CPU UTILIZATION\n         SRA   R3,4               DEVIDE BY 16\n         LR    R1,R3\n         LA    R10,WORKAREA\n         CALL  JCECVTBD           CONVERT THE ROUTINE\n         STCM  R1,B'0111',HUTIL\nHUNZERO  DS    0H\n         L     R1,UIC\n         CALL  JCECVTBD\n         STCM  R1,B'0111',HUIC\nHUNZERO1 DS    0H\n         L     R1,PAGERATE\n         CALL  JCECVTBD\n         STCM  R1,B'1111',HPAGRATE\n         SETMODE MODE=24\n         PUTLINE PARM=PUTBLOK,OUTPUT=(HEADER,TERM,SINGLE,DATA),        X\n               MF=(E,IOPLADS)\nFINDCVT  L     R2,16              CVT POINTER\n         USING CVT,R2\n         L     R2,CVTASVT         ASVT POINTER\n         DROP  R2\n         USING ASVT,R2\n         L     R3,ASVTMAXU        MAXIMUM NUMBER OF ENTRIES\n         XR    R2,R2\n         STH   R2,ASIDNUM\n***********************************************************************\n*                                                                     *\n*            MAJOR LOOP (THROUGH ALL ASCB'S)                          *\n*                                                                     *\n***********************************************************************\nASCBLOOP DS    0H\n         MVC   TYPE(3),=CL3' '\n*\n         LH    R2,ASIDNUM         R2 = LAST ASID USED.\n         LA    R2,1(R2)\n         STH   R2,ASIDNUM\n*\n         LOCASCB ASID=ASIDNUM     INCREMENT TO NEXT ASCB ENTRY\n         LTR   R15,R15            As of Z/OS Brian Westerman 1/12/05\n         BNZ   NOGOOD\n         LR    R5,R1              GET ASCB ADDRESS\n         SRL   R5,31              SHIFT ALL BUT HIGH ORDER BYTE.\n         LTR   R5,R5              IF ON, ASID WAS NOGOOD\n         BNZ   NOGOOD\n         LR    R5,R1              OTHERWISE, USE IT!\n         USING ASCB,R5\n         SETMODE MODE=31\n         L     R6,ASCBOUCB        OUCB POINTER\n         USING OUCB,R6\n         L     R4,ASCBOUXB        OUXB POINTER\n         USING OUXB,R4\n         TM    OUCBYFL,OUCBLOG    LOGON CREATED USER?\n         MVC   JOB(8),=CL8'STARTING'\n         ICM   R7,B'1111',ASCBJBNI JOBNAME POINTER\n         BZ    NOTJOB             JOBNAME NOT AVAILABLE\n         MVC   JOB,0(R7)          MOVE IN JOBNAME\n         MVC   TYPE(3),=CL3'JOB'\n         UPDATEF JCOUNT\n         B     CONT1\nNOTJOB   ICM   R7,B'1111',ASCBJBNS S/M/L POINTER\n         BZ    NOGOOD             S/M/L NOT AVAILABLE\n         MVC   JOB,0(R7)          MOVE IN JOBNAME FOR S/M/L\nCONT1    DS    0H\n***********************************************************************\n*                                                                     *\n*                    ADDRESS SPACE QUEUE LOCATION                     *\n*                                                                     *\n***********************************************************************\n         CLC   JOB,=CL8'STARTING'\n         BE    NOGOOD\n         MVC   INOROUT(3),=CL3'IN'       ADDRESS SPACE ON 'IN' QUEUE\nWAITQ    TM    OUCBQFL,OUCBOFF    'WAIT' QUEUE\n         BZ    OUTQ               NO\n         MVC   INOROUT(3),=CL3'OUT'          MUST BE OUTN\n         B     DONE\nOUTQ     TM    OUCBQFL,OUCBOUT    'OUT' QUEUE\n         BZ    TRANS              NO\n         MVC   INOROUT(3),=CL3'OUT'\n         B     DONE\nTRANS    TM    OUCBQFL,OUCBGOO+OUCBGOI+OUCBGOB    TRANSITIONING' STATUS\n         BZ    DONE               NO\n         MVC   INOROUT(3),=CL3'TRA'\nDONE     DS    0H\n***********************************************************************\n*                                                                     *\n*                 FRAMES ALLOCATED TO ADDRESS SPACE                   *\n*                                                                     *\n***********************************************************************\n         LH    R1,ASCBFMCT        ALLOCATED PAGE FRAME COUNT\n         CALL  JCECVTBD\n         ST    R1,DECMEM\n*        EJECT\n***********************************************************************\n*                                                                     *\n*                   INTERVAL SERVICE ACCUMULATION                     *\n*                                                                     *\n***********************************************************************\n         L     R1,OUCBWMS         SERVICE UNITS - XACTION\n         CALL  JCECVTBD           CONVERT TO DECIMAL.\n         STCM  R0,B'1111',DECSERV\n         STCM  R1,B'1111',DECSERV+4\n***********************************************************************\n*                                                                     *\n*                    M/S/L                                            *\n*                                                                     *\n***********************************************************************\n         CLC   TYPE(3),=CL3'JOB'\n         BE    CONT2\n         TM    OUCBYFL,OUCBSTT    START CREATED TASK?\n         BZ    TEST2              NO\n         CLC   JOB(4),=CL4'INIT'    INITIATOR ?\n         BNE   TEST2P5\n         UPDATEF ICOUNT\n         B     CONT2\nTEST2P5  DS    0H\n         MVC   TYPE(3),=CL3'STC'\n         UPDATEF SCOUNT\n         B     CONT2\nTEST2    TM    OUCBYFL,OUCBLOG    LOGON CREATED TASK?\n         BZ    TEST3              NO\n         MVC   TYPE(3),=CL3'TSO'\n         UPDATEF TCOUNT\n         B     CONT2\nTEST3    TM    OUCBYFL,OUCBMNT    MOUNT CREATED TASK?\n         BZ    CONT2              NO\n         MVC   TYPE(3),=CL3'MNT'\nCONT2    DS    0H\n         LH    R7,LJOBNAME        GET LENGTH FOR EXECUTE\n         EX    R7,COMPJOB         DOIT !\n         BE    CHECKTYP\n         CLC   JOBNAME(8),=CL8'ALL'  ARE WE LOOKING FOR ALL JOBS ?\n         BE    CHECKTYP\n         B     NOGOOD              DONT PRINT, JUST GET NEXT ADDR SPACE\nCOMPJOB  CLC   JOB(0),JOBNAME     *** EXECUTED **\nCHECKTYP DS    0H\n* WE COME HERE, IF THE JOBNAME IS OK, BUT THE OPERATOR MAY HAVE\n* REQUESTED A CERTAIN TYPE OF JOB.\n         CLC   PARMTYPE(1),TYPE    CHECK TYPE\n         BE    CHEKNEXT\n         CLC   PARMTYPE(3),=CL3'ALL'\n         BE    CHEKNEXT\n         B     NOGOOD\nCHEKNEXT DS    0H\nPRINTLNE DS    0H\n         SETMODE MODE=24\nLINEDONE PUTLINE PARM=PUTBLOK,OUTPUT=(LINE,TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\nNOGOOD   DS    0H                 PROCESS NEXT ADDRESS SPACE\n         BCT   R3,ASCBLOOP        PROCESS NEXT ADDRESS SPACE\n*\n*\n*\n***********************************************************************\n* ALL DONE PROCESSING THESE ADDRESS SPACES.                           *\n*                                                                     *\n***********************************************************************\n         DROP  R4,R5,R6\n         L     R1,TCOUNT\n         CALL  JCECVTBD\n         ST    R1,TSOEBC\n         L     R1,SCOUNT\n         CALL  JCECVTBD\n         ST    R1,STCEBC\n         L     R1,JCOUNT\n         CALL  JCECVTBD\n         ST    R1,JOBEBC\n         L     R1,ICOUNT\n         CALL  JCECVTBD\n         ST    R1,INITEBC\n         PUTLINE PARM=PUTBLOK,OUTPUT=(TRAILER,TERM,SINGLE,DATA),       X\n               MF=(E,IOPLADS)\n         MLEAVE\n         EJECT\n         PRINT NOGEN\nSPMONPCL IKJPARM\nREQPARM  IKJIDENT 'JOBNAME',UPPERCASE,MAXLNTH=8,FIRST=ALPHA\nREQTYPE  IKJIDENT 'TYPE',UPPERCASE,MAXLNTH=4,FIRST=ALPHA\n         IKJENDP\nWORKAREA DS    CL200\nTRAILER  DC    H'80',H'0'\nTSOEBC   DS    F\nTRAILLNE DC    C' TSO USERS, '\nSTCEBC   DS    F\n         DC    C' STARTED TASKS, '\nJOBEBC   DS    F\n         DC    C' BATCH JOBS, '\nINITEBC  DS    F\n         DC    C' INACTIVE INITS.'\n         DC    CL50' '\nHEADER   DC    H'80',H'0'\nHLINE    DC    C'CPU UTILIZATION: '\nHUTIL    DC    CL4'100%'\n         DC    C'  UIC: '\nHUIC     DC    CL4'255 '\n         DC    C'   PAGING RATE: '\nHPAGRATE DC    CL4'100 '\nHFILL    DC    CL60' '\nPTRN1    DC    X'2020202020202120'\nASIDNUM  DS    H\nWKA      DS    2D\nLINE     DS    0H\nLINEL    DC    H'80,0'\nTYPE     DC    CL4'JOB '\nJOB      DC    CL8' '\nISWORD   DC    C' IS '\nINOROUT  DC    CL5'OUT, '\nDECSERV  DC    CL9' '\nSERSTRIN DC    C'SU''S, '\nDECMEM   DC    CL4' '\nMEMWORD  DC    C' FRAMES'\nBLANKS   DC    CL80' '\nCPUUTIL  DS    F\nPAGERATE DS    F\nUIC      DS    F\nJCOUNT   DC    F'0'\nTCOUNT   DC    F'0'\nSCOUNT   DC    F'0'\nICOUNT   DC    F'0'\nLJOBNAME DC    H'6'\nJOBNAME  DC    CL8'NOOPER'\nPARMTYPE DC    CL4'ALL'\n         CVT   DSECT=YES\n         IRAOUCB\n         IHAASCB\n         IHAASVT\n         IHAOUXB\n         IKJIOPL\n         END   SPMON\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY SPMON(''TSSO V 4.1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    SPMON'\n PUNCH ' NAME     SPMON(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCONCB": {"ttr": 35334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         SSCONCB\nSSCONCB  DSECT\n***********************************************************************\n* THIS MACRO MAPS THE TSSO SUBSYSTEM CONSOLE CONTROL BLOCK.           *\n* THERE IS EXACTLY ONE TSSO SUBSYSTEM CONTROL BLOCK FOR EACH AND EVERY*\n* ALLOCATED SUBSYSTEM CONSOLES, AND THEY ARE CHAINED TOGETHER. THE    *\n* FIRST IS POINTED OF THE SSCONCB HEADER                              *\n***********************************************************************\n*\nSSCONNUM DS    F             SUBSYSTEM CONSOLE CONSOLE ID.\n*\n*\nSSCONICB DS    F             ADDRESS OF THE OSCMD INTERFACE CONTROL\n*                            BLOCK FOR THIS CONSOLE\n*\nSSCONAUT DS    A             ADDRESS OF THE UCMAUTH BYTE FOR THIS\n*                            SUBSYSTEM CONSOLE\n*\nSSCONFLG DS    F             TSSO SUBSYSTEM CONSOLE FLAGS\n* X'80' - SUBSYSTEM CONSOLE IN USE\n* X'40' - SUBSYSTEM CONSOLE DEDICATED TO SYSTEM CONSOLES\n* X'20' - SUBSYSTEM CONSOLE IS ACTIVELY RECORDING MESSAGES.\n*\nSSCONUID DS    CL8           SUBSYSTEM CONSOLE USER IDENTIFIER\n*\nSSCONCBL EQU   *-SSCONNUM    LENGTH OF SSCONCB\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSCONCBH": {"ttr": 35336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x14\\x00\\x14\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         SSCONCBH\nSSCONCBH DSECT\n***********************************************************************\n* THIS MACRO MAPS THE TSSO SUBSYSTEM CONSOLE CONTROL BLOCK HEADER.    *\n* THERE IS EXACTLY ONE SSCONCBH WITHIN TSSO, AND IT SERVES AS AN      *\n* ANCHOR TO TSSO'S SUBSYSTEM ALLOCATABLE CONSOLES.                    *\n***********************************************************************\nSSCONAMT DS    F             NUMBER OF TSSO SUBSYSTEM ALLOCATABLE\n*                            CONSOLES.\n*\nSSCONREQ DS    F             NUMBER OF SUBSYSTEM CONSOLES REQUESTED\n*                            IN PARMLIB.\n*\nSSCONRES DS    CL42          RESERVE MUCHO BYTES.\n*\n*\nSSCONFIR DS    0F            FIRST SUBSYSTEM TSSO SUBSYSTEM CONSOLE.\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SSID": {"ttr": 35338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\n\\x00\\n\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n.***************************************************************\n.* THIS MACRO WILL RETURN THE SMF SSID IN A USER SPECIFIED\n.* PLACE\n.***************************************************************\n&LAB     SSID  &LABEL=SSID\n&LAB     L    R1,16            GET ADDRESS OF CVT IN R1\n         L    R1,X'C4'(R1)     ADDRESS OF SMCA IN R1\n         MVC  &LABEL.(4),16(R1) PUT ADDRESS IN USER SPECIFIED PLACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TABEND": {"ttr": 35340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x17\\x00\\x17\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n.**********************************************************************\n.* VERSION LEVEL - TSSO VERSION 4.3                                   *\n.*                                                                    *\n.* MODIFIED                                                           *\n.*   30OCT92  GLA  SUPPORT BINARY SEARCH OF TABLE. NEED TO INCLUDE    *\n.*                 COUNT OF ENTRIES TO COMPUTE SIZE OF INDEX.         *\n.*                                                                    *\n.**********************************************************************\n         TABEND\n         GBLA  &ENTCOUNT\n.***************************************************************\n.* THE TABEND MACRO IS USED TO END A TSSO AOF TABLE DEFINITION *\n.***************************************************************\n         DC    A(0)\n         DC    CL8'ZZZZZZZZ'           MESSAGE IDENTIFIER\n         DC    CL8'ZZZZZZZZ'           ACTION PARM\n         DC    A(0)                    NO TEST ENTRIES\n         DC    H'0'                    LENGTH OF ACTION-TEXT\n         DC    100C'Z'                 JUST TO MAKE SURE.\nENTCNT   DC    A(&ENTCOUNT)            NUMBER OF ENTRIES.\n         END\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TABENTRY": {"ttr": 35342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x022O\\x01\\x026\\x1f\\x15H\\x01\\x8e\\x01\\x8c\\x00/\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-11-20T00:00:00", "modifydate": "2002-12-27T15:48:00", "lines": 398, "newlines": 396, "modlines": 47, "user": "CTEC004"}, "text": "         MACRO\n.**********************************************************************\n.* VERSION LEVEL: TSSO VERSION 4.3                                    *\n.*              : WRITTEN 6/1/85                                      *\n.* UPDATED: 12/15 TO SUPPORT HIGHLITE FIELD FOR ACTION=               *\n.* UPDATED: 1/12/85 TO SUPPORT MSG=* AND NTABALL MESSAGE.             *\n.*                                                                    *\n.* UPDATED FOR TSSO 4.2 TO SUPPORT THE FOLLOWING FEATURES.            *\n.*                                                                    *\n.* ECHO=YES/NO/LOG    TO DETERMINE IF COMMAND SHOULD BE ECHOED TO THE *\n.*                    CONSOLE OR SYSLOG.                              *\n.*                                                                    *\n.*                                                                    *\n.* MATCHLIM=NNNN      TO DETERMINE HOW OFTEN A GIVEN AOF ENTRY WILL   *\n.*                    BE MATCHED. IF THE NUMBER DECREMENTS TO ZERO,   *\n.*                    IT WILL EFFECTIVELY BE DELETED.                 *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.* UPDATED FOR TSSO 4.3 TO SUPPORT THE FOLLOWING FEATURES:            *\n.*                                                                    *\n.* 1) EACH AOF TABLE ENTRY WILL NOW HAVE AN 8 BYTE TABLE              *\n.*    IDENTIFIER. THIS 8 BYTE IDENTIFIER WILL BE ACCESSABLE           *\n.*    ON THE DISPAOF COMMAND, AS WELL AS RECOGNIZED ON THE ALTAOF     *\n.*    COMMAND.                                                        *\n.*                                                                    *\n.*                                                                    *\n.* 2) ECHO = YES WILL NOW BE THE DEFAULT.                             *\n.*                                                                    *\n.*                                                                    *\n.* 3) ACTION=POST WILL BE ACCEPTED, AND GENERATE THE NECCESARY        *\n.*    CONTROL BLOCK FIELDS FOR ACTIVATION/DEACTIVATION OF THIS        *\n.*    FACILITY.                                                       *\n.*                                                                    *\n.*                                                                    *\n.* 20AUG92 CART1 INTRODUCE LCLB &LTEXT TO SAY WHETHER 'TEXT' IS VALID *\n.* 24AUG92 CART1 PROCESS 'L=' OPTION IN TESTS. THIS ALTERS THE FORMAT *\n.*               OF THE TEST CONTROL BLOCK.                           *\n.* 26AUG92 CART1 ADD FIELDS FOR 'L=' OPTION DATA STORAGE.             *\n.* 09SEP92 CART1 ALLOW 'NONE' AS A VALID ACTION TO PASS TO TSSOSS09   *\n.*                                                                    *\n.*   15OCT92  GLA   CARRY OVER CHANGES FROM 4.2                       *\n.*                 A. SUPPORT QUOTED STRING FOR MSG=.                 *\n.*                                                                    *\n.* 24OCT02 DHC   SUPPORT EXCLUSION TESTING ( WX AND SX)               *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.*                                                                    *\n.* EACH AOF ENTRY WILL BE ASSIGNED A FULLWORD NUMBER. THIS IS FOR     *\n.* CONVIENT DISPLAYING AND ALTERING WITH THE DISPAOF AND ALTAOF       *\n.* COMMANDS.                                                          *\n.**********************************************************************\n&EID     TABENTRY &MSG=,&ACTION=,&TEXT=,&TEST=,&ECHO=,&MATCHLIM=\n         GBLA  &ENTCOUNT\n         LCLA  &LOOPCNT,&LMATTEXT,&LTEXT\n         LCLB  &BTEXT\n         LCLC  &TTYPE,&STRSTAR,&STRLEN,&SEPCHAR,&MATTEXT\n         LCLC  &ECHOVAR,&MLIMNMBR,&ENTRYID\n&BTEXT   SETB  0\n         AIF   (K'&MSG EQ 0).NOMSG\n         AIF   (K'&ACTION EQ 0).NOACT\n         AIF   ('&ACTION' EQ 'HILIGHT').ACTOK\n         AIF   ('&ACTION' EQ 'HIGHLITE').ACTOK\n         AIF   ('&ACTION' EQ 'MSGRED').ACTOK\n         AIF   ('&ACTION' EQ 'LOWLIGHT').ACTOK\n         AIF   ('&ACTION' EQ 'SUPPRESS').ACTOK\n         AIF   ('&ACTION' EQ 'POST').ACTOK\n         AIF   ('&ACTION' EQ 'NONE').ACTOK\n&BTEXT   SETB  1\n         AIF   ('&ACTION' EQ 'OSCMD').ACTOK\n         AIF   ('&ACTION' EQ 'OSCMDT').ACTOK\n         AIF   ('&ACTION' EQ 'REPLY').ACTOK\n         AGO   .ACTBAD\n.ACTOK   ANOP\n.**********************************************************************\n.* ONCE WE VERIFY THE CORRECTNESS OF THE MSG AND ACTION PARMS, WE     *\n.* START GENERATING TSSO AOF CONTROL BLOCKS. THE CONTROL BLOCK HEADER *\n.* IS GENERATED FIRST, FOLLOWED BY ANY TESTS THE USER MAY HAVE        *\n.* SPECIFIED.                                                         *\n.**********************************************************************\nNENT&SYSNDX    DC    A(ENDE&SYSNDX)       ADDRESS OF NEXT MAJOR ENTRY\n               DC    A(0)                 ADDRESS OF NEXT IDENT. ENTRY\n.**********************************************************************\n.*GENERATE THE MSG AND ACTION PARAMATERS, FOLLOWED BY THE TEXT        *\n.*OPERAND.                                                            *\n.**********************************************************************\n         AIF   ('&MSG'(1,1) EQ '''').MSGQUO                     15OCT92\nMID&SYSNDX     DC    CL8'&MSG'           MESSAGE TO SEARCH FOR.\n         AGO   .NOMSGQ                                          15OCT92\n.MSGQUO  ANOP  ,                                                15OCT92\nMID&SYSNDX     DC    CL8&MSG             MESSAGE TO SEARCH FOR. 15OCT92\n.NOMSGQ  ANOP  ,                                                15OCT92\nAID&SYSNDX     DC    CL8'&ACTION'        ACTION TYPE\n.**********************************************************************\n.* ENSURE THAT MSG='*' IS NOT SPECIFIED UNLESS TEST PARAMETERS ARE ALSO\n.* SPECIFIED.\n.**********************************************************************\n         AIF   ('&MSG' EQ '*' AND N'&TEST EQ 0).NTRAPALL\n         AIF   (N'&TEST EQ 0).GENA0\n.*\n               DC    A(FIRT&SYSNDX)      ADDRESS OF FIRST TEST PARM\n         AGO   .GENCOUNT\n.*\n.GENA0         ANOP\n               DC    A(0)                NO TEST PARM FOR THIS ENTRY\n               AGO   .GENCOUNT\n.*\n.GENCOUNT      ANOP\n.**********************************************************************\n.*UPDATE THE COUNT FIELD FOR GENERATION INTO THIS ENTRY. DEFINE A HALF*\n.*WORD WITH THE CURRENT NUMBER                                        *\n.**********************************************************************\n&ENTCOUNT      SETA  &ENTCOUNT+1\n               DC    AL2(&ENTCOUNT)     AOF ENTRY NUMBER &ENTCOUNT\n               AGO   .GENECHO\n.*\n.GENECHO       ANOP\n.**********************************************************************\n.*CREATE THE ECHO PARAMETER BASED ON USER INPUT. USE THE FOLLOWING    *\n.*TABLE TO DETERMINE ECHO PARAMETERS...                               *\n.*                                                                    *\n.*ECHO=YES :   DC  CL2'YE'                                            *\n.*ECHO=NO  :   DC  CL2'NO'                                            *\n.*ECHO=LOG :   DC  CL2'LO'                                            *\n.*                                                                    *\n.**********************************************************************\n&ECHOVAR       SETC '&ECHO'\n               AIF  ('&ECHOVAR' NE '').ECHOSPEC\n&ECHOVAR       SETC 'YES'\n.ECHOSPEC      ANOP\n               AIF  ('&ECHOVAR' EQ 'YES').ECHOYES\n               AIF  ('&ECHOVAR' EQ 'NO').ECHONO\n               AIF  ('&ECHOVAR' EQ 'LOG').ECHOLOG\n               AGO  .ECHOERR\n.ECHOYES       ANOP\nECHO&ENTCOUNT  DC   CL2'YE'             ECHO = YES SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ECHONO        ANOP\nECHO&ENTCOUNT  DC   CL2'NO'             ECHO = NO  SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ECHOLOG       ANOP\nECHO&ENTCOUNT  DC   CL2'LO'             ECHO = LOG SPECIFIED.\n               AGO  .ENDECHO\n.*\n.ENDECHO       ANOP\n               AGO  .GENMLIM\n.*\n.*\n.GENMLIM       ANOP\n.**********************************************************************\n.*CREATE THE MATCHLIM PARAMETER ENTRY BY GENERATING A FULLWORD WITH   *\n.*THE USER SPECIFIED MATCHLIM COUNT. IF MATCHLIM IS NOT SPECIFIED,    *\n.*IT WILL DEFAULT TO UNLIMITED MATCHING (I.E. ALWAYS PERFORM THE      *\n.*ACTIONS SPECIFIED IN THE ACTION = PARAMETER.                        *\n.*NOTE THAT THE DEFAULT VALUE \"999999\" WILL BE CHECKED BY TSSOSS09    *\n.*AS A FLAG TO DEMONSTRATE NO MATCHLIM IS IN EFFECT.                  *\n.**********************************************************************\n&MLIMNMBR      SETC '&MATCHLIM'\n               AIF  ('&MLIMNMBR' NE '').GOTMTCH\n&MLIMNMBR      SETC '999999'\n.GOTMTCH       ANOP\nMLIM&SYSNDX    DC   AL4(&MLIMNMBR)      MATCH LIMIT VALUE.\n.ENDMTCH       ANOP\n.**********************************************************************\n.*                                                                    *\n.* NEXT, WE GENERATE THE 8 CHARACTER ENTRY ID THAT WAS SPECIFIED IN   *\n.* THE LABEL FIELD OF THE TABENTRY MACRO.                             *\n.*                                                                    *\n.**********************************************************************\n               AIF  (K'&EID  EQ 0).DEFEID\n&ENTRYID       SETC '&EID'\n               AGO  .GENEID\n.*\n.DEFEID        ANOP\n.*\n&ENTRYID       SETC 'ENTR&ENTCOUNT'\n               AGO  .GENEID\n.GENEID        ANOP\n.*\nEID&SYSNDX     DC   CL8'&ENTRYID'\n               AGO  .GENTEXT\n.*\n.*\n.*\n.*\n.GENTEXT       ANOP\n               AIF   (K'&TEXT EQ 0).NOACTTEX\n               AIF   (&BTEXT NE 1).TEXTERR\n&LTEXT         SETA  K'&TEXT\n&LTEXT         SETA  &LTEXT-2\n               DC    AL2(ATEC&SYSNDX-ATEX&SYSNDX)    LENGTH OF ACT-TEXT\nATEX&SYSNDX    DC    C&TEXT             ACTION-TEXT\nATEC&SYSNDX    EQU   *\n               AGO   .DOTESTS\n.*\n.NOACTTEX      ANOP\n               AIF   ('&ACTION' EQ 'HILIGHT').ACTOK2\n               AIF   ('&ACTION' EQ 'MSGRED').ACTOK2\n               AIF   ('&ACTION' EQ 'LOWLIGHT').ACTOK2\n               AIF   ('&ACTION' EQ 'SUPPRESS').ACTOK2\n               AIF   ('&ACTION' EQ 'POST').ACTOK2\n               AIF   ('&ACTION' EQ 'NONE').ACTOK2\n               AGO   .INVMIX\n.ACTOK2        ANOP\n               DC    AL2(0)             NO ACTION-TEXT\n               AIF   ('&ACTION' EQ 'POST').GENPOST\n               AGO   .DOTESTS\n.GENPOST       ANOP\n.**********************************************************************\n.* GENERATE THE CONTROL BLOCKS FOR \"ACTION=POST\"                      *\n.**********************************************************************\nPFLG&SYSNDX    DC    XL4'00'        ACTION=POST FLAGS\n* X'80' ENTRY IS CURRENTLY BEING WAITED FOR BY SOME ADDRESS S\u00a2ACE\nPECB&SYSNDX    DC    XL4'00'        ECB TO WAIT ON.\nPASD&SYSNDX    DC    XL4'00'        ADDRESS SPACE WAITING FOR ENTRY.\nPWTO&SYSNDX    DC    CL150' '       WTO THAT CAUSED ENTRY TO BE\n*                                   TRIPPED.\n               AGO   .DOTESTS\n.*\n.*\n.DOTESTS ANOP\n&LOOPCNT SETA  1\nFIRT&SYSNDX    DS    0D\n.*\n.*\n.**********************************************************************\n.* WE ARE NOW READY TO GENERATE THE CONTROL BLOCKS TO REPRESENT ANY   *\n.* TEST ENTRIES WE MAY HAVE FOUND. THE VARIABLE \"TEST\" CONTAINS AN    *\n.* ARRAY OF SUCH ENTRIES. EACH LINE (ROW) CONTAINS THE FOLLOWING      *\n.* VARIABLES:                                                         *\n.*                                                                    *\n.* TEST TYPE, SUBSTRING OR WORD START, LENGTH, MATCHING STRING        *\n.*                                                                    *\n.* AND THE CONTROL BLOCK TO REPRESENT THIS WILL LOOK LIKE:            *\n.*                                                                    *\n.*     DC    A(NEXT TEST CONTROL BLOCK, OR ZERO)                      *\n.*     DC    CL2'TEST TYPE'    S=SUBSTR  W=WORD  L=LINE               *\n.*     DC    F'SUBSTRING OR WORD STARTING POINT OR LINE NO.'          *\n.*                                                                    *\n.* IF THE TEST IS FOR A 'S' OR 'W', THE FOLLOWING DATA IS PRESENT;    *\n.*                                                                    *\n.*     DC    F'LENGTH'                                                *\n.*     DC    CL&LENGTH'MATCHING STRING'                               *\n.*                                                                    *\n.* IF THE TEST IS FOR A MLWTO LINE NUMBER, TWO DATA AREAS ARE CREATED *\n.*                                                                    *\n.*     DC    F'0'          MLWTO SEQUENCE NO. (CONNECT ID)            *\n.*     DC    H'0'          NUMBER OF LINES PROCESSED                  *\n.*                                                                    *\n.* THE MACRO WILL LOOP, FOR THE NUMBER OF TEST ENTRIES SPECIFIED      *\n.* GENERATING THESE CONTROL BLOCKS.                                   *\n***********************************************************************\n.TOPTLOOP ANOP\n         AIF   (&LOOPCNT GT  N'&TEST).ENDTESTS\n.*\n         AIF   (&LOOPCNT EQ  N'&TEST).GENA02\n               DC   A(NTE&LOOPCNT.&SYSNDX)\n         AGO   .GENTTYPE\n.*\n.GENA02        DC   A(0)\n         AGO   .GENTTYPE\n.*\n.GENTTYPE ANOP\n.**********************************************************************\n.* HERE, WE GENERATE THE TYPE OF TEST TO PERFORM. THE POSSIBLE TYPES\n.* ARE:\n.*\n.* S - PERFORM A SUBSTRING TEST ON THE MESSAGE\n.* W - PERFORM A WORD MATCHING TEST ON THE MESSAGE\n.**********************************************************************\n&TTYPE   SETC  '&TEST(&LOOPCNT,1)'\n         AIF   ('&TTYPE' EQ 'S').TYPEOK\n         AIF   ('&TTYPE' EQ 'SX').TYPEOK\n         AIF   ('&TTYPE' EQ 'W').TYPEOK\n         AIF   ('&TTYPE' EQ 'WX').TYPEOK\n         AIF   ('&TTYPE' EQ 'L').TYPEOK\n         AGO   .TYPEBAD\n.TYPEOK  ANOP\n         DC    CL2'&TTYPE'       TYPE OF ENTRY, S=SUBSTR, W=WORD\n         DC    CL2' '            RESERVED, ALIGN TO WORD BOUNDARY\n.**********************************************************************\n.*\n.* NEXT, GENERATE THE SUBSTRING OR WORD START POINT\n.*\n.**********************************************************************\n&STRSTAR SETC  '&TEST(&LOOPCNT,2)'\n         DC    F'&STRSTAR'       START OF SUBSTR, NO. OF WORD OR LINE\n         AIF   ('&TTYPE' NE 'L').TESTLEX\n.**********************************************************************\n.* FOR 'L=' TESTS WE GENERATE TWO DATA AREAS FOR USE IN PROCESSING\n.**********************************************************************\n         DC    F'0'                MLWTO IDENT\n         DC    H'0'                MLWTO LINE COUNT\n         AGO   .BOTTLOOP\n.*\n.TESTLEX ANOP\n.**********************************************************************\n.*\n.* NOW, WE GENERATE THE LENGTH THAT WE WILL COMPARE\n.*\n.**********************************************************************\n&STRLEN  SETC  '&TEST(&LOOPCNT,3)'\n         DC    F'&STRLEN'        LENGTH OF SUBSTRING OR WORD\n.*\n.**********************************************************************\n.*\n.* NOW, WE GENERATE THE POSSIBLE SEPERATOR CHARACTERS, IF THE TYPE WAS\n.* FOR A WORD SEARCH. FIRST, CHECK IF THE TYPE WAS S OR W\n.**********************************************************************\n&SEPCHAR SETC  '&TEST(&LOOPCNT,5)'\n         AIF   ('&TTYPE' EQ 'S').CHEKSERR    CHECK FOR AN ERROR\n         AIF   ('&TTYPE' EQ 'SX').CHEKSERR    CHECK FOR AN ERROR\n.**********************************************************************\n.* TYPE WAS \"W\" - USE SEPCHARS\n.**********************************************************************\n         DC    CL4&SEPCHAR      SEPARATOR CHARS FOR ENTRY\n         AGO   .GENMTEXT\n.*\n.CHEKSERR ANOP\n         AIF   (K'&SEPCHAR EQ 0).GENNSEP\n         AGO   .INVMIX\n.*\n.GENNSEP  ANOP\n          DC   CL4' '            NO SEPARATOR FOR \"S\" TYPE ENTRY\n         AGO   .GENMTEXT\n.*\n***********************************************************************\n.* NOW, WE HAVE GENERATED ALL BUT THE MATCHING TEXT. WE GENERATED THE *\n.* TEXT AS A STRING, PROCEDED BY A TWO BYTE LENGTH FIELD.             *\n.**********************************************************************\n.GENMTEXT ANOP\n&MATTEXT  SETC  '&TEST(&LOOPCNT,4)'\n&LMATTEXT SETA  K'&MATTEXT\n&LMATTEXT SETA  &LMATTEXT-2             ACCOUNT FOR QUOTES\n          DC   H'&LMATTEXT'             LENGTH OF MATCH-TEXT\n          DC   C&MATTEXT                MATCH-TEXT\n***********************************************************************\n.* LASTLY, WE MUST GENERATE THE LABEL TO BE USED BY THE NEXT TEST     *\n.* ENTRY, IF THERE IS ONE, AND INCREMENT &LOOPCNT                     *\n.**********************************************************************\n.BOTTLOOP ANOP\nNTE&LOOPCNT.&SYSNDX   DS     0D\n&LOOPCNT  SETA  &LOOPCNT+1\n          AGO  .TOPTLOOP\n.*\n.ENDTESTS ANOP\n.**********************************************************************\n.* WHEN THE CONTROL BLOCKS FOR ALL THE APPROPRIATE TESTS HAVE BEEN    *\n.* GENERATED, WE GENERATE THE LABEL FOR THE NEXT MSG ENTRY, IF WE     *\n.* HAVE ONE.                                                          *\n.**********************************************************************\nENDE&SYSNDX DS   0D\n          AGO    .ENDIT\n.**********************************************************************\n.* ERROR ROUTINES TO GENERATE MNOTES GO HERE                          *\n.*                                                                    *\n.**********************************************************************\n.NOMSG    ANOP\n  MNOTE 12,'TSSG001A REQUIRED PARAMETER \"MSG\" MISSING'\n          AGO    .ENDIT\n.*\n.NOACT    ANOP\n  MNOTE 12,'TSSG002A REQUIRED PARAMETER \"ACTION\" MISSING'\n          AGO    .ENDIT\n.*\n.ACTBAD   ANOP\n  MNOTE 12,'TSSG003A ACTION PARAMETER INVALID- CHECK USER GUIDE'\n          AGO    .ENDIT\n.*\n.INVMIX   ANOP\n  MNOTE 12,'TSSG004A INVALID MIXTURE OF PARAMETERS- CHECK USER GUIDE'\n          AGO    .ENDIT\n.*\n.TYPEBAD  ANOP\n  MNOTE 12,'TSSG005A TYPE INVALID, MUST BE \"S\" OR \"W\"'\n          AGO    .ENDIT\n.*\n.NTRAPALL ANOP\n  MNOTE 12,'TSSG006A MSG = \"*\" WITH NO TEST PARAMETERS IS INVALID, AS'\n  MNOTE 12,'TSSG006A (CONT) THIS WOULD TRAP ALL WTO MESSAGES'\n          AGO    .ENDIT\n.*\n.ECHOERR  ANOP\n  MNOTE 12,'TSSG007A IMPROPER SPECIFICATION OF ECHO PARAMETER'\n  MNOTE 12,'TSSG007A TRY \"YES\", \"NO\" OR \"LOG\"'\n          AGO    .ENDIT\n.*\n.TEXTERR  ANOP\n  MNOTE 4,'TSSG008I TEXT PARAMETER INVALID FOR THIS ACTION. IGNORED'\n          AGO    .NOACTTEX\n.*\n.ENDIT    ANOP\n          MEXIT\n          MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABSTART": {"ttr": 35589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00#\\x00#\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n.**********************************************************************\n.* VERSION LEVEL: TSSO VERSION 4.2       11/20/84                     *\n.*                                                                    *\n.* CHANGE LOG: INSTALLED: 11/20/84                                    *\n.*             VERSION LEVEL CHANGED: 3/30/85                         *\n.*             VERSION LEVEL CHANGED: 7/07/86                         *\n.*                                                                    *\n.* MODIFIED                                                           *\n.*   30OCT92  GLA  SUPPORT BINARY SEARCH OF TABLE. NEED TO INCLUDE    *\n.*                 COUNT OF ENTRIES TO COMPUTE SIZE OF INDEX.         *\n.*                                                                    *\n.**********************************************************************\n&TABNAME TABSTART &ID=\n          GBLA  &ENTCOUNT\n&ENTCOUNT SETA   0\n          AIF (T'&TABNAME EQ 'O').TABNBAD\n&TABNAME CSECT\n         DC  A(FIRSTENT)      +0     ADDRESS OF FIRST ENTRY INTO TABLE\n         DC  CL8'TSSOTABL'    +4     CONTROL BLOCK IDENTIFIER\n         DC  CL8'&ID'         +12    USER SPECIFIED ID\n         DC  CL8'&TABNAME'    +20    NAME OF THE TABLE.\n         DC  CL8'&SYSDATE'    +28    DATE OF ASSEMBLY\n         DC  CL8'&SYSTIME'    +36    TIME OF ASSEMBLY\n         DC  CL8'TSSO 4.3'    +44    TSSO VERSION NUMBER\n         DC  A(ENTCNT)        +52    ADDRESS OF ENTRY COUNT\n*                             +56\nSTRTRSVD DC  XL16'0102030405060708090A0B0C0D0E0F'   RESERVED\nFIRSTENT DS  0F\n         MEXIT\n.TABNBAD  ANOP\n         MNOTE 12,'THE TABSTART MACRO MUST HAVE A LABEL'\n         AGO   .ERREXIT\n.ERREXIT ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAOFNTRY": {"ttr": 35591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x022O\\x01\\x026\\x1f\\x15H\\x00P\\x00O\\x00\\t\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-20T00:00:00", "modifydate": "2002-12-27T15:48:00", "lines": 80, "newlines": 79, "modlines": 9, "user": "CTEC004"}, "text": "         MACRO\n         TAOFNTRY\n***********************************************************************\n*                                                                     *\n* Description of AOF entry generated by the TABENTRY macro.           *\n*                                                                     *\n*                                                                     *\n* Created   TSSO Version 4.3+   GLA                                   *\n*                                                                     *\n***********************************************************************\nAOFNTRY  DSECT\nAOFNXT   DS    A                   PTR TO NEXT PHY ENTRY\nAOFBNXT  DS    A                   PTR TO NEXT IDENTICAL ENTRY\nAOFMSGID DS    CL8                 MESSAGE ID (FIRST 8 CHARS) OR '*'\nAOFACTN  DS    CL8                 ACTION FUNCTION\n*                                   'HILIGHT' MESSAGE AT CONSOLE\n*                                   'HIGHLITE'  (OBSOLETE SPELLING)\n*                                   'MSGRED'  HILITE MSG IN RED\n*                                   'LOWLIGHT' MESSAGE AT CONSOLE\n*                                   'SUPPRESS' MESSAGE AT CONSOLE\n*                                   'POST' A WAITING OSWAIT COMMAND\n*                                   'NONE' PERFORM NO ACTION\n*                                   'OSCMD' ISSUE COMMAND\n*                                   'OSCMDT' WTO COMMAND (TEST MODE)\n*                                   'REPLY' USE TEXT TO REPLY TO WTOR\nAOFTESTP DS    A                   PTR TO TEST BLOCKS\nAOFNTRCT DS    AL2                 ENTRY NUMBER IN LOAD MODULE\nAOFECHO  DS    CL2                 ECHO PARAMETER\n*                                    'YE'  YES ECHO TO CONSOLE\n*                                    'NO'  NO SUPPRESS FROM CONSOLE\n*                                    'LO'  LOG TO SYSLOG\nAOFMLIM  DS    AL4                 MATCHLIM COUNT\nAOFENTR  DS    CL8                 ENTRY NAME, EITHER LABEL OR\n*                                   GENERATED NAME 'ENTRN'\nAOFAORP  DS    0X                  DIFFERENT SEGMENTS FOR ACTIONS\n*\n**       FOR ACTION=OSCMD, ACTION=OSCMDT, ACTION=REPLY\n*\nAOFACTL  DS    AL2                 LENGTH OF ACTION TEXT\nAOFACT   DS    0C                  START OF ACTION TEXT\n         ORG   AOFAORP\n*\n**       FOR ACTION=POST\n*\nAOFPFLG  DS    X                   POST FLAGS\nAOFP1WT  EQU   X'80'               SOMEONE IS WAITING ON THIS ENTRY\n         DS    XL3                 RESERVED\nAOFPECB  DS    XL4                 ECB\nAOFPASCB DS    XL4                 ASCB\nAOFWQE   DS    CL150               COPY OF WQE THAT CAUSES POST\n         ORG   ,\n         EJECT\nATSNTRY  DSECT ,                   TEST OPERAND ENTRY\nATSNXT   DS    A                   PTR TO NEXT TEST ENTRY\nATSTYPE  DS    CL2                 TEST TYPE\n*                                    'W ' WORD TYPE TEST\n*                                    'WX' WORD EXCLUDE TEST\n*                                    'S ' SUBSTRING TYPE TEST\n*                                    'SX' SUBSTRING EXCLUDE TEST\n*                                    'L ' LINE NUMBER TEST\n         DS    CL2                 RESERVED\nATSWORD  DS    A                   WORD NUMBER\nATSSUBST EQU   ATSWORD             SUBSTRING CHARACTER POSITION\nATSLINE  EQU   ATSWORD             LINE NUMBER\nATSEXTN  DS    0X                  START OF VARIABLE EXTENSIONS\n*\n**       EXTENSION FOR CHARACTER TESTS (WORD, SUBSTRING)\n*\nATSLNGTH DS    A                   LENGTH OF SUBSTRING\nATSSEPS  DS    CL4                 PARSE SEPARATORS\nATSTXTL  DS    H                   LENGTH OF TEXT\nATSTXT   DS    0C                  TEXT TO COMPARE\n*\n**       EXTENSION FOR MLWTO LINE NUMBER TESTS\n*\n         ORG   ATSEXTN\nATSSEQ#  DS    CL4                 MLWTO SEQUENCE NUMBER\nATSLNCNT DS    H                   MINOR WQE LINE COUNT\n         ORG   ,\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TLINE": {"ttr": 35594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x07\\x00\\x07\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         TLINE  &LIT\n         B   X&SYSNDX\nLIT&SYSNDX DC   C&LIT\nX&SYSNDX DS    0H\n         TPUT  LIT&SYSNDX,L'LIT&SYSNDX\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSLRACF": {"ttr": 35596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x07\\x01\\x021\\x9f\\x01\\x022\\x1f\\x16\\x13\\x012\\x017\\x00\\x15\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-17T16:13:07", "lines": 306, "newlines": 311, "modlines": 21, "user": "EDJXADM"}, "text": "        TITLE  'T S S O   R A C F   LOGON/LOGOFF PROCESSING'\nTSSLRACF CSECT\n***********************************************************************\n* THIS IS THE RACF VERSION OF THE TSSO .LOGON COMMAND. THE FUNCTION   *\n* OF THIS MODULE IS TO GET RACF TO CREATE AN ACEE FOR THE CONSOLE     *\n* WHO IS ATTEMPTING TO LOGON.                                         *\n*                                                                     *\n* PARAMETERS PASSED:                                                  *\n* R1 POINTS TO A 24 BYTE AREA. THE LAYOUT OF THE AREA, AND THE        *\n*    EXPECTED RESULTS ARE DOCUMENTED BELOW.                           *\n*                                                                     *\n*                                                                     *\n* FIELD NAME    LENGTH     INPUT                     OUTPUT           *\n*                                                                     *\n*    PRMFLAG       2      BYTE 1                                      *\n*                         X'80' - LOGON               NONE            *\n*                         X'40' - LOGOFF                              *\n*                                                                     *\n*                                                                     *\n*    (none)        2      Reserved for future use               EEJ1102\n*                                                                     *\n*                                                                     *\n*    PRMACEE       4      LOGON - NULL                LOGON - ADDRESS *\n*                         LOGOFF - ACEE OF USER             OF ACEE OF*\n*                                  LOGGING OFF TSSO.      NEWLY LOGGED*\n*                                                         ON USER.    *\n*                                                                     *\n*    PRMUSER       8      USERID SPECIFIED ON                         *\n*                         LOGON COMMAND, OR USERID    NONE            *\n*                         ATTEMPTING TO LOGOFF.                       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*    PRMPASS       8      PASSWORD SPECIFIED ON       NONE            *\n*                         LOGON COMMAND.                              *\n*                                                                     *\n*    PRMCNID       4      Console ID                  None      EEJ1102\n*                                                               EEJ1102\n*    PRMCNAME      8      Console name                None      EEJ1102\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*    RETURN CODES:                                                    *\n*                                                                     *\n*    R15 = 0 : FUNCTION OK                                            *\n*    R15 = 4 : FUNCTION FAILED.                                       *\n*                                                                     *\n* THE MODULE WILL ISSUE ITS OWN MESSAGES FOR FAILURE REASONS....      *\n*                                                                     *\n*                                                                     *\n* MODULE HISTORY:                                                     *\n*    7/25/86: TSSO 4.3: MODIFIED TO SUPPORT THE SAF INTERFACE.        *\n*                                                               EEJ1102\n*    NOV 2002 EEJ  Support MCS Extended Consoles                EEJ1102\n*                                                                     *\n* NOTES:                                                              *\n*                                                                     *\n*    THIS MODULE SHOULD WORK FOR ANY SECURITY SYSTEM THAT CLAIMS TO   *\n*    SUPPORT THE SAF INTERFACE.                                       *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSLRACF,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=2048         GET STORAGE FOR A LOCAL      EEJ1102\n         LR    R11,R1             DATA AREA\n         USING TSSLDATD,R11       AND TELL ASSEMBLER\n*                                                   PREPROCESSING EXIT\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO2D(WTO2CE-WTO2C),WTO2C\n         MVC   WTO3D(WTO3CE-WTO3C),WTO3C\n         MVC   RACINI1D(RACINI1E-RACINI1C),RACINI1C\n         MVC   RACINI2D(RACINI2E-RACINI2C),RACINI2C\n*\n         TM    0(R8),X'80'        LOGGING ON ?\n         BO    LON\n         TM    0(R8),X'40'        LOGGING OFF ?\n         BO    LOFF\n         B     LRACFERR\nLOFF     DS    0H\n***********************************************************************\n* WE COME HERE IF WE ARE TRYING TO LOG A CONSOLE OFF OF TSSO.         *\n*                                                                     *\n***********************************************************************\n         LA    R2,4(R8)            GET ACEE OF USER LOGGING OFF...\n         LTR   R2,R2\n         BZ    LRACFERR            IF NO ACEE - LOGICAL ERROR\n*        RACINIT ACEE=(R2),MF=(E,RACINI2D)\n         RACROUTE REQUEST=VERIFY,ACEE=(R2),WORKA=(R11),MF=(E,RACINI2D)\n*\n*        LTR   R15,R15\n*        BNZ   SAFFAIL              BAD NEWS... SAF FAILED...\n*\n         L     R15,RACINI2D         GET RACF RETURN CODE\n         LTR   R15,R15\n         BZ    DELOK\n         WTO   'TSSL456S ERROR DELETING RACF ACEE - CONTACT SYSTEM PROGX\n               RAMMER',DESC=1\n         B     LRACRC12\n*\nDELOK    DS    0H\n         MVC   WTO3D+21(8),28(R8)   Copy console name           EEJ1102\n         MVC   WTO3D+31(8),8(R8)    Copy user ID                EEJ1102\n         WTO   MF=(E,WTO3D)         (MSG 456)\n         B     ENDPROG\n*\n*\n*\nLON      DS    0H\n***********************************************************************\n* HERE, WE WILL LOGON A USER. THIS IS ACCOMPLISHED BY ISSUING THE     *\n* APPROPRAITE RACINIT CALL -                                          *\n***********************************************************************\n         MVC   CONSOLE,24(R8)      Copy console ID              EEJ1102\nCHECKPW  DS    0H\n         LA    R2,8\n         LA    R3,8(R8)\n         XR    R4,R4\nUIDLOOP  DS    0H\n         CLI   0(R3),C' '\n         BE    FNDUSER\n         LA    R3,1(R3)\n         LA    R4,1(R4)\n         BCT   R2,UIDLOOP\n         B     INVUSER\nFNDUSER  DS    0H\n         STC   R4,RACUSER\n*\n         LA    R2,8\n         LA    R3,16(R8)\n         XR    R4,R4\nPWLOOP   DS    0H\n         CLI   0(R3),C' '\n         BE    FNDPW\n         OI    0(R3),X'40'          MAKE UPPER CASE\n         LA    R3,1(R3)\n         LA    R4,1(R4)\n         BCT   R2,PWLOOP\nFNDPW    DS    0H\n         LTR   R4,R4                 ANY PASSWORD ENTERED ?\n         BZ    BADPW\n         STC   R4,RACPASS\n*\n         MVC   RACUSER+1(8),8(R8)\n         MVC   RACPASS+1(8),16(R8)\n         XC    ACEEADDR(4),ACEEADDR\n         LA    R2,ACEEADDR\n*        RACINIT USERID=RACUSER,PASSWRD=RACPASS,ACEE=(R2),            X\n*              MF=(E,RACINITD)\n         RACROUTE REQUEST=VERIFY,USERID=RACUSER,PASSWRD=RACPASS,       X\n               ACEE=(R2),WORKA=(R11),MF=(E,RACINI1D)\n*\n*        LTR   R15,R15               CHECK SAF RETURN CODE\n*        BNZ   SAFFAIL               SAF FAILED...\n*\n         L     R15,RACINI1D          GET RETURN CODE...\n*\n         C     R15,=XL4'00000030'    WAS RC OK\n         BH    BADRC\n         LTR   R15,R15\n         BM    BADRC\n         B     *+4(R15)              LETS SEE WHAT HAPPENED\n         B     RACOK                 Y E S !!\n         B     NOTDEF\n         B     INVPW\n         B     EXPIRED\n         B     BADRC\n         B     BADRC\n         B     BADRC\n         B     REVOKED\n         B     BADRC\n         B     REVOKED\n         B     BADRC\n         B     BADRC\n         B     BADRC\nNOTDEF   DS    0H\n         MVC   ERRMSG(40),=CL40'XXXXXXXX IS NOT DEFINED TO RACF'\n         MVC   ERRMSG(8),RACUSER+1\n         B     WTOMSG\nINVPW    DS    0H\n         MVC   ERRMSG(40),=CL40'LOGON REJECTED - INCORRECT PASSWORD'\n         B     WTOMSG\nEXPIRED  DS    0H\n         MVC   ERRMSG(40),=CL40'LOGON REJECTED - EXPIRED PASSWORD'\n         B     WTOMSG\nREVOKED  DS    0H\n         MVC   ERRMSG(40),=CL40'LOGON REJECTED - REVOKED USERID'\n         B     WTOMSG\nBADPW    DS    0H\n         MVC   ERRMSG(40),=CL40'LOGON REJECTED - NULL PASSWORD ENTERED'\n         B     WTOMSG\nINVUSER  DS    0H\n         MVC   ERRMSG(40),=CL40'LOGON REJECTED - USERID > 7 CHARACTERS'\n         B     WTOMSG\nSAFFAIL  DS    0H\nBADRC    DS    0H\n         LA    R10,WORKAREA\n         LR    R1,R15\n         CALL  JCECVTBH\n         MVC   ERRMSG(40),=CL40'SAF ERROR -    RC IS XXXXXXXX'\n         STCM  R0,B'1111',ERRMSG+21\n         STCM  R1,B'1111',ERRMSG+25\n         B     WTOMSG\nRACOK    DS    0H\n***********************************************************************\n* WE COME HERE IF THE USER HAS ACTUALLY BEEN SUCCUSSFULLY LOGGED ON   *\n* TO RACF.                                                            *\n***********************************************************************\n         L     R2,ACEEADDR          GET RACF PROVIDED ACEE ADDRESS\n         ST    R2,4(R8)             AND PUT IT AWAY...\n         LA    R10,WORKAREA\n         MVC   WTO2D+21(8),28(R8)   Copy console name           EEJ1102\n         MVC   WTO2D+51(8),RACUSER+1 Copy user ID               EEJ1102\n         WTO   MF=(E,WTO2D)\n         XC    RETCODE(2),RETCODE     ZERO RETURN CODE\n         B     ENDPROG\nWTOMSG   DS    0H\n***********************************************************************\n* THIS ROUTINE WILL PRINT THE MESSAGE IN VARIABLE ERRMSG ON THE MVS   *\n* CONSOLE THAT THE LOGON WAS ATTEMPTED FOR.                           *\n***********************************************************************\n         MVC   WTO1D+13(40),ERRMSG\n         WTO   CONSID=CONSOLE,MF=(E,WTO1D)                      EEJ1102\n         B     LRACRC12\nLRACFERR DS    0H\n         MVC   ERRMSG(40),=CL40'LOGICAL ERROR PROCESSING LOGON REQUEST'\n         B     WTOMSG\nLRACRC12 DS    0H\n         MVC   RETCODE(2),=H'12'\n         B     ENDPROG\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n*\nWTO1C    WTO   'TSSL452I                                         ',    X\n               CONSID=,MF=L                                     EEJ1102\nWTO1CE   EQU   *\n*\nWTO2C    WTO   'TSSL455I CONSOLE XXXXXXXX LOGGED ON TO TSSO AS XXXXXXXXX\n               ',MCSFLAG=BRDCST,MF=L\nWTO2CE   EQU   *\n*\nWTO3C    WTO   'TSSL457I CONSOLE XXXXXXXX (XXXXXXXX) LOGGED OFF TSSO', X\n               MCSFLAG=BRDCST,MF=L\nWTO3CE   EQU   *\nRACINI1C RACROUTE REQUEST=VERIFY,ENVIR=CREATE,SMC=YES,PASSCHK=YES,MF=L\nRACINI1E EQU   *\n*\nRACINI2C RACROUTE REQUEST=VERIFY,ENVIR=DELETE,SMC=YES,MF=L\nRACINI2E EQU   *\n*\n*\n*\n*\n***********************************************************************\n* TSSLRACF ONLY DATA AREA.                                            *\n*                                                                     *\n***********************************************************************\nTSSLDATD DSECT\nWORKAREA DS    CL512\nCONSOLE  DS    F\nRACUSER  DS    CL9          USERID FOR RACINIT.\nRACPASS  DS    CL9          PASSWORD FOR RACINIT.\nRETCODE  DS    F\nACEEADDR DS    F\nERRMSG   DC    CL40' '\nWTO1D    WTO   'TSSL452I                                         ',    X\n               CONSID=,MF=L                                     EEJ1102\n*\nWTO2D    WTO   'TSSL455I CONSOLE XXXXXXXX LOGGED ON TO TSSO AS XXXXXXXXX\n               ',MCSFLAG=BRDCST,MF=L\n*\n*\nWTO3D    WTO   'TSSL457I CONSOLE XXXXXXXX (XXXXXXXX) LOGGED OFF TSSO', X\n               MCSFLAG=BRDCST,MF=L\n*\nRACINI1D RACROUTE REQUEST=VERIFY,ENVIR=CREATE,SMC=YES,PASSCHK=YES,MF=L\n*\nRACINI2D RACROUTE REQUEST=VERIFY,ENVIR=DELETE,SMC=YES,MF=L\n*\n         END   TSSLRACF\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSLRACF(''TSSO V 4.3.0  &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSLRACF'\n PUNCH ' NAME     TSSLRACF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSSO": {"ttr": 35843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00A\\x01\\x022\\x1f\\x01\\x07\\x06\\x9f!\"\\x03\\x9c\\x03\\x9a\\x00\\x04\\xc4\\xd9\\xc3\\xc9\\xc3\\xe2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2007-03-10T21:22:41", "lines": 924, "newlines": 922, "modlines": 4, "user": "DRCICS"}, "text": "         TITLE 'T S S O   M A I N L I N E  M O D U L E '\n&WTOR    SETC  'YES'                   INCLUDE SUPPORT FOR WTOR REPLY\nTSSO     CSECT\n***********************************************************************\n* THIS IS THE MAINLINE ROUTINE OF TSSO. IT IS RESPONSIBLE FOR THE     *\n* INITIALIZATION AND TERMINATION OF THE SUBSYSTEM ADDRESS SPACE.      *\n* TSSO WILL LINK TO THE TSSOMAIN ROUTINE FOLLOWING INITIALIZATION.    *\n*                                                                     *\n* VERSION IDENTIFIER: TSSO 4.3                                        *\n* DATE: 2/25/86                                                       *\n* AUTHOR: MARC SCHARE                                                 *\n*                                                                     *\n*                                                                     *\n* CHANGE LOG:                                                         *\n*                                                                     *\n* NOTE: LAST MESSAGE ID FOR TSSO MAINLINE MODULE IS 73.               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n* R11: TSSO DATA AREA (TSSOVARS)                                      *\n* R10: TSSO CVT AFTER ITS AVAILABLE.                                  *\n* R9 : TSSODATD DATA AREA                                             *\n* R8 : TSSO SSCT ENTRY                                                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*   15OCT92  GLA   CANCEL ESTAE WHEN WE TERMINATE.                    *\n*                                                                     *\n*   29OCT92  GLA   SET MASTCONS OF ZERO IF NO UCMLIST (HARDWARE       *\n*                  SYSCONS AS MASTER)                                 *\n*                                                                     *\n*   30OCT92  GLA   SPLIT LOAD OF AOF TABLE INTO SEPERATE MODULE, AND  *\n*                  ADD BINARY SEARCH ROUTINE.                         *\n*                                                                     *\n*   14DEC92  GLA   ADD SUPPORT FOR MPFSUPP PARAMETER.                 *\n*                                                               EEJ1102\n*   NOV 2002 EEJ   Acquire proper work area size                EEJ1102\n*                                                                     *\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSO,R12           GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         LTR   R15,R15\n         BNZ   GETMERR            GETMAIN FAILED\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                 SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n***********************************************************************\n* GETMAIN STORAGE FOR THE VARIABLES THAT ARE TI BE ACCESSED ONLY BY   *\n* THE TSSO MAINLINE CODE. R11 WILL POINT TO THIS STORAGE FOR THE LIFE *\n* OF TSSO.                                                            *\n***********************************************************************\n         GETMAIN R,LV=4096              ** FOR TSSO PRIVATE VARIABLES\n         LR    R11,R1                   ** REMEMBER IT.\n         USING TSSOVARS,R11\n         MVC   LINK1D(LINK1CE-LINK1C),LINK1C\n         MVC   LOAD1D(LOAD1CE-LOAD1C),LOAD1C\n*\n*\n***********************************************************************\n* STEP 0 - MAKE SURE THAT THE TSSO NDSA ACTUALLY EXISTS...            *\n***********************************************************************\nSTEP0    DS    0H\n         GETCVT (R2),NDSA=YES\n         LTR   R2,R2\n         BNZ   STEP1               NDSA PRESENT - CONTINUE INIT.\n         LINK  EP=TSSOINIT         OBTAIN NDSA\n         GETCVT (R2),NDSA=YES      TRY AGAIN TO OBTAIN NDSA\n         LTR   R2,R2               SUCCESS ?\n         BNZ   STEP1               YES, CONTINUE INIT\n         DROP  R2                                                   RPS\nNONDSA   DS    0H\n         WTO   'TSSI072S TSSONDSA IS NOT PRESENT, AND COULD NOT BE OBTAX\n               INED. CONTACT SYSTEMS PROGRAMMER',DESC=1\n         B     ENDPROG0\n*\n*\n*\n***********************************************************************\n* STEP 1 - INITIALIZE THE TSSO VARIABLES IN THE TSSO COMMUNICATIONS   *\n*          AREA. THIS IS DONE TO PRESERVE THE ADDRESSABILITY OF THIS  *\n*          AREA TO ONE BASE REGISTER. GETMAIN THE DATD AREA.          *\n***********************************************************************\n*\nSTEP1    DS    0H\n         L     R2,=A(DATDLEN)      Get data area soze           EEJ1102\n         GETMAIN R,LV=(2)         ** FOR VARIABLES SHARED AMONG EEJ1102\n*                                       ** TSSO ROUTINES\n         LR    R9,R1\n         USING DATD,R9\n*\n***********************************************************************\n* LINK TO THE TSSO INITIALIZATION MODULE TO FILL IN THE DATD VARS.    *\n***********************************************************************\n         LINK  EP=TSSOINI1,PARAM=((R9)),SF=(E,LINK1D),MF=(E,LINKPARM)\n         ST    R8,PARMPTR               REMEMBER ADDRESS OF PARAMETERS\n*                                       THIS IS REQUIRED FOR THE\n*                                       INITIALIZATION SECTION -\n*                                       PARMLIB PROCESSING.\n*\n         B     STEP2\n*\n*\nSTEP2    DS    0H\n***********************************************************************\n* STEP 2 OF TSSO INITIALIZATION IS TO PROCESS THE PARMLIB MEMBER      *\n* SPECIFIED... SINCE PARMLIB PROCESSING IS A LENGTHY PROCEDURE, IT    *\n* IS DONE PRIMARILY IN MODULE TSSOINI2. WE WILL LINK TO THE MODULE    *\n* HERE. STEP 2 WILL ALSO BE USED TO CHECK IF TSSO IS ALREADY UP.      *\n* IT MAY NOT BE CORRECT TO PLACE IT HERE, BUT WE NEED TO BE ABLE TO   *\n* PROCESS THE \"FORCE\" PARAMETER.                                      *\n***********************************************************************\n         LINK  EP=TSSOINI2,PARAM=((R9)),SF=(E,LINK1D),MF=(E,LINKPARM)\n         LTR   R15,R15\n         BNZ   ENDPROG\n*\n         GETCVT (R8),SSCT=YES      GET A POINTER TO TSSO SSCT ENTRY\n         LTR   R15,R15             WAS IT FOUND ?\n         BNZ   NOTUP               TSSO IS NOT UP, LET SOMEONE ELSE\n*                                  MENTION THE SSCT ISNT THERE.\n         DROP  R8                                                RPS\n         USING SSCT,R8            ADDRESS THE SSCT\n         L     R10,SSCTSUSE         PICK UP TSSO CVT\n         LTR   R10,R10             IS THERE ONE ?\n         BZ    NOTUP               TSSO IS NOT UP, THIS IS GOOD NEWS\n         DROP  R8\n***********************************************************************\n* WHEN WE GET HERE, WE HAVE DETECTED THAT TSSO IS TRYING TO RESTART.  *\n* THIS WILL NOT BE PERMITTED, UNLESS THE FORCE PARAMETER IS IN EFFECT *\n***********************************************************************\nALREADUP DS    0H\n         CLI   STARFORC,C'Y'       IS FORCE IN EFFECT ?\n         BE    STP2ALUP            NO, BLOW TSSO AWAY...\n***********************************************************************\n* HERE, FORCE IS NOT IN EFFECT, DO NOT ALLOW THE TSSO RESTART.        *\n***********************************************************************\nSTP2DNST DS    0H\n         WTO   'TSSI070E TSSO IS ALREADY ACTIVE - START REJECTED'\n         B     ENDPROG\n*\nSTP2ALUP DS    0H\n         WTO   'TSSI071I WARNING - TSSO IS ALREADY ACTIVE - INITIALIZATX\n               ION CONTINUES DUE TO FORCE OPTION'\n         B     NOTUP\nNOTUP    DS    0H\n*\n         B     STEP3\n*\n*\n*\n*\n*\nSTEP3    DS    0H\n***********************************************************************\n* STEP3 OF TSSO INITIALIZATION IS TO LOAD THE TSSOWTO PROGRAM INTO    *\n* THE TSSO ADDRESS SPACE.                                             *\n***********************************************************************\nLOADWTO  DS    0H\n***********************************************************************\n* THIS IS THE OUTPUT PROCESSOR                                        *\n* FOR TSSO, AND CURRENTLY, ONE OF THE WAYS THAT TSSO WILL ISSUE       *\n* COMMANDS. THE MODULE IS LOADED ONCE, AND BRANCHED TO WHEN NEEDED.   *\n* IT IS DELETED AT TASK TERMINATION.                                  *\n***********************************************************************\n         LOAD  EP=TSSOWTO,ERRET=NOTSSWTO\n         ST    R0,WTOADDR\n         B     STEP4\nNOTSSWTO DS    0H\n         WTO   'TSST051S TSSO TERMINATING BECAUSE OF NO TSSOWTO MODULE'X\n               ,DESC=(1)\n         B     EXIT0\n*\n*\n*\n*\n*\nSTEP4    DS    0H\n***********************************************************************\n* STEP 4 OF TSSO INITIALIZATION IS TO SET UP THE TSSO COMMAND RING.   *\n* THIS DATA AREA IS USED BY TSSO TO QUEUE UP TSSO COMMANDS FROM       *\n* CONSOLES WHEN TSSO IS DOING SOMETHING ELSE.                         *\n***********************************************************************\nGETRING  DS    0H\n         L     R2,MAXCMDS          GET VALUE FOR MAX COMMANDS\n         SLL   R2,8                MULTIPLY BY 256- SIZE PER ENTRY\n         MODESET KEY=ZERO\n***********************************************************************\n* NOTE THAT KEY ZERO IS OBTAINED BECAUSE WE DO NOT WANT UNAUTHORIZED  *\n* USERS TO TRAMP ALL OVER OUR COMMAND RING.                           *\n***********************************************************************\n         GETMAIN R,LV=(R2),SP=241   GET THE STORAGE\n         ST    R1,CMDRINGL         AND PUT IT IN CMDRING\n*\n         L     R1,CMDRINGL\n         LR    R2,R1               COPY STARTING ADDRESS\n         L     R4,MAXCMDS          GET MAX COMMAANDS AGAIN\n         BCTR  R4,0                SUBTRACT 1 FOR LOOP\nCMNDLOOP DS    0H\n         XC    0(256,R2),0(R2)     ZERO OUT STORAGE\n         LA    R3,256(R2)          POINT TO NEXT ENTRY\n         ST    R3,0(R2)            AND STORE ENTRY IN POINTER FIELD\n         LR    R2,R3               MAKE EM EQUAL\n         BCT   R4,CMNDLOOP         DO IT AGAIN\n*\n         XC    0(256,R2),0(R2)     ZERO OUT STORAGE\n         L     R3,CMDRINGL\n         ST    R3,0(R2)            COMPLETE THE RING\n         ST    R3,CURRCMD          MARK THIS AS CURRENT COMMAND\n*                                  THE NEXT COMMAND IN RING\n         MODESET KEY=NZERO\n         B     STEP5\n*\n*\n*\n*\n*\nSTEP5    DS    0H\n***********************************************************************\n* STEP 5 OF THE TSSO INITIALIZATION PROCESS IS TO DYNAMICALLY CHANGE  *\n* THE RACF USERID OF THE TSSO ADDRESS SPACE TO SOME OTHER VALUE. THIS *\n* IS DONE IN THE TSSOINI3 MODULE.                                     *\n***********************************************************************\nGETRACF  DS    0H\n*\n         LR    R1,R9            GET ADDRESS OF DATD MODULE\n         LINK  EP=TSSOINI3,SF=(E,LINK1D)\n*\n         B     STEP6\n*\n*\n*\n*\n*\nSTEP6    DS    0H\n***********************************************************************\n* STEP 6 OF THE TSSO INITIALIZATION PROCESS IS TO OBTAIN THE ADDRESSES*\n* OF SEVERAL MVS CONTROL BLOCKS, AND PUT THEM AWAY FOR LATER USE.     *\n***********************************************************************\n         SPACE\n         L     R2,X'21C'           PSATOLD-PSA\n         ST    R2,TSSOTCB          SAVE TCB ADDRESS\n*\n         USING TCB,R2\n         L     R2,TCBJSCB          GET JSCB FIELD\n         USING IEZJSCB,R2\n*\n         L     R2,JSCBACT          MAKE SURE ITS ACTIVE JSCB\n         ST    R2,TSSOJSCB\n*\n         L     R2,JSCBSSIB         AND PLUCK OFF SSIB FIELD\n         ST    R2,HOLDSSIB         PUT IT AWAY FOR NOW\n         B     STEP7\n*\nSTEP7    DS    0H\n***********************************************************************\n* STEP 7 OF THE TSSO INITIALIZATION PROCESS IS TO LOCATE THE TSSO SSCT*\n* ENTRY. THIS IS DONE THROUGH A MACRO CALL.                           *\n***********************************************************************\n         GETCVT (R8),SSCT=YES      GET A POINTER TO TSSO SSCT ENTRY\n         LTR   R15,R15             WAS IT FOUND ?\n         BNZ   NOSSCT\n         USING SSCT,R8            ADDRESS THE SSCT\n         L     R10,SSCTSUSE         PICK UP TSSO CVT\n         LTR   R10,R10             IS THERE ONE ?\n         BNZ   RESTART             YES, THIS MUST BE A RESTART\n         B     STEP8\n         DROP  R8\nRESTART  DS    0H\n*\n***********************************************************************\n* STEP 8 OF THE TSSO INITIALIZATION PROCESS IS TO DO A GETMAIN OF THE *\n* TSSO CVT. THE ADDRESS OF THIS GLOBAL DATA AREA IS THEN STORED IN    *\n* THE SSCTSUSE FIELD OF TSSO'S SSCT ENTRY. THIS AREA IS ACCESSABLE    *\n* FROM ANY ADDRESS SPACE.                                             *\n***********************************************************************\nSTEP8    DS    0H\n         MODESET KEY=ZERO\n         GETMAIN R,LV=1024,SP=228\n         LR    R10,R1\n         USING TSSOCVT,R10\n         XC    0(256,R1),0(R1)            ZERO OUT CVT\n         XC    256(256,R1),256(R1)\n         XC    512(256,R1),512(R1)\n         XC    768(256,R1),768(R1)\n         USING SSCT,R8\n         ST    R10,SSCTSUSE        STORE TSSO CVT ADDRESS\n         ST    R10,TSSOCVTA        ALSO SAVE IN DATD DSECT      30OCT92\n         DROP  R8\n         MODESET KEY=NZERO\n         B     STEP9\n*\n*\n*\n*\n*\nSTEP9    DS    0H\n***********************************************************************\n* STEP 9 OF THE TSSO INITIALIZATION PROCESS IS TO POPULATE THE        *\n* TSSOCVT WITH THE VALUES WE HAVE OBTAINED SO FAR. NOTE THAT R10      *\n* SERVES AS THE BASE REGISTER FOR THE TSSO CVT.                       *\n***********************************************************************\n         MODESET KEY=ZERO\n         XC    TSSOFLG1,TSSOFLG1   ZERO STATUS BYTE\n         MVC   NUMCMDS(4),MAXCMDS    FILL IN MAX COMMANDS\n         MVC   TSSOSSIB(4),HOLDSSIB\n         MVC   TSSOCHAR(1),TSSOSRC   DEFAULT IS A '#'\n         MVC   CMDRING(4),CMDRINGL\n         MVC   NEXTCMD(4),CMDRING    MARK FIRST PLACE   FOR SSSM\n*                                     TO PUT COMMAND\n         CLI   TSSOMPF,C'Y'          WHAT TO DO ABOUT MPF       14DEC92\n         BNE   *+8                                              14DEC92\n         OI    TSSOFLG1,TSSOSMPF     OBEY MPF SUPPRESSION FLG   14DEC92\n         L     R1,X'224'          ASCB ADDRESS\n         ST    R1,TSSOASCB        NEEDED FOR CROSS MEMORY POST OF\n*                                 TSSO FROM TSSOSS10\n         ST    R9,TSSODSEC        MAKE DATD EASILY ADDRESSABLE FROM\n*                                 ALL TSSO MODULES.\n*\n         MVC   SECLEVEL(4),INISEC   COPY IN SPECIFIED SECURITY LVL\n         MVC   SECTMEOT(4),TMEOTVL  COPY IN TIMEOUT VALUE FROM PARMS..\n         ST    R8,TSSOSSCT         SAVE SSCT ADDRESS\n         MODESET KEY=NZERO\n         B     STEP10\n*\n*\n*\n*\n*\n***********************************************************************\n* STEP 10 OF THE INITIALIZATION PROCESS IS TO TAKE STEPS TO KEEP THE  *\n* TSSO ADDRESS SPACE AROUND ALL DAY, NOT LETTING IT SUCCUMB TO THE    *\n* JOB WAIT TIME PARAMETER SPECIFIED TO SMF.                           *\n***********************************************************************\nSTEP10   DS    0H\n         L     R2,X'224'          GET ASCB ADDRESS...\n         USING ASCB,R2            MOVE HIGH NUMBER INTO JOB WAIT TIME\n*                                 SO TSSO WILL NOT TIME OUT.\n         L     R6,=F'986400'       ALL DAY.. ALL NIGHT ...\n         MODESET KEY=ZERO\n         ST    R6,ASCBSWTL        STICK IN JOB WAIT TIME.\n         MODESET KEY=NZERO\n         DROP  R2\n         B     STEP11\n*\n*\n*\n*\n*\n***********************************************************************\n* STEP 11 OF THE INITIALIZATION PROCESS IS TO SET UP THE TSSO ESTAE   *\n* TO CLEAN UP ANY ABENDS THAT MAY OCCUR. THIS ESTAE IS IN EFFECT FOR  *\n* THE LIFE OF THE JOB.                                                *\n***********************************************************************\nSTEP11   DS    0H\n         LOAD  EP=TSSOESTA,ERRET=BADESTAE,LSEARCH=YES\n         LR    R6,R0              SAVE ENTRY POINT\n         ESTAE (R6),TERM=YES,PARAM=(R10),MF=(E,ESTAED)\n*\n         LTR   R15,R15\n         BNZ   BADESTAE\n         B     OKESTAE\nBADESTAE DS    0H\n         WTO   MF=(E,WTO9D)     ** GIVE USER BAD NEWS **  (MSG 52)\n         B     EXIT0\n         EJECT\nOKESTAE  DS    0H\n         B     STEP12\n*\n*\n*\n*\n*\nSTEP12   DS    0H\n***********************************************************************\n* STEP 12 OF THE INITIALIZATION PROCESS IS TO START FILLING IN THE    *\n* SSVT FOR TSSO. TSSO MUST GETMAIN THE SSVT, AND PLUG IN ENTRIES FROM *\n* THE SSIARRAY. THIS IS DONE AT A LATER STEP.                         *\n***********************************************************************\n         GETCVT (R2),SSCT=YES      IS OUR SSVT IN?\n         L     R2,SSCTSSVT\n         LTR   R2,R2\n         BZ    NOSSVT              BRANCH IF ALREADY IN\n         USING SSVT,R2\n         SPACE\n         WTO   'TSST053A SSVT LOCATED FOR TSSO- MULTIPLE TSSO ADDRESS SX\n               ACES MAY EXIST',DESC=(6)\nNOSSVT   DS    0H\n         MODESET KEY=ZERO\n         GETMAIN R,LV=1024+256+4+4,SP=241\n* THE ABOVE INSTRUCTION GETMAINS THE SPACE NEEDED FOR THE TSSO\n* SSVT. THE LENGTHS ARE: 1024 FOR THE FUNCTION ROUTINE ADDRESSES\n*                         256 FOR THE ONE BYTE LENGTH\n*                           4 FOR THE SSVT HEADER\n*                           4 FOR THE BCR SSVT IDENTIFIER (SSVT)\n*                        1284 ==== TOTAL\n         XC    0(256,R1),0(R1)          ZERO OUT THE TSSO SSVT\n         XC    256(256,R1),256(R1)\n         XC    512(256,R1),512(R1)\n         XC    768(256,R1),768(R1)\n         XC    1024(256,R1),1024(R1)\n         XC    1280(4,R1),1280(R1)\n         SPACE\n         MVC   0(4,R1),=C'SSVT'    MOVE IN IDENTIFIER.\n         LA    R2,4(,R1)           GET ADDRESS OF ACTUAL SSVT\n* R2 POINTS TO THE SSVT AS IT WILL BE PRESENTED TO MVS...\n         ST    R2,TSSOSSVT         SAVE SSVT ADDRESS\n         MODESET KEY=NZERO\n         B     STEP13\n*\n*\n*\n*\n*\n***********************************************************************\n* STEP 13 OF TSSO INITIALIZATION IS TO LOAD THE SUBSYSTEM MONITORS    *\n* SPECIFIED IN THE PARAMETER DECK. THESE PARAMETERS ARE ADDED TO THE  *\n* SSIARRAY, WHICH IS RESIDENT IN THE TSSODATD AREA.                   *\n***********************************************************************\nSTEP13   DS    0H\n         LA    R7,SSIARRAY        USE REG 7 AS THE BASE FOR SSIARRAY\n         LH    R6,SSICOUNT        HOW MANY MODULES ARE WE LOADING\n* NOW, LOOP ON THE NUMBER OF MODULES SPECIFIED, LOADING EACH INTO\n* GLOBAL STORAGE.\nSSILOADL DS    0H\n         LA    R5,8(R7)\n         LOAD  EPLOC=(R5),GLOBAL=(YES,P),LSEARCH=YES,ERRET=SSILOADB,   X\n               SF=(E,LOAD1D)\n         ST    R0,16(R7)          STORE LOAD MODULE ADDRESS\n         LR    R5,R0              COPY ENTRY POINT\n         MVC   20(8,R7),10(R5)    SAVE DATE\n         MVC   28(8,R7),18(R5)    AND TIME\n         LA    R7,36(R7)          BUMP TO NEXT ENTRY\n         BCT   R6,SSILOADL        AND LOOP BACK.\n         B     STEP14             WHEN DONE, GO TO THE NEXT STEP.\nSSILOADB DS    0H\n         MVC   WTO39D+49(8),8(R7)\n         WTO   MF=(E,WTO39D)          (MSG 54)\n         B     EXIT0\n*\n*\n*\n*\n*\nSTEP14   DS    0H\n***********************************************************************\n* STEP 14 OF TSSO INITIALIZATION IS TO BUILD THE TSSO SSVT. THIS IS   *\n* DONE BY USING THE INFORMATION FROM THE SSIARRAY, AND PLUGGING INTO  *\n* THE SSVT IN THE FORMAT EXPECTED BY MVS.                             *\n***********************************************************************\nBLDSSVT  DS    0H\n         SPACE\n         XR    R4,R4               R4 WILL KEEP A COUNT OF THE NUMBER\n*                                  OF ENTRIES LOADED SO FAR. THIS COUNT\n*                                  STARTS AT ZERO.\n         LH    R5,SSICOUNT         GET COUNT OF NUMBER OF ROUTINES\n*                                  TO LOAD...\n         LA    R6,SSIARRAY         REG 6 POINTS TO THE START OF THE\n*                                  SSIARRAY TABLE...\n         L     R7,TSSOSSVT         REG 7 POINTS TO THE START OF THE\n*                                  SSVT MODULE THAT WAS GETMAINED\n         MODESET KEY=ZERO\n         STH   R5,2(0,R7)          STORE COUNT OF ROUTINES INTO SSVT\n         LA    R7,4(R7)\n         LA    R8,256(R7)          REG 8 POINTS TO THE POINTERS FOR THE\n*                                  FUNCTION ROUTINE ADDRESSES.\nLOADTAB  DS    0H\n         LH    R3,0(R6)            GET SUBSYSTEM FUNCTION NUMBER E.G.\n*                                  10 = OPERATOR COMMAND\n         BCTR  R3,0                SUBTRACT ONE FOR STC BECAUSE\n*                                  THE SSVT FUNCTION CODES START AT\n*                                  1 INSTEAD OF ZERO, SO 10(R7) IS\n*                                  FUNCTION CODE 11.\n         LA    R4,1(R4)            BUMP UP COUNTER\n         STC   R4,0(R3,R7)         PLACE THE NUMBER INTO THE\n*                                  SUBSYSTEM FUNCTION TABLE. THE\n*                                  OFFSET WILL BE THE COUNT IN REG 1\n         L     R3,16(R6)           POINT AT ADDRESS OF ROUTINE TO HAND\n*                                  LE THE FUNCTION.\n         ST    R3,0(R8)            STORE THAT ADDRESS INTO THE\n*                                  FUNCTION ADDRESS POINTER TABLE\n         LA    R8,4(R8)            POINT TO MEXT FUNCTION ROUTINE\n*                                  ADDRESS\n         LA    R6,36(R6)           POINT TO NEXT ENTRY IN TABLE\n         BCT   R5,LOADTAB\n         MODESET KEY=NZERO\nENDSTP14 DS    0H\n* AT THIS POINT, THE SSVT HAS BEEN LOADED, AND ALL THAT REMAINS IS TO\n* CONNECT THE SSVT INTO THE MVS TABLE. THIS IS DONE AS THE LAST STEP\n* OF TSSO INITIALIZATION.\n*\n*\n*\n*\nSTEP15   DS    0H\n***********************************************************************\n* STEP 15 OF TSSO INITIALIZATION IS TO BUMP UP THE COUNT OF SUBSYSTEMS*\n* RECEIVING WTO MESSAGES BY ONE. WE WILL ALSO TEST FOR THIS COUNT     *\n* BEING NEGATIVE, AND ISSUE A MESSAGE IF THIS IS TRUE.                *\n* THIS SECTION OF CODE ALSO OBTAINS THE MASTER CONSOLE, AND STORES IT *\n* IN THE TSSODATD AREA.                                               *\n***********************************************************************\n* THIS SECTION OF CODE WILL BUMP UP THE COUNT OF SUBSYSTEM\n* ACCEPTING WTO REQUESTS BY 1. THIS FIELD IS KEPT IN THE UCM.\n         L     R7,16\n         USING CVT,R7\n         L     R3,CVTCUCB           GET UCM PREFIX\n         AH    R3,=H'-4'\n         L     R3,0(R3)             GET UCM PREFIX\n         USING UCMPRFX,R3\n         MODESET KEY=ZERO\n         XR    R15,R15\n* drcics ICM   R14,15,UCMMCENT      GET ADDR OF UCM OF MASTCONS 29OCT92\n* drcics BZ    HRDCONS              IF NONE THEN USE MASTCONS=0 29OCT92\n         USING UCMLIST,R14                                      29OCT92\n         IC    R15,UCMID            GET THE CONSOLE ID\nHRDCONS  DS    0H                                               29OCT92\n         STH   R15,MASTCONS         AND STORE IT...\n         ST    R15,CURRCONS         INDICATE START FROM MSTR??  30OCT92\n         DROP  R3,R14\n         L     R3,CVTCUCB           GET UCM PREFIX\n         DROP  R7\n         USING UCM,R3\n         AIF   ('&WTOR' NE 'YES').NOBRD\n         LH    R1,UCMBRDST\n         LTR   R1,R1\n         BM    BRDPROB\n         LA    R1,1(R1)\n         STH   R1,UCMBRDST\n         B     ENDSTP15\nBRDPROB  DS    0H\n         WTO   'TSST069E WARNING: UCMBRDST WAS NEGATIVE - CALL IBM'\n         LA    R1,1\n         STH   R1,UCMBRDST\n         MODESET KEY=NZERO\n         B     ENDSTP15\n.NOBRD   ANOP\nENDSTP15 DS    0H\n         B     STEP16\n         DROP  R3\n*\n*\n*\n*\n*\nSTEP16   DS    0H\n***********************************************************************\n* STEP 16 IN THE TSSO INITIALIZATION PROCESS IS TO LOAD THE TSSO      *\n* AOF TABLE SPECIFIED IN THE PARAMETER INPUT DECK. ALSO INCLUDED      *\n* ARE WARNINGS FOR BAD TABLES, INCORRECT VERSIONS, ETC...             *\n***********************************************************************\n         LR    R1,R9            GET ADDRESS OF DATD MODULE      30OCT92\n         LINK  EP=TSSOLAOF,SF=(E,LINK1D)                        30OCT92\nENDSTP16 DS    0H\n         B     STEP17\n*\n*\n*\n*\n*\n***********************************************************************\n* STEP 17 OF TSSO INITIALIZATION IS TO GETMAIN THE TSSO CONTROL       *\n* BLOCK HEADER. THIS CONTROL BLOCK CONTAINS INFORMATION ABOUT ALL     *\n* TSSO SUBSYSTEM ALLOCATABLE CONSOLES.                                *\n***********************************************************************\nSTEP17   DS    0H\n         MODESET KEY=ZERO\n         GETMAIN R,LV=1024,SP=241\n         ST    R1,SSCONSAD         STORE ADDRESS OF SSCONSAD INTO TSSO\n*                                  CVT.\n         XC    0(256,R1),0(R1)          ZERO OUT THE SSCON CB\n         XC    256(256,R1),256(R1)\n         XC    512(256,R1),512(R1)\n         XC    768(256,R1),768(R1)\n         MODESET KEY=NZERO\nENDSTP17 DS    0H\n         B     STEP18\n*\n*\n*\n*\n*\nSTEP18   DS    0H\n***********************************************************************\n* STEP 18 OF THE TSSO INITIALIZATION PROCESS IS TO ALLOCATE THE       *\n* REQUESTED NUMBER OF SUBSYSTEM ALLOCATABLE CONSOLES.                 *\n* THE TSSOINI4 ROUTINE IS TO BE USED FOR THIS PROCESS.                *\n***********************************************************************\n***********************************************************************\n* NOTE THAT TSSOINI4 CALLS IEAVG700 FOR EACH SUBSYSTEM CONSOLE THAT   *\n* IS REQUESTED THROUGH PARMLIB.                                       *\n***********************************************************************\n         XR    R0,R0\n         LINK  EP=TSSOINI4,SF=(E,LINK1D)\nENDSTP18 DS    0H\n         B     STEP19\n*\n*\n*\n*\n*\nSTEP19   DS    0H\n***********************************************************************\n* STEP 19 OF THE TSSO INITIALIZATION PROCESS IS TO GET STORAGE AND    *\n* INITIALIZE THE SECURITY SYSTEM ARRAY. THIS ARRAY IS POINTED TO BY   *\n* \"SECARRAY\" AND IS USED TO HOLD USERIDS, CONSOLES ETC... FOR SIGNED  *\n* ON TSSO USERS.                                                      *\n***********************************************************************\n***********************************************************************\n* EACH ENTRY IN THE SECURITY TABLE IS 32 BYTES, AND WE WILL HAVE 20   *\n* ENTRIES, THEREFORE, THE TABLE IS 640 BYTES LONG.                    *\n***********************************************************************\nGETSECR  DS    0H\n         CLC   SECLEVEL(4),=CL4'MINI'    SECURITY WANTED ?\n         BE    NOSECR                    NO - DONT BOTHER WITH ARRAY\n*\n         MODESET KEY=ZERO\n         GETMAIN R,LV=1024,SP=241\n         ST    R1,SECARRAY         REMEMBER THE ADDRESS...\n         XC    0(256,R1),0(R1)\n         XC    256(256,R1),256(R1)\n         XC    512(256,R1),512(R1)\n         XC    768(256,R1),768(R1)\n         MODESET KEY=NZERO\n         B     ENDSTP19\n*\nNOSECR   DS    0H\n         MODESET KEY=ZERO\n         XC    SECARRAY(4),SECARRAY\n         MODESET KEY=NZERO\n         B     ENDSTP19\nENDSTP19 DS    0H\n         B     STEP20\n*\n*\n*\n*\n*\nSTEP20   DS    0H\n***********************************************************************\n* STEP 20 OF THE TSSO INITIALIZATION PROCEDURE IS TO LOCATE AND LOAD  *\n* THE TSSO TSSOPCMD MODULE. THIS MODULE IS RESPONSIBLE FOR ISSUEING   *\n* THE OS CMDS FROM TSO, NCCF AND IMS.                                 *\n***********************************************************************\nLDOPCMD  DS    0H\n         LOAD  EP=TSSOPCMD,GLOBAL=(YES,P),ERRET=OPCMDERR,LSEARCH=YES,  X\n               SF=(E,LOAD1D)\n         LR    R6,R0\n         MODESET KEY=ZERO\n         ST    R6,OPCMDADR         REMEMBER ITS ADDRESS\n         OI    TSSOFLG2,TSSOPLOA   MARK TSSOPCMD AS LOADED.\n         MODESET KEY=NZERO\n         B     ENDSTP20\nOPCMDERR DS    0H\n         WTO   'TSSI068E ERROR LOADING MODULE TSSOPCMD',DESC=1\n         MODESET KEY=ZERO\n         XC    OPCMDADR(4),OPCMDADR    ZERO OUT OPCMDADR\n         MODESET KEY=NZERO\n         B     ENDSTP20\nENDSTP20 DS    0H\n         B     STEP21\n*\n*\n*\n*\n*\nSTEP21   DS    0H\n***********************************************************************\n* STEP 21 OF THE TSSO INTIALIZATION PROCEDURE IS TO MARK THE TSSO     *\n* ADDRESS SPACE AS NON SWAPPABLE FOR PERFORMANCE REASONS. THIS IS     *\n* OPTIONAL, BASED ON A PARMLIB PARAMETER.                             *\n***********************************************************************\n         CLI   TSSOSWAP,C'Y'      NON SWAPPABLE REQUESTED\n         BNE   MAKESWAP           OH WELL...\n         MODESET MODE=SUP,KEY=ZERO\n         L     R6,X'224'           GET ASCB ADDRESS\n         USING ASCB,R6\n         LH    R6,ASCBASID         GET ASID FIELD\n         DROP  R6\n         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC\n         MODESET MODE=PROB,KEY=NZERO\n         B     ENDSTP21\nMAKESWAP DS    0H\n         B     ENDSTP21\nENDSTP21 DS    0H\n         B     STEP21#1\n*\n*\nSTEP21#1 DS    0H\n***********************************************************************\n* STEP 21.1  OF  TSSO INTIALIZATION PROCEDURE IS TO STORE THE ACTIVE  *\n* TSSO ADDRESS SPACE IN THE TSSONDSA. THIS WILL ALLOW INCARNATIONS    *\n* OF TSSO TO DETERMINE IF THEY ARE THE \"ACTIVE\" ONE...                *\n***********************************************************************\n         L     R6,X'224'           GET ASCB ADDRESS\n         USING ASCB,R6\n         LH    R6,ASCBASID         GET ASID FIELD\n         GETCVT (R2),NDSA=YES\n         USING TSSONDSA,R2\n         MODESET KEY=ZERO\n         STH   R6,TSSOASID         PLACE IN NDSA\n         MODESET KEY=NZERO\n         DROP  R2,R6\n         B     STEP22\n*\n*\nSTEP22   DS    0H\n***********************************************************************\n* STEP 22   OF TSSO INITIALIZATION IS TO LOAD THE ADDRESS OF THE      *\n* TSSO PC ROUTINE (TSSOGAPF) AND PUT ITS ADDRESS INTO TSSOPC1 VARIABLE*\n***********************************************************************\n*\n         GETCVT (R2),NDSA=YES\n         USING TSSONDSA,R2\n         MODESET KEY=ZERO\n         LOAD  EP=TSSOGAPF,GLOBAL=(YES,P),ERRET=LDAPFERR,LSEARCH=YES,  X\n               SF=(E,LOAD1D)\n         ST    R0,TSSOPC1               AND PUT THE ADDRESS AWAY\n         B     ESTP22\nLDAPFERR DS    0H\n         WTO   'TSSI070E ERROR LOADING TSSOGAPF MODULE',DESC=1\n         B     ENDPROG\nESTP22   DS    0H\n         MODESET KEY=NZERO\n         DROP  R2\n         B     STEP22#2\n*\n*\nSTEP22#2 DS    0H\n***********************************************************************\n* STEP 22.2   OF TSSO INITIALIZATION IS TO CALL THE TSSO CROSS MEMORY *\n* SERVICES INITIALIZATION ROUTINE. THIS ROUTINE WILL GO OUT AND       *\n* INITIALIZE THE TSSO CROSS MEMORY SERVICES ENVIRONMENT.              *\n***********************************************************************\n         LINK  EP=TSSOINI5,SF=(E,LINK1D)\n         LTR   R15,R15\n         BNZ   ENDPROG\n*\n         B     ENDS22#2\nENDS22#2 DS    0H\n         B     STEP22#5\n*\n*\nSTEP22#5 DS    0H\n***********************************************************************\n* STEP 22#5 OF THE TSSO INITIALIZATION PROCESS IS TO INFORM THE\n* OPERATOR (IF SECLEVEL='MAXIMAL') THAT THEY MUST LOGON TO THE TSSO   *\n* SUBSYSTEM AS THE NEXT COMMAND                                       *\n***********************************************************************\n         CLC   SECLEVEL(4),=CL4'MAXI'   MAXIMAL SECURITY ?\n         BNE   NOMAXI1\n         WTO   'TSSI067A ALL CONSOLES MUST NOW LOG ON TO TSSO',DESC=1\n         B     ENDS22#5\nNOMAXI1  DS    0H\nENDS22#5 DS    0H\n         B     STEP23\n*\n*\nSTEP23   DS    0H\n***********************************************************************\n* AT LAST, WE ARE READY TO START. WE DO THIS BY CONNECTING THE        *\n* SSVT TO THE SSCT ENTRY. THIS WILL INFORM MVS THAT WE ARE READY TO   *\n* PROCESS.                                                            *\n***********************************************************************\nCNCTSSVT DS    0H\n         L     R4,TSSOSSCT\n         USING SSCT,R4\n         L     R2,TSSOSSVT         LOAD THE SSVT\n         MODESET KEY=ZERO\n         ST    R2,SSCTSSVT         ** CONNECT **\n         MODESET KEY=NZERO\n         WTO   MF=(E,WTO4D)        STARTED MESSAGE  (MSG 60)\n         WTO   'TSSI073I COPYRIGHT (C) 1986 BELL COMMUNICATIONS RESEARCX\n               H'\n***********************************************************************\n* IN TSSO 4.3, THE MAIN WORK OF TSSO HAS BEEN MOVED TO THE TSSOMAIN   *\n* MODULE. THIS IS TO PROVIDE ADDITIONAL SPACE IN THE INITIALIZATION   *\n* ROUTINE. TSSOMAIN WILL RETURN HERE FOLLOWING RECEIPT OF A STOP CMD. *\n***********************************************************************\n*\n         LINK  EP=TSSOMAIN,SF=(E,LINK1D)\n*\n************************************************************\n*                                                          *\n*        STOP - DISCONNECT THE SUBSYSTEM                   *\n*                                                          *\n************************************************************\n         SPACE\nSTOP     EQU   *\n         LINK  EP=TSSOTERM,SF=(E,LINK1D)\n         WTO   MF=(E,WTO14D)     (MSG 64)\n         ESTAE 0,MF=(E,ESTAED)       KILL ESTAE                 15OCT92\n         B     ENDPROG\n*\nNOSSCT   DS   0H\n         WTO  MF=(E,WTO1D)       (MSG 65)\n         B    EXIT0\n*\nGETMERR  DS   0H\n         WTO  'TSST066S TSSO TERMINATING BECAUSE IT CANT GET STORAGE !'\n         B    ENDPROG1\nEXIT0    DS   0H\nENDPROG  DS   0H\n         SPACE\n         FREEMAIN R,LV=4096,A=(R9)     FREEMAIN TSSODATD\nENDPROG0 DS    0H\n         FREEMAIN R,LV=4096,A=(R11)    FREEMAIN TSSOVARS\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n         EJECT\n***********************************************************************\n* TSSO ONLY DATA CONSTANTS.\n***********************************************************************\nALPRMLIB DC    CL50'ALLOC FI(PARMLIB) DSN(''SYS1.PARMLIB'') SHR'\nFRPRMLIB DC    CL20'FREE FI(PARMLIB)'\nLINK1C   LINK  LSEARCH=YES,SF=L\n*\nLINK1CE  EQU   *\nLOAD1C   LOAD  EPLOC=0,GLOBAL=(YES,P),LSEARCH=YES,ERRET=SSILOADB,      X\n               SF=L\nLOAD1CE  DS    0H\n************************************************************\n* TSSO ONLY DSECT- NOT SHARED WITH OTHER MODULES.          *\n************************************************************\nTSSOVARS DSECT\nLINK1D   LINK  LSEARCH=YES,SF=L\n*\nLOAD1D   LOAD  EPLOC=0,GLOBAL=(YES,P),LSEARCH=YES,ERRET=SSILOADB,      X\n               SF=L\n*\nLINKPARM DS    F\n*\n***********************************************************************\n* END OF TSSO ONLY VARIABLES.                                         *\n***********************************************************************\n*\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO MAINLINE SHARED VARIABLES.           *\n***********************************************************************\n         COPY  TSSODATD\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO CVT.                                 *\n***********************************************************************\n         TSSOCVT\n         TSSONDSA\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO COMMAND RING                         *\n***********************************************************************\n         TSSOCMND          DSECT FOR TSSO COMMAND RING\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO SECURITY ARRAY                       *\n***********************************************************************\n         TSSOSECR          DSECT FOR TSSO SECURITY ARRAY\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO SS CONSOLE BLOCK HEADER              *\n***********************************************************************\n         SSCONCBH          SUBSYSTEM CONSOLE CONTROL BLOCK HEADER\n         SSCONCB           SUBSYSTEM CONSOLE CONTROL BLOCK\n*\n*\n         PRINT NOGEN\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         DCBD  DSORG=PO,DEVD=DA\n         CVT   DSECT=YES\n         IEFJSSIB\n         IEFJSSOB (CM,RR),CONTIG=YES\n         IEZJSCB\n         IKJTCB\n         IHAASCB\n         IHAASXB\n         IHAETD\nUCM      DSECT\n         IEECUCM\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSO(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSO'\n PUNCH ' NAME     TSSO(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOCCMD": {"ttr": 36104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x98\\x06\\x8f\\x01\\x026\\x1f\\x15R\\x04\\xb4\\x04O\\x00\\xf8\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1998-03-09T00:00:00", "modifydate": "2002-12-27T15:52:00", "lines": 1204, "newlines": 1103, "modlines": 248, "user": "CTEC004"}, "text": "        TITLE  'T S S O   C O N T R O L   C O M M A N D S'\n***********************************************************************\n* THIS MODULE WILL PROCESS THE TSSO CONTROL COMMANDS. THESE COMMANDS  *\n* ALL START WITH A \"#.\".                                              *\n* PARAMETERS:                                                         *\n* ON ENTRY, R1 POINTS TO THE TSSO DATA AREA (DATD). THE TSSO CONTROL  *\n* COMMAND IN QUESTION (NOTE THAT THE FACT THAT IT IS A CONTROL        *\n* COMMAND IS VERIFIED IN THE MAINLINE MODULE) IS PARSED AND PROCESSED *\n*            THE DATA AREA \"TSSOCMD\" HAS THE COMMAND IN QUESTION, AND *\n* THE TSSO VARIABLE \"CURRCONS\" HAS THE CONSOLE ID IN QUESTION.        *\n* NOTE: LAST MESSAGE NUMBER WAS TSSC142X                              *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*   15OCT92  GLA  SUPPORT ES/9000 HARDWARE SYSTEM CONSOLE (UCMID 100) *\n*                 JUST LIKE INTERNAL MVS COMMANDS (UCMID 0).          *\n*   20OCT92  GLA  USE NEW DSECT FOR AOF TABLE                         *\n*   30OCT92  GLA  INVOKE NEW MODULE TO LOAD AN AOF TABLE AND BUILD    *\n*                 THE BINARY INDEX HEADER.                            *\n*                                                                     *\n*   30DEC96  RPS  FIXED ADDRESSABILITY ERROR WITH HLASM               *\n*                                                                     *\n*   NOV 2002 EEJ  Support MCS extended consoles                 EEJ1102\n*                                                               EEJ1102\n*   DEC 2002 PVW  Change to key 8 before deleting AOF table     PVW1202\n*                                                               PVW1202\n***********************************************************************\n* RETURN CODES:                                                       *\n* R15 = 0: TSSOCCMD PROCESSED THE TSSO DIRECTIVE SUCCESSFULLY         *\n* R15 = 8: THE COMMAND WAS NOT PROCESSED.                             *\n* IN ADDITION, THE FOLLOWING BIT FLAGS IN THE DATA AREA FLAG CCMDFLAG *\n* ARE RETURNED:\n*\n* X'80' REQUEST TO STOP TSSO\n* X'40' UPON COMPLETION OF THIS CONTROL COMMAND, LIST THE SYSTSPRT\n*       FILE.\n***********************************************************************\nTSSOCCMD CSECT\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOCCMD,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LA    R8,4095(R12)       GET ADDRESSABILITY TO REST OF MOD\n         LA    R8,1(R8)           FINISH THE JOB\n         USING TSSOCCMD+4096,R8\n         LR    R9,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=2048         GET STORAGE FOR A LOCAL      EEJ1102\n         LR    R11,R1             DATA AREA\n         USING CCMDDATD,R11       AND TELL ASSEMBLER\n***********************************************************************\n* WE MUST PICK UP THE ADDRESS OF THE TSSO DATA AREA. THIS IS PASSED   *\n* THROUGH REG 1 AND COPIED TO REG 8 IN THE LINKAGE ABOVE. SINCE R9    *\n* IS THE BASE FOR THE DATA AREA, WE WILL PICK UP THE ADDRESS.         *\n* THE TSSO PARSE ROUTINE WILL BE USED TO PARSE THE COMMAND. THIS IS   *\n* PROBABLY TOUGHER THEN IT NEEDS TO BE, BUT IT PROVIDES A CLEANER     *\n* INTERFACE FOR PEOPLE TO WRITE THERE OWN COMMANDS.                   *\n***********************************************************************\n         MVC   CCWTO1D(CCWTO1CE-CCWTO1C),CCWTO1C\n         MVC   CCWTO2D(CCWTO2CE-CCWTO2C),CCWTO2C\n         MVC   CCWTO3D(CCWTO3CE-CCWTO3C),CCWTO3C\n         MVC   CCWTO4D(CCWTO4CE-CCWTO4C),CCWTO4C\n         MVC   CCWTO5D(CCWTO5CE-CCWTO5C),CCWTO5C\n         MVC   POST1D(POST1CE-POST1C),POST1C\n         USING DATD,R9\n         GETCVT  (R10)                 ADDRESS THE TSSO CVT\n         USING TSSOCVT,R10\n         ST    R10,CVTADDR             REMEMBER CVT ADDRESS\n*                                                               EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* TSSO used to get the console authorization by searching the  *EEJ1102\n* UCM entries. This technique is incompatible with the use of  *EEJ1102\n* MCS extended consoles since they don't have UCM entries.     *EEJ1102\n* All of this logic has been removed. Instead, console auth-   *EEJ1102\n* orization is obtained from the SSCM when the command enters  *EEJ1102\n* the TSSO environment.                                        *EEJ1102\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                               EEJ1102\n         MVC   CONSOLE,CURRCONS    Copy console ID              EEJ1102\n         MVC   CONSNAME,CURRCNAM   Copy console name            EEJ1102\n         MVC   AUTHBITS,CURRCATH   Copy console auth bits       EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n* PARSE THE COMMAND USING THE TSSO PARSE SERVICE ROUTINE              *\n*                                                                     *\n***********************************************************************\n         LA    R1,TSSOCMD              POINT TO THE INPUT BUFFER\n         LA    R1,1(R1)                POINT PAST THE \".\"\n         ST    R1,PARS1                AND STORE ADDRESS OF THE STRING\n*\n         LA    R1,126\n         ST    R1,PARS2                GET ADDRESS OF THE STRING\n*\n         MVI   PARARRAY,C' '\n         MVC   PARARRAY+1(129),PARARRAY\n         LA    R1,PARARRAY\n         MVC   0(2,R1),=H'10'          MAXIMUM OF TEN TOKENS\n         ST    R1,PARS3\n*\n         MVC   PARSSEP(4),=CL4',='     PARSE CHARACTERS\n         LA    R1,PARSSEP\n         ST    R1,PARS4\n*\n         LA    R1,PARSPARM             GET PARM LIST TO TSSOPARS\n         CALL  TSSOPARS                GO FOR IT...\n*\n         LA    R2,PARARRAY+2           POINT TO FIRST TOKEN...\n         LA    R7,CMDTABLE             AND TO COMMAND TABLE\nSRCHLOOP DS    0H\n         CLC   0(8,R7),0(R2)           IS THIS THE COMMAND ?\n         BE    CMDFOUND                YUP, GOT THE COMMAND\n         CLC   0(8,R7),=CL8'ZZZZZZZZ'  IS THIS THE END OF THE TABLE ?\n         BE    CMDNFND                 NO, COMMAND IS NOT FOUND\n         LA    R7,16(R7)               POINT AT NEXT COMMAND\n         B     SRCHLOOP                AND KEEP LOOKING\nCMDNFND  DS    0H\n***********************************************************************\n* WE COME HERE IF THE COMMAND IS NOT FOUND IN THE TABLE...            *\n*                                                                     *\n***********************************************************************\n         L     R1,=A(MSG102)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG102L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\nCMDFOUND DS    0H\n***********************************************************************\n* HERE, THE COMMAND IS FOUND. WE WILL CHECK TO SEE IF IT IS RESTRICTED*\n* TO CONSOLES WITH SYSTEM AUTHORITY, AND IF SO, CHECK TO SEE IF SAID  *\n* AUTHORITY EXISTS. NOTE THAT R7 POINTS TO THE COMMAND IN QUESTION.   *\n***********************************************************************\n         TM    12(R7),B'10000000'     IS COMMAND RESTRICTED?\n         BNO   GODOCMD                YUP, BETTER CHECK IT...\n         TM    AUTHBITS,X'80'         SYSTEM AUTHORITY ?\n         BO    GODOCMD                YUP! GREAT, GO TO IT !\n         L     R1,=A(MSG103)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG103L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n***********************************************************************\n* HERE, THE COMMAND IS UNRESTRICTED, OR THE REQUIREMENTS HAVE BEEN    *\n* SATISFIED. WE WILL BRANCH TO THE COMMAND IS QUESTION.               *\n***********************************************************************\nGODOCMD  DS    0H\n         L     R2,8(R7)               GET ADDRESS OF COMMAND\n         B     0(R2)                  AND GO FOR IT !!!\n*\n*\n*\n*\n***********************************************************************\n* START OF CODE FOR THE SUBCOMMANDS.                                  *\n* ABEND TSSO CONTROL COMMAND                                          *\n***********************************************************************\nABENDIT  DS    0H\n         WTO   'TSSC104S TSSO ABENDING AT OPERATOR DEMAND',DESC=(1)\n         DC    X'00000000'\n***********************************************************************\n* STC TSSO CONTROL COMMAND                                            *\n*                                                                     *\n***********************************************************************\nSTC      DS    0H\n         TM    TSSOFLG1,TSSOJBID   DO WE HAVE AN ID ALREADY ?\n         BO    ENDPROG             YES, DO NOTHING\n         BAL   R14,REQJOBID\n         B     ENDPROG\n         SPACE\nMONITOR  DS    0H\n***********************************************************************\n* MONITOR TSSO CONTROL COMMAND                                        *\n*                                                                     *\n***********************************************************************\n         LA    R1,PARARRAY+18        GET SECOND PARAMETER.\n         CLI   0(R1),C'0'            MONITORING BEING TURNED OFF ?\n         BE    MONOFF                YUP...\n         CLI   0(R1),C'1'            MONITORING BEING TURNED ON ?\n         BE    MONON                 YUP...\n         L     R1,=A(MSG105)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG105L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\nMONON    DS    0H\n         OI    TSSOFLG2,TSSOMON       TURN MONITORING ON\n         B     ENDPROG\nMONOFF   DS    0H\n         NI    TSSOFLG2,255-TSSOMON   TURN MONITORING OFF\n         B     ENDPROG\n*\n*\n*\n*\n*\nRELOAD   DS    0H\n***********************************************************************\n* THE RELOAD COMMAND WILL DYNAMICALLY RELOAD A BRAND NEW AOF TABLE.   *\n*                                                                     *\n***********************************************************************\n         L     R6,TSSOTABL        CHECK TO SEE IF FUNCTION ACTIVE\n         LTR   R6,R6              WELL.. IS IT ?\n         BZ    NODEL              NO FUNCTION, NO NEED TO DELETE\n***********************************************************************\n* IN TSSO 4.3, WE NEED TO SEE IF ANYONE IS WAITING ON AN OUTSTANDING  *\n* OSWAIT EVENT, IF SO, WE NEED TO POST THEM WITH A COMPCODE OF FFF    *\n***********************************************************************\n         L     R6,0(R6)           POINT TO FIRST RECORD IN TABLE.\n         USING AOFNTRY,R6         SETUP ADDRESSABILITY\n         XR    R4,R4              FLAG...\n         ST    R4,TSSOTABL        IMMEDIATELY SHUT OFF TABLE\nRELALOOP DS    0H\n         CLC   AOFMSGID,=CL8'ZZZZZZZZ' END OF TABLE ?\n         BE    RELEOT                  YES, END OF TABLE...\n         CLC   AOFACTN,=CL8'POST'      IS THIS ACTION=POST ?\n         BNE   RELNENT                 NO, CHECK NEXT ENTRY\n         TM    AOFPFLG,AOFP1WT         IS IT BEING WAITED ON ?\n         BNO   RELNENT                 NO, DO BOTHER...\n         L     R2,AOFPECB              GET ECB TO POST\n         L     R3,AOFPASCB             GET THE ADDRESS SPACE...\n         POST  (R2),X'FFF',ASCB=(R3),ERRET=NOAOF,MF=(E,POST1D)\n         LA    R4,1\n         B     RELNENT\nRELNENT  DS    0H\n         L     R6,AOFNXT\n         B     RELALOOP\n         DROP  R6\n*\nRELEOT   DS    0H\n         LTR   R4,R4              ANYBODY WAITING ?\n         BZ    DODEL\n*\n         WTO   'TSSC142I RELOAD DELAYED - ACTIVE OSWAITS IN PROGRESS'\n         MVC   DINTVL(8),=CL8'00000500'   WAIT FIVE SECONDS....\n         STIMER WAIT,DINTVL=DINTVL\n*\nDODEL    DS    0H\n         L     R1,TSSOBSTH              GET POINTER TO INDEX TABLEOCT92\n         L     R0,0(,R1)                GET LENGTH AND SUBPOOL  30OCT92\n         XC    TSSOBSTH(TSSOBSTL+4-TSSOBSTH),TSSOBSTH CLR PTRS  30OCT92\n         XC    TSSOTABL,TSSOTABL        INDICATE NO POINTER     30OCT92\n         FREEMAIN R,LV=(0),A=(1)        GET RID OF INDEX TABLE  30OCT92\n         MODESET KEY=NZERO              CHANGE TO KEY 8         PVW1202\n         LA    R6,TSSOTABN        GET CURRENT TABLE NAME\n         DELETE EPLOC=(R6)           DELETE IT !\n         MODESET KEY=ZERO               CHANGE BACK TO KEY 0    PVW1202\n         MVC   TSSOTABN(8),=CL8' '\nNODEL    DS    0H\n         MVC   TSSOTABN(8),PARARRAY+18 POINT TO MODULE TO RELOAD TABLE\n         CLC   TSSOTABN(8),=CL8'NONE'     OPERATOR WANTS NO REPLIES?\n         BNE   LOADNTAB                  NO, LOAD NEW TABLE\n*\n* HERE, THE OPERATOR HAS REQUESTED WE SUPPRESS THE WTO REPLY FUNCTION\nNOAOF    DS    0H\n         XR    R6,R6\n         ST    R6,TSSOTABL\n         MVC   TSSOTABN(8),=CL8'NONE'\n         WTO   'TSSC106I TSSO AUTOMATED OPERATOR FACILITY DEACTIVATED  X\n               ',DESC=(1)\n         B     ENDPROG\n*\nLOADNTAB DS    0H\n         LR    R1,R9                    POINT AT DATD           30OCT92\n         LINK  EP=TSSOLAOF              GET NEW TABLE AND INDEX 30OCT92\n         L     R1,=A(MSG107)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG107L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     QUERYTAB           MIGHT AS WELL, OPERATOR WILL ANYWAY\n*\n*\nLOGON    DS    0H\n***********************************************************************\n* HERE, WE PROCESS THE #.LOGON COMMAND. WE FORMAT THE PARAMETER LIST, *\n* AND CALL THE SECURITY EXIT ROUTINE.                                 *\n*                                                                     *\n***********************************************************************\n         CLC   SECLEVEL(4),=CL4'MINI'\n         BE    LGNBSLVL                  NO LOGONS IF SECURITY NOT MAX\n         CLI   PARARRAY+18,X'40'         ANY SECOND PARAMETER ?\n         BE    LGNBDPRM                  NO - BAD PARAMETERS...\n         CLI   PARARRAY+34,X'40'         ANY THIRD  PARAMETER ?\n         BE    LGNBDPRM                  NO - BAD PARAMETERS...\n         XC    NEWENTAD(4),NEWENTAD\n         LA    R7,20\n         L     R6,SECARRAY               PICK UP ADDRESS OF ARRAY\n         LTR   R6,R6                     ANY THERE ?\n         BZ    LGNERROR\nLGNLOOP  DS    0H\n         USING TSSOSECR,R6\n         TM    SECFLAGS,X'80'            ENTRY IN USE ?\n         BNO   NEWENTRY                  NO, THIS WILL BE USED IF\n*                                        USER IS NOT LOGGED ON.\n         CLC   SECUSER(8),PARARRAY+18    IS USER ALREADY LOGGED ON\n         BE    LGNDUPL\n         L     R1,CONSOLE\n         C     R1,SECRCNID               Console logged on ?    EEJ1102\n         BE    LGNDUPLC                  Branch if yes          EEJ1102\n         B     LGNELOOP\n*\nNEWENTRY DS    0H\n         L     R1,NEWENTAD               DO WE ALREADY HAVE A NEW ENTRY\n         LTR   R1,R1                     LETS SEE...\n         BNZ   LGNELOOP                  YUP...\n         ST    R6,NEWENTAD               REMEMBER ADDRESS OF NEW ENTRY\n*\nLGNELOOP DS    0H\n         LA    R6,SECRLGNT(R6)           INCREMENT TO NEXT ENTRY\n         BCT   R7,LGNLOOP                GET NEXT ENTRY\n*\n***********************************************************************\n* AT THIS POINT IN LOGON PROCESSING, WE HAVE COMPLETED A SEARCH FOR   *\n* DUPLICATE LOGONS.. NEXT, WE MUST SEE IF WE ENCOUNTERED ANY BLANK    *\n* ENTRIES ALONG THE WAY.                                              *\n***********************************************************************\n         L     R6,NEWENTAD               GET ADDDRESS OF NEW TABLE ENT\n         LTR   R6,R6\n         BZ    LGNFULL                   NO ROOM IN  ARRAY !\n* NOTE: R6 POINTS TO THE ADDRESS OF THE NEW TABLE ENTRY.\n         MVC   PRMUSER(8),PARARRAY+18\n         MVC   PRMPASS(8),PARARRAY+34\n         MVC   PRMCNID,CONSOLE           Copy console ID        EEJ1102\n         MVC   PRMCNAME,CONSNAME         Copy console name      EEJ1102\n         MVC   PRMACEE(4),4(R6)          PLACE TO PUT ACEE'S\n         CLC   SECSYS(4),=CL4'RACF'      CALLING RACF ?\n         BE    LGNRACF\n         CLC   SECSYS(4),=CL4'ACF2'      CALLING ACF2 ?\n         BE    LGNACF2\n         CLC   SECSYS(4),=CL4'TOPS'      CALLING TOP SECRET ?\n         BE    LGNRACF\n         B     ENDPROG\nLGNRACF  DS    0H\n         LA    R1,SECPRM\n         XC    PRMFLAGS(2),PRMFLAGS      CLEAR FLAGS\n         OI    PRMFLAGS,X'80'            INDICATE LOGON PROCESSING\n         LINK  EP=TSSLRACF,ERRET=LGNERROR\n         LTR   R15,R15\n         BNZ   LGNBAD\n         B     LGNOK\nLGNACF2  DS    0H\n         LA    R1,SECPRM\n         XC    PRMFLAGS(2),PRMFLAGS      CLEAR FLAGS\n         LINK  EP=TSSLACF2,ERRET=LGNERROR\n         LTR   R15,R15\n         BNZ   LGNBAD\n         B     LGNOK\nLGNOK    DS    0H\n         USING TSSOSECR,R6\n         OI    SECFLAGS,X'80'         INDICATE ENTRY IN USE\n         MVC   SECACEE(4),PRMACEE     COPY ACEE (OR ACF2 EQUIVALENT)\n         MVC   SECUSER(8),PRMUSER     COPY USER ID\n         MVC   SECRCNID,CONSOLE    Copy console ID              EEJ1102\n         MVC   SECRCNAM,CONSNAME   Copy console name            EEJ1102\n         MVC   SECRAUTH,AUTHBITS   Copy console auth bits       EEJ1102\n         TIME  BIN\n         ST    R1,SECRDATE            GET INITIAL DATE\n         ST    R0,SECRTIME            AND ALSO GET TIME...\n         B     ENDPROG\nLGNBAD   DS    0H\n         B     ENDPROG\n*\n*\n*\nLGNBDPRM DS    0H\n         L     R1,=A(MSG138)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG138L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*\nLGNBSLVL DS    0H\n         L     R1,=A(MSG135)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG135L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGNDUPL  DS    0H\n         L     R1,=A(MSG131)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG131L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGNDUPLC DS    0H\n         L     R1,=A(MSG132)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG132L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGNFULL  DS    0H\n         L     R1,=A(MSG133)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG133L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGNERROR DS    0H\n         WTO  'TSSC134S LOGON/LOGOFF COMMAND REJECTED - LOGICAL ERROR IX\n               N PROCESSING',DESC=1\n         B     ENDPROG\n         DROP  R6\n*\n*\n*\nLOGOFF   DS    0H\n***********************************************************************\n* WE COME HERE TO LOG A USER OFF THE TSSO SUBSYSTEM. THIS IS ACCOMPLIS*\n* BY SIMPLY TURNING OFF THE IN USE BIT IN THE CONSOLES ENTRY IN THE   *\n* SECURITY ARRAY.                                                     *\n*                                                                     *\n***********************************************************************\n*\n         CLC   SECLEVEL(4),=CL4'MINI'\n         BE    LGOBSLVL                  NO LOGONS IF SECURITY NOT MAX\n         LA    R7,20\n         L     R6,SECARRAY               PICK UP ADDRESS OF ARRAY\n         LTR   R6,R6                     ANY THERE ?\n         BZ    LGNERROR\nLGNLOOP2 DS    0H\n         USING TSSOSECR,R6\n         TM    SECFLAGS,X'80'            ENTRY IN USE ?\n         BNO   LGOELOOP                  NO, THIS CANNOT BE ENTRY FOR\n*                                        THIS CONSOLE.\n         L     R1,CONSOLE\n         C     R1,SECRCNID               Console logged on ?    EEJ1102\n         BE    LOGOCONS                  Branch if yes          EEJ1102\n*\nLGOELOOP DS    0H\n         LA    R6,SECRLGNT(R6)           INCREMENT TO NEXT ENTRY\n         BCT   R7,LGNLOOP2               GET NEXT ENTRY\n         B     LGONLOG                   USER MUST NOT BE LOGGED ON\n*\n***********************************************************************\n* AT THIS POINT IN LOGOFF PROCESSING, WE HAVE FOUND THE CONSOLE THAT  *\n* MUST BE LOGGED OFF... WE WILL FORMAT THE PARAMETER LIST FOR THE     *\n* SECURITY SYSTEM, AND PROCEED TO LOG THE CONSOLE OFF.                *\n***********************************************************************\n* NOTE: R6 POINTS TO THE ADDRESS OF THE NEW TABLE ENTRY.\nLOGOCONS DS    0H\n         MVC   PRMUSER(8),8(R6)          PICK UP USER ID\n         MVC   PRMACEE(4),4(R6)          PLACE TO PUT ACEE'S\n         MVC   PRMCNID,SECRCNID          Copy console ID        EEJ1102\n         MVC   PRMCNAME,SECRCNAM         Copy console name      EEJ1102\n         CLC   SECSYS(4),=CL4'RACF'      CALLING RACF ?\n         BE    LGORACF\n         CLC   SECSYS(4),=CL4'ACF2'      CALLING ACF2 ?\n         BE    LGOACF2\n         CLC   SECSYS(4),=CL4'TOPS'      CALLING TOP SECRET ?\n         BE    LGORACF\n         B     ENDPROG\nLGORACF  DS    0H\n         LA    R1,SECPRM\n         XC    PRMFLAGS(2),PRMFLAGS      CLEAR FLAGS\n         OI    PRMFLAGS,X'40'            INDICATE LOGOFF\n         LINK  EP=TSSLRACF,ERRET=LGNERROR\n         LTR   R15,R15\n         BNZ   LGOBAD\n         B     LGOOK\nLGOACF2  DS    0H\n         XC    PRMFLAGS(2),PRMFLAGS      CLEAR FLAGS\n         OI    PRMFLAGS,X'40'            INDICATE LOGOFF\n         LA    R1,SECPRM\n         LINK  EP=TSSLACF2,ERRET=LGNERROR\n         LTR   R15,R15\n         BNZ   LGOBAD\n         B     LGOOK\nLGOBSLVL DS    0H\n         L     R1,=A(MSG136)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG136L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGONLOG  DS    0H\n         L     R1,=A(MSG137)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG137L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nLGOOK    DS    0H\n***********************************************************************\n* NOTE - IT IS THE RESPONSIBILITY OF THE SECURITY MODULES, TSSLRACF   *\n* AND TSSLACF2 TO PROCESS THE LOGOFF ROUTINES, AND TO PRODUCE A       *\n* WTO TO THE CONSOLE INDICATING SUCCESSFULL LOGOFF.                   *\n***********************************************************************\n         USING TSSOSECR,R6\n         NI    SECFLAGS,255-X'80'     INDICATE ENTRY NO LONGER IN USE\n         XC    SECRCNID,SECRCNID      Zero console ID\n         XC    SECRCNAM,SECRCNAM      Zero console name\n         XC    SECRAUTH,SECRAUTH      Zero console auth bits\n         XC    SECACEE(4),SECACEE     ZERO ACEE (OR ACF2 EQUIVALENT)\n         B     ENDPROG\nLGOBAD   DS    0H\n***********************************************************************\n* NOTE, IF THE LOGOFF WAS BAD, IT IS THE RESPONSABILITY OF THE        *\n* SECURITY MODULES (TSSLRACF OR TSSLACF2) TO PRODUCE ANY DESCRIPTIVE  *\n* MESSAGES THAT MAY HAVE CAUSED THE FAILURE.                          *\n***********************************************************************\n         B     ENDPROG\n         DROP  R6\n*\n*\n*\n*\nQUERY    DS    0H\n***********************************************************************\n* THE QUERY COMMAND HAS A MASSIVE AMOUNT OF SUBCOMMANDS. WE HAVE YET  *\n* ANOTHER TABLE TO SCAN TO DETERMINE THE OPERANDS OF THE QUERY COMMAND*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         LA    R2,PARARRAY+18          POINT TO FIRST TOKEN...\n         LA    R7,QRYTABLE             AND TO COMMAND TABLE\nSRCHQLOP DS    0H\n         CLC   0(8,R7),0(R2)           IS THIS THE COMMAND ?\n         BE    QCMDFND                 YUP, GOT THE COMMAND\n         CLC   0(8,R7),=CL8'ZZZZZZZZ'  IS THIS THE END OF THE TABLE ?\n         BE    QCMDNFND                NO, COMMAND IS NOT FOUND\n         LA    R7,16(R7)               POINT AT NEXT COMMAND\n         B     SRCHQLOP                AND KEEP LOOKING\nQCMDNFND DS    0H\n***********************************************************************\n* WE COME HERE IF THE COMMAND IS NOT FOUND IN THE TABLE...            *\n*                                                                     *\n***********************************************************************\n         L     R1,=A(MSG110)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG110L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nQCMDFND  DS    0H\n         TM    12(R7),B'10000000'     RESTRICTED QUERY COMMAND ?\n         BNO   GODOQRY                NO, SEEMS OK...\n         TM    AUTHBITS,X'80'         SYSTEM AUTHORITY ?\n         BO    GODOQRY                YUP! GREAT, GO TO IT !\n         L     R1,=A(MSG111)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG111L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\n***********************************************************************\n* HERE, THE COMMAND IS UNRESTRICTED, OR THE REQUIREMENTS HAVE BEEN    *\n* SATISFIED. WE WILL BRANCH TO THE COMMAND IS QUESTION.               *\n***********************************************************************\nGODOQRY  DS    0H\n         L     R2,8(R7)               GET ADDRESS OF COMMAND\n         B     0(R2)                  AND GO FOR IT !!!\n*\nQUERYVRS DS    0H\n         L     R0,CONSOLE\n         WTO   CONSID=CONSOLE,MF=(E,WTO27D) (MSG 112)           EEJ1102\n         L     R1,WTOADDR              GET ADDRESS OF TSSOWTO MODULE\n         MVC   WTO28D+13(8),=CL8'TSSOWTO'\n         MVC   WTO28D+21(5),=CL5' '\n         MVC   WTO28D+46(8),10(R1)         GET DATE OF ASSEMBLY\n         MVC   WTO28D+62(8),18(R1)         GET TIME OF ASSEMBLY\n         WTO   CONSID=CONSOLE,MF=(E,WTO28D) (MSG 113)           EEJ1102\n* NOW, WE MUST LOOP THROUGH THE SSIARRAY VARIABLES, AND PROCESS THE\n* INFORMATION CONTAINED THEREIN.\n         LH    R6,SSICOUNT\n         LA    R7,SSIARRAY\nSSILOOP  DS    0H\n         MVC   WTO28D+13(8),8(R7)       MOVE SSI MODULE NAME\n         LH    R1,0(R7)              GET SUBSYS NUMBER\n         MVI   WTO28D+22,C'('\n         LA    R10,DATD\n         CALL  JCECVTBD              CONVERT IT TO DECIMAL\n         L     R10,CVTADDR\n         STCM  R1,B'0011',WTO28D+23\n         MVI   WTO28D+25,C')'\n         MVC   WTO28D+46(8),20(R7)   PICK UP DATE OF ASSEMBLY\n         MVC   WTO28D+62(8),28(R7)   AND NOW GET TIME\n         WTO   CONSID=CONSOLE,       AND DISPLAY FOR OPERATOR   EEJ1102+\n               MF=(E,WTO28D)         (MSG 113)                  EEJ1102\n         LA    R7,36(R7)             GET THE NEXT ENTRY\n         BCT   R6,SSILOOP            REPEAT FOR ALL SUBSYS MODULES\n         B     ENDPROG               COMMAND TERMINATED.\n*\nQUERYRCF DS    0H\n***********************************************************************\n* THE QRACF COMMAND                                                   *\n*                                                                     *\n***********************************************************************\n         MVC   WTO24D+41(8),TSSORACF+1 GET RACF USER ID\n         WTO   CONSID=CONSOLE,MF=(E,WTO24D) (MSG 114)           EEJ1102\n         B     ENDPROG\n*\nQUERYSWP DS    0H\n***********************************************************************\n* THE QSWAP COMMAND                                                   *\n*                                                                     *\n***********************************************************************\n         CLI   TSSOSWAP,C'Y'        CHECK IT OUT.\n         BNE   QUERNSWP             NOPE...\n         L     R1,=A(MSG115)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG115L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nQUERNSWP DS    0H\n         L     R1,=A(MSG116)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG116L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nQMAXCMD  DS    0H\n***********************************************************************\n* THE QMAXCMDS COMMAND                                                *\n*                                                                     *\n***********************************************************************\n         L     R1,MAXCMDS        GET MAX COMMANDS\n         LA    R10,DATD          R10 MUST POINT TO WORKAREA FOR CONVERT\n         CALL  JCECVTBD          FROM BINARY TO DECIMAL\n         L     R10,CVTADDR\n         STH   R1,WTO22D+42\n         WTO   CONSID=CONSOLE,MF=(E,WTO22D) (MSG 117)           EEJ1102\n         B     ENDPROG\n*\nQTMEOUT  DS    0H\n***********************************************************************\n* THE QUERT TIMEOUT COMMAND                                           *\n*                                                                     *\n***********************************************************************\n         L     R1,SECTMEOT       GET TSSO TIMEOUT VALUE.\n         LA    R10,DATD          R10 MUST POINT TO WORKAREA FOR CONVERT\n         XR    R0,R0\n         CALL  JCECVTBD          FROM BINARY TO DECIMAL\n         L     R10,CVTADDR\n         STCM  R1,B'0011',CCWTO4D+41\n         WTO   CONSID=CONSOLE,MF=(E,CCWTO4D)  (MSG 139)         EEJ1102\n         B     ENDPROG\n*\nQMAXWTO  DS    0H\n***********************************************************************\n* THE QMAXWTO COMMAND                                                 *\n*                                                                     *\n***********************************************************************\n         L     R1,MAXWTO         GET MAXIMUM WTO VALUE.\n         LA    R10,DATD          R10 MUST POINT TO WORKAREA FOR CONVERT\n         XR    R0,R0\n         CALL  JCECVTBD          FROM BINARY TO DECIMAL\n         L     R10,CVTADDR\n         STCM  R1,B'1111',WTO36D+43\n         WTO   CONSID=CONSOLE,MF=(E,WTO36D) (MSG 118)           EEJ1102\n         B     ENDPROG\n*\nQUERYSCO DS    0H\n***********************************************************************\n* THE QSCON COMMAND                                                   *\n*                                                                     *\n***********************************************************************\n         TM    TSSOFLG1,TSSOSCON DO WE HAVE A CONSOLE ID ?\n         BNO   SCONOFF           SORRY...\n         L     R6,SSCONSAD       GET SSCONS CB ADDRESS\n         USING SSCONCBH,R6       GET THE HEADER...\n         L     R1,SSCONREQ       GET NUMBER OF SSCONS REQUESTED\n         LA    R10,DATD\n         CALL  JCECVTBD\n         STCM  R1,B'0011',WTO49D+13   #REQUESTED\n*\n         L     R1,SSCONAMT       GET NUMBER OF SSCONS ALLOCATED\n         LA    R10,DATD\n         CALL  JCECVTBD\n         STCM  R1,B'0011',WTO49D+46   ALLOCATED...\n         L     R0,CONSOLE\n         WTO   CONSID=CONSOLE,   SSCONS REQUESTED/ALLOC         EEJ1102+\n               MF=(E,WTO49D)     (MSG 140)\n*\n*\n         L     R7,SSCONAMT       GET THE NUMBER OF SS CONSOLES\n         LA    R5,SSCONFIR       POINT TO FIRST ELEMENT\nQSCONLOP DS    0H\n         USING SSCONCB,R5\n         L     R1,SSCONNUM       GET TSSO CONSOLE ID...\n         LA    R10,DATD          R10 MUST POINT TO WORKAREA FOR CONVERT\n         XR    R0,R0\n         CALL  JCECVTBD          FROM BINARY TO DECIMAL\n         L     R10,CVTADDR\n         STCM  R1,B'0011',WTO48D+31    CONSOLE ID\n         TM    SSCONFLG,X'80'          SS CONSOLE IN USE ?\n         BNO   SCONNUSE                NO, NOT IN USE\n         MVC   WTO48D+36(18),=CL18'IN USE, USERID IS '\n         MVC   WTO48D+54(8),SSCONUID\n         B     SCONPRT\nSCONNUSE DS    0H\n         TM    SSCONFLG,X'40'          MAYBE IT IS DEDICATED ?\n         BNO   SCONDNUS\n*\n         MVC   WTO48D+36(26),=CL26'DEDICATED TO TSSO'\n         B     SCONPRT\n*\nSCONDNUS DS    0H\n         MVC   WTO48D+36(26),=CL26'NOT IN USE'\n         B     SCONPRT                 PRINT THE LINE\n*\nSCONPRT  DS    0H\n         WTO   CONSID=CONSOLE,MF=(E,WTO48D) (MSG 119)           EEJ1102\n         LA    R5,SSCONCBL(R5)\n         BCT   R7,QSCONLOP             GET NEXT ONE\n         B     ENDPROG\nSCONOFF  DS    0H\n         L     R1,=A(MSG120)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG120L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\n         DROP  R6\n         DROP  R5\n*\nQUERYSEC DS    0H\n***********************************************************************\n* THE QUERY SECURITY COMMAND                                          *\n*                                                                     *\n***********************************************************************\n         CLC   SECLEVEL(4),=CL4'MINI'\n         BE    QSECMINI\n         CLC   SECLEVEL(4),=CL4'MAXI'\n         BE    QSECMAXI\n         CLC   SECLEVEL(4),=CL4'MEDI'\n         BE    QSECMEDI\n         B     QSECERR\nQSECMINI DS    0H\n         MVC   CCWTO1D+31(8),=CL8'MINIMAL'\n         B     QSECSECS\nQSECMAXI MVC   CCWTO1D+31(8),=CL8'MAXIMAL'\n         B     QSECSECS\nQSECMEDI MVC   CCWTO1D+31(8),=CL8'MEDIAL'\n         B     QSECSECS\n*\nQSECSECS DS    0H\n         MVC   CCWTO1D+51(4),SECSYS\n         WTO   CONSID=CONSOLE,MF=(E,CCWTO1D)  (MSG 126)         EEJ1102\n\n         B     ENDPROG\nQSECERR  DS    0H\n         WTO   'TSSC127S ERROR PROCESSING Q SEC COMMAND',DESC=1\n         B     ENDPROG\n*\nQUERYXME DS    0H\n***********************************************************************\n* PROCESS THE QUERY XMEM COMMAND. THIS COMMAND DISPLAYS THE VALUE OF  *\n* THE TSSO LX INDEX.                                                  *\n*                                                                     *\n***********************************************************************\n         L     R10,CVTADDR           PICK UP THE TSSO CVT\n         TM    TSSOFLG2,TSSOXMON     IS XMEM ON ?\n         BNO   NOXMEM                NO XMEM SERVICES\n         GETCVT (R7),NDSA=YES        GET THE NDSA\n         USING TSSONDSA,R7\n         L     R1,TSSOLX             GET THE TSSO LX\n         DROP  R7\n         LA    R10,DATD\n         CALL  JCECVTBH              CONVERT\n         STCM  R0,B'1111',CCWTO5D+39\n         STCM  R1,B'1111',CCWTO5D+43\n         WTO   CONSID=CONSOLE,MF=(E,CCWTO5D)                    EEJ1102\n         B     ENDPROG\nNOXMEM   DS    0H\n         L     R1,=A(MSG141)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG141L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*                                                               EEJ1102\nQUERYLGN DS    0H\n***********************************************************************\n* PROCESS THE QUERY LOGONS COMMAND. THIS COMMAND WILL DISPLAY ALL     *\n* USERS LOGGED ON TO THE SECURITY SYSTEM.                             *\n*                                                                     *\n***********************************************************************\n         XR    R7,R7                         KEEP COUNT OF # OF USERS\n         CLC   SECLEVEL(4),=CL4'MINI'        MINIMAL SECURITY ?\n         BE    LGNSMINI\n         L     R6,SECARRAY                   GET ADDRESS OF SECARRAY\n         LTR   R6,R6                         ANY ?\n         BZ    LGNSERR\n         LA    R5,20                         MAXIMUM ENTRIES\nLGNSLOOP DS    0H\n         USING TSSOSECR,R6\n         TM    SECFLAGS,X'80'          IN USE?\n         BZ    LGNSELOP                NO, IGNORE IT.\n***********************************************************************\n* HERE, WE HAVE AN ENTRY IN THE TABLE. WE WILL FORMAT THE ENTRY AND   *\n* WTO IT OUT TO THE OPERATOR.                                         *\n***********************************************************************\n         LA    R10,DATD\n         MVC   CCWTO2D+25(8),SECRCNAM Copy console name         EEJ1102\n         MVC   CCWTO2D+40(8),SECUSER Copy User ID               EEJ1102\n         WTO   CONSID=CONSOLE,MF=(E,CCWTO2D)  (MSG 128)         EEJ1102\n         LA    R7,1(R7)\nLGNSELOP DS    0H\n         LA    R6,SECRLGNT(R6)\n         BCT   R5,LGNSLOOP\n*\n         LA    R10,DATD\n         LR    R1,R7\n         CALL  JCECVTBD\n         L     R10,CVTADDR\n         STCM  R1,B'0011',CCWTO3D+13   (MSG 131)\n         WTO   CONSID=CONSOLE,MF=(E,CCWTO3D)                    EEJ1102\n         B     ENDPROG\n*\nLGNSMINI DS    0H\n         L     R1,=A(MSG129)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG129L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDPROG\n*\nLGNSERR  DS    0H\n         WTO   'TSSC130S Q LOGON CONTROL COMMAND ENCOUNTERED A SEVERE EX\n               RROR- CONTACT TSSO SUPPORT',DESC=(1)\n         B     ENDPROG\n         DROP  R6\n*\n*\nQUERYTAB DS    0H\n***********************************************************************\n* THE ALL IMPORTANT .QT COMMAND                                       *\n*                                                                     *\n***********************************************************************\n         L     R6,TSSOTABL       GET ADDRESS OF TABLE\n         LTR   R6,R6\n         BNZ   QTABREAL\n         L     R1,=A(MSG121)       Load WTO parm list address   EEJ1102\n         MVC   WTOWK(MSG121L),0(R1) Copy WTO parm list          EEJ1102\n         WTO   CONSID=CONSOLE,     Issue the message            EEJ1102+\n               MF=(E,WTOWK)        (same)                       EEJ1102\n         B     ENDQUERY\n*\nQTABREAL DS    0H\n         MVC   WTO15D+33(8),TSSOTABN\n         WTO   CONSID=CONSOLE,MF=(E,WTO15D)  (MSG 122)          EEJ1102\n         MVC   WTO38D+23(8),12(R6)  INSERT TABLE ID.\n         MVC   WTO38D+39(8),28(R6)  INSERT DATE ASSEMBLED\n         MVC   WTO38D+55(8),36(R6)  INSERT TIME.\n         WTO   CONSID=CONSOLE,MF=(E,WTO38D) (MSG 123)           EEJ1102\n         B     ENDQUERY\nENDQUERY DS    0H\n         B     ENDPROG\n*\n*\n*\n*\n*\nLISTREQ  DS    0H\n***********************************************************************\n* THE #.L COMMAND WILL LIST THE OUTPUT FROM THE LAST TSSO COMMAND OR  *\n* CLIST AT SOME OTHER CONSOLE.                                        *\n*                                                                     *\n***********************************************************************\n         MVC   CCMDFLAG+2(2),CONSOLE+2   ASSUME SOURCE CONSOLE.\n         CLI   PARARRAY+18,C' '           L=N OR L=NN, CONSOLE ID\n         BE    LISTSCON                   JUST L, USE SOURCE CONSOLE\n         CLI   PARARRAY+18,C'0'\n         BL    LISTSCON\n*\n         CLI   PARARRAY+19,C'0'\n         BL    LISTID1\n         PACK  DOUBLE,PARARRAY+18(2)\n         B     AR10\nLISTID1  PACK  DOUBLE,PARARRAY+18(1)\nAR10     DS    0H\n         CVB   R0,DOUBLE\n         LTR   R0,R0\n         BZ    LISTSCON\n         STH   R0,CCMDFLAG+2\nLISTSCON DS    0H\n         OI    CCMDFLAG,X'40'       SET FLAG INDICATING LIST OUTPUT\n         B     ENDPROG\n*\n*\n*\n*\nSTOPREQ  DS   0H\n***********************************************************************\n* THIS A A REQUEST TO TERMINATE THE TSSO SUBSYSTEM...                 *\n***********************************************************************\n         OI   CCMDFLAG,X'80'        INDICATE OPERATORS DESIRES...\n         B    ENDPROG               OH WELL...\nEXIT0    DS   0H\nENDPROG  DS   0H\n         LR     R1,R13              GET ADDRESS OF CORE IN R1\n         L      R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS     0H\n         L      R14,12(R13)         RELOAD RETURN POINT\n         XR     R15,R15\n         LM     R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR     R14\n*\nREQJOBID DS    0H\n***********************************************************************\n* THIS IS THE SUBROUTINE TO REQUEST A JOB ID FROM THE PRIMARY JOB     *\n* ENTRY SUBSYSTEM. TSSO WILL MAKE THE SUBSYSTEM CALL TO JES REQUESTING*\n* THAT IT BE KNOWN.                                                   *\n***********************************************************************\n         L     R3,16               CVTPTR\n         USING CVT,R3\n         L     R4,CVTJESCT         JES CONTROL TABLE\n         USING JESCT,R4\n*              FOR SUBSYSTEMS, SSIBSSNM IS MSTR, SSIBJBID IS NAME\n*              FOR STC,        SSIBSSNM IS JES2, SSIBJBID IS STC NNNN\n         MVC   PRIMSSIB+8(4),JESPJESN\n         LR    R6,R14\n         LA    R5,$SVSSOB           GET ADDRESS OF AN SSOB\n         USING SSOB,R5              ADDRESS IT\n         MVC   SSOBID(4),=C'SSOB'   FILL IN  \"SSOB\" HEADER\n         LA    R15,SSOBHSIZ         GET LENGTH  OF HEADER\n*                                   FROM IEFJSSOBH (COMMON HEADER)\n         STH   R15,SSOBLEN          FILL IN LENGTH FIELD\n         LA    R15,SSOBRQST         GET \"REQUEST\" IDENTIFIER\n         STH   R15,SSOBFUNC         AND STORE IN FUNCTION FIELD\n         LA    R15,$SVSSIB           GET ADDRESS OF OUR NEW SSIB\n         MVC   $SVSSIB(36),PRIMSSIB  FILL IN ALL FIELDS FROM MODEL\n         ST    R15,SSOBSSIB          STORE IN OUR SSOB\n         LA    R15,SSRRBGN          GET ADDRESS OF FUNCTION DEPENDENT\n*                                   AREA\n         ST    R15,SSOBINDV         AND STORE AWAY\n         LA    R1,$SVSSOBA           POINT TO ADDRESS FIELD TO CONTAIN\n*                                   A(SSOB)\n         ST    R5,0(R1)             PUT ADDRESS OF OUR SSOB INTO IT\n         OI    0(R1),X'80'          FLIP ON HIGH ORDER BIT\n*                                   AS REQUIRED BY IEFSSREQ\n         LA    R15,8\n         STH   R15,SSRRLEN          COMPLETE SSOB EXTENSION BY\n*                                   FILLING IN LENGTH FIELD OF 8\n         LA    R15,$SVRRECB         GIVE IT AN ECB\n         ST    R15,SSRRSECB         AND TELL IT WHERE IT IS\n         DROP  R5                  SSOB\n         SPACE\n         LR    R5,R1                SAVE R5 ACROSS THE MODESET\n         MODESET MODE=SUP\n         LR    R1,R5                AND RETRIEVE IT\n         SPACE\n         PUSH  USING                                        RPS\n         DROP  R3,R4                                        RPS\n         IEFSSREQ\n         POP   USING                                        RPS\n         LR    R5,R15               SAVE RETURN CODE FROM IEFSSREQ\n         MODESET MODE=PROB\n*\n         MODESET KEY=ZERO\n*\n         LR    R15,R5               AND RETRIEVE IT.\n         LTR   R15,R15\n         BZ    OKREQ\n         WTO   'TSSC124E TSSO IS UNABLE TO OBTAIN A JOB IDENTIFIER FROMX\n               THE JOB ENTRY SUBSYSTEM'\n         BR    R6\nOKREQ    DS    0H                  WE HAVE A JOB ID\n         OI    TSSOFLG1,TSSOJBID   WE HAVE A JOB ID\n*\n*              OPENING A SYSOUT DATA SET WILL CAUSE A 913-C0 ABEND\n*              UNLESS THE JSCB POINTS TO A JES2 SSIB.  WE COULD\n*              MODIFY THE SSIB, OR POINT THE JSCB TO A NEW SSIB.\n*              THE LATTER IS USED HERE.  THE OTHER METHOD HAS\n*              NOT BEEN TESTED.\n*\n         SPACE\n         SPACE\n         LA    R1,$SVSSIB          POINT TO OUR SSIB\n         L     R15,TSSOJSCB\n         STCM  R1,7,X'13D'(R15)    JSCBSSIB-JSCB(,R15)\n         OI    TSSOFLG1,TSSOJSMD   INDICATE JSCB MODIFIED\n         SPACE\n         BR    R6\n***********************************************************************\n* CONSTANTS AREA FOR TSSOCCMD VARIABLES ONLY                          *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCCWTO1C  WTO   'TSSC126I SECURITY LEVEL IS XXXXXXXX, SYSTEM IS XXXX',  X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO1CE EQU   *\n*\nCCWTO2C  WTO   'TSSC128I CONSOLE ID: XXXXXXXX, USER XXXXXXXX',         X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO2CE EQU   *\n*\nCCWTO3C  WTO   'TSSC131I XX CONSOLES CURRENTLY LOGGED ON TO TSSO',     X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO3CE EQU   *\n*\n*\nCCWTO4C  WTO   'TSSC139I CONSOLES WILL \"TIME OUT\" IN XX MINUTES',      X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO4CE EQU   *\n*\nCCWTO5C  WTO   'TSSC140I TSSO LX RESERVED VALUE IS XXXXXXXX',          X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO5CE EQU   *\n*\nPOST1C   POST  ,ASCB=0,ERRET=0,MF=L\nPOST1CE  DS    0H\n*\nCMDTABLE DS    0H\n***********************************************************************\n* THE FORMAT OF THE TSSO CONTROL COMMANDS TABLE IS AS FOLLOWS.        *\n* 8 BYTES: COMMAND NAME                                               *\n* 4 BYTES: ADDRESS OF ROUTINE TO HANDLE IT                            *\n* 4 BYTES: FLAGS                                                      *\n*          BYTE 1:\n*          X'80'     COMMAND REQUIRES AT LEAST SYSTEM AUTHORITY\n***********************************************************************\n         DC    CL8'P       ',AL4(STOPREQ),X'80000000'       RESTRICTED\n         DC    CL8'L       ',AL4(LISTREQ),X'00000000'   NOT RESTRICTED\n         DC    CL8'M       ',AL4(MONITOR),X'80000000'       RESTRICTED\n         DC    CL8'J       ',AL4(STC),X'80000000'           RESTRICTED\n         DC    CL8'Q       ',AL4(QUERY),X'00000000'     NOT RESTRICTED\n         DC    CL8'RELOAD  ',AL4(RELOAD),X'80000000'        RESTRICTED\n         DC    CL8'ABEND   ',AL4(ABENDIT),X'80000000'       RESTRICTED\n         DC    CL8'LOGON   ',AL4(LOGON),X'00000000'  NOT  RESTRICTED\n         DC    CL8'LOGOFF  ',AL4(LOGOFF),X'00000000'   NOT RESTRICTED\n         DC    CL8'ZZZZZZZZ',AL4(0),X'00000000'         END OF TABLE.\nQRYTABLE DS    0H\n***********************************************************************\n* THE FORMAT OF THE TSSO QUERY CONTROL COMMAND TABLE IS AS FOLLOWS    *\n* 8 BYTES: COMMAND NAME                                               *\n* 4 BYTES: ADDRESS OF ROUTINE TO HANDLE IT                            *\n* 4 BYTES: FLAGS                                                      *\n*          BYTE 1:\n*          X'80'     COMMAND REQUIRES AT LEAST SYSTEM AUTHORITY\n***********************************************************************\n         DC    CL8'T       ',AL4(QUERYTAB),X'00000000'  NOT RESTRICTED\n         DC    CL8'TABLE   ',AL4(QUERYTAB),X'00000000'  NOT RESTRICTED\n         DC    CL8'MAXCMD  ',AL4(QMAXCMD),X'00000000'   NOT RESTRICTED\n         DC    CL8'MAXWTO  ',AL4(QMAXWTO),X'00000000'   NOT RESTRICTED\n         DC    CL8'TIMEOUT ',AL4(QTMEOUT),X'00000000'   NOT RESTRICTED\n         DC    CL8'SWAP    ',AL4(QUERYSWP),X'00000000'  NOT RESTRICTED\n         DC    CL8'RACF    ',AL4(QUERYRCF),X'80000000'      RESTRICTED\n         DC    CL8'VERS    ',AL4(QUERYVRS),X'00000000'  NOT RESTRICTED\n         DC    CL8'SCON    ',AL4(QUERYSCO),X'00000000'  NOT RESTRICTED\n         DC    CL8'SEC     ',AL4(QUERYSEC),X'00000000'  NOT RESTRICTED\n         DC    CL8'LOGON   ',AL4(QUERYLGN),X'00000000'  NOT RESTRICTED\n         DC    CL8'XMEM    ',AL4(QUERYXME),X'00000000'  NOT RESTRICTED\n         DC    CL8'ZZZZZZZZ',AL4(0),X'00000000'         END OF TABLE.\n*                                                               EEJ1102\n         LTORG ,                                                EEJ1102\n*                                                               EEJ1102\n* Messages                                                      EEJ1102\n*                                                               EEJ1102\nMSG102   WTO   'TSSC102E INVALID TSSO CONTROL COMMAND',         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMSG102L  EQU   *-MSG102                                         EEJ1102\n*                                                               EEJ1102\nMSG103   WTO   'TSSC103E RESTRICTED T S S O   COMMAND',         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMSG103L  EQU   *-MSG103                                         EEJ1102\n*                                                               EEJ1102\nMSG105   WTO   'TSSC105S INVALID TSSO MONITORING CONTROL COMMAND',     X\n               CONSID=,MF=L                                     EEJ1102\nMSG105L  EQU   *-MSG105                                         EEJ1102\n*                                                               EEJ1102\nMSG107   WTO   'TSSC107I TSSO AUTOMATED OPERATOR FACILITY TABLE RELOADEX\n               D',CONSID=,MF=L                                  EEJ1102\nMSG107L  EQU   *-MSG107                                         EEJ1102\n*                                                               EEJ1102\nMSG138   WTO  'TSSC138E LOGON COMMAND REJECTED - PARAMETER MISSING',   X\n               CONSID=,MF=L                                     EEJ1102\nMSG138L  EQU   *-MSG138                                         EEJ1102\n*                                                               EEJ1102\nMSG135   WTO  'TSSC135E LOGON COMMAND REJECTED - SECURITY LEVEL IS MINIX\n               MAL',CONSID=,MF=L                                EEJ1102\nMSG135L  EQU   *-MSG135                                         EEJ1102\n*                                                               EEJ1102\nMSG131   WTO  'TSSC131E LOGON COMMAND REJECTED - USER ALREADY LOGGED ONX\n               ',CONSID=,MF=L                                   EEJ1102\nMSG131L  EQU   *-MSG131                                         EEJ1102\n*                                                               EEJ1102\nMSG132   WTO  'TSSC132E LOGON COMMAND REJECTED - CONSOLE ALREADY LOGGEDX\n                ON',CONSID=,MF=L                                EEJ1102\nMSG132L  EQU   *-MSG132                                         EEJ1102\n*                                                               EEJ1102\nMSG133   WTO  'TSSC133E LOGON COMMAND REJECTED - TSSO MAX USERS (20)  AX\n               LREADY LOGGED ON',CONSID=,MF=L                   EEJ1102\nMSG133L  EQU   *-MSG133                                         EEJ1102\n*                                                               EEJ1102\nMSG136   WTO   'TSSC136I LOGOFF COMMAND REJECTED - SECLEVEL = MINIMAL',X\n               CONSID=,MF=L                                     EEJ1102\nMSG136L  EQU   *-MSG136                                         EEJ1102\n*                                                               EEJ1102\nMSG137   WTO   'TSSC137I LOGOFF COMMAND REJECTED - CONSOLE IS NOT LOGGEX\n               D ON',CONSID=,MF=L                               EEJ1102\nMSG137L  EQU   *-MSG137                                         EEJ1102\n*                                                               EEJ1102\nMSG110   WTO   'TSSC110E INVALID TSSO QUERY COMMAND',           EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMSG110L  EQU   *-MSG110                                         EEJ1102\n*                                                               EEJ1102\nMSG111   WTO   'TSSC111E RESTRICTED T S S O QUERY COMMAND',     EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMSG111L  EQU   *-MSG111                                         EEJ1102\n*                                                               EEJ1102\nMSG115   WTO   'TSSC115I TSSO IS RUNNING NON SWAPPABLE',        EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nMSG115L  EQU   *-MSG115                                         EEJ1102\n*                                                               EEJ1102\nMSG116   WTO   'TSSC116E TSSO IS RUNNING SWAPPABLE- PERFORMANCE MAY BE X\n               DEGRADED',CONSID=,MF=L                           EEJ1102\nMSG116L  EQU   *-MSG116                                         EEJ1102\n*                                                               EEJ1102\nMSG120   WTO   'TSSC120E TSSO DOES NOT HAVE ANY SUBSYSTEM CONSOLES',   X\n               CONSID=,MF=L                                     EEJ1102\nMSG120L  EQU   *-MSG120                                         EEJ1102\n*                                                               EEJ1102\nMSG141   WTO   'TSSC141I TSSO CROSS MEMORY SERVICES ENVIRONMENT NOT ESTX\n               ABLISHED',CONSID=,MF=L                           EEJ1102\nMSG141L  EQU   *-MSG141                                         EEJ1102\n*                                                               EEJ1102\nMSG129   WTO   'TSSC129E Q LOGON CONTROL COMMAND INVALID IF SECLEVEL ISX\n                MINIMAL',CONSID=,MF=L                           EEJ1102\nMSG129L  EQU   *-MSG129                                         EEJ1102\n*                                                               EEJ1102\nMSG121   WTO   'TSSC121I TSSO AUTOMATED OPERATIONS FACILITY IS NOT ACTIX\n               VE',CONSID=,MF=L                                 EEJ1102\nMSG121L  EQU   *-MSG121                                         EEJ1102\n*                                                               EEJ1102\nCCMDDATD DSECT\n***********************************************************************\n* DATA AREA FOR TSSOCCMD VARIABLES ONLY                               *\n*                                                                     *\n***********************************************************************\nCCWTO1D  WTO   'TSSC126I SECURITY LEVEL IS XXXXXXXX, SYSTEM IS XXXX',  X\n               CONSID=,MF=L                                     EEJ1102\n*\nCCWTO2D  WTO   'TSSC128I CONSOLE ID: XXXXXXXX, USER XXXXXXXX',         X\n               CONSID=,MF=L                                     EEJ1102\n*\nCCWTO3D  WTO   'TSSC131I XX CONSOLES CURRENTLY LOGGED ON TO TSSO',     X\n               CONSID=,MF=L                                     EEJ1102\n*\nCCWTO4D  WTO   'TSSC139I CONSOLES WILL \"TIME OUT\" IN XX MINUTES',      X\n               CONSID=,MF=L                                     EEJ1102\nCCWTO5D  WTO   'TSSC140I TSSO LX RESERVED VALUE IS XXXXXXXX',          X\n               CONSID=,MF=L                                     EEJ1102\n*\nPOST1D   POST  ,ASCB=0,ERRET=0,MF=L\n*\nWTOWK    DS    32D                 WTO work area                EEJ1102\nCONSOLE  DS    F            CONSOLE INVOKING THIS COMMAND\nCONSNAME DS    CL8          Console name                        EEJ1102\nNEWENTAD DS    F            ADDRESS OF NOT IN USE ENTRY IN SECURITY\nCVTADDR  DS    F            ADDRESS OF THE TSSO CVT\n*                           ARRAY\nDINTVL   DS    CL8          TIME INTERVAL.\nAUTHBITS DS    X\n***********************************************************************\n* PARAMETERS TO PASS TO THE SECURITY LOGON ROUTINE.                   *\n*                                                                     *\n***********************************************************************\nSECPRM   DS    0H\nPRMFLAGS DS    XL2\n* X'80'  ROUTINE CALLED FOR LOGON\n* X'40'  ROUTINE CALLED FOR LOGOFF.\n         DS    CL2                 Reserved for future use      EEJ1102\nPRMACEE  DS    CL4\nPRMUSER  DS    CL8\nPRMPASS  DS    CL8\nPRMCNID  DS    XL4                 Console ID                   EEJ1102\nPRMCNAME DS    CL8                 Console name                 EEJ1102\n         COPY  TSSODATD\n         TSSOCVT\n         TSSONDSA\n         TSSOSECR\n         TAOFNTRY\n         SSCONCBH\n         SSCONCB\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         IEFJSSIB\n         IEFJSSOB (CM,RR),CONTIG=YES\n         IEZJSCB\nUCM      DSECT\n         IEECUCM\n         END   TSSOCCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOCCMD(''TSSO V 4.3.0  &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOCCMD'\n PUNCH ' NAME     TSSOCCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOCMND": {"ttr": 36616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00B\\x01\\x022\\x0f\\x01\\x022\\x0f\\x12F\\x00\\x1a\\x00\\x12\\x00\\n\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-11-16T00:00:00", "modifydate": "2002-11-16T12:46:42", "lines": 26, "newlines": 18, "modlines": 10, "user": "EDJXADM"}, "text": "         MACRO\n         TSSOCMND\n*****************************************************************\n* THIS IS THE TSSO COMMAND RING DSECT. TSSO COMMANDS ARE CHAINED*\n* OF THE CMDRING POINTER IN THE TSSOCVT, AND EACH COMMAND LOOKS *\n* LIKE THIS ONE.\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ  Support MCS extended consoles                *EEJ1102\n*                                                              *EEJ1102\n*****************************************************************\nTSSOCMND DSECT\nCMNDNEXT DS    A             ADDRESS OF NEXT COMMAND IN RING\nCMNDFLAG DS    F\n* BYTE 1\n* X'80' COMMAND HAS BEEN ISSUED, BUT NOT EXECUTED.\nCMNDCONS DS    F             CONSOLE FOR THIS COMMAND\nCMNDLENG DS    F             LENGTH OF THIS COMMAND\nCMNDCMD  DS    CL128         TSSO COMMAND\nCMNDNAME DS    CL8           Console name                       EEJ1102\nCMNDAUTH DS    XL2           Console authority bits             EEJ1102\nCMDNRSVD DS    CL102         Reserved for future use            EEJ1102\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSSOCVT": {"ttr": 36618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00n\\x00n\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         TSSOCVT\n***********************************************************************\n* THIS MACRO MAPS THE TSSO COMMUNICATION VECTOR TABLE. THIS CONTROL   *\n* BLOCK IS THE PRIMARY INTERFACE BETWEEN THE TSSO ADDRESS SPACE, AND  *\n* THE SUBSYSTEM SUPPORT MODULE                                        *\n***********************************************************************\nTSSOCVT  DSECT\nTSSOFLG1 DS    X            FLAG BYTE.\nTSSOJBID EQU   X'80'        TSSO HAS OBTAINED A JOB ID FROM JES\nTSSOJSMD EQU   X'40'        TSSO HAS MODIFIED THE JSCBSSIB FIELD.\nTSSOGONE EQU   X'20'        TSSO HAS TERMINATED.\nTSSOSCON EQU   X'10'        TSSO HAS OBTAINED A SUBSYSTEM CONSOLE.\nTSSOMSGI EQU   X'08'        TSSO SHOULD BE INTERCEPTING MESSAGES\n*                           DESTINED FOR THE SUBSYSTEM ALLOCATABLE\n*                           CONSOLE.\nTSSOSMPF EQU   X'04'        IGNORE MPF SUPPRESSED MESSAGES      14DEC92\n*\nTSSOFLG2 DS    X            FLAG BYTE USED FOR MONITORING.\nTSSOMON  EQU   X'80'        TSSO MONITORING IS ENABLED.\nTSSOOKFL EQU   X'40'        ECHO BACK \"OK\" AFTER EACH COMMAND.\nTSSOPLOA EQU   X'20'        TSSOPCMD HAS BEEN LOADED\nTSSOXMON EQU   X'10'        A VALID CROSS MEMORY SERVICES ENVIRONMENT\n*                           EXISTS...\n*\nTSSOFLG3 DS    X\nINESTAE  EQU   X'80'        THE TSSO ESTAE ROUTINE HAS BEEN VISITED.\n*\nTSSOFLG4 DS    X\n*\n$SVPOSTE DS    F            ECB FOR COMMUNICATION BETWEEN TSSO ADDRESS\n*                           SPACE AND SUBSYSTEM ROUTINES.\n*\nTSSOASCB DS    F            ASCB FOR THE TSSO ADDRESS SPACE.\n*\n$SVPOSTL DS    3F           LIST FORM OF POST MACRO.\n*\nTSSOTABL DS    A            ADDRESS OF THE TSSO TABLE FOR\n*                           EXTENDED OPERATOR FUNCTION.\n*\nTSSOBSTH DS    A            ADDRESS OF HEADER OF BLOCK CONTAINING\n*                           BINARY SEARCH TABLE\n*\nTSSOBSTS DS    A            ADDRESS OF START OF BINARY SEARCH TABLE\n*                           FOR EXTENDED OPERATOR FUNCTION.\n*\nTSSOBSTE DS    A            ADDRESS OF END OF BINARY SEARCH TABLE\n*                           FOR EXTENDED OPERATOR FUNCTION.\n*\nTSSOBSTL DS    F            LENGTH OF ENTRY IN BINARY SEARCH TABLE\n*                           FOR EXTENDED OPERATOR FUNCTION.\n*\nTSSOALMS DS    A            ADDRESS OF CHAIN OF AOFNTRY BLOCKS FOR\n*                           MSG=* PROCESSING.\n*\nTSSOCHAR DS    CL1          TSSO SYSTEM RECOGNITION CHARACTER\n*\nMASTCONS DS    H            MASTER CONSOLE FOR THE MVS SYSTEM\n*\nTSSOSSVT DC    F'0'         ADDRESS OF THE SSVT FOR TSSO\n*\nTSSOSSCT DC    F'0'         ADDRESS OF THE SSCT FOR TSSO\n*\n$SSSM    DC    F'0'\n*\nTSSOSSIB DC    A(0)                ADDRESS(ORIGINAL SSIB FOR TSSO)\n*\nSSSMNAME DS    CL8                 NAME OF SUB SYSTEM SUPPORT MODULE\n*\nESTASDWA DC    CL2' '              1ST BYTE = Y IF SDWA EXISTS\n*\nCMDRING  DS    A                   ADDRESS OF TSSO COMMAND RING\n*\nNUMCMDS  DS    F                   MAXIMUM NUMBER OF TSSO COMMAND\n*                                  IN COMMAND RING\nNEXTCMD  DS    A                   ADDRESS OF NEXT TSSO COMMAND TOKEN,\n*                                  I.E. PLACE FOR SSSM TO STORE NEXT\n*                                  COMMAND.\n*\nTSSODSEC DS    A                   ADDRESS OF THE TSSO DATD DSECT.\n*\n*\nTSSOSCNA DS    A                   ADDRESS OF THE UCMAUTH BYTE FOR\n*                                  TSSO SUBSYSTEM CONSOLES. THIS IS A\n*                                  CONVIENANCE FOR THE TSSOGSSC ROUTINE\n*\nTSSCONID DS    F                   CONSOLE ID FOR TSSOGSSC. THIS VALUE\n*                                  IS NO LONGER THE SUBSYSTEM CONSOLE\n*                                  ID FOR ALL OF TSSO.\n*\nSECARRAY DS    A                   ADDRESS OF THE SECURITY ARRAY TABLE\n*                                  FOR CONSOLE SIGNONS\n*\n*\nSSCONSAD DS    A                   ADDRESS OF THE TSSO SUBSYSTEM\n*                                  CONSOLE CONTROL BLOCK HEADER\n*\nSECLEVEL DS    CL4                 SECURITY LEVEL FOR TSSO.\n*\nSECTMEOT DS    F                   SECURITY TIMEOUT VALUE\n*\nOPCMDADR DS    A                   ADDRESS OF THE TSSOPCMD MODULE\n*\nCOUNTOSC DS    F                   NUMBER OF OSCMDS ISSUE SO FAR.\n*\nCOUNTCMD DS    F                   NUMBER OF TSO COMMANDS ISSUED.\n*\nTSSOCVTL EQU   *-TSSOCVT\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSODATD": {"ttr": 36621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00Y\\x01\\x022\\x0f\\x01\\x172O\\x10\\x04\\x00\\xea\\x00\\xe5\\x00\\\\\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2002-11-16T00:00:00", "modifydate": "2017-11-20T10:04:59", "lines": 234, "newlines": 229, "modlines": 92, "user": "JOARMC"}, "text": "***********************************************************************\n* THIS IS THE TSSO ADDRESS SPACE COMMON DATA DSECT. ALL TSSO MODULES  *\n* NEEDING TO REFERENCE THIS DSECT CAN PICK IT UP AFTER INITIALIZATION *\n* FROM THE TSSODSEC FIELD IN THE TSSO CVT.                            *\n*                                                                     *\n* THESE FIELDS ARE INITIALIZED MOSTLY IN THE TSSOINIT MODULE.         *\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ  Support MCS extended consoles                *EEJ1102\n*                                                              *EEJ1102\n***********************************************************************\nDATD     DSECT\n*PLIST    DS    0CL200\nWORKAREA DS    CL200            WORK AREA FOR CONVERSIONS AND STUFF\nPARMPTR  DS    A                POINTER TO TSSO PARMS FROM JCL OR OP\n*                               CONSOLE\n************************************************************\n* TSSO SUBSYSTEM PARAMETER SECTION. ALL THESE VALUES CAN BE*\n* SET FROM THE TSSO PARMLIB MEMBER.\n************************************************************\nPARMMEM  DC    CL8' '           ADDRESS OF BUFFER FROM PARM READS\nPARMBLK  DS    F                BLOCKSIZE OF SYS1.PARMLIB\nPARMREAD DS    F                NUMBER OF BYTES READ THIS TIME\nPARMBUF  DS    A                POINTER TO BUFFER FOR PARMLIB\n*\nTMPNAME  DS    CL8              NAME OF THE TERMINAL MONITOR PGM\nTSSOSRC  DS    X                TSSO SUBSYSTEM RECOGNITION CHAR\nTSSOMPF  DS    X                MPFSUPP PARAMETER               14DEC92\nTSSOSSSM DC    CL8' '           NAME OF TSSO SUB SYSTEM SUPPORT\n*                               MODULE\nINISEC   DS    CL4              MINI, MEDI OR MAXI\nININUMSS DS    F                NUMBER OF SUBSYSTEM CONSOLES REQUESTED\nTSSOTABN DC    CL8' '           NAME OF TSSO SYSTEM CONTROL TABLE\nMAXCMDS  DS    F                MAXIMUM NUMBER OF COMMANDS\nTMEOTVL  DS    F                TSSO TIMEOUT VALUE.\nMAXWTO   DS    F                MAXIMUM NUMBER OF WTOS FOR ANY 1\n*                               COMMAND.\nTSSOSWAP DS    X                SWAPPABLE OR NON-SWAPPABLE\n*                               Y - NON SWAPPABLE\n*                               N - SWAPPABLE\nTSSOPROM DS    X                TSSO PROMPTS OPERATOR FOR PARMS\nTSSORACF DS    CL9              TSSO RACF USER ID (AND LENGTH IN BYTE 1\nSTARFORC DS    C                FORCE START TSSO - Y = YES, N = NO\nWTORECB  DS    A\nPROMPINP DS    CL80             PROMPTING INPUT\nSSIARRAY DS    CL360            ARRAY OF UP TO 10 SUBSYSTEM INTERFACE\n*                               CHARACTERS.\n* EACH ENTRY IN THE ARRAY WILL HAVE THE FOLLOWING ENTRIES.\n* DC CL2'SUBSYSTEM FUNCTION NUMBER'\n* DC CL6'RESERVED'\n* DS CL8'LOAD MODULE NAME'\n* DS CL4'LOAD MODULE ADDRESS IN CSA'\n* DS CL8'DATE OF ASSEMBLY'\n* DS CL8'TIME OF ASSEMBLY'\n*\n* DS CL36 CHARACTERS PER ENTRY.\n*\nSSICOUNT DS    H                COUNT OF SUPPORTED SSI CALLS  IN TSSO\n************************************************************\n* THESE VARIABLES ARE REQUIRED TO ISSUE A TSO COMMAND      *\n* USING THE ISSUECMD SUBROUTINE. THE IDEA IS TO PLACE VALUE*\n* IN THESE VARIABLES, WHEREAS THAT ROUTINE CAN THAT PICK   *\n* UP THOSE VALUES AND EXECUTE THE COMMAND                  *\n************************************************************\nTSSOPFLG DS    F                PARAMETERS TO PASS TO DOCM.\n*BYTE 1:\n* X'80' - NO AUTHORITY CHECKING FOR THIS COMMAND.\nTSSOPRMP DS    A                POINTER TO THE TSO PARM LIST.\nTSSOPRMS DS    0H               TSSO PARAMETER TSO PARM LIST.\nTSSOCMDL DS    H                LENGTH OF TSO COMMAND\nTSSOCMD  DS    CL130            ACTUAL TSO COMMAND TO BE ISSUED\nTSSOPECB DS    F                ECB TO WAIT ON WHILE TMP IS RUNNING\nTSSOPTCB DS    A                ADDRESS OF THE TMP'S TCB\n************************************************************\n* TSSO MAINLINE PROGRAM VARIABLES\n************************************************************\nHOLDSSIB DS    A                TEMP STORAGE FOR TSSOSSIB FIELD\nTSSOCVTA DS    A                ADDRESS OF TSSO CVT             30OCT92\nTSSOTCB  DC    F'0'             TSSO MAINLINE TCB\nTSSOJSCB DC    F'0'             TSSO SUBSYSTEM INTERFACE BLOCK\nTSSOASXB DS    F\nTSSOACEE DS    A              ADDRESS OF TSSO'S ACEE.\nTSSOSENV DS    F\nRACFSENV DS    F              ACEE BEFORE WE MODIFY IT.\nATTCECB2 DC    F'0'\nATTCTCB2 DC    F'0'\nTSSOSSNM DS    F              TSSO SSIB SUBSYSTEM NAME\nWTOADDR  DS    A              ADDRESS OF TSSOWTO MODULE\nTSSWPARM DS    A              TSSOWTO MODULE PARAMETERS.\nDOUBLE   DS    D                DOUBLEWORD USED FOR PACKING\nCMDRINGL DS    A              ADDRESS OF TSSO COMMAND RING- USED TO\n*                             HOLD ADDRESS UNTIL WE GET TSSO CVT\nCURRCMD  DS    A              CURRENT COMMAND ENTRY THAT TSSO IS\n*                             PROCESSING\nCONSPARM DS    F              CONSOLE ID TO BE USED AS A PARAMETER TO\n*                             THE TSSOWTO MODULE.\nTSSWFLAG DS    F              FLAG WORD TO BE USED AS A PARAMETER TO\n*                             THE TSSOWTO MODULE.\nCCMDFLAG DS    F              FLAG WORD TO BE USED AS OUTPUT FROM THE\n*                             TSSOCCMD MODULE.\n* CCMDFLAG: BYTE 1\n*           X'80'  CONTROL COMMAND IS A REQUEST TO STOP TSSO\n*           X'40'  AT THE COMPLETION OF THE CONTROL COMMAND, LIST THE\n*                  SYSTSPRT FILE. THE CONSOLE WILL BE IN THE LOW\n*                  ORDER THREE BYTES.\nCURRCONS DS    F              CONSOLE FOR CURRENT COMMAND (I.E. CMD\n*                             TSSO IS CURRENTLY WORKING ON.\nCURRCNAM DS    CL8                 Current console name         EEJ1102\nCURRCATH DS    XL2                 Current console auth bits    EEJ1102\n***********************************************************************\n*                                                                     *\n*                                                                     *\n* THESE VARIABLES ARE REQUIRED TO SUPPORT THE #.J FUNCTIONS OF TSSO   *\n*                                                                     *\n***********************************************************************\nPRIMSSIB DC    0F'0',C'SSIB',AL2(36,0),C'JES2',CL16' ',XL8'00'\n$SVSSIB  DS    9F\n$SVSSOBA DS    F\n$SVSSOB  DS    5F,7F\n$SVRRECB DS    F\n***********************************************************************\n*                                                                     *\n*                                                                     *\n* THESE VARIABLES SUPPORT THE NEW SECURITY FEATURES IN TSSO 4.2       *\n*                                                                     *\n***********************************************************************\nSECSYS   DS    CL4           (RACF, ACF2)\n***********************************************************************\n* THESE VARIABLES ARE REQUIRED TO FORM THE RE-ENTRANT FORMS OF THE    *\n* MVS MACRO INSTRUCTIONS.                                             *\n***********************************************************************\nESTAED   ESTAE 0,MF=L\n*\nETDESD   ETDES  TOKEN=0,PURGE=YES,MF=L\n*\n*READD    READ  DECB,SF,MF=L\n*PARMDCBD DCB   DDNAME=PARMLIB,DSORG=PO,MACRF=R\n*OPEND    OPEN  (,INPUT),MF=L\n*CLOSED   CLOSE  (,LEAVE),MF=L\nATTACHD  ATTACH SF=L\nCALL1D   CALL  ,(0,0,0),MF=L\nPARSPARM DS    0H\nPARS1    DS    A\nPARS2    DS    A\nPARS3    DS    A\nPARS4    DS    A\nPARSSEP  DS    CL4\nPARARRAY DS    CL130\nPARMFLAG DS    X\n* X'80'  STORAGE WAS OBTAINED\n* X'40'  PROMPTING REQUESTED DURING PARMLIB INPUT\n* X'20'  CURRENTLY IN PROMPT MODE.\n* X'10'  A DEDICATED SUBSYSTEM CONSOLE IS REQUESTED.\n* X'01'  SEVERE ERROR IN INITIALIZATION...\n*                                                               EEJ1102\nWTO1D    WTO   'TSSI065S SUBSYSTEM NAME NOT DEFINED- TSSO TERMINATING',X\n               DESC=(1),MF=L\n*\nWTO4D    WTO   'TSST060I  T S S O   VERSION 4.3.0 INITIALIZATION COMPLEX\n               TED',MF=L\n*\nWTO9D    WTO   'TSST052S TSSO COULD NOT LOAD ITS ESTAE MODULE (TSSOESTAX\n                AND IS TERMINATING',MF=L,DESC=(1)\n*\nWTO10D   WTO   'TSST061I TSSO IS WAITING FOR POST FROM SSSM',MF=L\n*\nWTO11D   WTO   'TSST062I TSSO HAS BEEN POSTED FROM SSSM',MF=L\n*\nWTO14D   WTO   'TSST064I TSSO DISCONNECTED- SUBSYSTEM UNAVAILABLE',MF=L\n*\nWTO15D   WTO   'TSSC122I TSSO IS USING TABLE XXXXXXXX FOR THE AUTOMATEDX\n                 OPERATIONS FACILITY',CONSID=,MF=L              EEJ1102\n*\nWTO16D   WTO   'TSSI007E PARMLIB PARAMETER \"XXXXXXXX\" IS INVALID',MF=L\n*\nWTO17D   WTO   'TSSI008E PARMLIB PARAMETER \"XXXXXXXX\" IS INCORRECTLY SPX\n               ECIFIED',MF=L\n*\nWTO18D   WTO   'TSSI010E MEMBER XXXXXXXX IS NOT IN PARMLIB- TSSO DEFAULX\n               TS USED',MF=L\n*\nWTO19D   WTO   'TSST055I TSSO IS USING TABLE NAME XXXXXXXX FOR THE AUTOX\n               MATED OPERATIONS FACILITY',CONSID=,MF=L          EEJ1102\n*\nWTO20D   WTO   'TSSC108S MODULE XXXXXXXX NOT FOUND, AUTOMATED OPERATIONX\n               S FACILITY DEACTIVATED',DESC=1,MF=L\n*\nWTO21D   WTO   'TSSC109S MODULE XXXXXXXX IS NOT AN AUTOMATED OPERATIONSX\n                FACILITY TABLE- FUNCTION DEACTIVATED',DESC=(1),MF=L\n*\nWTO22D   WTO   'TSSC117I TSSO MAXIMUM COMMANDS SET AT XX',      EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\n*\nWTO23D   WTO   'TSST014I TSSO SUBSYSTEM SUPPORT MODULE IS XXXXXXXX',   X\n               MF=L\n*\nWTO24D   WTO   'TSSC114I TSSO DEFAULT SECURITY ID IS XXXXXXXX', EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\n*\nWTOR25D  WTOR  'TSSI001A ENTER PARMLIB MEMBER FOR TSSO PARAMETERS',MF=L\n*\nWTOR26D  WTOR  'TSSI012A ENTER TSSO PARAMETERS (OR \"END\")',MF=L\n*\nWTO27D   WTO   'TSSC112I T S S O  VERSION 4.3.0 --> DATE: &SYSDATE, TIMX\n               E: &SYSTIME',CONSID=,MF=L                        EEJ1102\n*\nWTO28D   WTO   'TSSC113I XXXXXXXXXXXXX -----------> DATE: XXXXXXXX, TIMX\n               E: XXXXXXXX',CONSID=,MF=L                        EEJ1102\n*\nWTO32D   WTO   'TSSC125S TABLE XXXXXXXX IS AT AN INCORRECT LEVEL- REASSX\n               EMBLE',DESC=1,MF=L\n*\n*\nWTO36D   WTO   'TSSC118I TSSO WILL OUTPUT A MAXIMUM OF XXXX WTO\"S PER CX\n               OMMAND',CONSID=,MF=L                             EEJ1102\n*\nWTO38D   WTO   'TSSC123I TABLE ID: XXXXXXXX, DATE: XXXXXXXX, TIME: XXXXX\n               XXXX',CONSID=,MF=L                               EEJ1102\n*\nWTO39D   WTO   'TSST054A AN ERROR HAS OCCURED LOADING MODULE XXXXXXXX- X\n               TSSO IS TERMINATING',DESC=(1),MF=L\n*\nWTO48D   WTO   'TSSC119I SUBSYSTEM CONSOLE XX,                         X\n                         ',CONSID=,MF=L                         EEJ1102\n*\nWTO49D   WTO   'TSSC140I XX SUBSYSTEM CONSOLES REQUESTED, XX ALLOCATED'X\n               ,CONSID=,MF=L                                    EEJ1102\n*\n         DS    0D\nIEFPRM01 DS    200F\nDATDLEN  EQU   *-DATD              Length of data area          EEJ1102\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSODOCM": {"ttr": 36869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x12\\x00\\x98\\x06\\x8f\\x01\\x022\\x1f 0\\x01y\\x01q\\x00\"\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1998-03-09T00:00:00", "modifydate": "2002-11-17T20:30:12", "lines": 377, "newlines": 369, "modlines": 34, "user": "EDJXADM"}, "text": "         TITLE 'T S S O    T S O   C O M M A N D   P R O C E S S O R'\n&WTOR    SETC  'YES'                   INCLUDE SUPPORT FOR WTOR REPLY\nTSSODOCM CSECT\n***********************************************************************\n* THIS MODULE WILL PROCESS TSO COMMANDS. IT OBTAINS THE TSO COMMAND   *\n* TO BE PROCESSED BY LOOKING THE THE TSSODATD DATA AREA, AND          *\n* OBTAINING THE COMMAND BUFFER. IT THEN ATTACHES THE DEFAULT          *\n* IBM TERMINAL MONITOR PROGRAM (IKJEFT01) WHICH ACTUALLY PROCESSES    *\n* THE COMMAND. CONTROL IS RETURNED AFTER THE ATTACH, AND THE RETURN   *\n* CODE INTERROGATED. IF NEEDED, A MESSAGE DISPLAYING THE RETURN CODE  *\n* IS ISSUED.                                                          *\n*                                                                     *\n* NOTE THAT KEY ZERO IS REQUIRED TO ATTACH THE TMP (APF AUTH)         *\n*                                                                     *\n* THE TSSODOCM MODULE IS ALSO RESPONSABLE FOR SECURITY OF TSSO COMMAND*\n* ATTACHED BY THE TMP. IF SECURITY LEVEL IS MEDIAL OR MAXIMAL, THIS   *\n* MODULE WILL VERIFY THAT THE USER IS LOGGED ON TO TSSO. IF NOT, THE  *\n* COMMAND IS REJECTED.                                                *\n*                                                                     *\n* IF THE USER IS LOGGED ON, THIS MODULE WILL COPY THE ACEE CREATED    *\n* BY THE USER INTO THE ASXBSENV FIELD, ATTACH THE TMP, AND THEN       *\n* RESTORE THAT FIELD.                                                 *\n*                                                                     *\n*                                                                     *\n* TSSO 4.3 WILL ALLOW A NOT-LOGGED ON CONSOLE TO ISSUE THE COMMAND    *\n* WITH THE DEFAULT TSSO AUTHORITY IF ONE OF THE FOLLOWING ARE TRUE    *\n*                                                                     *\n* 1) THE CONSOLE IS CONSOLE 0.  (USED BY JES2)                        *\n* 2) THE CONSOLE IS A SUBSYSTEM CONSOLE WITH SYSTEM AUTHORITY.        *\n* 3) THE SECURITY LEVEL IS SET AT \"MINIMAL\"                           *\n*                                                                     *\n***********************************************************************\n* NOTE THAT MESSAGE PRODUCED BY THIS MODULE HAVE THE FORM TSSMXXXS    *\n* WHERE XXX IS BETWEEN 451 AND 500.                                   *\n* LAST MESSAGE NUMBER: 456\n***********************************************************************\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ  Support MCS extended consoles                *EEJ1102\n*                                                              *EEJ1102\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSODOCM,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n         GETMAIN R,LV=1024\n         LR    R11,R1\n         USING DOCMDATD,R11\n         L     R9,0(R8)           GET ADDRESSABLE TO DATD.\n         USING DATD,R9\n         GETCVT (R10)\n         USING TSSOCVT,R10        NOTE: CVT DOES NOT EXIST YET...\n***********************************************************************\n* ACCESS TO THE SECARRAY VARIABLE IS OBTAINED THROUGH THE CVT, BUT IF *\n* DOCM IS CALLED VIA INITIALIZATION, THE CVT DOES NOT AS OF YET EXIST.*\n* THEREFORE, THE ADDRESS OF DATD MUST BE PASSED AS A PARAMETER...     *\n***********************************************************************\n         MVC   CMWTO1D(CMWTO1CE-CMWTO1C),CMWTO1C\n         MVC   CMWTO2D(CMWTO2CE-CMWTO2C),CMWTO2C\n         MVC   WTO29D(WTO29CE-WTO29C),WTO29C\n         XC    SWAPFLAG(4),SWAPFLAG\n************************************************************\n*                                                          *\n* ISSUE A TSO COMMAND BY ATTACHING THE TMP. COMMAND MUST   *\n* PREVIOUSLY HAVE BEEN PLACED IN FIELD \"TSOCMD\" WITH LENGTH*\n* IN FIELD TSOCMDL                                         *\n************************************************************\nISSUECMD DS    0H\n***********************************************************************\n* FIRST, WE WILL PERFORM THE SECURITY CHECKS MENTIONED ABOVE          *\n*                                                                     *\n***********************************************************************\n         TM    TSSOPFLG,X'80'           AUTHORTY CHECKING TURNED OFF?\n         BO    CMDOK                   YES, ALLOW COMMAND\n         CLC   SECLEVEL(4),=CL4'MINI'   MINIMAL SECURITY ?\n         BE    CMDOK                   YES, ALLOW COMMAND\n         CLC   CURRCONS(4),=XL4'0000'   IS THIS CONSOLE ZERO ?\n         BE    CMDOK                    ALLOW CONSOLE ZERO.\n***********************************************************************\n* CHECK FOR SUBSYSTEM ALLOCATABLE CONSOLE WITH AT LEAST SYSTEM        *\n* AUTHORITY.                                                          *\n***********************************************************************\n         L     R2,16             CVT\n         USING CVT,R2\n         L     R2,CVTCUCB        GET UCM BASE\n         USING UCM,R2\n         LM    R3,R5,UCMVEA      GET FIRST, LENGTH AND LAST UCME'S\n         DROP  R2\n         USING UCMLIST,R3\nUCMSLOOP DS    0H\n         L     R14,UCMFEXTP        UCME fixed extension         EEJ1102\n         USING UCMEFEXT,R14    *** Synchronize UCMEFEXT         EEJ1102\n         CLC   CURRCONS,UCMEFCN    Matching console ?           EEJ1102\n         BE    UCMFOUND            Branch if yes                EEJ1102\n         DROP  R14             *** Drop UCMEFEXT                EEJ1102\n         BXLE  R3,R4,UCMSLOOP\n         B     CHKTAUTH            Branch if no UCM found       EEJ1102\n*\nUCMFOUND DS    0H\n         TM    UCMDISP2,UCMDISPL     SUBSYSTEM ALLOCATABLE CONSOLE ?\n         BO    CHKCAUTH\n         B     CHKTAUTH              NOT A SS CONSOLE - CHECK USER AUTH\n*\nCHKCAUTH DS    0H\n         TM    UCMAUTHA,X'80'        SYSTEM AUTHORITY FOR CONSOLE ?\n         BO    CMDOK                 YUP - ALLOW ANYTHING.\n*\n         WTO   CONSID=CURRCONS,    Insufficient authority       EEJ1102+\n               MF=(E,CMWTO2D)      (Msg 456)                    EEJ1102\n*\n         MVC   RETCODE(2),=H'8'      INDICATE COMMAND NOT ISSUED.\n         B     ENDPROG\n         DROP  R3\nCHKTAUTH DS    0H\n***********************************************************************\n* IF WE GET HERE, THE CONSOLE IS NOT A SS CONSOLE, THEREFORE IT MUST  *\n* BE A REAL ONE. CHECK IF THE CONSOLE IS LOGGED ON.                   *\n***********************************************************************\n         L     R8,SECARRAY        GET SECURITY ARRAY\n         LTR   R8,R8\n         BZ    DOCMLERR           LOGICAL ERROR IN DOCM\n         LA    R3,20              MAXIMUM ENTRIES IN TABLE\nDOCMLOOP DS    0H\n         USING SECENTRY,R8\n         TM    SECFLAGS,X'80'     ENTRY IN USE ?\n         BNO   NEXTENTR\n         CLC   SECRCNID,CURRCONS   Matching console ?           EEJ1102\n         BE    FNDCONS             Branch if yes                EEJ1102\n*\nNEXTENTR DS    0H\n         LA    R8,SECRLGNT(R8)    TRY NEXT ENTRY\n         BCT   R3,DOCMLOOP\n*\n***********************************************************************\n* IF WE COME HERE, WE HAVE DETERMINED THAT THE CONSOLE IS NOT LOGGED  *\n* ON TO TSSO...                                                       *\n***********************************************************************\n         MVC   CMWTO1D+40(8),CURRCNAM Copy console name         EEJ1102\n         WTO   MF=(E,CMWTO1D)\n         MVC   RETCODE(2),=H'8'      INDICATE CONSOLE NOT LOGGED ON\n         B     ENDPROG\n*\n*\nFNDCONS  DS    0H\n***********************************************************************\n* HERE, WE HAVE FOUND THE CORRECT CONSOLE ENTRY. WE WILL NOW PERFORM  *\n* THE SECURITY SYSTEM DEPENDENT CODE TO MAKE MVS THINK THAT TSSO IS   *\n* THE USER ASSOCICATED WITH THAT SECURITY ENTRY                       *\n***********************************************************************\n         CLC   SECSYS(4),=CL4'RACF'   ARE WE USING RACF ?\n         BE    SECRACF\n         CLC   SECSYS(4),=CL4'ACF2'   ARE WE USING ACF2 ?\n         BE    SECACF2\n         CLC   SECSYS(4),=CL4'TOPS'   ARE WE USING TOP SECRET ?\n         BE    SECTOPS\n         B     DOCMLERR               LOGICAL ERROR (SIGH)\nSECRACF  DS    0H\n***********************************************************************\n* THE RACF PIECE OF THE PUZZLE IS RELATIVELY CLEAN. SIMPLY SWAP       *\n* THE ACEE POINTERS, THEN SWAP THEM BACK WHEN TMP TERMINATES.         *\n***********************************************************************\n         L     R2,TSSOASXB        GET THE ASXB POINTER\n         USING ASXB,R2\n         L     R3,SECACEE         PICK UP THE ACEE IN QUESTION\n         LTR   R3,R3              JUST TO MAKE SURE\n         BZ    DOCMLERR           LOGICAL ERROR HERE...\n         MODESET KEY=ZERO         KEY ZERO REQUIRED...\n         ST    R3,ASXBSENV        CONSIDER THE ACEE SWAPPED...\n         MVC   ASXBUSER(7),SECUSER   AND COPY THE ASXBUSER ID.\n         MODESET KEY=NZERO        KEY ZERO REQUIRED...\n         OI    SWAPFLAG,X'80'     INDICATE A SWAP TOOK PLACE.\n         B     CMDOK              NOW... GO DO THE COMMAND\nSECACF2  DS    0H\n***********************************************************************\n* CODE FOR ACF2 SUPPORT IS REQUIRED HERE...                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         WTO   'TSSMACF2 ACF2 SUPPORT IS NOT IN THIS COPY OF TSSO'\n         B     DOCMLERR           PROBABLY, A LOGICAL ERROR.\nSECTOPS  DS    0H\n***********************************************************************\n* CODE FOR TOP SECRET SUPPORT IS REQUIRED HERE.                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n        WTO   'TSSMTOPS TOP SECRET SUPPORT IS NOT IN THIS COPY OF TSSO'\n         B     DOCMLERR           PROBABLY, A LOGICAL ERROR.\n         DROP  R8                 SECENTRY\n*\nCMDOK    DS    0H\n         MODESET KEY=ZERO\n         LA    R1,TSSOPRMP        POINTER TO IKJEFT01 PARM LIST\n         OI    0(R1),X'80'        SOMETIMES THEY HAVE SUCH SILLY RULES\n         LA    R2,TSSOPRMS        GET ADDRESS OF PARMS\n         ST    R2,TSSOPRMP\n         XC    TSSOPECB(4),TSSOPECB  WIPE OUT THE ECB\n         LA    R6,TMPNAME         HOPE THIS POINTS TO A TMP.\n         LA    R7,TSSOPECB        GET REAL ECB\n*\n         ATTACH EPLOC=(R6),ECB=(R7),SZERO=NO,JSTCB=YES,                X\n               SF=(E,ATTACHD)     (PTF1)\n         ST    R1,TSSOPTCB        SAVE TCB ADDRESS\n*\n         WAIT  ECB=TSSOPECB       WAIT FOR TSO TO FINISH\n*\n         L     R7,540              PSATOLD-PSA\n         USING TCB,R7\n         L     R7,TCBJSCB          GET JSCB FIELD\n         USING IEZJSCB,R7\n         L     R7,JSCBACT          MAKE SURE ITS ACTIVE JSCB\n         OI    236(R7),X'01'       SET IT BACK ON\n***********************************************************************\n* THE ABOVE LINE IS NEEDED BECAUSE TSO HAS THIS ANNOYING TENDENCY TO  *\n* DE AUTHORIZE THAT WHICH CALLS IT... WE NEED AUTHORIZATION...        *\n***********************************************************************\n         DROP  R7\n*\n         L     R1,TSSOPECB           FINE- DETACH IKJEFT01\n         C     R1,=X'40000000'       IS EVERYTHING OK WITH TMP ?\n         BNE   TMPABEND              RATS !!\n         B     ISSUERET\nTMPABEND DS    0H\n         ST    R10,SAVER10\n         LA    R10,DATD\n         CALL  JCECVTBH\n         L     R10,SAVER10\n         STM   R0,R1,WTO29D+44        GET READY TO PRINT MESSAGE\n         WTO   CONSID=CURRCONS,MF=(E,WTO29D)                    EEJ1102\n         B     ISSUERET\nISSUERET DS    0H\n         LA    R1,TSSOPTCB\n         DETACH (R1)\n         MODESET KEY=NZERO\n         XC    RETCODE(2),RETCODE   CLEAR RETURN CODE\nEXIT0    DS    0H\n***********************************************************************\n* NOW, WE MUST SWAP THE ACEE POINTERS BACK...                         *\n*                                                                     *\n***********************************************************************\n         TM    SWAPFLAG,X'80'       DID A SECURITY ID SWAP OCCUR ?\n         BNO   ENDPROG              DONT BOTHER RESETTING AUTH.\n*\n         CLC   SECSYS(4),=CL4'RACF'   RACF SYSTEM ?\n         BE    RESTRACF                 YEA !!\n         CLC   SECSYS(4),=CL4'ACF2'   ACF2 SYSTEM...\n         BE    RESTACF2                 OH WELL...\n         CLC   SECSYS(4),=CL4'TOPS'   AINT COMPETITON WONDERFULL.\n         BE    RESTTOPS                 YEA !!\n         B     DOCMLERR\nRESTRACF DS    0H\n         L     R2,TSSOASXB\n         USING ASXB,R2\n         L     R3,TSSOACEE         GET TSSO'S ACEE.\n         MODESET KEY=ZERO\n         ST    R3,ASXBSENV\n         MVC   ASXBUSER(7),TSSORACF+1       RESTORE THE ORIGINAL ID.\n         DROP  R2\n         MODESET KEY=NZERO\n         B     ENDPROG\nRESTTOPS DS    0H\n***********************************************************************\n* TOP SECRET CODE FOR SWAPPING POINTERS GOES HERE...                  *\n*                                                                     *\n***********************************************************************\nRESTACF2 DS    0H\n***********************************************************************\n* ACF2 CODE FOR SWAPPING POINTERS BACK GOES HERE...                   *\n*                                                                     *\n***********************************************************************\n         B     ENDPROG\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=1024,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              COPY RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\nDOCMLERR DS    0H\n         WTO   'TSSM452S LOGICAL ERROR PROCESSING TSO COMMAND',DESC=1\n         MVC   RETCODE(2),=H'8'        MOVE IN RETURN CODE\n         B     ENDPROG\n         EJECT\n***********************************************************************\n* TSSODOCM ONLY DATA CONSTANTS.\n***********************************************************************\nCMWTO1C  WTO   'TSSM453E COMMAND REJECTED - CONSOLE XXXXXXXX NOT LOGGEDX\n                ON TO TSSO',MF=L\nCMWTO1CE EQU   *\n*\nCMWTO2C  WTO   'TSSM456E INSUFFUCIENT AUTHORITY TO ISSUE TSSO COMMANDS X\n               THROUGH OSCMD INTERFACE',CONSID=,MF=L            EEJ1102\nCMWTO2CE DS    0H                                               EEJ1102\n*                                                               EEJ1102\nWTO29C   WTO   'TSSM451A TSO COMMAND RETURN CODE WAS -->XXXXXXXX',     X\n               CONSID=,MF=L                                     EEJ1102\nWTO29CE  DS    0H\n*\n*\nDOCMDATD DSECT\n************************************************************\n* TSSO ONLY DSECT- NOT SHARED WITH OTHER MODULES.          *\n************************************************************\nCMWTO1D  WTO   'TSSM453E COMMAND REJECTED - CONSOLE XXXXXXXX NOT LOGGEDX\n                ON TO TSSO',MF=L\n*\nCMWTO2D  WTO   'TSSM456E INSUFFUCIENT AUTHORITY TO ISSUE TSSO COMMANDS X\n               THROUGH OSCMD INTERFACE',CONSID=,MF=L            EEJ1102\n*                                                               EEJ1102\nWTO29D   WTO   'TSSM451A TSO COMMAND RETURN CODE WAS -->XXXXXXXX',     X\n               CONSID=,MF=L                                     EEJ1102\n*\nSAVER10  DS    F\nRETCODE  DS    H                  RETURN CODE FROM TSSODOCM\nSWAPFLAG DS    XL4\n* BYTE 1\n* X'80' - SECURITY ID WAS SWAPPED\n***********************************************************************\n* END OF TSSODOCM ONLY VARIABLES.                                     *\n***********************************************************************\n*\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO MAINLINE SHARED VARIABLES.           *\n***********************************************************************\n         COPY  TSSODATD\n         TSSOCVT\n         TSSOCMND          DSECT FOR TSSO COMMAND RING\n         TSSOSECR\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IEZJSCB\n         IKJTCB\n         IHAASXB\n         IEFJSCVT\n         IEFJESCT\nUCM      DSECT\n         IEECUCM\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSODOCM(''V 4.3.0 (PTF1) &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSODOCM'\n PUNCH ' NAME     TSSODOCM(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOESTA": {"ttr": 36876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x022\\x1f\\x01\\x022\\x1f\\x14B\\x00\\x8a\\x00\\x8a\\x00\\x00\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T14:42:36", "lines": 138, "newlines": 138, "modlines": 0, "user": "EDJXADM"}, "text": "TSSOESTA CSECT\n         EQUATES\n**********************************************************************\n* THIS MODULE IS THE ESTAE ROUTINE FOR TSSO. ITS PURPOSE IS TO GAIN\n* CONTROL OF TSSO AFTER A FAILURE, AND PERFORM THE FOLLOWING FUNCTIONS\n*\n* 1) DISCONNECT THE SUBSYSTEM FROM MVS.\n* 2) FREEMAIN THE TSSO COMMAND RING\n* 3) FREEMAIN THE TSSO SSVT\n* 4) DELETE THE TSSO AUTOMATED OPERATOR PROCEDURE TABLE\n* 5) DELETE THE TSSO SUBSYSTEM SUPPORT MODULE.\n* 6) DECREMENT THE COUNT OF SUBSYSTEMS REQUESTING WTO BROADCASTS\n* 7) RETURN THE JOB ID TO JES.\n*\n* IT ACCOMPLISHES THE ABOVE ITEMS BY LINKING TO THE TSSOTERM MODULE\n*\n* NOTE. IN TSSO 4.3, THE ESTAE FUNCTION NOW CHECKS TO SEE IF IT IS THE\n* ACTIVE TSSO. IF IT IS, IT PROCEEDS WITH TERMINATION. IF NOT, IT\n* MEARLY ALLOWS THE TERMINATION TO CONTINUE.\n*\n*\n* LAST MESSAGE: 403\n\n\n*        +---------+\n*        + CHANGES +\n*        +---------+\n*  30 DEC 96  RPS FIXED ADDRESSABILITY ERROR WITH HLASM\n*                                                               EEJ1102\n*  NOV 2002   EEJ Removed extraneous PUSH USING added by RPS    EEJ1102\n*                                                               EEJ1102\n\n***********************************************************************\n* NOTE: MESSAGES PRODUCED BY THE ESTAE MODULE HAVE MESSAGE ID'S IN THE*\n* FORM TSSEXXXA WHERE 401 < XXX < 450                                 *\n***********************************************************************\n**********************************************************************\n*\n* IT DOESNT MUCH MATTER WHETHER WE HAVE AN SDWA OR NOT, BECAUSE WE\n* CAN ACCESS TSSO PROGRAM VARIABLES FROM THE TSSO CVT.\n         USING TSSOESTA,R15\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         XR    R9,R9            R9 = 0\n         LR    R7,R14           SAVE RETURN POINT\n         CH    R0,=H'12'\n         BE    NOSDWA\n         LR    R9,R1            SAVE ADDRESS OF THE SDWA.\nNOSDWA   DS    0H\n***********************************************************************\n* R9 = 0 -> ESTAE WAS ENTERED WITHOUT SDWA                            *\n* R9 \u00ac= 0 -> R9 HAS ADDRESS OF THE SDWA                               *\n***********************************************************************\n         DROP  R15                                               RPS\n         LR    R12,R15\n         USING TSSOESTA,R12\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         TESTAUTH FCTN=1       (PTF2) INCLUSIVE THROUGH ESTAEX LABEL\n         LTR   R15,R15\n         BZ    ESTAEX\n         WTO   'TSSE403E TSSO HAS BEEN DEAUTHORIZED - TSSO WILL ATTEMPTX\n                TO REGAIN AUTHORIZATION'\nNEEDAUTH DS    0H\n         GETCVT (R6),NDSA=YES    GET THE NDSA\n         USING TSSONDSA,R6\n         L     R2,TSSOLX        GET TSSO LINKAGE INDEX\n         DROP  R6\n         O     R2,=X'00000001'  OBTAIN PC SERVICE NUMBER\n         STM   R14,R12,12(R13)   REMEMBER REGS\n         L     R15,=CL4'TAPF'   WHATEVER\n         LA    R0,20            WHAT EVER\n         PC    0(R2)            GET AUTHORIZED\n         LM    R14,R12,12(R13)    (PTF2 END)\nESTAEX   DS    0H\n         L     R6,X'224'           GET ASCB ADDRESS\n         USING ASCB,R6\n         LH    R6,ASCBASID         GET ASID FIELD\n         DROP  R6\n         GETCVT (R2),NDSA=YES\n         USING TSSONDSA,R2\n         CH    R6,TSSOASID         IS THIS THE ACTIVE TSSO ?\n         BE    ACTTSSO             YES, PROCEED WITH TERMINATION\n*\n         DROP  R2\n         WTO   'TSSE402I TSSO ESTAE IS IN CONTROL FOR INACTIVE TSSO'\n         B     IACTTSSO\n*\nACTTSSO  DS    0H\n         WTO   'TSSE401I TSSO ESTAE IS IN CONTROL'\n**********************************************************************\n* AT THIS POINT, THE ESTAE ROUTINE IS READY TO GO...\n* WE WILL LINK TO THE TERMINATION ROUTINE FOR TSSO, TO DISCONNECT THE\n* SUBSYSTEM, FREEMAIN ALL AREAS, ETC...\n**********************************************************************\n         MODESET KEY=ZERO\n         OI    TSSOFLG1,TSSOGONE     IMMEDIATELY DISCONTINUE...\n         MODESET KEY=NZERO\n         LINK  EP=TSSOTERM\n**********************************************************************\n* HERE, WE ARE READY TO RETURN TO MVS. NO RETRY WILL BE ATTEMPTED.\n*\n**********************************************************************\nIACTTSSO DS    0H\n         LTR   R9,R9                 DID WE GET AN SDWA\n         BNZ   TERMSDWA              YES, TERMINATE WITH SDWA\n* TERMINATE WITHOUT SDWA\n*\n         XR    R15,R15\n         BR    R7                    GO AWAY\n*\nTERMSDWA DS    0H\n         SETRP WKAREA=(R9),DUMP=YES,RC=0\n**********************************************************************\n* LASTLY, WE ARE FINALLY READY TO FREEMAIN THE TSSO CVT.\n**********************************************************************\n*\n         WTO   'TSSE402E T S S O IS SADLY TERMINATING DUE TO AN'\n         WTO   '         UNEXPECTED ABEND. NOTIFY THE TSSO SYSTEM     '\n         WTO   '         PROGRAMMER OF THE ABEND CODE AND RESTART TSSO'\n         WTO   '         WITH THE  \"S TSSO,SUB=JES2\" COMMAND'\n         BR    R7                     GO AWAY...\n         PRINT NOGEN\n         IHASDWA\n         TSSOCVT\n         IEFJSCVT\n         IEFJESCT\n         IHAASCB\n         TSSONDSA\n         CVT  DSECT=YES\n         PRINT GEN\n         END  TSSOESTA\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOESTA(''TSSO V 4.3.0 (PTF2) &SYSDATE &SYSTIME'')'\n PUNCH ' ENTRY    TSSOESTA'\n PUNCH ' NAME     TSSOESTA(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOGAPF": {"ttr": 37123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00d\\x00d\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "TSSO403"}, "text": "         TITLE ' T S S O    GET AUTHORIZATION MODULE'\n***********************************************************************\n* THIS ROUTINE WILL BE CALLED BY VARIOUS CALLERS OF THE TSSOPCMD      *\n* ROUTINE. ITS PURPOSE IS TO GRANT APF AUTHORIZATION. IT IS DESIGNED  *\n* AS A PC ROUTINE. TSSOGAPF WILL CHECK A PASSWORD IN REGISTER 15      *\n* TO INSURE THE ONLY AUTHORIZED CALLERS USE THE FACILITY. THE PASSWORD*\n* IS PASSED AS A PARAMETER IN REGISTER 15. AS A CONVIENANCE,          *\n* THIS PROGRAM CAN ALSO BE USED TO DEAUTHORIZE A PROGRAM, SO THE      *\n* PROGRAM DOESNT NEED TO DO IT ITSELF. THIS ROUTINE USE A PARAMETER   *\n* PASSED IN R0 TO DETERMINE WHETHER TO AUTHORIZE OR DEAUTHORIZE.      *\n***********************************************************************\n***********************************************************************\nTSSOGAPF CSECT\n         PCLINK STACK,SAVE=NO      SAVE CALLERS REGSITERS\n         LR     R10,R14\n         BALR   R12,0\n         USING  *,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R9,R15               COPY PARM REGISTER\n         LR     R8,R0                COPY OTHER PARM REGISTER\n*\n         GETCVT (R7)                OBTAIN TSSO CVT\n         USING  TSSOCVT,R7\n         LTR    R7,R7\n         BZ     ENDPROG              DONT RUN ROUTINE WITHOUT TSSO\n         TM     TSSOFLG1,TSSOGONE\n         BO     ENDPROG              OR IF TSSO FLAGGED AS GONE\n         TM     TSSOFLG2,TSSOMON     IS DEBUGGING ACTIVATED ?\n         BNO    NODEBUG\n         WTO    'TSSAPF01 TSSOGAPF ROUTINE IS IN CONTROL'\nNODEBUG  DS     0H\n         DROP   R7\n         C      R9,=CL4'TAPF'    PROPER PASSWORD ?\n         BNE    ENDPROG\n         LTR    R8,R8\n         BZ     DEAUTH\n         CH     R8,=H'20'\n         BE     AUTH\n         B      ENDPROG\n*\nAUTH     DS     0H\n         L      R2,X'21C'\n         USING  TCB,R2\n         L      R2,TCBJSCB\n         USING IEZJSCB,R2\n         MODESET KEY=ZERO\n         OI    JSCBOPTS,JSCBAUTH\n         MODESET KEY=NZERO\n         DROP  R2\n         B     ENDPROG\n*\nDEAUTH   DS     0H\n         L      R2,X'21C'\n         USING  TCB,R2\n         L      R2,TCBJSCB\n         USING IEZJSCB,R2\n         MODESET KEY=ZERO\n         NI    JSCBOPTS,255-JSCBAUTH\n         MODESET KEY=NZERO\n         DROP  R2\n         B     ENDPROG\n*\nENDPROG  DS    0H\n*\nENDPROG1 DS    0H\n         LR    R14,R10             RELOAD RETURN POINT\n         PCLINK UNSTACK,THRU=(14),SAVE=NO\n         PT    R3,R14\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         IKJTCB\n         IEZJSCB\n         TSSOCVT\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         END   TSSOGAPF\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOGAPF(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOGAPF'\n PUNCH ' NAME     TSSOGAPF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOGSSC": {"ttr": 37126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x00\\x97&\\x9f\\x01\\x07\\x07\\x0f\\x06\\x19\\x00\\xd5\\x00\\xd1\\x00\\x08\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2007-03-11T06:19:09", "lines": 213, "newlines": 209, "modlines": 8, "user": "SBGOLOB"}, "text": "         TITLE ' T S S O  SUBSYSTEM CONSOLE SERVICES'\nTSSOGSSC CSECT\n         EQUATES\n***********************************************************************\n* THIS MODULE WILL PERFORM THE TSSO SUBSYSTEM CONSOLE SERVICES        *\n* REQUIRED FOR THE OSCMD COMMAND. THE TWO SERVICES WILL BE: GET A     *\n* SUBSYSTEM CONSOLE, AND RELEASE A SUBSYSTEM CONSOLE.                 *\n*\n***********************************************************************\n* THIS ROUTINE PERFORMS ITS MAGIC BY ISSUING REQUEST CALLS TO MVS     *\n* MODULE IEAVG700, WITH A PARAMETER LIST MAPPED BY IEZVG100. THIS     *\n* ROUTINE WILL FILL OUT THAT PARAMETER LIST, AND CALL IEAVG700, THUS  *\n* OBTAINING A SUBSYSTEM CONSOLE ID.                                   *\n***********************************************************************\n***********************************************************************\n* NOTE: ALL MESSAGES PRODUCED WILL BE IN THE FORM TSSGNNNS WHERE      *\n* 151 < NNN < 200                                                     *\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOGSSC,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R7,R0              GET TO THE ENTRY CODE.\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETCVT (R10)             OBTAIN TSSO CVT\n         USING TSSOCVT,R10\n         L     R9,TSSODSEC        GET TSSO'S DSECT\n         USING DATD,R9\n***********************************************************************\n* INITIALIZE TSSOGSSC DSECT VARIABLES\n***********************************************************************\n         CH    R7,=H'0'            ENTERED TO OBTAIN A CONSOLE ?\n         BE    GETSSCON            YUP, GET A SUBSYSTEM CONSOLE\n         CH    R7,=H'4'            ENTERED TO DELETE THE CONSOLE ?\n         BE    DELSSCON            YUP !\n         WTO   'TSSG151S INVALID ENTRY TO CONSOLE SERVICES',DESC=(1)\n         B     ENDPROG\nGETSSCON DS    0H\n***********************************************************************\n* HERE, WE HAVE A REQUEST TO OBTAIN A SUBSYSTEM CONSOLE. WE WILL      *\n* FORMAT THE IEZVG100 PARM LIST AND CALL IEAVG700.                    *\n***********************************************************************\n         LA    R2,SCSLEN\n         GETMAIN R,LV=256              GET SPACE FOR IEZVG100 PARM LIST\n         LR    R11,R1\n         USING SCSRPLST,R11\n         XC    0(256,R11),0(R11)       BLANK OUT THE STORAGE\n*\n         MVC   SCSACRO(4),=CL4'SCSR'    MOVE IN ACRONYM\n*\n         LA    R2,SCSVERSN              GET VERSION NUMBER\n         STC   R2,SCSVER                AND STORE AWAY\n*\n         OI    SCSFUNC1,SCSOBTAN        INDICATE A REQUEST TO GET A\n*                                       SUBSYSTEM CONSOLE\n*\n         OI    SCSFUNC2,SCSPMSTR        MAKE IT A PSEUDO-MASTER CONSOLE\n*\n         MVC   SCSNAME(8),=CL8'TSSO'    MAKE NICE DISPLAY CONSOLE CMD\n*\n         OI    SCSFLGS1,SCSTYPE1        TYPE \"1\" PROTOCAL- WE DONT KNOW\n*                                       WHAT TYPE 2 IS...\n         MVC   SCSPJESN(4),=CL4'JES2'   INDICATE PRIMARY SUBSYSTEM\n*\n         MODESET KEY=ZERO,MODE=SUP      GET POWERFULL\n         ST    R11,WORKAREA             PUT PARM LIST AWAY\n         LA    R1,WORKAREA              LOAD ADDRESS OF WHERE IT IS.\n         LINK  EP=IEAVG700              ** DO IT **\n         LTR   R15,R15\n         BZ    REQOK\n         CH    R15,=H'4'           NO CONSOLE AVAIALBLE\n         BE    REQNOTOK\n         WTO   'TSSG152S BAD RETURN CODE FROM IEAVG700- NO SUBSYSTEM COX\n               NSOLE ALLOCATED'\n         LA    R3,8\n         B     GETSSEXT\n*\nREQNOTOK DS    0H\n         LA    R3,8                   SET RETURN CODE.\n         B     GETSSEXT\n*\nREQOK    DS    0H\n*DRCICS* LH    R2,SCSCNID             GET CONSOLE ID         02/08/2007\n         L     R2,SCSCONID            GET CONSOLE ID         02/08/2007\n*DRCICS* STH   R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n         ST    R2,TSSCONID            PUT IN TSSO CVT.       02/08/2007\n*\n***********************************************************************\n* THE NEXT STEP AFTER OBTAINING THE SUBSYSTEM CONSOLE IS TO REMEMBER  *\n* IT'S UCMAUTH ADDRESS. THIS BYTE WILL BE CHANGED FOR MOST TSSO       *\n* COMMANDS ISSUED THROUGH THE OSCMD INTERFACE.                        *\n***********************************************************************\n         L     R6,16                  GET CVT\n         USING CVT,R6\n         L     R6,CVTCUCB             GET UCM PREFIX\n         USING UCM,R6\n         LM    R7,R9,UCMVEA           GET FIRST UCM, LENGTH,LAST UCM\n         DROP  R6\nUCMSLOOP DS    0H\n         USING UCMLIST,R7\n*DRCICS* CLC   UCMID(1),TSSCONID+1    COMPARE UCM IDS        02/08/2007\n         CLC   UCMID(1),TSSCONID+3    COMPARE UCM IDS        02/08/2007\n         BE    UCMFOUND               GOT IT...\n         BXLE  R7,R8,UCMSLOOP\n*\n         WTO   'TSSG154S UNABLE TO FIND UCM FOR TSSO SUBSYSTEM CONSOLE'X\n               ,DESC=1\n         B     REQNOTOK\n*\nUCMFOUND DS    0H\n         LA    R6,UCMAUTH\n         ST    R6,TSSOSCNA            STORE CONSOLE AUTH BYTE ADDRESS\n***********************************************************************\n* NOTE THAT THIS ADDRESS WILL BE USED TO ZAP THE SUBSYSTEM CONSOLE    *\n* AUTHORIZATION BYTE INTO APPROPRIATE VALUES FOR DIFFERENT CIRCUMSTANC*\n***********************************************************************\n         OI    TSSOFLG1,TSSOSCON      INDICATE WE HAVE A SUBSYSTEM\n*                                     CONSOLE\n         XR    R3,R3                  SET RETURN CODE 0\n         B     GETSSEXT\n*\nGETSSEXT DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         FREEMAIN R,LV=256,A=(R11)\n         B     ENDPROG\n*\n*\n*\nDELSSCON DS    0H\n***********************************************************************\n* HERE, WE HAVE A REQUEST TO DELETE THE SUBSYSTEM CONSOLE WE HAVE     *\n* PREVIOUSLY OBTAINED. WE WILL FORMAT THE PARM LIST AND CALL IEAVG700 *\n***********************************************************************\n         TM    TSSOFLG1,TSSOSCON       DID WE EVER GET A CONSOLE ?\n         BNO   ENDPROG                 NO, FORGET IT.\n*\n         MODESET KEY=ZERO\n         LA    R2,SCSLEN\n         GETMAIN R,LV=256              GET SPACE FOR IEZVG100 PARM LIST\n         LR    R11,R1\n         USING SCSRPLST,R11\n         XC    0(256,R11),0(R11)       BLANK OUT THE STORAGE\n*\n         MVC   SCSACRO(4),=CL4'SCSR'    MOVE IN ACRONYM\n*\n         LA    R2,SCSVERSN              GET VERSION NUMBER\n         STC   R2,SCSVER                AND STORE AWAY\n*\n         OI    SCSFUNC1,SCSRELSE        INDICATE A REQUEST TO RELEASE\n*                                       A SUBSYSTEM CONSOLE\n*\n*DRCICS* MVC   SCSCNID(2),TSSCONID    INDICATE THE CONSOLE TO02/08/2007\n         MVC   SCSCONID,TSSCONID      INDICATE CNSL TO RELEAS02/08/2007\n*\n         MVC   SCSNAME(8),=CL8'TSSO'    IT MUST MATCH, OR IEAVG700 WONT\n*                                       GIVE UP THE CONSOLE\n         MODESET MODE=SUP               GET POWERFULL\n*\n         ST    R11,WORKAREA\n         LA    R1,WORKAREA\n*\n         LINK  EP=IEAVG700              ** DO IT **\n*\n         LTR   R15,R15\n         BZ    DELOK\n         WTO   'TSSG155S ERROR RELEASING SUBSYSTEM CONSOLE -> PERHAPS TX\n               SSO SHOULD BE RESTARTED',DESC=(1)\n         B     DELSSEXT\n*\nDELOK    DS    0H\n         B     DELSSEXT\n*\nDELSSEXT DS    0H\n         MODESET MODE=PROB,KEY=NZERO\n         FREEMAIN R,LV=256,A=(R11)\n         B     ENDPROG\n*\nENDPROG  DS    0H\n*\n*\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R3              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n         COPY  TSSODATD\n         TSSOCVT\n         SSCONCBH\n         SSCONCB\n         IEZVG100\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSCVT\nUCM      DSECT\n         IEECUCM\n*\n         END   TSSOGSSC\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOGSSC(''TSSO 4.3  &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOGSSC'\n PUNCH ' NAME     TSSOGSSC(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOINIT": {"ttr": 37131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x966o\\x00\\x966o\\x10\\x05\\x00e\\x00e\\x00\\x00\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-31T00:00:00", "modifydate": "1996-12-31T10:05:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "RPS"}, "text": "TSSOINIT CSECT\n***********************************************************************\n* THIS IS THE INITIALIZATION PROGRAM FOR THE TSSO SUBSYSTEM.\n* THIS ROUTINE WILL GET CONTROL AT IPL TIME TO PERFORM THE FOLLOWING\n* FUNCTIONS:\n*\n* 1) GETMAIN THE TSSO NON DESTRUCTABLE SYSTEM AREA. THIS AREA IS\n*    GETMAINED AT IPL TIME, AND IT REMAINS THROUGHOUT THE DAY. THE\n*    CONTROL BLOCK MAPPING THIS AREA IS IN THE TSSONDSA DSECT. IT IS\n*    BASICALLY USED TO HOLD DATA THAT SHOULD NOT DISAPPEAR WHEN TSSO\n*    DOES, FOR EXAMPLE, THE NUMBER OF SYSTEM RESTARTS. THE TSSO LX\n*    NUMBER, ETC...\n*\n*\n*\n*\n*\n*\n*\n*\n*\n* THE ENTRY IN THE PARMLIB IEFSSNXX MEMBER FOR THE TSSO SUBSYSTEM\n* SHOULD LOOK LIKE THIS.\n*\n* TSSO,TSSOINIT\n***********************************************************************\n         EQUATES\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R9,R1              SAVE A COPY OF THE PARM LIST\n         LR     R12,R15            LOAD ENTRY POINT OF EXIT\n         USING  TSSOINIT,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         MODESET KEY=ZERO\n*\n         GETMAIN R,LV=1024\n         LR     R11,R1             COPY LOCAL STORAGE.\n         USING  INITDSEC,R11       AND ADDRESS IT.\n*\n***********************************************************************\n* STEP ONE IS TO GETMAIN THE AREA. NOTE THAT SUBPOOL 228 IS USED, AS  *\n* WE WANT READ ONLY ACCESS TO THIS AREA IN MEMORY.                    *\n***********************************************************************\n         GETMAIN R,LV=1024,SP=228\n         LR     R9,R1              R9 HAS ADDRESS OF THIS GLOBAL\n*                                  STORAGE.\n         GETCVT (R8),SSCT=YES      GET POINTER TO TSSO SSCT ENTRY.. RPS\n*                                  BE THERE YET...\n         USING SSCT,R8\n         L     R7,SSCTSUS2\n         LTR   R7,R7\n         BNZ   DUPINIT\n         ST    R9,SSCTSUS2         AND FILL IN THE SSCTSUS2 FIELD...\n         USING TSSONDSA,R9         ADDRESS IT.\n         XC    0(256,R9),0(R9)\n         XC    256(256,R9),256(R9) ZERO\n         XC    512(256,R9),512(R9)    OUT THE\n         XC    768(256,R9),768(R9)          STORAGE\n*\n         OI    SSCTFLG1,SSCTUPSS   USE JES2 FOR SYSOUT ETC...\n         DROP  R8\n         DROP  R9\n***********************************************************************\n* THE NEXT STEP IS TO DISPLAY THE PRETTY MESSAGE INIDICATING THAT     *\n* TSSO IS READY TO BE STARTED...                                      *\n***********************************************************************\n         WTO   'TSSI000I T S S O  IS WAITING FOR START COMMAND'\n         B     ENDPROG\nDUPINIT  DS    0H\n         WTO   'TSSI001I TSSOINIT HAS ALREADY BEEN RUN'\n         B     ENDPROG\nENDPROG  DS    0H\n         FREEMAIN R,LV=1024,A=(R11)\n         LR    R1,R13\n         L     R13,4(R13)\n         FREEMAIN R,LV=72,A=(R1)\n         LM    R14,R12,12(R13)     LOAD UP RETURN REGISTERS\n         XR    R15,R15\n         BR    R14\n         CVT   DSECT=YES\nINITDSEC DSECT\nFLAGS    DS    XL4\n* BYTE 1\n* X'80' - MODESET TO KEY ZERO WAS DONE.\n         IEFJSCVT\n         IEFJSIPL\n         IEFJESCT\n         TSSONDSA\n         END TSSOINIT\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINIT(''TSSO VERSION 4.3 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOINIT'\n PUNCH ' NAME     TSSOINIT(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOINI1": {"ttr": 37134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00X\\x01\\x022\\x1f\\x01\\x171\\x7f\\x15%\\x00\\xfc\\x01\\x03\\x00\\x0b\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2017-11-13T15:25:58", "lines": 252, "newlines": 259, "modlines": 11, "user": "JOARMC"}, "text": "         TITLE ' T S S O    I N I T I A L I Z A T I O N  ( 1 ) '\n***********************************************************************\n* THIS IS THE FIRST TSSO INTIALIZATION MODULE. IT PURPOSE IS TO FILL  *\n* UP THE TSSO DSECT, AND RETURN BACK TO THE TSSO MAINLINE ROUTINE. AS *\n* A RESULT OF THIS PROCESSING, ALL TSSO CONSTANTS THAT NEED TO BE     *\n* COPIED INTO THE TSSO DATA AREA ARE DEFINED AS CONSTANTS IN THIS     *\n* MODULE AND COPIED TO THE TSSO DATA AREA (TSSODATD)\n*                                                               EEJ1102\n****************************************************************EEJ1102\n*                                                               EEJ1102\n* Change Activity:                                              EEJ1102\n*                                                               EEJ1102\n*    NOV 2002 EEJ  Support MCS Extended Consoles                EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n*\n***********************************************************************\n* THE PURPOSE OF THIS MODULE IS TO ALLEVIATE THE STORAGE CONSTRAINTS  *\n* ON THE TSSO MAINLINE ROUTINE CAUSED BY THE CONSTANTS..              *\n*                                                                     *\n***********************************************************************\nTSSOINI1 CSECT\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         LR     R8,R1\n         USING  TSSOINI1,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n***********************************************************************\n* INITIALIZE THE DSECT VARIABLES, AND STORE THE ADDRESS INTO THE TSSO\n* COMMUNICATIONS VECTOR TABLE.\n***********************************************************************\n         L     R9,0(R8)            GET ADDRESS OF TSSO DSECT\n         USING DATD,R9\n         MVC   ESTAED(ESTAECE-ESTAEC),ESTAEC\n         MVC   ETDESD(ETDESCE-ETDESC),ETDESC\n         MVC   ATTACHD(ATTACHCE-ATTACHC),ATTACHC\n*        MVC   CLOSED(CLOSECE-CLOSEC),CLOSEC\n*        MVC   OPEND(OPENCE-OPENC),OPENC\n*        MVC   READD(READCE-READC),READC\n*        MVC   PARMDCBD(PARMDCBE-PARMDCBC),PARMDCBC  PARMLIB DCB\n         MVC   CALL1D(CALL1CE-CALL1C),CALL1C\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO4D(WTO4CE-WTO4C),WTO4C\n         MVC   WTO9D(WTO9CE-WTO9C),WTO9C\n         MVC   WTO10D(WTO10CE-WTO10C),WTO10C\n         MVC   WTO11D(WTO11CE-WTO11C),WTO11C\n         MVC   WTO14D(WTO14CE-WTO14C),WTO14C\n         MVC   WTO15D(WTO15CE-WTO15C),WTO15C\n         MVC   WTO16D(WTO16CE-WTO16C),WTO16C\n         MVC   WTO17D(WTO17CE-WTO17C),WTO17C\n         MVC   WTO18D(WTO18CE-WTO18C),WTO18C\n         MVC   WTO19D(WTO19CE-WTO19C),WTO19C\n         MVC   WTO20D(WTO20CE-WTO20C),WTO20C\n         MVC   WTO21D(WTO21CE-WTO21C),WTO21C\n         MVC   WTO22D(WTO22CE-WTO22C),WTO22C\n         MVC   WTO23D(WTO23CE-WTO23C),WTO23C\n         MVC   WTO24D(WTO24CE-WTO24C),WTO24C\n         MVC   WTOR25D(WTOR25CE-WTOR25C),WTOR25C\n         MVC   WTOR26D(WTOR26CE-WTOR26C),WTOR26C\n         MVC   WTO27D(WTO27CE-WTO27C),WTO27C\n         MVC   WTO28D(WTO28CE-WTO28C),WTO28C\n         MVC   WTO32D(WTO32CE-WTO32C),WTO32C\n         MVC   WTO36D(WTO36CE-WTO36C),WTO36C\n         MVC   WTO38D(WTO38CE-WTO38C),WTO38C\n         MVC   WTO39D(WTO39CE-WTO39C),WTO39C\n         MVC   WTO48D(WTO48CE-WTO48C),WTO48C\n         MVC   WTO49D(WTO49CE-WTO49C),WTO49C\n         MVC   PRIMSSIB(36),MASKSSIB\n         MVC   PARMMEM(8),=CL8' ' BLANK OUT PARMMEM\n         MVI   PARMFLAG,X'00'     ALL FLAGS OFF\n         B     ENDPROG\nEXIT0    DS   0H\nENDPROG  DS   0H\n         LR     R1,R13              GET ADDRESS OF CORE IN R1\n         L      R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         XR     R8,R8\n         B      ENDPROG1\nENDPROG1 DS     0H\n         L      R14,12(R13)         RELOAD RETURN POINT\n         LR     R15,R8              PICK UP RETURN CODE.\n         LM     R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR     R14\n*\n         EJECT\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nWTO1C    WTO   'TSSI065S SUBSYSTEM NAME NOT DEFINED- TSSO TERMINATING',X\n               DESC=(1),MF=L\nWTO1CE   DS    0H\n*\nWTO4C    WTO   'TSST060I  T S S O   VERSION 4.3.0 INITIALIZATION COMPLEX\n               TED',MF=L\nWTO4CE   DS    0H\n*\nWTO9C    WTO   'TSST052S TSSO COULD NOT LOAD ITS ESTAE MODULE (TSSOESTAX\n                AND IS TERMINATING',MF=L,DESC=(1)\nWTO9CE   DS    0H\n*\nWTO10C   WTO   'TSST061I TSSO IS WAITING FOR POST FROM SSSM',MF=L\nWTO10CE  DS    0H\n*\nWTO11C   WTO   'TSST062I TSSO HAS BEEN POSTED FROM SSSM',MF=L\nWTO11CE  DS    0H\n*\nWTO14C   WTO   'TSST064I TSSO DISCONNECTED- SUBSYSTEM UNAVAILABLE',MF=L\nWTO14CE  DS    0H\n*\nWTO15C   WTO   'TSSC122I TSSO IS USING TABLE XXXXXXXX FOR THE AUTOMATEDX\n                 OPERATIONS FACILITY',CONSID=,MF=L              EEJ1102\nWTO15CE  DS    0H\n*\nWTO16C   WTO   'TSSI007E PARMLIB PARAMETER \"XXXXXXXX\" IS INVALID',MF=L\nWTO16CE  DS    0H\n*\nWTO17C   WTO   'TSSI008E PARMLIB PARAMETER \"XXXXXXXX\" IS INCORRECTLY SPX\n               ECIFIED',MF=L\nWTO17CE  DS    0H\n*\nWTO18C   WTO   'TSSI010E MEMBER XXXXXXXX IS NOT IN PARMLIB- TSSO DEFAULX\n               TS USED',MF=L\nWTO18CE  DS    0H\n*\nWTO19C   WTO   'TSST055I TSSO IS USING TABLE NAME XXXXXXXX FOR THE AUTOX\n               MATED OPERATIONS FACILITY',CONSID=,MF=L          EEJ1102\nWTO19CE  DS    0H\n*\nWTO20C   WTO   'TSSC108S MODULE XXXXXXXX NOT FOUND, AUTOMATED OPERATIONX\n               S FACILITY DEACTIVATED',DESC=1,MF=L\nWTO20CE  DS    0H\n*\nWTO21C   WTO   'TSSC109S MODULE XXXXXXXX IS NOT AN AUTOMATED OPERATIONSX\n                FACILITY TABLE- FUNCTION DEACTIVATED',DESC=(1),MF=L\nWTO21CE  DS    0H\n*\nWTO22C   WTO   'TSSC117I TSSO MAXIMUM COMMANDS SET AT XX',      EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nWTO22CE  DS    0H\n*\nWTO23C   WTO   'TSST014I TSSO SUBSYSTEM SUPPORT MODULE IS XXXXXXXX',   X\n               MF=L\nWTO23CE  DS    0H\n*\nWTO24C   WTO   'TSSC114I TSSO DEFAULT SECURITY ID IS XXXXXXXX', EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nWTO24CE  DS    0H\n*\nWTOR25C  WTOR  'TSSI001A ENTER PARMLIB MEMBER FOR TSSO PARAMETERS',MF=L\nWTOR25CE DS    0H\n*\nWTOR26C  WTOR  'TSSI012A ENTER TSSO PARAMETERS (OR \"END\")',MF=L\nWTOR26CE DS    0H\n*\nWTO27C   WTO   'TSSC112I T S S O  VERSION 4.3.0 --> DATE: &SYSDATE, TIMX\n               E: &SYSTIME',CONSID=,MF=L                        EEJ1102\nWTO27CE  DS    0H\n*\nWTO28C   WTO   'TSSC113I XXXXXXXXXXXXX -----------> DATE: XXXXXXXX, TIMX\n               E: XXXXXXXX',CONSID=,MF=L                        EEJ1102\nWTO28CE  DS    0H\n*\nWTO32C   WTO   'TSSC125S TABLE XXXXXXXX IS AT AN INCORRECT LEVEL- REASSX\n               EMBLE',DESC=1,MF=L\n*\nWTO32CE  DS    0H\n*\nWTO36C   WTO   'TSSC118I TSSO WILL OUTPUT A MAXIMUM OF XXXX WTO\"S PER CX\n               OMMAND',CONSID=,MF=L                             EEJ1102\nWTO36CE  DS    0H\n*\nWTO38C   WTO   'TSSC123I TABLE ID: XXXXXXXX, DATE: XXXXXXXX, TIME: XXXXX\n               XXXX',CONSID=,MF=L                               EEJ1102\nWTO38CE  DS    0H\n*\nWTO39C   WTO   'TSST054A AN ERROR HAS OCCURED LOADING MODULE XXXXXXXX- X\n               TSSO IS TERMINATING',DESC=(1),MF=L\nWTO39CE  DS    0H\n*\nWTO48C   WTO   'TSSC119I SUBSYSTEM CONSOLE XX,                         X\n                         ',CONSID=,MF=L                         EEJ1102\nWTO48CE  DS    0H\n*\nWTO49C   WTO   'TSSC140I XX SUBSYSTEM CONSOLES REQUESTED, XX ALLOCATED'X\n               ,CONSID=,MF=L                                    EEJ1102\nWTO49CE  DS    0H\n*\nMASKSSIB DC    0F'0',C'SSIB',AL2(36,0),C'JES2',CL16' ',XL8'00'\n*\nESTAEC   ESTAE 0,MF=L\nESTAECE  EQU   *\n*\nETDESC   ETDES TOKEN=0,PURGE=YES,MF=L\nETDESCE  EQU   *\n*\nPARMDCBC DCB   DDNAME=PARMLIB,DSORG=PO,MACRF=R\nPARMDCBE DS    0H\n*\nREADC    READ  CECB,SF,MF=L\nREADCE   DS    0H\n*\nOPENC    OPEN  (,INPUT),MF=L\nOPENCE   DS    0H\n*\nCLOSEC   CLOSE  (,LEAVE),MF=L\nCLOSECE  DS    0H\n*\nATTACHC  ATTACH SF=L\nATTACHCE DS    0H\n*\n*\nCALL1C   CALL  ,(0,0,0),MF=L\nCALL1CE  DS    0H\n*\nDMYPW    DC    CL8'DUMMY'\nALPRMLIB DC    CL50'ALLOC FI(PARMLIB) DSN(''SYS1.PARMLIB'') SHR'\nFRPRMLIB DC    CL20'FREE FI(PARMLIB)'\n         COPY  TSSODATD\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI1(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOINI1'\n PUNCH ' NAME     TSSOINI1(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOINI2": {"ttr": 37381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x002\\x01\\x171\\x7f\\x01\\x172O\\x10\\x19\\x03F\\x03>\\x00\\x14\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2017-11-13T00:00:00", "modifydate": "2017-11-20T10:19:32", "lines": 838, "newlines": 830, "modlines": 20, "user": "JOARMC"}, "text": "         TITLE ' T S S O    I N I T I A L I Z A T I O N   (PART2)'\n***********************************************************************\nTSSOINI2 CSECT\n         GBLA  &READLEN\n&READLEN SETA  32768  - 32K BUFFER TO READ PARMLIB RECORDS\n***********************************************************************\n* THIS MODULE IS THE SECOND PART OF TSSO INITIALIZATION. IT'S PURPOSE *\n* IS TO PROCESS THE TSSO PARMLIB PARAMETERS. THESE PARAMETERS WILL    *\n* COME FROM THE SYS1.PARMLIB DATASET, WHICH IS DYNAMICALLY ALLOCATED  *\n* USING THE TSO ALLOCATE COMMAND. THIS MODULE WILL PROCESS THESE      *\n* PARAMETERS, AND STORE THE RESULTS INTO THE COMMON TSSO DATA AREA    *\n*                                                                     *\n* LAST MESSAGE NUMBER IN THE TSSI SEQUENCE IS TSSI019X                *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*    14DEC92  GLA  ADD MPF SUPPRESSION CONTROL STATMENT TO SUPPORT    *\n*                  ADDITION OF MPF SUPPRESSED MESSAGE ELIMINATION     *\n*                  FROM DAVE CARTWRIGHT AT SPRECHER ENERGIE AG        *\n*                                                                     *\n*    NOV 2002 EEJ  Support TMPNAME= parameter                   EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOINI2,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1              ADDRESS THE TSSO DATA AREA.\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(,R1)         STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(,R13)         REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         L      R9,0(,R8)\n         USING  DATD,R9\n***********************************************************************\n* INITIALIZE TSSOINI2 DSECT VARIABLES\n***********************************************************************\n         GETMAIN R,LV=4096\n         LR    R11,R1\n         USING TSSOVARS,R11\n         MVC   PARMLIB,IPARMLIB\n         MVC   LINK1D(LINK1CE-LINK1C),LINK1C\n         XC    RETCODE(2),RETCODE         ASSUME OK UNTIL PROVEN WRONG.\n***********************************************************************\n* ESTABLISH DEFAULTS FOR PARMLIB PARAMETERS IN CASE ONE IS LEFT OUT\n***********************************************************************\n         MVC   TMPNAME(8),=CL8'IKJEFT01'  DEFAULT TMP NAME\n         MVI   TSSOSRC,C'#'               DEFAULT SYSTEM RECOGNITION\n*                                         CHARACTER\n         MVC   TSSOTABN(8),=CL8'NONE'     DEFAULT NAME FOR TSSO TABLE\n         MVC   TSSORACF+1(8),=CL8'NONE'   ESTABLISH DEFAULT\n         MVC   INISEC(4),=CL4'MINI'      DEAFULT SECURITY IS MINIMAL\n         MVC   SECSYS(4),=CL4'RACF'      AND THE PACKAGE IS RACF.\n         MVC   MAXCMDS(4),=F'15'           DEFAULT MAXIMUM NUMBER OF\n*                                         SIMULTANEOUS COMMANDS\n*\n         MVC   ININUMSS(4),=F'1'         DEFAULT ONE SUBSYSTEM CONSOLE\n*\n         MVC   TMEOTVL(4),=F'15'          DEFAULT 15 MINUTES...\n*\n         MVI   TSSOSWAP,C'Y'              DEFAULT IS NON-SWAP\n         MVI   STARFORC,C'N'              DEFAULT IS NO FORCE.\n         MVC   TSSOPROM,C'N'              DEFAULT NOPROMPT\n         MVC   MAXWTO(4),=F'100'          DEFAULT MAXWTO VALUE = 100\n         MVI   TSSOMPF,C'N'         DEFAULT IS TO IGNORE MPF    14DEC92\n*\n         LA    R7,SSIARRAY                GET INIT ENTRY FOR SSI ARRAY\n         MVC   0(2,R7),=H'9'\n         MVC   8(8,R7),=CL8'TSSOSS09'     PREINITIALIZE THE TWO DEFAULT\n         LA    R7,36(,R7)                 ENTRIES FOR SUBSYSTEM\n         MVC   0(2,R7),=H'10'             CODES 9 AND 10.\n         MVC   8(8,R7),=CL8'TSSOSS10'\n         MVC   SSICOUNT(2),=H'2'          MOVE IN DEFAULT SSI COUNT\n***********************************************************************\n* END PARMLIB DEFAULT SETTING\n***********************************************************************\n         L     R8,PARMPTR         GET ADDRESS OF PARM FIELD IN R8\n         L     R8,0(,R8)\n         LH    R7,0(,R8)          GET LENGTHS OF PARMS\n         LTR   R7,R7              WAS THERE ONE ?\n         BZ    NOPARM\n         LA    R8,2(,R8)          POINT TO MEMBER NAME\n         BCTR  R7,0               FOR EX\n***********************************************************************\n* TSSO 4.3 - CHECK FOR SPECIAL CHARACTERS PROCEEDING THE MEMBER NAME  *\n* IF \"*\" IS PRESENT, ASSUME PROMPTING. IF '/' IS PRESENT, ASSUME FORCE*\n* = YES ON TSSO START COMMAND. THIS MAKES LIFE EASIER...              *\n***********************************************************************\n         CLI   0(R8),C'*'         IS PROMPTING DESIRED ?\n         BNE   CHKSPC2            NO, MOVE ON\n*\n         OI    PARMFLAG,X'40'     INDICATE PROMPTING REQUIRED.\n         LA    R8,1(,R8)\n         BCTR  R7,0\n*\nCHKSPC2  DS    0H\n         CLI   0(R8),C'/'         IS FORCE REQUIRED ?\n         BNE   CHKSPC3            NO, MOVE ON\n         MVI   STARFORC,C'Y'      SO INIDICATED.\n*\n         LA    R8,1(,R8)\n         BCTR  R7,0\n*\nCHKSPC3  DS    0H\n         LTR   R7,R7              ANY PARAMETERS LEFT ?\n         BNH   NOPARM\n         EX    R7,MOVEPARM        AND MOVE THE MEMBER NAME\n         B     AR1\nMOVEPARM MVC   PARMMEM(0),0(R8)   ** EXECUTED **\nAR1      DS    0H\n         B     ALLOPARM           GOT THE MEMBER- GO ALLOCATE PARMLIB\n*\n*\nNOPARM   DS    0H\n         MVC   PARMMEM(8),=CL8'TSSOPARM'\nALLOPARM DS    0H\n*\n* USE THE IEFPRMLB to allocate the system PARMLIB concatenation\n* to the DD name PARMLIB.\n         LA    R1,IEFPRM01\n         IEFPRMLB REQUEST=ALLOCATE,                                    X\n               S99RB=NO,                                               X\n               WAITDSN=NO,                                             X\n               MOUNT=NO,                                               X\n               RETMSG=NO,                                              X\n               CONSOLID=NOCONSID,                                      X\n               CART=NOCART,                                            X\n               ALLOCDDNAME=PARMLIB,                                    X\n               READ=NO, * MACRO DOES NOT READ MEMBER DATA              X\n               CALLERNAME=CALLTSSO,                                    X\n               MF=(E,(1),COMPLETE)\n* The return code is in GPR15\n* The reason code is in GPR0\n         LTR   R15,R15\n         JNZ   CMDFAIL\n         OC    PARMMEM(8),=CL8' '        MAKE UPPER CASE\n***********************************************************************\n*  READ INPUT FROM EITHER A DD OF PARMLIB, ALLOCATED IN THE JCL, OR\n*  FROM THE SYSTEM PARMLIB CONCATENATION, IF THERE IS NOT A DD OF\n*  PARMLIB ALLOCATED VIA JCL. THE TSSO MEMBER NAME TO BE READ FROM\n*  PARMLIB WILL BE PASSED AS A PARAMETER ON THE START COMMAND,\n*  ALLOWING FOR MULTIPLE TSSO PARAMETER MEMBERS TO BE IN THE\n*  PARMLIB, WITH THE CORRECT MEMBER BEING SELECTED ON THE START\n*  COMMAND . THE DEFAULT MEMBER NAME WILL BE \"TSSOPARM\". IF THE\n*  START COMMAND IS ISSUED LIKE \"S TSSO,PARM='NEWPARMS' THEN TSSO\n*  WILL USE THAT MEMBER FROM THE PARMLIB DD PREVIOUSLY MENTIONED.\n***********************************************************************\n         CLC   PARMMEM(8),=CL8'PROMPT'   WAS PROMPTING REQUESTED?\n         BNE   PROMPTNO                  NO, NO NEED\n         OI    PARMFLAG,X'40'            INDICATE PROMPTING DESIRED\n         MVC   PARMMEM(8),=CL8' '        BLANK OUT PARMMEM\n         LA    R7,WTORECB\n         XC    WTORECB(4),WTORECB\n         LA    R8,PARMMEM\n         WTOR  ,(R8),8,(R7),MF=(E,WTOR25D)   ** PROMPT **\n         WAIT  ECB=WTORECB\n         OC    PARMMEM(8),=CL8' '        MAKE UPPER CASE\nPROMPTNO DS    0H\n*                                  PROCESSED IN THE BLOCK\n         AGO   .RDMEM\nREADLOOP DS    0H\n         L     R8,PARMBUF\n         LA    R7,PARMDCBD\n         READ  DECB,SF,(R7),(R8),MF=E          PUT IT INTO BUFFER\n         CHECK DECB\n         L     R1,DECB+16          ADDRESS OF IOB\n         LH    R1,14(,R1)          RESIDUAL I/O COUNT\n         LH    R0,DCBBLKSI         GET DCB BLOCKSIZE\n         SR    R0,R1               GET NUMBER OF CHARS IN BUFFER\n         STH   R0,PARMREAD         ACTUAL NUMBER OF BYTES IN BUFFER\n.RDMEM   ANOP\n         STORAGE OBTAIN,                                               X\n               LENGTH=&READLEN,                                        X\n               SP=1,                                                   X\n               BNDRY=PAGE,                                             X\n               LOC=24\n         ST    R1,PARMBUF\n         USING PRM_READ_BUFFER,R1\n         MVC   PRM_READ_BUFF_SIZE,=A(&READLEN)\n         LR    R8,R1\n         LA    R1,IEFPRM01\n         IEFPRMLB REQUEST=READMEMBER,                                  X\n               DDNAME=PARMLIB,                                         X\n               CALLERNAME=CALLTSSO,                                    X\n               MEMNAME=PARMMEM,                                        X\n               READBUF=((8)),                                          X\n               BLANK72=NO,                                             X\n               MSG=YES,                                                X\n               RETMSG=NO,                                              X\n               CONSOLID=NOCONSID,                                      X\n               MF=(E,(1),COMPLETE)\n         ST    R15,RETURN_CODE\n         ST    R0,MODIFIER\n         LTR   R2,R15\n         LR    R3,R0\n         L     R1,PARMBUF\n         USING PRM_READ_BUFFER,R1\n         L     R8,PRM_RECORDS\n         L     R4,PRM_RECORDS_READ_COUNT\n         L     R5,PRM_TOTAL_RECORDS\n         MVC   RETCODE(2),=AL2(20)\n         CR    R4,R5\n         JNE   ENDPROG\n         XC    RETCODE(2),RETCODE\n         XR    R3,R3  HAVE NOT USED ANY BYTES\n         MHI   R4,80  RECORDS * 80 == NUMBER OF BYTES\n         ST    R4,PARMREAD\n*        L     R6,PRM_BUFF_SIZE_NEEDED\n         DROP  R1\n***********************************************************************\n* R8 WILL POINT TO THE CURRENT RECORD BEING PROCESSED.\n*    OR THE INPUT BUFFER FOR THE PROMPTING WTOR\n***********************************************************************\nPARMLOOP DS    0H\n***********************************************************************\n* WE WILL CALL THE NOW INFAMOUS TSSO PARSE ROUTINE TO SCAN THE\n* PARMLIB INPUT\n***********************************************************************\nPRSCHECK DS    0H\n         ST    R8,PARS1            PARM 1 IS THE ADDRESS OF STRING\n*\n         MVC   PARS2(4),=F'80'     PARM 2 GETS THE LENGTH OF THE STRING\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(49),PARARRAY\n         LA    R6,PARARRAY\n         ST    R6,PARS3\n         MVC   PARARRAY(2),=H'3'   MAXIMUM OF THREE TOKENS...\n*\n         LA    R6,PARSSEP          GET ADDRESS OF SEPERATOR CHARACTERS\n         ST    R6,PARS4\n         MVC   PARSSEP(4),=CL4',='\n*\n         LA    R1,PARSPARM         LOAD UP PARM REGISTER\n         CALL  TSSOPARS\n***********************************************************************\n* THE ARRAY SHOULD NOW BE FILLED WITH ALL KINDS OF GOOD STUFF.\n***********************************************************************\n         LA    R5,PARARRAY+2      POINT TO FIRST TOKEN\n***********************************************************************\n* THIS SECTION OF CODE MAY BE ENTERED OUT OF EITHER THE PARMLIB\n* INPUT ROUTINE, OR THE PROMPTING ROUTINE. THE ENTRY FROM THE PROMPT\n* ROUTINE IS NON OBVIOUS (READ  KLUDGE) SO BEWARE.\n***********************************************************************\n         CLC   0(8,R5),=CL8'SRC'      WAS IT SRC?\n         BE    PRSSRC                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'TABLE  '  WAS IT TABLE ?\n         BE    PRSTABLE               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'MAXCMDS'  WAS IT MAXCMD ?\n         BE    PRSMAXCM               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'TIMEOUT'  WAS IT TIMEOUT?\n         BE    PRSTMEOT               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'NUMCONS'  WAS IT NUMBER OF SS CONSOLES ?\n         BE    PRSNUMSS               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'NONSWAP'  WAS IT NONSWAP ?\n         BE    PRSNSWAP               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'PROMPT'   WAS IT PROMPT ?\n         BE    PRSPROM                YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'END    '  WAS IT END     ?\n         BE    PRSEND                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'RACFID '  WAS IT REQUEST FOR RACF ID?\n         BE    PRSRACF                YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'MAXWTO '  WAS IT REQUEST FOR MAXIMUM WTOS ?\n         BE    PRSMAXWT               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'SUBSYS '  WAS IT REQUEST FOR A SUBSYSTEM\n*                                     INTERFACE REQUEST ROUTINE ?\n         BE    PRSSSI                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'SECSYS'   DEFINING A SECURITY SYSTEM ?\n         BE    PRSSECS                OK, NO PROBLEM.\n*\n         CLC   0(8,R5),=CL8'SECLEVEL' DEFINING A SECURITY LEVEL ?\n         BE    PRSSECL                LETS SEE WHAT'S WHAT.\n*                                                               14DEC92\n         CLC   0(8,R5),=CL8'MPFSUPP'  REQUESTING TO IGNORE MPF  14DEC92\n*                                     SUPPRESSED MESSAGES       14DEC92\n         BE    PRSMPF                                           14DEC92\n*\n         CLC   0(8,R5),=CL8'TMPNAME'  Alternate TMP name ?      EEJ1102\n         BE    PRSTMPNM               Branch if yes             EEJ1102\n*                                                               EEJ1102\n         CLI   0(R5),C'*'             WAS IT A COMMENT ?\n         BE    PARMNEXT\n         B     PRSINV\nPRSTMPNM DS    0H\n* PROCESS ALTERNATE TMP REQUEST\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TMPNAME(8),16(R5)\n         B     PARMNEXT\nPRSSRC   DS    0H\n***********************************************************************\n* PROCESS THE  SRC  PARAMETER STATEMENT                               *\n***********************************************************************\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSOSRC(1),16(R5)\n         B     PARMNEXT\n*\nPRSTABLE DS    0H\n***********************************************************************\n* PROCESS THE  TABLE PARAMETER STATEMENT                              *\n***********************************************************************\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSOTABN(8),16(R5)\n         B     PARMNEXT\n*\nPRSTMEOT DS    0H\n***********************************************************************\n* PROCESS THE  TIMEOUT PARAMETER STATEMENT.                           *\n***********************************************************************\n* THIS PARAMETER DEFINES HOW LONG TSSO SHOULD WAIT FOR A COMMAND\n* BEFORE TIMING OUT A CONSOLE (LOGGING IT OFF). THE VALUE SPECIFIED IS\n* IN MINUTES, BUT IT IS INTERNALLY CONVERTED TO SECONDS.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    TMONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   TMEOTINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nTMONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(,R5)            POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   TMEOTINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    TMEOTINV              YUP, APPARAENTLY OK.\n         B     TMEOTOK\nTMEOTINV DS    0H\n         WTO   'TSSI018E INVALID TIMEOUT PARAMETER- DEFAULT (15) USED'\n         B     PARMNEXT\nTMEOTOK  DS    0H\n         ST    R1,TMEOTVL            STORE RESULTS..\n         B     PARMNEXT\n*\n*\nPRSNUMSS DS    0H\n***********************************************************************\n* PROCESS THE  NUMBER OF SUBSYSTEM CONSOLES PARAMETER.                *\n***********************************************************************\n* THIS PARAMETER DEFINES HOW MANY SUBSYSTEM CONSOLES TSSO SHOULD\n* ALLOCATE.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    SSONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   SSCONINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nSSONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(,R5)            POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   SSCONINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    SSCONINV              YUP, APPARAENTLY OK.\n         B     SSCONOK\nSSCONINV DS    0H\n         WTO   'TSSI019E INVALID NUMCONS PARAMETER SPECIFIED (1) USED'\n         B     PARMNEXT\nSSCONOK  DS    0H\n         ST    R1,ININUMSS           STORE RESULTS..\n***********************************************************************\n* CHECK IF A DEDICATED SUBSYSTEM CONSOLE IS REQUESTED...              *\n***********************************************************************\n         CLC   32(8,R5),=CL8'DEDICATE'   WAS DEDICATED REQUESTED ?\n         BNE   SSCONNOD                  DOESNT LOOK THAT WAY.\n         OI    PARMFLAG,X'10'            SET INDICATOR\nSSCONNOD DS    0H\n         B     PARMNEXT\n*\n*\nPRSMAXCM DS    0H\n***********************************************************************\n* PROCESS THE  MAXCMD PARAMETER STATEMENT                             *\n***********************************************************************\n* UP TO 99 MAX COMMANDS MAY BE SPECIFIED. CHECK TO SEE IF ONE DIGIT\n* OR 2 WAS SPECIFIED, THEN CALL THE CONVERT ROUTINE TO FIGURE OUT\n* WHAT IS WAS.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    CMONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   MAXCMINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nCMONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(,R5)            POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   MAXCMINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    MAXCMINV              YUP, APPARAENTLY OK.\n         B     MAXCMOK\nMAXCMINV DS    0H\n         WTO   'TSSI002E INVALID MAXCMDS PARAMETER- DEFAULT (15) USED'\n         B     PARMNEXT\nMAXCMOK  DS    0H\n         ST    R1,MAXCMDS            STORE RESULTS..\n         B     PARMNEXT\n*\nPRSMAXWT DS    0H\n***********************************************************************\n* THIS IS THE PARSE ROUTINE FOR THE MAXIMUM WTO PARMLIB ENTRY. THIS   *\n* ROUTINE WILL DETERMINE HOW MANY DIGITS WERE SPECIFIED FOR THE MAXWTO*\n* VALUE, AND CALL THE NIFTY EBCIDIC DECIMAL TO BINARY SUB TO DO THE   *\n* CONVERSION. THIS VALUE IS THEN STORED AT MAXWTO. UP TO 4 DIGITS MAY *\n* BE SPECIFIED.                                                       *\n***********************************************************************\n         XR    R1,R1                 START THE COUNT.\n         LA    R2,16(,R5)\nWTLOOP   DS    0H\n*\n         CLI   0(R2),X'40'           LOOKING FOR BLANK.\n         BE    WTBLANK               AHH. FOUND IT !\n         LA    R1,1(,R1)             INCREMENT COUNT.\n         CH    R1,=H'5'              TO BIG ?\n         BE    MAXWTINV              YUP, DONT ALLOW.\n         LA    R2,1(,R2)             TRY NEXT DIGIT.\n         B     WTLOOP\n*\nWTBLANK  DS    0H\n***********************************************************************\n* NOTE, R1 HAS COUNT OF DIGITS.\n***********************************************************************\n         LR    R0,R1                 COPY COUNT OF DIGITS.\n         LA    R1,16(,R5)            POINT TO START OF STRING TO CNVT.\n         LA    R10,DATD\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   MAXWTINV              YUP, APPARAENTLY BAD ONES.\n         LTR   R1,R1                 ANY RESULTS ?\nMAXWTOK  DS    0H\n         ST    R1,MAXWTO             STORE RESULTS..\n         B     PARMNEXT\n*\nMAXWTINV DS    0H\n         WTO   'TSSI003E INVALID MAXWTO PARAMETER- DEFAULT TAKEN (100)'\n         B     PARMNEXT\n*\n*\nPRSNSWAP DS    0H\n***********************************************************************\n* PROCESS THE  NONSWAP PARAMETER STATEMENT                            *\n***********************************************************************\n         CLI   16(R5),X'40'         ANYTHING THERE ?\n         BE    PRSNEQU              NOPE.. SORRY.\n         MVC   TSSOSWAP(1),16(R5)\n         B     PARMNEXT\n*\nPRSPROM  DS    0H\n         CLI   16(R5),C'Y'          DOES THE ANSWER START WITH \"Y\"?\n         BNE   PRSPROME\n         OI    PARMFLAG,X'40'       INDICATE PROMPTING REQUESTED\nPRSPROME DS    0H\n         B     PARMNEXT\n*\nPRSRACF  DS    0H\n***********************************************************************\n* PROCESS THE  RACFID  PARAMETER STATEMENT                            *\n***********************************************************************\n         TM    PARMFLAG,X'20'    ARE WE IN PARSE MODE ?\n         BNO   RACFNPRS          NO, OK TO ACCEPT RACF PARAMETER.\n         WTO   'TSSI004E RACFID PARAMETER REJECTED- NOT ACCEPTED IN PROX\n               MPT MODE'\n         B     PARMNEXT\nRACFNPRS DS    0H\n         CLI   16(R5),X'40'       ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSORACF+1(8),16(R5)\n         LA    R10,8\n         LA    R1,TSSORACF+1\n         XR    R5,R5\nRLOOP    DS    0H                GET THE LENGTH\n         CLI   0(R1),X'40'       OF THE USER ID AS\n         BE    RLOOPEND          REQUIRED BY THE RACINIT MACRO\n         LA    R5,1(,R5)\n         LA    R1,1(,R1)\n         BCT   R10,RLOOP\nRLOOPEND DS    0H\n         STC   R5,TSSORACF\n         B     PARMNEXT\n*\nPRSSSI   DS    0H\n***********************************************************************\n* PROCESS THE SUBSYS PARAMETER STATEMENT. THIS STATEMENT IS NEW WITH  *\n* TSSO VERSION 4.2, AND WILL CONTROL THE LOADING OF THE SUBSYSTEM     *\n* INTERFACE ROUTINES. THE SYNTAX IS:                                  *\n*\n* SUBSYS NN = MODULE-NAME\n*\n* ERROR WILL NOT BE DETECTED AT THIS TIME, BUT WILL BE DETECTED       *\n* WHEN LOADING THE MODULES. THIS ROUTINE WILL MEARLY FILL AN ARRAY    *\n* WITH INFORMATION.\n***********************************************************************\n         XR    R1,R1                 START THE COUNT.\n         LA    R2,16(,R5)\nSSILOOP  DS    0H\n*\n         CLI   0(R2),X'40'           LOOKING FOR BLANK.\n         BE    SSIBLANK              AHH. FOUND IT !\n         LA    R1,1(,R1)             INCREMENT COUNT.\n         CH    R1,=H'3'              TO BIG ?\n         BH    SSIPRMBD              YUP, DONT ALLOW.\n         LA    R2,1(,R2)             TRY NEXT DIGIT.\n         B     SSILOOP\n*\nSSIBLANK DS    0H\n***********************************************************************\n* NOTE, R1 HAS COUNT OF DIGITS.\n***********************************************************************\n         LR    R0,R1                 COPY COUNT OF DIGITS.\n         LA    R1,16(,R5)            POINT TO START OF STRING TO CNVT.\n         LA    R10,DATD\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   SSIPRMBD              YUP, APPARAENTLY BAD ONES.\n         CH    R1,=H'1'              ANY RESULTS ?\n         BL    SSIPRMBD\n         CH    R1,=H'255'            MAX 255 FOR SUBSYSTEM\n         BH    SSIPRMBD\nSSIPRMOK DS    0H\n* ONCE WE HAVE A VALID SUBSYS STATEMENT, WE WILL STORE IT IN THE SSI\n* ARRAY, FOR LATER LOADING. WE MUST VERIFY THAT THIS ENTRY WILL NOT\n* SQUASH OTHER ENTRIES.., OR IF IT DOES, USE THE LATER ENTRY\n         LA    R7,SSIARRAY           START AT BEGINNING OF ARRAY\n         LR    R2,R1                 COPY REGISTER CONTAINING SSICODE\n         LA    R6,10                 MAX COUNT OF SSI ENTRIES.\nSSIALOOP DS    0H\n         CH    R2,0(,R7)\n         BE    ENTFOUND              THIS MEANS THAT THIS SSI CODE IS\n*                                    THE SAME AS SOMETHING PREVIOUSLY\n*                                    USED, THEREFORE, THIS ENTRY IN\n*                                    SSIARRAY WILL BE USED\n         CLC   0(2,R7),=XL2'0000'    BLANK ENTRY ?\n         BE    ENTFOUND\n         LA    R7,36(,R7)\n         BCT   R6,SSIALOOP           AT MOST 10 ENTRIES...\n*\n         WTO   'TSSI005S SSI ARRAY OVERFLOW- TSSO TERMINATING',DESC=(1)\n         OI    PARMFLAG,X'01'        INDICATE SEVERE ERROR...\n         MVC   RETCODE(2),=H'12'     MOVE IN RETURN CODE.\n*\nENTFOUND DS    0H\n         CLI   32(R5),C' '           ANY THIRD PARM ON THIS LINE ?\n         BE    SSIPRMBD              GUESS NOT...\n         CLC   0(2,R7),=XL2'0000'    IS THIS A BLANK ENTRY ?\n         BNE   NOUPSSIC              NO, DONT UPDATE SSICOUNT\n         LH    R6,SSICOUNT           RAISE SSICOUNT BY 1\n         LA    R6,1(,R6)\n         STH   R6,SSICOUNT           AND PUT IT BACK\nNOUPSSIC DS    0H\n         STH   R2,0(,R7)             STORE RESULTS..\n         MVC   8(8,R7),32(R5)        AND STORE NAME OF LOAD MODULE\n         B     PARMNEXT\n*\nSSIPRMBD DS    0H\n         WTO   'TSSI006E INVALID SUBSYS CONTROL CARD - RECORD IGNORED'\n         B     PARMNEXT\n*\n*\nPRSSECS  DS    0H\n***********************************************************************\n* WHAT WE HAVE HERE IS AN ATTEMPT TO PROCESS THE SECSYS INITIATION    *\n* STATEMENT. CURRENTLY SUPPORTED VALUES ARE RACF AND ACF2.            *\n*                                                                     *\n* NOTE THAT THIS PARAMETER CANNOT BE SPECIFIED IN PROMPT MODE.        *\n*                                                                     *\n***********************************************************************\n         TM    PARMFLAG,X'20'      PROMPT MODE ACTIVE ?\n         BO    SECSNPRM            YUP, LETS NOT PROCESS THE PARM.\n         CLI   16(R5),X'40'        ANYTHING THERE ?\n         BE    PRSNEQU\n         CLC   16(8,R5),=CL8'RACF' WAS RACF SPECIFIED ?\n         BE    SECSRACF            YUP - WE CAN LIVE WITH THAT.\n*\n         CLC   16(8,R5),=CL8'ACF2' HOW BOUT ACF2 ?\n         BE    SECSACF2            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         CLC   16(8,R5),=CL8'TOPS' HOW BOUT TOP SECRET ?\n         BE    SECSTOPS            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         WTO   'TSSI014A SECSYS PARAMETER REJECTED - UNSUPPORTED SECURIX\n               TY SYSTEM'\n         B     SECSEND\nSECSRACF DS    0H\n***********************************************************************\n* WE COME HERE IF RACF IS SELECTED AS THE SECURITY SYSTEM.\n***********************************************************************\n         MVC   SECSYS(4),=CL4'RACF'\n         B     SECSEND\nSECSACF2 DS    0H\n***********************************************************************\n* WE COME HERE IF ACF2 IS SELECTED AS THE SECURITY SYSTEM.\n***********************************************************************\n         MVC   SECSYS(4),=CL4'ACF2'\n         B     SECSEND\nSECSTOPS DS    0H\n***********************************************************************\n* WE COME HERE IF TOP SECRET IS SELECTED AS THE SECURITY SYSTEM\n***********************************************************************\n         MVC   SECSYS(4),=CL4'TOPS'\n         B     SECSEND\n*\nSECSNPRM DS    0H\n         WTO   'TSSI015A SECSYS PARAMETER REJECTED - INVALID IN \"PROMPTX\n               \" MODE'\n         B     SECSEND\nSECSEND  DS    0H\n         B     PARMNEXT\n*\n*\n*\nPRSSECL  DS    0H\n***********************************************************************\n* HERE, WE WILL PROCESS THE SECLEVEL CONTROL STATEMENT. SUPPORTED     *\n* VALUES ARE MINIMAL AND MAXIMAL.                                     *\n*                                                                     *\n* NOTE THAT THIS PARAMETER CANNOT BE SPECIFIED IN PROMPT MODE.        *\n*                                                                     *\n***********************************************************************\n         TM    PARMFLAG,X'20'      PROMPT MODE ACTIVE ?\n         BO    SECLNPRM            YUP, LETS NOT PROCESS THE PARM.\n         CLI   16(R5),X'40'        ANYTHING THERE ?\n         BE    PRSNEQU\n         CLC   16(8,R5),=CL8'MINIMAL'  WAS MINIMAL SPECIFIED ?\n         BE    SECLMINI            YUP - WE CAN LIVE WITH THAT.\n*\n         CLC   16(8,R5),=CL8'MAXIMAL'  WAS MAXIMIAL SPECIFIED ?\n         BE    SECLMAXI            YUP, WE CAN LIVE WITH THAT, IF THE\n*\n         CLC   16(8,R5),=CL8'MEDIAL'   WAS MEDIAL   SPECIFIED ?\n         BE    SECLMEDI            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         WTO   'TSSI016A SECLEVEL PARAMETER REJECTED - TRY \"MINIMAL\" ORX\n               \"MAXIMAL\"'\n         B     SECLEND\nSECLMINI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MINIMAL.\n***********************************************************************\n         MVC   INISEC(4),=CL4'MINI'\n         B     SECLEND\nSECLMAXI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MAXIMAL\n***********************************************************************\n         MVC   INISEC(4),=CL4'MAXI'\n         B     SECLEND\nSECLMEDI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MEDIAL\n***********************************************************************\n         MVC   INISEC(4),=CL4'MEDI'\n         B     SECLEND\nSECLNPRM DS    0H\n         WTO   'TSSI017A SECLEVEL PARAMETER REJECTED - INVALID IN \"PROMX\n               PT\" MODE'\n         B     SECLEND\nSECLEND  DS    0H\n         B     PARMNEXT\n*                                                               14DEC92\nPRSMPF   DS    0H                                               14DEC92\n****************************************************************14DEC92\n* PROCESS THE  MPFSUPP PARAMETER STATEMENT                     *14DEC92\n****************************************************************14DEC92\n         MVC   TSSOMPF,16(R5)       SAVE PARAMETER              14DEC92\n         B     PARMNEXT                                         14DEC92\n*\n*\n*\nPRSEND   DS    0H\n         TM    PARMFLAG,X'20'      WAS END ENTERED FROM PROMPT MODE ?\n         BO    ENDPARMS            YUP, BEAM ME UP SCOTTY.\n         B     PARMEND\nPARMNEXT DS    0H\n         TM    PARMFLAG,X'20'      ARE WE IN PROMTING MODE ?\n         BO    CHKPROMP            IF IN PROMPTING MODE, PROMPT\n         LA    R8,80(,R8)\n         LA    R3,80(,R3)\n         C     R3,PARMREAD         ARE WE AT END OF BLOCK YET?\n         BL    PARMLOOP\n         XR    R3,R3\n         XR    R8,R8\n*        B     READLOOP\n         B     PRSEND                 YUP, GO HANDLE IT.\n*\nPRSINV   DS    0H\n         MVC   WTO16D+32(8),0(R5)     MOVE IN VERB FOR MESSAGE\n         WTO   MF=(E,WTO16D)          INVALID (YIPES!)  (MSG7)\n         B     PARMNEXT               GO GET NEXT RECORD\n*\nPRSNEQU  DS    0H\n         MVC   WTO17D+32(8),0(R5)     MOVE IN VERB FOR MESSAGE\n         WTO   MF=(E,WTO17D)          INVALID FORMAT    (MSG8)\n         B     PARMNEXT               GO GET NEXT RECORD\n*\nNPARMDCB DS    0H\n         WTO   'TSSI009E MISSING PARMLIB DD STATEMENT- DEFAULTS TAKEN'\n         B     PARMEND\nNPARM2   DS    0H\n         MVC   WTO18D+20(8),PARMMEM\n         WTO   MF=(E,WTO18D)           MEMBER NOT FOUND - (MSG10)\n         B     PARMEND\nNPARM3   DS    0H\n         WTO   'TSSI011E SYS1.PARMLIB IS NOT BLOCKED AT 80 BYTES- PARMLX\n               IB INPUT IGNORED'\n         B     PARMEND\nPARMEND  DS    0H\n*\n* Use the IEFPRMLB macro to dynamically free the PARMLIB\n         LA    R1,IEFPRM01\n         IEFPRMLB REQUEST=FREE,                                        X\n               DDNAME=PARMLIB,                                         X\n               CALLERNAME=CALLTSSO,                                    X\n               MF=(E,(1),COMPLETE)\n*\n* GPR15 contains the return code\n* GPR0 contains the reason code\n*\n         TM    PARMFLAG,X'80'      DID WE GET STORAGE ?\n         BNO   NOGETM              NOPE, DONT BOTHER WITH FREEMAIN\n         L     R0,PARMBLK\n         L     R1,PARMBUF\n         FREEMAIN R,LV=(R0),A=(R1)\n*        DROP  R7\nNOGETM   DS    0H\nCHKPROMP DS    0H\n         TM    PARMFLAG,X'01'      SEVERE ERROR IN INITIALIZATION ?\n         BO    ENDPARMS            YUP.. FORGET ALL THAT OTHER STUFF\n         OI    PARMFLAG,X'20'      INDICATE WE ARE INPROMPTING MODE.\n         TM    PARMFLAG,X'40'      WAS PROMPTING DESIRED ?\n         BNO   ENDPARMS            NO, GO TO END PARMS ROUTINE\n         XC    WTORECB(4),WTORECB\n         LA    R7,WTORECB\n         LA    R8,PROMPINP\n         MVC   PROMPINP(80),=CL80' '    BLANK OUT RESPONSE AREA\n         WTOR  ,(R8),80,(R7),MF=(E,WTOR26D)   ** PROMPT **  (MSG12)\n         WAIT  ECB=WTORECB\n         OC   PROMPINP(80),=CL80' '     UPPERCASE\n         B    PRSCHECK                  GO DO THE PARM\nENDPARMS DS    0H\nENDPROG  DS   0H\n*\n         LH    R8,RETCODE          PICK UP RETURN CODE\n*\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(,R13)         RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n*ENDPROG1 DS    0H\n         L     R14,12(,R13)        RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\nCMDFAIL  DS    0H\n         WTO 'TSSI013S UNABLE TO ISSUE TSO COMMANDS- TSSO TERMINATING',X\n               DESC=(1)\n         LA    R8,8\n         STH   R8,RETCODE\n         B     ENDPROG\n*\nERROR12  DS    0H\n         LA    R8,12\n         STH   R8,RETCODE\n         B     ENDPROG\n*\n***********************************************************************\n* TSSOINI2 ONLY DATA CONSTANTS.                                       *\n*                                                                     *\n***********************************************************************\nLINK1C   LINK  EP=TSSODOCM,SF=L\nLINK1CE  EQU   *\n*ALPRMLIB DC    CL50'ALLOC FI(PARMLIB) DSN(''SYS1.PARMLIB'') SHR'\n*FRPRMLIB DC    CL20'FREE FI(PARMLIB)'\nIPARMLIB DC    CL8'PARMLIB'\nCALLTSSO DC    CL8'TSSO',CL8'4.3.1'\n         EJECT\n***********************************************************************\n* TSSOINI2 ONLY DSECT.\n*                                                                     *\n***********************************************************************\nTSSOVARS DSECT\nRETURN_CODE DS F\nMODIFIER DS    F\nLINKPARM DS    F           PARAMETER FOR RE-ENTRANT LINK MACRO\nRETCODE  DS    H           RETURN CODE FROM TSSOINI2\nPARMLIB  DS    CL8         DDNAME\nLINK1D   LINK  EP=TSSODOCM,SF=L\n         COPY  TSSODATD\n         TSSOCVT\n         DCBD  DSORG=PO,DEVD=DA\n         IEFZPMAP DSECT=YES,                                           X\n               PRM_LIST_BUFFER=NO,                                     X\n               PRM_READ_BUFFER=YES,                                    X\n               PRM_MESSAGE_BUFFER=NO\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI2(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOINI2'\n PUNCH ' NAME     TSSOINI2(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOINI3": {"ttr": 37640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x8d\\x00\\x8d\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 141, "newlines": 141, "modlines": 0, "user": "TSSO403"}, "text": "TSSOINI3 CSECT\n***********************************************************************\n* THIS IS THE INITIALIZATION MODULE FOR THE TSSO RACF INTERFACE. THE  *\n* PURPOSE OF THIS MODULE IS TO PERFORM A RACROUT CALL TO ALLOW TSSO   *\n* TO ASSUME THE RACF ATTRIBUTES OF THE USERID SPECIFIED IN THE RACFID *\n* PARAMETER.\n*                                                                     *\n* TSSO 4.3 SUPPORTS THE CONCEPT OF A GENERIC SECURITY DEFAULT USERID. *\n* THIS SUPPORT WILL ALLOW A DEFAULT USERID IN RACF, ACF2 OR           *\n* TOP SECRET, DEPENDING ON THE SECSYS PARAMETER IN THE TSSO INIT DECK *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOINI3,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1              ADDRESS THE TSSO DATA AREA.\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                 SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=1024\n         LR    R11,R1\n         USING INI3DATD,R11\n*\n         MVC   RACROUTD(RACROUTE-RACROUTC),RACROUTC  RACROUT MACRO\n         LR    R9,R8\n         USING DATD,R9\n*\n         L     R1,X'224'          GET ASCB ADDRESS\n         USING ASCB,R1            ADDRESS THE ASCB\n         L     R1,ASCBASXB        GET ASXB POINTER\n         ST    R1,TSSOASXB        STORE FOR LATER\n         CLC   SECSYS(4),=CL4'RACF'   ARE WE DEALING WITH RACF ?\n         BE    SECRACF\n         CLC   SECSYS(4),=CL4'ACF2'   HOW BOUT ACF2\n         BE    SECACF2\n         CLC   SECSYS(4),=CL4'TOPS'   TOP SECRET ?\n         BE    SECTOPS                WE CAN USE RACF...\n         B     ENDPROG                LOGIC ERROR - FORGET IT.\n*\nSECRACF  DS    0H\n         L     R1,TSSOASXB\n         USING ASXB,R1\n         CLC   TSSORACF+1(8),=CL8' '  RACF ID WANTED ?\n         BE    NORACF               NOPE...\n         CLC   TSSORACF+1(8),=CL8'NONE' FOR THOSE WHO LIKE TO\n*                                     SPECIFY PARMS THAT DO NOTHING\n         BE    NORACF\n         RACSTAT                  IS RACF ACTIVE ?\n         LTR   R15,R15\n         BNZ   RACFBAD\n         L     R2,ASXBSENV\n         ST    R2,TSSOSENV        REMEMBER ADDRESS OF ORIGINAL SEC.\n*                                 ENVIRONMENT.\n*\n         ST    R2,ORIGACEE        REMEMBER ORIGINAL ACEE....\n         LA    R2,NEWACEE\n         DROP  R1                 (ASXB)\n         RACROUTE  REQUEST=VERIFY,WORKA=(R11),                         X\n               USERID=TSSORACF,MF=(E,RACROUTD),ACEE=(R2)\n         LTR   R15,R15\n         BZ    RACFOK\n*\n*\nRACFBAD  DS    0H\n         WTO   'TSSI014E ERROR ESTABLISING RACF ID- TSSO RUNNING WITH NX\n               O RACF AUTHORITY'\n         MODESET KEY=NZERO\n         B     NORACF\nRACFOK   DS    0H\n         L     R2,TSSOASXB        GET ASXB AGAIN\n         USING ASXB,R2\n         MODESET KEY=ZERO\n         MVC   ASXBUSER(7),TSSORACF+1\n         MVC   ASXBSENV(4),NEWACEE       AND GET NEW ACEE...\n         L     R2,ASXBSENV        GET ACEE ADDRESS\n         ST    R2,TSSOACEE        AND REMEMBER IT (FOR DOCM).\n         MODESET KEY=NZERO\n         DROP  R2\n         B     ENDPROG\nNORACF   DS    0H\n         B     ENDPROG\n*\nSECACF2  DS    0H\n         WTO   'TSS3501S ACF2 SUPPORT IS NOT INCLUDED IN THIS VERSION OX\n               F TSSO'\n         B     ENDPROG\n*\nSECTOPS  DS    0H\n         WTO   'TSS3501S TOP SECRET SUPPORT IS NOT INCLUDED IN THIS VERX\n               SION OF TSSO'\n         B     ENDPROG\n*\nENDPROG  DS    0H\n*\n         FREEMAIN R,LV=1024,A=(R11)\n*\n         XR    R8,R8               PICK UP RETURN CODE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n***********************************************************************\n* TSSOINI3 ONLY DATA CONSTANTS...                                     *\n*                                                                     *\n***********************************************************************\nRACROUTC RACROUTE REQUEST=VERIFY,                                      X\n               SMC=YES,PASSCHK=NO,ENVIR=CREATE,MF=L\nRACROUTE DS    0H\n*\nINI3DATD DSECT\n***********************************************************************\n* TSSOINI3 ONLY DSECT.                                                *\n*                                                                     *\n***********************************************************************\nINI3WORK DS    CL512\nORIGACEE DS    F                   ORIGINAL ACEE.\nNEWACEE  DS    F                   ACEE RETURNED BY RACF.\nRACROUTD RACROUTE REQUEST=VERIFY,                                      X\n               SMC=YES,PASSCHK=NO,ENVIR=CREATE,MF=L\n         COPY  TSSODATD\n         IHAASCB\n         IHAASXB\n         IHAACEE\n         END   TSSOINI3\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI3(''TSSO V 4.3.0  &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOINI3'\n PUNCH ' NAME     TSSOINI3(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOINI4": {"ttr": 37889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x00\\x97&\\x9f\\x01\\x07\\x07\\x0f\\x06 \\x00\\x9d\\x00\\x9c\\x00\\x02\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2007-03-11T06:20:36", "lines": 157, "newlines": 156, "modlines": 2, "user": "SBGOLOB"}, "text": "         TITLE ' T S S O    I N I T I A L I Z A T I O N   (PART2)'\n***********************************************************************\nTSSOINI4 CSECT\n***********************************************************************\n* THIS MODULE IS THE FOURTH PART OF TSSO INITIALIZATION. IT'S PURPOSE *\n* IS TO PROCESS THE TSSO SUBSYSTEM CONSOLES. THE NUMBER OF SUBSYSTEM  *\n* CONSOLES IS DEFINED IN THE NUMCONS INITIALIZATION PARAMETER, AND    *\n* THE PROCESSING OF THIS MODULE IS TO GET THAT PARAMETER, AND ATTEMPT *\n* TO ALLOCATE ALL THE SUBSYSTEM CONSOLES. IT WILL ACCOMPLISH THIS     *\n* THROUGH RECURSIVE CALLS TO TSSO GSSC.                               *\n***********************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOINI4,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         GETCVT (R9)\n         USING  TSSOCVT,R9\n         L      R8,TSSODSEC\n         USING  DATD,R8\n***********************************************************************\n* INITIALIZE TSSOINI4 DSECT VARIABLES\n***********************************************************************\n         GETMAIN R,LV=4096\n         LR    R11,R1\n         USING TSSOVARS,R11\n*\n         XC    INI4FLGS(4),INI4FLGS\n         TM    PARMFLAG,X'10'       WAS \"DEDICATE\" SPECIFIED IN PARMS?\n         BNO   INI4NODE             NO, DONT BOTHER DEDICATING SSCONS\n         OI    INI4FLGS,X'80'       OH HECK, GO AHEAD.\nINI4NODE DS    0H\n***********************************************************************\n* STEP 1 IS TO INITIALIZE THE SSCON CONTROL BLOCK AND THE SSCON CONTRO*\n* BLOCK HEADER.                                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MODESET KEY=ZERO           TO ACCESS THESE CONTROL BLOCKS\n         L    R10,SSCONSAD          GET ADDRESS OF SSCONCB HEADER.\n         USING SSCONCBH,R10\n         MVC  SSCONREQ(4),ININUMSS  MOVE NUMBER OF CONSOLES REQUESTED.\n         LA   R5,SSCONFIR           GET ADDRESS OF FIRST SS CONS CB\n         L    R7,SSCONREQ           ATTEMPT TO SATISFY REQUEST.\n*                                   R7 HAS NUMBER OF SUBSYSTEM CONSOLES\n*                                   REQUESTED VIA PARMLIB.\nGETCONS  DS   0H\n         USING SSCONCB,R5\n         XR   R0,R0                 FLAG TO OBTAIN SS CONSOLE\n         LINK EP=TSSOGSSC           GET A SUBSYSTEM CONSOLE\n         LTR  R15,R15               CHECK RETURN CODE\n         BNZ  INI4ERR               TROUBLE ALLOCATING A SUBSYSTEM\n*                                   CONSOLE\n*\n***********************************************************************\n* ASSUMING NO TROUBLE ALLOCATING THIS SUBSYSTEM CONSOLE, WE WILL      *\n* FILL IN THE FIELDS OF THE SSCON CB.                                 *\n*                                                                     *\n***********************************************************************\n         L     R2,SSCONAMT         GET # ALLOCATED TO DATE\n         LA    R2,1(R2)            BUMP\n         ST    R2,SSCONAMT         PUT BACK\n*DRCICS* LH    R2,TSSCONID         GET THE CONSOLE ID\n         L     R2,TSSCONID         GET THE CONSOLE ID\n         ST    R2,SSCONNUM         PUT IN SSCON CB\n         L     R2,TSSOSCNA         GET SSCONS UCMAUTH ADDRESS\n         ST    R2,SSCONAUT         AND STORE AWAY.\n         TM    INI4FLGS,X'80'      WAS A DEDICATED CONSOLE REQUESTED ?\n         BNO   GETMCONS            NO, DONT BOTHER TO GET ONE\n         TM    INI4FLGS,X'40'      IS THIS NOT THE FIRST TIME THROUGH\n         BO    GETMCONS            NOT THE FIRST TIME THROUGH, DONT\n*                                  DEDICATE THIS CONSOLE\n         OI    SSCONFLG,X'40'      INDICATE DEDICATED CONSOLE\n*\n         OI    INI4FLGS,X'40'      AND CONTINUE\nGETMCONS DS    0H\n         LA    R5,SSCONCBL(R5)     BUMP TO NEXT ENTRY.\n         BCT   R7,GETCONS          AND TRY FOR EVEN MORE SS CONSOLES\n         B     ENDPROG\nINI4ERR  DS    0H\n***********************************************************************\n* WE COME HERE IN CASE TSSOGSSC INFORMS US OF AN ERROR ALLOCATING A   *\n* SUBSYSTEM CONSOLE. IN THIS DEPRESSING EVENT, WE WILL TERMINATE      *\n* SSCONS INITIALIZATION WITH AN ERROR.                                *\n***********************************************************************\n         WTO   'TSSG153S TSSO IS UNABLE TO ALLOCATE ONE OR MORE SUBSYSTX\n               EM CONSOLES'\n         B     ENDPROG\nENDPROG  DS    0H\n*\n         MODESET KEY=NZERO\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n***********************************************************************\n* TSSOINI4 ONLY DATA CONSTANTS.                                       *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n* TSSOINI2 ONLY DSECT.\n*                                                                     *\n***********************************************************************\nTSSOVARS DSECT\nINI4FLGS DS    XL4\n* FIRST BYTE:\n* X'80'  A DEDICATED SUBSYSTEM CONSOLE IS REQUESTED. THIS BYTE IS\n*        COPIED FROM TSSO PARMFLAG (X'10')\n*\n* X'40'  THIS IS THE FIRST CONSOLE... USED WHEN CHECKING FOR DEDICATED\n*        CONSOLE REQUESTS... A DEDICATED CONSOLE WILL ALWAYS BE\n*        SATISFIED FIRST.\nRETCODE  DS    H           RETURN CODE FROM TSSOINI2\n         TSSOCVT\n         SSCONCBH\n         SSCONCB\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         COPY  TSSODATD\n         CVT   DSECT=YES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   TSSOINI4\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI4(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOINI4'\n PUNCH ' NAME     TSSOINI4(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOINI5": {"ttr": 37893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x966_\\x00\\x966_\\x13\\x10\\x01\\x0c\\x01\\x08\\x00\\x05\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-30T13:10:00", "lines": 268, "newlines": 264, "modlines": 5, "user": "RPS"}, "text": "         TITLE ' T S S O    I N I T I A L I Z A T I O N   (PART5)'\n***********************************************************************\nTSSOINI5 CSECT\n***********************************************************************\n* ----                                                           ---- *\n* ----  FOR ESA SYSTEMS, IF THIS MODULE DOES NOT ASSEMBLE        ---- *\n* ----  CLEANLY, THEN LOOK FOR THE STRING \"-ESA-\" IN THE         ---- *\n* ----  CODE, COMMENT OUT THE -NONESA- INSTRUCTION, AND          ---- *\n* ----  UNCOMMENT THE ESA-RELEVANT INSTRUCTION.                  ---- *\n* ----                                                           ---- *\n***********************************************************************\n* THIS ROUTINE IS THE FIFTH MAIN COMPONENT TO TSSO INITIALIZATION.    *\n* THIS ROUTINE IS RESPONSIBLE FOR SETTING UP THE CROSS MEMORY SERVICES*\n* ENVIRONMENT FOR TSSO. THIS ENVIRONMENT WILL PROVIDE FOR             *\n* AUTHORIZATION OF THE NCCF, IMS AND CICS CALLERS OF TSSOPCMD.        *\n*                                                                     *\n* NOTE: ERROR MESSAGES WILL BE IN THE FORM                            *\n* TSSXNNNA WHERE 500<NNN<549 AND A IS A SEVERITY CODE.                *\n*                                                                     *\n*        +---------+                                                  *\n*        + CHANGES +                                                  *\n*        +---------+                                                  *\n* 123096 RPS LABEL PROBLEM IN ETD                                     *\n*                                                                     *\n***********************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOINI5,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         GETCVT (R9)\n         USING  TSSOCVT,R9\n         L      R8,TSSODSEC\n         USING  DATD,R8\n         GETCVT (R7),NDSA=YES\n         USING  TSSONDSA,R7\n***********************************************************************\n* INITIALIZE TSSOINI5 DSECT VARIABLES\n***********************************************************************\n         GETMAIN R,LV=4096\n         LR    R11,R1\n         USING TSSOVARS,R11\n         MVC   WTOX1D(WTOX1CE-WTOX1C),WTOX1C\n         MVC   WTOX2D(WTOX2CE-WTOX2C),WTOX2C\n         MVC   WTOX3D(WTOX3CE-WTOX3C),WTOX3C\n         MVC   WTOX4D(WTOX4CE-WTOX4C),WTOX4C\n         MVC   LXRESD(LXRESCE-LXRESC),LXRESC\n*        MVC   ETCRED(ETCRECE-ETCREC),ETCREC\n         MVC   ETCOND(ETCONCE-ETCONC),ETCONC\n         MODESET KEY=ZERO\n***********************************************************************\n* STEP 1 IS TO SET THE TSSO AUTHORIZATION INDEX TO ONE. THIS GIVES    *\n* TSSO THE WRITE TO SSAR OR PT TO ANY OTHER ADDRESS SPACE.            *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         LA    R2,1\n         AXSET AX=(2)              SET AUTHORIZATION INDEX TO 1\n         LTR   R15,R15\n         BNZ   AXRESERR               BAD NEWS.\n***********************************************************************\n* STEP 2 WILL BE TO RESERVE A LINKAGE INDEX, OR TO REUSE ONE IF ONE   *\n* ALREADY EXISTS. THIS IS DETERMINED BY EXAMINING FLAGS IN THE TSSO   *\n* NDSA. NOTE THAT IF TSSO RESTART PROCESSING IS IN EFFECT, WE WILL    *\n* OBTAIN ANOTHER LINKAGE INDEX, EFFECTIVELY REBUILDING THE XMEM ENV.  *\n***********************************************************************\n         CLI   STARFORC,C'Y'       ARE WE IN FORCE MODE ?\n         BE    GETNEWLX            YUP, GET A NEW LX.\n         TM    NDSAFLG1,X'40'      HAS TSSO EVER GOT A LINKAGE INDEX ?\n         BO    GOTANLX             YUP, TSSO HAS INDEED GOT AN LX\nGETNEWLX DS    0H\n         LA    R2,1                WE NEED ONE LINKAGE INDEX VALUE\n         ST    R2,TSSOLXN\n         LXRES LXLIST=TSSOLXP,SYSTEM=YES,   ** GET A SYSTEM LX **      X\n               MF=(E,LXRESD)\n         LTR   R15,R15\n         BNZ   LXRESERR                     BAD NEWS\nGOTANLX  DS    0H                  TSSO ALREADY HAS AN LX.\n***********************************************************************\n* STEP THREE OF THE XMEM INITIALIZATION PROCESS IS TO BUILD THE       *\n* XMEM ENTRY TABLE HEADER.                                            *\n*                                                                     *\n***********************************************************************\n         TM    NDSAFLG1,X'10'      DO WE ALREADY HAVE AN XMEM ENVIR ?\n         BNO   INI5GO\n*\n         WTO   'TSSI504I XMEM ENVIRONMENT IS BEING RE-ESTABLISHED - PREX\n               VIOUS LINKAGE INDEX UNUSABLE'\n*\nINI5GO   DS    0H\n         LA    R6,TSSOETDH         POINT TO THE STORAGE\n         USING ETD,R6\n         MVI   ETDFMT,X'00'        FORMAT MUST BE ZERO\n*        MVI   ETDRSV1,X'00'    RESERVED FIELD MUST BE ZERO  -NONESA-\n*        MVI   ETDRS001,X'00'     -ESA-   -ESA-   -ESA-       RPS\n         MVI   ETDHFLAG,X'00'     -ESA-   -ESA-   -ESA-       RPS\n         MVC   ETDNUM(2),=H'1'     ONE PC ROUTINE FOR TSSO.\n*\n         DROP  R6\n***********************************************************************\n* STEP 4 IS TO FILL IN THE ENTRY TABLE. NOTE THAT ETDELE IS THE       *\n* BASE FOR THIS OPERATION.                                            *\n*                                                                     *\n***********************************************************************\n         LA    R6,TSSOETD1         POINT TO ENTRY TABLE 1\n         USING ETDELE,R6\n         MVI   ETDEX,X'01'         INDEX = 1\n         MVI   ETDFLG,ETDSUP        SUPERVISOR STATE, NON SPACE SWITCH\n*        MVC   ETDRSV3(2),=H'0'  MOVE A 0 INTO THE RSRVD FIELD -NONESA-\n         MVC   ETDRS002(2),=H'0'  -ESA-   -ESA-   -ESA-\n         XC    ETDPRO1(4),ETDPRO1    ZERO FIRST PART OF ADDRESS\n         MVC   ETDPRO2(4),TSSOPC1   AND PUT ADDRESS OF PC ROUTINE\n         MVC   ETDAKM(2),=XL2'FFFF'  AUTHORIZE ALL KEYS...\n         MVC   ETDEKM(2),=XL2'FFFF'  AUTHORIZE ALL KEYS...\n***********************************************************************\n* STEP 5 IS TO CREATE THE ENTRY TABLE. THIS IS ACCOMPLISHED BY        *\n* INVOKING THE MVS SERVICE DESIGNED TO CREATE ENTRY TABLES.           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         ETCRE ENTRIES=TSSOETD     GIVE IT THE ENTRY TABLE LIST\n         LTR   R15,R15             DID IT WORK ?\n         BNZ   ETCREERR            BAD NEWS...\n*\n         ST    R0,TSSOETTK         REMEMBER THE TOKEN !\n         LA    R2,1\n         ST    R2,TSSOETLN         FILL IN ENTRY TABLE LIST.\n*\n***********************************************************************\n* STEP 6 OF THE XMEM INITIALIZATION ROUTINE IS TO GLOBALLY CONNECT    *\n* THE ENTRY TABLE INTO EVERYONES ADDRESS SPACE. THE ETCON SERVICE     *\n* ACCOMPLISHES THIS.                                                  *\n***********************************************************************\n         ETCON TKLIST=TSSOETL,LXLIST=TSSOLXP,MF=(E,ETCOND)\n         LTR   R15,R15\n         BNZ   ETCONERR            REALLY BAD NEWS !\n         OI    TSSOFLG2,TSSOXMON   INDICATE XMEM ACTIVE !\n         OI    NDSAFLG1,X'40'      INDICATE THAT WE HAVE AN LX !\n         OI    NDSAFLG1,X'10'      INDICATE THAT CROSS MEMORY ENV IS\n*                                  ACTIVE.\n         B     ENDPROG\n*\nENDPROG  DS    0H\n*\n         MODESET KEY=NZERO\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nAXRESERR DS    0H\n         LR    R1,R15\n         LA    R10,INI5WORK\n         CALL  JCECVTBH\n         STCM  R0,B'1111',WTOX1D+37\n         STCM  R1,B'1111',WTOX1D+41\n         WTO   MF=(E,WTOX1D)\n         MVC   RETCODE(2),=H'8'\n         B     ENDPROG\nLXRESERR DS    0H\n         LR    R1,R15\n         LA    R10,INI5WORK\n         CALL  JCECVTBH\n         STCM  R0,B'1111',WTOX2D+37\n         STCM  R1,B'1111',WTOX2D+41\n         WTO   MF=(E,WTOX2D)\n         MVC   RETCODE(2),=H'8'\n         B     ENDPROG\nETCREERR DS    0H\n         LR    R1,R15\n         LA    R10,INI5WORK\n         CALL  JCECVTBH\n         STCM  R0,B'1111',WTOX3D+37\n         STCM  R1,B'1111',WTOX3D+41\n         WTO   MF=(E,WTOX3D)\n         MVC   RETCODE(2),=H'8'\n         B     ENDPROG\nETCONERR DS    0H\n         LR    R1,R15\n         LA    R10,INI5WORK\n         CALL  JCECVTBH\n         STCM  R0,B'1111',WTOX4D+37\n         STCM  R1,B'1111',WTOX4D+41\n         WTO   MF=(E,WTOX4D)\n         MVC   RETCODE(2),=H'8'\n         B     ENDPROG\n*\n***********************************************************************\n* TSSOINI5 ONLY DATA CONSTANTS.                                       *\n*                                                                     *\n***********************************************************************\nLXRESC   LXRES LXLIST=0,SYSTEM=YES,MF=L\nLXRESCE  EQU   *\n*\nETCONC   ETCON TKLIST=0,LXLIST=0,MF=L\nETCONCE  EQU   *\n*\n*\nWTOX1C   WTO   'TSSX500E ERROR IN AXRES - (R15 = XXXXXXXX',MF=L\nWTOX1CE  EQU   *\n*\nWTOX2C   WTO   'TSSX501E ERROR IN LXRES - (R15 = XXXXXXXX',MF=L\nWTOX2CE  EQU   *\n*\nWTOX3C   WTO   'TSSX502E ERROR IN ETCRE - (R15 = XXXXXXXX',MF=L\nWTOX3CE  EQU   *\n*\nWTOX4C   WTO   'TSSX503E ERROR IN ETCON - (R15 = XXXXXXXX',MF=L\nWTOX4CE  EQU   *\n*\nTSSOVARS DSECT\nINI5WORK DS    CL200\nLXRESD   LXRES LXLIST=0,SYSTEM=YES,MF=L\n*\nETCOND   ETCON TKLIST=0,LXLIST=0,MF=L\n*\nWTOX1D   WTO   'TSSX500E ERROR IN AXRES - (R15 = XXXXXXXX',MF=L\n*\nWTOX2D   WTO   'TSSX501E ERROR IN LXRES - (R15 = XXXXXXXX',MF=L\n*\nWTOX3D   WTO   'TSSX502E ERROR IN ETCRE - (R15 = XXXXXXXX',MF=L\n*\nWTOX4D   WTO   'TSSX503E ERROR IN ETCON - (R15 = XXXXXXXX',MF=L\n*\nRETCODE  DS    H           RETURN CODE FROM TSSOINI5\n         TSSOCVT\n         TSSONDSA\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         IHAETD\n         COPY  TSSODATD\n         CVT   DSECT=YES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   TSSOINI5\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI5(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOINI5'\n PUNCH ' NAME     TSSOINI5(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOLAOF": {"ttr": 37898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x022\\x1f\\x01\\x022\\x1f\\x16D\\x00\\xf7\\x00\\xf5\\x00\\x02\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T16:44:25", "lines": 247, "newlines": 245, "modlines": 2, "user": "EDJXADM"}, "text": "        TITLE  'T S S O   L O A D   A O F   T A B L E'\n***********************************************************************\n* THIS MODULE WILL LOAD, VALIDATE, AND BUILD THE BINARY SEARCH        *\n* INDEX FOR AN AOF TABLE.                                             *\n* PARAMETERS:                                                         *\n* ON ENTRY, R1 POINTS TO THE TSSO DATA AREA (DATD).                   *\n* THE NAME OF THE TABLE TO BE LOADED IS IN TSSOTABN.                  *\n* THIS TABLE IS LOADED, VERIFIED, AND THE INDEX IS BUILT.             *\n* IF EVERYTHING IS OK, THE POINTERS IN THE TSSOCVT ARE REPLACED.      *\n* NOTE: LAST MESSAGE NUMBER WAS TSSC142X                              *\n*                                                                     *\n* CREATED: 10/30/92                                                   *\n* AUTHOR:  GUY ALBERTELLI                                             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*                                                               EEJ1102\n*    NOV 2002 EEJ Support MCS extended consoles                 EEJ1102\n*                                                                     *\n***********************************************************************\n* RETURN CODES:                                                       *\n*   NONE                                                              *\n*                                                                     *\n***********************************************************************\nTSSOLAOF CSECT\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOLAOF,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R9,R1\n         USING DATD,R9\n         L     R10,TSSOCVTA             GET ADDRESS OF CVT\n         USING TSSOCVT,R10              SETUP ADDRESSABILITY\n         MODESET KEY=NZERO              GET TO TCB STATE\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=1024         GET STORAGE FOR A LOCAL\n         LR    R11,R1             DATA AREA\n         USING LAOFDATD,R11       AND TELL ASSEMBLER\n         MVC   LOAD1D(LOAD1CE-LOAD1C),LOAD1C  INITIALIZE LIST\n************************************************************\n*                                                          *\n*        LOAD THE AUTOMATED OPERATOR FACILITY TABLE        *\n*                                                          *\n************************************************************\nGETTABLE DS    0H\n         LA    R2,TSSOTABN\n         CLC   0(8,R2),=CL8'NONE'\n         BE    AOFDEACT\n         LOAD  EPLOC=(R2),GLOBAL=(YES,P),LSEARCH=YES,ERRET=NOLOAD,     X\n               SF=(E,LOAD1D)\n*#*      LOAD  EPLOC=(R2),ERRET=NOLOAD,                                X\n               SF=(E,LOAD1D)\n         LR    R6,R0                         REMEMBER LOAD ADDRESS\n         MODESET KEY=ZERO                    MOST THINGS NEED 0\n         CLC   4(8,R6),=CL8'TSSOTABL'        MAKE SURE WE REALLY\n*                                            HAVE A TSSO TABLE\n         BNE   TABNGOOD                      DARN\n         CLC   44(8,R6),=CL8'TSSO 4.3'       CHECK VERSION NUMBER\n         BNE   TABNGOO2                      INCORRECT VERSION\n         ST    R6,TSSOTABL\n         MVC   WTO19D+38(8),TSSOTABN\n         WTO   CONSID=CURRCONS,        Issue message            EEJ1102+\n               MF=(E,WTO19D)           (MSG 55)\n         B     ENDSTP16\nTABNGOOD DS    0H                      ** NOT A TSSO TABLE **\n         MVC   WTO21D+20(8),TSSOTABN\n         WTO   MF=(E,WTO21D)           (MSG 56)\n         B     BADE16                  GO TO BAD END OF STEP 16\nTABNGOO2 DS    0H                      ** TABLE AT INCORRECT VERSION **\n         MVC   WTO32D+19(8),TSSOTABN\n         WTO   MF=(E,WTO32D)           (MSG 57)\n         B     BADE16                  GO TO BAD END OF STEP 16\nNOLOAD   DS    0H\n         MVC   WTO20D+20(8),TSSOTABN\n         WTO   MF=(E,WTO20D)           (MSG 58)\n         MODESET KEY=ZERO                    MOST THINGS NEED 0\n         B     BADE16A                 GO TO BAD END OF STEP 16 W/O DEL\nBADE16   DS    0H\n         LA    R3,TSSOTABN\n         DELETE EPLOC=(R3)\nBADE16A  DS    0H\n         XR    R3,R3\n         ST    R3,TSSOTABL\n         MVC   TSSOTABN,=CL8'NONE'     INDICATE NO TABLE\n         B     ENDPROG\nAOFDEACT DS    0H\n         WTO   'TSSI059E TSSO AUTOMATED OPERATIONS FACILITY IS DEACTIVAX\n               TED BY PARMLIB INPUT'\n         B     ENDPROG\nENDSTP16 DS    0H\n***********************************************************************\n*  TABLE IS NOW LOADED AND VALIDATED, GO AND BUILD THE INDEX.         *\n***********************************************************************\n         L     R3,TSSOTABL              GET POINTER TO ACTUAL TABLE\n         L     R2,52(,R3)               POINT AT ENTRY COUNT\n         L     R2,0(,R2)                GET COUNT OF ENTRIES\n         LA    R2,1(,R2)                PLUS 1\n         SLL   R2,4                     ASSUME WORST,\n*                                       ALL ENTRIES DIFFERENT\n         LA    R2,4(,R2)                PLUS HEADER\n         GETMAIN R,LV=(2),SP=228        GET INDEX SPACE\n*#*      GETMAIN R,LV=(2)               GET INDEX SPACE\n         ST    R2,0(,R1)                SET LENGTH\n         MVI   0(R1),228                SET SUBPOOL\n         ST    R1,TSSOBSTH              SAVE ADDRESS OF INDEX BLOCK\n         AR    R1,R2                    POINT TO REAL END\n         SH    R1,=H'16'                LESS AN ENTRY SIZE\n         MVC   4(8,R1),=CL8'ZZZZZZZZ'   PUT IN DUMMY ENTRY\n         XC    0(4,R1),0(R1)            CLEAR POINTER\n         ST    R1,TSSOBSTS              SAVE POINTER TO START\n         ST    R1,TSSOBSTE              SAVE POINTER TO CURRENT LAST\n         MVI   TSSOBSTL+3,16            SET LENGTH\n         L     R3,0(,R3)                GET ADDRESS OF FIRST ENTRY\n         USING AOFNTRY,R3               SETUP ADDRESSABILITY\nLPAOFN   DS    0H\n         LTR   R3,R3                    ANY ENTRY\n         BZ    ENDPROG                  ALL DONE, SO EXIT\n         CLC   AOFMSGID,=CL8'*'         IS IT MATCH ALL\n         BNE   DORMSG                   NO, DO REAL MESSAGE\n         LA    R7,TSSOALMS              POINT TO HEAD OF ALL MSG\n         B     CHAINNEW                 CHAIN IT ON\nDORMSG   DS    0H                       DO REAL MESSAGE\n         LM    R4,R6,TSSOBSTS           LOAD PARMS\n         LA    R2,LAOFCLC\n         BAL   R14,BSCAN                GO AND FINE\n         B     ADD                      +0 NOT IN TABLE, ADD IT\n         B     CHAINNEW                 +4 IN TABLE, CHAIN IT\nLAOFCLC  CLC   AOFMSGID(8),4(R7)        COMPARE TO TABLE\n*\n**       CHAIN NEW AOF ENTRY TO PREVIOUS ENTRIES OR HEAD\n*\nCHAINNEW ICM   R4,15,0(R7)              GET POINTER TO FIRST\n         BNZ   CHNLP                    IF ONE EXISTS THEN HANDLE\n         ST    R3,0(,R7)                SET FIRST ENTRY\n         B     CHNELP                   NOW CLEAR NEW TAIL\nCHNLP    LR    R7,R4\n         ICM   R4,15,AOFBNXT-AOFNTRY(R7) ANY MORE\n         BNZ   CHNLP\n         ST    R3,AOFBNXT-AOFNTRY(,R7)  CHAIN NEW ON\nCHNELP   XC    AOFBNXT,AOFBNXT          CLEAR NEW TAIL\n         L     R3,AOFNXT                POINT TO NEXT\n         B     LPAOFN                   GO DO NEXT\n*\n**       ADD IN NEW ENTRY TO INDEX\n*\n*                       NOTE\n*                            - R7 POINTS TO ENTRY\n*                              THAT THE NEW ONE SHOULD FOLLOW\n*                            - TSSOBSTS AND TSSOBSTE POINT TO\n*                              AND END OF CURRENT TABLE. TSSOBSTS\n*                              WILL BE MODIFIED BY THIS ROUTINE\nADD      DS    0H                       ADD IN NEW ENTRY\n         LM    R4,R6,TSSOBSTS           GET START AND END PTRS\n*\n**       COMPUTE LENGTH TO MOVE\n*\n         LR    R1,R7\n         SR    R1,R4                    GET LENGTH TO MOVE\n         BNM   ADDNTY                   GO AND DO MOVE\n*\n**       ADD TO FRONT OF TABLE\n*\n         SR    R4,R6                    GET NEW LOW VALUE\n         ST    R4,TSSOBSTS              SAVE NEW START\n         MVC   4(8,R4),AOFMSGID         SET NEW MESSAGE ID\n         XC    0(4,R4),0(R4)            CLEAR CHAIN\n         LR    R7,R4                    POINT TO ENTRY TO ADD\n         B     CHAINNEW                 PUT ON CHAIN\n*\n**       ADD SOMEWHERE IN TABLE (EVEN END)\n*\nADDNTY   DS    0H\n         AR    R1,R6                    ADD IN AN ENTRY\n         LR    R0,R4                    GET OLD START\n         SR    R0,R6                    MAKE IT NEW START\n         ST    R0,TSSOBSTS\n         LR    R5,R1                    SET OLD LENGTH\n         MVCL  R0,R4                    MOVE FRONT OF TABLE UP\n*                                       R7 WILL POINT TO OPEN ENTRY\n         MVC   4(8,R7),AOFMSGID         SET NEW MESSAGE ID\n         XC    0(4,R7),0(R7)            CLEAR CHAIN\n         B     CHAINNEW\n***********************************************************************\n*  ALL DONE!!!!! NOW FREE UP STORAGE AND EXIT                         *\n***********************************************************************\nENDPROG  DS   0H\n         MODESET KEY=NZERO                   AND OUT AGAIN.\n         FREEMAIN R,LV=1024,A=(11)  FREE LOCAL STORAGE\n         LR     R1,R13              GET ADDRESS OF CORE IN R1\n         L      R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS     0H\n         L      R14,12(R13)         RELOAD RETURN POINT\n         XR     R15,R15\n         LM     R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR     R14\n         COPY  BSCAN\n         EJECT\n***********************************************************************\n* CONSTANTS FOR TSSOLAOF VARIABLES ONLY                               *\n*                                                                     *\n***********************************************************************\nLOAD1C   LOAD  EPLOC=0,GLOBAL=(YES,P),LSEARCH=YES,ERRET=SSILOADB,      X\n               SF=L\n*#*D1C   LOAD  EPLOC=0,ERRET=SSILOADB,                                 X\n               SF=L\nLOAD1CE  DS    0H\n         LTORG ,\n         EJECT\nLAOFDATD DSECT\n***********************************************************************\n* DATA AREA FOR TSSOLAOF VARIABLES ONLY                               *\n*                                                                     *\n***********************************************************************\nLOAD1D   LOAD  EPLOC=0,GLOBAL=(YES,P),LSEARCH=YES,ERRET=SSILOADB,      X\n               SF=L\n*#*D1D   LOAD  EPLOC=0,ERRET=SSILOADB,                                 X\n               SF=L\n         COPY  TSSODATD\n         TSSOCVT\n         TAOFNTRY\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         IEFJSSIB\n         IEFJSSOB (CM,RR),CONTIG=YES\n         IEZJSCB\nUCM      DSECT\n         IEECUCM\n         END   TSSOLAOF\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOLAOF(''TSSO V 4.3.0  &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOLAOF'\n PUNCH ' NAME     TSSOLAOF(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSSOMAIN": {"ttr": 38148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00(\\x01\\x021\\x9f\\x01\\x022\\x0f\\x12P\\x01\\x0e\\x01\\x0b\\x00\\x0e\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-16T12:50:28", "lines": 270, "newlines": 267, "modlines": 14, "user": "EDJXADM"}, "text": "         TITLE ' T S S O    M A I N L I N E   R O U T I N E '\n***********************************************************************\nTSSOMAIN CSECT\n***********************************************************************\n* THIS ROUTINE IS THE MAINLINE PROCESSING ROUTINE FOR TSSO. IT IS     *\n* RESPONSIBLE FOR THE ISSUING OF ALL TSSO COMMANDS, AND THE INTERFACE *\n* WITH THE SUBSYSTEM SUPPORT MODULE.                                  *\n*                                                                     *\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ  Support MCS extended consoles                *EEJ1102\n*                                                              *EEJ1102\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOMAIN,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN  R,LV=4096\n         LR    R11,R1\n         USING TSSOVARS,R11\n*\n         MVC   LINK1D(LINK1CE-LINK1C),LINK1C\n*\n         GETCVT (R10)\n         USING TSSOCVT,R10\n*\n         L     R9,TSSODSEC        GET LOCAL VARIABLES.\n         USING DATD,R9        ADDRESS THEM\n*\n*\n*\n***********************************************************************\n* SSSSS TTTTT   A    RRRR  TTTTT                                      *\n* S       T    A A   R  R    T                                        *\n* SSSSS   T   AAAAA  RRRR    T                                        *\n*     S   T   A   A  R R     T                                        *\n* SSSSS   T   A   A  R  R    T                                        *\n***********************************************************************\n************************************************************\n*                                                          *\n*        WAIT FOR POST FROM SSSM                           *\n*                                                          *\n************************************************************\n         SPACE\nWAIT     DS    0H\n         MODESET KEY=ZERO\n***********************************************************************\n* THE REMAINDER OF THIS MODULE MUST RUN IN KEY ZERO. TO MANY CONTROL  *\n* BLOCKS ARE REFERENCED TO MAKE IT VIABLE TO RUN ANY OTHER WAY.       *\n*                                                                     *\n***********************************************************************\n         L     R2,CURRCMD          GET CURRENT COMMAND\n         USING TSSOCMND,R2         ADDRESS IT\n         TM    CMNDFLAG,X'80'      IS IT ACTIVE\n         BO    NOWAIT\n         TM    TSSOFLG2,TSSOMON    MONITORING?\n         BZ    NOMON1\n         WTO   MF=(E,WTO10D)       WAITING (MSG 61)\nNOMON1   DS    0H\nWAIT4CMD DS    0H\n*\n         WAIT  ECB=$SVPOSTE\n*\n         TM    CMNDFLAG,X'80'      IS THIS COMMAND ACTIVE ?\n         BNO   WAIT4CMD\n         TM    TSSOFLG2,TSSOMON    MONITORING?\n         BZ    NOMON2\n         WTO   MF=(E,WTO11D)       POSTED  (MSG 62)\nNOMON2   EQU   *\nNOWAIT   DS    0H\n         SPACE\n         MVI   $SVPOSTE,0          ZERO OUT THE ECB\n*\n         MVC   TSSOCMD(128),CMNDCMD+1  MOVE IN COMMAND (- # SIGN)\n         L     R1,COUNTCMD             GET COUNT OF COMMANDS\n         LA    R1,1(R1)                    INCREMENT\n         ST    R1,COUNTCMD             AND REPLACE\n         LA    R1,127                  ALWAYS USE BIG LENGTH\n         STH   R1,TSSOCMDL             BECAUSE IT WORKS.\n         MVC   CURRCONS(4),CMNDCONS    MOVE IN CONSOLE ID\n         MVC   CURRCNAM,CMNDNAME       Copy console name        EEJ1102\n         MVC   CURRCATH,CMNDAUTH       Copy console auth bits   EEJ1102\n*\n         LA    R1,TSSOCMD\nOBV#     DS    0H                   OBVIOUSLY A '#' COMMAND\n*                                   OR WE WOULDNT BE HERE.\n         CLI   0(R1),C'.'           IS THIS A CONTROL COMMAND ?\n         BNE   TSOCMD               NOPE, MUST BE A TSO COMMAND\n         XC    CCMDFLAG(4),CCMDFLAG   ZERO OUT COMMUNICATIONS FLAG\n         LA    R1,DATD              PICK UP COMMON DATA AREA.\n         LINK  EP=TSSOCCMD,SF=(E,LINK1D)  LINK TO CONTROL COMMAND MOD\n         LTR   R15,R15\n         BNZ   CCERROR              PROBLEM PROCESSING COMMAND\n         TM    CCMDFLAG,X'80'       WAS THIS A REQUEST TO STOP?\n         BO    STOP                 DARN- GUESS WE GO AWAY\n         TM    CCMDFLAG,X'40'       SHOULD WE ATTEMPT TO LIST\n*                                   SYSTSPRT OUTPUT ?\n         BO    LISTAGAN             WELL.. I GUESS WE WILL REPEAT THE\n*                                   LIST...\n* HERE, WE CAN ASSUME ALL WENT WELL, AND GO BACK TO FETCH ANOTHER\n* COMMAND.\n         B     READY                READY TO PICK UP A NEW COMMAND\nCCERROR  DS    0H\n***********************************************************************\n* WE COME HERE IN CASE OF ERROR FROM THE TSSO CONTROL COMMAND ROUTINE *\n***********************************************************************\n         WTO   'TSST063S INTERNAL ERROR DETECTED PROCESSING CONTROL COMX\n               MAND- NOTIFY SYSTEMS PROGRAMMER',DESC=(1)\n         B     READY\n*\nLISTAGAN DS    0H\n* I haven't time to research the reason for this. Since it      EEJ1102\n* is used only in an exceptional condition, I'm going to        EEJ1102\n* comment the instructions and ignore it for now.               EEJ1102\n*        LH    R0,CCMDFLAG+2        PICK UP THE CONSOLE ID. ??  EEJ1102\n*        STH   R0,CURRCONS+2                                ??  EEJ1102\n         OI    TSSWFLAG,X'80'       CAREFUL NOT TO EXECUTE COMMANDS\n         B     LIST\n************************************************************\n*                                                          *\n*        TSO COMMAND                                       *\n*                                                          *\n************************************************************\n         SPACE\nTSOCMD   DS    0H\n*        OI    FLAG,X'80'          INDICATE THIS WAS A TSO COMMAND\n         LINK  EP=TSSODOCM,PARAM=((R9)),SF=(E,LINK1D),MF=(E,LINKPARM)\n         LR    R2,R15\n         LTR   R2,R2               CHECK RETURN CODE FROM DOCM\n         BNZ   READY               IF NON ZERO, DONT LIST.\n         B     LIST                OTHERWISE, YOU CAN LIST.\nREADY    EQU   *\n         L     R2,CURRCMD\n         USING TSSOCMND,R2\n         MODESET KEY=ZERO          TO FLICK BITS...\n         NI    CMNDFLAG,255-X'80'  TURN OFF BIT, INDICATING COMMAND\n*                                  DONE.\n         L     R2,CMNDNEXT\n         ST    R2,CURRCMD\n         MODESET KEY=NZERO\n         DROP  R2\n         B     WAIT\n************************************************************\n*                                                          *\n*        LIST TSO OUTPUT                                   *\n*                                                          *\n************************************************************\n         SPACE\nLIST     DS    0H\n         L     R0,CURRCONS         Load console ID              EEJ1102\nLISTR0   DS    0H\n************************************************************\n* THE LISTR0 LABEL ASSUMES THAT R0 HAS BEEN SET UP WITH THE\n* CONSOLE ID DESIRED. NOTE THAT IF ENTRY WAS OBTAINED THROUGH THE\n* #.L= COMMAND, THEN WE WILL NOT ALLOW COMMANDS IN THIS INVOCATION\n************************************************************\n         ST    R0,CONSPARM\n         L     R15,WTOADDR\n         CALL  (15),(CONSPARM,MAXWTO,TSSWFLAG),MF=(E,CALL1D)\n*\n         NI    TSSWFLAG,255-X'80'  TURN OFF FLAG BIT.\n         B     READY\n*\nSTOP     DS    0H\n***********************************************************************\n* THE STOP ROUTINE IS SIMPLY RETURN TO TSSO, THE MODULE THAT CALLED US*\n*                                                                     *\n***********************************************************************\nENDPROG  DS    0H\n         MODESET KEY=NZERO\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n***********************************************************************\n* TSSOMAIN ONLY DATA CONSTANTS                                        *\n*                                                                     *\n***********************************************************************\nLINK1C   LINK  LSEARCH=YES,SF=L\n*\nLINK1CE  EQU   *\n*\nTSSOVARS DSECT\n***********************************************************************\n* TSSOMAIN PRIVATE DSECT.                                             *\n*                                                                     *\n***********************************************************************\nLINK1D   LINK  LSEARCH=YES,SF=L\nLINKPARM DS    F\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO MAINLINE SHARED VARIABLES.           *\n***********************************************************************\n         COPY  TSSODATD\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO CVT.                                 *\n***********************************************************************\n         TSSOCVT\n         TSSONDSA\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO COMMAND RING                         *\n***********************************************************************\n         TSSOCMND          DSECT FOR TSSO COMMAND RING\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO SECURITY ARRAY                       *\n***********************************************************************\n         TSSOSECR          DSECT FOR TSSO SECURITY ARRAY\n*\n***********************************************************************\n* COPY IN THE DSECT FOR THE TSSO SS CONSOLE BLOCK HEADER              *\n***********************************************************************\n         SSCONCBH          SUBSYSTEM CONSOLE CONTROL BLOCK HEADER\n         SSCONCB           SUBSYSTEM CONSOLE CONTROL BLOCK\n*\n*\n         PRINT NOGEN\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSVT\n         DCBD  DSORG=PO,DEVD=DA\n         CVT   DSECT=YES\n         IEFJSSIB\n         IEFJSSOB (CM,RR),CONTIG=YES\n         IEZJSCB\n         IKJTCB\n         IHAASCB\n         IHAASXB\n         IHAETD\nUCM      DSECT\n         IEECUCM\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   TSSOMAIN\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOMAIN(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOMAIN'\n PUNCH ' NAME     TSSOMAIN(R)'\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSSONDSA": {"ttr": 38153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00'\\x00'\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n         TSSONDSA\n***********************************************************************\n* THIS MACRO MAPS THE TSSO NON DESTRUCTABLE SYSTEM AREA. THIS AREA IS *\n* OBTAINED ONCE, AT IPL TIME, AND SURVIVES ACROSS RESTARTS OF THE TSSO*\n* SUBSYSTEM.\n***********************************************************************\nTSSONDSA DSECT\nNDSAFLG1 DS    F                   MISC. FLAG BYTE\n* BYTE 1:\n* X'80' - TSSO HAS BEEN STARTED AT LEAST ONE TIME.\n* X'40' - TSSO HAS RESERVED A SYSTEM WIDE LINKAGE INDEX.\n* X'20' - TSSO IS CURRENTLY UP.\nSTARTCNT DS    F                   NUMBER OF TIMES TSSO HAS BEEN\n*                                  STARTED.\nTSSOLXP  DS    0F                  PARM TO LXRES MACRO\nTSSOLXN  DS    F                   TSSO LINKAGE INDEX COUNT...\nTSSOLX   DS    F                   TSSO LINKAGE INDEX.\n*\n***********************************************************************\n* THE FOLLOWING ENTRIES IN THE TSSO NDSAARE USED FOR THE TSSO XMEM    *\n* SERVICES ROUTINES. THEY ARE CREATED THROUGH TSSOINI5 AND DELETED    *\n* IN TSSOTERM.                                                        *\n*                                                                     *\n***********************************************************************\nTSSOPC1  DS    A                   ADDRESS OF TSSOPC1\nTSSOETD  DS    0D                  ENTRY TABLE DESCRIPTIONS\nTSSOETDH DS    CL4                 ENTRY TABLE HEADER (LENGTH 4)\nTSSOETD1 DS    CL20                ENTRY TABLE ENTRY NUMBER 1 (LENGTH\n*                                  OF AN ENTRY IS 20.\n*\nTSSOETL  DS    0F                  ENTRY TABLE LIST.\nTSSOETLN DS    F                   NUMBER OF ENTRIES\nTSSOETTK DS    F                   TOKEN VALUE RETURNED FROM ETCRE\n*\n*\nTSSOASID DS    H                   ADDRESS SPACE ID OF THE ACTIVE TSSO.\nNDSARESV DS    CL4092\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOPARS": {"ttr": 38155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 209, "newlines": 209, "modlines": 0, "user": "TSSO403"}, "text": "TSSOPARS CSECT\n         EQUATES\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSOPARS\n         USING  TSSOPARS,R12       GET ADDRESSIBILITY\n         LR     R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n***********************************************************************\n***********************************************************************\n* THIS IS A SUBROUTINE USED TO PARSE    ALMOST ANY STRING. THE INPUT\n* IS AS FOLLOWS:\n*\n* 0(R1)- POINTS TO THE STRING TO BE DECIPHERED.\n* 4(R1)- A FULLWORD CONTAINING THE LENGTH OF THE STRING\n* 8(R1)  AN ARRAY OF SIXTEEN BYTE ENTRIES. THE FIRST 2  BYTES OF THE\n*        ARRAY CONTAIN A COUNT OF THE MAXIMUM NUMBER OF ENTRIES IN THE\n*        ARRAY\n*\n* 12(R1) A 4 BYTE STRING OF SEPERATOR CHARACTERS. ANY OF THE CHARACTERS\n*        IN THE STRING MAY BE USED AS THE SEPARATOR.\n*\n*\n*\n* EXIT CONDITIONS:\n* R15 = 0: TSSOPARS COMPLETED NORMALLY. ARRAY HAS BEEN COMPLETED.\n* R15 = 4: TSSOPARS COMPLETED ABNORMALLY, ARRAY HAS FILLED UP.\n* R15 = 8: TSSOPARS COMPLETED ABNORMALLY, ARRAY PROBABLY NOT VALID\n* 0(ARRAY): TSSOPARS WILL RETURN THE NUMBER OF ENTRIES IN THE ARRAY IN\n*           THE FIRST TWO BYTES.\n***********************************************************************\n         GETMAIN R,LV=200\n         LR    R11,R1\n         USING DATA,R11\n         LR    R1,R8\n         L     R2,0(R1)              GET ADDRESS OF STRING\n         L     R7,8(R1)              GET ADDRESS OF ARRAY\n         ST    R7,ARRAY              PUT IT AWAY FOR LATER\n         LH    R3,0(R7)              GET MAXIMUM 16 BYTE ENTRIES\n         STH   R3,MAXCOUNT\n         LA    R7,2(R7)              NOW POINT TO START OF ARRAY\n         L     R4,4(R1)              GET LENGTH OF STRING\n         LA    R4,0(R2,R4)\n         L     R3,12(R1)\n         MVC   SEPCHARS(4),0(R3)\n         XC    ARRCOUNT(4),ARRCOUNT   ZERO OUT ARRCOUNT\n*\nPRSELOOP DS    0H\n***********************************************************************\n* R7 - NEXT POSITION IN ARRAY\n* R2 - CURRENT POSITION IN STRING\n***********************************************************************\n         BAL   R14,FNDNBLNK           FIND NEXT NON BLANK\n         LTR   R15,R15                 WHAT HAPPENED ?\n         BNZ   ALLBLANK              IT WAS ALL BLANK !\n* R2 POINTS TO FIRST NON BLANK CHARACTER IN REST OF STRING\n         LR    R5,R2                 REMEMBER (SPOCK TO MCCOY (ST:TWOK)\n         BAL   R14,FNDBLANK          GET NEXT BLANK CHARACTER\n         CH    R15,=H'0'             WHAT HAPPENED THIS TIME ?\n         BE    GOTBLNK               GOT A BLANK\n         CH    R15,=H'4'             HOW ABOUT NOW ?\n         BE    NOBLANKS              NO MORE BLANKS LEFT !\n         CH    R15,=H'8'             WHAT ABOUT THIS ?\n         BE    TOBIG                 MORE THEN SIXTEEN TOKENS !\n*\nGOTBLNK  DS    0H\n* R2 PTS TO ENDING BLANK\n* R5 PTS TO START OF STRING\n* R3 HAS COUNT OF CHARS\n* R7 HAS CURRENT TOKEN POSITION\n         BCTR  R3,0\n         EX    R3,MOVEIT\n         B     AR1\nMOVEIT   MVC   0(0,R7),0(R5)         ** EXECUTED **\nAR1      DS    0H\n         LA    R7,16(R7)             POINT TO NEXT TOKEN POSITION\n         L     R3,ARRCOUNT\n         LA    R3,1(R3)\n         ST    R3,ARRCOUNT\n         B     NEXTTOKE              CHECK FOR NEXT TOKEN...\n*\nNOBLANKS DS    0H\n* NO BLANKS FOUND AT END OF STRING.. PROCESS THIS LAST TOKEN AND EXIT\n* R2 - END OF STRING\n* R3 - LENGTH\n* R5 - START OF STRING\n* R7 - CURRENT TOKEN POSITION\n         BCTR  R3,0\n         EX    R3,MOVEIT\n         L     R3,ARRCOUNT\n         LA    R3,1(R3)\n         ST    R3,ARRCOUNT\n         B     PARSEND\n*\nALLBLANK DS    0H\n         B     LASTTOKE\n*\nTOBIG    DS    0H\n         MVC   0(16,R7),0(R5)\n         LA    R2,1(R2)              POINT TO NEXT CHARACTER\n         LA    R7,16(R7)\n         L     R3,ARRCOUNT\n         LA    R3,1(R3)\n         ST    R3,ARRCOUNT\n         B     NEXTTOKE\n*\nNEXTTOKE DS    0H\n         L     R3,ARRCOUNT           GET ARRCOUNT\n         CH    R3,MAXCOUNT           ARE WE AT END OF ROPE ?\n         BNL   LASTTOKE\n         B     PRSELOOP              GO AROUND AGAIN\nLASTTOKE DS    0H\n         B     PARSEND\nPARSEND  DS    0H\n         L     R1,ARRCOUNT\n         L     R2,ARRAY\n         STH   R1,0(R2)         PUT NUMBER OF TOKENS AWAY\n         FREEMAIN R,LV=200,A=(R11)\nENDPROG  DS   0H\n         LR     R1,R13              GET ADDRESS OF CORE IN R1\n         L      R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         L      R14,12(R13)         RELOAD RETURN POINT\n         XR     R15,R15\n         LM     R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR     R14\n*\n*\nFNDBLANK DS    0H\n* R2- A NON BLANK\n* R4- A(LAST CHARACTER IN STRING)\n         LA    R3,1             INCLUDE FIRST CHARACTER FOUND\nBLNKLOOP DS    0H\n         LA    R2,1(R2)         SCAN NEXT CHARACTER\n         CLC   0(1,R2),SEPCHARS   GOT A SEPARATOR ?\n         BE    FNDBLK           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+1    GOT A SEPARATOR ?\n         BE    FNDBLK           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+2    GOT A SEPARATOR ?\n         BE    FNDBLK           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+3    GOT A SEPARATOR ?\n         BE    FNDBLK           YUP- GOT ONE\n         CLI   0(R2),X'00'      IS THIS ZEROS ?\n         BE    FNDBLK\n         CR    R2,R4            AT END OF STRING\n         BNL   LASTWD           YUP, LAST WORD...\n         LA    R3,1(R3)         INCREMENT COUNT\n         CH    R3,=H'16'        TOKEN TO BIG ?\n         BE    WORD16           YUP- QUITE SAD..\n         B     BLNKLOOP\n*\nFNDBLK   DS    0H\n         XR    R15,R15\n         BR    R14\n*\nLASTWD   DS    0H\n         LA    R15,4\n         BR    R14\n*\nWORD16   DS    0H\n         LA    R15,8\n         BR    R14\n*\n*\nFNDNBLNK DS    0H\n* FIND NEXT NON BLANK CHARACTER IN STRING\n* R2- POINTS TO CURRENT POSITION IN STRING\n* R4- POINTS TO END OF STRING\n         CLC   0(1,R2),SEPCHARS   GOT A SEPARATOR ?\n         BE    NGOTIT           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+1    GOT A SEPARATOR ?\n         BE    NGOTIT           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+2    GOT A SEPARATOR ?\n         BE    NGOTIT           YUP- GOT ONE\n         CLC   0(1,R2),SEPCHARS+3    GOT A SEPARATOR ?\n         BE    NGOTIT           YUP- GOT ONE\n         CLI   0(R2),X'00'      ZEROS COUNT AS BLANKS...\n         BE    NGOTIT\n         B     GOTIT             NO, GOT NEXT NON-BLANK\nNGOTIT   DS    0H\n         LA    R2,1(R2)          INCREMENT\n         CR    R2,R4             AT END OF STRING ?\n         BNL   ENDOSTR           YUP- QUITE SAD.\n         B     FNDNBLNK\nGOTIT    DS    0H\n         XR    R15,R15\n         BR    R14\nENDOSTR  DS    0H\n         LA    R15,4\n         BR    R14\n*\nDATA     DSECT\nSEPCHARS DS    CL4               SEPARATOR CHARACTERS\nARRCOUNT DS    F\nMAXCOUNT DS    H\nARRAY    DS    A                 ADDRESS OF ARRAY\nDUMMY    DS    F\n         END   TSSOPARS\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOPARS(''V 1.1 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOPARS'\n PUNCH ' NAME     TSSOPARS(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOPCMD": {"ttr": 38403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x022\\x1f\\x01\\x022\\x1f\\x14D\\x02i\\x02i\\x00\\x00\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T14:44:37", "lines": 617, "newlines": 617, "modlines": 0, "user": "EDJXADM"}, "text": "         TITLE ' M V S   C O M M A N D   P R O C E S S O R '\nTSSOPCMD CSECT\n***********************************************************************\n* THIS IS THE TSSOPCMD SUBROUTINE. THIS SUBROUTINE WILL BE CALLED BY  *\n* SERVERS DESIRING TO ISSUE OPERATING SYSTEM COMMANDS AND RETRIEVE    *\n* RESPONSES. THE SUBROUTINE WILL RUN IN THE COMMON SYSTEM AREA,       *\n* AND UTILIZE THE SERVICES OF TSSO TO RETRIEVE THE OPERATING SYSTEM   *\n* COMMAND RESPONSE. BECAUSE OF THIS, THE SUBROUTINE CANNOT BE RUN     *\n* IN AN ENVIRONMENT THAT DOES NOT CONTAIN TSSO. SINCE THIS MODULE IS  *\n* IN FACT, A SUBROUTINE, IT DOES ISSUE ANY MESSAGES OF ITS OWN, SAVE  *\n* THOSE FORTELLINGDISASTER WITH TSSO ITSELF. IT WILL, INSTEAD, OFFER  *\n* RETURN CODES TO ITS CALLERS. THIS MODULE MUST RUN APF AUTHORIZED,   *\n* HOWEVER, IT WILL ASSUME IT IS CALLED IN THAT STATE. THIS REQUIRES   *\n* THE CALLER TO GET AUTHORIZED.                                       *\n*                                  . THE FOLLOWING ARE THE INPUT      *\n* PARAMETERS THAT THIS MODULE EXPECTS.                                *\n*                                                                     *\n*                                                                     *\n* R1 --> PARAMETER LIST                                               *\n*                                                                     *\n*  0(R1) ---> ADDRESS OF THE MVS COMMAND TO BE ISSUED THROUGH SVC 34  *\n*                                                                     *\n*  4(R1) ---> ADDRESS OF A 4 BYTES FIELD CONTAINING THE LENGTH OF     *\n*             THE ABOVE COMMAND.                                      *\n*                                                                     *\n*  8(R1) ---> ADDRESS OF A 4 BYTE FIELD CONTAINING THE MAXIMUM AMOUNT *\n*             OF TIME, IN 1/100 OF A SECOND, THAT THE CALLER  TO WAIT *\n*             FOR THE COMMAND TO TERMINATE. THE VALUE MUST BE BETWEEN *\n*             1 SECOND AND 60 SECONDS.                                *\n*                                                                     *\n* 12(R1) ---> ADDRESS OF A 4 BYTE FIELD CONTAINING THE MAXIMUM        *\n*             NUMBER OF LINES THAT THE CALLER WOULD LIKE TO GET       *\n*             BACK.                                                   *\n*                                                                     *\n* 16(R1) ---> ADDRESS OF A ONE BYTE FLAG INDICATING THE AUTHORITY     *\n*             LEVEL THAT THE COMMAND SHOULD BE INVOKED WITH. THE      *\n*             FLAG VALUES ARE:                                        *\n*                                                                     *\n*             X'80' - SYSTEM AUTHORITY                                *\n*             X'40' - I/O AUTHORITY                                   *\n*             X'20' - CONSOLE AUTHORITY                               *\n*             X'01' - CONSOLE IS CONSIDERED A PSEUDO-MASTER.          *\n*                                                                     *\n* 20(R1) ---> ADDRESS OF AN 8 BYTE FIELD CONTAINING THE USERID OF     *\n*             THE INVOKER. THIS WILL TYPICALLY BE THE TSO USERID,     *\n*             IMS LTERM                                               *\n*                                                                     *\n*                                                                     *\n* 24(R1) ---> ADDRESS OF A 40,000 BYTE BUFFER THAT TSSOPCMD IS TO     *\n*             COPY THE COMMAND RESPONSE BACK TO. THE REASON FOR       *\n*             REQUIRING THIS PARAMETER IS TO ENSURE THE 40K BUFFER    *\n*             REQUIRED IN CSA GETS FREED. A MOVE LONG INSTRUCTION     *\n*             WILL BE PERFORMED TO DO THE COPY.                       *\n*             NOTE: THE FIRST FOUR BYTES OF THIS BUFFER CONTAIN THE   *\n*                   COUNT OF MESSAGES IN THE BUFFER.                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* 28(R1) ---> ADDRESS OF A 4 BYTE FIELD THAT TSSOPCMD WILL PLACE THE  *\n*             NUMBER OF LINES RETURNED FROM THE MVS COMMAND.          *\n*                                                                     *\n*                                                                     *\n* 32(R1) ---> ADDRESS OF A 1 BYTE FIELD THAT TSSOPCMD WILL PLACE THE  *\n*             REASON CODE BEHIND SUCCESS/FAILURE.                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* METHOD OF OPERATION:                                                *\n*                                                                     *\n* 1) - VALIDATE THE PARAMETERS, AS WELL AS THE CALLING ENVIRONMENT    *\n*      AND ISSUE RETURN CODES IF NOT GOOD.                            *\n*                                                                     *\n* 2) - FIND A TSSO SUBSYSTEM CONSOLE. THIS IS DONE BY SCANNING THE    *\n*      SSCONCB CHAIN AND FINDING A FREE CONSOLE                       *\n*                                                                     *\n* 3) - GETMAIN AN OSCMD INTERFACE CONTROL BLOCK                       *\n*                                                                     *\n* 4) - PREPARE THE STIMER TO BLOW OFF IN THE SPECIFIED NUMBER OF      *\n*      SECONDS.                                                       *\n*                                                                     *\n* 5) - ISSUE SVC 34 AND WAIT.                                         *\n*                                                                     *\n* 6) - RETURN CONTROL TO CALLER AFTER FILLING IN PARAMETER LIST WITH  *\n*      OUTPUT VARIABLES.                                              *\n*                                                                     *\n*  +---------+                                                        *\n*  + CHANGES +                                                        *\n*  +---------+                                                        *\n*  30DEC96  RPS  FIXED ADDRESSABILITY ERROR WITH HLASM                *\n*                                                               EEJ1102\n*  NOV 2002 EEJ  Fixed non-empty PUSH stack error               EEJ1102\n*                                                                     *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSOPCMD\n         USING TSSOPCMD,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1              SAVE INPUT PARMS.\n*                                 THEN I EXPECTED.\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSCMDATD,R11\n         MVC   OPESTAED(ESTAECE-ESTAEC),ESTAEC\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         TM    TSSOFLG1,TSSOGONE   TSSO BLOWN AWAY ?\n         BO    RC32\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         LA    R2,OSCMDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         LA    R2,STIMEREX         GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n         ST    R8,TSSOPPRM         REMEMBER PARM LIST ADDRESS\n         MVI   MVSCMD+4,X'40'\n         MVC   MVSCMD+5(130),MVSCMD+4\n***********************************************************************\n* STEP 1 IS TO VALIDATE THE INPUT PARAMETERS AND APF AUTHORIZATION    *\n* STATUS.                                                             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         TESTAUTH FCTN=1              ARE WE AUTHORIZED ?\n         LTR   R15,R15\n         BNZ   RC4                    NO, GIVE UP.\n*\n***********************************************************************\n* STEP 2: VALIDATE AND PROCESS MVS COMMAND                            *\n*                                                                     *\n***********************************************************************\n         L     R3,0(R8)               POINT AT MVS COMMAND\n         L     R4,4(R8)               POINT AT LENGTH\n         L     R4,0(R4)               OBTAIN LENGTH\n         STH   R4,MVSCMD              STORE LENGTH AWAY\n         MVC   MVSCMD+2(2),=H'0'\n         MVC   MVSCMD(2),=H'127'\n         CH    R4,=H'127'\n         BH    RC8                    LENGTH OUT OF RANGE\n         LTR   R4,R4\n         BNH   RC8\n         BCTR  R4,0                   FOR EXECUTE.\n         EX    R4,MOVMVSCM            MOVE THE COMMAND TO OUR STORAGE\n         B     AR2\nMOVMVSCM MVC   MVSCMD+4(0),0(R3)      ** EXECUTED **\nAR2      DS    0H\n***********************************************************************\n* STEP 3: VALIDATE AND PROCESS THE TIME PARAMETER...                  *\n*                                                                     *\n***********************************************************************\n         L     R3,8(R8)               PICK UP POINTER TO TIME PARM\n         L     R3,0(R3)               PICK UP ACTUAL WAIT TIME\n         LTR   R3,R3                  POSTIVE  ?\n         BNH   RC12                   BAD NEWS.\n         CH    R3,=H'6000'            TO HIGH ?\n         BH    RC12                   BAD NEWS...\n         ST    R3,WAITTIME            PUT AWAY.\n***********************************************************************\n* STEP 4: VALIDATE AND PROCESS THE LINES PARAMETER...                 *\n*                                                                     *\n***********************************************************************\n         L     R3,12(R8)              PICK UP POINTER TO LINES PARM\n         L     R3,0(R3)               PICK UP ACTUAL MAX LINES COUNT\n         CH    R3,=H'200'             MAXIMUM SUPPORT IS 200.\n         BH    RC16\n         LTR   R3,R3                  POSTIVE  ?\n         BNH   RC16                   BAD NEWS.\n         ST    R3,MAXLINES            PUT AWAY.\n***********************************************************************\n* STEP 5: VALIDATE AND PROCESS THE COMMAND AUTHORIZATION PARAMETERS...*\n*         HERE, WE TAKE IT ON BLIND FAITH THAT THE INVOKER IS         *\n*         AUTHORIZED TO WHATEVER AUTHORITY HE WANTS, SINCE HE WAS APF *\n*         AUTHORIZED TO BEGIN WITH.                                   *\n***********************************************************************\n         L     R3,16(R8)              PICK UP POINTER TO AUTH  PARM\n         TM    0(R3),B'00001110'      CHECK THAT ALL BITS IN TAIL END\n*                                     OF BYTE ARE OFF...\n         BNZ   RC20                   INVALID AUTHORIZATION PARAMETER\n         MVC   AUTHBYTE(1),0(R3)      COPY IT.\n*\n***********************************************************************\n* NEXT, WE MOVE THE CALLER SUPPLIED USERID INTO LOCAL STORAGE.        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R3,20(R8)              GET POINTER TO USERID\n         MVC   USERID(8),0(R3)\n***********************************************************************\n* THE NEXT STEP IS TO FIND AN AVAILABLE TSSO SUBSYSTEM CONSOLE. TSSO  *\n* SUBSYSTEM CONSOLES ARE CHAINED OFF THE SSCONCBH CONTROL BLOCK IN THE*\n* TSSO CVT.                                                           *\n***********************************************************************\n         L     R4,SSCONSAD            GET THE SSCON CB HEADER\n         USING SSCONCBH,R4            ADDRESS IT\n         LA    R3,SSCONFIR            GET THE FIRST CONSOLE CONTROL BLK\n         USING SSCONCB,R3\n         L     R5,SSCONAMT            HOW MANY SUBSYSTEM CONSOLES ARE\n*                                     THERE.\n         LTR   R5,R5                  ARE THERE ANY ?\n         BZ    RC24                   NOPE, NO SS CONSOLES\nCHEKCONS DS    0H\n         TM    SSCONFLG,X'80'         IS THIS SS CONSOLE IN USE ?\n         BO    TRYNXTSS               YUP, TRY THE NEXT SS CONSOLE\n* THIS SUBSYSTEM CONSOLE IS NOT IN USE... CHECK OUT IF IT IS AVAILABLE\n* FOR AVERAGE USERS...\n         TM    SSCONFLG,X'40'         IS THIS SS CONSOLE DEDICATED\n*                                     TO TSSO ?\n         BNO   ALLOCONS               NO, THIS CONSOLE IS FREE TO ALLOC\n***********************************************************************\n* HERE, WE HAVE OURSELVES A SUBSYSTEM CONSOLE THAT WE CAN USE ONLY FOR*\n* TSSO. LETS CHECK IF WE ARE INDEED TSSO                              *\n***********************************************************************\n         L     R4,X'224'              GET ASCB ADDRESS\n         C     R4,TSSOASCB            ARE WE TSSO ?\n         BE    ALLOCONS               YES.. OK TO ALLOCATE CONSOLE\n         B     TRYNXTSS\nTRYNXTSS DS    0H\n***********************************************************************\n* HERE, WE HAVE FOUND THE CONSOLE TO BE BUSY... WE WILL GO AND TRY\n* THE NEXT SUBSYSTEM CONSOLE.\n***********************************************************************\n         LA    R3,SSCONCBL(R3)        TRY NEXT ENTRY\n         LTR   R3,R3                  IS THERE A NEXT ENTRY ?\n         BZ    RC24                   NO, BAD NEWS- ALL CONSOLES BUSY\n         BCT   R5,CHEKCONS\n         B     RC24\nALLOCONS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE HAVE DETERMINED THAT A SUBSYSTEM CONSOLE IS    *\n* AVAILABLE.                                                          *\n***********************************************************************\n         MODESET KEY=ZERO             SINCE THE SSCONCB IS FETCH PROT.\n         ST    R3,SSCONENT            SUBSYSTEM CONSOLE ENTRY WE ARE\n*                                     USING\n         OI    SSCONFLG,X'80'         MARK THE CONSOLE AS ALLOCATED\n         MVC   SSCONUID(8),USERID\n         DROP  R4\n***********************************************************************\n* NEXT, WE ALLOCATE THE OSCMD INTERFACE CONTROL BLOCK. THIS BLOCK IS  *\n* THE PRIMARY INTERFACE BETWEEN TSSOPCMD AND TSSOSS09.                *\n***********************************************************************\n         L     R2,=F'40000'\n         GETMAIN RC,LV=(R2),SP=241\n         LTR   R15,R15\n         BNZ   RC28                   STORAGE NOT AVAILABLE\n         ST    R1,ICBADDR             REMEMBER ADDRESS OF ICB\n         ST    R1,SSCONICB\n***********************************************************************\n* BECAUSE AN ADDRESS SPACE MAY BE CANCELLED WHILE WAITING FOR TSSO    *\n* SERVICES, WE MUST PROVIDE AN ESTAE ROUTINE TO RECOVER...            *\n***********************************************************************\n         L     R6,=V(TSSOPREC)\n         LTR   R6,R6              SAVE ENTRY POINT\n         BZ    BADESTAE\n*\n         ESTAE (R6),TERM=YES,PARAM=(R3),MF=(E,OPESTAED)\n*\n         LTR   R15,R15\n         BNZ   BADESTAE\n         B     OKESTAE\nBADESTAE DS    0H\n         B     RC36\nOKESTAE  DS    0H\n***********************************************************************\n* THE SSCONCB HAS BEEN PREPARED FOR MESSAGE INTERCEPTION. NOW, ME MUST*\n* INITIALIZE THE OSCMD INTERFACE CONTROL BLOCK.                       *\n*                                                                     *\n***********************************************************************\n         L     R7,SSCONICB            ADDRESS THE OSCMD INTERFACE\n*                                     CONTROL BLOCK\n         USING OSCMDICB,R7\n         XC    OSCMDECB(4),OSCMDECB\n         XC    OSCMDFLG(4),OSCMDFLG\n*\n         LA    R8,OSCMDBUF            GET ADDRESS OF OSCMDBUF\n         ST    R8,OSCMDNEX            THIS IS THE NEXT PLACE TO PUT\n*                                     A TRAPPED MVS MESSAGE\n         L     R8,X'224'              GET ASCB OF THIS ADDRESS SPACE\n         ST    R8,OSCMDACB            AND PUT IT AWAY...\n         XC    OSCMDCNT(4),OSCMDCNT   ZERO OUT THE COMMAND COUNT\n*\n         LA    R8,OSCMDBUF\n         LA    R1,199\nBLNKLOOP DS    0H                 BLANK OUT THE\n         MVI   0(R8),C' '         BUFFERS IN THE OSCMD\n         MVC   1(149,R8),0(R8)    INTERFACE CONTROL\n         LA    R8,150(R8)             BLOCK\n         BCT   R1,BLNKLOOP\n*\n         L     R8,MAXLINES            GET MAXIMUM NUMBER OF LINES\n         ST    R8,OSCMDMAX\n*\n***********************************************************************\n* THE NEXT STEP IS TO COPY THE AUTHORIZATION BITS FROM THE INVOKER TO *\n* THE TSSO SUBSYSTEM CONSOLE.                                         *\n***********************************************************************\n         L     R8,SSCONAUT            GET ADDRESS OF UCMAUTH\n         MVC   0(1,R8),AUTHBYTE       COPY THE AUTHORIZTION BYTE.\n         TM    AUTHBYTE,X'01'         PSEUDO MASTER AUTHORITY DESIRED?\n         BNO   NOPSEUDO               NO - SKIP IT\n         OI    2(R8),X'08'            SET PSEUDO MASTER FLAG.\n         B     PSPSEUDO               GO DO OTHER STUFF\nNOPSEUDO DS    0H\n         NI    2(R8),255-X'08'        RESET MASTER AUTH BIT\n         B     PSPSEUDO               AND TO DO OTHER STUFF\nPSPSEUDO DS    0H\n***********************************************************************\n* ALL IS IN READINESS. NOW WE MUST ISSUE THE STIMER, AND GO TO SLEEP, *\n* AWAITING THE MVS RESPONSE TO OUR COMMANDS.                          *\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=WAITTIME\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. WE WILL THEN   *\n* PROCESS THE BUFFER(S) CREATED BY TSSOSS09. IF THE ECB IS POSTED     *\n* DIRECTLY BY TSSOSS09, WE WILL WAKE UP, AND IMMEDIATELY CANCEL THE   *\n* STIMER. EITHER WAY, WE WILL PROCESS THE RESULTS OF THE BUFFER. NOTE *\n* THAT WE EXPECT TO BE POSTED FROM TSSOSS09 IN THE CASE OF A MULTI    *\n* LINE DISPLAY COMMAND, AND FROM THE STIMER EXIT IN THE CASE OF A JES2*\n* OR OTHER SUBSYSTEM COMMAND.                                         *\n***********************************************************************\n         XC    OSCMDECB(4),OSCMDECB   NULL OUT OSCMDECB\n         XC    STIMRECB(4),STIMRECB   NULL OUT STIMRECB\n         LA    R2,OSCMDECB            GET ADDRESS OF SS09ECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n*\n         MODESET MODE=SUP             GET POWER\n         LA    R1,MVSCMD              POINT TO THE MVS COMMAND\n         L     R3,SSCONENT            GET SS CON ENTRY\n         USING SSCONCB,R3\n         L     R0,SSCONNUM            GET THE SUBSYSTEM CONSOLE\n         OI    SSCONFLG,X'20'         ** START INTERCEPTING COMMANDS **\n*                                     INTERFACE CONTROL BLOCK.\n         SVC   34                     ** BANG !! **\n*\n         WAIT  ECBLIST=LISTECBS\n*\n         NI    SSCONFLG,255-X'20'     TURN OFF MESSAGE INTERCEPT FLAG\n         DROP  R3\n*\n         MODESET MODE=PROB\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM COMMTASK VIA XMEM-POST OR THROUGH  *\n* OUR STIMER EXIT ROUTINE. IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE XMEM-POST, WE SHOULD CANCEL THE STIMER    *\n***********************************************************************\n         TM    OSCMDECB,X'40'              POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* NOW, WE GO ABOUT THE BUSINESS OF EVALUATING THE RESULTS, AND PLACING*\n* ANSWERS IN THE INVOKERS PARAMETER LIST.                             *\n*\n* NOTE THAT THE OSCMDICB IN STILL ADDRESSED BY REGISTER 7             *\n* WE WILL TAKE THE FOLLOWING STEPS...                                 *\n*                                                                     *\n* 1) COPY THE GETMAINED AREA INTO THE CALLER PROVIDED AREA            *\n*                                                                     *\n* 2) DE-ALLOCATE THE SUBSYSTEM CONSOLE                                *\n*                                                                     *\n* 3) FREE THE ALLOCATED CSA                                           *\n*                                                                     *\n* 4) RETURN                                                           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCOPYBUF  DS    0H\n         L     R8,TSSOPPRM\n         L     R2,24(R8)              GET ADDRESS OF 40K BUFFER IN\n*                                     CALLERS REGION.\n         MVC   0(4,R2),OSCMDCNT       COPY THE COUNT FIELD\n         LA    R2,4(R2)\n         L     R3,=F'30000'           LENGTH\n         LA    R4,OSCMDBUF            ADDRESS OF OSCMD BUFFERS\n         LR    R5,R3                  SAME LENGTH\n         MVCL  R2,R4                  ** MOVE IT **\n*\n         FREEMAIN R,LV=40000,A=(R7),SP=241   *FREE CSA *\n*\n***********************************************************************\n* NOW - TO DEALLOCATE THE SUBSYSTEM CONSOLE.                          *\n*                                                                     *\n***********************************************************************\n         L     R3,SSCONENT\n         USING SSCONCB,R3\n         NI    SSCONFLG,255-X'80'    TURN OFF \"IN USE\" FLAG\n         XC    SSCONICB(4),SSCONICB  ZERO OUT THE ICB POINTER\n         MVC   SSCONUID(8),=CL8' '   BLANK OUT THE USER ID\n         DROP  R3\n*\n         ESTAE 0\n*\n         MODESET KEY=NZERO\n         B     RC0\nRC0      DS    0H\n         MVC   RETCODE(2),=H'0'      RETURN CODE 0\n         B     ENDPROG\n*\nRC4      DS    0H\n         MVC   RETCODE(2),=H'4'      RETURN CODE 4\n         B     ENDPROG               NOT AUTHORIZED\n*\nRC8      DS    0H\n         MVC   RETCODE(2),=H'8'      RETURN CODE 8\n         B     ENDPROG               MVS COMMAND IS INVALID\n*\nRC12     DS    0H\n         MVC   RETCODE(2),=H'12'     RETURN CODE 12\n         B     ENDPROG               TIME PARM INVALID\n*\nRC16     DS    0H\n         MVC   RETCODE(2),=H'16'     RETURN CODE 16\n         B     ENDPROG               LINES PARM INVALID\n*\nRC20     DS    0H\n         MVC   RETCODE(2),=H'20'     RETURN CODE 20\n         B     ENDPROG               AUTHORIZATION PARM INVALID\n*\nRC24     DS    0H\n         MVC   RETCODE(2),=H'24'     RETURN CODE 24\n         B     ENDPROG               ALL SUBSYSTEM CONSOLES BUSY\n*\nRC28     DS    0H\n         MVC   RETCODE(2),=H'28'     RETURN CODE 28\n         B     ENDPROG               STORAGE NOT AVAILABLE\n*\nRC32     DS    0H\n         MVC   RETCODE(2),=H'32'     RETURN CODE 32\n         B     ENDPROG               TSSO IS BLOWN AWAY\n*\nRC36     DS    0H\n         MVC   RETCODE(2),=H'36'     RETURN CODE 36\n         B     ENDPROG\n*\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nSTIMEREX DS    0H\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSCMD DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSCMD DSECT AREA\n         USING OSCMDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n         POP   USING               Restore USING status         EEJ1102\n*\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\nSTIMRPRE DS    0D\n         PUSH  USING                                               RPS\n         DROP  R12                                                 RPS\n         USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nSTIMER_CODEL   EQU  *-STIMRPRE   LENGTH OF CODE                   RPS\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n         DROP  R15                                                 RPS\n         POP   USING                                               RPS\n*\n*\nESTAEC   ESTAE 0,MF=L\nESTAECE  EQU   *\n*\nOSCMDATD DSECT\n***********************************************************************\n* WORK AREA FOR TSSOPCMD.                                             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nOSWKAREA DS    CL200\n*\nSTIMERD  DS    0D\n         DS    CL(STIMER_CODEL)   LENGTH OF CODE COPIED HERE       RPS\nR15SAVED DS    A\nR1SAVED  DS    A\nSTIMREAL DS    A\nSTIMPARM DS    F\n\n*\n***********************************************************************\n* THE FOLLOWING SECTION OUR VARIABLES THAT TSSOPCMD NEEDS, PRIMARILY  *\n* TO ACCESS THE CALLERS PARAMETER LIST.                               *\n*                                                                     *\n***********************************************************************\nMVSCMD   DS    0D\n         DC    H'0',H'0'      LENGTH,GARBAGE\n         DC    CL255' '       ACTUAL COMMAND\n*\nTSSOPPRM DS    F              ADDRESS OF THE PARAMETER LIST\n*\nSSCONENT DS    F              ADDRESS OF THE SSCONCB FOR THIS RUN OF\n*                             TSSOPCMD\nWAITTIME DS    F              MAXIMUM WAIT TIME FOR THE MVS COMMAND\n*\nMAXLINES DS    F              MAXIMUM NUMBER OF LINES TO GET BACK FOR\n*                             OUTPUT.\nAUTHBYTE DS    H              AUTHORIZATION FOR THE MVS COMMAND TO BE\n*                             ISSUED.\n*\nUSERID   DS    CL8            USER IDENTIFER (SUPPLIED BY CALLER OF\n*                             TSSOPCMD.\n*\nICBADDR  DS    F              ADDRESS OF ICB.\nRETCODE  DS    H              RETURN CODE TO GIVE TO CALLER\n***********************************************************************\n* THE FOLLOWING SECTION DENOTES THE ECB LIST THAT TSSOPCMD WILL WAIT  *\n* ON                                                                  *\n***********************************************************************\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSCMDECB\n         DC    X'80'\n         DC    A(0)\n*\nSS09ECB  DS    F\nSTIMRECB DS    F\n*\nOPESTAED ESTAE 0,MF=L\n         SSCONCBH\n         SSCONCB\n         TSSOCVT\n         COPY  TSSODATD\n         OSCMDICB\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\nUCM      DSECT\n         IEECUCM\n         END   TSSOPCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOPCMD(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(TSSOPREC)'\n PUNCH ' ENTRY    TSSOPCMD'\n PUNCH ' NAME     TSSOPCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOPREC": {"ttr": 38659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x009\\x009\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "TSSO403"}, "text": "TSSOPREC CSECT\n         EQUATES\n**********************************************************************\n* THIS MODULE IS THE ESTAE ROUTINE FOR TSSOPCMD. ITS PURPOSE IS TO\n* FREE THE RESOURCES OBTAINED BY TSSOPCMD ON BEHALF OF A GIVEN ADDRESS\n* SPACE. THE RESOURCES FREED ARE\n* 1) THE TSSO SUBSYSTEM CONSOLE.\n* 2) THE 40K OF CSA STORAGE IT OBTAINED.\n**********************************************************************\n*\n         LR    R12,R15\n         USING TSSOPREC,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R7,R14           SAVE RETURN POINT\n         CH    R0,=H'12'\n         BE    NOSDWA\n         LR    R9,R1            SAVE ADDRESS OF THE SDWA.\n         USING SDWA,R9\n         L     R3,SDWAPARM      OBTAIN PARAMETER. THIS IS THE\n*                               SSCON ENTRY FOR THE FAILED TASK\n         USING SSCONCB,R3\n         WTO   'TSSE999S TSSOPCMD ESTAE IS IN CONTROL',ROUTCDE=(11)\n         L     R4,SSCONICB      GET THE OSCMD ICB FOR THE ENTRY\n         L     R2,=F'40000'\n         FREEMAIN R,LV=(R2),A=(R4),SP=241   *FREE CSA *\n*\n***********************************************************************\n* NOW - TO DEALLOCATE THE SUBSYSTEM CONSOLE.                          *\n*                                                                     *\n***********************************************************************\n         NI    SSCONFLG,255-X'80'    TURN OFF \"IN USE\" FLAG\n         XC    SSCONICB(4),SSCONICB  ZERO OUT THE ICB POINTER\n         MVC   SSCONUID(8),=CL8' '   BLANK OUT THE USER ID\n         DROP  R3\n         SETRP WKAREA=(R9),DUMP=YES,RC=0\n         BR    R7\n*\nNOSDWA   DS    0H\n         XR    R15,R15\n         BR    R7\n*\n         IHASDWA\n         TSSOCVT\n         IEFJSCVT\n         IEFJESCT\n         CVT  DSECT=YES\n         SSCONCB\n         SSCONCBH\n         OSCMDICB\n         END  TSSOPREC\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOPREC(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    TSSOPREC'\n PUNCH ' NAME     TSSOPREC(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOPROC": {"ttr": 38661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00D\\x00D\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "TSSO403"}, "text": "//TSSO PROC\n//*********************************************************************\n//* A SUBSYSTEM STARTED TASK IS JUST LIKE ANY OTHER STARTED TASK, WITH*\n//* TWO EXCEPTIONS. THEY ARE:                                         *\n//*                                                                   *\n//* 1) ALL DATASET NAMES MUST BE CATALOGUED IN THE MASTER CATALOG.    *\n//*                                                                   *\n//* 2) THE PROC MUST BE LOCATED IN SYS1.PROCLIB. THIS IS TRUE IF YOU  *\n//*    DO NOT SPECIFY THE SUB= PARAMETER ON THE START COMMAND, TO LET *\n//*    JES START TSSO.                                                *\n//*********************************************************************\n//TSSO EXEC PGM=TSSO,REGION=3000K,TIME=50,DYNAMNBR=20\n//*********************************************************************\n//* THE PGM NAME IS TSSO, THE REGION IS ARBITRARY, THE TIME PARM      *\n//* IS REQUIRED FOR STARTED TASKS, AND SHOULD BE SET FAIRLY HIGH, SO  *\n//* TSSO DOES NOT 322 OUT, AND THE DYNAMNBR PARM IS THE NUMBER OF     *\n//* DYNAMICALLY ALLOCATED DATASETS THAT TSSO WILL HAVE AT ONE TIME    *\n//*\n//*********************************************************************\n//STEPLIB  DD  DSN=SYS1.TSSOLOAD,DISP=SHR\n//*********************************************************************\n//* ITS EASIER TO RUN THE TSSO SUBSYSTEM OUT OF A STEPLIB, THEN THE   *\n//* LINKLIST. ANY TSO COMMANDS THAT YOU WANT TO MAKE GENERALLY        *\n//* APPLICABLE SHOULD BE MOVED TO A SYSTEM COMMAND LIBRARY.           *\n//*********************************************************************\n//*\n//SYSPROC  DD  DSN=SYS1.TSSOPROC,DISP=SHR\n//*********************************************************************\n//* SINCE THE NICEST PART OF TSSO IS THE OPERATOR PRODUCTIVITY        *\n//* GAINED THROUGH CLISTS, IS PROBABLY BENEFICIAL TO SET UP A SEPARATE*\n//* CLIST LIBRARY. YOU MAY WANT TO CONCATENATE YOUR SYSTEMS CLIST     *\n//* LIBRARY IN BACK OF THIS ONE.\n//*********************************************************************\n//*\n//SYSUADS  DD  DSN=SYS1.UADS,DISP=SHR\n//*********************************************************************\n//* ACTUALLY, TSO WILL DYNAMICALLY ALLOCATE UADS WHEN RUNNING IN BATCH*\n//* IF RACF IS INSTALLED. THIS ALLOCATION STOPS TSO FROM DOING IT     *\n//* HIMSELF, AND HOPEFULLY SPEEDS THINGS UP A LITTLE.                 *\n//*********************************************************************\n//*\n//SYSTSIN  DD  DUMMY,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//*********************************************************************\n//* TSSO DOES NOT USE THE SYSTSIN DATASET, BUT TSO WILL TRY TO GET    *\n//* COMMANDS FROM HERE. TSSO PASSES COMMANDS TO TSO AND DOESNT REQUIRE*\n//* SYSTSIN.\n//*********************************************************************\n//*\n//SYSTSPRT DD  UNIT=VIO,SPACE=(CYL,2),\n//         DCB=(RECFM=VBA,LRECL=137,BLKSIZE=1370,DSORG=PS)\n//*********************************************************************\n//* W A R N I N G          W A R N I N G        W A R N I N G         *\n//*\n//* DO NOT CHANGE THE LRECL AND BLOCKSIZE OF THE SYSTSPRT DATASET.    *\n//*\n//* W A R N I N G          W A R N I N G        W A R N I N G         *\n//*********************************************************************\n//*\n//IDCAMSDD DD UNIT=VIO,SPACE=(CYL,1),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=6400,DSORG=PS)\n//IDCOUT   DD UNIT=VIO,SPACE=(CYL,1),\n//         DCB=(RECFM=VBA,LRECL=125,BLKSIZE=625,DSORG=PS)\n//*********************************************************************\n//* LASTLY, TSSO DOES NOT USE THE IDCAMSDD AND IDCOUT DD STATEMENTS   *\n//* BUT IF YOU TAKE ADVANTAGE OF THE CACHE COMMAND, IT REQUIRES BOTH  *\n//* THESE DD STATEMENTS TO BE ALLOCATED. DO NOT CHANGE THE LRECL OF   *\n//* OF THESE DATASETS EITHER.                                         *\n//*********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSORATH": {"ttr": 38663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x08\\x01\\x026\\x1f\\x01\\x026\\x1f\\x14G\\x00v\\x00v\\x00\\x00\\xc3\\xe3\\xc5\\xc3\\xf0\\xf0\\xf4@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-12-27T00:00:00", "modifydate": "2002-12-27T14:47:08", "lines": 118, "newlines": 118, "modlines": 0, "user": "CTEC004"}, "text": "        TITLE  'T S S O   R A C F   AUTHORIZATION CHECKING PROCESSING'\nTSSORATH CSECT\n***********************************************************************\n* THIS MODULE WILL CALL RACF TO CHECK IF THE USER IS AUTHORIZED TO    *\n* EXECUTE THE COMMAND.  THIS MODULES PROCESSING IS TO BE USED TO      *\n* REPLACE THE CHECKING OF THE UADS USERDATA FIELD FOR COMMAND         *\n* AUTHORIZATION.                                                      *\n*                                                                     *\n* PARAMETERS PASSED:                                                  *\n*   NONE                                                              *\n*                                                                     *\n*                                                                     *\n*    RETURN CODES:                                                    *\n*                                                                     *\n*    R15 = 0 : USER AUTHORIZED                                        *\n*    R15 = 4 : FACILITY CLASS PROFILE NOT FOUND                       *\n*    R15 = 8 : USER NOT AUTHORIZED                                    *\n*                                                                     *\n* THE MODULE WILL ISSUE ITS OWN MESSAGES FOR FAILURE REASONS....      *\n*                                                                     *\n*                                                                     *\n* MODULE HISTORY:                                                     *\n*    DEC 2002 PVW:  INITIALLY CREATED                                 *\n*                                                                     *\n* NOTES:                                                              *\n*                                                                     *\n*    THIS MODULE SHOULD WORK FOR ANY SECURITY SYSTEM THAT CLAIMS TO   *\n*    SUPPORT THE SAF INTERFACE.                                       *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSORATH,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=2048         GET STORAGE FOR A LOCAL\n         LR    R11,R1             DATA AREA\n         USING TSSORDAT,R11       AND TELL ASSEMBLER\n*\n         MVC   RACMACRO(RACLEN),RACTEMP\n         LA    R9,ENTITY\n*\n         RACROUTE WORKA=RACWORK,                                       X\n               REQUEST=AUTH,                                           X\n               ENTITY=((R9)),                                          X\n               ATTR=READ,          CHECK FOR READ ACCESS               X\n               RELEASE=1.9,        USE RACF 1.9 EXPANSION              X\n               MSGSUPP=YES,        SUPPRESS ICH408I MESSAGES           X\n               LOG=ASIS,           LOG AS DEFINED IN RESOURCE CLASS    X\n               MF=(E,RACMACRO)\n         ST    R15,RETCODE\n         C     R15,=F'8'\n         BNH   ENDPROG\nBADRC    DS    0H\n         LA    R10,WORKAREA\n         LR    R1,R15\n         CALL  JCECVTBH\n         MVC   ERRMSG(40),=CL40'SAF ERROR -    RC IS XXXXXXXX'\n         STCM  R0,B'1111',ERRMSG+21\n         STCM  R1,B'1111',ERRMSG+25\n*        B     WTOMSG\nENDPROG  DS    0H\n         L     R8,RETCODE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\n*\n*\n*\nENTITY   DC    CL39'TSSO.CMD.AUTH'\nRACTEMP  RACROUTE REQUEST=AUTH,                                        X\n               CLASS='FACILITY',                                       X\n               RELEASE=1.9,                                            X\n               MF=L\nRACLEN   EQU   *-RACTEMP           LENGTH OF RACROUTE MACRO EXPANSION\n*\n*\n*\n*\n***********************************************************************\n* TSSORATH ONLY DATA AREA.                                            *\n*                                                                     *\n***********************************************************************\nTSSORDAT DSECT\nWORKAREA DS    CL512\nCONSOLE  DS    F\nRACUSER  DS    CL9          USERID FOR RACINIT.\nRACPASS  DS    CL9          PASSWORD FOR RACINIT.\nRETCODE  DS    F\nACEEADDR DS    F\nERRMSG   DS    CL40\n*\nRACWORK  DS    CL512\nRACMACRO EQU    *\n         ORG    *+RACLEN\n*\n*\n         END   TSSORATH\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSORATH(''TSSO V 4.3.0  &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSORATH'\n PUNCH ' NAME     TSSORATH(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSSOSECR": {"ttr": 38666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00B\\x00\\x98\\x06\\x8f\\x01\\x022\\x0f\\x177\\x00\"\\x00\\x19\\x00\\x11\\xc5\\xc4\\xd1\\xe7\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1998-03-09T00:00:00", "modifydate": "2002-11-16T17:37:42", "lines": 34, "newlines": 25, "modlines": 17, "user": "EDJXADM"}, "text": "         MACRO\n         TSSOSECR\n***********************************************************************\n* THIS IS THE MACRO TO DEFINE THE TSSO SECURITY ARRAY. THE TABLE,     *\n* POINTED TO FROM THE SECARRAY FIELD OF THE TSSO DATA AREA, IS 640    *\n* BYTES LONG, WITH 20 ENTRIES CONSISTING OF 32 BYTES EACH. THIS MACRO *\n* MAPS THOSE ENTRIES.                                                 *\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* Change Activity:                                             *EEJ1102\n*                                                              *EEJ1102\n*   NOV 2002 EEJ  Support MCS extended consoles                *EEJ1102\n*                                                              *EEJ1102\n***********************************************************************\nTSSOSECR DSECT\nSECENTRY DS    0H\nSECFLAGS DS    0XL2                FLAG BYTES                   EEJ1102\nSECFLAG1 DS     XL1                Flag byte                    EEJ1102\nSEC1USED EQU     X'80'             - Entry is in use            EEJ1102\nSECFLAG2 DS     XL1                Flag byte                    EEJ1102\n         DS    XL2                 Reserved for future use      EEJ1102\nSECACEE  DS    A                   CONTROL BLOCK DESCRIBING SECURITY\n*                                  INFORMATION\nSECUSER  DS    CL8                 USERID\nSECRDATE DS    F                   DATE OF LAST COMMAND\nSECRTIME DS    F                   TIME OF LAST COMMAND\nSECRCNID DS    F                   Console ID                   EEJ1102\nSECRCNAM DS    CL8                 Console name                 EEJ1102\nSECRAUTH DS    XL2                 Console authorization bits   EEJ1102\nSECRESVD DS    XL2                 Reserved                     EEJ1102\nSECREND  DS    0H\nSECRLGNT EQU   SECREND-SECENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSSOSS09": {"ttr": 38668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00S\\x01\\t)_\\x01\\x10\\x01\\x9f\\x072\\x05\\xe1\\x05\\xdf\\x00\\x04\\xc4\\xd4\\xc9\\xe3\\xc3\\xc8\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2009-10-22T00:00:00", "modifydate": "2010-01-19T07:32:53", "lines": 1505, "newlines": 1503, "modlines": 4, "user": "DMITCHE"}, "text": "TSSOSS09 TITLE 'TSSO - ROUTINE TO PROCESS SUB SYSTEM FUNCTION 09'\nTSSOSS09 CSECT\n************************************************************\n*\n*        PDSDOC *SPRECHER ENERGIE VERSION OF TSSOSS09 WITH ML WTO FIXED\n*\n* THIS IS THE ENTRY POINT FOR THE TSSO AUTOMATED OPERATIONS FACILITY\n* WTO AND WTOR INTERCEPT ROUTINE. THE SUBSYSTEM INTERFACE CODE 9\n* PROVIDES THE FACILITY FOR SUBSYSTEMS TO INTERCEPT ALL WTO AND WTOR\n* REQUESTS, AND TAKE ACTION. THE SPECIFIC ACTIONS THAT TSSO/AOF WILL\n* TAKE IS DETERMINED BY A TABLE, LOADED AT SUBSYSTEM (TSSO)\n* INITIALIZATION TIME.\n*\n* THE FORMAT OF THE TABLE IS COMPLEX, AND BEST DOCUMENTED IN THE\n* DISPAOF TSSO COMMAND, INCLUDED WITH TSSO.\n*\n* SPECIFIC ACTIONS ARE:\n* OSCMD - ISSUE AN OPERATING SYSTEM, JES OR TSSO COMMAND IS RESPONSE\n*         TO THE MESSAGE\n*\n* OSCMDT - SIMULATE THE ISSUANCE OF THE COMMAND, BY WTO INSTEAD\n*          OF WTOR THE MESSAGE.\n*\n* HILITE - HILIGHT THE MESSAGE BY TURNING ON THE WQEDCMA BIT.\n*\n* SUPPRESS- SUPPRESS THE MESSAGE.\n*\n*    TSSO (VERSION 4.1) PROVIDES THE FACILITY FOR TESTING CERTAIN\n* (ACTUALLY, ANY) FIELD IN THE MESSAGE BY WORD OR SUBSTRING CONTENT\n* BEFORE ACTUALLY DECIDING TO PERFORM THE ACTION SPECIFIED.\n*\n*    TSSO (VERSION 4.1) WILL SCAN THE *ENTIRE* TABLE FOR THE\n* MESSAGE IDENTIFIER, EVEN WHEN ENCOUNTERED, THUS MULTIPLE ACTIONS\n* MAY BE SPECIFIED FOR THE SAME MESSAGE, UNDER DIFFERENT TEST\n* CONDITIONS. THE USER IS URGED TO READ NOT ONLY THE TSSO SOURCE CODE,\n* BUT THE TSSO SYSTEMS PROGRAMMING REFERENCE GUIDE, FOR DETAILS\n* ON TSSO/AOF USAGE.\n*\n***********************************************************************\n* TSSO VERSION 4.2 PROVIDES THE UNPARALLED ABILITY TO ISSUE MVS       *\n* OPERATOR COMMANDS FROM A TSSO CLIST, AND GET THE RESPONSE BACK TO   *\n* THE CLIST. THIS IS ACCOMPLISHED THROUGH COMMUNICATION BETWEEN THE   *\n* OSCMD COMMAND, AND THIS MODULE. THIS MODULE WILL CHECK IF MESSAGES  *\n* ARE TO BE INTERCEPTED. IF YES, IT WILL INTERCEPT ALL MESSAGES       *\n* DESTINED TO THE CONSOLE OBTAINED BY TSSO AS A SUBSYSTEM CONSOLE, AND*\n* STORE THEM IN A GLOBAL BUFFER PROVIDED BY THE OSCMD COMMAND.        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TSSO VERSION 4.3 ADDS THE FOLLOWING FUNCTION TO THIS MODULE:        *\n*                                                                     *\n* 1) SUPPORT FOR MULTIPLE SUBSYSTEM CONSOLES.                         *\n*                                                                     *\n* 2) SUPPORT FOR ACTION=POST IN THE AOF TABLES.                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n* NOTE: LAST MSGID IS 209.                                            *\n*                                        MARC.\n***********************************************************************\n*                                                                     *\n* 12JUL92 CART1 MAKE SOME CHANGES FOR MLWTO                           *\n* 19AUG92 CART1 ON TEST BLEW UP IEFJRASP LEADING TO IPL. ALTER MATCH  *\n*               FAIL CODE TO EXIT IMMEDIATELY.                   *SEAG*\n* 24AUG92 CART1 RECODE 'SEDOLINE' TO AVOID THE 0C4'S. THIS ALLOWS US  *\n*               TO USE IT IN PARSING THE TESTS TO RESTRICT PROCESSING *\n*               TO ONE MINOR WQE. ALSO REDUCE OVERHEAD BY TESTING FOR *\n*               TABLE ENTRY NAME AND STOP IF ENTRY MATCHED WITH NO    *\n*               ENTRY NAME (DEFAULT ENTR..).                          *\n* 26AUG92 CART1 RECODE 'SEDOLINE' FOR USE IN TESTS ONLY, NOT TEXT.    *\n*               THE REASON IS THAT THE COMMS TASK ONLY GIVES US A CSA *\n*               COPY OF THE WQE WHICH IS IN THE COMMS TASK ADDRESS    *\n*               SPACE. THUS WE CANNOT RUN THE LIST OF WQE'S. BY USING *\n*               DATA IN THE TEST CONTROL BLOCK WE CAN COUNT THE NUMBER*\n*               OF TIMES WE ARE CALLED FOR THIS MAJOR WQE.            *\n* 09SEP92 CART1 ADD 'ACTION=NONE' TO PROVIDE A 'STOP' FACILITY TO     *\n*               REDUCE RUNNING COSTS.                                 *\n*                                                                     *\n* 15OCT92  GLA  INCORPORATE NECESSARY FIXES FROM 4.2                  *\n*                 A. FIX BUG IN LOWLIGHT ROUTINE. CAUSES EVENTUAL ACT *\n*                    MESSAGES NOT TO BE LOWLIGHTED.                   *\n*                 B. FIX BUG IN AOF TABLE PROCESSING FOR MESSAGE.     *\n*                    ORIGINAL CODE WAS NOT CLEARING THE OUTPUT TOKEN  *\n*                    TABLE FULLY. ANY ATTEMPT TO ACCESS WORDS 17      *\n*                    TO 20 IN A MESSAGE WOULD RESULT IN GARBAGE.      *\n*                                                                     *\n* 20OCT92  GLA  INSTALL NEW DSECT FOR AOF TABLES                      *\n*                                                                     *\n* 30OCT92  GLA -USE BINARY SEARCH TABLE INDEX TO AOF TABLE.           *\n*              -GO BACK TO ORIGINAL PROCESSING OF ALL ENTRIES THAT    *\n*               MATCH ID, WITH ONE EXCEPTION, PROCESS ALL MSG=*       *\n*               ENTRIES AFTER ALL MSG=ID THAT MATCH.                  *\n*                                                                     *\n* 14SEP92 CART1 ADD CODE TO TEST FOR MPF MESSAGE SUPPRESSION. IF YOU  *\n*               MPF SUPPRESS A MESSAGE THAT IS ITS SINGLE POINT OF    *\n*               CONTROL.                                              *\n*                                                                     *\n* 14DEC92  GLA  ADD NEW PARAMETER TO TURN ABOVE FEATURE ON OR OFF.    *\n*                                                                     *\n* 30DEC96  RPS  FIXED ADDRESSABILITY ERROR WITH HLASM                 *\n*                                                                     *\n* 17SEP99  DHC  RESTORE TEST FOR ENTRY NAME TO GIVE BOOLEAN LOGIC*AGCO*\n*                                                               EEJ1102\n* NOV 2002 EEJ  Support 4-byte reply IDs                        EEJ1102\n*          DHC  Allow eXclusion testing (WX and SX)              *AGCO*\n*                                                                     *\n* 13FEB03  DHC  Tony Noyes reported MLWTO logic not working.          *\n*               Added debugging WTO's and logic to handle 2nd line of *\n*               Minor WQE.                                            *\n* 17DEC04  OSCA WMNMML2H removed at zos 1.6, logic changed to work    *\n*               without WMNMML2H     email:  Cattin@osys.ch           *\n*                                                                     *\n*  SHAZAM Update:                                                     *\n*                                                                     *\n*@DM081409 Add code to insert SYSTEM id with /I001,01/ directive      *\n*@DM011410 Correct problem processing MLWTO with TEST=((L,9)...       *\n*                                                                     *\n***********************************************************************\n*\n* REGISTER USAGE:\n*   R11: POINTS TO THE GETMAINED STORAGE AREA FOR THE LIFE OF THE\n*        ROUTINE\n*   R9 : POINTS TO THE SSOB EXTENTION FOR THE LIFE OF THE ROUTINE\n*   R8 : POINTS TO THE TSSO CVT FOR THE LIFE OF THE ROUTINE.\n*   R7 : POINTS TO THE TSSO AOF TABLE, FOR THE LIFE OF THE ROUTINE.\n*   R6 : POINTS TO THE CURRENT TEST ENTRY FOR THE LIFE OF THE ROUTINE.\n************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOSS09,R12         GET ADDRESSIBILITY\n         B      AR1\n         DC     CL8'&SYSDATE'      GET THE DATE\n         DC     CL8'&SYSTIME'      GET THE TIME\nAR1      DS     0H\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1\n         GETMAIN RC,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         LTR    R15,R15\n         BNZ    FUNC9EX3           STORAGE AVAILABLE.\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n*\n         GETMAIN RC,LV=4096         GET SOME STORAGE...\n         LTR    R15,R15\n         BNZ    GETMERR\n         LR     R11,R1\n         USING  FUN9DATA,R11\n*\n         LR     R10,R8\n         USING  SSOB,R10\n         ST     R10,SSOBADDR\n*\n         GETCVT (R8)               FIND TSSO CVT                   RPS\n         USING TSSOCVT,R8\n*\n         L     R9,SSOBINDV         POINT TO WTO EXTENSION\n         ST    R9,SSWTADDR         SAVE IT FOR FUTURE...\n         USING SSWTBGN,R9\n*\n         DROP  R10\n         MVC   POST1D(POST1CE-POST1C),POST1C\n         XC    MAJWQEAD(4),MAJWQEAD\n         XC    MINWQEAD(4),MINWQEAD\n         XC    MAJOREAD(4),MAJOREAD\n         XC    FUNC9RC(2),FUNC9RC   INIT RETURN CODE\n***********************************************************************\n* THE FIRST ORDER OF BUSINESS IS TO SEE IF MESSAGE TRAPPING IS ACTIVE *\n* FOR AN SS CONSOLE. IF SO, WE WILL QUEUE UP THE MESSAGE BASED ON THE *\n* INFORMATION OBTAINED FROM THE OSCMDICB, WHICH IS CHAINED OFF THE    *\n* SSCONCB FOR THE SPECIFIC CONSOLE.                                   *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n* THE NEXT STEP(S) CONCERN WHETHER TO INTERCEPT THIS MESSAGE. TSSO    *\n* MUST HAVE OBTAINED A SUBSYSTEM CONSOLE, AND THE INCOMING MESSAGE    *\n* MUST BE DESTINED FOR THAT SUBSYSTEM CONSOLE (IN FIELD TSSCONID).    *\n* IF EITHER OF THESE CONDITIONS ARE NOT MET, WE FORGET THIS MESSAGE.  *\n***********************************************************************\n         L     R5,SSWTWQE          ADDRESS THE WQE.\n         ST    R5,MAJWQEAD         REMEMBER THE MAJOR WQE\n*        ST    R5,WQEADDR          REMEMBER IT IN TWO PLACES\n         USING WQE,R5\n***********************************************************************\n* WE MUST DETERMINE IF ANY TSSO SUBSYSTEM CONSOLE IS CURRENTLY        *\n* INTERCEPTING MESSAGES, AND, IF THEY ARE, WHICH ONE MATCHES THIS     *\n* CONSOLE ID. LETS LOOP THROUGH THE SUBSYSTEM CONSOLES.\n***********************************************************************\n* NOTE THAT THE WQEUCMID FIELD IS IN THE SAME PLACE FOR MAJOR AND\n* NORMAL WQE'S\n***********************************************************************\n*drcics* XR    R6,R6               WIPE REGISTER             11/19/2006\n*drcics* IC    R6,WQEUCMID         PICK UP THE CONSOLE THIS  11/19/2006\n         L     R6,WQECNID          PICK UP THE CONSOLE THIS  11/19/2006\n*                                  GUY IS DESTINED FOR       11/19/2006\n         L     R7,SSCONSAD         THIS, FROM THE TSSO CVT\n         LTR   R7,R7               DO WE HAVE ONE ?\n         BZ    PART1EXT            TSSO HAS PROBLEMS...\n         USING SSCONCBH,R7\n         LA    R7,SSCONFIR         GET ADDRESS OF FIRST CONSOLE\nSSCLOOP  DS    0H\n         USING SSCONCB,R7\n         CLC   SSCONNUM(4),=XL4'0000'  END OF SSCON CHAIN\n         BE    PART1EXT\n         TM    SSCONFLG,X'20'      MESSAGE INTERCEPTION ACTIVE ?\n         BNO   SSCLOOPE            NOPE, END OF THE LOOP\n         L     R10,SSCONNUM        GET SUBSYSTEM CONSOLE ID\n         CR    R6,R10              IS IT OURS ?\n         BE    FNDSSCON            BY GOLLY, IT SURE IS...\nSSCLOOPE DS    0H\n         LA    R7,SSCONCBL(R7)\n         B     SSCLOOP\n         DROP  R5\n***********************************************************************\n* NOW WE GET THE OSCMD INTERFACE CONTROL BLOCK, AND PROCEED FROM THERE*\n*                                                                     *\n***********************************************************************\nFNDSSCON DS    0H\n         ST    R7,SSCONENT         SSCONENT IS THE ENTRY FOR THIS\n*                                  CALL TO THE SSI CODE 9\n         TM    TSSOFLG2,TSSOMON    IS THE DEBUG TURNED ON ?\n         BNO   NDEB1\n         WTO   'A TSSO SS CONSOLE ID IS NOW BEING PROCESSED'\nNDEB1    DS    0H\n         L     R7,SSCONICB         GET ADDRESS OF OSCMDICB FOR THIS\n*                                  CONSOLE\n         DROP  R7\n         LTR   R7,R7\n         BZ    NOICB               PROBLEMS...\n         USING OSCMDICB,R7\n***********************************************************************\n* WE NEED TO FIGURE OUT IF THIS IS A MAJOR WQE, A MINOR WQE, OR       *\n* A NORMAL WQE. IT COULD ALSO BE A REPLY.                             *\n***********************************************************************\n         L     R10,SSWTMIN         GET MINOR WQE ADDRESS\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    MINZIP              DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\n         ST    R10,MINWQEAD        REMEMBER MINOR WQE ADDRESS\nMINZIP   DS    0H\n         L     R10,SSWTORE         GET ORE ADDRESS.\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    OREZIP              DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         ST    R10,MAJOREAD        REMEMBER OREADDR\n*\nOREZIP   DS    0H\n*\n***********************************************************************\n* CHECK FOR A MULTI-LINE WTO.                                         *\n*                                                                     *\n***********************************************************************\n         L     R10,MINWQEAD        IS THIS A MULTI-LINE WTO ?\n         LTR   R10,R10             IF NON-ZERO, A MINOR WQE EXISTS,\n         BNZ   MLWTOWQE            SO WE GO AND PROCESS IT. OTHERWISE,\n*                                  CHECK TO SEE IF ITS THE FIRST LINE\n*                                  OF A MULTI-LINE WTO.\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   NORMWQE             NOPE, NORMAL WQE\n***********************************************************************\n* HERE, WE HAVE THE MAJOR WQE WITH MINORS TO FOLLOW. WE WILL PROCESS  *\n* THE MAJOR WQE BY QUEUEING THE RESPONSE TO OSCMD...                  *\n***********************************************************************\n         XR    R4,R4              CLEAR LEGNTH REGISTER\n         LH    R4,WMJMTXTL        GET LENGTH\n         LA    R5,WMJMTXT         GET ADDRESS OF MESSAGE\n         BAL   R14,QUEUEWQE       TELL OSCMD ABOUT IT\n         B     PART1EXT            MAJOR, WITH MINORS TO FOLLOW,\n         DROP  R10\n*\n***********************************************************************\n* PROCESS MULTI-LINE WQE'S...                                         *\n*                                                                     *\n***********************************************************************\nMLWTOWQE DS    0H\n***********************************************************************\n* AT THIS POINT, WE ARE PROCESSING ONE IN A SEQUENCE OF MINOR WQE'S.  *\n***********************************************************************\n* THERE MAY BE ZERO, ONE OR TWO MINOR WQE'S FOR EVERY INVOCATION OF   *\n* THE SUBSYSTEM INTERFACE. WE MUST CHECK FOR THESE CONDITIONS..       *\n* WE WILL QUEUE THE MINOR WQE'S IF THERE IS ROOM                      *\n***********************************************************************\n*        WTO   'TRAPPED A MULTILINE WTO'\n         L     R10,MINWQEAD        LETS DEAL WITH THE MINOR WQE\n         USING WMNM,R10\n         TM    WMNMLT1,WMNMLT1A+WMNMLT1B+WMNMLT1C   DATA ON THIS LINE ?\n         BZ    CHEKEND1            I GUESS NOT, WILL CHECK THE NEXT ONE\n         XR    R4,R4\n         IC    R4,WMNMTL1          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT1        GET ADDRESS OF PART 1\n*----    TM    WMNMML2,WMNMML2H    IS LINE 2 AVAILABLE ?         @OSCA\n*----    BNO   USELNE2                                           @OSCA\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C  Data on Line2?@OSCA\n         BNZ   USELNE2                                           @OSCA\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND1 DS    0H\n         TM    WMNMLT1,WMNMLT1D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\nUSELNE2  DS    0H\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C   DATA ON THIS LINE ?\n         BZ    CHEKEND2            I GUESS NOT, CHECK FOR END..\n         XR    R4,R4\n         IC    R4,WMNMTL2          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT2        GET ADDRESS OF PART 1\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND2 DS    0H\n         TM    WMNMLT2,WMNMLT2D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\n         DROP  R10\n*\n*\nNORMWQE  DS    0H\n***********************************************************************\n* AT THIS POINT, WE HAVE DETERMINED THAT WE ARE PROCESSING AN AVERAGE *\n* EVERY DAY RUN OF THE MILL WQE. WE WILL DETERMINE IF IT IS DESTINED  *\n* FOR THE TSSO SUBSYSTEM CONSOLE, AND IF SO, PROCESS IT.              *\n***********************************************************************\n*        WTO   'TRAPPED A NORMAL WQE'\n         LA    R4,147       (PTF1) LENGTH IS ALWAYS 147 FOR A NORMAL\n*                           (PTF1) WQE\n         L     R5,MAJWQEAD         START AT MAJOR WQE ADDRESS\n         USING WQE,R5\n         LA    R5,WQETS     (PTF1) - GET TIMESTAMP INSTEAD OF TEXT\n         DROP  R5\n         BAL   R14,QUEUEWQE        QUEUE THIS WTO...\n***********************************************************************\n* NOTE THAT WE DONT REALLY CARE ABOUT THE SUCCESS OF THE QUEUEING.    *\n***********************************************************************\n         B     PART1EXT            END OF PART 1 OF SSI RTN 9.\n*\nQUEUEWQE DS    0H\n***********************************************************************\n* WE MUST PROCESS THE MESSAGE. WE WILL PLACE THE MESSAGE TEXT IN THE  *\n* FIELD POINTED TO BY THE OSCMDICB.                                   *\n* THE QUEUEWQE ROUTINE IS CALLED AS AN INTERNAL SUBROUTINE FOR THE    *\n* PURPOSE OF QUEUEING UP THE CAPTURED MESSAGES IN THE OSCMDICB.       *\n*\n***********************************************************************\n* INPUT REGISTERS:                                                    *\n*                                                                     *\n* R5 POINTS TO THE MESSAGE TO BE QUEUED UP (WQETXT FROM EITHER MAJOR  *\n*    OR MINOR                                                         *\n* R4 CONTAINS THE LENGTH OF THE MESSAGE.                              *\n* R14 CONTAINS THE RETURN ADDRESS.                                    *\n*                                                                     *\n* OUTPUT REGISTERS: R15 = 0 : MESSAGE INSERTED OK                     *\n*                   R15 = 4 : ERROR INSERTING MESSAGE.                *\n***********************************************************************\n         L     R6,OSCMDCNT         GET COUNT OF MESSAGES\n         C     R6,OSCMDMAX         HAVE WE HIT THE MAXIMUM YET ?\n         BE    ENDQWQE4            YUP, WE WILL IGNORE THIS MESSAGE\n*                                  AND ALL SUBSEQUENT MESSAGES.\n         LA    R6,1(R6)            INCREMENT COUNT OF MESSAGES\n         ST    R6,OSCMDCNT         AND STORE BACK.\n         L     R6,OSCMDNEX         GET NEXT BUFFER LOCATION\n         BCTR  R4,0\n         EX    R4,COPYWQET         COPY THE WQETEXT\n         LA    R6,150(R6)   (PTF1) INCREMENT BUFFER COUNT NOW 150\n         ST    R6,OSCMDNEX\n         B     ENDQWQE0\n*\nCOPYWQET MVC   0(0,R6),0(R5)     COPY TEXT INTO BUFFER\n*\nENDQWQE0 DS    0H\n         LA    R15,SSWTNDSP      SET CODE FOR MESSAGE SUPPRESSION\n         STH   R15,FUNC9RC\n         XR    R15,R15\n         B     ENDQWQE\nENDQWQE4 DS    0H\n         LA    R15,4\n         B     ENDQWQE\nENDQWQE  DS    0H\n         BR    R14\n*\nPSTOSCMD DS    0H\n***********************************************************************\n* NOW, WE WILL POST THE OSCMD PROCESSOR, BECAUSE THERE ARE NO MORE    *\n* WTO'S FORTHCOMING FOR THIS COMMAND, SO THERE IS NO REASON TO WAIT   *\n* FOR THE COMMAND TO END.. OSCMD IS WAITING ON TWO ECBS, THE FIRST    *\n* BEING A STIMER FOR THE TIME IN THE WAITIME VARIABLE, THE SECOND     *\n* BEING THE OSCMDECB FIELD. WE WILL POST THIS FIELD.                  *\n***********************************************************************\n         L     R10,SSCONENT               SS CON ENTRY FOR THIS CALL\n         USING SSCONCB,R10\n         NI    SSCONFLG,255-X'20'        INDICATE NO MORE MESSAGE TRAP\n         DROP  R10\n         LA    R2,OSCMDECB\n         L     R6,OSCMDACB               GET ASCB OF CALLERS ADDRESS SP\n         POST  (R2),X'000',ASCB=(R6),ERRET=PART1EXT,MF=(E,POST1D)\n         B     PART1EXT\n*\nNOICB    DS    0H\n         WTO   'TSS9201S INVALID ICB POINTER -> RESTART TSSO',DESC=(1)\n         B     FUNC9EXT\n*\n*\nPART1EXT DS    0H\nFUN9PRT2 DS    0H\n***********************************************************************\n* THIS IS THE SECOND PART OF THE SS09 INTERCEPT ROUTINE. BASICALLY,   *\n* ITS PURPOSE IS TO INTERCEPT LINES THAT START WITH \"#.LOGON\" AND     *\n* SUBSTITUTE STUFF ON THE REST OF THE LINE WITH GIBESRISH - TO BLANK  *\n* OUT THE PASSWORD THAT WOULD HAVE BEEN ENTERED ON THE LINE...        *\n***********************************************************************\n         L     R2,SSWTMIN                  CHECK OUT MINOR WQE\n         LTR   R2,R2\n         BNZ   PART2EXT                    MINOR WQE -> EXIT.\n         L     R2,SSWTORE                  CHECK OUT OPERATOR REPLY?\n         LTR   R2,R2\n         BNZ   PART2EXT                    OPERATOR REPLY -> EXIT\n         L     R2,SSWTWQE                  GET THE MAJOR WQE\n         USING WQE,R2\n         CLC   WQETXT+2(6),=XL6'4B9396879695'   #.LOGON LOWER CASE\n         BE    SUPRLOGN\n         CLC   WQETXT+2(6),=CL6'.LOGON'     IS THIS \"#.LOGON\" ?\n         BE    SUPRLOGN                    NO - IGNORE ...\n         B     PART2EXT\nSUPRLOGN DS    0H\n         LA    R15,SSWTNDNH      SET CODE FOR MESSAGE AND LOG\n*                                SUPPRESSION\n         STH   R15,FUNC9RC       SUPPRESS THE #.LOGON COMMAND.\n*        WTO   'TSS9209I TSSO .LOGON COMMAND ECHO SUPPRESSED'\n         B     FUNC9EXT                    AND GET OUT OF HERE\n         DROP  R2\nPART2EXT DS    0H\n***********************************************************************\n* THIS IS THE END OF THE PROCESSING ROUTINE FOR THE #.LOGON INTERFACE.*\n* PART 3 OF THIS ROUTINE IS THE PROCESSING OF THE AOF TABLE.          *\n***********************************************************************\n         B     FUN9PRT3\n*\n        TITLE 'AOF PROCESSING'\nFUN9PRT3 DS    0H\n***********************************************************************\n* THIS IS PART THREE OF THE WTO/WTOR MESSAGE INTERCEPTION FUNCTIONS.  *\n* HERE, WE HANDLE THE AUTOMATED OPERATIONS FACILITY.                  *\n***********************************************************************\n         L     R7,TSSOTABL         GET ADDRESS OF TABLE.\n         LTR   R7,R7               CHECK IT OUT\n         BZ    FUNC9EXT            NO TABLE, NO WORK TO DO.\n         SPACE 1                                                14DEC92\n         TM    TSSOFLG1,TSSOSMPF   OBEY MPF SUPPRESSION         14DEC92\n         BZ    FUN9ACT             NO, HANDLE ALL MESSAGES      14DEC92\n         L     R5,SSWTWQE          PICK UP WQE ADDRESS          14DEC92\n         USING WQE,R5              ESTABLISH ADDRESSABILITY     14DEC92\n         TM    WQESUPB,WQESMPF     SUPPRESSED BY MPF?           14DEC92\n         BO    FUNC9EXT            YES, IGNORE MESSAGE          14DEC92\n         DROP  R5                  END WQE ADDRESSABILITY       14DEC92\nFUN9ACT  DS    0H\n***********************************************************************\n* IF WE GET HERE, THE TSSO/AOF COMPONENT IS ACTIVE, AND THERE IS A    *\n* (VALID) TSSO AOF TABLE. THE VALIDITY OF THE TABLE IS DETERMINED AT  *\n* TSSO STARTUP/TABLE RELOAD TIME. R7 WILL SERVE AS A BASE REGISTER    *\n* FOR THE TSSO/AOF TABLE CURRENT ENTRY\n***********************************************************************\n* INITIALIZE VARIABLES.\n***********************************************************************\n***********************************************************************\n* THE FIRST PART OF THE ROUTINE WILL ISOLATE THE MESSAGE ID, BE IT A  *\n* WTO OR WTOR, AND PRESERVE IT FOR FUTURE EXAMINATION.                *\n***********************************************************************\n         MVI   FUN9FLG,X'00'       RESET FLAG.\n         L     R5,SSWTMIN          GET MINOR WQE ADDRESS\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    MINZERO             DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\nMINZERO  DS    0H\n         L     R5,SSWTORE          GET ORE ADDRESS.\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    OREZERO             DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         USING WQE,R5              GAIN ADDRESSABILITY TO WQE\n         XR    R14,R14             Get length of reply ID       EEJ1102\n         IC    R14,WQERIDL         (same)                       EEJ1102\n         LA    R1,127-2            Compute actual string length EEJ1102\n         SR    R1,R14              (same)                       EEJ1102\n         LA    R14,WQETXT+2(R14)   Point to start of message ID EEJ1102\n         ST    R14,STRSTART        Save string starting address EEJ1102\n         MVC   TXTMSG(8),0(R14)    Copy message ID from WTOR    EEJ1102\n         B     GOTORE\nOREZERO  DS    0H\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         LA    R7,WQETXT+1         PICK UP STRING START FOR WQE\n         ST    R7,STRSTART         AND REMEMBER FOR TSSOPARS LATER\n*\n         LA    R7,WQETS            GET TIME STAMP ADDRESS FOR ACTION=\n*                                  POST\n         ST    R7,WQETSADR\n         USING WQE,R5\n         MVC   TXTMSG(8),WQETXT+1  WHY THE +1-- WHY NOT ?\n*                                  JUST SEEMS TO WORK BETTER\n         LA    R1,127              SET MAX. LENGTH\nGOTORE   DS    0H\n         ST    R1,STRLEN           SAVE LENGTH FOR LATER\n         ST    R5,WQEADDR          REMEMBER THE WQE ADDRESS\n         MVC   SYSID,WQESYSNM      SAVE SYSTEM NAME           @DM081409\n         DROP  R5                  DROP ADDRESSABILITY TO WQE\n************************************************************\n* HERE IS WHERE WE EXAMINE THE TEXT OF THE WTO TO SEE IF WE SHOUD\n* TAKE ACTION.\n* THE ADDRESS OF THE TABLE IS IN TSSOTABL, AND THE FORMAT IS DOCUMENTED\n* IN THE TSSO: LOGIC GUIDE (WELL... MAYBE SOMEDAY)\n* R6: POINTS TO CURRENT TABLE ENTRY, DURING TEST PROCESSING.\n************************************************************\n         LM    R4,R6,TSSOBSTS           SETUP FOR BSCAN CALL    30OCT92\n         LA    R2,S9BSCMP               POINT AT COMPARE COMMAND30OCT92\n         BAL   R14,BSCAN                GO DO BINARY SEARCH     30OCT92\n         B     TSTALLMG                 +0 NOT FOUND, LOOK MSG=*30OCT92\n*                                       +4 FOUND, DO ENTRIES    30OCT92\n         L     R7,0(,R7)                POINT AT FIRST AOFNTRY  30OCT92\n         B     MATCHMSG                 GO AND PROCESS A MATCH  30OCT92\nS9BSCMP  CLC   TXTMSG(8),4(R7)     **BSCAN EXED** CHECK MSG ID  30OCT92\nTSTALLMG DS    0H                                               30OCT92\n         ICM   R7,B'1111',TSSOALMS      POINT AT MSG=* ENTRIES   *AGCO*\n         BZ    PART3EXT                 IF NONE, THEN ALL DONE  30OCT92\n         OI    FUN9FLG,X'10'            INDICATE BSCAN DONE     30OCT92\n         B     MATCHMSG                 GO PROCESS ALL ENTRIES  30OCT92\n         SPACE 2                                                30OCT92\n         USING AOFNTRY,R7               SETUP DSECT\n***********************************************************************\n* TSSO/AOF HAS PERFORMED THE REQUESTED FUNCTION, HOWEVER, WE CAN NOW\n* CONTINUE TO SCAN THE TSSO/AOF TABLE, IN HOPES OF FINDING ANOTHER\n* TABLE ENTRY TO MATCH THIS MESSAGE ID.\n***********************************************************************\nGETNEXT  DS    0H                       GET THE NEXT AOF FOR MSG *AGCO*\n         TM    FUN9FLG,X'10'            DOING MSG=* PROCESSING?  *AGCO*\n         BO    RUNTABL                  YES SO DO ALL ENTRIES    *AGCO*\n         CLC   =C'ENTR',AOFENTR    WAS THERE AN ENTRY NAME?      *AGCO*\n         BE    PART3EXT            NO, REQUIRED ACTIONS DONE     *AGCO*\n*                                                                *AGCO*\nRUNTABL  DS    0H                       RUN THE REST OF TABLE    *AGCO*\n         ICM   R7,15,AOFBNXT            NEXT AOF IN BSCAN CHAIN 30OCT92\n         BNZ   MATCHMSG                 HAVE SAME MESSAGE ID    30OCT92\n         TM    FUN9FLG,X'10'            DONE MSG=* PROCESSING?? 30OCT92\n         BZ    TSTALLMG                 NO, TRY THE MSG=* TYPE  30OCT92\n         B     PART3EXT                 ALL DONE WITH MSG=*     30OCT92\n         EJECT                                                  30OCT92\nMATCHMSG DS    0H\n         ST    R7,CURTABAD              SAVE CURRENT ENTRY ADDR\n***********************************************************************\n* WE COME HERE WHEN A MATCH HAS BEEN FOUND IN THE MESSAGE ID SECTION  *\n* OF A TSSO TABLE ENTRY. THE PROCESSING CONTINUES WITH THE PERFORMING *\n* OF ANY TESTS THAT NEEDS TO BE ISSUED. IF ALL TESTS ARE MATCHED, THAN*\n* BRANCH TO THE PERFACT ROUTINE, WHICH WILL PERFORM ANY ACTIONS       *\n* REQUIRED. IF THE TESTS ARE NOT MET, CONTINUE SEARCHING THE TABLE AS *\n* THERE MAY BE ANOTHER MATCH.\n***********************************************************************\n         L     R6,AOFTESTP               LOAD UP TEST ENTRY.\n         USING ATSNTRY,R6\nTESTLOOP DS    0H                        LOOP FOR TEST ENTRIES\n         LTR   R6,R6                     ANY MORE TEST ENTRIES ?\n         BZ    TESTSUCC                  NOPE, ALL TESTS MUSTBE OK\n         L     R1,ATSWORD          LOAD SUBSTR OR WORD NUMBER\n         ST    R1,WORD1            AND REMEMBER IT.\n         L     R1,ATSLNGTH         LOAD LENGTH\n         ST    R1,WORD2\n         MVC   WORDSEPS(4),ATSSEPS LOAD WORD SEPARATORS.\n***********************************************************************\n* WE MUST DETERMINE THE TEST TYPE, EITHER A WORD TYPE, OR A SUBSTR    *\n* TYPE.                                                               *\n***********************************************************************\n         CLI   ATSTYPE,C'W'        IS IT A WORD ?                *AGCO*\n         BE    WORDTYPE            YUP, GO PROCESS IT\n         CLC   ATSTYPE,=CL2'P'     IS IT A SUBSTRING ?\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLI   ATSTYPE,C'S'        IS IT A SUBSTRING ?           *AGCO*\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLC   ATSTYPE,=CL2'L'     IS IT A LINE NUMBER?\n         BNE   TESTTBAD            NO, IT IS WRONG\n         L     R2,ATSLINE          PICK UP LINE NO.\n         BAL   R14,SEDOLINE        TRY TO FIND IT\n         B     TESTFAIL            NO MATCH, THIS TEST FAILS\n         B     SUBSSUCC            SUCCESSFUL, GO ONTO NEXT TEST\n         SPACE 1\nTESTTBAD DS    0H                  INVALID TEST TYPE\n* NEITHER WORD NOR SUBSTRING, ** PROBLEM **\n         WTO   'TSS9202E INVALID TEST TYPE- IGNORING MESSAGE ID'\n*        B     TESTFAIL            SIMULATE TEST FAILING !\n         B     PART3EXT            STOP PROCESSING ON FAILURE    *SEAG*\n         EJECT ,\nWORDTYPE DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE HAVE A WORD TEST. THE ROUTINE WILL PERFORM THE\n* FOLLOWING PROCEDURES.\n*                                                                     *\n* 1) USE TSSOPARS TO PARSE THE MESSAGE, BASED ON THE SEPARATOR CHARS  *\n*    SPECIFIED IN THE TABLE.                                          *\n* 2) PERFORM THE TEST BASED ON THE DESIRED WORD, USING THE LENGTH     *\n*    SPECIFIED IN THE TABLE.                                          *\n* 3) EITHER GO TO TESTFAIL, OR PERFORM ANOTHER TEST.                  *\n*                                                                     *\n***********************************************************************\n         L     R10,STRSTART      GET ADDRESS OF STRING\n*                                 NOTE- COULD HAVE BEEN WQETXT+1 IF WTO\n*                                 or WQETXT+WQERIDL+2 if WTOR.  EEJ1102\n         ST    R10,PARS1         THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY      PARARRAY IS THIRD PARAMETER\n         ST    R10,PARS3         STORE IN PARM LIST.\n*\n         LA    R10,WORDSEPS      USE WORD SEPARATORS ON TEST DIRECTIVE\n         ST    R10,PARS4         AND STORE IN FOURTH WORD IN PARM LIST.\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY     HOW MANY DID WE GET BACK\n         C     R10,WORD1        SEE WHICH ONE WAS SPECIFIED IN THE\n*                                TEST PARAMETER LIST.\n         BL    WORDFAIL          NOT ENOUGH WORDS.. FAIL THIS TEST.\n         LA    R10,PARARRAY+2   POINT TO WORD NUMBER 1\n         L     R5,WORD1          GET WORD  REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN\n         ST    R10,TOKADDR      REMEMBER WHERE TOKEN WAS FOUND.\n***********************************************************************\n* AT THIS POINT, TOKADDR CONTAINS THE ADDRESS OF THE TOKEN (WORD) THAT*\n* WAS LOCATED BY TSSOPARS. WE WILL COMPARE THIS WORD, FOR N CHARACTERS*\n* AGAINST WHAT WAS SPECIFIED IN THE TSSO/AOF TABLE. IF MATCHED, GREAT *\n* IF NOT, TEST HAS FAILED.                                            *\n*\n* WE NEED TO LOAD UP THE MATCH TEXT AS SPECIFIED IN THE AOF TABLE.    &\n***********************************************************************\n         LH    R4,ATSTXTL       GET MATCHING TEXT LENGTH\n***********************************************************************\n* NOTE, THE MATCHING TEXT STRING IS AT 20(R6) WHERE R6 POINTS TO THE\n* TEST PARAMETER ENTRY (TPE).\n***********************************************************************\n         L     R5,TOKADDR       LOAD TOKEN ADDRESS\n         BCTR  R4,0             -1 FOR HARDWARE DEFIENCY.\n         EX    R4,COMPSTR       DO COMPARE !\n         BE    WORDSUCC        WORD MATCHED !!\n         BNE   WORDFAIL         WORD DIDNT MATCH !!!\nCOMPSTR  CLC   0(0,R5),ATSTXT   ** EXECUTED **\nWORDSUCC DS    0H\n************************************************************\n* WE COME HERE IF THE WORD MATCHED, IMPLYING THAT THIS PARTICULAR\n* TEST WAS SUCCESSFULL. NOW WE WILL GO SEE IF THERE ARE ANY MORE\n* TESTS..\n************************************************************\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BE    TESTFAIL         YES, ASO THE TEST FAILED         *AGCO*\n         L     R6,ATSNXT        GET NEXT TEST ENTRY\n         B     TESTLOOP         AND TRY AGAIN...\n*\nWORDFAIL DS    0H\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BNE   TESTFAIL         NO, IT REALLY IS A FAILURE       *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n*\nSUBSTYPE DS    0H\n***********************************************************************\n* THE USER REQUESTED A SUBSTRING TYPE OF TEST ON THE MESSAGE. THE     *\n* ROUTINE WILL PROVIDE THAT TEST. THE TEST IS:                        *\n* SUBSTR(MVSWTO,START IN AOF,LENGTH IN AOF) ?= MATCHTEX IN AOF.       *\n*                                                                     *\n***********************************************************************\n         L     R5,STRSTART      GET START OF MVS MESSAGE.\n         L     R4,WORD1         GET START AS SPECIFIED IN AOF.\n         BCTR  R4,0             -1 TO GET CORRECT CHARACTER.\n         LA    R5,0(R4,R5)      POINT TO START OF SUBSTRING IN WQE\n         L     R4,WORD2         GET LENGTH FOR COMPARE.\n         BCTR  R4,0             -1 FOR EXECUTE\n         EX    R4,COMPSTR2      PERFORM THE SUBSTRING COMPARE.\n         BE    SUBSSUCC         THEY MATCHED! -> TEST SUCCEDED.\n         BNE   SUBSFAIL         NO MATCHED- SUBS FAILED\n***********************************************************************\n* NOTE THAT THE MATCH TEXT IS IN 20(R6) WHERE R6 POINTS TO THE CURRENT\n* AOF TABLE.\n***********************************************************************\nCOMPSTR2 CLC   0(0,R5),ATSTXT\nSUBSSUCC DS    0H\n***********************************************************************\n* WE GET HERE IF THE SUBSTRING TEST WAS SUCCESSFULL. TSSO/AOF WILL\n* CHECK THE NEXT ENTRY IN THE TABLE AND ATTEMPT THE NEXT TEXT\n***********************************************************************\n         CLC   ATSTYPE,=CL2'SX' IS IT AN EXCLUSION TEST?         *AGCO*\n         BE    TESTFAIL         YES, SO THE TEST FAILS           *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n*\nSUBSFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF THIS SUBSTRING TEST HAS FAILED. IF THIS IS THE CASE *\n* THEN WE WILL CONTINUING SEARCH AOF TABLE ENTRIES IN HOPES OF AGAIN  *\n* FINDING THE MSG ID.\n***********************************************************************\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BNE   TESTFAIL         NO, IT REALLY IS A FAILURE       *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n         SPACE 2\nTESTFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF A WORD OR SUBSTRING TEST FAILS. IF THIS SHOULD      *\n* HAPPEN, WE CONTINUE SEARCHING THROUGH ALL TSSO/AOF TABLE ENTRIES    *\n* FOR ANOTHER MATCH ON THE MSGID.                                     *\n***********************************************************************\n         B     RUNTABL          GO TEST ANOTHER AOF ENTRY        *AGCO*\n*\nTESTSUCC DS    0H\n***********************************************************************\n* WE COME HERE IF ALL TESTS HAVE BEEN SUCCUSSFULL FOR THIS TABLE ENTRY*\n* TSSO WILL GO AND PERFORM THE ACTION REQUESTED AND CONTINUE SEARCHING*\n* THE TABLE FOR ANY ADDITIONAL ENTRIES.                               *\n***********************************************************************\n         B     PERFACT\n         DROP  R6\n*\nPERFACT  DS    0H\n************************************************************\n* WE COME HERE WHEN WE HAVE FOUND A WTO IN THE TABLE, AND THE TESTS\n* SPECIFIED FOR THE ENTRY HAVE BEEN MET. AT THAT TIME, WE PERFORM\n* THE ACTION SPECIFIED IN THE ACTION= PARAMETER FOR THE ENTRY.\n*\n* PROCESSING CONTINUES AS FOLLOWS:\n*\n* 1) IF MATCHLIM PROCESSING HAS BEEN SPECIFIED (MATCHLIM > 0) DEDUCT\n*    ONE FROM MATCHLIM. IF MATCHLIM = 999999 THEN DONT BOTHER. IF\n*    MATCHLIM = 0 THEN DO NOT PERFORM THE REQUESTED FUNCTION AFTER ALL.\n*\n* 2) WE IDENTIFIY WHAT THE TABLE WANTS US TO DO, I.E. ISSUE AN OS\n*    COMMAND, TSSO COMMAND, REPLY, OR WHATEVER. WE THEN BRANCH TO THE\n*    APPROPRIATE ROUTINE.\n*    NOTE THAT R7 POINTS TO THE ENTRY IN THE TSSO/AOF TABLE.\n*\n************************************************************\n         L     R2,AOFMLIM                PICK UP MATCHLIM VALUE.\n         C     R2,=F'999999'             WAS MATCHLIM SPECIFIED ?\n         BE    PASTMLIM                  NO - DONT BOTHER DEDUCTING\n         LTR   R2,R2                     IS COUNT ALREADY ZERO ?\n         BZ    FUN9NACT                  NO, TAKE NO ACTION...\n         BCTR  R2,0                      TAKE  ONE AWAY FROM MATCHLIM\n         ST    R2,AOFMLIM                AND STORE NEW MATCHLIM BACK\nPASTMLIM DS    0H\n***********************************************************************\n* HERE, WE HAVE SURVIVED MATCHLIM PROCESSING, AND ARE READY TO TAKE   *\n* ON THE ACTION SPECIFIED IN THE ACTION= PARAMETER OF THE AOF TABLE   *\n***********************************************************************\n         CLC   AOFACTN,=CL8'NONE'       IS THIS A DUMMY REQUEST?\n         BE    GETNEXT                  YES, SO WE HAVE DONE IT\n*\n         CLC   AOFACTN,=CL8'REPLY'       REQUEST TO REPLY ?\n         BE    FUN9RPLY\n         CLC   AOFACTN,=CL8'SUPPRESS'     REQUEST TO SUPPRESS.\n         BE    FUN9SUPP\n         CLC   AOFACTN,=CL8'HILIGHT'     REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'HIGHLITE'   REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'MSGRED'     REQUEST TO HILIGHT  IN RED?\n         BE    FUN9RED                  YES, PROCESS IT\n         CLC   AOFACTN,=CL8'LOWLIGHT'    REQUEST TO TURN OFF HIGHLITE\n*                                       DESCRIPTOR ?\n         BE    FUN9LOW\n         CLC   AOFACTN,=CL8'OSCMD'      REQUEST FOR AN OS COMMAND ?\n         BE    FUN9CMND\n         CLC   AOFACTN,=CL8'OSCMDT'     REQUEST FOR AN OS COMMAND ?\n*                                       IN TEST MODE ?\n         BE    FUN9CMDT\n*\n         CLC   AOFACTN,=CL8'POST'       IS THIS REQUEST FOR POST\n         BE    FUN9POST\n*\n         WTO   'TSS9203E INVALID DIRECTIVE',DESC=1\n         B     PART3EXT                 SCOTTY, BEAM ME UP.\nFUN9NACT DS    0H\n***********************************************************************\n* HERE, THE MATCHLIM TEST HAS DETERMINED A ZERO MATCHLIM - IMMEDAITELY*\n* TERMINATE SS09 PROCESSING WITHOUT DOING ANYTHING                    *\n***********************************************************************\n         B     GETNEXT                 GET NEXT TSSO/AOF TABLE ENTRY\nFUN9CMDT DS    0H\n         OI    FUN9FLG,X'20'           INDICATE TEST MODE\n         B     FUN9CMND\nFUN9CMND DS    0H\n************************************************************\n* HERE IS THE ENTRY POINT FOR ISSUEING OS COMMANDS BASED ON\n* WTO'S.\n************************************************************\n         SPACE 1\nCMNDGO   DS    0H\n         LA    R2,MVSCMD+4       STARTING POINT FOR MVS CMD\n         MVI   MVSCMD+4,X'40'         BLANK OUT THE\n         MVC   MVSCMD+5(104),MVSCMD+4 COMMAND BUFFER\n         LA    R3,AOFACT         START POINT FOR MVS DIRECTIVE\n         LH    R4,AOFACTL        LENGTH OF MESSAGE\nCMNDLOOP DS    0H\n         LTR   R4,R4            CHECK TO SEE IF ANY CHARS REMAIN\n*                               IN BUFFER. THIS COULD HAVE HAPPENED\n*                               IF THE FORMATTING OPTION HAD BEEN\n*                               THE LAST THING IN THE TEXT OPERAND\n         BZ    ISSUECMD\n         CLI   0(R3),C'\\'       SIGNIFICANCE CHARACTER ON?\n         BE    SIGON             WELL.. IT IS NOW.\n         MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         BCT   R4,CMNDLOOP\n         B     ISSUECMD          GO DO THE COMMAND\n*\nSIGON    DS    0H\n************************************************************\n* WE COME HERE WHEN WE FIND THE '\\' DIRECTIVE IN THE TSSO TABLE\n* ENTRY FOR THIS MESSAGE. THIS MEANS WE HAVE SOME WORK TO DO.\n************************************************************\n         LA    R3,1(R3)           POINT TO NEXT CHARACTER\n         CLI   0(R3),C'I'         LOOKING FOR SYSID?          @DM081409\n         BE    SIGONI             YUP.. GOT IT                @DM081409\n         CLI   0(R3),C'P'         LOOKING FOR POSITION CHARACTER?\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'S'         CHECK ITS SYNONYM\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'W'         LOOKING FOR SOME 'WORD' ?\n         BE    SIGONW             YUP, GO DO IT !!\n*\n         WTO   'TSS9210E ERROR IN DEFINITION OF OSCMD, NOT I,P,S OR W'\n         B     PART3EXT\n         SPACE 2\nSIGONP   DS    0H\n         CLI   4(R3),C','         CHECK FOR CORRECT FORMAT.\n         BNE   SIGWRONG\n         CLI   7(R3),C'\\'         CHECK FOR CLOSING TERMINATOR.\n         BNE   SIGWRONG           OH WELL...\n*\n         LA    R10,WORKAREA       POINT R10 TO WORKAREA FOR CVT\n         LA    R0,3               SET LENGTH FOR FIRST CONVERT\n         LA    R1,1(R3)           SET ADDRESS\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGSTART        REMEMBER STARTING POINT\n         LA    R0,2               GET LENGTH\n         LA    R1,5(R3)           GET NEW START POINT FOR CONVERT\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGCOUNT        SAVE COUNT\n************************************************************\n* AT THIS POINT, WE HAVE THE PARAMETERS NEEDED FOR TEXT\n* SUBSTITUTION IN THE OS COMMAND TO BE ISSUED.\n************************************************************\n         L     R1,SIGCOUNT              GET COUNT FOR EXECUTE\n         BCTR  R1,0                     MAKE UP FOR HARDWARE FAULTS\n         L     R10,STRSTART             GET START ADDRESS OF TEXT\n         L     R5,SIGSTART              GET STARTING POINT\n         C     R5,STRLEN                CHECK STARTING POINT\n         BH    SIGWRONG                 IF TO HIGH, FORGET IT\n         LA    R10,0(R10,R5)            POINT TO STARTING POINT IN WQE\n*                                       FOR MOVE.\n         BCTR  R10,0                    GET EXACT CORRECT POSTITION\n         EX    R1,MOVESIG               MOVE THE STUFF...\n         B     AR2\nMOVESIG  MVC   0(0,R2),0(R10)\nAR2      DS    0H\n         A     R2,SIGCOUNT              NEXT CHAR IN CMD BUFFER\n         LA    R3,8(R3)                 MOVE PAST \\ STUFF IN TSSO TABLE\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWRONG\n         B     CMNDLOOP\nSIGWRONG DS    0H\n         WTO   'TSS9204E ERROR IN DEFINITION (P) FOR NEXT WTO MSG'\n         B     PART3EXT\n********************************************************************\n* SYSTEM ID IS BEING REQUESTED                                @DM081409\n********************************************************************\nSIGONI   DS    0H                                             @DM081409\n         MVC   0(L'SYSID,R2),SYSID      MOVE IN SYSTEM NAME   @DM081409\nSYSBLNK  DS    0H                       LOOK FOR TRAILING BLAN@DM081709\n         LA    R2,1(R2)                 INCEMENT PTR TO COMMAN@DM081709\n         CLI   0(R2),C' '               IS THIS TRAILING BLANK@DM081709\n         BH    SYSBLNK                  NO --> KEEP LOOKING   @DM081709\n*\n         LA    R3,8(R3)                 INCREMENT PAST \\      @DM081409\n         SH    R4,=H'9'                 DECREMENT LENGTH OF CM@DM081409\n         LTR   R4,R4                    IS THERE COMMAND LEFT?@DM081409\n         BM    SIGWRONI                 NO-->ERROR            @DM081409\n         B     CMNDLOOP                 YES->CONTINUE PROCESSI@DM081409\nSIGWRONI DS    0H\n         WTO   'TSS9209E ERROR IN DEFINITION (I) FOR NEXT WTO MSG'\n         B     PART3EXT\n************************************************************\n************************************************************\nSIGONW   DS    0H\n         CLI   7(R3),C'\\'               TERMINATION FOR W DIRECTIVE\n         BNE   SIGWBAD                 SHUCKS\n         MVC   SEPCHAR(4),1(R3)        GET SEPARATOR CHARACTERS\n         LA    R1,5(R3)                GET START FOR CONVERT RTN\n         LA    R0,2\n         LA    R10,WORKAREA\n         CALL  JCECVTDB                GET DECIMAL\n         LTR   R1,R1                   CHECK IT OUT\n         BZ    SIGWBAD\n         ST    R1,WORDREQ              THIS IS THE REQUESTED WORD\n         CH    R1,=H'20'               BUT IS IT OK?\n         BH    SIGWBAD                 NO, GUY DIDNT READ THE DOC\n************************************************************\n* NOW, WE MUST SET UP THE PARSE ROUTINE. THE GENERAL ID IS TO\n* PARSE THE WTO MSG INTO USER DEFINED WORDS, AND THEN GET THE ONE\n* HE WANTS.\n************************************************************\n         L     R10,STRSTART       GET ADDRESS OF STRING\n         ST    R10,PARS1          THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY\n         ST    R10,PARS3\n*\n         LA    R10,SEPCHAR\n         ST    R10,PARS4\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY      HOW MANY DID WE GET BACK\n         C     R10,WORDREQ       SEE HOW MANY HE WANTED\n         BL    NOWORDS           NOT ENOUGH WORDS.. FORGET IT.\n         LA    R10,PARARRAY+2    POINT TO WORD NUMBER 1\n         L     R5,WORDREQ        GET WORDS REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN... NOW WE GET LENGTH\n         ST    R10,TOKADDR       REMEMBER WHERE TOKEN WAS FOUND.\n         XR    R5,R5\n         LA    R1,16             TOKENS ARE 16 BYTES LONG\n************************************************************\n* AT THIS POINT, R10 POINTS TO THE TOKEN RETURNED BY THE PARSE ROUTINE\n* THAT THE USER REQUESTED.\n************************************************************\nWLOOP    DS    0H\n         CLI   0(R10),C' '\n         BE    ENDTOKEN\n         LA    R5,1(R5)\n         LA    R10,1(R10)\n         BCT   R1,WLOOP\nENDTOKEN DS    0H\n         ST    R5,LWORDREQ       STORE LENGTH OF REQUESTED WORD\n************************************************************\n* AT THIS POINT, WE HAVE ALL THE INFORMATION NEEDED TO DO  *\n* THE PARAMETER SUBSTITUTION. R2 POINTS TO THE SPOT TO     *\n* SUBSTITUTE.                                              *\n************************************************************\n         L     R5,LWORDREQ              GET LENGTH OF WORD\n         BCTR  R5,0                     MINUS 1 FOR EXECUTE\n         L     R10,TOKADDR\n         EX    R5,MOVEWORD\n         B     AR3\nMOVEWORD MVC   0(0,R2),0(R10)\nAR3      DS    0H\n         A     R2,LWORDREQ\n         LA    R3,8(R3)\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWBAD\n         B     CMNDLOOP\nNOWORDS  DS    0H\n         WTO   'TSS9205E NOT ENOUGH TOKENS IN BELOW WTO TO PROCESS'\n         B     PART3EXT\nSIGWBAD  DS    0H\n         WTO   'TSS9206E ERROR PROCESSING W DIRECTIVE- MSG IGNORED'\n         B     PART3EXT\nSIGLBAD  DS    0H\n         WTO   'TSS9208E ERROR PROCESSING L DIRECTIVE- ENTRY IGNORED'\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\nISSUECMD DS    0H\n         TM    FUN9FLG,X'20'            WAS OSCMD SPECIFIED ?\n         BNO   ISSURCMD                GO ISSUE REAL COMMAND\n* HERE, WE WILL NOT ISSUE THE COMMAND, BUT WE WILL WTO OUT WHAT THE\n* COMMAND WOULD HAVE BEEN\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+13(105),MVSCMD+4\n         WTO   MF=(E,WTO1D)           (MSG 207) DEFINED IN THIS MODULE\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\n*\nISSURCMD DS    0H\n         MVC   MVSCMD(2),=H'109'\n         MVC   MVSCMD+2(2),=H'0'\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(105),MVSCMD+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF1                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG1\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES1\nECHOOFF1 DS    0H\n         B     AFTECHO1                        NO ECHO, WHAT A SHAME\n*\nECHOYES1 DS    0H\n         WTO   MF=(E,WTO1D)        (MSG207)\n         B     AFTECHO1                        ECHO TO MASTCONS\n*\nECHOLOG1 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),MVSCMD+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO1\n*\nAFTECHO1 DS    0H\n*        LH    R0,MASTCONS                                     CM MAY08\n         SR    R0,R0                                           CM MAY08\n         LA    R1,MVSCMD\n         SVC   34\n         B     GETNEXT\nFUN9LITE DS    0H\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       HILIGHT\n         OI    WQEDC1,WQEDCB            HILITE THE SUCKER\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n*                                       FOR HILIGHT\n         B     GETNEXT\n*\nFUN9RED  DS    0H\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       HILIGHT\n         OI    WQEDC1,WQEDCA            HILITE THE SUCKER IN RED\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n*                                       FOR HILIGHT\n         B     GETNEXT\n*\nFUN9LOW  DS    0H\n***********************************************************************\n* THIS IS THE ROUTINE TO \"LOWLITE\" A MESSAGE. THE ROUTINE BASICALLY   *\n* INTERCEPTS THE MESSAGE, AND FLIPS OFF THE WQEDCA BIT.               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       LOW LIGHT\n         NI    WQEDC1,255-WQEDCA        (PTF3)\n         NI    WQEDC1,255-WQEDCB\n         NI    WQEDC1,255-WQEDCC        KILL EVENTUAL ACTION MSG15OCT92\n         NI    WQEDC2,255-WQEDCK\n         NI    WQEXA,255-WQEWTOR        FAKE OUT COMTASK INTO THINKING\n*                                       THE MESSAGE IS NOT A WTOR...\n* HILIGHTING CAUSED BY DESCRIPTOR CODES 1, 2 AND 11.\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n         B     GETNEXT\n*\nFUN9SUPP DS    0H\n***********************************************************************\n* THIS IS THE SUPPRESS HANDLER. THE SUPPRESS FUNCTION IS PROBABLY THE *\n* CLEANEST IN THE WHOLE PRODUCT, BECAUSE SUBSYSTEM CAN CAUSE MESSAGES *\n* TO BE SUPPRESSED. NOTE THAT THIS FUNCTION WILL BE INEFFECTIVE FOR   *\n* WTOR REQUESTS, HOWEVER, THE LOWLIGHT FUNCTION CAN BE USED.          *\n***********************************************************************\n         LA    R5,SSWTNDSP              LOAD CODE FOR SUPPRESSION\n         STH   R5,FUNC9RC               AND STORE IT AWAY.\n         B     GETNEXT                  GET A NEW ENTRY\n*\nFUN9RPLY DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO AOF REPLY FUNCTION. THE IDEA   *\n* HERE IS TO INTERCEPT THE WTOR, FORMAT A REPLY COMMAND OF THE FORM   *\n* R NNNN,MSG-TEXT where NNNN is picked up from the ORERPIDB     EEJ1102\n* field and MSG-TXT is picked up from the AOF table.  This is   EEJ1102\n* useful in \"nuking\" outstanding replies, like those from IMS.  EEJ1102\n* The REPLY command is used to reply to those messages.         EEJ1102\n***********************************************************************\n         L     R5,SSWTORE               GET THE OPERATOR REPLY ELEMENT\n         LTR   R5,R5                    MAKE SURE..\n         BZ    GETNEXT\n         USING OREF,R5                  GAIN ADDRESSABILITY TO ORE.\n         MVC   REPLY(2),=Y(REPLYLEN) Length of reply buffer     EEJ1102\n         MVC   REPLY+2(2),=H'0'\n         MVI   REPLYCOM,C','\n         L     R14,ORERPIDB        Load reply ID value          EEJ1102\n         CVD   R14,WORKAREA        Convert to decimal           EEJ1102\n         OI    WORKAREA+7,X'0F'    Ensure valid characters      EEJ1102\n*        UNPK  REPLYNUM,WORKAREA(8) CONVERT TO CHARACTER        EEJ1102\n         MVC   WORKAREA+8(L'REPLYEDT),REPLYEDT COPY EDIT MASK    *AGCO*\n         ED    WORKAREA+8(L'REPLYEDT),WORKAREA+5 edit reply num  *AGCO*\n         MVC   REPLYNUM,WORKAREA+8+2 COPY REPLY NUMBER           *AGCO*\n         LH    R1,AOFACTL               PICK UP LENGTH OF REPLY\n         BCTR  R1,0\n         MVI   REPLYMSG,X'40'\n         MVC   REPLYMSG+1(99),REPLYMSG   CLEAR REPLYMSG\n         EX    R1,MOVERPLY\n         B     AR4\nMOVERPLY MVC   REPLYMSG(0),AOFACT          MOVE IN AUTOMATIC REPLY\nAR4      DS    0H\n***********************************************************************\n* THE REPLY DIRECTIVE IS SUPPORTED BY THE ECHO FACILITY. CHECK TO SEE *\n* IF THE TABENTRY MACRO SPECIFIED ECHO= ON THE CARD, AND TAKE ACTION  *\n***********************************************************************\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(108),REPLY+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF2                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG2\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES2\nECHOOFF2 DS    0H\n         B     AFTECHO2                        NO ECHO, WHAT A SHAME\n*\nECHOYES2 DS    0H\n         WTO   MF=(E,WTO1D)\n         B     AFTECHO2                        ECHO TO MASTCONS\n*\nECHOLOG2 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),REPLY+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO2\nAFTECHO2 DS    0H\nISSUERPL DS    0H\n*        LH    R0,MASTCONS        LETS DO REPLY FROM MASTCONS  CM MAY08\n         SR    R0,R0                                           CM MAY08\n         LA    R1,REPLY\n         SVC   34\n         B     GETNEXT\n         DROP  R5               DROP ADDRESSABILITY TO OREF\nFUN9POST DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO POST ROUTINE, ALLOWING THE     *\n* CALLER TO WAIT ON A GIVEN MESSAGE OR AOF ENTRY ID BEFORE BEING      *\n* POSTED. THE CALLER WILL BE THE OSWAIT TSO COMMAND, OR (PERHAPS) ITS *\n* NCCF EQUIVALENT. STANDARD TSSO ACTION IS THE FOLLOWING:             *\n*                                                                     *\n* 1) DETERMINE IF THE CURRENT MESSAGE IS ACTIVE. IF NOT, TERMINATE    *\n*    IMMEDIATELY.                                                     *\n*                                                                     *\n* 2) GET THE ADDRESS SPACE, ECB AND PLACE TO PUT THE WTO INTO         *\n*    VARIABLES                                                        *\n*                                                                     *\n* 3) COPY THE WTO INTO THE AOF TABLE ENTRY                            *\n*                                                                     *\n* 4) POST THE ECB IN THE SPECIFIED ADDRESS SPACE                      *\n*                                                                     *\n* 5) GO TO NEXT ENTRY.                                                *\n*                                                                     *\n***********************************************************************\n         TM    AOFPFLG,AOFP1WT  IS THIS ENTRY BEING WAITED ON ?\n         BNO   END9POST         NO, END OF FUNCTION...\n*\n         L     R2,AOFPECB       PICK UP ECB TO POST....\n         L     R3,AOFPASCB      AND GET THE ADDRESS SPACE.\n         L     R4,WQETSADR      GET ADDRESS OF WQE\n         MVC   AOFWQE(147),0(R4) COPY TO AOF TABLE\n         POST  (R2),X'000',ASCB=(R3),ERRET=END9POST,MF=(E,POST1D)\nEND9POST DS    0H\n         B     GETNEXT\n         DROP  R7\n         SPACE 2\nPART3EXT DS    0H\n***********************************************************************\n* FINISHED WITH DOING THE AOF PROCESSING OF THE MESSAGE, EXIT NICELY  *\n***********************************************************************\n         B     FUNC9EXT                 ALL DON SO EXIT\n         EJECT ,\nGETMERR  DS    0H\n***********************************************************************\n* THIS CODE IS BRANCHED TO IN CASE OF A GETMAIN ERROR WITHIN          *\n* TSSOSS09. THIS WILL OCCUR IF THE CURRENT ADDRESS SPACE SUFFERS      *\n* AN 80A OR 878 ABEND. IT IS (PROBABLY) NOT A GOOD IDEA TO ISSUE      *\n* A WTO BECAUSE SS09 WOULD GET REDERIVEN BUT STILL BE OUT OF STORAGE  *\n***********************************************************************\n*        WTO   'TSS9208S SS09 TERMINATING BECAUSE IT CANT GET STORAGE'\n         B     FUNC9EX2\nFUNC9EXT DS    0H\n         LH    R8,FUNC9RC          TEMP STORAGE FOR THE RETURN CODE\n         L     R10,SSOBADDR\n         USING SSOB,R10\n         ST    R8,SSOBRETN\n         DROP  R10\n         FREEMAIN R,LV=4096,A=(R11)\nFUNC9EX2 DS    0H\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nFUNC9EX3 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15             COPY RC INTO REG 15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n         TITLE 'LOCATE LINE NUMBER IN MULTI-LINE WTO'\n***********************************************************************\n* THIS CODE ADDED BY D.H.CARTWRIGHT, SPRECHER ENERGIE, OBERENTFELDEN  *\n* CH-5036 SWITZERLAND AS PART OF THE ENHANCEMENT TO ALLOW DATA FROM   *\n* MULTI-LINE WTO'S TO BE USED IN OSCMD TEXT. THIS IS PARTICULARLY     *\n* NECESSARY FOR VTAM ERRORS DESCRIBED BY THE MLWTO MESSAGE 'IST663I'. *\n*                                                                     *\n* BASICALLY IT CHECKS THAT WE ARE PROCESSING THE REQUIRED LINE, THEN  *\n* ADJUSTS THE STRSTART AND STRLEN VARIABLES SO THAT THE EXISTING      *\n* PROCESSING WILL BE SWITCHED TO THE APPROPRIATE LINE OF TEXT.        *\n*                                                                     *\n* ON ENTRY R2  =  LINE NUMBER REQUIRED                                *\n*          R6  =  TEST DEFINITION CONTROL BLOCK                       *\n*                                                                     *\n* ON EXIT  STRSTART AND STRLEN HAVE BEEN ADJUSTED TO POINT TO THIS WQE*\n*    EXIT IS TO R14+4 IF THE LINE HAS BEEN FOUND                      *\n*               R14+0 IF THIS IS NOT THE REQUIRED LINE                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING ATSNTRY,R6\nSEDOLINE DS    0H                  LOCATE SPECIFIC LINE\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLINJ            NO, CHECK MAJOR\n         WTO   'A LINE NUMBER HAS BEEN REQUESTED'\nSEDOLINJ DS    0H                  PROCESS MAJOR WQE\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10            ESTABLISH ADDRESSABILTIY\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   SIGLBAD             NOPE, ERROR\n         TM    FUN9FLG,X'80'       DO WE HAVE A MINOR WQE?\n         BO    SEDOLMIN            YES, GO PROCESS WQE'S\n         MVC   ATSSEQ#,WMJMSEQ#    SAVE CONNECT ID\n         OI    WMJMRFB1,WMJMRPML   SAY WE WANT TO PROCESS THE MINORS\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLIN2            NO, CONTINUE\n         WTO   'ONLY MAJOR WQE'\nSEDOLIN2 DS    0H                  PROCESS MAJOR WQE\n         XR    R1,R1               CLEAR WORK REG.\n         STH   R1,ATSLNCNT         CLEAR TEST LINE COUNT\n         LA    R1,1                COUNT MAJOR AS FIRST LINE\n         STH   R1,ATSLNCNT         SAVE LINE COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, TRY THE MINORS NEXT TIME\n         LA    R1,WMJMTXT+1        POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         LH    R1,WMJMTXTL         GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLMIN DS    0H                  NOW PROCESS MINOR WQE'S\n         ICM   R5,B'1111',SSWTMIN  GET ADDRESS OF MINOR\n         BZ    SIGLBAD             ERROR IF NONE\n         PUSH  USING                                            RPS\n         DROP  R10                 DROP MAJOR ADDRESSABILITY    RPS\n         USING WMNM,R5             ESTABLISH MINOR ADDRESSABILTIY\n         LH    R1,ATSLNCNT         GET PREVIOUS LINE COUNT\n         SPACE 1\nSEDOLM1  DS    0H                  LOOP THROUGH THE LINES\n         TM    WMNMML1,WMNMML1C    IS THIS A MINOR WQE?\n         BNO   SIGLBAD             NO, ERROR\n         CLC   WMNMSEQ1,ATSSEQ#    SAME CONNECT ID?\n         BNE   SIGLBAD             NO, ERROR\n         ICM   R15,B'1111',WMNMNX1 IS THERE A SECOND HALF?\n         BNZ   SEDOLM2             YEs, ASSUME WE DID THE FIRST\n         TM    WMNMLT1,WMNMLT1A+WMNMLT1B+WMNMLT1C   DATA ON THIS LINE ?\n         BZ    SEDOLM2             I GUESS NOT, WILL CHECK THE NEXT ONE\n         LA    R1,1(,R1)           INCREMENT COUNT\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLM2             NO, TRY THE SECOND HALF\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLM1B            NO, SKIP THIS CODE\n         WTO   'SEDOLM1B WQE IS FOR LINE WANTED'\nSEDOLM1B DS    0H                  CONTINUE PROCESSING\n         LA    R1,WMNMTXT1+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL1          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLM2  DS    0H                  PROCESS SECOND HALF OF MINOR WQE\n         ICM   R15,B'1111',WMNMNX1 IS THERE A SECOND HALF?\n         BZ    SEDOLMX             NO, EXIT\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLM2A            NO, CONTINUE\n         WTO   '2ND HALF OF MINOR WQE'\nSEDOLM2A DS    0H                  PROCESS MINOR WQE 2ND HALF\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C   DATA ON THIS LINE ?\n         BZ    SEDOLMX             I GUESS NOT, WILL CHECK THE NEXT ONE\n         LH    R1,ATSLNCNT         GET PREVIOUS LINE COUNT\n         LA    R1,1(,R1)           INCREMENT SAVED COUNT\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, WAIT FOR NEXT MINOR WQE\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLM2B            NO, SKIP THIS CODE\n         WTO   'SEDOLM2B WQE IS FOR LINE WANTED'\nSEDOLM2B DS    0H                  CONTINUE PROCESSING\n         LA    R1,WMNMTXT2+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL2          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLMX  DS    0H                  LINE IS NOT IN THIS MINOR WQE\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLMXX            NO, SKIP THIS CODE\n         WTO   'WQE IS NOT FOR LINE WANTED'\nSEDOLMXX DS    0H                  CONTINUE PROCESSING\n         POP   USING               Moved here             @DM011410RPS\n         ICM   R15,B'1111',WMNMNX2 IS THERE ANOTHER MINOR?\n         BZ    SEDOLMX2            NO, A REAL EXIT\n         LR    R5,R15              YES, UPDATE POINTER\n         B     SEDOLM1             GO ROUND THE LIST OF MINOR WQE'S\n*        POP   USING               Move up                @DM011410RPS\n         SPACE 1\nSEDOLMX2 DS    0H                  NOR ANY OTHER THAT I KNOW OF\n         XR    R1,R1               SET RETURN OFFSET TO ZERO\n         SPACE 1\nSEDOLINX DS    0H                  SUB ROUTINE EXIT\n         B     0(R1,R14)           RETURN TO CALLER WITH OFFSET\n         DROP  R10                 END MAJOR ADDRESSABILITY\n*        DROP  R5                  END WQE ADDRESSABILITY\n         DROP  R6                  END TSSO AOF TEST BLOCK ADDRESSABTY\n         COPY  BSCAN                                            30OCT92\n         TITLE 'DATA AREAS'\n         LTORG\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\nPOST1C   POST  ,ASCB=0,ERRET=0,MF=L\nPOST1CE  DS    0H\nREPLYEDT DC    XL6'402020202120'    EDIT MASK FOR REPLY NUMBER   *AGCO*\nWTO1C    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTO1CE   EQU   *\n*\nWTL1C    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTL1CE   EQU   *\n*\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\nFUN9DATA DSECT\nWORKAREA DS    CL200            USED FOR CONVERT ROUTINES\n***********************************************************************\n* RE-ENTRANT MACRO DEFINITIONS...                                     *\n*                                                                     *\n***********************************************************************\nPOST1D   POST  ,ASCB=0,ERRET=0,MF=L\n***********************************************************************\n* VARIABLES USED TO PROCESS REQUESTS OF PART 1 OF THIS ROUTINE, THE   *\n* INTERFACE TO THE OSCMD COMMAND.                                     *\n*                                                                     *\n***********************************************************************\nMAJWQEAD DS    F                MAJOR WQE ADDRESS\nMINWQEAD DS    F                MINOR WQE ADDRESS\nMAJOREAD DS    F                ADDRESS OF AN ORE.\nSSOBADDR DS    F                ADDRESS OF THE SSOB\nSSWTADDR DS    F                ADDRESS OF THE SSWT FOR THIS SUBSYS CAL\nSSCONENT DS    F                IF SS CON ENTRY USED - THIS FIELD HAS\n*                               ADDRESS OF SSCON ENTRY FOR IT.\n*\n*\nWQEADDR  DS    A                ADDRESS OF THE WQE WE ARE TRYING\n*                               TO DEAL WITH\nWQETSADR DS    A                ADDRESS OF TIME STAMP IN THE WQE.\nCURTABAD DS    A                CURRENT TSSO/AOF TABLE ADDRESS WE ARE\nSYSID    DS    CL8              SAVED SYSTEM NAME FROM WQE    @DM081409\n*                               DEALING WITH\nTXTMSG   DS    CL8              FIRST 8 BYTES OF WTO/WTOR\nREPLY    DC    Y(REPLYLEN,0)       Reply command prefix         EEJ1102\nREPLYNUM DC    CL4' '              Reply ID                     EEJ1102\nREPLYCOM DC    CL1','\nREPLYMSG DC    CL100' '\nREPLYLEN EQU   *-REPLYNUM          Length of reply buffer       EEJ1102\nMVSCMD   DC    H'109',H'0'\nMVSCMD1  DS    CL105\nFUNC9RC  DS    H                RETURN CODE FOR FUNCTION 9.\nWTO1D    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MCSFLAG=(BRDCST,HRDCPY),MF=L\nWTL1D    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\n************************************************************\n* VARIABLES USED TO PROCESS TEST REQUESTS IN AOF TABLE.\n************************************************************\nWORD1    DS    F                IF TYPE=SUBSTR  STARTING CHARACTER\n*                               IF TYPE=WORD    WORD NUMBER\nWORD2    DS    F                LENGTH OF WORD\nWORDSEPS DS    CL4              SEPARATOR CHARACTORS FOR WORDS.\nSTRSTART DS    A                ADDRESS OF FIRST CHARACTER OF WQE\n*                               MESSAGE. THIS IS WQETXT+1 IF WTO\n*                               and WQETXT+WQERIDL+2 if WTOR.   EEJ1102\nSTRLEN   DS    A                LENGTH OF WQE MESSAGE\n************************************************************\n* VARIABLES USED TO PROCESS P DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSIGSTART DS    F                STARTING ADDRESS OF SIGNIFICANCE\nSIGCOUNT DS    F                NUMBER OF CHARACTERS\n************************************************************\n* PARSE PARAMETERS\n************************************************************\nPARSPARM DS    0H\nPARS1    DS    A\nPARS2    DS    A\nPARS3    DS    A\nPARS4    DS    A\nPARARRAY DS    CL2,20CL16  SPACE FOR COUNT AND 20 ITEMS         15OCT92\nLPARRAY  EQU   *-PARARRAY                                       15OCT92\n************************************************************\n* VARIABLES USED TO PROCESS W DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSEPCHAR  DS    F           SEPARATOR CHARACTERS FOR PARSE\nWORDREQ  DS    F\nLWORDREQ DS    F\nTOKADDR  DS    F           ADDRESS OF REQUESTED TOKEN IN\n*                          PARARRAY\n************************************************************\n* FLAGS USED IN PROCESSING REQUESTS FROM SUBSYSTEM CALL 9\n************************************************************\nFUN9FLG  DS    X\n* X'80'  SSWTMIN \u00ac= 0\n* X'40'  SSWTORE \u00ac= 0\n* X'20'  OSCMDT WAS SPECIFIED\n* X'10'  BSCAN PROCESSING IS DONE\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSSVT\n         IEFJSCVT\n         IEFJSSOB (CM,WT),CONTIG=NO\n         TSSOCVT\n         TSSOCMND\n         TSSONDSA\n         TAOFNTRY\n         OSCMDICB\n         SSCONCBH\n         SSCONCB\n         IHAWQE\n         IHAORE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n************************************************************\n* NOTE: PREVIOUS VERSION OF TSSO HAVE BEEN WRITTEN BY:\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC., MCLEAN VA\n*        DATE WRITTEN. SEPTEMBER 2 1976.\n*        DATE UPDATED. AUGUST 7 1980.\n************************************************************\n         END  TSSOSS09\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOSS09(''TSSO 4.3 &SYSDATE &SYSTIME'')'\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOSS09'\n PUNCH ' NAME     TSSOSS09(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOSS10": {"ttr": 39427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00Y\\x00\\x98\\x06\\x8f\\x01\\x03\\x07\\x7f\\x13\\x02\\x01\\x06\\x01c\\x005\\xd4\\xd4\\xc1\\xe8\\xd5\\xc5@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1998-03-09T00:00:00", "modifydate": "2003-03-18T13:02:59", "lines": 262, "newlines": 355, "modlines": 53, "user": "MMAYNE"}, "text": "TSSOSS10 CSECT\n***********************************************************************\n* THIS IS THE TSSO COMMAND INTERCEPT ROUTINE. CURRENT FUNCTION IS TO  *\n* CHECK FOR A \"#\" AND PASS TO TSSO.                                   *\n*                                                                     *\n* NOTE: ALL MESSAGES START WITH TSSAXXXS WHERE 301 <= XXX <= 350      *\n*       LAST MESSAGE NUMBER = 309                                     *\n***********************************************************************\n*                                                                     *\n* MODIFIED:                                                           *\n*   15OCT92  GLA  HANDLE HARDWARE SYSTEM CONSOLE UCMID (100) FOR      *\n*                 ES/9000 MACHINES.                                   *\n*                                                               EEJ1102\n*   NOV 2002 EEJ  1) Support MCS extended consoles.             EEJ1102\n*            EEJ  2) Remove restriction on non-TSSO commands    EEJ1102\n*                    being issued by consoles that are not      EEJ1102\n*                    logged on to TSSO. This function was       EEJ1102\n*                    incompatible with the MCS LOGON function.  EEJ1102\n*                                                                     *\n***********************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOSS10,R12       GET ADDRESSIBILITY\n         B      ARINIT1\n         DC     CL8'&SYSDATE'      GET DATE\n         DC     CL8'&SYSTIME'      AND TIME FOR QVERS COMMAND\nARINIT1  DS     0H\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=1024\n         LR     R11,R1\n         USING  SS10DATD,R11\n         LR     R10,R8\n         USING  SSOB,R10\n*\n         GETCVT (R8)               FIND TSSO CVT                  RPS\n         USING TSSOCVT,R8\n*****************************************************************\n* IF TSSO IS TERMINATED, UNDER NO CIRCUMSTANCES DO ANYTHING !\n*****************************************************************\n         LTR    R8,R8              ANY CVT ?\n         BO    S34EXIT             NO, DONT DO A THING ...\n*\n         TM    TSSOFLG1,TSSOGONE   TERMINATING?\n         BO    S34OEXIT            YES - IGNORE\n*\n*\n*\n         L     R9,SSOBINDV         POINT TO FUNCTION AREA\n         USING SSCMBGN,R9          ADDRESS IT.\n         L     R2,SSCMBUFF         POINT TO COMMAND BUFFER.\n         LH    R5,0(,R2)           GET LENGTH\n*                                                              MRM03077\n***************************************************************MRM03077\n* The passed length apparently includes the 4 byte header     *MRM03077\n* mapped by the IEZMGCR macro, and the maximum length command *MRM03077\n* is only 126 bytes.  We will subtract four from the passed   *MRM03077\n* length, and use 126 as the maximum length command to check  *MRM03077\n* for.  This was exposed because SDSF was passing a 126 byte  *MRM03077\n* command buffer, regardless of the actual length of the      *MRM03077\n* command entered.                                            *MRM03077\n***************************************************************MRM03077\n*                                                              MRM03077\n         SH    R5,=H'4'\n* COMMAND BUFFER FORMAT IS AS FOLLOWS:\n* 2 BYTES: LENGTH\n* 2 BYTES: WHO KNOWS\n* 126 BYTES: COMMAND\n         CH    R5,=H'126'          OUTRAGEOUS LENGTH?\n         BH    S34OEXIT            YES - IGNORE IT\n         LTR   R5,R5               NEGATIVE LENGTH ?\n         BNP   S34OEXIT            YES - IGNORE\n*                                                               EEJ1102\n****************************************************************EEJ1102\n*                                                              *EEJ1102\n* At this point, when SECLEVEL=MAXIMAL, TSSO used to disallow  *EEJ1102\n* commands issued from consoles that were not logged on to     *EEJ1102\n* TSSO. Commands intended for TSSO were allowed in all cases.  *EEJ1102\n*                                                              *EEJ1102\n* This logic has been removed entirely. MCS consoles have had  *EEJ1102\n* LOGON/LOGOFF capability for a long time so the function is   *EEJ1102\n* no longer valuable. Also, this logic prevented the console   *EEJ1102\n* from issuing the LOGON command itself. Thus, TSSO prevented  *EEJ1102\n* MCS consoles from logging on to MCS. Some consoles *require* *EEJ1102\n* LOGON/LOGOFF (e.g., SMCS consoles). Those consoles could not *EEJ1102\n* be used with TSSO active in SECLEVEL=MAXIMAL mode.           *EEJ1102\n*                                                              *EEJ1102\n****************************************************************EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n* HERE, WE HAVE DETERMINED THAT THE OPERATOR IS SIGNED ON TO TSSO.    *\n* WE WILL ALLOW (AT LEAST IN THIS RELEASE) ALL OPERATOR COMMANDS.     *\n***********************************************************************\n*\n         TM    TSSOFLG2,TSSOMON    MONITORING?\n         BNO   NM1\n         WTO   'TSSA301A TSSO COMMAND INTERCEPT ROUTINE ACTIVE'\n*****************************************************************\n* TSSO SHOULD NOT INTERFERE WITH THIS OS COMMAND                *\n*****************************************************************\nNM1      DS    0H\n         CLC   4(1,R2),TSSOCHAR    MINE?\n         BNE   S34OEXIT            NO - IGNORE\nCMDPROC  DS    0H\n         TM    TSSOFLG2,TSSOMON    MONITORING?\n         BNO   NM2\n         WTO   'TSSA302A TSSO WILL PROCESS THIS COMMAND'\n*****************************************************************\n* HERE, WE HAVE DETERMINED THAT THE OS COMMAND SHOULD BE HANDLED*\n* BY THE TSSO MAINLINE MODULE, IF TSSO IS AVAILABLE.            *\n*****************************************************************\nNM2      DS    0H\n         TM    TSSOFLG1,TSSOGONE   TERMINATING?\n         BNO   STAT2               YES - IGNORE\n         WTO   'TSSA303A TSSO IS IN SHUTDOWN STATUS- CMD REJECTED'\n         B     S34OEXIT            IGNORE COMMAND\nSTAT2    DS    0H\n         L     R3,NEXTCMD          ADDRESS OF NEXT AVAILABLE\n         USING TSSOCMND,R3         ADDRESS RING POSITION\n*                                  COMMAND BUFFER\n         TM    CMNDFLAG,X'80'      IS THIS BUFFER STILL BUSY.\n         BNO   STAT3               YES - BRANCH\n     WTO   'TSSA304A TSSO IS BUSY WITH PREVIOUS COMMNANDS'\n     WTO   'TSSA304A (CONT) THIS MAY INDICATE A TSSO SYSTEM PROBLEM'\n         B     S34BUSY\nSTAT3    DS    0H\n         MVI   CMNDCMD,X'40'\n         MVC   CMNDCMD+1(139),CMNDCMD  BLANK THE COMMAND AREA\n         OI    CMNDFLAG,X'80'      TURN ON COMMAND FLAG\n         BCTR  R5,0                LENGTH MINUS 1 FOR EX\n         EX    R5,MOVECMD          COPY THE COMMAND\n         B     AR1                 BRANCH AROUND MVC\nMOVECMD  MVC   CMNDCMD(0),4(R2)    (EXECUTED)\nAR1      DS    0H\n         MVC   CMNDLENG(4),0(R2)   COPY THE LENGTH\n*                                                               EEJ1102\n         CLC   SSCMCNID,=F'0'      Is this a console ?          EEJ1102\n         BNE   STAT4               Branch if yes                EEJ1102\n*                                                               EEJ1102\n* HERE, WE HAVE FOUND A COMMAND THAT WAS NOT ISSUED FROM A CONSOLE\n* WE WILL INVALIDATE THE BUFFER BY RESETTING THE FLAG, AND\n* ISSUE A MESSAGE TO THE CONSOLE, AND THE PROGRAMMER\n         NI    CMNDFLAG,255-X'80'  INVALIDATE THE COMMAND\n         B     S34EXITM            EXIT WITH A MESSAGE\nSTAT4    DS    0H\n         MVC   CMNDCONS,SSCMCNID   Save 4-byte console ID       EEJ1102\n         MVC   CMNDNAME,SSCMSCNM   Save 8-byte console name     EEJ1102\n         MVC   CMNDAUTH,SSCMAUTH   Save console authorization   EEJ1102\n         L     R2,CMNDNEXT\n         ST    R2,NEXTCMD          DO THIS FOR NEXT TIME.\n         TM    TSSOFLG2,TSSOOKFL   IS 'OK' TO BE SUPPRESSED?\n         BO    S34NOACK            YES - BRANCH\n         MVC   WORKAREA(OKMSGL),OKMSG Copy WTO parm list        EEJ1102\n         WTO   CONSID=SSCMCNID,    Issue OK message             EEJ1102+\n               MF=(E,WORKAREA)     (same)                       EEJ1102\n         B     S34NOACK            Continue                     EEJ1102\n*                                                               EEJ1102\nOKMSG    WTO   '# OK',CONSID=,MF=L OK message parameter list    EEJ1102\nOKMSGL   EQU   *-OKMSG             Length of OK message plist   EEJ1102\n*                                                               EEJ1102\nS34NOACK DS    0H\n*****************************************************************\n* NOW, THE IDEA IS TO POST THE TSSO MAINLINE ROUTINE, ONLY IF IT\n* NEEDS TO BE POSTED. IF IT NEEDS TO BE POSTED, THEN THE WAIT\n* BIT IN THE ECB SHOULD BE ON. WE WILL USE COMPARE AND SWAP\n* FOR TWO REASONS. THE FIRST, IS THAT I NEVER USED A COMPARE AND\n* SWAP, THE SECOND, IS THAT WE WANT TO ENSURE THAT TSSO DOESNT\n* TURN THE WAIT BUT ON AFTER WE DO THE TM THAT WOULD BE REQUIRED, AND\n* THEREFORE MISS THE POST.\n*****************************************************************\n         L     R2,$SVPOSTE         GET THE TSSO MAINLINE ECB\n         L     R3,=X'40000000'\n         TM    $SVPOSTE,X'80'      WAIT BIT ON ?\n         BO    DOPOST              IF YES, DO THE POST.\n         N     R2,=X'7FFFFFFF'    COMPARE OPERAND WITH WAIT BIT OFF\n         CS    R2,R3,$SVPOSTE      ** COMPARE AND SWAP **\n         BE    POSTDONE            COMPARE AND SWAP DID THE POST.\nDOPOST   DS    0H\n         LA    R5,$SVPOSTE          GET ECB TO POST\n         L     R6,TSSOASCB          GET ADDRESS SPACE OF TSSO\n         LA    R7,ENDPROG1          GET ERROR ROUTINE FOR XMEM POST\n         LA    R1,$SVPOSTL          GET DSECT FOR XMEM POST\n         SPACE\n         POST  (R5),X'111',ASCB=(R6),ERRET=(R7),MF=(E,(1))\nPOSTDONE DS    0H\n         B     S34MEXIT            INDICATE COMMAND IS MINE\n*\nS34BUSY  LA    R15,SSCMIMSG        COULD NOT EXECUTE\n         B     S34EXIT             ISSUE IEE707I 'TEXT' NOT EXECUTED\n*\nS34MEXIT LA    R15,SSCMSUBC        MINE\n         B     S34EXIT\n*\nS34OEXIT DS    0H\n         LA    R15,SSCMSCMD        NOT MINE\n         B     S34EXIT\n*\nS34EXITM DS    0H                  NOT MINE, EXIT WITH MESSAGE\n         WTO   'TSSA305E TSSO COMMANDS MAY NOT BE ISSUED FROM THIS ENVIX\n               RONMENT',ROUTCDE=(2,11)\n         LA    R15,SSCMSCMD        NOT MINE\n         B     S34EXIT\nSS10LERR DS    0H\n***********************************************************************\n* WE COME HERE IF WE HAVE A LOGICAL ERROR IN TSSOSS10. WE WILL ISSUE  *\n* A MESSAGE, DENY EVERYTHING, AND TERMINATE.                          *\n***********************************************************************\n         XR    R15,R15\n         WTO   'TSSA307S SEVERE ERROR IN TSSOSS10 - CONTACT TSSO SYSTEMX\n               S PROGRAMMER'\nS34EXIT  DS    0H\n         ST    R15,SSOBRETN\n         FREEMAIN R,LV=1024,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n***********************************************************************\n* TSSOSS10 CONSTANTS AREA.                                            *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n* TSSOSS10 DATA AREA.                                                 *\n*                                                                     *\n***********************************************************************\nSS10DATD DSECT\nWORKAREA DS    CL200\nCONSID   DS    F                 CONSOLE ID ISSUING THIS COMMAND\nSAVER10  DS    F                 REGISTER 10 WHEN USING JCE ROUTINE\nMVSCMD   DS    CL100\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSSVT\n         IEFJSCVT\n         IEFJSSOB (CM,WT),CONTIG=NO\nUCM      DSECT\n         IEECUCM\n         TSSOCVT\n         TSSOCMND\n         TSSOSECR\n         IHAWQE\n         IHAORE\n         EQUATES\n         END   TSSOSS10\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOSS10(''TSSO VERSION 4.2 &SYSDATE &SYSTIME'')'\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOSS10'\n PUNCH ' NAME     TSSOSS10(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOTERM": {"ttr": 39432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x00\\x97&\\x9f\\x01\\x07\\x07\\x0f\\x06!\\x01\\x9b\\x01\\x9a\\x00\\x12\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2007-03-11T06:21:48", "lines": 411, "newlines": 410, "modlines": 18, "user": "SBGOLOB"}, "text": "&WTOR   SETC   'YES'\n***********************************************************************\n* THIS MODULE WILL BE RESPONSIBLE FOR CLEANING UP TSSO RESOURCES      *\n* WHEN TSSO IS TERMINATING. THE MODULE WILL BE CALLED FROM ONE OF     *\n* TWO PLACES, EITHER FROM THE TSSOESTA ROUTINE, OR FROM THE TSSO      *\n* PROCESSING MODULE.                                                  *\n***********************************************************************\n***********************************************************************\n* NOTE: ALL MESSAGES PRODUCED BY THIS MODULE HAVE THE FORM:           *\n* TSSDXXXS WHERE 301 <= XXX <= 350                                    *\n* NOTE: THE LAST MESSAGE NUMBER IN USE IS 305.                        *\n* NOTE: THE \"D\" IN THE MESSAGE ID STANDS FOR \"DEATH\".                 *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*   20OCT92  GLA  USE NEW DSECT FOR AOF TABLE                         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nTSSOTERM CSECT\n         EQUATES\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOTERM,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=1024\n         LR     R11,R1\n         USING  TERMDATD,R11\n         MVC    POST1D(POST1CE-POST1C),POST1C\n         MVC    TRMWTO1D(TRMWTO1E-TRMWTO1C),TRMWTO1C\n**********************************************************************\n* THIS MODULE IS THE TERMINATE ROUTINE FOR TSSO. ITS PURPOSE IS TO GAIN\n* CONTROL OF TSSO AFTER A FAILURE, AND PERFORM THE FOLLOWING FUNCTIONS\n*\n* 1) DISCONNECT THE SUBSYSTEM FROM MVS.\n* 2) FREEMAIN THE TSSO COMMAND RING\n* 3) FREEMAIN THE TSSO SSVT\n* 4) DELETE THE TSSO AUTOMATED OPERATOR PROCEDURE TABLE\n* 5) DELETE THE TSSO SUBSYSTEM SUPPORT MODULE(S)\n* 6) DECREMENT THE COUNT OF SUBSYSTEMS REQUESTING WTO BROADCASTS\n* 7) RETURN THE JOB ID TO JES.\n* 8) DE-ALLOCATE THE SUBSYSTEM ALLOCATABLE CONSOLE(S)\n* 9) FREEMAIN THE TSSO SECURITY ARRAY\n*10) LASTLY, FREEMAIN THE TSSO CVT\n*\n**********************************************************************\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         L     R9,TSSODSEC\n         USING DATD,R9\n         ESTAE 0\nESTAEX   DS    0H\n**********************************************************************\n* AT THIS POINT, THE TERMINATION ROUTINE IS READY TO GO.\n* STEP 1 IS TO DISCONNECT THE SUBSYSTEM\n**********************************************************************\n         MODESET KEY=ZERO\n         OI    TSSOFLG1,TSSOGONE       SET TERMINATION FLAG\n         L     R2,TSSOSSCT             LOAD ADDRESS OF SSCT\n         LTR   R2,R2                   MAKE SURE IT EXISTS\n         BZ    NOSSCT\n         XR    R3,R3                   WIPE OUT R3\n         USING SSCT,R2\n         CLC   SSCTSNAM(4),=CL4'TSSO'  MAKE SURE ITS TSSO\n         BNE   NOSSCT\n         ST    R3,SSCTSSVT             ** DISC SUBSYSTEM **\n         DROP  R2\n*\n         B     FREEIT\nNOSSCT   DS    0H\n         WTO   'TSSD301S UNABLE TO DISCONNECT SUBSYSTEM- SSCT POINTER IX\n               VALID',DESC=(1)\nENDST1   DS    0H\n         B     STEP2\n*\n*\n*\n*\nSTEP2    DS    0H\nFREEIT   DS    0H\n**********************************************************************\n* STEP 2 AFTER DISCONNECTING THE SUBSYSTEM IS TO FREEMAIN THE TSSO\n* COMMAND RING. THIS IS A RELATIVELY STRAIGHTFOWARD PROCEDURE\n**********************************************************************\n         L     R2,NUMCMDS             GET MAX COMMAND ENTRY FOR TSSO\n         SLL   R2,8\n         L     R1,CMDRING             GET ADDRESS OF COMMAND RING\n         FREEMAIN R,LV=(R2),A=(R1),SP=241      COMMAND RING\nENDST2   DS    0H\n         B     STEP3\n*\n*\n*\n*\n*\n*\nFREESSVT DS    0H\nSTEP3    DS    0H\n**********************************************************************\n* STEP 3 AFTER FREEING THE COMMAND RING, IS TO FREEMAIN THE TSSO SSVT\n*\n**********************************************************************\n         L     R2,TSSOSSVT            GET ADDRESS OF SSVT\n         LTR   R2,R2\n         BZ    NOSSVT\n         SL    R2,=F'4'        ACTUAL SSVT IS FOUR BYTES LESS THEN\n*                              SSVT PRESENTED TO MVS FOR SSVT HEADER\n         CLC   0(4,R2),=CL4'SSVT'     MAKE SURE\n         BNE   NOSSVT                 IT ISNT FAKED\n         FREEMAIN R,LV=1024+256+4+4,SP=241,A=(R2)   FREEMAIN IT\n         B     FREEMORE\nNOSSVT   DS    0H\n         WTO   'TSSD302S UNABLE TO FREEMAIN SSVT- SSVT POINTER INVALID'X\n               ,DESC=(1)\nFREEMORE DS    0H\n**********************************************************************\n* STEP 4 AFTER FREEING THE SSVT IS TO PERFORM A MODULE DELETE ON THE\n* TSSO AUTOMATED OPERATOR FACILITY REPLY TABLE.\n*\n* TSSO 4.3 WILL CHECK IF THERE ARE ANY ACTIVE OSWAITS BEFORE DELETING\n* THE TABLE. IF SO, IT WILL POST THEM WITH BAD RETURN CODES AND ALLOW\n* TERMINATION TO PROCEED.\n*\n*\n**********************************************************************\n         L     R2,TSSOTABL         GET ADDRESS OF TSSO AOF TABLE.\n         LTR   R2,R2               DOES IT EXIST ?\n         BZ    NOREPLY\n         L     R2,0(R2)           POINT TO FIRST RECORD IN TABLE.\n         USING AOFNTRY,R2         SETUP ADDRESSABILITY FOR ENTRY\n         XR    R4,R4              FLAG...\nRELALOOP DS    0H\n         CLC   AOFMSGID,=CL8'ZZZZZZZZ' END OF TABLE ?\n         BE    RELEOT                  YES, END OF TABLE...\n         CLC   AOFACTN,=CL8'POST'      IS THIS ACTION=POST ?\n         BNE   RELNENT                 NO, CHECK NEXT ENTRY\n         TM    AOFPFLG,AOFP1WT         IS IT BEING WAITED ON ?\n         BNO   RELNENT                 NO, DO BOTHER...\n         L     R5,AOFPECB              GET ECB TO POST\n         L     R3,AOFPASCB             GET THE ADDRESS SPACE...\n         POST  (R5),X'FFF',ASCB=(R3),ERRET=DODEL,MF=(E,POST1D)\n         LA    R4,1\n         B     RELNENT\nRELNENT  DS    0H\n         L     R2,AOFNXT\n         B     RELALOOP\n         DROP  R2\n*\nRELEOT   DS    0H\n         LTR   R4,R4              ANYBODY WAITING ?\n         BZ    DODEL\n*\n         WTO   'TSSC142I TERMINATION DELAYED - ACTIVE OSWAITS IN PROGREX\n               SS'\n         MVC   DINTVL(8),=CL8'00000200'   WAIT TWO SECONDS.....\n         STIMER WAIT,DINTVL=DINTVL\n*\nDODEL    DS    0H\n         LA    R2,16(R2)           POINT TO TABLE NAME\n         DELETE EPLOC=(R2)         ALL GONE...\n*\nNOREPLY  DS    0H\n**********************************************************************\n* STEP 5 AFTER DELETE THE AOF TABLE, IS TO DELETE THE SUBSYSTEM SUPPORT\n* MODULES. A LOOP IS REQUIRED TO DO THIS, BECAUSE THERE MAY BE MORE\n* THEN ONE.\n**********************************************************************\nFREESSSM DS    0H\n         LH    R2,SSICOUNT\n         LA    R3,SSIARRAY\nFREESSLP DS    0H\n         DELETE EPLOC=8(R3)            ALL GONE...\n         LA    R3,36(R3)               NEXT ENTRY\n         BCT   R2,FREESSLP\n**********************************************************************\n* STEP 6 AFTER DELETING THE SSSM MODULE IS TO DECREMENT THE COUNT OF\n* SUBSYSTEMS RECEIVEING WTO REQUESTS. THIS IS REQUIRED IF ASSURE\n* SUCCESS OF FUTURE STARTUPS OF TSSO.\n**********************************************************************\n         L     R2,16\n         USING CVT,R2\n         L     R2,CVTCUCB           GET UCM PREFIX\n         USING UCM,R2\n         AIF   ('&WTOR' NE 'YES').NOBRD2\n         LH    R3,UCMBRDST\n         BCTR  R3,0         (NOT BALR - MARC)\n         STH   R3,UCMBRDST\n.NOBRD2  ANOP\n         DROP  R2\n**********************************************************************\n* STEP 7 CONCERNS RETURNING THE JOB ID TO JES. THIS IS A SUBSYSTEM\n* FUNCTION. THIS ALLOWS JES TO NUKE CONTROL BLOCKS, CLOSE SUBSYSTEM\n* DATASETS AND THE LIKE. IT IS NOT REQUIRED IF TSSO NEVER OBTAINED A\n* JES ID.\n* THE FIRST STEP IN THIS FUNCTION IS TO MODIFY THE JSCBSSIB FIELD\n* TO REFLECT WHAT IT WAS ORIGNINALLY.\n**********************************************************************\nTRMSTEP7 DS    0H\n         TM    TSSOFLG1,TSSOJSMD     DID TSSO EVER MODIFY THE JSCBSSIB\n         BZ    JSCBOK\n* WE MUST MODIFY THE JSCB\n         L     R15,540               CURRENT TCB POINTER\n         L     R15,180(R15)          TCBJSCB FIELD\n         USING IEZJSCB,R15\n         L     R15,JSCBACT\n         L     R5,TSSOSSIB           GET ORIGNAL SSIB\n         ST    R5,JSCBSSIB           AND STORE IT IN...\n         DROP  R15\nJSCBOK   DS    0H\n         TM    TSSOFLG1,TSSOJBID     DID TSSO EVER GET A JOBID ?\n         BZ    NORETJOB              NOPE, DONT SWEAT IT.\n*\n         LA    R5,$SVSSOB            THIS FIELD WAS PREVIOUSLY\n*                                    INITIALIZED IN THE REQUEST\n*                                    JOBID FUNCTION OF TSSO\n         USING SSOB,R5               ADDRESS IT\n         LA    R15,SSOBRTRN          GET JES FUNCTION CODE\n         STH   R15,SSOBFUNC          AND PUT IN SSOB\n*\n         MODESET MODE=SUP            SUBSYSTEM REQUESTS NEED\n*                                    SUPERVISOR MODE\n         LA    R1,$SVSSOBA           THIS FIELD WAS INITIALIZED TO\n*                                    THE START OF THE SSOB IN THE\n*                                    REQUEST JOBID FUNCTION.\n         IEFSSREQ\n         LR    R5,R15\n*\n         MODESET MODE=PROB           ALL DONE\n         LTR   R5,R5\n         BNZ   ERRRETJB\n         B     NORETJOB\nERRRETJB DS    0H\n         WTO   'TSSD303E TSSO UNABLE TO RETURN JOB ID TO JES'\n*\nNORETJOB DS    0H\nTRMSTEP8 DS    0H\n***********************************************************************\n* STEP 8 OF THE TSSO TERMINATION PROCEDURE WILL BE TO DEALLOCATE THE  *\n* SUBSYSTEM CONSOLE, IF WE HAD PREVIOUSLY OBTAINED ONE. A CALL TO THE *\n* TSSO CONSOLE SERVICE ROUTINE WILL DO THE TRICK.                     *\n*\n* NOTE: TSSO 4.3 MODIFIES THIS ROUTINE TO DELETE *ALL* OF THE OBTAINED*\n* CONSOLES, IN ADDITION TO FREEMAINING THE SSCONCB AND THE SSCONCBH   *\n***********************************************************************\n         L     R8,SSCONSAD       GET THE SS CONSOLE CONTROL BLK HEADER\n         USING SSCONCBH,R8\n         LA    R8,SSCONFIR       POINT TO FIRST ELEMENT\nFRESCNLP DS    0H\n         USING SSCONCB,R8\n         L     R1,SSCONNUM       GET TSSO CONSOLE ID...\n         LTR   R1,R1             ANYTHING THERE ?\n         BZ    FRECONCB          NO, GO DO THE FREEMAIN\n*\n         LA    R5,3              TRY TO FREE IT THREE TIMES.\nSSCFRELP DS    0H\n         TM    SSCONFLG,X'80'    IS SOMEONE USING THE SS CONSOLE ?\n         BNO   SSCNUSE           NO, SS CONSOLE NOT IN USE.\n*\n         L     R2,SSCONICB       GET THE ICB...\n         LTR   R2,R2             ANYTHING THERE ?\n         BZ    SSCNUSE\n*\n         NI    SSCONFLG,255-X'20'    TURN OFF TSSO MSG TRAPPING\n*\n         USING OSCMDICB,R2\n         LA    R3,OSCMDECB       GET ECB  FOR XMEM POST\n         L     R4,OSCMDACB       AND THE ASCB IS ALSO NEEDED\n         POST  (R3),X'EEE',ASCB=(R4),ERRET=SSCNUSE,MF=(E,POST1D)\n*\n         L     R1,SSCONNUM\n         ST    R10,TSCVTPTR      REMEMBER TSSO CVT ADDR\n         LR    R10,R11           FOR CONVERT ROUTINE\n         CALL  JCECVTBD\n         L     R10,TSCVTPTR      AND BACK TO THE CVT\n         STH   R1,TRMWTO1D+58\n         WTO   MF=(E,TRMWTO1D)   (MSG 305) - INDICATING SSCON BUSY.\n*\n         MVC   DINTVL(8),=CL8'00000200'   2 SECONDS TO FREE SS CONSOLE\n         STIMER WAIT,DINTVL=DINTVL\n*\n         BCT   R5,SSCFRELP\n         DROP  R2\n*\nSSCNUSE  DS    0H\n         L     R1,SSCONNUM       RESTORE CONSOLE NUMBER FOR FREE ROUT.\n*DRCICS* STH   R1,TSSCONID       STICK IN TSSCONID.\n         ST    R1,TSSCONID       STICK IN TSSCONID.\n         LA    R0,4\n         LINK  EP=TSSOGSSC          TSSOGSSC WILL DO THE FREEING\n         LA    R8,SSCONCBL(R8)\n         B     FRESCNLP\nFRECONCB DS    0H\n         L     R8,SSCONSAD       GET THE SSCONCB HEADER\n         LTR   R8,R8\n         BZ    NOFRECCB\n         FREEMAIN R,LV=1024,A=(R8),SP=241   AND PERFORM THE FREEMAIN\n         B     TRMSTEP9\nNOFRECCB DS    0H\n         WTO   'TSSD304E UNABLE TO FREE SSCONCBH - BAD POINTER'\n         B     TRMSTEP9\n*\nTRMSTEP9 DS    0H\n***********************************************************************\n* STEP 9 OF THE TERMINATION PROCEDURE IS TO FREEMAIN THE TSSO         *\n* SIGNON TABLE. THE ADDRESS IS POINTED TO FROM THE SECARRAY FIELD IN  *\n* THE TSSO DATA AREA.                                                 *\n***********************************************************************\n         L     R5,SECARRAY         GET ADDRESS\n         LTR   R5,R5\n         BZ    TRMSTE95            NO SECARRAY - GO DO NEXT THING\n*\n         FREEMAIN R,LV=1024,A=(R5),SP=241\n         B     TRMSTE95\nTRMSTE95 DS    0H\n***********************************************************************\n* STEP 2.5 OF THE TSSO TERMINATION PROCEDURE IS TO DESTROY THE CROSS  *\n* MEMORY SERVICES ENVIRONMENT. THIS IS DONE IMMEDIATELY TO PREVENT    *\n* ERRENT CROSS MEMORY SERVICE CALLS.                                  *\n***********************************************************************\n         GETCVT (R8),NDSA=YES\n         USING TSSONDSA,R8\n         TM    TSSOFLG2,TSSOXMON          XMEM EVER CREATED ?\n         BNO   ENDST9#5                    DONT BOTHER\n*\n         ETDES TOKEN=TSSOETTK,PURGE=YES,  GIVE IT THE TOKEN            X\n               MF=(E,ETDESD)              TO DESTROY XMEM ENVIRONMENT\n         NI    NDSAFLG1,255-X'10'         INDICATE ENVIRONMENT GONE.\n         DELETE EP=TSSOGAPF               DELETE THE XMEM MODULE.\n         DROP  R8\n*\nENDST9#5 DS    0H\n         B     TRMSTEPA\n*\nTRMSTEPA DS    0H\n***********************************************************************\n* STEP 10 OF THE TERMINATION PROCEDURE IS TO DELETE THE TSSOPCMD      *\n* MODULE FROM GLOBAL STORAGE.                                         *\n***********************************************************************\n         TM    TSSOFLG2,TSSOPLOA   WAS TSSOPCMD LOADED\n         BNO   TRMSTEPB\n         DELETE EP=TSSOPCMD\n         B     TRMSTEPB\nTRMSTEPB DS    0H\n***********************************************************************\n* FREEMAIN THE TSSO COMMUNICATIONS VECTOR TABLE, POINTER TO VIA       *\n* THE SSCTSUSE FIELD, AND STORE ZEROES INTO THAT FIELD.               *\n* NOTE THAT R10 STILL POINTS TO THE SSCTSUE FIELD (TSSO CVT)\n***********************************************************************\n         FREEMAIN R,LV=1024,SP=228,A=(R10)\n         GETCVT (R10),POINTER=YES\n         XR     R1,R1\n         ST     R1,0(R10)         BLANK OUT THE SSCTSUE\n         MODESET KEY=NZERO\n*\nENDPROG  DS    0H\n         FREEMAIN R,LV=1024,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\nPOST1C   POST  ,ASCB=0,ERRET=0,MF=L\nPOST1CE  DS    0H\n*\nTRMWTO1C WTO   'TSSD305I TSSO TERMINATION DELAYED - SUBSYSTEM CONSOLE XX\n               X BUSY',MF=L\nTRMWTO1E EQU   *\n*\nTERMDATD DSECT\nWKRATERM DS    CL200\nPOST1D   POST  ,ASCB=0,ERRET=0,MF=L\n*\nTRMWTO1D WTO   'TSSD305I TSSO TERMINATION DELAYED - SUBSYSTEM CONSOLE XX\n               X BUSY',MF=L\nDINTVL   DS    CL8\nTSCVTPTR DS    F\nUCM      DSECT\n         IEECUCM\n*\n         TSSOCVT\n         TSSONDSA\n         TAOFNTRY\n         COPY   TSSODATD\n         IEFJESCT\n         IEFJSCVT\n         IEFJSSOB (CM,RR),CONTIG=YES\n         IEZJSCB\n         CVT  DSECT=YES\n         SSCONCBH\n         SSCONCB\n         OSCMDICB\n         END  TSSOTERM\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOTERM(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOTERM'\n PUNCH ' NAME     TSSOTERM(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSOWTO": {"ttr": 39684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x03\\x00\\x97&\\x9f\\x01 \\x13\\x8f\\x14V\\x01J\\x01?\\x00\\x1c\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2020-05-17T14:56:03", "lines": 330, "newlines": 319, "modlines": 28, "user": "SBGOLOB"}, "text": "         TITLE 'T S S O    WRITE TO OPERATOR'\nTSSOWTO  CSECT\n         EQUATES\n***********************************************************************\n* THIS MODULE IS THE TSSO WRITE TO OPERATOR MODULE. ITS PURPOSES ARE  *\n* TWOFOLD. THE FIRST IS TO WRITE EVERY RECORD FROM THE SYSTSPRT FILE  *\n* TO THE OPERATORS CONSOLE. THE SECOND IS TO INTERCEPT THOSE RECORDS  *\n* THAT START WITH \"*COM\" AND ISSUE THE REST OF THE RECORD AS AN       *\n* OPERATOR COMMAND.                                                   *\n*                                                                     *\n* PARAMETERS PASSED:                                                  *\n* 0(R1) ADDRESS OF WORD CONTAINING CONSOLE ID FOR THE CONSOLE THAT    *\n*       ISSUED THE COMMAND FOR WHICH OUTPUT IS BEING DISPLAYED.       *\n*                                                                     *\n* 4(R1) THE MAXIMUM NUMBER OF WTO'S TO BE DISPLAYED IN A SINGLE       *\n*       COMMAND. THIS PARAMETER IS OBTAINED THROUGH THE TSSO          *\n*       INITIALIZATION PROCEDURES.\n*\n* 8(R1) ADDRESS OF A FLAG WORD, USED TO PASS PROCESSING OPTIONS       *\n*\n* THIS SUBROUTING ASSUMES A DDCARD OF SYSTSPRT IS IN THE TSSO JCL.    *\n* FURTHER, IT ASSUMES THAT TSSO HAS A LRECL OF 137 BYTES, AND IS RECFM*\n* OF VARIABLE BLOCKED (VBA)\n* THIS SHOULD BE SPECIFIED IN THE TSSO STARTUP JCL.\n***********************************************************************\n* NOTE: ALL MESSAGES PRODUCED BY THIS MODULE HAVE THE FORM TSSWXXXS   *\n* WHERE 351 <= XXX <= 400 AND \"S\" IS THE SEVERITY OF THE MESSAGE.     *\n***********************************************************************\n*                                                               EEJ1102\n* Change Activity:                                              EEJ1102\n*                                                               EEJ1102\n*   NOV 2002 EEJ Support MCS extended consoles                  EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSO\n         USING TSSOWTO,R12        GET ADDRESSIBILITY\n         B     ARINIT1\n         DC    CL8'&SYSDATE'      DATE FOR QVERS COMMAND\n         DC    CL8'&SYSTIME'      TIME FOR QVERS COMMAND\nARINIT1  DS    0H\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         LTR   R15,R15\n         BNZ   GETMERR            GETMAIN FAILED\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                 SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n***********************************************************************\n* GETMAIN DYNAMIC STORAGE FOR TSSOWTO VARIABLES.\n***********************************************************************\n         GETMAIN R,LV=1024\n         LR    R11,R1\n         USING DATD,R11\n*\n         MVC   OPEND(OPENCE-OPENC),OPENC\n         MVC   CLOSED(CLOSECE-CLOSEC),CLOSEC\n         MVC   INDCBD(INDCBCE-INDCBC),INDCBC\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         XC    WTONUM(4),WTONUM    INITIALIZE NUMBER OF WTOS ENCOUNTER\n         L     R2,0(R8)            GET ADDRESS OF CONSOLE ID.\n         L     R3,0(R2)            AND GET ACTUAL VALUE OF CONSOLE ID\n         ST    R3,CONSID           STORE IT AWAY. THIS CONSOLE ID WILL\n*                                  BE USED TO ISSUE COMMANDS AND WTOS\n         L     R2,4(R8)            GET MAX WTO ADDRESS\n         L     R3,0(R2)            AND GET ACTUAL VALUE\n         ST    R3,MAXWTO          STORE PARAMETER\n*\n         L     R2,8(R8)            GET A(TSSWFLAG)\n         L     R2,0(R2)\n         ST    R2,TSSWFLAG         AND PUT IT AWAY\n*\n         LA    R10,INDCBD          GET DCB ADDRESS\n         OPEN  ((R10),INPUT),MF=(E,OPEND)\n         TM    INDCBD+48,X'10'     IS IT REALLY (TRUELY) OPENED ?\n         BNO   TSPRTERR            YIPES! MAJOR PROBLEMS !\n*\nNEXTREC  DS    0H                   BLANK OUT INPUT BUFFER.\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(136),BUFFER\n         MVI   WTO1D+4,X'40'       BLANK OUT WTO BUFFER TOO\n         MVC   WTO1D+5(124),WTO1D+4\n         LA    R10,INDCBD          RESTORE DCB ADDRESS\n         GET   (R10),BUFFER        READ A RECORD..\n         MVI   BUFFER+4,X'40'      BLANK OUT CARRAIGE CONTROL.\n         LH    R2,BUFFER           GET LENGTH OF THIS RECORD.\n         CH    R2,=H'125'          GREATER THEN 125 CHARS, THE MAX THAT\n*                                 CAN FIT ON A WTO ?\n         BNH   LENGTHOK            YUP, ADJUST.\n         LH    R2,=H'125'          ADJUSTING...\nLENGTHOK DS    0H\n         ST    R2,LREC             THIS WILL BE LENGTH OF THIS RECORD.\nPROCREC  DS    0H\n         CLC   BUFFER+5(4),=CL4'*COM'  OPERATOR COMMAND REQUESTED ?\n         BE    ISSUECMD                YUP, GO ISSUE COMMAND.\n         CLC   BUFFER+5(3),=CL3'*HI'   HILIGHT THIS MESSAGE ?\n         BE    WTOHI                   YUP.. DUMMY UP DESCRIPTOR CODE\n***********************************************************************\n* NO SPECIAL TSSO CLIST CONSTRUCT HAS BEEN FOUND, SO WE WILL\n* OUTPUT THE LINE IN A WTO MESSAGE TO THE CONSOLE THAT ISSUED THE\n* COMMAND\n***********************************************************************\n         L     R2,LREC                 PICK UP LENGTH OF RECORD.\n         BCTR  R2,0                    -1 FOR EXECUTE\n         EX    R2,MOVEWTO              MOVE BUFFER CONTENTS TO WTO\n         B     AR1\nMOVEWTO  MVC   WTO1D+4(0),BUFFER+5     ** EXECUTED **\nAR1      DS    0H\n         WTO   CONSID=CONSID,      Print buffer line on console EEJ1102+\n               MF=(E,WTO1D)        (same)                       EEJ1102\n         L     R2,WTONUM               INCREMENT WTO NUMBER\n         LA    R2,1(R2)\n         C     R2,MAXWTO               PAST THE MAXWTO LIMIT ?\n         BNL   WTOLIM                  YUP, QUITE SAD.\n         ST    R2,WTONUM\n         B     RECEND                  ONWARD\nWTOHI    DS    0H\n***********************************************************************\n* HILIGHTING OF THIS WTO MESSAGE HAS BEEN REQUESTED.\n***********************************************************************\n         L     R2,LREC                 PICK UP LENGTH OF RECORD.\n         BCTR  R2,0                    -1 FOR EXECUTE\n         EX    R2,MOVEWTO2\n         B     AR2\nMOVEWTO2 MVC   WTO1D+4(0),BUFFER+9\nAR2      DS    0H\n         LA    R3,WTO1D        ADDRESS OF WTO CONSTRUCT\n         AH    R3,0(R3)        R1 IS NOW POINTING TO THE ROUTINE AND\n*                              DESCRIPTOR CODES.\n         OI    0(R3),X'80'     SET DESCRIPTOR CODE 1\n         L     R0,CONSID               DESTINATION CONSOLE\n         WTO   MF=(E,WTO1D)\n         NI    0(R3),255-X'80' SET DESCRIPTOR CODE ZERO\n         L     R2,WTONUM       INCREMENT WTO NUMBER\n         LA    R2,1(R2)\n         C     R2,MAXWTO               PAST THE MAXWTO LIMIT ?\n         BNL   WTOLIM                  YUP, QUITE SAD.\n         ST    R2,WTONUM\n         B     RECEND\nISSUECMD DS    0H\n***********************************************************************\n* WE COME HERE WHEN A REQUEST TO ISSUE AN MVS COMMAND HAS BEEN        *\n* ENCOUNTERED. THE CONSOLE AUTHORITY OF THE INVOKING CONSOLE IS USED  *\n* FOR THE COMMAND.                                                    *\n*                                                                     *\n***********************************************************************\n* FIRST, WE MUST SEE IF A DELAY FACTOR WAS SPECIFIED. WE ALLOWS DELAYS\n* OF BETWEEN 1 AND 999 SECONDS, THEREFORE, THE DELAY FACTOR CAN BE\n* BETWEEN ONE AND THREE DIGITS. WE WILL SCAN THE BUFFER, FIND THE\n* NUMBER OF DIGITS, AND IMPLEMENT THE DELAY.\n***********************************************************************\n         TM    TSSWFLAG,X'80'       NOT ISSUE COMMANDS (#.L)\n         BNO   NODUPL               YUP! GET NEXT RECORD.\n         MVC   BUFFER+5(4),=CL4'*DUP'  INDICATE DUPLICATE COMMAND\n         B     PROCREC                 AND REPROCESS THE RECORD.\nNODUPL   DS    0H\n***********************************************************************\n* WE COME HERE IF THE COMMAND IS REALLY GOING TO BE ISSUED, I.E.\n* NOT A #.L REPITION OF A COMMAND THAT HAS ALREADY BEEN EXECUTED.\n***********************************************************************\n         LA    R2,BUFFER+9          START AT POTENTIAL FIRST DIGIT.\n         XR    R3,R3                 COUNT OF NUMBERS FOUND SO FAR.\n         XC    CMDDELAY(4),CMDDELAY   ASSUME NO DELAY IN THIS COMMAND\nDIGLOOP  DS    0H\n         CLI   0(R2),C' '\n         BE    ENDDLOOP             NO MORE BLANKS.\n         CLI   0(R2),C'0'           CHECK FOR CHAR ZERO\n         BL    ENDDLOOP\n         CLI   0(R2),C'9'           CHECK FOR HIGHER THEN NINE\n         BH    ENDDLOOP\n         LA    R2,1(R2)             INCREMENT LOOP COUNTER\n         LA    R3,1(R3)             INCREMENT COUNT\n         B     DIGLOOP\nENDDLOOP DS    0H\n         CH    R3,=H'3'             ONLY DELAYS OF 999 SECONDS ARE OK\n         BH    INVDELAY\n         LA    R2,1(R2)             R2 NOW POINTS TO START OF COMMAND.\n         ST    R2,CMDSTART          SAVE STARTING ADDRESS OF COMMAND\n         ST    R3,DELAYCHR          STORE NUMBER OF EBCIDIC CHARS THAT\n*                                   MAKE UP THE DELAY.\n         LTR   R3,R3                ANY DELAY ?\n         BZ    BLANKEM              NO, SKIP DELAY STUFF.\n         LR    R0,R3                COPY LENGTH OF DELAY\n         LA    R1,BUFFER+9          STARTING ADDRESS OF DELAY.\n         LA    R10,WORKAREA\n         CALL  JCECVTDB             ** CONVERT **\n         ST    R1,CMDDELAY          STORE DELAY AWAY.\n***********************************************************************\n* WE WILL BLANK OUT THE EBCIDIC CHARACTERS REPRESENTING THE DELAY\n* AND THE \"*COM\" SO THESE CHARACTERS ARE NOT ISSUED AS PART OF THE\n* OPERATOR COMMAND.\n***********************************************************************\nBLANKEM  DS    0H\n         LA    R3,4                 START WITH CHARS FOR \"*COM\"\n         A     R3,DELAYCHR          ADD CHARS FOR EBCIDIC NUMBERS IN\n*                                   DELAY\n         BCTR  R3,0                 -1 FOR EXECUTE\n         EX    R3,BLANKBUF\n         B     AR3\nBLANKBUF MVC   BUFFER+5(0),=CL8' '   ** EXECUTED **\nAR3      DS    0H\nDELAYIT  DS    0H\n         L     R3,CMDDELAY\n         LTR   R3,R3                AND DELAY ?\n         BZ    DOCMD\n         M     R2,=F'100'           BECAUSE BINTVL IS ONLY .01 SECONDS\n         ST    R3,CMDDELAY\n         STIMER WAIT,BINTVL=CMDDELAY    DELAY THE COMMAND FOR\n*                                  THE SPECIFIED TIME PERIOD\nDOCMD    DS    0H\n*                                                               EEJ1102\n         L     R0,LREC             Get length of cmd buffer     EEJ1102\n         SH    R0,=H'4'            Decrement for MGCR prefix    EEJ1102\n         STH   R0,BUFFER+2         Store true command text len  EEJ1102\n         MVC   WORKAREA(MGCREL),MGCRE Copy MGCRE parm list      EEJ1102\n         LA    R2,BUFFER+2         Point to command text        EEJ1102\n         MODESET MODE=SUP\n         MGCRE TEXT=(2),           Issue the command            EEJ1102+\n               CONSID=CONSID,      (same)                       EEJ1102+\n               MF=(E,WORKAREA)     (same)                       EEJ1102\n         MODESET MODE=PROB\n         B    RECEND\nRECEND   DS   0H\n         B    NEXTREC\n*                                                               EEJ1102\nMGCRE    MGCRE MF=L                MGCRE parameter list         EEJ1102\nMGCREL   EQU   *-MGCRE             (same)                       EEJ1102\n*                                                               EEJ1102\nWTOLIM   DS   0H\n***********************************************************************\n* WE COME HERE WHEN THE MAXIMUM NUMBER OF WTO LINES HAS BEEN REACHED, *\n* WE WILL PRINT A LINE EXPLAINING WHAT HAPPENED, AND TERMINATE.       *\n***********************************************************************\n         WTO  'TSSW351A WTO LIMIT REACHED FOR THIS COMMAND, OUTPUT TERMX\n               INATED'\n         B     ENDRECS               AND WE TERMINATE.\nTSPRTERR DS    0H\n***********************************************************************\n* WE COME HERE IF WE ENCOUNTERED A PROBLEM OPENING THE SYSTSPRT\n* FILE. STANDARD PROCEDURE IS TO ISSUE A MESSAGE REQUESTING THAT TSSO\n* BE SHUT DOWN AND RESTARTED.\n***********************************************************************\n         WTO   'TSSW352S ERROR OPENING SYSTSPRT DDNAME- PLEASE CONTACT X\n               SYSTEMS PROGRAMMER',DESC=(1)\n         B     ENDPROG\nINVDELAY DS    0H\n         WTO   'TSSW353E INVALID DELAY FOR OPERATOR COMMAND- COMMAND TEX\n               XT FOLLOWS'\n         MVC   BUFFER+5(4),=CL4'*ERR'      INFORM USER OF ERROR\n         B     PROCREC                     AND SIMULATE A NORMAL MSG\nENDRECS  DS   0H\nENDPROG  DS   0H\n         LA   R2,INDCBD\n         CLOSE ((R2)),MF=(E,CLOSED)\n*\n***********************************************************************\n* THE BELOW INSTRUCTIONS ARE NECCESARY BECAUSE TSSO CAN CONCEIVAVLY   *\n* USE GREAT AMOUNTS OF VIRTUAL STORAGE DURING THE COURSE OF A DAY,    *\n* WHAT WITH TSO CONSTRUCTING DCBS FOR EACH COMMAND ENTERED.           *\n*                                                                     *\n* THE FREEPOOL MACRO WILL FREE THESE BUFFERS, EXCEPT IF THEY WERE     *\n* OBTAINED IN PROTECT KEY ZERO. SINCE TSO OPENED SYSTSPRT IN KEY ZERO *\n* THE FREEMAIN MACRO MUST SPECIFY SUBPOOL 252. THIS IS ACCOMPLISHED BY*\n* BACKING THE LOCATION COUNTER UP BY TWO BYTES, THUS OVERWRITING THE  *\n* SVC 10, THEN \"OR\"ING THE SUBPOOL 252 INTO R0. THIS EFFECTIVELY ADDS *\n* THE SP=252 OPERAND ONTO THE FREEMAIN MACRO.                         *\n*                                                                     *\n***********************************************************************\n         FREEPOOL (R2)\n         ORG  *-2\n         LA   R15,252              GET SUBPOOL ID IN R15\n         SLL  R15,24               MOVE TO HIGH ORDER BYTE.\n         OR   R0,R15               SET SUBPOOL ID IN R0\n         SVC  10                   ISSUE FREEMAIN\n*\n         FREEMAIN R,LV=1024,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\nGETMERR  DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nOPENC    OPEN  (,INPUT),MF=L\nOPENCE   DS    0H\nCLOSEC   CLOSE (,),MF=L\nCLOSECE  DS    0H\nINDCBC   DCB   DDNAME=SYSTSPRT,RECFM=VBA,MACRF=GM,DSORG=PS,            X\n               EODAD=ENDRECS,LRECL=137\nINDCBCE  DS    0H\nWTO1C    WTO   '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nWTO1CE   DS    0H\n*\n*\n*\nDATD     DSECT\nWORKAREA DS    CL200             WORKAREA FOR JCECVT\nBUFFER   DS    CL137             BUFFER FOR SYSTSPRT.\nOPEND    OPEN  (,INPUT),MF=L\nCLOSED   CLOSE (,),MF=L\nINDCBD   DCB   DDNAME=SYSTSPRT,RECFM=VBA,MACRF=GM,DSORG=PS,            X\n               EODAD=ENDRECS,LRECL=137\nWTO1D    WTO   '                                                       X\n                                                                       X\n                             ',MCSFLAG=(RESP),DESC=(6),         EEJ1102+\n               CONSID=,MF=L                                     EEJ1102\nCONSID   DS    F                 CONSOLE ID FOR THIS COMMAND.\nMAXWTO  DS    F                 MAXIMUM NUMBER OF WTOS FOR TSSO\nLREC     DS    F                 LENGTH OF RECORD BEING PROCESSED.\nWTONUM   DS    F                 NUMBER OF WTO'S ISSUED.\nCMDDELAY DS    F                 COMMAND DELAY VALUE FOR THIS RECORD.\nCMDSTART DS    A                 STARTING ADDRESS OF COMMAND\nTSSWFLAG DS    F                 FLAG WORD.\nDELAYCHR DS    F                 NUMBER OF CHARS IN DELAY FACTOR.\n         END   TSSOWTO\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOWTO(''TSSO V 4.1 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' ENTRY    TSSOWTO'\n PUNCH ' NAME     TSSOWTO(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSS0INI2": {"ttr": 39690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00D\\x01\\x021\\x9f\\x01\\x171O\\x14\\x12\\x03?\\x03\\x16\\x00)\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2017-11-10T14:12:44", "lines": 831, "newlines": 790, "modlines": 41, "user": "JOARMC"}, "text": "         TITLE ' T S S O    I N I T I A L I Z A T I O N   (PART2)'\n***********************************************************************\nTSSOINI2 CSECT\n***********************************************************************\n* THIS MODULE IS THE SECOND PART OF TSSO INITIALIZATION. IT'S PURPOSE *\n* IS TO PROCESS THE TSSO PARMLIB PARAMETERS. THESE PARAMETERS WILL    *\n* COME FROM THE SYS1.PARMLIB DATASET, WHICH IS DYNAMICALLY ALLOCATED  *\n* USING THE TSO ALLOCATE COMMAND. THIS MODULE WILL PROCESS THESE      *\n* PARAMETERS, AND STORE THE RESULTS INTO THE COMMON TSSO DATA AREA    *\n*                                                                     *\n* LAST MESSAGE NUMBER IN THE TSSI SEQUENCE IS TSSI019X                *\n***********************************************************************\n*                                                                     *\n* MODIFIED                                                            *\n*    14DEC92  GLA  ADD MPF SUPPRESSION CONTROL STATMENT TO SUPPORT    *\n*                  ADDITION OF MPF SUPPRESSED MESSAGE ELIMINATION     *\n*                  FROM DAVE CARTWRIGHT AT SPRECHER ENERGIE AG        *\n*                                                                     *\n*    NOV 2002 EEJ  Support TMPNAME= parameter                   EEJ1102\n*                                                               EEJ1102\n***********************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOINI2,R12       GET ADDRESSIBILITY\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1              ADDRESS THE TSSO DATA AREA.\n         GETMAIN R,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n         L      R9,0(R8)\n         USING  DATD,R9\n***********************************************************************\n* INITIALIZE TSSOINI2 DSECT VARIABLES\n***********************************************************************\n         GETMAIN R,LV=4096\n         LR    R11,R1\n         USING TSSOVARS,R11\n         MVC   PARMLIB,IPARMLIB\n         MVC   LINK1D(LINK1CE-LINK1C),LINK1C\n         XC    RETCODE(2),RETCODE         ASSUME OK UNTIL PROVEN WRONG.\n***********************************************************************\n* ESTABLISH DEFAULTS FOR PARMLIB PARAMETERS IN CASE ONE IS LEFT OUT\n***********************************************************************\n         MVC   TMPNAME(8),=CL8'IKJEFT01'  DEFAULT TMP NAME\n         MVI   TSSOSRC,C'#'               DEFAULT SYSTEM RECOGNITION\n*                                         CHARACTER\n         MVC   TSSOTABN(8),=CL8'NONE'     DEFAULT NAME FOR TSSO TABLE\n         MVC   TSSORACF+1(8),=CL8'NONE'   ESTABLISH DEFAULT\n         MVC   INISEC(4),=CL4'MINI'      DEAFULT SECURITY IS MINIMAL\n         MVC   SECSYS(4),=CL4'RACF'      AND THE PACKAGE IS RACF.\n         MVC   MAXCMDS(4),=F'15'           DEFAULT MAXIMUM NUMBER OF\n*                                         SIMULTANEOUS COMMANDS\n*\n         MVC   ININUMSS(4),=F'1'         DEFAULT ONE SUBSYSTEM CONSOLE\n*\n         MVC   TMEOTVL(4),=F'15'          DEFAULT 15 MINUTES...\n*\n         MVI   TSSOSWAP,C'Y'              DEFAULT IS NON-SWAP\n         MVI   STARFORC,C'N'              DEFAULT IS NO FORCE.\n         MVC   TSSOPROM,C'N'              DEFAULT NOPROMPT\n         MVC   MAXWTO(4),=F'100'          DEFAULT MAXWTO VALUE = 100\n         MVI   TSSOMPF,C'N'         DEFAULT IS TO IGNORE MPF    14DEC92\n*\n         LA    R7,SSIARRAY                GET INIT ENTRY FOR SSI ARRAY\n         MVC   0(2,R7),=H'9'\n         MVC   8(8,R7),=CL8'TSSOSS09'     PREINITIALIZE THE TWO DEFAULT\n         LA    R7,36(R7)                  ENTRIES FOR SUBSYSTEM\n         MVC   0(2,R7),=H'10'             CODES 9 AND 10.\n         MVC   8(8,R7),=CL8'TSSOSS10'\n         MVC   SSICOUNT(2),=H'2'          MOVE IN DEFAULT SSI COUNT\n***********************************************************************\n* END PARMLIB DEFAULT SETTING\n***********************************************************************\n         L     R8,PARMPTR         GET ADDRESS OF PARM FIELD IN R8\n         L     R8,0(R8)\n         LH    R7,0(R8)           GET LENGTHS OF PARMS\n         LTR   R7,R7              WAS THERE ONE ?\n         BZ    NOPARM\n         LA    R8,2(R8)           POINT TO MEMBER NAME\n         BCTR  R7,0               FOR EX\n***********************************************************************\n* TSSO 4.3 - CHECK FOR SPECIAL CHARACTERS PROCEEDING THE MEMBER NAME  *\n* IF \"*\" IS PRESENT, ASSUME PROMPTING. IF '/' IS PRESENT, ASSUME FORCE*\n* = YES ON TSSO START COMMAND. THIS MAKES LIFE EASIER...              *\n***********************************************************************\n         CLI   0(R8),C'*'         IS PROMPTING DESIRED ?\n         BNE   CHKSPC2            NO, MOVE ON\n*\n         OI    PARMFLAG,X'40'     INDICATE PROMPTING REQUIRED.\n         LA    R8,1(R8)\n         BCTR  R7,0\n*\nCHKSPC2  DS    0H\n         CLI   0(R8),C'/'         IS FORCE REQUIRED ?\n         BNE   CHKSPC3            NO, MOVE ON\n         MVI   STARFORC,C'Y'      SO INIDICATED.\n*\n         LA    R8,1(R8)\n         BCTR  R7,0\n*\nCHKSPC3  DS    0H\n         LTR   R7,R7              ANY PARAMETERS LEFT ?\n         BNH   NOPARM\n         EX    R7,MOVEPARM        AND MOVE THE MEMBER NAME\n         B     AR1\nMOVEPARM MVC   PARMMEM(0),0(R8)   ** EXECUTED **\nAR1      DS    0H\n         B     ALLOPARM           GOT THE MEMBER- GO ALLOCATE PARMLIB\n*\n*\nNOPARM   DS    0H\n         MVC   PARMMEM(8),=CL8'TSSOPARM'\nALLOPARM DS    0H\n         AGO   .PRMLB\n         MVC   TSSOCMDL(2),=H'50'\n         MVC   TSSOCMD(50),ALPRMLIB   MOVE IN TSO COMMAND TO ALLOC PARM\n         OI    TSSOPFLG,X'80'         IGNORE AUTHORITY CHECKING\n         LINK  EP=TSSODOCM,PARAM=((R9)),ERRET=CMDFAIL,SF=(E,LINK1D),   X\n               MF=(E,LINKPARM)\n         NI    TSSOPFLG,255-X'80'     DEFAULT - AUTH CHECKING.\n         AGO   .GOTMEM\n.PRMLB   ANOP\n*\n* USE THE IEFPRMLB to allocate the system PARMLIB concatenation\n* to the DD name PARMLIB.\n         IEFPRMLB REQUEST=ALLOCATE,                                    X\n               S99RB=NO,                                               X\n               WAITDSN=NO,                                             X\n               MOUNT=NO,                                               X\n               RETMSG=NO,                                              X\n               CONSOLID=NOCONSID,                                      X\n               CART=NOCART,                                            X\n               ALLOCDDNAME=PARMLIB,                                    X\n               READ=NO, * MACRO DOES NOT READ MEMBER DATA              X\n               CALLERNAME=CALLTSSO\n* The return code is in GPR15\n* The reason code is in GPR0\n         LTR   R15,R15\n         JNZ   CMDFAIL\n         AGO   .GOTMEM\n.GOTMEM  ANOP\nGOTMEM   DS    0H\n         OC    PARMMEM(8),=CL8' '        MAKE UPPER CASE\n***********************************************************************\n*  READ INPUT FROM SYS1.PARMLIB. THE TSSO MEMBER NAME FROM PARMLIB\n*  WILL BE PASSED AS A PARAMETER, ALLOWING MULTIPLE TSSO PARAMETER\n*  MEMBERS. THE DEFAULT MEMBER NAME WILL BE \"TSSOPARM\". IF THE START\n*  COMMAND IS ISSUED LIKE  \"S TSSO,PARM='NEWPARMS' THEN TSSO WILL\n*  GO OUT AND USE SYS1.PARMLIB(NEWPARMS) FOR TSSO INPUT.\n***********************************************************************\n         CLC   PARMMEM(8),=CL8'PROMPT'   WAS PROMPTING REQUESTED?\n         BNE   PROMPTNO                  NO, NO NEED\n         OI    PARMFLAG,X'40'            INDICATE PROMPTING DESIRED\n         MVC   PARMMEM(8),=CL8' '        BLANK OUT PARMMEM\n         LA    R7,WTORECB\n         XC    WTORECB(4),WTORECB\n         LA    R8,PARMMEM\n         WTOR  ,(R8),8,(R7),MF=(E,WTOR25D)   ** PROMPT **\n         WAIT  ECB=WTORECB\n         OC    PARMMEM(8),=CL8' '        MAKE UPPER CASE\nPROMPTNO DS    0H\n         LA    R7,PARMDCBD        GET PARMLIB DCB\n         OPEN  ((R7),INPUT),MF=(E,OPEND)   OPEN IT !!!\n         USING IHADCB,R7\n         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL ?\n         BNO   NPARMDCB            NOPE, MUST NOT BE THERE. PRETEND\n*                                  NO PARAMETERS.\n         CLC   DCBLRECL(2),=H'80'  LRECL IS 80 BYTES ?\n         BNE   NPARM3              NOPE, SORRY...\n*\n         LH    R0,DCBBLKSI         GET BLOCK SIZE OF PARMLIB\n         ST    R0,PARMBLK          REMEMBER BLOCK SIZE\n*\n         GETMAIN R,LV=(0)          GETMAIN 1 BUFFER\n         ST    R1,PARMBUF          REMEMBER WHERE IT IS\n         OI    PARMFLAG,X'80'      INDICATE STORAGE OBTAINED\n*\n         FIND  (R7),PARMMEM,D     FIND MEMBER\n         LTR   R15,R15             IS IT THERE ?\n         BNZ   NPARM2              NOPE, ASSUME ALL DEFAULTS\n         XR    R3,R3               R3 WILL BE USED FOR NUMBER OF BYTES\n*                                  PROCESSED IN THE BLOCK\nREADLOOP DS    0H\n         L     R8,PARMBUF\n         LA    R7,PARMDCBD\n         READ  DECB,SF,(R7),(R8),MF=E          PUT IT INTO BUFFER\n         CHECK DECB\n         L     R1,DECB+16          ADDRESS OF IOB\n         LH    R1,14(R1)           RESIDUAL I/O COUNT\n         LH    R0,DCBBLKSI         GET DCB BLOCKSIZE\n         SR    R0,R1               GET NUMBER OF CHARS IN BUFFER\n         STH   R0,PARMREAD         ACTUAL NUMBER OF BYTES IN BUFFER\n***********************************************************************\n* R8 WILL POINT TO THE CURRENT RECORD BEING PROCESSED.\n*    OR THE INPUT BUFFER FOR THE PROMPTING WTOR\n***********************************************************************\nPARMLOOP DS    0H\n***********************************************************************\n* WE WILL CALL THE NOW INFAMOUS TSSO PARSE ROUTINE TO SCAN THE\n* PARMLIB INPUT\n***********************************************************************\nPRSCHECK DS    0H\n         ST    R8,PARS1            PARM 1 IS THE ADDRESS OF STRING\n*\n         MVC   PARS2(4),=F'80'     PARM 2 GETS THE LENGTH OF THE STRING\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(49),PARARRAY\n         LA    R6,PARARRAY\n         ST    R6,PARS3\n         MVC   PARARRAY(2),=H'3'   MAXIMUM OF THREE TOKENS...\n*\n         LA    R6,PARSSEP          GET ADDRESS OF SEPERATOR CHARACTERS\n         ST    R6,PARS4\n         MVC   PARSSEP(4),=CL4',='\n*\n         LA    R1,PARSPARM         LOAD UP PARM REGISTER\n         CALL  TSSOPARS\n***********************************************************************\n* THE ARRAY SHOULD NOW BE FILLED WITH ALL KINDS OF GOOD STUFF.\n***********************************************************************\n         LA    R5,PARARRAY+2      POINT TO FIRST TOKEN\n***********************************************************************\n* THIS SECTION OF CODE MAY BE ENTERED OUT OF EITHER THE PARMLIB\n* INPUT ROUTINE, OR THE PROMPTING ROUTINE. THE ENTRY FROM THE PROMPT\n* ROUTINE IS NON OBVIOUS (READ  KLUDGE) SO BEWARE.\n***********************************************************************\n         CLC   0(8,R5),=CL8'SRC'      WAS IT SRC?\n         BE    PRSSRC                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'TABLE  '  WAS IT TABLE ?\n         BE    PRSTABLE               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'MAXCMDS'  WAS IT MAXCMD ?\n         BE    PRSMAXCM               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'TIMEOUT'  WAS IT TIMEOUT?\n         BE    PRSTMEOT               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'NUMCONS'  WAS IT NUMBER OF SS CONSOLES ?\n         BE    PRSNUMSS               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'NONSWAP'  WAS IT NONSWAP ?\n         BE    PRSNSWAP               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'PROMPT'   WAS IT PROMPT ?\n         BE    PRSPROM                YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'END    '  WAS IT END     ?\n         BE    PRSEND                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'RACFID '  WAS IT REQUEST FOR RACF ID?\n         BE    PRSRACF                YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'MAXWTO '  WAS IT REQUEST FOR MAXIMUM WTOS ?\n         BE    PRSMAXWT               YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'SUBSYS '  WAS IT REQUEST FOR A SUBSYSTEM\n*                                     INTERFACE REQUEST ROUTINE ?\n         BE    PRSSSI                 YUP, GO HANDLE IT.\n*\n         CLC   0(8,R5),=CL8'SECSYS'   DEFINING A SECURITY SYSTEM ?\n         BE    PRSSECS                OK, NO PROBLEM.\n*\n         CLC   0(8,R5),=CL8'SECLEVEL' DEFINING A SECURITY LEVEL ?\n         BE    PRSSECL                LETS SEE WHAT'S WHAT.\n*                                                               14DEC92\n         CLC   0(8,R5),=CL8'MPFSUPP'  REQUESTING TO IGNORE MPF  14DEC92\n*                                     SUPPRESSED MESSAGES       14DEC92\n         BE    PRSMPF                                           14DEC92\n*\n         CLC   0(8,R5),=CL8'TMPNAME'  Alternate TMP name ?      EEJ1102\n         BE    PRSTMPNM               Branch if yes             EEJ1102\n*                                                               EEJ1102\n         CLI   0(R5),C'*'             WAS IT A COMMENT ?\n         BE    PARMNEXT\n         B     PRSINV\nPRSTMPNM DS    0H\n* PROCESS ALTERNATE TMP REQUEST\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TMPNAME(8),16(R5)\n         B     PARMNEXT\nPRSSRC   DS    0H\n***********************************************************************\n* PROCESS THE  SRC  PARAMETER STATEMENT                               *\n***********************************************************************\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSOSRC(1),16(R5)\n         B     PARMNEXT\n*\nPRSTABLE DS    0H\n***********************************************************************\n* PROCESS THE  TABLE PARAMETER STATEMENT                              *\n***********************************************************************\n         CLI   16(R5),X'40'           ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSOTABN(8),16(R5)\n         B     PARMNEXT\n*\nPRSTMEOT DS    0H\n***********************************************************************\n* PROCESS THE  TIMEOUT PARAMETER STATEMENT.                           *\n***********************************************************************\n* THIS PARAMETER DEFINES HOW LONG TSSO SHOULD WAIT FOR A COMMAND\n* BEFORE TIMING OUT A CONSOLE (LOGGING IT OFF). THE VALUE SPECIFIED IS\n* IN MINUTES, BUT IT IS INTERNALLY CONVERTED TO SECONDS.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    TMONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   TMEOTINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nTMONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(R5)             POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   TMEOTINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    TMEOTINV              YUP, APPARAENTLY OK.\n         B     TMEOTOK\nTMEOTINV DS    0H\n         WTO   'TSSI018E INVALID TIMEOUT PARAMETER- DEFAULT (15) USED'\n         B     PARMNEXT\nTMEOTOK  DS    0H\n         ST    R1,TMEOTVL            STORE RESULTS..\n         B     PARMNEXT\n*\n*\nPRSNUMSS DS    0H\n***********************************************************************\n* PROCESS THE  NUMBER OF SUBSYSTEM CONSOLES PARAMETER.                *\n***********************************************************************\n* THIS PARAMETER DEFINES HOW MANY SUBSYSTEM CONSOLES TSSO SHOULD\n* ALLOCATE.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    SSONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   SSCONINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nSSONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(R5)             POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   SSCONINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    SSCONINV              YUP, APPARAENTLY OK.\n         B     SSCONOK\nSSCONINV DS    0H\n         WTO   'TSSI019E INVALID NUMCONS PARAMETER SPECIFIED (1) USED'\n         B     PARMNEXT\nSSCONOK  DS    0H\n         ST    R1,ININUMSS           STORE RESULTS..\n***********************************************************************\n* CHECK IF A DEDICATED SUBSYSTEM CONSOLE IS REQUESTED...              *\n***********************************************************************\n         CLC   32(8,R5),=CL8'DEDICATE'   WAS DEDICATED REQUESTED ?\n         BNE   SSCONNOD                  DOESNT LOOK THAT WAY.\n         OI    PARMFLAG,X'10'            SET INDICATOR\nSSCONNOD DS    0H\n         B     PARMNEXT\n*\n*\nPRSMAXCM DS    0H\n***********************************************************************\n* PROCESS THE  MAXCMD PARAMETER STATEMENT                             *\n***********************************************************************\n* UP TO 99 MAX COMMANDS MAY BE SPECIFIED. CHECK TO SEE IF ONE DIGIT\n* OR 2 WAS SPECIFIED, THEN CALL THE CONVERT ROUTINE TO FIGURE OUT\n* WHAT IS WAS.\n***********************************************************************\n         LA    R0,1                  ASSUME 1 DIGIT.\n         CLI   17(R5),X'40'          IF BLANK, WE HAVE ONLY ONE DIGIT\n         BE    CMONEDIG              INDEED, TWO DIGITS\n         CLI   18(R5),X'40'          ANYTHING IN THE NEXT COLUMN ?\n         BNE   MAXCMINV              YUP - THIS CANT BE RIGHT.\n         LA    R0,2                  OTHERWISE, TWO DIGITS\nCMONEDIG DS    0H                    ALL THIS, JUST TO GET THE LENGTH\n*                                    INTO R0\n         LA    R1,16(R5)             POINTER TO PARSE STRING\n         LA    R10,DATD              POINT R10 TO WORKAREA.\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   MAXCMINV              PROBLEM...\n         LTR   R1,R1                 ANY RESULTS ?\n         BZ    MAXCMINV              YUP, APPARAENTLY OK.\n         B     MAXCMOK\nMAXCMINV DS    0H\n         WTO   'TSSI002E INVALID MAXCMDS PARAMETER- DEFAULT (15) USED'\n         B     PARMNEXT\nMAXCMOK  DS    0H\n         ST    R1,MAXCMDS            STORE RESULTS..\n         B     PARMNEXT\n*\nPRSMAXWT DS    0H\n***********************************************************************\n* THIS IS THE PARSE ROUTINE FOR THE MAXIMUM WTO PARMLIB ENTRY. THIS   *\n* ROUTINE WILL DETERMINE HOW MANY DIGITS WERE SPECIFIED FOR THE MAXWTO*\n* VALUE, AND CALL THE NIFTY EBCIDIC DECIMAL TO BINARY SUB TO DO THE   *\n* CONVERSION. THIS VALUE IS THEN STORED AT MAXWTO. UP TO 4 DIGITS MAY *\n* BE SPECIFIED.                                                       *\n***********************************************************************\n         XR    R1,R1                 START THE COUNT.\n         LA    R2,16(R5)\nWTLOOP   DS    0H\n*\n         CLI   0(R2),X'40'           LOOKING FOR BLANK.\n         BE    WTBLANK               AHH. FOUND IT !\n         LA    R1,1(R1)              INCREMENT COUNT.\n         CH    R1,=H'5'              TO BIG ?\n         BE    MAXWTINV              YUP, DONT ALLOW.\n         LA    R2,1(R2)              TRY NEXT DIGIT.\n         B     WTLOOP\n*\nWTBLANK  DS    0H\n***********************************************************************\n* NOTE, R1 HAS COUNT OF DIGITS.\n***********************************************************************\n         LR    R0,R1                 COPY COUNT OF DIGITS.\n         LA    R1,16(R5)             POINT TO START OF STRING TO CNVT.\n         LA    R10,DATD\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   MAXWTINV              YUP, APPARAENTLY BAD ONES.\n         LTR   R1,R1                 ANY RESULTS ?\nMAXWTOK  DS    0H\n         ST    R1,MAXWTO             STORE RESULTS..\n         B     PARMNEXT\n*\nMAXWTINV DS    0H\n         WTO   'TSSI003E INVALID MAXWTO PARAMETER- DEFAULT TAKEN (100)'\n         B     PARMNEXT\n*\n*\nPRSNSWAP DS    0H\n***********************************************************************\n* PROCESS THE  NONSWAP PARAMETER STATEMENT                            *\n***********************************************************************\n         CLI   16(R5),X'40'         ANYTHING THERE ?\n         BE    PRSNEQU              NOPE.. SORRY.\n         MVC   TSSOSWAP(1),16(R5)\n         B     PARMNEXT\n*\nPRSPROM  DS    0H\n         CLI   16(R5),C'Y'          DOES THE ANSWER START WITH \"Y\"?\n         BNE   PRSPROME\n         OI    PARMFLAG,X'40'       INDICATE PROMPTING REQUESTED\nPRSPROME DS    0H\n         B     PARMNEXT\n*\nPRSRACF  DS    0H\n***********************************************************************\n* PROCESS THE  RACFID  PARAMETER STATEMENT                            *\n***********************************************************************\n         TM    PARMFLAG,X'20'    ARE WE IN PARSE MODE ?\n         BNO   RACFNPRS          NO, OK TO ACCEPT RACF PARAMETER.\n         WTO   'TSSI004E RACFID PARAMETER REJECTED- NOT ACCEPTED IN PROX\n               MPT MODE'\n         B     PARMNEXT\nRACFNPRS DS    0H\n         CLI   16(R5),X'40'       ANYTHING THERE ?\n         BE    PRSNEQU\n         MVC   TSSORACF+1(8),16(R5)\n         LA    R10,8\n         LA    R1,TSSORACF+1\n         XR    R5,R5\nRLOOP    DS    0H                GET THE LENGTH\n         CLI   0(R1),X'40'       OF THE USER ID AS\n         BE    RLOOPEND          REQUIRED BY THE RACINIT MACRO\n         LA    R5,1(R5)\n         LA    R1,1(R1)\n         BCT   R10,RLOOP\nRLOOPEND DS    0H\n         STC   R5,TSSORACF\n         B     PARMNEXT\n*\nPRSSSI   DS    0H\n***********************************************************************\n* PROCESS THE SUBSYS PARAMETER STATEMENT. THIS STATEMENT IS NEW WITH  *\n* TSSO VERSION 4.2, AND WILL CONTROL THE LOADING OF THE SUBSYSTEM     *\n* INTERFACE ROUTINES. THE SYNTAX IS:                                  *\n*\n* SUBSYS NN = MODULE-NAME\n*\n* ERROR WILL NOT BE DETECTED AT THIS TIME, BUT WILL BE DETECTED       *\n* WHEN LOADING THE MODULES. THIS ROUTINE WILL MEARLY FILL AN ARRAY    *\n* WITH INFORMATION.\n***********************************************************************\n         XR    R1,R1                 START THE COUNT.\n         LA    R2,16(R5)\nSSILOOP  DS    0H\n*\n         CLI   0(R2),X'40'           LOOKING FOR BLANK.\n         BE    SSIBLANK              AHH. FOUND IT !\n         LA    R1,1(R1)              INCREMENT COUNT.\n         CH    R1,=H'3'              TO BIG ?\n         BH    SSIPRMBD              YUP, DONT ALLOW.\n         LA    R2,1(R2)              TRY NEXT DIGIT.\n         B     SSILOOP\n*\nSSIBLANK DS    0H\n***********************************************************************\n* NOTE, R1 HAS COUNT OF DIGITS.\n***********************************************************************\n         LR    R0,R1                 COPY COUNT OF DIGITS.\n         LA    R1,16(R5)             POINT TO START OF STRING TO CNVT.\n         LA    R10,DATD\n         CALL  JCECVTDB              CONVERT THE SUCKER.\n         BNZ   SSIPRMBD              YUP, APPARAENTLY BAD ONES.\n         CH    R1,=H'1'              ANY RESULTS ?\n         BL    SSIPRMBD\n         CH    R1,=H'255'            MAX 255 FOR SUBSYSTEM\n         BH    SSIPRMBD\nSSIPRMOK DS    0H\n* ONCE WE HAVE A VALID SUBSYS STATEMENT, WE WILL STORE IT IN THE SSI\n* ARRAY, FOR LATER LOADING. WE MUST VERIFY THAT THIS ENTRY WILL NOT\n* SQUASH OTHER ENTRIES.., OR IF IT DOES, USE THE LATER ENTRY\n         LA    R7,SSIARRAY           START AT BEGINNING OF ARRAY\n         LR    R2,R1                 COPY REGISTER CONTAINING SSICODE\n         LA    R6,10                 MAX COUNT OF SSI ENTRIES.\nSSIALOOP DS    0H\n         CH    R2,0(R7)\n         BE    ENTFOUND              THIS MEANS THAT THIS SSI CODE IS\n*                                    THE SAME AS SOMETHING PREVIOUSLY\n*                                    USED, THEREFORE, THIS ENTRY IN\n*                                    SSIARRAY WILL BE USED\n         CLC   0(2,R7),=XL2'0000'    BLANK ENTRY ?\n         BE    ENTFOUND\n         LA    R7,36(R7)\n         BCT   R6,SSIALOOP           AT MOST 10 ENTRIES...\n*\n         WTO   'TSSI005S SSI ARRAY OVERFLOW- TSSO TERMINATING',DESC=(1)\n         OI    PARMFLAG,X'01'        INDICATE SEVERE ERROR...\n         MVC   RETCODE(2),=H'12'     MOVE IN RETURN CODE.\n*\nENTFOUND DS    0H\n         CLI   32(R5),C' '           ANY THIRD PARM ON THIS LINE ?\n         BE    SSIPRMBD              GUESS NOT...\n         CLC   0(2,R7),=XL2'0000'    IS THIS A BLANK ENTRY ?\n         BNE   NOUPSSIC              NO, DONT UPDATE SSICOUNT\n         LH    R6,SSICOUNT           RAISE SSICOUNT BY 1\n         LA    R6,1(R6)\n         STH   R6,SSICOUNT           AND PUT IT BACK\nNOUPSSIC DS    0H\n         STH   R2,0(R7)              STORE RESULTS..\n         MVC   8(8,R7),32(R5)        AND STORE NAME OF LOAD MODULE\n         B     PARMNEXT\n*\nSSIPRMBD DS    0H\n         WTO   'TSSI006E INVALID SUBSYS CONTROL CARD - RECORD IGNORED'\n         B     PARMNEXT\n*\n*\nPRSSECS  DS    0H\n***********************************************************************\n* WHAT WE HAVE HERE IS AN ATTEMPT TO PROCESS THE SECSYS INITIATION    *\n* STATEMENT. CURRENTLY SUPPORTED VALUES ARE RACF AND ACF2.            *\n*                                                                     *\n* NOTE THAT THIS PARAMETER CANNOT BE SPECIFIED IN PROMPT MODE.        *\n*                                                                     *\n***********************************************************************\n         TM    PARMFLAG,X'20'      PROMPT MODE ACTIVE ?\n         BO    SECSNPRM            YUP, LETS NOT PROCESS THE PARM.\n         CLI   16(R5),X'40'        ANYTHING THERE ?\n         BE    PRSNEQU\n         CLC   16(8,R5),=CL8'RACF' WAS RACF SPECIFIED ?\n         BE    SECSRACF            YUP - WE CAN LIVE WITH THAT.\n*\n         CLC   16(8,R5),=CL8'ACF2' HOW BOUT ACF2 ?\n         BE    SECSACF2            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         CLC   16(8,R5),=CL8'TOPS' HOW BOUT TOP SECRET ?\n         BE    SECSTOPS            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         WTO   'TSSI014A SECSYS PARAMETER REJECTED - UNSUPPORTED SECURIX\n               TY SYSTEM'\n         B     SECSEND\nSECSRACF DS    0H\n***********************************************************************\n* WE COME HERE IF RACF IS SELECTED AS THE SECURITY SYSTEM.\n***********************************************************************\n         MVC   SECSYS(4),=CL4'RACF'\n         B     SECSEND\nSECSACF2 DS    0H\n***********************************************************************\n* WE COME HERE IF ACF2 IS SELECTED AS THE SECURITY SYSTEM.\n***********************************************************************\n         MVC   SECSYS(4),=CL4'ACF2'\n         B     SECSEND\nSECSTOPS DS    0H\n***********************************************************************\n* WE COME HERE IF TOP SECRET IS SELECTED AS THE SECURITY SYSTEM\n***********************************************************************\n         MVC   SECSYS(4),=CL4'TOPS'\n         B     SECSEND\n*\nSECSNPRM DS    0H\n         WTO   'TSSI015A SECSYS PARAMETER REJECTED - INVALID IN \"PROMPTX\n               \" MODE'\n         B     SECSEND\nSECSEND  DS    0H\n         B     PARMNEXT\n*\n*\n*\nPRSSECL  DS    0H\n***********************************************************************\n* HERE, WE WILL PROCESS THE SECLEVEL CONTROL STATEMENT. SUPPORTED     *\n* VALUES ARE MINIMAL AND MAXIMAL.                                     *\n*                                                                     *\n* NOTE THAT THIS PARAMETER CANNOT BE SPECIFIED IN PROMPT MODE.        *\n*                                                                     *\n***********************************************************************\n         TM    PARMFLAG,X'20'      PROMPT MODE ACTIVE ?\n         BO    SECLNPRM            YUP, LETS NOT PROCESS THE PARM.\n         CLI   16(R5),X'40'        ANYTHING THERE ?\n         BE    PRSNEQU\n         CLC   16(8,R5),=CL8'MINIMAL'  WAS MINIMAL SPECIFIED ?\n         BE    SECLMINI            YUP - WE CAN LIVE WITH THAT.\n*\n         CLC   16(8,R5),=CL8'MAXIMAL'  WAS MAXIMIAL SPECIFIED ?\n         BE    SECLMAXI            YUP, WE CAN LIVE WITH THAT, IF THE\n*\n         CLC   16(8,R5),=CL8'MEDIAL'   WAS MEDIAL   SPECIFIED ?\n         BE    SECLMEDI            YUP, WE CAN LIVE WITH THAT, IF THE\n*                                  INSTALLATION CAN.\n         WTO   'TSSI016A SECLEVEL PARAMETER REJECTED - TRY \"MINIMAL\" ORX\n               \"MAXIMAL\"'\n         B     SECLEND\nSECLMINI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MINIMAL.\n***********************************************************************\n         MVC   INISEC(4),=CL4'MINI'\n         B     SECLEND\nSECLMAXI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MAXIMAL\n***********************************************************************\n         MVC   INISEC(4),=CL4'MAXI'\n         B     SECLEND\nSECLMEDI DS    0H\n***********************************************************************\n* WE COME HERE IF THE SECURITY LEVEL IS MEDIAL\n***********************************************************************\n         MVC   INISEC(4),=CL4'MEDI'\n         B     SECLEND\nSECLNPRM DS    0H\n         WTO   'TSSI017A SECLEVEL PARAMETER REJECTED - INVALID IN \"PROMX\n               PT\" MODE'\n         B     SECLEND\nSECLEND  DS    0H\n         B     PARMNEXT\n*                                                               14DEC92\nPRSMPF   DS    0H                                               14DEC92\n****************************************************************14DEC92\n* PROCESS THE  MPFSUPP PARAMETER STATEMENT                     *14DEC92\n****************************************************************14DEC92\n         MVC   TSSOMPF,16(R5)       SAVE PARAMETER              14DEC92\n         B     PARMNEXT                                         14DEC92\n*\n*\n*\nPRSEND   DS    0H\n         TM    PARMFLAG,X'20'      WAS END ENTERED FROM PROMPT MODE ?\n         BO    ENDPARMS            YUP, BEAM ME UP SCOTTY.\n         B     PARMEND\nPARMNEXT DS    0H\n         TM    PARMFLAG,X'20'      ARE WE IN PROMTING MODE ?\n         BO    CHKPROMP            IF IN PROMPTING MODE, PROMPT\n         LA    R8,80(R8)\n         LA    R3,80(R3)\n         CH    R3,PARMREAD         ARE WE AT END OF BLOCK YET?\n         BL    PARMLOOP\n         XR    R3,R3\n         XR    R8,R8\n         B     READLOOP\n*\nPRSINV   DS    0H\n         MVC   WTO16D+32(8),0(R5)     MOVE IN VERB FOR MESSAGE\n         WTO   MF=(E,WTO16D)          INVALID (YIPES!)  (MSG7)\n         B     PARMNEXT               GO GET NEXT RECORD\n*\nPRSNEQU  DS    0H\n         MVC   WTO17D+32(8),0(R5)     MOVE IN VERB FOR MESSAGE\n         WTO   MF=(E,WTO17D)          INVALID FORMAT    (MSG8)\n         B     PARMNEXT               GO GET NEXT RECORD\n*\nNPARMDCB DS    0H\n         WTO   'TSSI009E MISSING PARMLIB DD STATEMENT- DEFAULTS TAKEN'\n         B     PARMEND\nNPARM2   DS    0H\n         MVC   WTO18D+20(8),PARMMEM\n         WTO   MF=(E,WTO18D)           MEMBER NOT FOUND - (MSG10)\n         B     PARMEND\nNPARM3   DS    0H\n         WTO   'TSSI011E SYS1.PARMLIB IS NOT BLOCKED AT 80 BYTES- PARMLX\n               IB INPUT IGNORED'\n         B     PARMEND\nPARMEND  DS    0H\nNEGPROM  DS    0H\n         LA    R7,PARMDCBD         (PTF 2)\n         TM    DCBOFLGS,DCBOFOPN   IS THE SUCKER OPEN ?\n         BNO   CHKPROMP            NOPE, MUST NOT BE THERE. SEE IF\n*                                  PROMPTING WAS REQUESTED.\n         CLOSE ((R7),LEAVE),MF=(E,CLOSED)\n*\n         AGO   .PARMLIB2\n         MVC   TSSOCMDL(2),=H'20'\n         MVC   TSSOCMD(20),FRPRMLIB   MOVE IN TSO COMMAND TO FREE PARM\n         OI    TSSOPFLG,X'80'         IGNORE AUTHORITY CHECKING\n         LINK  EP=TSSODOCM,PARAM=((R9)),SF=(E,LINK1D),                 X\n               MF=(E,LINKPARM)\n         NI    TSSOPFLG,255-X'80'     ALLOW AUTH CHECKING\n         AGO   .PARMLIB3\n.PARMLIB2 ANOP\n*\n* Use the IEFPRMLB macro to dynamically free the PARMLIB\n         IEFPRMLB REQUEST=FREE,                                        X\n               DDNAME=PARMLIB,                                         X\n               CALLERNAME=CALLTSSO\n*\n* GPR15 contains the return code\n* GPR0 contains the reason code\n         AGO   .PARMLIB3\n.PARMLIB3 ANOP\n*\n         TM    PARMFLAG,X'80'      DID WE GET STORAGE ?\n         BNO   NOGETM              NOPE, DONT BOTHER WITH FREEMAIN\n         L     R0,PARMBLK\n         L     R1,PARMBUF\n         FREEMAIN R,LV=(R0),A=(R1)\n         DROP  R7\nNOGETM   DS    0H\nCHKPROMP DS    0H\n         TM    PARMFLAG,X'01'      SEVERE ERROR IN INITIALIZATION ?\n         BO    ENDPARMS            YUP.. FORGET ALL THAT OTHER STUFF\n         OI    PARMFLAG,X'20'      INDICATE WE ARE INPROMPTING MODE.\n         TM    PARMFLAG,X'40'      WAS PROMPTING DESIRED ?\n         BNO   ENDPARMS            NO, GO TO END PARMS ROUTINE\n         XC    WTORECB(4),WTORECB\n         LA    R7,WTORECB\n         LA    R8,PROMPINP\n         MVC   PROMPINP(80),=CL80' '    BLANK OUT RESPONSE AREA\n         WTOR  ,(R8),80,(R7),MF=(E,WTOR26D)   ** PROMPT **  (MSG12)\n         WAIT  ECB=WTORECB\n         OC   PROMPINP(80),=CL80' '     UPPERCASE\n         B    PRSCHECK                  GO DO THE PARM\nENDPARMS DS    0H\nENDPROG  DS   0H\n*\n         LH    R8,RETCODE          PICK UP RETURN CODE\n*\n         FREEMAIN R,LV=4096,A=(R11)\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              RELOAD RETURN CODE\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n*\nCMDFAIL  DS    0H\n         WTO 'TSSI013S UNABLE TO ISSUE TSO COMMANDS- TSSO TERMINATING',X\n               DESC=(1)\n         LA    R8,8\n         STH   R8,RETCODE\n         B     ENDPROG\n*\nERROR12  DS    0H\n         LA    R8,12\n         STH   R8,RETCODE\n         B     ENDPROG\n*\n***********************************************************************\n* TSSOINI2 ONLY DATA CONSTANTS.                                       *\n*                                                                     *\n***********************************************************************\nLINK1C   LINK  EP=TSSODOCM,SF=L\nLINK1CE  EQU   *\nALPRMLIB DC    CL50'ALLOC FI(PARMLIB) DSN(''SYS1.PARMLIB'') SHR'\nFRPRMLIB DC    CL20'FREE FI(PARMLIB)'\nIPARMLIB DC    CL8'PARMLIB'\nCALLTSSO DC    CL8'TSSO'\n         EJECT\n***********************************************************************\n* TSSOINI2 ONLY DSECT.\n*                                                                     *\n***********************************************************************\nTSSOVARS DSECT\nLINKPARM DS    F           PARAMETER FOR RE-ENTRANT LINK MACRO\nRETCODE  DS    H           RETURN CODE FROM TSSOINI2\nPARMLIB  DS    CL8         DDNAME\nLINK1D   LINK  EP=TSSODOCM,SF=L\n         COPY  TSSODATD\n         TSSOCVT\n         DCBD  DSORG=PO,DEVD=DA\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOINI2(''V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOINI2'\n PUNCH ' NAME     TSSOINI2(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UG43IMPT": {"ttr": 40195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x12M\\x12M\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 4685, "newlines": 4685, "modlines": 0, "user": "TSSO403"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "UG43RAW": {"ttr": 41991, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x0f\\xb1\\x0f\\xb1\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 4017, "newlines": 4017, "modlines": 0, "user": "TSSO403"}, "text": ".**********************************************************************\n.* This document was prepared with SCRIPT/VS Release 3                *\n.* using both GML tags and DCF macros.  It is designed                *\n.* for printing on an IBM 3800 Model 3 laser printer and,             *\n.* with one exception, uses the default fonts for headers,            *\n.* highlighting, and text.                                            *\n.**********************************************************************\n.if &$PDEV eq 38PP .or &$PDEV eq 3820\n.th .cs 1 include\n.el .cs 1 ignore\n.cs 1 on\n.df figfont type ('gothic' 9) codepage t1d0base\n.cs 1 off\n.ls text 1.0\n.ti ~ 41\n.ti \u00ac 05\n.ll 6.5i\n:gdoc.\n:frontm.\n:titlep.\n:title stitle='TSSO User''s Guide'\n:title.Time Sharing Subsystem Option User's Guide\n:date.Release 4.3  August, 1986\n:address.\n:aline.Marc Schare\n:aline.Bell Communications Research, Inc.\n:aline.3 Corporate Place, Room 2C-211\n:aline.Piscataway, NJ 08854\n:aline.Telephone:  201-981-2796\n:eaddress.\n:etitlep.\n:toc.\n:figlist.\n:body.\n:h1 id=intro.INTRODUCTION\nThe Time Sharing\nSubsystem Option (TSSO) is a package designed to increase operator\nproductivity by automating tasks which need not be performed\nmanually. TSSO performs its function through three integrated\ncomponents. The Operator Productivity Facility (OPF) extends the\npower of TSO to the MVS operator's console.\nThe Automated\nOperations Facility (AOF) enhances an installation's ability\nto control system events based on console message traffic.\nAn interface to the Network Communication Control Facility (NCCF)\nallows the network operator to use TSSO\nas a command processor,\nissuing and receiving operating system commands at the NCCF terminal.\nTSSO also enhances end-user productivity\nby allowing end-user access to the\nMVS command subsystem.\nThis document describes the installation of TSSO,\nTSSO parameters, and the use of the three components.\n:h1.CURRENT VERSION\nThis document describes the function of TSSO Version 4, Release 3 (TSSO 4.3).\nAll features described here will continue to work on subsequent versions of\nthe Time Sharing Subsystem Option unless specified in a future version of this\ndocument.\nA description of the new features of TSSO Version 4.3 can be\nfound in member RELGUIDE in the TSSO.VERS43.ASM data set.\n:h1.ABOUT THIS DOCUMENT\nThe :hp1.TSSO User's Guide:ehp1. was created using\nthe Document Composition Facility, Release 3.\nThe TSSO.VERS43.ASM data set contains three members with different\nversions of this document.\n:p.\nMember UG43RAW is the raw SCRIPT source,\nwhich is best suited for running on a 3800 Model 3\nof 3820 page printer.\nUse the following command to generate copies:\n:xmp.\nSCRIPT 'TSSO.VERS43.ASM(UG43RAW)' PROFILE(DSMPROF3) TWOPASS\n~~~~~~~DEVICE(:hp1.device-type:ehp1.) PRINT\n:exmp.\nwhere :hp1.device-type:ehp1. is the logical device type\nat your location.\n:p.\nMember UG43TERM is a pre-formatted copy\nsuitable for browsing at your terminal.\n:p.\nMember UG43IMPT is a pre-formatted copy suitable for dumping to\nan impact printer.\n:h1 id=plan.PLANNING FOR TSSO INSTALLATION\nBecause TSSO has grown in function and complexity,\na planning section is now necessary to describe\npre-requisite program products, MVS I/O generation requirements, and\nsecurity system conditioning.\nThis section should be reviewed\n:hp2.\nprior\n:ehp2.\nto the installation of TSSO.\n:p.\nTSSO 4.3 was developed for Bellcore internal use as part of a study on\nautomating the operation of an MVS computer center. Because the kernal of\nTSSO was originally developed external to Bellcore, permission was granted to\nmake this new version of TSSO available as public domain, unsupported\nsoftware. As a public domain software package, TSSO receives no formal\nsupport from Bellcore or anyone else.\nTherefore, installations that want to use TSSO must be prepared\nto support it locally as a worst case possibility. Questions, comments or\nenhancement requests are always welcome on an informal, non-committal basis.\n:h2.TSSO Software Prerequisites\nThe software listed below is the minimum version of the program product\nrequired to run TSSO. In general, that version, or a later release, is\nsufficient. Also listed is the version of the product run at Bell\nCommunications Research (i.e., the environment on which TSSO 4.3 was developed).\n:ol.\n:li.\n:hp3.\nMVS/SP 1.3.3 or MVS/XA 2.1.1:ehp. is required for the OCCF enhancements\nto the subsystem interface that allow TSSO/AOF and the OS family of commands\nto function. TSSO 4.3 has never been run on earlier MVS releases.\nBellcore runs MVS/XA 2.1.3, and TSSO has also been tested on MVS/SP\n1.3.4.\n:li.\n:hp3.\nTSO/E Release 2:ehp3. is required by the OS family of commands.  These commands\nuse CLIST variables for input and output, and require the CLIST\nenhancements of TSO/E Release 2 to accomplish this. TSO/E is not required if\nthese commands will not be used.\nBellcore runs TSO/E Release 2.1, and TSSO has also been tested with TSO/E\nRelease 2.\n:li.\n:hp3.RACF 1.6:ehp3.\nis required for the TSSO/RACF security interface.  TSSO has never\nbeen run on previous releases of RACF.\nBellcore runs RACF 1.7,\nand TSSO 4.3 has been tested only in that environment.\n:li.\n:hp3.ACF2 4.1:ehp3.\nis the release on which TSSO/ACF2 interface is being\ndeveloped.\n:eol.\n:h2 id=cons.TSSO Subsystem Console\nThe OSCMD facility allows a\nTSO CLIST to issue an operating system command and retrieve the\nresponse. This facility requires a subsystem console\nfor every simultaneous caller of OSCMD.\nIn addition, an installation may want\nto dedicate one subsystem console for the TSSO address space.\n:fn.\nFor more information on this option,\nsee :hdref refid=numcons..\n:efn.\nTo create a subsystem\nconsole, include the following card after the \"CONSOLE\" macros in the\nMVS STAGE1 generation deck.\n:xmp.\nCONSOLE    TYPE=JES\n:exmp.\nBecause TSSO 4.3 can use as many subsystem consoles\nas are genned in,\nit is a good idea to include many (10-20) of these cards.\n(Bellcore has 10 subsystem consoles genned in.)\nJES3 shops should note that JES3 and TSSO both\nrequire subsystem consoles,\nand you specify them accordingly.\n:hp2.\nAn MVS IOGEN must be performed to generate the subsystem console. Installations\nfamiliar with the \"MINIGEN\" approach may use this as an alternative.\n:ehp2.\n:h2.TSSO Security Issues\nAn optional feature of TSSO 4.3 is the ability\nto secure your MVS consoles.\nConsole security requires MVS operators to identify themselves\nbefore issuing commands;\nthus, MVS installations\nalways know which operators issue which commands. The\nfollowing steps should be taken prior to initializing TSSO with a\nsecurity level other than \"minimal\".\n:ol.\n:li.\nProvide a RACF user ID for each operator who will be issuing MVS commands\non the system. This includes the master console, I/O console(s) and\nuser consoles.\n:li.\nAdd a corresponding user ID to the User Attributes Data Set (UADS),\nand set the USERDATA bits to X'C0' for operators who will be\ninvoking the privileged TSSO commands (e.g., REPLY, OSCMD etc.).\nNote that\nthe USERDATA bits also control authority for regular TSO users,\nand, if the Program Control Facility (PCF)\nis installed,\nthe OSCMD and REPLY commands must be modified so that\nPCF and TSSO don't conflict.\nSee :hdref refid=cmdauth. for information\non the OSCMDATH user exit.\n:li.\nPick a security level. SECLEVEL=MEDIAL is a good initial selection,\nas operators can get used to the concept of logging on and logging off\nof an MVS console. Later, security can be strengthened with\nSECLEVEL=MAXIMAL.\n:li.\nSelect a TIMEOUT parameter. This parameter is the number of minutes\nbefore which an\nMVS console will \"timeout\" and require a new LOGON command.\n:li.\nAs with the rest of TSSO, operator training is\n:hp3.\ncrucial\n:ehp3.\nfor a successful implementation. Operators must become familiar with\nthe concepts of security.\n:li.\nACF2 will eventually be supported under TSSO.\nFor the current status of this effort,\ncall Jim Lane, 416-926-3076.\n:eol.\n:h2.Problems or Fixes\nFor the current bucket, call Marc Schare at 201-981-2796.\n:h2.Conclusion\nThe remainder of this\nguide should be read\n:hp2.\nin its entirety\n:ehp2.\nbefore installing TSSO.\nMany of the\nphone calls I've received on TSSO were answered in\nthe :hp3.TSSO User's Guide:ehp3..\nGood luck in your TSSO installation !\n.sp 2\n.fo off\n.in 45\nMarc Schare\nBell Communication Research, Inc.\n6 Corporate Place, Room 2C-211\nPiscataway, NJ 08854\n201-981-2796\n.in 0\n.fo on\n:h1.INSTALLATION\nTSSO is distributed in a single partitioned data set, which contains all\nsource modules, procedures and documentation.  Although\nthe data set may be called by any name, this document assumes\na name of\nTSSO.VERS43.ASM.\n:ol.\n:li.\nDownload the TSSO.VERS43.ASM data set to DASD.  About 5 cylinders of\n3380 space is required.\nIf you received your copy of the TSSO subsystem from the CBT tape, simply\ncopy it to a data set with this name.  If you received a tape,\nthen the TSSO subsystem is in IEBCOPY format on the first file.\nThe tape will be non-labeled, so use the LABEL=(1,NL) parameter when\ndownloading TSSO.\n:li.\nCreate two data sets for the TSSO modules\nwith the characteristics RECFM=U, LRECL=0, BLKSIZE=13030, DSORG=PO.\n:ol.\n:li.\nTSSO.VERS43.LOAD will be\nan intermediate data set for assembling TSSO modules.\n:li.\nSYS1.TSSOLOAD will contain the TSSO\nproduction modules.\n:lp.\nOne cylinder of 3380 DASD space should be sufficient\nfor these data sets.\n:p.\nMany users have found it useful to allocate a third data set:\n:li.\nSYS1.TSSOPROC will contain TSSO CLISTs.\nAllocate it with characteristics\nLRECL=255, BLKSIZE=3140, RECFM=VB, DSORG=PO.\nSpace requirements depend on the number of CLISTs you\nanticipate creating.\n:eol.\n:li.\nAssemble the TSSO source modules using the procedure\nASMALL in TSSO.VERS43.ASM.\nYou will need to EDIT the procedure and add\nthe appropriate installation job cards and\nlocal accounting information.\n:p.\nIf you will be running the TSSO subsystem on MVS/370, or both MVS/370 and\nMVS/XA, the SYSLIB DD statement must be pointing to the SYS1.MACLIB and\nSYS1.AMODGEN data sets for MVS/370. If you will be running the subsystem\nexclusively on MVS/XA, the SYSLIB DD statement may point to the XA versions\nof SYS1.MACLIB and SYS1.AMODGEN.\n:note.\nIf you do not have TSO/E Release 2 installed,\nthe assemblies for OSCMD, OSWAIT, and OSASK will fail.\n:li.\nCopy the load modules from TSSO.VERS43.LOAD into the production\nlibrary SYS1.TSSOLOAD.  The library TSSO.VERS43.LOAD should remain\non the system as an intermediate library to contain assembled TSSO\nload modules and assembled Automated Operations Facility tables.\n:li.\nIf OSCMD, OSWAIT, OSPAUSE, OSWTO, and OSWTOH\nwill be accessed by TSO users,\ncopy the modules\nfrom SYS1.TSSOLOAD to a publicly-accessible\nTSO command library (e;g;, SYS1,CMDLIB).\n:li.\nUpdate the SYS1.PARMLIB data set with one or more TSSO\nparameter decks.  The default member is TSSOPARM; however, alternate\nmembers may be selected when TSSO is started.\nNote that the TSSO parameter decks\n:hp3.must:ehp3.\nbe located in SYS1.PARMLIB, as TSSO will dynamically allocate this data set.\nReview the section :hdref refid=parms. for\nfurther information.\nA sample TSSO parameter deck may be found in\n:hdref refid=deck. or in the SAMPPARM member of the\nTSSO.VERS43.ASM data set.\n:li id=subsyid.\nIdentify TSSO to MVS as a subsystem.\nMake one of the following two entries\nin the subsystem names table,\nmember IEFSSN:hp1.xx:ehp1. in SYS1.PARMLIB:\n.sp\n.fo off\n.kp on\n.bx .5i 2.5i 4.5i 6.5i\n.tp .6i 2.6i 4.6i\n\u00acIf you want:\u00acthen make the entry:\u00acand:\n.bx\n\u00acNO JES support\u00acTSSO\u00acgo to Step :liref refid=vantsso.\n.sp\n\u00acJES support\u00acTSSO,TSSOINIT\u00acgo to Step :liref refid=tssojes.\n.bx off\n.kp off\n.fo on\n:li id=tssojes.\nCopy TSSOINIT from SYS1.TSSOLOAD to SYS1.LINKLIB.\n:li id=vantsso.\nInclude SYS1.TSSOLOAD in the IEAAPF:hp1.xx:ehp1. member of SYS1.PARMLIB.\nThis allows the TSSO subsystem to run APF authorized.\n:li.\nInclude a TSSO start-up\nprocedure in the SYS1.PROCLIB data set.\nNote that, because TSSO may be started by the master scheduler,\nthis procedure must be in SYS1.PROCLIB,\nnot in a PROCLIB defined to JES2.\nA sample procedure for starting TSSO is in member TSSOPROC in\nthe TSSO.VERS43.ASM data set.\n:li.\nGive the TSO commands supplied with TSSO APF authorization.\nUpdate\nthe installation CSECT IKJEFTE2 in load module IKJEFT02 to include the\nfollowing commands:\nALTAOF, CACHE, CPCMD, REPLY, OSCMD, OSWTO, OSWTOH, OSWAIT, and OSASK.\nUnder TSO/E Release 2.1,\nthis CSECT is\nin the load module IKJTABLS. If this release of TSO/E is installed, a\nseparate copy of IKJTABLS may be used by TSSO if included in the SYS1.TSSOLOAD\ndata set.\n:li.\nCreate the TSSO Automated Operations Facility table(s).\nInstructions for preparing the table are found later in this document.\n:li.\nCopy the ASMTAB CLIST from the TSSO.VERS43.ASM data set\nto SYS1.TSSOPROC.\n:li.\nIf you will be running TSSO with RACF support and MINIMAL security,\nadd a RACF ID for TSSO.\nAlso add a RACF ID for TSSO to SYS1.UADS.\nThis will allow TSSO to assume the TSO attributes (e.g. ACCOUNT, SUBMIT\nor MOUNT) that the installation desires.\nIf you will be running with MEDIAL or MAXIMAL security,\nyou may wish to add additional RACF or ACF2 and TSO user IDs\nfor each operator who will be logging on.\n:li.\nIPL MVS to refresh the subsystem name table.\n:li.\nIf the OSCMD facility will be used,\nyou must have generated subsystem consoles\nas specified in :hdref refid=cons..\nTSSO will warn you if the number of subsystem consoles requested\nis not available at start time.\n:li.Install the NCCF Interface (optional).\nThe following steps are required:\n:ol.\n:li.Copy the NCFOSCMD module into a library\nconcatenated to the STEPLIB~DD statement in the\nprocedure used to start NCCF.\n:li.\nMake the following entry in member DSICMD\nof the data set defined by the DSIPARM~DD statement\nin the procedure used to start NCCF:\n:xmp.\nOSCMD CMDMDL MOD=NCFOSCMD,TYPE=R,RES=N    TSSO 4.3\n:exmp.\n:eol.\n:eol.\n:h1 id=parms.TSSO PARAMETERS\nTSSO parameters provide an installation with a\nflexible mechanism for altering TSSO processing.\nParameters are\nstored as members in SYS1.PARMLIB.\nThe default member is TSSOPARM,\nand it is recommended that a TSSOPARM be created for daily processing.\n:p.\nParameters can be entered in any order, and if two\nentries are specified for the same parameter, the last entry\ntakes precedence.\nSee the SAMPPARM member or :hdref refid=deck..\n:h2.MAXCMDS Parameter\nMAXCMDS defines the maximum\nnumber of concurrent commands that TSSO\nwill hold for processing.  TSSO processes commands in the order in\nwhich they are entered, on a first~in-first~out basis.\nAny commands that are entered\nwhile TSSO is processing another command are queued for execution.\nThe MAXCMDS\nparameter defines the size of that queue.\nToo small a number is undesirable\nbecause it is advantageous to be able to enter many TSSO commands at\na time.\nToo large a number is also undesirable because it becomes\ndifficult to detect when a TSSO command may be looping or awaiting\nterminal input.  The syntax is\n:xmp.\nMAXCMDS=:hp1.nn:ehp1.\n:exmp.\nwhere\n:hp1.\nnn\n:ehp1.\ndefines the maximum number of simultaneous TSSO commands.\nNote that TSSO\nrequires 256 bytes for each command in the common service area (CSA).\nThe default value is 15 simultaneous commands.\n:h2.MAXWTO Parameter\nMAXWTO defines the maximum number of WTOs TSSO will issue\nfor any given TSO command.  The parameter is designed to prevent console\nflooding with TSO commands that produce many lines of output.\nThe syntax is\n:xmp.\nMAXWTO=:hp1.nnn:ehp1.\n:exmp.\nwhere\n:hp1.\nnnn\n:ehp1.\nis the maximum number of WTOs TSSO will allow for any one command.\nTSSO will issue a message when this limit is exceeded.\nDefault is 250.\n:h2.NONSWAP Parameter\nNONSWAP defines whether TSSO will run non-swappable.  If\n\"Y\" is entered, TSSO will issue the appropriate SYSEVENT to\nMVS to declare itself non-swappable.  Any other entry will cause TSSO\nto be swapped out whenever it has no work.  This can cause\n:hp3.\nsevere\n:ehp3.\nperformance degradation when using the subsystem.  The default value\nis \"Y\".  The syntax is\n.ti { AD\n.ti } BD\n:xmp.\nNONSWAP={Y/N}\n:exmp.\nwhere \"Y\" will mark the TSSO address space non-swappable.\n:h2 id=numcons.NUMCONS Parameter\nNUMCONS defines the number of subsystem consoles for\nthe installation.\nOptionally, you may dedicate one subsystem console\nfor the TSSO address space.\nThe syntax is\n:xmp.\nNUMCONS=:hp1.nn:ehp1. {DEDICATE}\n:exmp.\nwhere :hp1.nn:ehp1. is the number of consoles.\nIf DEDICATE is specified,\none console will be dedicated for the TSSO address space.\nNote that at least :hp1.nn:ehp1. subsystem consoles\nmust have been generated in the\nMVS IOGEN prior to starting TSSO.\nDefault is 1 console, none dedicated.\n:h2.PROMPT Parameter\nPROMPT defines whether or not the operator will be prompted\nfor additional TSSO parameters at start-up time.\nThe syntax is\n:xmp.\nPROMPT={Y/N}\n:exmp.\nIf PROMPT=Y is specified, TSSO will enter\nprompt mode after processing all the parameters in PARMLIB and allow\nthe MVS operator to enter or override parameters\n(except security-related parameters).\nFor example,\nif you want a different AOF table used each day,\nyou would want to be prompted so that you can enter\nthe TABLE parameter.\n:note.\nPrompt mode may also be specified at start-up time.\nSee the next section for more information.\n:h2.RACFID Parameter\nRACFID defines a default RACF ID for the TSSO subsystem,\nallowing TSSO to access data sets\nwith the authority of that RACF ID.  This implies that\nRACF commands can be entered from the MVS console through the use\nof TSSO.\nIf the installation has not installed the RACF\nprogram product, this parameter must be omitted.\nThe syntax is\n:xmp.\nRACFID=:hp1.RACF-id:ehp1.\n:exmp.\nwhere\n:hp1.\nRACF-id\n:ehp1.\nis the RACF identifier that TSSO will assume.\nThis parameter has no default. If it is not specified,\nTSSO will execute with the default RACF authority.\n:p.\nRACFID is dependent on the SECLEVEL parameter.\nIf SECLEVEL=MINIMAL,\nthen the RACFID authority level applies to\nany TSO command issued through TSSO.\nIf SECLEVEL=MEDIAL or MAXIMAL,\nthen the RACFID authority level applies to\nCONSOLE~0 and any TSO command issued from\na subsystem console through OSCMD.\nNote that TSSO requires that subsystem consoles\nissuing commands have at least \"SYSTEM\" authority.\n:dl tsize=11.\n:dt.CAUTION:\n:dd.\nTSSO does not require a password to acquire this RACF\nauthority, and care must be taken to ensure that use of this\nparameter does not violate installation security standards.\n:edl.\n:p.\nA recent small programming enhancement (SPE) to the JES2 subsystem has enhanced\nTSSO's ability to control production batch jobs that may use RACF-protected\ndata sets.  JES2 will now propagate the RACF ID and group from\nthe current address\nspace for jobs submitted through the internal reader.\nTSSO can submit jobs\nusing the TSO SUBMIT command, and those jobs can acquire the authority of\nthe TSSO address space.\n:h2.SECLEVEL Parameter\nSECLEVEL defines the security level of the installation.\nThe syntax is\n:xmp.\nSECLEVEL={MINIMAL/MEDIAL/MAXIMAL}\n:exmp.\n.in 5\n:dl tsize=15 termhi=0.\n:dt.MINIMAL\n:dd.\nDefault for RACF and TOP SECRET.\nThe RACFID parameter is used to determine\nTSSO's authority level.\nTherefore, all TSO commands will execute with\nTSSO's authority,\nregardless of the console's authority level.\n:dt.MEDIAL\n:dd.\nThis level requires all consoles using TSSO\nto log on\n:fn.Using the #.LOGON command,\nwhich will assign each console a separate RACFID parameter.\n:efn.\nusing the appropriate security system\n(RACF, TOP SECRET, or ACF2).\nAll data set access checking for TSSO commands and CLISTs\nis based on the console's logon ID authority.\nNote that this does not include TSSO control commands,\nwhich follow a different authorization mechanism.\n:dt.MAXIMAL\n:dd.\nThis level is extremely restrictive.\nOnce TSSO is initialized,\nall consoles must log on using\nthe appropriate security system.\n:hp2.\nAny console that does not log on is locked out\nof all MVS commands.\n:ehp2.\n:edl.\n.in 0\n:h2.SECSYS Parameter\nSECSYS defines the security system used\nby the installation.\nThe syntax is\n:xmp.\nSECSYS={RACF/ACF2/TOPS}\n:exmp.\nThe default is RACF.\n:h2.SUBSYS Parameter\nSUBSYS\ndefines subsystem interface exits and the routines\nthat will handle the exit functions.\nThe syntax is\n:xmp.\nSUBSYS :hp1.nn:ehp1.=:hp1.module-name:ehp1.\n:exmp.\nwhere :hp1.nn:ehp1. is the subsystem interface function code\nand :hp1.module-name:ehp1. is the name of the\nroutine that will handle the function.\nYou may specify as many SUBSYS parameters as desired.\nHowever, if there are multiple entries\nwith the same function code,\nonly the last appearance of the code will be honored.\n:p.\nBy default,\nTSSO includes two SUBSYS entries,\none for function code 9 which intercepts WTO messages\n(the AOF facility)\nand one for function code 10 which intercepts\noperator commands\n(the OPF facility).\nTherefore, be careful that you do not enter\na SUBSYS parameter with code 9 or 10;\notherwise, your entries will override the defaults\nand disable the AOF and OPF facilities.\n:h2.System Recognition Character (SRC) Parameter\nSRC defines the character that\nTSSO will use to recognize TSSO operator commands.  For example, if\nthis character is \"#\", TSSO will intercept and process all\noperator commands starting with a \"#\".\nThe syntax is\n:xmp.\nSRC=:hp1.char:ehp1.\n:exmp.\nwhere\n:hp1.\nchar\n:ehp1.\nis the character that TSSO will use.\nThe default character is a \"#\".\n:h2.TABLE Parameter\nTABLE defines the name of the TSSO Automated Operations\nFacility (AOF) table.\nThe AOF table contains information used to intercept and responding\nto operating system messages.\n(Information describing how to create this table is specified later in\nthis document.)\nThere is no default.  If this parameter is\nnot specified, the AOF is deactivated.  Note that this table can be\nreloaded (and AOF activated) at any time with\nthe \".RELOAD\" TSSO operator command described later.\nThe syntax is\n:xmp.\nTABLE=:hp1.table-name:ehp1.\n:exmp.\nwhere\n:hp1.\ntable-name\n:ehp1.\nis the load module name that contains a TSSO AOF table.\n:h2.TIMEOUT Parameter\nTIMEOUT defines the interval after which\nTSSO will log off an inactive console.\nThe syntax is\n:xmp.\nTIMEOUT=:hp1.nn:ehp1.\n:exmp.\nwhere :hp1.nn:ehp1. is the maximum number of minutes\nof inactivity.\n:h2.* (Comments) Parameter\nThe \"*\" parameter allows an installation to place comments in the\nTSSO initialization deck.  The line will be ignored by TSSO.\nThe syntax is\n:xmp.\n* :hp1.any-text:ehp1.\n:exmp.\nwhere\n:hp1.\nany-text\n:ehp1.\nis any descriptive comments the installation may want to include in\nthe initialization deck.\n:h2.END Parameter\nEND marks the end of TSSO parameter input. The syntax\nis\n:xmp.\nEND\n:exmp.\nwith no operands.  If prompt mode was enabled, the MVS\nconsole operator will be prompted for additional\nTSSO parameters after the END parameter is processed.\n:h1.TSSO START COMMAND OPTIONS\nStart procedures under release 4.3 have changed significantly.\nDepending on how you identified TSSO to MVS (see Step :liref refid=subsyid.),\nJES support may or may not be available automatically at start time.\nIf not, you may initialize TSSO with JES by using the SUB= operand.\nNote that, except for emergencies,\n:hp2.you can no longer start TSSO if it is already up.:ehp2.\n:p.\nThe TSSO start command has the following syntax:\n:xmp.\nS TSSO{,PARM='{*}{:hp1.parm-member:ehp1.}{PROMPT}'}{,SUB=JES2/JES3/MSTR}\n:exmp.\n:dl tsize='1.75i' termhi=0.\n:dt.\nPARM='*'\n:dd.\nAllows you to specify TSSO parameters\n:fn.\nExcept the security-related parameters\nSECSYS, SECLEVEL, and RACFID.\n:efn.\nwithout\nentering them previously into SYS1.PARMLIB.  This can be\nuseful in emergency situations;\nfor example, if you need to enter a parameter on a one-time basis,\nor if you are locked out of SYS1.PARMLIB\nand need to enter a different parameter.\n:dt.\nPARM='parm-member'\n:dd.\nDirects TSSO to use\nan alternate TSSO parameter deck in SYS1.PARMLIB\nfor parameters.\nDefault is TSSOPARM.\n:dt.\nPARM='PROMPT'\n:dd.\nDirects TSSO to prompt the MVS console operator for the name of\na member in SYS1.PARMLIB to be used for parameters.\nAfter processing the named member, TSSO will also\nprompt the MVS console operator\nfor additional parameters,\neven if the parameter deck specifies PROMPT=N.\n:dt.SUB=JES2/JES3\n:dd.Initialize TSSO with JES2 or JES3:fnref refid=jes3..\n:note.The JES subsystem must be up for this to work.\n:dt.SUB=MSTR\n:dd.Initializes TSSO without the primary subsystem.\nThis should be used only if JES won't come up.\n:edl.\n:p.\nIf an emergency restart is necessary,\nthe start command has the form\n:xmp.\nS TSSO,PARM='/{:hp1.options:ehp1.}'\n:exmp.\nwhere :hp1.options:ehp1. are any of the PARM options\nlisted above.\nThe \"/\" :hp2.must:ehp2. be specified as the first operand.\nWhen a force restart occurs,\nthe inactive TSSO address space\nmay be cancelled.\nNote that the inactive TSSO does not\nrelinquish its subsystem consoles,\nand, therefore, it is not advisable to\nforce start TSSO unless absolutely necessary.\n:fn id=jes3.\nAlthough TSSO has not been tested extensively using the JES3 product,\nthe interfaces\nshould be the same because TSSO uses standard subsystem interface calls.\n:efn.\n:h1.THE TSSO OPERATOR PRODUCTIVITY FACILITY\n:h2.Overview\nThe TSSO Operator Productivity Facility (OPF) is a\npowerful tool which,\nin conjunction with the Automated Operations Facility,\ncan automate many procedures that currently must\nbe done manually.\nOPF extends the power of TSO to the MVS operator's console by\nallowing TSO commands and CLISTS to be executed\nfrom an MVS console, with the response going back to the\ninvoking console.\nThis includes all TSO functions\nwhich use standard interfaces (with the exceptions noted below)\nand control\nfunctions unique to the TSSO environment that alter\nTSSO options and display TSSO information.\n:p.\nOPF also allows TSO users to issue MVS commands\nand get responses returned to the terminal or\nto CLIST variables.\nTSO users are usually restricted to INFO console authority.\n(See :hdref refid=cmdauth..)\n:h2.TSO Commands Under TSSO\nMost TSO commands may be run under control of the TSSO subsystem. The\nrequirements for such commands are as follows:\n:ol.\n:li.\nThe command must use standard TSO interfaces (namely, GETLINE and\nPUTLINE) to perform I/O.  The command should not require\ninput of any kind other than normal TSO command parameters.\n:li.\n:hp2.The command should\nnot attempt to use full screen processing.\n:ehp2.\nA command that issues the STFSMODE FULLSCRN=YES macro in\nACF/VTAM environments can hang the TSSO subsystem, forcing\nit to be cancelled.\n:li.\nThe command should be\n:hp3.\ntested under batch TSO\n:ehp3.\nbefore running it under TSSO, since TSO assumes that TSSO-initiated commands\nare running in\n:hp3.\nbackground\n:ehp3.\nmode.\n:eol.\n:h2.TSSO Control Commands\nTSSO supports a number of commands that are not directed to the TMP\nfor execution.  These commands are handled directly by TSSO, and\nare used to alter or query TSSO processing options.\nSee :hdref refid=cntlcmd. for more information.\n:h2.TSO Commands Distributed with TSSO\n:fig id=cmdresp frame=box.\n.tp 1.5i 4.75i\n.sp\n:hp2.ENVIRONMENT\u00acLEGAL VALUES FOR CMDRESP\u00acAUTHORITY CHECKING:ehp2.\n.sp\nTSSO CLIST\u00ac-~CLIST\u00acBased on invoking\n\u00ac-~NOWHERE\u00acconsole\n\u00ac-~If not defined, value is assumed\u00ac\n\u00ac~~to be CLIST (if MAXCMDOUT > 0)\u00ac\n\u00ac~~or NOWHERE (if MAXCMDOUT = 0).\u00ac\n\u00ac~~This is included for compatibility\u00ac\n\u00ac~~with previous releases.\u00ac\n.sp\nTSO CLIST\u00ac-~TERM\u00acBased on OSCMDATH\n\u00ac-~CLIST\u00acuser exit\n\u00ac-~NOWHERE\u00ac\n\u00ac-~If not defined, OSCMD assumes\u00ac\n\u00ac~~NOWHERE\u00ac\n.sp\nTSO terminal\u00ac-~TERM\u00acBased on OSCMDATH\n\u00ac\u00acuser exit\n:figcap.Behavior of CMDRESP in Various Environments\n:efig.\nA number of TSO commands that are designed to run with the TSSO subsystem\nare distributed with the base code.\nTSO commands used primarily from CLISTs\ninclude the \"OS family\" and the REPLY command.\nThese are designed to provide services such as\ncommunicating with the MVS operator and\nissuing messages to the MVS console,\ncommunicating with the MVS command subsystem,\nand communicating with programs that have issued WTORs.\nApplications of these commands are described below.\n:figref refid=cmdresp. summarizes\nthe behavior of OSCMD with the CMDRESP variable\nin different environments.\n:figref refid=exjobs. through :figref refid=exask. illustrate\nthe OS family\nin some useful CLISTs,\nwhich can be found in data set TSSO.VERS43.ASM.\n:p.\nOther commands are provided as auxiliary TSO command processors.\nThese include the CACHE command for controlling\n3880-21 and 3880-23 cache devices, the LINKLIST command for\ndisplaying the system LNKLST concatenation, and the VOLSER and VALLOC\ncommands for displaying UCB information for DASD devices.\nAlso, the CPCMD command allows an MVS console\noperator running in a virtual machine under VM/SP, VM/SP HPO or the VM/XA\nsystems facility to issue CP commands and get the response back to the\nconsole invoking the command.\n:p.\nA complete description of TSO commands may be\nfound in :hdref refid=cmdref..\n:h3.The OSCMD Command\n:fig id=exjobs frame=box.\n.sp\n   PROC 1 JNAME\n  /*************************************************************/\n  /* THIS CLIST WILL DISPLAY ALL JOBS THAT START WITH A GIVEN  */\n  /* CHARACTER STRING. THE STRING IS PASSED TO THE CLIST AS A  */\n  /* PARAMETER. THE CLIST WILL ISSUE A OSCMD $DN, AND SCAN THE */\n  /* OUTPUT FOR JOBS THAT START WITH THE GIVEN STRING.         */\n  /*************************************************************/\n\n  SET MAXCMDOUT = 200\n  /*************************************************************/\n  /* WE WISH TO TRAP AS MANY LINES OF OUTPUT AS JES WOULD CARE */\n  /* TO PROVIDE, THEREFORE, SET MAXCMDOUT TO THE MAX - 200     */\n  /*************************************************************/\n\n  SET CMDWAIT = 1\n  /*************************************************************/\n  /* THE JES COMMAND SHOULD ONLY TAKE 1 SECOND OR LESS, SO     */\n  /* SET THE CMDWAIT VARIABLE TO 1.                            */\n  /*************************************************************/\n\n  OSCMD $DN\n  /*************************************************************/\n  /* ISSUE THE $DN JES COMMAND. THIS WILL POPULATE CLIST VARS  */\n  /* WITH THE OUTPUT FROM THIS COMMAND.                        */\n  /*************************************************************/\n\n  /*************************************************************/\n  /* SINCE THE OSCMD COMMAND ALWAYS RETURNS AN ECHO OF THE     */\n  /* COMMAND AS THE FIRST LINE, START WITH THE SECOND LINE.    */\n  /*************************************************************/\n  SET I = 2\n  SET COUNT = 0\n\n  /*************************************************************/\n  /* WE NEED TO LOOP BETWEEN THE SECOND LINE, AND THE \"LAST\"   */\n  /* LINE, CONVENIENTLY STORED IN &CMDOUT VARIABLE.            */\n  /*************************************************************/\n  DO WHILE (&I <= &CMDOUT - 1)\n  /*************************************************************/\n  /* NOTE THAT THE $DN RESPONSE INCLUDES THE SPOOL UTILIZATION */\n  /* AS THE LAST LINE. WE WILL IGNORE IT.                      */\n  /*************************************************************/\n\n  SET LJNAME = &LENGTH(&JNAME)\n\n  /*************************************************************/\n  /* THE JOBNAME IS RETURNED IN THE SECOND WORD OF EACH LINE.  */\n  /*************************************************************/\n  SET JESJOB = &&CMDOUT&I.W2\n\n  IF &SUBSTR(1:&LJNAME,&JESJOB) = &JNAME THEN +\n  DO\n  /*************************************************************/\n  /* WE HAVE FOUND A JOBNAME THAT STARTS WITH THE JOB. WE WILL */\n  /* DISPLAY THE ENTIRE LINE.                                  */\n  /*************************************************************/\n           SET OUT = &STR(&&CMDOUT&I)\n           WRITE &STR(&OUT)\n           SET COUNT = &COUNT + 1\n  END\n\n  SET I = &I + 1\n  END\n\n  WRITE &COUNT JOBS FOUND.\n  EXIT CODE(0)\n.sp\n:figcap.CLIST EXJOBS\n:efig.\nOSCMD allows you to issue any MVS command\n(JES2, VTAM, etc.).\nOSCMD is most useful when issued from a CLIST,\nwhere the response is returned to CLIST variables.\nThe CLIST can be designed to manipulate\nthese variables to produce readable\nresponses to the user.\nFor example,\nthe JES command $DN\nqueries the status of all jobs on the system.\nThe output from $DN could be filtered\nso that the information will be printed\nonly for certain job names (:figref refid=exjobs.).\n:p.\nThe syntax of OSCMD is\n:xmp.\nOSCMD~:hp1.mvs-cmd:ehp1.\n:exmp.\nwhere :hp1.mvs-cmd:ehp1. is any MVS command.\nThrough the CLIST variable CMDRESP,\nOSCMD can determine the destination of a command response\nbased on its origin.\n.tp .25i 1.75i\n.sp\n.bx 0 1.5i 5.5i\n.fo off\n\u00acIf CMDRESP =\u00acthen the response will be:\n.bx\n.sp\n\u00acTERM\u00acreturned to the TSO user's terminal\n.sp\n\u00acCLIST\u00acreturned to CLIST variables (see OSCMD\n\u00ac\u00acin :hdref refid=cmdref.)\n.sp\n\u00acNOWHERE\u00acdiscarded (TSO users) or\n\u00ac\u00acreturned to the console (TSSO-initiated commands)\n.sp\n.bx off\n.sp\n.fo on\nInput and output variables are described in :hdref refid=cmdref..\n:fig id=exckspl frame=box place=bottom.\n.sp\n  PROC 0\n  /***********************************************************/\n  /* THIS CLIST WILL ISSUE A JES2 COMMAND TO DISPLAY TO      */\n  /* SPOOL UTILIZATION. IF THE SPOOL UTILIZATION IS          */\n  /* ABOVE 80%, THE CLIST WILL ISSUE A HILIGHTED MESSAGE     */\n  /* TO THE OPERATOR. OTHERWISE, IT WILL ISSUE AN ORDINARY   */\n  /* MESSAGE INDICATING HOW BUSY THE SPOOL IS. IT UTILIZES   */\n  /* THE COMMAND TRAPPING FACILITIES IN TSSO 4.3             */\n  /*                                                         */\n  /***********************************************************/\n\n  /*************************************************************/\n  /* THE FIRST STEP IS THE SETTING OF MAXCMDOUT. SINCE THE     */\n  /* EXPECTED COMMAND RESPONSE IS 3 LINES, WE SET MAXCMDOUT = 3*/\n  /*************************************************************/\n  SET MAXCMDOUT = 3\n\n  /*************************************************************/\n  /* NEXT, WE DECIDE HOW LONG THE CLIST SHOULD WAIT FOR THE    */\n  /* COMMAND. 1 SECOND IS PLENTY FOR THIS JES COMMAND.         */\n  /*************************************************************/\n  SET CMDWAIT = 1\n\n  /*************************************************************/\n  /* NOW THAT THE TWO INPUT VARIABLES ARE SET UP, WE WILL      */\n  /* ISSUE THE OSCMD COMMAND. THE RESPONSE WILL BE PLACED IN   */\n  /* CLIST VARIABLES.                                          */\n  /*************************************************************/\n           OSCMD $DSPOOL\n\n  /*************************************************************/\n  /* THE EXPECTED COMMAND RESPONSE LOOKS LIKE THIS.            */\n  /* $DSPOOL                                                   */\n  /* $HASP646 XX PERCENT SPOOL UTILIZATION.                    */\n  /*                                                           */\n  /* NOTE THAT LINE1 IS ALWAYS AN ECHO OF THE ORIGINAL COMMAND */\n  /*************************************************************/\n.sp\n:figcap.CLIST EXCKSPL\n:figdesc.(Continued on next page)\n:efig.\n:h4 id=cmdauth.Authority Checking with OSCMD\nBecause OSCMD allows a TSO user to issue any MVS command,\nstrict security must be enforced to prevent\nunauthorized users from issuing\ndangerous system commands.\nWhen issued from a TSSO-initiated CLIST,\nOSCMD checks the authority of the invoking console\nand only permits commands of that level.\nWhen issued by a TSO user,\nthe OSCMDATH user exit checks the installation authority of\nthe user's ID.\nBy default, all TSO users have INFO-only authority\nas defined in\nthe MVS system operations manual.\nOther authority levels\n(system, I/O, master)\ncan be defined through the OSCMDATH user exit.\nThis exit allows the installation to code a routine\nto determine the MVS command group level for a TSO user.\nFull authority can be granted on a per-user basis.\n:fn.\n\"Authorized users\" are\nthose with X'C0'\nin the PSCBATR2 field of the User Attributes Data Set.\nThis can be set through the USERDATA operand\nof the CHANGE subcommand of ACCOUNT.\n:efn.\n.kp on\n.bx left 6.5i\n.fo off\n.if &$PDEV eq 38PP .or &$PDEV eq 3820\n.th .bf figfont\n.sp\n  /*************************************************************/\n  /* IF WE DO NOT GET BACK AT LEAST 2 LINES OF RESPONSE, THEN  */\n  /* AN ERROR HAS OCCURRED. WRITE A MESSAGE TO THE OPERATOR    */\n  /* AND TERMINATE.                                            */\n  /*************************************************************/\n           IF &CMDOUT < 2 THEN +\n           DO\n             OSWTOH PROBLEM WITH THE CHKSPL COMMAND - CONTACT SUPPORT\n             EXIT CODE(12)\n           END\n\n  /*************************************************************/\n  /* ASSUMING EVERYTHING WENT OK WITH THE COMMAND, THE RESPONSE*/\n  /* IS RETURNED IN THE SECOND WORD OF THE SECOND LINE OF THE  */\n  /* MESSAGE. TSSO HAS ALREADY PARSED THE MESSAGE. WE PICK UP  */\n  /* THE UTILIZATION.                                          */\n  /*                                                           */\n  /*************************************************************/\n           SET UTIL = &CMDOUT2W2\n\n\n  /*************************************************************/\n  /* NOW, WE LOOK AT THE SPOOL UTILIZATION, AND DETERMINE IF   */\n  /* IT IS GREATER THE 80%. IF SO, SEND A HILIGHTED MESSAGE.   */\n  /*                                                           */\n  /*************************************************************/\n           IF &UTIL > 80 THEN +\n           DO\n              OSWTOH SPOOL UTILIZATION IS &UTIL - CONTACT JES2 SUPPORT\n           END\n           ELSE +\n           DO\n              OSWTO  SPOOL UTILIZATION IS &UTIL PERCENT.\n           END\n.sp 2\n.if &$PDEV eq 38PP .or &$PDEV eq 3820\n.th .pf\n.bf figcap\n~~Figure 3, cont'd.  CLIST EXCKSPL\n.pf\n.bx off\n.fo on\n.sp\n.kp off\n:h3.The OSWTO and OSWTOH Commands\n:fig id=exstvt frame=box.\n.sp\n            PROC 0\n  /*************************************************************/\n  /* THIS CLIST WILL START THE ADDRESS SPACES RELATING TO      */\n  /* VTAM. THESE INCLUDE NCCF, VPS AND OMEGAMON. THIS CLIST    */\n  /* IS NORMALLY KICKED OFF AT IPL TIME BY AN AOF TABLE ENTRY  */\n  /* SUCH AS THE FOLLOWING                                     */\n  /*                                                           */\n  /*        TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT=#STRTVTAM   */\n  /*                                                           */\n  /* THE IST020I MESSAGE IS FOR VTAM INITIALIZATION COMPLETED. */\n  /*                                                           */\n  /*                                                           */\n  /*************************************************************/\n  /*************************************************************/\n  /* NOTE THAT WE ARE NOT INTERESTED IN GETTING THE RESPONSE   */\n  /* BACK TO ANY OF THESE MVS COMMANDS. THEREFORE, WE DO NOT   */\n  /* SET THE MAXCMDOUT OR CMDWAIT VARIABLES.                   */\n  /*************************************************************/\n            OSCMD $SLOGON1       /* START JES/VTAM CONNECT */\n\n            OSCMD START TSO      /* START TSO              */\n\n            OSCMD START NCCF     /* START NCCF             */\n\n            OSCMD S OMVTAM,PREFIX='OMEGA.V652',APPL=OMR4\n\n\n            OSCMD START GDDMPRT           /* START ADMPRT ADDRESS SPC */\n\n            OSCMD START VPS               /* AND START VPS AS WELL    */\n            OSPAUSE 5                     /* DELAY 5 SECONDS          */\n            OSCMD VARY NET,ACT,ID=VPS     /* AND VARY IN TO VTAM      */\n            WRITE\n            OSWTOH IPL0004I NETWORKING ADDRESS SPACES HAVE BEEN\n            OSWTOH IPL0004I (CONT) STARTED.\n.sp 2\n:figcap.CLIST EXSTVTAM\n:efig.\nOSWTO and OSWTOH allow you\nto write messages to the operator console.\nOSWTOH highlights the message.\nThe syntax of the commands is\n:xmp.\nOSWTO :hp1.message:ehp1.\nOSWTOH :hp1.message:ehp1.\n:exmp.\nwhere :hp1.message:ehp1. is the text of the message issued.\n:figref refid=exjobs. through :figref refid=exstvt. illustrate\nthese commands.\n:h3.The OSASK Command\n:fig id=exask frame=box.\n.sp\n         PROC 0\n         /****************************************************/\n         /* THIS CLIST WILL PROVIDE AN EXAMPLE OF THE OSASK  */\n         /* FACILITY OF TSSO.                                */\n         /****************************************************/\n\n         /* FIRST, FIND OUT IF THE OPERATOR IS READY TO PROCEED */\n         /* SET A TIME LIMIT OF 30 SECONDS...                   */\n         SET REPLYWAIT = 30\n\n         STARTAGN: +\n         OSASK ARE YOU READY TO PROCEED\n\n         IF &REPLY = NOREPLY THEN GOTO TIMEDOUT\n         IF &REPLY = NO THEN GOTO ENDPROG\n         IF &REPLY = YES THEN GOTO CONFUSED\n\n         OSASK GREAT ! WHAT TASK(S) ARE YOU TRYING TO PERFORM ?\n\n         /* UP TO 6 ITEMS MAY BE ENTERED ON THE RESPONSE LINE. THE */\n         /* OSASK COMMAND PARSES THE OPERATOR RESPONSE INTO CLIST  */\n         /* VARIABLES. WE WILL LOOP THROUGH, SUPPLYING THE OPERATOR*/\n         /* WITH THE NEEDED ANSWERS.                               */\n\n         IF &REPLY = NOREPLY THEN GOTO TIMEDOUT\n         SET COUNT = &REPLYW\n\n         SET I = 1\n         DO WHILE (&I <= &COUNT)\n\n           SET VAR = &&REPLYW&I       /* GET THE I'TH WORD */\n\n           IF &VAR = IPL THEN LIST 'SYS1.HELPOPER(IPL)'\n           ELSE IF &VAR = SHUTDOWN THEN LIST 'SYS1.HELPOPER(SHUTDOWN)'\n           ELSE IF &VAR = STARTNET THEN LIST 'SYS1.HELPOPER(STARTNET)'\n           /* MANY OTHER ENTRIES MAY BE PLACED HERE ...    */\n           ELSE OSWTO   THERE IS NOT HELP FOR \"&VAR\"\n\n           SET I = &I + 1\n         END\n         GOTO  ENDPROG\n.sp\n         CONFUSED: +\n           OSWTOH ANSWER YES OR NO...\n           GOTO STARTAGN\n\n         TIMEDOUT: +\n           OSWTO HELP FACILITY TIMING OUT - REINVOKE WHEN YOU HAVE MORE\n           OSWTO TIME.\n           GOTO  ENDPROG\n\n         ENDPROG: +\n           OSWTO GOODBYE.\n           EXIT\n.sp\n:figcap.CLIST EXASK\n:efig.\nOSASK allows you to ask the operator\na question and get a response.\nIf it is issued from a TSO command line,\nthe response goes to the user's terminal.\nHowever, like OSCMD,\nOSASK is most useful when issued from a CLIST,\nwhere the response is returned to CLIST variables\nwhich can then be manipulated.\nSo that TSSO is not delayed too long\nfor an operator reply,\nthe maximum wait time is 60 seconds,\nafter which the default response is \"NOREPLY\".\n:p.\nThe syntax of OSASK is\n:xmp.\nOSASK :hp1.question:ehp1.\n:exmp.\nInput and output variables are described in :hdref refid=cmdref..\n:figref refid=exask. illustrates\nOSASK with an interactive help procedure.\n:h3.The OSPAUSE Command\nOSPAUSE is used to delay CLIST execution\nfor a specified number of seconds.\nThis is useful if the CLIST\nany time the CLIST must wait for an event.\n:figref refid=exstvt. shows an example of a CLIST\nthat initiates a started task and\nmust wait for it to initialize.\n:h3 id=oswait.The OSWAIT Command\n:fig id=oswait frame=box.\n.sp\n  PROC 0\n  /**********************************************************/\n  /*  This clist will start a job, wait for its completion, */\n  /*  and purge the job.                                    */\n  /**********************************************************/\n\n  OSCMD S MYJOB\n  OSWAIT ENTRY(MYJOBEND)    TIMEOUT(60)\n  OSWTO MYJOB HAS ENDED ...\n  OSCMD $P'MYJOB'\n  EXIT\n.sp 3\nThe CLIST above used the AOF table entry\n.sp\n~~~~~MYJOBEND TABENTRY MSG=IEF404I,ACTION=POST,TEST=((W,2,5,'MYJOB','~'))\n.sp\n:figcap.Sample CLIST for OSWAIT.\n:efig.\nOSWAIT directs TSSO to wait for a particular system\nmessage or a timeout limit to occur before proceeding.\nThese messages are defined in the AOF table.\nOSWAIT is intended to be issued from a CLIST.\n:p.\nOSWAIT provides many automation opportunities\nthat were (in previous versions of TSSO)\ntoo cumbersome to develop.\nOSWAIT does not need to run from the TSSO address space.\nIn theory, an installation may have many OSWAIT events\noutstanding at any one time\nin different TSO or batch address spaces.\nFor example, a simple job scheduler can be coded\nas a CLIST using the OSWAIT and OSCMD facilities.\nThe CLIST can then be run under control of a\nbatch TMP in a separate address space.\n:p.\nThe syntax of OSWAIT is\n:xmp.\nOSWAIT ENTRY(:hp1.entry-id:ehp1.) TIMEOUT(:hp1.nnnnn:ehp1.)\n:exmp.\nwhere :hp1.entry-id:ehp1. is the 1- to 8-character identifier\nof the AOF table entry;\nand :hp1.nnnnn:ehp1. is the number of second to wait before\ntimeout, maximum 86400 seconds.\nFor example,\n:figref refid=oswait. shows\na CLIST that will start a job,\nwait for the job to complete, and purge the job.\n:p.\nSee :hdref refid=cmdref. for more information on OSWAIT.\n:h2.Using the WRITE Statement in TSSO CLISTs\nIn previous releases of TSSO,\noperator commands and highlighted messages could only\nbe issued using the WRITE statement\nwith the *COM and *HI keywords.\nThese facilities still work under release 4.3,\nand CLISTs written with them can be used unaltered.\nHowever, note that the difference between these facilities\nand the commands OSCMD, OSWTO, OSWTOH, and OSPAUSE is that\nTSSO processes *COM and *HI directives :hp3.after:ehp3.\nthe CLIST has completed,\nwhereas the TSSO commands will be executed :hp3.immediately:ehp3..\nCare\nmust therefore be taken in designing CLISTs with *COM and *HI,\nbecause any TSO commands in\nthe CLIST are executed before any MVS commands are issued by TSSO.\n:p.\nThe *COM and *HI facilities are available only\nthrough TSSO-initiated CLISTs.\n:h3.*COM Keyword\nThe *COM keyword used in the WRITE statements also\nenables you to issue\nMVS commands.  When an output line in the SYSTSPRT output\nstream (the output from the TSO command or CLIST) begins with the\nkeyword \"*COM\", TSSO will execute the remainder of that statement as an\nMVS operator command.\nThe syntax of this extended WRITE statement is\n:xmp.\nWRITE *COM:hp1.nnn oscmd:ehp1.\n:exmp.\n.kp on\n.in 5\nwhere\n:dl tsize=8 termhi=1.\n:dt.\nnnn\n:dd.\nis a delay factor directing\nTSSO to delay :hp1.nnn:ehp1. seconds after processing the command.\nThis is\nuseful when operating system commands have a time dependency on each\nother.\n:dt.\noscmd\n:dd.\nis an MVS operator command to be executed.  The command could be an\nMVS command, JES command, or even another TSSO command.\nNote that\n:hp3.the command will be executed with the authority of the console\nthat originally invoked the TSSO command.:ehp3.\n:edl.\n.kp off\n.in 0\n:h3.*HI Keyword\nThe *HI keyword allows you to write highlighted\nmessages on the MVS console.  The syntax is\n:xmp.\nWRITE *HI :hp1.message:ehp1.\n:exmp.\nwhere\n:hp1.\nmessage\n:ehp1.\nis the message to be highlighted on the MVS console.\n.pa\n:h2.Guidelines and Suggestions for Writing CLISTs\n:ol.\n:li.\nCLISTs can\nbe used to write operator HELP procedures to the MVS console.\nThis is\ndemonstrated in :figref refid=ophelp..\n:fig id=ophelp frame=box.\n.sp\n  PROC 0\n  /********************************************************/\n  /* This CLIST will provide HELP information to the      */\n  /* operator on the current status of the NJE LINES      */\n  /* between JES2 systems                                 */\n  /********************************************************/\n  WRITE NJE LINK BETWEEN A and B is line 12\n  WRITE NJE LINK BETWEEN A and C is line 16\n  WRITE NJE LINK BETWEEN B and C is line 20\n  WRITE NJE LINK BETWEEN C and A is line 19\n  WRITE NJE LINK BETWEEN C and B is line 24\n  WRITE NJE LINK BETWEEN B and A is line 13\n  WRITE\n  WRITE This list is current as of January 3, 1985. For more\n  WRITE assistance, contact Alan Grossman at extension 5555.\n  EXIT CODE(0)\n.sp\n:figcap.CLIST with an Operator Help Procedure Using WRITE\n:figdesc.Note that OSWTO is the preferred command for CLISTs.\n:efig.\n:li.\nThe REPLY command is useful in CLISTS\nto automate operational procedures with products\nthat communicate to the operator\nthrough the WTOR interface\n(e.g., NCCF and IMS).\nFor example, if\nnumerous NCCF commands are to be executed, these can be executed in a\nTSSO CLIST using the REPLY command with message ID DSI802A. See the\ndescription of the REPLY command in :hdref refid=cmdref..\n:li.\nComments may be placed at the end of MVS commands because\nMVS treats them as MVS command comments.  However, JES2 treats CLIST\ncomments as data and tries to use them in forming the command.  Therefore,\ndo not place CLIST comments on JES2 commands;\nplace them on the lines following the command.\nFor example, the following\nCLIST is invalid because it\nwould produce an invalid JES2 command.\n:p.\n.hr left to 6.5i\n:xmp.\nPROC 0\nOSCMD $TEXIT6,ENABLE        /* ENABLE THE EXIT */\nEXIT\n:exmp.\n.hr left to 6.5i\n:p.\nThis situation is remedied in MVS/SP JES2 Release 1.3.6 and MVS/XA JES2\nRelease 2.1.5.\n:li.\nSymbolic substitution can be used in TSSO CLISTS\nas shown in :figref refid=symbsub..\n:li.\nSince operations personnel will be using OPF, the\nrecommendation is to allow them to write their own CLISTS.\n:li.\nTSSO CLISTS are invoked in the same fashion as TSSO commands. The\nnormal TSO search sequence is followed. The recommendation is to\nallocate a SYS1.TSSOPROC data set and allocate it to DDNAME SYSPROC\nin the TSSO bringup deck. The SYSPROC data set may also be\ndynamically allocated through the TSO ALLOCATE command. Lastly, the\nTSO EXEC command may be used to execute TSSO CLISTS.\n:li.\nUse OSWTOH and WRITE~*HI with caution. Do not highlight messages\nunless their importance warrants it, because your operations staff will\nlearn to ignore highlighted messages, and this can be harmful to your\noverall system operations.\n:eol.\n:fig id=symbsub frame=box.\n.sp\n  PROC 2 UNIT VOLSER USE()\n  /*****************************************/\n  /* This CLIST will mount MVS volumes     */\n  /* using a command in operator friendly  */\n  /* syntax. Note the optional USE         */\n  /* parameter.                            */\n  /*****************************************/\n  OSCMD VARY &UNIT,ONLINE\n  IF &USE = THEN +\n  DO\n          OSCMD MOUNT &UNIT,VOL=(SL,&VOLSER)\n  END\n  ELSE +\n  DO\n          OSCMD MOUNT &UNIT,VOL=(SL,&VOLSER),USE=&USE\n  END\n  OSWTOH MNT001I VOLUME &VOLSER NOW MOUNTED ON &UNIT\n  OSCMD D U,,,&UNIT,1\n  EXIT\n.sp\n:figcap.CLIST Using Symbolic Substitution\n:efig.\n:h1.TSSO AUTOMATED OPERATIONS FACILITY\n:h2.Introduction\nA high percentage of MVS commands are issued\nin response to system or subsystem messages,\nand these responses are predetermined by the\ncontents of the messages.\nThe TSSO Automated Operations Facility (AOF)\nfrees the MVS console operator from routine tasks\nby automating responses to system messages.\nAOF is a table-driven monitor that intercepts messages\nand carries out one of four actions:\nsuppresses, highlights, or lowlights the message;\nor issues an MVS, JES2 or subsystem command.\nBecause AOF does not require the services of the TSSO address space,\nany number of messages can be processed simultaneously.\n:p.\nThere are three steps required to install this facility;\nbriefly:\n:ol.\n:li.\nCreate the AOF table.\n:li.\nAssemble and link-edit the table into load module format.\n:li.\nStore the module in SYS1.TSSOLOAD.\n:eol.\n:p.\nThese steps are described in detail below.\n:p.\nNote that the table can be updated at any time.\nAlso, you may create multiple tables,\nalthough only one can be active at a time.\nMultiple tables may be useful so that different\nsets of commands can be used at different times\n(e.g., first, second and third shifts).\nYou can change the active table in three ways:\n:ol.\n:li.\nBy changing the TABLE= parameter in the parameter deck;\nthe new table will be available the next time\nTSSO is brought up.\n:li.\nBy dynamically reloading the table with the \"#.RELOAD\"\ncommand; the new table will be available immediately.\n:li.\nBy resetting the MATCHLIM parameter\nof any entry in the active AOF table with the ALTAOF command;\nthe new MATCHLIM value will be effective immediately.\n:eol.\n.pa\n:h2.Creating the AOF Table\nThere are three macros required to create the table:\nTABSTART to start the table,\nTABENTRY to specify actions on messages,\nand TABEND to end the table.\n:p.\nTABSTART is always the first macro and can be\nspecified only once.\nIt takes the form\n:xmp.\n:hp1.loadname:ehp1. TABSTART ID=:hp1.table-id:ehp1.\n:exmp.\nwhere :hp1.loadname:ehp1. is the name of this TSSO table and\n:hp1.table-id:ehp1. is an eye-catching name to identify\nthe table in a dump.\n:hp1.table-id:ehp1. will also be displayed on the\nDISPAOF and .Q~T commands.\nThe :hp1.loadname:ehp1. label is used as the CSECT name and\n:hp1.must:ehp1. be used as the load module name.\n:p.\nTABEND is always the last macro,\nsignifying the end of the table.\nTABEND must be present;\notherwise, unpredictable things may happen,\nnone of them pleasant.\n:p.\nTABENTRY macros are entered between TABSTART and TABEND.\nTABENTRY macros generate entries in the AOF table\nand take the form\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=:hp1.action:ehp1.\\\n{,TEXT=':hp1.operator-cmd:ehp1.'}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{,TEXT=(:hp1.condition:ehp1.)}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{,MATCHLIM=:hp1.n:ehp1.}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{,ECHO={YES/NO/LOG}}\n:exmp.\nA sample AOF table, demonstrating most of the capabilities of TSSO/AOF and\nall forms of the TABENTRY macro, is in the TSSO.VERS43.ASM data set\nin member AOFIVP.\n:h2.TABENTRY Operands\n:h3.The Entry-id Operand\n:hp1.Entry-id:ehp1. is a 1- to 8-character identifier\nfor each AOF table entry.\nThe ID allows you to identify entries by name rather\nthan position in the table\nto the commands OSWAIT, DISPAOF, and ALTAOF.\n:h3.The MSG Operand\nMSG identifies an MVS, JES2, or subsystem message\nas defined in :hp3.MVS/XA System Messages:ehp3. (GC28-1376 and -1377)\nor its MVS/370 equivalent.\n:hp1.msg-id:ehp1. is the first seven or eight characters of the console message.\n:hp1.msg-id:ehp1. may also be an asterisk (*),\nwhich will match on all console messages.\nMSG=* is useful with the TEST operand described later.\n:h3.The ACTION Operand\nThe following actions may be taken in response to the identified message:\n:ol.\n:li.\n:hp3.Suppress (i.e., do not print) the message at the console.:ehp3.\nThe macro takes the form\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=SUPPRESS\n:exmp.\n:li.\n:hp3.Highlight the message at the console.:ehp3.\nThis is useful for highlighting important messages.\nThe macro takes the form\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY~MSG=:hp1.msg-id:ehp1.,ACTION=HILIGHT\n:exmp.\n:li.\n:hp3.Lowlight the message at the console.:ehp3.\nThis reverses the intensity of MVS messages that\nare automatically highlighted.\nThe macro takes the form\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY~MSG=:hp1.msg-id:ehp1.,ACTION=LOWLIGHT\n:exmp.\n:li.\n:hp3.Reply to a Write to Operator with Reply (WTOR) message:ehp3..\nThe macro takes the form\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=REPLY,\\\nTEXT=:hp1.'reply-text':ehp1.\n:exmp.\nwhere :hp1.reply-text:ehp1. is the text of the reply;\nTSSO will automatically format the reply message as\nR~:hp1.msg-no,reply-text.:ehp1.\nNote that :hp1.msg-id:ehp1. must be a WTOR message.\n:li.\n:hp3.Issue an operator command\nin response to a message and extract part of the message\nto use in the command:ehp3..\nThe macro takes the form\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=OSCMD,\\\nTEXT=:hp1.'operator-cmd':ehp1.\n:exmp.\n:hp1.operator-cmd:ehp1. can be an MVS command, JES2 command,\nTSSO command, or TSSO CLIST.\nRules for coding TEXT are described later.\n:li.\n:hp3.Print an operator command at the console\nrather that execute it.:ehp3.\nThis allows you to test an operator command\nthat results from a TABENTRY before executing it.\nThe macro takes the form\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=OSCMDT,\\\nTEXT=:hp1.'operator-cmd':ehp1.\n:exmp.\nThe rules are the same as for OSCMD above.\n:li.\n:hp3.Post a \"waiting task\" that a message occurred.:ehp3.\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=POST\n:exmp.\nPosting supports the OSWAIT command\n(see :hdref refid=oswait.).\n.pa\n:li.\n:hp3.Carry out the specified action if and only if\nthe message meets certain conditions,:ehp3.\nsuch as matching a particular job name.\nTo do this, include the TEST operand in\nyour TABENTRY macro as follows:\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=:hp1.action:ehp1.\\\nTEST=(:hp1.condition:ehp1.)\n~~~~~~~~~~~~~~~~~~{TEXT=':hp1.operator-cmd:ehp1.'}\n:exmp.\n.dc cont off\nwhere :hp1.condition:ehp1. tests portions of the message by\nsubstring or word.\nRules for coding the TEST operand are described later.\n:note.\nTEXT can only be used if ACTION=OSCMD, OSCMDT, or REPLY.\n:eol.\n:p.\nThere is no limit on the number of TABENTRY macros that may be specified in\na given AOF table. Note that TSSO will process\n:hp3.\nall\n:ehp3.\nof the entries in the TSSO/AOF table for every WTO or WTOR message.\nThis\nimplies that multiple ACTION= operands may be specified for the same\n:hp1.msg-id:ehp1.,\nby specifying multiple TABENTRY macros.  TSSO does not stop\nprocessing one ACTION= directive, but continues until the end of the\ntable.\n:h3.The TEXT Operand\nThe OSCMD action\nallows you to specify an operator command to be performed\nin response to a particular message.\nOptionally,\nyou may select one or more portions of the message\nto include in the command.\n:hp1.entry-id:ehp1.~This is useful for extracting a data set name,\njob name, or other variable information from a message\nand embedding it in the command to be executed.\nThe two formatting options in the TEXT parameter\nallow you to extract this information by\nsubstring or by word.\n:p.\nTo select information by substring, use the format\n.dc cont off\n:xmp.\n\\S:hp1.nnn,yy:ehp1.\\\n:exmp.\nwhere :hp1.nnn:ehp1. is the starting character position\nand :hp1.yy:ehp1. is the number of characters to select.\nFor example,\nsuppose you want to record the text of /*MESSAGE cards\nwhenever they are encountered in the job stream.\nJES2 issues a $HASP104 message, and you want to\ncapture characters 1 through 72 of the card.\nThus, the TABENTRY would look like this:\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=$HASP104,ACTION=OSCMD,\\\n.dc cont off\nTEXT='#RECMSG MSG(''\\S001,72\\'')\n:exmp.\nNote that :hp1.nnn:ehp1. must be left-padded with zeroes.\n:p.\nTo select information by word, use the format\n:xmp.\n\\W:hp1.abcdnn:ehp1.\\\n:exmp.\nwhere :hp1.a, b, c,:ehp1. and :hp1.d:ehp1. define the word separator characters,\nand :hp1.nn:ehp1. identifies the word's position.\nA word can be a maximum of 16 characters.\nFor example, given the message\n:xmp.\nIEF176I WTR 1A4 WAITING FOR WORK ...\n:exmp.\nyou might want to purge the writer 1A4 with the command\n:xmp.\nPURGE 1A4\n:exmp.\nTo do this, you want to extract the third word\nfrom the message, which identifies the external writer name.\nThus, the TABENTRY macro would look like this:\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=IEF176I,ACTION=OSCMD,TEXT='PURGE \\W    03\\'\n:exmp.\nNote that if you do not need to define four separator characters,\nyou must pad the field with blanks.\nAlso, :hp1.nn:ehp1. must be left-padded with a zero.\n:p.\nMultiple \"S\" and \"W\" options can be used in one TEXT operand.\nIf AOF detects an error in the TEXT parameter as\na result of a S or W option,\na message is issued and processing is terminated.\n:h3.The TEST Operand\nThe TEST operand allows you to respond selectively\nto messages by \"testing\" the text.\nFor example, when payroll jobs complete,\nyou may want to highlight the message,\nwhereas you want to ignore other job completion messages.\nThe TEST operand allows you to match on message text\nby substring or word.\n:p.\nTo match by substring, use the format\n:xmp.\n(S,:hp1.nnn,yy,'literal-string':ehp1.)\n:exmp.\nwhere you want to find the character string :hp1.literal-string:ehp1.\nstarting in character position :hp1.nnn:ehp1.\nfor a length of :hp1.yy:ehp1. characters.\nFor example,\n:hp2.(S,32,07,'PAYROLL'):ehp2.\nwould look for PAYROLL in character positions 32 through 38.\n:p.\nTo match by word order, use the format\n:xmp.\n(W,:hp1.nn,yy,'literal-string','abcd':ehp1.)\n:exmp.\nwhere you want to find the character string\n:hp1.literal-string:ehp1. as word number :hp1.nn:ehp1.\nwith a word length of :hp1.yy:ehp1. characters;\nand :hp1.a, b, c,:ehp1. and :hp1.d:ehp1. define\nthe word separator characters.\nFor example,\n:hp2.(W,03,07,'PAYROLL',',~'):ehp2.\nwould look for PAYROLL as the third word with seven characters\nseparated by blanks or commas.\n:p.\nThus, the whole TABENTRY macro for our example could be either\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=$HASP395,ACTION=HILITE,\\\nTEST=((S,32,07,'PAYROLL'))\n:exmp.\nor\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=$HASP395,ACTION=HILITE,\\\nTEST=((W,03,07,'PAYROLL',' ,'))\n:exmp.\nIt is possible to test on all WTO or WTOR messages by\nspecifying MSG=*.\nFor example, if you want to highlight\nall JES end-of-day messages,\nyou would test for a first word of $HASP\nand a second word (i.e., job name) of ENDOFDAY.\nThe TABENTRY macro would look like this:\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=*,ACTION=HILIGHT,\\\nTEST=((W,1,5,'$HASP',' '),~~~~~~~~~~X\n~~~~~~~~~~~~~~~~~~(W,2,7,'ENDOFDAY'))\n:exmp.\nMSG=* is also useful when testing for message IDs that are\ngreater than 8 characters or for message IDs in a non-standard format\n(e.g., messages for MODEL 204 applications).\n.dc cont off\n:h4.Notes on the TEST Operand\n:ol.\n:li.\n:hp2.\nEach TEST condition, as well as the\nentire TEST parameter list, must be enclosed in parentheses.\n:ehp2.\n:li.\nThere are multiple way to do the same test,\nas shown in the examples above.\nHowever, it is generally easier to match on words\nrather than substrings.\n:li.\n\"Logical and\" and \"logical or\" test conditions\ncan be constructed with the TEST operand.\n:ol.\n:li.\nTo construct a \"logical and\", specify all the conditions\nto be met in one TEST operand:\n:xmp.\nTEST=((:hp1.condition1),(condition2),(condition3:ehp1.))\n:exmp.\n:li.\nTo construct a \"logical or\", specify multiple\nTABENTRY macros with the same MSG, ACTION, and TEXT operands\nbut with different TEST operands:\n:xmp.\nTABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=:hp1.action:ehp1.,TEST=((condition1))\n.sp\nTABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=:hp1.action:ehp1.,TEST=((condition2))\n.sp\nTABENTRY MSG=:hp1.msg-id:ehp1.,ACTION=:hp1.action:ehp1.,TEST=((condition3))\n:exmp.\n:eol.\n:li.\nWhen using the TEST operand,\nTABENTRY macros can be quite lengthy.\nTo continue a macro on the next line,\nenter an \"X\" in column 72.\nSince the TABENTRY macro follows the conventions for the IBM assembler\nlanguage, the next line in a continuation must start in column 16. Note\nthat blank characters are not permitted, except if they are inside\nquotation marks.\n:li.\nThe first word in the message is usually the message ID.\nThe first column position is the first character in the message ID.\n:eol.\n:h3.The MATCHLIM Operand\nMATCHLIM specifies the maximum number\nof times a particular action can be executed.\nWhen the MATCHLIM value is exceeded,\nthe AOF table entry is ignored.\nNote that the MATCHLIM value may be reset with the\nALTOF command.\n:p.\nFor example,\nif VTAM crashes, you may want TSSO to issue a restart\ncommand immediately but you also\nwant to limit the number of restarts\nin the event VTAM has a serious problem\nthat is not solved by a restart.\nThe following entry will restart VTAM up to three\ntimes after it goes inactive.\n.dc cont \\\n:xmp.\n:hp1.entry-id:ehp1.~TABENTRY MSG=1ST002I,ACTION=OSCMD,\\\nTEXT='START NETWORK',       X\n~~~~~~~~~~~~~~~~~~~ECHO=YES,MATCHLIM=3\n:exmp.\n.dc cont off\n:h3.The ECHO Operand\nSpecifying ECHO=YES will echo the command or reply\nof the TEXT operand to the console\nbefore the action is executed.\nSpecifying ECHO=LOG will echo the command or reply\nin the system log.\nThis provides a level of TSSO accountability.\nThe default is ECHO=YES.\n:h2.Assembling and Link-Editing the Table\nRelease 4.3 provides a sample CLIST for assembling\nand link-editing the TSSO AOF table.\nThe CLIST makes the job of placing a new AOF table\nin production less cumbersome.\nYou will probably need to modify ASMTAB for your installation.\nIts syntax is\n:xmp.\nASMTAB :hp1.table-name:ehp1. {RELOAD}\n:exmp.\nThe CLIST can assemble a moderately sized table,\nlink-edit the result,\nand copy the resulting load module into\nSYS1.TSSOLOAD in about 10 seconds.\nThe RELOAD parameter will issue the TSSO~#.RELOAD command\nupon successful assembly and link-edit.\n:p.\nAlternately, you can\nsubmit a batch job similar to\nthe sample in the TSSO.VERS43.ASM data set, member ASMTABLE.\nYou may tailor a copy of this data set to\nyour specifications as follows:\n:ol.\n:li.\nInclude the appropriate installation-dependent\ninformation on the JOB card.\n:li.\nChange the SYSIN DD card to\npoint to your AOF table.\n:li.\nChange the load library name in the\nLKED.SYSLMOD step to one of your choice (e.g., TSSO.VERS43.LOAD).\n:li.\nChange the NAME statement in the linkage editor control cards to match\nthe label on the TABSTART macro in your AOF table.\n:eol.\n:p.\nNote that the Assembler parameters RENT and NOALIGN\n:hp3.must:ehp3. be present.\n:p.\nA return code of 0 indicates that the assembly was successful.\n:dl tsize=13.\n:dt.WARNING:\n:dd.\n:hp2.\nUnder no circumstances attempt to load\na table if either the assembly or link return codes\nare non-zero.\n:ehp2.\n:edl.\n:h2.Storing the Module\nWhen the table assembly is successful,\ncopy the load module from TSSO.VERS43.LOAD (or the appropriate\ndata set)\ninto the SYS1.TSSOLOAD data set.\nTo activate the new AOF table, use the procedures as described previously\nin this document.\n:h1 id=nccf.TSSO NETWORK COMMUNICATION CONTROL FACILITY INTERFACE\nThe Network Communication Control Facility (NCCF)\nis an IBM program product that provides network control\nin ACF/VTAM or ACF/TCAM environments.\nThrough the addition of an OSCMD command processor,\nNCCF allows a network operator to issue\nMVS, JES2, or subsystem commands\nand to retrieve responses at the NCCF terminal.\nThe NCCF version of OSCMD is a completely separate entity\nfrom the TSO version.\nThe command installs directly into the NCCF load library,\nor a concatenated data set,\nand is defined to NCCF in the DSICMD member of\nthe NCCF parameter data set.\n:h2.Notes on the NCCF Interface\n:ul.\n:li.\nThe NCCF and TSO versions of OSCMD share the same pool\nof subsystem consoles.\nWhen defining the NUMCONS parameter\n(see :hdref refid=numcons.)\nit is important to consider the number of\nsimultaneous NCCF users that will be using TSSO facilities.\n:li.\nAlthough OSCMD runs with APF authority,\nNCCF :hp1.does not:ehp1. require APF authorization with\nthis facility.\nTSSO grants APF authorization to the NCCF version of\nOSCMD through MVS cross memory services.\nThe operator command\n.bf xmpfont\n#.Q~XMEM\n.pf\nmonitors the cross memory service environment.\nA debug option displays a message when the NCCF version\nof OSCMD has called the TSSO cross memory services routine.\n:li.\nTSSO assumes that all NCCF users are authorized\nto issue MVS master console commands.\nThe NCFOSATH user exit is provided\nfor coding a routine to alter the default.\nThe exit is passed the NCCF user identifier.\n:li.\nThe TSSO/NCCF OSCMD facility fully supports\nthe NCCF ROUTE command.\nThis allows remote operators to\nroute MVS, JES2, or subsystem commands\nto remote systems and to retrieve the responses.\nThis facility makes it possible for an operator to\ncontrol (or at least monitor)\nmany MVS hosts from one NCCF console.\n:eul.\n:h1.RECOVERY PROCEDURES\nTSSO operates as a proper subsystem under MVS. Because of this, it can run\nwithout support of a Job Entry Subsystem or communications subsystem.\nTherefore,\nTSSO will initialize even if JES or VTAM will not.\nThrough the use of several command processors,\nTSSO provides facilities for repairing\ncritical MVS files or load modules in the event a subsystem\ndoes not initialize.\n:p.\nThe\n:hp2.\nEF\n:ehp2.\ncommand allows the MVS console operator to perform TSO edit commands\non the file allocated to DDNAME \"EDITFILE\".  This DDNAME could have\nbeen pre-allocated through the ALLOCATE command.  The syntax of the\nEF command is\n:xmp.\nEF (;:hp1.cmd1;cmd2;cmd3...;cmdn:ehp1.)\n:exmp.\nwhere\n:hp1.\ncmd1 ...cmdn\n:ehp1.\nare TSO EDIT commands.\n:p.\nThe\n:hp2.\nPDS\n:ehp2.\ncommand\n:fn.\nA public domain TSO facility rewritten by Bruce Leland\nfrom Cambridge Systems.\n:efn.\nallows you\nto rename, delete or otherwise manipulate members of\na partitioned\ndata set.\nThe PDS command offers a wide range of facilities and can be\nused to recover from a variety of subsystem problems.\nYou are encouraged to obtain a copy of the\nPDS command (Version 7.3)\nfrom the Connecticut Bank and Trust (CBT) mods tape.\n:p.\nLastly, you can also use the standard TSO facilities, such as the\nALLOCATE command, to correct JCL or other initialization errors in\nmajor subsystems.  The full range of TSO commands are available to\nassist in problem resolution.\n:appendix.\n:h1 id=cmdref.TSSO Command Reference\nThis appendix describes the TSO command processors\nthat are distributed with TSSO.  Unless otherwise noted, these\ncommand processors can be issued by TSO users as well as the TSSO\nsubsystem.\nThe commands are documented one-to-a-page for easy insertion into\nexisting operator procedure books.\n.rh on\n.sx c /ALTAOF/TSSO User's Guide/ALTAOF/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nALTAOF\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nALTOAF dynamically resets the MATCHLIM value for\na given AOF table entry.\nNote that resetting the MATCHLIM value to 0\neffectively deletes the entry.\n:note.The ALTAOF command requires the user ID invoking the command\nto have the X'C0' bits turned on in the USERDATA(PSCBATR2) field\nin their UADS entry.\nThis can be accomplished through the USERDATA parameter of the\nCHANGE or ADD subcommand of ACCOUNT.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n:xmp.\nALTAOF ENTRY:hp1.(entry-id):ehp1. MATCHLIM(:hp1.matchlim-value:ehp1.)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~or\n~~~~~~~~~~~~~~~~~~~~~~~~~~MLIM(:hp1.matchlim-value:ehp1.)\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=17 termhi=1.\n:dt.entry-id\n:dd.\nA 1- to 8-character ID for a\nTSSO/AOF table entry for which the MATCHLIM value will be changed.\n:dt.matchlim-value\n:dd.\nNew MATCHLIM value.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=13.\n:dt.Example 1.\n:dd.\nReset the MATCHLIM value to 4 for the\nlabeled \"VTAMUP\" entry in the\nactive AOF table.\n:xmp.\nALTAOF ENTRY(VTAMUP) MATCHLIM(4)\n:exmp.\n:dt.Example 2.\n:dd.\nDelete the labeled \"OFFLINE\" entry in the active AOF table.\n:xmp.\nALTAOF ENTRY(OFFLINE) MATCHLIM(0)\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /CACHE/TSSO User's Guide/CACHE/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nCACHE\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe CACHE command controls the operation of 3880-11, 3880-21,\n3880-13 or 3880-23 cache devices from the MVS console.  As distributed by\nIBM, software support for control of these devices\nis contained in the IDCAMS program\navailable with MVS; the MVS console operator cannot control or even query\nthe device.  The CACHE command will format an IDCAMS command, attach IDCAMS,\nand write the results using the PUTLINE interface.  When issued under TSSO,\nthese results are then displayed on the MVS console.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nCACHE :hp1.cache-device:ehp1. {:hp1.action:ehp1.} {SUBSYS} {LEGEND}\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=15 termhi=1.\n:dt.cache-device\n:dd.\nA 3-digit UCB address or a 6-character volume serial.\n:dt.action\n:dd.Action to be performed by the CACHE command:\n:dl tsize=9 termhi=0.\n:dt.ON\n:dd.Format the appropriate IDCAMS command (SETCACHE) to turn the cache unit\non.\n:dt.OFF\n:dd.Format the appropriate IDCAMS command (SETCACHE) to turn the cache  unit\noff.\n:dt.LIST\n:dd.\nFormat a LISTDATA command to list cache statistics\n(e.g., READ hit ratio).\n:dt.STATUS\n:dd.(default) Provide information concerning the current status of the\ncache device.\n:edl.\n:edl.\n:dl tsize=15 termhi=0.\n:dt.SUBSYS\n:dd.\nProvide information about\nthe entire 3350 or 3380 string.\n:dt.LEGEND\n:dd.\nProvide a verbose Description of the format of the IDCAMS\noutput.\n(This is probably inappropriate for display at the console.)\n:edl.\n.in 0\n.bf hd4\nIssuing Other IDCAMS Commands with CACHE\n.pf\n.sp\n.in 5\nThere are some commands that you may want to issue to the cache controller\nthrough IDCAMS that are not supported by this command.  For these\noccasions, an alternate form of the CACHE command is provided.\n:xmp.\n~~~~~CACHE~*~CMD(':hp1.idcams-cmd:ehp1.')\n:exmp.\nwhere\n:hp1.\nidcams-cmd\n:ehp1.\nis any command accepted by IDCAMS.  This can be a cache command, such\nas BINDDATA, or a command that has nothing to do with cache devices, such as\nLISTC.\n:dl tsize=7.\n:dt.NOTE:\n:dd.\nTo issue these commands under a TSO session,\nfirst execute the CLIST ALOCCACHE in TSSO.VERS43.ASM\nto allocate the needed data sets.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nTurn on the cache device for the volume at UCB 263.\n:xmp.\nCACHE 263 ON\n:exmp.\n:dt.Example 2.\n:dd.\nTurn off volume JESSPL to the cache device.\n:xmp.\nCACHE JESSPL OFF\n:exmp.\n:dt.Example 3.\n:dd.\nTurn volume PGMPRO on to the cache device.\n:xmp.\nCACHE PGMPRO ON\n:exmp.\n:dt.Example 4.\n:dd.\nPrint status information for the cache device covering volume PGMPRO.\n:xmp.\nCACHE PGMPRO\n:exmp.\n:dt.Example 5.\n:dd.\nPrint status information for all volumes covered by the cache\ndevice covering\nvolume PGMPRO.\n:xmp.\nCACHE PGMPRO SUBSYS\n:exmp.\n:dt.Example 6.\n:dd.\nPrint statistics for the cache device at UCB 265.\n:xmp.\nCACHE 265 LIST\n:exmp.\n:dt.Example 7.\n:dd.\nIssue the IDCAMS LISTC command and return the reply to the\ninvoking console.\n:xmp.\nCACHE * CMD('LISTC')\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /CPCMD/TSSO User's Guide/CPCMD/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nCPCMD\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe CPCMD command allows the MVS operator of a virtual\nmachine to issue CP commands on a VM/SP, VM/SP HPO or\nVM/XA system.  Any CP command of the appropriate CP privilege class\nis allowed.  The response of the command is returned to the invoking\nconsole.\nNote that this command will also function under TSO and\nreturn the response to the CP command to the invoking TSO user.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nCPCMD :hp1.cp-cmd:ehp1.\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl termhi=1.\n:dt.\ncp-cmd\n:dd.Any VM CP command.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nIssue the CP QUERY NAMES command and return the response to the\ninvoking console.\n:xmp.\nCPCMD~QUERY~NAMES\n:exmp.\n:dt.Example 2.\n:dd.\nDirect VM to attach the device at 3F0 to the virtual machine\nconfiguration at virtual device 3F0.\n:xmp.\nCPCMD~ATTACH~3F0~*~3F0\n:exmp.\nNote that the device must also be varied on-line\nby the MVS operator.  The MVS virtual machine\nwould need command privilege class \"B\" to issue this command.\n:edl.\n.in 0\n.rh on\n.sx c /DISPAOF/TSSO User's Guide/DISPAOF/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nDISPAOF\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe DISPAOF command displays the contents of TSSO/AOF tables\nwhich control the operation of the TSSO Automated Operations Facility.\nThe DISPAOF command can query either the active TSSO/AOF table or a table\nthat has been assembled and is residing on DASD.\nBy default, DISPAOF will display all entries in the\nrunning TSSO/AOF table.\nThe information\ndisplayed includes the TSSO/AOF table name, ID parameter, date and time\nassembled, and TSSO version number.  For each message displayed, the\ntable entry ID,\nMSG ID, ACTION directive and ACTION TEXT will be displayed.\nTEST conditions will not be displayed unless the\nTEST parameter is specified.\nOptionally, the display can be limited to selected\nmessage IDs.\n:p.\nInformation about alternate TSSO/AOF tables\ncan be displayed by using the :hp1.table-name:ehp1. parameter.\nAlternate\ntables must previously have been assembled and\nplaced (in load module form) into the\nSYS1.TSSOLOAD dataset.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n.dc cont \\\n:xmp.\nDISPAOF~{ENTRY(:hp1.entry-id:ehp1.)} {MSG(msg-id)}\\\n~{TABLE(:hp1.table-name:ehp1.)}~{TEST}\n:exmp.\n.dc cont off\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=20 termhi=0.\n:dt.ENTRY(entry-id)\n:dd.\nA 1- to 8-character ID of a AOF table entry.\nNote that DISPAOF will display :hp2.all:ehp2.\nentries that start with the entry identifier;\nan exact match is not required\n(see examples).\n:dt.MSG(msg-id)\n:dd.\nA 1- to 8-character message identifier specified in the\nTSSO/AOF TABENTRY macro MSG parameter.\nNote that DISPAOF will display :hp2.all:ehp2.\nentries that start with the message identifier;\nan exact match is not required\n(see examples).\n:dt.TABLE(table-name)\n:dd.\nAn alternate TSSO AOF table name.\nThe table must previously have been assembled and available to TSSO.\n:dt.TEST\n:dd.\nFor each message, display any TEST conditions that exist.\n:edl.\n.in 0\n.pa\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nDisplay the running TSSO/AOF table with all message IDs, action\ndirectives, and action text.\n:xmp.\nDISPAOF\n:exmp.\n:dt.Example 2.\n:dd.\nDisplay all entries in the running TSSO/AOF table with a message ID\nof $HASP395.\n:xmp.\nDISPAOF MSG($HASP395)\n:exmp.\n:dt.Example 3.\n:dd.\nDisplay all entries and all test conditions in the running AOF\ntable for message ID $HASP350.\n:xmp.\nDISPAOF MSG($HASP350) TEST\n:exmp.\n:dt.Example 4.\n:dd.\nDisplay all entries and all test conditions for message IKT021D\nin load module AOFNEW.\n:xmp.\nDISPAOF MSG(IKT021D) TABLE(AOFNEW) TEST\n:exmp.\n:dt.Example 5.\n:dd.\nDisplay all entries in the active AOF table starting with \"VTAMUP\".\n:xmp.\nDISPAOF ENTRY(VTAMUP)\n:exmp.\n:dt.Example 6.\n:dd.\nDisplay all entries in the active AOF table  with a message ID\nstarting with \"$HASP\".\n:xmp.\nDISPAOF MSG($HASP)\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /LINKLIST/TSSO User's Guide/LINKLIST/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nLINKLIST\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe\nLINKLIST\ncommand displays the list of the data sets in the current MVS LNKLST\nconcatenation.\nThis command is only valid in an MVS/XA\nenvironment, because the information is not available in MVS/370.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nLINKLIST\n:exmp.\n.in 0\n.rh on\n.sx c /OSASK/TSSO User's Guide/OSASK/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nOSASK\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nOSASK allows you to ask the operator a question and\nget a response.\nIf it is issued from a TSO command line,\nthe response goes to the user's terminal.\nIf it is issued from a CLIST,\nthe response goes to CLIST variables\n(see below).\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nOSASK :hp1.question:ehp1.\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=12 termhi=1.\n:dt.\nquestion\n:dd.\nQuestion to be sent to the operator's console.\n:edl.\n.in 0\n.sp\n.bf hd3\nCLIST Variables\n.pf\n.in 5\n:dl tsize=18 termhi=0.\n:dthd.Input Variables\n:ddhd.~~~~~~~~~~Definition\n:dt.REPLYWAIT\n:dd.\nThe number of seconds you are willing to wait for\na reply to the question.\nThis can be a value from 1 to 60;\ndefault is 60.\n:edl.\n:dl tsize=18 termhi=0.\n:dthd.Output Variables\n:ddhd.~~~~~~~~~~Definition\n:dt.REPLY\n:dd.\nText of the reply to the question.\n:dt.REPLYW\n:dd.\nThe number of words in the operator's reply.\n:dt.REPLYWn\n:dd.\nThe :hp1.n:ehp1.th word of the reply.\n:edl.\n.in 0\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nAsk the operator a question.\n:xmp.\nOSASK WHAT TIME IS SHUTDOWN?\n:exmp.\n:dt.\nExample 2.\n:dd.\nAsk the operator to specify type of start for production system.\n:xmp.\nOSASK BCR001I SPECIFY START FOR PRODUCTION SYSTEM (WARM, COLD)?\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /OSCMD/TSSO User s Guide/OSCMD/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nOSCMD\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nOSCMD allows you to issue any MVS command\n(JES2, VTAM, etc.).\nIf it is issued from a TSO command line,\nthe response is returned to the terminal.\nIf it is issued from a CLIST,\nthe response can optionally go to the CLIST variables\n(see below).\nNote that,\nwhen OSCMD is issued from a TSSO-initiated CLIST,\nOSCMD checks the authority of the invoking console\nand only permits commands of that level.\nWhen issued by a TSO user,\nOSCMD checks the installation authority of the user's ID.\nBy default, all TSO users have INFO-only authority;\nsystem or I/O authority can be granted on a per-user basis.\nThe installation can control access\nthrough the OSCMDATH user exit.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nOSCMD :hp1.mvs-cmd:ehp1.\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=12 termhi=1.\n:dt.\nos-cmd\n:dd.\nAny MVS command.\n:edl.\n.in 0\n.sp\n.bf hd3\nCLIST Variables\n.pf\n.in 5\n:dl tsize=25 termhi=0.\n:dthd.Input Variables\n:ddhd.~~~~~~~~~~Definition\n:dt.CMDRESP=dest\n:dd.\nDestination of OSCMD response:\n:dl termhi=0 tsize='1i'.\n:dt.CLIST:dd.return response to CLIST variables (see below)\n:dt.TERM:dd.return response to TSO user's terminal\n:dt.NOWHERE:dd.discard the response (TSO users)\nor return response to console (TSSO-initiated commands)\n:edl.\n:dt.CMDWAIT=nn\n:dd.\nMaximum number of seconds you are willing to wait\nfor the command to finish.\n:hp1.nn:ehp1. is a value from 1 to 60;\ndefault is 1 for nonCLIST execution.\nIf the CMDWAIT value is exceeded,\nthe only response returned will be an echo\nof the original OSCMD.\nIf TSSO can detect the end of a command response\n(e.g., responses using MLWTOs),\nthen OSCMD will not need to wait the full value of CMDWAIT.\n:dt.MAXCMDOUT=nnn\n:dd.\nMaximum number of lines of response you want returned\nfrom the command.\n:hp1.nnn:ehp1. is a value from 1 to 200;\ndefault is 200 for nonCLIST execution.\n:edl.\n.pa\n:dl tsize=20 termhi=0.\n:dthd.Output Variables\n:ddhd.~~~~~~~~~~Definition\n:dt.CMDOUT\n:dd.\nThe number of lines returned in the response.\n:dt.CMDOUTm\n:dd.\nThe :hp1.m:ehp1.th line returned in the response.\n:hp1.m:ehp1. is a value from 1 to 200.\n.br\nNOTE:  CMDOUT1 is always an echo of the original command.\n:dt.CMDOUTmW\n:dd.\nThe number of words in the :hp1.m:ehp1.th line of the response.\n:dt.CMDOUTmWn\n:dd.\nThe :hp1.m:ehp1.th line, the :hp1.n:ehp1.th word in the response line.\n:hp1.n:ehp1. is a value from 1 to 20.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.sp\n.in 5\nSee :figref refid=exjobs. through :figref refid=exstvt..\n.in 0\n.rh on\n.sx c /OSPAUSE/TSSO User's Guide/OSPAUSE/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nOSPAUSE\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nOSPAUSE delays processing of a command for\nthe specified number of seconds.\nThis is useful if the CLIST initiates a started task\nand must wait for it to initialize.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nOSPAUSE :hp1.seconds:ehp1.\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl termhi=1.\n:dt.\nseconds\n:dd.\nThe number of seconds that the CLIST should be delayed.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.Delay the CLIST 10 seconds.\n:xmp.\nOSPAUSE 10\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /OSWAIT/TSSO User's Guide/OSWAIT/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nOSWAIT\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nOSWAIT directs TSSO to wait for a particular system\nmessage or a timeout limit to occur before proceeding.\nThese messages are defined in the AOF table.\nOSWAIT is intended to be issued from a CLIST.\n:p.\nIf the message appears,\nOSWAIT gives a return code of 0 (RC=0).\nIf OSWAIT was issued from a terminal,\nthe message prints at the terminal.\nOtherwise, the CLIST variables are populated (see below).\nIf the message does not appear by the timeout limit,\nOSWAIT gives a return code of 8 (RC=8).\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nOSWAIT ENTRY(:hp1.entry-id:ehp1.) TIMEOUT(:hp1.nnnnn:ehp1.)\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl termhi=1.\n:dt.\nentry-id:dd.The 1- to 8-character identifier\nof the AOF table entry.\n:dt.nnnnn:dd.The number of second to wait before\ntimeout, maximum 86400 seconds.\n:edl.\n.in 0\n.sp\n.bf hd3\nCLIST Variables\n.pf\n.in 5\n:dl tsize=20 termhi=0.\n:dthd.Output Variables\n:ddhd.~~~~~~~~~~Description\n:dt.WTO\n:dd.Text of the message\n:dt.WTOW\n:dd.Number of words in the message\n:dt.WTOWn\n:dd.Nth word of the message\n:edl.\n.in 0\n:p.\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.\nExample 1.\n:dd.Wait 2 minutes for message IST020I to appear.\n:xmp.\nOSWAIT ENTRY(IST020I) TIME(120)\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /OSWTO and OSWTOH/TSSO User's Guide/OSWTO and OSWTOH/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nOSWTO and OSWTOH\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nOSWTO and OSWTOH allow you to write messages\nto the operator's console.\nOSWTOH highlights the message.\nThese commands can be issued only from a TSSO-initiated CLIST.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nOSWTO :hp1.message:ehp1.\n.sp\nOSWTOH :hp1.message:ehp1.\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=12 termhi=1.\n:dt.\nmessage\n:dd.\nThe text of the message to be sent to the operator.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nNotify the operator of an IPL in progress.\n:xmp.\nOSWTO BCR101I AUTOMATED IPL IN PROGRESS\n:exmp.\n:dt.\nExample 2.\n:dd.\nSend a highlighted message to the operator.\n:xmp.\nOSWTOH BCR102I SYSTEM SHUTDOWN COMPLETE\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /REPLY/TSSO User s Guide/REPLY/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nREPLY\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe REPLY command is used to reply to MVS WTOR messages after the WTOR\nhas appeared on the MVS console.\n:fn.\nContrast this to the ACTION=REPLY directive in\nTSSO/AOF, which replies to messages the instant they are generated.\nThus, TSSO/AOF and the REPLY command combine to give full coverage\non automating responses to MVS WTORs.\n:efn.\nYou do not need to know the MVS reply\nnumber to respond to the WTOR.  The REPLY command can, therefore, be used\nto automate operational procedures with products that communicate to the\noperator through the WTOR interface\n(e.g., NCCF, IMS, GDDM).\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nREPLY MSG(:hp1.msg-id:ehp1.) TEXT(:hp1.reply-text:ehp1.)\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=18 termhi=0.\n:dt.\nMSG(msg-id)\n:dd.The message you are replying to (e.g., DSI802A)\n:dt.\nTEXT(reply-text)\n:dd.\nThe text of the reply you wish to give in response to the WTOR.\n:edl.\n.in 0\n.sp\n.bf hd3\nNotes on Using REPLY with IMS/VS\n.pf\n.sp\n.in 5\nThere are some installations that run multiple copies of the IMS/VS\nprogram product.\nAll of the subsystems issue the same message ID as a WTOR.\nFor\nthese installations, an alternate form of the REPLY command\nis available to direct replies to the correct IMS subsystem:\n.fo off\n:xmp.\n~~~~~REPLY IMS(:hp1.ims-id:ehp1.) TEXT(:hp1.reply-text:ehp1.)\n:exmp.\n.fo on\nwhere\n:hp1.\nims-id\n:ehp1.\nis the name of the IMS subsystem to which you wish to\ndirect the response, and\n:hp1.\nreply-text\n:ehp1.\nis as defined above.\nIn this way IMS procedures can be automated.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nShut down the NCCF program product.\n:xmp.\nREPLY MSG(DSI802A) TEXT('CLOSE IMMED')\n:exmp.\n.pa\n:dt.Example 2.\n:dd.Reply to message USRWT01.\n:xmp.\nREPLY MSG(USRWTO1) TEXT('DISPLAY FIELDS')\n:exmp.\n:dt.Example 3.\n:dd.Issue the IMS command DISPLAY ACTIVE on IMS subsystem ZFF.\n:xmp.\nREPLY IMS(ZFF) TEXT('/DIS A')\n:exmp.\n:dt.Example 4.\n:dd.Issue the IMS command NRESTART on IMS subsystem PRO.\n:xmp.\nREPLY IMS(PRO) TEXT('NRE CHECKPOINT 0 FMT ALL')\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /SPMON/TSSO User's Guide/SPMON/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nSPMON\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe SPMON command displays system information to the MVS\nconsole operator.\nBy default SPMON will display the following information:\npercentage of CPU busy,\naverage Unreferenced Interval Count (UIC),\naverage paging rate,\nnumber of TSO users,\nnumber of started tasks,\nnumber of batch jobs, and\nnumber of\n:hp1.\ninactive\n:ehp1.\ninitiators.\nIn addition, if Parameters are specified to SPMON,\nthe following\njob-related information is printed:\nJOBNAME,\nnumber of service units in current transaction,\nswap-in/swap-out status, and\nnumber of active frames in real storage.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nSPMON  {:hp1.job-parm:ehp1. {:hp1.type-parm:ehp1.}}\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl tsize=12 termhi=1.\n:dt.\njob-parm\n:dd.A 1- to 8-character string\nfor matching on job name,\nor \"ALL\" to display information on all jobs.\n:dt.\ntype-parm\n:dd.\nThis directs SPMON to print information about selected\ntypes of jobs.\nLegal values are\nJOB (all batch jobs),\nSTC (all started tasks),\nTSO (all TSO users),\nor ALL (all batch jobs, started tasks, and TSO users).\nDefault is ALL.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nDisplay the general system information only.\n:xmp.\nSPMON\n:exmp.\n:dt.\nExample 2.\n:dd.Display general system information as well as information on\nall jobs, TSO users or started tasks that start with \"BCR\".\n:xmp.\nSPMON BCR\n:exmp.\n:dt.Example 3.\n:dd.Display general system information and information\nabout all TSO users whose user IDs begin with \"PY\".\n:xmp.\nSPMON PY TSO\n:exmp.\n:edl.\n.in 0\n.rh on\n.sx c /VALLOC and VOLSER/TSSO User's Guide/VALLOC and VOLSER/\n.sp 3\n.rh off\n.pa\n.bf hd3\nName:\n.pf\nVALLOC and VOLSER\n.sp\n.bf hd3\nAvailable Under TSO:\n.pf\nYes\n.sp\n.bf hd3\nDescription\n.pf\n.sp\n.in 5\nThe VALLOC and VOLSER commands display\nUCB and ALLOCATION information.\nBy default,\nthe commands will display information for the MVS SYSRES (IPL)\ndevice.\nIf a volume serial is specified,\nthe command will locate the device\nusing the standard MVS UCBSCAN service and display the UCB address and  the\nUCB itself.\n:fn.\nThe commands use\nthe TSSO \"*COM\" interface to issue appropriate MVS commands.\nto display UNIT or ALLOCATION information.\nThe VOLSER command\nissues the \"D~U,,,:hp1.ucb-address:ehp1.,1\" MVS system command,\nwhile the VALLOC command\nissues the \"D~U,,ALLOC,:hp1.ucb-address:ehp1.,1\" MVS command.\nNote that, when this command is issued under regular\nTSO, the MVS commands are not generated and the invoker of the command will\nsee the formatted command including the *COM keyword.\n:efn.\nThe command will also\ninform the MVS operator if the\nvolume is not found.\n.in 0\n.sp\n.bf hd3\nSyntax\n.pf\n.in 5\n:xmp.\nVALLOC {:hp1.volser:ehp1.}\n.sp\nVOLSER {:hp1.volser:ehp1.}\n:exmp.\n.in 0\n.bf hd3\nParameters\n.pf\n.in 5\n:dl termhi=1.\n:dt.\nvolser\n:dd.A  6-character DASD volume identifier.\n:edl.\n.in 0\n.sp\n.bf hd3\nExamples\n.pf\n.in 5\n:dl tsize=12.\n:dt.Example 1.\n:dd.\nDisplay the UCB address and allocation information for volume PPBFX2.\n:xmp.\nVALLOC PPBFX2\n:exmp.\n:dt.Example 2.\n:dd.\nDisplay UCB information for the MVS SYSRES (IPL) pack.\n:xmp.\nVOLSER\n:exmp.\n:dt.Example 3.\n:dd.\nDisplay the UCB address for volume SYSRES.\n:xmp.\nVOLSER SYSRES\n:exmp.\n:edl.\n.in 0\n.rh cancel\n:h1 id=cntlcmd.TSSO Control Commands\nTSSO control commands are used to direct TSSO processing.\nAll such commands start with the TSSO System Recognition Character\n(SRC).\nThe Examples below assume that \"#\" is the TSSO SRC.\n:p.\nNote that TSSO control commands may be treated exactly as other TSO\ncommands when used in a TSSO CLIST.  For example, a CLIST may process\ndirectives and then issue a .RELOAD command to reload the TSSO/AOF\ntable.  It is also possible for a CLIST to consist of nothing but\nTSSO commands. For example, a CLIST could be written\nto query all the TSSO Parameters.\n:h2.General Commands\n:dl tsize=28.\n:dt.#.L n\n:dd.Lists the results of the previous TSSO commands on console\n:hp1.n:ehp1..\n:dt.\n#.LOGOFF\n:dd.\nLogs off the console.\n:dt.\n#.LOGON user-id password\n:dd.\nLogs on the invoking console to TSSO.\n:edl.\n.sp 2\nVarious Parameters of the TSSO subsystem\ncan be queried using the #.Q family of commands.\n:dl tsize=28.\n:dt.\n#.Q LOGON\n:dd.\nDisplays the console ID and the user ID of all\nconsoles logged on to TSSO.\n:dt.\n#.Q MAXCMD\n:dd.\nReturns the value of the MAXCMDS parameter specified at TSSO\nstartup.\n:dt.\n#.Q MAXWTO\n:dd.\nReturns the value of the MAXWTO parameter specified at TSSO\nstartup.\n:dt.\n#.Q RACF\n:dd.\nReturns the name of the TSSO RACF user identifier.\n:dt.#.Q SCON\n:dd.Displays the status of subsystem consoles.\n:dt.\n#.Q SWAP\n:dd.\nIndicates if TSSO is running non-swappable.\n:dt.\n#.Q T\n:dd.\nReturns the name of the TSSO AOF table.\nAdditional information displayed includes the\nvalue specified on the :hp3.ID:ehp3. parameter\nof the TABSTART macro and the\ndate and time the AOF table was assembled.\n:dt.\n#.Q TIMEOUT\n:dd.\nDisplays the TIMEOUT value.\n:dt.\n#.Q VERS\n:dd.\nDisplays the TSSO Version identifier (TSSO 4.3) and the date and times\nthat the TSSO, TSSOWTO,\nand the subsystem interface intercept modules were last assembled.\n:dt.#.Q XMEM\n:dd.Displays status of TSSO cross memory services environment.\n:edl.\n.pa\n:h2.Restricted Commands\nThe following commands are restricted to consoles\nwith MVS system authority.\n:dl tsize=22.\n:dt.\n#.ABEND\n:dd.\nAbnormally terminates the TSSO address space. This is\na TSSO debugging aid which should not be used in normal\noperation.\n:dt.\n#.J\n:dd.\nRequests a job identification number from the primary subsystem.\nThis\nis required if TSSO will be using the primary subsystem's services.\nThese\nservices include submitting jobs\n(with the TSO SUBMIT command) and using the PRINTOFF command.\nNote that if TSSO was started using the \"SUB=JES2\" parameter, this command\nwill have no effect.\n:dt.\n#.M\n:dd.\nManipulates the TSSO debugging facility. This command\nshould not be used under normal circumstances.\n:dt.\n#.P\n:dd.\nTerminates the Time Sharing Subsystem Option.  TSSO can be\nrestarted through the \"S TSSO\" command as described on page 13.\n:dt.\n#.RELOAD table-name\n:dd.\nLoads a\nTSSO Automated Operations Facility table\nidentified by :hp1.table-name:ehp1.\nand performs a \"#.Q T\"\n(see previous page).\nIf :hp1.table-name:ehp1.='NONE', then\nthe AOF is deactivated.  If an error occurs while processing\nthe table, AOF is deactivated.  The most common errors include\n:hp1.table-name:ehp1. not being found\nand :hp1.table-name:ehp1. not being a valid TSSO AOF table.\n:edl.\n:h1.TSSO Processing Modules\n:dl tsize=15.\n:dt.$ENDOFDA\n:dd.\nSample IEFBR14 job: AOF can trap the END OF JOB message\n:dt.$PAYROLL\n:dd.\nSame as above.\n:dt.ALOCCACH\n:dd.\nSample CLIST to allocate files needed to run the cache\ncommand from a TSO user ID.\n:dt.ALTAOF\n:dd.\nALTAOF command:  Change MATCHLIM dynamically for TSSO/AOF\n:dt.AOFIVP\n:dd.\nSample AOF table that shows all forms of TABENTRY macro.\n:dt.ASMALL\n:dd.\nPROC to assemble all TSSO processing modules.\n:dt.ASMONE\n:dd.\nPROC to assemble one TSSO processing module.\n:dt.ASMTABLE\n:dd.\nPROC to assemble an AOF table.\n:dt.ASMTSSO\n:dd.\nPROC to assemble all TSSO subsystem modules.\nThis is need if the TSSOCVT or TSSODATD macro is altered.\n:dt.CACHE\n:dd.\nCACHE command:  Controls a 3880 CACHE control unit.\n:dt.COPYPROC\n:dd.\nPROC to copy the sample TSSO START PROC into SYS1.PROCLIB.\n:dt.CPCMD\n:dd.\nCPCMD command:  Issue a CP command if running under VM.\n:dt.DATAAREA\n:dd.An non-comprehensive list of the major TSSO data areas.\n:dt.DISPAOF\n:dd.\nDISPAOF command:  Displays an active or inactive AOF table.\n:dt.EF\n:dd.\nEF command:  Allows a file to be edited under TSSO.\n:dt.EQUATES\n:dd.\nStandard R0-R15 equate macro.\n:dt.EXASK\n:dd.\nSample CLIST using the OSASK command.\n:dt.EXCHKSPL\n:dd.\nSample CLIST using OSCMD command and\nmanipulation of the response.\n:dt.EXJOBS\n:dd.\nAnother example using OSCMD.\n:dt.EXSTVTAM\n:dd.\nAn example of OSCMD without response retrieval.\n:dt.FORMAT\n:dd.\nMacro to format numbers from assembler programs.\n:dt.GENTAPE\n:dd.\nPROC to generate the TSSO distribution tape.\n:dt.GETCVT\n:dd.\nMacro to find the TSSO CVT (SSCTSUSE field in TSSO SSCT).\n:dt.ISXA\n:dd.\nMacro to determine if you are running under MVS/XA.\n:dt.JCECVT\n:dd.\nSubroutine for decimal/hex conversions.\n:dt.LINKLIST\n:dd.\nLINKLIST command:  Displays the MVS LNKLST concatenation.\n:dt.MENTER\n:dd.\nMacro for beginning subroutine linkage.\n:dt.MLEAVE\n:dd.\nMacro for closing subroutine linkage.\n:dt.MULT\n:dd.\nBill Godfrey's MULT command:\nAllows you to enter multiple commands on a line.\nGreat for commands that have subcommands.\n:dt.NCFOSATH\n:dd.The NCCF user authorization exit.\n:dt.NCFOSCMD\n:dd.The NCCF version of the OSCMD command processor.\n:dt.OPCMDMSG\n:dd.A message CSECT for callers of TSSOPCMD.\n:dt.OSASK\n:dd.\nOSASK command:  Ask the operator a question.\n:dt.OSCMD\n:dd.\nOSCMD command:  Issue an MVS command and get a response.\n:dt.OSCMDICB\n:dd.\nOSCMD Interface Control Block:  for communication\nbetween OSCMD and TSSOSS09.\n:dt.OSCMDATH\n:dd.The user exit for the OSCMD TSO facility.\n:dt.OSCMDICB\n:dd.OSCMD Interface Control Block for communication\nbetween TSSOPCMD and TSSOSS09.\n:dt.OSPAUSE\n:dd.\nOSPAUSE command:  Delay the execution of a CLIST.\n:dt.OSWAIT\n:dd.The OSWAIT command processor.\n:dt.OSWTO\n:dd.\nOSWTO command:  Issue a message to the operator.\n:dt.PTFS\n:dd.A summary of the PTFs in TSSO 4.2 that are in 4.3.\n:dt.RELGDE41\n:dd.\nTSSO 4.1 release guide.\n:dt.RELGDE42\n:dd.\nTSSO 4.2 release guide.\n:dt.RELGDE43\n:dd.\nTSSO 4.3 release guide.\n:dt.REPLY\n:dd.\nREPLY command:  Issue a REPLY command by message ID.\n:dt.REPLYLOA\n:dd.\nREPLYLOA module:  Performs X-MEM functions for REPLY command.\n:dt.RUNASM\n:dd.\nPROC for assembling TSSO commands.\n:dt.SAMPPARM\n:dd.\nSample Parameters for SYS1.PARMLIB(TSSOPARM).\n:dt.SETMODE\n:dd.\nMacro for changing mode (24 bit - 31 bit).\n:dt.SETPARSE\n:dd.\nMacro for setting up IKJPARS control blocks.\n:dt.SPMON\n:dd.\nSPMON command for performance monitoring.\n:dt.SSCONCB\n:dd.Subsystem Control Control Block DSECT.\n:dt.SSCOBCBH:dd.DSECT for the SSCONCB header.\n:dt.SSID\n:dd.\nSSID macro for obtaining SMF system ID.\n:dt.TABEND\n:dd.\nTABEND macro for defining end of AOF table.\n:dt.TABENTRY\n:dd.\nTABENTRY macro for defining AOF table entries.\n:dt.TABSTART\n:dd.\nTABSTART macro for defining start of AOF table entries.\n:dt.TLINE\n:dd.\nTLINE macro for doing TPUT of character string.\n:dt.TSSLRACF\n:dd.\nTSSLRACF subroutine for doing RACINITS in #.LOGON command.\n:dt.TSSO\n:dd.\nTSSO mainline processing module.\n:dt.TSSOCCMD\n:dd.\nTSSOCCMD subroutine for handling TSSO control commands.\n:dt.TSSOCMND\n:dd.\nTSSOCMND macro for defining control block to interface\nbetween TSSO and TSSOSS10 (CMDRING DSECT).\n:dt.TSSOCVT\n:dd.\nMapping macro for TSSO's CVT.\n:dt.TSSODATD\n:dd.\nMapping macro for TSSO's private data area.\n:dt.TSSODOCM\n:dd.\nTSSODOCM subroutine for handling TSO commands under TSSO.\n:dt.TSSOESTA\n:dd.\nTSSOESTA subroutine for handling TSSO errors.\n:dt.TSSOGAPF\n:dd.TSSO cross memory services routine to get APF authorized.\n:dt.TSSOGSSC\n:dd.\nInterface for subsystem allocatable consoles.\n:dt.TSSOINIT:dd.TSSO routine for IPL time initialization.\n:dt.TSSOINI1\n:dd.\nTSSO initialization, part 1.\n:dt.TSSOINI2\n:dd.\nTSSO initialization, part 2.\n:dt.TSSOINI3\n:dd.\nTSSO initialization, part 3.\n:dt.TSSOINI4:dd.TSSO initialization, part 4 (SS consoles).\n:dt.TSSOINI5:dd.TSSO initialization, part 5 (XMEM services).\n:dt.TSSOMAIN:dd.TSSO mainline routine for processing TSO commands\n:dt.TSSONDSA:dd.TSSO Non-Disruptable System Area DSECT.\n:dt.TSSOPARS\n:dd.\nSubroutine for parsing just about anything.\n:dt.TSSOPCMD\n:dd.Routine to process operating system commands and return\nthe responses to a buffer.\n:dt.TSSOPREC:dd.Recovery routine for TSSOPCMD.\n:dt.TSSOPROC\n:dd.\nA sample proc for starting TSSO (S TSSO).\n:dt.TSSOSECR\n:dd.\nMacro to map the TSSO security control block.\n:dt.TSSOSS09\n:dd.\nTSSO WTO intercept routine (subsys code 9).\n:dt.TSSOSS10\n:dd.\nTSSO Command intercept routine (subsys code 10).\n:dt.TSSOTERM\n:dd.\nModule for handling TSSO termination.\n:dt.TSSOWTO\n:dd.\nModule for copying SYSTSPRT file to console after commands.\n:dt.UNDERTSO\n:dd.\nMacro to determine if you are running under TSO.\n:dt.USEGDE41\n:dd.\nThe user's guide for TSSO 4.1.\n:dt.USEGDE42\n:dd.\nThe user's guide for TSSO 4.2.\n:dt.UG43IMPT\n:dd.\nA pre-formatted copy of the :hp3.TSSO User's Guide:ehp3.\nfor version 4.3 for dumping to an impact printer.\n:dt.UG43RAW\n:dd.\nThe raw source for\nthe :hp3.TSSO User's Guide:ehp3. for version 4.3, complete with SCRIPT control\nwords.\n:dt.UG43TERM\n:dd.\nA pre-formatted copy of the :hp3.TSSO User's Guide:ehp3.\nfor version 4.3 for browsing at the terminal.\n:dt.VALLOC\n:dd.\nCommand for displaying MVS allocation information.\n:dt.VOLSER\n:dd.\nCommand for displaying MVS UCB information.\n:edl.\n:h1.Sample AOF Table\nThis is the sample AOF table distributed with TSSO in member AOFIVP of the\nTSSO.VERS43.ASM data set.\n.sp 2\n.bf figfont\n.fo off\n***********************************************************************\n* THIS IS A SAMPLE AUTOMATED OPERATIONS FACILITY TABLE. IT IS USED AS *\n* PART OF THE TSSO INSTALLATION VERIFICATION PROCEDURE. IT CONSISTS   *\n* OF A SUBSET OF ALL POSSIBLE ENTRIES IN A TSSO/AOF TABLE.            *\n*                                                                     *\n* THIS AOF TABLE CAN BE USED IN CONJUNCTION WITH THE AOF/IVP,         *\n* DISTRIBUTED WITH TSSO.                                              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nAOFIVP   TABSTART ID=IVPTABLE\n***********************************************************************\n* FIRST, A COUPLE OF REPLIES TO STANDARD ANNOYING MVS   MESSAGES.     *\n***********************************************************************\n*\n***********************************************************************\n* REPLY '' TO VTAM INITIALIZATION MESSAGE\n***********************************************************************\nVTAMUP   TABENTRY MSG=IST051A,ACTION=REPLY,TEXT=' '\n*\n***********************************************************************\n* REPLY 'SIC' TO TCAS TERMINATION MESSAGE\n***********************************************************************\nREPSIC   TABENTRY MSG=IKT010D,ACTION=REPLY,TEXT='SIC'\n*\n***********************************************************************\n* REPLY 'U' TO TCAS TERMINATION MESSAGE\n* AND ECHO THE REPLY OUT TO THE MVS CONSOLE. ALSO, ENSURE THAT WE ONLY\n* MAKE THE REPLY ONE TIME THROUGH THE MATCHLIM FACILITY.\n***********************************************************************\n*\nTCASDOWN TABENTRY MSG=IKT012D,ACTION=REPLY,TEXT='U',ECHO=YES,          X\n               MATCHLIM=1\n***********************************************************************\n* REPLY 'POST' TO IMS BRINGUP ON UCB MESSAGE\n***********************************************************************\n*\nIMSPOST  TABENTRY MSG=IEC804A,ACTION=REPLY,TEXT='POST'\n*\n***********************************************************************\n* THE NEXT ENTRY POINTS OUT THE HILIGHTING FEATURE. IEE704I IS THE    *\n* MESSAGE ID FOR   REPLY XX IS NOT OUTSTANDING.                       *\n***********************************************************************\nRPLYWRNG TABENTRY MSG=IEE704I,ACTION=HILIGHT\n*\n.pa\n***********************************************************************\n* THE NEXT ENTRY DEMONSTRATES A POSSIBLE USE FOR THE OSCMD FEATURE.   *\n* IEE043I IS THE MESSAGE YOU GET WHEN A SYSTEM LOG DATASET IS QUEUE   *\n* TO A GIVEN OUTPUT CLASS. THE #LOGWTRR4 PROGRAM (OR CLIST) CAN BE    *\n* USED TO PROCESS THE LOG DATASET. THE XWTR PROC    CAN ALSO BE USED. *\n* YOU CAN CAUSE THIS TO OCCUR BY ISSUING THE \"W Z\" COMMAND.           *\n* PERFORM THIS ACTION AT MOST 7 TIMES, AND, EACH TIME, ECHO THE       *\n* GENERATED COMMAND OUT TO THE MVS CONSOLE.\n***********************************************************************\nLOGWTR   TABENTRY MSG=IEE043I,ACTION=OSCMD,MATCHLIM=7,ECHO=YES,        X\n               TEXT='#LOGWTRR4'\n*\n***********************************************************************\n* WHEN THE LOGWTR PROGRAM TERMINATES, MESSAGE IEF176I IS ISSUED,      *\n* INDICATING THE LOGWTR IS LOOKING FOR WORK. HAVE TSSO PURGE IT OUT.  *\n* NOTE HOW IT USES THE DDD FROM THE MESSAGE TO FIGURE OUT WHAT TO     *\n* PURGE. NOTE THAT THIS WILL WORK FOR ANY EXTERNAL WRITER.            *\n* THIS IS AN EXAMPLE OF \"WORD\" FORMATTING IN THE TEXT= PARM.          *\n* NOTE THAT THE COMMAND GENERATED IS ECHOED TO THE MVS CONSOLE\n***********************************************************************\nPURGEWTR TABENTRY MSG=IEF176I,ACTION=OSCMD,ECHO=YES,                   X\n               TEXT='P \\W    03\\'\n*\n***********************************************************************\n* THE NEXT EXAMPLE SHOWS POSITIONAL FORMATTING IN THE COMMAND TEXT.   *\n* THE $HASP104 MESSAGE IS ISSUED WHENEVER A //*MESSAGE CARD IS        *\n* ENCOUNTERED IN THE JOB STREAM. THE #RECMSG CLIST MEARLY RECORDS IN  *\n* A DATASET (USING CLIST OPENFILE/PUTFILE/CLOSFILE TECHNIQUES) THE    *\n* TEXT OF THE MESSAGE.                                                *\n***********************************************************************\nRECMSG   TABENTRY MSG=$HASP104,ACTION=OSCMD,                           X\n               TEXT='#RECMSG JOB(''\\P001,72\\'')'\n*\n***********************************************************************\n* ANOTHER EXAMPLE OF THE USE OF THE HILIGHTING FEATURE. HILIGHT THE   *\n* MESSAGE INDICATING THAT VTAM IS UP.                                 *\n***********************************************************************\n         TABENTRY MSG=IST020I,ACTION=HILIGHT\n*\n***********************************************************************\n* IN ADDITION TO  HILIGHTING THE VTAM INITIALIZATION MESSAGE, ISSUE   *\n* THE #VTAMR4 CLIST. THIS CLIST IS A OPERATOR CLIST THAT ISSUES       *\n* MVS START COMMANDS FOR VTAM DEPENDANT PROGRAM PRODUCT, LIKE NCCF    *\n* AND TSO.                                                            *\n*                                                                     *\n***********************************************************************\nSTRTVTAM TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT='#VTAMR4'\n*\n***********************************************************************\n* DSI802A IS THE NCCF MESSAGE SAYING THAT YOU CAN ISSUE A VALID NCCF  *\n* OPERATOR COMMAND. YOU DO NOT NEED TO KNOW THE MESSAGE NUMBER FOR    *\n* THIS COMMAND, BECAUSE YOU CAN REPLY TO IT USING THE REPLY COMMAND   *\n* SO WE LOWLIGHT THE MESSAGE, AND ALLOW IT TO ROLL OFF THE SCREEN.    *\n* THIS IS AN EXMAPLE OF THE LOWLIGHTING FEATURE.\n***********************************************************************\n         TABENTRY MSG=DSI802A,ACTION=LOWLIGHT\n*\n***********************************************************************\n* THIS IS AN EXAMPLE OF A SUPPRESS CONDITION. $HASP309 IS A MESSAGE   *\n* THAT JES2 ISSUES EVERY TIME AN INITIATOR GOES INACTIVE. THIS MESSAGE*\n* IS NOW SUPPRESSED.                                                  *\n***********************************************************************\n         TABENTRY MSG=$HASP309,ACTION=SUPPRESS\n.pa\n***********************************************************************\n* WE WILL NOW DISPLAY SOME OF THE POWER OF THE TEST CONDITIONS. THE   *\n* FOLLOWING DEMONSTRATIONS ALL TRAP THE $HASP395 JOB ENDED MESSAGE,   *\n* HOWEVER, THE ACTION= PARAMETER IS EXECUTED ONLY IF ALL CONDITIONS   *\n* FOR THE TESTS ARE MET. FOR EXAMPLE, OUR FIRST CASE WILL ONLY        *\n* HILIGHT THE MESSAGE IF THE JOB THAT HAS ENDED IS NAMED \"PAYROLL\".   *\n* THIS TEST CASE SPECIFIES THAT (1) WORDS ARE BEING TESTED, (2), THAT\n* IT IS THE SECONDWORD WE ARE INTERESTED IN, (3), WE ARE INTERESTED IN\n* THE FIRST SEVEN CHARACTERS OF THAT WORD, (4), WE WISH TO MATCH THE\n* STRING 'PAYROLL', AND      (5), WE WILL USE FOUR BLANKS AS THE\n* SEPARATOR CHARACTORS WHEN DEFINING A WORD.\n* NOTE THAT THE DOUBLE PARENTHESIS ARE REQUIRED.\n***********************************************************************\n         TABENTRY  MSG=$HASP395,ACTION=HILIGHT,                        X\n               TEST=((W,2,7,'PAYROLL','    '))\n*\n***********************************************************************\n* THE NEXT ENTRY IS AN EXAMPLE OF A TEST CONDITION BASED ON SUBSTRING,*\n* OR COLUMNS. THE MESSAGE WILL THE JES2 $HAS648 MESSAGE, WHICH IS     *\n* THE RESPONSE TO A $DU,STA. THIS ENTRY WILL SUPPRESS ALL LINES FROM  *\n* THE JES2 RESPONSE THAT ARE SNA LINES (COLS 20 THROUGH 22 = 'SNA'    *\n*                                                                     *\n***********************************************************************\n         TABENTRY  MSG=$HASP628,ACTION=SUPPRESS,                       X\n               TEST=((S,20,3,'SNA'))\n*\n***********************************************************************\n* THE NEXT ENTRY IS AN EXAMPLE OF A LOGICAL AND CONDITION BETWEEN TEST*\n* CASES. BOTH CRITERIA MUST BE SATISIFED FOR THE TESTS TO PASS.       *\n* THE TEST CASE WILL AN MVS/JES2 JOB AWAITING EXECUTION IN A CERTAIN  *\n* JOB CLASS. THIS ENTRY WILL TAKE A $DN COMMAND, AND ISSUE AN OSCMD   *\n* TO RAISE THE PRIORITY OF JOBS AWAITING EXECUTION IN CLASS 9 TO \"15\" *\n* (YES, I REALIZE THIS DOESNT MAKE MUCH SENSE, BUT ITS GOOD FOR DEMO  *\n* PURPOSES).\n* NOTE THAT THE THIRD WORD IS CHECKED FOR \"AWAITING\" AND THE FOURTH   *\n* WORD IS CHECK FOR EXECUTION, AND THE FIFTH WORD IS THE JOB CLASS.   *\n* ALSO NOTE HOW THE SECOND WORD OF THE MESSAGE (THE JOB NAME) IS USED *\n* IN FORMING THE TEXT= OPERAND. OSCMDT WILL BE USED SO THE COMMAND    *\n* DOESNT ACTUALLY GET ISSUED.\n* NOTE ALSO THAT YOU DONT NEED TO SPECIFY FOUR BLANKS- ONE IS         *\n* SUFFICIENT WHEN GENERATING TEST CASES.\n***********************************************************************\n         TABENTRY MSG=$HASP608,ACTION=OSCMDT,                          X\n               TEXT='$T''\\W    02\\'',P=15',                            X\n               TEST=((W,3,8,'AWAITING','  '),(W,4,9,'EXECUTION','    ')X\n               ,(W,5,1,'9',' '))\n*\n***********************************************************************\n* THE NEXT CASE IS A GENERIC MESSAGE. THIS MESSAGE IS MATCHED BY      *\n* EVERY SINGLE WTO OR WTOR THAT COME ACROSS, EXCEPT IT MUST STILL     *\n* PASS THE TEST CONDITIONS. THIS EXAMPLE I WILL GIVE HILIGHTS ALL JES *\n* MESSAGES CONCERNING JOB ENDOFDAY.THESE MESSAGES ALL START WITH      *\n* $HASP (WORD 1) AND CONTAIN THE JOBNAME IN WORD 2.                   *\n*                                                                     *\n***********************************************************************\n         TABENTRY MSG=*,ACTION=HILIGHT,                                X\n               TEST=((W,1,5,'$HASP',' '),(W,2,8,'ENDOFDAY',' '))\n*\n.pa\n***********************************************************************\n* THE NEXT CASE IS AN EXAMPLE OF THE ACTION=POST FACILITY OF THE TSSO *\n* AOF TABLES. THE BELOW MESSAGE CAN BE USED TO POST A CLIST WAITING   *\n* FOR A GIVEN CTC TO BE VARIED OFFLINE.                               *\n*                                                                     *\n***********************************************************************\nCTCOFF   TABENTRY MSG=IEF281I,ACTION=POST\n*\n*\n***********************************************************************\n* THE NEXT CASE IS AN EXAMPLE OF THE ACTION=POST FACILITY OF THE TSSO *\n* AOF TABLES. THE BELOW MESSAGE CAN BE USED TO POST A CLIST WAITING   *\n* FOR A SPECIFIC CTC TO BE VARIED OFFLINE.                            *\n*                                                                     *\n***********************************************************************\nCTC980OF TABENTRY MSG=IEF281I,ACTION=POST,TEST=((W,2,3,'980',' '))\n*\n***********************************************************************\n* THIS TABEND MACRO DEFINES THE END OF THE AUTOMATED OPERATIONS       *\n* FACILITY TABLE.                                                     *\n*                                                                     *\n* DO NOT LEAVE THE TABEND MACRO OUT OF THIS ASSEMBLY.                 *\n*                                                                     *\n***********************************************************************\n         TABEND\n.pf\n.fo on\n:h1.TSSO/AOF Text Processing Algorithm\nThis section describes the algorithm used in forming the MVS operator\ncommands issued as a result of processing the ACTION=OSCMD directive under\nthe TSSO Automated Operations Facility.\n:h2.Definition of Terms\n.in 5\n:dl tsize=13 termhi=0.\n:dt.\naction-text\n:dd.\nis the parameter specified in the TEXT operand\nof the TABENTRY macro.\n:dt.\nWTOTEXT\n:dd.\nis the text of the console message that\nwas matched by the MSG parameter. Therefore, the first 8 bytes of WTOTEXT\nmust have matched an entry in the AOF table, as specified by\nthe MSG parameter.\n:dt.\ncmd-buffer\n:dd.\nis the buffer that will be passed to\nMVS to be executed as an operator command.\n:edl.\n.in 0\n:h2.Algorithm\n:ol.\n:li.\nExamine the MATCHLIM value for an entry.\nIf MATCHLIM=999999, then ignore.\nIf MATCHLIM=0, then do not process the entry;\notherwise, decrement MATCHLIM by 1.\n:li.\nCopy characters from :hp1.action-text:ehp1. to :hp1.cmd-buffer:ehp1. until\nno more characters are found, or a \"\\\" is located. The \"\\\" is\na significance indicator that indicates to AOF that\ncharacters or words from\nWTOTEXT\nare to be copied.\nWhen a significance indicator is detected, go to step 2. When no\nmore characters remain in :hp1.action-text:ehp1., pass the command to\nMVS for processing and terminate.\n:li.\nThe character after the significance indicator determines the\ntype of formatting to be performed. Two characters are permissible. The \"S\"\ndirective indicates substring formatting and the \"W\" directive\nindicates word formatting. If the character is a \"S\", go to step 3;\nif the character is a \"W\", go to step 4.\n:li.\nTo use substring formatting,\nthe syntax, including the leading \"\\S\" must be\n:xmp.\n\\S:hp1.nnn,yy:ehp1.\\\n:exmp.\nwhere :hp1.nnn:ehp1. are numeric characters that specify\nthe starting position in WTOTEXT, and the :hp1.yy:ehp1. indicates the number of\ncharacters starting from position :hp1.nnn:ehp1.\nto copy into the command buffer.\nThus,\nit is possible to include\nall or part of WTOTEXT in the operator command\nto be issued.  For example, if\n:xmp.\n\\S032,08\\\n:exmp.\nwas coded, then character positions 32-39 of WTOTEXT would be copied\nto :hp1.cmd-buffer:ehp1.. The syntax for the substring parameter is very rigid.\nLeading zeroes must be specified, and the final \"\\\" must be present.\nProcessing continues at step 1 with the character following the final \"\\\"\n:li.\nA word\nis defined as a string of characters separated by separator characters. The\nmaximum size of a word is 16 bytes. To use the word formatting option, code\n:xmp.\n\\W:hp1.abcdnn:ehp1.\\\n:exmp.\nwhere :hp1.a, b, c:ehp1. and :hp1.d:ehp1. specify separator\ncharacters to be used in the definition of a word, and :hp1.nn:ehp1.\nis a numeric\nvalue indicating which word to use. The selected word is then copied\nto :hp1.cmd-buffer:ehp1..  For example, if\n:xmp.\n\\W=,   03\\\n:exmp.\nwere coded, it would be interpreted as\nword formatting with the next four\ncharacters  \"=\", \",\", \" \", and \" \"\nused as word separator characters.\nIn this example, the third word is copied from WTOTEXT\ninto :hp1.cmd-buffer:ehp1.. The Syntax of the \"W\" directive if\nvery strict. If you do not need four separator characters, you must code\nblanks (as in the example). The numeric specification must have\ntwo digits (including a leading zero if required)\nand the terminating \"\\\" is required. Processing\ncontinues at step 1, with the character following the last \"\\\".\nNote that a word is at most, 16 characters in length, and is copied\nto :hp1.cmd-buffer:ehp1. without leading or trailing blanks.\n:eol.\n:p.\nNote that the formatting options are available only if ACTION=OSCMD\nor ACTION=OSCMDT is specified.\n:h1 id=deck.TSSO Sample Parameter Deck\nThe parameter deck shown below is in\nfile SAMPPARM in the TSSO.VERS43.ASM data set.\n.sp 2\n.bf figfont\n.fo off\n***********************************************************************\n* THIS IS A TYPICAL TSSO PARAMETER DECK FOR A TYPICAL SYSTEM. THE     *\n* DOCUMENTATION IS   IN \"TSSO SYSTEM PROGRAMMERS GUIDE- RELEASE 4.3   *\n* THESE VALUES SHOULD WORK AS DEFAULTS.                               *\n* NOTE THAT THE ONLY NEW PARAMETER IN TSSO 4.3 IS THE NUMCONS PARM.   *\n***********************************************************************\nNONSWAP=Y\n************************************************************\n* TSSO WILL BE RUNNING NON-SWAPABBLE                       *\n************************************************************\n*\nTABLE=AOFIVP\n************************************************************\n* THE TABLE NAME FOR TSSO AOF WILL BE AOFIVP               *\n************************************************************\n*\nRACFID=TSSO\n************************************************************\n* TSSO WILL ASSUME A RACF USERID OF \"TSSO\" ON STARTUP      *\n************************************************************\n*\nSRC=#\n************************************************************\n* THE COMMAND RECOGNITION CHARACTER IS A POUND SIGN ('#')  *\n************************************************************\n*\nMAXCMDS=15\n************************************************************\n* TSSO WILL HANDLE AT MOST 15 SIMULTANEOUS COMMANDS        *\n************************************************************\n*\nMAXWTO=250\n************************************************************\n* TSSO WILL ISSUE AT MOST 250 WTOS FOR ANY ONE COMMAND     *\n************************************************************\n*\n.pa\nPROMPT=NO\n************************************************************\n* DO NOT PROMPT THE MVS OPERATOR FOR ADDITIONAL TSSO       *\n* PARAMETERS                                               *\n************************************************************\n*\nSECSYS=RACF\n***********************************************************************\n* THE SECURITY SYSTEM IN USE WILL BE THE RESOURCE ACCESS CONTROL      *\n* FACILITY.                                                           *\n***********************************************************************\n*\nSECLEVEL=MINIMAL\n***********************************************************************\n* WE WILL BE USING THE \"MINIMAL\" LEVEL OF SECURITY, SO YOU CAN PHASE  *\n* IN CONSOLE SECURITY AT A LATER DATE.                                *\n***********************************************************************\n*\nSUBSYS 9 = TSSOSS09\n***********************************************************************\n* THE \"TSSOSS09\" ROUTINE, SUPPLIED WITH TSSO, WILL BE PROCESSING      *\n* THE WTO AND WTOR MESSAGES WHEN AOF IS ACTIVE. ANY OTHER SELECTION   *\n* MAY CAUSE TSSO TO FAIL.                                             *\n***********************************************************************\n*\nSUBSYS 10 = TSSOSS10\n***********************************************************************\n* THE \"TSSOSS10\" ROUTINE, SUPPLIED WITH TSSO, WILL BE PROCESSING      *\n* THE MVS AND SUBSYSTEM COMMANDS. ANY OTHER SELECTION MAY MAKE TSSO   *\n* FAIL.                                                               *\n***********************************************************************\n*\nTIMEOUT = 30\n***********************************************************************\n* IF THE SECLEVEL PARAMETER IS EVER SET TO \"MAX\", CONSOLES WILL TIME  *\n* OUT AFTER THIRTY MINUTES OF INACTIVITY...                           *\n***********************************************************************\n*\nNUMCONS = 10 DEDICATE\n***********************************************************************\n* TSSO WILL HAVE 10 SUBSYSTEM CONSOLES AT ITS DISPOSAL. ONE OF THESE  *\n* CONSOLES WILL BE DEDICATED TO THE TSSO ADDRESS SPACE.               *\n***********************************************************************\nEND\n.pf\n.fo on\n:egdoc.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UG43TERM": {"ttr": 43777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x00\\x97&\\x9f\\x01\\t)_!A\\x140\\x14\\x18\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "2009-10-22T21:41:06", "lines": 5168, "newlines": 5144, "modlines": 0, "user": "TSSO403"}, "text": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                        TIME SHARING SUBSYSTEM OPTION USER'S GUIDE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                         Release 4.3  August, 1986\n\n\n\n\n\n\n\n\n\n\n\n                                                       Marc Schare\n                                Bell Communications Research, Inc.\n                                    3 Corporate Place, Room 2C-211\n                                              Piscataway, NJ 08854\n                                          Telephone:  201-981-2796\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n TABLE OF CONTENTS\n _________________\n\n\n\n INTRODUCTION   . . . . . . . . . . . . . . . . . . . . . . . .  1\n\n CURRENT VERSION  . . . . . . . . . . . . . . . . . . . . . . .  2\n\n ABOUT THIS DOCUMENT  . . . . . . . . . . . . . . . . . . . . .  3\n\n PLANNING FOR TSSO INSTALLATION   . . . . . . . . . . . . . . .  4\n TSSO Software Prerequisites  . . . . . . . . . . . . . . . . .  4\n TSSO Subsystem Console   . . . . . . . . . . . . . . . . . . .  5\n TSSO Security Issues   . . . . . . . . . . . . . . . . . . . .  5\n Problems or Fixes  . . . . . . . . . . . . . . . . . . . . . .  6\n Conclusion   . . . . . . . . . . . . . . . . . . . . . . . . .  6\n\n INSTALLATION   . . . . . . . . . . . . . . . . . . . . . . . .  8\n\n TSSO PARAMETERS  . . . . . . . . . . . . . . . . . . . . . . . 11\n MAXCMDS Parameter  . . . . . . . . . . . . . . . . . . . . . . 11\n MAXWTO Parameter   . . . . . . . . . . . . . . . . . . . . . . 11\n NONSWAP Parameter  . . . . . . . . . . . . . . . . . . . . . . 12\n NUMCONS Parameter  . . . . . . . . . . . . . . . . . . . . . . 12\n PROMPT Parameter   . . . . . . . . . . . . . . . . . . . . . . 12\n RACFID Parameter   . . . . . . . . . . . . . . . . . . . . . . 13\n SECLEVEL Parameter   . . . . . . . . . . . . . . . . . . . . . 14\n SECSYS Parameter   . . . . . . . . . . . . . . . . . . . . . . 14\n SUBSYS Parameter   . . . . . . . . . . . . . . . . . . . . . . 15\n System Recognition Character (SRC) Parameter   . . . . . . . . 15\n TABLE Parameter  . . . . . . . . . . . . . . . . . . . . . . . 15\n TIMEOUT Parameter  . . . . . . . . . . . . . . . . . . . . . . 16\n * (Comments) Parameter   . . . . . . . . . . . . . . . . . . . 16\n END Parameter  . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n TSSO START COMMAND OPTIONS   . . . . . . . . . . . . . . . . . 17\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY  . . . . . . . . . . . 19\n Overview   . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n TSO Commands Under TSSO  . . . . . . . . . . . . . . . . . . . 19\n TSSO Control Commands  . . . . . . . . . . . . . . . . . . . . 20\n TSO Commands Distributed with TSSO   . . . . . . . . . . . . . 20\n   The OSCMD Command  . . . . . . . . . . . . . . . . . . . . . 20\n     Authority Checking with OSCMD  . . . . . . . . . . . . . . 22\n   The OSWTO and OSWTOH Commands  . . . . . . . . . . . . . . . 23\n   The OSASK Command  . . . . . . . . . . . . . . . . . . . . . 23\n   The OSPAUSE Command  . . . . . . . . . . . . . . . . . . . . 23\n   The OSWAIT Command   . . . . . . . . . . . . . . . . . . . . 24\n\n\n Table of Contents                                              ii\n\n\n\n\n\n\n\n\n\n Using the WRITE Statement in TSSO CLISTs   . . . . . . . . . . 24\n   *COM Keyword   . . . . . . . . . . . . . . . . . . . . . . . 25\n   *HI Keyword  . . . . . . . . . . . . . . . . . . . . . . . . 26\n Guidelines and Suggestions for Writing CLISTs  . . . . . . . . 27\n\n TSSO AUTOMATED OPERATIONS FACILITY   . . . . . . . . . . . . . 30\n Introduction   . . . . . . . . . . . . . . . . . . . . . . . . 30\n Creating the AOF Table   . . . . . . . . . . . . . . . . . . . 31\n TABENTRY Operands  . . . . . . . . . . . . . . . . . . . . . . 31\n   The Entry-id Operand   . . . . . . . . . . . . . . . . . . . 31\n   The MSG Operand  . . . . . . . . . . . . . . . . . . . . . . 32\n   The ACTION Operand   . . . . . . . . . . . . . . . . . . . . 32\n   The TEXT Operand   . . . . . . . . . . . . . . . . . . . . . 34\n   The TEST Operand   . . . . . . . . . . . . . . . . . . . . . 35\n     Notes on the TEST Operand  . . . . . . . . . . . . . . . . 36\n   The MATCHLIM Operand   . . . . . . . . . . . . . . . . . . . 37\n   The ECHO Operand   . . . . . . . . . . . . . . . . . . . . . 38\n Assembling and Link-Editing the Table  . . . . . . . . . . . . 38\n Storing the Module   . . . . . . . . . . . . . . . . . . . . . 39\n\n TSSO NETWORK COMMUNICATION CONTROL FACILITY INTERFACE  . . . . 40\n Notes on the NCCF Interface  . . . . . . . . . . . . . . . . . 40\n\n RECOVERY PROCEDURES  . . . . . . . . . . . . . . . . . . . . . 41\n\n APPENDIX A. TSSO COMMAND REFERENCE   . . . . . . . . . . . . . 42\n\n APPENDIX B. TSSO CONTROL COMMANDS  . . . . . . . . . . . . . . 67\n General Commands   . . . . . . . . . . . . . . . . . . . . . . 67\n Restricted Commands  . . . . . . . . . . . . . . . . . . . . . 69\n\n APPENDIX C. TSSO PROCESSING MODULES  . . . . . . . . . . . . . 70\n\n APPENDIX D. TSSO/AOF TEXT PROCESSING ALGORITHM   . . . . . . . 75\n Definition of Terms  . . . . . . . . . . . . . . . . . . . . . 75\n Algorithm  . . . . . . . . . . . . . . . . . . . . . . . . . . 75\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Table of Contents                                             iii\n\n\n\n\n\n\n\n\n\n LIST OF ILLUSTRATIONS\n _____________________\n\n\n\n Figure  1. Behavior of CMDRESP in Various Environments   . . . 21\n Figure  2. Sample CLIST for OSWAIT.  . . . . . . . . . . . . . 25\n Figure  3. CLIST with an Operator Help Procedure Using WRITE   28\n Figure  4. CLIST Using Symbolic Substitution   . . . . . . . . 29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n List of Illustrations                                          iv\n\n\n\n\n\n\n\n\n\n INTRODUCTION\n ____________\n\n\n\n The Time Sharing Subsystem Option (TSSO) is a package designed to\n increase operator productivity by automating tasks which need not\n be performed manually. TSSO performs its function  through  three\n integrated  components.  The Operator Productivity Facility (OPF)\n extends the power of TSO to the MVS operator's console.  The  Au-\n tomated  Operations  Facility  (AOF)  enhances  an installation's\n ability to control system events based on console  message  traf-\n fic.   An interface to the Network Communication Control Facility\n (NCCF) allows the network operator  to  use  TSSO  as  a  command\n processor, issuing and receiving operating system commands at the\n NCCF  terminal.   TSSO also enhances end-user productivity by al-\n lowing end-user access to the MVS command subsystem.  This  docu-\n ment describes the installation of TSSO, TSSO parameters, and the\n use of the three components.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n INTRODUCTION                                                    1\n\n\n\n\n\n\n\n\n\n CURRENT VERSION\n _______________\n\n\n\n This document describes the function of TSSO Version 4, Release 3\n (TSSO 4.3).  All features described here will continue to work on\n subsequent  versions  of the Time Sharing Subsystem Option unless\n specified in a future version of this document.  A description of\n the new features of TSSO Version  4.3  can  be  found  in  member\n RELGUIDE in the TSSO.VERS43.ASM data set.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n CURRENT VERSION                                                 2\n\n\n\n\n\n\n\n\n\n ABOUT THIS DOCUMENT\n ___________________\n\n\n\n The  TSSO User's Guide was created using the Document Composition\n      _________________\n Facility, Release 3.  The TSSO.VERS43.ASM data set  contains  two\n members with different versions of this document.\n\n Member UG43RAW is the raw SCRIPT source, which is best suited for\n running  on  a 3800 or 3820 page printer.  Use the following com-\n mand to generate copies:\n\n   SCRIPT 'TSSO.VERS43.ASM(UG43RAW)' PROFILE(DSMPROF3) TWOPASS\n           DEVICE(device-type) PRINT\n                  ___________\n\n where device-type is the logical device type at your location.\n       ___________\n\n Member UG43TERM is a pre-formatted copy suitable for browsing  at\n your terminal.\n\n Member  UG43IMPT  is a pre-formatted copy suitable for dumping to\n an impact printer.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ABOUT THIS DOCUMENT                                             3\n\n\n\n\n\n\n\n\n\n PLANNING FOR TSSO INSTALLATION\n ______________________________\n\n\n\n Because TSSO has grown in function  and  complexity,  a  planning\n section  is  now necessary to describe pre-requisite program pro-\n ducts, MVS I/O generation requirements, and security system  con-\n ditioning.    This  section  should  be  reviewed  PRIOR  to  the\n installation of TSSO.\n\n TSSO 4.3 was developed for Bellcore internal use  as  part  of  a\n study  on automating the operation of an MVS computer center. Be-\n cause the kernal of TSSO was  originally  developed  external  to\n Bellcore, permission was granted to make this new version of TSSO\n available as public domain, unsupported software. As a public do-\n main  software  package,  TSSO  receives  no  formal support from\n Bellcore or anyone else.  Therefore, installations that  want  to\n use  TSSO  must be prepared to support it locally as a worst case\n possibility. Questions, comments or enhancement requests are  al-\n ways welcome on an informal, non-committal basis.\n\n\n\n TSSO SOFTWARE PREREQUISITES\n ___________________________\n\n\n The  software  listed below is the minimum version of the program\n product required to run TSSO. In  general,  that  version,  or  a\n later  release,  is sufficient. Also listed is the version of the\n product run at Bell Communications Research (i.e.,  the  environ-\n ment on which TSSO 4.3 was developed).\n\n 1.  MVS/SP  1.3.3  OR  MVS/XA  2.1.1 is required for the OCCF en-\n     ________________________________\n     hancements to the subsystem interface that allow TSSO/AOF and\n     the OS family of commands to function.  TSSO  4.3  has  never\n     been  run  on  earlier  MVS  releases.   Bellcore runs MVS/XA\n     2.1.3, and TSSO has also been tested on MVS/SP 1.3.4.\n\n 2.  TSO/E RELEASE 2 is required by the  OS  family  of  commands.\n     _______________\n     These  commands use CLIST variables for input and output, and\n     require the CLIST enhancements of TSO/E Release 2  to  accom-\n     plish  this. TSO/E is not required if these commands will not\n     be used.  Bellcore runs TSO/E Release 2.1, and TSSO has  also\n     been tested with TSO/E Release 2.\n\n 3.  RACF  1.6  is  required for the TSSO/RACF security interface.\n     _________\n     TSSO has  never  been  run  on  previous  releases  of  RACF.\n\n\n\n PLANNING FOR TSSO INSTALLATION                                  4\n\n\n\n\n\n\n\n\n\n     Bellcore  runs RACF 1.7, and TSSO 4.3 has been tested only in\n     that environment.\n\n 4.  ACF2 4.1 is the release on which TSSO/ACF2 interface is being\n     ________\n     developed.\n\n\n\n TSSO SUBSYSTEM CONSOLE\n ______________________\n\n\n The OSCMD facility allows a TSO CLIST to issue an operating  sys-\n tem  command  and retrieve the response. This facility requires a\n subsystem console for every simultaneous caller of OSCMD.  In ad-\n dition, an installation may want to dedicate one  subsystem  con-\n sole for  the  TSSO  address  space.(1)  To  create  a  subsystem\n console, include the following card after the \"CONSOLE\" macros in\n the MVS STAGE1 generation deck.\n\n   CONSOLE    TYPE=JES\n\n Because TSSO 4.3 can use as many subsystem consoles as are genned\n in,  it  is  a  good idea to include many (10-20) of these cards.\n (Bellcore has 10 subsystem  consoles  genned  in.)    JES3  shops\n should  note  that JES3 and TSSO both require subsystem consoles,\n and you specify them accordingly.  AN MVS IOGEN MUST BE PERFORMED\n TO GENERATE THE SUBSYSTEM CONSOLE.  INSTALLATIONS  FAMILIAR  WITH\n THE \"MINIGEN\" APPROACH MAY USE THIS AS AN ALTERNATIVE.\n\n\n\n TSSO SECURITY ISSUES\n ____________________\n\n\n An optional feature of TSSO 4.3 is the ability to secure your MVS\n consoles.    Console  security requires MVS operators to identify\n themselves before issuing commands; thus, MVS  installations  al-\n ways  know  which  operators  issue which commands. The following\n steps should be taken prior to initializing TSSO with a  security\n level other than \"minimal\".\n\n\n\n\n ----------------\n\n 1   For  more information on this option, see \"NUMCONS Parameter\"\n     on page 12.\n\n\n PLANNING FOR TSSO INSTALLATION                                  5\n\n\n\n\n\n\n\n\n\n 1.  Provide  a RACF user ID for each operator who will be issuing\n     MVS commands on the system. This includes the master console,\n     I/O console(s) and user consoles.\n\n 2.  Add a corresponding user ID to the User Attributes  Data  Set\n     (UADS),  and set the USERDATA bits to X'C0' for operators who\n     will be invoking the privileged TSSO commands  (e.g.,  REPLY,\n     OSCMD  etc.).    Note that the USERDATA bits also control au-\n     thority for regular TSO users, and, if  the  Program  Control\n     Facility  (PCF)  is  installed,  the OSCMD and REPLY commands\n     must be modified so that PCF and TSSO don't  conflict.    See\n     \"Authority Checking with OSCMD\" on page 22 for information on\n     the OSCMDATH user exit.\n\n 3.  Pick  a security level. SECLEVEL=MEDIAL is a good initial se-\n     lection, as operators can get used to the concept of  logging\n     on  and logging off of an MVS console. Later, security can be\n     strengthened with SECLEVEL=MAXIMAL.\n\n 4.  Select a TIMEOUT parameter. This parameter is the  number  of\n     minutes  before  which  an MVS console will \"timeout\" and re-\n     quire a new LOGON command.\n\n 5.  As with the rest of TSSO, operator training is CRUCIAL for  a\n                                                    _______\n     successful  implementation.  Operators  must  become familiar\n     with the concepts of security.\n\n 6.  ACF2 will eventually be supported under TSSO.   For the  cur-\n     rent status of this effort, call Jim Lane, 416-926-3076.\n\n\n\n PROBLEMS OR FIXES\n _________________\n\n\n For the current bucket, call Marc Schare at 201-981-2796.\n\n\n\n CONCLUSION\n __________\n\n\n The remainder of this guide should be read IN ITS ENTIRETY before\n installing  TSSO.   Many of the phone calls I've received on TSSO\n were answered in the TSSO USER'S GUIDE.  Good luck in  your  TSSO\n                      _________________\n installation !\n\n\n\n\n PLANNING FOR TSSO INSTALLATION                                  6\n\n\n\n\n\n\n\n\n\n Marc Schare\n Bell Communication Research, Inc.\n 6 Corporate Place, Room 2C-211\n Piscataway, NJ 08854\n 201-981-2796\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n PLANNING FOR TSSO INSTALLATION                                  7\n\n\n\n\n\n\n\n\n\n INSTALLATION\n ____________\n\n\n\n TSSO  is distributed in a single partitioned data set, which con-\n tains all source modules, procedures and documentation.  Although\n the data set may be called by any name, this document  assumes  a\n name of TSSO.VERS43.ASM.\n\n 1.  Download  the TSSO.VERS43.ASM data set to DASD.  About 5 cyl-\n     inders of 3380 space is required.  If you received your  copy\n     of  the TSSO subsystem from the CBT tape, simply copy it to a\n     data set with this name.  If you received a  tape,  then  the\n     TSSO  subsystem  is in IEBCOPY format on the first file.  The\n     tape will be non-labeled, so use the  LABEL=(1,NL)  parameter\n     when downloading TSSO.\n\n 2.  Create two data sets for the TSSO modules with the character-\n     istics RECFM=U, LRECL=0, BLKSIZE=13030, DSORG=PO.\n\n     a.  TSSO.VERS43.LOAD will be an intermediate data set for as-\n         sembling TSSO modules.\n\n     b.  SYS1.TSSOLOAD will contain the TSSO production modules.\n\n     One  cylinder  of  3380  DASD  space should be sufficient for\n     these data sets.\n\n     Many users have found it useful to allocate a third data set:\n\n     c.  SYS1.TSSOPROC will contain TSSO CLISTs.  Allocate it with\n         characteristics   LRECL=255,   BLKSIZE=3140,    RECFM=VB,\n         DSORG=PO.    Space  requirements  depend on the number of\n         CLISTs you anticipate creating.\n\n 3.  Assemble the TSSO source modules using the  procedure  ASMALL\n     in  TSSO.VERS43.ASM.  You will need to EDIT the procedure and\n     add the appropriate installation job cards and local account-\n     ing information.\n\n     If you will be running the TSSO subsystem on MVS/370, or both\n     MVS/370 and MVS/XA, the SYSLIB DD statement must be  pointing\n     to the SYS1.MACLIB and SYS1.AMODGEN data sets for MVS/370. If\n     you  will be running the subsystem exclusively on MVS/XA, the\n     SYSLIB  DD  statement  may  point  to  the  XA  versions   of\n     SYS1.MACLIB and SYS1.AMODGEN.\n\n\n\n\n INSTALLATION                                                    8\n\n\n\n\n\n\n\n\n\n     NOTE: If  you  do not have TSO/E Release 2 installed, the as-\n     semblies for OSCMD, OSWAIT, and OSASK will fail.\n\n 4.  Copy the load modules from  TSSO.VERS43.LOAD  into  the  pro-\n     duction  library SYS1.TSSOLOAD.  The library TSSO.VERS43.LOAD\n     should remain on the system as  an  intermediate  library  to\n     contain  assembled  TSSO load modules and assembled Automated\n     Operations Facility tables.\n\n 5.  If OSCMD, OSWAIT, OSPAUSE, OSWTO, and OSWTOH will be accessed\n     by TSO users,  copy  the  modules  from  SYS1.TSSOLOAD  to  a\n     publicly-accessible TSO command library (e;g;, SYS1,CMDLIB).\n\n 6.  Update the SYS1.PARMLIB data set with one or more TSSO param-\n     eter  decks.  The default member is TSSOPARM; however, alter-\n     nate members may be selected when TSSO is started.  Note that\n     the TSSO parameter decks MUST be located in SYS1.PARMLIB,  as\n                              ____\n     TSSO  will  dynamically  allocate this data set.   Review the\n     section \"TSSO PARAMETERS\" on page 11 for further information.\n     A sample TSSO parameter deck may be found in member  SAMPPARM\n     in TSSO.VERS43.ASM data set.\n\n 7.  Identify TSSO to MVS as a subsystem.  Make one of the follow-\n     ing two entries in the subsystem names table, member IEFSSNxx\n                                                                __\n     in SYS1.PARMLIB:\n\n     +-------------------+----------------------+----------------+\n     |  If you want:     |  then make the entry:|  and:          |\n     +-------------------+----------------------+----------------+\n     |  NO JES support   |  TSSO                |  go to Step 9. |\n     |                   |                      |                |\n     |  JES support      |  TSSO,TSSOINIT       |  go to Step 8. |\n     +-------------------+----------------------+----------------+\n\n 8.  Copy TSSOINIT from SYS1.TSSOLOAD to SYS1.LINKLIB.\n\n 9.  Include SYS1.TSSOLOAD in the IEAAPFxx member of SYS1.PARMLIB.\n                                        __\n     This allows the TSSO subsystem to run APF authorized.\n\n 10. Include  a  TSSO  start-up procedure in the SYS1.PROCLIB data\n     set.  Note that, because TSSO may be started  by  the  master\n     scheduler,  this  procedure must be in SYS1.PROCLIB, not in a\n     PROCLIB defined to JES2.   A sample  procedure  for  starting\n     TSSO is in member TSSOPROC in the TSSO.VERS43.ASM data set.\n\n 11. Give  the  TSO commands supplied with TSSO APF authorization.\n     Update  the  installation  CSECT  IKJEFTE2  in  load   module\n     IKJEFT02  to  include the following commands:  ALTAOF, CACHE,\n\n\n INSTALLATION                                                    9\n\n\n\n\n\n\n\n\n\n     CPCMD, REPLY, OSCMD, OSWTO, OSWTOH, OSWAIT, and OSASK.  Under\n     TSO/E Release 2.1, this CSECT is in the load module IKJTABLS.\n     If this release of TSO/E is installed,  a  separate  copy  of\n     IKJTABLS may be used by TSSO if included in the SYS1.TSSOLOAD\n     data set.\n\n 12. Create  the TSSO Automated Operations Facility table(s).  In-\n     structions for preparing the table are found  later  in  this\n     document.\n\n 13. Copy  the  ASMTAB  CLIST from the TSSO.VERS43.ASM data set to\n     SYS1.TSSOPROC.\n\n 14. If you will be running TSSO with RACF support and MINIMAL se-\n     curity, add a RACF ID for TSSO.  Also add a RACF ID for  TSSO\n     to  SYS1.UADS.  This will allow TSSO to assume the TSO attri-\n     butes (e.g. ACCOUNT, SUBMIT or MOUNT) that  the  installation\n     desires.  If you will be running with MEDIAL or MAXIMAL secu-\n     rity,  you  may  wish  to add additional RACF or ACF2 and TSO\n     user IDs for each operator who will be logging on.\n\n 15. IPL MVS to refresh the subsystem name table.\n\n 16. If the OSCMD facility will be used, you must  have  generated\n     subsystem  consoles  as specified in \"TSSO Subsystem Console\"\n     on page 5.  TSSO will warn you if  the  number  of  subsystem\n     consoles requested is not available at start time.\n\n 17. Install  the  NCCF Interface (optional).  The following steps\n     are required:\n\n     a.  Copy the NCFOSCMD module into a library  concatenated  to\n         the  STEPLIB DD  statement in the procedure used to start\n         NCCF.\n\n     b.  Make the following entry in member DSICMD of the data set\n         defined by the DSIPARM DD statement in the procedure used\n         to start NCCF:\n\n           OSCMD CMDMDL MOD=NCFOSCMD,TYPE=R,RES=N    TSSO 4.3\n\n\n\n\n\n\n\n\n\n\n INSTALLATION                                                   10\n\n\n\n\n\n\n\n\n\n TSSO PARAMETERS\n _______________\n\n\n\n TSSO parameters provide an installation with a flexible mechanism\n for altering TSSO processing.  Parameters are stored  as  members\n in  SYS1.PARMLIB.   The default member is TSSOPARM, and it is re-\n commended that a TSSOPARM be created for daily processing.\n\n Parameters can be entered in any order, and if  two  entries  are\n specified  for  the  same parameter, the last entry takes preced-\n ence.  See the SAMPPARM member of TSSO.VERS43.ASM.\n\n\n\n MAXCMDS PARAMETER\n _________________\n\n\n MAXCMDS defines the maximum number of  concurrent  commands  that\n TSSO  will  hold for processing.   TSSO processes commands in the\n order in which they are entered, on a  first in-first out  basis.\n Any  commands  that  are entered while TSSO is processing another\n command are queued for execution.  The MAXCMDS parameter  defines\n the  size  of that queue.   Too small a number is undesirable be-\n cause it is advantageous to be able to enter many  TSSO  commands\n at a time.  Too large a number is also undesirable because it be-\n comes  difficult  to detect when a TSSO command may be looping or\n awaiting terminal input.  The syntax is\n\n   MAXCMDS=nn\n           __\n\n where nn defines the maximum number  of  simultaneous  TSSO  com-\n       __\n mands.  Note that TSSO requires 256 bytes for each command in the\n common  service area (CSA).  The default value is 15 simultaneous\n commands.\n\n\n\n MAXWTO PARAMETER\n ________________\n\n\n MAXWTO defines the maximum number of WTOs TSSO will issue for any\n given TSO command.  The parameter is designed to prevent  console\n flooding  with  TSO  commands  that produce many lines of output.\n The syntax is\n\n   MAXWTO=nnn\n          ___\n\n\n\n TSSO PARAMETERS                                                11\n\n\n\n\n\n\n\n\n\n where nnn is the maximum number of WTOs TSSO will allow  for  any\n       ___\n one  command.    TSSO will issue a message when this limit is ex-\n ceeded.  Default is 250.\n\n\n\n NONSWAP PARAMETER\n _________________\n\n\n NONSWAP defines whether TSSO will run non-swappable.   If \"Y\"  is\n entered,  TSSO  will issue the appropriate SYSEVENT to MVS to de-\n clare itself non-swappable.  Any other entry will cause  TSSO  to\n be  swapped  out  whenever it has no work.  This can cause SEVERE\n                                                            ______\n performance degradation when using the subsystem.    The  default\n value is \"Y\".  The syntax is\n\n   NONSWAP=\u00ddY/N\u00a8\n\n where \"Y\" will mark the TSSO address space non-swappable.\n\n\n\n NUMCONS PARAMETER\n _________________\n\n\n NUMCONS  defines the number of subsystem consoles for the instal-\n lation.  Optionally, you may dedicate one subsystem  console  for\n the TSSO address space.  The syntax is\n\n   NUMCONS=nn \u00ddDEDICATE\u00a8\n           __\n\n where  nn  is  the number of consoles.  If DEDICATE is specified,\n        __\n one console will be dedicated for the TSSO address space.    Note\n that  at  least nn subsystem consoles must have been generated in\n                 __\n the MVS IOGEN prior to starting TSSO.  Default is 1 console, none\n dedicated.\n\n\n\n PROMPT PARAMETER\n ________________\n\n\n PROMPT defines whether or not the operator will be  prompted  for\n additional TSSO parameters at start-up time.  The syntax is\n\n   PROMPT=\u00ddY/N\u00a8\n\n\n\n\n TSSO PARAMETERS                                                12\n\n\n\n\n\n\n\n\n\n If PROMPT=Y is specified, TSSO will enter prompt mode after proc-\n essing  all  the parameters in PARMLIB and allow the MVS operator\n to enter or override parameters (except security-related  parame-\n ters).   For example, if you want a different AOF table used each\n day, you would want to be prompted so that you can enter the  TA-\n BLE parameter.\n\n NOTE: Prompt  mode  may  also be specified at start-up time.  See\n the next section for more information.\n\n\n\n RACFID PARAMETER\n ________________\n\n\n RACFID defines a default RACF ID for the TSSO subsystem, allowing\n TSSO to access data sets with the  authority  of  that  RACF  ID.\n This  implies that RACF commands can be entered from the MVS con-\n sole through the use of TSSO.  If the installation  has  not  in-\n stalled the RACF program product, this parameter must be omitted.\n The syntax is\n\n   RACFID=RACF-id\n          _______\n\n where RACF-id is the RACF identifier that TSSO will assume.  This\n       _______\n parameter  has no default. If it is not specified, TSSO will exe-\n cute with the default RACF authority.\n\n RACFID  is   dependent   on   the   SECLEVEL   parameter.      If\n SECLEVEL=MINIMAL,  then the RACFID authority level applies to any\n TSO command issued through TSSO.  If SECLEVEL=MEDIAL or  MAXIMAL,\n then  the RACFID authority level applies to CONSOLE 0 and any TSO\n command issued from a subsystem console through OSCMD.  Note that\n TSSO requires that subsystem consoles issuing  commands  have  at\n least \"SYSTEM\" authority.\n\n CAUTION:   TSSO  does not require a password to acquire this RACF\n            authority, and care must be taken to ensure  that  use\n            of  this parameter does not violate installation secu-\n            rity standards.\n\n A recent small programming enhancement (SPE) to the JES2  subsys-\n tem  has enhanced TSSO's ability to control production batch jobs\n that may use RACF-protected data sets.  JES2 will  now  propagate\n the  RACF  ID  and  group from the current address space for jobs\n submitted through the internal reader.  TSSO can submit jobs  us-\n ing  the  TSO  SUBMIT command, and those jobs can acquire the au-\n thority of the TSSO address space.\n\n\n TSSO PARAMETERS                                                13\n\n\n\n\n\n\n\n\n\n SECLEVEL PARAMETER\n __________________\n\n\n SECLEVEL defines the security level of  the  installation.    The\n syntax is\n\n   SECLEVEL=\u00ddMINIMAL/MEDIAL/MAXIMAL\u00a8\n\n      MINIMAL        Default  for RACF and TOP SECRET.  The RACFID\n                     parameter is used to determine TSSO's author-\n                     ity level.  Therefore, all TSO commands  will\n                     execute  with TSSO's authority, regardless of\n                     the console's authority level.\n\n      MEDIAL         This level requires all consoles  using  TSSO\n                     to log on(2) using the  appropriate  security\n                     system (RACF, TOP SECRET, or ACF2).  All data\n                     set  access  checking  for  TSSO commands and\n                     CLISTs is based on the console's logon ID au-\n                     thority.   Note that this  does  not  include\n                     TSSO control commands, which follow a differ-\n                     ent authorization mechanism.\n\n      MAXIMAL        This  level  is extremely restrictive.   Once\n                     TSSO is initialized, all consoles must log on\n                     using the appropriate security system.    ANY\n                     CONSOLE THAT DOES NOT LOG ON IS LOCKED OUT OF\n                     ALL MVS COMMANDS.\n\n\n\n SECSYS PARAMETER\n ________________\n\n\n SECSYS defines the security system used by the installation.  The\n syntax is\n\n   SECSYS=\u00ddRACF/ACF2/TOPS\u00a8\n\n The default is RACF.\n\n\n\n\n ----------------\n\n 2   Using  the  #.LOGON command, which will assign each console a\n     separate RACFID parameter.\n\n\n TSSO PARAMETERS                                                14\n\n\n\n\n\n\n\n\n\n SUBSYS PARAMETER\n ________________\n\n\n SUBSYS  defines  subsystem  interface exits and the routines that\n will handle the exit functions.  The syntax is\n\n   SUBSYS nn=module-name\n          __ ___________\n\n where nn is the subsystem interface function code and module-name\n       __                                              ___________\n is the name of the routine that will handle the  function.    You\n may  specify  as  many SUBSYS parameters as desired.  However, if\n there are multiple entries with the same function code, only  the\n last appearance of the code will be honored.\n\n By  default,  TSSO  includes two SUBSYS entries, one for function\n code 9 which intercepts WTO messages (the AOF facility)  and  one\n for  function code 10 which intercepts operator commands (the OPF\n facility).  Therefore, be careful that you do not enter a  SUBSYS\n parameter  with  code 9 or 10; otherwise, your entries will over-\n ride the defaults and disable the AOF and OPF facilities.\n\n\n\n SYSTEM RECOGNITION CHARACTER (SRC) PARAMETER\n ____________________________________________\n\n\n SRC defines the character that TSSO will use  to  recognize  TSSO\n operator  commands.   For example, if this character is \"#\", TSSO\n will intercept and process all operator commands starting with  a\n \"#\".  The syntax is\n\n   SRC=char\n       ____\n\n where  char  is  the  character that TSSO will use.   The default\n        ____\n character is a \"#\".\n\n\n\n TABLE PARAMETER\n _______________\n\n\n TABLE defines the name of the TSSO Automated Operations  Facility\n (AOF)  table.   The AOF table contains information used to inter-\n cept and responding to operating system messages.    (Information\n describing  how  to  create this table is specified later in this\n document.)  There is no default.  If this parameter is not speci-\n fied, the AOF is deactivated.  Note that this table  can  be  re-\n\n\n\n TSSO PARAMETERS                                                15\n\n\n\n\n\n\n\n\n\n loaded  (and  AOF  activated) at any time with the \".RELOAD\" TSSO\n operator command described later.  The syntax is\n\n   TABLE=table-name\n         __________\n\n where table-name is the load module name that contains a TSSO AOF\n       __________\n table.\n\n\n\n TIMEOUT PARAMETER\n _________________\n\n\n TIMEOUT defines the interval after which TSSO will log off an in-\n active console.  The syntax is\n\n   TIMEOUT=nn\n           __\n\n where nn is the maximum number of minutes of inactivity.\n       __\n\n\n\n * (COMMENTS) PARAMETER\n ______________________\n\n\n The \"*\" parameter allows an installation to place comments in the\n TSSO initialization deck.  The line will be ignored by TSSO.  The\n syntax is\n\n   * any-text\n     ________\n\n where any-text is any descriptive comments the  installation  may\n       ________\n want to include in the initialization deck.\n\n\n\n END PARAMETER\n _____________\n\n\n END marks the end of TSSO parameter input. The syntax is\n\n   END\n\n with  no  operands.   If prompt mode was enabled, the MVS console\n operator will be prompted for additional  TSSO  parameters  after\n the END parameter is processed.\n\n\n\n\n TSSO PARAMETERS                                                16\n\n\n\n\n\n\n\n\n\n TSSO START COMMAND OPTIONS\n __________________________\n\n\n\n Start  procedures  under  release 4.3 have changed significantly.\n Depending on how you identified TSSO to MVS (see Step 7. on  page\n 9),  JES  support  may  or  may not be available automatically at\n start time.  If not, you may initialize TSSO with  JES  by  using\n the  SUB= operand.  Note that, except for emergencies, YOU CAN NO\n LONGER START TSSO IF IT IS ALREADY UP.\n\n The TSSO start command has the following syntax:\n\n   S TSSO\u00dd,PARM='\u00dd*\u00a8\u00ddparm-member\u00a8\u00ddPROMPT\u00a8'\u00a8\u00dd,SUB=JES2/JES3/MSTR\u00a8\n                     ___________\n\n PARM='*'          Allows  you to specify TSSO parameters(3) with-\n                   out entering them previously into SYS1.PARMLIB.\n                   This can be useful in emergency situations; for\n                   example, if you need to enter a parameter on  a\n                   one-time  basis,  or  if  you are locked out of\n                   SYS1.PARMLIB and need to enter a different  pa-\n                   rameter.\n\n PARM='parm-member'  Directs TSSO to use an alternate TSSO parame-\n                   ter deck in SYS1.PARMLIB for parameters.    De-\n                   fault is TSSOPARM.\n\n PARM='PROMPT'     Directs TSSO to prompt the MVS console operator\n                   for  the name of a member in SYS1.PARMLIB to be\n                   used for  parameters.    After  processing  the\n                   named  member,  TSSO  will  also prompt the MVS\n                   console  operator  for  additional  parameters,\n                   even if the parameter deck specifies PROMPT=N.\n\n SUB=JES2/JES3     Initialize TSSO with JES2 or JES3(4).\n\n                   NOTE: The  JES subsystem must be up for this to\n                   work.\n\n SUB=MSTR          Initializes TSSO without the primary subsystem.\n                   This should be used only if JES won't come up.\n\n\n\n ----------------\n\n 3   Except the security-related parameters SECSYS, SECLEVEL,  and\n     RACFID.\n\n\n TSSO START COMMAND OPTIONS                                     17\n\n\n\n\n\n\n\n\n\n If an emergency restart is necessary, the start command  has  the\n form\n\n   S TSSO,PARM='/\u00ddoptions\u00a8'\n                  _______\n\n where  options are any of the PARM options listed above.  The \"/\"\n        _______\n MUST be specified as the first operand.  When a force restart oc-\n curs, the inactive TSSO address space may  be  cancelled.    Note\n that  the  inactive  TSSO  does not relinquish its subsystem con-\n soles, and, therefore, it is not advisable to  force  start  TSSO\n unless absolutely necessary.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ----------------\n\n 4   Although  TSSO has not been tested extensively using the JES3\n     product, the interfaces should be the same because TSSO  uses\n     standard subsystem interface calls.\n\n\n TSSO START COMMAND OPTIONS                                     18\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY\n _______________________________________\n\n\n\n OVERVIEW\n ________\n\n\n The  TSSO Operator Productivity Facility (OPF) is a powerful tool\n which, in conjunction with the Automated Operations Facility, can\n automate many procedures that currently must  be  done  manually.\n OPF extends the power of TSO to the MVS operator's console by al-\n lowing  TSO  commands  and CLISTS to be executed from an MVS con-\n sole, with the response going back to the invoking console.  This\n includes all TSO functions which use  standard  interfaces  (with\n the  exceptions  noted below) and control functions unique to the\n TSSO environment that alter TSSO options and display TSSO  infor-\n mation.\n\n OPF also allows TSO users to issue MVS commands and get responses\n returned  to  the  terminal or to CLIST variables.  TSO users are\n usually restricted to INFO console authority.    (See  \"Authority\n Checking with OSCMD\" on page 22.)\n\n\n\n TSO COMMANDS UNDER TSSO\n _______________________\n\n\n Most TSO commands may be run under control of the TSSO subsystem.\n The requirements for such commands are as follows:\n\n 1.  The command must use standard TSO interfaces (namely, GETLINE\n     and  PUTLINE) to perform I/O.  The command should not require\n     input of any kind other than normal TSO command parameters.\n\n 2.  THE COMMAND SHOULD NOT ATTEMPT TO USE FULL SCREEN PROCESSING.\n     A command that issues  the  STFSMODE  FULLSCRN=YES  macro  in\n     ACF/VTAM environments can hang the TSSO subsystem, forcing it\n     to be cancelled.\n\n 3.  The  command  should be TESTED UNDER BATCH TSO before running\n                             ______________________\n     it under TSSO, since TSO assumes that TSSO-initiated commands\n     are running in BACKGROUND mode.\n                    __________\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        19\n\n\n\n\n\n\n\n\n\n TSSO CONTROL COMMANDS\n _____________________\n\n\n TSSO supports a number of commands that are not directed  to  the\n TMP  for execution.  These commands are handled directly by TSSO,\n and are used to alter or query TSSO processing options.  See \"Ap-\n pendix B. TSSO Control Commands\" on page 67 for more information.\n\n\n\n TSO COMMANDS DISTRIBUTED WITH TSSO\n __________________________________\n\n\n A number of TSO commands that are designed to run with  the  TSSO\n subsystem  are distributed with the base code.  TSO commands used\n primarily from CLISTs include the \"OS family\" and the REPLY  com-\n mand.  These are designed to provide services such as communicat-\n ing  with  the  MVS  operator  and  issuing  messages  to the MVS\n console, communicating with the MVS command subsystem, and commu-\n nicating with programs that have issued WTORs.   Applications  of\n these  commands  are described below.  Figure 1 on page 21 summa-\n rizes the behavior of OSCMD with the CMDRESP variable in  differ-\n ent  environments.   Members EXJOBS, EXCKSPL,, EXSTVTAM and EXASK\n in data set TSSO.VERS43.ASM illustrate the OS family in some use-\n ful CLISTs.\n\n Other commands are provided as auxiliary TSO command  processors.\n These  include  the  CACHE  command  for  controlling 3880-21 and\n 3880-23 cache devices, the LINKLIST command  for  displaying  the\n system  LNKLST  concatenation, and the VOLSER and VALLOC commands\n for displaying UCB information for DASD devices.  Also, the CPCMD\n command allows an MVS console operator running in a  virtual  ma-\n chine under VM/SP, VM/SP HPO or the VM/XA systems facility to is-\n sue CP commands and get the response back to the console invoking\n the command.\n\n A  complete description of TSO commands may be found in \"Appendix\n A. TSSO Command Reference\" on page 42.\n\n\n\n THE OSCMD COMMAND\n _________________\n\n\n OSCMD allows you to issue any MVS  command  (JES2,  VTAM,  etc.).\n OSCMD is most useful when issued from a CLIST, where the response\n is returned to CLIST variables.  The CLIST can be designed to ma-\n nipulate  these  variables  to  produce readable responses to the\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        20\n\n\n\n\n\n\n\n\n\n +---------------------------------------------------------------+\n |                                                               |\n | ENVIRONMENT  LEGAL VALUES FOR CMDRESP       AUTHORITY CHECKING|\n |                                                               |\n | TSSO CLIST   - CLIST                        Based on invoking |\n |              - NOWHERE                      console           |\n |              - If not defined, value is                       |\n |                assumed to be CLIST                            |\n |                (if MAXCMDOUT > 0) or                          |\n |                NOWHERE (if MAXCMDOUT = 0).                    |\n |                This is included for                           |\n |                compatibility with previous                    |\n |                releases.                                      |\n |                                                               |\n | TSO CLIST    - TERM                         Based on OSCMDATH |\n |              - CLIST                        user exit         |\n |              - NOWHERE                                        |\n |              - If not defined, OSCMD                          |\n |                assumes NOWHERE                                |\n |                                                               |\n | TSO terminal - TERM                         Based on OSCMDATH |\n |                                             user exit         |\n |                                                               |\n | Figure 1.  Behavior of CMDRESP in Various Environments        |\n +---------------------------------------------------------------+\n\n user.  For example, the JES command $DN queries the status of all\n jobs on the system.  The output from $DN  could  be  filtered  so\n that  the  information will be printed only for certain job names\n (member EXJOBS in TSSO.VERS43.ASM).\n\n The syntax of OSCMD is\n\n   OSCMD mvs-cmd\n         _______\n\n where mvs-cmd is any MVS command.   Through  the  CLIST  variable\n       _______\n CMDRESP,  OSCMD  can  determine  the destination of a command re-\n sponse based on its origin.\n\n\n\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        21\n\n\n\n\n\n\n\n\n\n\n +-------------+-------------------------------------------------+\n | If CMDRESP= | then the response will be:                      |\n +-------------+-------------------------------------------------+\n |             |                                                 |\n | TERM        | returned to the TSO user's terminal             |\n |             |                                                 |\n | CLIST       | returned to CLIST variables (see OSCMD in       |\n |             | \"Appendix A. TSSO Command Reference\" on page 42)|\n |             |                                                 |\n | NOWHERE     | discarded (TSO users) or                        |\n |             | returned to the console (TSSO-initiated commands|\n |             |                                                 |\n +-------------+-------------------------------------------------+\n\n Input and output variables are described  in  \"Appendix  A.  TSSO\n Command Reference\" on page 42.\n\n\n\n AUTHORITY CHECKING WITH OSCMD\n\n\n Because  OSCMD allows a TSO user to issue any MVS command, strict\n security must be enforced to prevent unauthorized users from  is-\n suing   dangerous   system   commands.      When  issued  from  a\n TSSO-initiated CLIST, OSCMD checks the authority of the  invoking\n console  and only permits commands of that level.  When issued by\n a TSO user, the OSCMDATH user exit checks  the  installation  au-\n thority  of  the  user's  ID.    By  default,  all TSO users have\n INFO-only authority as defined in the MVS system operations  man-\n ual.  Other authority levels (system, I/O, master) can be defined\n through  the  OSCMDATH user exit.  This exit allows the installa-\n tion to code a routine to determine the MVS command  group  level\n for  a TSO user.  Full authority can be granted on a per-user ba-\n sis.(5)\n\n\n\n\n\n\n\n ----------------\n\n 5   \"Authorized users\" are those with X'C0' in the PSCBATR2 field\n     of the User Attributes Data Set.  This can be set through the\n     USERDATA operand of the CHANGE subcommand of ACCOUNT.\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        22\n\n\n\n\n\n\n\n\n\n THE OSWTO AND OSWTOH COMMANDS\n _____________________________\n\n\n OSWTO and OSWTOH allow you to write messages to the operator con-\n sole.  OSWTOH highlights the message.  The syntax of the commands\n is\n\n   OSWTO message\n         _______\n   OSWTOH message\n          _______\n\n where message is the text of the message issued.  Members EXJOBS,\n       _______\n EXCKSPL, EXSTVTAM, and EXASK in TSSO.VER43.ASM  illustrate  these\n commands.\n\n\n\n THE OSASK COMMAND\n _________________\n\n\n OSASK  allows  you  to  ask the operator a question and get a re-\n sponse.  If it is issued from a TSO command  line,  the  response\n goes  to the user's terminal.  However, like OSCMD, OSASK is most\n useful when issued from a CLIST, where the response  is  returned\n to  CLIST  variables which can then be manipulated.  So that TSSO\n is not delayed too long for an operator reply, the  maximum  wait\n time   is  60  seconds,  after  which  the  default  response  is\n \"NOREPLY\".\n\n The syntax of OSASK is\n\n   OSASK question\n         ________\n\n Input and output variables are described  in  \"Appendix  A.  TSSO\n Command  Reference\"  on page 42.  Member EXASK in TSSO.VERS43.ASM\n illustrates OSASK with an interactive help procedure.\n\n\n\n THE OSPAUSE COMMAND\n ___________________\n\n\n OSPAUSE is used to delay CLIST execution for a  specified  number\n of  seconds.  This is useful if the CLIST any time the CLIST must\n wait for an event.  Member EXSTVTAM in TSSO.VERS43.ASM  shows  an\n example  of  a  CLIST that initiates a started task and must wait\n for it to initialize.\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        23\n\n\n\n\n\n\n\n\n\n THE OSWAIT COMMAND\n __________________\n\n\n OSWAIT directs TSSO to wait for a particular system message or  a\n timeout limit to occur before proceeding.  These messages are de-\n fined  in  the AOF table.  OSWAIT is intended to be issued from a\n CLIST.\n\n OSWAIT provides many automation opportunities that were (in  pre-\n vious  versions  of TSSO) too cumbersome to develop.  OSWAIT does\n not need to run from the TSSO address space.  In theory,  an  in-\n stallation  may  have  many  OSWAIT events outstanding at any one\n time in different TSO or batch address spaces.   For  example,  a\n simple job scheduler can be coded as a CLIST using the OSWAIT and\n OSCMD  facilities.   The CLIST can then be run under control of a\n batch TMP in a separate address space.\n\n The syntax of OSWAIT is\n\n   OSWAIT ENTRY(entry-id) TIMEOUT(nnnnn)\n                ________          _____\n\n where entry-id is the 1- to 8-character identifier of the AOF ta-\n       ________\n ble entry; and nnnnn is the number of second to wait before time-\n                _____\n out, maximum 86400 seconds.   For example, Figure 2  on  page  25\n shows  a  CLIST  that  will start a job, wait for the job to com-\n plete, and purge the job.\n\n See \"Appendix A. TSSO Command Reference\" on page 42 for more  in-\n formation on OSWAIT.\n\n\n\n USING THE WRITE STATEMENT IN TSSO CLISTS\n ________________________________________\n\n\n In  previous  releases of TSSO, operator commands and highlighted\n messages could only be issued using the WRITE statement with  the\n *COM and *HI keywords.  These facilities still work under release\n 4.3,  and  CLISTs  written with them can be used unaltered.  How-\n ever, note that the difference between these facilities  and  the\n commands OSCMD, OSWTO, OSWTOH, and OSPAUSE is that TSSO processes\n *COM  and  *HI  directives AFTER the CLIST has completed, whereas\n                            _____\n the TSSO commands will be executed IMMEDIATELY.  Care must there-\n                                    ___________\n fore be taken in designing CLISTs with *COM and *HI, because  any\n TSO  commands  in  the CLIST are executed before any MVS commands\n are issued by TSSO.\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        24\n\n\n\n\n\n\n\n\n\n +---------------------------------------------------------------+\n |                                                               |\n |   PROC 0                                                      |\n |   /**********************************************************/|\n |   /*  This clist will start a job, wait for its completion, */|\n |   /*  and purge the job.                                    */|\n |   /**********************************************************/|\n |                                                               |\n |   OSCMD S MYJOB                                               |\n |   OSWAIT ENTRY(MYJOBEND)    TIMEOUT(60)                       |\n |   OSWTO MYJOB HAS ENDED ...                                   |\n |   OSCMD $P'MYJOB'                                             |\n |   EXIT                                                        |\n |                                                               |\n |                                                               |\n |                                                               |\n | The CLIST above used the AOF table entry                      |\n |                                                               |\n | MYJOBEND TABENTRY MSG=IEF404I,ACTION=POST,                  X |\n |          TEST=((W,2,5,'MYJOB',' '))                           |\n |                                                               |\n |                                                               |\n | Figure 2.  Sample CLIST for OSWAIT.                           |\n +---------------------------------------------------------------+\n\n The  *COM  and  *HI  facilities  are   available   only   through\n TSSO-initiated CLISTs.\n\n\n\n *COM KEYWORD\n ____________\n\n\n The *COM keyword used in the WRITE statements also enables you to\n issue  MVS commands.   When an output line in the SYSTSPRT output\n stream (the output from the TSO command or CLIST) begins with the\n keyword \"*COM\", TSSO will execute the remainder of that statement\n as an MVS operator command.  The syntax of  this  extended  WRITE\n statement is\n\n   WRITE *COMnnn oscmd\n             _________\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        25\n\n\n\n\n\n\n\n\n\n      where\n\n      nnn     is  a  delay factor directing TSSO to delay nnn sec-\n      ___                                                 ___\n              onds after processing the command.   This is  useful\n              when  operating  system commands have a time depend-\n              ency on each other.\n\n      oscmd   is an MVS operator command to be executed.  The com-\n      _____\n              mand could be an MVS command, JES command,  or  even\n              another TSSO command.  Note that THE COMMAND WILL BE\n                                               ___________________\n              EXECUTED WITH THE AUTHORITY OF THE CONSOLE THAT ORI-\n              ____________________________________________________\n              GINALLY INVOKED THE TSSO COMMAND.\n              _________________________________\n\n\n\n\n *HI KEYWORD\n ___________\n\n\n The  *HI  keyword allows you to write highlighted messages on the\n MVS console.  The syntax is\n\n   WRITE *HI message\n             _______\n\n where message is the message to be highlighted on  the  MVS  con-\n       _______\n sole.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        26\n\n\n\n\n\n\n\n\n\n GUIDELINES AND SUGGESTIONS FOR WRITING CLISTS\n _____________________________________________\n\n\n 1.  CLISTs  can  be used to write operator HELP procedures to the\n     MVS console.  This is demonstrated in Figure 3 on page 28.\n\n 2.  The REPLY command is useful in CLISTS to automate operational\n     procedures with products that  communicate  to  the  operator\n     through  the  WTOR interface (e.g., NCCF and IMS).  For exam-\n     ple, if numerous NCCF commands are to be executed, these  can\n     be executed in a TSSO CLIST using the REPLY command with mes-\n     sage  ID DSI802A. See the description of the REPLY command in\n     \"Appendix A. TSSO Command Reference\" on page 42.\n\n 3.  Comments may be placed at the end of MVS commands because MVS\n     treats them as MVS command comments.   However,  JES2  treats\n     CLIST  comments  as data and tries to use them in forming the\n     command.  Therefore, do not place CLIST comments on JES2 com-\n     mands; place them on the lines following the  command.    For\n     example,  the  following  CLIST  is  invalid because it would\n     produce an invalid JES2 command.\n\n -----------------------------------------------------------------\n\n       PROC 0\n       OSCMD $TEXIT6,ENABLE        /* ENABLE THE EXIT */\n       EXIT\n\n -----------------------------------------------------------------\n\n     This situation is remedied in MVS/SP JES2 Release  1.3.6  and\n     MVS/XA JES2 Release 2.1.5.\n\n 4.  Symbolic  substitution can be used in TSSO CLISTS as shown in\n     Figure 4 on page 29.\n\n 5.  Since operations personnel will be using OPF, the recommenda-\n     tion is to allow them to write their own CLISTS.\n\n 6.  TSSO CLISTS are invoked in the same fashion as TSSO commands.\n     The normal TSO search sequence is followed.  The  recommenda-\n     tion  is to allocate a SYS1.TSSOPROC data set and allocate it\n     to DDNAME SYSPROC in the TSSO bringup deck. The SYSPROC  data\n     set  may  also be dynamically allocated through the TSO ALLO-\n     CATE command. Lastly, the TSO EXEC command may be used to ex-\n     ecute TSSO CLISTS.\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        27\n\n\n\n\n\n\n\n\n\n +---------------------------------------------------------------+\n |                                                               |\n |   PROC 0                                                      |\n |   /********************************************************/  |\n |   /* This CLIST will provide HELP information to the      */  |\n |   /* operator on the current status of the NJE LINES      */  |\n |   /* between JES2 systems                                 */  |\n |   /********************************************************/  |\n |   WRITE NJE LINK BETWEEN A and B is line 12                   |\n |   WRITE NJE LINK BETWEEN A and C is line 16                   |\n |   WRITE NJE LINK BETWEEN B and C is line 20                   |\n |   WRITE NJE LINK BETWEEN C and A is line 19                   |\n |   WRITE NJE LINK BETWEEN C and B is line 24                   |\n |   WRITE NJE LINK BETWEEN B and A is line 13                   |\n |   WRITE                                                       |\n |   WRITE This list is current as of January 3, 1985. For more  |\n |   WRITE assistance, contact Alan Grossman at extension 5555.  |\n |   EXIT CODE(0)                                                |\n |                                                               |\n |                                                               |\n | Figure 3.  CLIST  with  an  Operator  Help  Procedure   Using |\n |            WRITE:  Note  that  OSWTO is the preferred command |\n |            for CLISTs.                                        |\n +---------------------------------------------------------------+\n\n 7.  Use OSWTOH and WRITE *HI with caution. Do not highlight  mes-\n     sages unless their importance warrants it, because your oper-\n     ations  staff  will learn to ignore highlighted messages, and\n     this can be harmful to your overall system operations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        28\n\n\n\n\n\n\n\n\n\n +---------------------------------------------------------------+\n |                                                               |\n |   PROC 2 UNIT VOLSER USE()                                    |\n |   /*****************************************/                 |\n |   /* This CLIST will mount MVS volumes     */                 |\n |   /* using a command in operator friendly  */                 |\n |   /* syntax. Note the optional USE         */                 |\n |   /* parameter.                            */                 |\n |   /*****************************************/                 |\n |   OSCMD VARY &UNIT,ONLINE                                     |\n |   IF &USE = THEN +                                            |\n |   DO                                                          |\n |           OSCMD MOUNT &UNIT,VOL=(SL,&VOLSER)                  |\n |   END                                                         |\n |   ELSE +                                                      |\n |   DO                                                          |\n |           OSCMD MOUNT &UNIT,VOL=(SL,&VOLSER),USE=&USE         |\n |   END                                                         |\n |   OSWTOH MNT001I VOLUME &VOLSER NOW MOUNTED ON &UNIT          |\n |   OSCMD D U,,,&UNIT,1                                         |\n |   EXIT                                                        |\n |                                                               |\n |                                                               |\n | Figure 4.  CLIST Using Symbolic Substitution                  |\n +---------------------------------------------------------------+\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n THE TSSO OPERATOR PRODUCTIVITY FACILITY                        29\n\n\n\n\n\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY\n __________________________________\n\n\n\n INTRODUCTION\n ____________\n\n\n A high percentage of MVS commands are issued in response to  sys-\n tem  or subsystem messages, and these responses are predetermined\n by the contents of the messages.  The TSSO  Automated  Operations\n Facility  (AOF) frees the MVS console operator from routine tasks\n by automating responses to system messages.    AOF  is  a  table-\n driven  monitor  that  intercepts messages and carries out one of\n four actions:  suppresses, highlights, or lowlights the  message;\n or  issues  an  MVS, JES2 or subsystem command.  Because AOF does\n not require the services of the TSSO address space, any number of\n messages can be processed simultaneously.\n\n There are three steps required to install this facility; briefly:\n\n 1.  Create the AOF table.\n\n 2.  Assemble and link-edit the table into load module format.\n\n 3.  Store the module in SYS1.TSSOLOAD.\n\n These steps are described in detail below.\n\n Note that the table can be updated at any time.   Also,  you  may\n create  multiple  tables,  although  only  one can be active at a\n time.  Multiple tables may be useful so that  different  sets  of\n commands  can be used at different times (e.g., first, second and\n third shifts).  You can change the active table in three ways:\n\n 1.  By changing the TABLE= parameter in the parameter  deck;  the\n     new table will be available the next time TSSO is brought up.\n\n 2.  By  dynamically  reloading the table with the \"#.RELOAD\" com-\n     mand; the new table will be available immediately.\n\n 3.  By resetting the MATCHLIM parameter of any entry in  the  ac-\n     tive  AOF  table  with  the  ALTAOF command; the new MATCHLIM\n     value will be effective immediately.\n\n\n\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             30\n\n\n\n\n\n\n\n\n\n CREATING THE AOF TABLE\n ______________________\n\n\n There are three macros required to create the table:  TABSTART to\n start the table, TABENTRY to specify  actions  on  messages,  and\n TABEND to end the table.\n\n TABSTART  is  always  the  first  macro and can be specified only\n once.  It takes the form\n\n   loadname TABSTART ID=table-id\n   ________             ________\n\n where loadname is the name of this TSSO table and table-id is  an\n       ________                                    ________\n eye-catching name to identify the table in a dump.  table-id will\n                                                     ________\n also be displayed on the DISPAOF and .Q T commands.  The loadname\n                                                          ________\n label is used as the CSECT name and must be used as the load mod-\n                                     ____\n ule name.\n\n TABEND is always the last macro, signifying the end of the table.\n TABEND  must be present; otherwise, unpredictable things may hap-\n pen, none of them pleasant.\n\n TABENTRY  macros  are  entered  between  TABSTART   and   TABEND.\n TABENTRY  macros  generate  entries in the AOF table and take the\n form\n\n   entry-id TABENTRY MSG=msg-id,ACTION=action\u00dd,TEXT='operator-cmd'\u00a8\n   ________              ______        ______        ____________\n                                             \u00dd,TEXT=(condition)\u00a8\n                                                     _________\n                                             \u00dd,MATCHLIM=n\u00a8\n                                                        _\n                                             \u00dd,ECHO=\u00ddYES/NO/LOG\u00a8\u00a8\n\n A sample AOF table, demonstrating most  of  the  capabilities  of\n TSSO/AOF  and  all  forms  of  the  TABENTRY  macro,  is  in  the\n TSSO.VERS43.ASM data set in member AOFIVP.\n\n\n\n TABENTRY OPERANDS\n _________________\n\n\n\n THE ENTRY-ID OPERAND\n ____________________\n\n\n Entry-id is a 1- to 8-character identifier  for  each  AOF  table\n ________\n entry.  The ID allows you to identify entries by name rather than\n position  in  the  table  to  the  commands  OSWAIT, DISPAOF, and\n ALTAOF.\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             31\n\n\n\n\n\n\n\n\n\n THE MSG OPERAND\n _______________\n\n\n MSG identifies an MVS, JES2, or subsystem message as  defined  in\n MVS/XA  SYSTEM  MESSAGES  (GC28-1376  and  -1377)  or its MVS/370\n ________________________\n equivalent.  msg-id is the first seven or eight characters of the\n              ______\n console message.  msg-id may also be an asterisk (*), which  will\n                   ______\n match on all console messages.  MSG=* is useful with the TEST op-\n erand described later.\n\n\n\n THE ACTION OPERAND\n __________________\n\n\n The  following actions may be taken in response to the identified\n message:\n\n 1.  SUPPRESS (I.E., DO NOT PRINT) THE  MESSAGE  AT  THE  CONSOLE.\n     _____________________________________________________________\n     The macro takes the form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=SUPPRESS\n       ________              ______\n\n 2.  HIGHLIGHT  THE  MESSAGE  AT THE CONSOLE.   This is useful for\n     ________________________________________\n     highlighting important messages.  The macro takes the form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=HILIGHT\n       ________              ______\n\n 3.  LOWLIGHT THE MESSAGE AT THE CONSOLE.  This reverses  the  in-\n     ____________________________________\n     tensity  of  MVS messages that are automatically highlighted.\n     The macro takes the form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=LOWLIGHT\n       ________              ______\n\n 4.  REPLY TO A WRITE TO OPERATOR WITH REPLY (WTOR) MESSAGE.   The\n     ______________________________________________________\n     macro takes the form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=REPLY,TEXT='reply-text'\n       ________              ______                   ____________\n\n     where reply-text is the text of the reply; TSSO will automat-\n           __________\n     ically format the reply message as R msg-no,reply-text.  Note\n                                          __________________\n     that msg-id must be a WTOR message.\n          ______\n\n 5.  ISSUE  AN  OPERATOR  COMMAND IN RESPONSE TO A MESSAGE AND EX-\n     _____________________________________________________________\n     TRACT PART OF THE MESSAGE TO USE IN THE COMMAND.   The  macro\n     _______________________________________________\n     takes the form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=OSCMD,TEXT='operator-cmd'\n       ________              ______                   ______________\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             32\n\n\n\n\n\n\n\n\n\n     operator-cmd  can  be an MVS command, JES2 command, TSSO com-\n     ____________\n     mand, or TSSO CLIST.   Rules for coding  TEXT  are  described\n     later.\n\n 6.  PRINT  AN OPERATOR COMMAND AT THE CONSOLE RATHER THAT EXECUTE\n     _____________________________________________________________\n     IT. This allows you to test an operator command that  results\n     ___\n     from  a  TABENTRY  before executing it.   The macro takes the\n     form\n\n       entry-id TABENTRY MSG=msg-id,ACTION=OSCMDT,TEXT='operator-cmd'\n       ________              ______                    ______________\n\n     The rules are the same as for OSCMD above.\n\n 7.  POST A \"WAITING TASK\" THAT A MESSAGE OCCURRED.\n     ______________________________________________\n\n       entry-id TABENTRY MSG=msg-id,ACTION=POST\n       ________              ______\n\n     Posting supports the OSWAIT command (see \"The OSWAIT Command\"\n     on page 23).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             33\n\n\n\n\n\n\n\n\n\n 8.  CARRY OUT THE SPECIFIED ACTION IF AND  ONLY  IF  THE  MESSAGE\n     _____________________________________________________________\n     MEETS  CERTAIN  CONDITIONS, such as matching a particular job\n     ___________________________\n     name.  To do this, include the TEST operand in your  TABENTRY\n     macro as follows:\n\n       entry-id TABENTRY MSG=msg-id,ACTION=actionTEST=(condition)\n       ________              ______        ______      _________\n                         \u00ddTEXT='operator-cmd'\u00a8\n                                ____________\n\n     where condition tests portions of the message by substring or\n           _________\n     word.  Rules for coding the TEST operand are described later.\n\n     NOTE:       TEXT can only be used if ACTION=OSCMD, OSCMDT, or\n     REPLY.\n\n There is no limit on the number of TABENTRY macros  that  may  be\n specified  in  a given AOF table. Note that TSSO will process ALL\n                                                               ___\n of the entries in the TSSO/AOF table for every WTO or  WTOR  mes-\n sage.   This implies that multiple ACTION= operands may be speci-\n fied for the same msg-id, by specifying multiple TABENTRY macros.\n                   ______\n TSSO does not stop processing one ACTION= directive, but  contin-\n ues until the end of the table.\n\n\n\n THE TEXT OPERAND\n ________________\n\n\n The  OSCMD action allows you to specify an operator command to be\n performed in response to a particular message.   Optionally,  you\n may  select one or more portions of the message to include in the\n command.  entry-id This is useful for extracting a data set name,\n           ________\n job name, or other variable information from a message and embed-\n ding it in the command  to  be  executed.    The  two  formatting\n options  in the TEXT parameter allow you to extract this informa-\n tion by substring or by word.\n\n To select information by substring, use the format\n\n   \\Snnn,yy\\\n     ______\n\n where nnn is the starting character position and yy is the number\n       ___                                        __\n of characters to select.  For example, suppose you want to record\n the text of /*MESSAGE cards whenever they are encountered in  the\n job stream.  JES2 issues a $HASP104 message, and you want to cap-\n ture  characters  1  through  72 of the card.  Thus, the TABENTRY\n would look like this:\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             34\n\n\n\n\n\n\n\n\n\n   entry-id TABENTRY MSG=$HASP104,ACTION=OSCMD,             X\n   ________\n            TEXT='#RECMSG MSG(''\\S001,72\\'')\n\n Note that nnn must be left-padded with zeroes.\n           ___\n\n To select information by word, use the format\n\n   \\Wabcdnn\\\n     ______\n\n where a, b, c, and d define the word separator characters, and nn\n       ________     _                                           __\n identifies the word's position.  A word can be a  maximum  of  16\n characters.  For example, given the message\n\n   IEF176I WTR 1A4 WAITING FOR WORK ...\n\n you might want to purge the writer 1A4 with the command\n\n   PURGE 1A4\n\n To  do this, you want to extract the third word from the message,\n which identifies the external writer name.   Thus,  the  TABENTRY\n macro would look like this:\n\n   entry-id TABENTRY MSG=IEF176I,ACTION=OSCMD,TEXT='PURGE \\W    03\\'\n   ________\n\n Note that if you do not need to define four separator characters,\n you must pad the field with blanks.  Also, nn must be left-padded\n                                            __\n with a zero.\n\n Multiple \"S\" and \"W\" options can be used in one TEXT operand.  If\n AOF  detects an error in the TEXT parameter as a result of a S or\n W option, a message is issued and processing is terminated.\n\n------------------------------------------------------------------------\nTo insert the system ID of the issuing system in a SYSPLEX, use\nthe format:\n\n   \\Iabcdnn\\\n     ______\n\n where abcdnn are optional and ignored.  The trailing '\\' must be\nspecified.\n\n For example, to route a command to the system that issued a\nmessage, you need to insert the SYSTEM ID into the ROUTE command,\nThe TABENTRY macro would look like this:\n\n   entry-id TABENTRY MSG=IEF176I,ACTION=OSCMD,\n   ________\n                  TEXT='RO \\I001,01\\P \\W    03\\'\n\n\n Multiple \"I\" \"S\" and \"W\" options can be used in one TEXT operand.\nIf AOF  detects an error in the TEXT parameter as a result of a S\nor W option, a message is issued and processing is terminated.\n\n---------------------------------------------------------------------\n\n\n THE TEST OPERAND\n ________________\n\n\n The TEST operand allows you to respond selectively to messages by\n \"testing\" the text.  For example, when payroll jobs complete, you\n may want to highlight the message, whereas  you  want  to  ignore\n other  job  completion messages.   The TEST operand allows you to\n match on message text by substring or word.\n\n To match by substring, use the format\n\n   (S,nnn,yy,'literal-string')\n      _______________________\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             35\n\n\n\n\n\n\n\n\n\n where you want to find the character string literal-string start-\n                                             ______________\n ing in character position nnn for a length of yy characters.  For\n                           ___                 __\n example, (S,32,07,'PAYROLL') would look for PAYROLL in  character\n positions 32 through 38.\n\n To match by word order, use the format\n\n   (W,nn,yy,'literal-string','abcd')\n      _____________________________\n\n where  you  want  to  find the character string literal-string as\n                                                 ______________\n word number nn with a word length of yy characters; and a, b,  c,\n             __                       __                 _________\n and  d  define  the  word  separator  characters.    For example,\n      _\n (W,03,07,'PAYROLL',', ') would look for PAYROLL as the third word\n with seven characters separated by blanks or commas.\n\n Thus, the whole TABENTRY macro for our example could be either\n\n   entry-id TABENTRY MSG=$HASP395,ACTION=HILITE,        X\n   ________\n            TEST=((S,32,07,'PAYROLL'))\n\n or\n\n   entry-id TABENTRY MSG=$HASP395,ACTION=HILITE,        X\n   ________\n            TEST=((W,03,07,'PAYROLL',' ,'))\n\n It is possible to test on all WTO or WTOR messages by  specifying\n MSG=*.   For example, if you want to highlight all JES end-of-day\n messages, you would test for a first word of $HASP and  a  second\n word (i.e., job name) of ENDOFDAY.  The TABENTRY macro would look\n like this:\n\n   entry-id TABENTRY MSG=*,ACTION=HILIGHT,             X\n   ________\n            TEST=((W,1,5,'$HASP',' '),(W,2,7,'ENDOFDAY'))\n\n MSG=*  is  also  useful  when  testing  for  message IDs that are\n greater than 8 characters or for message IDs  in  a  non-standard\n format (e.g., messages for MODEL 204 applications).\n\n\n\n NOTES ON THE TEST OPERAND\n\n\n 1.    EACH  TEST  CONDITION, AS WELL AS THE ENTIRE TEST PARAMETER\n     LIST, MUST BE ENCLOSED IN PARENTHESES.\n\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             36\n\n\n\n\n\n\n\n\n\n 2.  There are multiple way to do the same test, as shown  in  the\n     examples  above.  However, it is generally easier to match on\n     words rather than substrings.\n\n 3.  \"Logical and\" and \"logical or\" test conditions  can  be  con-\n     structed with the TEST operand.\n\n     a.  To  construct a \"logical and\", specify all the conditions\n         to be met in one TEST operand:\n\n           TEST=((condition1),(condition2),(condition3))\n                  ____________________________________\n\n     b.  To construct a \"logical or\",  specify  multiple  TABENTRY\n         macros  with  the same MSG, ACTION, and TEXT operands but\n         with different TEST operands:\n\n           TABENTRY MSG=msg-id,ACTION=action,TEST=((condition1))\n                        ______        ______\n\n           TABENTRY MSG=msg-id,ACTION=action,TEST=((condition2))\n                        ______        ______\n\n           TABENTRY MSG=msg-id,ACTION=action,TEST=((condition3))\n                        ______        ______\n\n 4.  When using the TEST operand, TABENTRY  macros  can  be  quite\n     lengthy.   To continue a macro on the next line, enter an \"X\"\n     in column 72.   Since the TABENTRY  macro  follows  the  con-\n     ventions  for  the IBM assembler language, the next line in a\n     continuation must start in column 16. Note that blank charac-\n     ters are not permitted, except if they are  inside  quotation\n     marks.\n\n 5.  The first word in the message is usually the message ID.  The\n     first  column  position is the first character in the message\n     ID.\n\n\n\n THE MATCHLIM OPERAND\n ____________________\n\n\n MATCHLIM specifies the  maximum  number  of  times  a  particular\n action can be executed.  When the MATCHLIM value is exceeded, the\n AOF  table entry is ignored.  Note that the MATCHLIM value may be\n reset with the ALTOF command.\n\n For example, if VTAM crashes, you may want TSSO to  issue  a  re-\n start  command  immediately but you also want to limit the number\n of restarts in the event VTAM has a serious problem that  is  not\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             37\n\n\n\n\n\n\n\n\n\n solved by a restart.  The following entry will restart VTAM up to\n three times after it goes inactive.\n\n   entry-id TABENTRY MSG=1ST002I,ACTION=OSCMD,             X\n   ________\n            TEXT='START NETWORK',ECHO=YES,MATCHLIM=3\n\n\n\n THE ECHO OPERAND\n ________________\n\n\n Specifying  ECHO=YES  will  echo the command or reply of the TEXT\n operand to the console before the action is executed.  Specifying\n ECHO=LOG will echo the command or reply in the system log.   This\n provides  a  level  of  TSSO  accountability.    The  default  is\n ECHO=YES.\n\n\n\n ASSEMBLING AND LINK-EDITING THE TABLE\n _____________________________________\n\n\n Release 4.3 provides a sample  CLIST  for  assembling  and  link-\n editing the TSSO AOF table.  The CLIST makes the job of placing a\n new  AOF  table in production less cumbersome.  You will probably\n need to modify ASMTAB for your installation.  Its syntax is\n\n   ASMTAB table-name \u00ddRELOAD\u00a8\n          __________\n\n The CLIST can assemble a moderately sized  table,  link-edit  the\n result,  and copy the resulting load module into SYS1.TSSOLOAD in\n about  10  seconds.    The  RELOAD  parameter  will   issue   the\n TSSO #.RELOAD command upon successful assembly and link-edit.\n\n Alternately,  you can submit a batch job similar to the sample in\n the TSSO.VERS43.ASM data set, member ASMTABLE.  You may tailor  a\n copy of this data set to your specifications as follows:\n\n 1.  Include the appropriate installation-dependent information on\n     the JOB card.\n\n 2.  Change the SYSIN DD card to point to your AOF table.\n\n 3.  Change  the load library name in the LKED.SYSLMOD step to one\n     of your choice (e.g., TSSO.VERS43.LOAD).\n\n 4.  Change the NAME statement in the linkage editor control cards\n     to match the label on the TABSTART macro in your AOF table.\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             38\n\n\n\n\n\n\n\n\n\n Note that the Assembler parameters RENT and NOALIGN MUST be pres-\n                                                     ____\n ent.\n\n A return code of 0 indicates that the assembly was successful.\n\n WARNING:       UNDER NO CIRCUMSTANCES ATTEMPT TO LOAD A TABLE  IF\n              EITHER   THE  ASSEMBLY  OR  LINK  RETURN  CODES  ARE\n              NON-ZERO.\n\n\n\n STORING THE MODULE\n __________________\n\n\n When the table assembly is successful, copy the load module  from\n TSSO.VERS43.LOAD   (or   the   appropriate  data  set)  into  the\n SYS1.TSSOLOAD data set.  To activate the new AOF table,  use  the\n procedures as described previously in this document.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n TSSO AUTOMATED OPERATIONS FACILITY                             39\n\n\n\n\n\n\n\n\n\n TSSO NETWORK COMMUNICATION CONTROL FACILITY INTERFACE\n _____________________________________________________\n\n\n\n The  Network Communication Control Facility (NCCF) is an IBM pro-\n gram  product  that  provides  network  control  in  ACF/VTAM  or\n ACF/TCAM  environments.  Through the addition of an OSCMD command\n processor, NCCF allows a network operator to issue MVS, JES2,  or\n subsystem  commands  and to retrieve responses at the NCCF termi-\n nal.  The NCCF version of OSCMD is a completely  separate  entity\n from  the  TSO  version.   The command installs directly into the\n NCCF load library, or a concatenated data set, and is defined  to\n NCCF in the DSICMD member of the NCCF parameter data set.\n\n\n\n NOTES ON THE NCCF INTERFACE\n ___________________________\n\n\n o   The  NCCF  and  TSO  versions of OSCMD share the same pool of\n     subsystem consoles.  When defining the NUMCONS parameter (see\n     \"NUMCONS Parameter\" on page 12) it is important  to  consider\n     the number of simultaneous NCCF users that will be using TSSO\n     facilities.\n\n o   Although OSCMD runs with APF authority, NCCF does not require\n                                                  ________\n     APF  authorization  with this facility.   TSSO grants APF au-\n     thorization to the NCCF version of OSCMD  through  MVS  cross\n     memory  services.  The operator command #.Q XMEM monitors the\n     cross memory service environment.  A debug option displays  a\n     message  when  the  NCCF version of OSCMD has called the TSSO\n     cross memory services routine.\n\n o   TSSO assumes that all NCCF users are authorized to issue  MVS\n     master  console commands.  The NCFOSATH user exit is provided\n     for coding a routine to alter  the  default.    The  exit  is\n     passed the NCCF user identifier.\n\n o   The  TSSO/NCCF  OSCMD  facility fully supports the NCCF ROUTE\n     command.  This allows remote operators to route MVS, JES2, or\n     subsystem commands to remote systems and to retrieve the  re-\n     sponses.   This facility makes it possible for an operator to\n     control (or at least monitor) many MVS hosts  from  one  NCCF\n     console.\n\n\n\n\n\n\n TSSO NETWORK COMMUNICATION CONTROL FACILITY INTERFACE          40\n\n\n\n\n\n\n\n\n\n RECOVERY PROCEDURES\n ___________________\n\n\n\n TSSO  operates  as a proper subsystem under MVS. Because of this,\n it can run without support of a Job Entry Subsystem  or  communi-\n cations  subsystem.   Therefore, TSSO will initialize even if JES\n or VTAM will not.  Through the use of several command processors,\n TSSO provides facilities for repairing critical MVS files or load\n modules in the event a subsystem does not initialize.\n\n The EF command allows the MVS console  operator  to  perform  TSO\n edit  commands  on the file allocated to DDNAME \"EDITFILE\".  This\n DDNAME could have been pre-allocated through  the  ALLOCATE  com-\n mand.  The syntax of the EF command is\n\n   EF (;cmd1;cmd2;cmd3...;cmdn)\n        ______________________\n\n where cmd1 ...cmdn are TSO EDIT commands.\n       ____________\n\n The PDS command(6) allows you to rename, delete or otherwise  ma-\n nipulate  members of a partitioned data set.  The PDS command of-\n fers a wide range of facilities and can be used to recover from a\n variety of subsystem problems.  You are encouraged  to  obtain  a\n copy  of  the PDS command (Version 7.3) from the Connecticut Bank\n and Trust (CBT) mods tape.\n\n Lastly, you can also use the standard TSO facilities, such as the\n ALLOCATE command, to correct JCL or other  initialization  errors\n in  major subsystems.   The full range of TSO commands are avail-\n able to assist in problem resolution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n ----------------\n\n 6   A  public  domain TSO facility rewritten by Bruce Leland from\n     Cambridge Systems.\n\n\n RECOVERY PROCEDURES                                            41\n\n\n\n\n\n\n\n\n\n APPENDIX A. TSSO COMMAND REFERENCE\n __________________________________\n\n\n\n This appendix describes the TSO command processors that are  dis-\n tributed  with  TSSO.    Unless  otherwise  noted,  these command\n processors can be issued by TSO users as well as the TSSO subsys-\n tem.   The commands are documented  one-to-a-page  for  easy  in-\n sertion into existing operator procedure books.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             42\n\n\n\n\n\n\n ALTAOF                  TSSO User's Guide                  ALTAOF\n\n\n\n NAME:  ALTAOF\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      ALTOAF dynamically resets the MATCHLIM value for a given AOF\n      table  entry.    Note that resetting the MATCHLIM value to 0\n      effectively deletes the entry.\n\n      NOTE:    The ALTAOF command requires the  user  ID  invoking\n      the  command  to  have  the  X'C0'  bits  turned  on  in the\n      USERDATA(PSCBATR2) field in their UADS entry.   This can  be\n      accomplished through the USERDATA parameter of the CHANGE or\n      ADD subcommand of ACCOUNT.\n\n SYNTAX\n ______\n\n   ALTAOF ENTRY(entry-id) MATCHLIM(matchlim-value)\n               __________          ______________\n                              or\n                             MLIM(matchlim-value)\n                                  ______________\n\n PARAMETERS\n __________\n\n      entry-id         A 1- to 8-character ID for a TSSO/AOF table\n      ________\n                       entry  for which the MATCHLIM value will be\n                       changed.\n\n      matchlim-value   New MATCHLIM value.\n      ______________\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.   Reset the MATCHLIM value to 4 for  the  labeled\n                   \"VTAMUP\" entry in the active AOF table.\n\n                     ALTAOF ENTRY(VTAMUP) MATCHLIM(4)\n\n      EXAMPLE 2.   Delete  the  labeled \"OFFLINE\" entry in the ac-\n                   tive AOF table.\n\n                     ALTAOF ENTRY(OFFLINE) MATCHLIM(0)\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             43\n\n\n\n\n\n\n CACHE                   TSSO User's Guide                   CACHE\n\n\n\n NAME:  CACHE\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The  CACHE  command  controls  the  operation  of   3880-11,\n      3880-21,  3880-13 or 3880-23 cache devices from the MVS con-\n      sole.  As distributed by IBM, software support  for  control\n      of  these  devices is contained in the IDCAMS program avail-\n      able with MVS; the MVS console operator  cannot  control  or\n      even  query  the  device.   The CACHE command will format an\n      IDCAMS command, attach IDCAMS, and write the  results  using\n      the  PUTLINE  interface.   When issued under TSSO, these re-\n      sults are then displayed on the MVS console.\n\n SYNTAX\n ______\n\n        CACHE cache-device \u00ddaction\u00a8 \u00ddSUBSYS\u00a8 \u00ddLEGEND\u00a8\n              ____________  ______\n\n PARAMETERS\n __________\n\n      cache-device   A 3-digit UCB address or a 6-character volume\n      ____________\n                     serial.\n\n      action         Action to be performed by the CACHE command:\n      ______\n\n                     ON       Format the appropriate  IDCAMS  com-\n                              mand  (SETCACHE)  to  turn the cache\n                              unit on.\n\n                     OFF      Format the appropriate  IDCAMS  com-\n                              mand  (SETCACHE)  to  turn the cache\n                              unit off.\n\n                     LIST     Format a LISTDATA  command  to  list\n                              cache statistics (e.g., READ hit ra-\n                              tio).\n\n                     STATUS   (default)  Provide  information con-\n                              cerning the current  status  of  the\n                              cache device.\n\n      SUBSYS         Provide  information about the entire 3350 or\n                     3380 string.\n\n\n\n\n Appendix A. TSSO Command Reference                             44\n\n\n\n\n\n\n CACHE                   TSSO User's Guide                   CACHE\n\n\n\n      LEGEND         Provide a verbose Description of  the  format\n                     of  the IDCAMS output.  (This is probably in-\n                     appropriate for display at the console.)\n\n ISSUING OTHER IDCAMS COMMANDS WITH CACHE\n\n      There are some commands that you may want to  issue  to  the\n      cache  controller  through  IDCAMS that are not supported by\n      this command.  For these occasions, an alternate form of the\n      CACHE command is provided.\n\n             CACHE * CMD('idcams-cmd')\n                          __________\n\n      where idcams-cmd is any command accepted by  IDCAMS.    This\n            __________\n      can  be a cache command, such as BINDDATA, or a command that\n      has nothing to do with cache devices, such as LISTC.\n\n      NOTE:  To issue these commands under a  TSO  session,  first\n             execute the CLIST ALOCCACHE in TSSO.VERS43.ASM to al-\n             locate the needed data sets.\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Turn  on  the cache device for the volume at UCB\n                  263.\n\n                    CACHE 263 ON\n\n      EXAMPLE 2.  Turn off volume JESSPL to the cache device.\n\n                    CACHE JESSPL OFF\n\n      EXAMPLE 3.  Turn volume PGMPRO on to the cache device.\n\n                    CACHE PGMPRO ON\n\n      EXAMPLE 4.  Print status information for  the  cache  device\n                  covering volume PGMPRO.\n\n                    CACHE PGMPRO\n\n      EXAMPLE 5.  Print status information for all volumes covered\n                  by the cache device covering volume PGMPRO.\n\n                    CACHE PGMPRO SUBSYS\n\n\n\n\n Appendix A. TSSO Command Reference                             45\n\n\n\n\n\n\n CACHE                   TSSO User's Guide                   CACHE\n\n\n\n      EXAMPLE 6.  Print  statistics  for  the  cache device at UCB\n                  265.\n\n                    CACHE 265 LIST\n\n      EXAMPLE 7.  Issue the IDCAMS LISTC command  and  return  the\n                  reply to the invoking console.\n\n                    CACHE * CMD('LISTC')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             46\n\n\n\n\n\n\n CPCMD                   TSSO User's Guide                   CPCMD\n\n\n\n NAME:  CPCMD\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The  CPCMD  command allows the MVS operator of a virtual ma-\n      chine to issue CP commands on a VM/SP, VM/SP  HPO  or  VM/XA\n      system.    Any  CP  command  of the appropriate CP privilege\n      class is allowed.  The response of the command  is  returned\n      to  the  invoking console.  Note that this command will also\n      function under TSO and return the response to the CP command\n      to the invoking TSO user.\n\n SYNTAX\n ______\n\n        CPCMD cp-cmd\n              ______\n\n PARAMETERS\n __________\n\n      cp-cmd    Any VM CP command.\n      ______\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Issue the CP QUERY NAMES command and return  the\n                  response to the invoking console.\n\n                    CPCMD QUERY NAMES\n\n      EXAMPLE 2.  Direct  VM  to  attach  the device at 3F0 to the\n                  virtual machine configuration at virtual  device\n                  3F0.\n\n                    CPCMD ATTACH 3F0 * 3F0\n\n                  Note that the device must also be varied on-line\n                  by  the  MVS operator.   The MVS virtual machine\n                  would need command privilege class \"B\" to  issue\n                  this command.\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             47\n\n\n\n\n\n\n DISPAOF                 TSSO User's Guide                 DISPAOF\n\n\n\n NAME:  DISPAOF\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The DISPAOF command displays the contents of TSSO/AOF tables\n      which control the operation of the TSSO Automated Operations\n      Facility.    The DISPAOF command can query either the active\n      TSSO/AOF table or a table that has been assembled and is re-\n      siding on DASD.  By default, DISPAOF will  display  all  en-\n      tries  in  the  running  TSSO/AOF  table.    The information\n      displayed includes the TSSO/AOF table  name,  ID  parameter,\n      date  and time assembled, and TSSO version number.  For each\n      message displayed, the table entry ID, MSG ID, ACTION direc-\n      tive and ACTION TEXT will be  displayed.    TEST  conditions\n      will  not  be  displayed unless the TEST parameter is speci-\n      fied.  Optionally, the display can be  limited  to  selected\n      message IDs.\n\n      Information about alternate TSSO/AOF tables can be displayed\n      by  using  the table-name parameter.   Alternate tables must\n                     __________\n      previously have been assembled and placed  (in  load  module\n      form) into the SYS1.TSSOLOAD dataset.\n\n SYNTAX\n ______\n\n        DISPAOF \u00ddENTRY(entry-id)\u00a8 \u00ddMSG(msg-id)\u00a8\n                       ________\n                \u00ddTABLE(table-name)\u00a8 \u00ddTEST\u00a8\n                       __________\n\n PARAMETERS\n __________\n\n      ENTRY(entry-id)     A  1-  to  8-character ID of a AOF table\n                          entry.  Note that DISPAOF  will  display\n                          ALL  entries  that  start with the entry\n                          identifier; an exact match  is  not  re-\n                          quired (see examples).\n\n      MSG(msg-id)         A  1-  to 8-character message identifier\n                          specified in the TSSO/AOF TABENTRY macro\n                          MSG parameter.  Note that  DISPAOF  will\n                          display  ALL entries that start with the\n                          message identifier; an  exact  match  is\n                          not required (see examples).\n\n\n\n\n\n Appendix A. TSSO Command Reference                             48\n\n\n\n\n\n\n DISPAOF                 TSSO User's Guide                 DISPAOF\n\n\n\n      TABLE(table-name)   An  alternate  TSSO AOF table name.  The\n                          table must previously have  been  assem-\n                          bled and available to TSSO.\n\n      TEST                For  each message, display any TEST con-\n                          ditions that exist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             49\n\n\n\n\n\n\n DISPAOF                 TSSO User's Guide                 DISPAOF\n\n\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Display the running TSSO/AOF table with all mes-\n                  sage IDs, action directives, and action text.\n\n                    DISPAOF\n\n      EXAMPLE 2.  Display all entries in the running TSSO/AOF  ta-\n                  ble with a message ID of $HASP395.\n\n                    DISPAOF MSG($HASP395)\n\n      EXAMPLE 3.  Display  all  entries and all test conditions in\n                  the running AOF table for message ID $HASP350.\n\n                    DISPAOF MSG($HASP350) TEST\n\n      EXAMPLE 4.  Display all entries and all test conditions  for\n                  message IKT021D in load module AOFNEW.\n\n                    DISPAOF MSG(IKT021D) TABLE(AOFNEW) TEST\n\n      EXAMPLE 5.  Display  all  entries  in  the  active AOF table\n                  starting with \"VTAMUP\".\n\n                    DISPAOF ENTRY(VTAMUP)\n\n      EXAMPLE 6.  Display all entries  in  the  active  AOF  table\n                  with a message ID starting with \"$HASP\".\n\n                    DISPAOF MSG($HASP)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             50\n\n\n\n\n\n\n LINKLIST                TSSO User's Guide                LINKLIST\n\n\n\n NAME:  LINKLIST\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The  LINKLIST  command displays the list of the data sets in\n      the current MVS LNKLST concatenation.  This command is  only\n      valid  in  an MVS/XA environment, because the information is\n      not available in MVS/370.\n\n SYNTAX\n ______\n\n        LINKLIST\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             51\n\n\n\n\n\n\n OSASK                   TSSO User's Guide                   OSASK\n\n\n\n NAME:  OSASK\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      OSASK allows you to ask the operator a question  and  get  a\n      response.   If it is issued from a TSO command line, the re-\n      sponse goes to the user's terminal.  If it is issued from  a\n      CLIST, the response goes to CLIST variables (see below).\n\n SYNTAX\n ______\n\n        OSASK question\n              ________\n\n PARAMETERS\n __________\n\n      question    Question to be sent to the operator's console.\n      ________\n\n CLIST VARIABLES\n _______________\n\n\n      INPUT VARIABLES             DEFINITION\n      _______________   ____________________\n\n      REPLYWAIT         The  number  of seconds you are willing to\n                        wait for a reply to the  question.    This\n                        can  be  a  value from 1 to 60; default is\n                        60.\n\n\n      OUTPUT VARIABLES            DEFINITION\n      ________________  ____________________\n\n      REPLY             Text of the reply to the question.\n\n      REPLYW            The number of words in the operator's  re-\n                        ply.\n\n      REPLYWn           The nth word of the reply.\n                            _\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Ask the operator a question.\n\n                    OSASK WHAT TIME IS SHUTDOWN?\n\n      EXAMPLE 2.  Ask  the  operator  to specify type of start for\n                  production system.\n\n\n Appendix A. TSSO Command Reference                             52\n\n\n\n\n\n\n OSASK                   TSSO User's Guide                   OSASK\n\n\n\n                    OSASK BCR001I SPECIFY START FOR PROD SYS (WARM, COLD)?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             53\n\n\n\n\n\n\n OSCMD                   TSSO User s Guide                   OSCMD\n\n\n\n NAME:  OSCMD\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      OSCMD allows you to  issue  any  MVS  command  (JES2,  VTAM,\n      etc.).    If  it  is issued from a TSO command line, the re-\n      sponse is returned to the terminal.  If it is issued from  a\n      CLIST, the response can optionally go to the CLIST variables\n      (see  below).    Note  that,  when  OSCMD  is  issued from a\n      TSSO-initiated CLIST, OSCMD checks the authority of the  in-\n      voking  console  and  only  permits  commands of that level.\n      When issued by a TSO user, OSCMD checks the installation au-\n      thority of the user's ID.  By default, all  TSO  users  have\n      INFO-only  authority; system or I/O authority can be granted\n      on a per-user basis.   The installation can  control  access\n      through the OSCMDATH user exit.\n\n SYNTAX\n ______\n\n        OSCMD mvs-cmd\n              _______\n\n PARAMETERS\n __________\n\n      os-cmd      Any MVS command.\n      ______\n\n CLIST VARIABLES\n _______________\n\n\n      INPUT VARIABLES                    DEFINITION\n      _______________          ____________________\n\n      CMDRESP=dest             Destination of OSCMD response:\n\n                               CLIST     return  response to CLIST\n                                         variables (see below)\n\n                               TERM      return  response  to  TSO\n                                         user's terminal\n\n                               NOWHERE   discard the response (TSO\n                                         users) or return response\n                                         to                console\n                                         (TSSO-initiated commands)\n\n      CMDWAIT=nn               Maximum number of seconds  you  are\n                               willing  to wait for the command to\n\n\n Appendix A. TSSO Command Reference                             54\n\n\n\n\n\n\n OSCMD                   TSSO User s Guide                   OSCMD\n\n\n\n                               finish.  nn is a value  from  1  to\n                                        __\n                               60;  default is 1 for nonCLIST exe-\n                               cution.   If the CMDWAIT  value  is\n                               exceeded,  the  only  response  re-\n                               turned will be an echo of the  ori-\n                               ginal  OSCMD.    If TSSO can detect\n                               the  end  of  a  command   response\n                               (e.g.,   responses  using  MLWTOs),\n                               then OSCMD will not  need  to  wait\n                               the full value of CMDWAIT.\n\n      MAXCMDOUT=nnn            Maximum number of lines of response\n                               you want returned from the command.\n                               nnn  is  a value from 1 to 200; de-\n                               ___\n                               fault  is  200  for  nonCLIST  exe-\n                               cution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             55\n\n\n\n\n\n\n OSCMD                   TSSO User s Guide                   OSCMD\n\n\n\n      OUTPUT VARIABLES              DEFINITION\n      ________________    ____________________\n\n      CMDOUT              The  number of lines returned in the re-\n                          sponse.\n\n      CMDOUTm             The mth line returned in  the  response.\n                              _\n                          m is a value from 1 to 200.\n                          _\n                          NOTE:   CMDOUT1 is always an echo of the\n                          original command.\n\n      CMDOUTmW            The number of words in the mth  line  of\n                                                     _\n                          the response.\n\n      CMDOUTmWn           The  mth  line,  the nth word in the re-\n                               _               _\n                          sponse line.  n is a value from 1 to 20.\n                                        _\n\n EXAMPLES\n ________\n\n      See   members   EXJOBS,    EXCKSPL,    and    EXSTVTAM    in\n      TSSO.VERS43.ASM.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             56\n\n\n\n\n\n\n OSPAUSE                 TSSO User's Guide                 OSPAUSE\n\n\n\n NAME:  OSPAUSE\n _____\n\n DESCRIPTION\n ___________\n\n      OSPAUSE  delays  processing  of  a command for the specified\n      number of seconds.  This is useful if the CLIST initiates  a\n      started task and must wait for it to initialize.\n\n SYNTAX\n ______\n\n        OSPAUSE seconds\n                _______\n\n PARAMETERS\n __________\n\n      seconds   The number of seconds that the CLIST should be de-\n      _______\n                layed.\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Delay the CLIST 10 seconds.\n\n                    OSPAUSE 10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             57\n\n\n\n\n\n\n OSWAIT                  TSSO User's Guide                  OSWAIT\n\n\n\n NAME:  OSWAIT\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      OSWAIT  directs TSSO to wait for a particular system message\n      or a timeout limit to occur before proceeding.   These  mes-\n      sages  are  defined in the AOF table.  OSWAIT is intended to\n      be issued from a CLIST.\n\n      If the message appears, OSWAIT gives  a  return  code  of  0\n      (RC=0).    If OSWAIT was issued from a terminal, the message\n      prints at the terminal.  Otherwise, the CLIST variables  are\n      populated  (see  below).   If the message does not appear by\n      the timeout limit, OSWAIT gives a return code of 8 (RC=8).\n\n SYNTAX\n ______\n\n        OSWAIT ENTRY(entry-id) TIMEOUT(nnnnn)\n                     ________          _____\n\n PARAMETERS\n __________\n\n      entry-id  The 1- to 8-character identifier of the AOF  table\n      ________\n                entry.\n\n      nnnnn     The number of second to wait before timeout, maxi-\n      _____\n                mum 86400 seconds.\n\n CLIST VARIABLES\n _______________\n\n\n      OUTPUT VARIABLES              DESCRIPTION\n      ________________    _____________________\n\n      WTO                 Text of the message\n\n      WTOW                Number of words in the message\n\n      WTOWn               Nth word of the message\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Wait 2 minutes for message IST020I to appear.\n\n                    OSWAIT ENTRY(IST020I) TIME(120)\n\n\n\n\n Appendix A. TSSO Command Reference                             58\n\n\n\n\n\n\n OSWTO and OSWTOH        TSSO User's Guide        OSWTO and OSWTOH\n\n\n\n NAME:  OSWTO and OSWTOH\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      OSWTO  and  OSWTOH allow you to write messages to the opera-\n      tor's console.  OSWTOH highlights the message.   These  com-\n      mands can be issued only from a TSSO-initiated CLIST.\n\n SYNTAX\n ______\n\n        OSWTO message\n              _______\n\n        OSWTOH message\n               _______\n\n PARAMETERS\n __________\n\n      message     The text of the message to be sent to the opera-\n      _______\n                  tor.\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Notify the operator of an IPL in progress.\n\n                    OSWTO BCR101I AUTOMATED IPL IN PROGRESS\n\n      EXAMPLE 2.  Send a highlighted message to the operator.\n\n                    OSWTOH BCR102I SYSTEM SHUTDOWN COMPLETE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             59\n\n\n\n\n\n\n REPLY                   TSSO User s Guide                   REPLY\n\n\n\n NAME:  REPLY\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The  REPLY command is used to reply to MVS WTOR messages af-\n      ter  the WTOR has appeared on the MVS console.(7) You do not\n      need to know the MVS reply number to respond  to  the  WTOR.\n      The REPLY command can, therefore, be used to automate opera-\n      tional  procedures with products that communicate to the op-\n      erator through the WTOR interface (e.g., NCCF, IMS, GDDM).\n\n SYNTAX\n ______\n\n        REPLY MSG(msg-id) TEXT(reply-text)\n                  ______       __________\n\n PARAMETERS\n __________\n\n      MSG(msg-id)       The message you  are  replying  to  (e.g.,\n                        DSI802A)\n\n      TEXT(reply-text)  The  text of the reply you wish to give in\n                        response to the WTOR.\n\n NOTES ON USING REPLY WITH IMS/VS\n ________________________________\n\n      There are some installations that run multiple copies of the\n      IMS/VS program product.   All of the  subsystems  issue  the\n      same  message ID as a WTOR.  For these installations, an al-\n      ternate form of the REPLY command is available to direct re-\n      plies to the correct IMS subsystem:\n\n             REPLY IMS(ims-id) TEXT(reply-text)\n                       ______       __________\n\n      where ims-id is the name of the IMS subsystem to  which  you\n            ______\n      wish  to  direct  the response, and reply-text is as defined\n                                          __________\n      above.  In this way IMS procedures can be automated.\n\n EXAMPLES\n ________\n\n ----------------\n\n 7   Contrast this to  the  ACTION=REPLY  directive  in  TSSO/AOF,\n     which  replies  to  messages  the instant they are generated.\n     Thus, TSSO/AOF and the REPLY command  combine  to  give  full\n     coverage on automating responses to MVS WTORs.\n\n\n Appendix A. TSSO Command Reference                             60\n\n\n\n\n\n\n REPLY                   TSSO User s Guide                   REPLY\n\n\n\n      EXAMPLE 1.  Shut down the NCCF program product.\n\n                    REPLY MSG(DSI802A) TEXT('CLOSE IMMED')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             61\n\n\n\n\n\n\n REPLY                   TSSO User s Guide                   REPLY\n\n\n\n      EXAMPLE 2.  Reply to message USRWT01.\n\n                    REPLY MSG(USRWTO1) TEXT('DISPLAY FIELDS')\n\n      EXAMPLE 3.  Issue the IMS command DISPLAY ACTIVE on IMS sub-\n                  system ZFF.\n\n                    REPLY IMS(ZFF) TEXT('/DIS A')\n\n      EXAMPLE 4.  Issue the IMS command NRESTART on IMS  subsystem\n                  PRO.\n\n                    REPLY IMS(PRO) TEXT('NRE CHECKPOINT 0 FMT ALL')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             62\n\n\n\n\n\n\n SPMON                   TSSO User's Guide                   SPMON\n\n\n\n NAME:  SPMON\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The  SPMON  command  displays  system information to the MVS\n      console operator.  By default SPMON will display the follow-\n      ing information:  percentage of CPU busy,  average  Unrefer-\n      enced  Interval  Count (UIC), average paging rate, number of\n      TSO users, number of started tasks, number  of  batch  jobs,\n      and  number of inactive initiators.  In addition, if Parame-\n                     ________\n      ters are specified to SPMON, the following  job-related  in-\n      formation  is printed:   JOBNAME, number of service units in\n      current transaction, swap-in/swap-out status, and number  of\n      active frames in real storage.\n\n SYNTAX\n ______\n\n        SPMON  \u00ddjob-parm \u00ddtype-parm\u00a8\u00a8\n                ________  _________\n\n PARAMETERS\n __________\n\n      job-parm    A  1-  to 8-character string for matching on job\n      ________\n                  name, or \"ALL\" to  display  information  on  all\n                  jobs.\n\n      type-parm   This  directs  SPMON  to print information about\n      _________\n                  selected types of jobs.   Legal values  are  JOB\n                  (all  batch  jobs), STC (all started tasks), TSO\n                  (all TSO users), or ALL (all batch jobs, started\n                  tasks, and TSO users).  Default is ALL.\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Display the general system information only.\n\n                    SPMON\n\n      EXAMPLE 2.  Display general system information  as  well  as\n                  information  on  all  jobs, TSO users or started\n                  tasks that start with \"BCR\".\n\n                    SPMON BCR\n\n\n\n\n\n Appendix A. TSSO Command Reference                             63\n\n\n\n\n\n\n SPMON                   TSSO User's Guide                   SPMON\n\n\n\n      EXAMPLE 3.  Display general system information and  informa-\n                  tion  about  all  TSO users whose user IDs begin\n                  with \"PY\".\n\n                    SPMON PY TSO\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             64\n\n\n\n\n\n\n VALLOC and VOLSER       TSSO User's Guide       VALLOC and VOLSER\n\n\n\n NAME:  VALLOC and VOLSER\n _____\n\n AVAILABLE UNDER TSO:  Yes\n ____________________\n\n DESCRIPTION\n ___________\n\n      The VALLOC and VOLSER commands display  UCB  and  ALLOCATION\n      information.  By default, the commands will display informa-\n      tion for the MVS SYSRES (IPL) device.  If a volume serial is\n      specified,  the  command  will  locate  the device using the\n      standard MVS UCBSCAN service and display the UCB address and\n      the UCB itself.(8) The command will also inform the MVS  op-\n      erator if the volume is not found.\n\n SYNTAX\n ______\n\n        VALLOC \u00ddvolser\u00a8\n                ______\n\n        VOLSER \u00ddvolser\u00a8\n                ______\n\n PARAMETERS\n __________\n\n      volser    A  6-character DASD volume identifier.\n      ______\n\n EXAMPLES\n ________\n\n      EXAMPLE 1.  Display  the UCB address and allocation informa-\n                  tion for volume PPBFX2.\n\n                    VALLOC PPBFX2\n\n      EXAMPLE 2.  Display UCB information for the MVS SYSRES (IPL)\n                  pack.\n\n                    VOLSER\n\n\n ----------------\n\n 8   The commands use the TSSO \"*COM\" interface to issue appropri-\n     ate MVS commands.  to display UNIT or ALLOCATION information.\n     The VOLSER command issues the \"D U,,,ucb-address,1\" MVS  sys-\n                                          ___________\n     tem   command,   while   the   VALLOC   command   issues  the\n     \"D U,,ALLOC,ucb-address,1\" MVS command.  Note that, when this\n                 ___________\n     command is issued under regular TSO, the MVS commands are not\n     generated and the invoker of the command will see the format-\n     ted command including the *COM keyword.\n\n\n Appendix A. TSSO Command Reference                             65\n\n\n\n\n\n\n VALLOC and VOLSER       TSSO User's Guide       VALLOC and VOLSER\n\n\n\n      EXAMPLE 3.  Display the UCB address for volume SYSRES.\n\n                    VOLSER SYSRES\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix A. TSSO Command Reference                             66\n\n\n\n\n\n\n APPENDIX B. TSSO CONTROL COMMANDS\n _________________________________\n\n\n\n TSSO control commands are used to direct TSSO  processing.    All\n such  commands  start  with the TSSO System Recognition Character\n (SRC).  The Examples below assume that \"#\" is the TSSO SRC.\n\n Note that TSSO control commands may be treated exactly  as  other\n TSO commands when used in a TSSO CLIST.  For example, a CLIST may\n process directives and then issue a .RELOAD command to reload the\n TSSO/AOF  table.    It is also possible for a CLIST to consist of\n nothing but TSSO commands. For example, a CLIST could be  written\n to query all the TSSO Parameters.\n\n\n\n GENERAL COMMANDS\n ________________\n\n\n #.L N                       List the results of the previous TSSO\n                             commands on console n.\n                                                 _\n\n #.LOGOFF                    Logs off the console.\n\n #.LOGON USER-ID PASSWORD    Logs on the invoking console to TSSO.\n\n\n Various Parameters of the TSSO subsystem can be queried using the\n #.Q family of commands.\n\n #.Q LOGON                   Displays  the console ID and the user\n                             ID of all consoles logged on to TSSO.\n\n #.Q MAXCMD                  Returns the value of the MAXCMDS  pa-\n                             rameter specified at TSSO startup.\n\n #.Q MAXWTO                  Returns  the  value of the MAXWTO pa-\n                             rameter specified at TSSO startup.\n\n #.Q RACF                    Returns the name  of  the  TSSO  RACF\n                             user identifier.\n\n #.Q SCON                    Displays the status of subsystem con-\n                             soles.\n\n #.Q SWAP                    Indicates  if  TSSO  is  running non-\n                             swappable.\n\n #.Q T                       Returns the name of the TSSO AOF  ta-\n                             ble.    Additional  information  dis-\n\n\n Appendix B. TSSO Control Commands                              67\n\n\n\n\n\n\n                             played includes the  value  specified\n                             on  the  ID parameter of the TABSTART\n                                      __\n                             macro and the date and time  the  AOF\n                             table was assembled.\n\n #.Q TIMEOUT                 Displays the TIMEOUT value.\n\n #.Q VERS                    Displays  the TSSO Version identifier\n                             (TSSO 4.3) and  the  date  and  times\n                             that  the TSSO, TSSOWTO, and the sub-\n                             system  interface  intercept  modules\n                             were last assembled.\n\n #.Q XMEM                    Displays  status of TSSO cross memory\n                             services environment.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix B. TSSO Control Commands                              68\n\n\n\n\n\n\n RESTRICTED COMMANDS\n ___________________\n\n\n The following commands are restricted to consoles with MVS system\n authority.\n\n #.ABEND               Abnormally  terminates  the  TSSO   address\n                       space.  This  is a TSSO debugging aid which\n                       should not be used in normal operation.\n\n #.J                   Requests a job identification  number  from\n                       the primary subsystem.  This is required if\n                       TSSO  will be using the primary subsystem's\n                       services.  These services  include  submit-\n                       ting jobs (with the TSO SUBMIT command) and\n                       using  the  PRINTOFF command.  Note that if\n                       TSSO was started using the  \"SUB=JES2\"  pa-\n                       rameter, this command will have no effect.\n\n #.M                   Manipulates  the  TSSO  debugging facility.\n                       This  command  should  not  be  used  under\n                       normal circumstances.\n\n #.P                   Terminates  the  Time Sharing Subsystem Op-\n                       tion.  TSSO can be restarted through the \"S\n                       TSSO\" command as described on page 13.\n\n #.RELOAD TABLE-NAME   Loads a TSSO Automated Operations  Facility\n                       table identified by table-name and performs\n                                           __________\n                       a  \"#.Q  T\" (see previous page).  If table-\n                                                            ______\n                       name='NONE', then the AOF  is  deactivated.\n                       ____\n                       If an error occurs while processing the ta-\n                       ble,  AOF  is deactivated.  The most common\n                       errors include table-name not  being  found\n                                      __________\n                       and  table-name  not being a valid TSSO AOF\n                            __________\n                       table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix B. TSSO Control Commands                              69\n\n\n\n\n\n\n APPENDIX C. TSSO PROCESSING MODULES\n ___________________________________\n\n\n\n $ENDOFDA       Sample IEFBR14 job: AOF can trap the  END  OF  JOB\n                message\n\n $PAYROLL       Same as above.\n\n ALOCCACH       Sample  CLIST  to allocate files needed to run the\n                cache command from a TSO user ID.\n\n ALTAOF         ALTAOF command:  Change MATCHLIM  dynamically  for\n                TSSO/AOF\n\n AOFIVP         Sample  AOF table that shows all forms of TABENTRY\n                macro.\n\n ASMALL         PROC to assemble all TSSO processing modules.\n\n ASMONE         PROC to assemble one TSSO processing module.\n\n ASMTABLE       PROC to assemble an AOF table.\n\n ASMTSSO        PROC to assemble all TSSO subsystem modules.  This\n                is need if the TSSOCVT or TSSODATD  macro  is  al-\n                tered.\n\n CACHE          CACHE  command:    Controls  a  3880 CACHE control\n                unit.\n\n COPYPROC       PROC to copy  the  sample  TSSO  START  PROC  into\n                SYS1.PROCLIB.\n\n CPCMD          CPCMD  command:  Issue a CP command if running un-\n                der VM.\n\n DATAAREA       An non-comprehensive list of the major  TSSO  data\n                areas.\n\n DISPAOF        DISPAOF  command:   Displays an active or inactive\n                AOF table.\n\n EF             EF command:   Allows a file  to  be  edited  under\n                TSSO.\n\n EQUATES        Standard R0-R15 equate macro.\n\n EXASK          Sample CLIST using the OSASK command.\n\n\n\n\n Appendix C. TSSO Processing Modules                            70\n\n\n\n\n\n\n EXCHKSPL       Sample  CLIST using OSCMD command and manipulation\n                of the response.\n\n EXJOBS         Another example using OSCMD.\n\n EXSTVTAM       An example of OSCMD without response retrieval.\n\n FORMAT         Macro to format numbers from assembler programs.\n\n GENTAPE        PROC to generate the TSSO distribution tape.\n\n GETCVT         Macro to find the TSSO CVT (SSCTSUSE field in TSSO\n                SSCT).\n\n ISXA           Macro  to  determine  if  you  are  running  under\n                MVS/XA.\n\n JCECVT         Subroutine for decimal/hex conversions.\n\n LINKLIST       LINKLIST command:  Displays the MVS LNKLST concat-\n                enation.\n\n MENTER         Macro for beginning subroutine linkage.\n\n MLEAVE         Macro for closing subroutine linkage.\n\n MULT           Bill  Godfrey's MULT command:  Allows you to enter\n                multiple commands on a line.   Great for  commands\n                that have subcommands.\n\n NCFOSATH       The NCCF user authorization exit.\n\n NCFOSCMD       The NCCF version of the OSCMD command processor.\n\n OPCMDMSG       A message CSECT for callers of TSSOPCMD.\n\n OSASK          OSASK command:  Ask the operator a question.\n\n OSCMD          OSCMD command:  Issue an MVS command and get a re-\n                sponse.\n\n OSCMDICB       OSCMD  Interface Control Block:  for communication\n                between OSCMD and TSSOSS09.\n\n OSCMDATH       The user exit for the OSCMD TSO facility.\n\n OSCMDICB       OSCMD Interface Control  Block  for  communication\n                between TSSOPCMD and TSSOSS09.\n\n OSPAUSE        OSPAUSE command:  Delay the execution of a CLIST.\n\n\n\n Appendix C. TSSO Processing Modules                            71\n\n\n\n\n\n\n OSWAIT         The OSWAIT command processor.\n\n OSWTO          OSWTO command:  Issue a message to the operator.\n\n PTFS           A summary of the PTFs in TSSO 4.2 that are in 4.3.\n\n RELGDE41       TSSO 4.1 release guide.\n\n RELGDE42       TSSO 4.2 release guide.\n\n RELGDE43       TSSO 4.3 release guide.\n\n REPLY          REPLY  command:   Issue a REPLY command by message\n                ID.\n\n REPLYLOA       REPLYLOA module:  Performs X-MEM functions for RE-\n                PLY command.\n\n RUNASM         PROC for assembling TSSO commands.\n\n SAMPPARM       Sample Parameters for SYS1.PARMLIB(TSSOPARM).\n\n SETMODE        Macro for changing mode (24 bit - 31 bit).\n\n SETPARSE       Macro for setting up IKJPARS control blocks.\n\n SPMON          SPMON command for performance monitoring.\n\n SSCONCB        Subsystem Control Control Block DSECT.\n\n SSCOBCBH       DSECT for the SSCONCB header.\n\n SSID           SSID macro for obtaining SMF system ID.\n\n TABEND         TABEND macro for defining end of AOF table.\n\n TABENTRY       TABENTRY macro for defining AOF table entries.\n\n TABSTART       TABSTART macro for defining start of AOF table en-\n                tries.\n\n TLINE          TLINE macro for doing TPUT of character string.\n\n TSSLRACF       TSSLRACF subroutine for doing RACINITS in  #.LOGON\n                command.\n\n TSSO           TSSO mainline processing module.\n\n TSSOCCMD       TSSOCCMD subroutine for handling TSSO control com-\n                mands.\n\n\n\n Appendix C. TSSO Processing Modules                            72\n\n\n\n\n\n\n TSSOCMND       TSSOCMND  macro  for  defining  control  block  to\n                interface  between  TSSO  and  TSSOSS10   (CMDRING\n                DSECT).\n\n TSSOCVT        Mapping macro for TSSO's CVT.\n\n TSSODATD       Mapping macro for TSSO's private data area.\n\n TSSODOCM       TSSODOCM  subroutine for handling TSO commands un-\n                der TSSO.\n\n TSSOESTA       TSSOESTA subroutine for handling TSSO errors.\n\n TSSOGAPF       TSSO cross memory services routine to get APF  au-\n                thorized.\n\n TSSOGSSC       Interface for subsystem allocatable consoles.\n\n TSSOINIT       TSSO routine for IPL time initialization.\n\n TSSOINI1       TSSO initialization, part 1.\n\n TSSOINI2       TSSO initialization, part 2.\n\n TSSOINI3       TSSO initialization, part 3.\n\n TSSOINI4       TSSO initialization, part 4 (SS consoles).\n\n TSSOINI5       TSSO initialization, part 5 (XMEM services).\n\n TSSOMAIN       TSSO mainline routine for processing TSO commands\n\n TSSONDSA       TSSO Non-Disruptable System Area DSECT.\n\n TSSOPARS       Subroutine for parsing just about anything.\n\n TSSOPCMD       Routine  to  process operating system commands and\n                return the responses to a buffer.\n\n TSSOPREC       Recovery routine for TSSOPCMD.\n\n TSSOPROC       A sample proc for starting TSSO (S TSSO).\n\n TSSOSECR       Macro to map the TSSO security control block.\n\n TSSOSS09       TSSO WTO intercept routine (subsys code 9).\n\n TSSOSS10       TSSO Command intercept routine (subsys code 10).\n\n TSSOTERM       Module for handling TSSO termination.\n\n\n\n Appendix C. TSSO Processing Modules                            73\n\n\n\n\n\n\n TSSOWTO        Module for copying SYSTSPRT file to console  after\n                commands.\n\n UNDERTSO       Macro to determine if you are running under TSO.\n\n USEGDE41       The user's guide for TSSO 4.1.\n\n USEGDE42       The user's guide for TSSO 4.2.\n\n UG43IMPT       A  pre-formatted copy of the TSSO USER'S GUIDE for\n                                             _________________\n                version 4.3 for dumping to an impact printer.\n\n UG43RAW        The raw source for the TSSO USER'S GUIDE for  ver-\n                                       _________________\n                sion 4.3, complete with SCRIPT control words.\n\n UG43TERM       A  pre-formatted copy of the TSSO USER'S GUIDE for\n                                             _________________\n                version 4.3 for browsing at a terminal.\n\n VALLOC         Command for displaying MVS allocation information.\n\n VOLSER         Command for displaying MVS UCB information.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Appendix C. TSSO Processing Modules                            74\n\n\n\n\n\n\n APPENDIX D. TSSO/AOF TEXT PROCESSING ALGORITHM\n ______________________________________________\n\n\n\n This section describes the algorithm used in forming the MVS  op-\n erator commands issued as a result of processing the ACTION=OSCMD\n directive under the TSSO Automated Operations Facility.\n\n\n\n DEFINITION OF TERMS\n ___________________\n\n\n      action-text  is  the parameter specified in the TEXT operand\n                   of the TABENTRY macro.\n\n      WTOTEXT      is the text of the  console  message  that  was\n                   matched  by  the  MSG parameter. Therefore, the\n                   first 8 bytes of WTOTEXT must have  matched  an\n                   entry in the AOF table, as specified by the MSG\n                   parameter.\n\n      cmd-buffer   is  the buffer that will be passed to MVS to be\n                   executed as an operator command.\n\n\n\n ALGORITHM\n _________\n\n\n 1.  Examine the MATCHLIM value for an entry.  If MATCHLIM=999999,\n     then ignore.  If MATCHLIM=0, then do not process  the  entry;\n     otherwise, decrement MATCHLIM by 1.\n\n 2.  Copy  characters from action-text to cmd-buffer until no more\n                           ___________    __________\n     characters are found, or a \"\\\" is located. The \"\\\" is a  sig-\n     nificance  indicator that indicates to AOF that characters or\n     words from WTOTEXT are to be copied.  When a significance in-\n     dicator is detected, go to step 2. When  no  more  characters\n     remain in action-text, pass the command to MVS for processing\n               ___________\n     and terminate.\n\n 3.  The character after the significance indicator determines the\n     type  of  formatting to be performed. Two characters are per-\n     missible. The \"S\" directive  indicates  substring  formatting\n     and the \"W\" directive indicates word formatting. If the char-\n     acter  is  a \"S\", go to step 3; if the character is a \"W\", go\n     to step 4.\n\n 4.  To use substring formatting, the syntax, including the  lead-\n     ing \"\\S\" must be\n\n\n Appendix D. TSSO/AOF Text Processing Algorithm                 75\n\n\n\n\n\n\n       \\Snnn,yy\\\n         ______\n\n     where  nnn  are  numeric characters that specify the starting\n            ___\n     position in WTOTEXT, and the yy indicates the number of char-\n                                  __\n     acters starting from position nnn to copy  into  the  command\n                                   ___\n     buffer.    Thus,  it  is  possible  to include all or part of\n     WTOTEXT in the operator command to be issued.   For  example,\n     if\n\n       \\S032,08\\\n\n     was coded, then character positions 32-39 of WTOTEXT would be\n     copied  to cmd-buffer. The syntax for the substring parameter\n                __________\n     is very rigid.   Leading zeroes must be  specified,  and  the\n     final  \"\\\"  must be present.   Processing continues at step 1\n     with the character following the final \"\\\"\n\n 5.  A word is defined as a string of characters separated by sep-\n     arator characters. The maximum size of a word is 16 bytes. To\n     use the word formatting option, code\n\n       \\Wabcdnn\\\n         ______\n\n     where a, b, c and d specify separator characters to  be  used\n           _______     _\n     in  the definition of a word, and nn is a numeric value indi-\n                                       __\n     cating which word to use. The selected word is then copied to\n     cmd-buffer.  For example, if\n     __________\n\n       \\W=,   03\\\n\n     were coded, it would be interpreted as word  formatting  with\n     the next four characters  \"=\", \",\", \" \", and \" \" used as word\n     separator  characters.    In  this example, the third word is\n     copied from WTOTEXT into cmd-buffer. The Syntax  of  the  \"W\"\n                              __________\n     directive  if  very strict. If you do not need four separator\n     characters, you must code blanks (as in the example). The nu-\n     meric specification must have two digits (including a leading\n     zero if required) and the terminating \"\\\" is required.  Proc-\n     essing  continues at step 1, with the character following the\n     last \"\\\".  Note that a word is  at  most,  16  characters  in\n     length, and is copied to cmd-buffer without leading or trail-\n                              __________\n     ing blanks.\n\n Note   that   the   formatting  options  are  available  only  if\n ACTION=OSCMD or ACTION=OSCMDT is specified.\n\n\n\n\n\n\n\n\n Appendix D. TSSO/AOF Text Processing Algorithm                 76\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNDERTSO": {"ttr": 45828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x00\\x19\\x00\\x19\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "TSSO403"}, "text": "         MACRO\n&LOCLBL  UNDERTSO &YES=,&NO=\n.*                                                                   *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n.*                                                                   *.\n.*  ISYES          IDENTIFY WHETHER OR NOT TSO     IS BEING USED     *.\n.*                                                                   *.\n.*                 TAKES A BRANCH DEPENDING ON WHICH PARMS ARE       *.\n.*                 SPECIFIED                                         *.\n.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *.\n         AIF   ('&YES' EQ '' AND '&NO' EQ '').ERR\n&LOCLBL  DS    0H                      REG &R --> REAL CVT\n         L     R14,X'224'              GET ASCB ADDRESS\n         L     R14,60(R14)             GET ASCBTSB FIELD\n         LTR   R14,R14                 IF ZERO, NOT UNDER TSO\n         AIF   ('&YES' EQ '').GEN370\n         BNZ   &YES\n.GEN370  ANOP\n         AIF   ('&NO' EQ '').EXIT\n         BZ    &NO\n         AGO   .EXIT\n.EXIT    ANOP\n         MEXIT\n.ERR     MNOTE 8,'*** UNDERTSO ERROR, MUST SPECIFY YES OR NO '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "USEGDE41": {"ttr": 45830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x0b\\x93\\x0b\\x93\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 2963, "newlines": 2963, "modlines": 0, "user": "TSSO403"}, "text": "       subject: Time Sharing Subsystem        date: February 5, 1985\n                Option (TSSO) Systems\n                Programming Reference         from: M. A. Schare\n                - Case 25820-I0200                  PY 25821\n                                                    2C-209 x2796\n\n\n\n                           U S E R S   G U I D E\n\n\n\n       INTRODUCTION\n\n       This document  provides  a  general  overview  of  the  Time\n       Sharing  Subsystem  Option  (TSSO),  a  package  designed to\n       increase operator productivity  by  automating  tasks  which\n       need  not  be performed manually. TSSO performs its function\n       through two integrated components. The Operator Productivity\n       Facility   (OPF)  extends  the  power  of  TSO  to  the  MVS\n       operator's console, while the Automated Operations  Facility\n       (AOF)  enhances  an installation's ability to control system\n       events based  on  console  message  traffic.  This  document\n       offers   information  on  the  installation  of  TSSO,  TSSO\n       parameters, and the use of the two components.\n\n       CURRENT_VERSION\n\n       This document describes the  function  of  TSSO  Version  4,\n       Release  1  (TSSO  4.1).  All features described herein will\n       continue to work on subsequent versions of the Time  Sharing\n       Subsystem  Option  unless  specified  in a future version of\n       this document. A description of the  new  features  of  TSSO\n       Version   4.1  can  be  found  in  member  RELGUIDE  in  the\n       TSSO.VERS41.ASM dataset.\n\n       INSTALLATION\n\n       TSSO is distributed in a single partitioned data set,  which\n       contains  all  source modules, procedures and documentation.\n       Although this dataset  may  be  called  by  any  name,  this\n       document   assumes   a   name   of   TSSO.VERS41.ASM.    The\n       installation of TSSO is outlined in the  following  step  by\n       step procedure.\n\n         1.  First, download the TSSO.VERS41.ASM dataset  to  DASD.\n             About  3  cylinders of 3380 space is required.  If you\n             received your copy of the TSSO subsystem from the  CBT\n             tape, simply copy it to a dataset by this name. If you\n             received a tape, then the TSSO subsystem is in IEBCOPY\n             format,  on  the  first  file.   The tape will be non-\n\n\n\n\n\n\n\n\n\n\n\n                                  - 2 -\n\n\n\n             labeled,  so  use  the  LABEL=(1,NL)  parameter   when\n             downloading TSSO.\n\n         2.  Next,  create  a   dataset,   TSSO.VERS41.LOAD,   with\n             RECFM=U,   LRECL=0,   BLKSIZE=13030,   DSORG=PO.  This\n             dataset will be an intermediate  dataset  to  assemble\n             TSSO  modules.  Create another dataset, SYS1.TSSOLOAD,\n             to contain the TSSO production modules.  This  dataset\n             should   have   the   same   DCB   characteristics  as\n             TSSO.VERS41.LOAD.\n\n         3.  The next step calls for assembly of  the  TSSO  source\n             modules.   A   procedure,  ASMALL,  contained  in  the\n             TSSO.VERS41.ASM dataset, has been set up to assist  in\n             this  task. TSSO Version 4.1 contains 18 modules to be\n             assembled. You will need to EDIT this dataset  to  put\n             in   installation   jobcards   and   local  accounting\n             information. If you will be running the TSSO subsystem\n             on  MVS/370, or both MVS/370 and MVS/XA, the SYSLIB DD\n             statement must be  pointing  to  the  SYS1.MACLIB  and\n             SYS1.AMODGEN  datasets  for  MVS/370.  If  you will be\n             running  the  subsystem  exclusively  on  MVS/XA,  the\n             SYSLIB  DD  statement  may point to the XA versions of\n             SYS1.MACLIB and SYS1.AMODGEN.\n\n         4.  Copy the load modules from TSSO.VERS41.LOAD  into  the\n             production    library   SYS1.TSSOLOAD.   The   library\n             TSSO.VERS41.LOAD should remain on  the  system  as  an\n             intermediate  library,  to contain assembled TSSO load\n             modules, and assembled Automated  Operations  Facility\n             tables.\n\n         5.  The SYS1.PARMLIB dataset must be updated with  one  or\n             more  TSSO  parameter  decks.  The  default  member is\n             TSSOPARM, however, alternate members may  be  selected\n             when  TSSO  is  started.  The  next  section  provides\n             details on TSSO parameters, and attachment 4 gives  an\n             example  of  a TSSO parameter deck. Note that the TSSO\n             parameter decks must be located  in  SYS1.PARMLIB,  as\n             TSSO will dynamically allocate this dataset.  A sample\n             TSSO parameter deck may be found in member SAMPPARM in\n             the TSSO.VERS41.ASM dataset.\n\n         6.  TSSO must be identified to MVS as a subsystem. This is\n             accomplished  through an entry in the active subsystem\n             names table,  member  IEFSSNxx  in  SYS1.PARMLIB.  The\n             format of the entry is\n\n             TSSO\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 3 -\n\n\n\n         7.  SYS1.TSSOLOAD must be included in the IEAAPFxx  member\n             of SYS1.PARMLIB. This allows the TSSO subsystem to run\n             APF authorized.\n\n         8.  A procedure for starting TSSO must be included in  the\n             SYS1.PROCLIB dataset. Note that TSSO may be started by\n             the master scheduler, rather then JES, and  therefore,\n             this procedure cannot be in a PROCLIB defined to JES2.\n             It must be in  the  SYS1.PROCLIB  dataset.   A  sample\n             procedure  for  starting TSSO is in member TSSOPROC in\n             the TSSO.VERS41.ASM dataset.\n\n         9.  Some of the TSO commands supplied  with  TSSO  require\n             APF   authorization.  Update  the  installation  CSECT\n             IKJEFTE2 in load module IKJEFT02 to include the CACHE,\n             CPCMD  and  REPLY  commands.  Under TSO/E Release 2.1,\n             this CSECT is in the load  module  IKJTABLS.  If  this\n             release  of  TSO/E  is  installed,  a separate copy of\n             IKJTABLS may be  used  by  TSSO  if  included  in  the\n             SYS1.TSSOLOAD dataset.\n\n        10.  The TSSO Automated Operations Facility table(s) should\n             be  created  at  this time. Instructions for preparing\n             the table are found later in this document.\n\n        11.  If you will be running TSSO with  RACF support, a RACF\n             user  id  for  TSSO  should  be  added. In addition, a\n             userid of TSSO should be  added  to  SYS1.UADS.   This\n             will  allow  TSSO  to  assume the TSO attributes (e.g.\n             ACCOUNT,  SUBMIT  or  MOUNT)  that  the   installation\n             desires.\n\n        12.  A warm start of MVS must be performed before TSSO  can\n             be   used.   The  next  section  describes  what  TSSO\n             parameters can be  specified  in  the  TSSO  parameter\n             deck. This is only required if TSSO is being installed\n             for the first time.\n\n       TSSO_PARAMETERS_AND_INITIALIZATION_PROCESSING\n\n       The use of TSSO parameters provides an installation  with  a\n       flexible  mechanism  for  altering TSSO processing. Next, an\n       overview of  TSSO  initialization  processing   is  provided\n       including  a  description  on  how to specify alternate TSSO\n       parameters at startup. Note that  these  parameters  can  be\n       entered  in  any order, and if two entries are specified for\n       the same parameter, the last entry takes precedence.\n\n         A.  The SRC (System  Recognition  Character)  defines  the\n             character   that  TSSO  will  use  to  recognize  TSSO\n             operator commands. For example, if this  character  is\n\n\n\n\n\n\n\n\n\n\n\n                                  - 4 -\n\n\n\n             \"#\",  TSSO  will  intercept  and  process all operator\n             commands starting  with  a  \"#\".  The  syntax  of  the\n             parameter is:\n\n             SRC = char\n\n             where char is the character that TSSO  will  use.  The\n             default character is a \"#\".\n\n         B.  The SSSM (Sub System Support Module) parameter defines\n             the  module  name  that  TSSO  will  load  to  perform\n             subsystem interface requests. The syntax is:\n\n             SSSM = sssmname\n\n             where sssmname is the module name used. This parameter\n             should   not   be  specified  under  normal  operating\n             conditions. It is useful when testing new versions  of\n             TSSO. The default module name is TSSOSSSM.\n\n         C.  The TABLE parameter  defines  the  name  of  the  TSSO\n             Automated  Operations  Facility  (AOF)  table. The AOF\n             table contains information used  in  the  intercepting\n             and   responding   to   operating   system   messages.\n             Information describing how to  create  this  table  is\n             specified   later  in  this  document.   There  is  no\n             default. If this parameter is not specified,  the  AOF\n             is  deactivated.  Note that this table can be reloaded\n             at any time with the \".RELOAD\" TSSO  operator  command\n             described later. The syntax of this parameter is:\n\n             TABLE = table-name\n\n             where table-name is the load module name that contains\n             a TSSO AOF table.\n\n         D.  The MAXCMDS parameter defines the  maximum  number  of\n             concurrent   commands   that   TSSO   will   hold  for\n             processing. TSSO processes commands in  the  order  in\n             which  they are entered, on a FIFO basis. Any commands\n             that are entered  while  TSSO  is  processing  another\n             command  are  queued  for  execution.  This  parameter\n             defines the size of that  queue.  A  small  number  is\n             undesirable  because  it is advantageous to be able to\n             enter many TSSO commands at a time, however,  a  large\n             number  is undesirable because it becomes difficult to\n             detect when a TSSO command may be looping, or awaiting\n             terminal input. The syntax of this parameter is\n\n             MAXCMDS=nn\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 5 -\n\n\n\n             where nn defines the maximum  number  of  simultaneous\n             TSSO  commands.  Note that TSSO requires 256 bytes for\n             each command, in the common service  area  (CSA).  The\n             default value is 15 simultaneous commands.\n\n         E.  The NONSWAP parameter defines whether  TSSO  will  run\n             non-swappable.  If \"Y\" is entered, TSSO will issue the\n             appropriate SYSEVENT to MVS  to  declare  itself  non-\n             swappable.  Any  other  entry  will  cause  TSSO to be\n             swapped out whenever it has no work.  This  can  cause\n             severe   performance   degradation   when   using  the\n             subsystem. The default value is  \"Y\".  The  syntax  of\n             this parameter is\n\n             NONSWAP=(Y|N)\n\n             where \"Y\"  will  mark  the  TSSO  address  space  non-\n             swappable.\n\n         F.  The PROMPT parameter provides  a  mechanism  to  alter\n             TSSO   processing   without  editing  the  appropriate\n             PARMLIB members. The syntax of this parameter is:\n\n             PROMPT=(Y|N)\n\n             If PROMPT=Y is specified, TSSO will enter prompt  mode\n             after  processing  all  the parameters in PARMLIB, and\n             allow  the  MVS  operator   to   enter   or   override\n             parameters.  A  discussion of prompt mode can be found\n             below.\n\n         G.  The  RACFID  parameter  allows  the  installation   to\n             specify a RACF user identifier for the TSSO subsystem.\n             The  TSSO  subsystem  will  then  execute   with   the\n             authority  of that RACF userid. This implies that RACF\n             commands can be entered from the MVS  console  through\n             the  use  of  TSSO.  Note that TSSO does not require a\n             password to acquire this RACF authority, and care must\n             be taken to assure that use of this parameter does not\n             violate installation security standards.   The  syntax\n             of this parameter is:\n\n             RACFID=racf-user-id\n\n             where racf-user-id is the RACF  identifier  that  TSSO\n             will  assume.  This parameter has no default. If it is\n             not specified, TSSO will execute with the default RACF\n             authority.  If  the installation has not installed the\n             RACF program product, this parameter must be  omitted.\n             A  recent  small  programming enhancement (SPE) to the\n             JES2 subsystem has enhanced TSSO's ability to  control\n\n\n\n\n\n\n\n\n\n\n\n                                  - 6 -\n\n\n\n             production  batch  jobs  that  may  use RACF protected\n             datasets. JES2 will now propagate the userid and group\n             from  the  current  address  space  for jobs submitted\n             through the internal  reader.  TSSO  can  submit  jobs\n             using  the  TSO  SUBMIT  command,  and  those jobs can\n             acquire the authority of the TSSO address  space.  Due\n             to security considerations, TSSO Release 4.1 or higher\n             does not permit the MVS console operator to enter  the\n             RACF userid while in PROMPT mode.\n\n         H.  The END parameter marks  the  end  of  TSSO  parameter\n             input. The syntax of this parameter is:\n\n             END\n\n             with no operands. If prompt mode was enabled, the  MVS\n             console  operator will be prompted for additional TSSO\n             parameters after the END parameter is processed.\n\n         I.  The \"*\" parameter  allows  an  installation  to  place\n             comments  in  the  TSSO  initialization deck. The line\n             will be ignored by TSSO. The syntax of  the  statement\n             is\n\n             * any-text\n\n             where  any-text  is  any  descriptive   comments   the\n             installation may want to include in the initialization\n             deck.\n\n       TSSO_START_COMMAND_OPTIONS\n\n       TSSO  provides  the  installation  with  a  great  deal   of\n       flexibility  at startup time. The following forms of the MVS\n       START command may be used to start TSSO.  In  any  of  these\n       forms,  the SUB=JES2 parameter may only be specified  if the\n       JES2 subsystem is up. Specification of SUB=JES2  allows  the\n       TSSO  subsystem  to  use  JES2 services such as PRINTOFF and\n       SUBMIT. The SUB=JES2 parameter should be  specified  in  all\n       but  emergency situations.  Note that the SUB=JES2 parameter\n       is an  MVS  directive  to  direct  processing  of  the  TSSO\n       procedure  JCL  to the JES2 subsystem. It is not a parameter\n       in the TSSO procedure, and therefore, cannot be overridden.\n\n          o S TSSO,SUB=JES2\n\n            This form of the MVS start command  instructs  TSSO  to\n            use  the  default parmlib member of \"TSSOPARM\" for TSSO\n            parameters. Normally,  this  form  of  the  TSSO  start\n            command  should  be  used and perhaps executed from the\n            JES2 or JES3 initialization deck.\n\n\n\n\n\n\n\n\n\n\n\n                                  - 7 -\n\n\n\n          o S TSSO,PARM=parm-member,SUB=JES2\n\n            where parm-member is an alternate TSSO  parameter  deck\n            in  SYS1.PARMLIB.  TSSO will use the alternate deck for\n            parameters if this form of the  MVS  START  command  is\n            used.\n\n          o S TSSO,PARM='PROMPT',SUB=JES2\n\n            will instruct TSSO to prompt the MVS  console  operator\n            for the name of a member in SYS1.PARMLIB to be used for\n            parameters. After processing  the  named  member,  TSSO\n            will  behave  as if the PROMPT parameter was specified,\n            prompting  the  MVS  console  operator  for  additional\n            parameters.   Use   of   this   parameter   allows   an\n            installation to specify TSSO parameters without  having\n            to previously enter them into SYS1.PARMLIB. This can be\n            useful in emergency situations.\n       If the SUB=JES2 parameter is not used, the MVS operator must\n       issue  the  \".J\"  TSSO  command  to  allow  TSSO to use JES2\n       services.  Although TSSO has not been tested using the  JES3\n       product,  the  interfaces should be the same because TSSO is\n       using standard subsystem interface calls.\n\n       Prompt mode is entered in one of two  ways.  If  the  PROMPT\n       parameter  was specified on the MVS START command, or if the\n       PROMPT parameter was specified in  a  PARMLIB  member,  TSSO\n       will  prompt  for  additional parameters after processing of\n       the PARMLIB  input.  Anything  entered  during  prompt  mode\n       processing overrides PARMLIB input. It is recommended that a\n       default TSSOPARM member be created for daily processing, and\n       that prompt mode be used in emergency situations only.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 8 -\n\n\n\n       THE_TSSO_OPERATOR_PRODUCTIVITY_FACILITY_(OPF)\n\n       OPF extends the power of TSO to the MVS operator's  console.\n       The  facility  allows  for the execution of TSO commands and\n       CLISTS from an MVS console, with the response going back  to\n       the  invoking  console.  OPF  can  be  used to automate many\n       operations procedures.\n\n       Conceptually, TSSO OPF is the addition of TSO  functions  to\n       operators  at  MVS  consoles. OPF includes all TSO functions\n       which use standard interfaces  (with  the  exceptions  noted\n       below).  It  also  includes control functions, unique to the\n       TSSO environment, that alter TSSO options and  display  TSSO\n       information.  A  special  OUTPUT  monitor redirects selected\n       TSSO output to the MVS command subsystem through the SVC  34\n       interface,  enabling  TSSO  CLISTS and command processors to\n       issue MVS operator commands. These functions  are  described\n       below.    The  output  monitor  also  allows  for  hilighted\n       messages to be displayed at the MVS console.\n\n       Most TSO commands may be  run  under  control  of  the  TSSO\n       subsystem.   The  requirements  for  such  commands  are  as\n       follows:\n\n         1.  The command must use standard TSO interfaces,  namely,\n             GETLINE and PUTLINE to perform I/O. The command should\n             not require input of any kind, other than  normal  TSO\n             command parameters.\n\n         2.  The command should not  attempt  to  use  full  screen\n             processing   A   command   that  issues  the  STFSMODE\n             FULLSCRN=YES macro in ACF/VTAM environments  can  hang\n             the TSSO subsystem, forcing a restart.\n\n         3.  The command should be tested before running  it  under\n             TSSO.  TSO  assumes  that  TSSO initiated commands are\n             running in background  mode,  therefore,  the  command\n             should be tested using batch TSO.\n\n       A number of TSO commands that are designed to run  with  the\n       TSSO  subsystem  are  distributed  with  the base code. Most\n       notable is the REPLY command, providing  the  capability  to\n       issue MVS replies to outstanding WTOR's based on message id.\n       Other commands  provided  include  the  CACHE  command,  for\n       controlling  3880-21 and 3880-23 cache devices, the LINKLIST\n       command, for displaying the system LNKLST concatenation, and\n       the   VOLSER   and   VALLOC  commands,  for  displaying  UCB\n       information for DASD devices.  Also worth mentioning is  the\n       CPCMD  command,  that allows an MVS console operator running\n       in a virtual machine under VM/SP, VM/SP  HPO  or  the  VM/XA\n       migration  aid,  to  issue  CP commands and get the response\n\n\n\n\n\n\n\n\n\n\n\n                                  - 9 -\n\n\n\n       back to the console invoking the command.  A  complete  list\n       of these TSO commands may be found later in this document.\n\n       TSSO supports a number of commands that are not directed  to\n       the  TMP  for execution. These commands are handled directly\n       by TSSO, and are used to  alter  or  query  TSSO  processing\n       options.  One  such  command  is  the  \".P\" command, used to\n       terminate TSSO. The \".P\" command, and other control commands\n       are documented later in this document.\n\n       TSSO also supports the use of TSO CLISTS. CLISTS may be used\n       for  tasks  such  as  displaying  instructions  for  the MVS\n       operator, or editing a file. CLISTS under TSSO also have the\n       ability   to   issue  MVS  operator  commands.   Since  this\n       capability  provides  a   great   deal   of   function   and\n       flexibility,  it  will  be  discussed separately in the next\n       section.\n\n       THE_TSSO_CLIST_ENVIRONMENT\n\n       Most of the operational benefits  that  are  gained  through\n       TSSO/OPF  are  realized  through  the CLIST facility. A TSSO\n       CLIST is exactly the same as a CLIST that  a  TSO  user  may\n       execute, with one important exception. TSSO scans all output\n       lines to be written to the console. Special TSSO  directives\n       may  be  inserted  into  the output stream of the TSO CLIST.\n       These directives are summarized below.\n\n         A.  The  first  directive,  and  the  most  useful,  is  a\n             facility whereby TSSO can issue MVS operator commands.\n             When an output line in the SYSTSPRT output stream (the\n             output  from the TSO command or CLIST) begins with the\n             keyword \"*COM\", TSSO will  execute  the  remainder  of\n             that  statement as an MVS operator command. The effect\n             of this processing is the TSSO CLISTS may be  used  to\n             issue operator commands. The easiest way to insert the\n             \"*COM\" into the output stream  is  through  the  CLIST\n             WRITE  statement.  The  syntax  of this extended write\n             statement is as follows.\n\n             WRITE *COMnnn  oscmd\n\n             where\n\n             nnn - is a delay factor. If n is specified as a number\n             between  1  and  999,  TSSO will delay n seconds after\n             processing the command. This is useful when  operating\n             system  commands have a time dependency on each other,\n             and\n\n             oscmd- is an MVS operator command to be executed.  The\n\n\n\n\n\n\n\n\n\n\n\n                                  - 10 -\n\n\n\n             command  could be an MVS command, JES command, or even\n             another TSSO command. The  command  will  be  executed\n             with  the  authority  of  the  console that originally\n             invoked the TSSO command.\n\n         B.  The second directive for  which  TSSO  will  scan  the\n             output stream for is the \"*HI\" facility. This facility\n             allows the CLIST developer to write hilighted messages\n             on the MVS console. The syntax of this directive is\n\n             WRITE *HI message\n\n             where message is the message to be  hilighted  on  the\n             MVS  console.  Note that the CLIST WRITE statement can\n             be used in its normal form to write  messages  to  the\n             console  operator.  This  can  be useful in setting up\n             HELP files for the operator.\n\n       The following is an example of a TSSO CLIST  that  automates\n       the bringup of VTAM system address spaces.\n\n       PROC 0\n       /*********************************************************/\n       /* This CLIST will bring up the system address           */\n       /* spaces related to VTAM. Note that delays are used to  */\n       /* achieve proper timing                                 */\n       /*********************************************************/\n       WRITE *COM30 S NETWORK    /* START THE NETWORK           */\n       WRITE *COM3 S TSO         /* START TCAS                  */\n       WRITE *COM $SLOGON1\n                                 /* NOTE THAT COMMENTS CANNOT BE*/\n                                 /* PLACED ON THE SAME LINE AS  */\n                                 /* JES2 COMMANDS               */\n       EXEC 'SYS1.TSSOPROC(SLINES)' /* START JES2 LINES         */\n       WRITE *HI TSSN001I NETWORK INITIALIZED\n                                    /* SEND MSG TO CONSOLE      */\n                                    /* AND HILIGHT IT           */\n       EXIT\n\n       The following tips are useful when writing TSSO CLISTS.\n\n       All TSSO CLIST processing takes place after  the  CLIST  has\n       completed execution (e.g. IKJEFT01 has terminated). The TSSO\n       CLIST monitor uses the completed SYSTSPRT output  stream  as\n       input.  Care  must  therefore be taken in TSSO CLIST design,\n       because any TSO commands in the CLIST  are  executed  before\n       any MVS commands are issued by TSSO.\n\n       As stated above, any MVS commands generated by a  CLIST  are\n       executed  with the authority of the console that invoked the\n       CLIST. This prohibits an INFO-only MCS console, for example,\n\n\n\n\n\n\n\n\n\n\n\n                                  - 11 -\n\n\n\n       from issuing commands with authority.\n\n       CLISTS can use the WRITE statement to generate  messages  to\n       the MVS console. This can be useful in writing operator HELP\n       procedures as demonstrated in the following CLIST.\n\n               PROC 0\n               /********************************************************/\n               /* This CLIST will provide HELP information to the      */\n               /* operator on the current status of the NJE LINES      */\n               /* between JES2 systems                                 */\n               /********************************************************/\n               WRITE NJE LINK BETWEEN A and B is line 12\n               WRITE NJE LINK BETWEEN A and C is line 16\n               WRITE NJE LINK BETWEEN B and C is line 20\n               WRITE NJE LINK BETWEEN C and A is line 19\n               WRITE NJE LINK BETWEEN C and B is line 24\n               WRITE NJE LINK BETWEEN B and A is line 13\n               WRITE\n               WRITE This list is current as of January 3, 1985. For more\n               WRITE assistance, contact Alan Grossman at extension 5555.\n               EXIT CODE(0)\n\n\n       The REPLY command is  particularly  useful  in  CLISTS.  For\n       example, if numerous NCCF commands are to be executed, these\n       can be executed in a TSSO CLIST using the reply command with\n       message id DSI802A. See the description of the REPLY command\n       later in this document.\n\n       Comments may be placed at the end of  MVS  commands  because\n       MVS   treats them as MVS command comments. JES2 treats CLIST\n       comments as data, and tries  to  use  them  in  forming  the\n       command.  Therefore,  do  not  place  CLIST comments on JES2\n       commands. For example, the following CLIST is invalid\n\n       PROC 0\n       WRITE *COM $TEXIT6,ENABLE  /* ENABLE THE EXIT */\n       EXIT\n\n       and would produce an invalid JES2 command.\n\n       Symbolic substitution  can  be  used  in  TSSO  CLISTS.  The\n       following CLIST demonstrates this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 12 -\n\n\n\n       PROC 2 UNIT VOLSER USE()\n       /*****************************************/\n       /* This CLIST will mount MVS volumes     */\n       /* using a command is operator friendly  */\n       /* syntax. Note the optional PUBLIC      */\n       /* parameter.                            */\n       /*****************************************/\n       WRITE *COM3 VARY &UNIT,ONLINE\n       IF &USE = THEN +\n       DO\n         WRITE *COM MOUNT &UNIT,VOL=(SL,&VOLSER)\n       END\n       ELSE +\n       DO\n         WRITE *COM MOUNT &UNIT,VOL=(SL,&VOLSER),USE=&USE\n       END\n       WRITE *HI MNT001I VOLUME &VOLSER NOW MOUNTED ON &UNIT\n       WRITE *COM D U,,,&UNIT,1\n       EXIT\n\n\n       Since operations personnel will  be  using  this  tool,  the\n       recommendation  is  to allow them to write their own CLISTS.\n       With the exception of the *COM feature, all such CLISTS  can\n       be harmlessly tested under TSO.\n\n       TSSO  CLISTS  are  invoked  in  the  same  fashion  as  TSSO\n       commands.  The  normal  TSO search sequence is followed. The\n       recommendation is to allocate a SYS1.TSSOPROC  dataset,  and\n       allocate  it to DDNAME SYSPROC in the TSSO bringup deck. The\n       SYSPROC dataset may also be  dynamically  allocated  through\n       the  TSSO ALLOCATE command. Lastly, the TSO EXEC command may\n       be used to execute TSSO CLISTS.\n\n       Use the TSSO  hilighting  procedure  with  caution.  Do  not\n       highlight  messages  unless  their  importance  warrants it,\n       because  your  operations  staff  will   learn   to   ignore\n       highlighted  messages,  and  this  can  be  harmful  to your\n       overall system operations.\n\n       As is becoming  apparent,  the  TSSO  Operator  Productivity\n       Facility  is  tremendously  powerful  tool. Many procedures,\n       which currently must be done manually, should  be  automated\n       using  OPF.  In  conjunction  with  the Automated Operations\n       Facility, TSSO provides an installation with  an  impressive\n       array  of  operational  enhancements.  The next few sections\n       describe the Automated Operations Facility.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 13 -\n\n\n\n       TSSO AUTOMATED OPERATIONS FACILITY\n\n       Introduction\n\n       A high percentage of MVS commands are issued in response  to\n       system  or  subsystem  messages,  and  these  responses  are\n       predetermined by the contents of  the  messages.   The  TSSO\n       Automated  Operations  Facility  (AOF) frees the MVS console\n       operator from  routine  tasks  by  automating  responses  to\n       system   messages.   AOF  is  a  table-driven  monitor  that\n       intercepts messages and carries out  one  of  four  actions:\n       suppresses,  highlights, or lowlights the message; or issues\n       an MVS, JES2 or subsystem command.   Because  AOF  does  not\n       require  the  services of the TSSO address space, any number\n       of messages can be processed simultaneously.\n\n       There are three steps required  to  install  this  facility;\n       briefly:\n\n         1.  Create the AOF table.\n\n         2.  Assemble and link-edit  the  table  into  load  module\n             format.\n\n         3.  Store the module in SYS1.TSSOLOAD.\n\n       These steps are described in detail below.\n\n       Note that the table can be updated at any time.   Also,  you\n       may  create multiple tables, although only one can be active\n       at a time.  Multiple tables may be useful so that  different\n       sets  of  commands  can  be  used  at different times (e.g.,\n       first, second and third shifts).  You can change the  active\n       table in two ways:\n\n         1.  By changing the  TABLE=  parameter  in  the  parameter\n             deck;  the  new  table will be available the next time\n             TSSO is brought up.\n\n         2.  By dynamically reloading the table with the \"#.RELOAD\"\n             command; the new table will be available immediately.\n\n       Creating the AOF Table\n\n       There  are  three  macros  required  to  create  the  table:\n       TABSTART  to start the table, TABENTRY to specify actions on\n       messages, and TABEND to end the table.\n\n       TABSTART is always the first macro and can be specified only\n       once.  It takes the form\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 14 -\n\n\n\n            loadname TABSTART ID=table-id\n\n       where loadname is the name of this TSSO table  and  table-id\n       is  an  eye-catching  name  to identify the table in a dump.\n       table-id will also be  displayed  on  the  DISPAOF  and  .QT\n       commands.   The loadname label is used as the CSECT name and\n       must be used as the load module name.\n\n       TABEND is always the last macro, signifying the end  of  the\n       table.   TABEND  must  be  present; otherwise, unpredictable\n       things may happen, none of them pleasant.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 15 -\n\n\n\n       TABENTRY macros are entered  between  TABSTART  and  TABEND.\n       TABENTRY  macros  generate entries in the AOF table and take\n       the form\n\n    TABENTRY MSG=msg-id,ACTION=action\u00dd,TEXT='operator-cmd'\u00a8\u00dd,TEST=(condition)\u00a8\n\n       A sample AOF table, demonstrating most of  the  capabilities\n       of TSSO/AOF, and all forms of the TABENTRY macro, is located\n       in the TSSO.VERS41.ASM dataset in member AOFIVP.\n\n       The MSG Operand\n\n       MSG identifies an MVS, JES2, or subsystem message as defined\n       in  MVS/XA  System  Messages  (GC28-1376  and  -1377) or its\n       MVS/370 equivalent.  msg-id is  the  first  seven  or  eight\n       characters  of  the  console message.  msg-id may also be an\n       asterisk (*), which will  match  on  all  console  messages.\n       MSG=* is useful with the TEST operand described later.\n\n       The ACTION Operand\n\n       The following actions  may  be  taken  in  response  to  the\n       identified message:\n\n         1.  Suppress (i.e., do  not  print)  the  message  at  the\n             console.  The macro takes the form\n\n             TABENTRY MSG=msg-id,ACTION=SUPPRESS\n\n         2.  Highlight the message at the console.  This is  useful\n             for  highlighting important messages.  The macro takes\n             the form\n\n             TABENTRY MSG=msg-id,ACTION=HILIGHT\n\n         3.  Lowlight the message at the  console.   This  reverses\n             the  intensity  of MVS messages that are automatically\n             highlighted.  The macro takes the form\n\n             TABENTRY MSG=msg-id,ACTION=LOWLIGHT\n\n         4.  Reply  to  a  Write  to  Operator  with  Reply  (WTOR)\n             message.  The macro takes the form\n\n             TABENTRY MSG=msg-id,ACTION=REPLY,TEXT='reply-text'\n\n             where reply-text is the text of the reply;  TSSO  will\n             automatically  format  the  reply  message  as  R msg-\n             no,reply-text.   Note  that  msg-id  must  be  a  WTOR\n             message.\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 16 -\n\n\n\n         5.  Issue an operator command in response to a message and\n             extract  part  of  the  message to use in the command.\n             The macro takes the form\n\n             TABENTRY MSG=msg-id,ACTION=OSCMD,TEXT='operator-cmd'\n\n             operator-cmd can be an MVS command, JES2 command, TSSO\n             command,  or  TSSO  CLIST.   Rules for coding TEXT are\n             described later.\n\n         6.  Print an operator command at the console  rather  that\n             execute  it.   this  allows  you  to  test an operator\n             command that results from a TABENTRY before  executing\n             it.  The macro takes the form\n\n             TABENTRY MSG=msg-id,ACTION=OSCMDT,TEXT='operator-cmd'\n\n             The rules are the same as for OSCMD above.\n\n         7.  Carry out the specified action  if  and  only  if  the\n             message  meets  certain conditions, such as matching a\n             particular job name.  To do  this,  include  the  TEST\n             operand in your TABENTRY macro as follows:\n\n     TABENTRY MSG=msg-id,ACTION=action,\u00ddTEXT='operator-cmd',\u00a8TEST=(condition)\n\n             where condition  tests  portions  of  the  message  by\n             substring  or word.  Rules for coding the TEST operand\n             are described later.\n\n             NOTE:  TEXT can only be used if ACTION=OSCMD,  OSCMDT,\n                    or REPLY.\n\n       There is no limit on the number of TABENTRY macros that  may\n       be  specified  in  a  given  AOF  table. Note that TSSO will\n       process all of the entries in the TSSO/AOF table  for  every\n       WTO  or  WTOR  message.  This  implies that multiple ACTION=\n       specifications may be specified  for  the  same  msg-id,  by\n       specifying  multiple  TABENTRY  macros.  TSSO  does not stop\n       after processing one ACTION= directive, but continues  until\n       the end of the table.\n\n       The TEXT Operand\n\n       The OSCMD action allows you to specify an  operator  command\n       to  be  performed  in  response  to  a  particular  message.\n       Optionally, you may select  one  or  more  portions  of  the\n       message  to  include  in  the  command.   This is useful for\n       extracting a data set name,  job  name,  or  other  variable\n       information  from  a message and embedding it in the command\n       to be executed.  The two  formatting  options  in  the  TEXT\n\n\n\n\n\n\n\n\n\n\n\n                                  - 17 -\n\n\n\n       parameter allow you to extract this information by substring\n       or by word.\n\n       To select information by substring, use the format\n\n            \\Pnnn,yy\\\n\n       where nnn is the starting character position and yy  is  the\n       number  of  characters  to select.  For example, suppose you\n       want to record the text of /*MESSAGE cards whenever they are\n       encountered  in  the  job  stream.   JES2  issues a $HASP104\n       message, and you want to capture characters 1 through 72  of\n       the card.  Thus, the TABENTRY would look like this:\n\n            TABENTRY MSG=$HASP104,ACTION=OSCMD,TEXT='#RECMSG MSG(''\\P001,72\\'')'\n\n       Note that nnn must be left-padded with zeroes.\n\n       To select information by word, use the format\n\n            \\Wabcdnn\\\n\n       where a, b, c, and d define the word  separator  characters,\n       and  nn  identifies  the  word's  position.  A word can be a\n       maximum of 16 characters.  For example, given the message\n\n            IEF176I WTR 1A4 WAITING FOR WORK...\n\n       you might want to purge the writer 1A4 with the command\n\n            PURGE 1A4\n\n       To do this, you want to extract  the  third  word  from  the\n       message,  which  identifies the external writer name.  Thus,\n       the TABENTRY macro would look like this:\n\n            TABENTRY MSG=IEF176I,ACTION=OSCMD,TEXT='PURGE \\W03    \\'\n\n       Note that if you  do  not  need  to  define  four  separator\n       characters,  you  must  pad the field with blanks.  Also, nn\n       must be left-padded with a zero.\n\n       Multiple \"P\" and  \"W\"  options  can  be  used  in  one  TEXT\n       operand.  If AOF detects an error in the TEXT parameter as a\n       result of  a  P  or  W  option,  a  message  is  issued  and\n       processing is terminated.\n\n       The TEST Operand\n\n       The TEST  operand  allows  you  to  respond  selectively  to\n       messages  by  \"testing\" the text.  For example, when payroll\n\n\n\n\n\n\n\n\n\n\n\n                                  - 18 -\n\n\n\n       jobs complete,  you  may  want  to  highlight  the  message,\n       whereas  you  want  to ignore other job completion messages.\n       The TEST operand allows you to  match  on  message  text  by\n       substring or word.\n\n       To match by substring, use the format\n\n            (P,nnn,yy,'literal-string')\n\n       where you want to find the character  string  literal-string\n       starting  in  character  position  nnn  for  a  length of yy\n       characters.  For example, (P,32,07,'PAYROLL') would look for\n       PAYROLL in character positions 32 through 38.\n\n       To match by word order, use the format\n\n            (W,nn,yy,'literal-string','abcd')\n\n       where you want to find the character  string  literal-string\n       as  word  number nn with a word length of yy characters; and\n       a, b, c, and d define the word  separator  characters.   For\n       example,  (W,03,07,'PAYROLL',', ') would look for PAYROLL as\n       the third word with seven characters separated by blanks  or\n       commas.\n\n       Thus, the whole TABENTRY macro  for  our  example  could  be\n       either\n\n            TABENTRY MSG=$HASP395,ACTION=HILIGHT,TEST=((P,32,07,'PAYROLL'))\n\n            or\n\n            TABENTRY MSG=$HASP395,ACTION=HILIGHT,TEST=((W,03,07,'PAYROLL',' ,'))\n\n       It is possible to test  on  all  WTO  or  WTOR  messages  by\n       specifying MSG=*.  For example, if you want to highlight all\n       JES end-of-day messages, you would test for a first word  of\n       $HASP  and  a second word (i.e., job name) of ENDOFDAY.  The\n       TABENTRY macro would look like this:\n\n    TABENTRY MSG=*,ACTION=HILIGHT,                                         X\n                 TEST=((W,1,5,'$HASP',' '),(W,2,7,'ENDOFDAY',' '))\n\n       Notes on the TEST Operand\n\n         1.  Each TEST  condition,  as  well  as  the  entire  TEST\n             parameter list, must be enclosed in parentheses.\n\n         2.  There are multiple way to do the same test,  as  shown\n             in  the  examples  above.   However,  it  is generally\n             easier to match on words rather than substrings.\n\n\n\n\n\n\n\n\n\n\n\n                                  - 19 -\n\n\n\n         3.  \"Logical and\" and \"logical or\" test conditions can  be\n             constructed with the TEST operand.\n\n               a.  To construct a \"logical and\",  specify  all  the\n                   conditions to be met in one TEST operand:\n\n                   TEST=((condition1),(condition2),(condition3))\n\n               b.  To construct a \"logical  or\",  specify  multiple\n                   TABENTRY  macros  with the same MSG, ACTION, and\n                   TEXT operands but with different TEST operands:\n\n                   TABENTRY MSG=msg-id,ACTION=action,TEST=((condition1))\n\n                   TABENTRY MSG=msg-id,ACTION=action,TEST=((condition2))\n\n                   TABENTRY MSG=msg-id,ACTION=action,TEST=((condition3))\n\n         4.  When using the TEST operand, TABENTRY  macros  can  be\n             quite  lengthy.  To continue a macro on the next line,\n             enter an \"X\" in column 72.  Since the  TABENTRY  macro\n             follows   the   conventions   for  the  IBM  assembler\n             language, the next line in a continuation  must  start\n             in  column  16.  Note  that  blank  characters are not\n             permitted, except if they are inside quotation marks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 20 -\n\n\n\n       Assembling and Link-Editing the Table\n\n       Assemble and link edit your AOF table into load module  form\n       by  submitting  a  batch  job  similar  to the sample in the\n       TSSO.VERS41.ASM dataset, member ASMTABLE.  You may tailor  a\n       copy of this data set to your specifications as follows:\n\n         1.  Include   the    appropriate    installation-dependent\n             information on the JOB card.\n\n         2.  change the SYSIN DD card to point to your AOF table.\n\n         3.  Change the load library name in the LKED.SYSLMOD  step\n             to one of your choice. (Optional)\n\n         4.  Change  the  NAME  statement  in  the  linkage  editor\n             control cards to match the label on the TABSTART macro\n             in your AOF table.\n\n       Note that the Assembler parameters RENT and NOALIGN must  be\n       present.\n\n       A  return  code  of  0  indicates  that  the  assembly   was\n       successful.\n\n       Storing the Module\n\n       When the table assembly is successful, copy the load  module\n       from  TSSO.VERS41.load (or the appropriate dataset) into the\n       SYS1.TSSOLOAD dataset.  To activate the new AOF  table,  use\n       the procedures as described previously in this document.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 21 -\n\n\n\n       T_S_S_O__Command_Reference\n\n       This section of the  TSSO  users  guide  documents  the  TSO\n       command  processors  that  are distributed with TSSO. Unless\n       otherwise noted, these command processors can be  issued  by\n       TSO  users  as well as the TSSO subsystem.  The commands are\n       documented, one to a page, for easy insertion into  existing\n       operator procedure books.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 22 -\n\n\n\n       SPMON_COMMAND\n\n       The SPMON command is used to display system  information  to\n       the MVS console operator. The syntax of this command is:\n\n\n       SPMON  job-parm  type-parm\n\n       where job-parm is a 1-8 character jobname, and type-parm  is\n       one of four possible strings, 'JOB', 'STC', 'TSO', or 'ALL'.\n       The  command  will  always   display   certain   information\n       regardless  of the parameters entered. Information displayed\n       is:\n\n         a.  Percentage of CPU busy.\n\n         b.  Average Unreferenced Interval Count (UIC)\n\n         c.  Average Paging Rate.\n\n         d.  Number of TSO users.\n\n         e.  Number of Started tasks\n\n         f.  Number of batch jobs\n\n         g.  Number of inactive initiators\n       In addition to the  above  information,  the  SPMON  command\n       displays   additional   job  related  information  based  on\n       parameters specified. SPMON  determines  the  job  selection\n       criteria  through the use of the two parameters. If job-parm\n       is  'ALL',  SPMON  will  select  all  jobs  in  the  system,\n       otherwise,  SPMON  will only select jobs that begin with the\n       character string entered for  job-parm  The  jobs  that  are\n       selected  based  on  the  job-parm  parameter may be further\n       reduced through the  use  of  the  type-parm  parameter.  If\n       type-parm  equals 'ALL', which is the default, the parameter\n       has no effect. Otherwise, each selected job must be  of  the\n       type  (JOB, STC or TSO) selected by the type-parm parameter.\n       After jobs finally pass  the  two  criteria,  the  following\n       information is displayed for each job.\n\n         a.  JOBNAME\n\n         b.  Number of service units in current transaction\n\n         c.  Swap-in, Swap-out status\n\n         d.  Number of active frames in real storage\n\n       Some examples may prove informative.\n\n\n\n\n\n\n\n\n\n\n\n                                  - 23 -\n\n\n\n       EXAMPLE ONE\n\n       SPMON BCR\n\n       will display the general system information, in addition  to\n       information  about all jobs, TSO users or started tasks that\n       start with \"BCR\".\n\n\n       EXAMPLE TWO\n\n       SPMON PY TSO\n\n       will display the general system information, in addition  to\n       information about all TSO users starting with \"PY\".\n\n\n       EXAMPLE THREE\n\n       SPMON\n\n       will display the general system information only.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 24 -\n\n\n\n       LINKLIST_COMMAND\n\n       The LINKLIST command will display the list of  the  datasets\n       in  the  current MVS LNKLST concatenation. The syntax of the\n       command is:\n\n       LINKLIST\n\n       There are no parameters. This command is only  valid  in  an\n       MVS/XA environment, because the information is not available\n       in MVS/370. The command works under both TSO  and  the  TSSO\n       Subsystem.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 25 -\n\n\n\n       The_VALLOC_and_VOLSER__COMMANDS\n\n       The VALLOC and VOLSER commands demonstrate the power of  the\n       TSSO  subsystem.  These commands are used to display UCB and\n       ALLOCATION information. The syntax of these commands is:\n\n       VALLOC volume-serial\n\n       VOLSER volume-serial\n\n       where  volume-serial  is  a  six   character   DASD   volume\n       identifier.  The command will locate the volume-serial using\n       the standard  MVS  UCBSCAN  service,  and  display  the  UCB\n       address  and  the  UCB itself. To display UNIT or ALLOCATION\n       information, the command uses the TSSO \"*COM\"  interface  to\n       issue  appropriate  MVS  commands. The VOLSER command issues\n       the \"D U,,,ucb-address,1\"  MVS  system  command,  while  the\n       VALLOC  command  issues  the  \"D U,,ALLOC,ucb-address,1\" MVS\n       command. The result is an eye-pleasing, informative  display\n       to  the  console  operator. The command will also inform the\n       MVS operator if the volume-serial is not  found.  Note  that\n       while  this command will function under regular TSO, the MVS\n       commands are not generated, and the invoker of  the  command\n       will  see  the formatted command, \"*COM\" and all. If volume-\n       serial is omitted, the command will display information  for\n       the MVS SYSRES (IPL) device. Some examples of the VALLOC and\n       VOLSER commands follow.\n\n\n       EXAMPLE ONE\n\n       VALLOC PPBFX2\n\n       will display the ucb address, and allocation information for\n       volume PPBFX2.\n\n\n       EXAMPLE TWO\n\n       VOLSER SYSRES\n\n       will display the ucb address for volume \"SYSRES\".\n\n\n       EXAMPLE THREE\n\n       VOLSER\n\n       will locate, and display ucb information for the MVS  SYSRES\n       (IPL) pack.\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 26 -\n\n\n\n       REPLY_COMMAND\n\n       The REPLY command is used to  reply  to  MVS  WTOR  messages\n       after  the  WTOR has appeared on the MVS console. You do not\n       need to know the MVS reply number to respond  to  the  WTOR.\n       The  REPLY  command  can,  therefore,  be  used  to automate\n       operational procedures with products that communicate to the\n       operator  through  the WTOR interface. Such products include\n       NCCF, IMS and GDDM. The syntax of the REPLY command is:\n\n       REPLY MESSAGE(msg-id)   TEXT(reply-text)\n\n       where msg-id is  the  message  you  are  replying  to  (e.g.\n       DSI802A  or IKT013A) and reply-text is the text of the reply\n       you wish to give in response to the WTOR. The REPLY  command\n       functions  by  loading  a  module,  REPLYLOA,  into  CSA and\n       branching to  it.  This  module  scans  the  Operator  Reply\n       Elements (OREs) using Cross Memory Services in search of the\n       message id. The ORE contains the proper  reply  number,  and\n       the  REPLY  command  will construct and issue the proper MVS\n       reply. Once again, the command is only  effective  once  the\n       WTOR  has  been  issued.  Contrast  this to the ACTION=REPLY\n       directive in TSSO/AOF, which replies to messages the instant\n       they  are generated. You can see that TSSO/AOF and the REPLY\n       command  combine  to  give  full  coverage   on   automating\n       responses to MVS WTORs.\n\n\n       EXAMPLE 1\n\n       REPLY MSG(DSI802A) TEXT('CLOSE IMMED')\n\n       DSI802A is the message number of the NCCF WTOR. This command\n       will effectively shut down the NCCF program product.\n\n\n       EXAMPLE 2\n\n       REPLY MSG(USRWTO1) TEXT('DISPLAY FIELDS')\n\n       would issue the reply to  a WTOR with  message  id  USRWTO1.\n       The text of the reply would be 'DISPLAY FIELDS'.\n\n\n\n\n       There are some installations that run multiple  versions  of\n       the IMS/VS program product. All of the copies issue the same\n       message id as a WTOR. For these installations, an  alternate\n       form  of  the REPLY command exists. The syntax for this form\n       of the command is:\n\n\n\n\n\n\n\n\n\n\n\n                                  - 27 -\n\n\n\n       REPLY IMS(ims-id) TEXT(reply-text)\n\n       where ims-id is the system identifier of the  IMS  copy  you\n       wish to direct the response to, and reply-text is as defined\n       above. The effect of this form of the command is to  provide\n       a mechanism for automating IMS procedures. Some examples are\n       provided.\n\n\n       EXAMPLE 3\n\n       REPLY IMS(ZFF) TEXT('/DIS A')\n\n       will perform the IMS command, DISPLAY ACTIVE, on an IMS copy\n       genned as ZFF.\n\n\n       EXAMPLE 4\n\n       REPLY IMS(PRO) TEXT('NRE CHECKPOINT 0 FMT ALL')\n\n       will perform the NRESTART  command  on  the  IMS  copy  with\n       system identifier PRO.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 28 -\n\n\n\n       CACHE_COMMAND\n\n       The CACHE command is useful in controlling the operation  of\n       3880-11,  3880-21, 3880-13 or 3880-23 cache devices from the\n       MVS console. As distributed by  IBM,  software  support  for\n       these  devices  is contained in the IDCAMS program available\n       with MVS. The MVS console operator cannot  control  or  even\n       query  the  device.  The CACHE command will format an IDCAMS\n       command, attach IDCAMS, and  write  the  results  using  the\n       PUTLINE interface. When issued under TSSO, these results are\n       then displayed on the MVS console. The syntax of  the  CACHE\n       command is:\n\n       CACHE (cache-device) ON|OFF|LIST|STATUS   SUBSYS  LEGEND\n\n       where cache-device is either a UCB address of the form  UUU,\n       or a six character volume serial representing the device you\n       wish information about. The next parameter defines what  the\n       CACHE command will do:\n\n         a.  ON- Format the appropriate IDCAMS  command  (SETCACHE)\n             to turn the cache unit on.\n\n         b.  OFF- Format the appropriate IDCAMS command  (SETCACHE)\n             to turn the cache unit off.\n\n         c.  LIST  format  a  LISTDATA  command   to   list   cache\n             statistics  such  as  READ  hit  ratio, and WRITE miss\n             ratios.\n\n         d.  STATUS- (default) Provide information  concerning  the\n             current status of the cache device.\n\n       The SUBSYS keyword extends the above commands from just  one\n       UCB  or VOLSER to the entire 3350 or 3380 string. The LEGEND\n       keyword provides a verbose description of the format of  the\n       IDCAMS  output and is likely to be inappropriate for display\n       at the console.\n\n\n       There are some commands that you may want to  issue  to  the\n       cache  controller  through  IDCAMS that are not supported by\n       this command. For these occasions, and alternate form of the\n       CACHE command is provided. The syntax is:\n\n\n       CACHE * CMD('idcams-command')\n\n       where idcams-command is any command accepted by IDCAMS. This\n       command  can  be  a  cache  command  such  as BINDDATA, or a\n       command that has nothing to do with cache  devices  such  as\n\n\n\n\n\n\n\n\n\n\n\n                                  - 29 -\n\n\n\n       LISTC.\n\n\n       EXAMPLE 1\n\n       CACHE 263 ON\n\n       will turn the CACHE on for the volume at UCB 263.\n\n\n       EXAMPLE 2\n\n       CACHE JESSPL OFF\n\n       will turn the volume  JESSPL  off  to  the  cache.  This  is\n       probably a good idea.\n\n\n       EXAMPLE 3\n\n       CACHE PGMPRO ON\n\n       will turn volume PGMPRO on to the cache device.\n\n\n       EXAMPLE 4\n\n       CACHE PGMPRO\n\n       will provide status information for the cache  covering  the\n       volume PGMPRO.\n\n\n       EXAMPLE 5\n\n       CACHE PGMPRO SUBSYS\n\n       will provide status information for all volumes  covered  by\n       the cache covering the volume PGMPRO.\n\n\n       EXAMPLE 6\n\n       CACHE 265 LIST\n\n       will provide statistics for the cache device at UCB 265.\n\n\n       EXAMPLE 7\n\n       CACHE * CMD('LISTC')\n\n\n\n\n\n\n\n\n\n\n\n                                  - 30 -\n\n\n\n       will issue the IDCAMS LISTC command, and return the reply to\n       the invoking console.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 31 -\n\n\n\n       CPCMD_command\n\n       The CPCMD command is designed to provide an MVS operator  of\n       a virtual machine with the ability to issue CP commands on a\n       VM/SP, VM/SP HPO or VM/XA system.  Any  CP  command  of  the\n       appropriate  CP  privilege class is allowed. The response of\n       the command is returned to the invoking console. The  syntax\n       of this command is:\n\n       CPCMD cp-command\n\n       where cp-command is  any  VM  CP  command.  Note  that  this\n       command  will  function under TSO and return the response to\n       the CP command to the invoking TSO user.\n\n\n       EXAMPLE 1\n\n       CPCMD QUERY NAMES\n\n       will issue the  CP  QUERY  NAMES  command,  and  return  the\n       response to the invoking console\n\n\n       EXAMPLE 2\n\n       CPCMD ATTACH 3F0 * 3F0\n\n       will instruct VM to attach the device at 3F0 to the  virtual\n       machine configuration at virtual device 3F0. The device must\n       also be varied online by the MVS operator. Note that the MVS\n       virtual  machine  would  need command privilege class \"B\" to\n       issue this command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 32 -\n\n\n\n       DISPAOF_COMMAND\n\n       The DISPAOF command is used  to  display   the  contents  of\n       TSSO/AOF  tables.  These tables control the operation of the\n       TSSO Automated Operations Facility.  The DISPAOF command can\n       query  either the active TSSO/AOF table, or a table that has\n       been assembled and is residing on DASD. The  syntax  of  the\n       DISPAOF command is\n\n       DISPAOF MSG(msg-id)  TABLE(table-name) TEST\n\n       where msg-id is a 1-8 character message identifier that  was\n       specified  in  the TSSO/AOF TABENTRY macro MSG parameter. If\n       the msg-id parameter is not specified, DISPAOF will  display\n       all  entries in the TSSO/AOF table.  If msg-id is specified,\n       the display will be  limited  to  those  messages  with  the\n       selected  msg-id.   The  information  displayed includes the\n       TSSO/AOF table name, ID parameter, date and time  assembled,\n       and TSSO version number. For each message displayed, the MSG\n       ID, ACTION directive and ACTION TEXT will be displayed.\n\n       The table-name parameter is used  to  specify  an  alternate\n       TSSO/AOF  table  name.  This table must previously have been\n       assembled and available to TSSO. This  can  be  achieved  by\n       placing   the   table   (in   load  module  form)  into  the\n       SYS1.TSSOLOAD  dataset.  If  table-name  is  not  specified,\n       DISPAOF  will  use the running TSSO/AOF table (i.e. the same\n       table TSSO/AOF is currently using).\n\n       The TEST parameter will expand the information  printed  for\n       each  selected message by including any TEST conditions that\n       exist for that message.\n\n\n       EXAMPLE 1\n\n       DISPAOF\n\n       will display the running TSSO/AOF table,  with  all  message\n       ids, action directives and action text. The TEST conditions,\n       if any, will not be displayed.\n\n\n       EXAMPLE 2\n\n       DISPAOF MSG($HASP395)\n\n       will display all entries in the running TSSO/AOF table  with\n       a message id of $HASP395.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 33 -\n\n\n\n       EXAMPLE 3\n\n       DISPAOF MSG($HASP350) TEST\n\n       will display all entries, and all  test  conditions  in  the\n       running AOF table for message id $HASP350.\n\n\n       EXAMPLE 4\n\n       DISPAOF MSG(IKT021D) TABLE(AOFNEW) TEST\n\n       will display  all  entries,  and  all  test  conditions  for\n       message  IKT021D,  however, instead of using the running AOF\n       table, DISPAOF will  search  a  table  in  the  load  module\n       \"AOFNEW\".\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 34 -\n\n\n\n       T_S_S_O___Control_Commands\n\n       TSSO has a number of commands that are used to  direct  TSSO\n       processing.  All  such commands start with the TSSO SRC. The\n       examples below  assume  that  '#'  is  the  TSSO  SRC.   The\n       commands are listed below:\n\n         1.  #.RELOAD table-name\n\n             where  table-name  is  a  TSSO  Automated   Operations\n             Facility  table.  If  table-name  =  'NONE' the AOF is\n             deactivated. If an error occurs while  processing  the\n             table,  AOF  is  deactivated.  The  most common errors\n             include table-name not found, and table-name not being\n             a valid TSSO AOF table.\n\n         2.  #.P\n\n             is  used  to  terminate  the  Time  Sharing  Subsystem\n             Option.  TSSO  can  be  restarted through the \"S TSSO\"\n             command as documented above.\n\n         3.  #.J\n\n             is used to request a job  identification  number  from\n             the  primary  subsystem. This is required if TSSO will\n             be  using  the  primary  subsystems  services.   These\n             services include submitting  jobs (with the TSO SUBMIT\n             command), and using the PRINTOFF command.   Note  that\n             if  TSSO  was  started using the \"SUB=JES2\" parameter,\n             this command will have no effect.\n\n         4.  #.M\n\n             is used to manipulate  the  TSSO  debugging  facility.\n             This   command   should   not  be  used  under  normal\n             circumstances.\n\n         5.  #.ABEND\n\n             is used  to  abnormally  terminate  the  TSSO  address\n             space. This is another TSSO debugging aid which should\n             not be used in normal operation.\n\n         6.  #.Q\n\n             is used  to  query  certain  parameters  of  the  TSSO\n             subsystem. Individual subcommands are:\n\n               a.  #.QT\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 35 -\n\n\n\n                   will return the name of the TSSO AOF table.  The\n                   value  specified  on  the  ID  parameter  of the\n                   TABSTART macro is also displayed, in addition to\n                   the data and time the AOF table was assembled.\n\n               b.  #.QMAXCMD\n\n                   will return the value of the MAXCMDS  parameter,\n                   specified at TSSO startup.\n\n               c.  #.QSSSM\n\n                   will return  the  name  of  the  TSSO  subsystem\n                   support module.\n\n               d.  #.QSWAP\n\n                   will indicate if TSSO is running non-swappable.\n\n               e.  #.QRACF\n\n                   will return the  name  of  the  TSSO  RACF  user\n                   identifier.\n\n               f.  #.QMAXWTO\n\n                   will return the value of the  MAXWTO  parameter,\n                   specified at TSSO startup.\n\n               g.  #.QVERS\n\n                   will display the TSSO Version  identifier  (TSSO\n                   4.1)  and  the  date  and  times  that the TSSO,\n                   TSSOSSSM   and   TSSOWTO   modules   were   last\n                   assembled.\n             Note that TSSO control commands may be treated exactly\n             as  other  TSO commands when used in a TSSO CLIST. For\n             example, a CLIST  may  process  directives,  and  then\n             perform  a  .RELOAD  command  to  reload  the TSSO/AOF\n             table. It is also possible for a CLIST to  consist  of\n             nothing but TSSO commands. An example might be a CLIST\n             to query all the TSSO parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 36 -\n\n\n\n       TSSO_Commands_for_Emergency_Procedures\n\n       TSSO operates as a proper subsystem under  MVS.  Because  of\n       this,  it  can run without support of a Job Entry Subsystem,\n       or communications  subsystem.  This  means  that  TSSO  will\n       initialize,  even if JES or VTAM will not. TSSO, through the\n       use of several command processors,  provides  facilities  to\n       repair  critical  MVS files, or load modules, in the event a\n       subsystem does not initialize. The commands  are  summarized\n       below:\n\n         a.  The EF command, allows the  MVS  console  operator  to\n             perform  TSO  edit  commands  on the file allocated to\n             DDNAME 'EDITFILE'. This DDNAME could  have  been  pre-\n             allocated  through the ALLOCATE command. The syntax of\n             the EF command is as follows:\n\n             EF (;cmd1;cmd2;cmd3...;cmdn)\n\n             where cmdx are TSO EDIT commands.\n\n         b.  The PDS command, a public domain TSO facility, written\n             by  Bruce  Leland  from  Hitachi,  provides  for  TSSO\n             support. Through the PDS command, it  is  possible  to\n             rename,  delete  or  otherwise manipulate members of a\n             partitioned  dataset.  The  PDS   command   offers   a\n             tremendous  range  of  facilities,  and can be used to\n             recover from a wide variety of subsystem problems.\n\n         c.  Lastly,  it  is  possible  to  use  the  standard  TSO\n             facilities,  such  as the ALLOCATE command, to correct\n             JCL  or   other   initialization   errors   in   major\n             subsystems.   The  full  range  of  TSO  commands  are\n             available to assist in problem resolution.\n\n       ACKNOWLEDGEMENTS\n\n       The author wishes to thank Bill Godfrey, from  the  Planning\n       Research  Corporation,  for his work on the original version\n       of TSSO. Although 97% of the code has been replaced in  TSSO\n       Release 4.1, the idea of a user written subsystem to process\n       TSO commands was his. The author also wishes to  acknowledge\n       Bill for the EF command, the original version is still being\n       used. The  author  wishes  to  thank  Cheryl  Rahn  for  her\n       contribution  of  the CPCMD command.  The author also wishes\n       to thank Eileen Saks, for her work on this document, and Len\n       Castelli,  for   being  a  sounding  board  on  TSSO design.\n       Lastly, the author wishes to thank Bruce Leland  for  adding\n       TSSO support in his PDS command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                  - 37 -\n\n\n\n       CONCLUSIONS\n\n       This document has described the external interfaces  to  the\n       Time   Sharing   Subsystem  Option  package.  Any  questions\n       concerning TSSO, its uses, or its internal structure, may be\n       directed to the author at (201) 981-2796.\n\n\n\n       PY-25821-MAS-mas              M. A. Schare\n\n       Copy to\n       B. Clair\n       W. G. Ferrone\n       L. Garcia\n       B. L. Howard\n       C. P. Lewis\n       W. J. Lundy\n       S. P. Nathan\n       T. P. Senior\n       L. M. Szasy\n       J. J. Yostpille\n       Members: System Software District\n       Members: Technical Support District\n       District Managers: 25820\n       District Managers: 25850\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n       Module Descriptions        Page 1               Attachment 1\n\n\n\n       This attachment  is  a  brief  summary  of  TSSO  processing\n       modules.\n\n         1.  TSSO- The TSSO  mainline  routine.  This  module  gets\n             invoked when the MVS START command is issued for TSSO.\n\n         2.  TSSOSSSM- The  TSSO  subsystem  support  module.  This\n             module  contains the subsystem interface routines, and\n             is LOADED by TSSO.\n\n         3.  TSSOWTO- Is a module that copies the SYSTSPRT file  to\n             the  MVS console through the WTO macro. It also issues\n             the commands specified through TSSO OPF.\n\n         4.  TSSOESTA- The  TSSO  ESTAE  routine.  This  module  is\n             loaded as part of TSSO startup.\n\n         5.  TSSOPARS- Is the TSSO parse routine.  It  is  used  to\n             parse PARMLIB input, and to parse MVS console messages\n             in support of the  'W' formatting directive in AOF.\n\n         6.  JCECVT- Is the TSSO convert routine.  It  is  used  to\n             perform data conversions.\n\n         7.  CACHE- The TSO CACHE command.\n\n         8.  LINKLIST- The TSO LINKLIST command.\n\n         9.  REPLY and REPLYLOA- The TSO  REPLY  command,  and  the\n             module it loads into global storage.\n\n        10.  VALLOC- The TSSO VALLOC command.\n\n        11.  VOLSER- The TSSO VOLSER command.\n\n        12.  CPCMD- The TSSO CPCMD command.\n\n        13.  DISPAOF- The TSSO DISPAOF command for  displaying  the\n             contents of AOF tables.\n\n        14.  SPMON- The TSSO SPMON command.\n\n        15.  EF- The TSSO EDIT facility command.\n\n        16.  MULT- The TSSO MULT command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n       Sample AOF Table           Page 1               Attachment 2\n\n\n\n       This is the sample AOF table distributed with TSSO in member\n       AOFIVP of the TSSO.VERS41.ASM dataset.\n\n\n\n\n\n       ***********************************************************************\n       * THIS IS A SAMPLE AUTOMATED OPERATIONS FACILITY TABLE. IT IS USED AS *\n       * PART OF THE TSSO INSTALLATION VERIFICATION PROCEDURE. IT CONSISTS   *\n       * OF A SUBSET OF ALL POSSIBLE ENTRIES IN A TSSO/AOF TABLE.            *\n       *                                                                     *\n       * THIS AOF TABLE CAN BE USED IN CONJUNCTION WITH THE AOF/IVP,         *\n       * DISTRIBUTED WITH TSSO.                                              *\n       *                                                                     *\n       *                                                                     *\n       ***********************************************************************\n       AOFIVP   TABSTART ID=IVPTABLE\n       ***********************************************************************\n       * FIRST, A COUPLE OF REPLIES TO STANDARD ANNOYING MVS   MESSAGES.     *\n       ***********************************************************************\n       *\n       ***********************************************************************\n       * REPLY '' TO VTAM INITIALIZATION MESSAGE\n       ***********************************************************************\n                TABENTRY MSG=IST051A,ACTION=REPLY,TEXT=' '\n       *\n       ***********************************************************************\n       * REPLY 'SIC' TO TCAS TERMINATION MESSAGE\n       ***********************************************************************\n                TABENTRY MSG=IKT010D,ACTION=REPLY,TEXT='SIC'\n       ***********************************************************************\n       * REPLY 'SIC' TO TCAS TERMINATION MESSAGE\n       ***********************************************************************\n       *\n                TABENTRY MSG=IKT012D,ACTION=REPLY,TEXT='U'\n       ***********************************************************************\n       * REPLY 'POST' TO IMS BRINGUP ON UCB MESSAGE\n       ***********************************************************************\n       *\n                TABENTRY MSG=IEC804A,ACTION=REPLY,TEXT='POST'\n       *\n       ***********************************************************************\n       * THE NEXT ENTRY POINTS OUT THE HILIGHTING FEATURE. IEE704I IS THE    *\n       * MESSAGE ID FOR   REPLY XX IS NOT OUTSTANDING.                       *\n       ***********************************************************************\n                TABENTRY MSG=IEE704I,ACTION=HILIGHT\n       *\n       ***********************************************************************\n       * THE NEXT ENTRY DEMONSTRATES A POSSIBLE USE FOR THE OSCMD FEATURE.   *\n       * IEE043I IS THE MESSAGE YOU GET WHEN A SYSTEM LOG DATASET IS QUEUE   *\n\n\n\n\n\n\n\n\n\n\n\n       Sample AOF Table           Page 2               Attachment 2\n\n\n\n       * TO A GIVEN OUTPUT CLASS. THE #LOGWTRR4 PROGRAM (OR CLIST) CAN BE    *\n       * USED TO PROCESS THE LOG DATASET. THE XWTR PROC    CAN ALSO BE USED. *\n       * YOU CAN CAUSE THIS TO OCCUR BY ISSUING THE \"W Z\" COMMAND.           *\n       ***********************************************************************\n                TABENTRY MSG=IEE043I,ACTION=OSCMD,                            X\n                      TEXT='#LOGWTRR4'\n       *\n       ***********************************************************************\n       * WHEN THE LOGWTR PROGRAM TERMINATES, MESSAGE IEF176I IS ISSUED,      *\n       * INDICATING THE LOGWTR IS LOOKING FOR WORK. HAVE TSSO PURGE IT OUT.  *\n       * NOTE HOW IT USES THE DDD FROM THE MESSAGE TO FIGURE OUT WHAT TO     *\n       * PURGE. NOTE THAT THIS WILL WORK FOR ANY EXTERNAL WRITER.            *\n       * THIS IS AN EXAMPLE OF \"WORD\" FORMATTING IN THE TEXT= PARM.          *\n       ***********************************************************************\n                TABENTRY MSG=IEF176I,ACTION=OSCMD,                            X\n                      TEXT='P \\W03    \\'\n       *\n       ***********************************************************************\n       * THE NEXT EXAMPLE SHOWS POSITIONAL FORMATTING IN THE COMMAND TEXT.   *\n       * THE $HASP104 MESSAGE IS ISSUED WHENEVER A //*MESSAGE CARD IS        *\n       * ENCOUNTERED IN THE JOB STREAM. THE #RECMSG CLIST MEARLY RECORDS IN  *\n       * A DATASET (USING CLIST OPENFILE/PUTFILE/CLOSFILE TECHNIQUES) THE    *\n       * TEXT OF THE MESSAGE.                                                *\n       ***********************************************************************\n                TABENTRY MSG=$HASP104,ACTION=OSCMD,                           X\n                      TEXT='#RECMSG JOB(''\\P001,72\\'')'\n       *\n       ***********************************************************************\n       * ANOTHER EXAMPLE OF THE USE OF THE HILIGHTING FEATURE. HILIGHT THE   *\n       * MESSAGE INDICATING THAT VTAM IS UP.                                 *\n       ***********************************************************************\n                TABENTRY MSG=IST020I,ACTION=HILIGHT\n       *\n       ***********************************************************************\n       * IN ADDITION TO  HILIGHTING THE VTAM INITIALIZATION MESSAGE, ISSUE   *\n       * THE #VTAMR4 CLIST. THIS CLIST IS A OPERATOR CLIST THAT ISSUES       *\n       * MVS START COMMANDS FOR VTAM DEPENDANT PROGRAM PRODUCT, LIKE NCCF    *\n       * AND TSO.                                                            *\n       *                                                                     *\n       ***********************************************************************\n                TABENTRY MSG=IST020I,ACTION=OSCMD,TEXT='#VTAMR4'\n       *\n       ***********************************************************************\n       * DSI802A IS THE NCCF MESSAGE SAYING THAT YOU CAN ISSUE A VALID NCCF  *\n       * OPERATOR COMMAND. YOU DO NOT NEED TO KNOW THE MESSAGE NUMBER FOR    *\n       * THIS COMMAND, BECAUSE YOU CAN REPLY TO IT USING THE REPLY COMMAND   *\n       * SO WE LOWLIGHT THE MESSAGE, AND ALLOW IT TO ROLL OFF THE SCREEN.    *\n       * THIS IS AN EXMAPLE OF THE LOWLIGHTING FEATURE.\n       ***********************************************************************\n                TABENTRY MSG=DSI802A,ACTION=LOWLIGHT\n       *\n\n\n\n\n\n\n\n\n\n\n\n       Sample AOF Table           Page 3               Attachment 2\n\n\n\n       ***********************************************************************\n       * THIS IS AN EXAMPLE OF A SUPPRESS CONDITION. $HASP309 IS A MESSAGE   *\n       * THAT JES2 ISSUES EVERY TIME AN INITIATOR GOES INACTIVE. THIS MESSAGE*\n       * IS NOW SUPPRESSED.                                                  *\n       ***********************************************************************\n                TABENTRY MSG=$HASP309,ACTION=SUPPRESS\n       ***********************************************************************\n       * WE WILL NOW DISPLAY SOME OF THE POWER OF THE TEST CONDITIONS. THE   *\n       * FOLLOWING DEMONSTRATIONS ALL TRAP THE $HASP395 JOB ENDED MESSAGE,   *\n       * HOWEVER, THE ACTION= PARAMETER IS EXECUTED ONLY IF ALL CONDITIONS   *\n       * FOR THE TESTS ARE MET. FOR EXAMPLE, OUR FIRST CASE WILL ONLY        *\n       * HILIGHT THE MESSAGE IF THE JOB THAT HAS ENDED IS NAMED \"PAYROLL\".   *\n       * THIS TEST CASE SPECIFIES THAT (1) WORDS ARE BEING TESTED, (2), THAT\n       * IT IS THE SECONDWORD WE ARE INTERESTED IN, (3), WE ARE INTERESTED IN\n       * THE FIRST SEVEN CHARACTERS OF THAT WORD, (4), WE WISH TO MATCH THE\n       * STRING 'PAYROLL', AND      (5), WE WILL USE FOUR BLANKS AS THE\n       * SEPARATOR CHARACTORS WHEN DEFINING A WORD.\n       * NOTE THAT THE DOUBLE PARENTHESIS ARE REQUIRED.\n       ***********************************************************************\n                TABENTRY  MSG=$HASP395,ACTION=HILIGHT,                        X\n                      TEST=((W,2,7,'PAYROLL','    '))\n       *\n       ***********************************************************************\n       * THE NEXT ENTRY IS AN EXAMPLE OF A TEST CONDITION BASED ON SUBSTRING,*\n       * OR COLUMNS. THE MESSAGE WILL THE JES2 $HAS648 MESSAGE, WHICH IS     *\n       * THE RESPONSE TO A $DU,STA. THIS ENTRY WILL SUPPRESS ALL LINES FROM  *\n       * THE JES2 RESPONSE THAT ARE SNA LINES (COLS 20 THROUGH 22 = 'SNA'    *\n       *                                                                     *\n       ***********************************************************************\n                TABENTRY  MSG=$HASP628,ACTION=SUPPRESS,                       X\n                      TEST=((S,20,3,'SNA'))\n       *\n       ***********************************************************************\n       * THE NEXT ENTRY IS AN EXAMPLE OF A LOGICAL AND CONDITION BETWEEN TEST*\n       * CASES. BOTH CRITERIA MUST BE SATISIFED FOR THE TESTS TO PASS.       *\n       * THE TEST CASE WILL AN MVS/JES2 JOB AWAITING EXECUTION IN A CERTAIN  *\n       * JOB CLASS. THIS ENTRY WILL TAKE A $DN COMMAND, AND ISSUE AN OSCMD   *\n       * TO RAISE THE PRIORITY OF JOBS AWAITING EXECUTION IN CLASS 9 TO \"15\" *\n       * (YES, I REALIZE THIS DOESNT MAKE MUCH SENSE, BUT ITS GOOD FOR DEMO  *\n       * PURPOSES).\n       * NOTE THAT THE THIRD WORD IS CHECKED FOR \"AWAITING\" AND THE FOURTH   *\n       * WORD IS CHECK FOR EXECUTION, AND THE FIFTH WORD IS THE JOB CLASS.   *\n       * ALSO NOTE HOW THE SECOND WORD OF THE MESSAGE (THE JOB NAME) IS USED *\n       * IN FORMING THE TEXT= OPERAND. OSCMDT WILL BE USED SO THE COMMAND    *\n       * DOESNT ACTUALLY GET ISSUED.\n       * NOTE ALSO THAT YOU DONT NEED TO SPECIFY FOUR BLANKS- ONE IS         *\n       * SUFFICIENT WHEN GENERATING TEST CASES.\n       ***********************************************************************\n                TABENTRY MSG=$HASP608,ACTION=OSCMDT,                          X\n                      TEXT='$T''\\W    02\\'',P=15',                            X\n                      TEST=((W,3,8,'AWAITING','  '),(W,4,9,'EXECUTION','    ')X\n\n\n\n\n\n\n\n\n\n\n\n       Sample AOF Table           Page 4               Attachment 2\n\n\n\n                      ,(W,5,1,'9',' '))\n       *\n       ***********************************************************************\n       * THE LAST CASE IS A GENERIC MESSAGE. THIS MESSAGE IS MATCHED BY      *\n       * EVERY SINGLE WTO OR WTOR THAT COME ACROSS, EXCEPT IT MUST STILL     *\n       * PASS THE TEST CONDITIONS. THIS EXAMPLE I WILL GIVE HILIGHTS ALL JES *\n       * MESSAGES CONCERNING JOB ENDOFDAY.THESE MESSAGES ALL START WITH      *\n       * $HASP (WORD 1) AND CONTAIN THE JOBNAME IN WORD 2.                   *\n       *                                                                     *\n       ***********************************************************************\n                TABENTRY MSG=*,ACTION=HILIGHT,                                X\n                      TEST=((W,1,5,'$HASP',' '),(W,2,7,'ENDOFDAY',' '))\n       ***********************************************************************\n       * THIS TABEND MACRO DEFINES THE END OF THE AUTOMATED OPERATIONS       *\n       * FACILITY TABLE.                                                     *\n       *                                                                     *\n       * DO NOT LEAVE THE TABEND MACRO OUT OF THIS ASSEMBLY.                 *\n       *                                                                     *\n       ***********************************************************************\n                TABEND\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n       AOF Processing Algorithm   Page 1               Attachment 3\n\n\n\n       TSSO Automated Operations Facility- Text Processing\n       Algorithm\n\n       This section will describe the algorithm used in forming the\n       MVS  operator  commands issued as a result of processing the\n       ACTION=OSCMD directive under the TSSO  Automated  Operations\n       Facility.  To describe this algorithm, several terms must be\n       defined. First, action-text  is  defined  as  the  parameter\n       specified in the TEXT operand of the TABENTRY macro. WTOTEXT\n       is the text of the console message that was matched  by  the\n       MSG  parameter. Therefore, the first 8 bytes of WTOTEXT must\n       have matched an entry in the AOF table, as specified by  the\n       MSG  parameter.  Lastly, cmd-buffer is defined as the buffer\n       that will  be passed to MVS to be executed  as  an  operator\n       command.\n\n       The algorithm in forming the command buffer is described  in\n       the following paragraphs.\n\n         1.  Copy characters from action-text to  cmd-buffer  until\n             no more characters are found, or a '\\' is located. The\n             '\\'  is  defined  as  a  significance  indicator   and\n             indicates to AOF that characters or words from WTOTEXT\n             are to be copied.  When a  significance  indicator  is\n             detected, go to step 2. When no more characters remain\n             in  action-text,  pass  the   command   to   MVS   for\n             processing, and terminate.\n\n         2.  The  character  after   the   significance   indicator\n             determines the type of formatting to be performed. Two\n             characters  are   permissible.   The   'P'   directive\n             indicates   positional   formatting,   while  the  'W'\n             directive indicates word formatting. If the  character\n             is  a 'P', go to step 3, if the character is a 'W', go\n             to step 4.\n\n         3.  The syntax of  the  positional  formatting  option  is\n             defined  here. To use position formatting, the syntax,\n             including the leading '\\P' must be\n\n             \\Pnnn,yy\\\n\n             where 'P' indicates positional formatting,  the  'nnn'\n             are  numeric  characters  that  specify  the  starting\n             position in WTOTEXT, and the 'yy' indicates the number\n             of  characters starting from position 'nnn' to copy to\n             the command buffer. Thus, it is  possible  to  include\n             all  or  part of WTOTEXT in the operator command to be\n             issued. For example, if\n\n             \\P032,08\\\n\n\n\n\n\n\n\n\n\n\n\n       AOF Processing Algorithm   Page 2               Attachment 3\n\n\n\n             was coded, then character positions 32-39  of  WTOTEXT\n             would  be  copied  to  cmd-buffer.  The syntax for the\n             positional parameter is  very  rigid.  Leading  zeroes\n             must  be specified, and the final '\\' must be present.\n             Processing continues at  step  1  with  the  character\n             following the final '\\'\n\n         4.  The  syntax  of  the  'word'  formatting   option   is\n             described  here.  A  word  is  defined  as a string of\n             characters  separated  by  separator  characters.  The\n             maximum  size  of  a word is 16 bytes. To use the word\n             formatting option, code\n\n             \\Wabcdnn\\\n\n             where 'W' indicates word formatting, the 'a', 'b', 'c'\n             and 'd' specify separator characters to be used in the\n             definition of a word, and  'nn'  is  a  numeric  value\n             indicating  which  word  to  use. The selected word is\n             then copied to cmd-buffer. For example if\n\n             \\W=,  03\\\n\n             were coded, it would be interpreted  as  follows.  The\n             'W'   selects  word  formatting,  and  the  next  four\n             characters,  '=', ',', ' ', and ' ' are used  as  word\n             separator  characters. In this example, the third word\n             is copied from WTOTEXT into cmd-buffer. The syntax  of\n             the  'W'  directive if very strict. If you do not need\n             four separator characters, you must code blanks (as in\n             the  example). The numeric specification must have two\n             digits (including a leading zero if required) and  the\n             terminating  '\\'  is required. Processing continues at\n             step 1, with the character  following  the  last  '\\'.\n             Note  that a word is at most, 16 characters in length,\n             and  is  copied  to  cmd-buffer  without  leading   or\n             trailing blanks.\n\n       Note that the  formatting  options  are  only  available  if\n       ACTION=OSCMD or ACTION=OSCMDT is specified.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n       Sample Parameters          Page 1               Attachment 4\n\n\n\n       TSSO_Sample_Parameter_Deck\n\n       This attachment is an actual TSSO parameter deck. This  deck\n       is in file SAMPPARM in the TSSO.VERS41.ASM dataset.\n\n       ***********************************************************************\n       * THIS IS A TYPICAL TSSO PARAMETER DECK FOR A TYPICAL SYSTEM. THE     *\n       * DOCUMENTATION IS   IN \"TSSO SYSTEM PROGRAMMERS GUIDE- RELEASE 4.1   *\n       * THESE VALUES SHOULD WORK AS DEFAULTS.                               *\n       ***********************************************************************\n       ************************************************************\n       SSSM=TSSOSSSM\n       ************************************************************\n       * SUB SYSTEM SUPPORT MODULE IS \"TSSOSSSM\"                  *\n       ************************************************************\n       NONSWAP=Y\n       ************************************************************\n       * TSSO WILL BE RUNNING NON-SWAPABBLE                       *\n       ************************************************************\n       TABLE=AOFR4\n       ************************************************************\n       * THE TABLE NAME FOR TSSO AOF WILL BE AOFR4                *\n       ************************************************************\n       RACFID=TSSO\n       ************************************************************\n       * TSSO WILL ASSUME A RACF USERID OF \"TSSO\" ON STARTUP      *\n       ************************************************************\n       SRC=#\n       ************************************************************\n       * THE COMMAND RECOGNITION CHARACTER IS A POUND SIGN ('#')  *\n       ************************************************************\n       MAXCMDS=15\n       ************************************************************\n       * TSSO WILL HANDLE AT MOST 15 SIMULTANEOUS COMMANDS        *\n       ************************************************************\n       MAXWTO=250\n       ************************************************************\n       * TSSO WILL ISSUE AT MOST 250 WTOS FOR ANY ONE COMMAND     *\n       ************************************************************\n       PROMPT=NO\n       ************************************************************\n       * DO NOT PROMPT THE MVS OPERATOR FOR ADDITIONAL TSSO       *\n       * PARAMETERS                                               *\n       ************************************************************\n       END\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USEGDE42": {"ttr": 47107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x9f\\x00\\x97&\\x9f\\x01\\x05\\x0b\\x84\\x0b\\x84\\x00\\x00\\xe3\\xe2\\xe2\\xd6\\xf4\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-26T00:00:00", "modifydate": "1997-09-26T01:05:00", "lines": 2948, "newlines": 2948, "modlines": 0, "user": "TSSO403"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "VALLOC": {"ttr": 48138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x966_\\x00\\x966_\\x12G\\x00~\\x00~\\x00\\x00\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-30T12:47:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "RPS"}, "text": "          PRINT GEN\nVALLOC     MENTER  12,EQU,COM=VALLOC,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n***********************************************************************\n* THIS PROGRAM WILL PERFORM THE IOS LOOKUP TABLE FUNCTION.            *\n* IT IS MEANT TO BE EXECUTED UNDER THE TSSO SUBSYSTEM.\n* COMMAND SYNTAX-     #VALLOC VOLUME\n* IF NO VALLOC IS SPECIFIED, THE SYSTEM RESIDENCE UCB WILL BE\n* DISPLAYED.\n\n*         +---------+\n*         + CHANGES +\n*         +---------+\n* 30DEC96 RPS FIXED ADDRESSABILITY ERRORS WITH HLASM\n***********************************************************************\n         SETPARSE PCL=PARSEPCL\n         CALLTSSR EP=IKJPARS\n         CH     R15,=H'3'\n         BH     TRUB1             RC = 4 OR ABOVE\n         L      R4,MYANS\n         USING  IKJPARMD,R4\n         TM     VOLSERP+6,X'80'       IS VOLSER PRESENT?\n         BNO    USERES\n         LH     R3,VOLSERP+4          GET LENGTH\n         CH     R3,=H'6'              VOLSER IS 6 BYTES !\n         BNE    INVALID               GET ADDR OF PARM\n         L      R3,VOLSERP            POINT THO THE VOLSER\n         MVC    VOLDES(6),0(R3)\n         OC     VOLDES(6),=CL6' '     MAKE UPPER CASE\n         L      R3,16\n         USING  CVTMAP,R3\n         XC     WORKAREA(100),WORKAREA     ZERO OUT WORKAREA\n         LA     R1,WORKAREA\n         ST     R1,PARM1\n         LA     R1,DEVCLASS\n         ST     R1,PARM2\n         LA     R1,UCBADDR\n         ST     R1,PARM3\n         OI     PARM3,X'80'\nSRCHIT   DS     0H\n         LA     R1,PARMLIST\n         L      R15,CVTUCBSC\n         BALR   R14,R15\n         LTR    R15,R15\n         BNZ    ENDLIST\n         B      FORMUCB\nUSERES   DS     0H\n***********************************************************************\n* IF NO VOLSER WAS SPECIFIED IN THE COMMAND, THE PROGRAM WILL JUMP HERE\n* POINTING TO THE UCB FOR THE SYSTEM RESIDENCE VOLUME.\n***********************************************************************\n         DROP   R3                                                 RPS\n         L      R5,16\n         USING  CVT,R5\n         L      R5,CVTSYSAD\n         DROP   R5\n         ST     R5,UCBADDR\n         MVC    VOLDES(6),28(R5)\n         B      FORMUCB\nFORMUCB  DS     0H\n         FORMAT (UCBADDR,4,XXXXXXXX),TO=UCBECB,WKA=WKA\n         L      R5,UCBADDR\n         MVC    MSG2+9(3),13(R5)\n         MVC    MSG2+21(6),28(R5)\n         MVC    MSG2+37(8),UCBECB\n         CLC    28(6,R5),VOLDES\n         BE     FINIT\nCONVEXIT DS     0H\n         B      SRCHIT\nTRUB1    DS     0H\n         WTO    'IKJPARSE FAILURE, CONTACT SUPPORT',ROUTCDE=(2,11)\n         B      ENDPROG\nINVALID  WTO   'INVALID VOLSER SPECIFIED- REENTER COMMAND',            X\n               ROUTCDE=(2,11)\n         B      ENDPROG\nFINIT    DS     0H\n         PUTLINE PARM=PUTBLOK,                                         X\n               OUTPUT=(MSG2,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         MVC   OPERMSG+16(3),13(R5)\n         PUTLINE PARM=PUTBLOK,                                         X\n               OUTPUT=(OPERPUT,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         B     ENDPROG\nENDLIST  DS     0H\n         MVC   MSG4+19(6),VOLDES\n         PUTLINE PARM=PUTBLOK,OUTPUT=(MSG4,TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\nENDPROG  DS    0H\n         MLEAVE\nPARSEPCL IKJPARM\nVOLSERP  IKJIDENT 'VOLSER',UPPERCASE,MAXLNTH=6,FIRST=ALPHA,            X\n               OTHER=ALPHANUM,CHAR,                                    X\n               HELP=('VOLSER IN THE FORM XXXXXX')\n         IKJENDP\nPUTECB   DS     F\nMSG2     DC     H'80',H'0'\n         DC     CL80'UCB: XXX, VOLSER=YYYYYY, UCBADDR=ZZZZZZZZ'\nMSG4     DC     H'80',H'0'\nMSG4TEXT DC     CL80'TSSO01I VOLSER XXXXXX IS NOT IN THE SYSTEM'\nOPERPUT  DC     H'80',H'0'\nOPERMSG  DC     CL80'*COM D U,,ALLOC,XXX,1'\nUCBECB   DC     CL8' '\nWKA      DC     CL12' '\nUCBADDR  DS     F\nVOLDES   DC     CL80' '             VOLUME DESIRED\nDEVHEX   DS     F\nADDRECB  DC     CL8' '\nCURRADDR DS     F                   STATUS OF SEARCH IN UCBS\nPARMLIST DS     0D\nPARM1    DS     F\nPARM2    DS     F\nPARM3    DS     F\nWORKAREA DS     XL100\nDEVCLASS DC     XL1'00'\nNUM      DS     F\nCOMLIST  DS     0H\n         PRINT  NOGEN\n         CVT    DSECT=YES\n         IKJIOPL\n         END VALLOC\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY VALLOC(''V 1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    VALLOC'\n PUNCH ' NAME     VALLOC(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VOLSER": {"ttr": 48386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x966_\\x00\\x966_\\x12H\\x00~\\x00~\\x00\\x00\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-30T12:48:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "RPS"}, "text": "          PRINT GEN\nVOLSER    MENTER  12,EQU,COM=VOLSER,CP=CP\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n***********************************************************************\n* THIS PROGRAM WILL PERFORM THE IOS LOOKUP TABLE FUNCTION.            *\n* IT IS MEANT TO BE EXECUTED UNDER THE TSSO SUBSYSTEM.\n* COMMAND SYNTAX-     #VOLSER VOLUME\n* IF NO VOLSER IS SPECIFIED, THE SYSTEM RESIDENCE UCB WILL BE\n* DISPLAYED.\n\n*         +---------+\n*         + CHANGES +\n*         +---------+\n* 30DEC96 RPS FIXED ADDRESSABILITY ERRORS WITH HLASM\n***********************************************************************\n         SETPARSE PCL=PARSEPCL\n         CALLTSSR EP=IKJPARS\n         CH     R15,=H'3'\n         BH     TRUB1             RC = 4 OR ABOVE\n         L      R4,MYANS\n         USING  IKJPARMD,R4\n         TM     VOLSERP+6,X'80'       IS VOLSER PRESENT?\n         BNO    USERES\n         LH     R3,VOLSERP+4          GET LENGTH\n         CH     R3,=H'6'              VOLSER IS 6 BYTES !\n         BNE    INVALID               GET ADDR OF PARM\n         L      R3,VOLSERP            POINT THO THE VOLSER\n         MVC    VOLDES(6),0(R3)\n         OC     VOLDES(6),=CL6' '     MAKE UPPER CASE\n         L      R3,16\n         USING  CVTMAP,R3\n         XC     WORKAREA(100),WORKAREA     ZERO OUT WORKAREA\n         LA     R1,WORKAREA\n         ST     R1,PARM1\n         LA     R1,DEVCLASS\n         ST     R1,PARM2\n         LA     R1,UCBADDR\n         ST     R1,PARM3\n         OI     PARM3,X'80'\nSRCHIT   DS     0H\n         LA     R1,PARMLIST\n         L      R15,CVTUCBSC\n         BALR   R14,R15\n         LTR    R15,R15\n         BNZ    ENDLIST\n         B      FORMUCB\nUSERES   DS     0H\n***********************************************************************\n* IF NO VOLSER WAS SPECIFIED IN THE COMMAND, THE PROGRAM WILL JUMP HERE\n* POINTING TO THE UCB FOR THE SYSTEM RESIDENCE VOLUME.\n***********************************************************************\n         DROP   R3                                               RPS\n         L      R5,16\n         USING  CVT,R5\n         L      R5,CVTSYSAD\n         DROP   R5\n         ST     R5,UCBADDR\n         MVC    VOLDES(6),28(R5)\n         B      FORMUCB\nFORMUCB  DS     0H\n         FORMAT (UCBADDR,4,XXXXXXXX),TO=UCBECB,WKA=WKA\n         L      R5,UCBADDR\n         MVC    MSG2+9(3),13(R5)\n         MVC    MSG2+21(6),28(R5)\n         MVC    MSG2+37(8),UCBECB\n         CLC    28(6,R5),VOLDES\n         BE     FINIT\nCONVEXIT DS     0H\n         B      SRCHIT\nTRUB1    DS     0H\n         WTO    'IKJPARSE FAILURE, CONTACT SUPPORT',ROUTCDE=(2,11)\n         B      ENDPROG\nINVALID  WTO   'INVALID VOLSER SPECIFIED- REENTER COMMAND',            X\n               ROUTCDE=(2,11)\n         B      ENDPROG\nFINIT    DS     0H\n         PUTLINE PARM=PUTBLOK,                                         X\n               OUTPUT=(MSG2,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         MVC   OPERMSG+11(3),13(R5)\n         PUTLINE PARM=PUTBLOK,                                         X\n               OUTPUT=(OPERPUT,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         B     ENDPROG\nENDLIST  DS     0H\n         MVC   MSG4+19(6),VOLDES\n         PUTLINE PARM=PUTBLOK,OUTPUT=(MSG4,TERM,SINGLE,DATA),          X\n               MF=(E,IOPLADS)\nENDPROG  DS    0H\n         MLEAVE\nPARSEPCL IKJPARM\nVOLSERP  IKJIDENT 'VOLSER',UPPERCASE,MAXLNTH=6,FIRST=ALPHA,            X\n               OTHER=ALPHANUM,CHAR,                                    X\n               HELP=('VOLSER IN THE FORM XXXXXX')\n         IKJENDP\nPUTECB   DS     F\nMSG2     DC     H'80',H'0'\n         DC     CL80'UCB: XXX, VOLSER=YYYYYY, UCBADDR=ZZZZZZZZ'\nMSG4     DC     H'80',H'0'\nMSG4TEXT DC     CL80'TSSO01I VOLSER XXXXXX IS NOT IN THE SYSTEM'\nOPERPUT  DC     H'80',H'0'\nOPERMSG  DC     CL80'*COM D U,,,XXX,1'\nUCBECB   DC     CL8' '\nWKA      DC     CL12' '\nUCBADDR  DS     F\nVOLDES   DC     CL80' '             VOLUME DESIRED\nDEVHEX   DS     F\nADDRECB  DC     CL8' '\nCURRADDR DS     F                   STATUS OF SEARCH IN UCBS\nPARMLIST DS     0D\nPARM1    DS     F\nPARM2    DS     F\nPARM3    DS     F\nWORKAREA DS     XL100\nDEVCLASS DC     XL1'00'\nNUM      DS     F\nCOMLIST  DS     0H\n         PRINT  NOGEN\n         CVT    DSECT=YES\n         IKJIOPL\n         END VOLSER\n PUNCH ' SETCODE  AC(0)'\n PUNCH ' IDENTIFY VOLSER(''V 1.0 &SYSDATE &SYSTIME'') '\n PUNCH ' ENTRY    VOLSER'\n PUNCH ' NAME     VOLSER(R)'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WORKS9A": {"ttr": 48389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x01\\x1f\\x01\\x18\\x01\\x1f\\x19\\x06\\x05\\x9f\\x05\\x9f\\x00\\x00\\xd6\\xd3\\xc4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-11T00:00:00", "modifydate": "2018-01-11T19:06:19", "lines": 1439, "newlines": 1439, "modlines": 0, "user": "OLD"}, "text": "TSSOSS09 TITLE 'TSSO - ROUTINE TO PROCESS SUB SYSTEM FUNCTION 09'\nTSSOSS09 CSECT\n************************************************************\n*\n*        PDSDOC *SPRECHER ENERGIE VERSION OF TSSOSS09 WITH ML WTO FIXED\n*\n* THIS IS THE ENTRY POINT FOR THE TSSO AUTOMATED OPERATIONS FACILITY\n* WTO AND WTOR INTERCEPT ROUTINE. THE SUBSYSTEM INTERFACE CODE 9\n* PROVIDES THE FACILITY FOR SUBSYSTEMS TO INTERCEPT ALL WTO AND WTOR\n* REQUESTS, AND TAKE ACTION. THE SPECIFIC ACTIONS THAT TSSO/AOF WILL\n* TAKE IS DETERMINED BY A TABLE, LOADED AT SUBSYSTEM (TSSO)\n* INITIALIZATION TIME.\n*\n* THE FORMAT OF THE TABLE IS COMPLEX, AND BEST DOCUMENTED IN THE\n* DISPAOF TSSO COMMAND, INCLUDED WITH TSSO.\n*\n* SPECIFIC ACTIONS ARE:\n* OSCMD - ISSUE AN OPERATING SYSTEM, JES OR TSSO COMMAND IS RESPONSE\n*         TO THE MESSAGE\n*\n* OSCMDT - SIMULATE THE ISSUANCE OF THE COMMAND, BY WTO INSTEAD\n*          OF WTOR THE MESSAGE.\n*\n* HILITE - HILIGHT THE MESSAGE BY TURNING ON THE WQEDCMA BIT.\n*\n* SUPPRESS- SUPPRESS THE MESSAGE.\n*\n*    TSSO (VERSION 4.1) PROVIDES THE FACILITY FOR TESTING CERTAIN\n* (ACTUALLY, ANY) FIELD IN THE MESSAGE BY WORD OR SUBSTRING CONTENT\n* BEFORE ACTUALLY DECIDING TO PERFORM THE ACTION SPECIFIED.\n*\n*    TSSO (VERSION 4.1) WILL SCAN THE *ENTIRE* TABLE FOR THE\n* MESSAGE IDENTIFIER, EVEN WHEN ENCOUNTERED, THUS MULTIPLE ACTIONS\n* MAY BE SPECIFIED FOR THE SAME MESSAGE, UNDER DIFFERENT TEST\n* CONDITIONS. THE USER IS URGED TO READ NOT ONLY THE TSSO SOURCE CODE,\n* BUT THE TSSO SYSTEMS PROGRAMMING REFERENCE GUIDE, FOR DETAILS\n* ON TSSO/AOF USAGE.\n*\n***********************************************************************\n* TSSO VERSION 4.2 PROVIDES THE UNPARALLED ABILITY TO ISSUE MVS       *\n* OPERATOR COMMANDS FROM A TSSO CLIST, AND GET THE RESPONSE BACK TO   *\n* THE CLIST. THIS IS ACCOMPLISHED THROUGH COMMUNICATION BETWEEN THE   *\n* OSCMD COMMAND, AND THIS MODULE. THIS MODULE WILL CHECK IF MESSAGES  *\n* ARE TO BE INTERCEPTED. IF YES, IT WILL INTERCEPT ALL MESSAGES       *\n* DESTINED TO THE CONSOLE OBTAINED BY TSSO AS A SUBSYSTEM CONSOLE, AND*\n* STORE THEM IN A GLOBAL BUFFER PROVIDED BY THE OSCMD COMMAND.        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TSSO VERSION 4.3 ADDS THE FOLLOWING FUNCTION TO THIS MODULE:        *\n*                                                                     *\n* 1) SUPPORT FOR MULTIPLE SUBSYSTEM CONSOLES.                         *\n*                                                                     *\n* 2) SUPPORT FOR ACTION=POST IN THE AOF TABLES.                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n* NOTE: LAST MSGID IS 209.                                            *\n*                                        MARC.\n***********************************************************************\n*                                                                     *\n* 12JUL92 CART1 MAKE SOME CHANGES FOR MLWTO                           *\n* 19AUG92 CART1 ON TEST BLEW UP IEFJRASP LEADING TO IPL. ALTER MATCH  *\n*               FAIL CODE TO EXIT IMMEDIATELY.                   *SEAG*\n* 24AUG92 CART1 RECODE 'SEDOLINE' TO AVOID THE 0C4'S. THIS ALLOWS US  *\n*               TO USE IT IN PARSING THE TESTS TO RESTRICT PROCESSING *\n*               TO ONE MINOR WQE. ALSO REDUCE OVERHEAD BY TESTING FOR *\n*               TABLE ENTRY NAME AND STOP IF ENTRY MATCHED WITH NO    *\n*               ENTRY NAME (DEFAULT ENTR..).                          *\n* 26AUG92 CART1 RECODE 'SEDOLINE' FOR USE IN TESTS ONLY, NOT TEXT.    *\n*               THE REASON IS THAT THE COMMS TASK ONLY GIVES US A CSA *\n*               COPY OF THE WQE WHICH IS IN THE COMMS TASK ADDRESS    *\n*               SPACE. THUS WE CANNOT RUN THE LIST OF WQE'S. BY USING *\n*               DATA IN THE TEST CONTROL BLOCK WE CAN COUNT THE NUMBER*\n*               OF TIMES WE ARE CALLED FOR THIS MAJOR WQE.            *\n* 09SEP92 CART1 ADD 'ACTION=NONE' TO PROVIDE A 'STOP' FACILITY TO     *\n*               REDUCE RUNNING COSTS.                                 *\n*                                                                     *\n* 15OCT92  GLA  INCORPORATE NECESSARY FIXES FROM 4.2                  *\n*                 A. FIX BUG IN LOWLIGHT ROUTINE. CAUSES EVENTUAL ACT *\n*                    MESSAGES NOT TO BE LOWLIGHTED.                   *\n*                 B. FIX BUG IN AOF TABLE PROCESSING FOR MESSAGE.     *\n*                    ORIGINAL CODE WAS NOT CLEARING THE OUTPUT TOKEN  *\n*                    TABLE FULLY. ANY ATTEMPT TO ACCESS WORDS 17      *\n*                    TO 20 IN A MESSAGE WOULD RESULT IN GARBAGE.      *\n*                                                                     *\n* 20OCT92  GLA  INSTALL NEW DSECT FOR AOF TABLES                      *\n*                                                                     *\n* 30OCT92  GLA -USE BINARY SEARCH TABLE INDEX TO AOF TABLE.           *\n*              -GO BACK TO ORIGINAL PROCESSING OF ALL ENTRIES THAT    *\n*               MATCH ID, WITH ONE EXCEPTION, PROCESS ALL MSG=*       *\n*               ENTRIES AFTER ALL MSG=ID THAT MATCH.                  *\n*                                                                     *\n* 14SEP92 CART1 ADD CODE TO TEST FOR MPF MESSAGE SUPPRESSION. IF YOU  *\n*               MPF SUPPRESS A MESSAGE THAT IS ITS SINGLE POINT OF    *\n*               CONTROL.                                              *\n*                                                                     *\n* 14DEC92  GLA  ADD NEW PARAMETER TO TURN ABOVE FEATURE ON OR OFF.    *\n*                                                                     *\n* 30DEC96  RPS  FIXED ADDRESSABILITY ERROR WITH HLASM                 *\n*                                                                     *\n* 17SEP99  DHC  RESTORE TEST FOR ENTRY NAME TO GIVE BOOLEAN LOGIC*AGCO*\n*                                                               EEJ1102\n* NOV 2002 EEJ  Support 4-byte reply IDs                        EEJ1102\n*          DHC  Allow eXclusion testing (WX and SX)              *AGCO*\n***********************************************************************\n*\n* REGISTER USAGE:\n*   R11: POINTS TO THE GETMAINED STORAGE AREA FOR THE LIFE OF THE\n*        ROUTINE\n*   R9 : POINTS TO THE SSOB EXTENTION FOR THE LIFE OF THE ROUTINE\n*   R8 : POINTS TO THE TSSO CVT FOR THE LIFE OF THE ROUTINE.\n*   R7 : POINTS TO THE TSSO AOF TABLE, FOR THE LIFE OF THE ROUTINE.\n*   R6 : POINTS TO THE CURRENT TEST ENTRY FOR THE LIFE OF THE ROUTINE.\n************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOSS09,R12         GET ADDRESSIBILITY\n         B      AR1\n         DC     CL8'&SYSDATE'      GET THE DATE\n         DC     CL8'&SYSTIME'      GET THE TIME\nAR1      DS     0H\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1\n         GETMAIN RC,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         LTR    R15,R15\n         BNZ    FUNC9EX3           STORAGE AVAILABLE.\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n*\n         GETMAIN RC,LV=4096         GET SOME STORAGE...\n         LTR    R15,R15\n         BNZ    GETMERR\n         LR     R11,R1\n         USING  FUN9DATA,R11\n*\n         LR     R10,R8\n         USING  SSOB,R10\n         ST     R10,SSOBADDR\n*\n         GETCVT (R8)               FIND TSSO CVT                   RPS\n         USING TSSOCVT,R8\n*\n         L     R9,SSOBINDV         POINT TO WTO EXTENSION\n         ST    R9,SSWTADDR         SAVE IT FOR FUTURE...\n         USING SSWTBGN,R9\n*\n         DROP  R10\n         MVC   POST1D(POST1CE-POST1C),POST1C\n         XC    MAJWQEAD(4),MAJWQEAD\n         XC    MINWQEAD(4),MINWQEAD\n         XC    MAJOREAD(4),MAJOREAD\n         XC    FUNC9RC(2),FUNC9RC   INIT RETURN CODE\n***********************************************************************\n* THE FIRST ORDER OF BUSINESS IS TO SEE IF MESSAGE TRAPPING IS ACTIVE *\n* FOR AN SS CONSOLE. IF SO, WE WILL QUEUE UP THE MESSAGE BASED ON THE *\n* INFORMATION OBTAINED FROM THE OSCMDICB, WHICH IS CHAINED OFF THE    *\n* SSCONCB FOR THE SPECIFIC CONSOLE.                                   *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n* THE NEXT STEP(S) CONCERN WHETHER TO INTERCEPT THIS MESSAGE. TSSO    *\n* MUST HAVE OBTAINED A SUBSYSTEM CONSOLE, AND THE INCOMING MESSAGE    *\n* MUST BE DESTINED FOR THAT SUBSYSTEM CONSOLE (IN FIELD TSSCONID).    *\n* IF EITHER OF THESE CONDITIONS ARE NOT MET, WE FORGET THIS MESSAGE.  *\n***********************************************************************\n         L     R5,SSWTWQE          ADDRESS THE WQE.\n         ST    R5,MAJWQEAD         REMEMBER THE MAJOR WQE\n*        ST    R5,WQEADDR          REMEMBER IT IN TWO PLACES\n         USING WQE,R5\n***********************************************************************\n* WE MUST DETERMINE IF ANY TSSO SUBSYSTEM CONSOLE IS CURRENTLY        *\n* INTERCEPTING MESSAGES, AND, IF THEY ARE, WHICH ONE MATCHES THIS     *\n* CONSOLE ID. LETS LOOP THROUGH THE SUBSYSTEM CONSOLES.\n***********************************************************************\n* NOTE THAT THE WQEUCMID FIELD IS IN THE SAME PLACE FOR MAJOR AND\n* NORMAL WQE'S\n***********************************************************************\n         XR    R6,R6               WIPE REGISTER\n         IC    R6,WQEUCMID         PICK UP THE CONSOLE THIS GUY IS\n*                                  DESTINED FOR\n         L     R7,SSCONSAD         THIS, FROM THE TSSO CVT\n         LTR   R7,R7               DO WE HAVE ONE ?\n         BZ    PART1EXT            TSSO HAS PROBLEMS...\n         USING SSCONCBH,R7\n         LA    R7,SSCONFIR         GET ADDRESS OF FIRST CONSOLE\nSSCLOOP  DS    0H\n         USING SSCONCB,R7\n         CLC   SSCONNUM(4),=XL4'0000'  END OF SSCON CHAIN\n         BE    PART1EXT\n         TM    SSCONFLG,X'20'      MESSAGE INTERCEPTION ACTIVE ?\n         BNO   SSCLOOPE            NOPE, END OF THE LOOP\n         L     R10,SSCONNUM        GET SUBSYSTEM CONSOLE ID\n         CR    R6,R10              IS IT OURS ?\n         BE    FNDSSCON            BY GOLLY, IT SURE IS...\nSSCLOOPE DS    0H\n         LA    R7,SSCONCBL(R7)\n         B     SSCLOOP\n         DROP  R5\n***********************************************************************\n* NOW WE GET THE OSCMD INTERFACE CONTROL BLOCK, AND PROCEED FROM THERE*\n*                                                                     *\n***********************************************************************\nFNDSSCON DS    0H\n         ST    R7,SSCONENT         SSCONENT IS THE ENTRY FOR THIS\n*                                  CALL TO THE SSI CODE 9\n         TM    TSSOFLG2,TSSOMON    IS THE DEBUG TURNED ON ?\n         BNO   NDEB1\n         WTO   'A TSSO SS CONSOLE ID IS NOW BEING PROCESSED'\nNDEB1    DS    0H\n         L     R7,SSCONICB         GET ADDRESS OF OSCMDICB FOR THIS\n*                                  CONSOLE\n         DROP  R7\n         LTR   R7,R7\n         BZ    NOICB               PROBLEMS...\n         USING OSCMDICB,R7\n***********************************************************************\n* WE NEED TO FIGURE OUT IF THIS IS A MAJOR WQE, A MINOR WQE, OR       *\n* A NORMAL WQE. IT COULD ALSO BE A REPLY.                             *\n***********************************************************************\n         L     R10,SSWTMIN         GET MINOR WQE ADDRESS\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    MINZIP              DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\n         ST    R10,MINWQEAD        REMEMBER MINOR WQE ADDRESS\nMINZIP   DS    0H\n         L     R10,SSWTORE         GET ORE ADDRESS.\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    OREZIP              DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         ST    R10,MAJOREAD        REMEMBER OREADDR\n*\nOREZIP   DS    0H\n*\n***********************************************************************\n* CHECK FOR A MULTI-LINE WTO.                                         *\n*                                                                     *\n***********************************************************************\n         L     R10,MINWQEAD        IS THIS A MULTI-LINE WTO ?\n         LTR   R10,R10             IF NON-ZERO, A MINOR WQE EXISTS,\n         BNZ   MLWTOWQE            SO WE GO AND PROCESS IT. OTHERWISE,\n*                                  CHECK TO SEE IF ITS THE FIRST LINE\n*                                  OF A MULTI-LINE WTO.\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   NORMWQE             NOPE, NORMAL WQE\n***********************************************************************\n* HERE, WE HAVE THE MAJOR WQE WITH MINORS TO FOLLOW. WE WILL PROCESS  *\n* THE MAJOR WQE BY QUEUEING THE RESPONSE TO OSCMD...                  *\n***********************************************************************\n         XR    R4,R4              CLEAR LEGNTH REGISTER\n         LH    R4,WMJMTXTL        GET LENGTH\n         LA    R5,WMJMTXT         GET ADDRESS OF MESSAGE\n         BAL   R14,QUEUEWQE       TELL OSCMD ABOUT IT\n         B     PART1EXT            MAJOR, WITH MINORS TO FOLLOW,\n         DROP  R10\n*\n***********************************************************************\n* PROCESS MULTI-LINE WQE'S...                                         *\n*                                                                     *\n***********************************************************************\nMLWTOWQE DS    0H\n***********************************************************************\n* AT THIS POINT, WE ARE PROCESSING ONE IN A SEQUENCE OF MINOR WQE'S.  *\n***********************************************************************\n* THERE MAY BE ZERO, ONE OR TWO MINOR WQE'S FOR EVERY INVOCATION OF   *\n* THE SUBSYSTEM INTERFACE. WE MUST CHECK FOR THESE CONDITIONS..       *\n* WE WILL QUEUE THE MINOR WQE'S IF THERE IS ROOM                      *\n***********************************************************************\n*        WTO   'TRAPPED A MULTILINE WTO'\n         L     R10,MINWQEAD        LETS DEAL WITH THE MINOR WQE\n         USING WMNM,R10\n         TM    WMNMLT1,WMNMLT1A+WMNMLT1B+WMNMLT1C   DATA ON THIS LINE ?\n         BZ    CHEKEND1            I GUESS NOT, WILL CHECK THE NEXT ONE\n         XR    R4,R4\n         IC    R4,WMNMTL1          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT1        GET ADDRESS OF PART 1\n         TM    WMNMML2,WMNMML2H    IS LINE 2 AVAILABLE ?\n         BNO   USELNE2\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND1 DS    0H\n         TM    WMNMLT1,WMNMLT1D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\nUSELNE2  DS    0H\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C   DATA ON THIS LINE ?\n         BZ    CHEKEND2            I GUESS NOT, CHECK FOR END..\n         XR    R4,R4\n         IC    R4,WMNMTL2          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT2        GET ADDRESS OF PART 1\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND2 DS    0H\n         TM    WMNMLT2,WMNMLT2D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\n         DROP  R10\n*\n*\nNORMWQE  DS    0H\n***********************************************************************\n* AT THIS POINT, WE HAVE DETERMINED THAT WE ARE PROCESSING AN AVERAGE *\n* EVERY DAY RUN OF THE MILL WQE. WE WILL DETERMINE IF IT IS DESTINED  *\n* FOR THE TSSO SUBSYSTEM CONSOLE, AND IF SO, PROCESS IT.              *\n***********************************************************************\n*        WTO   'TRAPPED A NORMAL WQE'\n         LA    R4,147       (PTF1) LENGTH IS ALWAYS 147 FOR A NORMAL\n*                           (PTF1) WQE\n         L     R5,MAJWQEAD         START AT MAJOR WQE ADDRESS\n         USING WQE,R5\n         LA    R5,WQETS     (PTF1) - GET TIMESTAMP INSTEAD OF TEXT\n         DROP  R5\n         BAL   R14,QUEUEWQE        QUEUE THIS WTO...\n***********************************************************************\n* NOTE THAT WE DONT REALLY CARE ABOUT THE SUCCESS OF THE QUEUEING.    *\n***********************************************************************\n         B     PART1EXT            END OF PART 1 OF SSI RTN 9.\n*\nQUEUEWQE DS    0H\n***********************************************************************\n* WE MUST PROCESS THE MESSAGE. WE WILL PLACE THE MESSAGE TEXT IN THE  *\n* FIELD POINTED TO BY THE OSCMDICB.                                   *\n* THE QUEUEWQE ROUTINE IS CALLED AS AN INTERNAL SUBROUTINE FOR THE    *\n* PURPOSE OF QUEUEING UP THE CAPTURED MESSAGES IN THE OSCMDICB.       *\n*\n***********************************************************************\n* INPUT REGISTERS:                                                    *\n*                                                                     *\n* R5 POINTS TO THE MESSAGE TO BE QUEUED UP (WQETXT FROM EITHER MAJOR  *\n*    OR MINOR                                                         *\n* R4 CONTAINS THE LENGTH OF THE MESSAGE.                              *\n* R14 CONTAINS THE RETURN ADDRESS.                                    *\n*                                                                     *\n* OUTPUT REGISTERS: R15 = 0 : MESSAGE INSERTED OK                     *\n*                   R15 = 4 : ERROR INSERTING MESSAGE.                *\n***********************************************************************\n         L     R6,OSCMDCNT         GET COUNT OF MESSAGES\n         C     R6,OSCMDMAX         HAVE WE HIT THE MAXIMUM YET ?\n         BE    ENDQWQE4            YUP, WE WILL IGNORE THIS MESSAGE\n*                                  AND ALL SUBSEQUENT MESSAGES.\n         LA    R6,1(R6)            INCREMENT COUNT OF MESSAGES\n         ST    R6,OSCMDCNT         AND STORE BACK.\n         L     R6,OSCMDNEX         GET NEXT BUFFER LOCATION\n         BCTR  R4,0\n         EX    R4,COPYWQET         COPY THE WQETEXT\n         LA    R6,150(R6)   (PTF1) INCREMENT BUFFER COUNT NOW 150\n         ST    R6,OSCMDNEX\n         B     ENDQWQE0\n*\nCOPYWQET MVC   0(0,R6),0(R5)     COPY TEXT INTO BUFFER\n*\nENDQWQE0 DS    0H\n         LA    R15,SSWTNDSP      SET CODE FOR MESSAGE SUPPRESSION\n         STH   R15,FUNC9RC\n         XR    R15,R15\n         B     ENDQWQE\nENDQWQE4 DS    0H\n         LA    R15,4\n         B     ENDQWQE\nENDQWQE  DS    0H\n         BR    R14\n*\nPSTOSCMD DS    0H\n***********************************************************************\n* NOW, WE WILL POST THE OSCMD PROCESSOR, BECAUSE THERE ARE NO MORE    *\n* WTO'S FORTHCOMING FOR THIS COMMAND, SO THERE IS NO REASON TO WAIT   *\n* FOR THE COMMAND TO END.. OSCMD IS WAITING ON TWO ECBS, THE FIRST    *\n* BEING A STIMER FOR THE TIME IN THE WAITIME VARIABLE, THE SECOND     *\n* BEING THE OSCMDECB FIELD. WE WILL POST THIS FIELD.                  *\n***********************************************************************\n         L     R10,SSCONENT               SS CON ENTRY FOR THIS CALL\n         USING SSCONCB,R10\n         NI    SSCONFLG,255-X'20'        INDICATE NO MORE MESSAGE TRAP\n         DROP  R10\n         LA    R2,OSCMDECB\n         L     R6,OSCMDACB               GET ASCB OF CALLERS ADDRESS SP\n         POST  (R2),X'000',ASCB=(R6),ERRET=PART1EXT,MF=(E,POST1D)\n         B     PART1EXT\n*\nNOICB    DS    0H\n         WTO   'TSS9201S INVALID ICB POINTER -> RESTART TSSO',DESC=(1)\n         B     FUNC9EXT\n*\n*\nPART1EXT DS    0H\nFUN9PRT2 DS    0H\n***********************************************************************\n* THIS IS THE SECOND PART OF THE SS09 INTERCEPT ROUTINE. BASICALLY,   *\n* ITS PURPOSE IS TO INTERCEPT LINES THAT START WITH \"#.LOGON\" AND     *\n* SUBSTITUTE STUFF ON THE REST OF THE LINE WITH GIBESRISH - TO BLANK  *\n* OUT THE PASSWORD THAT WOULD HAVE BEEN ENTERED ON THE LINE...        *\n***********************************************************************\n         L     R2,SSWTMIN                  CHECK OUT MINOR WQE\n         LTR   R2,R2\n         BNZ   PART2EXT                    MINOR WQE -> EXIT.\n         L     R2,SSWTORE                  CHECK OUT OPERATOR REPLY?\n         LTR   R2,R2\n         BNZ   PART2EXT                    OPERATOR REPLY -> EXIT\n         L     R2,SSWTWQE                  GET THE MAJOR WQE\n         USING WQE,R2\n         CLC   WQETXT+2(6),=XL6'4B9396879695'   #.LOGON LOWER CASE\n         BE    SUPRLOGN\n         CLC   WQETXT+2(6),=CL6'.LOGON'     IS THIS \"#.LOGON\" ?\n         BE    SUPRLOGN                    NO - IGNORE ...\n         B     PART2EXT\nSUPRLOGN DS    0H\n         LA    R15,SSWTNDNH      SET CODE FOR MESSAGE AND LOG\n*                                SUPPRESSION\n         STH   R15,FUNC9RC       SUPPRESS THE #.LOGON COMMAND.\n*        WTO   'TSS9209I TSSO .LOGON COMMAND ECHO SUPPRESSED'\n         B     FUNC9EXT                    AND GET OUT OF HERE\n         DROP  R2\nPART2EXT DS    0H\n***********************************************************************\n* THIS IS THE END OF THE PROCESSING ROUTINE FOR THE #.LOGON INTERFACE.*\n* PART 3 OF THIS ROUTINE IS THE PROCESSING OF THE AOF TABLE.          *\n***********************************************************************\n         B     FUN9PRT3\n*\n        TITLE 'AOF PROCESSING'\nFUN9PRT3 DS    0H\n***********************************************************************\n* THIS IS PART THREE OF THE WTO/WTOR MESSAGE INTERCEPTION FUNCTIONS.  *\n* HERE, WE HANDLE THE AUTOMATED OPERATIONS FACILITY.                  *\n***********************************************************************\n         L     R7,TSSOTABL         GET ADDRESS OF TABLE.\n         LTR   R7,R7               CHECK IT OUT\n         BZ    FUNC9EXT            NO TABLE, NO WORK TO DO.\n         SPACE 1                                                14DEC92\n         TM    TSSOFLG1,TSSOSMPF   OBEY MPF SUPPRESSION         14DEC92\n         BZ    FUN9ACT             NO, HANDLE ALL MESSAGES      14DEC92\n         L     R5,SSWTWQE          PICK UP WQE ADDRESS          14DEC92\n         USING WQE,R5              ESTABLISH ADDRESSABILITY     14DEC92\n         TM    WQESUPB,WQESMPF     SUPPRESSED BY MPF?           14DEC92\n         BO    FUNC9EXT            YES, IGNORE MESSAGE          14DEC92\n         DROP  R5                  END WQE ADDRESSABILITY       14DEC92\nFUN9ACT  DS    0H\n***********************************************************************\n* IF WE GET HERE, THE TSSO/AOF COMPONENT IS ACTIVE, AND THERE IS A    *\n* (VALID) TSSO AOF TABLE. THE VALIDITY OF THE TABLE IS DETERMINED AT  *\n* TSSO STARTUP/TABLE RELOAD TIME. R7 WILL SERVE AS A BASE REGISTER    *\n* FOR THE TSSO/AOF TABLE CURRENT ENTRY\n***********************************************************************\n* INITIALIZE VARIABLES.\n***********************************************************************\n***********************************************************************\n* THE FIRST PART OF THE ROUTINE WILL ISOLATE THE MESSAGE ID, BE IT A  *\n* WTO OR WTOR, AND PRESERVE IT FOR FUTURE EXAMINATION.                *\n***********************************************************************\n         MVI   FUN9FLG,X'00'       RESET FLAG.\n         L     R5,SSWTMIN          GET MINOR WQE ADDRESS\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    MINZERO             DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\nMINZERO  DS    0H\n         L     R5,SSWTORE          GET ORE ADDRESS.\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    OREZERO             DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         USING WQE,R5              GAIN ADDRESSABILITY TO WQE\n         XR    R14,R14             Get length of reply ID       EEJ1102\n         IC    R14,WQERIDL         (same)                       EEJ1102\n         LA    R1,127-2            Compute actual string length EEJ1102\n         SR    R1,R14              (same)                       EEJ1102\n         LA    R14,WQETXT+2(R14)   Point to start of message ID EEJ1102\n         ST    R14,STRSTART        Save string starting address EEJ1102\n         MVC   TXTMSG(8),0(R14)    Copy message ID from WTOR    EEJ1102\n         B     GOTORE\nOREZERO  DS    0H\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         LA    R7,WQETXT+1         PICK UP STRING START FOR WQE\n         ST    R7,STRSTART         AND REMEMBER FOR TSSOPARS LATER\n*\n         LA    R7,WQETS            GET TIME STAMP ADDRESS FOR ACTION=\n*                                  POST\n         ST    R7,WQETSADR\n         USING WQE,R5\n         MVC   TXTMSG(8),WQETXT+1  WHY THE +1-- WHY NOT ?\n*                                  JUST SEEMS TO WORK BETTER\n         LA    R1,127              SET MAX. LENGTH\nGOTORE   DS    0H\n         ST    R1,STRLEN           SAVE LENGTH FOR LATER\n         ST    R5,WQEADDR          REMEMBER THE WQE ADDRESS\n         DROP  R5                  DROP ADDRESSABILITY TO WQE\n************************************************************\n* HERE IS WHERE WE EXAMINE THE TEXT OF THE WTO TO SEE IF WE SHOUD\n* TAKE ACTION.\n* THE ADDRESS OF THE TABLE IS IN TSSOTABL, AND THE FORMAT IS DOCUMENTED\n* IN THE TSSO: LOGIC GUIDE (WELL... MAYBE SOMEDAY)\n* R6: POINTS TO CURRENT TABLE ENTRY, DURING TEST PROCESSING.\n************************************************************\n         LM    R4,R6,TSSOBSTS           SETUP FOR BSCAN CALL    30OCT92\n         LA    R2,S9BSCMP               POINT AT COMPARE COMMAND30OCT92\n         BAL   R14,BSCAN                GO DO BINARY SEARCH     30OCT92\n         B     TSTALLMG                 +0 NOT FOUND, LOOK MSG=*30OCT92\n*                                       +4 FOUND, DO ENTRIES    30OCT92\n         L     R7,0(,R7)                POINT AT FIRST AOFNTRY  30OCT92\n         B     MATCHMSG                 GO AND PROCESS A MATCH  30OCT92\nS9BSCMP  CLC   TXTMSG(8),4(R7)     **BSCAN EXED** CHECK MSG ID  30OCT92\nTSTALLMG DS    0H                                               30OCT92\n         ICM   R7,B'1111',TSSOALMS      POINT AT MSG=* ENTRIES   *AGCO*\n         BZ    PART3EXT                 IF NONE, THEN ALL DONE  30OCT92\n         OI    FUN9FLG,X'10'            INDICATE BSCAN DONE     30OCT92\n         B     MATCHMSG                 GO PROCESS ALL ENTRIES  30OCT92\n         SPACE 2                                                30OCT92\n         USING AOFNTRY,R7               SETUP DSECT\n***********************************************************************\n* TSSO/AOF HAS PERFORMED THE REQUESTED FUNCTION, HOWEVER, WE CAN NOW\n* CONTINUE TO SCAN THE TSSO/AOF TABLE, IN HOPES OF FINDING ANOTHER\n* TABLE ENTRY TO MATCH THIS MESSAGE ID.\n***********************************************************************\nGETNEXT  DS    0H                       GET THE NEXT AOF FOR MSG *AGCO*\n         TM    FUN9FLG,X'10'            DOING MSG=* PROCESSING?  *AGCO*\n         BO    RUNTABL                  YES SO DO ALL ENTRIES    *AGCO*\n         CLC   =C'ENTR',AOFENTR    WAS THERE AN ENTRY NAME?      *AGCO*\n         BE    PART3EXT            NO, REQUIRED ACTIONS DONE     *AGCO*\n*                                                                *AGCO*\nRUNTABL  DS    0H                       RUN THE REST OF TABLE    *AGCO*\n         ICM   R7,15,AOFBNXT            NEXT AOF IN BSCAN CHAIN 30OCT92\n         BNZ   MATCHMSG                 HAVE SAME MESSAGE ID    30OCT92\n         TM    FUN9FLG,X'10'            DONE MSG=* PROCESSING?? 30OCT92\n         BZ    TSTALLMG                 NO, TRY THE MSG=* TYPE  30OCT92\n         B     PART3EXT                 ALL DONE WITH MSG=*     30OCT92\n         EJECT                                                  30OCT92\nMATCHMSG DS    0H\n         ST    R7,CURTABAD              SAVE CURRENT ENTRY ADDR\n***********************************************************************\n* WE COME HERE WHEN A MATCH HAS BEEN FOUND IN THE MESSAGE ID SECTION  *\n* OF A TSSO TABLE ENTRY. THE PROCESSING CONTINUES WITH THE PERFORMING *\n* OF ANY TESTS THAT NEEDS TO BE ISSUED. IF ALL TESTS ARE MATCHED, THAN*\n* BRANCH TO THE PERFACT ROUTINE, WHICH WILL PERFORM ANY ACTIONS       *\n* REQUIRED. IF THE TESTS ARE NOT MET, CONTINUE SEARCHING THE TABLE AS *\n* THERE MAY BE ANOTHER MATCH.\n***********************************************************************\n         L     R6,AOFTESTP               LOAD UP TEST ENTRY.\n         USING ATSNTRY,R6\nTESTLOOP DS    0H                        LOOP FOR TEST ENTRIES\n         LTR   R6,R6                     ANY MORE TEST ENTRIES ?\n         BZ    TESTSUCC                  NOPE, ALL TESTS MUSTBE OK\n         L     R1,ATSWORD          LOAD SUBSTR OR WORD NUMBER\n         ST    R1,WORD1            AND REMEMBER IT.\n         L     R1,ATSLNGTH         LOAD LENGTH\n         ST    R1,WORD2\n         MVC   WORDSEPS(4),ATSSEPS LOAD WORD SEPARATORS.\n***********************************************************************\n* WE MUST DETERMINE THE TEST TYPE, EITHER A WORD TYPE, OR A SUBSTR    *\n* TYPE.                                                               *\n***********************************************************************\n         CLI   ATSTYPE,C'W'        IS IT A WORD ?                *AGCO*\n         BE    WORDTYPE            YUP, GO PROCESS IT\n         CLC   ATSTYPE,=CL2'P'     IS IT A SUBSTRING ?\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLI   ATSTYPE,C'S'        IS IT A SUBSTRING ?           *AGCO*\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLC   ATSTYPE,=CL2'L'     IS IT A LINE NUMBER?\n         BNE   TESTTBAD            NO, IT IS WRONG\n         L     R2,ATSLINE          PICK UP LINE NO.\n         BAL   R14,SEDOLINE        TRY TO FIND IT\n         B     TESTFAIL            NO MATCH, THIS TEST FAILS\n         B     SUBSSUCC            SUCCESSFUL, GO ONTO NEXT TEST\n         SPACE 1\nTESTTBAD DS    0H                  INVALID TEST TYPE\n* NEITHER WORD NOR SUBSTRING, ** PROBLEM **\n         WTO   'TSS9202E INVALID TEST TYPE- IGNORING MESSAGE ID'\n*        B     TESTFAIL            SIMULATE TEST FAILING !\n         B     PART3EXT            STOP PROCESSING ON FAILURE    *SEAG*\n         EJECT ,\nWORDTYPE DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE HAVE A WORD TEST. THE ROUTINE WILL PERFORM THE\n* FOLLOWING PROCEDURES.\n*                                                                     *\n* 1) USE TSSOPARS TO PARSE THE MESSAGE, BASED ON THE SEPARATOR CHARS  *\n*    SPECIFIED IN THE TABLE.                                          *\n* 2) PERFORM THE TEST BASED ON THE DESIRED WORD, USING THE LENGTH     *\n*    SPECIFIED IN THE TABLE.                                          *\n* 3) EITHER GO TO TESTFAIL, OR PERFORM ANOTHER TEST.                  *\n*                                                                     *\n***********************************************************************\n         L     R10,STRSTART      GET ADDRESS OF STRING\n*                                 NOTE- COULD HAVE BEEN WQETXT+1 IF WTO\n*                                 or WQETXT+WQERIDL+2 if WTOR.  EEJ1102\n         ST    R10,PARS1         THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY      PARARRAY IS THIRD PARAMETER\n         ST    R10,PARS3         STORE IN PARM LIST.\n*\n         LA    R10,WORDSEPS      USE WORD SEPARATORS ON TEST DIRECTIVE\n         ST    R10,PARS4         AND STORE IN FOURTH WORD IN PARM LIST.\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY     HOW MANY DID WE GET BACK\n         C     R10,WORD1        SEE WHICH ONE WAS SPECIFIED IN THE\n*                                TEST PARAMETER LIST.\n         BL    WORDFAIL          NOT ENOUGH WORDS.. FAIL THIS TEST.\n         LA    R10,PARARRAY+2   POINT TO WORD NUMBER 1\n         L     R5,WORD1          GET WORD  REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN\n         ST    R10,TOKADDR      REMEMBER WHERE TOKEN WAS FOUND.\n***********************************************************************\n* AT THIS POINT, TOKADDR CONTAINS THE ADDRESS OF THE TOKEN (WORD) THAT*\n* WAS LOCATED BY TSSOPARS. WE WILL COMPARE THIS WORD, FOR N CHARACTERS*\n* AGAINST WHAT WAS SPECIFIED IN THE TSSO/AOF TABLE. IF MATCHED, GREAT *\n* IF NOT, TEST HAS FAILED.                                            *\n*\n* WE NEED TO LOAD UP THE MATCH TEXT AS SPECIFIED IN THE AOF TABLE.    &\n***********************************************************************\n         LH    R4,ATSTXTL       GET MATCHING TEXT LENGTH\n***********************************************************************\n* NOTE, THE MATCHING TEXT STRING IS AT 20(R6) WHERE R6 POINTS TO THE\n* TEST PARAMETER ENTRY (TPE).\n***********************************************************************\n         L     R5,TOKADDR       LOAD TOKEN ADDRESS\n         BCTR  R4,0             -1 FOR HARDWARE DEFIENCY.\n         EX    R4,COMPSTR       DO COMPARE !\n         BE    WORDSUCC        WORD MATCHED !!\n         BNE   WORDFAIL         WORD DIDNT MATCH !!!\nCOMPSTR  CLC   0(0,R5),ATSTXT   ** EXECUTED **\nWORDSUCC DS    0H\n************************************************************\n* WE COME HERE IF THE WORD MATCHED, IMPLYING THAT THIS PARTICULAR\n* TEST WAS SUCCESSFULL. NOW WE WILL GO SEE IF THERE ARE ANY MORE\n* TESTS..\n************************************************************\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BE    TESTFAIL         YES, ASO THE TEST FAILED         *AGCO*\n         L     R6,ATSNXT        GET NEXT TEST ENTRY\n         B     TESTLOOP         AND TRY AGAIN...\n*\nWORDFAIL DS    0H\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BNE   TESTFAIL         NO, IT REALLY IS A FAILURE       *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n*\nSUBSTYPE DS    0H\n***********************************************************************\n* THE USER REQUESTED A SUBSTRING TYPE OF TEST ON THE MESSAGE. THE     *\n* ROUTINE WILL PROVIDE THAT TEST. THE TEST IS:                        *\n* SUBSTR(MVSWTO,START IN AOF,LENGTH IN AOF) ?= MATCHTEX IN AOF.       *\n*                                                                     *\n***********************************************************************\n         L     R5,STRSTART      GET START OF MVS MESSAGE.\n         L     R4,WORD1         GET START AS SPECIFIED IN AOF.\n         BCTR  R4,0             -1 TO GET CORRECT CHARACTER.\n         LA    R5,0(R4,R5)      POINT TO START OF SUBSTRING IN WQE\n         L     R4,WORD2         GET LENGTH FOR COMPARE.\n         BCTR  R4,0             -1 FOR EXECUTE\n         EX    R4,COMPSTR2      PERFORM THE SUBSTRING COMPARE.\n         BE    SUBSSUCC         THEY MATCHED! -> TEST SUCCEDED.\n         BNE   SUBSFAIL         NO MATCHED- SUBS FAILED\n***********************************************************************\n* NOTE THAT THE MATCH TEXT IS IN 20(R6) WHERE R6 POINTS TO THE CURRENT\n* AOF TABLE.\n***********************************************************************\nCOMPSTR2 CLC   0(0,R5),ATSTXT\nSUBSSUCC DS    0H\n***********************************************************************\n* WE GET HERE IF THE SUBSTRING TEST WAS SUCCESSFULL. TSSO/AOF WILL\n* CHECK THE NEXT ENTRY IN THE TABLE AND ATTEMPT THE NEXT TEXT\n***********************************************************************\n         CLC   ATSTYPE,=CL2'SX' IS IT AN EXCLUSION TEST?         *AGCO*\n         BE    TESTFAIL         YES, SO THE TEST FAILS           *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n*\nSUBSFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF THIS SUBSTRING TEST HAS FAILED. IF THIS IS THE CASE *\n* THEN WE WILL CONTINUING SEARCH AOF TABLE ENTRIES IN HOPES OF AGAIN  *\n* FINDING THE MSG ID.\n***********************************************************************\n         CLI   ATSTYPE+1,C'X'   IS IT AN EXCLUSION TEST?         *AGCO*\n         BNE   TESTFAIL         NO, IT REALLY IS A FAILURE       *AGCO*\n         ICM   R6,B'1111',ATSNXT GET NEXT TEST ENTRY             *AGCO*\n         BNZ   TESTLOOP         MORE TESTS, GO TRY THEM          *AGCO*\n         B     TESTSUCC         LAST TEST, OTHERS HAVE SUCCEEDED *AGCO*\n         SPACE 2\nTESTFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF A WORD OR SUBSTRING TEST FAILS. IF THIS SHOULD      *\n* HAPPEN, WE CONTINUE SEARCHING THROUGH ALL TSSO/AOF TABLE ENTRIES    *\n* FOR ANOTHER MATCH ON THE MSGID.                                     *\n***********************************************************************\n         B     RUNTABL          GO TEST ANOTHER AOF ENTRY        *AGCO*\n*\nTESTSUCC DS    0H\n***********************************************************************\n* WE COME HERE IF ALL TESTS HAVE BEEN SUCCUSSFULL FOR THIS TABLE ENTRY*\n* TSSO WILL GO AND PERFORM THE ACTION REQUESTED AND CONTINUE SEARCHING*\n* THE TABLE FOR ANY ADDITIONAL ENTRIES.                               *\n***********************************************************************\n         B     PERFACT\n         DROP  R6\n*\nPERFACT  DS    0H\n************************************************************\n* WE COME HERE WHEN WE HAVE FOUND A WTO IN THE TABLE, AND THE TESTS\n* SPECIFIED FOR THE ENTRY HAVE BEEN MET. AT THAT TIME, WE PERFORM\n* THE ACTION SPECIFIED IN THE ACTION= PARAMETER FOR THE ENTRY.\n*\n* PROCESSING CONTINUES AS FOLLOWS:\n*\n* 1) IF MATCHLIM PROCESSING HAS BEEN SPECIFIED (MATCHLIM > 0) DEDUCT\n*    ONE FROM MATCHLIM. IF MATCHLIM = 999999 THEN DONT BOTHER. IF\n*    MATCHLIM = 0 THEN DO NOT PERFORM THE REQUESTED FUNCTION AFTER ALL.\n*\n* 2) WE IDENTIFIY WHAT THE TABLE WANTS US TO DO, I.E. ISSUE AN OS\n*    COMMAND, TSSO COMMAND, REPLY, OR WHATEVER. WE THEN BRANCH TO THE\n*    APPROPRIATE ROUTINE.\n*    NOTE THAT R7 POINTS TO THE ENTRY IN THE TSSO/AOF TABLE.\n*\n************************************************************\n         L     R2,AOFMLIM                PICK UP MATCHLIM VALUE.\n         C     R2,=F'999999'             WAS MATCHLIM SPECIFIED ?\n         BE    PASTMLIM                  NO - DONT BOTHER DEDUCTING\n         LTR   R2,R2                     IS COUNT ALREADY ZERO ?\n         BZ    FUN9NACT                  NO, TAKE NO ACTION...\n         BCTR  R2,0                      TAKE  ONE AWAY FROM MATCHLIM\n         ST    R2,AOFMLIM                AND STORE NEW MATCHLIM BACK\nPASTMLIM DS    0H\n***********************************************************************\n* HERE, WE HAVE SURVIVED MATCHLIM PROCESSING, AND ARE READY TO TAKE   *\n* ON THE ACTION SPECIFIED IN THE ACTION= PARAMETER OF THE AOF TABLE   *\n***********************************************************************\n         CLC   AOFACTN,=CL8'NONE'       IS THIS A DUMMY REQUEST?\n         BE    GETNEXT                  YES, SO WE HAVE DONE IT\n*\n         CLC   AOFACTN,=CL8'REPLY'       REQUEST TO REPLY ?\n         BE    FUN9RPLY\n         CLC   AOFACTN,=CL8'SUPPRESS'     REQUEST TO SUPPRESS.\n         BE    FUN9SUPP\n         CLC   AOFACTN,=CL8'HILIGHT'     REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'HIGHLITE'   REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'LOWLIGHT'    REQUEST TO TURN OFF HIGHLITE\n*                                       DESCRIPTOR ?\n         BE    FUN9LOW\n         CLC   AOFACTN,=CL8'OSCMD'      REQUEST FOR AN OS COMMAND ?\n         BE    FUN9CMND\n         CLC   AOFACTN,=CL8'OSCMDT'     REQUEST FOR AN OS COMMAND ?\n*                                       IN TEST MODE ?\n         BE    FUN9CMDT\n*\n         CLC   AOFACTN,=CL8'POST'       IS THIS REQUEST FOR POST\n         BE    FUN9POST\n*\n         WTO   'TSS9203E INVALID DIRECTIVE',DESC=1\n         B     PART3EXT                 SCOTTY, BEAM ME UP.\nFUN9NACT DS    0H\n***********************************************************************\n* HERE, THE MATCHLIM TEST HAS DETERMINED A ZERO MATCHLIM - IMMEDAITELY*\n* TERMINATE SS09 PROCESSING WITHOUT DOING ANYTHING                    *\n***********************************************************************\n         B     GETNEXT                 GET NEXT TSSO/AOF TABLE ENTRY\nFUN9CMDT DS    0H\n         OI    FUN9FLG,X'20'           INDICATE TEST MODE\n         B     FUN9CMND\nFUN9CMND DS    0H\n************************************************************\n* HERE IS THE ENTRY POINT FOR ISSUEING OS COMMANDS BASED ON\n* WTO'S.\n************************************************************\n         SPACE 1\nCMNDGO   DS    0H\n         LA    R2,MVSCMD+4       STARTING POINT FOR MVS CMD\n         MVI   MVSCMD+4,X'40'         BLANK OUT THE\n         MVC   MVSCMD+5(104),MVSCMD+4 COMMAND BUFFER\n         LA    R3,AOFACT         START POINT FOR MVS DIRECTIVE\n         LH    R4,AOFACTL        LENGTH OF MESSAGE\nCMNDLOOP DS    0H\n         LTR   R4,R4            CHECK TO SEE IF ANY CHARS REMAIN\n*                               IN BUFFER. THIS COULD HAVE HAPPENED\n*                               IF THE FORMATTING OPTION HAD BEEN\n*                               THE LAST THING IN THE TEXT OPERAND\n         BZ    ISSUECMD\n         CLI   0(R3),C'\\'       SIGNIFICANCE CHARACTER ON?\n         BE    SIGON             WELL.. IT IS NOW.\n         MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         BCT   R4,CMNDLOOP\n         B     ISSUECMD          GO DO THE COMMAND\n*\nSIGON    DS    0H\n************************************************************\n* WE COME HERE WHEN WE FIND THE '\\' DIRECTIVE IN THE TSSO TABLE\n* ENTRY FOR THIS MESSAGE. THIS MEANS WE HAVE SOME WORK TO DO.\n************************************************************\n         LA    R3,1(R3)           POINT TO NEXT CHARACTER\n         CLI   0(R3),C'P'         LOOKING FOR POSITION CHARACTER?\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'S'         CHECK ITS SYNONYM\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'W'         LOOKING FOR SOME 'WORD' ?\n         BE    SIGONW             YUP, GO DO IT !!\n         B     SIGWRONG           NO, INVALID '\\' DIRECTIVE...\n         SPACE 2\nSIGONP   DS    0H\n         CLI   4(R3),C','         CHECK FOR CORRECT FORMAT.\n         BNE   SIGWRONG\n         CLI   7(R3),C'\\'         CHECK FOR CLOSING TERMINATOR.\n         BNE   SIGWRONG           OH WELL...\n*\n         LA    R10,WORKAREA       POINT R10 TO WORKAREA FOR CVT\n         LA    R0,3               SET LENGTH FOR FIRST CONVERT\n         LA    R1,1(R3)           SET ADDRESS\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGSTART        REMEMBER STARTING POINT\n         LA    R0,2               GET LENGTH\n         LA    R1,5(R3)           GET NEW START POINT FOR CONVERT\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGCOUNT        SAVE COUNT\n************************************************************\n* AT THIS POINT, WE HAVE THE PARAMETERS NEEDED FOR TEXT\n* SUBSTITUTION IN THE OS COMMAND TO BE ISSUED.\n************************************************************\n         L     R1,SIGCOUNT              GET COUNT FOR EXECUTE\n         BCTR  R1,0                     MAKE UP FOR HARDWARE FAULTS\n         L     R10,STRSTART             GET START ADDRESS OF TEXT\n         L     R5,SIGSTART              GET STARTING POINT\n         C     R5,STRLEN                CHECK STARTING POINT\n         BH    SIGWRONG                 IF TO HIGH, FORGET IT\n         LA    R10,0(R10,R5)            POINT TO STARTING POINT IN WQE\n*                                       FOR MOVE.\n         BCTR  R10,0                    GET EXACT CORRECT POSTITION\n         EX    R1,MOVESIG               MOVE THE STUFF...\n         B     AR2\nMOVESIG  MVC   0(0,R2),0(R10)\nAR2      DS    0H\n         A     R2,SIGCOUNT              NEXT CHAR IN CMD BUFFER\n         LA    R3,8(R3)                 MOVE PAST \\ STUFF IN TSSO TABLE\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWRONG\n         B     CMNDLOOP\nSIGWRONG DS    0H\n         WTO   'TSS9204E ERROR IN DEFINITION (P) FOR NEXT WTO MSG'\n         B     PART3EXT\n*\nSIGONW   DS    0H\n         CLI   7(R3),C'\\'               TERMINATION FOR W DIRECTIVE\n         BNE   SIGWBAD                 SHUCKS\n         MVC   SEPCHAR(4),1(R3)        GET SEPARATOR CHARACTERS\n         LA    R1,5(R3)                GET START FOR CONVERT RTN\n         LA    R0,2\n         LA    R10,WORKAREA\n         CALL  JCECVTDB                GET DECIMAL\n         LTR   R1,R1                   CHECK IT OUT\n         BZ    SIGWBAD\n         ST    R1,WORDREQ              THIS IS THE REQUESTED WORD\n         CH    R1,=H'20'               BUT IS IT OK?\n         BH    SIGWBAD                 NO, GUY DIDNT READ THE DOC\n************************************************************\n* NOW, WE MUST SET UP THE PARSE ROUTINE. THE GENERAL ID IS TO\n* PARSE THE WTO MSG INTO USER DEFINED WORDS, AND THEN GET THE ONE\n* HE WANTS.\n************************************************************\n         L     R10,STRSTART       GET ADDRESS OF STRING\n         ST    R10,PARS1          THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY\n         ST    R10,PARS3\n*\n         LA    R10,SEPCHAR\n         ST    R10,PARS4\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY      HOW MANY DID WE GET BACK\n         C     R10,WORDREQ       SEE HOW MANY HE WANTED\n         BL    NOWORDS           NOT ENOUGH WORDS.. FORGET IT.\n         LA    R10,PARARRAY+2    POINT TO WORD NUMBER 1\n         L     R5,WORDREQ        GET WORDS REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN... NOW WE GET LENGTH\n         ST    R10,TOKADDR       REMEMBER WHERE TOKEN WAS FOUND.\n         XR    R5,R5\n         LA    R1,16             TOKENS ARE 16 BYTES LONG\n************************************************************\n* AT THIS POINT, R10 POINTS TO THE TOKEN RETURNED BY THE PARSE ROUTINE\n* THAT THE USER REQUESTED.\n************************************************************\nWLOOP    DS    0H\n         CLI   0(R10),C' '\n         BE    ENDTOKEN\n         LA    R5,1(R5)\n         LA    R10,1(R10)\n         BCT   R1,WLOOP\nENDTOKEN DS    0H\n         ST    R5,LWORDREQ       STORE LENGTH OF REQUESTED WORD\n************************************************************\n* AT THIS POINT, WE HAVE ALL THE INFORMATION NEEDED TO DO  *\n* THE PARAMETER SUBSTITUTION. R2 POINTS TO THE SPOT TO     *\n* SUBSTITUTE.                                              *\n************************************************************\n         L     R5,LWORDREQ              GET LENGTH OF WORD\n         BCTR  R5,0                     MINUS 1 FOR EXECUTE\n         L     R10,TOKADDR\n         EX    R5,MOVEWORD\n         B     AR3\nMOVEWORD MVC   0(0,R2),0(R10)\nAR3      DS    0H\n         A     R2,LWORDREQ\n         LA    R3,8(R3)\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWBAD\n         B     CMNDLOOP\nNOWORDS  DS    0H\n         WTO   'TSS9205E NOT ENOUGH TOKENS IN BELOW WTO TO PROCESS'\n         B     PART3EXT\nSIGWBAD  DS    0H\n         WTO   'TSS9206E ERROR PROCESSING W DIRECTIVE- MSG IGNORED'\n         B     PART3EXT\nSIGLBAD  DS    0H\n         WTO   'TSS9208E ERROR PROCESSING L DIRECTIVE- ENTRY IGNORED'\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\nISSUECMD DS    0H\n         TM    FUN9FLG,X'20'            WAS OSCMD SPECIFIED ?\n         BNO   ISSURCMD                GO ISSUE REAL COMMAND\n* HERE, WE WILL NOT ISSUE THE COMMAND, BUT WE WILL WTO OUT WHAT THE\n* COMMAND WOULD HAVE BEEN\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+13(105),MVSCMD+4\n         WTO   MF=(E,WTO1D)           (MSG 207) DEFINED IN THIS MODULE\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\n*\nISSURCMD DS    0H\n         MVC   MVSCMD(2),=H'109'\n         MVC   MVSCMD+2(2),=H'0'\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(105),MVSCMD+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF1                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG1\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES1\nECHOOFF1 DS    0H\n         B     AFTECHO1                        NO ECHO, WHAT A SHAME\n*\nECHOYES1 DS    0H\n         WTO   MF=(E,WTO1D)        (MSG207)\n         B     AFTECHO1                        ECHO TO MASTCONS\n*\nECHOLOG1 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),MVSCMD+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO1\n*\nAFTECHO1 DS    0H\n         LH    R0,MASTCONS\n         LA    R1,MVSCMD\n         SVC   34\n         B     GETNEXT\nFUN9LITE DS    0H\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       HILIGHT\n         OI    WQEDC1,WQEDCB            HILITE THE SUCKER\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n*                                       FOR HILIGHT\n         B     GETNEXT\n*\nFUN9LOW  DS    0H\n***********************************************************************\n* THIS IS THE ROUTINE TO \"LOWLITE\" A MESSAGE. THE ROUTINE BASICALLY   *\n* INTERCEPTS THE MESSAGE, AND FLIPS OFF THE WQEDCA BIT.               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       LOW LIGHT\n         NI    WQEDC1,255-WQEDCA        (PTF3)\n         NI    WQEDC1,255-WQEDCB\n         NI    WQEDC1,255-WQEDCC        KILL EVENTUAL ACTION MSG15OCT92\n         NI    WQEDC2,255-WQEDCK\n         NI    WQEXA,255-WQEWTOR        FAKE OUT COMTASK INTO THINKING\n*                                       THE MESSAGE IS NOT A WTOR...\n* HILIGHTING CAUSED BY DESCRIPTOR CODES 1, 2 AND 11.\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n         B     GETNEXT\n*\nFUN9SUPP DS    0H\n***********************************************************************\n* THIS IS THE SUPPRESS HANDLER. THE SUPPRESS FUNCTION IS PROBABLY THE *\n* CLEANEST IN THE WHOLE PRODUCT, BECAUSE SUBSYSTEM CAN CAUSE MESSAGES *\n* TO BE SUPPRESSED. NOTE THAT THIS FUNCTION WILL BE INEFFECTIVE FOR   *\n* WTOR REQUESTS, HOWEVER, THE LOWLIGHT FUNCTION CAN BE USED.          *\n***********************************************************************\n         LA    R5,SSWTNDSP              LOAD CODE FOR SUPPRESSION\n         STH   R5,FUNC9RC               AND STORE IT AWAY.\n         B     GETNEXT                  GET A NEW ENTRY\n*\nFUN9RPLY DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO AOF REPLY FUNCTION. THE IDEA   *\n* HERE IS TO INTERCEPT THE WTOR, FORMAT A REPLY COMMAND OF THE FORM   *\n* R NNNN,MSG-TEXT where NNNN is picked up from the ORERPIDB     EEJ1102\n* field and MSG-TXT is picked up from the AOF table.  This is   EEJ1102\n* useful in \"nuking\" outstanding replies, like those from IMS.  EEJ1102\n* The REPLY command is used to reply to those messages.         EEJ1102\n***********************************************************************\n         L     R5,SSWTORE               GET THE OPERATOR REPLY ELEMENT\n         LTR   R5,R5                    MAKE SURE..\n         BZ    GETNEXT\n         USING OREF,R5                  GAIN ADDRESSABILITY TO ORE.\n         MVC   REPLY(2),=Y(REPLYLEN) Length of reply buffer     EEJ1102\n         MVC   REPLY+2(2),=H'0'\n         MVI   REPLYCOM,C','\n         L     R14,ORERPIDB        Load reply ID value          EEJ1102\n         CVD   R14,WORKAREA        Convert to decimal           EEJ1102\n         OI    WORKAREA+7,X'0F'    Ensure valid characters      EEJ1102\n*        UNPK  REPLYNUM,WORKAREA(8) CONVERT TO CHARACTER        EEJ1102\n         MVC   WORKAREA+8(L'REPLYEDT),REPLYEDT COPY EDIT MASK    *AGCO*\n         ED    WORKAREA+8(L'REPLYEDT),WORKAREA+5 edit reply num  *AGCO*\n         MVC   REPLYNUM,WORKAREA+8+2 COPY REPLY NUMBER           *AGCO*\n         LH    R1,AOFACTL               PICK UP LENGTH OF REPLY\n         BCTR  R1,0\n         MVI   REPLYMSG,X'40'\n         MVC   REPLYMSG+1(99),REPLYMSG   CLEAR REPLYMSG\n         EX    R1,MOVERPLY\n         B     AR4\nMOVERPLY MVC   REPLYMSG(0),AOFACT          MOVE IN AUTOMATIC REPLY\nAR4      DS    0H\n***********************************************************************\n* THE REPLY DIRECTIVE IS SUPPORTED BY THE ECHO FACILITY. CHECK TO SEE *\n* IF THE TABENTRY MACRO SPECIFIED ECHO= ON THE CARD, AND TAKE ACTION  *\n***********************************************************************\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(108),REPLY+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF2                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG2\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES2\nECHOOFF2 DS    0H\n         B     AFTECHO2                        NO ECHO, WHAT A SHAME\n*\nECHOYES2 DS    0H\n         WTO   MF=(E,WTO1D)\n         B     AFTECHO2                        ECHO TO MASTCONS\n*\nECHOLOG2 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),REPLY+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO2\nAFTECHO2 DS    0H\nISSUERPL DS    0H\n         LH    R0,MASTCONS              LETS DO REPLY FROM MASTCONS\n         LA    R1,REPLY\n         SVC   34\n         B     GETNEXT\n         DROP  R5               DROP ADDRESSABILITY TO OREF\nFUN9POST DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO POST ROUTINE, ALLOWING THE     *\n* CALLER TO WAIT ON A GIVEN MESSAGE OR AOF ENTRY ID BEFORE BEING      *\n* POSTED. THE CALLER WILL BE THE OSWAIT TSO COMMAND, OR (PERHAPS) ITS *\n* NCCF EQUIVALENT. STANDARD TSSO ACTION IS THE FOLLOWING:             *\n*                                                                     *\n* 1) DETERMINE IF THE CURRENT MESSAGE IS ACTIVE. IF NOT, TERMINATE    *\n*    IMMEDIATELY.                                                     *\n*                                                                     *\n* 2) GET THE ADDRESS SPACE, ECB AND PLACE TO PUT THE WTO INTO         *\n*    VARIABLES                                                        *\n*                                                                     *\n* 3) COPY THE WTO INTO THE AOF TABLE ENTRY                            *\n*                                                                     *\n* 4) POST THE ECB IN THE SPECIFIED ADDRESS SPACE                      *\n*                                                                     *\n* 5) GO TO NEXT ENTRY.                                                *\n*                                                                     *\n***********************************************************************\n         TM    AOFPFLG,AOFP1WT  IS THIS ENTRY BEING WAITED ON ?\n         BNO   END9POST         NO, END OF FUNCTION...\n*\n         L     R2,AOFPECB       PICK UP ECB TO POST....\n         L     R3,AOFPASCB      AND GET THE ADDRESS SPACE.\n         L     R4,WQETSADR      GET ADDRESS OF WQE\n         MVC   AOFWQE(147),0(R4) COPY TO AOF TABLE\n         POST  (R2),X'000',ASCB=(R3),ERRET=END9POST,MF=(E,POST1D)\nEND9POST DS    0H\n         B     GETNEXT\n         DROP  R7\n         SPACE 2\nPART3EXT DS    0H\n***********************************************************************\n* FINISHED WITH DOING THE AOF PROCESSING OF THE MESSAGE, EXIT NICELY  *\n***********************************************************************\n         B     FUNC9EXT                 ALL DON SO EXIT\n         EJECT ,\nGETMERR  DS    0H\n***********************************************************************\n* THIS CODE IS BRANCHED TO IN CASE OF A GETMAIN ERROR WITHIN          *\n* TSSOSS09. THIS WILL OCCUR IF THE CURRENT ADDRESS SPACE SUFFERS      *\n* AN 80A OR 878 ABEND. IT IS (PROBABLY) NOT A GOOD IDEA TO ISSUE      *\n* A WTO BECAUSE SS09 WOULD GET REDERIVEN BUT STILL BE OUT OF STORAGE  *\n***********************************************************************\n*        WTO   'TSS9208S SS09 TERMINATING BECAUSE IT CANT GET STORAGE'\n         B     FUNC9EX2\nFUNC9EXT DS    0H\n         LH    R8,FUNC9RC          TEMP STORAGE FOR THE RETURN CODE\n         L     R10,SSOBADDR\n         USING SSOB,R10\n         ST    R8,SSOBRETN\n         DROP  R10\n         FREEMAIN R,LV=4096,A=(R11)\nFUNC9EX2 DS    0H\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nFUNC9EX3 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15             COPY RC INTO REG 15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n         TITLE 'LOCATE LINE NUMBER IN MULTI-LINE WTO'\n***********************************************************************\n* THIS CODE ADDED BY D.H.CARTWRIGHT, SPRECHER ENERGIE, OBERENTFELDEN  *\n* CH-5036 SWITZERLAND AS PART OF THE ENHANCEMENT TO ALLOW DATA FROM   *\n* MULTI-LINE WTO'S TO BE USED IN OSCMD TEXT. THIS IS PARTICULARLY     *\n* NECESSARY FOR VTAM ERRORS DESCRIBED BY THE MLWTO MESSAGE 'IST663I'. *\n*                                                                     *\n* BASICALLY IT CHECKS THAT WE ARE PROCESSING THE REQUIRED LINE, THEN  *\n* ADJUSTS THE STRSTART AND STRLEN VARIABLES SO THAT THE EXISTING      *\n* PROCESSING WILL BE SWITCHED TO THE APPROPRIATE LINE OF TEXT.        *\n*                                                                     *\n* ON ENTRY R2  =  LINE NUMBER REQUIRED                                *\n*          R6  =  TEST DEFINITION CONTROL BLOCK                       *\n*                                                                     *\n* ON EXIT  STRSTART AND STRLEN HAVE BEEN ADJUSTED TO POINT TO THIS WQE*\n*    EXIT IS TO R14+4 IF THE LINE HAS BEEN FOUND                      *\n*               R14+0 IF THIS IS NOT THE REQUIRED LINE                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING ATSNTRY,R6\nSEDOLINE DS    0H                  LOCATE SPECIFIC LINE\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLINJ            NO, CHECK MAJOR\n         WTO   'A LINE NUMBER HAS BEEN REQUESTED'\nSEDOLINJ DS    0H                  PROCESS MAJOR WQE\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10            ESTABLISH ADDRESSABILTIY\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   SIGLBAD             NOPE, ERROR\n         TM    FUN9FLG,X'80'       DO WE HAVE A MINOR WQE?\n         BO    SEDOLMIN            YES, GO PROCESS WQE'S\n         MVC   ATSSEQ#,WMJMSEQ#    SAVE CONNECT ID\n         OI    WMJMRFB1,WMJMRPML   SAY WE WANT TO PROCESS THE MINORS\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLIN2            NO, CONTINUE\n         WTO   'ONLY MAJOR WQE'\nSEDOLIN2 DS    0H                  PROCESS MAJOR WQE\n         XR    R1,R1               CLEAR WORK REG.\n         STH   R1,ATSLNCNT         CLEAR TEST LINE COUNT\n         LA    R1,1                COUNT MAJOR AS FIRST LINE\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, TRY THE MINORS NEXT TIME\n         STH   R1,ATSLNCNT         SAVE LINE COUNT\n         LA    R1,WMJMTXT+1        POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         LH    R1,WMJMTXTL         GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLMIN DS    0H                  NOW PROCESS MINOR WQE'S\n         ICM   R5,B'1111',SSWTMIN  GET ADDRESS OF MINOR\n         BZ    SIGLBAD             ERROR IF NONE\n         PUSH  USING                                            RPS\n         DROP  R10                 DROP MAJOR ADDRESSABILITY    RPS\n         USING WMNM,R5             ESTABLISH MINOR ADDRESSABILTIY\n         LH    R1,ATSLNCNT         GET PREVIOUS LINE COUNT\n         SPACE 1\nSEDOLM1  DS    0H                  LOOP THROUGH THE LINES\n         TM    WMNMML1,WMNMML1C    IS THIS A MINOR WQE?\n         BNO   SIGLBAD             NO, ERROR\n         CLC   WMNMSEQ1,ATSSEQ#    SAME CONNECT ID?\n         BNE   SIGLBAD             NO, ERROR\n         TM    WMNMLT1,WMNMLT1A+WMNMLT1B+WMNMLT1C   DATA ON THIS LINE ?\n         BZ    SEDOLM2             I GUESS NOT, WILL CHECK THE NEXT ONE\n         LA    R1,1(,R1)           INCREMENT COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLM2             NO, TRY THE SECOND HALF\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         LA    R1,WMNMTXT1+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL1          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLM2  DS    0H                  PROCESS SECOND HALF OF MINOR WQE\n         ICM   R15,B'1111',WMNMNX1 IS THERE A SECOND HALF?\n         BZ    SEDOLMX             NO, EXIT\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLM2A            NO, CONTINUE\n         WTO   '2ND HALF OF MINOR WQE'\nSEDOLM2A DS    0H                  PROCESS MINOR WQE 2ND HALF\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C   DATA ON THIS LINE ?\n         BZ    SEDOLMX             I GUESS NOT, WILL CHECK THE NEXT ONE\n         LH    R1,ATSLNCNT         GET PREVIOUS LINE COUNT\n         LA    R1,1(,R1)           INCREMENT SAVED COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, WAIT FOR NEXT MINOR WQE\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         LA    R1,WMNMTXT2+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL2          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         POP   USING                                               RPS\n         SPACE 1\nSEDOLMX  DS    0H                  LINE IS NOT IN THIS MINOR WQE\n         ICM   R15,B'1111',WMNMNX2 IS THERE ANOTHER MINOR?\n         BZ    SEDOLMX2            NO, A REAL EXIT\n         LR    R5,R15              YES, UPDATE POINTER\n         B     SEDOLM1             GO ROUND THE LIST OF MINOR WQE'S\n         SPACE 1\nSEDOLMX2 DS    0H                  NOR ANY OTHER THAT I KNOW OF\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         XR    R1,R1               SET RETURN OFFSET TO ZERO\n         SPACE 1\nSEDOLINX DS    0H                  SUB ROUTINE EXIT\n         B     0(R1,R14)           RETURN TO CALLER WITH OFFSET\n         DROP  R10                 END MAJOR ADDRESSABILITY\n*        DROP  R5                  END WQE ADDRESSABILITY\n         DROP  R6                  END TSSO AOF TEST BLOCK ADDRESSABTY\n         COPY  BSCAN                                            30OCT92\n         TITLE 'DATA AREAS'\n         LTORG\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\nREPLYEDT DC    XL6'402020202120'    EDIT MASK FOR REPLY NUMBER   *AGCO*\nWTO1C    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTO1CE   EQU   *\n*\nWTL1C    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTL1CE   EQU   *\n*\nPOST1C   POST  ,ASCB=0,ERRET=0,MF=L\nPOST1CE  DS    0H\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\nFUN9DATA DSECT\nWORKAREA DS    CL200            USED FOR CONVERT ROUTINES\n***********************************************************************\n* RE-ENTRANT MACRO DEFINITIONS...                                     *\n*                                                                     *\n***********************************************************************\nPOST1D   POST  ,ASCB=0,ERRET=0,MF=L\n***********************************************************************\n* VARIABLES USED TO PROCESS REQUESTS OF PART 1 OF THIS ROUTINE, THE   *\n* INTERFACE TO THE OSCMD COMMAND.                                     *\n*                                                                     *\n***********************************************************************\nMAJWQEAD DS    F                MAJOR WQE ADDRESS\nMINWQEAD DS    F                MINOR WQE ADDRESS\nMAJOREAD DS    F                ADDRESS OF AN ORE.\nSSOBADDR DS    F                ADDRESS OF THE SSOB\nSSWTADDR DS    F                ADDRESS OF THE SSWT FOR THIS SUBSYS CAL\nSSCONENT DS    F                IF SS CON ENTRY USED - THIS FIELD HAS\n*                               ADDRESS OF SSCON ENTRY FOR IT.\n*\n*\nWQEADDR  DS    A                ADDRESS OF THE WQE WE ARE TRYING\n*                               TO DEAL WITH\nWQETSADR DS    A                ADDRESS OF TIME STAMP IN THE WQE.\nCURTABAD DS    A                CURRENT TSSO/AOF TABLE ADDRESS WE ARE\n*                               DEALING WITH\nTXTMSG   DS    CL8              FIRST 8 BYTES OF WTO/WTOR\nREPLY    DC    Y(REPLYLEN,0)       Reply command prefix         EEJ1102\nREPLYNUM DC    CL4' '              Reply ID                     EEJ1102\nREPLYCOM DC    CL1','\nREPLYMSG DC    CL100' '\nREPLYLEN EQU   *-REPLYNUM          Length of reply buffer       EEJ1102\nMVSCMD   DC    H'109',H'0'\nMVSCMD1  DS    CL105\nFUNC9RC  DS    H                RETURN CODE FOR FUNCTION 9.\nWTO1D    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MCSFLAG=(BRDCST,HRDCPY),MF=L\nWTL1D    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\n************************************************************\n* VARIABLES USED TO PROCESS TEST REQUESTS IN AOF TABLE.\n************************************************************\nWORD1    DS    F                IF TYPE=SUBSTR  STARTING CHARACTER\n*                               IF TYPE=WORD    WORD NUMBER\nWORD2    DS    F                LENGTH OF WORD\nWORDSEPS DS    CL4              SEPARATOR CHARACTORS FOR WORDS.\nSTRSTART DS    A                ADDRESS OF FIRST CHARACTER OF WQE\n*                               MESSAGE. THIS IS WQETXT+1 IF WTO\n*                               and WQETXT+WQERIDL+2 if WTOR.   EEJ1102\nSTRLEN   DS    A                LENGTH OF WQE MESSAGE\n************************************************************\n* VARIABLES USED TO PROCESS P DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSIGSTART DS    F                STARTING ADDRESS OF SIGNIFICANCE\nSIGCOUNT DS    F                NUMBER OF CHARACTERS\n************************************************************\n* PARSE PARAMETERS\n************************************************************\nPARSPARM DS    0H\nPARS1    DS    A\nPARS2    DS    A\nPARS3    DS    A\nPARS4    DS    A\nPARARRAY DS    CL2,20CL16  SPACE FOR COUNT AND 20 ITEMS         15OCT92\nLPARRAY  EQU   *-PARARRAY                                       15OCT92\n************************************************************\n* VARIABLES USED TO PROCESS W DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSEPCHAR  DS    F           SEPARATOR CHARACTERS FOR PARSE\nWORDREQ  DS    F\nLWORDREQ DS    F\nTOKADDR  DS    F           ADDRESS OF REQUESTED TOKEN IN\n*                          PARARRAY\n************************************************************\n* FLAGS USED IN PROCESSING REQUESTS FROM SUBSYSTEM CALL 9\n************************************************************\nFUN9FLG  DS    X\n* X'80'  SSWTMIN \u00ac= 0\n* X'40'  SSWTORE \u00ac= 0\n* X'20'  OSCMDT WAS SPECIFIED\n* X'10'  BSCAN PROCESSING IS DONE\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSSVT\n         IEFJSCVT\n         IEFJSSOB (CM,WT),CONTIG=NO\n         TSSOCVT\n         TSSOCMND\n         TSSONDSA\n         TAOFNTRY\n         OSCMDICB\n         SSCONCBH\n         SSCONCB\n         IHAWQE\n         IHAORE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n************************************************************\n* NOTE: PREVIOUS VERSION OF TSSO HAVE BEEN WRITTEN BY:\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC., MCLEAN VA\n*        DATE WRITTEN. SEPTEMBER 2 1976.\n*        DATE UPDATED. AUGUST 7 1980.\n************************************************************\n         END  TSSOSS09\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOSS09(''TSSO 4.3 &SYSDATE &SYSTIME'')'\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOSS09'\n PUNCH ' NAME     TSSOSS09(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XSSOSS09": {"ttr": 48903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x966_\\x00\\x966o\\x13#\\x05\\x82\\x05\\x7f\\x00\\x05\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-31T13:23:00", "lines": 1410, "newlines": 1407, "modlines": 5, "user": "RPS"}, "text": "TSSOSS09 TITLE 'TSSO - ROUTINE TO PROCESS SUB SYSTEM FUNCTION 09'\nTSSOSS09 CSECT\n************************************************************\n*\n*        PDSDOC *SPRECHER ENERGIE VERSION OF TSSOSS09 WITH ML WTO FIXED\n*\n* THIS IS THE ENTRY POINT FOR THE TSSO AUTOMATED OPERATIONS FACILITY\n* WTO AND WTOR INTERCEPT ROUTINE. THE SUBSYSTEM INTERFACE CODE 9\n* PROVIDES THE FACILITY FOR SUBSYSTEMS TO INTERCEPT ALL WTO AND WTOR\n* REQUESTS, AND TAKE ACTION. THE SPECIFIC ACTIONS THAT TSSO/AOF WILL\n* TAKE IS DETERMINED BY A TABLE, LOADED AT SUBSYSTEM (TSSO)\n* INITIALIZATION TIME.\n*\n* THE FORMAT OF THE TABLE IS COMPLEX, AND BEST DOCUMENTED IN THE\n* DISPAOF TSSO COMMAND, INCLUDED WITH TSSO.\n*\n* SPECIFIC ACTIONS ARE:\n* OSCMD - ISSUE AN OPERATING SYSTEM, JES OR TSSO COMMAND IS RESPONSE\n*         TO THE MESSAGE\n*\n* OSCMDT - SIMULATE THE ISSUANCE OF THE COMMAND, BY WTO INSTEAD\n*          OF WTOR THE MESSAGE.\n*\n* HILITE - HILIGHT THE MESSAGE BY TURNING ON THE WQEDCMA BIT.\n*\n* SUPPRESS- SUPPRESS THE MESSAGE.\n*\n*    TSSO (VERSION 4.1) PROVIDES THE FACILITY FOR TESTING CERTAIN\n* (ACTUALLY, ANY) FIELD IN THE MESSAGE BY WORD OR SUBSTRING CONTENT\n* BEFORE ACTUALLY DECIDING TO PERFORM THE ACTION SPECIFIED.\n*\n*    TSSO (VERSION 4.1) WILL SCAN THE *ENTIRE* TABLE FOR THE\n* MESSAGE IDENTIFIER, EVEN WHEN ENCOUNTERED, THUS MULTIPLE ACTIONS\n* MAY BE SPECIFIED FOR THE SAME MESSAGE, UNDER DIFFERENT TEST\n* CONDITIONS. THE USER IS URGED TO READ NOT ONLY THE TSSO SOURCE CODE,\n* BUT THE TSSO SYSTEMS PROGRAMMING REFERENCE GUIDE, FOR DETAILS\n* ON TSSO/AOF USAGE.\n*\n***********************************************************************\n* TSSO VERSION 4.2 PROVIDES THE UNPARALLED ABILITY TO ISSUE MVS       *\n* OPERATOR COMMANDS FROM A TSSO CLIST, AND GET THE RESPONSE BACK TO   *\n* THE CLIST. THIS IS ACCOMPLISHED THROUGH COMMUNICATION BETWEEN THE   *\n* OSCMD COMMAND, AND THIS MODULE. THIS MODULE WILL CHECK IF MESSAGES  *\n* ARE TO BE INTERCEPTED. IF YES, IT WILL INTERCEPT ALL MESSAGES       *\n* DESTINED TO THE CONSOLE OBTAINED BY TSSO AS A SUBSYSTEM CONSOLE, AND*\n* STORE THEM IN A GLOBAL BUFFER PROVIDED BY THE OSCMD COMMAND.        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TSSO VERSION 4.3 ADDS THE FOLLOWING FUNCTION TO THIS MODULE:        *\n*                                                                     *\n* 1) SUPPORT FOR MULTIPLE SUBSYSTEM CONSOLES.                         *\n*                                                                     *\n* 2) SUPPORT FOR ACTION=POST IN THE AOF TABLES.                       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n* NOTE: LAST MSGID IS 209.                                            *\n*                                        MARC.\n***********************************************************************\n*                                                                     *\n* 12JUL92 CART1 MAKE SOME CHANGES FOR MLWTO                           *\n* 19AUG92 CART1 ON TEST BLEW UP IEFJRASP LEADING TO IPL. ALTER MATCH  *\n*               FAIL CODE TO EXIT IMMEDIATELY.                   *SEAG*\n* 24AUG92 CART1 RECODE 'SEDOLINE' TO AVOID THE 0C4'S. THIS ALLOWS US  *\n*               TO USE IT IN PARSING THE TESTS TO RESTRICT PROCESSING *\n*               TO ONE MINOR WQE. ALSO REDUCE OVERHEAD BY TESTING FOR *\n*               TABLE ENTRY NAME AND STOP IF ENTRY MATCHED WITH NO    *\n*               ENTRY NAME (DEFAULT ENTR..).                          *\n* 26AUG92 CART1 RECODE 'SEDOLINE' FOR USE IN TESTS ONLY, NOT TEXT.    *\n*               THE REASON IS THAT THE COMMS TASK ONLY GIVES US A CSA *\n*               COPY OF THE WQE WHICH IS IN THE COMMS TASK ADDRESS    *\n*               SPACE. THUS WE CANNOT RUN THE LIST OF WQE'S. BY USING *\n*               DATA IN THE TEST CONTROL BLOCK WE CAN COUNT THE NUMBER*\n*               OF TIMES WE ARE CALLED FOR THIS MAJOR WQE.            *\n* 09SEP92 CART1 ADD 'ACTION=NONE' TO PROVIDE A 'STOP' FACILITY TO     *\n*               REDUCE RUNNING COSTS.                                 *\n*                                                                     *\n* 15OCT92  GLA  INCORPORATE NECESSARY FIXES FROM 4.2                  *\n*                 A. FIX BUG IN LOWLIGHT ROUTINE. CAUSES EVENTUAL ACT *\n*                    MESSAGES NOT TO BE LOWLIGHTED.                   *\n*                 B. FIX BUG IN AOF TABLE PROCESSING FOR MESSAGE.     *\n*                    ORIGINAL CODE WAS NOT CLEARING THE OUTPUT TOKEN  *\n*                    TABLE FULLY. ANY ATTEMPT TO ACCESS WORDS 17      *\n*                    TO 20 IN A MESSAGE WOULD RESULT IN GARBAGE.      *\n*                                                                     *\n* 20OCT92  GLA  INSTALL NEW DSECT FOR AOF TABLES                      *\n*                                                                     *\n* 30OCT92  GLA -USE BINARY SEARCH TABLE INDEX TO AOF TABLE.           *\n*              -GO BACK TO ORIGINAL PROCESSING OF ALL ENTRIES THAT    *\n*               MATCH ID, WITH ONE EXCEPTION, PROCESS ALL MSG=*       *\n*               ENTRIES AFTER ALL MSG=ID THAT MATCH.                  *\n*                                                                     *\n* 14SEP92 CART1 ADD CODE TO TEST FOR MPF MESSAGE SUPPRESSION. IF YOU  *\n*               MPF SUPPRESS A MESSAGE THAT IS ITS SINGLE POINT OF    *\n*               CONTROL.                                              *\n*                                                                     *\n* 14DEC92  GLA  ADD NEW PARAMETER TO TURN ABOVE FEATURE ON OR OFF.    *\n*                                                                     *\n* 30DEC96  RPS  FIXED ADDRESSABILITY ERROR WITH HLASM                 *\n***********************************************************************\n*\n* REGISTER USAGE:\n*   R11: POINTS TO THE GETMAINED STORAGE AREA FOR THE LIFE OF THE\n*        ROUTINE\n*   R9 : POINTS TO THE SSOB EXTENTION FOR THE LIFE OF THE ROUTINE\n*   R8 : POINTS TO THE TSSO CVT FOR THE LIFE OF THE ROUTINE.\n*   R7 : POINTS TO THE TSSO AOF TABLE, FOR THE LIFE OF THE ROUTINE.\n*   R6 : POINTS TO THE CURRENT TEST ENTRY FOR THE LIFE OF THE ROUTINE.\n************************************************************\n         STM    R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR     R12,R15            LOAD ENTRY POINT OF TSSO\n         USING  TSSOSS09,R12         GET ADDRESSIBILITY\n         B      AR1\n         DC     CL8'&SYSDATE'      GET THE DATE\n         DC     CL8'&SYSTIME'      GET THE TIME\nAR1      DS     0H\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR     R8,R1\n         GETMAIN RC,LV=72           WE NEED STORAGE FOR THE SAVE AREA\n         LTR    R15,R15\n         BNZ    FUNC9EX3           STORAGE AVAILABLE.\n         ST     R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST     R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR     R13,R1             KEEP A COPY IN R13\n*\n*\n         GETMAIN RC,LV=4096         GET SOME STORAGE...\n         LTR    R15,R15\n         BNZ    GETMERR\n         LR     R11,R1\n         USING  FUN9DATA,R11\n*\n         LR     R10,R8\n         USING  SSOB,R10\n         ST     R10,SSOBADDR\n*\n         GETCVT (R8)               FIND TSSO CVT                   RPS\n         USING TSSOCVT,R8\n*\n         L     R9,SSOBINDV         POINT TO WTO EXTENSION\n         ST    R9,SSWTADDR         SAVE IT FOR FUTURE...\n         USING SSWTBGN,R9\n*\n         DROP  R10\n         MVC   POST1D(POST1CE-POST1C),POST1C\n         XC    MAJWQEAD(4),MAJWQEAD\n         XC    MINWQEAD(4),MINWQEAD\n         XC    MAJOREAD(4),MAJOREAD\n         XC    FUNC9RC(2),FUNC9RC   INIT RETURN CODE\n***********************************************************************\n* THE FIRST ORDER OF BUSINESS IS TO SEE IF MESSAGE TRAPPING IS ACTIVE *\n* FOR AN SS CONSOLE. IF SO, WE WILL QUEUE UP THE MESSAGE BASED ON THE *\n* INFORMATION OBTAINED FROM THE OSCMDICB, WHICH IS CHAINED OFF THE    *\n* SSCONCB FOR THE SPECIFIC CONSOLE.                                   *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n* THE NEXT STEP(S) CONCERN WHETHER TO INTERCEPT THIS MESSAGE. TSSO    *\n* MUST HAVE OBTAINED A SUBSYSTEM CONSOLE, AND THE INCOMING MESSAGE    *\n* MUST BE DESTINED FOR THAT SUBSYSTEM CONSOLE (IN FIELD TSSCONID).    *\n* IF EITHER OF THESE CONDITIONS ARE NOT MET, WE FORGET THIS MESSAGE.  *\n***********************************************************************\n         L     R5,SSWTWQE          ADDRESS THE WQE.\n         ST    R5,MAJWQEAD         REMEMBER THE MAJOR WQE\n*        ST    R5,WQEADDR          REMEMBER IT IN TWO PLACES\n         USING WQE,R5\n***********************************************************************\n* WE MUST DETERMINE IF ANY TSSO SUBSYSTEM CONSOLE IS CURRENTLY        *\n* INTERCEPTING MESSAGES, AND, IF THEY ARE, WHICH ONE MATCHES THIS     *\n* CONSOLE ID. LETS LOOP THROUGH THE SUBSYSTEM CONSOLES.\n***********************************************************************\n* NOTE THAT THE WQEUCMID FIELD IS IN THE SAME PLACE FOR MAJOR AND\n* NORMAL WQE'S\n***********************************************************************\n         XR    R6,R6               WIPE REGISTER\n         IC    R6,WQEUCMID         PICK UP THE CONSOLE THIS GUY IS\n*                                  DESTINED FOR\n         L     R7,SSCONSAD         THIS, FROM THE TSSO CVT\n         LTR   R7,R7               DO WE HAVE ONE ?\n         BZ    PART1EXT            TSSO HAS PROBLEMS...\n         USING SSCONCBH,R7\n         LA    R7,SSCONFIR         GET ADDRESS OF FIRST CONSOLE\nSSCLOOP  DS    0H\n         USING SSCONCB,R7\n         CLC   SSCONNUM(4),=XL4'0000'  END OF SSCON CHAIN\n         BE    PART1EXT\n         TM    SSCONFLG,X'20'      MESSAGE INTERCEPTION ACTIVE ?\n         BNO   SSCLOOPE            NOPE, END OF THE LOOP\n         L     R10,SSCONNUM        GET SUBSYSTEM CONSOLE ID\n         CR    R6,R10              IS IT OURS ?\n         BE    FNDSSCON            BY GOLLY, IT SURE IS...\nSSCLOOPE DS    0H\n         LA    R7,SSCONCBL(R7)\n         B     SSCLOOP\n         DROP  R5\n***********************************************************************\n* NOW WE GET THE OSCMD INTERFACE CONTROL BLOCK, AND PROCEED FROM THERE*\n*                                                                     *\n***********************************************************************\nFNDSSCON DS    0H\n         ST    R7,SSCONENT         SSCONENT IS THE ENTRY FOR THIS\n*                                  CALL TO THE SSI CODE 9\n         TM    TSSOFLG2,TSSOMON    IS THE DEBUG TURNED ON ?\n         BNO   NDEB1\n         WTO   'A TSSO SS CONSOLE ID IS NOW BEING PROCESSED'\nNDEB1    DS    0H\n         L     R7,SSCONICB         GET ADDRESS OF OSCMDICB FOR THIS\n*                                  CONSOLE\n         DROP  R7\n         LTR   R7,R7\n         BZ    NOICB               PROBLEMS...\n         USING OSCMDICB,R7\n***********************************************************************\n* WE NEED TO FIGURE OUT IF THIS IS A MAJOR WQE, A MINOR WQE, OR       *\n* A NORMAL WQE. IT COULD ALSO BE A REPLY.                             *\n***********************************************************************\n         L     R10,SSWTMIN         GET MINOR WQE ADDRESS\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    MINZIP              DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\n         ST    R10,MINWQEAD        REMEMBER MINOR WQE ADDRESS\nMINZIP   DS    0H\n         L     R10,SSWTORE         GET ORE ADDRESS.\n         LTR   R10,R10             CHECK IT OUT..\n         BZ    OREZIP              DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         ST    R10,MAJOREAD        REMEMBER OREADDR\n*\nOREZIP   DS    0H\n*\n***********************************************************************\n* CHECK FOR A MULTI-LINE WTO.                                         *\n*                                                                     *\n***********************************************************************\n         L     R10,MINWQEAD        IS THIS A MULTI-LINE WTO ?\n         LTR   R10,R10             IF NON-ZERO, A MINOR WQE EXISTS,\n         BNZ   MLWTOWQE            SO WE GO AND PROCESS IT. OTHERWISE,\n*                                  CHECK TO SEE IF ITS THE FIRST LINE\n*                                  OF A MULTI-LINE WTO.\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   NORMWQE             NOPE, NORMAL WQE\n***********************************************************************\n* HERE, WE HAVE THE MAJOR WQE WITH MINORS TO FOLLOW. WE WILL PROCESS  *\n* THE MAJOR WQE BY QUEUEING THE RESPONSE TO OSCMD...                  *\n***********************************************************************\n         XR    R4,R4              CLEAR LEGNTH REGISTER\n         LH    R4,WMJMTXTL        GET LENGTH\n         LA    R5,WMJMTXT         GET ADDRESS OF MESSAGE\n         BAL   R14,QUEUEWQE       TELL OSCMD ABOUT IT\n         B     PART1EXT            MAJOR, WITH MINORS TO FOLLOW,\n         DROP  R10\n*\n***********************************************************************\n* PROCESS MULTI-LINE WQE'S...                                         *\n*                                                                     *\n***********************************************************************\nMLWTOWQE DS    0H\n***********************************************************************\n* AT THIS POINT, WE ARE PROCESSING ONE IN A SEQUENCE OF MINOR WQE'S.  *\n***********************************************************************\n* THERE MAY BE ZERO, ONE OR TWO MINOR WQE'S FOR EVERY INVOCATION OF   *\n* THE SUBSYSTEM INTERFACE. WE MUST CHECK FOR THESE CONDITIONS..       *\n* WE WILL QUEUE THE MINOR WQE'S IF THERE IS ROOM                      *\n***********************************************************************\n*        WTO   'TRAPPED A MULTILINE WTO'\n         L     R10,MINWQEAD        LETS DEAL WITH THE MINOR WQE\n         USING WMNM,R10\n         TM    WMNMLT1,WMNMLT1A+WMNMLT1B+WMNMLT1C   DATA ON THIS LINE ?\n         BZ    CHEKEND1            I GUESS NOT, WILL CHECK THE NEXT ONE\n         XR    R4,R4\n         IC    R4,WMNMTL1          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT1        GET ADDRESS OF PART 1\n         TM    WMNMML2,WMNMML2H    IS LINE 2 AVAILABLE ?\n         BNO   USELNE2\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND1 DS    0H\n         TM    WMNMLT1,WMNMLT1D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\nUSELNE2  DS    0H\n         TM    WMNMLT2,WMNMLT2A+WMNMLT2B+WMNMLT2C   DATA ON THIS LINE ?\n         BZ    CHEKEND2            I GUESS NOT, CHECK FOR END..\n         XR    R4,R4\n         IC    R4,WMNMTL2          GET LENGTH OF PART 1\n         LA    R5,WMNMTXT2        GET ADDRESS OF PART 1\n         BAL   R14,QUEUEWQE        GO TELL OSCMD ABOUT IT\n         LTR   R15,R15\n         BNZ   PSTOSCMD            IF THIS FAILED, DONT DO THE NEXT\n*                                  ONE\nCHEKEND2 DS    0H\n         TM    WMNMLT2,WMNMLT2D    ARE WE AT THE LAST ONE ?\n         BO    PSTOSCMD            YUP, POST THE OSCMD PROCESSOR\n         B     PART1EXT\n*\n         DROP  R10\n*\n*\nNORMWQE  DS    0H\n***********************************************************************\n* AT THIS POINT, WE HAVE DETERMINED THAT WE ARE PROCESSING AN AVERAGE *\n* EVERY DAY RUN OF THE MILL WQE. WE WILL DETERMINE IF IT IS DESTINED  *\n* FOR THE TSSO SUBSYSTEM CONSOLE, AND IF SO, PROCESS IT.              *\n***********************************************************************\n*        WTO   'TRAPPED A NORMAL WQE'\n         LA    R4,147       (PTF1) LENGTH IS ALWAYS 147 FOR A NORMAL\n*                           (PTF1) WQE\n         L     R5,MAJWQEAD         START AT MAJOR WQE ADDRESS\n         USING WQE,R5\n         LA    R5,WQETS     (PTF1) - GET TIMESTAMP INSTEAD OF TEXT\n         DROP  R5\n         BAL   R14,QUEUEWQE        QUEUE THIS WTO...\n***********************************************************************\n* NOTE THAT WE DONT REALLY CARE ABOUT THE SUCCESS OF THE QUEUEING.    *\n***********************************************************************\n         B     PART1EXT            END OF PART 1 OF SSI RTN 9.\n*\nQUEUEWQE DS    0H\n***********************************************************************\n* WE MUST PROCESS THE MESSAGE. WE WILL PLACE THE MESSAGE TEXT IN THE  *\n* FIELD POINTED TO BY THE OSCMDICB.                                   *\n* THE QUEUEWQE ROUTINE IS CALLED AS AN INTERNAL SUBROUTINE FOR THE    *\n* PURPOSE OF QUEUEING UP THE CAPTURED MESSAGES IN THE OSCMDICB.       *\n*\n***********************************************************************\n* INPUT REGISTERS:                                                    *\n*                                                                     *\n* R5 POINTS TO THE MESSAGE TO BE QUEUED UP (WQETXT FROM EITHER MAJOR  *\n*    OR MINOR                                                         *\n* R4 CONTAINS THE LENGTH OF THE MESSAGE.                              *\n* R14 CONTAINS THE RETURN ADDRESS.                                    *\n*                                                                     *\n* OUTPUT REGISTERS: R15 = 0 : MESSAGE INSERTED OK                     *\n*                   R15 = 4 : ERROR INSERTING MESSAGE.                *\n***********************************************************************\n         L     R6,OSCMDCNT         GET COUNT OF MESSAGES\n         C     R6,OSCMDMAX         HAVE WE HIT THE MAXIMUM YET ?\n         BE    ENDQWQE4            YUP, WE WILL IGNORE THIS MESSAGE\n*                                  AND ALL SUBSEQUENT MESSAGES.\n         LA    R6,1(R6)            INCREMENT COUNT OF MESSAGES\n         ST    R6,OSCMDCNT         AND STORE BACK.\n         L     R6,OSCMDNEX         GET NEXT BUFFER LOCATION\n         BCTR  R4,0\n         EX    R4,COPYWQET         COPY THE WQETEXT\n         LA    R6,150(R6)   (PTF1) INCREMENT BUFFER COUNT NOW 150\n         ST    R6,OSCMDNEX\n         B     ENDQWQE0\n*\nCOPYWQET MVC   0(0,R6),0(R5)     COPY TEXT INTO BUFFER\n*\nENDQWQE0 DS    0H\n         LA    R15,SSWTNDSP      SET CODE FOR MESSAGE SUPPRESSION\n         STH   R15,FUNC9RC\n         XR    R15,R15\n         B     ENDQWQE\nENDQWQE4 DS    0H\n         LA    R15,4\n         B     ENDQWQE\nENDQWQE  DS    0H\n         BR    R14\n*\nPSTOSCMD DS    0H\n***********************************************************************\n* NOW, WE WILL POST THE OSCMD PROCESSOR, BECAUSE THERE ARE NO MORE    *\n* WTO'S FORTHCOMING FOR THIS COMMAND, SO THERE IS NO REASON TO WAIT   *\n* FOR THE COMMAND TO END.. OSCMD IS WAITING ON TWO ECBS, THE FIRST    *\n* BEING A STIMER FOR THE TIME IN THE WAITIME VARIABLE, THE SECOND     *\n* BEING THE OSCMDECB FIELD. WE WILL POST THIS FIELD.                  *\n***********************************************************************\n         L     R10,SSCONENT               SS CON ENTRY FOR THIS CALL\n         USING SSCONCB,R10\n         NI    SSCONFLG,255-X'20'        INDICATE NO MORE MESSAGE TRAP\n         DROP  R10\n         LA    R2,OSCMDECB\n         L     R6,OSCMDACB               GET ASCB OF CALLERS ADDRESS SP\n         POST  (R2),X'000',ASCB=(R6),ERRET=PART1EXT,MF=(E,POST1D)\n         B     PART1EXT\n*\nNOICB    DS    0H\n         WTO   'TSS9201S INVALID ICB POINTER -> RESTART TSSO',DESC=(1)\n         B     FUNC9EXT\n*\n*\nPART1EXT DS    0H\nFUN9PRT2 DS    0H\n***********************************************************************\n* THIS IS THE SECOND PART OF THE SS09 INTERCEPT ROUTINE. BASICALLY,   *\n* ITS PURPOSE IS TO INTERCEPT LINES THAT START WITH \"#.LOGON\" AND     *\n* SUBSTITUTE STUFF ON THE REST OF THE LINE WITH GIBESRISH - TO BLANK  *\n* OUT THE PASSWORD THAT WOULD HAVE BEEN ENTERED ON THE LINE...        *\n***********************************************************************\n         L     R2,SSWTMIN                  CHECK OUT MINOR WQE\n         LTR   R2,R2\n         BNZ   PART2EXT                    MINOR WQE -> EXIT.\n         L     R2,SSWTORE                  CHECK OUT OPERATOR REPLY?\n         LTR   R2,R2\n         BNZ   PART2EXT                    OPERATOR REPLY -> EXIT\n         L     R2,SSWTWQE                  GET THE MAJOR WQE\n         USING WQE,R2\n         CLC   WQETXT+2(6),=XL6'4B9396879695'   #.LOGON LOWER CASE\n         BE    SUPRLOGN\n         CLC   WQETXT+2(6),=CL6'.LOGON'     IS THIS \"#.LOGON\" ?\n         BE    SUPRLOGN                    NO - IGNORE ...\n         B     PART2EXT\nSUPRLOGN DS    0H\n         LA    R15,SSWTNDNH      SET CODE FOR MESSAGE AND LOG\n*                                SUPPRESSION\n         STH   R15,FUNC9RC       SUPPRESS THE #.LOGON COMMAND.\n*        WTO   'TSS9209I TSSO .LOGON COMMAND ECHO SUPPRESSED'\n         B     FUNC9EXT                    AND GET OUT OF HERE\n         DROP  R2\nPART2EXT DS    0H\n***********************************************************************\n* THIS IS THE END OF THE PROCESSING ROUTINE FOR THE #.LOGON INTERFACE.*\n* PART 3 OF THIS ROUTINE IS THE PROCESSING OF THE AOF TABLE.          *\n***********************************************************************\n         B     FUN9PRT3\n*\n        TITLE 'AOF PROCESSING'\nFUN9PRT3 DS    0H\n***********************************************************************\n* THIS IS PART THREE OF THE WTO/WTOR MESSAGE INTERCEPTION FUNCTIONS.  *\n* HERE, WE HANDLE THE AUTOMATED OPERATIONS FACILITY.                  *\n***********************************************************************\n         L     R7,TSSOTABL         GET ADDRESS OF TABLE.\n         LTR   R7,R7               CHECK IT OUT\n         BZ    FUNC9EXT            NO TABLE, NO WORK TO DO.\n         SPACE 1                                                14DEC92\n         TM    TSSOFLG1,TSSOSMPF   OBEY MPF SUPPRESSION         14DEC92\n         BZ    FUN9ACT             NO, HANDLE ALL MESSAGES      14DEC92\n         L     R5,SSWTWQE          PICK UP WQE ADDRESS          14DEC92\n         USING WQE,R5              ESTABLISH ADDRESSABILITY     14DEC92\n         TM    WQESUPB,WQESMPF     SUPPRESSED BY MPF?           14DEC92\n         BO    FUNC9EXT            YES, IGNORE MESSAGE          14DEC92\n         DROP  R5                  END WQE ADDRESSABILITY       14DEC92\nFUN9ACT  DS    0H\n***********************************************************************\n* IF WE GET HERE, THE TSSO/AOF COMPONENT IS ACTIVE, AND THERE IS A    *\n* (VALID) TSSO AOF TABLE. THE VALIDITY OF THE TABLE IS DETERMINED AT  *\n* TSSO STARTUP/TABLE RELOAD TIME. R7 WILL SERVE AS A BASE REGISTER    *\n* FOR THE TSSO/AOF TABLE CURRENT ENTRY\n***********************************************************************\n* INITIALIZE VARIABLES.\n***********************************************************************\n***********************************************************************\n* THE FIRST PART OF THE ROUTINE WILL ISOLATE THE MESSAGE ID, BE IT A  *\n* WTO OR WTOR, AND PRESERVE IT FOR FUTURE EXAMINATION.                *\n***********************************************************************\n         MVI   FUN9FLG,X'00'       RESET FLAG.\n         L     R5,SSWTMIN          GET MINOR WQE ADDRESS\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    MINZERO             DONT SET FLAG\n         OI    FUN9FLG,X'80'       SSWTMIN \u00ac= ZERO\nMINZERO  DS    0H\n         L     R5,SSWTORE          GET ORE ADDRESS.\n         LTR   R5,R5               CHECK IT OUT..\n         BZ    OREZERO             DONT SET FLAG\n         OI    FUN9FLG,X'40'       SSWTORE \u00ac= ZERO\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         USING WQE,R5              GAIN ADDRESSABILITY TO WQE\n         MVC   TXTMSG(8),WQETXT+4  MOVE IN MESSAGE FOR WTOR\n         LA    R7,WQETXT+4         PICK UP STRING START FOR WQE\n         ST    R7,STRSTART         AND REMEMBER FOR TSSOPARS LATER\n         LA    R1,124              SET MAX. LENGTH\n         B     GOTORE\nOREZERO  DS    0H\n         L     R5,SSWTWQE          GET QUEUE ELEMENT\n         LA    R7,WQETXT+1         PICK UP STRING START FOR WQE\n         ST    R7,STRSTART         AND REMEMBER FOR TSSOPARS LATER\n*\n         LA    R7,WQETS            GET TIME STAMP ADDRESS FOR ACTION=\n*                                  POST\n         ST    R7,WQETSADR\n         USING WQE,R5\n         MVC   TXTMSG(8),WQETXT+1  WHY THE +1-- WHY NOT ?\n*                                  JUST SEEMS TO WORK BETTER\n         LA    R1,127              SET MAX. LENGTH\nGOTORE   DS    0H\n         ST    R1,STRLEN           SAVE LENGTH FOR LATER\n         ST    R5,WQEADDR          REMEMBER THE WQE ADDRESS\n         DROP  R5                  DROP ADDRESSABILITY TO WQE\n************************************************************\n* HERE IS WHERE WE EXAMINE THE TEXT OF THE WTO TO SEE IF WE SHOUD\n* TAKE ACTION.\n* THE ADDRESS OF THE TABLE IS IN TSSOTABL, AND THE FORMAT IS DOCUMENTED\n* IN THE TSSO: LOGIC GUIDE (WELL... MAYBE SOMEDAY)\n* R6: POINTS TO CURRENT TABLE ENTRY, DURING TEST PROCESSING.\n************************************************************\n         LM    R4,R6,TSSOBSTS           SETUP FOR BSCAN CALL    30OCT92\n         LA    R2,S9BSCMP               POINT AT COMPARE COMMAND30OCT92\n         BAL   R14,BSCAN                GO DO BINARY SEARCH     30OCT92\n         B     TSTALLMG                 +0 NOT FOUND, LOOK MSG=*30OCT92\n*                                       +4 FOUND, DO ENTRIES    30OCT92\n         L     R7,0(,R7)                POINT AT FIRST AOFNTRY  30OCT92\n         B     MATCHMSG                 GO AND PROCESS A MATCH  30OCT92\nS9BSCMP  CLC   TXTMSG(8),4(R7)     **BSCAN EXED** CHECK MSG ID  30OCT92\nTSTALLMG DS    0H                                               30OCT92\n         ICM   R7,4,TSSOALMS            POINT AT MSG=* ENTRIES  30OCT92\n         BZ    PART3EXT                 IF NONE, THEN ALL DONE  30OCT92\n         OI    FUN9FLG,X'10'            INDICATE BSCAN DONE     30OCT92\n         B     MATCHMSG                 GO PROCESS ALL ENTRIES  30OCT92\n         SPACE 2                                                30OCT92\n         USING AOFNTRY,R7               SETUP DSECT\n***********************************************************************\n* TSSO/AOF HAS PERFORMED THE REQUESTED FUNCTION, HOWEVER, WE CAN NOW\n* CONTINUE TO SCAN THE TSSO/AOF TABLE, IN HOPES OF FINDING ANOTHER\n* TABLE ENTRY TO MATCH THIS MESSAGE ID.\n***********************************************************************\nGETNEXT  DS    0H                       RUN THE REST OF TABLE   30OCT92\n         ICM   R7,15,AOFBNXT            NEXT AOF IN BSCAN CHAIN 30OCT92\n         BNZ   MATCHMSG                 HAVE SAME MESSAGE ID    30OCT92\n         TM    FUN9FLG,X'10'            DONE MSG=* PROCESSING?? 30OCT92\n         BZ    TSTALLMG                 NO, TRY THE MSG=* TYPE  30OCT92\n         B     PART3EXT                 ALL DONE WITH MSG=*     30OCT92\n         EJECT                                                  30OCT92\nMATCHMSG DS    0H\n         ST    R7,CURTABAD              SAVE CURRENT ENTRY ADDR\n***********************************************************************\n* WE COME HERE WHEN A MATCH HAS BEEN FOUND IN THE MESSAGE ID SECTION  *\n* OF A TSSO TABLE ENTRY. THE PROCESSING CONTINUES WITH THE PERFORMING *\n* OF ANY TESTS THAT NEEDS TO BE ISSUED. IF ALL TESTS ARE MATCHED, THAN*\n* BRANCH TO THE PERFACT ROUTINE, WHICH WILL PERFORM ANY ACTIONS       *\n* REQUIRED. IF THE TESTS ARE NOT MET, CONTINUE SEARCHING THE TABLE AS *\n* THERE MAY BE ANOTHER MATCH.\n***********************************************************************\n         L     R6,AOFTESTP               LOAD UP TEST ENTRY.\n         USING ATSNTRY,R6\nTESTLOOP DS    0H                        LOOP FOR TEST ENTRIES\n         LTR   R6,R6                     ANY MORE TEST ENTRIES ?\n         BZ    TESTSUCC                  NOPE, ALL TESTS MUSTBE OK\n         L     R1,ATSWORD          LOAD SUBSTR OR WORD NUMBER\n         ST    R1,WORD1            AND REMEMBER IT.\n         L     R1,ATSLNGTH         LOAD LENGTH\n         ST    R1,WORD2\n         MVC   WORDSEPS(4),ATSSEPS LOAD WORD SEPARATORS.\n***********************************************************************\n* WE MUST DETERMINE THE TEST TYPE, EITHER A WORD TYPE, OR A SUBSTR    *\n* TYPE.                                                               *\n***********************************************************************\n         CLC   ATSTYPE,=CL2'W'     IS IT A WORD ?\n         BE    WORDTYPE            YUP, GO PROCESS IT\n         CLC   ATSTYPE,=CL2'P'     IS IT A SUBSTRING ?\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLC   ATSTYPE,=CL2'S'     IS IT A SUBSTRING ?\n         BE    SUBSTYPE            YUP, GO PROCESS IT.\n         CLC   ATSTYPE,=CL2'L'     IS IT A LINE NUMBER?\n         BNE   TESTTBAD            NO, IT IS WRONG\n         L     R2,ATSLINE          PICK UP LINE NO.\n         BAL   R14,SEDOLINE        TRY TO FIND IT\n         B     TESTFAIL            NO MATCH, THIS TEST FAILS\n         B     SUBSSUCC            SUCCESSFUL, GO ONTO NEXT TEST\n         SPACE 1\nTESTTBAD DS    0H                  INVALID TEST TYPE\n* NEITHER WORD NOR SUBSTRING, ** PROBLEM **\n         WTO   'TSS9202E INVALID TEST TYPE- IGNORING MESSAGE ID'\n*        B     TESTFAIL            SIMULATE TEST FAILING !\n         B     PART3EXT            STOP PROCESSING ON FAILURE    *SEAG*\n         EJECT ,\nWORDTYPE DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE HAVE A WORD TEST. THE ROUTINE WILL PERFORM THE\n* FOLLOWING PROCEDURES.\n*                                                                     *\n* 1) USE TSSOPARS TO PARSE THE MESSAGE, BASED ON THE SEPARATOR CHARS  *\n*    SPECIFIED IN THE TABLE.                                          *\n* 2) PERFORM THE TEST BASED ON THE DESIRED WORD, USING THE LENGTH     *\n*    SPECIFIED IN THE TABLE.                                          *\n* 3) EITHER GO TO TESTFAIL, OR PERFORM ANOTHER TEST.                  *\n*                                                                     *\n***********************************************************************\n         L     R10,STRSTART      GET ADDRESS OF STRING\n*                                 NOTE- COULD HAVE BEEN WQETXT+1 IF WTO\n*                                 OR WQETXT+4 IF WTOR.\n         ST    R10,PARS1         THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY      PARARRAY IS THIRD PARAMETER\n         ST    R10,PARS3         STORE IN PARM LIST.\n*\n         LA    R10,WORDSEPS      USE WORD SEPARATORS ON TEST DIRECTIVE\n         ST    R10,PARS4         AND STORE IN FOURTH WORD IN PARM LIST.\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY     HOW MANY DID WE GET BACK\n         C     R10,WORD1        SEE WHICH ONE WAS SPECIFIED IN THE\n*                                TEST PARAMETER LIST.\n         BL    WORDFAIL          NOT ENOUGH WORDS.. FAIL THIS TEST.\n         LA    R10,PARARRAY+2   POINT TO WORD NUMBER 1\n         L     R5,WORD1          GET WORD  REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN\n         ST    R10,TOKADDR      REMEMBER WHERE TOKEN WAS FOUND.\n***********************************************************************\n* AT THIS POINT, TOKADDR CONTAINS THE ADDRESS OF THE TOKEN (WORD) THAT*\n* WAS LOCATED BY TSSOPARS. WE WILL COMPARE THIS WORD, FOR N CHARACTERS*\n* AGAINST WHAT WAS SPECIFIED IN THE TSSO/AOF TABLE. IF MATCHED, GREAT *\n* IF NOT, TEST HAS FAILED.                                            *\n*\n* WE NEED TO LOAD UP THE MATCH TEXT AS SPECIFIED IN THE AOF TABLE.    &\n***********************************************************************\n         LH    R4,ATSTXTL       GET MATCHING TEXT LENGTH\n***********************************************************************\n* NOTE, THE MATCHING TEXT STRING IS AT 20(R6) WHERE R6 POINTS TO THE\n* TEST PARAMETER ENTRY (TPE).\n***********************************************************************\n         L     R5,TOKADDR       LOAD TOKEN ADDRESS\n         BCTR  R4,0             -1 FOR HARDWARE DEFIENCY.\n         EX    R4,COMPSTR       DO COMPARE !\n         BE    WORDSUCC        WORD MATCHED !!\n         BNE   WORDFAIL         WORD DIDNT MATCH !!!\nCOMPSTR  CLC   0(0,R5),ATSTXT   ** EXECUTED **\nWORDSUCC DS    0H\n************************************************************\n* WE COME HERE IF THE WORD MATCHED, IMPLYING THAT THIS PARTICULAR\n* TEST WAS SUCCESSFULL. NOW WE WILL GO SEE IF THERE ARE ANY MORE\n* TESTS..\n************************************************************\n         L     R6,ATSNXT        GET NEXT TEST ENTRY\n         B     TESTLOOP         AND TRY AGAIN...\n*\nWORDFAIL DS    0H\n         B     TESTFAIL         IF THIS TEST FAILED, ALL TESTS\n*                               FOR THIS ENTRY FAIL, AND WE\n*                               CONTINUE SEARCHING THROUGH THE\n*                               TABLE.\n*\nSUBSTYPE DS    0H\n***********************************************************************\n* THE USER REQUESTED A SUBSTRING TYPE OF TEST ON THE MESSAGE. THE     *\n* ROUTINE WILL PROVIDE THAT TEST. THE TEST IS:                        *\n* SUBSTR(MVSWTO,START IN AOF,LENGTH IN AOF) ?= MATCHTEX IN AOF.       *\n*                                                                     *\n***********************************************************************\n         L     R5,STRSTART      GET START OF MVS MESSAGE.\n         L     R4,WORD1         GET START AS SPECIFIED IN AOF.\n         BCTR  R4,0             -1 TO GET CORRECT CHARACTER.\n         LA    R5,0(R4,R5)      POINT TO START OF SUBSTRING IN WQE\n         L     R4,WORD2         GET LENGTH FOR COMPARE.\n         BCTR  R4,0             -1 FOR EXECUTE\n         EX    R4,COMPSTR2      PERFORM THE SUBSTRING COMPARE.\n         BE    SUBSSUCC         THEY MATCHED! -> TEST SUCCEDED.\n         BNE   SUBSFAIL         NO MATCHED- SUBS FAILED\n***********************************************************************\n* NOTE THAT THE MATCH TEXT IS IN 20(R6) WHERE R6 POINTS TO THE CURRENT\n* AOF TABLE.\n***********************************************************************\nCOMPSTR2 CLC   0(0,R5),ATSTXT\nSUBSSUCC DS    0H\n***********************************************************************\n* WE GET HERE IF THE SUBSTRING TEST WAS SUCCESSFULL. TSSO/AOF WILL\n* CHECK THE NEXT ENTRY IN THE TABLE AND ATTEMPT THE NEXT TEXT\n***********************************************************************\n         L     R6,ATSNXT\n         B     TESTLOOP\n*\nSUBSFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF THIS SUBSTRING TEST HAS FAILED. IF THIS IS THE CASE *\n* THEN WE WILL CONTINUING SEARCH AOF TABLE ENTRIES IN HOPES OF AGAIN  *\n* FINDING THE MSG ID.\n***********************************************************************\n         B     TESTFAIL\nTESTFAIL DS    0H\n***********************************************************************\n* WE COME HERE IF A WORD OR SUBSTRING TEST FAILS. IF THIS SHOULD      *\n* HAPPEN, WE CONTINUE SEARCHING THROUGH ALL TSSO/AOF TABLE ENTRIES    *\n* FOR ANOTHER MATCH ON THE MSGID.                                     *\n***********************************************************************\n         B     GETNEXT          GO TEST ANOTHER AOF ENTRY\n*\nTESTSUCC DS    0H\n***********************************************************************\n* WE COME HERE IF ALL TESTS HAVE BEEN SUCCUSSFULL FOR THIS TABLE ENTRY*\n* TSSO WILL GO AND PERFORM THE ACTION REQUESTED AND CONTINUE SEARCHING*\n* THE TABLE FOR ANY ADDITIONAL ENTRIES.                               *\n***********************************************************************\n         B     PERFACT\n         DROP  R6\n*\nPERFACT  DS    0H\n************************************************************\n* WE COME HERE WHEN WE HAVE FOUND A WTO IN THE TABLE, AND THE TESTS\n* SPECIFIED FOR THE ENTRY HAVE BEEN MET. AT THAT TIME, WE PERFORM\n* THE ACTION SPECIFIED IN THE ACTION= PARAMETER FOR THE ENTRY.\n*\n* PROCESSING CONTINUES AS FOLLOWS:\n*\n* 1) IF MATCHLIM PROCESSING HAS BEEN SPECIFIED (MATCHLIM > 0) DEDUCT\n*    ONE FROM MATCHLIM. IF MATCHLIM = 999999 THEN DONT BOTHER. IF\n*    MATCHLIM = 0 THEN DO NOT PERFORM THE REQUESTED FUNCTION AFTER ALL.\n*\n* 2) WE IDENTIFIY WHAT THE TABLE WANTS US TO DO, I.E. ISSUE AN OS\n*    COMMAND, TSSO COMMAND, REPLY, OR WHATEVER. WE THEN BRANCH TO THE\n*    APPROPRIATE ROUTINE.\n*    NOTE THAT R7 POINTS TO THE ENTRY IN THE TSSO/AOF TABLE.\n*\n************************************************************\n         L     R2,AOFMLIM                PICK UP MATCHLIM VALUE.\n         C     R2,=F'999999'             WAS MATCHLIM SPECIFIED ?\n         BE    PASTMLIM                  NO - DONT BOTHER DEDUCTING\n         LTR   R2,R2                     IS COUNT ALREADY ZERO ?\n         BZ    FUN9NACT                  NO, TAKE NO ACTION...\n         BCTR  R2,0                      TAKE  ONE AWAY FROM MATCHLIM\n         ST    R2,AOFMLIM                AND STORE NEW MATCHLIM BACK\nPASTMLIM DS    0H\n***********************************************************************\n* HERE, WE HAVE SURVIVED MATCHLIM PROCESSING, AND ARE READY TO TAKE   *\n* ON THE ACTION SPECIFIED IN THE ACTION= PARAMETER OF THE AOF TABLE   *\n***********************************************************************\n         CLC   AOFACTN,=CL8'NONE'       IS THIS A DUMMY REQUEST?\n         BE    GETNEXT                  YES, SO WE HAVE DONE IT\n*\n         CLC   AOFACTN,=CL8'REPLY'       REQUEST TO REPLY ?\n         BE    FUN9RPLY\n         CLC   AOFACTN,=CL8'SUPPRESS'     REQUEST TO SUPPRESS.\n         BE    FUN9SUPP\n         CLC   AOFACTN,=CL8'HILIGHT'     REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'HIGHLITE'   REQUEST TO HILIGHT ?\n         BE    FUN9LITE\n         CLC   AOFACTN,=CL8'LOWLIGHT'    REQUEST TO TURN OFF HIGHLITE\n*                                       DESCRIPTOR ?\n         BE    FUN9LOW\n         CLC   AOFACTN,=CL8'OSCMD'      REQUEST FOR AN OS COMMAND ?\n         BE    FUN9CMND\n         CLC   AOFACTN,=CL8'OSCMDT'     REQUEST FOR AN OS COMMAND ?\n*                                       IN TEST MODE ?\n         BE    FUN9CMDT\n*\n         CLC   AOFACTN,=CL8'POST'       IS THIS REQUEST FOR POST\n         BE    FUN9POST\n*\n         WTO   'TSS9203E INVALID DIRECTIVE',DESC=1\n         B     PART3EXT                 SCOTTY, BEAM ME UP.\nFUN9NACT DS    0H\n***********************************************************************\n* HERE, THE MATCHLIM TEST HAS DETERMINED A ZERO MATCHLIM - IMMEDAITELY*\n* TERMINATE SS09 PROCESSING WITHOUT DOING ANYTHING                    *\n***********************************************************************\n         B     GETNEXT                 GET NEXT TSSO/AOF TABLE ENTRY\nFUN9CMDT DS    0H\n         OI    FUN9FLG,X'20'           INDICATE TEST MODE\n         B     FUN9CMND\nFUN9CMND DS    0H\n************************************************************\n* HERE IS THE ENTRY POINT FOR ISSUEING OS COMMANDS BASED ON\n* WTO'S.\n************************************************************\n         SPACE 1\nCMNDGO   DS    0H\n         LA    R2,MVSCMD+4       STARTING POINT FOR MVS CMD\n         MVI   MVSCMD+4,X'40'         BLANK OUT THE\n         MVC   MVSCMD+5(104),MVSCMD+4 COMMAND BUFFER\n         LA    R3,AOFACT         START POINT FOR MVS DIRECTIVE\n         LH    R4,AOFACTL        LENGTH OF MESSAGE\nCMNDLOOP DS    0H\n         LTR   R4,R4            CHECK TO SEE IF ANY CHARS REMAIN\n*                               IN BUFFER. THIS COULD HAVE HAPPENED\n*                               IF THE FORMATTING OPTION HAD BEEN\n*                               THE LAST THING IN THE TEXT OPERAND\n         BZ    ISSUECMD\n         CLI   0(R3),C'\\'       SIGNIFICANCE CHARACTER ON?\n         BE    SIGON             WELL.. IT IS NOW.\n         MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         BCT   R4,CMNDLOOP\n         B     ISSUECMD          GO DO THE COMMAND\n*\nSIGON    DS    0H\n************************************************************\n* WE COME HERE WHEN WE FIND THE '\\' DIRECTIVE IN THE TSSO TABLE\n* ENTRY FOR THIS MESSAGE. THIS MEANS WE HAVE SOME WORK TO DO.\n************************************************************\n         LA    R3,1(R3)           POINT TO NEXT CHARACTER\n         CLI   0(R3),C'P'         LOOKING FOR POSITION CHARACTER?\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'S'         CHECK ITS SYNONYM\n         BE    SIGONP             YUP.. GOT IT\n         CLI   0(R3),C'W'         LOOKING FOR SOME 'WORD' ?\n         BE    SIGONW             YUP, GO DO IT !!\n         B     SIGWRONG           NO, INVALID '\\' DIRECTIVE...\n         SPACE 2\nSIGONP   DS    0H\n         CLI   4(R3),C','         CHECK FOR CORRECT FORMAT.\n         BNE   SIGWRONG\n         CLI   7(R3),C'\\'         CHECK FOR CLOSING TERMINATOR.\n         BNE   SIGWRONG           OH WELL...\n*\n         LA    R10,WORKAREA       POINT R10 TO WORKAREA FOR CVT\n         LA    R0,3               SET LENGTH FOR FIRST CONVERT\n         LA    R1,1(R3)           SET ADDRESS\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGSTART        REMEMBER STARTING POINT\n         LA    R0,2               GET LENGTH\n         LA    R1,5(R3)           GET NEW START POINT FOR CONVERT\n         CALL  JCECVTDB           ** CONVERT **\n         LTR   R1,R1\n         BZ    SIGWRONG           INVALID DATA\n         ST    R1,SIGCOUNT        SAVE COUNT\n************************************************************\n* AT THIS POINT, WE HAVE THE PARAMETERS NEEDED FOR TEXT\n* SUBSTITUTION IN THE OS COMMAND TO BE ISSUED.\n************************************************************\n         L     R1,SIGCOUNT              GET COUNT FOR EXECUTE\n         BCTR  R1,0                     MAKE UP FOR HARDWARE FAULTS\n         L     R10,STRSTART             GET START ADDRESS OF TEXT\n         L     R5,SIGSTART              GET STARTING POINT\n         C     R5,STRLEN                CHECK STARTING POINT\n         BH    SIGWRONG                 IF TO HIGH, FORGET IT\n         LA    R10,0(R10,R5)            POINT TO STARTING POINT IN WQE\n*                                       FOR MOVE.\n         BCTR  R10,0                    GET EXACT CORRECT POSTITION\n         EX    R1,MOVESIG               MOVE THE STUFF...\n         B     AR2\nMOVESIG  MVC   0(0,R2),0(R10)\nAR2      DS    0H\n         A     R2,SIGCOUNT              NEXT CHAR IN CMD BUFFER\n         LA    R3,8(R3)                 MOVE PAST \\ STUFF IN TSSO TABLE\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWRONG\n         B     CMNDLOOP\nSIGWRONG DS    0H\n         WTO   'TSS9204E ERROR IN DEFINITION (P) FOR NEXT WTO MSG'\n         B     PART3EXT\n*\nSIGONW   DS    0H\n         CLI   7(R3),C'\\'               TERMINATION FOR W DIRECTIVE\n         BNE   SIGWBAD                 SHUCKS\n         MVC   SEPCHAR(4),1(R3)        GET SEPARATOR CHARACTERS\n         LA    R1,5(R3)                GET START FOR CONVERT RTN\n         LA    R0,2\n         LA    R10,WORKAREA\n         CALL  JCECVTDB                GET DECIMAL\n         LTR   R1,R1                   CHECK IT OUT\n         BZ    SIGWBAD\n         ST    R1,WORDREQ              THIS IS THE REQUESTED WORD\n         CH    R1,=H'20'               BUT IS IT OK?\n         BH    SIGWBAD                 NO, GUY DIDNT READ THE DOC\n************************************************************\n* NOW, WE MUST SET UP THE PARSE ROUTINE. THE GENERAL ID IS TO\n* PARSE THE WTO MSG INTO USER DEFINED WORDS, AND THEN GET THE ONE\n* HE WANTS.\n************************************************************\n         L     R10,STRSTART       GET ADDRESS OF STRING\n         ST    R10,PARS1          THERES OPERAND NUMBER 1\n*\n         MVC   PARS2(4),STRLEN    LENGTH OF WTO MESSAGES\n*\n         MVI   PARARRAY,X'40'\n         MVC   PARARRAY+1(255),PARARRAY      BLANK OUT PARARRAY\n         MVC   PARARRAY+256(LPARRAY-256),PARARRAY               15OCT92\n         MVC   PARARRAY(2),=H'20'           MAX OF 20 TOKENS.\n         LA    R10,PARARRAY\n         ST    R10,PARS3\n*\n         LA    R10,SEPCHAR\n         ST    R10,PARS4\n*\n         LA    R1,PARSPARM\n         CALL  TSSOPARS          ** P A R S E   I T   **\n*        MVC   PARARRAY(2),=H'1'\n         LH    R10,PARARRAY      HOW MANY DID WE GET BACK\n         C     R10,WORDREQ       SEE HOW MANY HE WANTED\n         BL    NOWORDS           NOT ENOUGH WORDS.. FORGET IT.\n         LA    R10,PARARRAY+2    POINT TO WORD NUMBER 1\n         L     R5,WORDREQ        GET WORDS REQUESTED\n         BCTR  R5,0\n         SLL   R5,4              MULTIPLY BY 16\n         LA    R10,0(R5,R10)     POINT TO TOKEN... NOW WE GET LENGTH\n         ST    R10,TOKADDR       REMEMBER WHERE TOKEN WAS FOUND.\n         XR    R5,R5\n         LA    R1,16             TOKENS ARE 16 BYTES LONG\n************************************************************\n* AT THIS POINT, R10 POINTS TO THE TOKEN RETURNED BY THE PARSE ROUTINE\n* THAT THE USER REQUESTED.\n************************************************************\nWLOOP    DS    0H\n         CLI   0(R10),C' '\n         BE    ENDTOKEN\n         LA    R5,1(R5)\n         LA    R10,1(R10)\n         BCT   R1,WLOOP\nENDTOKEN DS    0H\n         ST    R5,LWORDREQ       STORE LENGTH OF REQUESTED WORD\n************************************************************\n* AT THIS POINT, WE HAVE ALL THE INFORMATION NEEDED TO DO  *\n* THE PARAMETER SUBSTITUTION. R2 POINTS TO THE SPOT TO     *\n* SUBSTITUTE.                                              *\n************************************************************\n         L     R5,LWORDREQ              GET LENGTH OF WORD\n         BCTR  R5,0                     MINUS 1 FOR EXECUTE\n         L     R10,TOKADDR\n         EX    R5,MOVEWORD\n         B     AR3\nMOVEWORD MVC   0(0,R2),0(R10)\nAR3      DS    0H\n         A     R2,LWORDREQ\n         LA    R3,8(R3)\n         SH    R4,=H'9'\n         LTR   R4,R4\n         BM    SIGWBAD\n         B     CMNDLOOP\nNOWORDS  DS    0H\n         WTO   'TSS9205E NOT ENOUGH TOKENS IN BELOW WTO TO PROCESS'\n         B     PART3EXT\nSIGWBAD  DS    0H\n         WTO   'TSS9206E ERROR PROCESSING W DIRECTIVE- MSG IGNORED'\n         B     PART3EXT\nSIGLBAD  DS    0H\n         WTO   'TSS9208E ERROR PROCESSING L DIRECTIVE- ENTRY IGNORED'\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\nISSUECMD DS    0H\n         TM    FUN9FLG,X'20'            WAS OSCMD SPECIFIED ?\n         BNO   ISSURCMD                GO ISSUE REAL COMMAND\n* HERE, WE WILL NOT ISSUE THE COMMAND, BUT WE WILL WTO OUT WHAT THE\n* COMMAND WOULD HAVE BEEN\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+13(105),MVSCMD+4\n         WTO   MF=(E,WTO1D)           (MSG 207) DEFINED IN THIS MODULE\n         B     GETNEXT            TRY THE NEXT TSSO/AOF TABLE ENTRY\n*\nISSURCMD DS    0H\n         MVC   MVSCMD(2),=H'109'\n         MVC   MVSCMD+2(2),=H'0'\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(105),MVSCMD+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF1                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG1\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES1\nECHOOFF1 DS    0H\n         B     AFTECHO1                        NO ECHO, WHAT A SHAME\n*\nECHOYES1 DS    0H\n         WTO   MF=(E,WTO1D)        (MSG207)\n         B     AFTECHO1                        ECHO TO MASTCONS\n*\nECHOLOG1 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),MVSCMD+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO1\n*\nAFTECHO1 DS    0H\n         LH    R0,MASTCONS\n         LA    R1,MVSCMD\n         SVC   34\n         B     GETNEXT\nFUN9LITE DS    0H\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       HILIGHT\n         OI    WQEDC1,WQEDCB            HILITE THE SUCKER\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n*                                       FOR HILIGHT\n         B     GETNEXT\n*\nFUN9LOW  DS    0H\n***********************************************************************\n* THIS IS THE ROUTINE TO \"LOWLITE\" A MESSAGE. THE ROUTINE BASICALLY   *\n* INTERCEPTS THE MESSAGE, AND FLIPS OFF THE WQEDCA BIT.               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R5,WQEADDR               GET ADDRESS OF THIS WQE\n         USING WQE,R5                   GAIN ADDRESSABILITY TO WQE FOR\n*                                       LOW LIGHT\n         NI    WQEDC1,255-WQEDCA        (PTF3)\n         NI    WQEDC1,255-WQEDCB\n         NI    WQEDC1,255-WQEDCC        KILL EVENTUAL ACTION MSG15OCT92\n         NI    WQEDC2,255-WQEDCK\n         NI    WQEXA,255-WQEWTOR        FAKE OUT COMTASK INTO THINKING\n*                                       THE MESSAGE IS NOT A WTOR...\n* HILIGHTING CAUSED BY DESCRIPTOR CODES 1, 2 AND 11.\n         DROP  R5                       NO LONGER NEED ADDRESSABILITY\n         B     GETNEXT\n*\nFUN9SUPP DS    0H\n***********************************************************************\n* THIS IS THE SUPPRESS HANDLER. THE SUPPRESS FUNCTION IS PROBABLY THE *\n* CLEANEST IN THE WHOLE PRODUCT, BECAUSE SUBSYSTEM CAN CAUSE MESSAGES *\n* TO BE SUPPRESSED. NOTE THAT THIS FUNCTION WILL BE INEFFECTIVE FOR   *\n* WTOR REQUESTS, HOWEVER, THE LOWLIGHT FUNCTION CAN BE USED.          *\n***********************************************************************\n         LA    R5,SSWTNDSP              LOAD CODE FOR SUPPRESSION\n         STH   R5,FUNC9RC               AND STORE IT AWAY.\n         B     GETNEXT                  GET A NEW ENTRY\n*\nFUN9RPLY DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO AOF REPLY FUNCTION. THE IDEA   *\n* HERE IS TO INTERCEPT THE WTOR, FORMAT A REPLY COMMAND OF THE FORM   *\n* R NN,MSG-TEXT WHERE NN IS PICKED UP FROM THE ORE (OREID) FIELD.     *\n* MSG-TEXT IS PICKED UP FROM THE AOF TABLE. THIS IS USEFULL IN        *\n* NUKING OUTSTANDING REPLIES, LIKE IMS. THE REPLY COMMAND CAN THEN BE *\n* USED TO REPLY TO THOSE OUTSTANDING MESSAGES.                        *\n***********************************************************************\n         L     R5,SSWTORE               GET THE OPERATOR REPLY ELEMENT\n         LTR   R5,R5                    MAKE SURE..\n         BZ    GETNEXT\n         USING OREF,R5                  GAIN ADDRESSABILITY TO ORE.\n         MVC   REPLY(2),=H'64'\n         MVC   REPLY+2(2),=H'0'\n         MVC   REPLY+4(6),=CL6'REPLY'\n         MVI   REPLYCOM,C','\n         MVC   REPLYNUM(2),OREID        MOVE IN AUTOMATIC REPLY NUM\n         LH    R1,AOFACTL               PICK UP LENGTH OF REPLY\n         BCTR  R1,0\n         MVI   REPLYMSG,X'40'\n         MVC   REPLYMSG+1(99),REPLYMSG   CLEAR REPLYMSG\n         EX    R1,MOVERPLY\n         B     AR4\nMOVERPLY MVC   REPLYMSG(0),AOFACT          MOVE IN AUTOMATIC REPLY\nAR4      DS    0H\n***********************************************************************\n* THE REPLY DIRECTIVE IS SUPPORTED BY THE ECHO FACILITY. CHECK TO SEE *\n* IF THE TABENTRY MACRO SPECIFIED ECHO= ON THE CARD, AND TAKE ACTION  *\n***********************************************************************\n         MVC   WTO1D(WTO1CE-WTO1C),WTO1C\n         MVC   WTO1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTO1D+16(108),REPLY+4\n         CLC   AOFECHO,=CL2'NO'                ECHO ON ?\n         BE    ECHOOFF2                        NO, GO ISSUE COMMAND\n         CLC   AOFECHO,=CL2'LO'                ECHO ON FOR LOGGING ?\n         BE    ECHOLOG2\n         CLC   AOFECHO,=CL2'YE'                ECHO ON ?\n         BE    ECHOYES2\nECHOOFF2 DS    0H\n         B     AFTECHO2                        NO ECHO, WHAT A SHAME\n*\nECHOYES2 DS    0H\n         WTO   MF=(E,WTO1D)\n         B     AFTECHO2                        ECHO TO MASTCONS\n*\nECHOLOG2 DS    0H\n         MVC   WTL1D(WTL1CE-WTL1C),WTL1C\n         MVC   WTL1D+4(12),=CL12'(TSSO AOF): '   PRIME FOR ECHO\n         MVC   WTL1D+16(105),REPLY+4\n         WTL   MF=(E,WTL1D)\n         B     AFTECHO2\nAFTECHO2 DS    0H\nISSUERPL DS    0H\n         LH    R0,MASTCONS              LETS DO REPLY FROM MASTCONS\n         LA    R1,REPLY\n         SVC   34\n         B     GETNEXT\n         DROP  R5               DROP ADDRESSABILITY TO OREF\nFUN9POST DS    0H\n***********************************************************************\n* THIS IS THE ENTRY POINT FOR THE TSSO POST ROUTINE, ALLOWING THE     *\n* CALLER TO WAIT ON A GIVEN MESSAGE OR AOF ENTRY ID BEFORE BEING      *\n* POSTED. THE CALLER WILL BE THE OSWAIT TSO COMMAND, OR (PERHAPS) ITS *\n* NCCF EQUIVALENT. STANDARD TSSO ACTION IS THE FOLLOWING:             *\n*                                                                     *\n* 1) DETERMINE IF THE CURRENT MESSAGE IS ACTIVE. IF NOT, TERMINATE    *\n*    IMMEDIATELY.                                                     *\n*                                                                     *\n* 2) GET THE ADDRESS SPACE, ECB AND PLACE TO PUT THE WTO INTO         *\n*    VARIABLES                                                        *\n*                                                                     *\n* 3) COPY THE WTO INTO THE AOF TABLE ENTRY                            *\n*                                                                     *\n* 4) POST THE ECB IN THE SPECIFIED ADDRESS SPACE                      *\n*                                                                     *\n* 5) GO TO NEXT ENTRY.                                                *\n*                                                                     *\n***********************************************************************\n         TM    AOFPFLG,AOFP1WT  IS THIS ENTRY BEING WAITED ON ?\n         BNO   END9POST         NO, END OF FUNCTION...\n*\n         L     R2,AOFPECB       PICK UP ECB TO POST....\n         L     R3,AOFPASCB      AND GET THE ADDRESS SPACE.\n         L     R4,WQETSADR      GET ADDRESS OF WQE\n         MVC   AOFWQE(147),0(R4) COPY TO AOF TABLE\n         POST  (R2),X'000',ASCB=(R3),ERRET=END9POST,MF=(E,POST1D)\nEND9POST DS    0H\n         B     GETNEXT\n         DROP  R7\n         SPACE 2\nPART3EXT DS    0H\n***********************************************************************\n* FINISHED WITH DOING THE AOF PROCESSING OF THE MESSAGE, EXIT NICELY  *\n***********************************************************************\n         B     FUNC9EXT                 ALL DON SO EXIT\n         EJECT ,\nGETMERR  DS    0H\n***********************************************************************\n* THIS CODE IS BRANCHED TO IN CASE OF A GETMAIN ERROR WITHIN          *\n* TSSOSS09. THIS WILL OCCUR IF THE CURRENT ADDRESS SPACE SUFFERS      *\n* AN 80A OR 878 ABEND. IT IS (PROBABLY) NOT A GOOD IDEA TO ISSUE      *\n* A WTO BECAUSE SS09 WOULD GET REDERIVEN BUT STILL BE OUT OF STORAGE  *\n***********************************************************************\n*        WTO   'TSS9208S SS09 TERMINATING BECAUSE IT CANT GET STORAGE'\n         B     FUNC9EX2\nFUNC9EXT DS    0H\n         LH    R8,FUNC9RC          TEMP STORAGE FOR THE RETURN CODE\n         L     R10,SSOBADDR\n         USING SSOB,R10\n         ST    R8,SSOBRETN\n         DROP  R10\n         FREEMAIN R,LV=4096,A=(R11)\nFUNC9EX2 DS    0H\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\nFUNC9EX3 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         XR    R15,R15             COPY RC INTO REG 15\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\n         TITLE 'LOCATE LINE NUMBER IN MULTI-LINE WTO'\n***********************************************************************\n* THIS CODE ADDED BY D.H.CARTWRIGHT, SPRECHER ENERGIE, OBERENTFELDEN  *\n* CH-5036 SWITZERLAND AS PART OF THE ENHANCEMENT TO ALLOW DATA FROM   *\n* MULTI-LINE WTO'S TO BE USED IN OSCMD TEXT. THIS IS PARTICULARLY     *\n* NECESSARY FOR VTAM ERRORS DESCRIBED BY THE MLWTO MESSAGE 'IST663I'. *\n*                                                                     *\n* BASICALLY IT CHECKS THAT WE ARE PROCESSING THE REQUIRED LINE, THEN  *\n* ADJUSTS THE STRSTART AND STRLEN VARIABLES SO THAT THE EXISTING      *\n* PROCESSING WILL BE SWITCHED TO THE APPROPRIATE LINE OF TEXT.        *\n*                                                                     *\n* ON ENTRY R2  =  LINE NUMBER REQUIRED                                *\n*          R6  =  TEST DEFINITION CONTROL BLOCK                       *\n*                                                                     *\n* ON EXIT  STRSTART AND STRLEN HAVE BEEN ADJUSTED TO POINT TO THIS WQE*\n*    EXIT IS TO R14+4 IF THE LINE HAS BEEN FOUND                      *\n*               R14+0 IF THIS IS NOT THE REQUIRED LINE                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING ATSNTRY,R6\nSEDOLINE DS    0H                  LOCATE SPECIFIC LINE\n         TM    TSSOFLG2,TSSOMON    IS DEBUG TURNED ON ?\n         BNO   SEDOLINJ            NO, CHECK MAJOR\n         WTO   'A LINE NUMBER HAS BEEN REQUESTED'\nSEDOLINJ DS    0H                  PROCESS MAJOR WQE\n         L     R10,MAJWQEAD        GET MAJOR BACK...\n         USING WMJM,R10            ESTABLISH ADDRESSABILTIY\n         TM    WMJMMLW,WMJMMLWB    MAJOR WQE WITH MINORS TO FOLLOW ?\n         BNO   SIGLBAD             NOPE, ERROR\n         TM    FUN9FLG,X'80'       DO WE HAVE A MINOR WQE?\n         BO    SEDOLMIN            YES, GO PROCESS WQE'S\n         MVC   ATSSEQ#,WMJMSEQ#    SAVE CONNECT ID\n         XR    R1,R1               CLEAR WORK REG.\n         STH   R1,ATSLNCNT         CLEAR TEST LINE COUNT\n         LA    R1,1                COUNT MAJOR AS FIRST LINE\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, TRY THE MINORS NEXT TIME\n         STH   R1,ATSLNCNT         SAVE LINE COUNT\n         LA    R1,WMJMTXT+1        POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         LH    R1,WMJMTXTL         GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLMIN DS    0H                  NOW PROCESS MINOR WQE'S\n         ICM   R15,B'1111',SSWTMIN GET ADDRESS OF MINOR\n         BZ    SIGLBAD             ERROR IF NONE\n         PUSH  USING                                            RPS\n         DROP  R10                 DROP MAJOR ADDRESSABILITY    RPS\n         USING WMNM,R15            ESTABLISH MINOR ADDRESSABILTIY\n         LH    R1,ATSLNCNT         GET PREVIOUS LINE COUNT\n         SPACE 1\nSEDOLM1  DS    0H                  LOOP THROUGH THE LINES\n         TM    WMNMML1,WMNMML1C    IS THIS A MINOR WQE?\n         BNO   SIGLBAD             NO, ERROR\n         CLC   WMNMSEQ1,ATSSEQ#    SAME CONNECT ID?\n         BNE   SIGLBAD             NO, ERROR\n         LA    R1,1(,R1)           INCREMENT COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLM2             NO, TRY THE SECOND HALF\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         LA    R1,WMNMTXT1+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL1          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         SPACE 1\nSEDOLM2  DS    0H                  PROCESS SECOND HALF OF MINOR WQE\n         ICM   R5,B'1111',WMNMNX1  IS THERE A SECOND HALF?\n         BZ    SEDOLMX             NO, EXIT\n         LA    R1,1(,R1)           YES, INCREMENT COUNT\n         CR    R1,R2               IS THIS THE LINE REQUIRED?\n         BNE   SEDOLMX             NO, WAIT FOR NEXT MINOR WQE\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         LA    R1,WMNMTXT2+1       POINT TO TEXT (+1 STILL)\n         ST    R1,STRSTART         SAVE AS TEXT START\n         SR    R1,R1               CLEAR REGISTER\n         IC    R1,WMNMTL2          GET LENGTH OF TEXT\n         ST    R1,STRLEN           SAVE TEXT LENGTH\n         LA    R1,4                SET RETURN OFFSET\n         B     SEDOLINX            GO BACK TO PROCESS\n         POP   USING                                               RPS\n         SPACE 1\nSEDOLMX  DS    0H                  LINE IS NOT IN THIS MINOR WQE\n         STH   R1,ATSLNCNT         SAVE TEST LINE COUNT\n         XR    R1,R1               SET RETURN OFFSET TO ZERO\n         SPACE 1\nSEDOLINX DS    0H                  SUB ROUTINE EXIT\n         B     0(R1,R14)           RETURN TO CALLER WITH OFFSET\n         DROP  R10                 END MAJOR ADDRESSABILITY\n*        DROP  R15                 END WQE ADDRESSABILITY\n         DROP  R6                  END TSSO AOF TEST BLOCK ADDRESSABTY\n         COPY  BSCAN                                            30OCT92\n         TITLE 'DATA AREAS'\n         LTORG\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\nWTO1C    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTO1CE   EQU   *\n*\nWTL1C    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\nWTL1CE   EQU   *\n*\nPOST1C   POST  ,ASCB=0,ERRET=0,MF=L\nPOST1CE  DS    0H\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\nFUN9DATA DSECT\nWORKAREA DS    CL200            USED FOR CONVERT ROUTINES\n***********************************************************************\n* RE-ENTRANT MACRO DEFINITIONS...                                     *\n*                                                                     *\n***********************************************************************\nPOST1D   POST  ,ASCB=0,ERRET=0,MF=L\n***********************************************************************\n* VARIABLES USED TO PROCESS REQUESTS OF PART 1 OF THIS ROUTINE, THE   *\n* INTERFACE TO THE OSCMD COMMAND.                                     *\n*                                                                     *\n***********************************************************************\nMAJWQEAD DS    F                MAJOR WQE ADDRESS\nMINWQEAD DS    F                MINOR WQE ADDRESS\nMAJOREAD DS    F                ADDRESS OF AN ORE.\nSSOBADDR DS    F                ADDRESS OF THE SSOB\nSSWTADDR DS    F                ADDRESS OF THE SSWT FOR THIS SUBSYS CAL\nSSCONENT DS    F                IF SS CON ENTRY USED - THIS FIELD HAS\n*                               ADDRESS OF SSCON ENTRY FOR IT.\n*\n*\nWQEADDR  DS    A                ADDRESS OF THE WQE WE ARE TRYING\n*                               TO DEAL WITH\nWQETSADR DS    A                ADDRESS OF TIME STAMP IN THE WQE.\nCURTABAD DS    A                CURRENT TSSO/AOF TABLE ADDRESS WE ARE\n*                               DEALING WITH\nTXTMSG   DS    CL8              FIRST 8 BYTES OF WTO/WTOR\nREPLY    DC    H'109',H'0'\n         DC    CL6'REPLY '\nREPLYNUM DC    CL2' '\nREPLYCOM DC    CL1','\nREPLYMSG DC    CL100' '\nMVSCMD   DC    H'109',H'0'\nMVSCMD1  DS    CL105\nFUNC9RC  DS    H                RETURN CODE FOR FUNCTION 9.\nWTO1D    WTO   'TSS9207I                                               X\n                                                                       X\n                             ',MCSFLAG=(BRDCST,HRDCPY),MF=L\nWTL1D    WTL   'TSS9207I                                               X\n                                                                       X\n                             ',MF=L\n************************************************************\n* VARIABLES USED TO PROCESS TEST REQUESTS IN AOF TABLE.\n************************************************************\nWORD1    DS    F                IF TYPE=SUBSTR  STARTING CHARACTER\n*                               IF TYPE=WORD    WORD NUMBER\nWORD2    DS    F                LENGTH OF WORD\nWORDSEPS DS    CL4              SEPARATOR CHARACTORS FOR WORDS.\nSTRSTART DS    A                ADDRESS OF FIRST CHARACTER OF WQE\n*                               MESSAGE. THIS IS WQETXT+1 IF WTO\n*                               AND WQETXT+4 IF WTOR.\nSTRLEN   DS    A                LENGTH OF WQE MESSAGE\n************************************************************\n* VARIABLES USED TO PROCESS P DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSIGSTART DS    F                STARTING ADDRESS OF SIGNIFICANCE\nSIGCOUNT DS    F                NUMBER OF CHARACTERS\n************************************************************\n* PARSE PARAMETERS\n************************************************************\nPARSPARM DS    0H\nPARS1    DS    A\nPARS2    DS    A\nPARS3    DS    A\nPARS4    DS    A\nPARARRAY DS    CL2,20CL16  SPACE FOR COUNT AND 20 ITEMS         15OCT92\nLPARRAY  EQU   *-PARARRAY                                       15OCT92\n************************************************************\n* VARIABLES USED TO PROCESS W DIRECTIVE IN OSCMD REQUEST\n************************************************************\nSEPCHAR  DS    F           SEPARATOR CHARACTERS FOR PARSE\nWORDREQ  DS    F\nLWORDREQ DS    F\nTOKADDR  DS    F           ADDRESS OF REQUESTED TOKEN IN\n*                          PARARRAY\n************************************************************\n* FLAGS USED IN PROCESSING REQUESTS FROM SUBSYSTEM CALL 9\n************************************************************\nFUN9FLG  DS    X\n* X'80'  SSWTMIN \u00ac= 0\n* X'40'  SSWTORE \u00ac= 0\n* X'20'  OSCMDT WAS SPECIFIED\n* X'10'  BSCAN PROCESSING IS DONE\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFJSSVT\n         IEFJSCVT\n         IEFJSSOB (CM,WT),CONTIG=NO\n         TSSOCVT\n         TSSOCMND\n         TSSONDSA\n         TAOFNTRY\n         OSCMDICB\n         SSCONCBH\n         SSCONCB\n         IHAWQE\n         IHAORE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n************************************************************\n* NOTE: PREVIOUS VERSION OF TSSO HAVE BEEN WRITTEN BY:\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC., MCLEAN VA\n*        DATE WRITTEN. SEPTEMBER 2 1976.\n*        DATE UPDATED. AUGUST 7 1980.\n************************************************************\n         END  TSSOSS09\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOSS09(''TSSO 4.3 &SYSDATE &SYSTIME'')'\n PUNCH ' INCLUDE  SYSLMOD(JCECVT)'\n PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'\n PUNCH ' ENTRY    TSSOSS09'\n PUNCH ' NAME     TSSOSS09(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XXX": {"ttr": 49418, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x966_\\x00\\x966o\\x10\\x16\\x02o\\x02o\\x00\\x0b\\xd9\\xd7\\xe2@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-12-30T00:00:00", "modifydate": "1996-12-31T10:16:00", "lines": 623, "newlines": 623, "modlines": 11, "user": "RPS"}, "text": "         TITLE ' M V S   C O M M A N D   P R O C E S S O R '\nTSSOPCMD CSECT\n***********************************************************************\n* THIS IS THE TSSOPCMD SUBROUTINE. THIS SUBROUTINE WILL BE CALLED BY  *\n* SERVERS DESIRING TO ISSUE OPERATING SYSTEM COMMANDS AND RETRIEVE    *\n* RESPONSES. THE SUBROUTINE WILL RUN IN THE COMMON SYSTEM AREA,       *\n* AND UTILIZE THE SERVICES OF TSSO TO RETRIEVE THE OPERATING SYSTEM   *\n* COMMAND RESPONSE. BECAUSE OF THIS, THE SUBROUTINE CANNOT BE RUN     *\n* IN AN ENVIRONMENT THAT DOES NOT CONTAIN TSSO. SINCE THIS MODULE IS  *\n* IN FACT, A SUBROUTINE, IT DOES ISSUE ANY MESSAGES OF ITS OWN, SAVE  *\n* THOSE FORTELLINGDISASTER WITH TSSO ITSELF. IT WILL, INSTEAD, OFFER  *\n* RETURN CODES TO ITS CALLERS. THIS MODULE MUST RUN APF AUTHORIZED,   *\n* HOWEVER, IT WILL ASSUME IT IS CALLED IN THAT STATE. THIS REQUIRES   *\n* THE CALLER TO GET AUTHORIZED.                                       *\n*                                  . THE FOLLOWING ARE THE INPUT      *\n* PARAMETERS THAT THIS MODULE EXPECTS.                                *\n*                                                                     *\n*                                                                     *\n* R1 --> PARAMETER LIST                                               *\n*                                                                     *\n*  0(R1) ---> ADDRESS OF THE MVS COMMAND TO BE ISSUED THROUGH SVC 34  *\n*                                                                     *\n*  4(R1) ---> ADDRESS OF A 4 BYTES FIELD CONTAINING THE LENGTH OF     *\n*             THE ABOVE COMMAND.                                      *\n*                                                                     *\n*  8(R1) ---> ADDRESS OF A 4 BYTE FIELD CONTAINING THE MAXIMUM AMOUNT *\n*             OF TIME, IN 1/100 OF A SECOND, THAT THE CALLER  TO WAIT *\n*             FOR THE COMMAND TO TERMINATE. THE VALUE MUST BE BETWEEN *\n*             1 SECOND AND 60 SECONDS.                                *\n*                                                                     *\n* 12(R1) ---> ADDRESS OF A 4 BYTE FIELD CONTAINING THE MAXIMUM        *\n*             NUMBER OF LINES THAT THE CALLER WOULD LIKE TO GET       *\n*             BACK.                                                   *\n*                                                                     *\n* 16(R1) ---> ADDRESS OF A ONE BYTE FLAG INDICATING THE AUTHORITY     *\n*             LEVEL THAT THE COMMAND SHOULD BE INVOKED WITH. THE      *\n*             FLAG VALUES ARE:                                        *\n*                                                                     *\n*             X'80' - SYSTEM AUTHORITY                                *\n*             X'40' - I/O AUTHORITY                                   *\n*             X'20' - CONSOLE AUTHORITY                               *\n*             X'01' - CONSOLE IS CONSIDERED A PSEUDO-MASTER.          *\n*                                                                     *\n* 20(R1) ---> ADDRESS OF AN 8 BYTE FIELD CONTAINING THE USERID OF     *\n*             THE INVOKER. THIS WILL TYPICALLY BE THE TSO USERID,     *\n*             IMS LTERM                                               *\n*                                                                     *\n*                                                                     *\n* 24(R1) ---> ADDRESS OF A 40,000 BYTE BUFFER THAT TSSOPCMD IS TO     *\n*             COPY THE COMMAND RESPONSE BACK TO. THE REASON FOR       *\n*             REQUIRING THIS PARAMETER IS TO ENSURE THE 40K BUFFER    *\n*             REQUIRED IN CSA GETS FREED. A MOVE LONG INSTRUCTION     *\n*             WILL BE PERFORMED TO DO THE COPY.                       *\n*             NOTE: THE FIRST FOUR BYTES OF THIS BUFFER CONTAIN THE   *\n*                   COUNT OF MESSAGES IN THE BUFFER.                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* 28(R1) ---> ADDRESS OF A 4 BYTE FIELD THAT TSSOPCMD WILL PLACE THE  *\n*             NUMBER OF LINES RETURNED FROM THE MVS COMMAND.          *\n*                                                                     *\n*                                                                     *\n* 32(R1) ---> ADDRESS OF A 1 BYTE FIELD THAT TSSOPCMD WILL PLACE THE  *\n*             REASON CODE BEHIND SUCCESS/FAILURE.                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* METHOD OF OPERATION:                                                *\n*                                                                     *\n* 1) - VALIDATE THE PARAMETERS, AS WELL AS THE CALLING ENVIRONMENT    *\n*      AND ISSUE RETURN CODES IF NOT GOOD.                            *\n*                                                                     *\n* 2) - FIND A TSSO SUBSYSTEM CONSOLE. THIS IS DONE BY SCANNING THE    *\n*      SSCONCB CHAIN AND FINDING A FREE CONSOLE                       *\n*                                                                     *\n* 3) - GETMAIN AN OSCMD INTERFACE CONTROL BLOCK                       *\n*                                                                     *\n* 4) - PREPARE THE STIMER TO BLOW OFF IN THE SPECIFIED NUMBER OF      *\n*      SECONDS.                                                       *\n*                                                                     *\n* 5) - ISSUE SVC 34 AND WAIT.                                         *\n*                                                                     *\n* 6) - RETURN CONTROL TO CALLER AFTER FILLING IN PARAMETER LIST WITH  *\n*      OUTPUT VARIABLES.                                              *\n*                                                                     *\n*        +----------+                                                 *\n*        + CHANGES  +                                                 *\n*        +----------+                                                 *\n*  20DEC96 RPS FIXED ADDRESSABILITY ERROR WITH HLASM                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EQUATES\n         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS\n         LR    R12,R15            LOAD ENTRY POINT OF TSSOPCMD\n         USING TSSOPCMD,R12\n         B     EYE1\n         COPY  EYECATCH\nEYE1     DS    0H\n         LR    R8,R1              SAVE INPUT PARMS.\n*                                 THEN I EXPECTED.\n         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA\n         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA\n*                                  SAVE AREA\n         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS\n         LR    R13,R1             KEEP A COPY IN R13\n*\n         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...\n         LR    R11,R1\n         USING OSCMDATD,R11\n         MVC   OPESTAED(ESTAECE-ESTAEC),ESTAEC\n         GETCVT (R10)\n         USING TSSOCVT,R10\n         TM    TSSOFLG1,TSSOGONE   TSSO BLOWN AWAY ?\n         BO    RC32\n         MVC   STIMERD(STIMRPEN-STIMRPRE),STIMRPRE     COPY STIMER\n*                                                   PREPROCESSING EXIT\n         LA    R2,OSCMDATD\n         ST    R2,STIMPARM         GET ADDRESS OF DSECT AREA FOR PARMS\n         LA    R2,STIMEREX         GET ADDRESS OF STIMER EXIT\n         ST    R2,STIMREAL         AND TELL STIMER PREPROCESSOR\n         ST    R8,TSSOPPRM         REMEMBER PARM LIST ADDRESS\n         MVI   MVSCMD+4,X'40'\n         MVC   MVSCMD+5(130),MVSCMD+4\n***********************************************************************\n* STEP 1 IS TO VALIDATE THE INPUT PARAMETERS AND APF AUTHORIZATION    *\n* STATUS.                                                             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         TESTAUTH FCTN=1              ARE WE AUTHORIZED ?\n         LTR   R15,R15\n         BNZ   RC4                    NO, GIVE UP.\n*\n***********************************************************************\n* STEP 2: VALIDATE AND PROCESS MVS COMMAND                            *\n*                                                                     *\n***********************************************************************\n         L     R3,0(R8)               POINT AT MVS COMMAND\n         L     R4,4(R8)               POINT AT LENGTH\n         L     R4,0(R4)               OBTAIN LENGTH\n         STH   R4,MVSCMD              STORE LENGTH AWAY\n         MVC   MVSCMD+2(2),=H'0'\n         MVC   MVSCMD(2),=H'127'\n         CH    R4,=H'127'\n         BH    RC8                    LENGTH OUT OF RANGE\n         LTR   R4,R4\n         BNH   RC8\n         BCTR  R4,0                   FOR EXECUTE.\n         EX    R4,MOVMVSCM            MOVE THE COMMAND TO OUR STORAGE\n         B     AR2\nMOVMVSCM MVC   MVSCMD+4(0),0(R3)      ** EXECUTED **\nAR2      DS    0H\n***********************************************************************\n* STEP 3: VALIDATE AND PROCESS THE TIME PARAMETER...                  *\n*                                                                     *\n***********************************************************************\n         L     R3,8(R8)               PICK UP POINTER TO TIME PARM\n         L     R3,0(R3)               PICK UP ACTUAL WAIT TIME\n         LTR   R3,R3                  POSTIVE  ?\n         BNH   RC12                   BAD NEWS.\n         CH    R3,=H'6000'            TO HIGH ?\n         BH    RC12                   BAD NEWS...\n         ST    R3,WAITTIME            PUT AWAY.\n***********************************************************************\n* STEP 4: VALIDATE AND PROCESS THE LINES PARAMETER...                 *\n*                                                                     *\n***********************************************************************\n         L     R3,12(R8)              PICK UP POINTER TO LINES PARM\n         L     R3,0(R3)               PICK UP ACTUAL MAX LINES COUNT\n         CH    R3,=H'200'             MAXIMUM SUPPORT IS 200.\n         BH    RC16\n         LTR   R3,R3                  POSTIVE  ?\n         BNH   RC16                   BAD NEWS.\n         ST    R3,MAXLINES            PUT AWAY.\n***********************************************************************\n* STEP 5: VALIDATE AND PROCESS THE COMMAND AUTHORIZATION PARAMETERS...*\n*         HERE, WE TAKE IT ON BLIND FAITH THAT THE INVOKER IS         *\n*         AUTHORIZED TO WHATEVER AUTHORITY HE WANTS, SINCE HE WAS APF *\n*         AUTHORIZED TO BEGIN WITH.                                   *\n***********************************************************************\n         L     R3,16(R8)              PICK UP POINTER TO AUTH  PARM\n         TM    0(R3),B'00001110'      CHECK THAT ALL BITS IN TAIL END\n*                                     OF BYTE ARE OFF...\n         BNZ   RC20                   INVALID AUTHORIZATION PARAMETER\n         MVC   AUTHBYTE(1),0(R3)      COPY IT.\n*\n***********************************************************************\n* NEXT, WE MOVE THE CALLER SUPPLIED USERID INTO LOCAL STORAGE.        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         L     R3,20(R8)              GET POINTER TO USERID\n         MVC   USERID(8),0(R3)\n***********************************************************************\n* THE NEXT STEP IS TO FIND AN AVAILABLE TSSO SUBSYSTEM CONSOLE. TSSO  *\n* SUBSYSTEM CONSOLES ARE CHAINED OFF THE SSCONCBH CONTROL BLOCK IN THE*\n* TSSO CVT.                                                           *\n***********************************************************************\n         L     R4,SSCONSAD            GET THE SSCON CB HEADER\n         USING SSCONCBH,R4            ADDRESS IT\n         LA    R3,SSCONFIR            GET THE FIRST CONSOLE CONTROL BLK\n         USING SSCONCB,R3\n         L     R5,SSCONAMT            HOW MANY SUBSYSTEM CONSOLES ARE\n*                                     THERE.\n         LTR   R5,R5                  ARE THERE ANY ?\n         BZ    RC24                   NOPE, NO SS CONSOLES\nCHEKCONS DS    0H\n         TM    SSCONFLG,X'80'         IS THIS SS CONSOLE IN USE ?\n         BO    TRYNXTSS               YUP, TRY THE NEXT SS CONSOLE\n* THIS SUBSYSTEM CONSOLE IS NOT IN USE... CHECK OUT IF IT IS AVAILABLE\n* FOR AVERAGE USERS...\n         TM    SSCONFLG,X'40'         IS THIS SS CONSOLE DEDICATED\n*                                     TO TSSO ?\n         BNO   ALLOCONS               NO, THIS CONSOLE IS FREE TO ALLOC\n***********************************************************************\n* HERE, WE HAVE OURSELVES A SUBSYSTEM CONSOLE THAT WE CAN USE ONLY FOR*\n* TSSO. LETS CHECK IF WE ARE INDEED TSSO                              *\n***********************************************************************\n         L     R4,X'224'              GET ASCB ADDRESS\n         C     R4,TSSOASCB            ARE WE TSSO ?\n         BE    ALLOCONS               YES.. OK TO ALLOCATE CONSOLE\n         B     TRYNXTSS\nTRYNXTSS DS    0H\n***********************************************************************\n* HERE, WE HAVE FOUND THE CONSOLE TO BE BUSY... WE WILL GO AND TRY\n* THE NEXT SUBSYSTEM CONSOLE.\n***********************************************************************\n         LA    R3,SSCONCBL(R3)        TRY NEXT ENTRY\n         LTR   R3,R3                  IS THERE A NEXT ENTRY ?\n         BZ    RC24                   NO, BAD NEWS- ALL CONSOLES BUSY\n         BCT   R5,CHEKCONS\n         B     RC24\nALLOCONS DS    0H\n***********************************************************************\n* WE COME HERE WHEN WE HAVE DETERMINED THAT A SUBSYSTEM CONSOLE IS    *\n* AVAILABLE.                                                          *\n***********************************************************************\n         MODESET KEY=ZERO             SINCE THE SSCONCB IS FETCH PROT.\n         ST    R3,SSCONENT            SUBSYSTEM CONSOLE ENTRY WE ARE\n*                                     USING\n         OI    SSCONFLG,X'80'         MARK THE CONSOLE AS ALLOCATED\n         MVC   SSCONUID(8),USERID\n         DROP  R4\n***********************************************************************\n* NEXT, WE ALLOCATE THE OSCMD INTERFACE CONTROL BLOCK. THIS BLOCK IS  *\n* THE PRIMARY INTERFACE BETWEEN TSSOPCMD AND TSSOSS09.                *\n***********************************************************************\n         L     R2,=F'40000'\n         GETMAIN RC,LV=(R2),SP=241\n         LTR   R15,R15\n         BNZ   RC28                   STORAGE NOT AVAILABLE\n         ST    R1,ICBADDR             REMEMBER ADDRESS OF ICB\n         ST    R1,SSCONICB\n***********************************************************************\n* BECAUSE AN ADDRESS SPACE MAY BE CANCELLED WHILE WAITING FOR TSSO    *\n* SERVICES, WE MUST PROVIDE AN ESTAE ROUTINE TO RECOVER...            *\n***********************************************************************\n         L     R6,=V(TSSOPREC)\n         LTR   R6,R6              SAVE ENTRY POINT\n         BZ    BADESTAE\n*\n         ESTAE (R6),TERM=YES,PARAM=(R3),MF=(E,OPESTAED)\n*\n         LTR   R15,R15\n         BNZ   BADESTAE\n         B     OKESTAE\nBADESTAE DS    0H\n         B     RC36\nOKESTAE  DS    0H\n***********************************************************************\n* THE SSCONCB HAS BEEN PREPARED FOR MESSAGE INTERCEPTION. NOW, ME MUST*\n* INITIALIZE THE OSCMD INTERFACE CONTROL BLOCK.                       *\n*                                                                     *\n***********************************************************************\n         L     R7,SSCONICB            ADDRESS THE OSCMD INTERFACE\n*                                     CONTROL BLOCK\n         USING OSCMDICB,R7\n         XC    OSCMDECB(4),OSCMDECB\n         XC    OSCMDFLG(4),OSCMDFLG\n*\n         LA    R8,OSCMDBUF            GET ADDRESS OF OSCMDBUF\n         ST    R8,OSCMDNEX            THIS IS THE NEXT PLACE TO PUT\n*                                     A TRAPPED MVS MESSAGE\n         L     R8,X'224'              GET ASCB OF THIS ADDRESS SPACE\n         ST    R8,OSCMDACB            AND PUT IT AWAY...\n         XC    OSCMDCNT(4),OSCMDCNT   ZERO OUT THE COMMAND COUNT\n*\n         LA    R8,OSCMDBUF\n         LA    R1,199\nBLNKLOOP DS    0H                 BLANK OUT THE\n         MVI   0(R8),C' '         BUFFERS IN THE OSCMD\n         MVC   1(149,R8),0(R8)    INTERFACE CONTROL\n         LA    R8,150(R8)             BLOCK\n         BCT   R1,BLNKLOOP\n*\n         L     R8,MAXLINES            GET MAXIMUM NUMBER OF LINES\n         ST    R8,OSCMDMAX\n*\n***********************************************************************\n* THE NEXT STEP IS TO COPY THE AUTHORIZATION BITS FROM THE INVOKER TO *\n* THE TSSO SUBSYSTEM CONSOLE.                                         *\n***********************************************************************\n         L     R8,SSCONAUT            GET ADDRESS OF UCMAUTH\n         MVC   0(1,R8),AUTHBYTE       COPY THE AUTHORIZTION BYTE.\n         TM    AUTHBYTE,X'01'         PSEUDO MASTER AUTHORITY DESIRED?\n         BNO   NOPSEUDO               NO - SKIP IT\n         OI    2(R8),X'08'            SET PSEUDO MASTER FLAG.\n         B     PSPSEUDO               GO DO OTHER STUFF\nNOPSEUDO DS    0H\n         NI    2(R8),255-X'08'        RESET MASTER AUTH BIT\n         B     PSPSEUDO               AND TO DO OTHER STUFF\nPSPSEUDO DS    0H\n***********************************************************************\n* ALL IS IN READINESS. NOW WE MUST ISSUE THE STIMER, AND GO TO SLEEP, *\n* AWAITING THE MVS RESPONSE TO OUR COMMANDS.                          *\n***********************************************************************\n         STIMER REAL,STIMERD,BINTVL=WAITTIME\n***********************************************************************\n* WE WILL AWAKEN UPON ONE OF TWO EVENTS. IF THE STIMER EXPIRES, THE   *\n* STIMEREX EXIT IS DRIVEN, AND THIS WILL POST THE ECB. WE WILL THEN   *\n* PROCESS THE BUFFER(S) CREATED BY TSSOSS09. IF THE ECB IS POSTED     *\n* DIRECTLY BY TSSOSS09, WE WILL WAKE UP, AND IMMEDIATELY CANCEL THE   *\n* STIMER. EITHER WAY, WE WILL PROCESS THE RESULTS OF THE BUFFER. NOTE *\n* THAT WE EXPECT TO BE POSTED FROM TSSOSS09 IN THE CASE OF A MULTI    *\n* LINE DISPLAY COMMAND, AND FROM THE STIMER EXIT IN THE CASE OF A JES2*\n* OR OTHER SUBSYSTEM COMMAND.                                         *\n***********************************************************************\n         XC    OSCMDECB(4),OSCMDECB   NULL OUT OSCMDECB\n         XC    STIMRECB(4),STIMRECB   NULL OUT STIMRECB\n         LA    R2,OSCMDECB            GET ADDRESS OF SS09ECB\n         ST    R2,LISTECBS            STORE IN LIST\n         LA    R2,STIMRECB            GET ADDRESS OF OTHER ECB\n         ST    R2,LISTECBS+4           STORE IN LIST\n         OI    LISTECBS+4,X'80'       SET HIGH ORDER BYTE\n*\n         MODESET MODE=SUP             GET POWER\n         LA    R1,MVSCMD              POINT TO THE MVS COMMAND\n         L     R3,SSCONENT            GET SS CON ENTRY\n         USING SSCONCB,R3\n         L     R0,SSCONNUM            GET THE SUBSYSTEM CONSOLE\n         OI    SSCONFLG,X'20'         ** START INTERCEPTING COMMANDS **\n*                                     INTERFACE CONTROL BLOCK.\n         SVC   34                     ** BANG !! **\n*\n         WAIT  ECBLIST=LISTECBS\n*\n         NI    SSCONFLG,255-X'20'     TURN OFF MESSAGE INTERCEPT FLAG\n         DROP  R3\n*\n         MODESET MODE=PROB\n*\n***********************************************************************\n* WE HAVE BEEN POSTED, EITHER FROM COMMTASK VIA XMEM-POST OR THROUGH  *\n* OUR STIMER EXIT ROUTINE. IF POSTED THROUGH OUR STIMER EXIT, WE ARE  *\n* OK, IF POSTED THROUGH THE XMEM-POST, WE SHOULD CANCEL THE STIMER    *\n***********************************************************************\n         TM    OSCMDECB,X'40'              POST BIT ON ?\n         BNO   PSTTSTIM\n         TTIMER CANCEL\n***********************************************************************\n* FOLLOWING THE TTIMER, THERE IS A CHANCE THAT THE TIMER EXIT WAS     *\n* SCHEDULED (IF TIME REMAINING IS ZERO) BUT NOT YET CALLED. TO HANDLE *\n* THIS RARE OCCURANCE, WE WILL CHECK..                                *\n***********************************************************************\n         LTR   R0,R0          ANY TIME INTERVAL REMAINING ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         TM    STIMRECB,X'40' WERE WE ALREADY POSTED ?\n         BNZ   NOWAIT2        NO, NO NEED TO BE CONCERNED...\n         WAIT  ECB=STIMRECB   WE HAVE TO BE CONCERNED... WAIT TILL\n*                             STIMER EXIT POPS BEFORE CONTINUING.\nNOWAIT2  DS    0H\n*\nPSTTSTIM DS    0H\n***********************************************************************\n* NOW, WE GO ABOUT THE BUSINESS OF EVALUATING THE RESULTS, AND PLACING*\n* ANSWERS IN THE INVOKERS PARAMETER LIST.                             *\n*\n* NOTE THAT THE OSCMDICB IN STILL ADDRESSED BY REGISTER 7             *\n* WE WILL TAKE THE FOLLOWING STEPS...                                 *\n*                                                                     *\n* 1) COPY THE GETMAINED AREA INTO THE CALLER PROVIDED AREA            *\n*                                                                     *\n* 2) DE-ALLOCATE THE SUBSYSTEM CONSOLE                                *\n*                                                                     *\n* 3) FREE THE ALLOCATED CSA                                           *\n*                                                                     *\n* 4) RETURN                                                           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nCOPYBUF  DS    0H\n         L     R8,TSSOPPRM\n         L     R2,24(R8)              GET ADDRESS OF 40K BUFFER IN\n*                                     CALLERS REGION.\n         MVC   0(4,R2),OSCMDCNT       COPY THE COUNT FIELD\n         LA    R2,4(R2)\n         L     R3,=F'30000'           LENGTH\n         LA    R4,OSCMDBUF            ADDRESS OF OSCMD BUFFERS\n         LR    R5,R3                  SAME LENGTH\n         MVCL  R2,R4                  ** MOVE IT **\n*\n         FREEMAIN R,LV=40000,A=(R7),SP=241   *FREE CSA *\n*\n***********************************************************************\n* NOW - TO DEALLOCATE THE SUBSYSTEM CONSOLE.                          *\n*                                                                     *\n***********************************************************************\n         L     R3,SSCONENT\n         USING SSCONCB,R3\n         NI    SSCONFLG,255-X'80'    TURN OFF \"IN USE\" FLAG\n         XC    SSCONICB(4),SSCONICB  ZERO OUT THE ICB POINTER\n         MVC   SSCONUID(8),=CL8' '   BLANK OUT THE USER ID\n         DROP  R3\n*\n         ESTAE 0\n*\n         MODESET KEY=NZERO\n         B     RC0\nRC0      DS    0H\n         MVC   RETCODE(2),=H'0'      RETURN CODE 0\n         B     ENDPROG\n*\nRC4      DS    0H\n         MVC   RETCODE(2),=H'4'      RETURN CODE 4\n         B     ENDPROG               NOT AUTHORIZED\n*\nRC8      DS    0H\n         MVC   RETCODE(2),=H'8'      RETURN CODE 8\n         B     ENDPROG               MVS COMMAND IS INVALID\n*\nRC12     DS    0H\n         MVC   RETCODE(2),=H'12'     RETURN CODE 12\n         B     ENDPROG               TIME PARM INVALID\n*\nRC16     DS    0H\n         MVC   RETCODE(2),=H'16'     RETURN CODE 16\n         B     ENDPROG               LINES PARM INVALID\n*\nRC20     DS    0H\n         MVC   RETCODE(2),=H'20'     RETURN CODE 20\n         B     ENDPROG               AUTHORIZATION PARM INVALID\n*\nRC24     DS    0H\n         MVC   RETCODE(2),=H'24'     RETURN CODE 24\n         B     ENDPROG               ALL SUBSYSTEM CONSOLES BUSY\n*\nRC28     DS    0H\n         MVC   RETCODE(2),=H'28'     RETURN CODE 28\n         B     ENDPROG               STORAGE NOT AVAILABLE\n*\nRC32     DS    0H\n         MVC   RETCODE(2),=H'32'     RETURN CODE 32\n         B     ENDPROG               TSSO IS BLOWN AWAY\n*\nRC36     DS    0H\n         MVC   RETCODE(2),=H'36'     RETURN CODE 36\n         B     ENDPROG\n*\nENDPROG  DS    0H\n         LH    R8,RETCODE\n         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE\n         LR    R1,R13              GET ADDRESS OF CORE IN R1\n         L     R13,4(R13)          RESTORE R13\n         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE\n         B     ENDPROG1\nENDPROG1 DS    0H\n         L     R14,12(R13)         RELOAD RETURN POINT\n         LR    R15,R8              PICK UP RETURN CODE.\n         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS\n         BR    R14\nSTIMEREX DS    0H\n***********************************************************************\n* THIS IS THE STIMER EXIT ROUTINE. IT IS BRANCHED TO BY THE STIMER    *\n* PREPROCESSING ROUTINE THAT IS SET UP TO PASS PARAMETERS. THE        *\n* REGISTERS ON ENTRY TO THIS ROUTINE ARE:                             *\n*                                                                     *\n* R1: ADDRESS OF THE OSCMD DSECT.   R15: ADDRESS OF STIMEREX          *\n* R13: SAVEAREA                                                       *\n* R14: PLACE TO RETURN TO.                                            *\n*\n* SINCE THIS CODE MUST RESTORE ALL REGISTERS TO THE OPERATING SYSTEM,\n* IT WILL LOCATE THE \"REAL\" REGS 1 AND 15 THROUGH THE\n***********************************************************************\n         PUSH  USING\n         STM   R14,R12,12(R13)     SAVE OS REGS FOR STIMER\n         LR    R12,R15             GET GOOD BASE\n         USING STIMEREX,R12        TELL GOOD ASSEMBLER\n         LR    R11,R1              GET ADDRESS OF OSCMD DSECT AREA\n         USING OSCMDATD,R11        TELL MEDIOCRE ASSEMBLER\n***********************************************************************\n* THE WHOLE IDEA OF THIS CODE IS TO POST THE ECB ASSOCIATED WITH THE  *\n* STIMER. THE ECB IS NOW CONVIENTLY ADDRESSABLE.                      *\n***********************************************************************\n         LA    R2,STIMRECB         GET ADDRESS OF STIMER ECB\n         POST  (R2),0              POST ECB WITH COMP CODE ZERO\n***********************************************************************\n* NOW WE WILL TERMINATE STIMER EXIT PROCESSING BY RESTORING REGISTERS *\n* INCLUDING R1 AND R15 PREVIOUSLY DESTROYED. NOTE THAT THESE WERE     *\n* SAVED IN THE DSECT AREA, WHICH WE STILL HAVE ADDRESSABILITY TO.     *\n***********************************************************************\n         L     R15,R15SAVED        RESTORE R15\n         L     R1,R1SAVED          RESTORE R1\n         L     R14,12(R13)         RESTORE RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE EVERYTHING ELSE.\n         BR    R14\n*\n************************************************************\n*                                                          *\n*        CONSTANTS AND WORKAREAS                           *\n*                                                          *\n************************************************************\n***********************************************************************\n* ALTHOUGH THIS LOOKS LIKE REAL CODE, IT'S ACTUALLY A MECHANISM USED  *\n* TO PASS A PARAMETER TO A STIMER EXIT ROUTINE. WE WILL PREPORCESS THE*\n* ROUTINE WITH THIS ONE, WHICH IS COPIED TO THE DSECT AREA.           *\n***********************************************************************\nSTIMRPRE DS    0D\n*        PUSH  USING                                       RPS\n*        DROP  R15                                         RPS\n*        USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,20(R15)  +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,24(R15)   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVE  DS    A            +20: ROOM FOR R15\nR1SAVE   DS    A            +24: ROOM FOR R1\nSTMRADDR DC    A(STIMEREX)  +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nPARMADDR DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMRPEN DS    0H\n*        POP   USING\n*\n*\nESTAEC   ESTAE 0,MF=L\nESTAECE  EQU   *\n*\n*\n         DS    0D\nSTIMERD  CSECT\n*        USING *,R15            ON ENTRY, R15 POINTS TO STIMER EXIT.\n         ST    R15,R15SAVED +0: STORE REGISTER 15 IN DSECT AREA\n         ST    R1,R1SAVED   +4: STORE REGISTER 1  IN DSECT AREA\n         L     R1,PARMADDR  +8: LOAD PARAMETER R1 FROM DSECT AREA\n         L     R15,STMRADDR +12: LOAD REGISTER 15 WITH \"REAL\" STIMER\n*                                EXIT ROUTINE\n         BR    R15          +16: BRANCH TO REAL STIMER EXIT ROUTINE\nR15SAVED DS    A            +20: ROOM FOR R15\nR1SAVED  DS    A            +24: ROOM FOR R1\nSTIMREAL DS    A            +28: ADDRESS OF REAL STIMER EXIT ROUTINE\nSTIMPARM DS    F            +32: TO BE FILLED IN BY PROGRAM.\nSTIMERDE DS    0H\n*\n***********************************************************************\n* THE FOLLOWING SECTION OUR VARIABLES THAT TSSOPCMD NEEDS, PRIMARILY  *\n* TO ACCESS THE CALLERS PARAMETER LIST.                               *\n*                                                                     *\n***********************************************************************\nMVSCMD   DS    0D\n         DC    H'0',H'0'      LENGTH,GARBAGE\n         DC    CL255' '       ACTUAL COMMAND\n*\nTSSOPPRM DS    F              ADDRESS OF THE PARAMETER LIST\n*\nSSCONENT DS    F              ADDRESS OF THE SSCONCB FOR THIS RUN OF\n*                             TSSOPCMD\nWAITTIME DS    F              MAXIMUM WAIT TIME FOR THE MVS COMMAND\n*\nMAXLINES DS    F              MAXIMUM NUMBER OF LINES TO GET BACK FOR\n*                             OUTPUT.\nAUTHBYTE DS    H              AUTHORIZATION FOR THE MVS COMMAND TO BE\n*                             ISSUED.\n*\nUSERID   DS    CL8            USER IDENTIFER (SUPPLIED BY CALLER OF\n*                             TSSOPCMD.\n*\nICBADDR  DS    F              ADDRESS OF ICB.\nRETCODE  DS    H              RETURN CODE TO GIVE TO CALLER\n***********************************************************************\n* THE FOLLOWING SECTION DENOTES THE ECB LIST THAT TSSOPCMD WILL WAIT  *\n* ON                                                                  *\n***********************************************************************\nLISTECBS DS    0F\n         DC    A(0)            ONE FOR THE OSCMDECB\n         DC    X'80'\n         DC    A(0)\n*\nSS09ECB  DS    F\nSTIMRECB DS    F\n*\nOPESTAED ESTAE 0,MF=L\nOSCMDATD DSECT\n***********************************************************************\n* WORK AREA FOR TSSOPCMD.                                             *\n***********************************************************************\nOSWKAREA DS    CL200\n\n         SSCONCBH\n         SSCONCB\n         TSSOCVT\n         COPY  TSSODATD\n         OSCMDICB\n         CVT   DSECT=YES\n         IEFJSCVT\n         IEFJESCT\nUCM      DSECT\n         IEECUCM\n         END   TSSOPCMD\n PUNCH ' SETCODE  AC(1)'\n PUNCH ' IDENTIFY TSSOPCMD(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '\n PUNCH ' INCLUDE  SYSLMOD(TSSOPREC)'\n PUNCH ' ENTRY    TSSOPCMD'\n PUNCH ' NAME     TSSOPCMD(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT404/FILE404.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT404", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}